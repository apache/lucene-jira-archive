Index: src/test/org/apache/lucene/util/TestBitVector.java
===================================================================
--- src/test/org/apache/lucene/util/TestBitVector.java	(revision 736191)
+++ src/test/org/apache/lucene/util/TestBitVector.java	(working copy)
@@ -161,6 +161,27 @@
     }
 
     /**
+     * Test nextSetBit() with various bit-twiddling edge cases.
+     * @throws Exception
+     */
+    public void testNextSetBit() throws Exception {
+      for (int i = 24; i <= 33; i++) {
+        BitVector bitVec = new BitVector(64);
+        bitVec.set(i);
+        assertEquals("nextSetBit for 0 is " + i, bitVec.nextSetBit(0), i);
+        assertEquals("nextSetBit for 1 is " + i, bitVec.nextSetBit(1), i);
+        for (int probe = 15; probe <= i; probe++) {
+          assertEquals("nextSetBit for " + probe + " is " + i,
+            bitVec.nextSetBit(probe), i);
+        }
+        for (int probe = i + 1; probe <= i + 9; probe++) {
+          assertEquals("no nextSetBit for " + probe + " when max is " + i, 
+            bitVec.nextSetBit(probe), -1);
+        }
+      }
+    }
+    
+    /**
      * Test r/w when size/count cause switching between bit-set and d-gaps file formats.  
      * @throws Exception
      */
Index: src/java/org/apache/lucene/index/SegmentTermDocs.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentTermDocs.java	(revision 736191)
+++ src/java/org/apache/lucene/index/SegmentTermDocs.java	(working copy)
@@ -32,6 +32,7 @@
 
   private int skipInterval;
   private int maxSkipLevels;
+  private int nextDeletion;
   private DefaultSkipListReader skipListReader;
   
   private long freqBasePointer;
@@ -47,6 +48,7 @@
     this.parent = parent;
     this.freqStream = (IndexInput) parent.freqStream.clone();
     this.deletedDocs = parent.deletedDocs;
+    this.nextDeletion = this.deletedDocs == null ? Integer.MAX_VALUE : -1;
     this.skipInterval = parent.tis.getSkipInterval();
     this.maxSkipLevels = parent.tis.getMaxSkipLevels();
   }
@@ -75,6 +77,7 @@
 
   void seek(TermInfo ti, Term term) throws IOException {
     count = 0;
+    nextDeletion = deletedDocs == null ? Integer.MAX_VALUE : -1;
     FieldInfo fi = parent.fieldInfos.fieldInfo(term.field);
     currentFieldOmitTf = (fi != null) ? fi.omitTf : false;
     currentFieldStoresPayloads = (fi != null) ? fi.storePayloads : false;
@@ -122,9 +125,20 @@
       
       count++;
 
-      if (deletedDocs == null || !deletedDocs.get(doc))
-        break;
-      skippingDoc();
+      if (doc >= nextDeletion) {
+        if (doc > nextDeletion) {
+          nextDeletion = deletedDocs.nextSetBit(doc);
+          if (nextDeletion == -1) {
+            nextDeletion = Integer.MAX_VALUE;
+          }
+        }
+        if (doc == nextDeletion) {
+          skippingDoc();
+          continue;
+        }
+      }
+
+      break;
     }
     return true;
   }
@@ -147,12 +161,23 @@
           freq = freqStream.readVInt();     // else read freq
         count++;
 
-        if (deletedDocs == null || !deletedDocs.get(doc)) {
-          docs[i] = doc;
-          freqs[i] = freq;
-          ++i;
+        if (doc >= nextDeletion) {
+          if (doc > nextDeletion) {
+            nextDeletion = deletedDocs.nextSetBit(doc);
+            if (nextDeletion == -1) {
+              nextDeletion = Integer.MAX_VALUE;
+            }   
+          }
+          if (doc == nextDeletion) {
+            continue;
+          }
         }
+
+        docs[i] = doc;
+        freqs[i] = freq;
+        ++i;
       }
+
       return i;
     }
   }
@@ -164,13 +189,23 @@
       doc += freqStream.readVInt();       
       count++;
 
-      if (deletedDocs == null || !deletedDocs.get(doc)) {
-        docs[i] = doc;
-        // Hardware freq to 1 when term freqs were not
-        // stored in the index
-        freqs[i] = 1;
-        ++i;
+      if (doc >= nextDeletion) {
+        if (doc > nextDeletion) {
+          nextDeletion = deletedDocs.nextSetBit(doc);
+          if (nextDeletion == -1) {
+            nextDeletion = Integer.MAX_VALUE;
+          }
+        }
+        if (doc == nextDeletion) {
+          continue;
+        }
       }
+
+      docs[i] = doc;
+      // Hardwire freq to 1 when term freqs were not
+      // stored in the index
+      freqs[i] = 1;
+      ++i;
     }
     return i;
   }
Index: src/java/org/apache/lucene/util/BitVector.java
===================================================================
--- src/java/org/apache/lucene/util/BitVector.java	(revision 736191)
+++ src/java/org/apache/lucene/util/BitVector.java	(working copy)
@@ -133,7 +133,29 @@
     4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
   };
 
+  /** Returns the index of the first bit that is set to true that occurs on or
+   * after the specified starting index.
+   */
+  public final int nextSetBit(int bit) {
+    final int max = bits.length;
+    for (int pos = bit >>> 3; pos < max; pos++) {
+      if (bits[pos] != 0) {
+        // There's a non-zero bit in this byte. 
+        final int base = pos * 8;
+        for (int i = 0; i < 8; i++) {
+          final int candidate = base + i;
+          if (candidate < size && candidate >= bit) {
+            if (get(candidate)) {
+              return candidate;
+            }
+          }
+        }
+      }
+    }
 
+    return -1;
+  }
+
   /** Writes this vector to the file <code>name</code> in Directory
     <code>d</code>, in a format that can be read by the constructor {@link
     #BitVector(Directory, String)}.  */
