Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.java	(revision 1684346)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.java	(working copy)
@@ -120,8 +120,12 @@
       final SidedPlane candidate4 = SidedPlane.constructNormalizedThreePointSidedPlane(currentSegment.start, prevSegment.LRHC, prevSegment.URHC, currentSegment.ULHC);
 
       if (candidate1 == null && candidate2 == null && candidate3 == null && candidate4 == null) {
-        // The planes are identical.  We don't need a circle at all.  Special constructor...
-        endPoints.add(new SegmentEndpoint(currentSegment.start));
+        // The planes are identical.  We wouldn't need a circle at all except for the possibility of
+        // backing up, which is hard to detect here.
+        final SegmentEndpoint midEndpoint = new SegmentEndpoint(currentSegment.start, 
+          prevSegment.endCutoffPlane, currentSegment.startCutoffPlane, currentSegment.ULHC, currentSegment.LLHC);
+        //don't need a circle at all.  Special constructor...
+        endPoints.add(midEndpoint);
       } else {
         endPoints.add(new SegmentEndpoint(currentSegment.start,
           prevSegment.endCutoffPlane, currentSegment.startCutoffPlane,
@@ -414,6 +418,7 @@
    * Note well: This is not necessarily a circle.  There are four cases:
    * (1) The path consists of a single endpoint.  In this case, we build a simple circle with the proper cutoff offset.
    * (2) This is the end of a path.  The circle plane must be constructed to go through two supplied points and be perpendicular to a connecting plane.
+   * (2.5) Intersection, but the path on both sides is linear.  We generate a circle, but we use the cutoff planes to limit its influence in the straight line case.
    * (3) This is an intersection in a path.  We are supplied FOUR planes.  If there are intersections within bounds for both upper and lower, then
    *    we generate no circle at all.  If there is one intersection only, then we generate a plane that includes that intersection, as well as the remaining
    *    cutoff plane/edge plane points.
@@ -458,6 +463,18 @@
       // To construct the plane, we now just need D, which is simply the negative of the evaluation of the circle normal vector at one of the points.
       this.circlePlane = SidedPlane.constructNormalizedPerpendicularSidedPlane(point, cutoffPlane, topEdgePoint, bottomEdgePoint);
     }
+
+    /** Constructor for case (2.5).
+     * Generate an endpoint, given two cutoff planes plus upper and lower edge points.
+     */
+    public SegmentEndpoint(final GeoPoint point,
+      final SidedPlane cutoffPlane1, final SidedPlane cutoffPlane2, final GeoPoint topEdgePoint, final GeoPoint bottomEdgePoint) {
+      this.point = point;
+      this.cutoffPlanes = new Membership[]{new SidedPlane(cutoffPlane1), new SidedPlane(cutoffPlane2)};
+      this.notablePoints = new GeoPoint[]{topEdgePoint, bottomEdgePoint};
+      // To construct the plane, we now just need D, which is simply the negative of the evaluation of the circle normal vector at one of the points.
+      this.circlePlane = SidedPlane.constructNormalizedPerpendicularSidedPlane(point, cutoffPlane1, topEdgePoint, bottomEdgePoint);
+    }
     
     /** Constructor for case (3).
      * Generate an endpoint for an intersection, given four points.
Index: lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java	(revision 1684346)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java	(working copy)
@@ -93,6 +93,44 @@
   }
 
   @Test
+  public void testFailure2() throws IOException {
+    /*
+   [junit4]   2> NOTE: reproduce with: ant test  -Dtestcase=Geo3dRptTest -Dtests.method=testOperations -Dtests.seed=ADFCC7193C72FA89 -Dtests.multiplier=3 -Dtests.slow=true -Dtests.locale=nl_BE -Dtests.timezone=Africa/Tripoli -Dtests.asserts=true -Dtests.file.encoding=UTF-8
+   [junit4] FAILURE 0.10s | Geo3dRptTest.testOperations {#5 seed=[ADFCC7193C72FA89:9BDCDB8859624E4]} <<<
+   [junit4]    > Throwable #1: java.lang.AssertionError: [Intersects] qIdx:34 
+    Shouldn't match I#1:
+    Rect(minX=131.0,maxX=143.0,minY=39.0,maxY=54.0) Q:
+    Geo3dShape{planetmodel=PlanetModel.SPHERE, shape=
+    GeoPath: {planetmodel=PlanetModel.SPHERE, width=0.5061454830783556(29.0), points={
+    [[X=0.5155270860898133, Y=-0.25143936017440033, Z=0.8191520442889918],
+    [X=-6.047846824324981E-17, Y=9.57884834439237E-18, Z=-1.0],
+    [X=-0.5677569555011356, Y=0.1521300177236823, Z=0.8090169943749475],
+    [X=5.716531405282095E-17, Y=2.1943708116382607E-17, Z=-1.0]]}}}
+   [junit4]    > 	at __randomizedtesting.SeedInfo.seed([ADFCC7193C72FA89:9BDCDB8859624E4]:0)
+   [junit4]    > 	at org.apache.lucene.spatial.prefix.RandomSpatialOpStrategyTestCase.fail(RandomSpatialOpStrategyTestCase.java:127)
+   [junit4]    > 	at org.apache.lucene.spatial.prefix.RandomSpatialOpStrategyTestCase.testOperation(RandomSpatialOpStrategyTestCase.java:116)
+   [junit4]    > 	at org.apache.lucene.spatial.prefix.RandomSpatialOpStrategyTestCase.testOperationRandomShapes(RandomSpatialOpStrategyTestCase.java:56)
+   [junit4]    > 	at org.apache.lucene.spatial.spatial4j.Geo3dRptTest.testOperations(Geo3dRptTest.java:100)
+    */
+    setupStrategy();
+
+    final List<GeoPoint> points = new ArrayList<GeoPoint>();
+    points.add(new GeoPoint(PlanetModel.SPHERE, 18 * DEGREES_TO_RADIANS, -27 * DEGREES_TO_RADIANS));
+    points.add(new GeoPoint(PlanetModel.SPHERE, -57 * DEGREES_TO_RADIANS, 146 * DEGREES_TO_RADIANS));
+    points.add(new GeoPoint(PlanetModel.SPHERE, 14 * DEGREES_TO_RADIANS, -180 * DEGREES_TO_RADIANS));
+    points.add(new GeoPoint(PlanetModel.SPHERE, -15 * DEGREES_TO_RADIANS, 153 * DEGREES_TO_RADIANS));
+    final GeoPath path = new GeoPath(PlanetModel.SPHERE, 29 * DEGREES_TO_RADIANS);
+    path.addPoint(55.0 * DEGREES_TO_RADIANS, -26.0 * DEGREES_TO_RADIANS);
+    path.addPoint(-90.0 * DEGREES_TO_RADIANS, 0.0);
+    path.addPoint(54.0 * DEGREES_TO_RADIANS, 165.0 * DEGREES_TO_RADIANS);
+    path.addPoint(-90.0 * DEGREES_TO_RADIANS, 0.0);
+    path.done();
+    final Shape shape = new Geo3dShape(path,ctx);
+    final Rectangle rect = ctx.makeRectangle(131, 143, 39, 54);
+    testOperation(rect,SpatialOperation.Intersects,shape,true);
+  }
+
+  @Test
   @Repeat(iterations = 10)
   public void testOperations() throws IOException {
     setupStrategy();
