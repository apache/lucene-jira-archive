diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index b5335c8..140b25c 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -56,6 +56,10 @@ API Changes
 * LUCENE-8388: Unused PostingsEnum#attributes() method has been removed 
   (Alan Woodward)
 
+* LUCENE-8405: TopDocs.maxScore is removed. IndexSearcher and TopFieldCollector
+  no longer have an option to compute the maximum score when sorting by field.
+  (Adrien Grand)
+
 Changes in Runtime Behavior
 
 * LUCENE-8333: Switch MoreLikeThis.setMaxDocFreqPct to use maxDoc instead of
diff --git a/lucene/MIGRATE.txt b/lucene/MIGRATE.txt
index cc356eb..8467d72 100644
--- a/lucene/MIGRATE.txt
+++ b/lucene/MIGRATE.txt
@@ -62,3 +62,17 @@ to the constructor
 
 English stop words are now defined in EnglishAnalyzer#ENGLISH_STOP_WORD_SET in the
 analysis-common module
+
+## TopDocs.maxScore removed ##
+
+TopDocs.maxScore is removed. IndexSearcher and TopFieldCollector no longer have
+an option to compute the maximum score when sorting by field. If you need to
+know the maximum score for a query, the recommended approach is to run a
+separate query:
+
+  TopDocs topHits = searcher.search(query, 1);
+  float maxScore = topHits.scoreDocs.length == 0 ? Float.NaN : topHits.scoreDocs[0].score;
+
+Thanks to other optimizations that were added to Lucene 8, this query will be
+able to efficiently select the top-scoring document without having to visit
+all matches.
diff --git a/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java b/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java
index a3b90f5..f587357 100644
--- a/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java
+++ b/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java
@@ -113,7 +113,6 @@ public abstract class ReadTask extends PerfTask {
             // pulling the Weight ourselves:
             TopFieldCollector collector = TopFieldCollector.create(sort, numHits,
                                                                    true, withScore(),
-                                                                   withMaxScore(),
                                                                    withTotalHits());
             searcher.search(q, collector);
             hits = collector.topDocs();
@@ -215,12 +214,6 @@ public abstract class ReadTask extends PerfTask {
     return true;
   }
 
-  /** Whether maxScores should be computed (only useful with
-   *  field sort) */
-  public boolean withMaxScore() {
-    return true;
-  }
-
   /** Whether totalHits should be computed (only useful with
    *  field sort) */
   public boolean withTotalHits() {
diff --git a/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchWithSortTask.java b/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchWithSortTask.java
index 8361ab3..6a17714 100644
--- a/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchWithSortTask.java
+++ b/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchWithSortTask.java
@@ -30,7 +30,6 @@ import org.apache.lucene.search.SortField;
 public class SearchWithSortTask extends ReadTask {
 
   private boolean doScore = true;
-  private boolean doMaxScore = true;
   private Sort sort;
 
   public SearchWithSortTask(PerfRunData runData) {
@@ -64,9 +63,6 @@ public class SearchWithSortTask extends ReadTask {
       } else if (field.equals("noscore")) {
         doScore = false;
         continue;
-      } else if (field.equals("nomaxscore")) {
-        doMaxScore = false;
-        continue;
       } else {
         int index = field.lastIndexOf(":");
         String fieldName;
@@ -124,11 +120,6 @@ public class SearchWithSortTask extends ReadTask {
   public boolean withScore() {
     return doScore;
   }
-
-  @Override
-  public boolean withMaxScore() {
-    return doMaxScore;
-  }
   
   @Override
   public Sort getSort() {
diff --git a/lucene/classification/src/java/org/apache/lucene/classification/BM25NBClassifier.java b/lucene/classification/src/java/org/apache/lucene/classification/BM25NBClassifier.java
index f03fc53..0613856 100644
--- a/lucene/classification/src/java/org/apache/lucene/classification/BM25NBClassifier.java
+++ b/lucene/classification/src/java/org/apache/lucene/classification/BM25NBClassifier.java
@@ -217,7 +217,7 @@ public class BM25NBClassifier implements Classifier<BytesRef> {
       builder.add(query, BooleanClause.Occur.MUST);
     }
     TopDocs search = indexSearcher.search(builder.build(), 1);
-    return search.totalHits > 0 ? search.getMaxScore() : 1;
+    return search.totalHits > 0 ? search.scoreDocs[0].score : 1;
   }
 
   private double calculateLogPrior(Term term) throws IOException {
@@ -228,7 +228,7 @@ public class BM25NBClassifier implements Classifier<BytesRef> {
       bq.add(query, BooleanClause.Occur.MUST);
     }
     TopDocs topDocs = indexSearcher.search(bq.build(), 1);
-    return topDocs.totalHits > 0 ? Math.log(topDocs.getMaxScore()) : 0;
+    return topDocs.totalHits > 0 ? Math.log(topDocs.scoreDocs[0].score) : 0;
   }
 
 }
diff --git a/lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier.java b/lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier.java
index 941d881..0e90ccd 100644
--- a/lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier.java
+++ b/lucene/classification/src/java/org/apache/lucene/classification/KNearestFuzzyClassifier.java
@@ -159,7 +159,7 @@ public class KNearestFuzzyClassifier implements Classifier<BytesRef> {
   private List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {
     Map<BytesRef, Integer> classCounts = new HashMap<>();
     Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs
-    float maxScore = topDocs.getMaxScore();
+    float maxScore = topDocs.totalHits == 0 ? Float.NaN : topDocs.scoreDocs[0].score;
     for (ScoreDoc scoreDoc : topDocs.scoreDocs) {
       IndexableField storableField = indexSearcher.doc(scoreDoc.doc).getField(classFieldName);
       if (storableField != null) {
diff --git a/lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier.java b/lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier.java
index 1bc53b0..6c55493 100644
--- a/lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier.java
+++ b/lucene/classification/src/java/org/apache/lucene/classification/KNearestNeighborClassifier.java
@@ -190,7 +190,7 @@ public class KNearestNeighborClassifier implements Classifier<BytesRef> {
   protected List<ClassificationResult<BytesRef>> buildListFromTopDocs(TopDocs topDocs) throws IOException {
     Map<BytesRef, Integer> classCounts = new HashMap<>();
     Map<BytesRef, Double> classBoosts = new HashMap<>(); // this is a boost based on class ranking positions in topDocs
-    float maxScore = topDocs.getMaxScore();
+    float maxScore = topDocs.totalHits == 0 ? Float.NaN : topDocs.scoreDocs[0].score;
     for (ScoreDoc scoreDoc : topDocs.scoreDocs) {
       IndexableField[] storableFields = indexSearcher.doc(scoreDoc.doc).getFields(classFieldName);
       for (IndexableField singleStorableField : storableFields) {
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java b/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
index 5a3c890..c4bf83d 100644
--- a/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
+++ b/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
@@ -433,8 +433,8 @@ public class IndexSearcher {
    *         {@link BooleanQuery#getMaxClauseCount()} clauses.
    */
   public TopFieldDocs search(Query query, int n,
-      Sort sort, boolean doDocScores, boolean doMaxScore) throws IOException {
-    return searchAfter(null, query, n, sort, doDocScores, doMaxScore);
+      Sort sort, boolean doDocScores) throws IOException {
+    return searchAfter(null, query, n, sort, doDocScores);
   }
 
   /**
@@ -446,7 +446,7 @@ public class IndexSearcher {
    * @throws IOException if there is a low-level I/O error
    */
   public TopFieldDocs search(Query query, int n, Sort sort) throws IOException {
-    return searchAfter(null, query, n, sort, false, false);
+    return searchAfter(null, query, n, sort, false);
   }
 
   /** Finds the top <code>n</code>
@@ -461,7 +461,7 @@ public class IndexSearcher {
    *         {@link BooleanQuery#getMaxClauseCount()} clauses.
    */
   public TopDocs searchAfter(ScoreDoc after, Query query, int n, Sort sort) throws IOException {
-    return searchAfter(after, query, n, sort, false, false);
+    return searchAfter(after, query, n, sort, false);
   }
 
   /** Finds the top <code>n</code>
@@ -481,17 +481,17 @@ public class IndexSearcher {
    *         {@link BooleanQuery#getMaxClauseCount()} clauses.
    */
   public TopFieldDocs searchAfter(ScoreDoc after, Query query, int numHits, Sort sort,
-      boolean doDocScores, boolean doMaxScore) throws IOException {
+      boolean doDocScores) throws IOException {
     if (after != null && !(after instanceof FieldDoc)) {
       // TODO: if we fix type safety of TopFieldDocs we can
       // remove this
       throw new IllegalArgumentException("after must be a FieldDoc; got " + after);
     }
-    return searchAfter((FieldDoc) after, query, numHits, sort, doDocScores, doMaxScore);
+    return searchAfter((FieldDoc) after, query, numHits, sort, doDocScores);
   }
 
   private TopFieldDocs searchAfter(FieldDoc after, Query query, int numHits, Sort sort,
-      boolean doDocScores, boolean doMaxScore) throws IOException {
+      boolean doDocScores) throws IOException {
     final int limit = Math.max(1, reader.maxDoc());
     if (after != null && after.doc >= limit) {
       throw new IllegalArgumentException("after.doc exceeds the number of documents in the reader: after.doc="
@@ -506,7 +506,7 @@ public class IndexSearcher {
       public TopFieldCollector newCollector() throws IOException {
         final boolean fillFields = true;
         // TODO: don't pay the price for accurate hit counts by default
-        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, fillFields, doDocScores, doMaxScore, true);
+        return TopFieldCollector.create(rewrittenSort, cappedNumHits, after, fillFields, doDocScores, true);
       }
 
       @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/QueryRescorer.java b/lucene/core/src/java/org/apache/lucene/search/QueryRescorer.java
index 1a128ec..b3452f4 100644
--- a/lucene/core/src/java/org/apache/lucene/search/QueryRescorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/QueryRescorer.java
@@ -135,7 +135,7 @@ public abstract class QueryRescorer extends Rescorer {
       hits = subset;
     }
 
-    return new TopDocs(firstPassTopDocs.totalHits, hits, hits[0].score);
+    return new TopDocs(firstPassTopDocs.totalHits, hits);
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/SortRescorer.java b/lucene/core/src/java/org/apache/lucene/search/SortRescorer.java
index b83e233..d8e16b1 100644
--- a/lucene/core/src/java/org/apache/lucene/search/SortRescorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/SortRescorer.java
@@ -54,7 +54,7 @@ public class SortRescorer extends Rescorer {
 
     List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();
 
-    TopFieldCollector collector = TopFieldCollector.create(sort, topN, true, true, true, true);
+    TopFieldCollector collector = TopFieldCollector.create(sort, topN, true, true, true);
 
     // Now merge sort docIDs from hits, with reader's leaves:
     int hitUpto = 0;
diff --git a/lucene/core/src/java/org/apache/lucene/search/TopDocs.java b/lucene/core/src/java/org/apache/lucene/search/TopDocs.java
index c1a4ca6..3a2fa58 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TopDocs.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TopDocs.java
@@ -28,31 +28,10 @@ public class TopDocs {
   /** The top hits for the query. */
   public ScoreDoc[] scoreDocs;
 
-  /** Stores the maximum score value encountered, needed for normalizing. */
-  private float maxScore;
-  
-  /**
-   * Returns the maximum score value encountered. Note that in case
-   * scores are not tracked, this returns {@link Float#NaN}.
-   */
-  public float getMaxScore() {
-    return maxScore;
-  }
-  
-  /** Sets the maximum score value encountered. */
-  public void setMaxScore(float maxScore) {
-    this.maxScore = maxScore;
-  }
-
-  /** Constructs a TopDocs with a default maxScore=Float.NaN. */
-  TopDocs(long totalHits, ScoreDoc[] scoreDocs) {
-    this(totalHits, scoreDocs, Float.NaN);
-  }
-
-  public TopDocs(long totalHits, ScoreDoc[] scoreDocs, float maxScore) {
+  /** Constructs a TopDocs. */
+  public TopDocs(long totalHits, ScoreDoc[] scoreDocs) {
     this.totalHits = totalHits;
     this.scoreDocs = scoreDocs;
-    this.maxScore = maxScore;
   }
 
   // Refers to one hit:
@@ -268,7 +247,6 @@ public class TopDocs {
 
     long totalHitCount = 0;
     int availHitCount = 0;
-    float maxScore = Float.MIN_VALUE;
     for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {
       final TopDocs shard = shardHits[shardIDX];
       // totalHits can be non-zero even if no hits were
@@ -277,14 +255,9 @@ public class TopDocs {
       if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {
         availHitCount += shard.scoreDocs.length;
         queue.add(new ShardRef(shardIDX, setShardIndex == false));
-        maxScore = Math.max(maxScore, shard.getMaxScore());
       }
     }
 
-    if (availHitCount == 0) {
-      maxScore = Float.NaN;
-    }
-
     final ScoreDoc[] hits;
     if (availHitCount <= start) {
       hits = new ScoreDoc[0];
@@ -320,9 +293,9 @@ public class TopDocs {
     }
 
     if (sort == null) {
-      return new TopDocs(totalHitCount, hits, maxScore);
+      return new TopDocs(totalHitCount, hits);
     } else {
-      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);
+      return new TopFieldDocs(totalHitCount, hits, sort.getSort());
     }
   }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/TopDocsCollector.java b/lucene/core/src/java/org/apache/lucene/search/TopDocsCollector.java
index 219ee3a..1ad3553 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TopDocsCollector.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TopDocsCollector.java
@@ -35,7 +35,7 @@ public abstract class TopDocsCollector<T extends ScoreDoc> implements Collector
 
   /** This is used in case topDocs() is called with illegal parameters, or there
    *  simply aren't (enough) results. */
-  protected static final TopDocs EMPTY_TOPDOCS = new TopDocs(0, new ScoreDoc[0], Float.NaN);
+  protected static final TopDocs EMPTY_TOPDOCS = new TopDocs(0, new ScoreDoc[0]);
   
   /**
    * The priority queue which holds the top documents. Note that different
diff --git a/lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java b/lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java
index 3d85277..3ccd9bb 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java
@@ -28,7 +28,7 @@ import org.apache.lucene.util.PriorityQueue;
  * A {@link Collector} that sorts by {@link SortField} using
  * {@link FieldComparator}s.
  * <p>
- * See the {@link #create(org.apache.lucene.search.Sort, int, boolean, boolean, boolean, boolean)} method
+ * See the {@link #create(org.apache.lucene.search.Sort, int, boolean, boolean, boolean)} method
  * for instantiating a TopFieldCollector.
  *
  * @lucene.experimental
@@ -94,24 +94,19 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
     final Sort sort;
     final FieldValueHitQueue<Entry> queue;
     final boolean trackDocScores;
-    final boolean trackMaxScore;
     final boolean mayNeedScoresTwice;
     final boolean trackTotalHits;
 
     public SimpleFieldCollector(Sort sort, FieldValueHitQueue<Entry> queue, int numHits, boolean fillFields,
-        boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits) {
-      super(queue, numHits, fillFields, sort.needsScores() || trackDocScores || trackMaxScore);
+        boolean trackDocScores, boolean trackTotalHits) {
+      super(queue, numHits, fillFields, sort.needsScores() || trackDocScores);
       this.sort = sort;
       this.queue = queue;
-      if (trackMaxScore) {
-        maxScore = Float.NEGATIVE_INFINITY; // otherwise we would keep NaN
-      }
       this.trackDocScores = trackDocScores;
-      this.trackMaxScore = trackMaxScore;
       // If one of the sort fields needs scores, and if we also track scores, then
       // we might call scorer.score() several times per doc so wrapping the scorer
       // to cache scores would help
-      this.mayNeedScoresTwice = sort.needsScores() && (trackDocScores || trackMaxScore);
+      this.mayNeedScoresTwice = sort.needsScores() && trackDocScores;
       this.trackTotalHits = trackTotalHits;
     }
 
@@ -123,7 +118,6 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       final int[] reverseMul = queue.getReverseMul();
       final Sort indexSort = context.reader().getMetaData().getSort();
       final boolean canEarlyTerminate = trackTotalHits == false &&
-          trackMaxScore == false &&
           indexSort != null &&
           canEarlyTerminate(sort, indexSort);
       final int initialTotalHits = totalHits;
@@ -133,12 +127,6 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
         @Override
         public void collect(int doc) throws IOException {
           float score = Float.NaN;
-          if (trackMaxScore) {
-            score = scorer.score();
-            if (score > maxScore) {
-              maxScore = score;
-            }
-          }
 
           ++totalHits;
           if (queueFull) {
@@ -158,7 +146,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
               }
             }
 
-            if (trackDocScores && !trackMaxScore) {
+            if (trackDocScores) {
               score = scorer.score();
             }
 
@@ -170,7 +158,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
             // Startup transient: queue hasn't gathered numHits yet
             final int slot = totalHits - 1;
 
-            if (trackDocScores && !trackMaxScore) {
+            if (trackDocScores) {
               score = scorer.score();
             }
 
@@ -197,27 +185,20 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
     int collectedHits;
     final FieldValueHitQueue<Entry> queue;
     final boolean trackDocScores;
-    final boolean trackMaxScore;
     final FieldDoc after;
     final boolean mayNeedScoresTwice;
     final boolean trackTotalHits;
 
     public PagingFieldCollector(Sort sort, FieldValueHitQueue<Entry> queue, FieldDoc after, int numHits, boolean fillFields,
-                                boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits) {
-      super(queue, numHits, fillFields, trackDocScores || trackMaxScore || sort.needsScores());
+                                boolean trackDocScores, boolean trackTotalHits) {
+      super(queue, numHits, fillFields, trackDocScores || sort.needsScores());
       this.sort = sort;
       this.queue = queue;
       this.trackDocScores = trackDocScores;
-      this.trackMaxScore = trackMaxScore;
       this.after = after;
-      this.mayNeedScoresTwice = sort.needsScores() && (trackDocScores || trackMaxScore);
+      this.mayNeedScoresTwice = sort.needsScores() && trackDocScores;
       this.trackTotalHits = trackTotalHits;
 
-      // Must set maxScore to NEG_INF, or otherwise Math.max always returns NaN.
-      if (trackMaxScore) {
-        maxScore = Float.NEGATIVE_INFINITY;
-      }
-
       FieldComparator<?>[] comparators = queue.comparators;
       // Tell all comparators their top value:
       for(int i=0;i<comparators.length;i++) {
@@ -233,7 +214,6 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       final int afterDoc = after.doc - docBase;
       final Sort indexSort = context.reader().getMetaData().getSort();
       final boolean canEarlyTerminate = trackTotalHits == false &&
-          trackMaxScore == false &&
           indexSort != null &&
           canEarlyTerminate(sort, indexSort);
       final int initialTotalHits = totalHits;
@@ -246,12 +226,6 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
           totalHits++;
 
           float score = Float.NaN;
-          if (trackMaxScore) {
-            score = scorer.score();
-            if (score > maxScore) {
-              maxScore = score;
-            }
-          }
 
           if (queueFull) {
             // Fastmatch: return if this hit is no better than
@@ -283,7 +257,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
             comparator.copy(bottom.slot, doc);
 
             // Compute score only if it is competitive.
-            if (trackDocScores && !trackMaxScore) {
+            if (trackDocScores) {
               score = scorer.score();
             }
             updateBottom(doc, score);
@@ -299,7 +273,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
             comparator.copy(slot, doc);
 
             // Compute score only if it is competitive.
-            if (trackDocScores && !trackMaxScore) {
+            if (trackDocScores) {
               score = scorer.score();
             }
             bottom = pq.add(new Entry(slot, docBase + doc, score));
@@ -318,12 +292,6 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
 
   private final boolean fillFields;
 
-  /*
-   * Stores the maximum score value encountered, needed for normalizing. If
-   * document scores are not tracked, this value is initialized to NaN.
-   */
-  float maxScore = Float.NaN;
-
   final int numHits;
   FieldValueHitQueue.Entry bottom = null;
   boolean queueFull;
@@ -370,13 +338,6 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
    *          it incurs the score computation on each competitive result.
    *          Therefore if document scores are not required by the application,
    *          it is recommended to set it to false.
-   * @param trackMaxScore
-   *          specifies whether the query's maxScore should be tracked and set
-   *          on the resulting {@link TopDocs}. Note that if set to false,
-   *          {@link TopDocs#getMaxScore()} returns Float.NaN. Setting this to
-   *          true affects performance as it incurs the score computation on
-   *          each result. Also, setting this true automatically sets
-   *          <code>trackDocScores</code> to true as well.
    * @param trackTotalHits
    *          specifies whether the total number of hits should be tracked. If
    *          set to false, the value of {@link TopFieldDocs#totalHits} will be
@@ -385,8 +346,8 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
    *         the sort criteria.
    */
   public static TopFieldCollector create(Sort sort, int numHits,
-      boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits) {
-    return create(sort, numHits, null, fillFields, trackDocScores, trackMaxScore, trackTotalHits);
+      boolean fillFields, boolean trackDocScores, boolean trackTotalHits) {
+    return create(sort, numHits, null, fillFields, trackDocScores, trackTotalHits);
   }
 
   /**
@@ -413,12 +374,6 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
    *          it incurs the score computation on each competitive result.
    *          Therefore if document scores are not required by the application,
    *          it is recommended to set it to false.
-   * @param trackMaxScore
-   *          specifies whether the query's maxScore should be tracked and set
-   *          on the resulting {@link TopDocs}. Note that if set to false,
-   *          {@link TopDocs#getMaxScore()} returns Float.NaN. Setting this to
-   *          true affects performance as it incurs the score computation on
-   *          each result. Also, setting this true automatically sets
    *          <code>trackDocScores</code> to true as well.
    * @param trackTotalHits
    *          specifies whether the total number of hits should be tracked. If
@@ -428,7 +383,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
    *         the sort criteria.
    */
   public static TopFieldCollector create(Sort sort, int numHits, FieldDoc after,
-      boolean fillFields, boolean trackDocScores, boolean trackMaxScore, boolean trackTotalHits) {
+      boolean fillFields, boolean trackDocScores, boolean trackTotalHits) {
 
     if (sort.fields.length == 0) {
       throw new IllegalArgumentException("Sort must contain at least one field");
@@ -441,7 +396,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
     FieldValueHitQueue<Entry> queue = FieldValueHitQueue.create(sort.fields, numHits);
 
     if (after == null) {
-      return new SimpleFieldCollector(sort, queue, numHits, fillFields, trackDocScores, trackMaxScore, trackTotalHits);
+      return new SimpleFieldCollector(sort, queue, numHits, fillFields, trackDocScores, trackTotalHits);
     } else {
       if (after.fields == null) {
         throw new IllegalArgumentException("after.fields wasn't set; you must pass fillFields=true for the previous search");
@@ -451,7 +406,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
         throw new IllegalArgumentException("after.fields has " + after.fields.length + " values but sort has " + sort.getSort().length);
       }
 
-      return new PagingFieldCollector(sort, queue, after, numHits, fillFields, trackDocScores, trackMaxScore, trackTotalHits);
+      return new PagingFieldCollector(sort, queue, after, numHits, fillFields, trackDocScores, trackTotalHits);
     }
   }
 
@@ -497,12 +452,10 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
   protected TopDocs newTopDocs(ScoreDoc[] results, int start) {
     if (results == null) {
       results = EMPTY_SCOREDOCS;
-      // Set maxScore to NaN, in case this is a maxScore tracking collector.
-      maxScore = Float.NaN;
     }
 
     // If this is a maxScoring tracking collector and there were no results,
-    return new TopFieldDocs(totalHits, results, ((FieldValueHitQueue<Entry>) pq).getFields(), maxScore);
+    return new TopFieldDocs(totalHits, results, ((FieldValueHitQueue<Entry>) pq).getFields());
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/TopFieldDocs.java b/lucene/core/src/java/org/apache/lucene/search/TopFieldDocs.java
index 52a51b7..95c7dee 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TopFieldDocs.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TopFieldDocs.java
@@ -30,10 +30,9 @@ public class TopFieldDocs extends TopDocs {
    * @param totalHits  Total number of hits for the query.
    * @param scoreDocs  The top hits for the query.
    * @param fields     The sort criteria used to find the top hits.
-   * @param maxScore   The maximum score encountered.
    */
-  public TopFieldDocs (long totalHits, ScoreDoc[] scoreDocs, SortField[] fields, float maxScore) {
-    super (totalHits, scoreDocs, maxScore);
+  public TopFieldDocs (long totalHits, ScoreDoc[] scoreDocs, SortField[] fields) {
+    super (totalHits, scoreDocs);
     this.fields = fields;
   }
 }
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.java b/lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.java
index afae1fc..a319de7 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TopScoreDocCollector.java
@@ -148,7 +148,7 @@ public abstract class TopScoreDocCollector extends TopDocsCollector<ScoreDoc> {
 
     @Override
     protected TopDocs newTopDocs(ScoreDoc[] results, int start) {
-      return results == null ? new TopDocs(totalHits, new ScoreDoc[0], Float.NaN) : new TopDocs(totalHits, results);
+      return results == null ? new TopDocs(totalHits, new ScoreDoc[0]) : new TopDocs(totalHits, results);
     }
 
     @Override
@@ -240,19 +240,7 @@ public abstract class TopScoreDocCollector extends TopDocsCollector<ScoreDoc> {
       return EMPTY_TOPDOCS;
     }
 
-    // We need to compute maxScore in order to set it in TopDocs. If start == 0,
-    // it means the largest element is already in results, use its score as
-    // maxScore. Otherwise pop everything else, until the largest element is
-    // extracted and use its score as maxScore.
-    float maxScore = Float.NaN;
-    if (start == 0) {
-      maxScore = results[0].score;
-    } else {
-      for (int i = pq.size(); i > 1; i--) { pq.pop(); }
-      maxScore = pq.pop().score;
-    }
-
-    return new TopDocs(totalHits, results, maxScore);
+    return new TopDocs(totalHits, results);
   }
 
   @Override
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexSorting.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexSorting.java
index 3679d20..9f12ca2 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexSorting.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexSorting.java
@@ -2324,11 +2324,11 @@ public class TestIndexSorting extends LuceneTestCase {
         System.out.println("TEST: iter=" + iter + " numHits=" + numHits);
       }
 
-      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true, true);
+      TopFieldCollector c1 = TopFieldCollector.create(sort, numHits, true, true, true);
       s1.search(new MatchAllDocsQuery(), c1);
       TopDocs hits1 = c1.topDocs();
 
-      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, true, false);
+      TopFieldCollector c2 = TopFieldCollector.create(sort, numHits, true, true, false);
       s2.search(new MatchAllDocsQuery(), c2);
 
       TopDocs hits2 = c2.topDocs();
@@ -2344,7 +2344,6 @@ public class TestIndexSorting extends LuceneTestCase {
         }
       }
 
-      assertTrue(hits2.totalHits <= hits1.totalHits);
       assertEquals(hits2.scoreDocs.length, hits1.scoreDocs.length);
       for(int i=0;i<hits2.scoreDocs.length;i++) {
         ScoreDoc hit1 = hits1.scoreDocs[i];
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java b/lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java
index 66b895a..7522cd0 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java
@@ -386,10 +386,10 @@ public class TestBoolean2 extends LuceneTestCase {
         }
 
         // check diff (randomized) scorers (from AssertingSearcher) produce the same results
-        TopFieldCollector collector = TopFieldCollector.create(sort, 1000, false, true, true, false);
+        TopFieldCollector collector = TopFieldCollector.create(sort, 1000, false, true, false);
         searcher.search(q1, collector);
         ScoreDoc[] hits1 = collector.topDocs().scoreDocs;
-        collector = TopFieldCollector.create(sort, 1000, false, true, true, false);
+        collector = TopFieldCollector.create(sort, 1000, false, true, false);
         searcher.search(q1, collector);
         ScoreDoc[] hits2 = collector.topDocs().scoreDocs;
         tot+=hits2.length;
@@ -402,10 +402,10 @@ public class TestBoolean2 extends LuceneTestCase {
         assertEquals(mulFactor*collector.totalHits + NUM_EXTRA_DOCS/2, hits4.totalHits);
 
         // test diff (randomized) scorers produce the same results on bigSearcher as well
-        collector = TopFieldCollector.create(sort, 1000 * mulFactor, false, true, true, false);
+        collector = TopFieldCollector.create(sort, 1000 * mulFactor, false, true, false);
         bigSearcher.search(q1, collector);
         hits1 = collector.topDocs().scoreDocs;
-        collector = TopFieldCollector.create(sort, 1000 * mulFactor, false, true, true, false);
+        collector = TopFieldCollector.create(sort, 1000 * mulFactor, false, true, false);
         bigSearcher.search(q1, collector);
         hits2 = collector.topDocs().scoreDocs;
         CheckHits.checkEqual(q1, hits1, hits2);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestDoubleValuesSource.java b/lucene/core/src/test/org/apache/lucene/search/TestDoubleValuesSource.java
index 49b0e11..9806add 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestDoubleValuesSource.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestDoubleValuesSource.java
@@ -163,9 +163,9 @@ public class TestDoubleValuesSource extends LuceneTestCase {
 
   void checkSorts(Query query, Sort sort) throws Exception {
     int size = TestUtil.nextInt(random(), 1, searcher.getIndexReader().maxDoc() / 5);
-    TopDocs expected = searcher.search(query, size, sort, random().nextBoolean(), random().nextBoolean());
+    TopDocs expected = searcher.search(query, size, sort, random().nextBoolean());
     Sort mutatedSort = convertSortToSortable(sort);
-    TopDocs actual = searcher.search(query, size, mutatedSort, random().nextBoolean(), random().nextBoolean());
+    TopDocs actual = searcher.search(query, size, mutatedSort, random().nextBoolean());
 
     CheckHits.checkEqual(query, expected.scoreDocs, actual.scoreDocs);
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestElevationComparator.java b/lucene/core/src/test/org/apache/lucene/search/TestElevationComparator.java
index 3178c35..bc849e9 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestElevationComparator.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestElevationComparator.java
@@ -86,7 +86,7 @@ public class TestElevationComparator extends LuceneTestCase {
         new SortField(null, SortField.Type.SCORE, reversed)
       );
 
-    TopDocsCollector<Entry> topCollector = TopFieldCollector.create(sort, 50, false, true, true, true);
+    TopDocsCollector<Entry> topCollector = TopFieldCollector.create(sort, 50, false, true, true);
     searcher.search(newq.build(), topCollector);
 
     TopDocs topDocs = topCollector.topDocs(0, 10);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java b/lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java
index 8748a1a..a3930a9 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java
@@ -100,15 +100,11 @@ public class TestIndexSearcher extends LuceneTestCase {
             searcher.searchAfter(after, query, Integer.MAX_VALUE);
             if (sort != null) {
               searcher.search(query, Integer.MAX_VALUE, sort);
-              searcher.search(query, Integer.MAX_VALUE, sort, true, true);
-              searcher.search(query, Integer.MAX_VALUE, sort, true, false);
-              searcher.search(query, Integer.MAX_VALUE, sort, false, true);
-              searcher.search(query, Integer.MAX_VALUE, sort, false, false);
+              searcher.search(query, Integer.MAX_VALUE, sort, true);
+              searcher.search(query, Integer.MAX_VALUE, sort, false);
               searcher.searchAfter(after, query, Integer.MAX_VALUE, sort);
-              searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, true, true);
-              searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, true, false);
-              searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, false, true);
-              searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, false, false);
+              searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, true);
+              searcher.searchAfter(after, query, Integer.MAX_VALUE, sort, false);
             }
           }
         }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestLongValuesSource.java b/lucene/core/src/test/org/apache/lucene/search/TestLongValuesSource.java
index 4c77e7e..f33292d 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestLongValuesSource.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestLongValuesSource.java
@@ -136,8 +136,8 @@ public class TestLongValuesSource extends LuceneTestCase {
   void checkSorts(Query query, Sort sort) throws Exception {
     int size = TestUtil.nextInt(random(), 1, searcher.getIndexReader().maxDoc() / 5);
     Sort mutatedSort = convertSortToSortable(sort);
-    TopDocs actual = searcher.search(query, size, mutatedSort, random().nextBoolean(), random().nextBoolean());
-    TopDocs expected = searcher.search(query, size, sort, random().nextBoolean(), random().nextBoolean());
+    TopDocs actual = searcher.search(query, size, mutatedSort, random().nextBoolean());
+    TopDocs expected = searcher.search(query, size, sort, random().nextBoolean());
 
     CheckHits.checkEqual(query, expected.scoreDocs, actual.scoreDocs);
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java b/lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java
index 7017dde..363c974 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java
@@ -216,14 +216,13 @@ public class TestSearchAfter extends LuceneTestCase {
     if (VERBOSE) {
       System.out.println("\nassertQuery " + (iter++) + ": query=" + query + " sort=" + sort + " pageSize=" + pageSize);
     }
-    final boolean doMaxScore = random().nextBoolean();
     final boolean doScores = random().nextBoolean();
     if (sort == null) {
       all = searcher.search(query, maxDoc);
     } else if (sort == Sort.RELEVANCE) {
-      all = searcher.search(query, maxDoc, sort, true, doMaxScore);
+      all = searcher.search(query, maxDoc, sort, true);
     } else {
-      all = searcher.search(query, maxDoc, sort, doScores, doMaxScore);
+      all = searcher.search(query, maxDoc, sort, doScores);
     }
     if (VERBOSE) {
       System.out.println("  all.totalHits=" + all.totalHits);
@@ -246,9 +245,9 @@ public class TestSearchAfter extends LuceneTestCase {
           System.out.println("  iter lastBottom=" + lastBottom);
         }
         if (sort == Sort.RELEVANCE) {
-          paged = searcher.searchAfter(lastBottom, query, pageSize, sort, true, doMaxScore);
+          paged = searcher.searchAfter(lastBottom, query, pageSize, sort, true);
         } else {
-          paged = searcher.searchAfter(lastBottom, query, pageSize, sort, doScores, doMaxScore);
+          paged = searcher.searchAfter(lastBottom, query, pageSize, sort, doScores);
         }
       }
       if (VERBOSE) {
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestShardSearching.java b/lucene/core/src/test/org/apache/lucene/search/TestShardSearching.java
index ebc7062..df34107 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestShardSearching.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestShardSearching.java
@@ -328,12 +328,12 @@ public class TestShardSearching extends ShardSearchingTestBase {
         System.out.println("  shard=" + shardID + " maxDoc=" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());
       }
       */
-      System.out.println("  single searcher: " + hits.totalHits + " totalHits maxScore=" + hits.getMaxScore());
+      System.out.println("  single searcher: " + hits.totalHits);
       for(int i=0;i<hits.scoreDocs.length;i++) {
         final ScoreDoc sd = hits.scoreDocs[i];
         System.out.println("    doc=" + sd.doc + " score=" + sd.score);
       }
-      System.out.println("  shard searcher: " + shardHits.totalHits + " totalHits maxScore=" + shardHits.getMaxScore());
+      System.out.println("  shard searcher: " + shardHits.totalHits);
       for(int i=0;i<shardHits.scoreDocs.length;i++) {
         final ScoreDoc sd = shardHits.scoreDocs[i];
         System.out.println("    doc=" + sd.doc + " (rebased: " + (sd.doc + base[sd.shardIndex]) + ") score=" + sd.score + " shard=" + sd.shardIndex);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSortRandom.java b/lucene/core/src/test/org/apache/lucene/search/TestSortRandom.java
index 05b016c..a96399e 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSortRandom.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSortRandom.java
@@ -146,7 +146,7 @@ public class TestSortRandom extends LuceneTestCase {
       }
       final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);
       final RandomQuery f = new RandomQuery(random.nextLong(), random.nextFloat(), docValues);
-      hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());
+      hits = s.search(f, hitCount, sort, random.nextBoolean());
 
       if (VERBOSE) {
         System.out.println("\nTEST: iter=" + iter + " " + hits.totalHits + " hits; topN=" + hitCount + "; reverse=" + reverse + "; sortMissingLast=" + sortMissingLast + " sort=" + sort);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSortedNumericSortField.java b/lucene/core/src/test/org/apache/lucene/search/TestSortedNumericSortField.java
index 210ff89..37fb710 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSortedNumericSortField.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSortedNumericSortField.java
@@ -36,13 +36,13 @@ public class TestSortedNumericSortField extends LuceneTestCase {
   
     Sort sort = new Sort();
     sort.setSort(new SortedNumericSortField("sortednumeric", SortField.Type.LONG));
-    TopDocs td = empty.search(query, 10, sort, true, true);
+    TopDocs td = empty.search(query, 10, sort, true);
     assertEquals(0, td.totalHits);
     
     // for an empty index, any selector should work
     for (SortedNumericSelector.Type v : SortedNumericSelector.Type.values()) {
       sort.setSort(new SortedNumericSortField("sortednumeric", SortField.Type.LONG, false, v));
-      td = empty.search(query, 10, sort, true, true);
+      td = empty.search(query, 10, sort, true);
       assertEquals(0, td.totalHits);
     }
   }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSortedSetSortField.java b/lucene/core/src/test/org/apache/lucene/search/TestSortedSetSortField.java
index 7b4ca27..899e46d 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSortedSetSortField.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSortedSetSortField.java
@@ -37,13 +37,13 @@ public class TestSortedSetSortField extends LuceneTestCase {
   
     Sort sort = new Sort();
     sort.setSort(new SortedSetSortField("sortedset", false));
-    TopDocs td = empty.search(query, 10, sort, true, true);
+    TopDocs td = empty.search(query, 10, sort, true);
     assertEquals(0, td.totalHits);
     
     // for an empty index, any selector should work
     for (SortedSetSelector.Type v : SortedSetSelector.Type.values()) {
       sort.setSort(new SortedSetSortField("sortedset", false, v));
-      td = empty.search(query, 10, sort, true, true);
+      td = empty.search(query, 10, sort, true);
       assertEquals(0, td.totalHits);
     }
   }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestTopDocsCollector.java b/lucene/core/src/test/org/apache/lucene/search/TestTopDocsCollector.java
index 17c5f85..4cf36ef 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestTopDocsCollector.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestTopDocsCollector.java
@@ -46,15 +46,7 @@ public class TestTopDocsCollector extends LuceneTestCase {
         return EMPTY_TOPDOCS;
       }
       
-      float maxScore = Float.NaN;
-      if (start == 0) {
-        maxScore = results[0].score;
-      } else {
-        for (int i = pq.size(); i > 1; i--) { pq.pop(); }
-        maxScore = pq.pop().score;
-      }
-      
-      return new TopDocs(totalHits, results, maxScore);
+      return new TopDocs(totalHits, results);
     }
     
     @Override
@@ -188,18 +180,6 @@ public class TestTopDocsCollector extends LuceneTestCase {
     assertEquals(5, tdc.topDocs(10).scoreDocs.length);
   }
   
-  public void testMaxScore() throws Exception {
-    // ask for all results
-    TopDocsCollector<ScoreDoc> tdc = doSearch(15);
-    TopDocs td = tdc.topDocs();
-    assertEquals(MAX_SCORE, td.getMaxScore(), 0f);
-    
-    // ask for 5 last results
-    tdc = doSearch(15);
-    td = tdc.topDocs(10);
-    assertEquals(MAX_SCORE, td.getMaxScore(), 0f);
-  }
-  
   // This does not test the PQ's correctness, but whether topDocs()
   // implementations return the results in decreasing score order.
   public void testResultsOrder() throws Exception {
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java b/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java
index 0173cf9..65de8f5 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java
@@ -275,13 +275,13 @@ public class TestTopDocsMerge extends LuceneTestCase {
             tempTopHits.scoreDocs = newScoreDocs;
             topHits = tempTopHits;
           } else {
-            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());
+            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);
           }
         } else {
           topHits = searcher.search(query, numHits);
         }
       } else {
-        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);
+        final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);
         searcher.search(query, c);
         if (useFrom) {
           from = TestUtil.nextInt(random(), 0, numHits - 1);
@@ -295,7 +295,7 @@ public class TestTopDocsMerge extends LuceneTestCase {
             tempTopHits.scoreDocs = newScoreDocs;
             topHits = tempTopHits;
           } else {
-            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0], tempTopHits.getMaxScore());
+            topHits = new TopDocs(tempTopHits.totalHits, new ScoreDoc[0]);
           }
         } else {
           topHits = c.topDocs(0, numHits);
@@ -306,7 +306,7 @@ public class TestTopDocsMerge extends LuceneTestCase {
         if (useFrom) {
           System.out.println("from=" + from + " size=" + size);
         }
-        System.out.println("  top search: " + topHits.totalHits + " totalHits; hits=" + (topHits.scoreDocs == null ? "null" : topHits.scoreDocs.length + " maxScore=" + topHits.getMaxScore()));
+        System.out.println("  top search: " + topHits.totalHits + " totalHits; hits=" + (topHits.scoreDocs == null ? "null" : topHits.scoreDocs.length));
         if (topHits.scoreDocs != null) {
           for(int hitIDX=0;hitIDX<topHits.scoreDocs.length;hitIDX++) {
             final ScoreDoc sd = topHits.scoreDocs[hitIDX];
@@ -330,7 +330,7 @@ public class TestTopDocsMerge extends LuceneTestCase {
         if (sort == null) {
           subHits = subSearcher.search(w, numHits);
         } else {
-          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true, true);
+          final TopFieldCollector c = TopFieldCollector.create(sort, numHits, true, true, true);
           subSearcher.search(w, c);
           subHits = c.topDocs(0, numHits);
         }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollector.java b/lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollector.java
index f12e910..a7f4cda 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollector.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollector.java
@@ -71,7 +71,7 @@ public class TestTopFieldCollector extends LuceneTestCase {
     for(int i = 0; i < sort.length; i++) {
       Query q = new MatchAllDocsQuery();
       TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, false,
-          false, false, true);
+          false, true);
       
       is.search(q, tdc);
       
@@ -90,7 +90,7 @@ public class TestTopFieldCollector extends LuceneTestCase {
     for(int i = 0; i < sort.length; i++) {
       Query q = new MatchAllDocsQuery();
       TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, false,
-          false, true);
+          true);
       
       is.search(q, tdc);
       
@@ -99,7 +99,6 @@ public class TestTopFieldCollector extends LuceneTestCase {
       for(int j = 0; j < sd.length; j++) {
         assertTrue(Float.isNaN(sd[j].score));
       }
-      assertTrue(Float.isNaN(td.getMaxScore()));
     }
   }
 
@@ -111,10 +110,10 @@ public class TestTopFieldCollector extends LuceneTestCase {
       // the index is not sorted
       TopDocsCollector<Entry> tdc;
       if (i % 2 == 0) {
-        tdc =  TopFieldCollector.create(sort, 10, true, false, false, false);
+        tdc =  TopFieldCollector.create(sort, 10, true, false, false);
       } else {
         FieldDoc fieldDoc = new FieldDoc(1, Float.NaN, new Object[] { 1 });
-        tdc = TopFieldCollector.create(sort, 10, fieldDoc, true, false, false, false);
+        tdc = TopFieldCollector.create(sort, 10, fieldDoc, true, false, false);
       }
 
       is.search(q, tdc);
@@ -124,59 +123,17 @@ public class TestTopFieldCollector extends LuceneTestCase {
       for(int j = 0; j < sd.length; j++) {
         assertTrue(Float.isNaN(sd[j].score));
       }
-      assertTrue(Float.isNaN(td.getMaxScore()));
-    }
-  }
-  
-  public void testSortWithScoreNoMaxScoreTracking() throws Exception {
-    
-    // Two Sort criteria to instantiate the multi/single comparators.
-    Sort[] sort = new Sort[] {new Sort(SortField.FIELD_DOC), new Sort() };
-    for(int i = 0; i < sort.length; i++) {
-      Query q = new MatchAllDocsQuery();
-      TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true,
-          false, true);
-      
-      is.search(q, tdc);
-      
-      TopDocs td = tdc.topDocs();
-      ScoreDoc[] sd = td.scoreDocs;
-      for(int j = 0; j < sd.length; j++) {
-        assertTrue(!Float.isNaN(sd[j].score));
-      }
-      assertTrue(Float.isNaN(td.getMaxScore()));
-    }
-  }
-  
-  // MultiComparatorScoringNoMaxScoreCollector
-  public void testSortWithScoreNoMaxScoreTrackingMulti() throws Exception {
-    
-    // Two Sort criteria to instantiate the multi/single comparators.
-    Sort[] sort = new Sort[] {new Sort(SortField.FIELD_DOC, SortField.FIELD_SCORE) };
-    for(int i = 0; i < sort.length; i++) {
-      Query q = new MatchAllDocsQuery();
-      TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true,
-          false, true);
-
-      is.search(q, tdc);
-      
-      TopDocs td = tdc.topDocs();
-      ScoreDoc[] sd = td.scoreDocs;
-      for(int j = 0; j < sd.length; j++) {
-        assertTrue(!Float.isNaN(sd[j].score));
-      }
-      assertTrue(Float.isNaN(td.getMaxScore()));
     }
   }
   
-  public void testSortWithScoreAndMaxScoreTracking() throws Exception {
+  public void testSortWithScoreTracking() throws Exception {
     
     // Two Sort criteria to instantiate the multi/single comparators.
     Sort[] sort = new Sort[] {new Sort(SortField.FIELD_DOC), new Sort() };
     for(int i = 0; i < sort.length; i++) {
       Query q = new MatchAllDocsQuery();
       TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true,
-          true, true);
+          true);
       
       is.search(q, tdc);
       
@@ -185,19 +142,17 @@ public class TestTopFieldCollector extends LuceneTestCase {
       for(int j = 0; j < sd.length; j++) {
         assertTrue(!Float.isNaN(sd[j].score));
       }
-      assertTrue(!Float.isNaN(td.getMaxScore()));
     }
   }
 
-  public void testSortWithScoreAndMaxScoreTrackingNoResults() throws Exception {
+  public void testSortWithScoreTrackingNoResults() throws Exception {
     
     // Two Sort criteria to instantiate the multi/single comparators.
     Sort[] sort = new Sort[] {new Sort(SortField.FIELD_DOC), new Sort() };
     for(int i = 0; i < sort.length; i++) {
-      TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true, true, true);
+      TopDocsCollector<Entry> tdc = TopFieldCollector.create(sort[i], 10, true, true, true);
       TopDocs td = tdc.topDocs();
       assertEquals(0, td.totalHits);
-      assertTrue(Float.isNaN(td.getMaxScore()));
     }
   }
 
@@ -228,55 +183,53 @@ public class TestTopFieldCollector extends LuceneTestCase {
     final IndexSearcher searcher = new IndexSearcher(reader);
     for (Sort sort : new Sort[] {new Sort(SortField.FIELD_SCORE), new Sort(new SortField("f", SortField.Type.SCORE))}) {
       for (boolean doDocScores : new boolean[] {false, true}) {
-        for (boolean doMaxScore : new boolean[] {false, true}) {
-          final TopFieldCollector topCollector = TopFieldCollector.create(sort, TestUtil.nextInt(random(), 1, 2), true, doDocScores, doMaxScore, true);
-          final Collector assertingCollector = new Collector() {
-            @Override
-            public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {
-              final LeafCollector in = topCollector.getLeafCollector(context);
-              return new FilterLeafCollector(in) {
-                @Override
-                public void setScorer(final Scorer scorer) throws IOException {
-                  Scorer s = new Scorer(null) {
-
-                    int lastComputedDoc = -1;
-                    
-                    @Override
-                    public float score() throws IOException {
-                      if (lastComputedDoc == docID()) {
-                        throw new AssertionError("Score computed twice on " + docID());
-                      }
-                      lastComputedDoc = docID();
-                      return scorer.score();
-                    }
-
-                    @Override
-                    public float getMaxScore(int upTo) throws IOException {
-                      return scorer.getMaxScore(upTo);
-                    }
-
-                    @Override
-                    public int docID() {
-                      return scorer.docID();
-                    }
-
-                    @Override
-                    public DocIdSetIterator iterator() {
-                      return scorer.iterator();
+        final TopFieldCollector topCollector = TopFieldCollector.create(sort, TestUtil.nextInt(random(), 1, 2), true, doDocScores, true);
+        final Collector assertingCollector = new Collector() {
+          @Override
+          public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {
+            final LeafCollector in = topCollector.getLeafCollector(context);
+            return new FilterLeafCollector(in) {
+              @Override
+              public void setScorer(final Scorer scorer) throws IOException {
+                Scorer s = new Scorer(null) {
+
+                  int lastComputedDoc = -1;
+
+                  @Override
+                  public float score() throws IOException {
+                    if (lastComputedDoc == docID()) {
+                      throw new AssertionError("Score computed twice on " + docID());
                     }
-                    
-                  };
-                  super.setScorer(s);
-                }
-              };
-            }
-            @Override
-            public ScoreMode scoreMode() {
-              return topCollector.scoreMode();
-            }
-          };
-          searcher.search(query, assertingCollector);
-        }
+                    lastComputedDoc = docID();
+                    return scorer.score();
+                  }
+
+                  @Override
+                  public float getMaxScore(int upTo) throws IOException {
+                    return scorer.getMaxScore(upTo);
+                  }
+
+                  @Override
+                  public int docID() {
+                    return scorer.docID();
+                  }
+
+                  @Override
+                  public DocIdSetIterator iterator() {
+                    return scorer.iterator();
+                  }
+
+                };
+                super.setScorer(s);
+              }
+            };
+          }
+          @Override
+          public ScoreMode scoreMode() {
+            return topCollector.scoreMode();
+          }
+        };
+        searcher.search(query, assertingCollector);
       }
     }
     reader.close();
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination.java b/lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination.java
index df02cb3..2fd99d9 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestTopFieldCollectorEarlyTermination.java
@@ -138,9 +138,8 @@ public class TestTopFieldCollectorEarlyTermination extends LuceneTestCase {
         }
         final boolean fillFields = random().nextBoolean();
         final boolean trackDocScores = random().nextBoolean();
-        final boolean trackMaxScore = random().nextBoolean();
-        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, true);
-        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, trackMaxScore, false);
+        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, true);
+        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, after, fillFields, trackDocScores, false);
 
         final Query query;
         if (random().nextBoolean()) {
@@ -154,7 +153,7 @@ public class TestTopFieldCollectorEarlyTermination extends LuceneTestCase {
         TopDocs td2 = collector2.topDocs();
 
         assertFalse(collector1.isEarlyTerminated());
-        if (trackMaxScore == false && paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {
+        if (paging == false && maxSegmentSize > numHits && query instanceof MatchAllDocsQuery) {
           // Make sure that we sometimes early terminate
           assertTrue(collector2.isEarlyTerminated());
         }
diff --git a/lucene/expressions/src/test/org/apache/lucene/expressions/TestDemoExpressions.java b/lucene/expressions/src/test/org/apache/lucene/expressions/TestDemoExpressions.java
index b84b7ad..5edd3ee 100644
--- a/lucene/expressions/src/test/org/apache/lucene/expressions/TestDemoExpressions.java
+++ b/lucene/expressions/src/test/org/apache/lucene/expressions/TestDemoExpressions.java
@@ -114,7 +114,7 @@ public class  TestDemoExpressions extends LuceneTestCase {
     
     Sort sort = new Sort(expr.getSortField(bindings, true));
     Query query = new TermQuery(new Term("body", "contents"));
-    TopFieldDocs td = searcher.search(query, 3, sort, true, true);
+    TopFieldDocs td = searcher.search(query, 3, sort, true);
     for (int i = 0; i < 3; i++) {
       FieldDoc d = (FieldDoc) td.scoreDocs[i];
       float expected = (float) Math.sqrt(d.score);
@@ -132,7 +132,7 @@ public class  TestDemoExpressions extends LuceneTestCase {
     
     Sort sort = new Sort(expr.getSortField(bindings, true));
     Query query = new TermQuery(new Term("body", "contents"));
-    TopFieldDocs td = searcher.search(query, 3, sort, true, true);
+    TopFieldDocs td = searcher.search(query, 3, sort, true);
     for (int i = 0; i < 3; i++) {
       FieldDoc d = (FieldDoc) td.scoreDocs[i];
       float expected = 2*d.score;
@@ -151,7 +151,7 @@ public class  TestDemoExpressions extends LuceneTestCase {
     
     Sort sort = new Sort(expr.getSortField(bindings, true));
     Query query = new TermQuery(new Term("body", "contents"));
-    TopFieldDocs td = searcher.search(query, 3, sort, true, true);
+    TopFieldDocs td = searcher.search(query, 3, sort, true);
     for (int i = 0; i < 3; i++) {
       FieldDoc d = (FieldDoc) td.scoreDocs[i];
       float expected = 2*d.score;
@@ -171,7 +171,7 @@ public class  TestDemoExpressions extends LuceneTestCase {
     
     Sort sort = new Sort(expr2.getSortField(bindings, true));
     Query query = new TermQuery(new Term("body", "contents"));
-    TopFieldDocs td = searcher.search(query, 3, sort, true, true);
+    TopFieldDocs td = searcher.search(query, 3, sort, true);
     for (int i = 0; i < 3; i++) {
       FieldDoc d = (FieldDoc) td.scoreDocs[i];
       float expected = 2*d.score;
@@ -203,7 +203,7 @@ public class  TestDemoExpressions extends LuceneTestCase {
     Expression expr = JavascriptCompiler.compile(sb.toString());
     Sort sort = new Sort(expr.getSortField(bindings, true));
     Query query = new TermQuery(new Term("body", "contents"));
-    TopFieldDocs td = searcher.search(query, 3, sort, true, true);
+    TopFieldDocs td = searcher.search(query, 3, sort, true);
     for (int i = 0; i < 3; i++) {
       FieldDoc d = (FieldDoc) td.scoreDocs[i];
       float expected = n*d.score;
diff --git a/lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java b/lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java
index fe5317e..e61c1a3 100644
--- a/lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java
+++ b/lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java
@@ -116,7 +116,7 @@ public class TestExpressionSorts extends LuceneTestCase {
 
   void assertQuery(Query query, Sort sort) throws Exception {
     int size = TestUtil.nextInt(random(), 1, searcher.getIndexReader().maxDoc() / 5);
-    TopDocs expected = searcher.search(query, size, sort, random().nextBoolean(), random().nextBoolean());
+    TopDocs expected = searcher.search(query, size, sort, random().nextBoolean());
     
     // make our actual sort, mutating original by replacing some of the 
     // sortfields with equivalent expressions
@@ -137,7 +137,7 @@ public class TestExpressionSorts extends LuceneTestCase {
     }
     
     Sort mutatedSort = new Sort(mutated);
-    TopDocs actual = searcher.search(query, size, mutatedSort, random().nextBoolean(), random().nextBoolean());
+    TopDocs actual = searcher.search(query, size, mutatedSort, random().nextBoolean());
     CheckHits.checkEqual(query, expected.scoreDocs, actual.scoreDocs);
     
     if (size < actual.totalHits) {
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/DrillSideways.java b/lucene/facet/src/java/org/apache/lucene/facet/DrillSideways.java
index 2e6f8fa..9badc8c 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/DrillSideways.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/DrillSideways.java
@@ -223,7 +223,7 @@ public class DrillSideways {
    * drill down and sideways counts.
    */
   public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,
-          boolean doDocScores, boolean doMaxScore) throws IOException {
+          boolean doDocScores) throws IOException {
     if (filter != null) {
       query = new DrillDownQuery(config, filter, query);
     }
@@ -241,7 +241,7 @@ public class DrillSideways {
 
                   @Override
                   public TopFieldCollector newCollector() throws IOException {
-                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore, true);
+                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, true);
                   }
 
                   @Override
@@ -260,7 +260,7 @@ public class DrillSideways {
       } else {
 
         final TopFieldCollector hitCollector =
-                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore, true);
+                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, true);
         DrillSidewaysResult r = search(query, hitCollector);
         return new DrillSidewaysResult(r.facets, hitCollector.topDocs());
       }
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/FacetsCollector.java b/lucene/facet/src/java/org/apache/lucene/facet/FacetsCollector.java
index 370f132..8c32f8c 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/FacetsCollector.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/FacetsCollector.java
@@ -156,7 +156,7 @@ public class FacetsCollector extends SimpleCollector implements Collector {
   /** Utility method, to search and also collect all hits
    *  into the provided {@link Collector}. */
   public static TopDocs search(IndexSearcher searcher, Query q, int n, Collector fc) throws IOException {
-    return doSearch(searcher, null, q, n, null, false, false, fc);
+    return doSearch(searcher, null, q, n, null, false, fc);
   }
 
   /** Utility method, to search and also collect all hits
@@ -165,22 +165,22 @@ public class FacetsCollector extends SimpleCollector implements Collector {
     if (sort == null) {
       throw new IllegalArgumentException("sort must not be null");
     }
-    return (TopFieldDocs) doSearch(searcher, null, q, n, sort, false, false, fc);
+    return (TopFieldDocs) doSearch(searcher, null, q, n, sort, false, fc);
   }
 
   /** Utility method, to search and also collect all hits
    *  into the provided {@link Collector}. */
-  public static TopFieldDocs search(IndexSearcher searcher, Query q, int n, Sort sort, boolean doDocScores, boolean doMaxScore, Collector fc) throws IOException {
+  public static TopFieldDocs search(IndexSearcher searcher, Query q, int n, Sort sort, boolean doDocScores, Collector fc) throws IOException {
     if (sort == null) {
       throw new IllegalArgumentException("sort must not be null");
     }
-    return (TopFieldDocs) doSearch(searcher, null, q, n, sort, doDocScores, doMaxScore, fc);
+    return (TopFieldDocs) doSearch(searcher, null, q, n, sort, doDocScores, fc);
   }
 
   /** Utility method, to search and also collect all hits
    *  into the provided {@link Collector}. */
   public static TopDocs searchAfter(IndexSearcher searcher, ScoreDoc after, Query q, int n, Collector fc) throws IOException {
-    return doSearch(searcher, after, q, n, null, false, false, fc);
+    return doSearch(searcher, after, q, n, null, false, fc);
   }
 
   /** Utility method, to search and also collect all hits
@@ -189,20 +189,20 @@ public class FacetsCollector extends SimpleCollector implements Collector {
     if (sort == null) {
       throw new IllegalArgumentException("sort must not be null");
     }
-    return doSearch(searcher, after, q, n, sort, false, false, fc);
+    return doSearch(searcher, after, q, n, sort, false, fc);
   }
 
   /** Utility method, to search and also collect all hits
    *  into the provided {@link Collector}. */
-  public static TopDocs searchAfter(IndexSearcher searcher, ScoreDoc after, Query q, int n, Sort sort, boolean doDocScores, boolean doMaxScore, Collector fc) throws IOException {
+  public static TopDocs searchAfter(IndexSearcher searcher, ScoreDoc after, Query q, int n, Sort sort, boolean doDocScores, Collector fc) throws IOException {
     if (sort == null) {
       throw new IllegalArgumentException("sort must not be null");
     }
-    return doSearch(searcher, after, q, n, sort, doDocScores, doMaxScore, fc);
+    return doSearch(searcher, after, q, n, sort, doDocScores, fc);
   }
 
   private static TopDocs doSearch(IndexSearcher searcher, ScoreDoc after, Query q, int n, Sort sort,
-                                  boolean doDocScores, boolean doMaxScore, Collector fc) throws IOException {
+                                  boolean doDocScores, Collector fc) throws IOException {
 
     int limit = searcher.getIndexReader().maxDoc();
     if (limit == 0) {
@@ -219,7 +219,7 @@ public class FacetsCollector extends SimpleCollector implements Collector {
     if (n==0) {
       TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector();
       searcher.search(q, MultiCollector.wrap(totalHitCountCollector, fc));
-      topDocs = new TopDocs(totalHitCountCollector.getTotalHits(), new ScoreDoc[0], Float.NaN);
+      topDocs = new TopDocs(totalHitCountCollector.getTotalHits(), new ScoreDoc[0]);
     } else {
       TopDocsCollector<?> hitsCollector;
       if (sort != null) {
@@ -233,7 +233,6 @@ public class FacetsCollector extends SimpleCollector implements Collector {
                                                  (FieldDoc) after,
                                                  fillFields,
                                                  doDocScores,
-                                                 doMaxScore,
                                                  true); // TODO: can we disable exact hit counts
       } else {
         hitsCollector = TopScoreDocCollector.create(n, after, true);
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways.java b/lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways.java
index c632f3a..45a0aa2 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/TestDrillSideways.java
@@ -813,7 +813,7 @@ public class TestDrillSideways extends FacetTestCase {
       }
 
       // Retrieve all facets:
-      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true, true);
+      DrillSidewaysResult actual = ds.search(ddq, filter, null, numDocs, sort, true);
 
       TopDocs hits = s.search(baseQuery, numDocs);
       Map<String, Float> scores = new HashMap<>();
@@ -1145,8 +1145,7 @@ public class TestDrillSideways extends FacetTestCase {
     DrillSidewaysResult r = ds.search(ddq, 10); // this used to fail on IllegalArgEx
     assertEquals(0, r.hits.totalHits);
 
-    r = ds.search(ddq, null, null, 10, new Sort(new SortField("foo", SortField.Type.INT)), false,
-            false); // this used to fail on IllegalArgEx
+    r = ds.search(ddq, null, null, 10, new Sort(new SortField("foo", SortField.Type.INT)), false); // this used to fail on IllegalArgEx
     assertEquals(0, r.hits.totalHits);
 
     writer.close();
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetSumValueSource.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetSumValueSource.java
index 2af9925..5bc8472 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetSumValueSource.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyFacetSumValueSource.java
@@ -261,7 +261,7 @@ public class TestTaxonomyFacetSumValueSource extends FacetTestCase {
 
     Facets facets = new TaxonomyFacetSumValueSource(taxoReader, config, fc, DoubleValuesSource.SCORES);
     
-    int expected = (int) (td.getMaxScore() * td.totalHits);
+    int expected = (int) (csq.getBoost() * td.totalHits);
     assertEquals(expected, facets.getSpecificValue("dim", "a").intValue());
 
     iw.close();
diff --git a/lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector.java b/lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector.java
index d915eb9..f627adf 100644
--- a/lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector.java
+++ b/lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector.java
@@ -306,9 +306,10 @@ public class BlockGroupingCollector extends SimpleCollector {
         collector = TopScoreDocCollector.create(maxDocsPerGroup);
       } else {
         // Sort by fields
-        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true); // TODO: disable exact counts?
+        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, true); // TODO: disable exact counts?
       }
 
+      float groupMaxScore = needsScores ? Float.NEGATIVE_INFINITY : Float.NaN;
       LeafCollector leafCollector = collector.getLeafCollector(og.readerContext);
       leafCollector.setScorer(fakeScorer);
       for(int docIDX=0;docIDX<og.count;docIDX++) {
@@ -316,6 +317,7 @@ public class BlockGroupingCollector extends SimpleCollector {
         fakeScorer.doc = doc;
         if (needsScores) {
           fakeScorer.score = og.scores[docIDX];
+          groupMaxScore = Math.max(groupMaxScore, fakeScorer.score);
         }
         leafCollector.collect(doc);
       }
@@ -337,12 +339,12 @@ public class BlockGroupingCollector extends SimpleCollector {
       // TODO: we could aggregate scores across children
       // by Sum/Avg instead of passing NaN:
       groups[downTo] = new GroupDocs<>(Float.NaN,
-                                             topDocs.getMaxScore(),
+                                             groupMaxScore,
                                              og.count,
                                              topDocs.scoreDocs,
                                              null,
                                              groupSortValues);
-      maxScore = Math.max(maxScore, topDocs.getMaxScore());
+      maxScore = Math.max(maxScore, groupMaxScore);
     }
 
     /*
diff --git a/lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups.java b/lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups.java
index 36ab8d9..c87dd0d 100644
--- a/lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups.java
+++ b/lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroups.java
@@ -161,13 +161,11 @@ public class TopGroups<T> {
 
         if (docSort.equals(Sort.RELEVANCE)) {
           shardTopDocs[shardIDX] = new TopDocs(shardGroupDocs.totalHits,
-                                               shardGroupDocs.scoreDocs,
-                                               shardGroupDocs.maxScore);
+                                               shardGroupDocs.scoreDocs);
         } else {
           shardTopDocs[shardIDX] = new TopFieldDocs(shardGroupDocs.totalHits,
               shardGroupDocs.scoreDocs,
-              docSort.getSort(),
-              shardGroupDocs.maxScore);
+              docSort.getSort());
         }
         maxScore = Math.max(maxScore, shardGroupDocs.maxScore);
         totalHits += shardGroupDocs.totalHits;
diff --git a/lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroupsCollector.java b/lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroupsCollector.java
index 7e41a6c..eb75366 100644
--- a/lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroupsCollector.java
+++ b/lucene/grouping/src/java/org/apache/lucene/search/grouping/TopGroupsCollector.java
@@ -17,15 +17,23 @@
 
 package org.apache.lucene.search.grouping;
 
+import java.io.IOException;
 import java.util.Collection;
 import java.util.Objects;
 import java.util.function.Supplier;
 
+import org.apache.lucene.search.FilterCollector;
+import org.apache.lucene.search.MultiCollector;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.ScoreMode;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.SimpleCollector;
 import org.apache.lucene.search.Sort;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.TopDocsCollector;
 import org.apache.lucene.search.TopFieldCollector;
 import org.apache.lucene.search.TopScoreDocCollector;
+import org.apache.lucene.util.ArrayUtil;
 
 /**
  * A second-pass collector that collects the TopDocs for each group, and
@@ -60,17 +68,64 @@ public class TopGroupsCollector<T> extends SecondPassGroupingCollector<T> {
 
   }
 
-  private static class TopDocsReducer<T> extends GroupReducer<T, TopDocsCollector<?>> {
+  private static class MaxScoreCollector extends SimpleCollector {
+    private Scorer scorer;
+    private float maxScore = Float.MIN_VALUE;
+    private boolean collectedAnyHits = false;
 
-    private final Supplier<TopDocsCollector<?>> supplier;
+    public MaxScoreCollector() {}
+
+    public float getMaxScore() {
+      return collectedAnyHits ? maxScore : Float.NaN;
+    }
+
+    @Override
+    public ScoreMode scoreMode() {
+      return ScoreMode.COMPLETE;
+    }
+
+    @Override
+    public void setScorer(Scorer scorer) {
+      this.scorer = scorer;
+    }
+
+    @Override
+    public void collect(int doc) throws IOException {
+      collectedAnyHits = true;
+      maxScore = Math.max(scorer.score(), maxScore);
+    }
+  }
+
+  private static class TopDocsAndMaxScoreCollector extends FilterCollector {
+    private final TopDocsCollector<?> topDocsCollector;
+    private final MaxScoreCollector maxScoreCollector;
+    private final boolean sortedByScore;
+    
+    public TopDocsAndMaxScoreCollector(boolean sortedByScore, TopDocsCollector<?> topDocsCollector, MaxScoreCollector maxScoreCollector) {
+      super(MultiCollector.wrap(topDocsCollector, maxScoreCollector));
+      this.sortedByScore = sortedByScore;
+      this.topDocsCollector = topDocsCollector;
+      this.maxScoreCollector = maxScoreCollector;
+    }
+  }
+
+  private static class TopDocsReducer<T> extends GroupReducer<T, TopDocsAndMaxScoreCollector> {
+
+    private final Supplier<TopDocsAndMaxScoreCollector> supplier;
     private final boolean needsScores;
 
     TopDocsReducer(Sort withinGroupSort,
                    int maxDocsPerGroup, boolean getScores, boolean getMaxScores, boolean fillSortFields) {
       this.needsScores = getScores || getMaxScores || withinGroupSort.needsScores();
-      this.supplier = withinGroupSort == Sort.RELEVANCE ?
-          () -> TopScoreDocCollector.create(maxDocsPerGroup) :
-          () -> TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, getScores, getMaxScores, true); // TODO: disable exact counts?
+      if (withinGroupSort == Sort.RELEVANCE) {
+        supplier = () -> new TopDocsAndMaxScoreCollector(true, TopScoreDocCollector.create(maxDocsPerGroup), null);
+      } else {
+        supplier = () -> {
+          TopFieldCollector topDocsCollector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, getScores, true); // TODO: disable exact counts?
+          MaxScoreCollector maxScoreCollector = getMaxScores ? new MaxScoreCollector() : null;
+          return new TopDocsAndMaxScoreCollector(false, topDocsCollector, maxScoreCollector);
+        };
+      }
     }
 
     @Override
@@ -79,7 +134,7 @@ public class TopGroupsCollector<T> extends SecondPassGroupingCollector<T> {
     }
 
     @Override
-    protected TopDocsCollector<?> newCollector() {
+    protected TopDocsAndMaxScoreCollector newCollector() {
       return supplier.get();
     }
   }
@@ -95,15 +150,33 @@ public class TopGroupsCollector<T> extends SecondPassGroupingCollector<T> {
     int groupIDX = 0;
     float maxScore = Float.MIN_VALUE;
     for(SearchGroup<T> group : groups) {
-      TopDocsCollector<?> collector = (TopDocsCollector<?>) groupReducer.getCollector(group.groupValue);
-      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);
+      TopDocsAndMaxScoreCollector collector = (TopDocsAndMaxScoreCollector) groupReducer.getCollector(group.groupValue);
+      final TopDocs topDocs;
+      final float groupMaxScore;
+      if (collector.sortedByScore) {
+        TopDocs allTopDocs = collector.topDocsCollector.topDocs();
+        groupMaxScore = allTopDocs.scoreDocs.length == 0 ? Float.NaN : allTopDocs.scoreDocs[0].score;
+        if (allTopDocs.scoreDocs.length <= withinGroupOffset) {
+          topDocs = new TopDocs(allTopDocs.totalHits, new ScoreDoc[0]);
+        } else {
+          topDocs = new TopDocs(allTopDocs.totalHits, ArrayUtil.copyOfSubArray(allTopDocs.scoreDocs, withinGroupOffset, Math.min(allTopDocs.scoreDocs.length, withinGroupOffset + maxDocsPerGroup)));
+        }
+      } else {
+        topDocs = collector.topDocsCollector.topDocs(withinGroupOffset, maxDocsPerGroup);
+        if (collector.maxScoreCollector == null) {
+          groupMaxScore = Float.NaN;
+        } else {
+          groupMaxScore = collector.maxScoreCollector.getMaxScore();
+        }
+      }
+      
       groupDocsResult[groupIDX++] = new GroupDocs<>(Float.NaN,
-          topDocs.getMaxScore(),
+          groupMaxScore,
           topDocs.totalHits,
           topDocs.scoreDocs,
           group.groupValue,
           group.sortValues);
-      maxScore = Math.max(maxScore, topDocs.getMaxScore());
+      maxScore = Math.max(maxScore, groupMaxScore);
     }
 
     return new TopGroups<>(groupSort.getSort(),
diff --git a/lucene/highlighter/src/test/org/apache/lucene/search/uhighlight/TestUnifiedHighlighterStrictPhrases.java b/lucene/highlighter/src/test/org/apache/lucene/search/uhighlight/TestUnifiedHighlighterStrictPhrases.java
index b768382..44a8272 100644
--- a/lucene/highlighter/src/test/org/apache/lucene/search/uhighlight/TestUnifiedHighlighterStrictPhrases.java
+++ b/lucene/highlighter/src/test/org/apache/lucene/search/uhighlight/TestUnifiedHighlighterStrictPhrases.java
@@ -540,7 +540,7 @@ public class TestUnifiedHighlighterStrictPhrases extends LuceneTestCase {
     final String indexedText = "x y z x z x a";
     indexWriter.addDocument(newDoc(indexedText));
     initReaderSearcherHighlighter();
-    TopDocs topDocs = new TopDocs(1, new ScoreDoc[]{new ScoreDoc(0, 1f)}, 1f);
+    TopDocs topDocs = new TopDocs(1, new ScoreDoc[]{new ScoreDoc(0, 1f)});
 
     String expected = "<b>x</b> <b>y</b> <b>z</b> x z x <b>a</b>";
     Query q = new SpanNearQuery(new SpanQuery[] {
diff --git a/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java b/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
index cad709b..12c7915 100644
--- a/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
+++ b/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
@@ -1013,7 +1013,7 @@ public class TestBlockJoin extends LuceneTestCase {
   private void compareHits(IndexReader r, IndexReader joinR, TopDocs controlHits, Map<Integer, TopDocs> joinResults) throws Exception {
     int currentParentID = -1;
     int childHitSlot = 0;
-    TopDocs childHits = new TopDocs(0, new ScoreDoc[0], 0f);
+    TopDocs childHits = new TopDocs(0, new ScoreDoc[0]);
     for (ScoreDoc controlHit : controlHits.scoreDocs) {
       Document controlDoc = r.document(controlHit.doc);
       int parentID = Integer.parseInt(controlDoc.get("parentID"));
diff --git a/lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java b/lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java
index a0f86af..3f3ac7c 100644
--- a/lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java
+++ b/lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java
@@ -1287,7 +1287,6 @@ public class TestJoinUtil extends LuceneTestCase {
         System.out.printf(Locale.ENGLISH, "Expected score: %f | Actual score: %f\n", expectedTopDocs.scoreDocs[i].score, actualTopDocs.scoreDocs[i].score);
       }
     }
-    assertEquals(expectedTopDocs.getMaxScore(), actualTopDocs.getMaxScore(), 0.0f);
 
     for (int i = 0; i < expectedTopDocs.scoreDocs.length; i++) {
       assertEquals(expectedTopDocs.scoreDocs[i].doc, actualTopDocs.scoreDocs[i].doc);
@@ -1647,7 +1646,7 @@ public class TestJoinUtil extends LuceneTestCase {
       Map.Entry<Integer,JoinScore> hit = hits.get(i);
       scoreDocs[i] = new ScoreDoc(hit.getKey(), hit.getValue().score(scoreMode));
     }
-    return new TopDocs(hits.size(), scoreDocs, hits.isEmpty() ? Float.NaN : hits.get(0).getValue().score(scoreMode));
+    return new TopDocs(hits.size(), scoreDocs);
   }
 
   private BitSet createExpectedResult(String queryValue, boolean from, IndexReader topLevelReader, IndexIterationContext context) throws IOException {
diff --git a/lucene/join/src/test/org/apache/lucene/search/join/TestParentChildrenBlockJoinQuery.java b/lucene/join/src/test/org/apache/lucene/search/join/TestParentChildrenBlockJoinQuery.java
index fe849cb..f6cc6d9 100644
--- a/lucene/join/src/test/org/apache/lucene/search/join/TestParentChildrenBlockJoinQuery.java
+++ b/lucene/join/src/test/org/apache/lucene/search/join/TestParentChildrenBlockJoinQuery.java
@@ -88,7 +88,6 @@ public class TestParentChildrenBlockJoinQuery extends LuceneTestCase {
       TopDocs topDocs = searcher.search(parentChildrenBlockJoinQuery, maxChildDocsPerParent);
       assertEquals(expectedChildDocs, topDocs.totalHits);
       if (expectedChildDocs > 0) {
-        assertEquals(expectedChildDocs, topDocs.getMaxScore(), 0);
         for (int i = 0; i < topDocs.scoreDocs.length; i++) {
           ScoreDoc childScoreDoc = topDocs.scoreDocs[i];
           assertEquals(expectedChildDocs - i, childScoreDoc.score, 0);
diff --git a/lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector.java b/lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector.java
index dbe4324..bd4978d 100644
--- a/lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector.java
+++ b/lucene/misc/src/java/org/apache/lucene/search/DiversifiedTopDocsCollector.java
@@ -92,21 +92,7 @@ public abstract class DiversifiedTopDocsCollector extends
       return EMPTY_TOPDOCS;
     }
 
-    // We need to compute maxScore in order to set it in TopDocs. If start == 0,
-    // it means the largest element is already in results, use its score as
-    // maxScore. Otherwise pop everything else, until the largest element is
-    // extracted and use its score as maxScore.
-    float maxScore = Float.NaN;
-    if (start == 0) {
-      maxScore = results[0].score;
-    } else {
-      for (int i = globalQueue.size(); i > 1; i--) {
-        globalQueue.pop();
-      }
-      maxScore = globalQueue.pop().score;
-    }
-
-    return new TopDocs(totalHits, results, maxScore);
+    return new TopDocs(totalHits, results);
   }
 
   protected ScoreDocKey insert(ScoreDocKey addition, int docBase,
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/function/TestIndexReaderFunctions.java b/lucene/queries/src/test/org/apache/lucene/queries/function/TestIndexReaderFunctions.java
index ea21074..5223a4b 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/function/TestIndexReaderFunctions.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/function/TestIndexReaderFunctions.java
@@ -180,7 +180,7 @@ public class TestIndexReaderFunctions extends LuceneTestCase {
       expected[i] = new ScoreDoc(i, scores[i]);
     }
     TopDocs docs = searcher.search(q, documents.size(),
-        new Sort(new SortField("id", SortField.Type.STRING)), true, false);
+        new Sort(new SortField("id", SortField.Type.STRING)), true);
     CheckHits.checkHits(random(), q, "", searcher, expectedDocs);
     CheckHits.checkHitsQuery(q, expected, docs.scoreDocs, expectedDocs);
     CheckHits.checkExplanations(q, "", searcher);
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/function/TestValueSources.java b/lucene/queries/src/test/org/apache/lucene/queries/function/TestValueSources.java
index b12f026..1d7fefb 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/function/TestValueSources.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/function/TestValueSources.java
@@ -648,7 +648,7 @@ public class TestValueSources extends LuceneTestCase {
       expected[i] = new ScoreDoc(i, scores[i]);
     }
     TopDocs docs = searcher.search(q, documents.size(),
-        new Sort(new SortField("id", SortField.Type.STRING)), true, false);
+        new Sort(new SortField("id", SortField.Type.STRING)), true);
     CheckHits.checkHits(random(), q, "", searcher, expectedDocs);
     CheckHits.checkHitsQuery(q, expected, docs.scoreDocs, expectedDocs);
     CheckHits.checkExplanations(q, "", searcher);
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java
index 9621e1e..f22793c 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java
@@ -158,7 +158,6 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     //they should all have the exact same score, because they all contain seventy once, and we set
     //all the other similarity factors to be 1
 
-    assertTrue(hits.getMaxScore() + " does not equal: " + 1, hits.getMaxScore() == 1);
     for (int i = 0; i < hits.scoreDocs.length; i++) {
       ScoreDoc doc = hits.scoreDocs[i];
       assertTrue(doc.score + " does not equal: " + 1, doc.score == 1);
@@ -200,7 +199,6 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     //all the other similarity factors to be 1
 
     //System.out.println("Hash: " + seventyHash + " Twice Hash: " + 2*seventyHash);
-    assertTrue(hits.getMaxScore() + " does not equal: " + 4.0, hits.getMaxScore() == 4.0);
     //there should be exactly 10 items that score a 4, all the rest should score a 2
     //The 10 items are: 70 + i*100 where i in [0-9]
     int numTens = 0;
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor.java b/lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor.java
index 90a80b6..80a5e7d 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor.java
@@ -378,6 +378,6 @@ public class FloatPointNearestNeighbor {
       NearestHit hit = hits[i];
       scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] { (float)Math.sqrt(hit.distanceSquared) });
     }
-    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);
+    return new TopFieldDocs(totalHits, scoreDocs, null);
   }
 }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint.java
index 1e5e4bd..7b45c6b 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint.java
@@ -330,6 +330,6 @@ public class LatLonPoint extends Field {
       NearestNeighbor.NearestHit hit = hits[i];
       scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});
     }
-    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);
+    return new TopFieldDocs(totalHits, scoreDocs, null);
   }
 }
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java
index 85bb6d1..ad76224 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java
@@ -647,7 +647,7 @@ public class AnalyzingInfixSuggester extends Lookup implements Closeable {
     //System.out.println("finalQuery=" + finalQuery);
 
     // Sort by weight, descending:
-    TopFieldCollector c = TopFieldCollector.create(SORT, num, true, false, false, false);
+    TopFieldCollector c = TopFieldCollector.create(SORT, num, true, false, false);
     List<LookupResult> results = null;
     SearcherManager mgr;
     IndexSearcher searcher;
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/document/TopSuggestDocs.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/document/TopSuggestDocs.java
index 1ffcbdc..ec76ce0 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/document/TopSuggestDocs.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/document/TopSuggestDocs.java
@@ -31,7 +31,7 @@ public class TopSuggestDocs extends TopDocs {
   /**
    * Singleton for empty {@link TopSuggestDocs}
    */
-  public final static TopSuggestDocs EMPTY = new TopSuggestDocs(0, new SuggestScoreDoc[0], 0);
+  public final static TopSuggestDocs EMPTY = new TopSuggestDocs(0, new SuggestScoreDoc[0]);
 
   /**
    * {@link org.apache.lucene.search.ScoreDoc} with an
@@ -92,8 +92,8 @@ public class TopSuggestDocs extends TopDocs {
    * {@link TopSuggestDocs.SuggestScoreDoc}
    * instead of {@link org.apache.lucene.search.ScoreDoc}
    */
-  public TopSuggestDocs(int totalHits, SuggestScoreDoc[] scoreDocs, float maxScore) {
-    super(totalHits, scoreDocs, maxScore);
+  public TopSuggestDocs(int totalHits, SuggestScoreDoc[] scoreDocs) {
+    super(totalHits, scoreDocs);
   }
 
   /**
@@ -124,7 +124,7 @@ public class TopSuggestDocs extends TopDocs {
     }
     SuggestScoreDoc[] topNResults = priorityQueue.getResults();
     if (topNResults.length > 0) {
-      return new TopSuggestDocs(topNResults.length, topNResults, topNResults[0].score);
+      return new TopSuggestDocs(topNResults.length, topNResults);
     } else {
       return TopSuggestDocs.EMPTY;
     }
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/document/TopSuggestDocsCollector.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/document/TopSuggestDocsCollector.java
index 90db227..1eae018 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/document/TopSuggestDocsCollector.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/document/TopSuggestDocsCollector.java
@@ -177,7 +177,7 @@ public class TopSuggestDocsCollector extends SimpleCollector {
     }
 
     if (suggestScoreDocs.length > 0) {
-      return new TopSuggestDocs(suggestScoreDocs.length, suggestScoreDocs, suggestScoreDocs[0].score);
+      return new TopSuggestDocs(suggestScoreDocs.length, suggestScoreDocs);
     } else {
       return TopSuggestDocs.EMPTY;
     }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/TestUtil.java b/lucene/test-framework/src/java/org/apache/lucene/util/TestUtil.java
index d8960a1..537731e 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/TestUtil.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/TestUtil.java
@@ -1042,7 +1042,6 @@ public final class TestUtil {
 
   public static void assertEquals(TopDocs expected, TopDocs actual) {
     Assert.assertEquals("wrong total hits", expected.totalHits, actual.totalHits);
-    Assert.assertEquals("wrong maxScore", expected.getMaxScore(), actual.getMaxScore(), 0.0);
     Assert.assertEquals("wrong hit count", expected.scoreDocs.length, actual.scoreDocs.length);
     for(int hitIDX=0;hitIDX<expected.scoreDocs.length;hitIDX++) {
       final ScoreDoc expectedSD = expected.scoreDocs[hitIDX];
diff --git a/solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer.java b/solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer.java
index b6e46cf..30d4c82 100644
--- a/solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer.java
+++ b/solr/contrib/ltr/src/java/org/apache/solr/ltr/LTRRescorer.java
@@ -135,7 +135,7 @@ public class LTRRescorer extends Rescorer {
       }
     });
 
-    return new TopDocs(firstPassTopDocs.totalHits, reranked, reranked[0].score);
+    return new TopDocs(firstPassTopDocs.totalHits, reranked);
   }
 
   public void scoreFeatures(IndexSearcher indexSearcher, TopDocs firstPassTopDocs,
diff --git a/solr/contrib/ltr/src/test/org/apache/solr/ltr/TestLTRReRankingPipeline.java b/solr/contrib/ltr/src/test/org/apache/solr/ltr/TestLTRReRankingPipeline.java
index de97894..875be66 100644
--- a/solr/contrib/ltr/src/test/org/apache/solr/ltr/TestLTRReRankingPipeline.java
+++ b/solr/contrib/ltr/src/test/org/apache/solr/ltr/TestLTRReRankingPipeline.java
@@ -245,7 +245,7 @@ public class TestLTRReRankingPipeline extends LuceneTestCase {
 
       final ScoreDoc[] slice = new ScoreDoc[topN];
       System.arraycopy(hits.scoreDocs, 0, slice, 0, topN);
-      hits = new TopDocs(hits.totalHits, slice, hits.getMaxScore());
+      hits = new TopDocs(hits.totalHits, slice);
       hits = rescorer.rescore(searcher, hits, topN);
       for (int i = topN - 1, j = 0; i >= 0; i--, j++) {
         log.info("doc {} in pos {}", searcher.doc(hits.scoreDocs[j].doc)
diff --git a/solr/core/src/java/org/apache/solr/handler/component/ExpandComponent.java b/solr/core/src/java/org/apache/solr/handler/component/ExpandComponent.java
index 9ffea4b..e7b5433 100644
--- a/solr/core/src/java/org/apache/solr/handler/component/ExpandComponent.java
+++ b/solr/core/src/java/org/apache/solr/handler/component/ExpandComponent.java
@@ -437,7 +437,7 @@ public class ExpandComponent extends SearchComponent implements PluginInfoInitia
           docs[i] = scoreDoc.doc;
           scores[i] = scoreDoc.score;
         }
-        DocSlice slice = new DocSlice(0, docs.length, docs, scores, topDocs.totalHits, topDocs.getMaxScore());
+        DocSlice slice = new DocSlice(0, docs.length, docs, scores, topDocs.totalHits, Float.NaN);
 
         if(fieldType instanceof StrField) {
           final BytesRef bytesRef = ordBytes.get((int)groupValue);
@@ -535,7 +535,7 @@ public class ExpandComponent extends SearchComponent implements PluginInfoInitia
       DocIdSetIterator iterator = new BitSetIterator(groupBits, 0); // cost is not useful here
       int group;
       while ((group = iterator.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
-        Collector collector = (sort == null) ? TopScoreDocCollector.create(limit) : TopFieldCollector.create(sort, limit, false, false, false, true);
+        Collector collector = (sort == null) ? TopScoreDocCollector.create(limit) : TopFieldCollector.create(sort, limit, false, false, true);
         groups.put(group, collector);
       }
 
@@ -619,7 +619,7 @@ public class ExpandComponent extends SearchComponent implements PluginInfoInitia
       Iterator<LongCursor> iterator = groupSet.iterator();
       while (iterator.hasNext()) {
         LongCursor cursor = iterator.next();
-        Collector collector = (sort == null) ? TopScoreDocCollector.create(limit) : TopFieldCollector.create(sort, limit, false, false, false, true);
+        Collector collector = (sort == null) ? TopScoreDocCollector.create(limit) : TopFieldCollector.create(sort, limit, false, false, true);
         groups.put(cursor.value, collector);
       }
 
diff --git a/solr/core/src/java/org/apache/solr/search/ExportQParserPlugin.java b/solr/core/src/java/org/apache/solr/search/ExportQParserPlugin.java
index dbaf3db..64464d4 100644
--- a/solr/core/src/java/org/apache/solr/search/ExportQParserPlugin.java
+++ b/solr/core/src/java/org/apache/solr/search/ExportQParserPlugin.java
@@ -180,7 +180,7 @@ public class ExportQParserPlugin extends QParserPlugin {
 
       ScoreDoc[] scoreDocs = getScoreDocs(howMany);
       assert scoreDocs.length <= totalHits;
-      return new TopDocs(totalHits, scoreDocs, 0.0f);
+      return new TopDocs(totalHits, scoreDocs);
     }
 
     @Override
diff --git a/solr/core/src/java/org/apache/solr/search/Grouping.java b/solr/core/src/java/org/apache/solr/search/Grouping.java
index 4500464..fff536d 100644
--- a/solr/core/src/java/org/apache/solr/search/Grouping.java
+++ b/solr/core/src/java/org/apache/solr/search/Grouping.java
@@ -834,6 +834,7 @@ public class Grouping {
 
     public Query query;
     TopDocsCollector topCollector;
+    MaxScoreCollector maxScoreCollector;
     FilterCollector collector;
 
     @Override
@@ -844,25 +845,37 @@ public class Grouping {
     @Override
     protected Collector createFirstPassCollector() throws IOException {
       DocSet groupFilt = searcher.getDocSet(query);
-      topCollector = newCollector(withinGroupSort, needScores);
-      collector = new FilterCollector(groupFilt, topCollector);
-      return collector;
-    }
-
-    TopDocsCollector newCollector(Sort sort, boolean needScores) throws IOException {
       int groupDocsToCollect = getMax(groupOffset, docsPerGroup, maxDoc);
-      if (sort == null || sort.equals(Sort.RELEVANCE)) {
-        return TopScoreDocCollector.create(groupDocsToCollect);
+      Collector subCollector;
+      if (withinGroupSort == null || withinGroupSort.equals(Sort.RELEVANCE)) {
+        subCollector = topCollector = TopScoreDocCollector.create(groupDocsToCollect);
       } else {
-        return TopFieldCollector.create(searcher.weightSort(sort), groupDocsToCollect, false, needScores, needScores, true);
+        topCollector = TopFieldCollector.create(searcher.weightSort(withinGroupSort), groupDocsToCollect, false, needScores, true);
+        if (needScores) {
+          maxScoreCollector = new MaxScoreCollector();
+          subCollector = MultiCollector.wrap(topCollector, maxScoreCollector);
+        } else {
+          subCollector = topCollector;
+        }
       }
+      collector = new FilterCollector(groupFilt, subCollector);
+      return collector;
     }
 
     @Override
     protected void finish() throws IOException {
       TopDocsCollector topDocsCollector = (TopDocsCollector) collector.getDelegate();
       TopDocs topDocs = topDocsCollector.topDocs();
-      GroupDocs<String> groupDocs = new GroupDocs<>(Float.NaN, topDocs.getMaxScore(), topDocs.totalHits, topDocs.scoreDocs, query.toString(), null);
+      float maxScore;
+      if (withinGroupSort == null || withinGroupSort.equals(Sort.RELEVANCE)) {
+        maxScore = topDocs.scoreDocs.length == 0 ? Float.NaN : topDocs.scoreDocs[0].score;
+      } else if (needScores) {
+        maxScore = maxScoreCollector.getMaxScore();
+      } else {
+        maxScore = Float.NaN;
+      }
+      
+      GroupDocs<String> groupDocs = new GroupDocs<>(Float.NaN, maxScore, topDocs.totalHits, topDocs.scoreDocs, query.toString(), null);
       if (main) {
         mainResult = getDocList(groupDocs);
       } else {
diff --git a/solr/core/src/java/org/apache/solr/search/MaxScoreCollector.java b/solr/core/src/java/org/apache/solr/search/MaxScoreCollector.java
new file mode 100644
index 0000000..ed1ded7
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/search/MaxScoreCollector.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.search;
+
+import java.io.IOException;
+
+import org.apache.lucene.search.ScoreMode;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.SimpleCollector;
+
+public class MaxScoreCollector extends SimpleCollector {
+  private Scorer scorer;
+  private float maxScore = Float.MIN_VALUE;
+  private boolean collectedAnyHits = false;
+
+  public MaxScoreCollector() {}
+
+  public float getMaxScore() {
+    return collectedAnyHits ? maxScore : Float.NaN;
+  }
+
+  @Override
+  public ScoreMode scoreMode() {
+    return ScoreMode.COMPLETE;
+  }
+
+  @Override
+  public void setScorer(Scorer scorer) {
+    this.scorer = scorer;
+  }
+
+  @Override
+  public void collect(int doc) throws IOException {
+    collectedAnyHits = true;
+    maxScore = Math.max(scorer.score(), maxScore);
+  }
+}
diff --git a/solr/core/src/java/org/apache/solr/search/ReRankCollector.java b/solr/core/src/java/org/apache/solr/search/ReRankCollector.java
index a1689dd..a94a412 100644
--- a/solr/core/src/java/org/apache/solr/search/ReRankCollector.java
+++ b/solr/core/src/java/org/apache/solr/search/ReRankCollector.java
@@ -67,7 +67,7 @@ public class ReRankCollector extends TopDocsCollector {
     } else {
       sort = sort.rewrite(searcher);
       //scores are needed for Rescorer (regardless of whether sort needs it)
-      this.mainCollector = TopFieldCollector.create(sort, Math.max(this.reRankDocs, length), false, true, true, true);
+      this.mainCollector = TopFieldCollector.create(sort, Math.max(this.reRankDocs, length), false, true, true);
     }
     this.searcher = searcher;
     this.reRankQueryRescorer = reRankQueryRescorer;
@@ -118,7 +118,8 @@ public class ReRankCollector extends TopDocsCollector {
 
         IntIntHashMap boostedDocs = QueryElevationComponent.getBoostDocs((SolrIndexSearcher)searcher, boostedPriority, requestContext);
 
-        Arrays.sort(rescoredDocs.scoreDocs, new BoostedComp(boostedDocs, mainDocs.scoreDocs, rescoredDocs.getMaxScore()));
+        float maxScore = rescoredDocs.scoreDocs.length == 0 ? Float.NaN : rescoredDocs.scoreDocs[0].score;
+        Arrays.sort(rescoredDocs.scoreDocs, new BoostedComp(boostedDocs, mainDocs.scoreDocs, maxScore));
       }
 
       if(howMany == rescoredDocs.scoreDocs.length) {
diff --git a/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java b/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
index 44e12a7..122de2b 100644
--- a/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
+++ b/solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
@@ -1540,7 +1540,7 @@ public class SolrIndexSearcher extends IndexSearcher implements Closeable, SolrI
       // ... see comments in populateNextCursorMarkFromTopDocs for cache issues (SOLR-5595)
       final boolean fillFields = (null != cursor);
       final FieldDoc searchAfter = (null != cursor ? cursor.getSearchAfterFieldDoc() : null);
-      return TopFieldCollector.create(weightedSort, len, searchAfter, fillFields, needScores, needScores, true);
+      return TopFieldCollector.create(weightedSort, len, searchAfter, fillFields, needScores, true);
     }
   }
 
@@ -1617,14 +1617,19 @@ public class SolrIndexSearcher extends IndexSearcher implements Closeable, SolrI
       qr.setNextCursorMark(cmd.getCursorMark());
     } else {
       final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);
+      MaxScoreCollector maxScoreCollector = null;
       Collector collector = topCollector;
+      if ((cmd.getFlags() & GET_SCORES) != 0) {
+        maxScoreCollector = new MaxScoreCollector();
+        collector = MultiCollector.wrap(topCollector, maxScoreCollector);
+      }
       buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);
 
       totalHits = topCollector.getTotalHits();
       TopDocs topDocs = topCollector.topDocs(0, len);
       populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);
 
-      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;
+      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;
       nDocsReturned = topDocs.scoreDocs.length;
       ids = new int[nDocsReturned];
       scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;
@@ -1712,7 +1717,15 @@ public class SolrIndexSearcher extends IndexSearcher implements Closeable, SolrI
 
       final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);
       DocSetCollector setCollector = new DocSetCollector(maxDoc);
-      Collector collector = MultiCollector.wrap(topCollector, setCollector);
+      MaxScoreCollector maxScoreCollector = null;
+      List<Collector> collectors = new ArrayList<>(Arrays.asList(topCollector, setCollector));
+
+      if ((cmd.getFlags() & GET_SCORES) != 0) {
+        maxScoreCollector = new MaxScoreCollector();
+        collectors.add(maxScoreCollector);
+      }
+
+      Collector collector = MultiCollector.wrap(collectors);
 
       buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);
 
@@ -1723,7 +1736,7 @@ public class SolrIndexSearcher extends IndexSearcher implements Closeable, SolrI
 
       TopDocs topDocs = topCollector.topDocs(0, len);
       populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);
-      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;
+      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;
       nDocsReturned = topDocs.scoreDocs.length;
 
       ids = new int[nDocsReturned];
diff --git a/solr/core/src/java/org/apache/solr/search/grouping/distributed/command/QueryCommand.java b/solr/core/src/java/org/apache/solr/search/grouping/distributed/command/QueryCommand.java
index e8b61bc..321936b 100644
--- a/solr/core/src/java/org/apache/solr/search/grouping/distributed/command/QueryCommand.java
+++ b/solr/core/src/java/org/apache/solr/search/grouping/distributed/command/QueryCommand.java
@@ -19,6 +19,7 @@ package org.apache.solr.search.grouping.distributed.command;
 import org.apache.lucene.search.*;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.search.DocSet;
+import org.apache.solr.search.MaxScoreCollector;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.search.SyntaxError;
@@ -110,8 +111,9 @@ public class QueryCommand implements Command<QueryCommandResult> {
   private final boolean needScores;
   private final String queryString;
 
-  private TopDocsCollector collector;
+  private TopDocsCollector topDocsCollector;
   private FilterCollector filterCollector;
+  private MaxScoreCollector maxScoreCollector;
 
   private QueryCommand(Sort sort, Query query, int docsToCollect, boolean needScores, DocSet docSet, String queryString) {
     this.sort = sort;
@@ -124,18 +126,32 @@ public class QueryCommand implements Command<QueryCommandResult> {
 
   @Override
   public List<Collector> create() throws IOException {
+    Collector subCollector;
     if (sort == null || sort.equals(Sort.RELEVANCE)) {
-      collector = TopScoreDocCollector.create(docsToCollect);
+      subCollector = topDocsCollector = TopScoreDocCollector.create(docsToCollect);
     } else {
-      collector = TopFieldCollector.create(sort, docsToCollect, true, needScores, needScores, true);
+      topDocsCollector = TopFieldCollector.create(sort, docsToCollect, true, needScores, true);
+      if (needScores) {
+        maxScoreCollector = new MaxScoreCollector();
+        subCollector = MultiCollector.wrap(topDocsCollector, maxScoreCollector);
+      } else {
+        subCollector = topDocsCollector;
+      }
     }
-    filterCollector = new FilterCollector(docSet, collector);
+    filterCollector = new FilterCollector(docSet, subCollector);
     return Arrays.asList((Collector) filterCollector);
   }
 
   @Override
   public QueryCommandResult result() {
-    return new QueryCommandResult(collector.topDocs(), filterCollector.getMatches());
+    TopDocs topDocs = topDocsCollector.topDocs();
+    float maxScore;
+    if (sort == null) {
+      maxScore = topDocs.scoreDocs.length == 0 ? Float.NaN : topDocs.scoreDocs[0].score;
+    } else {
+      maxScore = maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore();
+    }
+    return new QueryCommandResult(topDocs, filterCollector.getMatches(), maxScore);
   }
 
   @Override
diff --git a/solr/core/src/java/org/apache/solr/search/grouping/distributed/command/QueryCommandResult.java b/solr/core/src/java/org/apache/solr/search/grouping/distributed/command/QueryCommandResult.java
index 8114a46..391ecfa 100644
--- a/solr/core/src/java/org/apache/solr/search/grouping/distributed/command/QueryCommandResult.java
+++ b/solr/core/src/java/org/apache/solr/search/grouping/distributed/command/QueryCommandResult.java
@@ -25,10 +25,12 @@ public class QueryCommandResult {
 
   private final TopDocs topDocs;
   private final int matches;
+  private final float maxScore;
 
-  public QueryCommandResult(TopDocs topDocs, int matches) {
+  public QueryCommandResult(TopDocs topDocs, int matches, float maxScore) {
     this.topDocs = topDocs;
     this.matches = matches;
+    this.maxScore = maxScore;
   }
 
   public TopDocs getTopDocs() {
@@ -38,4 +40,8 @@ public class QueryCommandResult {
   public int getMatches() {
     return matches;
   }
+
+  public float getMaxScore() {
+    return maxScore;
+  }
 }
diff --git a/solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor.java b/solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor.java
index d05be0d..e2dd299 100644
--- a/solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor.java
+++ b/solr/core/src/java/org/apache/solr/search/grouping/distributed/responseprocessor/TopGroupsShardResponseProcessor.java
@@ -137,7 +137,7 @@ public class TopGroupsShardResponseProcessor implements ShardResponseProcessor {
         QueryCommandResult queryCommandResult = (QueryCommandResult) result.get(query);
         if (individualShardInfo != null) { // keep track of this when shards.info=true
           numFound += queryCommandResult.getMatches();
-          float thisMax = queryCommandResult.getTopDocs().getMaxScore();
+          float thisMax = queryCommandResult.getMaxScore();
           if (Float.isNaN(maxScore) || thisMax > maxScore) maxScore = thisMax;
         }
         commandTopDocs.get(query).add(queryCommandResult);
@@ -168,9 +168,17 @@ public class TopGroupsShardResponseProcessor implements ShardResponseProcessor {
       List<QueryCommandResult> queryCommandResults = commandTopDocs.get(query);
       List<TopDocs> topDocs = new ArrayList<>(queryCommandResults.size());
       int mergedMatches = 0;
+      float maxScore = Float.NaN;
       for (QueryCommandResult queryCommandResult : queryCommandResults) {
-        topDocs.add(queryCommandResult.getTopDocs());
+        TopDocs thisTopDocs = queryCommandResult.getTopDocs();
+        topDocs.add(thisTopDocs);
         mergedMatches += queryCommandResult.getMatches();
+        if (thisTopDocs.scoreDocs.length > 0) {
+          float thisMaxScore = queryCommandResult.getMaxScore();
+          if (Float.isNaN(maxScore) || thisMaxScore > maxScore) {
+            maxScore = thisMaxScore;
+          }
+        }
       }
 
       int topN = rb.getGroupingSpec().getOffset() + rb.getGroupingSpec().getLimit();
@@ -180,7 +188,7 @@ public class TopGroupsShardResponseProcessor implements ShardResponseProcessor {
       } else {
         mergedTopDocs = TopDocs.merge(withinGroupSort, topN, topDocs.toArray(new TopFieldDocs[topDocs.size()]));
       }
-      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches));
+      rb.mergedQueryCommandResults.put(query, new QueryCommandResult(mergedTopDocs, mergedMatches, maxScore));
     }
 
     Map<Object, ShardDoc> resultIds = new HashMap<>();
diff --git a/solr/core/src/java/org/apache/solr/search/grouping/distributed/shardresultserializer/TopGroupsResultTransformer.java b/solr/core/src/java/org/apache/solr/search/grouping/distributed/shardresultserializer/TopGroupsResultTransformer.java
index 8d2b3dc..a5ce1ff 100644
--- a/solr/core/src/java/org/apache/solr/search/grouping/distributed/shardresultserializer/TopGroupsResultTransformer.java
+++ b/solr/core/src/java/org/apache/solr/search/grouping/distributed/shardresultserializer/TopGroupsResultTransformer.java
@@ -108,11 +108,11 @@ public class TopGroupsResultTransformer implements ShardResultTransformer<List<C
         ScoreDoc[] scoreDocs = transformToNativeShardDoc(documents, groupSort, shard, schema);
         final TopDocs topDocs;
         if (withinGroupSort.equals(Sort.RELEVANCE)) {
-          topDocs = new TopDocs(totalHits.longValue(), scoreDocs, maxScore);
+          topDocs = new TopDocs(totalHits.longValue(), scoreDocs);
         } else {
-          topDocs = new TopFieldDocs(totalHits.longValue(), scoreDocs, withinGroupSort.getSort(), maxScore);
+          topDocs = new TopFieldDocs(totalHits.longValue(), scoreDocs, withinGroupSort.getSort());
         }
-        result.put(key, new QueryCommandResult(topDocs, matches));
+        result.put(key, new QueryCommandResult(topDocs, matches, maxScore));
         continue;
       }
 
@@ -242,8 +242,8 @@ public class TopGroupsResultTransformer implements ShardResultTransformer<List<C
     queryResult.add("matches", result.getMatches());
     queryResult.add("totalHits", result.getTopDocs().totalHits);
     // debug: assert !Float.isNaN(result.getTopDocs().getMaxScore()) == rb.getGroupingSpec().isNeedScore();
-    if (!Float.isNaN(result.getTopDocs().getMaxScore())) {
-      queryResult.add("maxScore", result.getTopDocs().getMaxScore());
+    if (!Float.isNaN(result.getMaxScore())) {
+      queryResult.add("maxScore", result.getMaxScore());
     }
     List<NamedList> documents = new ArrayList<>();
     queryResult.add("documents", documents);
diff --git a/solr/core/src/java/org/apache/solr/search/grouping/endresulttransformer/GroupedEndResultTransformer.java b/solr/core/src/java/org/apache/solr/search/grouping/endresulttransformer/GroupedEndResultTransformer.java
index b060590..6c9372c 100644
--- a/solr/core/src/java/org/apache/solr/search/grouping/endresulttransformer/GroupedEndResultTransformer.java
+++ b/solr/core/src/java/org/apache/solr/search/grouping/endresulttransformer/GroupedEndResultTransformer.java
@@ -91,8 +91,8 @@ public class GroupedEndResultTransformer implements EndResultTransformer {
         command.add("matches", queryCommandResult.getMatches());
         SolrDocumentList docList = new SolrDocumentList();
         docList.setNumFound(queryCommandResult.getTopDocs().totalHits);
-        if (!Float.isNaN(queryCommandResult.getTopDocs().getMaxScore())) {
-          docList.setMaxScore(queryCommandResult.getTopDocs().getMaxScore());
+        if (!Float.isNaN(queryCommandResult.getMaxScore())) {
+          docList.setMaxScore(queryCommandResult.getMaxScore());
         }
         docList.setStart(rb.getGroupingSpec().getWithinGroupOffset());
         for (ScoreDoc scoreDoc :queryCommandResult.getTopDocs().scoreDocs){
diff --git a/solr/core/src/test/org/apache/solr/search/TestRankQueryPlugin.java b/solr/core/src/test/org/apache/solr/search/TestRankQueryPlugin.java
index 6d2143a..f72fd56 100644
--- a/solr/core/src/test/org/apache/solr/search/TestRankQueryPlugin.java
+++ b/solr/core/src/test/org/apache/solr/search/TestRankQueryPlugin.java
@@ -723,7 +723,7 @@ public class TestRankQueryPlugin extends QParserPlugin {
         }
       });
       ScoreDoc[] scoreDocs = list.toArray(new ScoreDoc[list.size()]);
-      return new TopDocs(list.size(), scoreDocs, 0.0f);
+      return new TopDocs(list.size(), scoreDocs);
     }
 
     public TopDocs topDocs(int start, int len) {
@@ -785,7 +785,7 @@ public class TestRankQueryPlugin extends QParserPlugin {
         }
       });
       ScoreDoc[] scoreDocs = list.toArray(new ScoreDoc[list.size()]);
-      return new TopDocs(list.size(), scoreDocs, 0.0f);
+      return new TopDocs(list.size(), scoreDocs);
     }
 
     public TopDocs topDocs(int start, int len) {
diff --git a/solr/core/src/test/org/apache/solr/search/TestSort.java b/solr/core/src/test/org/apache/solr/search/TestSort.java
index 03365b4..abfbe8a 100644
--- a/solr/core/src/test/org/apache/solr/search/TestSort.java
+++ b/solr/core/src/test/org/apache/solr/search/TestSort.java
@@ -283,9 +283,8 @@ public class TestSort extends SolrTestCaseJ4 {
         final String nullRep2 = luceneSort2 || sortMissingFirst2 && !reverse2 || sortMissingLast2 && reverse2 ? "" : "zzz";
 
         boolean trackScores = r.nextBoolean();
-        boolean trackMaxScores = r.nextBoolean();
         boolean scoreInOrder = r.nextBoolean();
-        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, trackMaxScores, true);
+        final TopFieldCollector topCollector = TopFieldCollector.create(sort, top, true, trackScores, true);
 
         final List<MyDoc> collectedDocs = new ArrayList<>();
         // delegate and collect docs ourselves
diff --git a/solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSort.java b/solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSort.java
index 2c0862f..ddf4cc3 100644
--- a/solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSort.java
+++ b/solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSort.java
@@ -1664,12 +1664,6 @@ public class TestFieldCacheSort extends LuceneTestCase {
                     Collections.singletonMap("id", Type.LEGACY_INTEGER));
     w.close();
     Query q = new TermQuery(new Term("body", "text"));
-    IndexSearcher s = newSearcher(r);
-    float maxScore = s.search(q , 10).getMaxScore();
-    assertEquals(maxScore, s.search(q, 3, Sort.INDEXORDER, random().nextBoolean(), true).getMaxScore(), 0.0);
-    assertEquals(maxScore, s.search(q, 3, Sort.RELEVANCE, random().nextBoolean(), true).getMaxScore(), 0.0);
-    assertEquals(maxScore, s.search(q, 3, new Sort(new SortField[] {new SortField("id", SortField.Type.INT, false)}), random().nextBoolean(), true).getMaxScore(), 0.0);
-    assertEquals(maxScore, s.search(q, 3, new Sort(new SortField[] {new SortField("id", SortField.Type.INT, true)}), random().nextBoolean(), true).getMaxScore(), 0.0);
     TestUtil.checkReader(r);
     r.close();
     d.close();
@@ -1681,27 +1675,27 @@ public class TestFieldCacheSort extends LuceneTestCase {
     Query query = new TermQuery(new Term("contents", "foo"));
   
     Sort sort = new Sort();
-    TopDocs td = empty.search(query, 10, sort, true, true);
+    TopDocs td = empty.search(query, 10, sort, true);
     assertEquals(0, td.totalHits);
 
     sort.setSort(SortField.FIELD_DOC);
-    td = empty.search(query, 10, sort, true, true);
+    td = empty.search(query, 10, sort, true);
     assertEquals(0, td.totalHits);
 
     sort.setSort(new SortField("int", SortField.Type.INT), SortField.FIELD_DOC);
-    td = empty.search(query, 10, sort, true, true);
+    td = empty.search(query, 10, sort, true);
     assertEquals(0, td.totalHits);
     
     sort.setSort(new SortField("string", SortField.Type.STRING, true), SortField.FIELD_DOC);
-    td = empty.search(query, 10, sort, true, true);
+    td = empty.search(query, 10, sort, true);
     assertEquals(0, td.totalHits);
     
     sort.setSort(new SortField("string_val", SortField.Type.STRING_VAL, true), SortField.FIELD_DOC);
-    td = empty.search(query, 10, sort, true, true);
+    td = empty.search(query, 10, sort, true);
     assertEquals(0, td.totalHits);
 
     sort.setSort(new SortField("float", SortField.Type.FLOAT), new SortField("string", SortField.Type.STRING));
-    td = empty.search(query, 10, sort, true, true);
+    td = empty.search(query, 10, sort, true);
     assertEquals(0, td.totalHits);
   }
   
@@ -1743,7 +1737,7 @@ public class TestFieldCacheSort extends LuceneTestCase {
 
     TopDocs expected = searcher.search(new TermQuery(new Term("value", "foo")), 10);
     assertEquals(1, expected.totalHits);
-    TopDocs actual = searcher.search(new TermQuery(new Term("value", "foo")), 10, sort, true, true);
+    TopDocs actual = searcher.search(new TermQuery(new Term("value", "foo")), 10, sort, true);
     
     assertEquals(expected.totalHits, actual.totalHits);
     assertEquals(expected.scoreDocs[0].score, actual.scoreDocs[0].score, 0F);
diff --git a/solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom.java b/solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom.java
index 58069cd..f9653e0 100644
--- a/solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom.java
+++ b/solr/core/src/test/org/apache/solr/uninverting/TestFieldCacheSortRandom.java
@@ -168,9 +168,9 @@ public class TestFieldCacheSortRandom extends LuceneTestCase {
       int queryType = random.nextInt(2);
       if (queryType == 0) {
         hits = s.search(new ConstantScoreQuery(f),
-                        hitCount, sort, random.nextBoolean(), random.nextBoolean());
+                        hitCount, sort, random.nextBoolean());
       } else {
-        hits = s.search(f, hitCount, sort, random.nextBoolean(), random.nextBoolean());
+        hits = s.search(f, hitCount, sort, random.nextBoolean());
       }
 
       if (VERBOSE) {
