Index: src/java/org/apache/lucene/util/automaton/Automaton.java
===================================================================
--- src/java/org/apache/lucene/util/automaton/Automaton.java	(revision 930953)
+++ src/java/org/apache/lucene/util/automaton/Automaton.java	(working copy)
@@ -319,17 +319,17 @@
    */
   void totalize() {
     State s = new State();
-    s.transitions.add(new Transition(Character.MIN_VALUE, Character.MAX_VALUE,
+    s.transitions.add(new Transition(Character.MIN_CODE_POINT, Character.MAX_CODE_POINT,
         s));
     for (State p : getStates()) {
-      int maxi = Character.MIN_VALUE;
+      int maxi = Character.MIN_CODE_POINT;
       for (Transition t : p.getSortedTransitions(false)) {
-        if (t.min > maxi) p.transitions.add(new Transition((char) maxi,
-            (char) (t.min - 1), s));
+        if (t.min > maxi) p.transitions.add(new Transition(maxi,
+            (t.min - 1), s));
         if (t.max + 1 > maxi) maxi = t.max + 1;
       }
-      if (maxi <= Character.MAX_VALUE) p.transitions.add(new Transition(
-          (char) maxi, Character.MAX_VALUE, s));
+      if (maxi <= Character.MAX_CODE_POINT) p.transitions.add(new Transition(
+          maxi, Character.MAX_CODE_POINT, s));
     }
   }
   
@@ -362,39 +362,39 @@
           if (t.min <= max + 1) {
             if (t.max > max) max = t.max;
           } else {
-            if (p != null) s.transitions.add(new Transition((char) min,
-                (char) max, p));
+            if (p != null) s.transitions.add(new Transition(min,
+                max, p));
             min = t.min;
             max = t.max;
           }
         } else {
-          if (p != null) s.transitions.add(new Transition((char) min,
-              (char) max, p));
+          if (p != null) s.transitions.add(new Transition(min,
+              max, p));
           p = t.to;
           min = t.min;
           max = t.max;
         }
       }
       if (p != null) s.transitions
-          .add(new Transition((char) min, (char) max, p));
+          .add(new Transition(min, max, p));
     }
   }
   
   /**
    * Returns sorted array of all interval start points.
    */
-  char[] getStartPoints() {
-    Set<Character> pointset = new HashSet<Character>();
+  int[] getStartPoints() {
+    Set<Integer> pointset = new HashSet<Integer>();
     for (State s : getStates()) {
-      pointset.add(Character.MIN_VALUE);
+      pointset.add(Character.MIN_CODE_POINT);
       for (Transition t : s.transitions) {
         pointset.add(t.min);
-        if (t.max < Character.MAX_VALUE) pointset.add((char) (t.max + 1));
+        if (t.max < Character.MAX_CODE_POINT) pointset.add((t.max + 1));
       }
     }
-    char[] points = new char[pointset.size()];
+    int[] points = new int[pointset.size()];
     int n = 0;
-    for (Character m : pointset)
+    for (Integer m : pointset)
       points[n++] = m;
     Arrays.sort(points);
     return points;
@@ -470,9 +470,9 @@
     if (isSingleton()) {
       State p = new State();
       initial = p;
-      for (int i = 0; i < singleton.length(); i++) {
+      for (int i = 0, cp = 0; i < singleton.length(); i += Character.charCount(cp)) {
         State q = new State();
-        p.transitions.add(new Transition(singleton.charAt(i), q));
+        p.transitions.add(new Transition(cp = singleton.codePointAt(i), q));
         p = q;
       }
       p.accept = true;
@@ -542,7 +542,11 @@
     StringBuilder b = new StringBuilder();
     if (isSingleton()) {
       b.append("singleton: ");
-      for (char c : singleton.toCharArray())
+      int length = singleton.codePointCount(0, singleton.length());
+      int codepoints[] = new int[length];
+      for (int i = 0, j = 0, cp = 0; i < singleton.length(); i += Character.charCount(cp))
+        codepoints[j++] = cp = singleton.codePointAt(i);
+      for (int c : codepoints)
         Transition.appendCharString(c, b);
       b.append("\n");
     } else {
Index: src/java/org/apache/lucene/util/automaton/MinimizationOperations.java
===================================================================
--- src/java/org/apache/lucene/util/automaton/MinimizationOperations.java	(revision 930953)
+++ src/java/org/apache/lucene/util/automaton/MinimizationOperations.java	(working copy)
@@ -70,8 +70,8 @@
     Set<Transition> tr = a.initial.getTransitions();
     if (tr.size() == 1) {
       Transition t = tr.iterator().next();
-      if (t.to == a.initial && t.min == Character.MIN_VALUE
-          && t.max == Character.MAX_VALUE) return;
+      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT
+          && t.max == Character.MAX_CODE_POINT) return;
     }
     a.totalize();
     // make arrays for numbered states and effective alphabet
@@ -82,7 +82,7 @@
       states[number] = q;
       q.number = number++;
     }
-    char[] sigma = a.getStartPoints();
+    int[] sigma = a.getStartPoints();
     // initialize data structures
     ArrayList<ArrayList<LinkedList<State>>> reverse = new ArrayList<ArrayList<LinkedList<State>>>();
     for (int q = 0; q < states.length; q++) {
@@ -121,7 +121,7 @@
       partition.get(j).add(qq);
       block[qq.number] = j;
       for (int x = 0; x < sigma.length; x++) {
-        char y = sigma[x];
+        int y = sigma[x];
         State p = qq.step(y);
         reverse.get(p.number).get(x).add(qq);
         reverse_nonempty[p.number][x] = true;
Index: src/java/org/apache/lucene/util/automaton/BasicAutomata.java
===================================================================
--- src/java/org/apache/lucene/util/automaton/BasicAutomata.java	(revision 930953)
+++ src/java/org/apache/lucene/util/automaton/BasicAutomata.java	(working copy)
@@ -70,35 +70,35 @@
     State s = new State();
     a.initial = s;
     s.accept = true;
-    s.transitions.add(new Transition(Character.MIN_VALUE, Character.MAX_VALUE,
+    s.transitions.add(new Transition(Character.MIN_CODE_POINT, Character.MAX_CODE_POINT,
         s));
     a.deterministic = true;
     return a;
   }
   
   /**
-   * Returns a new (deterministic) automaton that accepts any single character.
+   * Returns a new (deterministic) automaton that accepts any single codepoint.
    */
   public static Automaton makeAnyChar() {
-    return makeCharRange(Character.MIN_VALUE, Character.MAX_VALUE);
+    return makeCharRange(Character.MIN_CODE_POINT, Character.MAX_CODE_POINT);
   }
   
   /**
-   * Returns a new (deterministic) automaton that accepts a single character of
+   * Returns a new (deterministic) automaton that accepts a single codepoint of
    * the given value.
    */
-  public static Automaton makeChar(char c) {
+  public static Automaton makeChar(int c) {
     Automaton a = new Automaton();
-    a.singleton = Character.toString(c);
+    a.singleton = new String(Character.toChars(c));
     a.deterministic = true;
     return a;
   }
   
   /**
-   * Returns a new (deterministic) automaton that accepts a single char whose
+   * Returns a new (deterministic) automaton that accepts a single codepoint whose
    * value is in the given interval (including both end points).
    */
-  public static Automaton makeCharRange(char min, char max) {
+  public static Automaton makeCharRange(int min, int max) {
     if (min == max) return makeChar(min);
     Automaton a = new Automaton();
     State s1 = new State();
Index: src/java/org/apache/lucene/util/automaton/State.java
===================================================================
--- src/java/org/apache/lucene/util/automaton/State.java	(revision 930953)
+++ src/java/org/apache/lucene/util/automaton/State.java	(working copy)
@@ -106,11 +106,12 @@
   /**
    * Performs lookup in transitions, assuming determinism.
    * 
-   * @param c character to look up
+   * @param c codepoint to look up
    * @return destination state, null if no matching outgoing transition
-   * @see #step(char, Collection)
+   * @see #step(int, Collection)
    */
-  public State step(char c) {
+  public State step(int c) {
+    assert c >= 0;
     for (Transition t : transitions)
       if (t.min <= c && c <= t.max) return t.to;
     return null;
@@ -119,11 +120,11 @@
   /**
    * Performs lookup in transitions, allowing nondeterminism.
    * 
-   * @param c character to look up
+   * @param c codepoint to look up
    * @param dest collection where destination states are stored
-   * @see #step(char)
+   * @see #step(int)
    */
-  public void step(char c, Collection<State> dest) {
+  public void step(int c, Collection<State> dest) {
     for (Transition t : transitions)
       if (t.min <= c && c <= t.max) dest.add(t.to);
   }
Index: src/java/org/apache/lucene/util/automaton/LevenshteinAutomata.java
===================================================================
--- src/java/org/apache/lucene/util/automaton/LevenshteinAutomata.java	(revision 930953)
+++ src/java/org/apache/lucene/util/automaton/LevenshteinAutomata.java	(working copy)
@@ -39,13 +39,13 @@
   public static final int MAXIMUM_SUPPORTED_DISTANCE = 2;
   /* input word */
   final String input;
-  final char word[];
+  final int word[];
   /* the automata alphabet. */
-  final char alphabet[];
+  final int alphabet[];
 
   /* the unicode ranges outside of alphabet */
-  final char rangeLower[];
-  final char rangeUpper[];
+  final int rangeLower[];
+  final int rangeUpper[];
   int numRanges = 0;
   
   ParametricDescription descriptions[]; 
@@ -55,35 +55,39 @@
    */
   public LevenshteinAutomata(String input) {
     this.input = input;
-    this.word = input.toCharArray();
+    int length = Character.codePointCount(input, 0, input.length());
+    word = new int[length];
+    for (int i = 0, j = 0, cp = 0; i < input.length(); i += Character.charCount(cp)) {
+      word[j++] = cp = input.codePointAt(i);
+    }
     
     // calculate the alphabet
-    SortedSet<Character> set = new TreeSet<Character>();
+    SortedSet<Integer> set = new TreeSet<Integer>();
     for (int i = 0; i < word.length; i++)
       set.add(word[i]);
-    alphabet = new char[set.size()];
-    Iterator<Character> iterator = set.iterator();
+    alphabet = new int[set.size()];
+    Iterator<Integer> iterator = set.iterator();
     for (int i = 0; i < alphabet.length; i++)
       alphabet[i] = iterator.next();
       
-    rangeLower = new char[alphabet.length + 2];
-    rangeUpper = new char[alphabet.length + 2];
+    rangeLower = new int[alphabet.length + 2];
+    rangeUpper = new int[alphabet.length + 2];
     // calculate the unicode range intervals that exclude the alphabet
     // these are the ranges for all unicode characters not in the alphabet
     int lower = 0;
     for (int i = 0; i < alphabet.length; i++) {
-      char higher = alphabet[i];
+      int higher = alphabet[i];
       if (higher > lower) {
-        rangeLower[numRanges] = (char) lower;
-        rangeUpper[numRanges] = (char) (higher - 1);
+        rangeLower[numRanges] = lower;
+        rangeUpper[numRanges] = higher - 1;
         numRanges++;
       }
       lower = higher + 1;
     }
     /* add the final endpoint */
-    if (lower <= 0xFFFF) {
-      rangeLower[numRanges] = (char) lower;
-      rangeUpper[numRanges] = '\uFFFF';
+    if (lower <= Character.MAX_CODE_POINT) {
+      rangeLower[numRanges] = lower;
+      rangeUpper[numRanges] = Character.MAX_CODE_POINT;
       numRanges++;
     }
 
@@ -129,7 +133,7 @@
       final int end = xpos + Math.min(word.length - xpos, range);
       
       for (int x = 0; x < alphabet.length; x++) {
-        final char ch = alphabet[x];
+        final int ch = alphabet[x];
         // get the characteristic vector at this position wrt ch
         final int cvec = getVector(ch, xpos, end);
         int dest = description.transition(k, xpos, cvec);
@@ -157,7 +161,7 @@
    * Get the characteristic vector <code>X(x, V)</code> 
    * where V is <code>substring(pos, end)</code>
    */
-  int getVector(char x, int pos, int end) {
+  int getVector(int x, int pos, int end) {
     int vector = 0;
     for (int i = pos; i < end; i++) {
       vector <<= 1;
Index: src/java/org/apache/lucene/util/automaton/TransitionComparator.java
===================================================================
--- src/java/org/apache/lucene/util/automaton/TransitionComparator.java	(revision 930953)
+++ src/java/org/apache/lucene/util/automaton/TransitionComparator.java	(working copy)
@@ -33,8 +33,8 @@
 import java.util.Comparator;
 
 /**
- * Comparator for state {@link Transition}s that orders unicode char range
- * transitions in lexicographic order.
+ * Comparator for state {@link Transition}s that orders unicode codepoint range
+ * transitions in codepoint order.
  * 
  * @lucene.experimental
  */
Index: src/java/org/apache/lucene/util/automaton/SpecialOperations.java
===================================================================
--- src/java/org/apache/lucene/util/automaton/SpecialOperations.java	(revision 930953)
+++ src/java/org/apache/lucene/util/automaton/SpecialOperations.java	(working copy)
@@ -46,7 +46,7 @@
    * Finds the largest entry whose value is less than or equal to c, or 0 if
    * there is no such entry.
    */
-  static int findIndex(char c, char[] points) {
+  static int findIndex(int c, int[] points) {
     int a = 0;
     int b = points.length;
     while (b - a > 1) {
@@ -119,7 +119,7 @@
     Automaton r = a.clone();
     reverse(r);
     r.determinize();
-    return reverseUnicode3(SpecialOperations.getCommonPrefix(r));
+    return new StringBuilder(SpecialOperations.getCommonPrefix(r)).reverse().toString();
   }
   
   /**
@@ -149,31 +149,4 @@
     a.deterministic = false;
     return accept;
   }
-  
-  /**
-   * Intentionally use a unicode 3 reverse.
-   * This is because we are only going to reverse it again...
-   */
-  private static String reverseUnicode3( final String input ){
-    char[] charInput = input.toCharArray();
-    reverseUnicode3(charInput, 0, charInput.length);
-    return new String(charInput);
-  }
-  
-  /**
-   * Intentionally use a unicode 3 reverse.
-   * This is because it is only used by getCommonSuffix(),
-   * which will reverse the entire FSM using code unit reversal,
-   * so we must then reverse its common prefix back using the 
-   * same code unit reversal.
-   */
-  private static void reverseUnicode3(char[] buffer, int start, int len){
-    if (len <= 1) return;
-    int num = len>>1;
-    for (int i = start; i < ( start + num ); i++) {
-      char c = buffer[i];
-      buffer[i] = buffer[start * 2 + len - i - 1];
-      buffer[start * 2 + len - i - 1] = c;
-    }
-  }
 }
Index: src/java/org/apache/lucene/util/automaton/BasicOperations.java
===================================================================
--- src/java/org/apache/lucene/util/automaton/BasicOperations.java	(revision 930953)
+++ src/java/org/apache/lucene/util/automaton/BasicOperations.java	(working copy)
@@ -302,8 +302,8 @@
               newstates.put(q, q);
               r = q;
             }
-            char min = t1[n1].min > t2[n2].min ? t1[n1].min : t2[n2].min;
-            char max = t1[n1].max < t2[n2].max ? t1[n1].max : t2[n2].max;
+            int min = t1[n1].min > t2[n2].min ? t1[n1].min : t2[n2].min;
+            int max = t1[n1].max < t2[n2].max ? t1[n1].max : t2[n2].max;
             p.s.transitions.add(new Transition(min, max, r.s));
           }
       }
@@ -348,10 +348,10 @@
         int min1 = t1[n1].min, max1 = t1[n1].max;
         for (int n2 = b2; n2 < t2.length && t1[n1].max >= t2[n2].min; n2++) {
           if (t2[n2].min > min1) return false;
-          if (t2[n2].max < Character.MAX_VALUE) min1 = t2[n2].max + 1;
+          if (t2[n2].max < Character.MAX_CODE_POINT) min1 = t2[n2].max + 1;
           else {
-            min1 = Character.MAX_VALUE;
-            max1 = Character.MIN_VALUE;
+            min1 = Character.MAX_CODE_POINT;
+            max1 = Character.MIN_CODE_POINT;
           }
           StatePair q = new StatePair(t1[n1].to, t2[n2].to);
           if (!visited.contains(q)) {
@@ -435,7 +435,7 @@
    * Determinizes the given automaton using the given set of initial states.
    */
   static void determinize(Automaton a, Set<State> initialset) {
-    char[] points = a.getStartPoints();
+    int[] points = a.getStartPoints();
     // subset construction
     Map<Set<State>,Set<State>> sets = new HashMap<Set<State>,Set<State>>();
     LinkedList<Set<State>> worklist = new LinkedList<Set<State>>();
@@ -463,10 +463,10 @@
           newstate.put(p, new State());
         }
         State q = newstate.get(p);
-        char min = points[n];
-        char max;
-        if (n + 1 < points.length) max = (char) (points[n + 1] - 1);
-        else max = Character.MAX_VALUE;
+        int min = points[n];
+        int max;
+        if (n + 1 < points.length) max = (points[n + 1] - 1);
+        else max = Character.MAX_CODE_POINT;
         r.transitions.add(new Transition(min, max, q));
       }
     }
@@ -563,8 +563,8 @@
     if (a.isSingleton()) return false;
     if (a.initial.accept && a.initial.transitions.size() == 1) {
       Transition t = a.initial.transitions.iterator().next();
-      return t.to == a.initial && t.min == Character.MIN_VALUE
-          && t.max == Character.MAX_VALUE;
+      return t.to == a.initial && t.min == Character.MIN_CODE_POINT
+          && t.max == Character.MAX_CODE_POINT;
     }
     return false;
   }
@@ -580,8 +580,8 @@
     if (a.isSingleton()) return s.equals(a.singleton);
     if (a.deterministic) {
       State p = a.initial;
-      for (int i = 0; i < s.length(); i++) {
-        State q = p.step(s.charAt(i));
+      for (int i = 0, cp = 0; i < s.length(); i += Character.charCount(cp)) {
+        State q = p.step(cp = s.charAt(i));
         if (q == null) return false;
         p = q;
       }
@@ -596,8 +596,8 @@
       pp.add(a.initial);
       ArrayList<State> dest = new ArrayList<State>();
       boolean accept = a.initial.accept;
-      for (int i = 0; i < s.length(); i++) {
-        char c = s.charAt(i);
+      for (int i = 0, c = 0; i < s.length(); i += Character.charCount(c)) {
+        c = s.codePointAt(i);
         accept = false;
         pp_other.clear();
         bb_other.clear();
Index: src/java/org/apache/lucene/util/automaton/RegExp.java
===================================================================
--- src/java/org/apache/lucene/util/automaton/RegExp.java	(revision 930953)
+++ src/java/org/apache/lucene/util/automaton/RegExp.java	(working copy)
@@ -366,9 +366,9 @@
   Kind kind;
   RegExp exp1, exp2;
   String s;
-  char c;
+  int c;
   int min, max, digits;
-  char from, to;
+  int from, to;
   
   String b;
   int flags;
@@ -625,10 +625,10 @@
         b.append(")");
         break;
       case REGEXP_CHAR:
-        b.append("\\").append(c);
+        b.append("\\").appendCodePoint(c);
         break;
       case REGEXP_CHAR_RANGE:
-        b.append("[\\").append(from).append("-\\").append(to).append("]");
+        b.append("[\\").appendCodePoint(from).append("-\\").appendCodePoint(to).append("]");
         break;
       case REGEXP_ANYCHAR:
         b.append(".");
@@ -725,9 +725,9 @@
   static private RegExp makeString(RegExp exp1, RegExp exp2) {
     StringBuilder b = new StringBuilder();
     if (exp1.kind == Kind.REGEXP_STRING) b.append(exp1.s);
-    else b.append(exp1.c);
+    else b.appendCodePoint(exp1.c);
     if (exp2.kind == Kind.REGEXP_STRING) b.append(exp2.s);
-    else b.append(exp2.c);
+    else b.appendCodePoint(exp2.c);
     return makeString(b.toString());
   }
   
@@ -777,14 +777,14 @@
     return r;
   }
   
-  static RegExp makeChar(char c) {
+  static RegExp makeChar(int c) {
     RegExp r = new RegExp();
     r.kind = Kind.REGEXP_CHAR;
     r.c = c;
     return r;
   }
   
-  static RegExp makeCharRange(char from, char to) {
+  static RegExp makeCharRange(int from, int to) {
     RegExp r = new RegExp();
     r.kind = Kind.REGEXP_CHAR_RANGE;
     r.from = from;
@@ -834,13 +834,13 @@
   }
   
   private boolean peek(String s) {
-    return more() && s.indexOf(b.charAt(pos)) != -1;
+    return more() && s.indexOf(b.codePointAt(pos)) != -1;
   }
   
-  private boolean match(char c) {
+  private boolean match(int c) {
     if (pos >= b.length()) return false;
-    if (b.charAt(pos) == c) {
-      pos++;
+    if (b.codePointAt(pos) == c) {
+      pos += Character.charCount(c);
       return true;
     }
     return false;
@@ -850,9 +850,11 @@
     return pos < b.length();
   }
   
-  private char next() throws IllegalArgumentException {
+  private int next() throws IllegalArgumentException {
     if (!more()) throw new IllegalArgumentException("unexpected end-of-string");
-    return b.charAt(pos++);
+    int ch = b.codePointAt(pos);
+    pos += Character.charCount(ch);
+    return ch;
   }
   
   private boolean check(int flag) {
@@ -933,7 +935,7 @@
   }
   
   final RegExp parseCharClass() throws IllegalArgumentException {
-    char c = parseCharExp();
+    int c = parseCharExp();
     if (match('-')) return makeCharRange(c, parseCharExp());
     else return makeChar(c);
   }
@@ -993,7 +995,7 @@
     } else return makeChar(parseCharExp());
   }
   
-  final char parseCharExp() throws IllegalArgumentException {
+  final int parseCharExp() throws IllegalArgumentException {
     match('\\');
     return next();
   }
Index: src/java/org/apache/lucene/util/automaton/Transition.java
===================================================================
--- src/java/org/apache/lucene/util/automaton/Transition.java	(revision 930953)
+++ src/java/org/apache/lucene/util/automaton/Transition.java	(working copy)
@@ -35,7 +35,7 @@
  * <tt>Automaton</tt> transition.
  * <p>
  * A transition, which belongs to a source state, consists of a Unicode
- * character interval and a destination state.
+ * codepoint interval and a destination state.
  * 
  * @lucene.experimental
  */
@@ -45,18 +45,19 @@
    * CLASS INVARIANT: min<=max
    */
 
-  char min;
-  char max;
+  int min;
+  int max;
   
   State to;
   
   /**
    * Constructs a new singleton interval transition.
    * 
-   * @param c transition character
+   * @param c transition codepoint
    * @param to destination state
    */
-  public Transition(char c, State to) {
+  public Transition(int c, State to) {
+    assert c >= 0;
     min = max = c;
     this.to = to;
   }
@@ -68,9 +69,11 @@
    * @param max transition interval maximum
    * @param to destination state
    */
-  public Transition(char min, char max, State to) {
+  public Transition(int min, int max, State to) {
+    assert min >= 0;
+    assert max >= 0;
     if (max < min) {
-      char t = max;
+      int t = max;
       max = min;
       min = t;
     }
@@ -80,12 +83,12 @@
   }
   
   /** Returns minimum of this transition interval. */
-  public char getMin() {
+  public int getMin() {
     return min;
   }
   
   /** Returns maximum of this transition interval. */
-  public char getMax() {
+  public int getMax() {
     return max;
   }
   
@@ -134,14 +137,18 @@
     }
   }
   
-  static void appendCharString(char c, StringBuilder b) {
-    if (c >= 0x21 && c <= 0x7e && c != '\\' && c != '"') b.append(c);
+  static void appendCharString(int c, StringBuilder b) {
+    if (c >= 0x21 && c <= 0x7e && c != '\\' && c != '"') b.appendCodePoint(c);
     else {
-      b.append("\\u");
+      b.append("\\\\U");
       String s = Integer.toHexString(c);
-      if (c < 0x10) b.append("000").append(s);
-      else if (c < 0x100) b.append("00").append(s);
-      else if (c < 0x1000) b.append("0").append(s);
+      if (c < 0x10) b.append("0000000").append(s);
+      else if (c < 0x100) b.append("000000").append(s);
+      else if (c < 0x1000) b.append("00000").append(s);
+      else if (c < 0x10000) b.append("0000").append(s);
+      else if (c < 0x100000) b.append("000").append(s);
+      else if (c < 0x1000000) b.append("00").append(s);
+      else if (c < 0x10000000) b.append("0").append(s);
       else b.append(s);
     }
   }
Index: src/java/org/apache/lucene/util/automaton/RunAutomaton.java
===================================================================
--- src/java/org/apache/lucene/util/automaton/RunAutomaton.java	(revision 930953)
+++ src/java/org/apache/lucene/util/automaton/RunAutomaton.java	(working copy)
@@ -44,8 +44,7 @@
   final int initial;
   final int[] transitions; // delta(state,c) = transitions[state*points.length +
                      // getCharClass(c)]
-  final char[] points; // char interval start points
-  final int[] classmap; // map from char number to class class
+  final int[] points; // char interval start points
   
   /**
    * Returns a string representation of this automaton.
@@ -61,10 +60,10 @@
       for (int j = 0; j < points.length; j++) {
         int k = transitions[i * points.length + j];
         if (k != -1) {
-          char min = points[j];
-          char max;
-          if (j + 1 < points.length) max = (char) (points[j + 1] - 1);
-          else max = Character.MAX_VALUE;
+          int min = points[j];
+          int max;
+          if (j + 1 < points.length) max = (points[j + 1] - 1);
+          else max = Character.MAX_CODE_POINT;
           b.append(" ");
           Transition.appendCharString(min, b);
           if (min != max) {
@@ -100,17 +99,17 @@
   }
   
   /**
-   * Returns array of character class interval start points. The array should
+   * Returns array of codepoint class interval start points. The array should
    * not be modified by the caller.
    */
-  public char[] getCharIntervals() {
+  public int[] getCharIntervals() {
     return points.clone();
   }
   
   /**
-   * Gets character class of given char.
+   * Gets character class of given codepoint
    */
-  int getCharClass(char c) {
+  int getCharClass(int c) {
     return SpecialOperations.findIndex(c, points);
   }
   
@@ -139,15 +138,6 @@
         if (q != null) transitions[n * points.length + c] = q.number;
       }
     }
-    /*
-     * Set alphabet table for optimal run performance.
-     */
-    classmap = new int[Character.MAX_VALUE + 1];
-    int i = 0;
-    for (int j = 0; j <= Character.MAX_VALUE; j++) {
-      if (i + 1 < points.length && j == points[i + 1]) i++;
-      classmap[j] = i;
-    }
   }
   
   /**
@@ -157,8 +147,8 @@
    * if a dead state is entered in an equivalent automaton with a total
    * transition function.)
    */
-  public int step(int state, char c) {
-    return transitions[state * points.length + classmap[c]];
+  public int step(int state, int c) {
+    return transitions[state * points.length + getCharClass(c)];
   }
   
   /**
@@ -167,8 +157,8 @@
   public boolean run(String s) {
     int p = initial;
     int l = s.length();
-    for (int i = 0; i < l; i++) {
-      p = step(p, s.charAt(i));
+    for (int i = 0, cp = 0; i < l; i += Character.charCount(cp)) {
+      p = step(p, cp = s.codePointAt(i));
       if (p == -1) return false;
     }
     return accept[p];
@@ -180,31 +170,10 @@
   public boolean run(char[] s, int offset, int length) {
     int p = initial;
     int l = offset + length;
-    for (int i = offset; i < l; i++) {
-      p = step(p, s[i]);
+    for (int i = offset, cp = 0; i < l; i += Character.charCount(cp)) {
+      p = step(p, cp = Character.codePointAt(s, i, l));
       if (p == -1) return false;
     }
     return accept[p];
   }
-  
-  /**
-   * Returns the length of the longest accepted run of the given string starting
-   * at the given offset.
-   * 
-   * @param s the string
-   * @param offset offset into <code>s</code> where the run starts
-   * @return length of the longest accepted run, -1 if no run is accepted
-   */
-  public int run(String s, int offset) {
-    int p = initial;
-    int l = s.length();
-    int max = -1;
-    for (int r = 0; offset <= l; offset++, r++) {
-      if (accept[p]) max = r;
-      if (offset == l) break;
-      p = step(p, s.charAt(offset));
-      if (p == -1) break;
-    }
-    return max;
-  }
 }
