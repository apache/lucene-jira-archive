Index: src/test/org/apache/lucene/search/TestAutomatonQuery.java
===================================================================
--- src/test/org/apache/lucene/search/TestAutomatonQuery.java	(revision 928858)
+++ src/test/org/apache/lucene/search/TestAutomatonQuery.java	(working copy)
@@ -106,23 +106,14 @@
     assertAutomatonHits(2, BasicAutomata.makeString("doc"));
     assertAutomatonHits(1, BasicAutomata.makeChar('a'));
     assertAutomatonHits(2, BasicAutomata.makeCharRange('a', 'b'));
-    assertAutomatonHits(2, BasicAutomata.makeCharSet("ab"));
-    assertAutomatonHits(1, BasicAutomata.makeDecimalValue("5678.9"));
-    assertAutomatonHits(1, BasicAutomata.makeDecimalValue("2345"));
-    assertAutomatonHits(3, BasicAutomata.makeFractionDigits(3));
-    assertAutomatonHits(1, BasicAutomata.makeIntegerValue("1234"));
     assertAutomatonHits(2, BasicAutomata.makeInterval(1233, 2346, 0));
     assertAutomatonHits(1, BasicAutomata.makeInterval(0, 2000, 0));
-    assertAutomatonHits(2, BasicAutomata.makeMaxInteger("003000"));
-    assertAutomatonHits(1, BasicAutomata.makeMinInteger("002000"));
-    assertAutomatonHits(2, BasicAutomata.makeStringMatcher("ome"));
-    assertAutomatonHits(2, BasicAutomata.makeTotalDigits(5));
     assertAutomatonHits(2, BasicOperations.union(BasicAutomata.makeChar('a'),
         BasicAutomata.makeChar('b')));
     assertAutomatonHits(0, BasicOperations.intersection(BasicAutomata
         .makeChar('a'), BasicAutomata.makeChar('b')));
-    assertAutomatonHits(1, BasicOperations.minus(BasicAutomata
-        .makeMaxInteger("3000"), BasicAutomata.makeIntegerValue("1234")));
+    assertAutomatonHits(1, BasicOperations.minus(BasicAutomata.makeCharRange('a', 'b'), 
+        BasicAutomata.makeChar('a')));
   }
   
   /**
Index: src/test/org/apache/lucene/util/automaton/TestBasicOperations.java
===================================================================
--- src/test/org/apache/lucene/util/automaton/TestBasicOperations.java	(revision 928858)
+++ src/test/org/apache/lucene/util/automaton/TestBasicOperations.java	(working copy)
@@ -23,7 +23,7 @@
   public void testSingletonConcatenate() {
     Automaton singleton = BasicAutomata.makeString("prefix");
     Automaton expandedSingleton = singleton.cloneExpanded();
-    Automaton other = BasicAutomata.makeMaxInteger("57");
+    Automaton other = BasicAutomata.makeCharRange('5', '7');
     Automaton concat = BasicOperations.concatenate(singleton, other);
     assertTrue(concat.isDeterministic());
     assertEquals(BasicOperations.concatenate(expandedSingleton, other), concat);
@@ -45,7 +45,7 @@
   public void testEmptySingletonConcatenate() {
     Automaton singleton = BasicAutomata.makeString("");
     Automaton expandedSingleton = singleton.cloneExpanded();
-    Automaton other = BasicAutomata.makeMaxInteger("57");
+    Automaton other = BasicAutomata.makeCharRange('5', '7');
     Automaton concat1 = BasicOperations.concatenate(expandedSingleton, other);
     Automaton concat2 = BasicOperations.concatenate(singleton, other);
     assertTrue(concat2.isDeterministic());
Index: src/java/org/apache/lucene/util/automaton/BasicAutomata.java
===================================================================
--- src/java/org/apache/lucene/util/automaton/BasicAutomata.java	(revision 928858)
+++ src/java/org/apache/lucene/util/automaton/BasicAutomata.java	(working copy)
@@ -30,10 +30,7 @@
 package org.apache.lucene.util.automaton;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
 
 /**
  * Construction of basic automata.
@@ -41,9 +38,6 @@
  * @lucene.experimental
  */
 final public class BasicAutomata {
-  // used by getWhitespaceAutomaton to match basic whitespace
-  private static final Automaton ws = Automaton.minimize(BasicAutomata
-      .makeCharSet(" \t\n\r").repeat());
   
   private BasicAutomata() {}
   
@@ -117,24 +111,6 @@
   }
   
   /**
-   * Returns a new (deterministic) automaton that accepts a single character in
-   * the given set.
-   */
-  public static Automaton makeCharSet(String set) {
-    if (set.length() == 1) return makeChar(set.charAt(0));
-    Automaton a = new Automaton();
-    State s1 = new State();
-    State s2 = new State();
-    a.initial = s1;
-    s2.accept = true;
-    for (int i = 0; i < set.length(); i++)
-      s1.transitions.add(new Transition(set.charAt(i), s2));
-    a.deterministic = true;
-    a.reduce();
-    return a;
-  }
-  
-  /**
    * Constructs sub-automaton corresponding to decimal numbers of length
    * x.substring(n).length().
    */
@@ -211,7 +187,7 @@
    * non-negative integers in the given interval.
    * 
    * @param min minimal value of interval
-   * @param max maximal value of inverval (both end points are included in the
+   * @param max maximal value of interval (both end points are included in the
    *          interval)
    * @param digits if >0, use fixed number of digits (strings must be prefixed
    *          by 0's to obtain the right length) - otherwise, the number of
@@ -263,217 +239,4 @@
     a.deterministic = true;
     return a;
   }
-  
-  /**
-   * Constructs automaton that accept strings representing nonnegative integers
-   * that are not larger than the given value.
-   * 
-   * @param n string representation of maximum value
-   */
-  public static Automaton makeMaxInteger(String n) {
-    int i = 0;
-    while (i < n.length() && n.charAt(i) == '0')
-      i++;
-    StringBuilder b = new StringBuilder();
-    b.append("0*(0|");
-    if (i < n.length()) b.append("[0-9]{1," + (n.length() - i - 1) + "}|");
-    maxInteger(n.substring(i), 0, b);
-    b.append(")");
-    return Automaton.minimize((new RegExp(b.toString())).toAutomaton());
-  }
-  
-  private static void maxInteger(String n, int i, StringBuilder b) {
-    b.append('(');
-    if (i < n.length()) {
-      char c = n.charAt(i);
-      if (c != '0') b.append("[0-" + (char) (c - 1) + "][0-9]{"
-          + (n.length() - i - 1) + "}|");
-      b.append(c);
-      maxInteger(n, i + 1, b);
-    }
-    b.append(')');
-  }
-  
-  /**
-   * Constructs automaton that accept strings representing nonnegative integers
-   * that are not less that the given value.
-   * 
-   * @param n string representation of minimum value
-   */
-  public static Automaton makeMinInteger(String n) {
-    int i = 0;
-    while (i + 1 < n.length() && n.charAt(i) == '0')
-      i++;
-    StringBuilder b = new StringBuilder();
-    b.append("0*");
-    minInteger(n.substring(i), 0, b);
-    b.append("[0-9]*");
-    return Automaton.minimize((new RegExp(b.toString())).toAutomaton());
-  }
-  
-  private static void minInteger(String n, int i, StringBuilder b) {
-    b.append('(');
-    if (i < n.length()) {
-      char c = n.charAt(i);
-      if (c != '9') b.append("[" + (char) (c + 1) + "-9][0-9]{"
-          + (n.length() - i - 1) + "}|");
-      b.append(c);
-      minInteger(n, i + 1, b);
-    }
-    b.append(')');
-  }
-  
-  /**
-   * Constructs automaton that accept strings representing decimal numbers that
-   * can be written with at most the given number of digits. Surrounding
-   * whitespace is permitted.
-   * 
-   * @param i max number of necessary digits
-   */
-  public static Automaton makeTotalDigits(int i) {
-    return Automaton.minimize((new RegExp("[ \t\n\r]*[-+]?0*([0-9]{0," + i
-        + "}|((([0-9]\\.*){0," + i + "})&@\\.@)0*)[ \t\n\r]*")).toAutomaton());
-  }
-  
-  /**
-   * Constructs automaton that accept strings representing decimal numbers that
-   * can be written with at most the given number of digits in the fraction
-   * part. Surrounding whitespace is permitted.
-   * 
-   * @param i max number of necessary fraction digits
-   */
-  public static Automaton makeFractionDigits(int i) {
-    return Automaton.minimize((new RegExp("[ \t\n\r]*[-+]?[0-9]+(\\.[0-9]{0,"
-        + i + "}0*)?[ \t\n\r]*")).toAutomaton());
-  }
-  
-  /**
-   * Constructs automaton that accept strings representing the given integer.
-   * Surrounding whitespace is permitted.
-   * 
-   * @param value string representation of integer
-   */
-  public static Automaton makeIntegerValue(String value) {
-    boolean minus = false;
-    int i = 0;
-    while (i < value.length()) {
-      char c = value.charAt(i);
-      if (c == '-') minus = true;
-      if (c >= '1' && c <= '9') break;
-      i++;
-    }
-    StringBuilder b = new StringBuilder();
-    b.append(value.substring(i));
-    if (b.length() == 0) b.append("0");
-    Automaton s;
-    if (minus) s = makeChar('-');
-    else s = makeChar('+').optional();
-    Automaton ws = getWhitespaceAutomaton();
-    return Automaton.minimize(ws.concatenate(
-        s.concatenate(makeChar('0').repeat()).concatenate(
-            makeString(b.toString()))).concatenate(ws));
-  }
-  
-  /**
-   * Constructs automaton that accept strings representing the given decimal
-   * number. Surrounding whitespace is permitted.
-   * 
-   * @param value string representation of decimal number
-   */
-  public static Automaton makeDecimalValue(String value) {
-    boolean minus = false;
-    int i = 0;
-    while (i < value.length()) {
-      char c = value.charAt(i);
-      if (c == '-') minus = true;
-      if ((c >= '1' && c <= '9') || c == '.') break;
-      i++;
-    }
-    StringBuilder b1 = new StringBuilder();
-    StringBuilder b2 = new StringBuilder();
-    int p = value.indexOf('.', i);
-    if (p == -1) b1.append(value.substring(i));
-    else {
-      b1.append(value.substring(i, p));
-      i = value.length() - 1;
-      while (i > p) {
-        char c = value.charAt(i);
-        if (c >= '1' && c <= '9') break;
-        i--;
-      }
-      b2.append(value.substring(p + 1, i + 1));
-    }
-    if (b1.length() == 0) b1.append("0");
-    Automaton s;
-    if (minus) s = makeChar('-');
-    else s = makeChar('+').optional();
-    Automaton d;
-    if (b2.length() == 0) d = makeChar('.')
-        .concatenate(makeChar('0').repeat(1)).optional();
-    else d = makeChar('.').concatenate(makeString(b2.toString())).concatenate(
-        makeChar('0').repeat());
-    Automaton ws = getWhitespaceAutomaton();
-    return Automaton.minimize(ws.concatenate(
-        s.concatenate(makeChar('0').repeat()).concatenate(
-            makeString(b1.toString())).concatenate(d)).concatenate(ws));
-  }
-  
-  /**
-   * Constructs deterministic automaton that matches strings that contain the
-   * given substring.
-   */
-  public static Automaton makeStringMatcher(String s) {
-    Automaton a = new Automaton();
-    State[] states = new State[s.length() + 1];
-    states[0] = a.initial;
-    for (int i = 0; i < s.length(); i++)
-      states[i + 1] = new State();
-    State f = states[s.length()];
-    f.accept = true;
-    f.transitions.add(new Transition(Character.MIN_VALUE, Character.MAX_VALUE,
-        f));
-    for (int i = 0; i < s.length(); i++) {
-      Set<Character> done = new HashSet<Character>();
-      char c = s.charAt(i);
-      states[i].transitions.add(new Transition(c, states[i + 1]));
-      done.add(c);
-      for (int j = i; j >= 1; j--) {
-        char d = s.charAt(j - 1);
-        if (!done.contains(d)
-            && s.substring(0, j - 1).equals(s.substring(i - j + 1, i))) {
-          states[i].transitions.add(new Transition(d, states[j]));
-          done.add(d);
-        }
-      }
-      char[] da = new char[done.size()];
-      int h = 0;
-      for (char w : done)
-        da[h++] = w;
-      Arrays.sort(da);
-      int from = Character.MIN_VALUE;
-      int k = 0;
-      while (from <= Character.MAX_VALUE) {
-        while (k < da.length && da[k] == from) {
-          k++;
-          from++;
-        }
-        if (from <= Character.MAX_VALUE) {
-          int to = Character.MAX_VALUE;
-          if (k < da.length) {
-            to = da[k] - 1;
-            k++;
-          }
-          states[i].transitions.add(new Transition((char) from, (char) to,
-              states[0]));
-          from = to + 2;
-        }
-      }
-    }
-    a.deterministic = true;
-    return a;
-  }
-  
-  private static Automaton getWhitespaceAutomaton() {
-    return ws;
-  }
 }
