Index: lucene/core/src/test/org/apache/lucene/search/TestBooleanOr.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBooleanOr.java	(revision 1412417)
+++ lucene/core/src/test/org/apache/lucene/search/TestBooleanOr.java	(working copy)
@@ -16,6 +16,8 @@
  * limitations under the License.
  */
 import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashSet;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.lucene.document.Document;
@@ -25,6 +27,7 @@
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util._TestUtil;
@@ -68,6 +71,17 @@
     q.add(new BooleanClause(c2, BooleanClause.Occur.SHOULD));
     assertEquals(1, search(q));
   }
+  
+  /**
+   * <code>T:files T:deleting C:production C:optimize </code>
+   * it works.
+   */
+  public void testMultiTermDisjunction() throws IOException {
+    MultiTermDisjunctionQuery q = new MultiTermDisjunctionQuery(t1.getTerm().field(),new HashSet<BytesRef>(Arrays.asList(new BytesRef[]{t1.getTerm().bytes(),t2.getTerm().bytes()})));
+    assertEquals(1, search(q));
+    q = new MultiTermDisjunctionQuery(c1.getTerm().field(),new HashSet<BytesRef>(Arrays.asList(new BytesRef[]{c1.getTerm().bytes(),c2.getTerm().bytes()})));
+    assertEquals(1, search(q));
+  }
 
   /**
    * <code>(T:files T:deleting) (+C:production +C:optimize)</code>
Index: lucene/core/src/java/org/apache/lucene/search/MultiTermDisjunctionQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MultiTermDisjunctionQuery.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/search/MultiTermDisjunctionQuery.java	(revision 0)
@@ -0,0 +1,89 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+import java.io.IOException;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.Set;
+
+import org.apache.lucene.index.FilteredTermsEnum;
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.util.AttributeSource;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * {@link MultiTermQuery} implementation for a set of terms as disjunction.
+ * This is an more optimal way of {@link BooleanQuery} of disjunction of the same field.
+ */
+public class MultiTermDisjunctionQuery extends MultiTermQuery{
+
+  private final Set<BytesRef> values;
+  
+  /**
+   * Constructor
+   * @param field the field 
+   * @param values a set of term values
+   */
+  public MultiTermDisjunctionQuery(String field,Set<BytesRef> values) {
+    super(field);
+    this.values = values;
+  }
+
+  @Override
+  protected TermsEnum getTermsEnum(Terms terms, AttributeSource atts)
+      throws IOException {
+    final TermsEnum termsEnum = terms.iterator(null);
+    final Iterator<BytesRef> it = values.iterator();
+
+    return new FilteredTermsEnum(termsEnum) {
+      @Override protected AcceptStatus accept(BytesRef term) throws IOException {
+        return AcceptStatus.YES;
+      }
+
+      @Override public BytesRef next() throws IOException {
+        while (it.hasNext()) {
+          BytesRef termRef = it.next();
+          if (termsEnum.seekExact(termRef, true)) {
+            return termRef;
+          }
+        }
+
+        return null;
+      }
+
+      @Override public Comparator<BytesRef> getComparator() {
+        return BytesRef.getUTF8SortedAsUnicodeComparator();
+      }
+    };
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder builder = new StringBuilder();
+    builder.append("MultiTermDisjunctionQuery[");
+    for (BytesRef termVal : this.values) {
+      builder.append(termVal);
+      builder.append(",");
+    }
+    builder.setLength(builder.length() - 1);
+    builder.append("]");
+    return builder.toString();
+  }
+}
