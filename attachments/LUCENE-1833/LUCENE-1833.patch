Index: contrib/analyzers/smartcn/src/java/org/apache/lucene/analysis/cn/smart/hhmm/BiSegGraph.java
===================================================================
--- contrib/analyzers/smartcn/src/java/org/apache/lucene/analysis/cn/smart/hhmm/BiSegGraph.java	(revision 821119)
+++ contrib/analyzers/smartcn/src/java/org/apache/lucene/analysis/cn/smart/hhmm/BiSegGraph.java	(working copy)
@@ -129,7 +129,7 @@
    * @return true if a token pair exists
    */
   public boolean isToExist(int to) {
-    return tokenPairListTable.get(new Integer(to)) != null;
+    return tokenPairListTable.get(Integer.valueOf(to)) != null;
   }
 
   /**
@@ -139,7 +139,7 @@
    * @return {@link List} of token pairs.
    */
   public List getToList(int to) {
-    return (List) tokenPairListTable.get(new Integer(to));
+    return (List) tokenPairListTable.get(Integer.valueOf(to));
   }
 
   /**
@@ -152,9 +152,9 @@
     if (!isToExist(to)) {
       ArrayList newlist = new ArrayList();
       newlist.add(tokenPair);
-      tokenPairListTable.put(new Integer(to), newlist);
+      tokenPairListTable.put(Integer.valueOf(to), newlist);
     } else {
-      List tokenPairList = (List) tokenPairListTable.get(new Integer(to));
+      List tokenPairList = (List) tokenPairListTable.get(Integer.valueOf(to));
       tokenPairList.add(tokenPair);
     }
   }
@@ -207,11 +207,11 @@
     List rpath = new ArrayList();
     List resultPath = new ArrayList();
 
-    rpath.add(new Integer(current));
+    rpath.add(Integer.valueOf(current));
     while (current != 0) {
       PathNode currentPathNode = (PathNode) path.get(current);
       preNode = currentPathNode.preNode;
-      rpath.add(new Integer(preNode));
+      rpath.add(Integer.valueOf(preNode));
       current = preNode;
     }
     for (int j = rpath.size() - 1; j >= 0; j--) {
Index: contrib/analyzers/smartcn/src/java/org/apache/lucene/analysis/cn/smart/hhmm/SegGraph.java
===================================================================
--- contrib/analyzers/smartcn/src/java/org/apache/lucene/analysis/cn/smart/hhmm/SegGraph.java	(revision 821119)
+++ contrib/analyzers/smartcn/src/java/org/apache/lucene/analysis/cn/smart/hhmm/SegGraph.java	(working copy)
@@ -50,7 +50,7 @@
    * @return true if there are tokens for the startOffset
    */
   public boolean isStartExist(int s) {
-    return tokenListTable.get(new Integer(s)) != null;
+    return tokenListTable.get(Integer.valueOf(s)) != null;
   }
 
   /**
@@ -60,7 +60,7 @@
    * @return List of tokens at the specified start offset.
    */
   public List getStartList(int s) {
-    return (List) tokenListTable.get(new Integer(s));
+    return (List) tokenListTable.get(Integer.valueOf(s));
   }
 
   /**
@@ -83,7 +83,7 @@
     short index = 0;
     while (count < size) {
       if (isStartExist(s)) {
-        tokenList = (List) tokenListTable.get(new Integer(s));
+        tokenList = (List) tokenListTable.get(Integer.valueOf(s));
         for (Iterator iter = tokenList.iterator(); iter.hasNext();) {
           SegToken st = (SegToken) iter.next();
           st.index = index;
@@ -106,9 +106,9 @@
     if (!isStartExist(s)) {
       ArrayList newlist = new ArrayList();
       newlist.add(token);
-      tokenListTable.put((Object) (new Integer(s)), newlist);
+      tokenListTable.put((Object) (Integer.valueOf(s)), newlist);
     } else {
-      List tokenList = (List) tokenListTable.get((Object) (new Integer(s)));
+      List tokenList = (List) tokenListTable.get((Object) (Integer.valueOf(s)));
       tokenList.add(token);
     }
     if (s > maxStart)
@@ -127,7 +127,7 @@
 
     while (count < size) {
       if (isStartExist(s)) {
-        tokenList = (List) tokenListTable.get(new Integer(s));
+        tokenList = (List) tokenListTable.get(Integer.valueOf(s));
         for (Iterator iter = tokenList.iterator(); iter.hasNext();) {
           SegToken st = (SegToken) iter.next();
           result.add(st);
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ContentSource.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ContentSource.java	(revision 821119)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ContentSource.java	(working copy)
@@ -59,8 +59,8 @@
   private static final int OTHER = 1;
   private static final Map extensionToType = new HashMap();
   static {
-    extensionToType.put(".bz2", new Integer(BZIP));
-    extensionToType.put(".bzip", new Integer(BZIP));
+    extensionToType.put(".bz2", Integer.valueOf(BZIP));
+    extensionToType.put(".bzip", Integer.valueOf(BZIP));
   }
   
   protected static final int BUFFER_SIZE = 1 << 16; // 64K
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.java	(revision 821119)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiContentSource.java	(working copy)
@@ -235,11 +235,11 @@
                                   "SEP", "OCT", "NOV", "DEC"};
 
   static {
-    ELEMENTS.put("page", new Integer(PAGE));
-    ELEMENTS.put("text", new Integer(BODY));
-    ELEMENTS.put("timestamp", new Integer(DATE));
-    ELEMENTS.put("title", new Integer(TITLE));
-    ELEMENTS.put("id", new Integer(ID));
+    ELEMENTS.put("page", Integer.valueOf(PAGE));
+    ELEMENTS.put("text", Integer.valueOf(BODY));
+    ELEMENTS.put("timestamp", Integer.valueOf(DATE));
+    ELEMENTS.put("title", Integer.valueOf(TITLE));
+    ELEMENTS.put("id", Integer.valueOf(ID));
   }
   
   /**
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Config.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Config.java	(revision 821119)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Config.java	(working copy)
@@ -287,7 +287,7 @@
     StringTokenizer st = new StringTokenizer(s,":");
     while (st.hasMoreTokens()) {
       String t = st.nextToken();
-      a.add(new Integer(t));
+      a.add(Integer.valueOf(t));
     }
     int res[] = new int[a.size()]; 
     for (int i=0; i<a.size(); i++) {
@@ -306,7 +306,7 @@
     StringTokenizer st = new StringTokenizer(s,":");
     while (st.hasMoreTokens()) {
       String t = st.nextToken();
-      a.add(new Double(t));
+      a.add(Double.valueOf(t));
     }
     double res[] = new double[a.size()]; 
     for (int i=0; i<a.size(); i++) {
Index: contrib/lucli/src/java/lucli/LuceneMethods.java
===================================================================
--- contrib/lucli/src/java/lucli/LuceneMethods.java	(revision 821119)
+++ contrib/lucli/src/java/lucli/LuceneMethods.java	(working copy)
@@ -292,10 +292,10 @@
               String name = termAtt.term();
               Integer Count = (Integer) tokenMap.get(name);
               if (Count == null) { // not in there yet
-                tokenMap.put(name, new Integer(1)); //first one
+                tokenMap.put(name, Integer.valueOf(1)); //first one
               } else {
                 int count = Count.intValue();
-                tokenMap.put(name, new Integer(count + 1));
+                tokenMap.put(name, Integer.valueOf(count + 1));
               }
               if (position > maxFieldLength) break;
             }
@@ -327,7 +327,7 @@
       //message(term.field() + ":" + term.text() + " freq:" + terms.docFreq());
       //if we're either not looking by field or we're matching the specific field
       if ((field == null) || field.equals(term.field()))
-        termMap.put(term.field() + ":" + term.text(), new Integer((terms.docFreq())));
+        termMap.put(term.field() + ":" + term.text(), Integer.valueOf((terms.docFreq())));
     }
 
     Iterator termIterator = termMap.keySet().iterator();
Index: contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap.java
===================================================================
--- contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap.java	(revision 821119)
+++ contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap.java	(working copy)
@@ -236,7 +236,7 @@
       
       Integer group = lastGroup;
       if (num != lastNum) {
-        group = new Integer(num);
+        group = Integer.valueOf(num);
         lastGroup = group;
         lastNum = num;
       }
Index: contrib/misc/src/java/org/apache/lucene/index/TermVectorAccessor.java
===================================================================
--- contrib/misc/src/java/org/apache/lucene/index/TermVectorAccessor.java	(revision 821119)
+++ contrib/misc/src/java/org/apache/lucene/index/TermVectorAccessor.java	(working copy)
@@ -106,7 +106,7 @@
         TermPositions termPositions = indexReader.termPositions(termEnum.term());
         if (termPositions.skipTo(documentNumber)) {
 
-          frequencies.add(new Integer(termPositions.freq()));
+          frequencies.add(Integer.valueOf(termPositions.freq()));
           tokens.add(termEnum.term().text());
 
 
Index: contrib/misc/src/java/org/apache/lucene/misc/SweetSpotSimilarity.java
===================================================================
--- contrib/misc/src/java/org/apache/lucene/misc/SweetSpotSimilarity.java	(revision 821119)
+++ contrib/misc/src/java/org/apache/lucene/misc/SweetSpotSimilarity.java	(working copy)
@@ -123,9 +123,9 @@
    */
   public void setLengthNormFactors(String field, int min, int max,
                                    float steepness, boolean discountOverlaps) {
-    ln_mins.put(field, new Integer(min));
-    ln_maxs.put(field, new Integer(max));
-    ln_steeps.put(field, new Float(steepness));
+    ln_mins.put(field, Integer.valueOf(min));
+    ln_maxs.put(field, Integer.valueOf(max));
+    ln_steeps.put(field, Float.valueOf(steepness));
     ln_overlaps.put(field, new Boolean(discountOverlaps));
   }
     
Index: contrib/queries/src/java/org/apache/lucene/search/similar/MoreLikeThis.java
===================================================================
--- contrib/queries/src/java/org/apache/lucene/search/similar/MoreLikeThis.java	(revision 821119)
+++ contrib/queries/src/java/org/apache/lucene/search/similar/MoreLikeThis.java	(working copy)
@@ -668,10 +668,10 @@
             // only really need 1st 3 entries, other ones are for troubleshooting
             res.insert(new Object[]{word,                   // the word
                                     topField,               // the top field
-                                    new Float(score),       // overall score
-                                    new Float(idf),         // idf
-                                    new Integer(docFreq),   // freq in all docs
-                                    new Integer(tf)
+                                    Float.valueOf(score),       // overall score
+                                    Float.valueOf(idf),         // idf
+                                    Integer.valueOf(docFreq),   // freq in all docs
+                                    Integer.valueOf(tf)
             });
         }
         return res;
Index: contrib/queries/src/test/org/apache/lucene/search/similar/TestMoreLikeThis.java
===================================================================
--- contrib/queries/src/test/org/apache/lucene/search/similar/TestMoreLikeThis.java	(revision 821119)
+++ contrib/queries/src/test/org/apache/lucene/search/similar/TestMoreLikeThis.java	(working copy)
@@ -119,7 +119,7 @@
 	for (int i = 0; i < clauses.size(); i++) {
 	    BooleanClause clause = (BooleanClause) clauses.get(i);
 	    TermQuery tq = (TermQuery) clause.getQuery();
-	    originalValues.put(tq.getTerm().text(), new Float(tq.getBoost()));
+	    originalValues.put(tq.getTerm().text(), Float.valueOf(tq.getBoost()));
 	}
 	return originalValues;
     }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/BoostQueryNode.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/BoostQueryNode.java	(revision 821119)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/BoostQueryNode.java	(working copy)
@@ -91,7 +91,7 @@
    * @return the parsed value
    */
   private CharSequence getValueString() {
-    Float f = new Float(this.value);
+    Float f = Float.valueOf(this.value);
     if (f == f.longValue())
       return "" + f.longValue();
     else
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PhraseSlopQueryNode.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PhraseSlopQueryNode.java	(revision 821119)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/PhraseSlopQueryNode.java	(working copy)
@@ -58,7 +58,7 @@
   }
 
   private CharSequence getValueString() {
-    Float f = new Float(this.value);
+    Float f = Float.valueOf(this.value);
     if (f == f.longValue())
       return "" + f.longValue();
     else
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/SlopQueryNode.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/SlopQueryNode.java	(revision 821119)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/SlopQueryNode.java	(working copy)
@@ -65,7 +65,7 @@
   }
 
   private CharSequence getValueString() {
-    Float f = new Float(this.value);
+    Float f = Float.valueOf(this.value);
     if (f == f.longValue())
       return "" + f.longValue();
     else
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQPHelper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQPHelper.java	(revision 821119)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQPHelper.java	(working copy)
@@ -147,8 +147,8 @@
 
   public void testBoostsSimple() throws Exception {
     Map boosts = new HashMap();
-    boosts.put("b", new Float(5));
-    boosts.put("t", new Float(10));
+    boosts.put("b", Float.valueOf(5));
+    boosts.put("t", Float.valueOf(10));
     String[] fields = { "b", "t" };
     StandardQueryParser mfqp = new StandardQueryParser();
     mfqp.setMultiFields(fields);
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQueryParserWrapper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQueryParserWrapper.java	(revision 821119)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQueryParserWrapper.java	(working copy)
@@ -142,8 +142,8 @@
 
   public void testBoostsSimple() throws Exception {
     Map boosts = new HashMap();
-    boosts.put("b", new Float(5));
-    boosts.put("t", new Float(10));
+    boosts.put("b", Float.valueOf(5));
+    boosts.put("t", Float.valueOf(10));
     String[] fields = { "b", "t" };
     MultiFieldQueryParserWrapper mfqp = new MultiFieldQueryParserWrapper(
         fields, new StandardAnalyzer(), boosts);
Index: contrib/remote/src/test/org/apache/lucene/search/TestRemoteSort.java
===================================================================
--- contrib/remote/src/test/org/apache/lucene/search/TestRemoteSort.java	(revision 821119)
+++ contrib/remote/src/test/org/apache/lucene/search/TestRemoteSort.java	(working copy)
@@ -219,7 +219,7 @@
     }
 
     public Comparable value(int slot) {
-      return new Integer(slotValues[slot]);
+      return Integer.valueOf(slotValues[slot]);
     }
   }
 
@@ -414,7 +414,7 @@
       Document doc = searcher.doc(hits[i].doc);
       String[] v = doc.getValues("tracer");
       assertEquals (v.length, 1);
-      scoreMap.put (v[0], new Float(hits[i].score));
+      scoreMap.put (v[0], Float.valueOf(hits[i].score));
     }
     return scoreMap;
   }
Index: contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashDistanceFilter.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashDistanceFilter.java	(revision 821119)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashDistanceFilter.java	(working copy)
@@ -118,10 +118,10 @@
   /** Returns a hash code value for this object.*/
   @Override
   public int hashCode() {
-    int h = new Double(distance).hashCode();
+    int h = Double.valueOf(distance).hashCode();
     h ^= startingFilter.hashCode();
-    h ^= new Double(lat).hashCode();
-    h ^= new Double(lng).hashCode();
+    h ^= Double.valueOf(lat).hashCode();
+    h ^= Double.valueOf(lng).hashCode();
     h ^= geoHashField.hashCode();
     
     return h;
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceHandler.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceHandler.java	(revision 821119)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceHandler.java	(working copy)
@@ -84,7 +84,7 @@
       double xLat = getPrecision(lat, precise);
       double xLng = getPrecision(lng, precise);
       
-      String k = new Double(xLat).toString() +","+ new Double(xLng).toString();
+      String k = Double.valueOf(xLat).toString() +","+ Double.valueOf(xLng).toString();
     
       Double d = (distanceLookupCache.get(k));
       if (d != null){
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/LatLongDistanceFilter.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/LatLongDistanceFilter.java	(revision 821119)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/tier/LatLongDistanceFilter.java	(working copy)
@@ -124,10 +124,10 @@
   /** Returns a hash code value for this object.*/
   @Override
   public int hashCode() {
-    int h = new Double(distance).hashCode();
+    int h = Double.valueOf(distance).hashCode();
     h ^= startingFilter.hashCode();
-    h ^= new Double(lat).hashCode();
-    h ^= new Double(lng).hashCode();
+    h ^= Double.valueOf(lat).hashCode();
+    h ^= Double.valueOf(lng).hashCode();
     h ^= latField.hashCode();
     h ^= lngField.hashCode();
     return h;
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/CartesianTierPlotter.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/CartesianTierPlotter.java	(revision 821119)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/CartesianTierPlotter.java	(working copy)
@@ -31,7 +31,7 @@
   int tierVerticalPosDivider;
   final IProjector projector;
   final String fieldPrefix;
-  Double idd = new Double(180);
+  Double idd = Double.valueOf(180);
   
   public CartesianTierPlotter (int tierLevel, IProjector projector, String fieldPrefix) {
   
@@ -65,8 +65,8 @@
     
     // ceiling of log base 10 of tierLen
     
-    tierVerticalPosDivider = new Double(Math.ceil(
-          Math.log10(new Integer(this.tierLength).doubleValue()))).intValue();
+    tierVerticalPosDivider = Double.valueOf(Math.ceil(
+          Math.log10(Integer.valueOf(this.tierLength).doubleValue()))).intValue();
     
     // 
     tierVerticalPosDivider = (int)Math.pow(10, tierVerticalPosDivider );
Index: contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
===================================================================
--- contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java	(revision 821119)
+++ contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java	(working copy)
@@ -197,7 +197,7 @@
           distance = 1.0d;
         //boost by distance is invertly proportional to
         // to distance from center point to location
-        float score = new Float((miles - distance) / miles ).floatValue();
+        float score = (float) ((miles - distance) / miles );
         return score * subQueryScore;
       }
     };
@@ -284,7 +284,7 @@
           distance = 1.0d;
         //boost by distance is invertly proportional to
         // to distance from center point to location
-        float score = new Float((miles - distance) / miles ).floatValue();
+        float score = (float) ((miles - distance) / miles );
         return score * subQueryScore;
       }
     };
@@ -373,7 +373,7 @@
               distance = 1.0d;
             //boost by distance is invertly proportional to
             // to distance from center point to location
-            float score = new Float((miles - distance) / miles ).floatValue();
+            float score = (float) ( (miles - distance) / miles );
             return score * subQueryScore;
           }
         };
@@ -462,7 +462,7 @@
               distance = 1.0d;
             //boost by distance is invertly proportional to
             // to distance from center point to location
-            float score = new Float((miles - distance) / miles ).floatValue();
+            float score = (float) ( (miles - distance) / miles );
             return score * subQueryScore;
           }
         };
Index: contrib/surround/src/java/org/apache/lucene/queryParser/surround/query/SpanNearClauseFactory.java
===================================================================
--- contrib/surround/src/java/org/apache/lucene/queryParser/surround/query/SpanNearClauseFactory.java	(revision 821119)
+++ contrib/surround/src/java/org/apache/lucene/queryParser/surround/query/SpanNearClauseFactory.java	(working copy)
@@ -101,9 +101,9 @@
   protected void addSpanQueryWeighted(SpanQuery sq, float weight) {
     Float w = (Float) weightBySpanQuery.get(sq);
     if (w != null)
-      w = new Float(w.floatValue() + weight);
+      w = Float.valueOf(w.floatValue() + weight);
     else
-      w = new Float(weight);
+      w = Float.valueOf(weight);
     weightBySpanQuery.put(sq, w); 
   }
   
Index: contrib/swing/src/java/org/apache/lucene/swing/models/ListSearcher.java
===================================================================
--- contrib/swing/src/java/org/apache/lucene/swing/models/ListSearcher.java	(revision 821119)
+++ contrib/swing/src/java/org/apache/lucene/swing/models/ListSearcher.java	(working copy)
@@ -191,7 +191,7 @@
             for (int t=0; t<hits.length(); t++){
                 Document document = hits.doc(t);
                 Fieldable field = document.getField(ROW_NUMBER);
-                rowToModelIndex.add(new Integer(field.stringValue()));
+                rowToModelIndex.add(Integer.valueOf(field.stringValue()));
             }
         } catch (Exception e){
             e.printStackTrace();
@@ -227,7 +227,7 @@
         searchString = null;
         rowToModelIndex.clear();
         for (int t=0; t<listModel.getSize(); t++){
-            rowToModelIndex.add(new Integer(t));
+            rowToModelIndex.add(Integer.valueOf(t));
         }
     }
 
Index: contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher.java
===================================================================
--- contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher.java	(revision 821119)
+++ contrib/swing/src/java/org/apache/lucene/swing/models/TableSearcher.java	(working copy)
@@ -272,7 +272,7 @@
             for (int t=0; t<hits.length(); t++){
                 Document document = hits.doc(t);
                 Fieldable field = document.getField(ROW_NUMBER);
-                rowToModelIndex.add(new Integer(field.stringValue()));
+                rowToModelIndex.add(Integer.valueOf(field.stringValue()));
             }
         } catch (Exception e){
             e.printStackTrace();
@@ -292,7 +292,7 @@
         searchString = null;
         rowToModelIndex.clear();
         for (int t=0; t<tableModel.getRowCount(); t++){
-            rowToModelIndex.add(new Integer(t));
+            rowToModelIndex.add(Integer.valueOf(t));
         }
     }
 
Index: src/java/org/apache/lucene/index/BufferedDeletes.java
===================================================================
--- src/java/org/apache/lucene/index/BufferedDeletes.java	(revision 821119)
+++ src/java/org/apache/lucene/index/BufferedDeletes.java	(working copy)
@@ -126,7 +126,7 @@
       Iterator iter = docIDs.iterator();
       while(iter.hasNext()) {
         Integer num = (Integer) iter.next();
-        newDeleteDocIDs.add(new Integer(mapper.remap(num.intValue())));
+        newDeleteDocIDs.add(Integer.valueOf(mapper.remap(num.intValue())));
       }
     } else
       newDeleteDocIDs = null;
@@ -141,7 +141,7 @@
         Entry entry = (Entry) iter.next();
         Integer num = (Integer) entry.getValue();
         newDeleteQueries.put(entry.getKey(),
-                             new Integer(mapper.remap(num.intValue())));
+                             Integer.valueOf(mapper.remap(num.intValue())));
       }
     } else
       newDeleteQueries = null;
Index: src/java/org/apache/lucene/index/DirectoryReader.java
===================================================================
--- src/java/org/apache/lucene/index/DirectoryReader.java	(revision 821119)
+++ src/java/org/apache/lucene/index/DirectoryReader.java	(working copy)
@@ -193,7 +193,7 @@
     if (oldReaders != null) {
       // create a Map SegmentName->SegmentReader
       for (int i = 0; i < oldReaders.length; i++) {
-        segmentReaders.put(oldReaders[i].getSegmentName(), new Integer(i));
+        segmentReaders.put(oldReaders[i].getSegmentName(), Integer.valueOf(i));
       }
     }
     
Index: src/java/org/apache/lucene/index/DocumentsWriter.java
===================================================================
--- src/java/org/apache/lucene/index/DocumentsWriter.java	(revision 821119)
+++ src/java/org/apache/lucene/index/DocumentsWriter.java	(working copy)
@@ -1040,12 +1040,12 @@
   // Buffer a specific docID for deletion.  Currently only
   // used when we hit a exception when adding a document
   synchronized private void addDeleteDocID(int docID) {
-    deletesInRAM.docIDs.add(new Integer(flushedDocCount+docID));
+    deletesInRAM.docIDs.add(Integer.valueOf(flushedDocCount+docID));
     deletesInRAM.addBytesUsed(BYTES_PER_DEL_DOCID);
   }
 
   synchronized private void addDeleteQuery(Query query, int docID) {
-    deletesInRAM.queries.put(query, new Integer(flushedDocCount + docID));
+    deletesInRAM.queries.put(query, Integer.valueOf(flushedDocCount + docID));
     deletesInRAM.addBytesUsed(BYTES_PER_DEL_QUERY);
   }
 
Index: src/java/org/apache/lucene/index/IndexReader.java
===================================================================
--- src/java/org/apache/lucene/index/IndexReader.java	(revision 821119)
+++ src/java/org/apache/lucene/index/IndexReader.java	(working copy)
@@ -635,7 +635,7 @@
   public static long lastModified(final Directory directory2) throws CorruptIndexException, IOException {
     return ((Long) new SegmentInfos.FindSegmentsFile(directory2) {
         public Object doBody(String segmentFileName) throws IOException {
-          return new Long(directory2.fileModified(segmentFileName));
+          return Long.valueOf(directory2.fileModified(segmentFileName));
         }
       }.run()).longValue();
   }
Index: src/java/org/apache/lucene/index/IndexWriter.java
===================================================================
--- src/java/org/apache/lucene/index/IndexWriter.java	(revision 821119)
+++ src/java/org/apache/lucene/index/IndexWriter.java	(working copy)
@@ -1631,7 +1631,7 @@
     rollbackSegments = new HashMap();
     final int size = rollbackSegmentInfos.size();
     for(int i=0;i<size;i++)
-      rollbackSegments.put(rollbackSegmentInfos.info(i), new Integer(i));
+      rollbackSegments.put(rollbackSegmentInfos.info(i), Integer.valueOf(i));
   }
 
   /**
Index: src/java/org/apache/lucene/index/PositionBasedTermVectorMapper.java
===================================================================
--- src/java/org/apache/lucene/index/PositionBasedTermVectorMapper.java	(revision 821119)
+++ src/java/org/apache/lucene/index/PositionBasedTermVectorMapper.java	(working copy)
@@ -69,7 +69,7 @@
    */
   public void map(String term, int frequency, TermVectorOffsetInfo[] offsets, int[] positions) {
     for (int i = 0; i < positions.length; i++) {
-      Integer posVal = new Integer(positions[i]);
+      Integer posVal = Integer.valueOf(positions[i]);
       TVPositionInfo pos = (TVPositionInfo) currentPositions.get(posVal);
       if (pos == null) {
         pos = new TVPositionInfo(positions[i], storeOffsets);
Index: src/java/org/apache/lucene/index/SegmentInfos.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentInfos.java	(revision 821119)
+++ src/java/org/apache/lucene/index/SegmentInfos.java	(working copy)
@@ -419,13 +419,13 @@
           }
      
           if(format < 0)
-            return new Long(version);
+            return Long.valueOf(version);
 
           // We cannot be sure about the format of the file.
           // Therefore we have to read the whole file and cannot simply seek to the version entry.
           SegmentInfos sis = new SegmentInfos();
           sis.read(directory, segmentFileName);
-          return new Long(sis.getVersion());
+          return Long.valueOf(sis.getVersion());
         }
       }.run()).longValue();
   }
Index: src/java/org/apache/lucene/search/FieldComparator.java
===================================================================
--- src/java/org/apache/lucene/search/FieldComparator.java	(revision 821119)
+++ src/java/org/apache/lucene/search/FieldComparator.java	(working copy)
@@ -120,7 +120,7 @@
     }
 
     public Comparable value(int slot) {
-      return new Byte(values[slot]);
+      return Byte.valueOf(values[slot]);
     }
   }
 
@@ -160,7 +160,7 @@
     }
 
     public Comparable value(int slot) {
-      return new Integer(docIDs[slot]);
+      return Integer.valueOf(docIDs[slot]);
     }
   }
 
@@ -215,7 +215,7 @@
     }
 
     public Comparable value(int slot) {
-      return new Double(values[slot]);
+      return Double.valueOf(values[slot]);
     }
   }
 
@@ -274,7 +274,7 @@
     }
 
     public Comparable value(int slot) {
-      return new Float(values[slot]);
+      return Float.valueOf(values[slot]);
     }
   }
 
@@ -337,7 +337,7 @@
     }
 
     public Comparable value(int slot) {
-      return new Integer(values[slot]);
+      return Integer.valueOf(values[slot]);
     }
   }
 
@@ -396,7 +396,7 @@
     }
 
     public Comparable value(int slot) {
-      return new Long(values[slot]);
+      return Long.valueOf(values[slot]);
     }
   }
 
@@ -444,7 +444,7 @@
     }
     
     public Comparable value(int slot) {
-      return new Float(scores[slot]);
+      return Float.valueOf(scores[slot]);
     }
   }
 
@@ -484,7 +484,7 @@
     }
 
     public Comparable value(int slot) {
-      return new Short(values[slot]);
+      return Short.valueOf(values[slot]);
     }
   }
 
Index: src/java/org/apache/lucene/search/FieldSortedHitQueue.java
===================================================================
--- src/java/org/apache/lucene/search/FieldSortedHitQueue.java	(revision 821119)
+++ src/java/org/apache/lucene/search/FieldSortedHitQueue.java	(working copy)
@@ -252,7 +252,7 @@
       }
 
       public Comparable sortValue (final ScoreDoc i) {
-        return new Byte(fieldOrder[i.doc]);
+        return Byte.valueOf(fieldOrder[i.doc]);
       }
 
       public int sortType() {
@@ -283,7 +283,7 @@
       }
 
       public Comparable sortValue (final ScoreDoc i) {
-        return new Short(fieldOrder[i.doc]);
+        return Short.valueOf(fieldOrder[i.doc]);
       }
 
       public int sortType() {
@@ -314,7 +314,7 @@
       }
 
       public Comparable sortValue (final ScoreDoc i) {
-        return new Integer (fieldOrder[i.doc]);
+        return Integer.valueOf(fieldOrder[i.doc]);
       }
 
       public int sortType() {
@@ -345,7 +345,7 @@
       }
 
       public Comparable sortValue (final ScoreDoc i) {
-        return new Long(fieldOrder[i.doc]);
+        return Long.valueOf(fieldOrder[i.doc]);
       }
 
       public int sortType() {
@@ -377,7 +377,7 @@
       }
 
       public Comparable sortValue (final ScoreDoc i) {
-        return new Float (fieldOrder[i.doc]);
+        return Float.valueOf(fieldOrder[i.doc]);
       }
 
       public int sortType() {
@@ -408,7 +408,7 @@
       }
 
       public Comparable sortValue (final ScoreDoc i) {
-        return new Double (fieldOrder[i.doc]);
+        return Double.valueOf(fieldOrder[i.doc]);
       }
 
       public int sortType() {
Index: src/java/org/apache/lucene/search/FilterManager.java
===================================================================
--- src/java/org/apache/lucene/search/FilterManager.java	(revision 821119)
+++ src/java/org/apache/lucene/search/FilterManager.java	(working copy)
@@ -103,12 +103,12 @@
   public Filter getFilter(Filter filter) {
     synchronized(cache) {
       FilterItem fi = null;
-      fi = (FilterItem)cache.get(new Integer(filter.hashCode()));
+      fi = (FilterItem)cache.get(Integer.valueOf(filter.hashCode()));
       if (fi != null) {
         fi.timestamp = new Date().getTime();
         return fi.filter;
       }
-      cache.put(new Integer(filter.hashCode()), new FilterItem(filter));
+      cache.put(Integer.valueOf(filter.hashCode()), new FilterItem(filter));
       return filter;
     }
   }
Index: src/java/org/apache/lucene/search/MultiPhraseQuery.java
===================================================================
--- src/java/org/apache/lucene/search/MultiPhraseQuery.java	(revision 821119)
+++ src/java/org/apache/lucene/search/MultiPhraseQuery.java	(working copy)
@@ -91,7 +91,7 @@
     }
 
     termArrays.add(terms);
-    positions.add(new Integer(position));
+    positions.add(Integer.valueOf(position));
   }
 
   /**
Index: src/java/org/apache/lucene/search/MultiSearcher.java
===================================================================
--- src/java/org/apache/lucene/search/MultiSearcher.java	(revision 821119)
+++ src/java/org/apache/lucene/search/MultiSearcher.java	(working copy)
@@ -222,7 +222,7 @@
           // iterate over the score docs and change their fields value
           for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {
             FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];
-            fd.fields[j] = new Integer(((Integer) fd.fields[j]).intValue() + starts[i]);
+            fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);
           }
           break;
         }
@@ -321,7 +321,7 @@
 
     HashMap dfMap = new HashMap();
     for(int i=0; i<allTermsArray.length; i++) {
-      dfMap.put(allTermsArray[i], new Integer(aggregatedDfs[i]));
+      dfMap.put(allTermsArray[i], Integer.valueOf(aggregatedDfs[i]));
     }
 
     // step4
Index: src/java/org/apache/lucene/search/ParallelMultiSearcher.java
===================================================================
--- src/java/org/apache/lucene/search/ParallelMultiSearcher.java	(revision 821119)
+++ src/java/org/apache/lucene/search/ParallelMultiSearcher.java	(working copy)
@@ -253,7 +253,7 @@
             // iterate over the score docs and change their fields value
             for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {
               FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];
-              fd.fields[j] = new Integer(((Integer) fd.fields[j]).intValue() + starts[i]);
+              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);
             }
             break;
           }
Index: src/java/org/apache/lucene/search/PhraseQuery.java
===================================================================
--- src/java/org/apache/lucene/search/PhraseQuery.java	(revision 821119)
+++ src/java/org/apache/lucene/search/PhraseQuery.java	(working copy)
@@ -88,7 +88,7 @@
           throw new IllegalArgumentException("All phrase terms must be in the same field: " + term);
 
       terms.add(term);
-      positions.add(new Integer(position));
+      positions.add(Integer.valueOf(position));
       if (position > maxPosition) maxPosition = position;
   }
 
Index: src/java/org/apache/lucene/search/QueryTermVector.java
===================================================================
--- src/java/org/apache/lucene/search/QueryTermVector.java	(revision 821119)
+++ src/java/org/apache/lucene/search/QueryTermVector.java	(working copy)
@@ -87,13 +87,13 @@
         String term = queryTerms[i];
         Integer position = (Integer)tmpSet.get(term);
         if (position == null) {
-          tmpSet.put(term, new Integer(j++));
+          tmpSet.put(term, Integer.valueOf(j++));
           tmpList.add(term);
-          tmpFreqs.add(new Integer(1));
+          tmpFreqs.add(Integer.valueOf(1));
         }       
         else {
           Integer integer = (Integer)tmpFreqs.get(position.intValue());
-          tmpFreqs.set(position.intValue(), new Integer(integer.intValue() + 1));          
+          tmpFreqs.set(position.intValue(), Integer.valueOf(integer.intValue() + 1));          
         }
       }
       terms = (String[])tmpList.toArray(terms);
Index: src/java/org/apache/lucene/search/ScoreDocComparator.java
===================================================================
--- src/java/org/apache/lucene/search/ScoreDocComparator.java	(revision 821119)
+++ src/java/org/apache/lucene/search/ScoreDocComparator.java	(working copy)
@@ -37,7 +37,7 @@
 			return 0;
 		}
 		public Comparable sortValue (ScoreDoc i) {
-			return new Float (i.score);
+			return Float.valueOf(i.score);
 		}
 		public int sortType() {
 			return SortField.SCORE;
@@ -52,7 +52,7 @@
 			return 0;
 		}
 		public Comparable sortValue (ScoreDoc i) {
-			return new Integer (i.doc);
+			return Integer.valueOf(i.doc);
 		}
 		public int sortType() {
 			return SortField.DOC;
Index: src/java/org/apache/lucene/search/SortComparator.java
===================================================================
--- src/java/org/apache/lucene/search/SortComparator.java	(revision 821119)
+++ src/java/org/apache/lucene/search/SortComparator.java	(working copy)
@@ -77,7 +77,7 @@
    * Returns an object which, when sorted according to natural order,
    * will order the Term values in the correct order.
    * <p>For example, if the Terms contained integer values, this method
-   * would return <code>new Integer(termtext)</code>.  Note that this
+   * would return <code>Integer.valueOf(termtext)</code>.  Note that this
    * might not always be the most efficient implementation - for this
    * particular example, a better implementation might be to make a
    * ScoreDocLookupComparator that uses an internal lookup table of int.
Index: src/java/org/apache/lucene/util/AverageGuessMemoryModel.java
===================================================================
--- src/java/org/apache/lucene/util/AverageGuessMemoryModel.java	(revision 821119)
+++ src/java/org/apache/lucene/util/AverageGuessMemoryModel.java	(working copy)
@@ -28,14 +28,14 @@
   // best guess primitive sizes
   private final Map sizes = new IdentityHashMap() {
     {
-      put(boolean.class, new Integer(1));
-      put(byte.class, new Integer(1));
-      put(char.class, new Integer(2));
-      put(short.class, new Integer(2));
-      put(int.class, new Integer(4));
-      put(float.class, new Integer(4));
-      put(double.class, new Integer(8));
-      put(long.class, new Integer(8));
+      put(boolean.class, Integer.valueOf(1));
+      put(byte.class, Integer.valueOf(1));
+      put(char.class, Integer.valueOf(2));
+      put(short.class, Integer.valueOf(2));
+      put(int.class, Integer.valueOf(4));
+      put(float.class, Integer.valueOf(4));
+      put(double.class, Integer.valueOf(8));
+      put(long.class, Integer.valueOf(8));
     }
   };
 
Index: src/java/org/apache/lucene/util/FieldCacheSanityChecker.java
===================================================================
--- src/java/org/apache/lucene/util/FieldCacheSanityChecker.java	(revision 821119)
+++ src/java/org/apache/lucene/util/FieldCacheSanityChecker.java	(working copy)
@@ -130,7 +130,7 @@
       final ReaderField rf = new ReaderField(item.getReaderKey(), 
                                             item.getFieldName());
 
-      final Integer valId = new Integer(System.identityHashCode(val));
+      final Integer valId = Integer.valueOf(System.identityHashCode(val));
 
       // indirect mapping, so the MapOfSet will dedup identical valIds for us
       valIdToItems.put(valId, item);
Index: src/test/org/apache/lucene/analysis/TestCharArraySet.java
===================================================================
--- src/test/org/apache/lucene/analysis/TestCharArraySet.java	(revision 821119)
+++ src/test/org/apache/lucene/analysis/TestCharArraySet.java	(working copy)
@@ -57,14 +57,14 @@
   
   public void testObjectContains() {
     CharArraySet set = new CharArraySet(10, true);
-    Integer val = new Integer(1);
+    Integer val = Integer.valueOf(1);
     set.add(val);
     assertTrue(set.contains(val));
-    assertTrue(set.contains(new Integer(1)));
+    assertTrue(set.contains(Integer.valueOf(1)));
     // test unmodifiable
     set = CharArraySet.unmodifiableSet(set);
     assertTrue(set.contains(val));
-    assertTrue(set.contains(new Integer(1)));
+    assertTrue(set.contains(Integer.valueOf(1)));
   }
   
   public void testClear(){
Index: src/test/org/apache/lucene/index/TestIndexModifier.java
===================================================================
--- src/test/org/apache/lucene/index/TestIndexModifier.java	(revision 821119)
+++ src/test/org/apache/lucene/index/TestIndexModifier.java	(working copy)
@@ -238,7 +238,7 @@
           } catch (EmptyStackException e) {
             continue;
           }
-          Term delTerm = new Term("id", new Integer(delId).toString());
+          Term delTerm = new Term("id", Integer.valueOf(delId).toString());
           int delCount = index.deleteDocuments(delTerm);
           if (delCount != 1) {
             throw new RuntimeException("Internal error: " + threadNumber + " deleted " + delCount + 
Index: src/test/org/apache/lucene/index/TestIndexReaderCloneNorms.java
===================================================================
--- src/test/org/apache/lucene/index/TestIndexReaderCloneNorms.java	(revision 821119)
+++ src/test/org/apache/lucene/index/TestIndexReaderCloneNorms.java	(working copy)
@@ -257,8 +257,8 @@
       // System.out.println("Modifying: for "+i+" from "+origNorm+" to
       // "+newNorm);
       // System.out.println(" and: for "+k+" from "+newNorm+" to "+origNorm);
-      modifiedNorms.set(i, new Float(newNorm));
-      modifiedNorms.set(k, new Float(origNorm));
+      modifiedNorms.set(i, Float.valueOf(newNorm));
+      modifiedNorms.set(k, Float.valueOf(origNorm));
       ir.setNorm(i, "f" + 1, newNorm);
       ir.setNorm(k, "f" + 1, origNorm);
       // System.out.println("setNorm i: "+i);
@@ -326,8 +326,8 @@
       }
       norm += normDelta;
     } while (true);
-    norms.add(numDocNorms, new Float(norm));
-    modifiedNorms.add(numDocNorms, new Float(norm));
+    norms.add(numDocNorms, Float.valueOf(norm));
+    modifiedNorms.add(numDocNorms, Float.valueOf(norm));
     // System.out.println("creating norm("+numDocNorms+"): "+norm);
     numDocNorms++;
     lastNorm = (norm > 10 ? 0 : norm); // there's a limit to how many distinct
Index: src/test/org/apache/lucene/index/TestNorms.java
===================================================================
--- src/test/org/apache/lucene/index/TestNorms.java	(revision 821119)
+++ src/test/org/apache/lucene/index/TestNorms.java	(working copy)
@@ -169,8 +169,8 @@
       float newNorm = ((Float)modifiedNorms.get(k)).floatValue();
       //System.out.println("Modifying: for "+i+" from "+origNorm+" to "+newNorm);
       //System.out.println("      and: for "+k+" from "+newNorm+" to "+origNorm);
-      modifiedNorms.set(i, new Float(newNorm));
-      modifiedNorms.set(k, new Float(origNorm));
+      modifiedNorms.set(i, Float.valueOf(newNorm));
+      modifiedNorms.set(k, Float.valueOf(origNorm));
       ir.setNorm(i, "f"+1, newNorm); 
       ir.setNorm(k, "f"+1, origNorm); 
     }
@@ -229,8 +229,8 @@
       }
       norm += normDelta;
     } while (true);
-    norms.add(numDocNorms, new Float(norm));
-    modifiedNorms.add(numDocNorms, new Float(norm));
+    norms.add(numDocNorms, Float.valueOf(norm));
+    modifiedNorms.add(numDocNorms, Float.valueOf(norm));
     //System.out.println("creating norm("+numDocNorms+"): "+norm);
     numDocNorms ++;
     lastNorm = (norm>10 ? 0 : norm); //there's a limit to how many distinct values can be stored in a ingle byte
Index: src/test/org/apache/lucene/queryParser/TestMultiFieldQueryParser.java
===================================================================
--- src/test/org/apache/lucene/queryParser/TestMultiFieldQueryParser.java	(revision 821119)
+++ src/test/org/apache/lucene/queryParser/TestMultiFieldQueryParser.java	(working copy)
@@ -130,8 +130,8 @@
   
   public void testBoostsSimple() throws Exception {
       Map boosts = new HashMap();
-      boosts.put("b", new Float(5));
-      boosts.put("t", new Float(10));
+      boosts.put("b", Float.valueOf(5));
+      boosts.put("t", Float.valueOf(10));
       String[] fields = {"b", "t"};
       MultiFieldQueryParser mfqp = new MultiFieldQueryParser(fields, new StandardAnalyzer(), boosts);
       
Index: src/test/org/apache/lucene/search/CheckHits.java
===================================================================
--- src/test/org/apache/lucene/search/CheckHits.java	(revision 821119)
+++ src/test/org/apache/lucene/search/CheckHits.java	(working copy)
@@ -47,12 +47,12 @@
     String d = q.toString(defaultFieldName);
     Set ignore = new TreeSet();
     for (int i = 0; i < results.length; i++) {
-      ignore.add(new Integer(results[i]));
+      ignore.add(Integer.valueOf(results[i]));
     }
     
     int maxDoc = searcher.maxDoc();
     for (int doc = 0; doc < maxDoc; doc++) {
-      if (ignore.contains(new Integer(doc))) continue;
+      if (ignore.contains(Integer.valueOf(doc))) continue;
 
       Explanation exp = searcher.explain(q, doc);
       Assert.assertNotNull("Explanation of [["+d+"]] for #"+doc+" is null",
@@ -87,7 +87,7 @@
     
     Set correct = new TreeSet();
     for (int i = 0; i < results.length; i++) {
-      correct.add(new Integer(results[i]));
+      correct.add(Integer.valueOf(results[i]));
     }
     final Set actual = new TreeSet();
     final Collector c = new SetCollector(actual);
@@ -124,7 +124,7 @@
     private int base = 0;
     public void setScorer(Scorer scorer) throws IOException {}
     public void collect(int doc) {
-      bag.add(new Integer(doc + base));
+      bag.add(Integer.valueOf(doc + base));
     }
     public void setNextReader(IndexReader reader, int docBase) {
       base = docBase;
@@ -162,12 +162,12 @@
 
     Set correct = new TreeSet();
     for (int i = 0; i < results.length; i++) {
-      correct.add(new Integer(results[i]));
+      correct.add(Integer.valueOf(results[i]));
     }
 
     Set actual = new TreeSet();
     for (int i = 0; i < hits.length; i++) {
-      actual.add(new Integer(hits[i].doc));
+      actual.add(Integer.valueOf(hits[i].doc));
     }
 
     Assert.assertEquals(query.toString(defaultFieldName), correct, actual);
Index: src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java
===================================================================
--- src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java	(revision 821119)
+++ src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java	(working copy)
@@ -244,7 +244,7 @@
   private HashMap topDocsToMap(TopDocs td) {
     HashMap h = new HashMap(); 
     for (int i=0; i<td.totalHits; i++) {
-      h.put(new Integer(td.scoreDocs[i].doc), new Float(td.scoreDocs[i].score));
+      h.put(Integer.valueOf(td.scoreDocs[i].doc), Float.valueOf(td.scoreDocs[i].score));
     }
     return h;
   }
Index: src/test/org/apache/lucene/search/SampleComparable.java
===================================================================
--- src/test/org/apache/lucene/search/SampleComparable.java	(revision 821119)
+++ src/test/org/apache/lucene/search/SampleComparable.java	(working copy)
@@ -56,7 +56,7 @@
   public SampleComparable (String s) {
     int i = s.indexOf ("-");
     string_part = s.substring (0, i);
-    int_part = new Integer (s.substring (i + 1));
+    int_part = Integer.valueOf(s.substring (i + 1));
   }
 
   public int compareTo (Object o) {
Index: src/test/org/apache/lucene/search/TestCachingWrapperFilter.java
===================================================================
--- src/test/org/apache/lucene/search/TestCachingWrapperFilter.java	(revision 821119)
+++ src/test/org/apache/lucene/search/TestCachingWrapperFilter.java	(working copy)
@@ -81,9 +81,9 @@
     // not cacheable:
     assertDocIdSetCacheable(reader, new QueryWrapperFilter(new TermQuery(new Term("test","value"))), false);
     // returns default empty docidset, always cacheable:
-    assertDocIdSetCacheable(reader, NumericRangeFilter.newIntRange("test", new Integer(10000), new Integer(-10000), true, true), true);
+    assertDocIdSetCacheable(reader, NumericRangeFilter.newIntRange("test", Integer.valueOf(10000), Integer.valueOf(-10000), true, true), true);
     // is cacheable:
-    assertDocIdSetCacheable(reader, FieldCacheRangeFilter.newIntRange("test", new Integer(10), new Integer(20), true, true), true);
+    assertDocIdSetCacheable(reader, FieldCacheRangeFilter.newIntRange("test", Integer.valueOf(10), Integer.valueOf(20), true, true), true);
     // a openbitset filter is always cacheable
     assertDocIdSetCacheable(reader, new Filter() {
       public DocIdSet getDocIdSet(IndexReader reader) {
Index: src/test/org/apache/lucene/search/TestCustomSearcherSort.java
===================================================================
--- src/test/org/apache/lucene/search/TestCustomSearcherSort.java	(revision 821119)
+++ src/test/org/apache/lucene/search/TestCustomSearcherSort.java	(working copy)
@@ -156,8 +156,8 @@
         // store hits in TreeMap - TreeMap does not allow duplicates; existing entries are silently overwritten
         for(int hitid=0;hitid<hitsByRank.length; ++hitid) {
             resultMap.put(
-                    new Integer(hitsByRank[hitid].doc),  // Key:   Lucene Document ID
-                    new Integer(hitid));				// Value: Hits-Objekt Index
+                    Integer.valueOf(hitsByRank[hitid].doc),  // Key:   Lucene Document ID
+                    Integer.valueOf(hitid));				// Value: Hits-Objekt Index
         }
         
         // now make a query using the sort criteria
@@ -166,7 +166,7 @@
 		
         // besides the sorting both sets of hits must be identical
         for(int hitid=0;hitid<resultSort.length; ++hitid) {
-            Integer idHitDate = new Integer(resultSort[hitid].doc); // document ID from sorted search
+            Integer idHitDate = Integer.valueOf(resultSort[hitid].doc); // document ID from sorted search
             if(!resultMap.containsKey(idHitDate)) {
                 log("ID "+idHitDate+" not found. Possibliy a duplicate.");
             }
@@ -193,7 +193,7 @@
             for(int docnum=0;docnum<hits.length;++docnum) {
                 Integer luceneId = null;
 
-                luceneId = new Integer(hits[docnum].doc);
+                luceneId = Integer.valueOf(hits[docnum].doc);
                 if(idMap.containsKey(luceneId)) {
                     StringBuffer message = new StringBuffer(prefix);
                     message.append("Duplicate key for hit index = ");
@@ -204,7 +204,7 @@
                     message.append(luceneId);
                     log(message.toString());
                 } else { 
-                    idMap.put(luceneId, new Integer(docnum));
+                    idMap.put(luceneId, Integer.valueOf(docnum));
                 }
             }
         }
Index: src/test/org/apache/lucene/search/TestDocIdSet.java
===================================================================
--- src/test/org/apache/lucene/search/TestDocIdSet.java	(revision 821119)
+++ src/test/org/apache/lucene/search/TestDocIdSet.java	(working copy)
@@ -94,9 +94,9 @@
     ArrayList/*<Integer>*/ list = new ArrayList/*<Integer>*/();
     int doc = iter.advance(3);
     if (doc != DocIdSetIterator.NO_MORE_DOCS) {
-      list.add(new Integer(doc));
+      list.add(Integer.valueOf(doc));
       while((doc = iter.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
-        list.add(new Integer(doc));
+        list.add(Integer.valueOf(doc));
       }
     }
 	  
Index: src/test/org/apache/lucene/search/TestElevationComparator.java
===================================================================
--- src/test/org/apache/lucene/search/TestElevationComparator.java	(revision 821119)
+++ src/test/org/apache/lucene/search/TestElevationComparator.java	(working copy)
@@ -110,7 +110,7 @@
    int max = (vals.length / 2) + 5;
    for (int i = 0; i < vals.length - 1; i += 2) {
      q.add(new TermQuery(new Term(vals[i], vals[i + 1])), BooleanClause.Occur.SHOULD);
-     priority.put(vals[i + 1], new Integer(max--));
+     priority.put(vals[i + 1], Integer.valueOf(max--));
      // System.out.println(" pri doc=" + vals[i+1] + " pri=" + (1+max));
    }
    return q;
@@ -166,7 +166,7 @@
      }
 
      public Comparable value(int slot) {
-       return new Integer(values[slot]);
+       return Integer.valueOf(values[slot]);
      }
    };
  }
Index: src/test/org/apache/lucene/search/TestFieldCacheRangeFilter.java
===================================================================
--- src/test/org/apache/lucene/search/TestFieldCacheRangeFilter.java	(revision 821119)
+++ src/test/org/apache/lucene/search/TestFieldCacheRangeFilter.java	(working copy)
@@ -203,9 +203,9 @@
 
     int numDocs = reader.numDocs();
     int medId = ((maxId - minId) / 2);
-    Short minIdO = new Short((short) minId);
-    Short maxIdO = new Short((short) maxId);
-    Short medIdO = new Short((short) medId);
+    Short minIdO = Short.valueOf((short) minId);
+    Short maxIdO = Short.valueOf((short) maxId);
+    Short medIdO = Short.valueOf((short) medId);
         
     assertEquals("num of docs", numDocs, 1+ maxId - minId);
         
@@ -279,9 +279,9 @@
     assertEquals("med,med,T,T", 1, result.length);
     
     // special cases
-    result = search.search(q,FieldCacheRangeFilter.newShortRange("id",new Short(Short.MAX_VALUE),null,F,F), numDocs).scoreDocs;
+    result = search.search(q,FieldCacheRangeFilter.newShortRange("id",Short.valueOf(Short.MAX_VALUE),null,F,F), numDocs).scoreDocs;
     assertEquals("overflow special case", 0, result.length);
-    result = search.search(q,FieldCacheRangeFilter.newShortRange("id",null,new Short(Short.MIN_VALUE),F,F), numDocs).scoreDocs;
+    result = search.search(q,FieldCacheRangeFilter.newShortRange("id",null,Short.valueOf(Short.MIN_VALUE),F,F), numDocs).scoreDocs;
     assertEquals("overflow special case", 0, result.length);
     result = search.search(q,FieldCacheRangeFilter.newShortRange("id",maxIdO,minIdO,T,T), numDocs).scoreDocs;
     assertEquals("inverse range", 0, result.length);
@@ -294,9 +294,9 @@
 
     int numDocs = reader.numDocs();
     int medId = ((maxId - minId) / 2);
-    Integer minIdO = new Integer(minId);
-    Integer maxIdO = new Integer(maxId);
-    Integer medIdO = new Integer(medId);
+    Integer minIdO = Integer.valueOf(minId);
+    Integer maxIdO = Integer.valueOf(maxId);
+    Integer medIdO = Integer.valueOf(medId);
         
     assertEquals("num of docs", numDocs, 1+ maxId - minId);
         
@@ -371,9 +371,9 @@
     assertEquals("med,med,T,T", 1, result.length);
     
     // special cases
-    result = search.search(q,FieldCacheRangeFilter.newIntRange("id",new Integer(Integer.MAX_VALUE),null,F,F), numDocs).scoreDocs;
+    result = search.search(q,FieldCacheRangeFilter.newIntRange("id",Integer.valueOf(Integer.MAX_VALUE),null,F,F), numDocs).scoreDocs;
     assertEquals("overflow special case", 0, result.length);
-    result = search.search(q,FieldCacheRangeFilter.newIntRange("id",null,new Integer(Integer.MIN_VALUE),F,F), numDocs).scoreDocs;
+    result = search.search(q,FieldCacheRangeFilter.newIntRange("id",null,Integer.valueOf(Integer.MIN_VALUE),F,F), numDocs).scoreDocs;
     assertEquals("overflow special case", 0, result.length);
     result = search.search(q,FieldCacheRangeFilter.newIntRange("id",maxIdO,minIdO,T,T), numDocs).scoreDocs;
     assertEquals("inverse range", 0, result.length);
@@ -386,9 +386,9 @@
 
     int numDocs = reader.numDocs();
     int medId = ((maxId - minId) / 2);
-    Long minIdO = new Long(minId);
-    Long maxIdO = new Long(maxId);
-    Long medIdO = new Long(medId);
+    Long minIdO = Long.valueOf(minId);
+    Long maxIdO = Long.valueOf(maxId);
+    Long medIdO = Long.valueOf(medId);
         
     assertEquals("num of docs", numDocs, 1+ maxId - minId);
         
@@ -463,9 +463,9 @@
     assertEquals("med,med,T,T", 1, result.length);
     
     // special cases
-    result = search.search(q,FieldCacheRangeFilter.newLongRange("id",new Long(Long.MAX_VALUE),null,F,F), numDocs).scoreDocs;
+    result = search.search(q,FieldCacheRangeFilter.newLongRange("id",Long.valueOf(Long.MAX_VALUE),null,F,F), numDocs).scoreDocs;
     assertEquals("overflow special case", 0, result.length);
-    result = search.search(q,FieldCacheRangeFilter.newLongRange("id",null,new Long(Long.MIN_VALUE),F,F), numDocs).scoreDocs;
+    result = search.search(q,FieldCacheRangeFilter.newLongRange("id",null,Long.valueOf(Long.MIN_VALUE),F,F), numDocs).scoreDocs;
     assertEquals("overflow special case", 0, result.length);
     result = search.search(q,FieldCacheRangeFilter.newLongRange("id",maxIdO,minIdO,T,T), numDocs).scoreDocs;
     assertEquals("inverse range", 0, result.length);
@@ -479,8 +479,8 @@
     IndexSearcher search = new IndexSearcher(reader);
 
     int numDocs = reader.numDocs();
-    Float minIdO = new Float(minId + .5f);
-    Float medIdO = new Float(minIdO.floatValue() + ((float) (maxId-minId))/2.0f);
+    Float minIdO = Float.valueOf(minId + .5f);
+    Float medIdO = Float.valueOf(minIdO.floatValue() + ((float) (maxId-minId))/2.0f);
         
     ScoreDoc[] result;
     Query q = new TermQuery(new Term("body","body"));
@@ -495,9 +495,9 @@
     assertEquals("sum of two concenatted ranges", numDocs, count);
     result = search.search(q,FieldCacheRangeFilter.newFloatRange("id",null,null,T,T), numDocs).scoreDocs;
     assertEquals("find all", numDocs, result.length);
-    result = search.search(q,FieldCacheRangeFilter.newFloatRange("id",new Float(Float.POSITIVE_INFINITY),null,F,F), numDocs).scoreDocs;
+    result = search.search(q,FieldCacheRangeFilter.newFloatRange("id",Float.valueOf(Float.POSITIVE_INFINITY),null,F,F), numDocs).scoreDocs;
     assertEquals("infinity special case", 0, result.length);
-    result = search.search(q,FieldCacheRangeFilter.newFloatRange("id",null,new Float(Float.NEGATIVE_INFINITY),F,F), numDocs).scoreDocs;
+    result = search.search(q,FieldCacheRangeFilter.newFloatRange("id",null,Float.valueOf(Float.NEGATIVE_INFINITY),F,F), numDocs).scoreDocs;
     assertEquals("infinity special case", 0, result.length);
   }
   
@@ -507,8 +507,8 @@
     IndexSearcher search = new IndexSearcher(reader);
 
     int numDocs = reader.numDocs();
-    Double minIdO = new Double(minId + .5);
-    Double medIdO = new Double(minIdO.floatValue() + ((double) (maxId-minId))/2.0);
+    Double minIdO = Double.valueOf(minId + .5);
+    Double medIdO = Double.valueOf(minIdO.floatValue() + ((double) (maxId-minId))/2.0);
         
     ScoreDoc[] result;
     Query q = new TermQuery(new Term("body","body"));
@@ -523,9 +523,9 @@
     assertEquals("sum of two concenatted ranges", numDocs, count);
     result = search.search(q,FieldCacheRangeFilter.newDoubleRange("id",null,null,T,T), numDocs).scoreDocs;
     assertEquals("find all", numDocs, result.length);
-    result = search.search(q,FieldCacheRangeFilter.newDoubleRange("id",new Double(Double.POSITIVE_INFINITY),null,F,F), numDocs).scoreDocs;
+    result = search.search(q,FieldCacheRangeFilter.newDoubleRange("id",Double.valueOf(Double.POSITIVE_INFINITY),null,F,F), numDocs).scoreDocs;
     assertEquals("infinity special case", 0, result.length);
-    result = search.search(q,FieldCacheRangeFilter.newDoubleRange("id",null, new Double(Double.NEGATIVE_INFINITY),F,F), numDocs).scoreDocs;
+    result = search.search(q,FieldCacheRangeFilter.newDoubleRange("id",null, Double.valueOf(Double.NEGATIVE_INFINITY),F,F), numDocs).scoreDocs;
     assertEquals("infinity special case", 0, result.length);
   }
   
@@ -553,23 +553,23 @@
     FieldCacheRangeFilter fcrf;
     Query q = new TermQuery(new Term("body","body"));
 
-    result = search.search(q,fcrf=FieldCacheRangeFilter.newByteRange("id",new Byte((byte) -20),new Byte((byte) 20),T,T), 100).scoreDocs;
+    result = search.search(q,fcrf=FieldCacheRangeFilter.newByteRange("id",Byte.valueOf((byte) -20),Byte.valueOf((byte) 20),T,T), 100).scoreDocs;
     assertFalse("DocIdSet must be not cacheable", fcrf.getDocIdSet(reader.getSequentialSubReaders()[0]).isCacheable());
     assertEquals("find all", 40, result.length);
 
-    result = search.search(q,fcrf=FieldCacheRangeFilter.newByteRange("id",new Byte((byte) 0),new Byte((byte) 20),T,T), 100).scoreDocs;
+    result = search.search(q,fcrf=FieldCacheRangeFilter.newByteRange("id",Byte.valueOf((byte) 0),Byte.valueOf((byte) 20),T,T), 100).scoreDocs;
     assertFalse("DocIdSet must be not cacheable", fcrf.getDocIdSet(reader.getSequentialSubReaders()[0]).isCacheable());
     assertEquals("find all", 20, result.length);
 
-    result = search.search(q,fcrf=FieldCacheRangeFilter.newByteRange("id",new Byte((byte) -20),new Byte((byte) 0),T,T), 100).scoreDocs;
+    result = search.search(q,fcrf=FieldCacheRangeFilter.newByteRange("id",Byte.valueOf((byte) -20),Byte.valueOf((byte) 0),T,T), 100).scoreDocs;
     assertFalse("DocIdSet must be not cacheable", fcrf.getDocIdSet(reader.getSequentialSubReaders()[0]).isCacheable());
     assertEquals("find all", 20, result.length);
 
-    result = search.search(q,fcrf=FieldCacheRangeFilter.newByteRange("id",new Byte((byte) 10),new Byte((byte) 20),T,T), 100).scoreDocs;
+    result = search.search(q,fcrf=FieldCacheRangeFilter.newByteRange("id",Byte.valueOf((byte) 10),Byte.valueOf((byte) 20),T,T), 100).scoreDocs;
     assertTrue("DocIdSet must be cacheable", fcrf.getDocIdSet(reader.getSequentialSubReaders()[0]).isCacheable());
     assertEquals("find all", 11, result.length);
 
-    result = search.search(q,fcrf=FieldCacheRangeFilter.newByteRange("id",new Byte((byte) -20),new Byte((byte) -10),T,T), 100).scoreDocs;
+    result = search.search(q,fcrf=FieldCacheRangeFilter.newByteRange("id",Byte.valueOf((byte) -20),Byte.valueOf((byte) -10),T,T), 100).scoreDocs;
     assertTrue("DocIdSet must be cacheable", fcrf.getDocIdSet(reader.getSequentialSubReaders()[0]).isCacheable());
     assertEquals("find all", 11, result.length);
   }
Index: src/test/org/apache/lucene/search/TestSort.java
===================================================================
--- src/test/org/apache/lucene/search/TestSort.java	(revision 821119)
+++ src/test/org/apache/lucene/search/TestSort.java	(working copy)
@@ -441,7 +441,7 @@
     }
 
     public Comparable value(int slot) {
-      return new Integer(slotValues[slot]);
+      return Integer.valueOf(slotValues[slot]);
     }
   }
 
@@ -1018,7 +1018,7 @@
       Document doc = searcher.doc(hits[i].doc);
       String[] v = doc.getValues("tracer");
       assertEquals (v.length, 1);
-      scoreMap.put (v[0], new Float(hits[i].score));
+      scoreMap.put (v[0], Float.valueOf(hits[i].score));
     }
     return scoreMap;
   }
Index: src/test/org/apache/lucene/search/TestTermVectors.java
===================================================================
--- src/test/org/apache/lucene/search/TestTermVectors.java	(revision 821119)
+++ src/test/org/apache/lucene/search/TestTermVectors.java	(working copy)
@@ -208,17 +208,17 @@
     String test3 = "a chocolate lab grows old"; //5 terms
     String test4 = "eating chocolate with a chocolate lab in an old chocolate colored computer lab"; //13 terms
     Map test4Map = new HashMap();
-    test4Map.put("chocolate", new Integer(3));
-    test4Map.put("lab", new Integer(2));
-    test4Map.put("eating", new Integer(1));
-    test4Map.put("computer", new Integer(1));
-    test4Map.put("with", new Integer(1));
-    test4Map.put("a", new Integer(1));
-    test4Map.put("colored", new Integer(1));
-    test4Map.put("in", new Integer(1));
-    test4Map.put("an", new Integer(1));
-    test4Map.put("computer", new Integer(1));
-    test4Map.put("old", new Integer(1));
+    test4Map.put("chocolate", Integer.valueOf(3));
+    test4Map.put("lab", Integer.valueOf(2));
+    test4Map.put("eating", Integer.valueOf(1));
+    test4Map.put("computer", Integer.valueOf(1));
+    test4Map.put("with", Integer.valueOf(1));
+    test4Map.put("a", Integer.valueOf(1));
+    test4Map.put("colored", Integer.valueOf(1));
+    test4Map.put("in", Integer.valueOf(1));
+    test4Map.put("an", Integer.valueOf(1));
+    test4Map.put("computer", Integer.valueOf(1));
+    test4Map.put("old", Integer.valueOf(1));
     
     Document testDoc1 = new Document();
     setupDoc(testDoc1, test1);
Index: src/test/org/apache/lucene/store/MockRAMDirectory.java
===================================================================
--- src/test/org/apache/lucene/store/MockRAMDirectory.java	(revision 821119)
+++ src/test/org/apache/lucene/store/MockRAMDirectory.java	(working copy)
@@ -236,10 +236,10 @@
     else {
       if (openFiles.containsKey(name)) {
         Integer v = (Integer) openFiles.get(name);
-        v = new Integer(v.intValue()+1);
+        v = Integer.valueOf(v.intValue()+1);
         openFiles.put(name, v);
       } else {
-         openFiles.put(name, new Integer(1));
+         openFiles.put(name, Integer.valueOf(1));
       }
     }
     return new MockRAMInputStream(this, name, file);
Index: src/test/org/apache/lucene/store/MockRAMInputStream.java
===================================================================
--- src/test/org/apache/lucene/store/MockRAMInputStream.java	(revision 821119)
+++ src/test/org/apache/lucene/store/MockRAMInputStream.java	(working copy)
@@ -50,7 +50,7 @@
           if (v.intValue() == 1) {
             dir.openFiles.remove(name);
           } else {
-            v = new Integer(v.intValue()-1);
+            v = Integer.valueOf(v.intValue()-1);
             dir.openFiles.put(name, v);
           }
         }
@@ -68,7 +68,7 @@
     synchronized(dir.openFiles) {
       if (dir.openFiles.containsKey(name)) {
         Integer v = (Integer) dir.openFiles.get(name);
-        v = new Integer(v.intValue()+1);
+        v = Integer.valueOf(v.intValue()+1);
         dir.openFiles.put(name, v);
       } else {
         throw new RuntimeException("BUG: cloned file was not open?");
Index: src/test/org/apache/lucene/store/TestHugeRamFile.java
===================================================================
--- src/test/org/apache/lucene/store/TestHugeRamFile.java	(revision 821119)
+++ src/test/org/apache/lucene/store/TestHugeRamFile.java	(working copy)
@@ -36,11 +36,11 @@
       capacity += size;
       if (capacity <= MAX_VALUE) {
         // below maxint we reuse buffers
-        byte buf[] = (byte[]) singleBuffers.get(new Integer(size));
+        byte buf[] = (byte[]) singleBuffers.get(Integer.valueOf(size));
         if (buf==null) {
           buf = new byte[size]; 
           //System.out.println("allocate: "+size);
-          singleBuffers.put(new Integer(size),buf);
+          singleBuffers.put(Integer.valueOf(size),buf);
         }
         return buf;
       }
Index: src/test/org/apache/lucene/util/cache/TestSimpleLRUCache.java
===================================================================
--- src/test/org/apache/lucene/util/cache/TestSimpleLRUCache.java	(revision 821119)
+++ src/test/org/apache/lucene/util/cache/TestSimpleLRUCache.java	(working copy)
@@ -28,34 +28,34 @@
     Cache cache = new SimpleLRUCache(n);
     
     for (int i = 0; i < n; i++) {
-      cache.put(new Integer(i), dummy);
+      cache.put(Integer.valueOf(i), dummy);
     }
     
     // access every 2nd item in cache
     for (int i = 0; i < n; i+=2) {
-      assertNotNull(cache.get(new Integer(i)));
+      assertNotNull(cache.get(Integer.valueOf(i)));
     }
     
     // add n/2 elements to cache, the ones that weren't
     // touched in the previous loop should now be thrown away
     for (int i = n; i < n + (n / 2); i++) {
-      cache.put(new Integer(i), dummy);
+      cache.put(Integer.valueOf(i), dummy);
     }
     
     // access every 4th item in cache
     for (int i = 0; i < n; i+=4) {
-      assertNotNull(cache.get(new Integer(i)));
+      assertNotNull(cache.get(Integer.valueOf(i)));
     }
 
     // add 3/4n elements to cache, the ones that weren't
     // touched in the previous loops should now be thrown away
     for (int i = n; i < n + (n * 3 / 4); i++) {
-      cache.put(new Integer(i), dummy);
+      cache.put(Integer.valueOf(i), dummy);
     }
     
     // access every 4th item in cache
     for (int i = 0; i < n; i+=4) {
-      assertNotNull(cache.get(new Integer(i)));
+      assertNotNull(cache.get(Integer.valueOf(i)));
     }
     
   }
Index: src/test/org/apache/lucene/util/LuceneTestCase.java
===================================================================
--- src/test/org/apache/lucene/util/LuceneTestCase.java	(revision 821119)
+++ src/test/org/apache/lucene/util/LuceneTestCase.java	(working copy)
@@ -201,7 +201,7 @@
     if (this.seed != null) {
       throw new IllegalStateException("please call LuceneTestCase.newRandom only once per test");
     }
-    this.seed = new Long(seed);
+    this.seed = Long.valueOf(seed);
     return new Random(seed);
   }
   
Index: src/test/org/apache/lucene/util/TestNumericUtils.java
===================================================================
--- src/test/org/apache/lucene/util/TestNumericUtils.java	(revision 821119)
+++ src/test/org/apache/lucene/util/TestNumericUtils.java	(working copy)
@@ -188,7 +188,7 @@
         // make unsigned longs for easier display and understanding
         min ^= 0x8000000000000000L;
         max ^= 0x8000000000000000L;
-        //System.out.println("new Long(0x"+Long.toHexString(min>>>shift)+"L),new Long(0x"+Long.toHexString(max>>>shift)+"L),");
+        //System.out.println("Long.valueOf(0x"+Long.toHexString(min>>>shift)+"L),Long.valueOf(0x"+Long.toHexString(max>>>shift)+"L),");
         assertEquals( "inner min bound", ((Long)neededBounds.next()).longValue(), min>>>shift);
         assertEquals( "inner max bound", ((Long)neededBounds.next()).longValue(), max>>>shift);
       }
@@ -204,45 +204,45 @@
   public void testSplitLongRange() throws Exception {
     // a hard-coded "standard" range
     assertLongRangeSplit(-5000L, 9500L, 4, true, Arrays.asList(new Long[]{
-      new Long(0x7fffffffffffec78L),new Long(0x7fffffffffffec7fL),
-      new Long(0x8000000000002510L),new Long(0x800000000000251cL),
-      new Long(0x7fffffffffffec8L), new Long(0x7fffffffffffecfL),
-      new Long(0x800000000000250L), new Long(0x800000000000250L),
-      new Long(0x7fffffffffffedL),  new Long(0x7fffffffffffefL),
-      new Long(0x80000000000020L),  new Long(0x80000000000024L),
-      new Long(0x7ffffffffffffL),   new Long(0x8000000000001L)
+      Long.valueOf(0x7fffffffffffec78L),Long.valueOf(0x7fffffffffffec7fL),
+      Long.valueOf(0x8000000000002510L),Long.valueOf(0x800000000000251cL),
+      Long.valueOf(0x7fffffffffffec8L), Long.valueOf(0x7fffffffffffecfL),
+      Long.valueOf(0x800000000000250L), Long.valueOf(0x800000000000250L),
+      Long.valueOf(0x7fffffffffffedL),  Long.valueOf(0x7fffffffffffefL),
+      Long.valueOf(0x80000000000020L),  Long.valueOf(0x80000000000024L),
+      Long.valueOf(0x7ffffffffffffL),   Long.valueOf(0x8000000000001L)
     }).iterator());
     
     // the same with no range splitting
     assertLongRangeSplit(-5000L, 9500L, 64, true, Arrays.asList(new Long[]{
-      new Long(0x7fffffffffffec78L),new Long(0x800000000000251cL)
+      Long.valueOf(0x7fffffffffffec78L),Long.valueOf(0x800000000000251cL)
     }).iterator());
     
     // this tests optimized range splitting, if one of the inner bounds
     // is also the bound of the next lower precision, it should be used completely
     assertLongRangeSplit(0L, 1024L+63L, 4, true, Arrays.asList(new Long[]{
-      new Long(0x800000000000040L), new Long(0x800000000000043L),
-      new Long(0x80000000000000L),  new Long(0x80000000000003L)
+      Long.valueOf(0x800000000000040L), Long.valueOf(0x800000000000043L),
+      Long.valueOf(0x80000000000000L),  Long.valueOf(0x80000000000003L)
     }).iterator());
     
     // the full long range should only consist of a lowest precision range; no bitset testing here, as too much memory needed :-)
     assertLongRangeSplit(Long.MIN_VALUE, Long.MAX_VALUE, 8, false, Arrays.asList(new Long[]{
-      new Long(0x00L),new Long(0xffL)
+      Long.valueOf(0x00L),Long.valueOf(0xffL)
     }).iterator());
 
     // the same with precisionStep=4
     assertLongRangeSplit(Long.MIN_VALUE, Long.MAX_VALUE, 4, false, Arrays.asList(new Long[]{
-      new Long(0x0L),new Long(0xfL)
+      Long.valueOf(0x0L),Long.valueOf(0xfL)
     }).iterator());
 
     // the same with precisionStep=2
     assertLongRangeSplit(Long.MIN_VALUE, Long.MAX_VALUE, 2, false, Arrays.asList(new Long[]{
-      new Long(0x0L),new Long(0x3L)
+      Long.valueOf(0x0L),Long.valueOf(0x3L)
     }).iterator());
 
     // the same with precisionStep=1
     assertLongRangeSplit(Long.MIN_VALUE, Long.MAX_VALUE, 1, false, Arrays.asList(new Long[]{
-      new Long(0x0L),new Long(0x1L)
+      Long.valueOf(0x0L),Long.valueOf(0x1L)
     }).iterator());
 
     // a inverse range should produce no sub-ranges
@@ -250,7 +250,7 @@
 
     // a 0-length range should reproduce the range itsself
     assertLongRangeSplit(9500L, 9500L, 4, false, Arrays.asList(new Long[]{
-      new Long(0x800000000000251cL),new Long(0x800000000000251cL)
+      Long.valueOf(0x800000000000251cL),Long.valueOf(0x800000000000251cL)
     }).iterator());
   }
 
@@ -270,7 +270,7 @@
         // make unsigned ints for easier display and understanding
         min ^= 0x80000000;
         max ^= 0x80000000;
-        //System.out.println("new Integer(0x"+Integer.toHexString(min>>>shift)+"),new Integer(0x"+Integer.toHexString(max>>>shift)+"),");
+        //System.out.println("Integer.valueOf(0x"+Integer.toHexString(min>>>shift)+"),Integer.valueOf(0x"+Integer.toHexString(max>>>shift)+"),");
         assertEquals( "inner min bound", ((Integer)neededBounds.next()).intValue(), min>>>shift);
         assertEquals( "inner max bound", ((Integer)neededBounds.next()).intValue(), max>>>shift);
       }
@@ -286,45 +286,45 @@
   public void testSplitIntRange() throws Exception {
     // a hard-coded "standard" range
     assertIntRangeSplit(-5000, 9500, 4, true, Arrays.asList(new Integer[]{
-      new Integer(0x7fffec78),new Integer(0x7fffec7f),
-      new Integer(0x80002510),new Integer(0x8000251c),
-      new Integer(0x7fffec8), new Integer(0x7fffecf),
-      new Integer(0x8000250), new Integer(0x8000250),
-      new Integer(0x7fffed),  new Integer(0x7fffef),
-      new Integer(0x800020),  new Integer(0x800024),
-      new Integer(0x7ffff),   new Integer(0x80001)
+      Integer.valueOf(0x7fffec78),Integer.valueOf(0x7fffec7f),
+      Integer.valueOf(0x80002510),Integer.valueOf(0x8000251c),
+      Integer.valueOf(0x7fffec8), Integer.valueOf(0x7fffecf),
+      Integer.valueOf(0x8000250), Integer.valueOf(0x8000250),
+      Integer.valueOf(0x7fffed),  Integer.valueOf(0x7fffef),
+      Integer.valueOf(0x800020),  Integer.valueOf(0x800024),
+      Integer.valueOf(0x7ffff),   Integer.valueOf(0x80001)
     }).iterator());
     
     // the same with no range splitting
     assertIntRangeSplit(-5000, 9500, 32, true, Arrays.asList(new Integer[]{
-      new Integer(0x7fffec78),new Integer(0x8000251c)
+      Integer.valueOf(0x7fffec78),Integer.valueOf(0x8000251c)
     }).iterator());
     
     // this tests optimized range splitting, if one of the inner bounds
     // is also the bound of the next lower precision, it should be used completely
     assertIntRangeSplit(0, 1024+63, 4, true, Arrays.asList(new Integer[]{
-      new Integer(0x8000040), new Integer(0x8000043),
-      new Integer(0x800000),  new Integer(0x800003)
+      Integer.valueOf(0x8000040), Integer.valueOf(0x8000043),
+      Integer.valueOf(0x800000),  Integer.valueOf(0x800003)
     }).iterator());
     
     // the full int range should only consist of a lowest precision range; no bitset testing here, as too much memory needed :-)
     assertIntRangeSplit(Integer.MIN_VALUE, Integer.MAX_VALUE, 8, false, Arrays.asList(new Integer[]{
-      new Integer(0x00),new Integer(0xff)
+      Integer.valueOf(0x00),Integer.valueOf(0xff)
     }).iterator());
 
     // the same with precisionStep=4
     assertIntRangeSplit(Integer.MIN_VALUE, Integer.MAX_VALUE, 4, false, Arrays.asList(new Integer[]{
-      new Integer(0x0),new Integer(0xf)
+      Integer.valueOf(0x0),Integer.valueOf(0xf)
     }).iterator());
 
     // the same with precisionStep=2
     assertIntRangeSplit(Integer.MIN_VALUE, Integer.MAX_VALUE, 2, false, Arrays.asList(new Integer[]{
-      new Integer(0x0),new Integer(0x3)
+      Integer.valueOf(0x0),Integer.valueOf(0x3)
     }).iterator());
 
     // the same with precisionStep=1
     assertIntRangeSplit(Integer.MIN_VALUE, Integer.MAX_VALUE, 1, false, Arrays.asList(new Integer[]{
-      new Integer(0x0),new Integer(0x1)
+      Integer.valueOf(0x0),Integer.valueOf(0x1)
     }).iterator());
 
     // a inverse range should produce no sub-ranges
@@ -332,7 +332,7 @@
 
     // a 0-length range should reproduce the range itsself
     assertIntRangeSplit(9500, 9500, 4, false, Arrays.asList(new Integer[]{
-      new Integer(0x8000251c),new Integer(0x8000251c)
+      Integer.valueOf(0x8000251c),Integer.valueOf(0x8000251c)
     }).iterator());
   }
 
