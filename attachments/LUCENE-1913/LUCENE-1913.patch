Index: contrib/fast-vector-highlighter/src/test/org/apache/lucene/search/vectorhighlight/FieldQueryTest.java
===================================================================
--- contrib/fast-vector-highlighter/src/test/org/apache/lucene/search/vectorhighlight/FieldQueryTest.java	(revision 816162)
+++ contrib/fast-vector-highlighter/src/test/org/apache/lucene/search/vectorhighlight/FieldQueryTest.java	(working copy)
@@ -94,6 +94,13 @@
     assertCollectionQueries( fq.expand( flatQueries ),
         pqF( "a", "b", "c" ), pqF( "c", "d", "e" ), pqF( "a", "b", "c", "d", "e" ) );
 
+    // "a b c d","b c" => "a b c d","b c"
+    flatQueries = new HashSet<Query>();
+    flatQueries.add( pqF( "a", "b", "c", "d" ) );
+    flatQueries.add( pqF( "b", "c" ) );
+    assertCollectionQueries( fq.expand( flatQueries ),
+        pqF( "a", "b", "c", "d" ), pqF( "b", "c" ) );
+
     // "a b b","b c" => "a b b","b c","a b b c"
     flatQueries = new HashSet<Query>();
     flatQueries.add( pqF( "a", "b", "b" ) );
Index: contrib/fast-vector-highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java
===================================================================
--- contrib/fast-vector-highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java	(revision 816162)
+++ contrib/fast-vector-highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java	(working copy)
@@ -148,6 +148,7 @@
    * ex6) src="a b c", dest="b"       => no overlap
    * ex7) src="a a a a", dest="a a a" => overlap;
    *                                     expandQueries={"a a a a a","a a a a a a"}
+   * ex8) src="a b c d", dest="b c"   => no overlap
    */
   private void checkOverlap( Collection<Query> expandQueries, Term[] src, Term[] dest, int slop, float boost ){
     // beginning from 1 (not 0) is safe because that the PhraseQuery has multiple terms
@@ -156,7 +157,7 @@
     for( int i = 1; i < src.length; i++ ){
       boolean overlap = true;
       for( int j = i; j < src.length; j++ ){
-        if( !src[j].text().equals( dest[j-i].text() ) ){
+        if( ( j - i ) < dest.length && !src[j].text().equals( dest[j-i].text() ) ){
           overlap = false;
           break;
         }
