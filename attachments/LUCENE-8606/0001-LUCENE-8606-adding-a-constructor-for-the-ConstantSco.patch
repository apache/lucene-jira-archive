From 3a752bef19d10d615eddb0a74ff1429b7ce153d5 Mon Sep 17 00:00:00 2001
From: Christian Ziech <christian.ziech@here.com>
Date: Wed, 12 Dec 2018 14:57:33 +0100
Subject: [PATCH] LUCENE-8606: adding a constructor for the ConstantScoreWeight
 that wakes a Weight and score

This solves a problem with the inability to properly expose explanations for more
complex inner queries that are wrapped in a ConstantScoreQuery. This e.g. happens
for filter clauses of a BooleanQuery.
---
 .../lucene/search/ConstantScoreQuery.java     |  6 +--
 .../lucene/search/ConstantScoreWeight.java    | 24 +++++++++
 .../apache/lucene/search/LRUQueryCache.java   | 50 +++++++++----------
 3 files changed, 51 insertions(+), 29 deletions(-)

diff --git a/lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java b/lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java
index 5c9ed19f89..bf031dabed 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java
@@ -107,9 +107,9 @@ public final class ConstantScoreQuery extends Query {
 
   @Override
   public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {
-    final Weight innerWeight = searcher.createWeight(query, ScoreMode.COMPLETE_NO_SCORES, 1f);
+    final Weight inner = searcher.createWeight(query, ScoreMode.COMPLETE_NO_SCORES, 1f);
     if (scoreMode.needsScores()) {
-      return new ConstantScoreWeight(this, boost) {
+      return new ConstantScoreWeight(inner, boost) {
 
         @Override
         public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {
@@ -175,7 +175,7 @@ public final class ConstantScoreQuery extends Query {
 
       };
     } else {
-      return innerWeight;
+      return inner;
     }
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/ConstantScoreWeight.java b/lucene/core/src/java/org/apache/lucene/search/ConstantScoreWeight.java
index 671ec71037..f9e114032d 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ConstantScoreWeight.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ConstantScoreWeight.java
@@ -33,9 +33,24 @@ import org.apache.lucene.index.Term;
 public abstract class ConstantScoreWeight extends Weight {
 
   private final float score;
+  protected final Weight innerWeight;
 
   protected ConstantScoreWeight(Query query, float score) {
     super(query);
+    this.innerWeight = null;
+    this.score = score;
+  }
+  
+  /**
+   * Creates a new ConstantScoreWeight to wrap the given Weight and overriding its score with the given constant
+   * score value.
+   * 
+   * @param weight The weight to wrap
+   * @param score The score to return by scorers produced by {@link Scorer scorers} of this weight
+   */
+  protected ConstantScoreWeight(Weight weight, float score) {
+    super(weight.parentQuery);
+    this.innerWeight = weight;
     this.score = score;
   }
 
@@ -53,6 +68,15 @@ public abstract class ConstantScoreWeight extends Weight {
 
   @Override
   public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+    if (innerWeight != null) {
+      final Explanation innerExplanation = innerWeight.explain(context, doc);
+      
+      if (innerExplanation.isMatch()) {
+        return Explanation.match(this.score, "Constant score", innerExplanation);
+      }
+      return Explanation.noMatch("No match for id "+doc, innerExplanation);
+    }
+    // the following code is here for those cases where the constructor ConstantScoreWeight(Query, float) is used 
     final Scorer s = scorer(context);
     final boolean exists;
     if (s == null) {
diff --git a/lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java b/lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java
index c2448edd42..a4a4d0a7ff 100644
--- a/lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java
+++ b/lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java
@@ -461,7 +461,7 @@ public class LRUQueryCache implements QueryCache, Accountable {
   @Override
   public Weight doCache(Weight weight, QueryCachingPolicy policy) {
     while (weight instanceof CachingWrapperWeight) {
-      weight = ((CachingWrapperWeight) weight).in;
+      weight = ((CachingWrapperWeight) weight).innerWeight;
     }
 
     return new CachingWrapperWeight(weight, policy);
@@ -660,27 +660,25 @@ public class LRUQueryCache implements QueryCache, Accountable {
 
   private class CachingWrapperWeight extends ConstantScoreWeight {
 
-    private final Weight in;
     private final QueryCachingPolicy policy;
     // we use an AtomicBoolean because Weight.scorer may be called from multiple
     // threads when IndexSearcher is created with threads
     private final AtomicBoolean used;
 
     CachingWrapperWeight(Weight in, QueryCachingPolicy policy) {
-      super(in.getQuery(), 1f);
-      this.in = in;
+      super(in, 1f);
       this.policy = policy;
       used = new AtomicBoolean(false);
     }
 
     @Override
     public void extractTerms(Set<Term> terms) {
-      in.extractTerms(terms);
+      innerWeight.extractTerms(terms);
     }
 
     @Override
     public Matches matches(LeafReaderContext context, int doc) throws IOException {
-      return in.matches(context, doc);
+      return innerWeight.matches(context, doc);
     }
 
     private boolean cacheEntryHasReasonableWorstCaseSize(int maxDoc) {
@@ -696,7 +694,7 @@ public class LRUQueryCache implements QueryCache, Accountable {
     }
 
     private DocIdSet cache(LeafReaderContext context) throws IOException {
-      final BulkScorer scorer = in.bulkScorer(context);
+      final BulkScorer scorer = innerWeight.bulkScorer(context);
       if (scorer == null) {
         return DocIdSet.EMPTY;
       } else {
@@ -716,41 +714,41 @@ public class LRUQueryCache implements QueryCache, Accountable {
         policy.onUse(getQuery());
       }
 
-      if (in.isCacheable(context) == false) {
+      if (innerWeight.isCacheable(context) == false) {
         // this segment is not suitable for caching
-        return in.scorerSupplier(context);
+        return innerWeight.scorerSupplier(context);
       }
 
       // Short-circuit: Check whether this segment is eligible for caching
       // before we take a lock because of #get
       if (shouldCache(context) == false) {
-        return in.scorerSupplier(context);
+        return innerWeight.scorerSupplier(context);
       }
 
       final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();
       if (cacheHelper == null) {
         // this reader has no cache helper
-        return in.scorerSupplier(context);
+        return innerWeight.scorerSupplier(context);
       }
 
       // If the lock is already busy, prefer using the uncached version than waiting
       if (lock.tryLock() == false) {
-        return in.scorerSupplier(context);
+        return innerWeight.scorerSupplier(context);
       }
 
       DocIdSet docIdSet;
       try {
-        docIdSet = get(in.getQuery(), context, cacheHelper);
+        docIdSet = get(innerWeight.getQuery(), context, cacheHelper);
       } finally {
         lock.unlock();
       }
 
       if (docIdSet == null) {
-        if (policy.shouldCache(in.getQuery())) {
+        if (policy.shouldCache(innerWeight.getQuery())) {
           docIdSet = cache(context);
-          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);
+          putIfAbsent(innerWeight.getQuery(), context, docIdSet, cacheHelper);
         } else {
-          return in.scorerSupplier(context);
+          return innerWeight.scorerSupplier(context);
         }
       }
 
@@ -788,7 +786,7 @@ public class LRUQueryCache implements QueryCache, Accountable {
 
     @Override
     public boolean isCacheable(LeafReaderContext ctx) {
-      return in.isCacheable(ctx);
+      return innerWeight.isCacheable(ctx);
     }
 
     @Override
@@ -797,41 +795,41 @@ public class LRUQueryCache implements QueryCache, Accountable {
         policy.onUse(getQuery());
       }
 
-      if (in.isCacheable(context) == false) {
+      if (innerWeight.isCacheable(context) == false) {
         // this segment is not suitable for caching
-        return in.bulkScorer(context);
+        return innerWeight.bulkScorer(context);
       }
 
       // Short-circuit: Check whether this segment is eligible for caching
       // before we take a lock because of #get
       if (shouldCache(context) == false) {
-        return in.bulkScorer(context);
+        return innerWeight.bulkScorer(context);
       }
 
       final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();
       if (cacheHelper == null) {
         // this reader has no cacheHelper
-        return in.bulkScorer(context);
+        return innerWeight.bulkScorer(context);
       }
 
       // If the lock is already busy, prefer using the uncached version than waiting
       if (lock.tryLock() == false) {
-        return in.bulkScorer(context);
+        return innerWeight.bulkScorer(context);
       }
 
       DocIdSet docIdSet;
       try {
-        docIdSet = get(in.getQuery(), context, cacheHelper);
+        docIdSet = get(innerWeight.getQuery(), context, cacheHelper);
       } finally {
         lock.unlock();
       }
 
       if (docIdSet == null) {
-        if (policy.shouldCache(in.getQuery())) {
+        if (policy.shouldCache(innerWeight.getQuery())) {
           docIdSet = cache(context);
-          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);
+          putIfAbsent(innerWeight.getQuery(), context, docIdSet, cacheHelper);
         } else {
-          return in.bulkScorer(context);
+          return innerWeight.bulkScorer(context);
         }
       }
 
-- 
2.19.0

