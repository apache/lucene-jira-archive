Index: lucene/src/test/org/apache/lucene/util/TestVersionComparator.java
===================================================================
--- lucene/src/test/org/apache/lucene/util/TestVersionComparator.java	(revision 1139242)
+++ lucene/src/test/org/apache/lucene/util/TestVersionComparator.java	(working copy)
@@ -43,5 +43,10 @@
     
     assertTrue(comp.compare("1.10", "1.9") > 0);
     assertTrue(comp.compare("1.9", "1.10") < 0);
+    
+    assertTrue(comp.compare("0", "1.0") < 0);
+    assertTrue(comp.compare("00", "1.0") < 0);
+    assertTrue(comp.compare("-1.0", "1.0") < 0);
+    assertTrue(comp.compare("3.0", Integer.toString(Integer.MIN_VALUE)) > 0);
   }
 }
Index: lucene/src/java/org/apache/lucene/index/CheckIndex.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/CheckIndex.java	(revision 1139242)
+++ lucene/src/java/org/apache/lucene/index/CheckIndex.java	(working copy)
@@ -22,6 +22,7 @@
 import org.apache.lucene.store.FSDirectory;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.document.AbstractField;  // for javadocs
 import org.apache.lucene.document.Document;
 
@@ -31,6 +32,7 @@
 import java.io.File;
 import java.util.Collection;
 
+import java.util.Comparator;
 import java.util.List;
 import java.util.ArrayList;
 import java.util.Map;
@@ -331,6 +333,27 @@
       return result;
     }
 
+    // find the oldest and newest segment versions
+    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);
+    String pre31 = null;
+    boolean foundNonNullVersion = false;
+    Comparator<String> versionComparator = StringHelper.getVersionComparator();
+    for (SegmentInfo si : sis) {
+      String version = si.getVersion();
+      if (version == null) {
+        // pre-3.1 segment
+        pre31 = "pre-3.1";
+      } else {
+        foundNonNullVersion = true;
+        if (versionComparator.compare(version, oldest) < 0) {
+          oldest = version;
+        }
+        if (versionComparator.compare(version, newest) > 0) {
+          newest = version;
+        }
+      }
+    }
+    
     final int numSegments = sis.size();
     final String segmentsFileName = sis.getCurrentSegmentFileName();
     IndexInput input = null;
@@ -382,7 +405,7 @@
       else if (format == SegmentInfos.FORMAT_HAS_VECTORS)
         sFormat = "FORMAT_HAS_VECTORS [Lucene 3.1]";
       else if (format == SegmentInfos.FORMAT_3_1)
-        sFormat = "FORMAT_3_1 [Lucene 3.1]";
+        sFormat = "FORMAT_3_1 [Lucene 3.1+]";
       else if (format == SegmentInfos.CURRENT_FORMAT)
         throw new RuntimeException("BUG: You should update this tool!");
       else if (format < SegmentInfos.CURRENT_FORMAT) {
@@ -404,7 +427,19 @@
       userDataString = "";
     }
 
-    msg("Segments file=" + segmentsFileName + " numSegments=" + numSegments + " version=" + sFormat + userDataString);
+    String versionString = null;
+    if (pre31 != null) {
+      if (foundNonNullVersion) {
+        versionString = "versions=[" + pre31 + " .. " + newest + "]";
+      } else {
+        versionString = "version=" + pre31;
+      }
+    } else {
+      versionString = oldest.equals(newest) ? ( "version=" + oldest ) : ("versions=[" + oldest + " .. " + newest + "]");
+    }
+    
+    msg("Segments file=" + segmentsFileName + " numSegments=" + numSegments
+        + " " + versionString + " format=" + sFormat + userDataString);
 
     if (onlySegments != null) {
       result.partial = true;
Index: lucene/src/java/org/apache/lucene/util/StringHelper.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/StringHelper.java	(revision 1139242)
+++ lucene/src/java/org/apache/lucene/util/StringHelper.java	(working copy)
@@ -76,7 +76,7 @@
         if (bTokens.hasMoreTokens()) {
           int bToken = Integer.parseInt(bTokens.nextToken());
           if (aToken != bToken) {
-            return aToken - bToken;
+            return aToken < bToken ? -1 : 1;
           }
         } else {
           // a has some extra trailing tokens. if these are all zeroes, thats ok.
