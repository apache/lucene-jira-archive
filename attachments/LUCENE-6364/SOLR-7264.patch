Index: solr/CHANGES.txt
===================================================================
--- solr/CHANGES.txt	(revision 1667866)
+++ solr/CHANGES.txt	(working copy)
@@ -134,6 +134,8 @@
 * SOLR-6892: Update processors can now be top-level components and they can be
   specified in request to create a new custom update chain (Noble Paul)
 
+* SOLR-7264: Add DocValues support to BoolField. Booleans will be stored as a 1 or 0.
+ 
 
 Bug Fixes
 ----------------------
Index: solr/core/src/java/org/apache/solr/schema/BoolField.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/BoolField.java	(revision 1667866)
+++ solr/core/src/java/org/apache/solr/schema/BoolField.java	(working copy)
@@ -18,11 +18,16 @@
 package org.apache.solr.schema;
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
 import java.util.Map;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.document.SortedSetDocValuesField;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.IndexableField;
@@ -33,6 +38,7 @@
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.uninverting.UninvertingReader.Type;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.BytesRefBuilder;
 import org.apache.lucene.util.CharsRef;
 import org.apache.lucene.util.CharsRefBuilder;
 import org.apache.lucene.util.mutable.MutableValue;
@@ -145,7 +151,7 @@
 
   private static final CharsRef TRUE = new CharsRef("true");
   private static final CharsRef FALSE = new CharsRef("false");
-  
+
   @Override
   public CharsRef indexedToReadable(BytesRef input, CharsRefBuilder charsRef) {
     if (input.length > 0 && input.bytes[input.offset] == 'T') {
@@ -170,6 +176,38 @@
   public Object unmarshalSortValue(Object value) {
     return unmarshalStringSortValue(value);
   }
+
+  @Override
+  public List<IndexableField> createFields(SchemaField sf, Object value, float boost) {
+    if (sf.hasDocValues()) {
+      List<IndexableField> fields = new ArrayList<>();
+      final IndexableField field = createField(sf, value, boost);
+      fields.add(field);
+
+      if (sf.multiValued()) {
+        BytesRefBuilder bytes = new BytesRefBuilder();
+        readableToIndexed(value.toString(), bytes);
+        fields.add(new SortedSetDocValuesField(sf.getName(), bytes.get()));
+      } else {
+        final long bits;
+        Boolean boolValue = toObject(field);
+        if (boolValue != null && boolValue.equals(Boolean.TRUE)) {
+          bits = 1;
+        } else {
+          bits = 0;
+        }
+        fields.add(new NumericDocValuesField(sf.getName(), bits));
+      }
+
+      return fields;
+    } else {
+      return Collections.singletonList(createField(sf, value, boost));
+    }
+  }
+
+  @Override
+  public void checkSchemaField(final SchemaField field) {
+  }
 }
 
 // TODO - this can be much more efficient - use FixedBitSet or Bits
