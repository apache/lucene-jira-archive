Index: contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
===================================================================
--- contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java	(révision 819480)
+++ contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java	(copie de travail)
@@ -155,12 +155,12 @@
     double miles = p1.arcDistance( p2, DistanceUnits.MILES );
     System.out.println("testDistances");
     System.out.println("miles:" + miles);
-    assertEquals(2288.82495932794, miles); 
+    assertEquals(2288.8249, miles, 1e-4); 
     LatLng p3 = new FloatLatLng( 41.6032207, -73.087749);
     LatLng p4 = new FloatLatLng( 55.0, 4.0 );
     miles = p3.arcDistance( p4, DistanceUnits.MILES );
     System.out.println("miles:" + miles);
-    assertEquals(3474.331719997617, miles); 
+    assertEquals(3474.3317, miles, 1e-4); 
   }
 
   public void testAntiM() throws IOException, InvalidGeoException {
Index: contrib/spatial/src/java/org/apache/lucene/spatial/geometry/LatLng.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/geometry/LatLng.java	(révision 819480)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/geometry/LatLng.java	(copie de travail)
@@ -29,6 +29,8 @@
  * release.</font>
  */
 public abstract class LatLng {
+  protected final static int LONGITUDE_DECIMAL_DEGREE_RANGE= 360;
+  protected final static int LATITUDE_DECIMAL_DEGREE_RANGE= 180;
 
   public abstract boolean isNormalized();
 
@@ -64,8 +66,8 @@
     int lng=ll.getFixedLng();
     
     return new CartesianPoint(
-        lng+180*FixedLatLng.SCALE_FACTOR_INT,
-        lat+90*FixedLatLng.SCALE_FACTOR_INT
+        lng+LONGITUDE_DECIMAL_DEGREE_RANGE/2*FixedLatLng.SCALE_FACTOR_INT,
+        lat+LATITUDE_DECIMAL_DEGREE_RANGE/2*FixedLatLng.SCALE_FACTOR_INT
     );
   }
   
@@ -74,8 +76,8 @@
    * @param pt
    */
   public static LatLng fromCartesian(CartesianPoint pt) {
-    int lat=pt.getY() - 90 * FixedLatLng.SCALE_FACTOR_INT;
-    int lng=pt.getX() - 180 * FixedLatLng.SCALE_FACTOR_INT;
+    int lat=pt.getY() - LATITUDE_DECIMAL_DEGREE_RANGE/2 * FixedLatLng.SCALE_FACTOR_INT;
+    int lng=pt.getX() - LONGITUDE_DECIMAL_DEGREE_RANGE/2 * FixedLatLng.SCALE_FACTOR_INT;
     
     return new FixedLatLng(lat, lng);
   }
@@ -97,7 +99,7 @@
    * Calculates the distance between two lat/lng's in miles or meters.
    * Imported from mq java client.  Variable references changed to match.
    * 
-   * @param ll2
+   * @param ll2s
    *            Second lat,lng position to calculate distance to.
    * @param lUnits
    *            Units to calculate distance, defaults to miles
@@ -108,39 +110,17 @@
     LatLng ll1 = normalize();
     ll2 = ll2.normalize();
 
-    double lat1 = ll1.getLat(), lng1 = ll1.getLng();
-    double lat2 = ll2.getLat(), lng2 = ll2.getLng();
+    double lat1 = Math.toRadians(ll1.getLat());
+    double lng1 = Math.toRadians(ll1.getLng());
+    double lat2 = Math.toRadians(ll2.getLat());
+    double lng2 = Math.toRadians(ll2.getLng());
 
-    // Check for same position
-    if (lat1 == lat2 && lng1 == lng2)
-      return 0.0;
-
-    // Get the m_dLongitude difference. Don't need to worry about
-    // crossing 180 since cos(x) = cos(-x)
-    double dLon = lng2 - lng1;
-
-    double a = radians(90.0 - lat1);
-    double c = radians(90.0 - lat2);
-    double cosB = (Math.cos(a) * Math.cos(c))
-        + (Math.sin(a) * Math.sin(c) * Math.cos(radians(dLon)));
-
     double radius = (lUnits == DistanceUnits.MILES) ? 3963.205/* MILERADIUSOFEARTH */
     : 6378.160187/* KMRADIUSOFEARTH */;
 
-    // Find angle subtended (with some bounds checking) in radians and
-    // multiply by earth radius to find the arc distance
-    if (cosB < -1.0)
-      return 3.14159265358979323846/* PI */* radius;
-    else if (cosB >= 1.0)
-      return 0;
-    else
-      return Math.acos(cosB) * radius;
+    return Math.acos( Math.sin(lat1)*Math.sin(lat2) + Math.cos(lat1)*Math.cos(lat2)*Math.cos(lng2-lng1)) * radius; 
   }
 
-  private double radians(double a) {
-    return a * 0.01745329251994;
-  }
-
   @Override
   public String toString() {
     return "[" + getLat() + "," + getLng() + "]";
Index: contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FloatLatLng.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FloatLatLng.java	(révision 819480)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FloatLatLng.java	(copie de travail)
@@ -26,9 +26,10 @@
   private double lat;
   private double lng;
   private boolean normalized;
+
   
   public FloatLatLng(double lat, double lng) {
-    if (lat>90.0 || lat<-90.0) throw new IllegalArgumentException("Illegal latitude value " + lat);
+    if (lat>LATITUDE_DECIMAL_DEGREE_RANGE/2 || lat<-LATITUDE_DECIMAL_DEGREE_RANGE/2) throw new IllegalArgumentException("Illegal latitude value " + lat);
     this.lat=lat;
     this.lng=lng;
   }
@@ -82,8 +83,8 @@
   public boolean isNormalized() {
     return 
       normalized || (
-          (lng>=-180) &&
-          (lng<=180)
+          (lng>=-LONGITUDE_DECIMAL_DEGREE_RANGE/2.0d) &&
+          (lng<=LONGITUDE_DECIMAL_DEGREE_RANGE/2.0d)
           );
   }
 
@@ -91,15 +92,9 @@
   public LatLng normalize() {
     if (isNormalized()) return this;
     
-    double delta=0;
-    if (lng<0) delta=360;
-    if (lng>=0) delta=-360;
+
+    double newLng= ((lng+ LONGITUDE_DECIMAL_DEGREE_RANGE)% LONGITUDE_DECIMAL_DEGREE_RANGE)- LONGITUDE_DECIMAL_DEGREE_RANGE/2.0d;
     
-    double newLng=lng;
-    while (newLng<=-180 || newLng>=180) {
-      newLng+=delta;
-    }
-    
     FloatLatLng ret=new FloatLatLng(lat, newLng);
     ret.normalized=true;
     return ret;
