diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java
index e275dec..3ae9ff0 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java
@@ -119,4 +119,12 @@ abstract class ConjunctionSpans extends Spans {
   public Spans[] getSubSpans() {
     return subSpans;
   }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    for (Spans subSpan : subSpans) {
+      subSpan.collect(collector);
+    }
+  }
+
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
index 4e021c7..feaec55 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
@@ -52,10 +52,4 @@ abstract class ContainSpans extends ConjunctionSpans {
     return sourceSpans.width();
   }
 
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    bigSpans.collect(collector);
-    littleSpans.collect(collector);
-  }
-
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
index f405473..0149402 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
@@ -143,12 +143,5 @@ public class NearSpansOrdered extends ConjunctionSpans {
     return matchWidth;
   }
 
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    for (Spans span : subSpans) {
-      span.collect(collector);
-    }
-  }
-
 }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrderedLookahead.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrderedLookahead.java
new file mode 100644
index 0000000..b1150d8
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrderedLookahead.java
@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search.spans;
+
+
+import java.io.IOException;
+import java.util.List;
+
+/**
+ * A Spans that is formed from the ordered subspans of a SpanNearQuery
+ * where the subspans do not overlap and have a maximum slop between them.
+ * <p>
+ * The formed spans only contains minimum slop matches.<br>
+ * The matching slop is computed from the distance(s) between
+ * the non overlapping matching Spans.<br>
+ * Successive matches are always formed from the successive Spans
+ * of the SpanNearQuery.
+ * <p>
+ * The formed spans may contain overlaps when the slop is at least 1.
+ * For example, when querying using
+ * <pre>t1 t2 t3</pre>
+ * with slop at least 1, the fragment:
+ * <pre>t1 t2 t1 t3 t2 t3</pre>
+ * matches twice:
+ * <pre>t1 t2 .. t3      </pre>
+ * <pre>      t1 .. t2 t3</pre>
+ *
+ * Expert:
+ * Only public for subclassing.  Most implementations should not need this class
+ */
+public class NearSpansOrderedLookahead extends ConjunctionSpans {
+
+  protected int matchStart = -1;
+  protected int matchEnd = -1;
+  protected int matchSlop = -1;
+
+  private boolean firstSubSpansAfterMatch = false;
+
+  private final int allowedSlop;
+
+  public NearSpansOrderedLookahead(int allowedSlop, List<Spans> subSpans) throws IOException {
+    super(subSpans);
+    this.atFirstInCurrentDoc = true; // -1 startPosition/endPosition also at doc -1
+    this.allowedSlop = allowedSlop;
+  }
+
+  @Override
+  boolean twoPhaseCurrentDocMatches() throws IOException {
+    assert unpositioned();
+    oneExhaustedInCurrentDoc = false;
+    subSpans[0].nextStartPosition();
+    while (subSpans[0].startPosition() != NO_MORE_POSITIONS && !oneExhaustedInCurrentDoc) {
+      if (! stretchToOrder()) {
+        return false;
+      }
+      if (matchSlop <= allowedSlop) {
+        return atFirstInCurrentDoc = true;
+      }
+      if (shrinkToDecreaseSlop()) {
+        return atFirstInCurrentDoc = true;
+      }
+    }
+    return false;
+  }
+
+  private boolean unpositioned() {
+    for (Spans span : subSpans) {
+      if (span.startPosition() != -1)
+        return false;
+    }
+    return true;
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    if (atFirstInCurrentDoc) {
+      atFirstInCurrentDoc = false;
+      return matchStart;
+    }
+
+    if (! firstSubSpansAfterMatch) {
+      subSpans[0].nextStartPosition();
+    }
+
+    oneExhaustedInCurrentDoc = false;
+    while (subSpans[0].startPosition() != NO_MORE_POSITIONS && !oneExhaustedInCurrentDoc) {
+      if (! stretchToOrder()) {
+        return matchStart = matchEnd = NO_MORE_POSITIONS;
+      }
+      if (matchSlop <= allowedSlop) {
+        return matchStart;
+      }
+      if (shrinkToDecreaseSlop()) {
+        return matchStart;
+      }
+    }
+
+    firstSubSpansAfterMatch = false; // prepare for possible next doc
+    return matchStart = matchEnd = NO_MORE_POSITIONS;
+  }
+
+  /**
+   * Order the subSpans within the same document by using nextStartPosition on all subSpans
+   * after the first as little as necessary.
+   * Return true when the subSpans could be ordered in this way,
+   * otherwise at least one is exhausted in the current doc.
+   */
+  private boolean stretchToOrder() throws IOException {
+    Spans prevSpans = subSpans[0];
+    matchStart = prevSpans.startPosition();
+    assert prevSpans.startPosition() != NO_MORE_POSITIONS : "prevSpans no start position "+prevSpans;
+    assert prevSpans.endPosition() != NO_MORE_POSITIONS;
+
+    matchSlop = 0;
+    firstSubSpansAfterMatch = false;
+
+    for (int i = 1; i < subSpans.length; i++) {
+      Spans spans = subSpans[i];
+      assert spans.startPosition() != NO_MORE_POSITIONS;
+      assert spans.endPosition() != NO_MORE_POSITIONS;
+      if (advancePosition(spans, prevSpans.endPosition()) == NO_MORE_POSITIONS) {
+        oneExhaustedInCurrentDoc = true;
+        return false;
+      }
+      assert spans.startPosition() >= prevSpans.endPosition();
+      matchSlop += spans.startPosition() - prevSpans.endPosition();
+      prevSpans = spans;
+    }
+    matchEnd = subSpans[subSpans.length - 1].endPosition();
+    return true; // all subSpans ordered and non overlapping
+  }
+
+  /** The subSpans are ordered in the same doc and matchSlop is too big.
+   * Try and decrease the slop by calling nextStartPosition() on all subSpans except the last one in reverse order.
+   * Return true iff an ordered match was found with small enough slop.
+   */
+  private boolean shrinkToDecreaseSlop() throws IOException {
+    int lastStart = subSpans[subSpans.length - 1].startPosition();
+
+    for (int i = subSpans.length - 2; i >= 1; i--) { // intermediate spans for subSpans.length >= 3
+      Spans prevSpans = subSpans[i];
+      int prevStart = prevSpans.startPosition();
+      int prevEnd = prevSpans.endPosition();
+      while (true) { // Advance prevSpans until it is after (lastStart, lastEnd) or the slop increases.
+        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {
+          oneExhaustedInCurrentDoc = true;
+          break; // Check remaining subSpans for final match in current doc
+        } else {
+          int ppEnd = prevSpans.endPosition();
+          if (ppEnd > lastStart) { // no more ordered
+            break; // Check remaining subSpans.
+          } else { // prevSpans still before lastStart
+            int ppStart = prevSpans.startPosition();
+            int slopIncrease = (prevEnd - prevStart) - (ppEnd - ppStart); // span length decrease is slop increase
+            if (slopIncrease > 0) {
+              break; // Check remaining subSpans.
+            } else { // slop did not increase
+              prevStart = ppStart;
+              prevEnd = ppEnd;
+              matchSlop += slopIncrease;
+            }
+          }
+        }
+      }
+      lastStart = prevStart;
+    }
+
+    while (true) { // for subSpans[0] only the end position influences the match slop.
+      int prevEnd = subSpans[0].endPosition();
+      if (subSpans[0].nextStartPosition() == NO_MORE_POSITIONS) {
+        oneExhaustedInCurrentDoc = true;
+        break;
+      }
+      int ppEnd = subSpans[0].endPosition();
+      if (ppEnd > lastStart) { // no more ordered
+        break;
+      }
+      int slopIncrease = prevEnd - ppEnd;
+      if (slopIncrease > 0) {
+        break;
+      }
+      // slop did not increase:
+      matchStart = subSpans[0].startPosition();
+      matchSlop += slopIncrease;
+    }
+
+    firstSubSpansAfterMatch = true;
+    boolean match = matchSlop <= allowedSlop;
+    return match; // ordered and allowed slop
+  }
+
+
+  private static int advancePosition(Spans spans, int position) throws IOException {
+    if (spans instanceof SpanNearQuery.GapSpans) {
+      return ((SpanNearQuery.GapSpans)spans).skipToPosition(position);
+    }
+    while (spans.startPosition() < position) {
+      spans.nextStartPosition();
+    }
+    return spans.startPosition();
+  }
+
+  @Override
+  public int startPosition() {
+    return atFirstInCurrentDoc ? -1 : matchStart;
+  }
+
+  @Override
+  public int endPosition() {
+    return atFirstInCurrentDoc ? -1 : matchEnd;
+  }
+
+  @Override
+  public int width() {
+    return matchSlop;
+  }
+
+}
+
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
index c3402bc..f2db212 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
@@ -258,11 +258,4 @@ public class NearSpansUnordered extends ConjunctionSpans {
     return maxEndPositionCell.startPosition() - minPositionCell().startPosition();
   }
 
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    for (SpansCell cell : subSpanCells) {
-      cell.collect(collector);
-    }
-  }
-
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnorderedStartPos.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnorderedStartPos.java
new file mode 100644
index 0000000..944e294
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnorderedStartPos.java
@@ -0,0 +1,176 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search.spans;
+
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.util.PriorityQueue;
+
+/**
+ * A Spans that is formed from the unordered subspans of a SpanNearQuery
+ * where the start positions of the subspans have a maximum slop between them.
+ * <p>
+ * The formed spans may contain overlaps.
+ * When the subspans share start positions, not all matches within the maximum slop
+ * may be found.
+ *
+ * Expert:
+ * Only public for subclassing.  Most implementations should not need this class.
+ */
+public class NearSpansUnorderedStartPos extends ConjunctionSpans {
+
+  private final int allowedSlop;
+
+  private SpanStartPositionWindow spanStartPosWindow;
+
+  public NearSpansUnorderedStartPos(int allowedSlop, List<Spans> subSpans)
+  throws IOException {
+    super(subSpans);
+    this.allowedSlop = allowedSlop;
+    this.spanStartPosWindow = new SpanStartPositionWindow();
+  }
+
+
+  class SpanStartPositionWindow extends PriorityQueue<Spans> {
+
+    int maxStartPosition;
+
+    public SpanStartPositionWindow() {
+      super(subSpans.length);
+    }
+
+    @Override
+    protected final boolean lessThan(Spans spans1, Spans spans2) {
+      return positionsOrdered(spans1, spans2);
+    }
+
+    void startDocument() throws IOException {
+      clear();
+      maxStartPosition = -1;
+      for (Spans spans : subSpans) {
+        assert spans.startPosition() == -1;
+        spans.nextStartPosition();
+        assert spans.startPosition() != NO_MORE_POSITIONS;
+        add(spans);
+        if (spans.startPosition() > maxStartPosition) {
+          maxStartPosition = spans.startPosition();
+        }
+      }
+    }
+
+    boolean nextPosition() throws IOException {
+      Spans topSpans = top();
+      assert topSpans.startPosition() != NO_MORE_POSITIONS;
+      int nextStartPos = topSpans.nextStartPosition();
+      if (nextStartPos != NO_MORE_POSITIONS) {
+        return false;
+      }
+      if (nextStartPos > maxStartPosition) {
+        maxStartPosition = nextStartPos;
+      }
+      updateTop();
+      return true;
+    }
+
+    boolean atMatch() {
+      return (maxStartPosition - top().startPosition()) <= allowedSlop;
+    }
+  }
+
+  /** Check whether two Spans in the same document are ordered with possible overlap.
+   * @return true iff spans1 starts before spans2
+   *              or the spans start at the same position,
+   *              and spans1 ends before spans2.
+   */
+  static boolean positionsOrdered(Spans spans1, Spans spans2) {
+    assert spans1.docID() == spans2.docID() : "doc1 " + spans1.docID() + " != doc2 " + spans2.docID();
+    int start1 = spans1.startPosition();
+    int start2 = spans2.startPosition();
+    return (start1 == start2) ? (spans1.endPosition() < spans2.endPosition()) : (start1 < start2);
+  }
+
+
+  @Override
+  boolean twoPhaseCurrentDocMatches() throws IOException {
+    // at doc with all subSpans
+    spanStartPosWindow.startDocument();
+    while (true) {
+      if (spanStartPosWindow.atMatch()) {
+        atFirstInCurrentDoc = true;
+        oneExhaustedInCurrentDoc = false;
+        return true;
+      }
+      if (! spanStartPosWindow.nextPosition()) {
+        return false;
+      }
+    }
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    if (atFirstInCurrentDoc) {
+      atFirstInCurrentDoc = false;
+      return spanStartPosWindow.top().startPosition();
+    }
+    if (spanStartPosWindow.top().startPosition() == -1) { // initially at current doc, non two phase
+      // CHECKME: can this occur?
+  System.out.println("non two phase, initially at doc " + spanStartPosWindow.top().docID());
+  assert false;
+      spanStartPosWindow.startDocument();
+      if (spanStartPosWindow.atMatch()) {
+        return spanStartPosWindow.top().startPosition();
+      }
+    }
+    assert spanStartPosWindow.top().startPosition() != NO_MORE_POSITIONS;
+    while (true) {
+      if (! spanStartPosWindow.nextPosition()) {
+        oneExhaustedInCurrentDoc = true;
+        return NO_MORE_POSITIONS;
+      }
+      if (spanStartPosWindow.atMatch()) {
+        return spanStartPosWindow.top().startPosition();
+      }
+    }
+  }
+
+  @Override
+  public int startPosition() {
+    assert spanStartPosWindow.top() != null;
+    return atFirstInCurrentDoc ? -1
+          : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
+          : spanStartPosWindow.top().startPosition();
+  }
+
+  @Override
+  public int endPosition() {
+    return atFirstInCurrentDoc ? -1
+          : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
+          : spanStartPosWindow.maxStartPosition;
+  }
+
+  @Override
+  public int width() {
+    return spanStartPosWindow.maxStartPosition
+            - spanStartPosWindow.top().startPosition()
+            + 1; // width must be positive
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
index 7958f47..021019f 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
@@ -34,32 +34,116 @@ import org.apache.lucene.index.Terms;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 
-/** Matches spans which are near one another.  One can specify <i>slop</i>, the
+/** Matches clauses of spans which are near one another.  One can specify <i>slop</i>, the
  * maximum number of intervening unmatched positions, as well as whether
  * matches are required to be in-order.
+ * <p>
+ * In the current implementation ordered spans that overlap will not match,
+ * and unordered spans that overlap will match.
+ * <p>
+ * When the spans vary in length the results may not be complete.
+ * <br>
+ * See LUCENE-7398 for more details.
  */
 public class SpanNearQuery extends SpanQuery implements Cloneable {
 
+  /** Specifies how clauses are to occur near each other in matching documents.
+    * The methods for this differ in
+    * <ul>
+    * <li>the required order for the subspans,
+    * <li>how the slop is to be determined,
+    * <li>the completeness of results when subspans of the clauses can vary in length, and 
+    * <li>the possilibity to use {@link Spans#collect}.
+    * </ul>
+    */
+  public static enum MatchNear {
+
+    /** Use this method for clauses that match when they are not ordered,
+     * and the slop should be determined between the end and start positions of all clauses.
+     * When the subspans vary in length, some present matches may not be found.
+     * <br>For each resulting document, this method works by repetitively calling {@link Spans#nextStartPosition}
+     * on the earliest subspans.
+     * <br>The order between subspans is first by start position, and then if necessary by end position.
+     * <br>The resulting spans have the lowest start positions and highest end positions of the subspans of each match.
+     * Span collection by {@link Spans#collect} can be done normally on the result.
+     */
+    UNORDERED_LAZY,
+
+    /** Use this method for clauses that match when they are not ordered,
+     * and the slop should be determined between the start positions of the first and last matching clauses.
+     * <br>For each resulting document, this method works by repetitively calling {@link Spans#nextStartPosition}
+     * on the earliest subspans.
+     * <br>The order between subspans is first by start position, and then if necessary by end position.
+     * <br>When the subspans have the same and/or repetitive start positions, for each present match
+     * at least one of the possibly overlapping results will be be found.
+     * <br>The resulting spans have the lowest start positions and highest start positions of the subspans of each match.
+     * Span collection by {@link Spans#collect} can be done normally on the result.
+     */
+    UNORDERED_STARTPOS,
+
+    /** Use this method for clauses that can match when they are in-order
+     * and the slop should be determined between the end and start positions of the clauses.
+     * When the subspans vary in length, some present matches may not be found.
+     * <br>For each resulting document, this method works by repetitively calling {@link Spans#nextStartPosition}
+     * on the first subspans, and then on the later subspans in the given order as long as the subspans overlap.
+     * <br>The resulting spans have the lowes and highest end positions of the subspans of each match
+     * as as start and end positions.
+     * Span collection by {@link Spans#collect} can be done normally on the result.
+     */
+    ORDERED_LAZY,
+
+    /** Use this method for clauses that can match when they are in-order,
+     * and the slop should be determined between the end and start positions of the clauses.
+     * When the subspans vary in length, some present matches may not be found.
+     * <br>For each resulting document, this method works by repetitively calling {@link Spans#nextStartPosition}
+     * on the first subspans, then on the later subspans in the given order as long as the subspans overlap,
+     * and if the resulting slop is too high a lookahead is done for all subspans except the last one in reverse order
+     * as long as the resulting slop does not increase.
+     * <br>Because of the additional lookahead, this method may find more matches than {@link ORDERED_LAZY}.
+     * <br>The resulting spans have the lowest start position and highest end position of the subspans of each match.
+     * Span collection by {@link Spans#collect} may fail on the result because the subspans can be after the match
+     * when collecting.
+     */
+    ORDERED_LOOKAHEAD
+  }
+
+
   /**
    * A builder for SpanNearQueries
    */
   public static class Builder {
-    private final boolean ordered;
+    private final MatchNear matchNear;
     private final String field;
     private final List<SpanQuery> clauses = new LinkedList<>();
     private int slop;
 
     /**
-     * Construct a new builder
+     * Construct a new builder.
+     * @param field the field to search in.
+     * @param matchNear how the clauses should match.
+     */
+    public Builder(String field, MatchNear matchNear) {
+      this.field = Objects.requireNonNull(field);
+      this.matchNear = Objects.requireNonNull(matchNear);
+    }
+
+     /**
+     * Construct a new builder.
      * @param field the field to search in
-     * @param ordered whether or not clauses must be in-order to match
+     * @param ordered whether or not clauses must be in-order to match.
+     *                For backward compatibiility, this chooses between
+     *               {@link MatchNear#ORDERED_LAZY} and {@link MatchNear#UNORDERED_LAZY}.
      */
     public Builder(String field, boolean ordered) {
-      this.field = field;
-      this.ordered = ordered;
+      this(field, ordered ? MatchNear.ORDERED_LAZY : MatchNear.UNORDERED_LAZY);
     }
 
     /**
+     * Construct a new builder.
+     * @param field the field to search in
+     * @param ordered whether or not clauses must be in-order to match.
+     */
+    /**
      * Add a new clause
      */
     public Builder addClause(SpanQuery clause) {
@@ -70,11 +154,12 @@ public class SpanNearQuery extends SpanQuery implements Cloneable {
     }
 
     /**
-     * Add a gap after the previous clause of a defined width
+     * Add a gap after the previous clause of a defined width.
+     * This can only be used in combination with {@link MatchNear#ORDERED_LAZY}.
      */
     public Builder addGap(int width) {
-      if (!ordered)
-        throw new IllegalArgumentException("Gaps can only be added to ordered near queries");
+      if (matchNear != MatchNear.ORDERED_LAZY)
+        throw new IllegalArgumentException("Gaps can only be added to near queries with " + MatchNear.ORDERED_LAZY);
       this.clauses.add(new SpanGapQuery(field, width));
       return this;
     }
@@ -91,28 +176,30 @@ public class SpanNearQuery extends SpanQuery implements Cloneable {
      * Build the query
      */
     public SpanNearQuery build() {
-      return new SpanNearQuery(clauses.toArray(new SpanQuery[clauses.size()]), slop, ordered);
+      return new SpanNearQuery(clauses.toArray(new SpanQuery[clauses.size()]), slop, matchNear);
     }
 
   }
 
   /**
-   * Returns a {@link Builder} for an ordered query on a particular field
+   * Returns a {@link Builder} for an ordered query on a particular field,
+   * using {@link MatchNear#ORDERED_LAZY}
    */
   public static Builder newOrderedNearQuery(String field) {
-    return new Builder(field, true);
+    return new Builder(field, MatchNear.ORDERED_LAZY);
   }
 
   /**
-   * Returns a {@link Builder} for an unordered query on a particular field
+   * Returns a {@link Builder} for an unordered query on a particular field.
+   * using {@link MatchNear#UNORDERED_LAZY}.
    */
   public static Builder newUnorderedNearQuery(String field) {
-    return new Builder(field, false);
+    return new Builder(field, MatchNear.UNORDERED_LAZY);
   }
 
   protected List<SpanQuery> clauses;
   protected int slop;
-  protected boolean inOrder;
+  protected MatchNear matchNear;
 
   protected String field;
 
@@ -125,9 +212,9 @@ public class SpanNearQuery extends SpanQuery implements Cloneable {
    * need not be ordered and may overlap.
    * @param clausesIn the clauses to find near each other, in the same field, at least 2.
    * @param slop The slop value
-   * @param inOrder true if order is important
+   * @param matchNear how the clauses should match.
    */
-  public SpanNearQuery(SpanQuery[] clausesIn, int slop, boolean inOrder) {
+  public SpanNearQuery(SpanQuery[] clausesIn, int slop, MatchNear matchNear) {
     this.clauses = new ArrayList<>(clausesIn.length);
     for (SpanQuery clause : clausesIn) {
       if (this.field == null) {                               // check field
@@ -138,7 +225,14 @@ public class SpanNearQuery extends SpanQuery implements Cloneable {
       this.clauses.add(clause);
     }
     this.slop = slop;
-    this.inOrder = inOrder;
+    this.matchNear = Objects.requireNonNull(matchNear);
+  }
+
+  /** For backward compatibility.
+   * Uses {@link MatchNear#ORDERED_LAZY} or {@link MatchNear#ORDERED_LAZY}.
+   */
+  public SpanNearQuery(SpanQuery[] clausesIn, int slop, boolean ordered) {
+    this(clausesIn, slop, ordered ? MatchNear.ORDERED_LAZY : MatchNear.UNORDERED_LAZY);
   }
 
   /** Return the clauses whose spans are matched. */
@@ -149,8 +243,14 @@ public class SpanNearQuery extends SpanQuery implements Cloneable {
   /** Return the maximum number of intervening unmatched positions permitted.*/
   public int getSlop() { return slop; }
 
+  /** Return the match method.*/
+  public MatchNear getMatchNear() { return matchNear; }
+
   /** Return true if matches are required to be in-order.*/
-  public boolean isInOrder() { return inOrder; }
+  public boolean isInOrder() {
+    return matchNear == MatchNear.ORDERED_LAZY
+        || matchNear == MatchNear.ORDERED_LOOKAHEAD;
+  }
 
   @Override
   public String getField() { return field; }
@@ -170,7 +270,7 @@ public class SpanNearQuery extends SpanQuery implements Cloneable {
     buffer.append("], ");
     buffer.append(slop);
     buffer.append(", ");
-    buffer.append(inOrder);
+    buffer.append(matchNear);
     buffer.append(")");
     return buffer.toString();
   }
@@ -219,8 +319,19 @@ public class SpanNearQuery extends SpanQuery implements Cloneable {
       }
 
       // all NearSpans require at least two subSpans
-      return (!inOrder) ? new NearSpansUnordered(slop, subSpans)
-          : new NearSpansOrdered(slop, subSpans);
+      if (matchNear == MatchNear.UNORDERED_LAZY) {
+        return new NearSpansUnordered(slop, subSpans);
+      }
+      else if (matchNear == MatchNear.UNORDERED_STARTPOS) {
+        return new NearSpansUnorderedStartPos(slop, subSpans);
+      }
+      else if (matchNear == MatchNear.ORDERED_LAZY) {
+        return new NearSpansOrdered(slop, subSpans);
+      }
+      else if (matchNear == MatchNear.ORDERED_LOOKAHEAD) {
+        return new NearSpansOrderedLookahead(slop, subSpans);
+      }
+      throw new RuntimeException("Not implemented for " + matchNear);
     }
 
     @Override
@@ -260,7 +371,7 @@ public class SpanNearQuery extends SpanQuery implements Cloneable {
   }
 
   private boolean equalsTo(SpanNearQuery other) {
-    return inOrder == other.inOrder && 
+    return matchNear == other.matchNear &&
            slop == other.slop &&
            clauses.equals(other.clauses);
   }
@@ -270,8 +381,8 @@ public class SpanNearQuery extends SpanQuery implements Cloneable {
     int result = classHash();
     result ^= clauses.hashCode();
     result += slop;
-    int fac = 1 + (inOrder ? 8 : 4);
-    return fac * result;
+    result += matchNear.hashCode();
+    return result;
   }
 
   private static class SpanGapQuery extends SpanQuery {
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java
index 2b42a76..5ab9eea 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java
@@ -92,7 +92,9 @@ public class TestSpanCollection extends LuceneTestCase {
       "w1 w2 w3 w4 w5",
       "w1 w3 w2 w3 zz",
       "w1 xx w2 yy w4",
-      "w1 w2 w1 w4 w2 w3"
+      "w1 w2 w1 w4 w2 w3",
+      "coordinate gene mapping research",
+      "coordinate gene research"
   };
 
   private void checkCollectedTerms(Spans spans, TermCollector collector, Term... expectedTerms) throws IOException {
@@ -105,6 +107,45 @@ public class TestSpanCollection extends LuceneTestCase {
   }
 
   @Test
+  public void testNestedOrQuery() throws IOException {
+    SpanNearQuery snq = new SpanNearQuery.Builder(FIELD, SpanNearQuery.MatchNear.ORDERED_LOOKAHEAD)
+        .addClause(new SpanTermQuery(new Term(FIELD, "coordinate")))
+        .addClause(new SpanOrQuery(
+            new SpanTermQuery(new Term(FIELD, "gene")),
+            SpanNearQuery.newOrderedNearQuery(FIELD)
+                .addClause(new SpanTermQuery(new Term(FIELD, "gene")))
+                .addClause(new SpanTermQuery(new Term(FIELD, "mapping")))
+                .build()
+        ))
+        .addClause(new SpanTermQuery(new Term(FIELD, "research")))
+        .build();
+
+    Spans spans = snq.createWeight(searcher, false, 1).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(4, spans.advance(4));
+    assertEquals(5, spans.nextDoc());
+  }
+
+  @Test
+  public void testNestedOrQuerySlop() throws IOException {
+    SpanNearQuery snq = new SpanNearQuery.Builder(FIELD, SpanNearQuery.MatchNear.ORDERED_LOOKAHEAD)
+        .setSlop(1)
+        .addClause(new SpanTermQuery(new Term(FIELD, "w1")))
+        .addClause(new SpanOrQuery(
+            new SpanTermQuery(new Term(FIELD, "w2")),
+            SpanNearQuery.newOrderedNearQuery(FIELD)
+                .addClause(new SpanTermQuery(new Term(FIELD, "w3")))
+                .addClause(new SpanTermQuery(new Term(FIELD, "w4")))
+                .build()
+        ))
+        .addClause(new SpanTermQuery(new Term(FIELD, "w5")))
+        .build();
+
+    Spans spans = snq.createWeight(searcher, false, 1).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(0, spans.advance(0));
+    assertEquals(Spans.NO_MORE_DOCS, spans.nextDoc());
+  }
+
+  @Test
   public void testNestedNearQuery() throws IOException {
 
     // near(w1, near(w2, or(w3, w4)))
@@ -130,6 +171,44 @@ public class TestSpanCollection extends LuceneTestCase {
     spans.nextStartPosition();
     checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"));
 
+    SpanNearQuery q23 = new SpanNearQuery(new SpanQuery[]{q2, q3}, 0, true);
+    SpanOrQuery q223 = new SpanOrQuery(q2, q23);
+
+    SpanNearQuery q1q2q3q4 = new SpanNearQuery(new SpanQuery[]{q1, q2, q3, q4}, 0, true);
+    SpanNearQuery q1q23q4 = new SpanNearQuery(new SpanQuery[]{q1, q23, q4}, 0, true);
+    SpanNearQuery q1q223q4 = new SpanNearQuery(new SpanQuery[]{q1, q223, q4}, 0, SpanNearQuery.MatchNear.ORDERED_LOOKAHEAD);
+    SpanNearQuery q223q4 = new SpanNearQuery(new SpanQuery[]{q223, q4}, 0, true);
+    SpanNearQuery q1q223 = new SpanNearQuery(new SpanQuery[]{q1, q223}, 0, true);
+
+    spans = q1q2q3q4.createWeight(searcher, false, 1f).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(0, spans.advance(0));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"), new Term(FIELD, "w4"));
+
+    spans = q1q23q4.createWeight(searcher, false, 1f).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(0, spans.advance(0));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"), new Term(FIELD, "w4"));
+
+    spans = q223q4.createWeight(searcher, false, 1f).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(0, spans.advance(0));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w2"), new Term(FIELD, "w3"), new Term(FIELD, "w4"));
+
+    // near/0(w1, or(w2, near/0(w2, w3)))
+    /* CHECKME: reenable this test when a SpanNearQuery.MatchNear method is available that does this well,
+     * checkCollectedTerms below fails because subspans vary in length because of the or(.., ..).
+     * spans =q1q223.createWeight(searcher, false, 1f).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+     * assertEquals(0, spans.advance(0));
+     * spans.nextStartPosition();
+     * checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"));
+     */
+    spans =q1q223q4.createWeight(searcher, false, 1f).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(0, spans.advance(0));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"), new Term(FIELD, "w4"));
+
+
   }
 
   @Test
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
index 2d5e05c..e7b7113 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
@@ -49,6 +49,7 @@ import static org.apache.lucene.search.spans.SpanTestUtil.assertFinished;
 import static org.apache.lucene.search.spans.SpanTestUtil.assertNext;
 import static org.apache.lucene.search.spans.SpanTestUtil.spanNearOrderedQuery;
 import static org.apache.lucene.search.spans.SpanTestUtil.spanNearUnorderedQuery;
+import static org.apache.lucene.search.spans.SpanTestUtil.spanNearQuery;
 import static org.apache.lucene.search.spans.SpanTestUtil.spanNotQuery;
 import static org.apache.lucene.search.spans.SpanTestUtil.spanOrQuery;
 import static org.apache.lucene.search.spans.SpanTestUtil.spanTermQuery;
@@ -216,7 +217,8 @@ public class TestSpans extends LuceneTestCase {
 
   public void testSpanNearUnOrdered() throws Exception {
     //See http://www.gossamer-threads.com/lists/lucene/java-dev/52270 for discussion about this test
-    SpanQuery senq = spanNearUnorderedQuery(field, 0, "u1", "u2");
+
+    SpanQuery senq = spanNearQuery(field, 0, SpanNearQuery.MatchNear.UNORDERED_LAZY, "u1", "u2");
     Spans spans = senq.createWeight(searcher, false, 1f).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
     assertNext(spans, 4, 1, 3);
     assertNext(spans, 5, 2, 4);
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java b/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
index 1388043..dbb95bf 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
@@ -124,12 +124,8 @@ public class SpanTestUtil {
    * Makes a new unordered SpanNearQuery (with additional asserts) from the provided {@code terms}
    */
   public static SpanQuery spanNearUnorderedQuery(String field, int slop, String... terms) {
-    SpanNearQuery.Builder builder = SpanNearQuery.newUnorderedNearQuery(field);
-    builder.setSlop(slop);
-    for (String term : terms) {
-      builder.addClause(new SpanTermQuery(new Term(field, term)));
-    }
-    return spanQuery(builder.build());
+    // SpanNearQuery.Builder builder = new SpanNearQuery.Builder(field, SpanNearQuery.MatchNear.UNORDERED_LAZY);
+    return spanNearQuery(field, slop, SpanNearQuery.MatchNear.UNORDERED_STARTPOS, terms);
   }
 
   /**
@@ -140,6 +136,18 @@ public class SpanTestUtil {
   }
 
   /**
+   * Makes a new SpanNearQuery (with additional asserts) using MatchNear
+   */
+  public static SpanQuery spanNearQuery(String field, int slop, SpanNearQuery.MatchNear matchNear, String... terms) {
+    SpanNearQuery.Builder builder = new SpanNearQuery.Builder(field, matchNear);
+    builder.setSlop(slop);
+    for (String term : terms) {
+      builder.addClause(new SpanTermQuery(new Term(field, term)));
+    }
+    return spanQuery(builder.build());
+  }
+
+  /**
    * Assert the next iteration from {@code spans} is a match
    * from {@code start} to {@code end} in {@code doc}.
    */
