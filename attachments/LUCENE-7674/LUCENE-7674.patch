diff --git a/lucene/join/src/java/org/apache/lucene/search/join/CheckJoinIndex.java b/lucene/join/src/java/org/apache/lucene/search/join/CheckJoinIndex.java
index 025aeef..5aa2d4c 100644
--- a/lucene/join/src/java/org/apache/lucene/search/join/CheckJoinIndex.java
+++ b/lucene/join/src/java/org/apache/lucene/search/join/CheckJoinIndex.java
@@ -40,32 +40,37 @@
         continue;
       }
       final BitSet parents = parentsFilter.getBitSet(context);
-      if (parents == null || parents.cardinality() == 0) {
-        throw new IllegalStateException("Every segment should have at least one parent, but " + context.reader() + " does not have any");
-      }
-      if (parents.get(context.reader().maxDoc() - 1) == false) {
-        throw new IllegalStateException("The last document of a segment must always be a parent, but " + context.reader() + " has a child as a last doc");
-      }
-      final Bits liveDocs = context.reader().getLiveDocs();
-      if (liveDocs != null) {
-        int prevParentDoc = -1;
-        DocIdSetIterator it = new BitSetIterator(parents, 0L);
-        for (int parentDoc = it.nextDoc(); parentDoc != DocIdSetIterator.NO_MORE_DOCS; parentDoc = it.nextDoc()) {
-          final boolean parentIsLive = liveDocs.get(parentDoc);
-          for (int child = prevParentDoc + 1; child != parentDoc; child++) {
-            final boolean childIsLive = liveDocs.get(child);
-            if (parentIsLive != childIsLive) {
-              if (childIsLive) {
-                throw new IllegalStateException("Parent doc " + parentDoc + " of segment " + context.reader() + " is live but has a deleted child document " + child);
-              } else {
-                throw new IllegalStateException("Parent doc " + parentDoc + " of segment " + context.reader() + " is deleted but has a live child document " + child);
-              }
+      checkParentsInSegment(context, parents);
+    }
+  }
+
+  protected static Bits checkParentsInSegment(LeafReaderContext context, final BitSet parents) throws IOException {
+    if (parents == null || parents.cardinality() == 0) {
+      throw new IllegalStateException("Every segment should have at least one parent, but " + context.reader() + " does not have any");
+    }
+    if (parents.get(context.reader().maxDoc() - 1) == false) {
+      throw new IllegalStateException("The last document of a segment must always be a parent, but " + context.reader() + " has a child as a last doc");
+    }
+    final Bits liveDocs = context.reader().getLiveDocs();
+    if (liveDocs != null) {
+      int prevParentDoc = -1;
+      DocIdSetIterator it = new BitSetIterator(parents, 0L);
+      for (int parentDoc = it.nextDoc(); parentDoc != DocIdSetIterator.NO_MORE_DOCS; parentDoc = it.nextDoc()) {
+        final boolean parentIsLive = liveDocs.get(parentDoc);
+        for (int child = prevParentDoc + 1; child != parentDoc; child++) {
+          final boolean childIsLive = liveDocs.get(child);
+          if (parentIsLive != childIsLive) {
+            if (childIsLive) {
+              throw new IllegalStateException("Parent doc " + parentDoc + " of segment " + context.reader() + " is live but has a deleted child document " + child);
+            } else {
+              throw new IllegalStateException("Parent doc " + parentDoc + " of segment " + context.reader() + " is deleted but has a live child document " + child);
             }
           }
-          prevParentDoc = parentDoc;
         }
+        prevParentDoc = parentDoc;
       }
     }
+    return liveDocs;
   }
 
 }
diff --git a/lucene/join/src/java/org/apache/lucene/search/join/CheckingQueryBitSetProducer.java b/lucene/join/src/java/org/apache/lucene/search/join/CheckingQueryBitSetProducer.java
new file mode 100644
index 0000000..78989e5
--- /dev/null
+++ b/lucene/join/src/java/org/apache/lucene/search/join/CheckingQueryBitSetProducer.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search.join;
+
+import java.io.IOException;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.search.DocIdSet;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.util.BitDocIdSet;
+import org.apache.lucene.util.BitSet;
+
+public class CheckingQueryBitSetProducer extends QueryBitSetProducer {
+
+  public CheckingQueryBitSetProducer(Query query) {
+    super(query);
+  }
+
+  @Override
+  protected DocIdSet createBitDocIdSet(LeafReaderContext context) throws IOException {
+    
+    DocIdSet docIdSet = super.createBitDocIdSet(context);
+
+    if (context.reader().maxDoc() > 0) {
+      BitSet bits = ((BitDocIdSet) docIdSet).bits();
+      try{
+         CheckJoinIndex.checkParentsInSegment(context,bits);
+      }catch(Exception e) {
+        throw new IllegalStateException("validating "+query+ " yields: "+e.getMessage(), e);
+      }
+    }
+    return docIdSet;
+  }
+}
diff --git a/lucene/join/src/java/org/apache/lucene/search/join/QueryBitSetProducer.java b/lucene/join/src/java/org/apache/lucene/search/join/QueryBitSetProducer.java
index 98d85cd..fa63e95 100644
--- a/lucene/join/src/java/org/apache/lucene/search/join/QueryBitSetProducer.java
+++ b/lucene/join/src/java/org/apache/lucene/search/join/QueryBitSetProducer.java
@@ -38,7 +38,7 @@
  * {@link BitSet}s per segment.
  */
 public class QueryBitSetProducer implements BitSetProducer {
-  private final Query query;
+  protected final Query query;
   private final Map<Object,DocIdSet> cache = Collections.synchronizedMap(new WeakHashMap<>());
 
   /** Wraps another query's result and caches it into bitsets.
@@ -63,21 +63,32 @@
 
     DocIdSet docIdSet = cache.get(key);
     if (docIdSet == null) {
-      final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(context);
-      final IndexSearcher searcher = new IndexSearcher(topLevelContext);
-      searcher.setQueryCache(null);
-      final Weight weight = searcher.createNormalizedWeight(query, false);
-      final Scorer s = weight.scorer(context);
-
-      if (s == null) {
-        docIdSet = DocIdSet.EMPTY;
-      } else {
-        docIdSet = new BitDocIdSet(BitSet.of(s.iterator(), context.reader().maxDoc()));
-      }
-      cache.put(key, docIdSet);
+      final DocIdSet value;
+      value = createBitDocIdSet(context);
+      cache.put(key, docIdSet=value);
     }
     return docIdSet == DocIdSet.EMPTY ? null : ((BitDocIdSet) docIdSet).bits();
   }
+
+  /**
+   * @return either {@link BitDocIdSet} for the given segment or {@link DocIdSet#EMPTY} 
+   * in case of absent matches on the given segment
+   * */
+  protected DocIdSet createBitDocIdSet(LeafReaderContext context) throws IOException {
+    final DocIdSet value;
+    final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(context);
+    final IndexSearcher searcher = new IndexSearcher(topLevelContext);
+    searcher.setQueryCache(null);
+    final Weight weight = searcher.createNormalizedWeight(query, false);
+    final Scorer s = weight.scorer(context);
+
+    if (s == null) {
+      value = DocIdSet.EMPTY;
+    } else {
+      value = new BitDocIdSet(BitSet.of(s.iterator(), context.reader().maxDoc()));
+    }
+    return value;
+  }
   
   @Override
   public String toString() {
diff --git a/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinValidation.java b/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinValidation.java
index aa68d09..36b56a2 100644
--- a/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinValidation.java
+++ b/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinValidation.java
@@ -68,7 +68,8 @@
     indexReader = DirectoryReader.open(indexWriter);
     indexWriter.close();
     indexSearcher = new IndexSearcher(indexReader);
-    parentsFilter = new QueryBitSetProducer(new WildcardQuery(new Term("parent", "*")));
+    parentsFilter = random().nextBoolean() ? new QueryBitSetProducer(new WildcardQuery(new Term("parent", "*"))) 
+       : new CheckingQueryBitSetProducer(new WildcardQuery(new Term("parent", "*")));
   }
 
   @Override
diff --git a/solr/core/src/java/org/apache/solr/search/join/BlockJoinParentQParser.java b/solr/core/src/java/org/apache/solr/search/join/BlockJoinParentQParser.java
index 8f36dd2..f54fc09 100644
--- a/solr/core/src/java/org/apache/solr/search/join/BlockJoinParentQParser.java
+++ b/solr/core/src/java/org/apache/solr/search/join/BlockJoinParentQParser.java
@@ -23,7 +23,7 @@
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.join.BitSetProducer;
-import org.apache.lucene.search.join.QueryBitSetProducer;
+import org.apache.lucene.search.join.CheckingQueryBitSetProducer;
 import org.apache.lucene.search.join.ScoreMode;
 import org.apache.lucene.search.join.ToParentBlockJoinQuery;
 import org.apache.lucene.util.BitDocIdSet;
@@ -94,7 +94,7 @@
   }
 
   private BitSetProducer createParentFilter(Query parentQ) {
-    return new QueryBitSetProducer(parentQ);
+    return new CheckingQueryBitSetProducer(parentQ);
   }
 
   static final class AllParentsAware extends ToParentBlockJoinQuery {
diff --git a/solr/core/src/test/org/apache/solr/search/join/BJQParserTest.java b/solr/core/src/test/org/apache/solr/search/join/BJQParserTest.java
index 39fa791..5e7374b 100644
--- a/solr/core/src/test/org/apache/solr/search/join/BJQParserTest.java
+++ b/solr/core/src/test/org/apache/solr/search/join/BJQParserTest.java
@@ -246,7 +246,7 @@
         req("q", "{!parent which=$parentfilter v=$children}", "children",
             "{!parent which=$childrenfilter v=$grandchildren}",
             "grandchildren", "grand_s:" + "x", "parentfilter",
-            "parent_s:[* TO *]", "childrenfilter", "child_s:[* TO *]"),
+            "parent_s:[* TO *]", "childrenfilter", "child_s:[* TO *] {!v=$parentfilter}"),
         sixParents);
     // int loops = atLeast(1);
     String grandChildren = xyz.get(random().nextInt(xyz.size()));
@@ -254,7 +254,7 @@
         req("q", "+parent_s:(a e b) +_query_:\"{!parent which=$pq v=$chq}\"",
             "chq", "{!parent which=$childfilter v=$grandchq}", "grandchq",
             "+grand_s:" + grandChildren + " +grand_parentchild_s:(b* e* c*)",
-            "pq", "parent_s:[* TO *]", "childfilter", "child_s:[* TO *]"),
+            "pq", "parent_s:[* TO *]", "childfilter", "child_s:[* TO *] {!v=$pq}"),
         beParents);
   }
   
