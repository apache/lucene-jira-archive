Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 1598471)
+++ lucene/CHANGES.txt	(working copy)
@@ -173,6 +173,8 @@
 
 * LUCENE-5700: Added oal.util.Accountable that is now implemented by all
   classes whose memory usage can be estimated. (Robert Muir, Adrien Grand)
+
+* LUCENE-5695: DocIdSet now implements Accountable. (Adrien Grand)
   
 Optimizations
 
Index: lucene/core/build.xml
===================================================================
--- lucene/core/build.xml	(revision 1598471)
+++ lucene/core/build.xml	(working copy)
@@ -32,7 +32,6 @@
 
   <property name="forbidden-rue-excludes" value="
     org/apache/lucene/util/RamUsageEstimator.class
-    org/apache/lucene/search/CachingWrapperFilter.class
   "/>
 
   <import file="../common-build.xml"/>
Index: lucene/core/src/java/org/apache/lucene/search/CachingWrapperFilter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/CachingWrapperFilter.java	(revision 1598471)
+++ lucene/core/src/java/org/apache/lucene/search/CachingWrapperFilter.java	(working copy)
@@ -17,6 +17,8 @@
  * limitations under the License.
  */
 
+import static org.apache.lucene.search.DocIdSet.EMPTY;
+
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -28,7 +30,6 @@
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.util.Accountable;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.RamUsageEstimator;
 import org.apache.lucene.util.WAH8DocIdSet;
 
 /**
@@ -60,7 +61,7 @@
    *  by the wrapped Filter. <p>This implementation returns the given {@link DocIdSet},
    *  if {@link DocIdSet#isCacheable} returns <code>true</code>, else it calls
    *  {@link #cacheImpl(DocIdSetIterator,AtomicReader)}
-   *  <p>Note: This method returns {@linkplain #EMPTY_DOCIDSET} if the given docIdSet
+   *  <p>Note: This method returns {@linkplain DocIdSet#EMPTY} if the given docIdSet
    *  is <code>null</code> or if {@link DocIdSet#iterator()} return <code>null</code>. The empty
    *  instance is use as a placeholder in the cache instead of the <code>null</code> value.
    */
@@ -67,7 +68,7 @@
   protected DocIdSet docIdSetToCache(DocIdSet docIdSet, AtomicReader reader) throws IOException {
     if (docIdSet == null) {
       // this is better than returning null, as the nonnull result can be cached
-      return EMPTY_DOCIDSET;
+      return EMPTY;
     } else if (docIdSet.isCacheable()) {
       return docIdSet;
     } else {
@@ -76,7 +77,7 @@
       // in this case we wrap with the sentinel set,
       // which is cacheable.
       if (it == null) {
-        return EMPTY_DOCIDSET;
+        return EMPTY;
       } else {
         return cacheImpl(it, reader);
       }
@@ -110,7 +111,7 @@
       cache.put(key, docIdSet);
     }
 
-    return docIdSet == EMPTY_DOCIDSET ? null : BitsFilteredDocIdSet.wrap(docIdSet, acceptDocs);
+    return docIdSet == EMPTY ? null : BitsFilteredDocIdSet.wrap(docIdSet, acceptDocs);
   }
   
   @Override
@@ -129,26 +130,6 @@
   public int hashCode() {
     return (filter.hashCode() ^ getClass().hashCode());
   }
-  
-  /** An empty {@code DocIdSet} instance */
-  protected static final DocIdSet EMPTY_DOCIDSET = new DocIdSet() {
-    
-    @Override
-    public DocIdSetIterator iterator() {
-      return DocIdSetIterator.empty();
-    }
-    
-    @Override
-    public boolean isCacheable() {
-      return true;
-    }
-    
-    // we explicitly provide no random access, as this filter is 100% sparse and iterator exits faster
-    @Override
-    public Bits bits() {
-      return null;
-    }
-  };
 
   @Override
   public long ramBytesUsed() {
@@ -161,7 +142,7 @@
 
     long total = 0;
     for(DocIdSet dis : docIdSets) {
-      total += RamUsageEstimator.sizeOf(dis);
+      total += dis.ramBytesUsed();
     }
 
     return total;
Index: lucene/core/src/java/org/apache/lucene/search/DocIdSet.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DocIdSet.java	(revision 1598471)
+++ lucene/core/src/java/org/apache/lucene/search/DocIdSet.java	(working copy)
@@ -18,6 +18,8 @@
  */
 
 import java.io.IOException;
+
+import org.apache.lucene.util.Accountable;
 import org.apache.lucene.util.Bits;
 
 /**
@@ -24,8 +26,33 @@
  * A DocIdSet contains a set of doc ids. Implementing classes must
  * only implement {@link #iterator} to provide access to the set. 
  */
-public abstract class DocIdSet {
+public abstract class DocIdSet implements Accountable {
 
+  /** An empty {@code DocIdSet} instance */
+  public static final DocIdSet EMPTY = new DocIdSet() {
+    
+    @Override
+    public DocIdSetIterator iterator() {
+      return DocIdSetIterator.empty();
+    }
+    
+    @Override
+    public boolean isCacheable() {
+      return true;
+    }
+    
+    // we explicitly provide no random access, as this filter is 100% sparse and iterator exits faster
+    @Override
+    public Bits bits() {
+      return null;
+    }
+
+    @Override
+    public long ramBytesUsed() {
+      return 0L;
+    }
+  };
+
   /** Provides a {@link DocIdSetIterator} to access the set.
    * This implementation can return <code>null</code> if there
    * are no docs that match. */
@@ -65,4 +92,5 @@
   public boolean isCacheable() {
     return false;
   }
+
 }
Index: lucene/core/src/java/org/apache/lucene/search/DocValuesDocIdSet.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DocValuesDocIdSet.java	(revision 1598471)
+++ lucene/core/src/java/org/apache/lucene/search/DocValuesDocIdSet.java	(working copy)
@@ -17,6 +17,7 @@
  */
 
 import java.io.IOException;
+
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.OpenBitSet;
@@ -55,6 +56,11 @@
   }
 
   @Override
+  public long ramBytesUsed() {
+    return 0L;
+  }
+
+  @Override
   public final Bits bits() {
     return (acceptDocs == null) ? new Bits() {
       @Override
Index: lucene/core/src/java/org/apache/lucene/search/FilteredDocIdSet.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/FilteredDocIdSet.java	(revision 1598471)
+++ lucene/core/src/java/org/apache/lucene/search/FilteredDocIdSet.java	(working copy)
@@ -18,7 +18,9 @@
  */
 
 import java.io.IOException;
+
 import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.RamUsageEstimator;
 
 /**
  * Abstract decorator class for a DocIdSet implementation
@@ -55,8 +57,13 @@
   public boolean isCacheable() {
     return _innerSet.isCacheable();
   }
-  
+
   @Override
+  public long ramBytesUsed() {
+    return RamUsageEstimator.NUM_BYTES_OBJECT_REF + _innerSet.ramBytesUsed();
+  }
+
+  @Override
   public Bits bits() throws IOException {
     final Bits bits = _innerSet.bits();
     return (bits == null) ? null : new Bits() {
Index: lucene/core/src/java/org/apache/lucene/search/QueryWrapperFilter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/QueryWrapperFilter.java	(revision 1598471)
+++ lucene/core/src/java/org/apache/lucene/search/QueryWrapperFilter.java	(working copy)
@@ -58,8 +58,11 @@
       public DocIdSetIterator iterator() throws IOException {
         return weight.scorer(privateContext, acceptDocs);
       }
+
       @Override
-      public boolean isCacheable() { return false; }
+      public long ramBytesUsed() {
+        return 0L;
+      }
     };
   }
 
Index: lucene/core/src/java/org/apache/lucene/util/DocIdBitSet.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/DocIdBitSet.java	(revision 1598471)
+++ lucene/core/src/java/org/apache/lucene/util/DocIdBitSet.java	(working copy)
@@ -64,7 +64,12 @@
     // the size may not be correct...
     return bitSet.size(); 
   }
-  
+
+  @Override
+  public long ramBytesUsed() {
+    return RamUsageEstimator.NUM_BYTES_OBJECT_REF + (bitSet.size() + 7) >>> 3;
+  }
+
   private static class DocIdBitSetIterator extends DocIdSetIterator {
     private int docId;
     private BitSet bitSet;
Index: lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java	(revision 1598471)
+++ lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java	(working copy)
@@ -218,6 +218,14 @@
     return true;
   }
 
+  @Override
+  public long ramBytesUsed() {
+    return RamUsageEstimator.alignObjectSize(
+          RamUsageEstimator.NUM_BYTES_OBJECT_REF // the reference to the long[]
+        + RamUsageEstimator.NUM_BYTES_INT * 2)   // numBits and numWords
+        + RamUsageEstimator.sizeOf(bits);        // the bits
+  }
+
   /** Expert. */
   public long[] getBits() {
     return bits;
Index: lucene/core/src/java/org/apache/lucene/util/OpenBitSet.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/OpenBitSet.java	(revision 1598471)
+++ lucene/core/src/java/org/apache/lucene/util/OpenBitSet.java	(working copy)
@@ -131,6 +131,15 @@
     return true;
   }
 
+  @Override
+  public long ramBytesUsed() {
+    return RamUsageEstimator.alignObjectSize(
+          RamUsageEstimator.NUM_BYTES_OBJECT_REF
+        + RamUsageEstimator.NUM_BYTES_LONG
+        + RamUsageEstimator.NUM_BYTES_INT)
+        + RamUsageEstimator.sizeOf(bits);
+  }
+
   /** Returns the current capacity in bits (1 greater than the index of the last bit) */
   public long capacity() { return bits.length << 6; }
 
Index: lucene/core/src/java/org/apache/lucene/util/SentinelIntSet.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/SentinelIntSet.java	(revision 1598471)
+++ lucene/core/src/java/org/apache/lucene/util/SentinelIntSet.java	(working copy)
@@ -145,4 +145,12 @@
     }
     rehashCount = newSize - (newSize>>2);
   }
+
+  /** Return the memory footprint of this class in bytes. */
+  public long ramBytesUsed() {
+    return RamUsageEstimator.alignObjectSize(
+          RamUsageEstimator.NUM_BYTES_INT * 3
+        + RamUsageEstimator.NUM_BYTES_OBJECT_REF)
+        + RamUsageEstimator.sizeOf(keys);
+  }
 }
Index: lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoDocIdSet.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoDocIdSet.java	(revision 1598471)
+++ lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoDocIdSet.java	(working copy)
@@ -21,8 +21,8 @@
 
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.DocIdSetIterator;
-
 import org.apache.lucene.util.FixedBitSet; // for javadocs
+import org.apache.lucene.util.RamUsageEstimator;
 
 
 /** A DocIdSet in Elias-Fano encoding.
@@ -126,5 +126,10 @@
   public int hashCode() {
     return efEncoder.hashCode() ^ getClass().hashCode();
   }
+
+  @Override
+  public long ramBytesUsed() {
+    return RamUsageEstimator.alignObjectSize(RamUsageEstimator.NUM_BYTES_OBJECT_REF) + efEncoder.ramBytesUsed();
+  }
 }
 
Index: lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder.java	(revision 1598471)
+++ lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder.java	(working copy)
@@ -19,8 +19,10 @@
 
 import java.util.Arrays;
 
+import org.apache.lucene.util.Accountable;
+import org.apache.lucene.util.FixedBitSet; // for javadocs
+import org.apache.lucene.util.RamUsageEstimator;
 import org.apache.lucene.util.ToStringUtils;
-import org.apache.lucene.util.FixedBitSet; // for javadocs
 
 
 /** Encode a non decreasing sequence of non negative whole numbers in the Elias-Fano encoding
@@ -82,7 +84,7 @@
  * @lucene.internal
  */
 
-public class EliasFanoEncoder {
+public class EliasFanoEncoder implements Accountable {
   final long numValues;
   private final long upperBound;
   final int numLowBits;
@@ -350,5 +352,15 @@
     return h;
   }
 
+  @Override
+  public long ramBytesUsed() {
+    return RamUsageEstimator.alignObjectSize(
+          RamUsageEstimator.NUM_BYTES_OBJECT_REF * 3
+        + RamUsageEstimator.NUM_BYTES_LONG * 8
+        + RamUsageEstimator.NUM_BYTES_INT * 2)
+        + RamUsageEstimator.sizeOf(lowerLongs)
+        + RamUsageEstimator.sizeOf(upperLongs)
+        + RamUsageEstimator.sizeOf(upperZeroBitPositionIndex);
+  }
 }
 
Index: lucene/core/src/test/org/apache/lucene/search/JustCompileSearch.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/JustCompileSearch.java	(revision 1598471)
+++ lucene/core/src/test/org/apache/lucene/search/JustCompileSearch.java	(working copy)
@@ -69,7 +69,11 @@
     public DocIdSetIterator iterator() {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
-    
+
+    @Override
+    public long ramBytesUsed() {
+      return 0L;
+    }
   }
 
   static final class JustCompileDocIdSetIterator extends DocIdSetIterator {
Index: lucene/core/src/test/org/apache/lucene/search/TestCachingWrapperFilter.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestCachingWrapperFilter.java	(revision 1598471)
+++ lucene/core/src/test/org/apache/lucene/search/TestCachingWrapperFilter.java	(working copy)
@@ -206,6 +206,11 @@
           public DocIdSetIterator iterator() {
             return null;
           }
+
+          @Override
+          public long ramBytesUsed() {
+            return 0L;
+          }
         };
       }
     };
Index: lucene/core/src/test/org/apache/lucene/search/TestDocIdSet.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestDocIdSet.java	(revision 1598471)
+++ lucene/core/src/test/org/apache/lucene/search/TestDocIdSet.java	(working copy)
@@ -38,6 +38,11 @@
     final int maxdoc=10;
     final DocIdSet innerSet = new DocIdSet() {
 
+      @Override
+      public long ramBytesUsed() {
+        return 0L;
+      }
+
         @Override
         public DocIdSetIterator iterator() {
           return new DocIdSetIterator() {
@@ -151,6 +156,11 @@
           public DocIdSetIterator iterator() {
             return null;
           } 
+
+          @Override
+          public long ramBytesUsed() {
+            return 0L;
+          }
         };
         return new FilteredDocIdSet(innerNullIteratorSet) {
           @Override
Index: lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery.java	(revision 1598471)
+++ lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery.java	(working copy)
@@ -435,8 +435,13 @@
               bitSet.set(d, true);
             }
             return new DocIdSet() {
-              
+
               @Override
+              public long ramBytesUsed() {
+                return 0L;
+              }
+
+              @Override
               public Bits bits() throws IOException {
                 if (nullBitset) {
                   return null;
@@ -502,8 +507,13 @@
       public DocIdSet getDocIdSet(final AtomicReaderContext context, Bits acceptDocs)
           throws IOException {
         return new DocIdSet() {
-          
+
           @Override
+          public long ramBytesUsed() {
+            return 0L;
+          }
+
+          @Override
           public Bits bits() throws IOException {
              return null;
           }
Index: lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRange.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRange.java	(revision 1598471)
+++ lucene/facet/src/java/org/apache/lucene/facet/range/DoubleRange.java	(working copy)
@@ -163,6 +163,11 @@
           public DocIdSetIterator iterator() {
             throw new UnsupportedOperationException("this filter can only be accessed via bits()");
           }
+
+          @Override
+          public long ramBytesUsed() {
+            return 0L;
+          }
         };
       }
     };
Index: lucene/facet/src/java/org/apache/lucene/facet/range/LongRange.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/range/LongRange.java	(revision 1598471)
+++ lucene/facet/src/java/org/apache/lucene/facet/range/LongRange.java	(working copy)
@@ -155,6 +155,11 @@
           public DocIdSetIterator iterator() {
             throw new UnsupportedOperationException("this filter can only be accessed via bits()");
           }
+
+          @Override
+          public long ramBytesUsed() {
+            return 0L;
+          }
         };
       }
     };
Index: lucene/join/src/java/org/apache/lucene/search/join/FixedBitSetCachingWrapperFilter.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/FixedBitSetCachingWrapperFilter.java	(revision 1598471)
+++ lucene/join/src/java/org/apache/lucene/search/join/FixedBitSetCachingWrapperFilter.java	(working copy)
@@ -17,6 +17,8 @@
  * limitations under the License.
  */
 
+import static org.apache.lucene.search.DocIdSet.EMPTY;
+
 import java.io.IOException;
 
 import org.apache.lucene.index.AtomicReader;
@@ -39,7 +41,7 @@
   protected DocIdSet docIdSetToCache(DocIdSet docIdSet, AtomicReader reader)
       throws IOException {
     if (docIdSet == null) {
-      return EMPTY_DOCIDSET;
+      return EMPTY;
     } else if (docIdSet instanceof FixedBitSet) {
       // this is different from CachingWrapperFilter: even when the DocIdSet is
       // cacheable, we convert it to a FixedBitSet since we require all the
@@ -48,7 +50,7 @@
     } else {
       final DocIdSetIterator it = docIdSet.iterator();
       if (it == null) {
-        return EMPTY_DOCIDSET;
+        return EMPTY;
       } else {
         final FixedBitSet copy = new FixedBitSet(reader.maxDoc());
         copy.or(it);
Index: lucene/queries/src/java/org/apache/lucene/queries/TermFilter.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/TermFilter.java	(revision 1598471)
+++ lucene/queries/src/java/org/apache/lucene/queries/TermFilter.java	(working copy)
@@ -72,6 +72,10 @@
         return termsEnum.docs(acceptDocs, null, DocsEnum.FLAG_NONE);
       }
 
+      @Override
+      public long ramBytesUsed() {
+        return 0L;
+      }
     };
   }
 
Index: lucene/queries/src/test/org/apache/lucene/queries/BooleanFilterTest.java
===================================================================
--- lucene/queries/src/test/org/apache/lucene/queries/BooleanFilterTest.java	(revision 1598471)
+++ lucene/queries/src/test/org/apache/lucene/queries/BooleanFilterTest.java	(working copy)
@@ -111,17 +111,7 @@
     return new Filter() {
       @Override
       public DocIdSet getDocIdSet(AtomicReaderContext context, Bits acceptDocs) {
-        return new DocIdSet() {
-          @Override
-          public DocIdSetIterator iterator() {
-            return null;
-          }
-          
-          @Override
-          public boolean isCacheable() {
-            return true;
-          }
-        };
+        return DocIdSet.EMPTY;
       }
     };
   }
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.java	(revision 1598471)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.java	(working copy)
@@ -19,6 +19,7 @@
 
 import com.spatial4j.core.shape.Shape;
 import com.spatial4j.core.shape.SpatialRelation;
+
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.search.DocIdSet;
@@ -28,6 +29,7 @@
 import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.RamUsageEstimator;
 import org.apache.lucene.util.SentinelIntSet;
 
 import java.io.IOException;
@@ -299,6 +301,14 @@
       };
     }
 
+    @Override
+    public long ramBytesUsed() {
+      return RamUsageEstimator.alignObjectSize(
+            RamUsageEstimator.NUM_BYTES_OBJECT_REF
+          + RamUsageEstimator.NUM_BYTES_INT)
+          + intSet.ramBytesUsed();
+    }
+
   }//class SmallDocSet
 
 }
Index: lucene/spatial/src/java/org/apache/lucene/spatial/serialized/SerializedDVStrategy.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/serialized/SerializedDVStrategy.java	(revision 1598471)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/serialized/SerializedDVStrategy.java	(working copy)
@@ -21,6 +21,7 @@
 import com.spatial4j.core.io.BinaryCodec;
 import com.spatial4j.core.shape.Point;
 import com.spatial4j.core.shape.Shape;
+
 import org.apache.lucene.document.BinaryDocValuesField;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.AtomicReaderContext;
@@ -170,6 +171,11 @@
             }
           };
         }
+
+        @Override
+        public long ramBytesUsed() {
+          return 0L;
+        }
       };
     }
 
Index: solr/core/src/java/org/apache/solr/search/BitDocSet.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/BitDocSet.java	(revision 1598471)
+++ solr/core/src/java/org/apache/solr/search/BitDocSet.java	(working copy)
@@ -336,6 +336,11 @@
           }
 
           @Override
+          public long ramBytesUsed() {
+            return bs.ramBytesUsed();
+          }
+
+          @Override
           public Bits bits() {
             return new Bits() {
               @Override
Index: solr/core/src/java/org/apache/solr/search/DocSetBase.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/DocSetBase.java	(revision 1598471)
+++ solr/core/src/java/org/apache/solr/search/DocSetBase.java	(working copy)
@@ -216,6 +216,11 @@
           }
 
           @Override
+          public long ramBytesUsed() {
+            return bs.ramBytesUsed();
+          }
+
+          @Override
           public Bits bits() {
             // sparse filters should not use random access
             return null;
Index: solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java	(revision 1598471)
+++ solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java	(working copy)
@@ -2508,6 +2508,11 @@
     public Bits bits() throws IOException {
       return null;  // don't use random access
     }
+
+    @Override
+    public long ramBytesUsed() {
+      return docIdSet != null ? docIdSet.ramBytesUsed() : 0L;
+    }
   }
 
   private static class FilterIterator extends DocIdSetIterator {
Index: solr/core/src/java/org/apache/solr/search/SortedIntDocSet.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/SortedIntDocSet.java	(revision 1598471)
+++ solr/core/src/java/org/apache/solr/search/SortedIntDocSet.java	(working copy)
@@ -25,6 +25,7 @@
 import org.apache.lucene.search.Filter;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.FixedBitSet;
+import org.apache.lucene.util.RamUsageEstimator;
 
 /**
  * <code>SortedIntDocSet</code> represents a sorted set of Lucene Document Ids.
@@ -766,6 +767,11 @@
           }
 
           @Override
+          public long ramBytesUsed() {
+            return RamUsageEstimator.sizeOf(docs);
+          }
+          
+          @Override
           public Bits bits() {
             // random access is expensive for this set
             return null;
Index: solr/core/src/java/org/apache/solr/search/function/ValueSourceRangeFilter.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/function/ValueSourceRangeFilter.java	(revision 1598471)
+++ solr/core/src/java/org/apache/solr/search/function/ValueSourceRangeFilter.java	(working copy)
@@ -84,6 +84,11 @@
        public Bits bits() {
          return null;  // don't use random access
        }
+
+       @Override
+       public long ramBytesUsed() {
+         return 0L;
+       }
      }, acceptDocs);
   }
 
