diff --git a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler.java b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler.java
index 1879724..dd403fb 100644
--- a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler.java
+++ b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler.java
@@ -228,7 +228,7 @@ public final class JavascriptCompiler {
   /**
    * Sends the bytecode of class file to {@link ClassWriter}.
    */
-  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) {
+  private void generateClass(final ParseTree parseTree, final ClassWriter classWriter, final Map<String, Integer> externalsMap) throws ParseException {
     classWriter.visit(CLASSFILE_VERSION,
         Opcodes.ACC_PUBLIC | Opcodes.ACC_SUPER | Opcodes.ACC_FINAL | Opcodes.ACC_SYNTHETIC,
         COMPILED_EXPRESSION_INTERNAL,
@@ -247,7 +247,7 @@ public final class JavascriptCompiler {
     
     final GeneratorAdapter gen = new GeneratorAdapter(Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC,
         EVALUATE_METHOD, null, null, classWriter);
-
+    
     // to completely hide the ANTLR visitor we use an anonymous impl:
     new JavascriptBaseVisitor<Void>() {
       private final Deque<Type> typeStack = new ArrayDeque<>();
@@ -295,8 +295,10 @@ public final class JavascriptCompiler {
           int arity = method.getParameterTypes().length;
 
           if (arguments != arity) {
-            throw new IllegalArgumentException(
-                "Expected (" + arity + ") arguments for function call (" + text + "), but found (" + arguments + ").");
+            throwParseException(
+                new ParseException("Invalid expression '" + sourceText + "': Expected (" + arity + 
+                                   ") arguments for function call (" + text + "), but found (" + arguments + ").", 
+                                   ctx.start.getStartIndex()));
           }
 
           typeStack.push(Type.DOUBLE_TYPE);
@@ -330,7 +332,10 @@ public final class JavascriptCompiler {
           gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);
           gen.cast(Type.DOUBLE_TYPE, typeStack.peek());
         } else {
-          throw new IllegalArgumentException("Unrecognized function call (" + text + ").");
+          throwParseException(
+              new ParseException("Invalid expression '" + sourceText + 
+                                 "': Unrecognized function call (" + text + ").", 
+                                 ctx.start.getStartIndex()));
         }
 
         return null;
@@ -703,6 +708,17 @@ public final class JavascriptCompiler {
     }
     DEFAULT_FUNCTIONS = Collections.unmodifiableMap(map);
   }
+  
+  // Hack to allow the JavascriptVisitor to throw a ParseException
+  // that's not declared
+  private static void throwParseException(Throwable t) {
+    JavascriptCompiler.<Error>rethrow0(t);
+  }
+  
+  @SuppressWarnings("unchecked")
+  private static <T extends Throwable> void rethrow0(Throwable t) throws T {
+    throw (T) t;
+  }
     
   /** Check Method signature for compatibility. */
   private static void checkFunction(Method method) {
diff --git a/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestCustomFunctions.java b/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestCustomFunctions.java
index c460154..5c7dfec 100644
--- a/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestCustomFunctions.java
+++ b/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestCustomFunctions.java
@@ -42,8 +42,9 @@ public class TestCustomFunctions extends LuceneTestCase {
     try {
       JavascriptCompiler.compile("sqrt(20)", functions, getClass().getClassLoader());
       fail();
-    } catch (IllegalArgumentException e) {
-      assertTrue(e.getMessage().contains("Unrecognized function"));
+    } catch (ParseException expected) {
+      assertEquals("Invalid expression 'sqrt(20)': Unrecognized function call (sqrt).", expected.getMessage());
+      assertEquals(expected.getErrorOffset(), 0);
     }
   }
   
@@ -98,19 +99,34 @@ public class TestCustomFunctions extends LuceneTestCase {
     try {
       JavascriptCompiler.compile("method()");
       fail();
-    } catch (ParseException exception) {
-      fail();
     } catch (IllegalArgumentException exception) {
+      fail();
+    } catch (ParseException expected) {
       //expected
+      assertEquals("Invalid expression 'method()': Unrecognized function call (method).", expected.getMessage());
+      assertEquals(0, expected.getErrorOffset());
     }
 
     try {
       JavascriptCompiler.compile("method.method(1)");
       fail();
-    } catch (ParseException exception) {
+    } catch (IllegalArgumentException exception) {
+      fail();
+    } catch (ParseException expected) {
+      //expected
+      assertEquals("Invalid expression 'method.method(1)': Unrecognized function call (method.method).", expected.getMessage());
+      assertEquals(0, expected.getErrorOffset());
+    }
+    
+    try {
+      JavascriptCompiler.compile("1 + method()");
       fail();
     } catch (IllegalArgumentException exception) {
+      fail();
+    } catch (ParseException expected) {
       //expected
+      assertEquals("Invalid expression '1 + method()': Unrecognized function call (method).", expected.getMessage());
+      assertEquals(4, expected.getErrorOffset());
     }
   }
 
diff --git a/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestJavascriptCompiler.java b/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestJavascriptCompiler.java
index 3f0c0b0..c572c33 100644
--- a/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestJavascriptCompiler.java
+++ b/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestJavascriptCompiler.java
@@ -181,16 +181,33 @@ public class TestJavascriptCompiler extends LuceneTestCase {
     try {
       JavascriptCompiler.compile("tan()");
       fail();
-    } catch (IllegalArgumentException expected) {
-      assertTrue(expected.getMessage().contains("arguments for function call"));
+    } catch (ParseException expected) {
+      assertEquals("Invalid expression 'tan()': Expected (1) arguments for function call (tan), but found (0).", expected.getMessage());
+      assertEquals(expected.getErrorOffset(), 0);
     }
     
     try {
       JavascriptCompiler.compile("tan(1, 1)");
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (ParseException expected) {
       assertTrue(expected.getMessage().contains("arguments for function call"));
     }
+    
+    try {
+      JavascriptCompiler.compile(" tan()");
+      fail();
+    } catch (ParseException expected) {
+      assertEquals("Invalid expression ' tan()': Expected (1) arguments for function call (tan), but found (0).", expected.getMessage());
+      assertEquals(expected.getErrorOffset(), 1);
+    }
+    
+    try {
+      JavascriptCompiler.compile("1 + tan()");
+      fail();
+    } catch (ParseException expected) {
+      assertEquals("Invalid expression '1 + tan()': Expected (1) arguments for function call (tan), but found (0).", expected.getMessage());
+      assertEquals(expected.getErrorOffset(), 4);
+    }
   }
 
   public void testVariableNormalization() throws Exception {
