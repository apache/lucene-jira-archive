Index: Field.java
===================================================================
--- Field.java	(revision 157812)
+++ Field.java	(working copy)
@@ -38,6 +38,8 @@
   
   // the one and only data object for all different kind of field values
   private Object fieldsData = null;
+  // if fieldsData is a byte[], then this is how many bytes in it represent the field value
+  private int fieldsDataLength;
   
   private boolean storeTermVector = false;
   private boolean storeOffsetWithTermVector = false; 
@@ -261,11 +263,18 @@
    * and binaryValue() must be set. */
   public Reader readerValue()   { try { return (Reader)fieldsData; } catch (ClassCastException ignore) { return null; } }
   
-  /** The value of the field in Binary, or null.  If null, the Reader or
+  /** The value of the field in Binary, or null. If null, the Reader or
    * String value is used.  Exactly one of stringValue(), readerValue() and
    * binaryValue() must be set. */
   public byte[] binaryValue()   { try { return (byte[])fieldsData; } catch (ClassCastException ignore) { return null; } }
   
+  /** Expert:  The number of bytes in a binaryValue() that holds field data.
+   * This should only be used internally within Lucene -- see the Field method that accepts a length parameter
+   * and FieldsWriter.addDocument().
+   * For normal purposes, use binaryValue().length
+   */
+  public int binaryLength() { return fieldsDataLength; }
+  
   /**
    * Create a field by specifying its name, value and how it will
    * be saved in the index. Term vectors will not be stored in the index.
@@ -398,7 +407,6 @@
     this(name, string, store, index, token, false);
   }
 
-  
   /**
    * Create a stored field with binary value. Optionally the value may be compressed.
    * 
@@ -407,6 +415,22 @@
    * @param store How <code>value</code> should be stored (compressed or not.)
    */
   public Field(String name, byte[] value, Store store) {
+    this(name, value, value.length, store);
+  }
+
+  
+  /** Expert: Create a stored field with binary value. Optionally the value may be compressed.
+   * This version of the method supports reusing a byte[] across successive documents during
+   * indexing, thereby eliminating allocations of large field values.  However, this value will be
+   * retained until the document is added to the index and so the same buffer cannot be used
+   * with different values on more than one field of a document.
+   * 
+   * @param name The name of the field
+   * @param value The byte[] holding the binary value
+   * @param length The number of bytes in value holding data
+   * @param store How <code>value</code> should be stored (compressed or not.)
+   */
+  public Field(String name, byte[] value, int length, Store store) {
     if (name == null)
       throw new IllegalArgumentException("name cannot be null");
     if (value == null)
@@ -414,6 +438,7 @@
     
     this.name = name.intern();
     this.fieldsData = value;
+    this.fieldsDataLength = length;
     
     if (store == Store.YES){
       this.isStored = true;
