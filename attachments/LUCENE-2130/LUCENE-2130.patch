Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 963233)
+++ lucene/CHANGES.txt	(working copy)
@@ -716,6 +716,9 @@
   files when a mergedSegmentWarmer is set on IndexWriter.  (Mike
   McCandless)
 
+* LUCENE-2130: Fix performance issue when FuzzyQuery runs on a
+  multi-segment index (Michael McCandless)
+
 API Changes
 
 * LUCENE-2281: added doBeforeFlush to IndexWriter to allow extensions to perform
Index: lucene/src/test/org/apache/lucene/index/TestMultiFields.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestMultiFields.java	(revision 963233)
+++ lucene/src/test/org/apache/lucene/index/TestMultiFields.java	(working copy)
@@ -88,6 +88,8 @@
         BytesRef term = terms.get(r.nextInt(terms.size()));
         
         DocsEnum docsEnum = terms2.docs(delDocs, term, null);
+        assertNotNull(docsEnum);
+
         int count = 0;
         for(int docID : docs.get(term)) {
           if (!deleted.contains(docID)) {
Index: lucene/src/java/org/apache/lucene/index/MultiTermsEnum.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/MultiTermsEnum.java	(revision 963233)
+++ lucene/src/java/org/apache/lucene/index/MultiTermsEnum.java	(working copy)
@@ -42,6 +42,9 @@
   private final MultiDocsEnum.EnumWithSlice[] subDocs;
   private final MultiDocsAndPositionsEnum.EnumWithSlice[] subDocsAndPositions;
 
+  private BytesRef lastSeek;
+  private final BytesRef lastSeekScratch = new BytesRef();
+
   private int numTop;
   private int numSubs;
   private BytesRef current;
@@ -139,8 +142,40 @@
   public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {
     queue.clear();
     numTop = 0;
+
+    boolean seekOpt = false;
+    if (lastSeek != null && termComp.compare(lastSeek, term) <= 0) {
+      seekOpt = true;
+    }
+    lastSeekScratch.copy(term);
+    lastSeek = lastSeekScratch;
+
     for(int i=0;i<numSubs;i++) {
-      final SeekStatus status = currentSubs[i].terms.seek(term, useCache);
+      final SeekStatus status;
+      // LUCENE-2130: if we had just seek'd already, prior
+      // to this seek, and the new seek term is after the
+      // previous one, don't try to re-seek this sub if its
+      // current term is already beyond this new seek term.
+      // Doing so is a waste because this sub will simply
+      // seek to the same spot.
+      if (seekOpt) {
+        final BytesRef curTerm = currentSubs[i].current;
+        if (curTerm != null) {
+          final int cmp = termComp.compare(term, curTerm);
+          if (cmp == 0) {
+            status = SeekStatus.FOUND;
+          } else if (cmp < 0) {
+            status = SeekStatus.NOT_FOUND;
+          } else {
+            status = currentSubs[i].terms.seek(term, useCache);
+          }
+        } else {
+          status = SeekStatus.END;
+        }
+      } else {
+        status = currentSubs[i].terms.seek(term, useCache);
+      }
+
       if (status == SeekStatus.FOUND) {
         top[numTop++] = currentSubs[i];
         current = currentSubs[i].current = currentSubs[i].terms.term();
@@ -150,6 +185,7 @@
         queue.add(currentSubs[i]);
       } else {
         // enum exhausted
+        currentSubs[i].current = null;
       }
     }
 
@@ -205,6 +241,8 @@
 
   @Override
   public BytesRef next() throws IOException {
+    lastSeek = null;
+
     // restore queue
     pushTop();
 
