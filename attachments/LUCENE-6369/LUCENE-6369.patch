Index: lucene/core/src/java/org/apache/lucene/search/AutomatonQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/AutomatonQuery.java	(revision 1668817)
+++ lucene/core/src/java/org/apache/lucene/search/AutomatonQuery.java	(working copy)
@@ -23,6 +23,7 @@
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.AttributeSource;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.ToStringUtils;
 import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.automaton.CompiledAutomaton;
@@ -79,7 +80,7 @@
    */
   public AutomatonQuery(final Term term, Automaton automaton, int maxDeterminizedStates) {
     super(term.field());
-    this.term = term;
+    this.term = new Term(term.field(), BytesRef.deepCopyOf(term.bytes()));
     this.automaton = automaton;
     this.compiled = new CompiledAutomaton(automaton, null, true, maxDeterminizedStates);
   }
Index: lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java	(revision 1668817)
+++ lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java	(working copy)
@@ -246,7 +246,10 @@
   @Override @SuppressWarnings("unchecked")
   public BooleanQuery clone() {
     BooleanQuery clone = (BooleanQuery)super.clone();
-    clone.clauses = new ArrayList<>(clauses);
+    clone.clauses = new ArrayList<>(clauses.size());
+    for (BooleanClause clause : clauses()) {
+      clone.add(clause.getQuery().clone(), clause.getOccur());
+    }
     return clone;
   }
 
Index: lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java	(revision 1668817)
+++ lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java	(working copy)
@@ -34,7 +34,7 @@
  * It therefore simply strips of all scores and returns a constant one.
  */
 public class ConstantScoreQuery extends Query {
-  protected final Query query;
+  protected Query query;
 
   /** Strips off scores from the passed in Query. The hits will get a constant score
    * dependent on the boost factor of this query. */
@@ -285,4 +285,10 @@
     return 31 * super.hashCode() + query.hashCode();
   }
 
+  @Override
+  public Query clone() {
+    ConstantScoreQuery clone = (ConstantScoreQuery) super.clone();
+    clone.query = query.clone();
+    return clone;
+  }
 }
Index: lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java	(revision 1668817)
+++ lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java	(working copy)
@@ -233,7 +233,10 @@
   @Override @SuppressWarnings("unchecked")
   public DisjunctionMaxQuery clone() {
     DisjunctionMaxQuery clone = (DisjunctionMaxQuery)super.clone();
-    clone.disjuncts = (ArrayList<Query>) this.disjuncts.clone();
+    clone.disjuncts = new ArrayList<>(disjuncts.size());
+    for (Query q : disjuncts) {
+      clone.add(q.clone());
+    }
     return clone;
   }
 
Index: lucene/core/src/java/org/apache/lucene/search/DocValuesTermsQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DocValuesTermsQuery.java	(revision 1668817)
+++ lucene/core/src/java/org/apache/lucene/search/DocValuesTermsQuery.java	(working copy)
@@ -91,6 +91,9 @@
   public DocValuesTermsQuery(String field, Collection<BytesRef> terms) {
     this.field = Objects.requireNonNull(field);
     this.terms = terms.toArray(new BytesRef[terms.size()]);
+    for (int i = 0; i < this.terms.length; ++i) {
+      this.terms[i] = BytesRef.deepCopyOf(this.terms[i]);
+    }
     ArrayUtil.timSort(this.terms, BytesRef.getUTF8SortedAsUnicodeComparator());
   }
 
Index: lucene/core/src/java/org/apache/lucene/search/Filter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/Filter.java	(revision 1668817)
+++ lucene/core/src/java/org/apache/lucene/search/Filter.java	(working copy)
@@ -62,19 +62,6 @@
   //
 
   @Override
-  public boolean equals(Object that) {
-    // Query's default impl only compares boost but they do not matter in the
-    // case of filters since it does not influence scores
-    return this == that;
-  }
-
-  @Override
-  public int hashCode() {
-    // Query's default impl returns a hash of the boost but this is irrelevant to filters
-    return System.identityHashCode(this);
-  }
-
-  @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     return new Weight(this) {
 
Index: lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java	(revision 1668817)
+++ lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java	(working copy)
@@ -42,8 +42,8 @@
  */
 public class FilteredQuery extends Query {
 
-  private final Query query;
-  private final Filter filter;
+  private Query query;
+  private Filter filter;
   private final FilterStrategy strategy;
 
   /**
@@ -86,7 +86,7 @@
    */
   @Override
   public Weight createWeight(final IndexSearcher searcher, boolean needsScores) throws IOException {
-    final Weight weight = query.createWeight (searcher, needsScores);
+    final Weight weight = searcher.createWeight (query, needsScores);
     return new Weight(FilteredQuery.this) {
 
       @Override
@@ -635,5 +635,12 @@
       return scorer == null ? null : new QueryFirstBulkScorer(scorer, filterAcceptDocs);
     }
   }
-  
+
+  @Override
+  public Query clone() {
+    FilteredQuery clone = (FilteredQuery) super.clone();
+    clone.query = query.clone();
+    clone.filter = (Filter) filter.clone();
+    return clone;
+  }
 }
Index: lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java	(revision 1668817)
+++ lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java	(working copy)
@@ -21,6 +21,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.ConcurrentModificationException;
 import java.util.IdentityHashMap;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
@@ -269,10 +270,20 @@
   synchronized void evictIfNecessary() {
     // under a lock to make sure that mostRecentlyUsedQueries and cache keep sync'ed
     if (requiresEviction()) {
+      
       Iterator<Query> iterator = mostRecentlyUsedQueries.iterator();
       do {
         final Query query = iterator.next();
+        final int size = mostRecentlyUsedQueries.size();
         iterator.remove();
+        if (size == mostRecentlyUsedQueries.size()) {
+          // size did not decrease, because the hash of the query changed since it has been
+          // put into the cache
+          throw new ConcurrentModificationException("Removal from the cache failed! This " +
+              "is probably due to a query which has been modified after having been put into " +
+              " the cache or a badly implemented clone(). Query class: [" + query.getClass() +
+              "], query: [" + query + "]");
+        }
         onEviction(query);
       } while (iterator.hasNext() && requiresEviction());
     }
Index: lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java	(revision 1668817)
+++ lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java	(working copy)
@@ -104,6 +104,11 @@
       }
     }
 
+    terms = Arrays.copyOf(terms, terms.length);
+    for (int i = 0; i < terms.length; ++i) {
+      terms[i] = new Term(terms[i].field(), BytesRef.deepCopyOf(terms[i].bytes()));
+    }
+
     termArrays.add(terms);
     positions.add(Integer.valueOf(position));
   }
@@ -399,6 +404,14 @@
     }
     return true;
   }
+
+  @Override
+  public Query clone() {
+    MultiPhraseQuery clone = (MultiPhraseQuery) super.clone();
+    clone.positions = new ArrayList<>(positions);
+    clone.termArrays = new ArrayList<>(termArrays);
+    return clone;
+  }
 }
 
 /**
Index: lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java	(revision 1668817)
+++ lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java	(working copy)
@@ -84,6 +84,13 @@
   public final String getField() { return query.getField(); }
 
   @Override
+  public Query clone() {
+    MultiTermQueryConstantScoreWrapper<Q> clone = new MultiTermQueryConstantScoreWrapper<Q>((Q) query.clone());
+    clone.setBoost(getBoost());
+    return clone;
+  }
+
+  @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     return new ConstantScoreWeight(this) {
       @Override
Index: lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java	(revision 1668817)
+++ lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java	(working copy)
@@ -36,6 +36,7 @@
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.ToStringUtils;
 
 /** A Query that matches documents containing a particular sequence of terms.
@@ -126,7 +127,7 @@
       throw new IllegalArgumentException("All phrase terms must be in the same field: " + term);
     }
 
-    terms.add(term);
+    terms.add(new Term(term.field(), BytesRef.deepCopyOf(term.bytes())));
     positions.add(Integer.valueOf(position));
   }
 
@@ -443,4 +444,11 @@
       ^ positions.hashCode();
   }
 
+  @Override
+  public Query clone() {
+    PhraseQuery clone = (PhraseQuery) super.clone();
+    clone.positions = new ArrayList<>(positions);
+    clone.terms = new ArrayList<>(terms);
+    return clone;
+  }
 }
Index: lucene/core/src/java/org/apache/lucene/search/QueryWrapperFilter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/QueryWrapperFilter.java	(revision 1668817)
+++ lucene/core/src/java/org/apache/lucene/search/QueryWrapperFilter.java	(working copy)
@@ -33,7 +33,7 @@
  * within the last week.  This would only need to be reconstructed once per day.
  */
 public class QueryWrapperFilter extends Filter {
-  private final Query query;
+  private Query query;
 
   /** Constructs a filter which only matches documents matching
    * <code>query</code>.
@@ -81,7 +81,7 @@
 
   @Override
   public boolean equals(Object o) {
-    if (!(o instanceof QueryWrapperFilter))
+    if (!super.equals(o))
       return false;
     return this.query.equals(((QueryWrapperFilter)o).query);
   }
@@ -88,6 +88,13 @@
 
   @Override
   public int hashCode() {
-    return query.hashCode() ^ 0x923F64B9;
+    return query.hashCode() ^ super.hashCode();
   }
+
+  @Override
+  public Query clone() {
+    QueryWrapperFilter clone = (QueryWrapperFilter) super.clone();
+    clone.query = query.clone();
+    return clone;
+  }
 }
Index: lucene/core/src/java/org/apache/lucene/search/TermQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/TermQuery.java	(revision 1668817)
+++ lucene/core/src/java/org/apache/lucene/search/TermQuery.java	(working copy)
@@ -32,6 +32,7 @@
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
 import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.ToStringUtils;
 
 /**
@@ -146,7 +147,7 @@
    * of looking up the docFreq against the searcher.
    */
   public TermQuery(Term t, int docFreq) {
-    term = t;
+    term = new Term(t.field(), BytesRef.deepCopyOf(t.bytes()));
     this.docFreq = docFreq;
     perReaderTermState = null;
   }
@@ -157,7 +158,7 @@
    */
   public TermQuery(Term t, TermContext states) {
     assert states != null;
-    term = t;
+    term = new Term(t.field(), BytesRef.deepCopyOf(t.bytes()));
     docFreq = states.docFreq();
     perReaderTermState = states;
   }
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(revision 1668817)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(working copy)
@@ -29,6 +29,7 @@
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.ToStringUtils;
 
 /** Matches spans containing a term. */
@@ -36,7 +37,9 @@
   protected Term term;
 
   /** Construct a SpanTermQuery matching the named term's spans. */
-  public SpanTermQuery(Term term) { this.term = term; }
+  public SpanTermQuery(Term term) {
+    this.term = new Term(term.field(), BytesRef.deepCopyOf(term.bytes()));
+  }
 
   /** Return the term whose spans are matched. */
   public Term getTerm() { return term; }
Index: lucene/core/src/test/org/apache/lucene/search/SingleDocTestFilter.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/SingleDocTestFilter.java	(revision 1668817)
+++ lucene/core/src/test/org/apache/lucene/search/SingleDocTestFilter.java	(working copy)
@@ -32,6 +32,20 @@
   }
 
   @Override
+  public boolean equals(Object o) {
+    if (!super.equals(o)) {
+      return false;
+    }
+    SingleDocTestFilter that = (SingleDocTestFilter) o;
+    return doc == that.doc;
+  }
+
+  @Override
+  public int hashCode() {
+    return 31 * super.hashCode() + doc;
+  }
+
+  @Override
   public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
     FixedBitSet bits = new FixedBitSet(context.reader().maxDoc());
     bits.set(doc);
Index: lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java	(revision 1668817)
+++ lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java	(working copy)
@@ -133,13 +133,34 @@
   // a filter for which other queries don't have special rewrite rules
   private static class FilterWrapper extends Filter {
 
-    private final Filter in;
+    private Filter in;
     
     FilterWrapper(Filter in) {
       this.in = in;
     }
-    
+
     @Override
+    public boolean equals(Object o) {
+      if (!super.equals(o)) {
+        return false;
+      }
+      FilterWrapper that = (FilterWrapper) o;
+      return in.equals(that.in);
+    }
+
+    @Override
+    public int hashCode() {
+      return 31 * super.hashCode() + in.hashCode();
+    }
+
+    @Override
+    public Query clone() {
+      FilterWrapper clone = (FilterWrapper) super.clone();
+      clone.in = (Filter) in.clone();
+      return clone;
+    }
+
+    @Override
     public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
       return in.getDocIdSet(context, acceptDocs);
     }
Index: lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery.java	(revision 1668817)
+++ lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery.java	(working copy)
@@ -305,7 +305,7 @@
   // a filter for which other queries don't have special rewrite rules
   private static class FilterWrapper extends Filter {
 
-    private final Filter in;
+    private Filter in;
     
     FilterWrapper(Filter in) {
       this.in = in;
@@ -312,6 +312,27 @@
     }
     
     @Override
+    public boolean equals(Object o) {
+      if (!super.equals(o)) {
+        return false;
+      }
+      FilterWrapper that = (FilterWrapper) o;
+      return in.equals(that.in);
+    }
+
+    @Override
+    public int hashCode() {
+      return 31 * super.hashCode() + in.hashCode();
+    }
+
+    @Override
+    public Query clone() {
+      FilterWrapper clone = (FilterWrapper) super.clone();
+      clone.in = (Filter) in.clone();
+      return clone;
+    }
+
+    @Override
     public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
       return in.getDocIdSet(context, acceptDocs);
     }
Index: lucene/core/src/test/org/apache/lucene/search/TestFilteredSearch.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestFilteredSearch.java	(revision 1668817)
+++ lucene/core/src/test/org/apache/lucene/search/TestFilteredSearch.java	(working copy)
@@ -18,6 +18,7 @@
 package org.apache.lucene.search;
 
 import java.io.IOException;
+import java.util.Arrays;
 
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.LeafReaderContext;
@@ -88,6 +89,20 @@
     }
 
     @Override
+    public boolean equals(Object o) {
+      if (!super.equals(o)) {
+        return false;
+      }
+      SimpleDocIdSetFilter that = (SimpleDocIdSetFilter) o;
+      return Arrays.equals(docs, that.docs);
+    }
+
+    @Override
+    public int hashCode() {
+      return 31 * super.hashCode() ^ Arrays.hashCode(docs);
+    }
+
+    @Override
     public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) {
       assertNull("acceptDocs should be null, as we have an index without deletions", acceptDocs);
       final FixedBitSet set = new FixedBitSet(context.reader().maxDoc());
Index: lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache.java	(revision 1668817)
+++ lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache.java	(working copy)
@@ -22,6 +22,7 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.ConcurrentModificationException;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
@@ -45,6 +46,7 @@
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.RamUsageTester;
 import org.apache.lucene.util.TestUtil;
@@ -913,4 +915,56 @@
     queryCache.assertConsistent();
   }
 
+  private static class BadQuery extends Query {
+
+    int[] i = new int[] {42}; // an array so that clone keeps the reference
+    
+    @Override
+    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+      return new ConstantScoreWeight(this) {
+        
+        @Override
+        Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {
+          return null;
+        }
+      };
+    }
+    
+    @Override
+    public String toString(String field) {
+      return "BadQuery";
+    }
+    
+    @Override
+    public int hashCode() {
+      return super.hashCode() ^ i[0];
+    }
+    
+  }
+
+  public void testDetectMutatedQueries() throws IOException {
+    Directory dir = newDirectory();
+    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);
+    w.addDocument(new Document());
+    IndexReader reader = w.getReader();
+
+    // size of 1 so that 2nd query evicts from the cache
+    final LRUQueryCache queryCache = new LRUQueryCache(1, 10000);
+    final IndexSearcher searcher = newSearcher(reader);
+    searcher.setQueryCache(queryCache);
+    searcher.setQueryCachingPolicy(QueryCachingPolicy.ALWAYS_CACHE);
+    
+    BadQuery query = new BadQuery();
+    searcher.count(query);
+    query.i[0] += 1; // change the hashCode!
+    try {
+      // trigger an eviction
+      searcher.count(new MatchAllDocsQuery());
+      fail();
+    } catch (ConcurrentModificationException e) {
+      // expected
+    }
+    
+    IOUtils.close(w, reader, dir);
+  }
 }
Index: lucene/core/src/test/org/apache/lucene/search/TestNeedsScores.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestNeedsScores.java	(revision 1668817)
+++ lucene/core/src/test/org/apache/lucene/search/TestNeedsScores.java	(working copy)
@@ -100,7 +100,7 @@
    * passed to Weight.scorer is the expected value.
    */
   static class AssertNeedsScores extends Query {
-    final Query in;
+    Query in;
     final boolean value;
     
     AssertNeedsScores(Query in, boolean value) {
@@ -136,6 +136,13 @@
     }
 
     @Override
+    public Query clone() {
+      AssertNeedsScores clone = (AssertNeedsScores) super.clone();
+      clone.in = in.clone();
+      return clone;
+    }
+
+    @Override
     public Query rewrite(IndexReader reader) throws IOException {
       Query in2 = in.rewrite(reader);
       if (in2 == in) {
Index: lucene/core/src/test/org/apache/lucene/search/TestQueryWrapperFilter.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestQueryWrapperFilter.java	(revision 1668817)
+++ lucene/core/src/test/org/apache/lucene/search/TestQueryWrapperFilter.java	(working copy)
@@ -39,7 +39,7 @@
   // a filter for which other queries don't have special rewrite rules
   private static class FilterWrapper extends Filter {
 
-    private final Filter in;
+    private Filter in;
     
     FilterWrapper(Filter in) {
       this.in = in;
@@ -46,6 +46,27 @@
     }
     
     @Override
+    public boolean equals(Object o) {
+      if (!super.equals(o)) {
+        return false;
+      }
+      FilterWrapper that = (FilterWrapper) o;
+      return in.equals(that.in);
+    }
+
+    @Override
+    public int hashCode() {
+      return 31 * super.hashCode() + in.hashCode();
+    }
+
+    @Override
+    public Query clone() {
+      FilterWrapper clone = (FilterWrapper) super.clone();
+      clone.in = (Filter) in.clone();
+      return clone;
+    }
+
+    @Override
     public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
       return in.getDocIdSet(context, acceptDocs);
     }
Index: lucene/core/src/test/org/apache/lucene/search/TestScorerPerf.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestScorerPerf.java	(revision 1668817)
+++ lucene/core/src/test/org/apache/lucene/search/TestScorerPerf.java	(working copy)
@@ -140,20 +140,44 @@
     }
   }
 
+  private static class RandomFilter extends Filter {
 
+    private final FixedBitSet set;
+
+    RandomFilter(FixedBitSet set) {
+      this.set = set;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (!super.equals(obj)) {
+        return false;
+      }
+      RandomFilter that = (RandomFilter) obj;
+      return set == that.set;
+    }
+
+    @Override
+    public int hashCode() {
+      return 31 * super.hashCode() + System.identityHashCode(set);
+    }
+
+    @Override
+    public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
+      assertNull(acceptDocs);
+      return new BitDocIdSet(set);
+    }
+
+    @Override
+    public String toString(String field) {
+      return "randomBitSetFilter";
+    }
+
+  }
+
   FixedBitSet addClause(BooleanQuery bq, FixedBitSet result) {
     final FixedBitSet rnd = sets[random().nextInt(sets.length)];
-    Query q = new ConstantScoreQuery(new Filter() {
-      @Override
-      public DocIdSet getDocIdSet (LeafReaderContext context, Bits acceptDocs) {
-        assertNull("acceptDocs should be null, as we have an index without deletions", acceptDocs);
-        return new BitDocIdSet(rnd);
-      }
-      @Override
-      public String toString(String field) {
-        return "randomBitSetFilter";
-      }
-    });
+    Query q = new ConstantScoreQuery(new RandomFilter(rnd));
     bq.add(q, BooleanClause.Occur.MUST);
     if (validate) {
       if (result==null) result = rnd.clone();
Index: lucene/core/src/test/org/apache/lucene/search/TestSortRandom.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestSortRandom.java	(revision 1668817)
+++ lucene/core/src/test/org/apache/lucene/search/TestSortRandom.java	(working copy)
@@ -23,6 +23,7 @@
 import java.util.Comparator;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Objects;
 import java.util.Random;
 import java.util.Set;
 
@@ -147,7 +148,7 @@
         sort = new Sort(sf, SortField.FIELD_DOC);
       }
       final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);
-      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);
+      final RandomFilter f = new RandomFilter(random.nextLong(), random.nextFloat(), docValues);
       int queryType = random.nextInt(2);
       if (queryType == 0) {
         // force out of order
@@ -232,14 +233,14 @@
   }
   
   private static class RandomFilter extends Filter {
-    private final Random random;
+    private final long seed;
     private float density;
     private final List<BytesRef> docValues;
     public final List<BytesRef> matchValues = Collections.synchronizedList(new ArrayList<BytesRef>());
 
     // density should be 0.0 ... 1.0
-    public RandomFilter(Random random, float density, List<BytesRef> docValues) {
-      this.random = random;
+    public RandomFilter(long seed, float density, List<BytesRef> docValues) {
+      this.seed = seed;
       this.density = density;
       this.docValues = docValues;
     }
@@ -246,14 +247,14 @@
 
     @Override
     public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
-      final int maxDoc = context.reader().maxDoc();
+      int maxDoc = context.reader().maxDoc();
       final NumericDocValues idSource = DocValues.getNumeric(context.reader(), "id");
       assertNotNull(idSource);
-      final FixedBitSet bits = new FixedBitSet(maxDoc);
+      FixedBitSet bits = new FixedBitSet(maxDoc);
+      Random random = new Random(seed ^ context.docBase);
       for(int docID=0;docID<maxDoc;docID++) {
         if (random.nextFloat() <= density && (acceptDocs == null || acceptDocs.get(docID))) {
           bits.set(docID);
-          //System.out.println("  acc id=" + idSource.getInt(docID) + " docID=" + docID);
           matchValues.add(docValues.get((int) idSource.get(docID)));
         }
       }
@@ -262,8 +263,22 @@
     }
 
     @Override
+    public boolean equals(Object o) {
+      if (!super.equals(o)) {
+        return false;
+      }
+      RandomFilter that = (RandomFilter) o;
+      return seed == that.seed && density == that.density && docValues.equals(that.docValues);
+    }
+
+    @Override
+    public int hashCode() {
+      return 31 * super.hashCode() + Objects.hash(seed, density, docValues);
+    }
+
+    @Override
     public String toString(String field) {
-      return "RandomFilter(density=" + density + ")";
+      return "RandomFilter(seed=" + seed + ",density=" + density + ")";
     }
   }
 }
Index: lucene/join/src/java/org/apache/lucene/search/join/BitDocIdSetCachingWrapperFilter.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/BitDocIdSetCachingWrapperFilter.java	(revision 1668817)
+++ lucene/join/src/java/org/apache/lucene/search/join/BitDocIdSetCachingWrapperFilter.java	(working copy)
@@ -87,7 +87,7 @@
 
   @Override
   public boolean equals(Object o) {
-    if (o == null || !getClass().equals(o.getClass())) return false;
+    if (!super.equals(o)) return false;
     final BitDocIdSetCachingWrapperFilter other = (BitDocIdSetCachingWrapperFilter) o;
     return this.filter.equals(other.filter);
   }
@@ -94,6 +94,6 @@
 
   @Override
   public int hashCode() {
-    return (filter.hashCode() ^ getClass().hashCode());
+    return (filter.hashCode() ^ super.hashCode());
   }
 }
Index: lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java	(revision 1668817)
+++ lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java	(working copy)
@@ -43,7 +43,7 @@
  * @lucene.experimental
  */
 
-public class ToChildBlockJoinQuery extends Query {
+public final class ToChildBlockJoinQuery extends Query {
 
   /** Message thrown from {@link
    *  ToChildBlockJoinScorer#validateParentDoc} on mis-use,
@@ -342,6 +342,7 @@
     if (_other instanceof ToChildBlockJoinQuery) {
       final ToChildBlockJoinQuery other = (ToChildBlockJoinQuery) _other;
       return origParentQuery.equals(other.origParentQuery) &&
+        parentQuery.equals(other.parentQuery) &&
         parentsFilter.equals(other.parentsFilter) &&
         super.equals(other);
     } else {
@@ -360,7 +361,10 @@
 
   @Override
   public ToChildBlockJoinQuery clone() {
-    return new ToChildBlockJoinQuery(origParentQuery.clone(),
+    ToChildBlockJoinQuery clone = new ToChildBlockJoinQuery(origParentQuery.clone(),
+                                     parentQuery.clone(),
                                      parentsFilter);
+    clone.setBoost(getBoost());
+    return clone;
   }
 }
Index: lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java	(revision 1668817)
+++ lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java	(working copy)
@@ -474,4 +474,11 @@
     hash = prime * hash + parentsFilter.hashCode();
     return hash;
   }
+
+  @Override
+  public Query clone() {
+    ToParentBlockJoinQuery clone = new ToParentBlockJoinQuery(origChildQuery.clone(), childQuery.clone(), parentsFilter, scoreMode);
+    clone.setBoost(getBoost());
+    return clone;
+  }
 }
Index: lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
===================================================================
--- lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java	(revision 1668817)
+++ lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java	(working copy)
@@ -423,6 +423,11 @@
     dir.close();
   }
 
+  public void testQueries() {
+    QueryUtils.check(new ToParentBlockJoinQuery(new MatchAllDocsQuery(), new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new MatchAllDocsQuery())), ScoreMode.Avg));
+    QueryUtils.check(new ToChildBlockJoinQuery(new MatchAllDocsQuery(), new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new MatchAllDocsQuery()))));
+  }
+
   public void testNestedDocScoringWithDeletes() throws Exception {
     final Directory dir = newDirectory();
     final RandomIndexWriter w = new RandomIndexWriter(
Index: lucene/misc/src/test/org/apache/lucene/index/TestBlockJoinSorter.java
===================================================================
--- lucene/misc/src/test/org/apache/lucene/index/TestBlockJoinSorter.java	(revision 1668817)
+++ lucene/misc/src/test/org/apache/lucene/index/TestBlockJoinSorter.java	(working copy)
@@ -65,6 +65,15 @@
     }
 
     @Override
+    public boolean equals(Object o) {
+      if (!super.equals(o)) {
+        return false;
+      }
+      BitSetCachingWrapperFilter other = (BitSetCachingWrapperFilter) o;
+      return filter.equals(other.filter);
+    }
+
+    @Override
     public DocIdSet getDocIdSet(LeafReaderContext context, final Bits acceptDocs) throws IOException {
       final LeafReader reader = context.reader();
       final Object key = reader.getCoreCacheKey();
Index: lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom.java
===================================================================
--- lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom.java	(revision 1668817)
+++ lucene/misc/src/test/org/apache/lucene/uninverting/TestFieldCacheSortRandom.java	(working copy)
@@ -25,6 +25,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Random;
 import java.util.Set;
 
@@ -163,7 +164,7 @@
         sort = new Sort(sf, SortField.FIELD_DOC);
       }
       final int hitCount = TestUtil.nextInt(random, 1, r.maxDoc() + 20);
-      final RandomFilter f = new RandomFilter(random, random.nextFloat(), docValues);
+      final RandomFilter f = new RandomFilter(random.nextLong(), random.nextFloat(), docValues);
       int queryType = random.nextInt(3);
       if (queryType == 0) {
         // force out of order
@@ -266,14 +267,14 @@
   }
   
   private static class RandomFilter extends Filter {
-    private final Random random;
+    private final long seed;
     private float density;
     private final List<BytesRef> docValues;
     public final List<BytesRef> matchValues = Collections.synchronizedList(new ArrayList<BytesRef>());
 
     // density should be 0.0 ... 1.0
-    public RandomFilter(Random random, float density, List<BytesRef> docValues) {
-      this.random = random;
+    public RandomFilter(long seed, float density, List<BytesRef> docValues) {
+      this.seed = seed;
       this.density = density;
       this.docValues = docValues;
     }
@@ -280,14 +281,14 @@
 
     @Override
     public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
-      final int maxDoc = context.reader().maxDoc();
+      int maxDoc = context.reader().maxDoc();
       final NumericDocValues idSource = DocValues.getNumeric(context.reader(), "id");
       assertNotNull(idSource);
-      final FixedBitSet bits = new FixedBitSet(maxDoc);
+      FixedBitSet bits = new FixedBitSet(maxDoc);
+      Random random = new Random(seed ^ context.docBase);
       for(int docID=0;docID<maxDoc;docID++) {
         if (random.nextFloat() <= density && (acceptDocs == null || acceptDocs.get(docID))) {
           bits.set(docID);
-          //System.out.println("  acc id=" + idSource.getInt(docID) + " docID=" + docID);
           matchValues.add(docValues.get((int) idSource.get(docID)));
         }
       }
@@ -296,8 +297,23 @@
     }
 
     @Override
+    public boolean equals(Object o) {
+      if (!super.equals(o)) {
+        return false;
+      }
+      RandomFilter that = (RandomFilter) o;
+      return seed == that.seed && density == that.density && docValues.equals(that.docValues);
+    }
+
+    @Override
+    public int hashCode() {
+      return 31 * super.hashCode() + Objects.hash(seed, density, docValues);
+    }
+
+    @Override
     public String toString(String field) {
-      return "RandomFilter(density=" + density + ")";
+      return "RandomFilter(seed=" + seed + ",density=" + density + ")";
     }
   }
+
 }
Index: lucene/queries/src/java/org/apache/lucene/queries/BoostingQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/BoostingQuery.java	(revision 1668817)
+++ lucene/queries/src/java/org/apache/lucene/queries/BoostingQuery.java	(working copy)
@@ -40,8 +40,8 @@
  */
 public class BoostingQuery extends Query {
     private final float boost;                            // the amount to boost by
-    private final Query match;                            // query to match
-    private final Query context;                          // boost when matches too
+    private Query match;                            // query to match
+    private Query context;                          // boost when matches too
 
     public BoostingQuery(Query match, Query context, float boost) {
       this.match = match;
@@ -135,4 +135,12 @@
     public String toString(String field) {
       return match.toString(field) + "/" + context.toString(field);
     }
-  }
+
+    @Override
+    public Query clone() {
+      BoostingQuery clone = (BoostingQuery) super.clone();
+      clone.match = match.clone();
+      clone.context = context.clone();
+      return clone;
+    }
+}
Index: lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery.java	(revision 1668817)
+++ lucene/queries/src/java/org/apache/lucene/queries/CommonTermsQuery.java	(working copy)
@@ -29,6 +29,7 @@
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.ToStringUtils;
 
 import java.io.IOException;
@@ -67,7 +68,7 @@
    * rewrite to dismax rather than boolean. Yet, this can already be subclassed
    * to do so.
    */
-  protected final List<Term> terms = new ArrayList<>();
+  protected List<Term> terms = new ArrayList<>();
   protected final boolean disableCoord;
   protected final float maxTermFrequency;
   protected final Occur lowFreqOccur;
@@ -141,7 +142,7 @@
     if (term == null) {
       throw new IllegalArgumentException("Term must not be null");
     }
-    this.terms.add(term);
+    this.terms.add(new Term(term.field(), BytesRef.deepCopyOf(term.bytes())));
   }
   
   @Override
@@ -418,4 +419,11 @@
   protected Query newTermQuery(Term term, TermContext context) {
     return context == null ? new TermQuery(term) : new TermQuery(term, context);
   }
+
+  @Override
+  public Query clone() {
+    CommonTermsQuery clone = (CommonTermsQuery) super.clone();
+    clone.terms = new ArrayList<>(terms);
+    return clone;
+  }
 }
Index: lucene/queries/src/java/org/apache/lucene/queries/function/BoostedQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/function/BoostedQuery.java	(revision 1668817)
+++ lucene/queries/src/java/org/apache/lucene/queries/function/BoostedQuery.java	(working copy)
@@ -196,4 +196,10 @@
     return h;
   }
 
+  @Override
+  public Query clone() {
+    BoostedQuery clone = (BoostedQuery) super.clone();
+    clone.q = q.clone();
+    return clone;
+  }
 }
Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java	(revision 1668817)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java	(working copy)
@@ -21,7 +21,7 @@
 import org.apache.lucene.search.Query;
 
 abstract class RewriteQuery<SQ extends SrndQuery> extends Query {
-  protected final SQ srndQuery;
+  protected SQ srndQuery;
   protected final String fieldName;
   protected final BasicQueryFactory qf;
 
@@ -73,7 +73,9 @@
    * @throws UnsupportedOperationException always: clone is not supported. */
   @Override
   public RewriteQuery clone() {
-    throw new UnsupportedOperationException();
+    RewriteQuery clone = (RewriteQuery) super.clone();
+    clone.srndQuery = srndQuery.clone();
+    return clone;
   }
 }
 
Index: lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/DuplicateFilter.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/DuplicateFilter.java	(revision 1668817)
+++ lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/DuplicateFilter.java	(working copy)
@@ -195,7 +195,7 @@
     if (this == obj) {
       return true;
     }
-    if ((obj == null) || (obj.getClass() != this.getClass())) {
+    if (!super.equals(obj)) {
       return false;
     }
 
@@ -216,7 +216,7 @@
 
   @Override
   public int hashCode() {
-    int hash = 217;
+    int hash = super.hashCode();
     hash = 31 * hash + keepMode.hashCode();
     hash = 31 * hash + processingMode.hashCode();
     hash = 31 * hash + fieldName.hashCode();
Index: lucene/sandbox/src/test/org/apache/lucene/search/TestTermAutomatonQuery.java
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/search/TestTermAutomatonQuery.java	(revision 1668817)
+++ lucene/sandbox/src/test/org/apache/lucene/search/TestTermAutomatonQuery.java	(working copy)
@@ -23,6 +23,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
+import java.util.Objects;
 import java.util.Random;
 import java.util.Set;
 
@@ -648,6 +649,20 @@
     }
 
     @Override
+    public boolean equals(Object o) {
+      if (!super.equals(o)) {
+        return false;
+      }
+      RandomFilter that = (RandomFilter) o;
+      return seed == that.seed && density == that.density;
+    }
+
+    @Override
+    public int hashCode() {
+      return 31 * super.hashCode() + Objects.hash(seed, density);
+    }
+
+    @Override
     public String toString(String field) {
       return "RandomFilter(seed=" + seed + ",density=" + density + ")";
     }
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractPrefixTreeFilter.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractPrefixTreeFilter.java	(revision 1668817)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractPrefixTreeFilter.java	(working copy)
@@ -51,7 +51,7 @@
   @Override
   public boolean equals(Object o) {
     if (this == o) return true;
-    if (!getClass().equals(o.getClass())) return false;
+    if (!super.equals(o)) return false;
 
     AbstractPrefixTreeFilter that = (AbstractPrefixTreeFilter) o;
 
@@ -64,7 +64,8 @@
 
   @Override
   public int hashCode() {
-    int result = queryShape.hashCode();
+    int result = super.hashCode();
+    result = 31 * result + queryShape.hashCode();
     result = 31 * result + fieldName.hashCode();
     result = 31 * result + detailLevel;
     return result;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/serialized/SerializedDVStrategy.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/serialized/SerializedDVStrategy.java	(revision 1668817)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/serialized/SerializedDVStrategy.java	(working copy)
@@ -183,7 +183,7 @@
     @Override
     public boolean equals(Object o) {
       if (this == o) return true;
-      if (o == null || getClass() != o.getClass()) return false;
+      if (!super.equals(o)) return false;
 
       PredicateValueSourceFilter that = (PredicateValueSourceFilter) o;
 
@@ -194,7 +194,7 @@
 
     @Override
     public int hashCode() {
-      return predicateValueSource.hashCode();
+      return 31 * super.hashCode() + predicateValueSource.hashCode();
     }
     
     @Override
Index: lucene/spatial/src/java/org/apache/lucene/spatial/util/ValueSourceFilter.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/util/ValueSourceFilter.java	(revision 1668817)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/util/ValueSourceFilter.java	(working copy)
@@ -23,9 +23,11 @@
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.Filter;
 import org.apache.lucene.search.FilteredDocIdSet;
+import org.apache.lucene.search.Query;
 import org.apache.lucene.util.Bits;
 
 import java.io.IOException;
+import java.util.Objects;
 
 /**
  * Filter that matches all documents where a ValueSource is
@@ -35,7 +37,7 @@
 public class ValueSourceFilter extends Filter {
   //TODO see https://issues.apache.org/jira/browse/LUCENE-4251  (move out of spatial & improve)
 
-  final Filter startingFilter;
+  Filter startingFilter;
   final ValueSource source;
   final double min;
   final double max;
@@ -52,6 +54,27 @@
   }
 
   @Override
+  public boolean equals(Object o) {
+    if (!super.equals(o)) {
+      return false;
+    }
+    ValueSourceFilter that = (ValueSourceFilter) o;
+    return startingFilter.equals(that.startingFilter) && source.equals(that.source) && min == that.min && max == that.max;
+  }
+
+  @Override
+  public int hashCode() {
+    return 31 * Objects.hash(startingFilter, source, min, max) + super.hashCode();
+  }
+
+  @Override
+  public Query clone() {
+    ValueSourceFilter clone = (ValueSourceFilter) super.clone();
+    clone.startingFilter = (Filter) startingFilter.clone();
+    return clone;
+  }
+
+  @Override
   public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
     final FunctionValues values = source.getValues( null, context );
     return new FilteredDocIdSet(startingFilter.getDocIdSet(context, acceptDocs)) {
Index: lucene/test-framework/src/java/org/apache/lucene/search/AssertingIndexSearcher.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/AssertingIndexSearcher.java	(revision 1668817)
+++ lucene/test-framework/src/java/org/apache/lucene/search/AssertingIndexSearcher.java	(working copy)
@@ -88,6 +88,12 @@
   }
 
   @Override
+  public Weight createWeight(Query query, boolean needsScores) throws IOException {
+    QueryUtils.check(query);
+    return super.createWeight(query, needsScores);
+  }
+
+  @Override
   public Query rewrite(Query original) throws IOException {
     // TODO: use the more sophisticated QueryUtils.check sometimes!
     QueryUtils.check(original);
Index: lucene/test-framework/src/java/org/apache/lucene/search/AssertingQuery.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/AssertingQuery.java	(revision 1668817)
+++ lucene/test-framework/src/java/org/apache/lucene/search/AssertingQuery.java	(working copy)
@@ -25,7 +25,7 @@
 import org.apache.lucene.index.Term;
 
 /** Assertion-enabled query. */
-public class AssertingQuery extends Query {
+public final class AssertingQuery extends Query {
 
   private final Random random;
   private final Query in;
Index: lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java	(revision 1668817)
+++ lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java	(working copy)
@@ -439,6 +439,12 @@
       final BulkScorer bulkScorer = weight.bulkScorer(context, context.reader().getLiveDocs());
       if (scorer == null && bulkScorer == null) {
         continue;
+      } else if (scorer == null) {
+        Assert.assertEquals(DocIdSetIterator.NO_MORE_DOCS, bulkScorer.score(new TotalHitCountCollector().getLeafCollector(context), 0, 0));
+        continue;
+      } else if (bulkScorer == null) {
+        Assert.assertEquals(DocIdSetIterator.NO_MORE_DOCS, scorer.nextDoc());
+        continue;
       }
       int upTo = 0;
       while (true) {
Index: lucene/test-framework/src/java/org/apache/lucene/search/RandomApproximationQuery.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/RandomApproximationQuery.java	(revision 1668817)
+++ lucene/test-framework/src/java/org/apache/lucene/search/RandomApproximationQuery.java	(working copy)
@@ -4,6 +4,7 @@
 import java.util.Random;
 
 import com.carrotsearch.randomizedtesting.generators.RandomInts;
+
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.util.Bits;
@@ -28,7 +29,7 @@
 /**
  * A {@link Query} that adds random approximations to its scorers.
  */
-public class RandomApproximationQuery extends Query {
+public final class RandomApproximationQuery extends Query {
 
   private final Query query;
   private final Random random;
@@ -68,6 +69,13 @@
   }
 
   @Override
+  public Query clone() {
+    RandomApproximationQuery clone = new RandomApproximationQuery(query, new Random(random.nextLong()));
+    clone.setBoost(getBoost());
+    return clone;
+  }
+
+  @Override
   public String toString(String field) {
     return query.toString(field);
   }
Index: lucene/test-framework/src/java/org/apache/lucene/search/SearchEquivalenceTestBase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/SearchEquivalenceTestBase.java	(revision 1668817)
+++ lucene/test-framework/src/java/org/apache/lucene/search/SearchEquivalenceTestBase.java	(working copy)
@@ -19,6 +19,7 @@
 
 import java.io.IOException;
 import java.util.BitSet;
+import java.util.Objects;
 import java.util.Random;
 
 import org.apache.lucene.analysis.Analyzer;
@@ -184,6 +185,27 @@
     }
 
     @Override
+    public Query clone() {
+      SlowWrapperFilter clone = new SlowWrapperFilter(query.clone(), useBits);
+      clone.setBoost(getBoost());
+      return clone;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (!super.equals(obj)) {
+        return false;
+      }
+      SlowWrapperFilter that = (SlowWrapperFilter) obj;
+      return query.equals(that.query) && useBits == that.useBits;
+    }
+
+    @Override
+    public int hashCode() {
+      return 31 * super.hashCode() + Objects.hash(query, useBits, getBoost());
+    }
+
+    @Override
     public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
       // get a private context that is used to rewrite, createWeight and score eventually
       final LeafReaderContext privateContext = context.reader().getContext();
Index: lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(revision 1668817)
+++ lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(working copy)
@@ -96,6 +96,7 @@
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.LRUQueryCache;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.QueryCache;
 import org.apache.lucene.search.QueryCachingPolicy;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.QueryUtils.FCInvisibleMultiReader;
@@ -1660,7 +1661,15 @@
   public static void resetDefaultQueryCache() {
     // we need to reset the query cache in an @BeforeClass so that tests that
     // instantiate an IndexSearcher in an @BeforeClass method use a fresh new cache
-    IndexSearcher.setDefaultQueryCache(new LRUQueryCache(10000, 1 << 25));
+    final QueryCache queryCache;
+    if (rarely()) {
+      queryCache = null;
+    } else {
+      final int maxSize = TestUtil.nextInt(random(), 1, 10);
+      final long maxRamBytesUsed = TestUtil.nextLong(random(), 1, 100000);
+      queryCache = new LRUQueryCache(maxSize, maxRamBytesUsed);
+    }
+    IndexSearcher.setDefaultQueryCache(queryCache);
     IndexSearcher.setDefaultQueryCachingPolicy(MAYBE_CACHE_POLICY);
   }
 
Index: solr/core/src/java/org/apache/solr/search/HashQParserPlugin.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/HashQParserPlugin.java	(revision 1668817)
+++ solr/core/src/java/org/apache/solr/search/HashQParserPlugin.java	(working copy)
@@ -19,6 +19,7 @@
 
 import java.io.IOException;
 import java.io.Serializable;
+import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.ArrayBlockingQueue;
 import java.util.concurrent.Callable;
@@ -26,6 +27,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.Future;
+
 import com.google.common.primitives.Longs;
 
 import org.apache.lucene.index.LeafReader;
@@ -36,7 +38,6 @@
 import org.apache.lucene.util.CharsRef;
 import org.apache.lucene.util.CharsRefBuilder;
 import org.apache.lucene.util.FixedBitSet;
-
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.search.BitsFilteredDocIdSet;
 import org.apache.solr.common.params.SolrParams;
@@ -48,7 +49,6 @@
 import org.apache.solr.schema.StrField;
 import org.apache.solr.schema.TrieField;
 import org.apache.solr.core.SolrCore;
-
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.ConstantScoreQuery;
 import org.apache.lucene.search.IndexSearcher;
@@ -59,7 +59,6 @@
 import org.apache.lucene.index.SortedDocValues;
 import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.util.BytesRef;
-
 import org.apache.solr.common.util.NamedList;
 
 /**
@@ -164,6 +163,21 @@
       public DocIdSet getDocIdSet(LeafReaderContext context, Bits bits) {
         return BitsFilteredDocIdSet.wrap(new BitDocIdSet(bitSets[context.ord]), bits);
       }
+
+      @Override
+      public boolean equals(Object o) {
+        if (!super.equals(o)) {
+          return false;
+        }
+        BitsFilter other = (BitsFilter) o;
+        return Arrays.equals(bitSets, other.bitSets);
+      }
+
+      @Override
+      public int hashCode() {
+        return 31 * super.hashCode() +  Arrays.hashCode(bitSets);
+      }
+
     }
 
 
Index: solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java	(revision 1668817)
+++ solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java	(working copy)
@@ -2460,6 +2460,23 @@
   }
 
   @Override
+  public boolean equals(Object o) {
+    if (!super.equals(o)) {
+      return false;
+    }
+    FilterImpl that = (FilterImpl) o;
+    return filter == that.filter && topFilter == that.topFilter && that.weights == weights;
+  }
+
+  @Override
+  public int hashCode() {
+    int hash = System.identityHashCode(filter);
+    hash = 31 * hash + System.identityHashCode(topFilter);
+    hash = 31 * hash + System.identityHashCode(weights);
+    return hash;
+  }
+
+  @Override
   public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
     DocIdSet sub = topFilter == null ? null : topFilter.getDocIdSet(context, acceptDocs);
     if (weights.size() == 0) return sub;
Index: solr/core/src/java/org/apache/solr/search/function/ValueSourceRangeFilter.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/function/ValueSourceRangeFilter.java	(revision 1668817)
+++ solr/core/src/java/org/apache/solr/search/function/ValueSourceRangeFilter.java	(working copy)
@@ -114,7 +114,7 @@
   @Override
   public boolean equals(Object o) {
     if (this == o) return true;
-    if (!(o instanceof ValueSourceRangeFilter)) return false;
+    if (!super.equals(o)) return false;
     ValueSourceRangeFilter other = (ValueSourceRangeFilter)o;
 
     if (!this.valueSource.equals(other.valueSource)
@@ -128,7 +128,8 @@
 
   @Override
   public int hashCode() {
-    int h = valueSource.hashCode();
+    int h = super.hashCode();
+    h = 31 * h + valueSource.hashCode();
     h += lowerVal != null ? lowerVal.hashCode() : 0x572353db;
     h = (h << 16) | (h >>> 16);  // rotate to distinguish lower from upper
     h += (upperVal != null ? (upperVal.hashCode()) : 0xe16fe9e7);
Index: solr/core/src/java/org/apache/solr/update/DeleteByQueryWrapper.java
===================================================================
--- solr/core/src/java/org/apache/solr/update/DeleteByQueryWrapper.java	(revision 1668817)
+++ solr/core/src/java/org/apache/solr/update/DeleteByQueryWrapper.java	(working copy)
@@ -39,7 +39,7 @@
  * cache key is the inner one, so it still reuses fieldcaches and so on.
  */
 final class DeleteByQueryWrapper extends Query {
-  final Query in;
+  Query in;
   final IndexSchema schema;
   
   DeleteByQueryWrapper(Query in, IndexSchema schema) {
@@ -100,6 +100,13 @@
   }
 
   @Override
+  public Query clone() {
+    DeleteByQueryWrapper clone = (DeleteByQueryWrapper) super.clone();
+    clone.in = in.clone();
+    return clone;
+  }
+
+  @Override
   public boolean equals(Object obj) {
     if (this == obj) return true;
     if (!super.equals(obj)) return false;
