commit be42ef88a45a680d5b378e55951c50cdf188c008
Author: Simon Willnauer <simonw@apache.org>
Date:   Tue Jun 21 12:50:10 2016 +0200

    LUCENE-7349: Close channel if Channel#size() throws and exception

diff --git a/lucene/core/src/java/org/apache/lucene/store/NIOFSDirectory.java b/lucene/core/src/java/org/apache/lucene/store/NIOFSDirectory.java
index 27a90e8..5df29f2 100644
--- a/lucene/core/src/java/org/apache/lucene/store/NIOFSDirectory.java
+++ b/lucene/core/src/java/org/apache/lucene/store/NIOFSDirectory.java
@@ -25,6 +25,8 @@ import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
 import java.util.concurrent.Future; // javadoc
 
+import org.apache.lucene.util.IOUtils;
+
 /**
  * An {@link FSDirectory} implementation that uses java.nio's FileChannel's
  * positional read, which allows multiple threads to read from the same file
@@ -78,8 +80,18 @@ public class NIOFSDirectory extends FSDirectory {
     ensureOpen();
     ensureCanRead(name);
     Path path = getDirectory().resolve(name);
-    FileChannel fc = FileChannel.open(path, StandardOpenOption.READ);
-    return new NIOFSIndexInput("NIOFSIndexInput(path=\"" + path + "\")", fc, context);
+    final FileChannel fc = FileChannel.open(path, StandardOpenOption.READ);
+    boolean success = false;
+    try {
+      // the ctor may throw an IOException so we need to close the channel if that happens
+      NIOFSIndexInput input = new NIOFSIndexInput("NIOFSIndexInput(path=\"" + path + "\")", fc, context);
+      success = true;
+      return input;
+    } finally {
+        if (success == false) {
+          IOUtils.closeWhileHandlingException(fc);
+        }
+    }
   }
   
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/store/SimpleFSDirectory.java b/lucene/core/src/java/org/apache/lucene/store/SimpleFSDirectory.java
index 0d650ae..68c79d6 100644
--- a/lucene/core/src/java/org/apache/lucene/store/SimpleFSDirectory.java
+++ b/lucene/core/src/java/org/apache/lucene/store/SimpleFSDirectory.java
@@ -27,6 +27,8 @@ import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
 import java.util.concurrent.Future;
 
+import org.apache.lucene.util.IOUtils;
+
 /** A straightforward implementation of {@link FSDirectory}
  *  using {@link Files#newByteChannel(Path, java.nio.file.OpenOption...)}.  
  *  However, this class has
@@ -74,8 +76,18 @@ public class SimpleFSDirectory extends FSDirectory {
     ensureOpen();
     ensureCanRead(name);
     Path path = directory.resolve(name);
-    SeekableByteChannel channel = Files.newByteChannel(path, StandardOpenOption.READ);
-    return new SimpleFSIndexInput("SimpleFSIndexInput(path=\"" + path + "\")", channel, context);
+    final SeekableByteChannel channel = Files.newByteChannel(path, StandardOpenOption.READ);
+    boolean success = false;
+    try {
+      // the ctor may throw an IOException so we need to close the channel if that happens
+      SimpleFSIndexInput input = new SimpleFSIndexInput("SimpleFSIndexInput(path=\"" + path + "\")", channel, context);
+      success = true;
+      return input;
+    } finally {
+      if (success == false) {
+        IOUtils.closeWhileHandlingException(channel);
+      }
+    }
   }
 
   /**
diff --git a/lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase.java
index e5af03b..cff2851 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase.java
@@ -30,6 +30,7 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.CountDownLatch;
 import java.util.zip.CRC32;
 
 import org.apache.lucene.index.DirectoryReader;
@@ -74,6 +75,43 @@ public abstract class BaseDirectoryTestCase extends LuceneTestCase {
     
     IOUtils.close(source, dest);
   }
+
+  public void testInterruptWhileOpen() throws IOException, InterruptedException {
+    // this test is only testing that we don't leak any files if we get interrupted.
+    // it is still documented NOT to do this but if users do it anyway we should at least
+    // not leak any file handles
+    Directory directory = getDirectory(createTempDir("testCopy"));
+    IndexOutput output = directory.createOutput("foobar", newIOContext(random()));
+    int numBytes = random().nextInt(2000);
+    final byte bytes[] = new byte[numBytes];
+    random().nextBytes(bytes);
+    output.writeBytes(bytes, bytes.length);
+    output.close();
+    CountDownLatch latch = new CountDownLatch(1);
+    CountDownLatch latch1 = new CountDownLatch(1);
+    Thread thread = new Thread() {
+      @Override
+      public void run() {
+        try {
+          latch1.countDown();
+          latch.await();
+        } catch (InterruptedException e) {
+          Thread.interrupted();
+        }
+        try (IndexInput input = directory.openInput("foobar", newIOContext(random()))) {
+          byte[] buffer = new byte[numBytes];
+          input.readBytes(buffer, 0, numBytes);
+          assertArrayEquals(buffer, bytes);
+        } catch (IOException e) {
+        }
+      }
+    };
+    thread.start();
+    latch1.await();
+    latch.countDown();
+    thread.interrupt();
+    thread.join();
+  }
   
   public void testCopyFromDestination() throws Exception {
     Directory source = newDirectory();
