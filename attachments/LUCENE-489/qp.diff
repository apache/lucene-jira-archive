Index: /home/dnaber/workspace2/LuceneOrig2/src/java/org/apache/lucene/queryParser/QueryParser.java
===================================================================
--- /home/dnaber/workspace2/LuceneOrig2/src/java/org/apache/lucene/queryParser/QueryParser.java	(revision 387802)
+++ /home/dnaber/workspace2/LuceneOrig2/src/java/org/apache/lucene/queryParser/QueryParser.java	(working copy)
@@ -1,33 +1,16 @@
 /* Generated By:JavaCC: Do not edit this line. QueryParser.java */
 package org.apache.lucene.queryParser;
 
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.document.DateField;
-import org.apache.lucene.document.DateTools;
+import java.util.Vector;
+import java.io.*;
+import java.text.*;
+import java.util.*;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.FuzzyQuery;
-import org.apache.lucene.search.MultiPhraseQuery;
-import org.apache.lucene.search.PhraseQuery;
-import org.apache.lucene.search.PrefixQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeQuery;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.WildcardQuery;
+import org.apache.lucene.analysis.*;
+import org.apache.lucene.document.*;
+import org.apache.lucene.search.*;
 import org.apache.lucene.util.Parameter;
 
-import java.io.IOException;
-import java.io.StringReader;
-import java.text.DateFormat;
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.List;
-import java.util.Locale;
-import java.util.Vector;
-
 /**
  * This class is generated by JavaCC.  The most important method is
  * {@link #parse(String)}.
@@ -88,6 +71,11 @@
   private static final int MOD_NOT     = 10;
   private static final int MOD_REQ     = 11;
 
+  /** @deprecated use {@link #OR_OPERATOR} instead */
+  public static final int DEFAULT_OPERATOR_OR  = 0;
+  /** @deprecated use {@link #AND_OPERATOR} instead */
+  public static final int DEFAULT_OPERATOR_AND = 1;
+
   // make it possible to call setDefaultOperator() without accessing 
   // the nested class:
   /** Alternative form of QueryParser.Operator.AND */
@@ -99,6 +87,7 @@
   private Operator operator = OR_OPERATOR;
 
   boolean lowercaseExpandedTerms = true;
+  boolean allowZeroLengthPrefixQuery = false;
 
   Analyzer analyzer;
   String field;
@@ -118,6 +107,20 @@
     static public final Operator AND = new Operator("AND");
   }
 
+  /** Parses a query string, returning a {@link org.apache.lucene.search.Query}.
+   *  @param query  the query string to be parsed.
+   *  @param field  the default field for query terms.
+   *  @param analyzer   used to find terms in the query text.
+   *  @throws ParseException if the parsing fails
+   *
+   *  @deprecated Use an instance of QueryParser and the {@link #parse(String)} method instead.
+   */
+  static public Query parse(String query, String field, Analyzer analyzer)
+       throws ParseException {
+    QueryParser parser = new QueryParser(field, analyzer);
+    return parser.parse(query);
+  }
+
   /** Constructs a query parser.
    *  @param f  the default field for query terms.
    *  @param a   used to find terms in the query text.
@@ -206,6 +209,40 @@
   }
 
   /**
+   * Set to <code>true</code> to allow <code>*</code> and <code>?</code> as the first character 
+   * of a PrefixQuery and WildcardQuery. Note that this can produce very slow
+   * queries on big indexes. Default: false.
+   */
+  public void setAllowZeroLengthPrefixQuery(boolean allowZeroLengthPrefixQuery) {
+    this.allowZeroLengthPrefixQuery = allowZeroLengthPrefixQuery;
+  }
+
+  /**
+   * @see #setAllowZeroLengthPrefixQuery
+   */
+  public boolean getAllowZeroLengthPrefixQuery() {
+    return allowZeroLengthPrefixQuery;
+  }
+
+  /**
+   * Sets the boolean operator of the QueryParser.
+   * In default mode (<code>DEFAULT_OPERATOR_OR</code>) terms without any modifiers
+   * are considered optional: for example <code>capital of Hungary</code> is equal to
+   * <code>capital OR of OR Hungary</code>.<br/>
+   * In <code>DEFAULT_OPERATOR_AND</code> terms are considered to be in conjuction: the
+   * above mentioned query is parsed as <code>capital AND of AND Hungary</code>
+   * @deprecated use {@link #setDefaultOperator(QueryParser.Operator)} instead
+   */
+  public void setOperator(int op) {
+    if (op == DEFAULT_OPERATOR_AND)
+      this.operator = AND_OPERATOR;
+    else if (op == DEFAULT_OPERATOR_OR)
+      this.operator = OR_OPERATOR;
+    else
+      throw new IllegalArgumentException("Unknown operator " + op);
+  }
+
+  /**
    * Sets the boolean operator of the QueryParser.
    * In default mode (<code>OR_OPERATOR</code>) terms without any modifiers
    * are considered optional: for example <code>capital of Hungary</code> is equal to
@@ -217,6 +254,19 @@
     this.operator = op;
   }
 
+  /**
+   * Gets implicit operator setting, which will be either DEFAULT_OPERATOR_AND
+   * or DEFAULT_OPERATOR_OR.
+   * @deprecated use {@link #getDefaultOperator()} instead
+   */
+  public int getOperator() {
+    if(operator == AND_OPERATOR)
+      return DEFAULT_OPERATOR_AND;
+    else if(operator == OR_OPERATOR)
+      return DEFAULT_OPERATOR_OR;
+    else
+      throw new IllegalStateException("Unknown operator " + operator);
+  }
 
   /**
    * Gets implicit operator setting, which will be either AND_OPERATOR
@@ -226,6 +276,14 @@
     return operator;
   }
 
+  /**
+   * Whether terms of wildcard, prefix, fuzzy and range queries are to be automatically
+   * lower-cased or not.  Default is <code>true</code>.
+   * @deprecated use {@link #setLowercaseExpandedTerms(boolean)} instead
+   */
+  public void setLowercaseWildcardTerms(boolean lowercaseExpandedTerms) {
+    this.lowercaseExpandedTerms = lowercaseExpandedTerms;
+  }
 
   /**
    * Whether terms of wildcard, prefix, fuzzy and range queries are to be automatically
@@ -236,6 +294,13 @@
   }
 
   /**
+   * @deprecated use {@link #getLowercaseExpandedTerms()} instead
+   */
+  public boolean getLowercaseWildcardTerms() {
+    return lowercaseExpandedTerms;
+  }
+
+  /**
    * @see #setLowercaseExpandedTerms(boolean)
    */
   public boolean getLowercaseExpandedTerms() {
@@ -306,6 +371,18 @@
       throw new RuntimeException("Clause cannot be both required and prohibited");
   }
 
+  /**
+   * Note that parameter analyzer is ignored. Calls inside the parser always
+   * use class member analyzer.
+   *
+   * @exception ParseException throw in overridden method to disallow
+   * @deprecated use {@link #getFieldQuery(String, String)}
+   */
+  protected Query getFieldQuery(String field,
+                                                    Analyzer analyzer,
+                                                    String queryText)  throws ParseException {
+    return getFieldQuery(field, queryText);
+  }
 
   /**
    * @exception ParseException throw in overridden method to disallow
@@ -391,6 +468,20 @@
   }
 
   /**
+   * Note that parameter analyzer is ignored. Calls inside the parser always
+   * use class member analyzer.
+   *
+   * @exception ParseException throw in overridden method to disallow
+   * @deprecated use {@link #getFieldQuery(String, String, int)}
+   */
+  protected Query getFieldQuery(String field,
+                                                    Analyzer analyzer,
+                                                    String queryText,
+                                                    int slop) throws ParseException {
+    return getFieldQuery(field, queryText, slop);
+  }
+
+  /**
    * Base implementation delegates to {@link #getFieldQuery(String,String)}.
    * This method may be overridden, for example, to return
    * a SpanNearQuery instead of a PhraseQuery.
@@ -411,6 +502,20 @@
     return query;
   }
 
+  /**
+   * Note that parameter analyzer is ignored. Calls inside the parser always
+   * use class member analyzer.
+   *
+   * @exception ParseException throw in overridden method to disallow
+   * @deprecated use {@link #getRangeQuery(String, String, String, boolean)}
+   */
+  protected Query getRangeQuery(String field,
+      Analyzer analyzer,
+      String part1,
+      String part2,
+      boolean inclusive) throws ParseException {
+    return getRangeQuery(field, part1, part2, inclusive);
+  }
 
   /**
    * @exception ParseException throw in overridden method to disallow
@@ -515,6 +620,8 @@
    */
   protected Query getWildcardQuery(String field, String termStr) throws ParseException
   {
+    if (!allowZeroLengthPrefixQuery && (termStr.startsWith("*") || termStr.startsWith("?")))
+      throw new ParseException("'*' or '?' not allowed as first character in WildcardQuery");
     if (lowercaseExpandedTerms) {
       termStr = termStr.toLowerCase();
     }
@@ -547,6 +654,8 @@
    */
   protected Query getPrefixQuery(String field, String termStr) throws ParseException
   {
+    if (!allowZeroLengthPrefixQuery && termStr.startsWith("*"))
+      throw new ParseException("'*' not allowed as first character in PrefixQuery");
     if (lowercaseExpandedTerms) {
       termStr = termStr.toLowerCase();
     }
@@ -554,6 +663,12 @@
     return new PrefixQuery(t);
   }
 
+ /**
+   * @deprecated use {@link #getFuzzyQuery(String, String, float)}
+   */
+  protected Query getFuzzyQuery(String field, String termStr) throws ParseException {
+    return getFuzzyQuery(field, termStr, fuzzyMinSim);
+  }
 
    /**
    * Factory method for generating a query (similar to
@@ -858,11 +973,11 @@
            {if (true) throw new ParseException("Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !");}
          }
          if(fms == fuzzyMinSim)
-           q = getFuzzyQuery(field, termImage, fuzzyMinSim);
+           q = getFuzzyQuery(field, termImage);
          else
            q = getFuzzyQuery(field, termImage, fms);
        } else {
-         q = getFieldQuery(field, termImage);
+         q = getFieldQuery(field, analyzer, termImage);
        }
       break;
     case RANGEIN_START:
@@ -919,7 +1034,7 @@
       } else {
         goop2.image = discardEscapeChar(goop2.image);
       }
-          q = getRangeQuery(field, goop1.image, goop2.image, true);
+          q = getRangeQuery(field, analyzer, goop1.image, goop2.image, true);
       break;
     case RANGEEX_START:
       jj_consume_token(RANGEEX_START);
@@ -976,7 +1091,7 @@
         goop2.image = discardEscapeChar(goop2.image);
       }
 
-          q = getRangeQuery(field, goop1.image, goop2.image, false);
+          q = getRangeQuery(field, analyzer, goop1.image, goop2.image, false);
       break;
     case QUOTED:
       term = jj_consume_token(QUOTED);
@@ -1005,7 +1120,7 @@
            }
            catch (Exception ignored) { }
          }
-         q = getFieldQuery(field, term.image.substring(1, term.image.length()-1), s);
+         q = getFieldQuery(field, analyzer, term.image.substring(1, term.image.length()-1), s);
       break;
     default:
       jj_la1[21] = jj_gen;
Index: /home/dnaber/workspace2/LuceneOrig2/src/java/org/apache/lucene/queryParser/QueryParser.jj
===================================================================
--- /home/dnaber/workspace2/LuceneOrig2/src/java/org/apache/lucene/queryParser/QueryParser.jj	(revision 387802)
+++ /home/dnaber/workspace2/LuceneOrig2/src/java/org/apache/lucene/queryParser/QueryParser.jj	(working copy)
@@ -110,6 +110,7 @@
   private Operator operator = OR_OPERATOR;
 
   boolean lowercaseExpandedTerms = true;
+  boolean allowZeroLengthPrefixQuery = false;
 
   Analyzer analyzer;
   String field;
@@ -231,6 +232,22 @@
   }
 
   /**
+   * Set to <code>true</code> to allow <code>*</code> and <code>?</code> as the first character 
+   * of a PrefixQuery and WildcardQuery. Note that this can produce very slow
+   * queries on big indexes. Default: false.
+   */
+  public void setAllowZeroLengthPrefixQuery(boolean allowZeroLengthPrefixQuery) {
+    this.allowZeroLengthPrefixQuery = allowZeroLengthPrefixQuery;
+  }
+
+  /**
+   * @see #setAllowZeroLengthPrefixQuery
+   */
+  public boolean getAllowZeroLengthPrefixQuery() {
+    return allowZeroLengthPrefixQuery;
+  }
+
+  /**
    * Sets the boolean operator of the QueryParser.
    * In default mode (<code>DEFAULT_OPERATOR_OR</code>) terms without any modifiers
    * are considered optional: for example <code>capital of Hungary</code> is equal to
@@ -626,6 +643,8 @@
    */
   protected Query getWildcardQuery(String field, String termStr) throws ParseException
   {
+    if (!allowZeroLengthPrefixQuery && (termStr.startsWith("*") || termStr.startsWith("?")))
+      throw new ParseException("'*' or '?' not allowed as first character in WildcardQuery");
     if (lowercaseExpandedTerms) {
       termStr = termStr.toLowerCase();
     }
@@ -658,6 +677,8 @@
    */
   protected Query getPrefixQuery(String field, String termStr) throws ParseException
   {
+    if (!allowZeroLengthPrefixQuery && termStr.startsWith("*"))
+      throw new ParseException("'*' not allowed as first character in PrefixQuery");
     if (lowercaseExpandedTerms) {
       termStr = termStr.toLowerCase();
     }
@@ -766,16 +787,6 @@
   < <_WHITESPACE>>
 }
 
-// OG: to support prefix queries:
-// http://issues.apache.org/bugzilla/show_bug.cgi?id=12137
-// Change from:
-//
-// | <WILDTERM:  <_TERM_START_CHAR>
-//              (<_TERM_CHAR> | ( [ "*", "?" ] ))* >
-// To:
-//
-// (<_TERM_START_CHAR> | [ "*", "?" ]) (<_TERM_CHAR> | ( [ "*", "?" ] ))* >
-
 <DEFAULT> TOKEN : {
   <AND:       ("AND" | "&&") >
 | <OR:        ("OR" | "||") >
@@ -789,9 +800,8 @@
 | <QUOTED:     "\"" (~["\""])+ "\"">
 | <TERM:      <_TERM_START_CHAR> (<_TERM_CHAR>)*  >
 | <FUZZY_SLOP:     "~" ( (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? )? >
-| <PREFIXTERM:  <_TERM_START_CHAR> (<_TERM_CHAR>)* "*" >
-| <WILDTERM:  <_TERM_START_CHAR>
-              (<_TERM_CHAR> | ( [ "*", "?" ] ))* >
+| <PREFIXTERM:  (<_TERM_START_CHAR> | "*") (<_TERM_CHAR>)* "*" >
+| <WILDTERM:  (<_TERM_START_CHAR> | [ "*", "?" ]) (<_TERM_CHAR> | ( [ "*", "?" ] ))* >
 | <RANGEIN_START: "[" > : RangeIn
 | <RANGEEX_START: "{" > : RangeEx
 }
Index: /home/dnaber/workspace2/LuceneOrig2/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java
===================================================================
--- /home/dnaber/workspace2/LuceneOrig2/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java	(revision 387802)
+++ /home/dnaber/workspace2/LuceneOrig2/src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java	(working copy)
@@ -104,7 +104,7 @@
 {
    int[] nextStates;
    int startsAt = 0;
-   jjnewStateCnt = 33;
+   jjnewStateCnt = 35;
    int i = 1;
    jjstateSet[0] = startState;
    int j, kind = 0x7fffffff;
@@ -120,11 +120,11 @@
             switch(jjstateSet[--i])
             {
                case 0:
-                  if ((0x7bffd0f8ffffd9ffL & l) != 0L)
+                  if ((0xfbffd4f8ffffd9ffL & l) != 0L)
                   {
-                     if (kind > 17)
-                        kind = 17;
-                     jjCheckNAddStates(0, 6);
+                     if (kind > 20)
+                        kind = 20;
+                     jjCheckNAddTwoStates(31, 32);
                   }
                   else if ((0x100002600L & l) != 0L)
                   {
@@ -138,6 +138,14 @@
                      if (kind > 9)
                         kind = 9;
                   }
+                  if ((0x7bffd4f8ffffd9ffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  if ((0x7bffd0f8ffffd9ffL & l) != 0L)
+                  {
+                     if (kind > 17)
+                        kind = 17;
+                     jjCheckNAddTwoStates(18, 19);
+                  }
                   if (curChar == 38)
                      jjstateSet[jjnewStateCnt++] = 4;
                   break;
@@ -165,25 +173,7 @@
                   if (curChar == 34 && kind > 16)
                      kind = 16;
                   break;
-               case 18:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 18)
-                     kind = 18;
-                  jjAddStates(7, 8);
-                  break;
-               case 19:
-                  if (curChar == 46)
-                     jjCheckNAdd(20);
-                  break;
-               case 20:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 18)
-                     kind = 18;
-                  jjCheckNAdd(20);
-                  break;
-               case 21:
+               case 17:
                   if ((0x7bffd0f8ffffd9ffL & l) == 0L)
                      break;
                   if (kind > 17)
@@ -188,9 +178,9 @@
                      break;
                   if (kind > 17)
                      kind = 17;
-                  jjCheckNAddStates(0, 6);
+                  jjCheckNAddTwoStates(18, 19);
                   break;
-               case 22:
+               case 18:
                   if ((0x7bfff8f8ffffd9ffL & l) == 0L)
                      break;
                   if (kind > 17)
@@ -195,9 +185,9 @@
                      break;
                   if (kind > 17)
                      kind = 17;
-                  jjCheckNAddTwoStates(22, 23);
+                  jjCheckNAddTwoStates(18, 19);
                   break;
-               case 24:
+               case 20:
                   if ((0x84002f0600000000L & l) == 0L)
                      break;
                   if (kind > 17)
@@ -202,21 +192,50 @@
                      break;
                   if (kind > 17)
                      kind = 17;
-                  jjCheckNAddTwoStates(22, 23);
+                  jjCheckNAddTwoStates(18, 19);
+                  break;
+               case 22:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 18)
+                     kind = 18;
+                  jjAddStates(3, 4);
+                  break;
+               case 23:
+                  if (curChar == 46)
+                     jjCheckNAdd(24);
+                  break;
+               case 24:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 18)
+                     kind = 18;
+                  jjCheckNAdd(24);
                   break;
                case 25:
-                  if ((0x7bfff8f8ffffd9ffL & l) != 0L)
-                     jjCheckNAddStates(9, 11);
+                  if ((0x7bffd4f8ffffd9ffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
                   break;
                case 26:
+                  if ((0x7bfff8f8ffffd9ffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 27:
                   if (curChar == 42 && kind > 19)
                      kind = 19;
                   break;
-               case 28:
+               case 29:
                   if ((0x84002f0600000000L & l) != 0L)
-                     jjCheckNAddStates(9, 11);
+                     jjCheckNAddStates(0, 2);
                   break;
-               case 29:
+               case 30:
+                  if ((0xfbffd4f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjCheckNAddTwoStates(31, 32);
+                  break;
+               case 31:
                   if ((0xfbfffcf8ffffd9ffL & l) == 0L)
                      break;
                   if (kind > 20)
@@ -221,9 +240,9 @@
                      break;
                   if (kind > 20)
                      kind = 20;
-                  jjCheckNAddTwoStates(29, 30);
+                  jjCheckNAddTwoStates(31, 32);
                   break;
-               case 31:
+               case 33:
                   if ((0x84002f0600000000L & l) == 0L)
                      break;
                   if (kind > 20)
@@ -228,7 +247,7 @@
                      break;
                   if (kind > 20)
                      kind = 20;
-                  jjCheckNAddTwoStates(29, 30);
+                  jjCheckNAddTwoStates(31, 32);
                   break;
                default : break;
             }
@@ -244,9 +263,9 @@
                case 0:
                   if ((0x97ffffff97ffffffL & l) != 0L)
                   {
-                     if (kind > 17)
-                        kind = 17;
-                     jjCheckNAddStates(0, 6);
+                     if (kind > 20)
+                        kind = 20;
+                     jjCheckNAddTwoStates(31, 32);
                   }
                   else if (curChar == 126)
                   {
@@ -252,10 +271,18 @@
                   {
                      if (kind > 18)
                         kind = 18;
-                     jjstateSet[jjnewStateCnt++] = 18;
+                     jjstateSet[jjnewStateCnt++] = 22;
+                  }
+                  if ((0x97ffffff97ffffffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  if ((0x97ffffff97ffffffL & l) != 0L)
+                  {
+                     if (kind > 17)
+                        kind = 17;
+                     jjCheckNAddTwoStates(18, 19);
                   }
                   if (curChar == 92)
-                     jjCheckNAddStates(12, 14);
+                     jjCheckNAddStates(5, 7);
                   else if (curChar == 78)
                      jjstateSet[jjnewStateCnt++] = 11;
                   else if (curChar == 124)
@@ -306,16 +333,10 @@
                      jjstateSet[jjnewStateCnt++] = 11;
                   break;
                case 15:
-                  jjAddStates(15, 16);
+                  jjAddStates(8, 9);
                   break;
                case 17:
-                  if (curChar != 126)
-                     break;
-                  if (kind > 18)
-                     kind = 18;
-                  jjstateSet[jjnewStateCnt++] = 18;
-                  break;
-               case 21:
+               case 18:
                   if ((0x97ffffff97ffffffL & l) == 0L)
                      break;
                   if (kind > 17)
@@ -320,20 +341,13 @@
                      break;
                   if (kind > 17)
                      kind = 17;
-                  jjCheckNAddStates(0, 6);
+                  jjCheckNAddTwoStates(18, 19);
                   break;
-               case 22:
-                  if ((0x97ffffff97ffffffL & l) == 0L)
-                     break;
-                  if (kind > 17)
-                     kind = 17;
-                  jjCheckNAddTwoStates(22, 23);
-                  break;
-               case 23:
+               case 19:
                   if (curChar == 92)
-                     jjCheckNAddTwoStates(24, 24);
+                     jjCheckNAddTwoStates(20, 20);
                   break;
-               case 24:
+               case 20:
                   if ((0x6800000078000000L & l) == 0L)
                      break;
                   if (kind > 17)
@@ -338,21 +352,30 @@
                      break;
                   if (kind > 17)
                      kind = 17;
-                  jjCheckNAddTwoStates(22, 23);
+                  jjCheckNAddTwoStates(18, 19);
+                  break;
+               case 21:
+                  if (curChar != 126)
+                     break;
+                  if (kind > 18)
+                     kind = 18;
+                  jjstateSet[jjnewStateCnt++] = 22;
                   break;
                case 25:
+               case 26:
                   if ((0x97ffffff97ffffffL & l) != 0L)
-                     jjCheckNAddStates(9, 11);
+                     jjCheckNAddStates(0, 2);
                   break;
-               case 27:
+               case 28:
                   if (curChar == 92)
-                     jjCheckNAddTwoStates(28, 28);
+                     jjCheckNAddTwoStates(29, 29);
                   break;
-               case 28:
+               case 29:
                   if ((0x6800000078000000L & l) != 0L)
-                     jjCheckNAddStates(9, 11);
+                     jjCheckNAddStates(0, 2);
                   break;
-               case 29:
+               case 30:
+               case 31:
                   if ((0x97ffffff97ffffffL & l) == 0L)
                      break;
                   if (kind > 20)
@@ -357,13 +380,13 @@
                      break;
                   if (kind > 20)
                      kind = 20;
-                  jjCheckNAddTwoStates(29, 30);
+                  jjCheckNAddTwoStates(31, 32);
                   break;
-               case 30:
+               case 32:
                   if (curChar == 92)
-                     jjCheckNAddTwoStates(31, 31);
+                     jjCheckNAddTwoStates(33, 33);
                   break;
-               case 31:
+               case 33:
                   if ((0x6800000078000000L & l) == 0L)
                      break;
                   if (kind > 20)
@@ -368,11 +391,11 @@
                      break;
                   if (kind > 20)
                      kind = 20;
-                  jjCheckNAddTwoStates(29, 30);
+                  jjCheckNAddTwoStates(31, 32);
                   break;
-               case 32:
+               case 34:
                   if (curChar == 92)
-                     jjCheckNAddStates(12, 14);
+                     jjCheckNAddStates(5, 7);
                   break;
                default : break;
             }
@@ -390,17 +413,27 @@
             switch(jjstateSet[--i])
             {
                case 0:
-                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 17)
-                     kind = 17;
-                  jjCheckNAddStates(0, 6);
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 17)
+                        kind = 17;
+                     jjCheckNAddTwoStates(18, 19);
+                  }
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                     jjCheckNAddStates(0, 2);
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 20)
+                        kind = 20;
+                     jjCheckNAddTwoStates(31, 32);
+                  }
                   break;
                case 15:
                   if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     jjAddStates(15, 16);
+                     jjAddStates(8, 9);
                   break;
-               case 22:
+               case 17:
+               case 18:
                   if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                      break;
                   if (kind > 17)
@@ -405,13 +438,15 @@
                      break;
                   if (kind > 17)
                      kind = 17;
-                  jjCheckNAddTwoStates(22, 23);
+                  jjCheckNAddTwoStates(18, 19);
                   break;
                case 25:
+               case 26:
                   if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     jjCheckNAddStates(9, 11);
+                     jjCheckNAddStates(0, 2);
                   break;
-               case 29:
+               case 30:
+               case 31:
                   if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                      break;
                   if (kind > 20)
@@ -416,7 +451,7 @@
                      break;
                   if (kind > 20)
                      kind = 20;
-                  jjCheckNAddTwoStates(29, 30);
+                  jjCheckNAddTwoStates(31, 32);
                   break;
                default : break;
             }
@@ -429,7 +464,7 @@
          kind = 0x7fffffff;
       }
       ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 33 - (jjnewStateCnt = startsAt)))
+      if ((i = jjnewStateCnt) == (startsAt = 35 - (jjnewStateCnt = startsAt)))
          return curPos;
       try { curChar = input_stream.readChar(); }
       catch(java.io.IOException e) { return curPos; }
@@ -565,7 +600,7 @@
                   jjCheckNAdd(4);
                   break;
                case 2:
-                  jjAddStates(17, 18);
+                  jjAddStates(10, 11);
                   break;
                default : break;
             }
@@ -592,7 +627,7 @@
                   break;
                case 2:
                   if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     jjAddStates(17, 18);
+                     jjAddStates(10, 11);
                   break;
                default : break;
             }
@@ -639,7 +674,7 @@
                      break;
                   if (kind > 23)
                      kind = 23;
-                  jjAddStates(19, 20);
+                  jjAddStates(12, 13);
                   break;
                case 1:
                   if (curChar == 46)
@@ -825,7 +860,7 @@
                   jjCheckNAdd(4);
                   break;
                case 2:
-                  jjAddStates(17, 18);
+                  jjAddStates(10, 11);
                   break;
                default : break;
             }
@@ -852,7 +887,7 @@
                   break;
                case 2:
                   if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     jjAddStates(17, 18);
+                     jjAddStates(10, 11);
                   break;
                default : break;
             }
@@ -872,8 +907,7 @@
    }
 }
 static final int[] jjnextStates = {
-   22, 25, 26, 29, 30, 27, 23, 18, 19, 25, 26, 27, 24, 28, 31, 15, 
-   16, 2, 3, 0, 1, 
+   26, 27, 28, 22, 23, 20, 29, 33, 15, 16, 2, 3, 0, 1, 
 };
 private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
 {
@@ -908,8 +942,8 @@
    0x40L, 
 };
 protected CharStream input_stream;
-private final int[] jjrounds = new int[33];
-private final int[] jjstateSet = new int[66];
+private final int[] jjrounds = new int[35];
+private final int[] jjstateSet = new int[70];
 protected char curChar;
 public QueryParserTokenManager(CharStream stream)
 {
@@ -931,7 +965,7 @@
 {
    int i;
    jjround = 0x80000001;
-   for (i = 33; i-- > 0;)
+   for (i = 35; i-- > 0;)
       jjrounds[i] = 0x80000000;
 }
 public void ReInit(CharStream stream, int lexState)
