Index: src/test/org/apache/lucene/queryParser/TestQueryParser.java
===================================================================
--- src/test/org/apache/lucene/queryParser/TestQueryParser.java	(revision 808150)
+++ src/test/org/apache/lucene/queryParser/TestQueryParser.java	(working copy)
@@ -233,12 +233,12 @@
            + "/, expecting /" + result + "/");
     }
   }
-
+  
   public void testCJK() throws Exception {
-	 // Test Ideographic Space - As wide as a CJK character cell (fullwidth)
-	 // used google to translate the word "term" to japanese -> 用語
-	 assertQueryEquals("term\u3000term\u3000term", null, "term\u0020term\u0020term");
-	 assertQueryEquals("用語\u3000用語\u3000用語", null, "用語\u0020用語\u0020用語");
+   // Test Ideographic Space - As wide as a CJK character cell (fullwidth)
+   // used google to translate the word "term" to japanese -> 用語
+   assertQueryEquals("term\u3000term\u3000term", null, "term\u0020term\u0020term");
+   assertQueryEquals("用語\u3000用語\u3000用語", null, "用語\u0020用語\u0020用語");
   }
   
   public void testSimple() throws Exception {
@@ -314,6 +314,34 @@
     assertQueryEquals("\" \"~2 germ", null, "germ");
     assertQueryEquals("\"term germ\"~2^2", null, "\"term germ\"~2^2.0");
   }
+  
+ public void testFuzzy() throws Exception {
+    
+    assertQueryEquals("foo~0.5", null, "foo~0.5");
+    assertQueryEquals("foo~0.4453", null, "foo~0.4453");
+    assertQueryEquals("foo~0", null, "foo~0.0");
+    assertQueryEquals("foo~0.0", null, "foo~0.0");
+    
+    // tests min similarity
+    FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
+    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+    fq = (FuzzyQuery) getQuery("term~", null);
+    assertEquals(0.5f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+    
+    // should ignore the fuzzy value when it's equals or greater than 1
+    assertQueryEquals("foo~1.0", null, "foo");
+    assertQueryEquals("foo~1.1", null, "foo");
+    
+    // should return TermQuery if fuzzy value is greater or equals 1
+    assertTrue(getQuery("foo~1", null) instanceof TermQuery);
+    assertTrue(getQuery("foo~1.1", null) instanceof TermQuery);
+    assertTrue(getQuery("foo~0.5", null) instanceof FuzzyQuery);
+    assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
+    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
+        
+  }
 
   public void testNumber() throws Exception {
 // The numbers go away because SimpleAnalzyer ignores them
@@ -339,22 +367,11 @@
 
     assertTrue(getQuery("term*", null) instanceof PrefixQuery);
     assertTrue(getQuery("term*^2", null) instanceof PrefixQuery);
-    assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
-    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
-    FuzzyQuery fq = (FuzzyQuery)getQuery("term~0.7", null);
-    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
-    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-    fq = (FuzzyQuery)getQuery("term~", null);
-    assertEquals(0.5f, fq.getMinSimilarity(), 0.1f);
-    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-    
-    assertParseException("term~1.1"); // value > 1, throws exception
-
     assertTrue(getQuery("term*germ", null) instanceof WildcardQuery);
 
 /* Tests to see that wild card terms are (or are not) properly
-	 * lower-cased with propery parser configuration
-	 */
+   * lower-cased with propery parser configuration
+   */
 // First prefix queries:
     // by default, convert to lowercase:
     assertWildcardQueryEquals("Term*", true, "term*");
Index: src/java/org/apache/lucene/queryParser/ParseException.java
===================================================================
--- src/java/org/apache/lucene/queryParser/ParseException.java	(revision 808150)
+++ src/java/org/apache/lucene/queryParser/ParseException.java	(working copy)
@@ -14,24 +14,24 @@
 public class ParseException extends Exception {
 
   /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /**
    * This constructor is used by the method "generateParseException"
    * in the generated parser.  Calling this constructor generates
    * a new object of this type with the fields "currentToken",
-   * "expectedTokenSequences", and "tokenImage" set.  The boolean
-   * flag "specialConstructor" is also set to true to indicate that
-   * this constructor was used to create this object.
-   * This constructor calls its super class with the empty string
-   * to force the "toString" method of parent class "Throwable" to
-   * print the error message in the form:
-   *     ParseException: <result of getMessage>
+   * "expectedTokenSequences", and "tokenImage" set.
    */
   public ParseException(Token currentTokenVal,
                         int[][] expectedTokenSequencesVal,
                         String[] tokenImageVal
                        )
   {
-    super("");
-    specialConstructor = true;
+    super(initialise(currentTokenVal, expectedTokenSequencesVal, tokenImageVal));
     currentToken = currentTokenVal;
     expectedTokenSequences = expectedTokenSequencesVal;
     tokenImage = tokenImageVal;
@@ -49,21 +49,13 @@
 
   public ParseException() {
     super();
-    specialConstructor = false;
   }
 
   /** Constructor with message. */
   public ParseException(String message) {
     super(message);
-    specialConstructor = false;
   }
 
-  /**
-   * This variable determines which constructor was used to create
-   * this object and thereby affects the semantics of the
-   * "getMessage" method (see below).
-   */
-  protected boolean specialConstructor;
 
   /**
    * This is the last token that has been consumed successfully.  If
@@ -87,19 +79,16 @@
   public String[] tokenImage;
 
   /**
-   * This method has the standard behavior when this object has been
-   * created using the standard constructors.  Otherwise, it uses
-   * "currentToken" and "expectedTokenSequences" to generate a parse
+   * It uses "currentToken" and "expectedTokenSequences" to generate a parse
    * error message and returns it.  If this object has been created
    * due to a parse error, and you do not catch it (it gets thrown
-   * from the parser), then this method is called during the printing
-   * of the final stack trace, and hence the correct error message
+   * from the parser) the correct error message
    * gets displayed.
    */
-  public String getMessage() {
-    if (!specialConstructor) {
-      return super.getMessage();
-    }
+  private static String initialise(Token currentToken,
+                           int[][] expectedTokenSequences,
+                           String[] tokenImage) {
+    String eol = System.getProperty("line.separator", "\n");
     StringBuffer expected = new StringBuffer();
     int maxSize = 0;
     for (int i = 0; i < expectedTokenSequences.length; i++) {
@@ -149,7 +138,7 @@
    * when these raw version cannot be used as part of an ASCII
    * string literal.
    */
-  protected String add_escapes(String str) {
+  static String add_escapes(String str) {
       StringBuffer retval = new StringBuffer();
       char ch;
       for (int i = 0; i < str.length(); i++) {
@@ -195,4 +184,4 @@
    }
 
 }
-/* JavaCC - OriginalChecksum=c63b396885c4ff44d7aa48d3feae60cd (do not edit this line) */
+/* JavaCC - OriginalChecksum=12633a996898f342ecccfda230ca22dd (do not edit this line) */
Index: src/java/org/apache/lucene/queryParser/QueryParser.java
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParser.java	(revision 808150)
+++ src/java/org/apache/lucene/queryParser/QueryParser.java	(working copy)
@@ -1093,7 +1093,7 @@
         }
         lastCharWasEscapeChar = false;
       } else {
-        if (curChar == '\\') {
+        if (curChar == '\u005c\u005c') {
           lastCharWasEscapeChar = true;
         } else {
           output[length] = curChar;
@@ -1135,10 +1135,10 @@
     for (int i = 0; i < s.length(); i++) {
       char c = s.charAt(i);
       // These characters are part of the query syntax and must be escaped
-      if (c == '\\' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':'
-        || c == '^' || c == '[' || c == ']' || c == '\"' || c == '{' || c == '}' || c == '~'
+      if (c == '\u005c\u005c' || c == '+' || c == '-' || c == '!' || c == '(' || c == ')' || c == ':'
+        || c == '^' || c == '[' || c == ']' || c == '\u005c"' || c == '{' || c == '}' || c == '~'
         || c == '*' || c == '?' || c == '|' || c == '&') {
-        sb.append('\\');
+        sb.append('\u005c\u005c');
       }
       sb.append(c);
     }
@@ -1417,10 +1417,19 @@
           try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
           } catch (Exception ignored) { }
-         if(fms < 0.0f || fms > 1.0f){
-           {if (true) throw new ParseException("Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !");}
-         }
-         q = getFuzzyQuery(field, termImage,fms);
+
+          // min similarity equals or greater than 1, ignores fuzzy and return a simple TermQuery
+
+          if(fms < 0.0f){
+                {if (true) throw new ParseException("Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !");}
+
+              } else if (fms >= 1.0f) {
+                q = getFieldQuery(field, termImage);
+
+              } else {
+                q = getFuzzyQuery(field, termImage,fms);
+              }
+
        } else {
          q = getFieldQuery(field, termImage);
        }
@@ -1591,16 +1600,6 @@
     finally { jj_save(0, xla); }
   }
 
-  private boolean jj_3_1() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_2()) {
-    jj_scanpos = xsp;
-    if (jj_3R_3()) return true;
-    }
-    return false;
-  }
-
   private boolean jj_3R_3() {
     if (jj_scan_token(STAR)) return true;
     if (jj_scan_token(COLON)) return true;
@@ -1613,6 +1612,16 @@
     return false;
   }
 
+  private boolean jj_3_1() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_2()) {
+    jj_scanpos = xsp;
+    if (jj_3R_3()) return true;
+    }
+    return false;
+  }
+
   /** Generated Token Manager. */
   public QueryParserTokenManager token_source;
   /** Current token. */
Index: src/java/org/apache/lucene/queryParser/QueryParser.jj
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParser.jj	(revision 808150)
+++ src/java/org/apache/lucene/queryParser/QueryParser.jj	(working copy)
@@ -1372,10 +1372,19 @@
        	  try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
        	  } catch (Exception ignored) { }
-       	 if(fms < 0.0f || fms > 1.0f){
-       	   throw new ParseException("Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !");
-       	 }
-       	 q = getFuzzyQuery(field, termImage,fms);
+       	  
+       	  // min similarity equals or greater than 1, ignores fuzzy and return a simple TermQuery
+       	  
+       	  if(fms < 0.0f){
+       	   	throw new ParseException("Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !");
+       	   
+	      } else if (fms >= 1.0f) {
+	       	q = getFieldQuery(field, termImage);
+	       
+	      } else {
+	     	q = getFuzzyQuery(field, termImage,fms);
+	      }
+       	  
        } else {
          q = getFieldQuery(field, termImage);
        }
Index: src/java/org/apache/lucene/queryParser/CharStream.java
===================================================================
--- src/java/org/apache/lucene/queryParser/CharStream.java	(revision 808150)
+++ src/java/org/apache/lucene/queryParser/CharStream.java	(working copy)
@@ -1,5 +1,5 @@
 /* Generated By:JavaCC: Do not edit this line. CharStream.java Version 4.1 */
-/* JavaCCOptions:STATIC=false */
+/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
 package org.apache.lucene.queryParser;
 
 /**
@@ -17,7 +17,8 @@
  * operation.
  */
 
-public interface CharStream {
+public
+interface CharStream {
 
   /**
    * Returns the next character from the selected input.  The method
@@ -109,4 +110,4 @@
   void Done();
 
 }
-/* JavaCC - OriginalChecksum=a83909a2403f969f94d18375f9f143e4 (do not edit this line) */
+/* JavaCC - OriginalChecksum=70acc0f240358486f3603747b17c71e9 (do not edit this line) */
Index: src/java/org/apache/lucene/queryParser/TokenMgrError.java
===================================================================
--- src/java/org/apache/lucene/queryParser/TokenMgrError.java	(revision 808150)
+++ src/java/org/apache/lucene/queryParser/TokenMgrError.java	(working copy)
@@ -6,135 +6,142 @@
 public class TokenMgrError extends Error
 {
 
-   /*
-    * Ordinals for various reasons why an Error of this type can be thrown.
-    */
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
 
-   /**
-    * Lexical error occurred.
-    */
-   static final int LEXICAL_ERROR = 0;
+  /*
+   * Ordinals for various reasons why an Error of this type can be thrown.
+   */
 
-   /**
-    * An attempt was made to create a second instance of a static token manager.
-    */
-   static final int STATIC_LEXER_ERROR = 1;
+  /**
+   * Lexical error occurred.
+   */
+  static final int LEXICAL_ERROR = 0;
 
-   /**
-    * Tried to change to an invalid lexical state.
-    */
-   static final int INVALID_LEXICAL_STATE = 2;
+  /**
+   * An attempt was made to create a second instance of a static token manager.
+   */
+  static final int STATIC_LEXER_ERROR = 1;
 
-   /**
-    * Detected (and bailed out of) an infinite loop in the token manager.
-    */
-   static final int LOOP_DETECTED = 3;
+  /**
+   * Tried to change to an invalid lexical state.
+   */
+  static final int INVALID_LEXICAL_STATE = 2;
 
-   /**
-    * Indicates the reason why the exception is thrown. It will have
-    * one of the above 4 values.
-    */
-   int errorCode;
+  /**
+   * Detected (and bailed out of) an infinite loop in the token manager.
+   */
+  static final int LOOP_DETECTED = 3;
 
-   /**
-    * Replaces unprintable characters by their escaped (or unicode escaped)
-    * equivalents in the given string
-    */
-   protected static final String addEscapes(String str) {
-      StringBuffer retval = new StringBuffer();
-      char ch;
-      for (int i = 0; i < str.length(); i++) {
-        switch (str.charAt(i))
-        {
-           case 0 :
-              continue;
-           case '\b':
-              retval.append("\\b");
-              continue;
-           case '\t':
-              retval.append("\\t");
-              continue;
-           case '\n':
-              retval.append("\\n");
-              continue;
-           case '\f':
-              retval.append("\\f");
-              continue;
-           case '\r':
-              retval.append("\\r");
-              continue;
-           case '\"':
-              retval.append("\\\"");
-              continue;
-           case '\'':
-              retval.append("\\\'");
-              continue;
-           case '\\':
-              retval.append("\\\\");
-              continue;
-           default:
-              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
-                 String s = "0000" + Integer.toString(ch, 16);
-                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
-              } else {
-                 retval.append(ch);
-              }
-              continue;
-        }
+  /**
+   * Indicates the reason why the exception is thrown. It will have
+   * one of the above 4 values.
+   */
+  int errorCode;
+
+  /**
+   * Replaces unprintable characters by their escaped (or unicode escaped)
+   * equivalents in the given string
+   */
+  protected static final String addEscapes(String str) {
+    StringBuffer retval = new StringBuffer();
+    char ch;
+    for (int i = 0; i < str.length(); i++) {
+      switch (str.charAt(i))
+      {
+        case 0 :
+          continue;
+        case '\b':
+          retval.append("\\b");
+          continue;
+        case '\t':
+          retval.append("\\t");
+          continue;
+        case '\n':
+          retval.append("\\n");
+          continue;
+        case '\f':
+          retval.append("\\f");
+          continue;
+        case '\r':
+          retval.append("\\r");
+          continue;
+        case '\"':
+          retval.append("\\\"");
+          continue;
+        case '\'':
+          retval.append("\\\'");
+          continue;
+        case '\\':
+          retval.append("\\\\");
+          continue;
+        default:
+          if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+            String s = "0000" + Integer.toString(ch, 16);
+            retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+          } else {
+            retval.append(ch);
+          }
+          continue;
       }
-      return retval.toString();
-   }
+    }
+    return retval.toString();
+  }
 
-   /**
-    * Returns a detailed message for the Error when it is thrown by the
-    * token manager to indicate a lexical error.
-    * Parameters :
-    *    EOFSeen     : indicates if EOF caused the lexical error
-    *    curLexState : lexical state in which this error occurred
-    *    errorLine   : line number when the error occurred
-    *    errorColumn : column number when the error occurred
-    *    errorAfter  : prefix that was seen before this error occurred
-    *    curchar     : the offending character
-    * Note: You can customize the lexical error message by modifying this method.
-    */
-   protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
-      return("Lexical error at line " +
-           errorLine + ", column " +
-           errorColumn + ".  Encountered: " +
-           (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
-           "after : \"" + addEscapes(errorAfter) + "\"");
-   }
+  /**
+   * Returns a detailed message for the Error when it is thrown by the
+   * token manager to indicate a lexical error.
+   * Parameters :
+   *    EOFSeen     : indicates if EOF caused the lexical error
+   *    curLexState : lexical state in which this error occurred
+   *    errorLine   : line number when the error occurred
+   *    errorColumn : column number when the error occurred
+   *    errorAfter  : prefix that was seen before this error occurred
+   *    curchar     : the offending character
+   * Note: You can customize the lexical error message by modifying this method.
+   */
+  protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
+    return("Lexical error at line " +
+          errorLine + ", column " +
+          errorColumn + ".  Encountered: " +
+          (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
+          "after : \"" + addEscapes(errorAfter) + "\"");
+  }
 
-   /**
-    * You can also modify the body of this method to customize your error messages.
-    * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
-    * of end-users concern, so you can return something like :
-    *
-    *     "Internal Error : Please file a bug report .... "
-    *
-    * from this method for such cases in the release version of your parser.
-    */
-   public String getMessage() {
-      return super.getMessage();
-   }
+  /**
+   * You can also modify the body of this method to customize your error messages.
+   * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
+   * of end-users concern, so you can return something like :
+   *
+   *     "Internal Error : Please file a bug report .... "
+   *
+   * from this method for such cases in the release version of your parser.
+   */
+  public String getMessage() {
+    return super.getMessage();
+  }
 
-   /*
-    * Constructors of various flavors follow.
-    */
+  /*
+   * Constructors of various flavors follow.
+   */
 
-   /** No arg constructor. */
-   public TokenMgrError() {
-   }
+  /** No arg constructor. */
+  public TokenMgrError() {
+  }
 
-   /** Constructor with message and reason. */
-   public TokenMgrError(String message, int reason) {
-      super(message);
-      errorCode = reason;
-   }
+  /** Constructor with message and reason. */
+  public TokenMgrError(String message, int reason) {
+    super(message);
+    errorCode = reason;
+  }
 
-   /** Full Constructor. */
-   public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
-      this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
-   }
+  /** Full Constructor. */
+  public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
+    this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
+  }
 }
-/* JavaCC - OriginalChecksum=55cddb2336a66b376c0bb59d916b326d (do not edit this line) */
+/* JavaCC - OriginalChecksum=41f2927aa4a05c602e9301e3e38a1cdb (do not edit this line) */
Index: src/java/org/apache/lucene/queryParser/Token.java
===================================================================
--- src/java/org/apache/lucene/queryParser/Token.java	(revision 808150)
+++ src/java/org/apache/lucene/queryParser/Token.java	(working copy)
@@ -1,14 +1,21 @@
 /* Generated By:JavaCC: Do not edit this line. Token.java Version 4.1 */
-/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null */
+/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
 package org.apache.lucene.queryParser;
 
 /**
  * Describes the input token stream.
  */
 
-public class Token {
+public class Token implements java.io.Serializable {
 
   /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /**
    * An integer that describes the kind of this token.  This numbering
    * system is determined by JavaCCParser, and a table of these numbers is
    * stored in the file ...Constants.java.
@@ -75,7 +82,7 @@
    */
   public Token(int kind)
   {
-     this(kind, null);
+    this(kind, null);
   }
 
   /**
@@ -83,8 +90,8 @@
    */
   public Token(int kind, String image)
   {
-     this.kind = kind;
-     this.image = image;
+    this.kind = kind;
+    this.image = image;
   }
 
   /**
@@ -92,7 +99,7 @@
    */
   public String toString()
   {
-     return image;
+    return image;
   }
 
   /**
@@ -109,16 +116,16 @@
    */
   public static Token newToken(int ofKind, String image)
   {
-     switch(ofKind)
-     {
-       default : return new Token(ofKind, image);
-     }
+    switch(ofKind)
+    {
+      default : return new Token(ofKind, image);
+    }
   }
 
   public static Token newToken(int ofKind)
   {
-     return newToken(ofKind, null);
+    return newToken(ofKind, null);
   }
 
 }
-/* JavaCC - OriginalChecksum=37b1923f964a5a434f5ea3d6952ff200 (do not edit this line) */
+/* JavaCC - OriginalChecksum=8bfb67fad204fb9440ba425fc3724e67 (do not edit this line) */
