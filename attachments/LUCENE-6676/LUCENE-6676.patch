Index: lucene/core/src/java/org/apache/lucene/index/DocumentsWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/DocumentsWriter.java	(revision 1690879)
+++ lucene/core/src/java/org/apache/lucene/index/DocumentsWriter.java	(working copy)
@@ -265,23 +265,18 @@
   /** Returns how many documents were aborted. */
   private int abortThreadState(final ThreadState perThread) {
     assert perThread.isHeldByCurrentThread();
-    if (perThread.isActive()) { // we might be closed
-      if (perThread.isInitialized()) { 
-        try {
-          int abortedDocCount = perThread.dwpt.getNumDocsInRAM();
-          subtractFlushedNumDocs(abortedDocCount);
-          perThread.dwpt.abort();
-          return abortedDocCount;
-        } finally {
-          flushControl.doOnAbort(perThread);
-        }
-      } else {
+    if (perThread.isInitialized()) { 
+      try {
+        int abortedDocCount = perThread.dwpt.getNumDocsInRAM();
+        subtractFlushedNumDocs(abortedDocCount);
+        perThread.dwpt.abort();
+        return abortedDocCount;
+      } finally {
         flushControl.doOnAbort(perThread);
-        // This DWPT was never initialized so it has no indexed documents:
-        return 0;
       }
     } else {
-      assert closed;
+      flushControl.doOnAbort(perThread);
+      // This DWPT was never initialized so it has no indexed documents:
       return 0;
     }
   }
@@ -390,9 +385,8 @@
   }
   
   private void ensureInitialized(ThreadState state) throws IOException {
-    if (state.isActive() && state.dwpt == null) {
-      final FieldInfos.Builder infos = new FieldInfos.Builder(
-          writer.globalFieldNumberMap);
+    if (state.dwpt == null) {
+      final FieldInfos.Builder infos = new FieldInfos.Builder(writer.globalFieldNumberMap);
       state.dwpt = new DocumentsWriterPerThread(writer, writer.newSegmentName(), directoryOrig,
                                                 directory, config, infoStream, deleteQueue, infos,
                                                 writer.pendingNumDocs, writer.enableTestPoints);
@@ -407,10 +401,9 @@
     final DocumentsWriterPerThread flushingDWPT;
     
     try {
-      if (!perThread.isActive()) {
-        ensureOpen();
-        assert false: "perThread is not active but we are still open";
-      }
+      // This must happen after we've pulled the ThreadState because IW.close
+      // waits for all ThreadStates to be released:
+      ensureOpen();
       ensureInitialized(perThread);
       assert perThread.isInitialized();
       final DocumentsWriterPerThread dwpt = perThread.dwpt;
@@ -445,10 +438,9 @@
 
     final DocumentsWriterPerThread flushingDWPT;
     try {
-      if (!perThread.isActive()) {
-        ensureOpen();
-        assert false: "perThread is not active but we are still open";
-      }
+      // This must happen after we've pulled the ThreadState because IW.close
+      // waits for all ThreadStates to be released:
+      ensureOpen();
       ensureInitialized(perThread);
       assert perThread.isInitialized();
       final DocumentsWriterPerThread dwpt = perThread.dwpt;
Index: lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java	(revision 1690879)
+++ lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java	(working copy)
@@ -288,7 +288,7 @@
       }
       assert assertMemory();
       // Take it out of the loop this DWPT is stale
-      perThreadPool.reset(state, closed);
+      perThreadPool.reset(state);
     } finally {
       updateStallState();
     }
@@ -306,7 +306,7 @@
       assert fullFlush : "can not block if fullFlush == false";
       final DocumentsWriterPerThread dwpt;
       final long bytes = perThread.bytesUsed;
-      dwpt = perThreadPool.reset(perThread, closed);
+      dwpt = perThreadPool.reset(perThread);
       numPending--;
       blockedFlushes.add(new BlockedFlush(dwpt, bytes));
     } finally {
@@ -314,8 +314,7 @@
     }
   }
 
-  private DocumentsWriterPerThread internalTryCheckOutForFlush(
-      ThreadState perThread) {
+  private DocumentsWriterPerThread internalTryCheckOutForFlush(ThreadState perThread) {
     assert Thread.holdsLock(this);
     assert perThread.flushPending;
     try {
@@ -327,7 +326,7 @@
             final DocumentsWriterPerThread dwpt;
             final long bytes = perThread.bytesUsed; // do that before
                                                          // replace!
-            dwpt = perThreadPool.reset(perThread, closed);
+            dwpt = perThreadPool.reset(perThread);
             assert !flushingWriters.containsKey(dwpt) : "DWPT is already flushing";
             // Record the flushing DWPT to reduce flushBytes in doAfterFlush
             flushingWriters.put(dwpt, Long.valueOf(bytes));
@@ -379,9 +378,7 @@
 
   synchronized void setClosed() {
     // set by DW to signal that we should not release new DWPT after close
-    if (!closed) {
-      this.closed = true;
-    }
+    this.closed = true;
   }
 
   /**
@@ -492,9 +489,6 @@
       next.lock();
       try {
         if (!next.isInitialized()) {
-          if (closed && next.isActive()) {
-            perThreadPool.deactivateThreadState(next);
-          }
           continue; 
         }
         assert next.dwpt.deleteQueue == flushingQueue
@@ -564,7 +558,7 @@
         fullFlushBuffer.add(flushingDWPT);
       }
     } else {
-        perThreadPool.reset(perThread, closed); // make this state inactive
+      perThreadPool.reset(perThread); // make this state inactive
     }
   }
   
Index: lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool.java	(revision 1690879)
+++ lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThreadPool.java	(working copy)
@@ -59,20 +59,11 @@
     // TODO this should really be part of DocumentsWriterFlushControl
     // write access guarded by DocumentsWriterFlushControl
     long bytesUsed = 0;
-    // guarded by Reentrant lock
-    private boolean isActive = true;
 
     ThreadState(DocumentsWriterPerThread dpwt) {
       this.dwpt = dpwt;
     }
     
-    /** Mark this ThreadState as inactive, setting dwpt to null.
-     * @see #isActive() */
-    private void deactivate() {
-      isActive = false;
-      reset();
-    }
-    
     private void reset() {
       assert this.isHeldByCurrentThread();
       this.dwpt = null;
@@ -80,19 +71,9 @@
       this.flushPending = false;
     }
     
-    /**
-     * Returns <code>true</code> if this ThreadState is still open. This will
-     * only return <code>false</code> iff the DW has been closed and this
-     * ThreadState is already checked out for flush.
-     */
-    boolean isActive() {
-      assert this.isHeldByCurrentThread();
-      return isActive;
-    }
-    
     boolean isInitialized() {
       assert this.isHeldByCurrentThread();
-      return isActive() && dwpt != null;
+      return dwpt != null;
     }
     
     /**
@@ -169,14 +150,10 @@
     return threadState;
   }
 
-  DocumentsWriterPerThread reset(ThreadState threadState, boolean closed) {
+  DocumentsWriterPerThread reset(ThreadState threadState) {
     assert threadState.isHeldByCurrentThread();
     final DocumentsWriterPerThread dwpt = threadState.dwpt;
-    if (!closed) {
-      threadState.reset();
-    } else {
-      threadState.deactivate();
-    }
+    threadState.reset();
     return dwpt;
   }
   
@@ -266,16 +243,4 @@
     }
     return minThreadState;
   }
-
-  /**
-   * Deactivates an active {@link ThreadState}. Inactive {@link ThreadState} can
-   * not be used for indexing anymore once they are deactivated. This method should only be used
-   * if the parent {@link DocumentsWriter} is closed or aborted.
-   * 
-   * @param threadState the state to deactivate
-   */
-  void deactivateThreadState(ThreadState threadState) {
-    assert threadState.isActive();
-    threadState.deactivate();
-  }
 }
