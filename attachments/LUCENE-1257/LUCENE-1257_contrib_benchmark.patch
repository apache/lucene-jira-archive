Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/utils/NoDeletionPolicy.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/utils/NoDeletionPolicy.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/utils/NoDeletionPolicy.java	(working copy)
@@ -20,12 +20,18 @@
 import java.io.IOException;
 import java.util.List;
 
+import org.apache.lucene.index.IndexCommit;
 import org.apache.lucene.index.IndexDeletionPolicy;
 
 public class NoDeletionPolicy implements IndexDeletionPolicy {
-  public void onCommit(List commits) throws IOException {    
+
+  public void onCommit(List<? extends IndexCommit> commits) throws IOException {
+    // TODO Auto-generated method stub
+    
   }
 
-  public void onInit(List commits) throws IOException {    
+  public void onInit(List<? extends IndexCommit> commits) throws IOException {
+    // TODO Auto-generated method stub
+    
   }
 }
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/utils/SimpleQQParser.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/utils/SimpleQQParser.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/utils/SimpleQQParser.java	(working copy)
@@ -32,7 +32,7 @@
 
   private String qqName;
   private String indexField;
-  ThreadLocal queryParser = new ThreadLocal();
+  ThreadLocal<QueryParser> queryParser = new ThreadLocal<QueryParser>();
 
   /**
    * Constructor of a simple qq parser.
@@ -48,7 +48,7 @@
    * @see org.apache.lucene.benchmark.quality.QualityQueryParser#parse(org.apache.lucene.benchmark.quality.QualityQuery)
    */
   public Query parse(QualityQuery qq) throws ParseException {
-    QueryParser qp = (QueryParser) queryParser.get();
+    QueryParser qp = queryParser.get();
     if (qp==null) {
       qp = new QueryParser(indexField, new StandardAnalyzer(Version.LUCENE_CURRENT));
       queryParser.set(qp);
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/utils/QualityQueriesFinder.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/utils/QualityQueriesFinder.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/utils/QualityQueriesFinder.java	(working copy)
@@ -105,7 +105,7 @@
     String res[] = new String[pq.size()];
     int i = 0;
     while (pq.size()>0) {
-      TermDf tdf = (TermDf) pq.pop(); 
+      TermDf tdf = pq.pop(); 
       res[i++] = tdf.word;
       System.out.println(i+".   word:  "+tdf.df+"   "+tdf.word);
     }
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityStats.java	(working copy)
@@ -58,7 +58,7 @@
     }
   }
   
-  private ArrayList recallPoints;
+  private ArrayList<RecallPoint> recallPoints;
   
   /**
    * Construct a QualityStats object with anticipated maximal number of relevant hits. 
@@ -67,7 +67,7 @@
   public QualityStats(double maxGoodPoints, long searchTime) {
     this.maxGoodPoints = maxGoodPoints;
     this.searchTime = searchTime;
-    this.recallPoints = new ArrayList();
+    this.recallPoints = new ArrayList<RecallPoint>();
     pAt = new double[MAX_POINTS+1]; // pAt[0] unused. 
   }
 
@@ -265,7 +265,7 @@
    * Returns the recallPoints.
    */
   public RecallPoint [] getRecallPoints() {
-    return (RecallPoint[]) recallPoints.toArray(new RecallPoint[0]);
+    return recallPoints.toArray(new RecallPoint[0]);
   }
 
   /**
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/trec/Trec1MQReader.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/trec/Trec1MQReader.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/trec/Trec1MQReader.java	(working copy)
@@ -55,7 +55,7 @@
    * @throws IOException if cannot read the queries.
    */
   public QualityQuery[] readQueries(BufferedReader reader) throws IOException {
-    ArrayList res = new ArrayList();
+    ArrayList<QualityQuery> res = new ArrayList<QualityQuery>();
     String line;
     try {
       while (null!=(line=reader.readLine())) {
@@ -69,7 +69,7 @@
         // qtext
         String qtext = line.substring(k+1).trim();
         // we got a topic!
-        HashMap fields = new HashMap();
+        HashMap<String,String> fields = new HashMap<String,String>();
         fields.put(name,qtext);
         //System.out.println("id: "+id+" qtext: "+qtext+"  line: "+line);
         QualityQuery topic = new QualityQuery(id,fields);
@@ -79,7 +79,7 @@
       reader.close();
     }
     // sort result array (by ID) 
-    QualityQuery qq[] = (QualityQuery[]) res.toArray(new QualityQuery[0]);
+    QualityQuery qq[] = res.toArray(new QualityQuery[0]);
     Arrays.sort(qq);
     return qq;
   }
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/trec/TrecTopicsReader.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/trec/TrecTopicsReader.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/trec/TrecTopicsReader.java	(working copy)
@@ -62,11 +62,11 @@
    * @throws IOException if cannot read the queries.
    */
   public QualityQuery[] readQueries(BufferedReader reader) throws IOException {
-    ArrayList res = new ArrayList();
+    ArrayList<QualityQuery> res = new ArrayList<QualityQuery>();
     StringBuffer sb;
     try {
       while (null!=(sb=read(reader,"<top>",null,false,false))) {
-        HashMap fields = new HashMap();
+        HashMap<String,String> fields = new HashMap<String,String>();
         // id
         sb = read(reader,"<num>",null,true,false);
         int k = sb.indexOf(":");
@@ -91,7 +91,7 @@
       reader.close();
     }
     // sort result array (by ID) 
-    QualityQuery qq[] = (QualityQuery[]) res.toArray(new QualityQuery[0]);
+    QualityQuery qq[] = res.toArray(new QualityQuery[0]);
     Arrays.sort(qq);
     return qq;
   }
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/trec/TrecJudge.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/trec/TrecJudge.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/trec/TrecJudge.java	(working copy)
@@ -21,7 +21,6 @@
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.HashMap;
-import java.util.Iterator;
 import java.util.StringTokenizer;
 
 import org.apache.lucene.benchmark.quality.Judge;
@@ -32,7 +31,7 @@
  */
 public class TrecJudge implements Judge {
 
-  HashMap judgements;
+  HashMap<String,QRelJudgement> judgements;
   
   /**
    * Constructor from a reader.
@@ -50,7 +49,7 @@
    * @throws IOException 
    */
   public TrecJudge (BufferedReader reader) throws IOException {
-    judgements = new HashMap();
+    judgements = new HashMap<String,QRelJudgement>();
     QRelJudgement curr = null;
     String zero = "0";
     String line;
@@ -69,7 +68,7 @@
         assert !st.hasMoreTokens() : "wrong format: "+line+"  next: "+st.nextToken();
         if (relevant) { // only keep relevant docs
           if (curr==null || !curr.queryID.equals(queryID)) {
-            curr = (QRelJudgement)judgements.get(queryID);
+            curr = judgements.get(queryID);
             if (curr==null) {
               curr = new QRelJudgement(queryID);
               judgements.put(queryID,curr);
@@ -85,18 +84,18 @@
   
   // inherit javadocs
   public boolean isRelevant(String docName, QualityQuery query) {
-    QRelJudgement qrj = (QRelJudgement) judgements.get(query.getQueryID());
+    QRelJudgement qrj = judgements.get(query.getQueryID());
     return qrj!=null && qrj.isRelevant(docName);
   }
 
   /** single Judgement of a trec quality query */
   private static class QRelJudgement {
     private String queryID;
-    private HashMap relevantDocs;
+    private HashMap<String,String> relevantDocs;
     
     QRelJudgement(String queryID) {
       this.queryID = queryID;
-      relevantDocs = new HashMap();
+      relevantDocs = new HashMap<String,String>();
     }
     
     public void addRelevandDoc(String docName) {
@@ -114,8 +113,8 @@
 
   // inherit javadocs
   public boolean validateData(QualityQuery[] qq, PrintWriter logger) {
-    HashMap missingQueries = (HashMap) judgements.clone();
-    ArrayList missingJudgements = new ArrayList();
+    HashMap<String,QRelJudgement> missingQueries = (HashMap<String, QRelJudgement>) judgements.clone();
+    ArrayList<String> missingJudgements = new ArrayList<String>();
     for (int i=0; i<qq.length; i++) {
       String id = qq[i].getQueryID();
       if (missingQueries.containsKey(id)) {
@@ -130,7 +129,7 @@
       if (logger!=null) {
         logger.println("WARNING: "+missingJudgements.size()+" queries have no judgments! - ");
         for (int i=0; i<missingJudgements.size(); i++) {
-          logger.println("   "+(String)missingJudgements.get(i));
+          logger.println("   "+ missingJudgements.get(i));
         }
       }
     }
@@ -138,8 +137,7 @@
       isValid = false;
       if (logger!=null) {
         logger.println("WARNING: "+missingQueries.size()+" judgments match no query! - ");
-        for (Iterator it = missingQueries.keySet().iterator(); it.hasNext();) {
-          String id = (String) it.next();
+        for (final String id : missingQueries.keySet()) {
           logger.println("   "+id);
         }
       }
@@ -149,7 +147,7 @@
 
   // inherit javadocs
   public int maxRecall(QualityQuery query) {
-    QRelJudgement qrj = (QRelJudgement) judgements.get(query.getQueryID());
+    QRelJudgement qrj = judgements.get(query.getQueryID());
     if (qrj!=null) {
       return qrj.maxRecall();
     }
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityQuery.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityQuery.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/quality/QualityQuery.java	(working copy)
@@ -34,14 +34,14 @@
  */
 public class QualityQuery implements Comparable<QualityQuery> {
   private String queryID;
-  private Map nameValPairs;
+  private Map<String,String> nameValPairs;
 
   /**
    * Create a QualityQuery with given ID and name-value pairs.
    * @param queryID ID of this quality query.
    * @param nameValPairs the contents of this quality query.
    */
-  public QualityQuery(String queryID, Map nameValPairs) {
+  public QualityQuery(String queryID, Map<String,String> nameValPairs) {
     this.queryID = queryID;
     this.nameValPairs = nameValPairs;
   }
@@ -50,7 +50,7 @@
    * Return all the names of name-value-pairs in this QualityQuery.
    */
   public String[] getNames() {
-    return (String[]) nameValPairs.keySet().toArray(new String[0]);
+    return nameValPairs.keySet().toArray(new String[0]);
   }
 
   /**
@@ -58,7 +58,7 @@
    * @param name the name whose value should be returned. 
    */
   public String getValue(String name) {
-    return (String) nameValPairs.get(name);
+    return nameValPairs.get(name);
   }
 
   /**
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Config.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Config.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Config.java	(working copy)
@@ -26,6 +26,7 @@
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Properties;
 import java.util.StringTokenizer;
 
@@ -50,7 +51,7 @@
   private int roundNumber = 0;
   private Properties props;
   private HashMap valByRound = new HashMap();
-  private HashMap colForValByRound = new HashMap();
+  private HashMap<String,String> colForValByRound = new HashMap<String,String>();
   private String algorithmText;
 
   /**
@@ -60,7 +61,7 @@
    */
   public Config (Reader algReader) throws IOException {
     // read alg file to array of lines
-    ArrayList lines = new ArrayList();
+    ArrayList<String> lines = new ArrayList<String>();
     BufferedReader r = new BufferedReader(algReader);
     int lastConfigLine=0;
     for (String line = r.readLine(); line!=null; line=r.readLine()) {
@@ -112,10 +113,9 @@
 
   private void printProps() {
     System.out.println("------------> config properties:");
-    List propKeys = new ArrayList(props.keySet());
+    List<String> propKeys = new ArrayList(props.keySet());
     Collections.sort(propKeys);
-    for (Iterator it = propKeys.iterator(); it.hasNext();) {
-      String propName = (String) it.next();
+    for (final String propName : propKeys) {
       System.out.println(propName + " = " + props.getProperty(propName));
     }
     System.out.println("-------------------------------");
@@ -283,7 +283,7 @@
       return new int [] { Integer.parseInt(s) };
     }
     
-    ArrayList a = new ArrayList();
+    ArrayList<Integer> a = new ArrayList<Integer>();
     StringTokenizer st = new StringTokenizer(s,":");
     while (st.hasMoreTokens()) {
       String t = st.nextToken();
@@ -291,7 +291,7 @@
     }
     int res[] = new int[a.size()]; 
     for (int i=0; i<a.size(); i++) {
-      res[i] = ((Integer) a.get(i)).intValue();
+      res[i] = a.get(i).intValue();
     }
     return res;
   }
@@ -302,7 +302,7 @@
       return new double [] { Double.parseDouble(s) };
     }
     
-    ArrayList a = new ArrayList();
+    ArrayList<Double> a = new ArrayList<Double>();
     StringTokenizer st = new StringTokenizer(s,":");
     while (st.hasMoreTokens()) {
       String t = st.nextToken();
@@ -310,7 +310,7 @@
     }
     double res[] = new double[a.size()]; 
     for (int i=0; i<a.size(); i++) {
-      res[i] = ((Double) a.get(i)).doubleValue();
+      res[i] = a.get(i).doubleValue();
     }
     return res;
   }
@@ -321,7 +321,7 @@
       return new boolean [] { Boolean.valueOf(s).booleanValue() };
     }
     
-    ArrayList a = new ArrayList();
+    ArrayList<Boolean> a = new ArrayList<Boolean>();
     StringTokenizer st = new StringTokenizer(s,":");
     while (st.hasMoreTokens()) {
       String t = st.nextToken();
@@ -329,7 +329,7 @@
     }
     boolean res[] = new boolean[a.size()]; 
     for (int i=0; i<a.size(); i++) {
-      res[i] = ((Boolean) a.get(i)).booleanValue();
+      res[i] = a.get(i).booleanValue();
     }
     return res;
   }
@@ -342,9 +342,8 @@
       return "";
     }
     StringBuffer sb = new StringBuffer(); 
-    for (Iterator it = colForValByRound.keySet().iterator(); it.hasNext();) {
-      String name = (String) it.next();
-      String colName = (String) colForValByRound.get(name);
+    for (final String name : colForValByRound.keySet()) {
+      String colName = colForValByRound.get(name);
       sb.append(" ").append(colName);
     }
     return sb.toString();
@@ -358,9 +357,8 @@
       return "";
     }
     StringBuffer sb = new StringBuffer(); 
-    for (Iterator it = colForValByRound.keySet().iterator(); it.hasNext();) {
-      String name = (String) it.next();
-      String colName = (String) colForValByRound.get(name);
+    for (final String name  : colForValByRound.keySet()) {
+      String colName = colForValByRound.get(name);
       String template = " "+colName;
       if (roundNum<0) {
         // just append blanks
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/utils/Algorithm.java	(working copy)
@@ -213,9 +213,9 @@
     
     // remove redundant top level enclosing sequences
     while (sequence.isCollapsable() && sequence.getRepetitions()==1 && sequence.getRate()==0) {
-      ArrayList t = sequence.getTasks();
+      ArrayList<PerfTask> t = sequence.getTasks();
       if (t!=null && t.size()==1) {
-        PerfTask p = (PerfTask) t.get(0);
+        PerfTask p = t.get(0);
         if (p instanceof TaskSequence) {
           sequence = (TaskSequence) p;
           continue;
@@ -252,20 +252,19 @@
    * Expert: for test purposes, return all tasks participating in this algorithm.
    * @return all tasks participating in this algorithm.
    */
-  public ArrayList extractTasks() {
-    ArrayList res = new ArrayList();
+  public ArrayList<PerfTask> extractTasks() {
+    ArrayList<PerfTask> res = new ArrayList<PerfTask>();
     extractTasks(res, sequence);
     return res;
   }
-  private void extractTasks (ArrayList extrct, TaskSequence seq) {
+  private void extractTasks (ArrayList<PerfTask> extrct, TaskSequence seq) {
     if (seq==null) 
       return;
     extrct.add(seq);
-    ArrayList t = sequence.getTasks();
+    ArrayList<PerfTask> t = sequence.getTasks();
     if (t==null) 
       return;
-    for (int i = 0; i < t.size(); i++) {
-      PerfTask p = (PerfTask) t.get(0);
+    for (final PerfTask p : t) {
       if (p instanceof TaskSequence) {
         extractTasks(extrct, (TaskSequence)p);
       } else {
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CommitIndexTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CommitIndexTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CommitIndexTask.java	(working copy)
@@ -46,7 +46,7 @@
     if (iw != null) {
       if (commitUserData == null) iw.commit();
       else {
-        Map map = new HashMap();
+        Map<String,String> map = new HashMap<String,String>();
         map.put(OpenReaderTask.USER_DATA, commitUserData);
         iw.commit(map);
       }
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefTask.java	(working copy)
@@ -21,7 +21,6 @@
 import org.apache.lucene.benchmark.byTask.stats.Report;
 import org.apache.lucene.benchmark.byTask.stats.TaskStats;
 
-import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 
@@ -49,16 +48,15 @@
     return 0;
   }
 
-  protected Report reportSumByPrefix (List taskStats) {
+  protected Report reportSumByPrefix (List<TaskStats> taskStats) {
     // aggregate by task name
     int reported = 0;
-    LinkedHashMap p2 = new LinkedHashMap();
-    for (Iterator it = taskStats.iterator(); it.hasNext();) {
-      TaskStats stat1 = (TaskStats) it.next();
+    LinkedHashMap<String,TaskStats> p2 = new LinkedHashMap<String,TaskStats>();
+    for (final TaskStats stat1 : taskStats) {
       if (stat1.getElapsed()>=0 && stat1.getTask().getName().startsWith(prefix)) { // only ended tasks with proper name
         reported++;
         String name = stat1.getTask().getName();
-        TaskStats stat2 = (TaskStats) p2.get(name);
+        TaskStats stat2 = p2.get(name);
         if (stat2 == null) {
           try {
             stat2 = (TaskStats) stat1.clone();
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetVectorHighlightTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetVectorHighlightTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetVectorHighlightTask.java	(working copy)
@@ -59,7 +59,7 @@
   protected int numToHighlight = Integer.MAX_VALUE;
   protected int maxFrags = 2;
   protected int fragSize = 100;
-  protected Set paramFields = Collections.EMPTY_SET;
+  protected Set<String> paramFields = Collections.emptySet();
   protected FastVectorHighlighter highlighter;
 
   public SearchTravRetVectorHighlightTask(PerfRunData runData) {
@@ -101,8 +101,8 @@
     };
   }
 
-  protected Collection/*<String>*/ getFieldsToHighlight(Document document) {
-    Collection result = super.getFieldsToHighlight(document);
+  protected Collection<String> getFieldsToHighlight(Document document) {
+    Collection<String> result = super.getFieldsToHighlight(document);
     //if stored is false, then result will be empty, in which case just get all the param fields
     if (paramFields.isEmpty() == false && result.isEmpty() == false) {
       result.retainAll(paramFields);
@@ -124,7 +124,7 @@
       } else if (splits[i].startsWith("fragSize[") == true){
         fragSize = (int)Float.parseFloat(splits[i].substring("fragSize[".length(),splits[i].length() - 1));
       } else if (splits[i].startsWith("fields[") == true){
-        paramFields = new HashSet();
+        paramFields = new HashSet<String>();
         String fieldNames = splits[i].substring("fields[".length(), splits[i].length() - 1);
         String [] fieldSplits = fieldNames.split(";");
         for (int j = 0; j < fieldSplits.length; j++) {
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSelectByPrefTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSelectByPrefTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSelectByPrefTask.java	(working copy)
@@ -17,7 +17,6 @@
  * limitations under the License.
  */
 
-import java.util.Iterator;
 import java.util.List;
 
 import org.apache.lucene.benchmark.byTask.PerfRunData;
@@ -46,15 +45,14 @@
     return 0;
   }
   
-  protected Report reportSelectByPrefix(List taskStats) {
-    String longestOp = longestOp(taskStats.iterator());
+  protected Report reportSelectByPrefix(List<TaskStats> taskStats) {
+    String longestOp = longestOp(taskStats);
     boolean first = true;
     StringBuffer sb = new StringBuffer();
     sb.append(tableTitle(longestOp));
     sb.append(newline);
     int reported = 0;
-    for (Iterator it = taskStats.iterator(); it.hasNext();) {
-      TaskStats stat = (TaskStats) it.next();
+    for (final TaskStats stat : taskStats) {
       if (stat.getElapsed()>=0 && stat.getTask().getName().startsWith(prefix)) { // only ended tasks with proper name
         reported++;
         if (!first) {
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTokensTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTokensTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTokensTask.java	(working copy)
@@ -25,7 +25,7 @@
 import org.apache.lucene.benchmark.byTask.PerfRunData;
 import org.apache.lucene.benchmark.byTask.feeds.DocMaker;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
+import org.apache.lucene.document.Fieldable;
 
 /**
  * Simple task to test performance of tokenizers.  It just
@@ -59,12 +59,10 @@
   }
 
   public int doLogic() throws Exception {
-    List fields = doc.getFields();
-    final int numField = fields.size();
+    List<Fieldable> fields = doc.getFields();
     Analyzer analyzer = getRunData().getAnalyzer();
     int tokenCount = 0;
-    for(int i=0;i<numField;i++) {
-      final Field field = (Field) fields.get(i);
+    for(final Fieldable field : fields) {
       final TokenStream stream;
       final TokenStream streamValue = field.tokenStreamValue();
 
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetHighlightTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetHighlightTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetHighlightTask.java	(working copy)
@@ -65,7 +65,7 @@
   protected int numToHighlight = Integer.MAX_VALUE;
   protected boolean mergeContiguous;
   protected int maxFrags = 2;
-  protected Set paramFields = Collections.EMPTY_SET;
+  protected Set<String> paramFields = Collections.emptySet();
   protected Highlighter highlighter;
   protected int maxDocCharsToAnalyze;
 
@@ -104,8 +104,8 @@
     };
   }
 
-  protected Collection/*<String>*/ getFieldsToHighlight(Document document) {
-    Collection result = super.getFieldsToHighlight(document);
+  protected Collection<String> getFieldsToHighlight(Document document) {
+    Collection<String> result = super.getFieldsToHighlight(document);
     //if stored is false, then result will be empty, in which case just get all the param fields
     if (paramFields.isEmpty() == false && result.isEmpty() == false) {
       result.retainAll(paramFields);
@@ -127,7 +127,7 @@
       } else if (splits[i].startsWith("mergeContiguous[") == true){
         mergeContiguous = Boolean.valueOf(splits[i].substring("mergeContiguous[".length(),splits[i].length() - 1)).booleanValue();
       } else if (splits[i].startsWith("fields[") == true){
-        paramFields = new HashSet();
+        paramFields = new HashSet<String>();
         String fieldNames = splits[i].substring("fields[".length(), splits[i].length() - 1);
         String [] fieldSplits = fieldNames.split(";");
         for (int j = 0; j < fieldSplits.length; j++) {
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReportTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReportTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReportTask.java	(working copy)
@@ -1,6 +1,5 @@
 package org.apache.lucene.benchmark.byTask.tasks;
 
-import java.util.Iterator;
 import java.util.LinkedHashMap;
 
 import org.apache.lucene.benchmark.byTask.PerfRunData;
@@ -96,10 +95,9 @@
    * @param taskStats completed tasks to be considered.
    * @return the longest op name out of completed tasks.
    */
-  protected String longestOp(Iterator taskStats) {
+  protected String longestOp(Iterable<TaskStats> taskStats) {
     String longest = OP;
-    while (taskStats.hasNext()) {
-      TaskStats stat = (TaskStats) taskStats.next();
+    for (final TaskStats stat : taskStats) {
       if (stat.getElapsed()>=0) { // consider only tasks that ended
         String name = stat.getTask().getName();
         if (name.length() > longest.length()) {
@@ -133,15 +131,14 @@
     return sb.toString();
   }
 
-  protected Report genPartialReport(int reported, LinkedHashMap partOfTasks, int totalSize) {
-    String longetOp = longestOp(partOfTasks.values().iterator());
+  protected Report genPartialReport(int reported, LinkedHashMap<String,TaskStats> partOfTasks, int totalSize) {
+    String longetOp = longestOp(partOfTasks.values());
     boolean first = true;
     StringBuffer sb = new StringBuffer();
     sb.append(tableTitle(longetOp));
     sb.append(newline);
     int lineNum = 0;
-    for (Iterator it = partOfTasks.values().iterator(); it.hasNext();) {
-      TaskStats stat = (TaskStats) it.next();
+    for (final TaskStats stat : partOfTasks.values()) {
       if (!first) {
         sb.append(newline);
       }
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameRoundTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameRoundTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameRoundTask.java	(working copy)
@@ -17,7 +17,6 @@
  * limitations under the License.
  */
 
-import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 
@@ -51,17 +50,16 @@
    * Report statistics as a string, aggregate for tasks named the same, and from the same round.
    * @return the report
    */
-  protected Report reportSumByNameRound(List taskStats) {
+  protected Report reportSumByNameRound(List<TaskStats> taskStats) {
     // aggregate by task name and round
-    LinkedHashMap p2 = new LinkedHashMap();
+    LinkedHashMap<String,TaskStats> p2 = new LinkedHashMap<String,TaskStats>();
     int reported = 0;
-    for (Iterator it = taskStats.iterator(); it.hasNext();) {
-      TaskStats stat1 = (TaskStats) it.next();
+    for (final TaskStats stat1 : taskStats) {
       if (stat1.getElapsed()>=0) { // consider only tasks that ended
         reported++;
         String name = stat1.getTask().getName();
         String rname = stat1.getRound()+"."+name; // group by round
-        TaskStats stat2 = (TaskStats) p2.get(rname);
+        TaskStats stat2 = p2.get(rname);
         if (stat2 == null) {
           try {
             stat2 = (TaskStats) stat1.clone();
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepAllTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepAllTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepAllTask.java	(working copy)
@@ -17,7 +17,6 @@
  * limitations under the License.
  */
 
-import java.util.Iterator;
 import java.util.List;
 
 import org.apache.lucene.benchmark.byTask.PerfRunData;
@@ -48,16 +47,14 @@
    * Report detailed statistics as a string
    * @return the report
    */
-  protected Report reportAll(List taskStats) {
-    String longestOp = longestOp(taskStats.iterator());
+  protected Report reportAll(List<TaskStats> taskStats) {
+    String longestOp = longestOp(taskStats);
     boolean first = true;
     StringBuffer sb = new StringBuffer();
     sb.append(tableTitle(longestOp));
     sb.append(newline);
     int reported = 0;
-    Iterator it = taskStats.iterator();
-    while (it.hasNext()) {
-      TaskStats stat = (TaskStats) it.next();
+    for (final TaskStats stat : taskStats) {
       if (stat.getElapsed()>=0) { // consider only tasks that ended
         if (!first) {
           sb.append(newline);
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetLoadFieldSelectorTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetLoadFieldSelectorTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/SearchTravRetLoadFieldSelectorTask.java	(working copy)
@@ -58,12 +58,12 @@
 
   public void setParams(String params) {
     this.params = params; // cannot just call super.setParams(), b/c it's params differ.
-    Set fieldsToLoad = new HashSet();
+    Set<String> fieldsToLoad = new HashSet<String>();
     for (StringTokenizer tokenizer = new StringTokenizer(params, ","); tokenizer.hasMoreTokens();) {
       String s = tokenizer.nextToken();
       fieldsToLoad.add(s);
     }
-    fieldSelector = new SetBasedFieldSelector(fieldsToLoad, Collections.EMPTY_SET);
+    fieldSelector = new SetBasedFieldSelector(fieldsToLoad, Collections.<String> emptySet());
   }
 
 
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenReaderTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenReaderTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/OpenReaderTask.java	(working copy)
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 import java.util.Collection;
-import java.util.Iterator;
 import java.util.Map;
 
 import org.apache.lucene.benchmark.byTask.PerfRunData;
@@ -59,14 +58,12 @@
  
   public static IndexReader openCommitPoint(String userData, Directory dir, Config config, boolean readOnly) throws IOException {
     IndexReader r = null;
-    Collection commits = IndexReader.listCommits(dir);
-    Iterator i = commits.iterator();
-    while (i.hasNext()) {
-      IndexCommit ic = (IndexCommit)i.next();
-      Map map = ic.getUserData();
+    Collection<IndexCommit> commits = IndexReader.listCommits(dir);
+    for (final IndexCommit ic : commits) {
+      Map<String,String> map = ic.getUserData();
       String ud = null;
       if (map != null) {
-        ud = (String)map.get(USER_DATA);
+        ud = map.get(USER_DATA);
       }
       if (ud != null && ud.equals(userData)) {
         IndexDeletionPolicy indexDeletionPolicy = CreateIndexTask.getIndexDeletionPolicy(config);
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefRoundTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefRoundTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByPrefRoundTask.java	(working copy)
@@ -17,7 +17,6 @@
  * limitations under the License.
  */
 
-import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 
@@ -47,17 +46,16 @@
     return 0;
   }
 
-  protected Report reportSumByPrefixRound(List taskStats) {
+  protected Report reportSumByPrefixRound(List<TaskStats> taskStats) {
     // aggregate by task name and by round
     int reported = 0;
-    LinkedHashMap p2 = new LinkedHashMap();
-    for (Iterator it = taskStats.iterator(); it.hasNext();) {
-      TaskStats stat1 = (TaskStats) it.next();
+    LinkedHashMap<String,TaskStats> p2 = new LinkedHashMap<String,TaskStats>();
+    for (final TaskStats stat1 : taskStats) {
       if (stat1.getElapsed()>=0 && stat1.getTask().getName().startsWith(prefix)) { // only ended tasks with proper name
         reported++;
         String name = stat1.getTask().getName();
         String rname = stat1.getRound()+"."+name; // group by round
-        TaskStats stat2 = (TaskStats) p2.get(rname);
+        TaskStats stat2 = p2.get(rname);
         if (stat2 == null) {
           try {
             stat2 = (TaskStats) stat1.clone();
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/NewAnalyzerTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/NewAnalyzerTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/NewAnalyzerTask.java	(working copy)
@@ -30,12 +30,12 @@
  *
  */
 public class NewAnalyzerTask extends PerfTask {
-  private List/*<String>*/ analyzerClassNames;
+  private List<String> analyzerClassNames;
   private int current;
 
   public NewAnalyzerTask(PerfRunData runData) {
     super(runData);
-    analyzerClassNames = new ArrayList();
+    analyzerClassNames = new ArrayList<String>();
   }
   
   public static final Analyzer createAnalyzer(String className) throws Exception{
@@ -57,7 +57,7 @@
       {
         current = 0;
       }
-      className = (String) analyzerClassNames.get(current++);
+      className = analyzerClassNames.get(current++);
       if (className == null || className.equals(""))
       {
         className = "org.apache.lucene.analysis.standard.StandardAnalyzer"; 
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/FlushReaderTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/FlushReaderTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/FlushReaderTask.java	(working copy)
@@ -43,7 +43,7 @@
   public int doLogic() throws IOException {
     IndexReader reader = getRunData().getIndexReader();
     if (userData != null) {
-      Map map = new HashMap();
+      Map<String,String> map = new HashMap<String,String>();
       map.put(OpenReaderTask.USER_DATA, userData);
       reader.flush(map);
     } else {
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/RepSumByNameTask.java	(working copy)
@@ -17,7 +17,6 @@
  * limitations under the License.
  */
 
-import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 
@@ -51,16 +50,15 @@
    * Report statistics as a string, aggregate for tasks named the same.
    * @return the report
    */
-  protected Report reportSumByName(List taskStats) {
+  protected Report reportSumByName(List<TaskStats> taskStats) {
     // aggregate by task name
     int reported = 0;
-    LinkedHashMap p2 = new LinkedHashMap();
-    for (Iterator it = taskStats.iterator(); it.hasNext();) {
-      TaskStats stat1 = (TaskStats) it.next();
+    LinkedHashMap<String,TaskStats> p2 = new LinkedHashMap<String,TaskStats>();
+    for (final TaskStats stat1: taskStats) {
       if (stat1.getElapsed()>=0) { // consider only tasks that ended
         reported++;
         String name = stat1.getTask().getName();
-        TaskStats stat2 = (TaskStats) p2.get(name);
+        TaskStats stat2 = p2.get(name);
         if (stat2 == null) {
           try {
             stat2 = (TaskStats) stat1.clone();
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/TaskSequence.java	(working copy)
@@ -18,7 +18,6 @@
  */
 
 import java.util.ArrayList;
-import java.util.Iterator;
 import java.text.NumberFormat;
 
 import org.apache.lucene.benchmark.byTask.PerfRunData;
@@ -29,7 +28,7 @@
  */
 public class TaskSequence extends PerfTask {
   public static int REPEAT_EXHAUST = -2; 
-  private ArrayList tasks;
+  private ArrayList<PerfTask> tasks;
   private int repetitions = 1;
   private boolean parallel;
   private TaskSequence parent;
@@ -54,7 +53,7 @@
     setSequenceName();
     this.parent = parent;
     this.parallel = parallel;
-    tasks = new ArrayList();
+    tasks = new ArrayList<PerfTask>();
   }
 
   public void close() throws Exception {
@@ -70,7 +69,7 @@
       final int numTasks = tasks.size();
       tasksArray = new PerfTask[numTasks];
       for(int k=0;k<numTasks;k++) {
-        tasksArray[k] = (PerfTask) tasks.get(k);
+        tasksArray[k] = tasks.get(k);
         anyExhaustibleTasks |= tasksArray[k] instanceof ResetInputsTask;
         anyExhaustibleTasks |= tasksArray[k] instanceof TaskSequence;
       }
@@ -279,8 +278,7 @@
     StringBuffer sb = new StringBuffer(super.toString());
     sb.append(parallel ? " [" : " {");
     sb.append(NEW_LINE);
-    for (Iterator it = tasks.iterator(); it.hasNext();) {
-      PerfTask task = (PerfTask) it.next();
+    for (final PerfTask task : tasks) {
       sb.append(task.toString());
       sb.append(NEW_LINE);
     }
@@ -304,8 +302,7 @@
    */
   public void setNoChildReport() {
     letChildReport  = false;
-    for (Iterator it = tasks.iterator(); it.hasNext();) {
-      PerfTask task = (PerfTask) it.next();
+    for (final PerfTask task : tasks) {
       if (task instanceof TaskSequence) {
         ((TaskSequence)task).setNoChildReport();
   }
@@ -352,7 +349,7 @@
   /**
    * @return Returns the tasks.
    */
-  public ArrayList getTasks() {
+  public ArrayList<PerfTask> getTasks() {
     return tasks;
   }
 
@@ -361,9 +358,9 @@
    */
   protected Object clone() throws CloneNotSupportedException {
     TaskSequence res = (TaskSequence) super.clone();
-    res.tasks = new ArrayList();
+    res.tasks = new ArrayList<PerfTask>();
     for (int i = 0; i < tasks.size(); i++) {
-      res.tasks.add(((PerfTask)tasks.get(i)).clone());
+      res.tasks.add((PerfTask)tasks.get(i).clone());
     }
     return res;
   }
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/ReadTask.java	(working copy)
@@ -20,7 +20,7 @@
 import java.io.IOException;
 import java.util.Collection;
 import java.util.HashSet;
-import java.util.Iterator;
+
 import java.util.List;
 import java.util.Set;
 
@@ -128,9 +128,8 @@
                 Document document = retrieveDoc(ir, id);
                 res += document != null ? 1 : 0;
                 if (numHighlight > 0 && m < numHighlight) {
-                  Collection/*<String>*/ fieldsToHighlight = getFieldsToHighlight(document);
-                  for (Iterator iterator = fieldsToHighlight.iterator(); iterator.hasNext();) {
-                    String field = (String) iterator.next();
+                  Collection<String> fieldsToHighlight = getFieldsToHighlight(document);
+                  for (final String field : fieldsToHighlight) {
                     String text = document.get(field);
                     res += highlighter.doHighlight(ir, id, field, document, analyzer, text);
                   }
@@ -291,11 +290,10 @@
    * @param document The Document
    * @return A Collection of Field names (Strings)
    */
-  protected Collection/*<String>*/ getFieldsToHighlight(Document document) {
-    List/*<Fieldable>*/ fieldables = document.getFields();
-    Set/*<String>*/ result = new HashSet(fieldables.size());
-    for (Iterator iterator = fieldables.iterator(); iterator.hasNext();) {
-      Fieldable fieldable = (Fieldable) iterator.next();
+  protected Collection<String> getFieldsToHighlight(Document document) {
+    List<Fieldable> fieldables = document.getFields();
+    Set<String> result = new HashSet<String>(fieldables.size());
+    for (final Fieldable fieldable : fieldables) {
       result.add(fieldable.name());
     }
     return result;
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Points.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Points.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/byTask/stats/Points.java	(working copy)
@@ -34,7 +34,7 @@
   // stat points ordered by their start time. 
   // for now we collect points as TaskStats objects.
   // later might optimize to collect only native data.
-  private ArrayList points = new ArrayList();
+  private ArrayList<TaskStats> points = new ArrayList<TaskStats>();
 
   private int nextTaskRunNum = 0;
 
@@ -50,7 +50,7 @@
    * the actual task stats are returned, so caller should not modify this task stats. 
    * @return current {@link TaskStats}.
    */
-  public List taskStats () {
+  public List<TaskStats> taskStats () {
     return points;
   }
 
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/QueryData.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/QueryData.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/QueryData.java	(working copy)
@@ -47,7 +47,7 @@
    * @return The QueryData
    */
   public static QueryData[] getAll(Query[] queries) {
-    Vector vqd = new Vector();
+    Vector<QueryData> vqd = new Vector<QueryData>();
     for (int i = 0; i < queries.length; i++) {
       for (int r = 1; r >= 0; r--) {
         for (int w = 1; w >= 0; w--) {
@@ -63,7 +63,7 @@
         }
       }
     }
-    return (QueryData[])vqd.toArray(new QueryData[0]);
+    return vqd.toArray(new QueryData[0]);
   }
 
   /** Short legend for interpreting toString() output. */
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestData.java	(working copy)
@@ -19,7 +19,7 @@
 import java.io.File;
 import java.text.NumberFormat;
 import java.util.ArrayList;
-import java.util.Collection;
+
 import java.util.Date;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -53,7 +53,7 @@
     /**
      * List of results for each test run with these parameters.
      */
-    private Vector runData = new Vector();
+    private Vector<TestRunData> runData = new Vector<TestRunData>();
     private int maxBufferedDocs, mergeFactor;
     /**
      * Directory containing source files.
@@ -132,7 +132,7 @@
         {
             return "# [NO RUN DATA]";
         }
-        HashMap resByTask = new HashMap(); 
+        HashMap<String,LDCounter> resByTask = new HashMap<String,LDCounter>(); 
         StringBuffer sb = new StringBuffer();
         String lineSep = System.getProperty("line.separator");
         sb.append("warm = Warm Index Reader").append(lineSep).append("srch = Search Index").append(lineSep).append("trav = Traverse Hits list, optionally retrieving document").append(lineSep).append(lineSep);
@@ -140,20 +140,17 @@
           sb.append(COLS[i]);
         }
         sb.append("\n");
-        LinkedHashMap mapMem = new LinkedHashMap();
-        LinkedHashMap mapSpeed = new LinkedHashMap();
+        LinkedHashMap<String,TestData.LCounter[]> mapMem = new LinkedHashMap<String,TestData.LCounter[]>();
+        LinkedHashMap<String,DCounter> mapSpeed = new LinkedHashMap<String,DCounter>();
         for (int i = 0; i < runData.size(); i++)
         {
-            TestRunData trd = (TestRunData) runData.get(i);
-            Collection labels = trd.getLabels();
-            Iterator it = labels.iterator();
-            while (it.hasNext())
+            TestRunData trd = runData.get(i);
+            for (final String label : trd.getLabels()) 
             {
-                String label = (String) it.next();
                 MemUsage mem = trd.getMemUsage(label);
                 if (mem != null)
                 {
-                    TestData.LCounter[] tm = (TestData.LCounter[]) mapMem.get(label);
+                    TestData.LCounter[] tm = mapMem.get(label);
                     if (tm == null)
                     {
                         tm = new TestData.LCounter[2];
@@ -169,7 +166,7 @@
                 TimeData td = trd.getTotals(label);
                 if (td != null)
                 {
-                    TestData.DCounter dc = (TestData.DCounter) mapSpeed.get(label);
+                    TestData.DCounter dc = mapSpeed.get(label);
                     if (dc == null)
                     {
                         dc = new TestData.DCounter();
@@ -182,12 +179,12 @@
                 }
             }
         }
-        LinkedHashMap res = new LinkedHashMap();
-        Iterator it = mapSpeed.keySet().iterator();
+        LinkedHashMap<String,String> res = new LinkedHashMap<String,String>();
+        Iterator<String> it = mapSpeed.keySet().iterator();
         while (it.hasNext())
         {
-            String label = (String) it.next();
-            TestData.DCounter dc = (TestData.DCounter) mapSpeed.get(label);
+            String label = it.next();
+            TestData.DCounter dc = mapSpeed.get(label);
             res.put(label, 
                 format(dc.count, RUNCNT) + 
                 format(dc.recordCount / dc.count, RECCNT) +
@@ -197,7 +194,7 @@
             
             // also sum by task
             String task = label.substring(label.lastIndexOf("-")+1);
-            LDCounter ldc = (LDCounter) resByTask.get(task);
+            LDCounter ldc = resByTask.get(task);
             if (ldc==null) {
               ldc = new LDCounter();
               resByTask.put(task,ldc);
@@ -209,9 +206,9 @@
         it = mapMem.keySet().iterator();
         while (it.hasNext())
         {
-            String label = (String) it.next();
-            TestData.LCounter[] lc = (TestData.LCounter[]) mapMem.get(label);
-            String speed = (String) res.get(label);
+            String label = it.next();
+            TestData.LCounter[] lc =  mapMem.get(label);
+            String speed = res.get(label);
             boolean makeSpeed = false;
             if (speed == null)
             {
@@ -227,7 +224,7 @@
             
             // also sum by task
             String task = label.substring(label.lastIndexOf("-")+1);
-            LDCounter ldc = (LDCounter) resByTask.get(task);
+            LDCounter ldc = resByTask.get(task);
             if (ldc==null) {
               ldc = new LDCounter();
               resByTask.put(task,ldc);
@@ -244,7 +241,7 @@
         it = res.keySet().iterator();
         while (it.hasNext())
         {
-            String label = (String) it.next();
+            String label = it.next();
             sb.append(format(prefix, ID));
             sb.append(format(label, OP));
             sb.append(res.get(label)).append("\n");
@@ -258,8 +255,8 @@
         it = resByTask.keySet().iterator();
         while (it.hasNext())
         {
-            String task = (String) it.next();
-            LDCounter ldc = (LDCounter) resByTask.get(task);
+            String task = it.next();
+            LDCounter ldc = resByTask.get(task);
             sb.append(format("    ", ID));
             sb.append(format(task, OP));
             sb.append(format(ldc.Dcount, RUNCNT)); 
@@ -309,7 +306,7 @@
      */
     public static TestData[] getAll(File[] sources, Analyzer[] analyzers)
     {
-        List res = new ArrayList(50);
+        List<TestData> res = new ArrayList<TestData>(50);
         TestData ref = new TestData();
         for (int q = 0; q < analyzers.length; q++)
         {
@@ -332,7 +329,7 @@
                                 ref.optimize = Constants.BOOLEANS[p].booleanValue();
                                 try
                                 {
-                                    res.add(ref.clone());
+                                    res.add((TestData)ref.clone());
                                 }
                                 catch (Exception e)
                                 {
@@ -344,7 +341,7 @@
                 }
             }
         }
-        return (TestData[]) res.toArray(new TestData[0]);
+        return res.toArray(new TestData[0]);
     }
 
     /**
@@ -358,7 +355,7 @@
      */
     public static TestData[] getTestDataMinMaxMergeAndMaxBuffered(File[] sources, Analyzer[] analyzers)
     {
-        List res = new ArrayList(50);
+        List<TestData> res = new ArrayList<TestData>(50);
         TestData ref = new TestData();
         for (int q = 0; q < analyzers.length; q++)
         {
@@ -373,7 +370,7 @@
                 ref.optimize = true;
                 try
                 {
-                    res.add(ref.clone());
+                    res.add((TestData)ref.clone());
                 }
                 catch (Exception e)
                 {
@@ -388,7 +385,7 @@
                 ref.optimize = true;
                 try
                 {
-                    res.add(ref.clone());
+                    res.add((TestData)ref.clone());
                 }
                 catch (Exception e)
                 {
@@ -403,7 +400,7 @@
                 ref.optimize = true;
                 try
                 {
-                    res.add(ref.clone());
+                    res.add((TestData)ref.clone());
                 }
                 catch (Exception e)
                 {
@@ -418,7 +415,7 @@
                 ref.optimize = true;
                 try
                 {
-                    res.add(ref.clone());
+                    res.add((TestData)ref.clone());
                 }
                 catch (Exception e)
                 {
@@ -426,7 +423,7 @@
                 }
             }
         }
-        return (TestData[]) res.toArray(new TestData[0]);
+        return res.toArray(new TestData[0]);
     }
 
     protected Object clone()
@@ -553,12 +550,12 @@
         this.queries = queries;
     }
 
-    public Vector getRunData()
+    public Vector<TestRunData> getRunData()
     {
         return runData;
     }
 
-    public void setRunData(Vector runData)
+    public void setRunData(Vector<TestRunData> runData)
     {
         this.runData = runData;
     }
Index: contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestRunData.java
===================================================================
--- contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestRunData.java	(revision 828773)
+++ contrib/benchmark/src/java/org/apache/lucene/benchmark/stats/TestRunData.java	(working copy)
@@ -33,7 +33,7 @@
   /** Start and end time of this test run. */
   private long start = 0L, end = 0L;
 
-  private LinkedHashMap data = new LinkedHashMap();
+  private LinkedHashMap<String,Vector<TimeData>> data = new LinkedHashMap<String,Vector<TimeData>>();
 
   public TestRunData() {}
 
@@ -41,7 +41,7 @@
     this.id = id;
   }
 
-    public LinkedHashMap getData()
+    public LinkedHashMap<String,Vector<TimeData>> getData()
     {
         return data;
     }
@@ -79,29 +79,29 @@
   /** Add a data point. */
   public void addData(TimeData td) {
     td.recordMemUsage();
-    Vector v = (Vector) data.get(td.name);
+    Vector<TimeData> v = data.get(td.name);
     if (v == null) {
-      v = new Vector();
+      v = new Vector<TimeData>();
       data.put(td.name, v);
     }
-    v.add(td.clone());
+    v.add((TimeData)td.clone());
   }
 
   /** Get a list of all available types of data points. */
-  public Collection getLabels() {
+  public Collection<String> getLabels() {
     return data.keySet();
   }
 
   /** Get total values from all data points of a given type. */
   public TimeData getTotals(String label) {
-    Vector v = (Vector) data.get(label);
+    Vector<TimeData> v = data.get(label);
       if (v == null)
       {
           return null;
       }
     TimeData res = new TimeData("TOTAL " + label);
     for (int i = 0; i < v.size(); i++) {
-      TimeData td = (TimeData) v.get(i);
+      TimeData td = v.get(i);
       res.count += td.count;
       res.elapsed += td.elapsed;
     }
@@ -111,12 +111,12 @@
   /** Get total values from all data points of all types.
    * @return a list of TimeData values for all types.
    */
-  public Vector getTotals() {
-    Collection labels = getLabels();
-    Vector v = new Vector();
-    Iterator it = labels.iterator();
+  public Vector<TimeData> getTotals() {
+    Collection<String> labels = getLabels();
+    Vector<TimeData> v = new Vector<TimeData>();
+    Iterator<String> it = labels.iterator();
     while (it.hasNext()) {
-      TimeData td = getTotals((String) it.next());
+      TimeData td = getTotals(it.next());
       v.add(td);
     }
     return v;
@@ -124,7 +124,7 @@
 
   /** Get memory usage stats for a given data type. */
   public MemUsage getMemUsage(String label) {
-    Vector v = (Vector) data.get(label);
+    Vector<TimeData> v = data.get(label);
       if (v == null)
       {
           return null;
@@ -134,7 +134,7 @@
     res.minTotal = Long.MAX_VALUE;
     long avgFree = 0L, avgTotal = 0L;
     for (int i = 0; i < v.size(); i++) {
-      TimeData td = (TimeData) v.get(i);
+      TimeData td = v.get(i);
         if (res.maxFree < td.freeMem)
         {
             res.maxFree = td.freeMem;
@@ -162,10 +162,7 @@
   /** Return a string representation. */
   public String toString() {
     StringBuffer sb = new StringBuffer();
-    Collection labels = getLabels();
-    Iterator it = labels.iterator();
-    while (it.hasNext()) {
-      String label = (String) it.next();
+    for (final String label : getLabels()) {
         sb.append(id).append("-").append(label).append(" ").append(getTotals(label).toString(false)).append(" ");
         sb.append(getMemUsage(label).toScaledString(1024 * 1024, "MB")).append("\n");
     }
