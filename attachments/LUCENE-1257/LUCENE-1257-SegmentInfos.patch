Index: src/java/org/apache/lucene/index/SegmentInfo.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentInfo.java	(revision 826188)
+++ src/java/org/apache/lucene/index/SegmentInfo.java	(working copy)
@@ -73,7 +73,7 @@
                                                   // and true for newly created merged segments (both
                                                   // compound and non compound).
   
-  private List files;                             // cached list of files that this segment uses
+  private List<String> files;                             // cached list of files that this segment uses
                                                   // in the Directory
 
   long sizeInBytes = -1;                          // total byte size of all of our files (computed on demand)
@@ -583,14 +583,14 @@
    * modify it.
    */
 
-  public List files() throws IOException {
+  public List<String> files() throws IOException {
 
     if (files != null) {
       // Already cached:
       return files;
     }
     
-    files = new ArrayList();
+    files = new ArrayList<String>();
     
     boolean useCompoundFile = getUseCompoundFile();
 
Index: src/java/org/apache/lucene/index/SegmentInfos.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentInfos.java	(revision 826188)
+++ src/java/org/apache/lucene/index/SegmentInfos.java	(working copy)
@@ -41,7 +41,7 @@
  * <p><b>NOTE:</b> This API is new and still experimental
  * (subject to change suddenly in the next release)</p>
  */
-public final class SegmentInfos extends Vector {
+public final class SegmentInfos extends Vector<SegmentInfo> {
 
   /** The file format version, a negative number. */
   /* Works since counter, the old 1st entry, is always >= 0 */
@@ -103,7 +103,7 @@
                                    // or wrote; this is normally the same as generation except if
                                    // there was an IOException that had interrupted a commit
 
-  private Map userData = Collections.EMPTY_MAP;       // Opaque Map<String, String> that user can specify during IndexWriter.commit
+  private Map<String, String> userData = Collections.emptyMap();       // Opaque Map<String, String> that user can specify during IndexWriter.commit
 
   /**
    * If non-null, information about loading segments_N files
@@ -269,10 +269,10 @@
         } else if (0 != input.readByte()) {
           userData = Collections.singletonMap("userData", input.readString());
         } else {
-          userData = Collections.EMPTY_MAP;
+          userData = Collections.emptyMap();
         }
       } else {
-        userData = Collections.EMPTY_MAP;
+        userData = Collections.emptyMap();
       }
 
       if (format <= FORMAT_CHECKSUM) {
@@ -372,9 +372,9 @@
   public Object clone() {
     SegmentInfos sis = (SegmentInfos) super.clone();
     for(int i=0;i<sis.size();i++) {
-      sis.set(i, sis.info(i).clone());
+      sis.set(i, (SegmentInfo) sis.info(i).clone());
     }
-    sis.userData = new HashMap(userData);
+    sis.userData = new HashMap<String, String>(userData);
     return sis;
   }
 
@@ -435,7 +435,7 @@
    * @throws CorruptIndexException if the index is corrupt
    * @throws IOException if there is a low-level IO error
    */
-  public static Map readCurrentUserData(Directory directory)
+  public static Map<String, String> readCurrentUserData(Directory directory)
     throws CorruptIndexException, IOException {
     SegmentInfos sis = new SegmentInfos();
     sis.read(directory);
@@ -814,8 +814,8 @@
    *  associated with any "external" segments are skipped).
    *  The returned collection is recomputed on each
    *  invocation.  */
-  public Collection files(Directory dir, boolean includeSegmentsFile) throws IOException {
-    HashSet files = new HashSet();
+  public Collection<String> files(Directory dir, boolean includeSegmentsFile) throws IOException {
+    HashSet<String> files = new HashSet<String>();
     if (includeSegmentsFile) {
       files.add(getCurrentSegmentFileName());
     }
@@ -909,13 +909,13 @@
     return buffer.toString();
   }
 
-  public Map getUserData() {
+  public Map<String, String> getUserData() {
     return userData;
   }
 
-  void setUserData(Map data) {
+  void setUserData(Map<String, String> data) {
     if (data == null) {
-      userData = Collections.EMPTY_MAP;
+      userData = Collections.emptyMap();
     } else {
       userData = data;
     }
Index: src/java/org/apache/lucene/index/CheckIndex.java
===================================================================
--- src/java/org/apache/lucene/index/CheckIndex.java	(revision 826188)
+++ src/java/org/apache/lucene/index/CheckIndex.java	(working copy)
@@ -83,13 +83,13 @@
 
     /** Empty unless you passed specific segments list to check as optional 3rd argument.
      *  @see CheckIndex#checkIndex(List) */
-    public List/*<String>*/ segmentsChecked = new ArrayList();
+    public List<String> segmentsChecked = new ArrayList<String>();
   
     /** True if the index was created with a newer version of Lucene than the CheckIndex tool. */
     public boolean toolOutOfDate;
 
     /** List of {@link SegmentInfoStatus} instances, detailing status of each segment. */
-    public List/*<SegmentInfoStatus*/ segmentInfos = new ArrayList();
+    public List<SegmentInfoStatus> segmentInfos = new ArrayList<SegmentInfoStatus>();
   
     /** Directory index is in. */
     public Directory dir;
@@ -544,7 +544,7 @@
       }
 
       // Keeper
-      result.newSegments.add(info.clone());
+      result.newSegments.add((SegmentInfo) info.clone());
     }
 
     if (0 == result.numBadSegments) {
Index: src/java/org/apache/lucene/store/IndexInput.java
===================================================================
--- src/java/org/apache/lucene/store/IndexInput.java	(revision 826188)
+++ src/java/org/apache/lucene/store/IndexInput.java	(working copy)
@@ -228,9 +228,9 @@
     return clone;
   }
 
-  // returns Map<String, String>
-  public Map readStringStringMap() throws IOException {
-    final Map map = new HashMap();
+
+  public Map<String, String> readStringStringMap() throws IOException {
+    final Map<String, String> map = new HashMap<String, String>();
     final int count = readInt();
     for(int i=0;i<count;i++) {
       final String key = readString();
