Index: src/java/org/apache/lucene/queryParser/QueryParser.java
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParser.java	(revision 827767)
+++ src/java/org/apache/lucene/queryParser/QueryParser.java	(working copy)
@@ -417,7 +417,7 @@
       return this.dateResolution;
     }
 
-    DateTools.Resolution resolution = (DateTools.Resolution) fieldToDateResolution.get(fieldName);
+    DateTools.Resolution resolution = fieldToDateResolution.get(fieldName);
     if (resolution == null) {
       // no date resolutions set for the given field; return default date resolution instead
       resolution = this.dateResolution;
Index: src/java/org/apache/lucene/queryParser/QueryParser.jj
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParser.jj	(revision 827767)
+++ src/java/org/apache/lucene/queryParser/QueryParser.jj	(working copy)
@@ -441,7 +441,7 @@
       return this.dateResolution;
     }
 
-    DateTools.Resolution resolution = (DateTools.Resolution) fieldToDateResolution.get(fieldName);
+    DateTools.Resolution resolution = fieldToDateResolution.get(fieldName);
     if (resolution == null) {
       // no date resolutions set for the given field; return default date resolution instead
       resolution = this.dateResolution;
Index: src/java/org/apache/lucene/search/FuzzyQuery.java
===================================================================
--- src/java/org/apache/lucene/search/FuzzyQuery.java	(revision 827767)
+++ src/java/org/apache/lucene/search/FuzzyQuery.java	(working copy)
@@ -153,7 +153,7 @@
             continue;
           }
 
-          reusableST = (ScoreTerm) stQueue.insertWithOverflow(reusableST);
+          reusableST =  stQueue.insertWithOverflow(reusableST);
         }
       } while (enumerator.next());
     } finally {
@@ -163,7 +163,7 @@
     BooleanQuery query = new BooleanQuery(true);
     int size = stQueue.size();
     for(int i = 0; i < size; i++){
-      ScoreTerm st = (ScoreTerm) stQueue.pop();
+      ScoreTerm st = stQueue.pop();
       TermQuery tq = new TermQuery(st.term);      // found a match
       tq.setBoost(getBoost() * st.score); // set the boost
       query.add(tq, BooleanClause.Occur.SHOULD);          // add to query
Index: src/java/org/apache/lucene/search/BooleanScorer2.java
===================================================================
--- src/java/org/apache/lucene/search/BooleanScorer2.java	(revision 827767)
+++ src/java/org/apache/lucene/search/BooleanScorer2.java	(working copy)
@@ -212,7 +212,7 @@
     if (optionalScorers.size() > nrOptRequired)
       requiredCountingSumScorer = countingDisjunctionSumScorer(optionalScorers, nrOptRequired);
     else if (optionalScorers.size() == 1)
-      requiredCountingSumScorer = new SingleMatchScorer((Scorer) optionalScorers.get(0));
+      requiredCountingSumScorer = new SingleMatchScorer(optionalScorers.get(0));
     else
       requiredCountingSumScorer = countingConjunctionSumScorer(optionalScorers);
     return addProhibitedScorers(requiredCountingSumScorer);
@@ -226,7 +226,7 @@
     } else { // optionalScorers.size() > minNrShouldMatch, and at least one required scorer
       Scorer requiredCountingSumScorer =
             requiredScorers.size() == 1
-            ? new SingleMatchScorer((Scorer) requiredScorers.get(0))
+            ? new SingleMatchScorer(requiredScorers.get(0))
             : countingConjunctionSumScorer(requiredScorers);
       if (minNrShouldMatch > 0) { // use a required disjunction scorer over the optional scorers
         return addProhibitedScorers( 
@@ -239,7 +239,7 @@
         return new ReqOptSumScorer(
                       addProhibitedScorers(requiredCountingSumScorer),
                       optionalScorers.size() == 1
-                        ? new SingleMatchScorer((Scorer) optionalScorers.get(0))
+                        ? new SingleMatchScorer(optionalScorers.get(0))
                         // require 1 in combined, optional scorer.
                         : countingDisjunctionSumScorer(optionalScorers, 1));
       }
Index: src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
===================================================================
--- src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(revision 827767)
+++ src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(working copy)
@@ -211,7 +211,7 @@
     return more && (atMatch() ||  next());
   }
 
-  private SpansCell min() { return (SpansCell)queue.top(); }
+  private SpansCell min() { return queue.top(); }
 
   public int doc() { return min().doc(); }
   public int start() { return min().start(); }
@@ -281,7 +281,7 @@
   private void queueToList() throws IOException {
     last = first = null;
     while (queue.top() != null) {
-      addToList((SpansCell)queue.pop());
+      addToList(queue.pop());
     }
   }
   
Index: src/java/org/apache/lucene/search/spans/SpanOrQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(revision 827767)
+++ src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(working copy)
@@ -54,7 +54,7 @@
 
   /** Return the clauses whose spans are matched. */
   public SpanQuery[] getClauses() {
-    return (SpanQuery[])clauses.toArray(new SpanQuery[clauses.size()]);
+    return clauses.toArray(new SpanQuery[clauses.size()]);
   }
 
   public String getField() { return field; }
@@ -151,7 +151,7 @@
 
   public Spans getSpans(final IndexReader reader) throws IOException {
     if (clauses.size() == 1)                      // optimize 1-clause case
-      return ((SpanQuery)clauses.get(0)).getSpans(reader);
+      return (clauses.get(0)).getSpans(reader);
 
     return new Spans() {
         private SpanQueue queue = null;
@@ -187,7 +187,7 @@
           return queue.size() != 0;
         }
 
-        private Spans top() { return (Spans)queue.top(); }
+        private Spans top() { return queue.top(); }
 
         public boolean skipTo(int target) throws IOException {
           if (queue == null) {
Index: src/java/org/apache/lucene/search/FuzzyTermEnum.java
===================================================================
--- src/java/org/apache/lucene/search/FuzzyTermEnum.java	(revision 827767)
+++ src/java/org/apache/lucene/search/FuzzyTermEnum.java	(working copy)
@@ -142,7 +142,7 @@
   }
   
   public final float difference() {
-    return (float)((similarity - minimumSimilarity) * scale_factor);
+    return ((similarity - minimumSimilarity) * scale_factor);
   }
   
   public final boolean endEnum() {
Index: src/java/org/apache/lucene/search/SloppyPhraseScorer.java
===================================================================
--- src/java/org/apache/lucene/search/SloppyPhraseScorer.java	(revision 827767)
+++ src/java/org/apache/lucene/search/SloppyPhraseScorer.java	(working copy)
@@ -58,9 +58,9 @@
         float freq = 0.0f;
         boolean done = (end<0);
         while (!done) {
-            PhrasePositions pp = (PhrasePositions) pq.pop();
+            PhrasePositions pp = pq.pop();
             int start = pp.position;
-            int next = ((PhrasePositions) pq.top()).position;
+            int next = (pq.top()).position;
 
             boolean tpsDiffer = true;
             for (int pos = start; pos <= next || !tpsDiffer; pos = pp.position) {
@@ -96,7 +96,7 @@
       int n=0;
       PhrasePositions pp3;
       //pop until finding pp2
-      while ((pp3=(PhrasePositions)pq.pop()) != pp2) {
+      while ((pp3=pq.pop()) != pp2) {
         tmpPos[n++] = pp3;
       }
       //insert back all but pp2
Index: src/java/org/apache/lucene/search/MultiPhraseQuery.java
===================================================================
--- src/java/org/apache/lucene/search/MultiPhraseQuery.java	(revision 827767)
+++ src/java/org/apache/lucene/search/MultiPhraseQuery.java	(working copy)
@@ -66,7 +66,7 @@
   public void add(Term[] terms) {
     int position = 0;
     if (positions.size() > 0)
-      position = ((Integer) positions.get(positions.size()-1)).intValue() + 1;
+      position = (positions.get(positions.size()-1)).intValue() + 1;
 
     add(terms, position);
   }
@@ -108,7 +108,7 @@
   public int[] getPositions() {
     int[] result = new int[positions.size()];
     for (int i = 0; i < positions.size(); i++)
-      result[i] = ((Integer) positions.get(i)).intValue();
+      result[i] = (positions.get(i)).intValue();
     return result;
   }
 
@@ -161,7 +161,7 @@
 
       TermPositions[] tps = new TermPositions[termArrays.size()];
       for (int i=0; i<tps.length; i++) {
-        Term[] terms = (Term[])termArrays.get(i);
+        Term[] terms = termArrays.get(i);
 
         TermPositions p;
         if (terms.length > 1)
@@ -250,7 +250,7 @@
 
   public Query rewrite(IndexReader reader) {
     if (termArrays.size() == 1) {                 // optimize one-term case
-      Term[] terms = (Term[])termArrays.get(0);
+      Term[] terms = termArrays.get(0);
       BooleanQuery boq = new BooleanQuery(true);
       for (int i=0; i<terms.length; i++) {
         boq.add(new TermQuery(terms[i]), BooleanClause.Occur.SHOULD);
Index: src/java/org/apache/lucene/search/PhraseScorer.java
===================================================================
--- src/java/org/apache/lucene/search/PhraseScorer.java	(revision 827767)
+++ src/java/org/apache/lucene/search/PhraseScorer.java	(working copy)
@@ -153,7 +153,7 @@
   protected final void pqToList() {
     last = first = null;
     while (pq.top() != null) {
-      PhrasePositions pp = (PhrasePositions) pq.pop();
+      PhrasePositions pp = pq.pop();
       if (last != null) {			  // add next to end of list
         last.next = pp;
       } else
Index: src/java/org/apache/lucene/search/CachingWrapperFilter.java
===================================================================
--- src/java/org/apache/lucene/search/CachingWrapperFilter.java	(revision 827767)
+++ src/java/org/apache/lucene/search/CachingWrapperFilter.java	(working copy)
@@ -72,7 +72,7 @@
     }
 
     if (cached != null) {
-      return (DocIdSet) cached;
+      return cached;
     }
 
     final DocIdSet docIdSet = docIdSetToCache(filter.getDocIdSet(reader), reader);
Index: src/java/org/apache/lucene/search/Query.java
===================================================================
--- src/java/org/apache/lucene/search/Query.java	(revision 827767)
+++ src/java/org/apache/lucene/search/Query.java	(working copy)
@@ -150,7 +150,7 @@
     }
     // optimization: if we have just one query, just return it
     if(uniques.size() == 1){
-        return (Query)uniques.iterator().next();
+        return uniques.iterator().next();
     }
     BooleanQuery result = new BooleanQuery(true);
     for (final Query query : uniques)
Index: src/java/org/apache/lucene/search/BooleanQuery.java
===================================================================
--- src/java/org/apache/lucene/search/BooleanQuery.java	(revision 827767)
+++ src/java/org/apache/lucene/search/BooleanQuery.java	(working copy)
@@ -187,7 +187,7 @@
       this.similarity = getSimilarity(searcher);
       weights = new ArrayList<Weight>(clauses.size());
       for (int i = 0 ; i < clauses.size(); i++) {
-        BooleanClause c = (BooleanClause)clauses.get(i);
+        BooleanClause c = clauses.get(i);
         weights.add(c.getQuery().createWeight(searcher));
       }
     }
@@ -202,8 +202,8 @@
     public float sumOfSquaredWeights() throws IOException {
       float sum = 0.0f;
       for (int i = 0 ; i < weights.size(); i++) {
-        BooleanClause c = (BooleanClause)clauses.get(i);
-        Weight w = (Weight)weights.get(i);
+        BooleanClause c = clauses.get(i);
+        Weight w = weights.get(i);
         // call sumOfSquaredWeights for all clauses in case of side effects
         float s = w.sumOfSquaredWeights();         // sum sub weights
         if (!c.isProhibited())
@@ -370,7 +370,7 @@
   @Override
   public Query rewrite(IndexReader reader) throws IOException {
     if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries
-      BooleanClause c = (BooleanClause)clauses.get(0);
+      BooleanClause c = clauses.get(0);
       if (!c.isProhibited()) {			  // just return clause
 
         Query query = c.getQuery().rewrite(reader);    // rewrite first
Index: src/java/org/apache/lucene/search/MultiSearcher.java
===================================================================
--- src/java/org/apache/lucene/search/MultiSearcher.java	(revision 827767)
+++ src/java/org/apache/lucene/search/MultiSearcher.java	(working copy)
@@ -198,7 +198,7 @@
 
     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
     for (int i = hq.size()-1; i >= 0; i--)	  // put docs in array
-      scoreDocs[i] = (ScoreDoc)hq.pop();
+      scoreDocs[i] = hq.pop();
     
     float maxScore = (totalHits==0) ? Float.NEGATIVE_INFINITY : scoreDocs[0].score;
     
@@ -241,7 +241,7 @@
 
     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
     for (int i = hq.size() - 1; i >= 0; i--)	  // put docs in array
-      scoreDocs[i] = (ScoreDoc) hq.pop();
+      scoreDocs[i] =  hq.pop();
 
     return new TopFieldDocs (totalHits, scoreDocs, hq.getFields(), maxScore);
   }
Index: src/java/org/apache/lucene/search/QueryWrapperFilter.java
===================================================================
--- src/java/org/apache/lucene/search/QueryWrapperFilter.java	(revision 827767)
+++ src/java/org/apache/lucene/search/QueryWrapperFilter.java	(working copy)
@@ -18,8 +18,8 @@
  */
 
 import java.io.IOException;
-import java.util.BitSet;
 
+
 import org.apache.lucene.index.IndexReader;
 
 /** 
Index: src/java/org/apache/lucene/search/TopFieldCollector.java
===================================================================
--- src/java/org/apache/lucene/search/TopFieldCollector.java	(revision 827767)
+++ src/java/org/apache/lucene/search/TopFieldCollector.java	(working copy)
@@ -939,7 +939,7 @@
       // avoid casting if unnecessary.
       FieldValueHitQueue queue = (FieldValueHitQueue) pq;
       for (int i = howMany - 1; i >= 0; i--) {
-        results[i] = queue.fillFields((Entry) queue.pop());
+        results[i] = queue.fillFields(queue.pop());
       }
     } else {
       for (int i = howMany - 1; i >= 0; i--) {
Index: src/java/org/apache/lucene/search/QueryTermVector.java
===================================================================
--- src/java/org/apache/lucene/search/QueryTermVector.java	(revision 827767)
+++ src/java/org/apache/lucene/search/QueryTermVector.java	(working copy)
@@ -68,7 +68,7 @@
             terms.add(termAtt.term());
             hasMoreTokens = stream.incrementToken();
           }
-          processTerms((String[])terms.toArray(new String[terms.size()]));
+          processTerms(terms.toArray(new String[terms.size()]));
         } catch (IOException e) {
         }
       }
Index: src/java/org/apache/lucene/search/ParallelMultiSearcher.java
===================================================================
--- src/java/org/apache/lucene/search/ParallelMultiSearcher.java	(revision 827767)
+++ src/java/org/apache/lucene/search/ParallelMultiSearcher.java	(working copy)
@@ -85,7 +85,7 @@
 
     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
     for (int i = hq.size() - 1; i >= 0; i--) // put docs in array
-      scoreDocs[i] = (ScoreDoc) hq.pop();
+      scoreDocs[i] = hq.pop();
 
     float maxScore = (totalHits==0) ? Float.NEGATIVE_INFINITY : scoreDocs[0].score;
     
@@ -133,7 +133,7 @@
 
     ScoreDoc[] scoreDocs = new ScoreDoc[hq.size()];
     for (int i = hq.size() - 1; i >= 0; i--) // put docs in array
-      scoreDocs[i] = (ScoreDoc) hq.pop();
+      scoreDocs[i] = hq.pop();
 
     return new TopFieldDocs(totalHits, scoreDocs, hq.getFields(), maxScore);
   }
Index: src/java/org/apache/lucene/search/FieldCacheImpl.java
===================================================================
--- src/java/org/apache/lucene/search/FieldCacheImpl.java	(revision 827767)
+++ src/java/org/apache/lucene/search/FieldCacheImpl.java	(working copy)
@@ -452,7 +452,7 @@
 
     protected Object createValue(IndexReader reader, Entry entryKey)
         throws IOException {
-      Entry entry = (Entry) entryKey;
+      Entry entry = entryKey;
       String field = entry.field;
       FieldCache.LongParser parser = (FieldCache.LongParser) entry.custom;
       if (parser == null) {
@@ -556,7 +556,7 @@
 
     protected Object createValue(IndexReader reader, Entry entryKey)
         throws IOException {
-      String field = StringHelper.intern((String) entryKey.field);
+      String field = StringHelper.intern(entryKey.field);
       final String[] retArray = new String[reader.maxDoc()];
       TermDocs termDocs = reader.termDocs();
       TermEnum termEnum = reader.terms (new Term (field));
@@ -591,7 +591,7 @@
 
     protected Object createValue(IndexReader reader, Entry entryKey)
         throws IOException {
-      String field = StringHelper.intern((String) entryKey.field);
+      String field = StringHelper.intern(entryKey.field);
       final int[] retArray = new int[reader.maxDoc()];
       String[] mterms = new String[reader.maxDoc()+1];
       TermDocs termDocs = reader.termDocs();
Index: src/java/org/apache/lucene/search/DefaultSimilarity.java
===================================================================
--- src/java/org/apache/lucene/search/DefaultSimilarity.java	(revision 827767)
+++ src/java/org/apache/lucene/search/DefaultSimilarity.java	(working copy)
@@ -37,7 +37,7 @@
       numTerms = state.getLength() - state.getNumOverlap();
     else
       numTerms = state.getLength();
-    return (float) (state.getBoost() * lengthNorm(field, numTerms));
+    return (state.getBoost() * lengthNorm(field, numTerms));
   }
   
   /** Implemented as <code>1/sqrt(numTerms)</code>. */
Index: src/java/org/apache/lucene/store/RAMFile.java
===================================================================
--- src/java/org/apache/lucene/store/RAMFile.java	(revision 827767)
+++ src/java/org/apache/lucene/store/RAMFile.java	(working copy)
@@ -71,7 +71,7 @@
   }
 
   final synchronized byte[] getBuffer(int index) {
-    return (byte[]) buffers.get(index);
+    return buffers.get(index);
   }
 
   final synchronized int numBuffers() {
Index: src/java/org/apache/lucene/store/RAMInputStream.java
===================================================================
--- src/java/org/apache/lucene/store/RAMInputStream.java	(revision 827767)
+++ src/java/org/apache/lucene/store/RAMInputStream.java	(working copy)
@@ -92,7 +92,7 @@
         bufferPosition = BUFFER_SIZE;
       }
     } else {
-      currentBuffer = (byte[]) file.getBuffer(currentBufferIndex);
+      currentBuffer = file.getBuffer(currentBufferIndex);
       bufferPosition = 0;
       bufferStart = (long) BUFFER_SIZE * (long) currentBufferIndex;
       long buflen = length - bufferStart;
Index: src/java/org/apache/lucene/store/RAMOutputStream.java
===================================================================
--- src/java/org/apache/lucene/store/RAMOutputStream.java	(revision 827767)
+++ src/java/org/apache/lucene/store/RAMOutputStream.java	(working copy)
@@ -61,7 +61,7 @@
       if (nextPos > end) {                        // at the last buffer
         length = (int)(end - pos);
       }
-      out.writeBytes((byte[])file.getBuffer(buffer++), length);
+      out.writeBytes(file.getBuffer(buffer++), length);
       pos = nextPos;
     }
   }
@@ -126,7 +126,7 @@
     if (currentBufferIndex == file.numBuffers()) {
       currentBuffer = file.addBuffer(BUFFER_SIZE);
     } else {
-      currentBuffer = (byte[]) file.getBuffer(currentBufferIndex);
+      currentBuffer = file.getBuffer(currentBufferIndex);
     }
     bufferPosition = 0;
     bufferStart = (long) BUFFER_SIZE * (long) currentBufferIndex;
Index: src/java/org/apache/lucene/util/ReaderUtil.java
===================================================================
--- src/java/org/apache/lucene/util/ReaderUtil.java	(revision 827767)
+++ src/java/org/apache/lucene/util/ReaderUtil.java	(working copy)
@@ -56,7 +56,7 @@
   public static IndexReader subReader(int doc, IndexReader reader) {
     List<IndexReader> subReadersList = new ArrayList<IndexReader>();
     ReaderUtil.gatherSubReaders(subReadersList, reader);
-    IndexReader[] subReaders = (IndexReader[]) subReadersList
+    IndexReader[] subReaders = subReadersList
         .toArray(new IndexReader[subReadersList.size()]);
     int[] docStarts = new int[subReaders.length];
     int maxDoc = 0;
@@ -77,7 +77,7 @@
   public static IndexReader subReader(IndexReader reader, int subIndex) {
     List<IndexReader> subReadersList = new ArrayList<IndexReader>();
     ReaderUtil.gatherSubReaders(subReadersList, reader);
-    IndexReader[] subReaders = (IndexReader[]) subReadersList
+    IndexReader[] subReaders = subReadersList
         .toArray(new IndexReader[subReadersList.size()]);
     return subReaders[subIndex];
   }
