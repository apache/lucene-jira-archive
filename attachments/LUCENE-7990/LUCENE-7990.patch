Index: lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeo3dShapeGenerator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeo3dShapeGenerator.java	(revision dfd13624c2b00ef5128417e32eaf9caa691af5fa)
+++ lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeo3dShapeGenerator.java	(revision )
@@ -19,9 +19,9 @@
 
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 import org.apache.lucene.util.LuceneTestCase;
 
@@ -852,84 +852,38 @@
   /**
    * Method that orders a lit of points anti-clock-wise to prevent crossing edges.
    *
-   * @param originalPoints The points to order.
+   * @param points The points to order.
    * @return The list of ordered points anti-clockwise.
    */
-  private List<GeoPoint> orderPoints(List<GeoPoint> originalPoints){
-    List<GeoPoint> points = new ArrayList<>(originalPoints.size());
-    points.addAll(originalPoints); //make a copy
-    GeoPoint lPoint = getPointLefLon(points);
-    points.remove(lPoint);
-    GeoPoint rPoint = getPointRigthLon(points);
-    points.remove(rPoint);
-    List<GeoPoint> APoints = getPointsBelowAndSort(points, lPoint);
-    List<GeoPoint> BPoints = getPointsAboveAndsort(points, lPoint);
-    List<GeoPoint> result = new ArrayList<>();
-    result.add(lPoint);
-    result.addAll(APoints);
-    result.add(rPoint);
-    result.addAll(BPoints);
-    return result;
-  }
-
-  private List<GeoPoint> getPointsAboveAndsort(List<GeoPoint> points,GeoPoint lPoint) {
-    List<GeoPoint> BPoints = new ArrayList<>();
-    for (GeoPoint point : points){
-      if(point.getLatitude() > lPoint.getLatitude()){
-        BPoints.add(point);
-      }
+  private List<GeoPoint> orderPoints(List<GeoPoint> points) {
+    double x = 0;
+    double y = 0;
+    double z = 0;
+    //get center of mass
+    for (GeoPoint point : points) {
+      x += point.x;
+      y += point.y;
+      z += point.z;
     }
-    Collections.sort(BPoints, new Comparator<GeoPoint>() {
-      public int compare(GeoPoint idx1, GeoPoint idx2) {
-        return Double.compare(idx1.getLongitude(), idx2.getLongitude());
-      }
-    });
-    return BPoints;
-  }
-
-  private List<GeoPoint> getPointsBelowAndSort(List<GeoPoint> points,GeoPoint lPoint) {
-    List<GeoPoint> APoints = new ArrayList<>();
-    for (GeoPoint point : points){
-      if(point.getLatitude() < lPoint.getLatitude()){
-        APoints.add(point);
-      }
+    Map<Double, GeoPoint> pointWithAngle = new HashMap<>();
+    //get angle respect center of mass
+    for (GeoPoint point : points) {
+      GeoPoint center = new GeoPoint(x / points.size(), y / points.size(), z / points.size());
+      double cs = Math.sin(center.getLatitude()) * Math.sin(point.getLatitude())
+          + Math.cos(center.getLatitude()) * Math.cos(point.getLatitude())  * Math.cos(point.getLongitude() - center.getLongitude());
+      double posAng = Math.atan2(Math.cos(center.getLatitude()) * Math.cos(point.getLatitude()) * Math.sin(point.getLongitude() - center.getLongitude()),
+          Math.sin(point.getLatitude()) - Math.sin(center.getLatitude())*cs);
+      pointWithAngle.put(posAng, point);
+    }
+    //order points
+    List<Double> angles = new ArrayList<>(pointWithAngle.keySet());
+    Collections.sort(angles);
+    Collections.reverse(angles);
+    List<GeoPoint> orderedPoints = new ArrayList<>();
+    for (Double d : angles) {
+      orderedPoints.add(pointWithAngle.get(d));
     }
-    Collections.sort(APoints, new Comparator<GeoPoint>() {
-      public int compare(GeoPoint idx1, GeoPoint idx2) {
-        return Double.compare(idx1.getLongitude(), idx2.getLongitude());
-      }
-    });
-    return APoints;
-  }
-
-  private GeoPoint getPointLefLon(List<GeoPoint> points)  {
-    GeoPoint lPoint = null;
-    for (GeoPoint point : points){
-      if(lPoint == null ){
-        lPoint = point;
-      }
-      else{
-        if (lPoint.getLongitude() > point.getLongitude()){
-          lPoint = point;
-        }
-      }
-    }
-    return lPoint;
-  }
-
-  private GeoPoint getPointRigthLon(List<GeoPoint> points) {
-    GeoPoint rPoint = null;
-    for (GeoPoint point : points){
-      if(rPoint == null ){
-        rPoint = point;
-      }
-      else{
-        if (rPoint.getLongitude() < point.getLongitude()){
-          rPoint = point;
-        }
-      }
-    }
-    return rPoint;
+    return orderedPoints;
   }
 
   /**
