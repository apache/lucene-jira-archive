Index: lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoCircleTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoCircleTest.java	(revision d84beb415cebc3f144fdd068c2728d5468d8c343)
+++ lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoCircleTest.java	(revision )
@@ -16,6 +16,7 @@
  */
 package org.apache.lucene.spatial3d.geom;
 
+import com.carrotsearch.randomizedtesting.annotations.Repeat;
 import org.apache.lucene.util.LuceneTestCase;
 import org.junit.Test;
 
@@ -418,5 +419,39 @@
     assert gc.isWithin(gp)?solid.isWithin(gp):true;
     
   }
+
+  @Test
+  @Repeat(iterations = 100)
+  public void RandomPointBearingWGS84Test(){
+    PlanetModel planetModel = PlanetModel.WGS84;
+    RandomGeo3dShapeGenerator generator = new RandomGeo3dShapeGenerator();
+    GeoPoint center = generator.randomGeoPoint(planetModel);
+    double radius = random().nextDouble() * Math.PI;
+    checkBearingPoint(planetModel, center, radius, 0);
+    checkBearingPoint(planetModel, center, radius, 0.5 * Math.PI);
+    checkBearingPoint(planetModel, center, radius, Math.PI);
+    checkBearingPoint(planetModel, center, radius, 1.5 * Math.PI);
+  }
+
+  @Test
+  @Repeat(iterations = 10000)
+  public void RandomPointBearingCardinalTest(){
+    double ab = random().nextDouble() * 0.6 + 0.9;
+    double c = random().nextDouble() * 0.6  + 0.9 ;
+    PlanetModel planetModel = new PlanetModel(ab, c);
+    RandomGeo3dShapeGenerator generator = new RandomGeo3dShapeGenerator();
+    GeoPoint center = generator.randomGeoPoint(planetModel);
+    double radius =  random().nextDouble() * 0.9 * Math.PI;
+    checkBearingPoint(planetModel, center, radius, 0);
+    checkBearingPoint(planetModel, center, radius, 0.5 * Math.PI);
+    checkBearingPoint(planetModel, center, radius, Math.PI);
+    checkBearingPoint(planetModel, center, radius, 1.5 * Math.PI);
+  }
+
+  private void checkBearingPoint(PlanetModel planetModel, GeoPoint center, double radius, double bearingAngle) {
+    GeoPoint point = planetModel.surfacePointOnBearing(center, radius, bearingAngle);
+    double surfaceDistance = planetModel.surfaceDistance(center, point);
+    assertTrue(planetModel.toString() + " " + Double.toString(surfaceDistance - radius) + " " + Double.toString(radius), surfaceDistance - radius < Vector.MINIMUM_ANGULAR_RESOLUTION);
+  }
   
 }
Index: lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java	(revision d84beb415cebc3f144fdd068c2728d5468d8c343)
+++ lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel.java	(revision )
@@ -368,7 +368,7 @@
           B / 6.0 * cos2σM * (-3.0 + 4.0 * sinσ * sinσ) * (-3.0 + 4.0 * cos2σM * cos2σM)));
       σʹ = σ;
       σ = dist / (c * A) + Δσ;
-    } while (Math.abs(σ - σʹ) > Vector.MINIMUM_ANGULAR_RESOLUTION && ++iterations < 200);
+    } while (Math.abs(σ - σʹ) > Vector.MINIMUM_RESOLUTION && ++iterations < 40);
 
     double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;
     double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1.0 - flattening) * Math.sqrt(sinα * sinα + x * x));
