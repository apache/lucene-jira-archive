
Property changes on: .
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0:r912383


Property changes on: build.xml
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/build.xml:r912383

Index: CHANGES.txt
===================================================================
--- CHANGES.txt	(revision 912370)
+++ CHANGES.txt	(working copy)
@@ -50,10 +50,16 @@
 
 API Changes
 
- * LUCENE-2190: Added setNextReader method to CustomScoreQuery, which
-   is necessary with per-segment searching to notify the subclass
-   which reader the int doc, passed to customScore, refers to.  (Paul
-   chez Jamespot via Mike McCandless)
+ * LUCENE-2190: Added a new class CustomScoreProvider to function package
+   that can be subclassed to provide custom scoring to CustomScoreQuery.
+   The methods in CustomScoreQuery that did this before were deprecated
+   and replaced by a method getCustomScoreProvider(IndexReader) that
+   returns a custom score implementation using the above class. The change
+   is necessary with per-segment searching, as CustomScoreQuery is
+   a stateless class (like all other Queries) and does not know about
+   the currently searched segment. This API works similar to Filter's
+   getDocIdSet(IndexReader).  (Paul chez Jamespot via Mike McCandless,
+   Uwe Schindler)
 
  * LUCENE-2080: Deprecate Version.LUCENE_CURRENT, as using this constant
    will cause backwards compatibility problems when upgrading Lucene. See

Property changes on: CHANGES.txt
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/CHANGES.txt:r912383

Index: common-build.xml
===================================================================
--- common-build.xml	(revision 912370)
+++ common-build.xml	(working copy)
@@ -595,6 +595,10 @@
           bottom="Copyright &amp;copy; ${year} Apache Software Foundation.  All Rights Reserved.">
         <tag name="todo" description="To Do:"/>
         <tag name="uml.property" description="UML Property:"/>
+        <tag name="lucene.experimental" 
+      	description="WARNING: This API is experimental and might change in incompatible ways in the next release."/>
+        <tag name="lucene.internal"
+        description="NOTE: This API is for Lucene internal purposes only and might change in incompatible ways in the next release."/>
       	<link offline="true" packagelistLoc="${javadoc.dir}"/>
       	
       	<sources />

Property changes on: contrib
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/contrib:r912383


Property changes on: contrib\CHANGES.txt
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/contrib/CHANGES.txt:r912383


Property changes on: contrib\highlighter\src\test
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/contrib/highlighter/src/test:r912383


Property changes on: contrib\instantiated\src\test\org\apache\lucene\store\instantiated\TestIndicesEquals.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/contrib/instantiated/src/test/org/apache/lucene/store/instantiated/TestIndicesEquals.java:r912383

Index: contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
===================================================================
--- contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java	(revision 912370)
+++ contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java	(working copy)
@@ -27,6 +27,7 @@
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.Hits;
 import org.apache.lucene.search.IndexSearcher;
@@ -35,6 +36,7 @@
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.function.CustomScoreQuery;
+import org.apache.lucene.search.function.CustomScoreProvider;
 import org.apache.lucene.search.function.FieldScoreQuery;
 import org.apache.lucene.search.function.FieldScoreQuery.Type;
 import org.apache.lucene.util.NumericUtils;
@@ -164,23 +166,27 @@
       FieldScoreQuery fsQuery = new FieldScoreQuery("geo_distance", Type.FLOAT);
     
       CustomScoreQuery customScore = new CustomScoreQuery(dq.getQuery(tq),fsQuery){
-      
-          @Override
+        @Override
+        protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) {
+          return new CustomScoreProvider(reader) {
+            @Override // TODO: broken, as reader is not used!
             public float customScore(int doc, float subQueryScore, float valSrcScore){
-            //System.out.println(doc);
-            if (dq.distanceFilter.getDistance(doc) == null)
-              return 0;
-        
-            double distance = dq.distanceFilter.getDistance(doc);
-            // boost score shouldn't exceed 1
-            if (distance < 1.0d)
-              distance = 1.0d;
-            //boost by distance is invertly proportional to
-            // to distance from center point to location
-            float score = new Float((miles - distance) / miles ).floatValue();
-            return score * subQueryScore;
-          }
-        };
+              //System.out.println(doc);
+              if (dq.distanceFilter.getDistance(doc) == null)
+                return 0;
+          
+              double distance = dq.distanceFilter.getDistance(doc);
+              // boost score shouldn't exceed 1
+              if (distance < 1.0d)
+                distance = 1.0d;
+              //boost by distance is invertly proportional to
+              // to distance from center point to location
+              float score = new Float((miles - distance) / miles ).floatValue();
+              return score * subQueryScore;
+            }
+          };
+        }
+      };
       // Create a distance sort
       // As the radius filter has performed the distance calculations
       // already, pass in the filter to reuse the results.
@@ -253,23 +259,27 @@
 	    
       FieldScoreQuery fsQuery = new FieldScoreQuery("geo_distance", Type.FLOAT);
       CustomScoreQuery customScore = new CustomScoreQuery(tq,fsQuery){
-	      
-          @Override
+        @Override
+        protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) {
+          return new CustomScoreProvider(reader) {
+            @Override // TODO: broken, as reader is not used!
             public float customScore(int doc, float subQueryScore, float valSrcScore){
-            //System.out.println(doc);
-            if (dq.distanceFilter.getDistance(doc) == null)
-              return 0;
-	        
-            double distance = dq.distanceFilter.getDistance(doc);
-            // boost score shouldn't exceed 1
-            if (distance < 1.0d)
-              distance = 1.0d;
-            //boost by distance is invertly proportional to
-            // to distance from center point to location
-            float score = new Float((miles - distance) / miles ).floatValue();
-            return score * subQueryScore;
-          }
-        };
+              //System.out.println(doc);
+              if (dq.distanceFilter.getDistance(doc) == null)
+                return 0;
+            
+              double distance = dq.distanceFilter.getDistance(doc);
+              // boost score shouldn't exceed 1
+              if (distance < 1.0d)
+                distance = 1.0d;
+              //boost by distance is invertly proportional to
+              // to distance from center point to location
+              float score = (float) ( (miles - distance) / miles );
+              return score * subQueryScore;
+            }
+          };
+        }
+      };
       // Create a distance sort
       // As the radius filter has performed the distance calculations
       // already, pass in the filter to reuse the results.

Property changes on: src\java\org\apache\lucene\analysis\Tokenizer.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/java/org/apache/lucene/analysis/Tokenizer.java:r912383

Index: src/java/org/apache/lucene/search/function/CustomScoreQuery.java
===================================================================
--- src/java/org/apache/lucene/search/function/CustomScoreQuery.java	(revision 912370)
+++ src/java/org/apache/lucene/search/function/CustomScoreQuery.java	(working copy)
@@ -38,7 +38,7 @@
  *        For most simple/convenient use cases this query is likely to be a 
  *        {@link org.apache.lucene.search.function.FieldScoreQuery FieldScoreQuery}</li>
  * </ol>
- * Subclasses can modify the computation by overriding {@link #customScore(int, float, float)}.
+ * Subclasses can modify the computation by overriding {@link #getCustomScoreProvider}.
  * 
  * <p><font color="#FF0000">
  * WARNING: The status of the <b>search.function</b> package is experimental. 
@@ -81,7 +81,6 @@
    * This parameter is optional - it can be null or even an empty array.
    */
   public CustomScoreQuery(Query subQuery, ValueSourceQuery valSrcQueries[]) {
-    super();
     this.subQuery = subQuery;
     this.valSrcQueries = valSrcQueries!=null?
         valSrcQueries : new ValueSourceQuery[0];
@@ -90,11 +89,23 @@
 
   /*(non-Javadoc) @see org.apache.lucene.search.Query#rewrite(org.apache.lucene.index.IndexReader) */
   public Query rewrite(IndexReader reader) throws IOException {
-    subQuery = subQuery.rewrite(reader);
+    CustomScoreQuery clone = null;
+    
+    final Query sq = subQuery.rewrite(reader);
+    if (sq != subQuery) {
+      clone = (CustomScoreQuery) clone();
+      clone.subQuery = sq;
+    }
+
     for(int i = 0; i < valSrcQueries.length; i++) {
-      valSrcQueries[i] = (ValueSourceQuery) valSrcQueries[i].rewrite(reader);
+      final ValueSourceQuery v = (ValueSourceQuery) valSrcQueries[i].rewrite(reader);
+      if (v != valSrcQueries[i]) {
+        if (clone == null) clone = (CustomScoreQuery) clone();
+        clone.valSrcQueries[i] = v;
+      }
     }
-    return this;
+    
+    return (clone == null) ? this : clone;
   }
 
   /*(non-Javadoc) @see org.apache.lucene.search.Query#extractTerms(java.util.Set) */
@@ -135,7 +146,8 @@
     }
     CustomScoreQuery other = (CustomScoreQuery)o;
     if (this.getBoost() != other.getBoost() ||
-        !this.subQuery.equals(other.subQuery)||
+        !this.subQuery.equals(other.subQuery) ||
+        this.strict != other.strict ||
         this.valSrcQueries.length != other.valSrcQueries.length) {
       return false;
     }
@@ -153,31 +165,48 @@
     for (int i=0; i<valSrcQueries.length; i++) { //TODO simplify with Arrays.deepHashcode() once moving to Java 1.5
       valSrcHash += valSrcQueries[i].hashCode();
     }
-    return (getClass().hashCode() + subQuery.hashCode() + valSrcHash) ^ Float.floatToIntBits(getBoost());
+    return (getClass().hashCode() + subQuery.hashCode() + valSrcHash) ^
+      Float.floatToIntBits(getBoost()) ^ (strict ? 1234 : 4321);
   }  
   
   /**
+   * Returns a {@link CustomScoreProvider} that calculates the custom scores
+   * for the given {@link IndexReader}. The default implementation returns a default
+   * implementation as specified in the docs of {@link CustomScoreProvider}.
+   * @since 2.9.2
+   */
+  protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) throws IOException {
+    // when deprecated methods are removed, do not extend class here, just return new default CustomScoreProvider
+    return new CustomScoreProvider(reader) {
+      
+      public float customScore(int doc, float subQueryScore, float valSrcScores[]) throws IOException {
+        return CustomScoreQuery.this.customScore(doc, subQueryScore, valSrcScores);
+      }
+      
+      public float customScore(int doc, float subQueryScore, float valSrcScore) throws IOException {
+        return CustomScoreQuery.this.customScore(doc, subQueryScore, valSrcScore);
+      }
+      
+      public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) throws IOException {
+        return CustomScoreQuery.this.customExplain(doc, subQueryExpl, valSrcExpls);
+      }
+      
+      public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) throws IOException {
+        return CustomScoreQuery.this.customExplain(doc, subQueryExpl, valSrcExpl);
+      }
+      
+    };
+  }
+
+  /**
    * Compute a custom score by the subQuery score and a number of 
    * ValueSourceQuery scores.
-   * <p> 
-   * Subclasses can override this method to modify the custom score.  
-   * <p>
-   * If your custom scoring is different than the default herein you 
-   * should override at least one of the two customScore() methods.
-   * If the number of ValueSourceQueries is always &lt; 2 it is 
-   * sufficient to override the other 
-   * {@link #customScore(int, float, float) customScore()} 
-   * method, which is simpler. 
-   * <p>
-   * The default computation herein is a multiplication of given scores:
-   * <pre>
-   *     ModifiedScore = valSrcScore * valSrcScores[0] * valSrcScores[1] * ...
-   * </pre>
-   * 
-   * @param doc id of scored doc. 
-   * @param subQueryScore score of that doc by the subQuery.
-   * @param valSrcScores scores of that doc by the ValueSourceQuery.
-   * @return custom score.
+   * @deprecated Will be removed in Lucene 3.1.
+   * The doc is relative to the current reader, which is
+   * unknown to CustomScoreQuery when using per-segment search (since Lucene 2.9).
+   * Please override {@link #getCustomScoreProvider} and return a subclass
+   * of {@link CustomScoreProvider} for the given {@link IndexReader}.
+   * @see CustomScoreProvider#customScore(int,float,float[])
    */
   public float customScore(int doc, float subQueryScore, float valSrcScores[]) {
     if (valSrcScores.length == 1) {
@@ -195,50 +224,25 @@
 
   /**
    * Compute a custom score by the subQuery score and the ValueSourceQuery score.
-   * <p> 
-   * Subclasses can override this method to modify the custom score.
-   * <p>
-   * If your custom scoring is different than the default herein you 
-   * should override at least one of the two customScore() methods.
-   * If the number of ValueSourceQueries is always &lt; 2 it is 
-   * sufficient to override this customScore() method, which is simpler. 
-   * <p>
-   * The default computation herein is a multiplication of the two scores:
-   * <pre>
-   *     ModifiedScore = subQueryScore * valSrcScore
-   * </pre>
-   *
-   * <p><b>NOTE</b>: The doc is relative to the current
-   * reader, last passed to {@link #setNextReader}.
-   * 
-   * @param doc id of scored doc. 
-   * @param subQueryScore score of that doc by the subQuery.
-   * @param valSrcScore score of that doc by the ValueSourceQuery.
-   * @return custom score.
+   * @deprecated Will be removed in Lucene 3.1.
+   * The doc is relative to the current reader, which is
+   * unknown to CustomScoreQuery when using per-segment search (since Lucene 2.9).
+   * Please override {@link #getCustomScoreProvider} and return a subclass
+   * of {@link CustomScoreProvider} for the given {@link IndexReader}.
+   * @see CustomScoreProvider#customScore(int,float,float)
    */
   public float customScore(int doc, float subQueryScore, float valSrcScore) {
     return subQueryScore * valSrcScore;
   }
 
   /**
-   * Called when the scoring switches to another reader.
-   * 
-   * @param reader
-   *          next IndexReader
-   */
-  public void setNextReader(IndexReader reader) throws IOException {
-  }
-
-  /**
    * Explain the custom score.
-   * Whenever overriding {@link #customScore(int, float, float[])}, 
-   * this method should also be overridden to provide the correct explanation
-   * for the part of the custom scoring.
-   *  
-   * @param doc doc being explained.
-   * @param subQueryExpl explanation for the sub-query part.
-   * @param valSrcExpls explanation for the value source part.
-   * @return an explanation for the custom score
+   * @deprecated Will be removed in Lucene 3.1.
+   * The doc is relative to the current reader, which is
+   * unknown to CustomScoreQuery when using per-segment search (since Lucene 2.9).
+   * Please override {@link #getCustomScoreProvider} and return a subclass
+   * of {@link CustomScoreProvider} for the given {@link IndexReader}.
+   * @see CustomScoreProvider#customExplain(int,Explanation,Explanation[])
    */
   public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) {
     if (valSrcExpls.length == 1) {
@@ -261,14 +265,12 @@
 
   /**
    * Explain the custom score.
-   * Whenever overriding {@link #customScore(int, float, float)}, 
-   * this method should also be overridden to provide the correct explanation
-   * for the part of the custom scoring.
-   *  
-   * @param doc doc being explained.
-   * @param subQueryExpl explanation for the sub-query part.
-   * @param valSrcExpl explanation for the value source part.
-   * @return an explanation for the custom score
+   * @deprecated Will be removed in Lucene 3.1.
+   * The doc is relative to the current reader, which is
+   * unknown to CustomScoreQuery when using per-segment search (since Lucene 2.9).
+   * Please override {@link #getCustomScoreProvider} and return a subclass
+   * of {@link CustomScoreProvider} for the given {@link IndexReader}.
+   * @see CustomScoreProvider#customExplain(int,Explanation,Explanation[])
    */
   public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) {
     float valSrcScore = 1;
@@ -372,7 +374,7 @@
       for(int i = 0; i < valSrcScorers.length; i++) {
         valSrcExpls[i] = valSrcScorers[i].explain(doc);
       }
-      Explanation customExp = customExplain(doc,subQueryExpl,valSrcExpls);
+      Explanation customExp = CustomScoreQuery.this.getCustomScoreProvider(reader).customExplain(doc,subQueryExpl,valSrcExpls);
       float sc = getValue() * customExp.getValue();
       Explanation res = new ComplexExplanation(
         true, sc, CustomScoreQuery.this.toString() + ", product of:");
@@ -399,6 +401,7 @@
     private Scorer subQueryScorer;
     private Scorer[] valSrcScorers;
     private IndexReader reader;
+    private final CustomScoreProvider provider;
     private float vScores[]; // reused in score() to avoid allocating this array for each doc 
 
     // constructor
@@ -411,7 +414,7 @@
       this.valSrcScorers = valSrcScorers;
       this.reader = reader;
       this.vScores = new float[valSrcScorers.length];
-      setNextReader(reader);
+      this.provider = CustomScoreQuery.this.getCustomScoreProvider(reader);
     }
 
     /** @deprecated use {@link #nextDoc()} instead. */
@@ -443,7 +446,7 @@
       for (int i = 0; i < valSrcScorers.length; i++) {
         vScores[i] = valSrcScorers[i].score();
       }
-      return qWeight * customScore(subQueryScorer.docID(), subQueryScorer.score(), vScores);
+      return qWeight * provider.customScore(subQueryScorer.docID(), subQueryScorer.score(), vScores);
     }
 
     /** @deprecated use {@link #advance(int)} instead. */

Property changes on: src\java\org\apache\lucene\search\MultiTermQueryWrapperFilter.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java:r912383


Property changes on: src\java\org\apache\lucene\util\AttributeSource.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/java/org/apache/lucene/util/AttributeSource.java:r912383


Property changes on: src\test\org\apache\lucene\analysis\BaseTokenStreamTestCase.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/test/org/apache/lucene/analysis/BaseTokenStreamTestCase.java:r912383


Property changes on: src\test\org\apache\lucene\analysis\TestISOLatin1AccentFilter.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/test/org/apache/lucene/analysis/TestISOLatin1AccentFilter.java:r912383


Property changes on: src\test\org\apache\lucene\document\TestDateTools.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/test/org/apache/lucene/document/TestDateTools.java:r912383


Property changes on: src\test\org\apache\lucene\document\TestNumberTools.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/test/org/apache/lucene/document/TestNumberTools.java:r912383


Property changes on: src\test\org\apache\lucene\index\TestBackwardsCompatibility.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java:r912383

Index: src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java
===================================================================
--- src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java	(revision 912370)
+++ src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java	(working copy)
@@ -74,29 +74,34 @@
   // must have static class otherwise serialization tests fail
   private static class CustomAddQuery extends CustomScoreQuery {
     // constructor
-    CustomAddQuery (Query q, ValueSourceQuery qValSrc) {
-      super(q,qValSrc);
+    CustomAddQuery(Query q, ValueSourceQuery qValSrc) {
+      super(q, qValSrc);
     }
+
     /*(non-Javadoc) @see org.apache.lucene.search.function.CustomScoreQuery#name() */
     public String name() {
       return "customAdd";
     }
-    /*(non-Javadoc) @see org.apache.lucene.search.function.CustomScoreQuery#customScore(int, float, float) */
-    public float customScore(int doc, float subQueryScore, float valSrcScore) {
-      return subQueryScore + valSrcScore;
+    
+    protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) {
+      return new CustomScoreProvider(reader) {
+        public float customScore(int doc, float subQueryScore, float valSrcScore) {
+          return subQueryScore + valSrcScore;
+        }
+
+        public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) {
+          float valSrcScore = valSrcExpl == null ? 0 : valSrcExpl.getValue();
+          Explanation exp = new Explanation(valSrcScore + subQueryExpl.getValue(), "custom score: sum of:");
+          exp.addDetail(subQueryExpl);
+          if (valSrcExpl != null) {
+            exp.addDetail(valSrcExpl);
+          }
+          return exp;
+        }
+      };
     }
-    /* (non-Javadoc)@see org.apache.lucene.search.function.CustomScoreQuery#customExplain(int, org.apache.lucene.search.Explanation, org.apache.lucene.search.Explanation)*/
-    public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) {
-      float valSrcScore = valSrcExpl==null ? 0 : valSrcExpl.getValue();
-      Explanation exp = new Explanation( valSrcScore + subQueryExpl.getValue(), "custom score: sum of:");
-      exp.addDetail(subQueryExpl);
-      if (valSrcExpl != null) {
-        exp.addDetail(valSrcExpl);
-      }
-      return exp;      
-    } 
   }
-  
+
   // must have static class otherwise serialization tests fail
   private static class CustomMulAddQuery extends CustomScoreQuery {
     // constructor
@@ -108,50 +113,52 @@
       return "customMulAdd";
     }
     /*(non-Javadoc) @see org.apache.lucene.search.function.CustomScoreQuery#customScore(int, float, float) */
-    public float customScore(int doc, float subQueryScore, float valSrcScores[]) {
-      if (valSrcScores.length == 0) {
-        return subQueryScore;
-      }
-      if (valSrcScores.length == 1) {
-        return subQueryScore + valSrcScores[0];
-        // confirm that skipping beyond the last doc, on the
-        // previous reader, hits NO_MORE_DOCS
-      }
-      return (subQueryScore + valSrcScores[0]) * valSrcScores[1]; // we know there are two
-    } 
-    /* (non-Javadoc)@see org.apache.lucene.search.function.CustomScoreQuery#customExplain(int, org.apache.lucene.search.Explanation, org.apache.lucene.search.Explanation)*/
-    public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) {
-      if (valSrcExpls.length == 0) {
-        return subQueryExpl;
-      }
-      Explanation exp = new Explanation(valSrcExpls[0].getValue() + subQueryExpl.getValue(), "sum of:");
-      exp.addDetail(subQueryExpl);
-      exp.addDetail(valSrcExpls[0]);
-      if (valSrcExpls.length == 1) {
-        exp.setDescription("CustomMulAdd, sum of:");
-        return exp;
-      }
-      Explanation exp2 = new Explanation(valSrcExpls[1].getValue() * exp.getValue(), "custom score: product of:");
-      exp2.addDetail(valSrcExpls[1]);
-      exp2.addDetail(exp);
-      return exp2;      
-    } 
+    protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) {
+      return new CustomScoreProvider(reader) {
+        public float customScore(int doc, float subQueryScore, float valSrcScores[]) {
+          if (valSrcScores.length == 0) {
+            return subQueryScore;
+          }
+          if (valSrcScores.length == 1) {
+            return subQueryScore + valSrcScores[0];
+            // confirm that skipping beyond the last doc, on the
+            // previous reader, hits NO_MORE_DOCS
+          }
+          return (subQueryScore + valSrcScores[0]) * valSrcScores[1]; // we know there are two
+        }
+
+        public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) {
+          if (valSrcExpls.length == 0) {
+            return subQueryExpl;
+          }
+          Explanation exp = new Explanation(valSrcExpls[0].getValue() + subQueryExpl.getValue(), "sum of:");
+          exp.addDetail(subQueryExpl);
+          exp.addDetail(valSrcExpls[0]);
+          if (valSrcExpls.length == 1) {
+            exp.setDescription("CustomMulAdd, sum of:");
+            return exp;
+          }
+          Explanation exp2 = new Explanation(valSrcExpls[1].getValue() * exp.getValue(), "custom score: product of:");
+          exp2.addDetail(valSrcExpls[1]);
+          exp2.addDetail(exp);
+          return exp2;
+        }
+      };
+    }
   }
 
   private final class CustomExternalQuery extends CustomScoreQuery {
-    private IndexReader reader;
-    private int[] values;
 
-    public float customScore(int doc, float subScore, float valSrcScore) {
-      assertTrue(doc <= reader.maxDoc());
-      return (float) values[doc];
+    protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) throws IOException {
+      final int[] values = FieldCache.DEFAULT.getInts(reader, INT_FIELD);
+      return new CustomScoreProvider(reader) {
+        public float customScore(int doc, float subScore, float valSrcScore) throws IOException {
+          assertTrue(doc <= reader.maxDoc());
+          return (float) values[doc];
+        }
+      };
     }
 
-    public void setNextReader(IndexReader r) throws IOException {
-      reader = r;
-      values = FieldCache.DEFAULT.getInts(r, INT_FIELD);
-    }
-
     public CustomExternalQuery(Query q) {
       super(q);
     }

Property changes on: src\test\org\apache\lucene\util\TestAttributeSource.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/test/org/apache/lucene/util/TestAttributeSource.java:r912383

