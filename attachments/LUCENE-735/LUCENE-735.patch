Index: src/java/org/apache/lucene/index/ConvertPreLockless.java
===================================================================
--- src/java/org/apache/lucene/index/ConvertPreLockless.java	(revision 0)
+++ src/java/org/apache/lucene/index/ConvertPreLockless.java	(revision 0)
@@ -0,0 +1,14 @@
+package org.apache.lucene.index;
+
+import org.apache.lucene.store.FSDirectory;
+import java.io.IOException;
+
+public class ConvertPreLockless {
+  public static void main(String[] args) throws IOException {
+    String indexDirName = args[0];
+    FSDirectory dir = FSDirectory.getDirectory(indexDirName, false);
+    SegmentInfos sis = new SegmentInfos();
+    sis.read(dir);
+    sis.writePreLockless(System.out, dir);
+  }
+}
Index: src/java/org/apache/lucene/index/SegmentInfos.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentInfos.java	(revision 480742)
+++ src/java/org/apache/lucene/index/SegmentInfos.java	(working copy)
@@ -210,6 +210,113 @@
     }.run();
   }
 
+  protected final void writePreLockless(PrintStream infoStream, Directory directory) throws IOException {
+    String currentSegmentFileName = getCurrentSegmentFileName();
+    IndexOutput output = directory.createOutput("segments.new");
+    try {
+      output.writeInt(FORMAT); // write FORMAT
+      output.writeLong(++version); // every write changes the index
+      output.writeInt(counter); // write counter
+      output.writeInt(size()); // write infos
+      if (infoStream != null) {
+        infoStream.println(size() + " segments in index");
+      }
+      for (int i = 0; i < size(); i++) {
+        SegmentInfo si = info(i);
+        output.writeString(si.name);
+        output.writeInt(si.docCount);
+        if (infoStream != null) {
+          if (si.getUseCompoundFile()) {
+            infoStream.println("segment " + i + ": compound file format");
+          } else {
+            infoStream.println("segment " + i + ": not compound file format");
+          }
+        }
+
+        //  If there is a _X_N.del, rename to _X.del:
+        if (si.hasDeletions()) {
+          if (infoStream != null) {
+            infoStream.println("  has deletions");
+          }
+          String oldDelFileName = si.name + ".del";
+          // It may actually already be named this (if this
+          // segment was written pre-lockless):
+          if (!oldDelFileName.equals(si.getDelFileName())) {
+            if (infoStream != null) {
+              infoStream.println("  rename " + si.getDelFileName() + " to " + oldDelFileName);
+            }
+            directory.renameFile(si.getDelFileName(),
+                                 oldDelFileName);
+          } else {
+            if (infoStream != null) {
+              infoStream.println("  deletions fileName is already " + si.getDelFileName());
+            }
+          }
+        } else {
+          if (infoStream != null) {
+            infoStream.println("  no deletions");
+          }
+        }
+        
+        if (si.normGen != null) {
+          // Also fix names of separate norms files:
+          if (infoStream != null) {
+            infoStream.println("  has separate norms");
+          }
+          for(int j=0;j<si.normGen.length;j++) {
+            if (si.hasSeparateNorms(j)) {
+              if (infoStream != null) {
+                infoStream.println("  field " + j + ": has separate norms");
+              }
+              String oldNormFileName = si.name + ".";
+              String normFileName = si.getNormFileName(j);
+              if (!oldNormFileName.equals(normFileName)) {
+                if (infoStream != null) {
+                  infoStream.println("  rename " + normFileName + " to " + oldNormFileName);
+                }
+                directory.renameFile(normFileName,
+                                     oldNormFileName);
+              } else {
+                if (infoStream != null) {
+                  infoStream.println("    fileName is already " + normFileName);
+                }
+              }
+            } else {
+              if (infoStream != null) {
+                infoStream.println("  field " + j + ": no separate norms");
+              }
+            }
+          }
+        } else {
+          if (infoStream != null) {
+            if (si.hasSeparateNorms()) {
+              infoStream.println("  separate norms are already pre-lockless format");
+            } else {
+              infoStream.println("  no separate norms");
+            }
+          }
+        }
+      }
+    }
+    finally {
+      output.close();
+    }
+
+    // install new segment info
+    directory.renameFile("segments.new", IndexFileNames.SEGMENTS);
+    if (infoStream != null) {
+      infoStream.println("wrote \"segments\" file");
+    }
+
+    // rename original segments_N --> segments_N.old
+    if (currentSegmentFileName != null && !currentSegmentFileName.equals("segments")) {
+      directory.renameFile(currentSegmentFileName, currentSegmentFileName + ".old");
+      if (infoStream != null) {
+        infoStream.println("rename " + currentSegmentFileName + " to " + currentSegmentFileName + ".old");
+      }
+    }
+  }
+
   public final void write(Directory directory) throws IOException {
 
     // Always advance the generation on write:
Index: src/java/org/apache/lucene/index/SegmentInfo.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentInfo.java	(revision 480742)
+++ src/java/org/apache/lucene/index/SegmentInfo.java	(working copy)
@@ -35,7 +35,7 @@
                                                   // (and we must check filesystem); 1 or higher if
                                                   // there are deletes at generation N
    
-  private long[] normGen;                         // current generations of each field's norm file.
+  protected long[] normGen;                       // current generations of each field's norm file.
                                                   // If this array is null, we must check filesystem
                                                   // when preLockLess is true.  Else,
                                                   // there are no separate norms
