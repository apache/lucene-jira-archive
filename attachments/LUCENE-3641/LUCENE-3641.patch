Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 1213099)
+++ lucene/CHANGES.txt	(working copy)
@@ -724,6 +724,9 @@
   In ParallelReader the bug was not existent, but the implementation method
   was also made private.  (Uwe Schindler)
 
+* LUCENE-3641: Fixed MultiReader to correctly propagate readerFinishedListeners
+  to clones/reopened readers.  (Uwe Schindler)
+
 Documentation
 
 * LUCENE-3597: Fixed incorrect grouping documentation. (Martijn van Groningen, Robert Muir)
Index: lucene/src/java/org/apache/lucene/index/MultiReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/MultiReader.java	(revision 1213099)
+++ lucene/src/java/org/apache/lucene/index/MultiReader.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import java.io.IOException;
+import java.util.Collection;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.apache.lucene.util.Bits;
@@ -27,7 +28,7 @@
 /** An IndexReader which reads multiple indexes, appending
  *  their content. */
 public class MultiReader extends BaseMultiReader<IndexReader> {
-  private boolean[] decrefOnClose; // remember which subreaders to decRef on close
+  private final boolean[] decrefOnClose; // remember which subreaders to decRef on close
   
  /**
   * <p>Construct a MultiReader aggregating the named set of (sub)readers.
@@ -46,7 +47,7 @@
    */
   public MultiReader(IndexReader[] subReaders, boolean closeSubReaders) throws IOException {
     super(subReaders.clone());
-    this.readerFinishedListeners = new MapBackedSet<ReaderFinishedListener>(new ConcurrentHashMap<ReaderFinishedListener,Boolean>());
+    readerFinishedListeners = new MapBackedSet<ReaderFinishedListener>(new ConcurrentHashMap<ReaderFinishedListener,Boolean>());
     decrefOnClose = new boolean[subReaders.length];
     for (int i = 0; i < subReaders.length; i++) {
       if (!closeSubReaders) {
@@ -57,6 +58,15 @@
       }
     }
   }
+  
+  // used only by openIfChaged
+  private MultiReader(IndexReader[] subReaders, boolean[] decrefOnClose,
+                      Collection<ReaderFinishedListener> readerFinishedListeners)
+                      throws IOException {
+    super(subReaders);
+    this.decrefOnClose = decrefOnClose;
+    this.readerFinishedListeners = readerFinishedListeners;
+  }
 
   @Override
   protected synchronized IndexReader doOpenIfChanged() throws CorruptIndexException, IOException {
@@ -117,9 +127,7 @@
           newDecrefOnClose[i] = true;
         }
       }
-      MultiReader mr = new MultiReader(newSubReaders);
-      mr.decrefOnClose = newDecrefOnClose;
-      return mr;
+      return new MultiReader(newSubReaders, newDecrefOnClose, readerFinishedListeners);
     } else {
       return null;
     }
