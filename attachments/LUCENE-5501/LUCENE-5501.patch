Index: lucene/grouping/src/java/org/apache/lucene/search/grouping/AbstractAllGroupHeadsCollector.java
===================================================================
--- lucene/grouping/src/java/org/apache/lucene/search/grouping/AbstractAllGroupHeadsCollector.java	(revision 1575260)
+++ lucene/grouping/src/java/org/apache/lucene/search/grouping/AbstractAllGroupHeadsCollector.java	(working copy)
@@ -128,7 +128,7 @@
 
   @Override
   public boolean acceptsDocsOutOfOrder() {
-    return true;
+    return false;
   }
 
   /**
Index: lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java
===================================================================
--- lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java	(revision 1575260)
+++ lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java	(working copy)
@@ -380,10 +380,7 @@
             System.out.println("\n===================================================================================");
           }
 
-          assertEquals(expectedGroupHeads.length, actualGroupHeads.length);
-          for (int i = 0; i < expectedGroupHeads.length; i++) {
-            assertEquals(expectedGroupHeads[i], actualGroupHeads[i]);
-          }
+          assertArrayEquals(expectedGroupHeads, actualGroupHeads);
         }
       } finally {
         QueryUtils.purgeFieldCache(r);
Index: lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java	(revision 1575260)
+++ lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java	(working copy)
@@ -116,6 +116,106 @@
     return score;
   }
 
+  private final static class FakeScorer extends Scorer {
+
+    float score;
+    int doc;
+    int freq;
+    final long cost;
+
+    public FakeScorer(Scorer other) {
+      super((Weight) null);
+      this.cost = other.cost();
+    }
+
+    @Override
+    public float score() {
+      return score;
+    }
+
+    @Override
+    public int freq() {
+      return freq;
+    }
+
+    @Override
+    public int docID() {
+      return doc;
+    }
+
+    @Override
+    public int advance(int target) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int nextDoc() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public long cost() {
+      return cost;
+    }
+  }
+
+  private void shuffle(int[] docIDs, float[] scores, int[] freqs, int size) {
+    for (int i = size - 1; i > 0; --i) {
+      final int other = random.nextInt(i + 1);
+
+      final int tmpDoc = docIDs[i];
+      docIDs[i] = docIDs[other];
+      docIDs[other] = tmpDoc;
+
+      final float tmpScore = scores[i];
+      scores[i] = scores[other];
+      scores[other] = tmpScore;
+      
+      final int tmpFreq = freqs[i];
+      freqs[i] = freqs[other];
+      freqs[other] = tmpFreq;
+    }
+  }
+
+  private static void flush(int[] docIDs, float[] scores, int[] freqs, int size,
+      FakeScorer scorer, Collector collector) throws IOException {
+    for (int i = 0; i < size; ++i) {
+      scorer.doc = docIDs[i];
+      scorer.freq = freqs[i];
+      scorer.score = scores[i];
+      collector.collect(scorer.doc);
+    }
+  }
+
+  private void scoreInRandomOrder(Collector collector) throws IOException {
+    assert docID() == -1; // not started
+    FakeScorer fake = new FakeScorer(this);
+    collector.setScorer(fake);
+
+    final int bufferSize = 1 + random.nextInt(100);
+    final int[] docIDs = new int[bufferSize];
+    final float[] scores = new float[bufferSize];
+    final int[] freqs = new int[bufferSize];
+
+    int buffered = 0;
+    int doc;
+    while ((doc = nextDoc()) != NO_MORE_DOCS) {
+      docIDs[buffered] = doc;
+      scores[buffered] = score();
+      freqs[buffered] = freq();
+
+      if (++buffered == bufferSize) {
+        shuffle(docIDs, scores, freqs, buffered);
+        flush(docIDs, scores, freqs, buffered, fake, collector);
+        buffered = 0;
+      }
+    }
+
+    shuffle(docIDs, scores, freqs, buffered);
+    flush(docIDs, scores, freqs, buffered, fake, collector);
+  }
+
+
   @Override
   public void score(Collector collector) throws IOException {
     assert topScorer != TopScorer.NO;
@@ -133,7 +233,11 @@
     } else {
       // score(Collector) has not been overridden, use the super method in
       // order to benefit from all assertions
-      super.score(collector);
+      if (collector.acceptsDocsOutOfOrder() && random.nextBoolean()) {
+        scoreInRandomOrder(collector);
+      } else {
+        super.score(collector);
+      }
     }
   }
 
Index: lucene/test-framework/src/java/org/apache/lucene/search/AssertingWeight.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/AssertingWeight.java	(revision 1575260)
+++ lucene/test-framework/src/java/org/apache/lucene/search/AssertingWeight.java	(working copy)
@@ -29,12 +29,14 @@
     return other instanceof AssertingWeight ? other : new AssertingWeight(random, other);
   }
 
+  final boolean scoresDocsOutOfOrder;
   final Random random;
   final Weight in;
 
   AssertingWeight(Random random, Weight in) {
     this.random = random;
     this.in = in;
+    scoresDocsOutOfOrder = in.scoresDocsOutOfOrder() || random.nextBoolean();
   }
 
   @Override
@@ -69,7 +71,7 @@
 
   @Override
   public boolean scoresDocsOutOfOrder() {
-    return in.scoresDocsOutOfOrder();
+    return scoresDocsOutOfOrder;
   }
 
 }
Index: lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java	(revision 1575260)
+++ lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java	(working copy)
@@ -329,7 +329,7 @@
 
           @Override
           public boolean acceptsDocsOutOfOrder() {
-            return true;
+            return false;
           }
         });
 
