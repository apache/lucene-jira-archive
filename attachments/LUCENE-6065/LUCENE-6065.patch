Index: lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/CheckIndex.java	(revision 1640668)
+++ lucene/core/src/java/org/apache/lucene/index/CheckIndex.java	(working copy)
@@ -31,7 +31,12 @@
 import java.util.Map;
 
 import org.apache.lucene.codecs.Codec;
+import org.apache.lucene.codecs.DocValuesProducer;
+import org.apache.lucene.codecs.FieldsProducer;
+import org.apache.lucene.codecs.NormsProducer;
 import org.apache.lucene.codecs.PostingsFormat;
+import org.apache.lucene.codecs.StoredFieldsReader;
+import org.apache.lucene.codecs.TermVectorsReader;
 import org.apache.lucene.index.CheckIndex.Status.DocValuesStatus;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.store.AlreadyClosedException;
@@ -632,11 +637,6 @@
 
         segInfoStat.openReaderPassed = true;
         
-        if (infoStream != null)
-          infoStream.print("    test: check integrity.....");
-        reader.checkIntegrity();
-        msg(infoStream, "OK");
-
         if (reader.maxDoc() != info.info.getDocCount()) {
           throw new RuntimeException("SegmentReader.maxDoc() " + reader.maxDoc() + " != SegmentInfos.docCount " + info.info.getDocCount());
         }
@@ -846,6 +846,16 @@
       if (infoStream != null) {
         infoStream.print("    test: field norms.........");
       }
+      
+      // nocommit: remove instanceof
+      // nocommit: use producer for everything from here, to not load up all norms into RAM!
+      if (reader instanceof LeafReader2) {
+        NormsProducer producer = ((LeafReader2)reader).getNormsReader();
+        if (producer != null) {
+          producer.checkIntegrity();
+        }
+      }
+      
       for (FieldInfo info : reader.getFieldInfos()) {
         if (info.hasNorms()) {
           checkNorms(info, reader, infoStream);
@@ -1451,6 +1461,15 @@
       if (infoStream != null) {
         infoStream.print("    test: terms, freq, prox...");
       }
+      
+      // nocommit: remove instanceof
+      // nocommit: use producer for everything from here, to not load up all fields into RAM!
+      if (reader instanceof LeafReader2) {
+        FieldsProducer producer = ((LeafReader2)reader).getPostingsReader();
+        if (producer != null) {
+          producer.checkIntegrity();
+        }
+      }
 
       final Fields fields = reader.fields();
       final FieldInfos fieldInfos = reader.getFieldInfos();
@@ -1487,6 +1506,15 @@
       if (infoStream != null) {
         infoStream.print("    test: stored fields.......");
       }
+      
+      // nocommit: remove instanceof
+      // nocommit: use producer for everything from here, to not load up all fields into RAM!
+      if (reader instanceof LeafReader2) {
+        StoredFieldsReader producer = ((LeafReader2)reader).getFieldsReader();
+        if (producer != null) {
+          producer.checkIntegrity();
+        }
+      }
 
       // Scan stored fields for all documents
       final Bits liveDocs = reader.getLiveDocs();
@@ -1533,6 +1561,16 @@
       if (infoStream != null) {
         infoStream.print("    test: docvalues...........");
       }
+      
+      // nocommit: remove instanceof
+      // nocommit: use producer for everything from here, to not load up all fields into RAM!
+      if (reader instanceof LeafReader2) {
+        DocValuesProducer producer = ((LeafReader2)reader).getDocValuesReader();
+        if (producer != null) {
+          producer.checkIntegrity();
+        }
+      }
+      
       for (FieldInfo fieldInfo : reader.getFieldInfos()) {
         if (fieldInfo.getDocValuesType() != DocValuesType.NONE) {
           status.totalValueFields++;
@@ -1727,6 +1765,7 @@
     } else if (docsWithField.length() != reader.maxDoc()) {
       throw new RuntimeException(fi.name + " docsWithField has incorrect length: " + docsWithField.length() + ",expected: " + reader.maxDoc());
     }
+    // nocommit: move these checks to TestUtil.checkReader
     switch(fi.getDocValuesType()) {
       case SORTED:
         status.totalSortedFields++;
@@ -1810,6 +1849,15 @@
       if (infoStream != null) {
         infoStream.print("    test: term vectors........");
       }
+      
+      // nocommit: remove instanceof
+      // nocommit: use producer for everything from here, to not load up all fields into RAM!
+      if (reader instanceof LeafReader2) {
+        TermVectorsReader producer = ((LeafReader2)reader).getTermVectorsReader();
+        if (producer != null) {
+          producer.checkIntegrity();
+        }
+      }
 
       DocsEnum docs = null;
       DocsAndPositionsEnum postings = null;
Index: lucene/core/src/java/org/apache/lucene/index/ExitableDirectoryReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/ExitableDirectoryReader.java	(revision 1640668)
+++ lucene/core/src/java/org/apache/lucene/index/ExitableDirectoryReader.java	(working copy)
@@ -90,13 +90,7 @@
     @Override
     public Object getCoreCacheKey() {
       return in.getCoreCacheKey();  
-    }
-    
-    @Override
-    public Object getCombinedCoreAndDeletesKey() {
-      return in.getCombinedCoreAndDeletesKey();
-    }
-    
+    }    
   }
 
   /**
Index: lucene/core/src/java/org/apache/lucene/index/FilterLeafReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/FilterLeafReader.java	(revision 1640668)
+++ lucene/core/src/java/org/apache/lucene/index/FilterLeafReader.java	(working copy)
@@ -39,14 +39,12 @@
  * content the contained reader, you could consider overriding
  * {@link #getCoreCacheKey()} so that
  * {@link CachingWrapperFilter} shares the same entries for this atomic reader
- * and the wrapped one. {@link #getCombinedCoreAndDeletesKey()} could be
- * overridden as well if the {@link #getLiveDocs() live docs} are not changed
- * either.
+ * and the wrapped one.
  */
-public class FilterLeafReader extends LeafReader {
+public abstract class FilterLeafReader extends LeafReader {
 
   /** Get the wrapped instance by <code>reader</code> as long as this reader is
-   *  an intance of {@link FilterLeafReader}.  */
+   *  an instance of {@link FilterLeafReader}.  */
   public static LeafReader unwrap(LeafReader reader) {
     while (reader instanceof FilterLeafReader) {
       reader = ((FilterLeafReader) reader).in;
@@ -462,10 +460,4 @@
     ensureOpen();
     return in.getDocsWithField(field);
   }
-
-  @Override
-  public void checkIntegrity() throws IOException {
-    ensureOpen();
-    in.checkIntegrity();
-  }
 }
Index: lucene/core/src/java/org/apache/lucene/index/FilterLeafReader2.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/FilterLeafReader2.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/index/FilterLeafReader2.java	(working copy)
@@ -0,0 +1,144 @@
+package org.apache.lucene.index;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.codecs.DocValuesProducer;
+import org.apache.lucene.codecs.FieldsProducer;
+import org.apache.lucene.codecs.NormsProducer;
+import org.apache.lucene.codecs.StoredFieldsReader;
+import org.apache.lucene.codecs.TermVectorsReader;
+import org.apache.lucene.search.CachingWrapperFilter;
+import org.apache.lucene.util.Bits;
+
+/**  A <code>FilterLeafReader</code> contains another LeafReader, which it
+ * uses as its basic source of data, possibly transforming the data along the
+ * way or providing additional functionality. The class
+ * <code>FilterLeafReader</code> itself simply implements all abstract methods
+ * of <code>IndexReader</code> with versions that pass all requests to the
+ * contained index reader. Subclasses of <code>FilterLeafReader</code> may
+ * further override some of these methods and may also provide additional
+ * methods and fields.
+ * <p><b>NOTE</b>: If you override {@link #getLiveDocs()}, you will likely need
+ * to override {@link #numDocs()} as well and vice-versa.
+ * <p><b>NOTE</b>: If this {@link FilterLeafReader} does not change the
+ * content the contained reader, you could consider overriding
+ * {@link #getCoreCacheKey()} so that
+ * {@link CachingWrapperFilter} shares the same entries for this atomic reader
+ * and the wrapped one.
+ */
+public class FilterLeafReader2 extends LeafReader2 {
+
+  /** Get the wrapped instance by <code>reader</code> as long as this reader is
+   *  an instance of {@link FilterLeafReader}.  */
+  public static LeafReader2 unwrap(LeafReader2 reader) {
+    while (reader instanceof FilterLeafReader2) {
+      reader = ((FilterLeafReader2) reader).in;
+    }
+    return reader;
+  }
+  
+  /** The underlying LeafReader. */
+  protected final LeafReader2 in;
+  
+  /**
+   * <p>Construct a FilterLeafReader based on the specified base reader.
+   * <p>Note that base reader is closed if this FilterLeafReader is closed.</p>
+   * @param in specified base reader.
+   */
+  public FilterLeafReader2(LeafReader2 in) {
+    super();
+    if (in == null) {
+      throw new NullPointerException("incoming LeafReader cannot be null");
+    }
+    this.in = in;
+    in.registerParentReader(this);
+  }
+  
+  @Override
+  protected TermVectorsReader getTermVectorsReader() {
+    return in.getTermVectorsReader();
+  }
+
+  @Override
+  protected StoredFieldsReader getFieldsReader() {
+    return in.getFieldsReader();
+  }
+
+  @Override
+  protected NormsProducer getNormsReader() {
+    return in.getNormsReader();
+  }
+
+  @Override
+  protected DocValuesProducer getDocValuesReader() {
+    return in.getDocValuesReader();
+  }
+
+  @Override
+  protected FieldsProducer getPostingsReader() {
+    return in.getPostingsReader();
+  }
+
+  @Override
+  public void addCoreClosedListener(CoreClosedListener listener) {
+    in.addCoreClosedListener(listener);
+  }
+
+  @Override
+  public void removeCoreClosedListener(CoreClosedListener listener) {
+    in.removeCoreClosedListener(listener);
+  }
+
+  @Override
+  public Bits getLiveDocs() {
+    ensureOpen();
+    return in.getLiveDocs();
+  }
+  
+  @Override
+  public FieldInfos getFieldInfos() {
+    return in.getFieldInfos();
+  }
+
+  @Override
+  public int numDocs() {
+    // Don't call ensureOpen() here (it could affect performance)
+    return in.numDocs();
+  }
+
+  @Override
+  public int maxDoc() {
+    // Don't call ensureOpen() here (it could affect performance)
+    return in.maxDoc();
+  }
+
+  @Override
+  protected void doClose() throws IOException {
+    in.close();
+  }
+
+  @Override
+  public String toString() {
+    final StringBuilder buffer = new StringBuilder("FilterLeafReader(");
+    buffer.append(in);
+    buffer.append(')');
+    return buffer.toString();
+  }
+}

Property changes on: lucene/core/src/java/org/apache/lucene/index/FilterLeafReader2.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/java/org/apache/lucene/index/IndexReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/IndexReader.java	(revision 1640668)
+++ lucene/core/src/java/org/apache/lucene/index/IndexReader.java	(working copy)
@@ -110,8 +110,6 @@
 
   /** Expert: adds a {@link ReaderClosedListener}.  The
    * provided listener will be invoked when this reader is closed.
-   * At this point, it is safe for apps to evict this reader from
-   * any caches keyed on {@link #getCombinedCoreAndDeletesKey()}.
    *
    * @lucene.experimental */
   public final void addReaderClosedListener(ReaderClosedListener listener) {
@@ -283,8 +281,7 @@
   /** {@inheritDoc}
    * <p>For caching purposes, {@code IndexReader} subclasses are not allowed
    * to implement equals/hashCode, so methods are declared final.
-   * To lookup instances from caches use {@link #getCoreCacheKey} and 
-   * {@link #getCombinedCoreAndDeletesKey}.
+   * To lookup instances from caches use {@link #getCoreCacheKey}.
    */
   @Override
   public final boolean equals(Object obj) {
@@ -294,8 +291,7 @@
   /** {@inheritDoc}
    * <p>For caching purposes, {@code IndexReader} subclasses are not allowed
    * to implement equals/hashCode, so methods are declared final.
-   * To lookup instances from caches use {@link #getCoreCacheKey} and 
-   * {@link #getCombinedCoreAndDeletesKey}.
+   * To lookup instances from caches use {@link #getCoreCacheKey}.
    */
   @Override
   public final int hashCode() {
@@ -447,15 +443,6 @@
     return this;
   }
 
-  /** Expert: Returns a key for this IndexReader that also includes deletions,
-   * so CachingWrapperFilter can find it again.
-   * This key must not have equals()/hashCode() methods, so &quot;equals&quot; means &quot;identical&quot;. */
-  public Object getCombinedCoreAndDeletesKey() {
-    // Don't call ensureOpen since FC calls this (to evict)
-    // on close
-    return this;
-  }
-  
   /** Returns the number of documents containing the 
    * <code>term</code>.  This method returns 0 if the term or
    * field does not exists.  This method does not take into
Index: lucene/core/src/java/org/apache/lucene/index/LeafReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/LeafReader.java	(revision 1640668)
+++ lucene/core/src/java/org/apache/lucene/index/LeafReader.java	(working copy)
@@ -318,13 +318,10 @@
    *  synchronization.
    */
   public abstract Bits getLiveDocs();
-
-  /**
-   * Checks consistency of this reader.
-   * <p>
-   * Note that this may be costly in terms of I/O, e.g.
-   * may involve computing a checksum value against large data files.
-   * @lucene.internal
-   */
-  public abstract void checkIntegrity() throws IOException;
+  
+  // nocommit:
+  // uncomment for compile
+  //public abstract void cutover();
+  // uncomment for testing
+  public void cutover() {}
 }
Index: lucene/core/src/java/org/apache/lucene/index/LeafReader2.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/LeafReader2.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/index/LeafReader2.java	(working copy)
@@ -0,0 +1,562 @@
+package org.apache.lucene.index;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import org.apache.lucene.codecs.DocValuesProducer;
+import org.apache.lucene.codecs.FieldsProducer;
+import org.apache.lucene.codecs.NormsProducer;
+import org.apache.lucene.codecs.StoredFieldsReader;
+import org.apache.lucene.codecs.TermVectorsReader;
+import org.apache.lucene.store.AlreadyClosedException;
+import org.apache.lucene.util.Accountable;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.CloseableThreadLocal;
+import org.apache.lucene.util.IOUtils;
+
+/** "this is the new LeafReader" */
+// nocommit: fold into LeafReader when all FilterReaders are converted
+public abstract class LeafReader2 extends LeafReader {
+  
+  /** 
+   * Expert: retrieve thread-private TermVectorsReader
+   * @throws AlreadyClosedException if this reader is closed
+   * @lucene.internal 
+   */
+  protected abstract TermVectorsReader getTermVectorsReader();
+
+  /** 
+   * Expert: retrieve thread-private StoredFieldsReader
+   * @throws AlreadyClosedException if this reader is closed
+   * @lucene.internal 
+   */
+  protected abstract StoredFieldsReader getFieldsReader();
+  
+  /** 
+   * Expert: retrieve underlying NormsProducer
+   * @throws AlreadyClosedException if this reader is closed
+   * @lucene.internal 
+   */
+  protected abstract NormsProducer getNormsReader();
+  
+  /** 
+   * Expert: retrieve underlying DocValuesProducer
+   * @throws AlreadyClosedException if this reader is closed
+   * @lucene.internal 
+   */
+  protected abstract DocValuesProducer getDocValuesReader();
+  
+  /** 
+   * Expert: retrieve underlying FieldsProducer
+   * @throws AlreadyClosedException if this reader is closed
+   * @lucene.internal  
+   */
+  protected abstract FieldsProducer getPostingsReader();
+  
+  @Override
+  public final Fields fields() {
+    return getPostingsReader();
+  }
+  
+  private final void checkBounds(int docID) {
+    if (docID < 0 || docID >= maxDoc()) {       
+      throw new IndexOutOfBoundsException("docID must be >= 0 and < maxDoc=" + maxDoc() + " (got docID=" + docID + ")");
+    }
+  }
+  
+  @Override
+  public final void document(int docID, StoredFieldVisitor visitor) throws IOException {
+    checkBounds(docID);
+    getFieldsReader().visitDocument(docID, visitor);
+  }
+  
+  @Override
+  public final Fields getTermVectors(int docID) throws IOException {
+    TermVectorsReader termVectorsReader = getTermVectorsReader();
+    if (termVectorsReader == null) {
+      return null;
+    }
+    checkBounds(docID);
+    return termVectorsReader.get(docID);
+  }
+  
+  final CloseableThreadLocal<Map<String,Object>> docValuesLocal = new CloseableThreadLocal<Map<String,Object>>() {
+    @Override
+    protected Map<String,Object> initialValue() {
+      return new HashMap<>();
+    }
+  };
+
+  final CloseableThreadLocal<Map<String,Bits>> docsWithFieldLocal = new CloseableThreadLocal<Map<String,Bits>>() {
+    @Override
+    protected Map<String,Bits> initialValue() {
+      return new HashMap<>();
+    }
+  };
+  
+
+  final CloseableThreadLocal<Map<String,Object>> normsLocal = new CloseableThreadLocal<Map<String,Object>>() {
+    @Override
+    protected Map<String,Object> initialValue() {
+      return new HashMap<>();
+    }
+  };
+  
+  // returns the FieldInfo that corresponds to the given field and type, or
+  // null if the field does not exist, or not indexed as the requested
+  // DovDocValuesType.
+  private FieldInfo getDVField(String field, DocValuesType type) {
+    FieldInfo fi = getFieldInfos().fieldInfo(field);
+    if (fi == null) {
+      // Field does not exist
+      return null;
+    }
+    if (fi.getDocValuesType() == DocValuesType.NONE) {
+      // Field was not indexed with doc values
+      return null;
+    }
+    if (fi.getDocValuesType() != type) {
+      // Field DocValues are different than requested type
+      return null;
+    }
+
+    return fi;
+  }
+  
+  @Override
+  public final NumericDocValues getNumericDocValues(String field) throws IOException {
+    ensureOpen();
+    Map<String,Object> dvFields = docValuesLocal.get();
+
+    Object previous = dvFields.get(field);
+    if (previous != null && previous instanceof NumericDocValues) {
+      return (NumericDocValues) previous;
+    } else {
+      FieldInfo fi = getDVField(field, DocValuesType.NUMERIC);
+      if (fi == null) {
+        return null;
+      }
+      NumericDocValues dv = getDocValuesReader().getNumeric(fi);
+      dvFields.put(field, dv);
+      return dv;
+    }
+  }
+  
+  @Override
+  public final Bits getDocsWithField(String field) throws IOException {
+    ensureOpen();
+    Map<String,Bits> dvFields = docsWithFieldLocal.get();
+
+    Bits previous = dvFields.get(field);
+    if (previous != null) {
+      return previous;
+    } else {
+      FieldInfo fi = getFieldInfos().fieldInfo(field);
+      if (fi == null) {
+        // Field does not exist
+        return null;
+      }
+      if (fi.getDocValuesType() == DocValuesType.NONE) {
+        // Field was not indexed with doc values
+        return null;
+      }
+      Bits dv = getDocValuesReader().getDocsWithField(fi);
+      dvFields.put(field, dv);
+      return dv;
+    }
+  }
+
+  @Override
+  public final BinaryDocValues getBinaryDocValues(String field) throws IOException {
+    ensureOpen();
+    FieldInfo fi = getDVField(field, DocValuesType.BINARY);
+    if (fi == null) {
+      return null;
+    }
+
+    Map<String,Object> dvFields = docValuesLocal.get();
+
+    BinaryDocValues dvs = (BinaryDocValues) dvFields.get(field);
+    if (dvs == null) {
+      dvs = getDocValuesReader().getBinary(fi);
+      dvFields.put(field, dvs);
+    }
+
+    return dvs;
+  }
+
+  @Override
+  public final SortedDocValues getSortedDocValues(String field) throws IOException {
+    ensureOpen();
+    Map<String,Object> dvFields = docValuesLocal.get();
+    
+    Object previous = dvFields.get(field);
+    if (previous != null && previous instanceof SortedDocValues) {
+      return (SortedDocValues) previous;
+    } else {
+      FieldInfo fi = getDVField(field, DocValuesType.SORTED);
+      if (fi == null) {
+        return null;
+      }
+      SortedDocValues dv = getDocValuesReader().getSorted(fi);
+      dvFields.put(field, dv);
+      return dv;
+    }
+  }
+  
+  @Override
+  public final SortedNumericDocValues getSortedNumericDocValues(String field) throws IOException {
+    ensureOpen();
+    Map<String,Object> dvFields = docValuesLocal.get();
+
+    Object previous = dvFields.get(field);
+    if (previous != null && previous instanceof SortedNumericDocValues) {
+      return (SortedNumericDocValues) previous;
+    } else {
+      FieldInfo fi = getDVField(field, DocValuesType.SORTED_NUMERIC);
+      if (fi == null) {
+        return null;
+      }
+      SortedNumericDocValues dv = getDocValuesReader().getSortedNumeric(fi);
+      dvFields.put(field, dv);
+      return dv;
+    }
+  }
+
+  @Override
+  public final SortedSetDocValues getSortedSetDocValues(String field) throws IOException {
+    ensureOpen();
+    Map<String,Object> dvFields = docValuesLocal.get();
+    
+    Object previous = dvFields.get(field);
+    if (previous != null && previous instanceof SortedSetDocValues) {
+      return (SortedSetDocValues) previous;
+    } else {
+      FieldInfo fi = getDVField(field, DocValuesType.SORTED_SET);
+      if (fi == null) {
+        return null;
+      }
+      SortedSetDocValues dv = getDocValuesReader().getSortedSet(fi);
+      dvFields.put(field, dv);
+      return dv;
+    }
+  }
+  
+  @Override
+  public final NumericDocValues getNormValues(String field) throws IOException {
+    ensureOpen();
+    Map<String,Object> normFields = normsLocal.get();
+
+    NumericDocValues norms = (NumericDocValues) normFields.get(field);
+    if (norms != null) {
+      return norms;
+    } else {
+      FieldInfo fi = getFieldInfos().fieldInfo(field);
+      if (fi == null || !fi.hasNorms()) {
+        // Field does not exist or does not index norms
+        return null;
+      }
+      norms = getNormsReader().getNorms(fi);
+      normFields.put(field, norms);
+      return norms;
+    }
+  }
+
+  @Override
+  protected void doClose() throws IOException {
+    IOUtils.close(docValuesLocal, docsWithFieldLocal, normsLocal);
+  }
+
+  // nocommit
+  @Override
+  public void cutover() {}
+  
+  // nocommit: this is all cutover API
+  // --------------------------------------------------------------------------
+  public static LeafReader2 hack(final LeafReader reader) throws IOException {
+    if (reader instanceof LeafReader2) {
+      return (LeafReader2) reader;
+    } else {
+      // simulate it, over the old leafReader api      
+      return new LeafReader2() {
+
+        @Override
+        protected TermVectorsReader getTermVectorsReader() {
+          ensureOpen();
+          return readerToTermVectorsReader(reader);
+        }
+
+        @Override
+        protected StoredFieldsReader getFieldsReader() {
+          ensureOpen();
+          return readerToStoredFieldsReader(reader);
+        }
+
+        @Override
+        protected NormsProducer getNormsReader() {
+          ensureOpen();
+          return readerToNormsProducer(reader);
+        }
+
+        @Override
+        protected DocValuesProducer getDocValuesReader() {
+          ensureOpen();
+          return readerToDocValuesProducer(reader);
+        }
+
+        @Override
+        protected FieldsProducer getPostingsReader() {
+          ensureOpen();
+          try {
+            return readerToFieldsProducer(reader);
+          } catch (IOException bogus) {
+            throw new AssertionError(bogus);
+          }
+        }
+
+        @Override
+        public void addCoreClosedListener(CoreClosedListener listener) {
+          reader.addCoreClosedListener(listener);
+        }
+
+        @Override
+        public void removeCoreClosedListener(CoreClosedListener listener) {
+          reader.removeCoreClosedListener(listener);
+        }
+
+        @Override
+        public FieldInfos getFieldInfos() {
+          return reader.getFieldInfos();
+        }
+
+        @Override
+        public Bits getLiveDocs() {
+          return reader.getLiveDocs();
+        }
+
+        @Override
+        public int numDocs() {
+          return reader.numDocs();
+        }
+
+        @Override
+        public int maxDoc() {
+          return reader.maxDoc();
+        }
+
+        @Override
+        public Object getCoreCacheKey() {
+          return reader.getCoreCacheKey();
+        }
+      };
+    }
+  }
+  
+  private static NormsProducer readerToNormsProducer(final LeafReader reader) {
+    return new NormsProducer() {
+
+      @Override
+      public NumericDocValues getNorms(FieldInfo field) throws IOException {
+        return reader.getNormValues(field.name);
+      }
+
+      @Override
+      public void checkIntegrity() throws IOException {
+        // We already checkIntegrity the entire reader up front in SegmentMerger
+      }
+
+      @Override
+      public void close() {
+      }
+
+      @Override
+      public long ramBytesUsed() {
+        return 0;
+      }
+
+      @Override
+      public Iterable<? extends Accountable> getChildResources() {
+        return Collections.emptyList();
+      }
+    };
+  }
+
+  private static DocValuesProducer readerToDocValuesProducer(final LeafReader reader) {
+    return new DocValuesProducer() {
+
+      @Override
+      public NumericDocValues getNumeric(FieldInfo field) throws IOException {  
+        return reader.getNumericDocValues(field.name);
+      }
+
+      @Override
+      public BinaryDocValues getBinary(FieldInfo field) throws IOException {
+        return reader.getBinaryDocValues(field.name);
+      }
+
+      @Override
+      public SortedDocValues getSorted(FieldInfo field) throws IOException {
+        return reader.getSortedDocValues(field.name);
+      }
+
+      @Override
+      public SortedNumericDocValues getSortedNumeric(FieldInfo field) throws IOException {
+        return reader.getSortedNumericDocValues(field.name);
+      }
+
+      @Override
+      public SortedSetDocValues getSortedSet(FieldInfo field) throws IOException {
+        return reader.getSortedSetDocValues(field.name);
+      }
+
+      @Override
+      public Bits getDocsWithField(FieldInfo field) throws IOException {
+        return reader.getDocsWithField(field.name);
+      }
+
+      @Override
+      public void checkIntegrity() throws IOException {
+        // We already checkIntegrity the entire reader up front in SegmentMerger
+      }
+
+      @Override
+      public void close() {
+      }
+
+      @Override
+      public long ramBytesUsed() {
+        return 0;
+      }
+
+      @Override
+      public Iterable<? extends Accountable> getChildResources() {
+        return Collections.emptyList();
+      }
+    };
+  }
+
+  private static StoredFieldsReader readerToStoredFieldsReader(final LeafReader reader) {
+    return new StoredFieldsReader() {
+      @Override
+      public void visitDocument(int docID, StoredFieldVisitor visitor) throws IOException {
+        reader.document(docID, visitor);
+      }
+
+      @Override
+      public StoredFieldsReader clone() {
+        return readerToStoredFieldsReader(reader);
+      }
+
+      @Override
+      public void checkIntegrity() throws IOException {
+        // We already checkIntegrity the entire reader up front in SegmentMerger
+      }
+
+      @Override
+      public void close() {
+      }
+
+      @Override
+      public long ramBytesUsed() {
+        return 0;
+      }
+
+      @Override
+      public Iterable<? extends Accountable> getChildResources() {
+        return Collections.emptyList();
+      }
+    };
+  }
+
+  private static TermVectorsReader readerToTermVectorsReader(final LeafReader reader) {
+    return new TermVectorsReader() {
+      @Override
+      public Fields get(int docID) throws IOException {
+        return reader.getTermVectors(docID);
+      }
+
+      @Override
+      public TermVectorsReader clone() {
+        return readerToTermVectorsReader(reader);
+      }
+
+      @Override
+      public void checkIntegrity() throws IOException {
+        // We already checkIntegrity the entire reader up front in SegmentMerger
+      }
+
+      @Override
+      public void close() {
+      }
+
+      @Override
+      public long ramBytesUsed() {
+        return 0;
+      }
+
+      @Override
+      public Iterable<? extends Accountable> getChildResources() {
+        return Collections.emptyList();
+      }
+    };
+  }
+
+  private static FieldsProducer readerToFieldsProducer(final LeafReader reader) throws IOException {
+    final Fields fields = reader.fields();
+    return new FieldsProducer() {
+      @Override
+      public Iterator<String> iterator() {
+        return fields.iterator();
+      }
+
+      @Override
+      public Terms terms(String field) throws IOException {
+        return fields.terms(field);
+      }
+
+      @Override
+      public int size() {
+        return fields.size();
+      }
+
+      @Override
+      public void checkIntegrity() throws IOException {
+        // We already checkIntegrity the entire reader up front in SegmentMerger
+      }
+
+      @Override
+      public void close() {
+      }
+
+      @Override
+      public long ramBytesUsed() {
+        return 0;
+      }
+
+      @Override
+      public Iterable<? extends Accountable> getChildResources() {
+        return Collections.emptyList();
+      }
+    };
+  }
+}

Property changes on: lucene/core/src/java/org/apache/lucene/index/LeafReader2.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/java/org/apache/lucene/index/MergeState.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/MergeState.java	(revision 1640668)
+++ lucene/core/src/java/org/apache/lucene/index/MergeState.java	(working copy)
@@ -18,8 +18,6 @@
  */
 
 import java.io.IOException;
-import java.util.Collections;
-import java.util.Iterator;
 import java.util.List;
 
 import org.apache.lucene.codecs.DocValuesProducer;
@@ -28,7 +26,6 @@
 import org.apache.lucene.codecs.StoredFieldsReader;
 import org.apache.lucene.codecs.TermVectorsReader;
 import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.Accountable;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.packed.PackedInts;
@@ -108,47 +105,33 @@
       liveDocs[i] = reader.getLiveDocs();
       fieldInfos[i] = reader.getFieldInfos();
 
-      NormsProducer normsProducer;
-      DocValuesProducer docValuesProducer;
-      StoredFieldsReader storedFieldsReader;
-      TermVectorsReader termVectorsReader;
-      FieldsProducer fieldsProducer;
-      if (reader instanceof SegmentReader) {
-        SegmentReader segmentReader = (SegmentReader) reader;
-        normsProducer = segmentReader.getNormsReader();
-        if (normsProducer != null) {
-          normsProducer = normsProducer.getMergeInstance();
-        }
-        docValuesProducer = segmentReader.getDocValuesReader();
-        if (docValuesProducer != null) {
-          docValuesProducer = docValuesProducer.getMergeInstance();
-        }
-        storedFieldsReader = segmentReader.getFieldsReader();
-        if (storedFieldsReader != null) {
-          storedFieldsReader = storedFieldsReader.getMergeInstance();
-        }
-        termVectorsReader = segmentReader.getTermVectorsReader();
-        if (termVectorsReader != null) {
-          termVectorsReader = termVectorsReader.getMergeInstance();
-        }
-        fieldsProducer = segmentReader.fields();
-        if (fieldsProducer != null) {
-          fieldsProducer = fieldsProducer.getMergeInstance();
-        }
-      } else {
-        // A "foreign" reader
-        normsProducer = readerToNormsProducer(reader);
-        docValuesProducer = readerToDocValuesProducer(reader);
-        storedFieldsReader = readerToStoredFieldsReader(reader);
-        termVectorsReader = readerToTermVectorsReader(reader);
-        fieldsProducer = readerToFieldsProducer(reader);
+      // nocommit
+      LeafReader2 coreReader = LeafReader2.hack(reader);
+      
+      normsProducers[i] = coreReader.getNormsReader();
+      if (normsProducers[i] != null) {
+        normsProducers[i] = normsProducers[i].getMergeInstance();
       }
-
-      normsProducers[i] = normsProducer;
-      docValuesProducers[i] = docValuesProducer;
-      storedFieldsReaders[i] = storedFieldsReader;
-      termVectorsReaders[i] = termVectorsReader;
-      fieldsProducers[i] = fieldsProducer;
+      
+      docValuesProducers[i] = coreReader.getDocValuesReader();
+      if (docValuesProducers[i] != null) {
+        docValuesProducers[i] = docValuesProducers[i].getMergeInstance();
+      }
+      
+      storedFieldsReaders[i] = coreReader.getFieldsReader();
+      if (storedFieldsReaders[i] != null) {
+        storedFieldsReaders[i] = storedFieldsReaders[i].getMergeInstance();
+      }
+      
+      termVectorsReaders[i] = coreReader.getTermVectorsReader();
+      if (termVectorsReaders[i] != null) {
+        termVectorsReaders[i] = termVectorsReaders[i].getMergeInstance();
+      }
+      
+      fieldsProducers[i] = coreReader.getPostingsReader();
+      if (fieldsProducers[i] != null) {
+        fieldsProducers[i] = fieldsProducers[i].getMergeInstance();
+      }
     }
 
     this.segmentInfo = segmentInfo;
@@ -158,194 +141,8 @@
     setDocMaps(readers);
   }
 
-  private NormsProducer readerToNormsProducer(final LeafReader reader) {
-    return new NormsProducer() {
 
-      @Override
-      public NumericDocValues getNorms(FieldInfo field) throws IOException {
-        return reader.getNormValues(field.name);
-      }
 
-      @Override
-      public void checkIntegrity() throws IOException {
-        // We already checkIntegrity the entire reader up front in SegmentMerger
-      }
-
-      @Override
-      public void close() {
-      }
-
-      @Override
-      public long ramBytesUsed() {
-        return 0;
-      }
-
-      @Override
-      public Iterable<? extends Accountable> getChildResources() {
-        return Collections.emptyList();
-      }
-    };
-  }
-
-  private DocValuesProducer readerToDocValuesProducer(final LeafReader reader) {
-    return new DocValuesProducer() {
-
-      @Override
-      public NumericDocValues getNumeric(FieldInfo field) throws IOException {  
-        return reader.getNumericDocValues(field.name);
-      }
-
-      @Override
-      public BinaryDocValues getBinary(FieldInfo field) throws IOException {
-        return reader.getBinaryDocValues(field.name);
-      }
-
-      @Override
-      public SortedDocValues getSorted(FieldInfo field) throws IOException {
-        return reader.getSortedDocValues(field.name);
-      }
-
-      @Override
-      public SortedNumericDocValues getSortedNumeric(FieldInfo field) throws IOException {
-        return reader.getSortedNumericDocValues(field.name);
-      }
-
-      @Override
-      public SortedSetDocValues getSortedSet(FieldInfo field) throws IOException {
-        return reader.getSortedSetDocValues(field.name);
-      }
-
-      @Override
-      public Bits getDocsWithField(FieldInfo field) throws IOException {
-        return reader.getDocsWithField(field.name);
-      }
-
-      @Override
-      public void checkIntegrity() throws IOException {
-        // We already checkIntegrity the entire reader up front in SegmentMerger
-      }
-
-      @Override
-      public void close() {
-      }
-
-      @Override
-      public long ramBytesUsed() {
-        return 0;
-      }
-
-      @Override
-      public Iterable<? extends Accountable> getChildResources() {
-        return Collections.emptyList();
-      }
-    };
-  }
-
-  private StoredFieldsReader readerToStoredFieldsReader(final LeafReader reader) {
-    return new StoredFieldsReader() {
-      @Override
-      public void visitDocument(int docID, StoredFieldVisitor visitor) throws IOException {
-        reader.document(docID, visitor);
-      }
-
-      @Override
-      public StoredFieldsReader clone() {
-        return readerToStoredFieldsReader(reader);
-      }
-
-      @Override
-      public void checkIntegrity() throws IOException {
-        // We already checkIntegrity the entire reader up front in SegmentMerger
-      }
-
-      @Override
-      public void close() {
-      }
-
-      @Override
-      public long ramBytesUsed() {
-        return 0;
-      }
-
-      @Override
-      public Iterable<? extends Accountable> getChildResources() {
-        return Collections.emptyList();
-      }
-    };
-  }
-
-  private TermVectorsReader readerToTermVectorsReader(final LeafReader reader) {
-    return new TermVectorsReader() {
-      @Override
-      public Fields get(int docID) throws IOException {
-        return reader.getTermVectors(docID);
-      }
-
-      @Override
-      public TermVectorsReader clone() {
-        return readerToTermVectorsReader(reader);
-      }
-
-      @Override
-      public void checkIntegrity() throws IOException {
-        // We already checkIntegrity the entire reader up front in SegmentMerger
-      }
-
-      @Override
-      public void close() {
-      }
-
-      @Override
-      public long ramBytesUsed() {
-        return 0;
-      }
-
-      @Override
-      public Iterable<? extends Accountable> getChildResources() {
-        return Collections.emptyList();
-      }
-    };
-  }
-
-  private FieldsProducer readerToFieldsProducer(final LeafReader reader) throws IOException {
-    final Fields fields = reader.fields();
-    return new FieldsProducer() {
-      @Override
-      public Iterator<String> iterator() {
-        return fields.iterator();
-      }
-
-      @Override
-      public Terms terms(String field) throws IOException {
-        return fields.terms(field);
-      }
-
-      @Override
-      public int size() {
-        return fields.size();
-      }
-
-      @Override
-      public void checkIntegrity() throws IOException {
-        // We already checkIntegrity the entire reader up front in SegmentMerger
-      }
-
-      @Override
-      public void close() {
-      }
-
-      @Override
-      public long ramBytesUsed() {
-        return 0;
-      }
-
-      @Override
-      public Iterable<? extends Accountable> getChildResources() {
-        return Collections.emptyList();
-      }
-    };
-  }
-
   // NOTE: removes any "all deleted" readers from mergeState.readers
   private void setDocMaps(List<LeafReader> readers) throws IOException {
     final int numReaders = maxDocs.length;
Index: lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader.java	(revision 1640668)
+++ lucene/core/src/java/org/apache/lucene/index/ParallelLeafReader.java	(working copy)
@@ -316,12 +316,4 @@
     NumericDocValues values = reader == null ? null : reader.getNormValues(field);
     return values;
   }
-
-  @Override
-  public void checkIntegrity() throws IOException {
-    ensureOpen();
-    for (LeafReader reader : completeReaderSet) {
-      reader.checkIntegrity();
-    }
-  }
 }
Index: lucene/core/src/java/org/apache/lucene/index/SegmentCoreReaders.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SegmentCoreReaders.java	(revision 1640668)
+++ lucene/core/src/java/org/apache/lucene/index/SegmentCoreReaders.java	(working copy)
@@ -19,9 +19,7 @@
 
 import java.io.IOException;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.LinkedHashSet;
-import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -67,8 +65,7 @@
   final FieldInfos coreFieldInfos;
 
   // TODO: make a single thread local w/ a
-  // Thingy class holding fieldsReader, termVectorsReader,
-  // normsProducer
+  // Thingy class holding fieldsReader, termVectorsReader
 
   final CloseableThreadLocal<StoredFieldsReader> fieldsReaderLocal = new CloseableThreadLocal<StoredFieldsReader>() {
     @Override
@@ -84,13 +81,6 @@
     }
   };
 
-  final CloseableThreadLocal<Map<String,Object>> normsLocal = new CloseableThreadLocal<Map<String,Object>>() {
-    @Override
-    protected Map<String,Object> initialValue() {
-      return new HashMap<>();
-    }
-  };
-
   private final Set<CoreClosedListener> coreClosedListeners = 
       Collections.synchronizedSet(new LinkedHashSet<CoreClosedListener>());
   
@@ -157,32 +147,13 @@
     throw new AlreadyClosedException("SegmentCoreReaders is already closed");
   }
 
-  NumericDocValues getNormValues(FieldInfos infos, String field) throws IOException {
-    Map<String,Object> normFields = normsLocal.get();
-
-    NumericDocValues norms = (NumericDocValues) normFields.get(field);
-    if (norms != null) {
-      return norms;
-    } else {
-      FieldInfo fi = infos.fieldInfo(field);
-      if (fi == null || !fi.hasNorms()) {
-        // Field does not exist or does not index norms
-        return null;
-      }
-      assert normsProducer != null;
-      norms = normsProducer.getNorms(fi);
-      normFields.put(field, norms);
-      return norms;
-    }
-  }
-
   void decRef() throws IOException {
     if (ref.decrementAndGet() == 0) {
 //      System.err.println("--- closing core readers");
       Throwable th = null;
       try {
-        IOUtils.close(termVectorsLocal, fieldsReaderLocal, normsLocal, fields, termVectorsReaderOrig, fieldsReaderOrig,
-            cfsReader, normsProducer);
+        IOUtils.close(termVectorsLocal, fieldsReaderLocal, fields, termVectorsReaderOrig, fieldsReaderOrig,
+                      cfsReader, normsProducer);
       } catch (Throwable throwable) {
         th = throwable;
       } finally {
Index: lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java	(revision 1640668)
+++ lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java	(working copy)
@@ -51,15 +51,6 @@
   // note, just like in codec apis Directory 'dir' is NOT the same as segmentInfo.dir!!
   SegmentMerger(List<LeafReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir,
                 MergeState.CheckAbort checkAbort, FieldInfos.FieldNumbers fieldNumbers, IOContext context) throws IOException {
-    // validate incoming readers
-    for (LeafReader reader : readers) {
-      if ((reader instanceof SegmentReader) == false) {
-        // We only validate foreign readers up front: each index component
-        // calls .checkIntegrity itself for each incoming producer
-        reader.checkIntegrity();
-      }
-    }
-
     mergeState = new MergeState(readers, segmentInfo, infoStream, checkAbort);
     directory = dir;
     this.codec = segmentInfo.getCodec();
Index: lucene/core/src/java/org/apache/lucene/index/SegmentReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SegmentReader.java	(revision 1640668)
+++ lucene/core/src/java/org/apache/lucene/index/SegmentReader.java	(working copy)
@@ -20,9 +20,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
 
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.codecs.DocValuesProducer;
@@ -36,8 +34,6 @@
 import org.apache.lucene.util.Accountable;
 import org.apache.lucene.util.Accountables;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.CloseableThreadLocal;
-import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.RamUsageEstimator;
 
 /**
@@ -47,7 +43,7 @@
  * may share the same core data.
  * @lucene.experimental
  */
-public final class SegmentReader extends LeafReader implements Accountable {
+public final class SegmentReader extends LeafReader2 implements Accountable {
 
   private static final long BASE_RAM_BYTES_USED =
         RamUsageEstimator.shallowSizeOfInstance(SegmentReader.class)
@@ -63,21 +59,6 @@
 
   final SegmentCoreReaders core;
   final SegmentDocValues segDocValues;
-  
-  final CloseableThreadLocal<Map<String,Object>> docValuesLocal = new CloseableThreadLocal<Map<String,Object>>() {
-    @Override
-    protected Map<String,Object> initialValue() {
-      return new HashMap<>();
-    }
-  };
-
-  final CloseableThreadLocal<Map<String,Bits>> docsWithFieldLocal = new CloseableThreadLocal<Map<String,Bits>>() {
-    @Override
-    protected Map<String,Bits> initialValue() {
-      return new HashMap<>();
-    }
-  };
-
   final DocValuesProducer docValuesProducer;
   final FieldInfos fieldInfos;
   
@@ -196,7 +177,7 @@
       core.decRef();
     } finally {
       try {
-        IOUtils.close(docValuesLocal, docsWithFieldLocal);
+        super.doClose();
       } finally {
         if (docValuesProducer instanceof SegmentDocValuesProducer) {
           segDocValues.decRef(((SegmentDocValuesProducer)docValuesProducer).dvGens);
@@ -212,20 +193,8 @@
     ensureOpen();
     return fieldInfos;
   }
-  
-  @Override
-  public void document(int docID, StoredFieldVisitor visitor) throws IOException {
-    checkBounds(docID);
-    getFieldsReader().visitDocument(docID, visitor);
-  }
 
   @Override
-  public FieldsProducer fields() {
-    ensureOpen();
-    return core.fields;
-  }
-
-  @Override
   public int numDocs() {
     // Don't call ensureOpen() here (it could affect performance)
     return numDocs;
@@ -237,51 +206,35 @@
     return si.info.getDocCount();
   }
 
-  /** Expert: retrieve thread-private {@link
-   *  TermVectorsReader}
-   *  @lucene.internal */
-  public TermVectorsReader getTermVectorsReader() {
+  @Override
+  protected TermVectorsReader getTermVectorsReader() {
     ensureOpen();
     return core.termVectorsLocal.get();
   }
 
-  /** Expert: retrieve thread-private {@link
-   *  StoredFieldsReader}
-   *  @lucene.internal */
-  public StoredFieldsReader getFieldsReader() {
+  @Override
+  protected StoredFieldsReader getFieldsReader() {
     ensureOpen();
     return core.fieldsReaderLocal.get();
   }
   
-  /** Expert: retrieve underlying NormsProducer
-   *  @lucene.internal */
-  public NormsProducer getNormsReader() {
+  @Override
+  protected NormsProducer getNormsReader() {
     ensureOpen();
     return core.normsProducer;
   }
   
-  /** Expert: retrieve underlying DocValuesProducer
-   *  @lucene.internal */
-  public DocValuesProducer getDocValuesReader() {
+  @Override
+  protected DocValuesProducer getDocValuesReader() {
     ensureOpen();
     return docValuesProducer;
   }
 
   @Override
-  public Fields getTermVectors(int docID) throws IOException {
-    TermVectorsReader termVectorsReader = getTermVectorsReader();
-    if (termVectorsReader == null) {
-      return null;
-    }
-    checkBounds(docID);
-    return termVectorsReader.get(docID);
+  public FieldsProducer getPostingsReader() {
+    ensureOpen();
+    return core.fields;
   }
-  
-  private void checkBounds(int docID) {
-    if (docID < 0 || docID >= maxDoc()) {       
-      throw new IndexOutOfBoundsException("docID must be >= 0 and < maxDoc=" + maxDoc() + " (got docID=" + docID + ")");
-    }
-  }
 
   @Override
   public String toString() {
@@ -322,159 +275,8 @@
     // Today it passes "this" as its coreCacheKey:
     return core;
   }
-
-  @Override
-  public Object getCombinedCoreAndDeletesKey() {
-    return this;
-  }
-
-  // returns the FieldInfo that corresponds to the given field and type, or
-  // null if the field does not exist, or not indexed as the requested
-  // DovDocValuesType.
-  private FieldInfo getDVField(String field, DocValuesType type) {
-    FieldInfo fi = fieldInfos.fieldInfo(field);
-    if (fi == null) {
-      // Field does not exist
-      return null;
-    }
-    if (fi.getDocValuesType() == DocValuesType.NONE) {
-      // Field was not indexed with doc values
-      return null;
-    }
-    if (fi.getDocValuesType() != type) {
-      // Field DocValues are different than requested type
-      return null;
-    }
-
-    return fi;
-  }
   
   @Override
-  public NumericDocValues getNumericDocValues(String field) throws IOException {
-    ensureOpen();
-    Map<String,Object> dvFields = docValuesLocal.get();
-
-    Object previous = dvFields.get(field);
-    if (previous != null && previous instanceof NumericDocValues) {
-      return (NumericDocValues) previous;
-    } else {
-      FieldInfo fi = getDVField(field, DocValuesType.NUMERIC);
-      if (fi == null) {
-        return null;
-      }
-      NumericDocValues dv = docValuesProducer.getNumeric(fi);
-      dvFields.put(field, dv);
-      return dv;
-    }
-  }
-
-  @Override
-  public Bits getDocsWithField(String field) throws IOException {
-    ensureOpen();
-    Map<String,Bits> dvFields = docsWithFieldLocal.get();
-
-    Bits previous = dvFields.get(field);
-    if (previous != null) {
-      return previous;
-    } else {
-      FieldInfo fi = fieldInfos.fieldInfo(field);
-      if (fi == null) {
-        // Field does not exist
-        return null;
-      }
-      if (fi.getDocValuesType() == DocValuesType.NONE) {
-        // Field was not indexed with doc values
-        return null;
-      }
-      Bits dv = docValuesProducer.getDocsWithField(fi);
-      dvFields.put(field, dv);
-      return dv;
-    }
-  }
-
-  @Override
-  public BinaryDocValues getBinaryDocValues(String field) throws IOException {
-    ensureOpen();
-    FieldInfo fi = getDVField(field, DocValuesType.BINARY);
-    if (fi == null) {
-      return null;
-    }
-
-    Map<String,Object> dvFields = docValuesLocal.get();
-
-    BinaryDocValues dvs = (BinaryDocValues) dvFields.get(field);
-    if (dvs == null) {
-      dvs = docValuesProducer.getBinary(fi);
-      dvFields.put(field, dvs);
-    }
-
-    return dvs;
-  }
-
-  @Override
-  public SortedDocValues getSortedDocValues(String field) throws IOException {
-    ensureOpen();
-    Map<String,Object> dvFields = docValuesLocal.get();
-    
-    Object previous = dvFields.get(field);
-    if (previous != null && previous instanceof SortedDocValues) {
-      return (SortedDocValues) previous;
-    } else {
-      FieldInfo fi = getDVField(field, DocValuesType.SORTED);
-      if (fi == null) {
-        return null;
-      }
-      SortedDocValues dv = docValuesProducer.getSorted(fi);
-      dvFields.put(field, dv);
-      return dv;
-    }
-  }
-  
-  @Override
-  public SortedNumericDocValues getSortedNumericDocValues(String field) throws IOException {
-    ensureOpen();
-    Map<String,Object> dvFields = docValuesLocal.get();
-
-    Object previous = dvFields.get(field);
-    if (previous != null && previous instanceof SortedNumericDocValues) {
-      return (SortedNumericDocValues) previous;
-    } else {
-      FieldInfo fi = getDVField(field, DocValuesType.SORTED_NUMERIC);
-      if (fi == null) {
-        return null;
-      }
-      SortedNumericDocValues dv = docValuesProducer.getSortedNumeric(fi);
-      dvFields.put(field, dv);
-      return dv;
-    }
-  }
-
-  @Override
-  public SortedSetDocValues getSortedSetDocValues(String field) throws IOException {
-    ensureOpen();
-    Map<String,Object> dvFields = docValuesLocal.get();
-    
-    Object previous = dvFields.get(field);
-    if (previous != null && previous instanceof SortedSetDocValues) {
-      return (SortedSetDocValues) previous;
-    } else {
-      FieldInfo fi = getDVField(field, DocValuesType.SORTED_SET);
-      if (fi == null) {
-        return null;
-      }
-      SortedSetDocValues dv = docValuesProducer.getSortedSet(fi);
-      dvFields.put(field, dv);
-      return dv;
-    }
-  }
-
-  @Override
-  public NumericDocValues getNormValues(String field) throws IOException {
-    ensureOpen();
-    return core.getNormValues(fieldInfos, field);
-  }
-  
-  @Override
   public void addCoreClosedListener(CoreClosedListener listener) {
     ensureOpen();
     core.addCoreClosedListener(listener);
@@ -520,33 +322,4 @@
     }
     return resources;
   }
-
-  @Override
-  public void checkIntegrity() throws IOException {
-    ensureOpen();
-
-    // stored fields
-    getFieldsReader().checkIntegrity();
-    
-    // term vectors
-    TermVectorsReader termVectorsReader = getTermVectorsReader();
-    if (termVectorsReader != null) {
-      termVectorsReader.checkIntegrity();
-    }
-    
-    // terms/postings
-    if (core.fields != null) {
-      core.fields.checkIntegrity();
-    }
-    
-    // norms
-    if (core.normsProducer != null) {
-      core.normsProducer.checkIntegrity();
-    }
-    
-    // docvalues
-    if (docValuesProducer != null) {
-      docValuesProducer.checkIntegrity();
-    }
-  }
 }
Index: lucene/core/src/java/org/apache/lucene/index/SlowCompositeReaderWrapper.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SlowCompositeReaderWrapper.java	(revision 1640668)
+++ lucene/core/src/java/org/apache/lucene/index/SlowCompositeReaderWrapper.java	(working copy)
@@ -243,21 +243,8 @@
   }
 
   @Override
-  public Object getCombinedCoreAndDeletesKey() {
-    return in.getCombinedCoreAndDeletesKey();
-  }
-
-  @Override
   protected void doClose() throws IOException {
     // TODO: as this is a wrapper, should we really close the delegate?
     in.close();
   }
-
-  @Override
-  public void checkIntegrity() throws IOException {
-    ensureOpen();
-    for (LeafReaderContext ctx : in.leaves()) {
-      ctx.reader().checkIntegrity();
-    }
-  }
 }
Index: lucene/core/src/test/org/apache/lucene/index/TestAddIndexes.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestAddIndexes.java	(revision 1640668)
+++ lucene/core/src/test/org/apache/lucene/index/TestAddIndexes.java	(working copy)
@@ -1239,7 +1239,7 @@
     Directory src = newDirectory(), dest = newDirectory();
     RandomIndexWriter w = new RandomIndexWriter(random(), src);
     w.addDocument(new Document());
-    IndexReader allDeletedReader = new AllDeletedFilterReader(w.getReader().leaves().get(0).reader());
+    IndexReader allDeletedReader = new AllDeletedFilterReader(LeafReader2.hack(w.getReader().leaves().get(0).reader()));
     w.close();
     
     w = new RandomIndexWriter(random(), dest);
Index: lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose.java	(revision 1640668)
+++ lucene/core/src/test/org/apache/lucene/index/TestIndexReaderClose.java	(working copy)
@@ -44,7 +44,7 @@
       DirectoryReader open = DirectoryReader.open(dir);
       final boolean throwOnClose = !rarely();
       LeafReader wrap = SlowCompositeReaderWrapper.wrap(open);
-      FilterLeafReader reader = new FilterLeafReader(wrap) {
+      FilterLeafReader2 reader = new FilterLeafReader2(LeafReader2.hack(wrap)) {
         @Override
         protected void doClose() throws IOException {
           super.doClose();
Index: lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
===================================================================
--- lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java	(revision 1640668)
+++ lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java	(working copy)
@@ -821,11 +821,6 @@
       return null;
     }
 
-    @Override
-    public void checkIntegrity() throws IOException {
-      // no-op
-    }
-
     private class MemoryFields extends Fields {
       @Override
       public Iterator<String> iterator() {
Index: lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader.java
===================================================================
--- lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader.java	(revision 1640668)
+++ lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader.java	(working copy)
@@ -304,11 +304,6 @@
   }
 
   @Override
-  public Object getCombinedCoreAndDeletesKey() {
-    return in.getCombinedCoreAndDeletesKey();
-  }
-
-  @Override
   public String toString() {
     return "Uninverting(" + in.toString() + ")";
   }
Index: lucene/test-framework/src/java/org/apache/lucene/index/AllDeletedFilterReader.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/index/AllDeletedFilterReader.java	(revision 1640668)
+++ lucene/test-framework/src/java/org/apache/lucene/index/AllDeletedFilterReader.java	(working copy)
@@ -22,10 +22,10 @@
 /**
  * Filters the incoming reader and makes all documents appear deleted.
  */
-public class AllDeletedFilterReader extends FilterLeafReader {
+public class AllDeletedFilterReader extends FilterLeafReader2 {
   final Bits liveDocs;
   
-  public AllDeletedFilterReader(LeafReader in) {
+  public AllDeletedFilterReader(LeafReader2 in) {
     super(in);
     liveDocs = new Bits.MatchNoBits(in.maxDoc());
     assert maxDoc() == 0 || hasDeletions();
Index: lucene/test-framework/src/java/org/apache/lucene/index/AssertingDirectoryReader.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/index/AssertingDirectoryReader.java	(revision 1640668)
+++ lucene/test-framework/src/java/org/apache/lucene/index/AssertingDirectoryReader.java	(working copy)
@@ -44,9 +44,4 @@
     return in.getCoreCacheKey();
   }
 
-  @Override
-  public Object getCombinedCoreAndDeletesKey() {
-    return in.getCombinedCoreAndDeletesKey();
-  }
-
 }
Index: lucene/test-framework/src/java/org/apache/lucene/index/AssertingLeafReader.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/index/AssertingLeafReader.java	(revision 1640668)
+++ lucene/test-framework/src/java/org/apache/lucene/index/AssertingLeafReader.java	(working copy)
@@ -814,11 +814,6 @@
   public Object getCoreCacheKey() {
     return cacheKey;
   }
-
-  @Override
-  public Object getCombinedCoreAndDeletesKey() {
-    return cacheKey;
-  }
   
   private final Object cacheKey = new Object();
 }
Index: lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.java	(revision 1640668)
+++ lucene/test-framework/src/java/org/apache/lucene/index/MockRandomMergePolicy.java	(working copy)
@@ -32,7 +32,6 @@
  */
 public class MockRandomMergePolicy extends MergePolicy {
   private final Random random;
-  boolean doNonBulkMerges = true;
 
   public MockRandomMergePolicy(Random random) {
     // fork a private random, since we are called
@@ -39,14 +38,6 @@
     // unpredictably from threads:
     this.random = new Random(random.nextLong());
   }
-  
-  /** 
-   * Set to true if sometimes readers to be merged should be wrapped in a FilterReader
-   * to mixup bulk merging.
-   */
-  public void setDoNonBulkMerges(boolean v) {
-    doNonBulkMerges = v;
-  }
 
   @Override
   public MergeSpecification findMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, IndexWriter writer) {
@@ -73,11 +64,7 @@
       // TODO: sometimes make more than 1 merge?
       mergeSpec = new MergeSpecification();
       final int segsToMerge = TestUtil.nextInt(random, 1, numSegments);
-      if (doNonBulkMerges) {
-        mergeSpec.add(new MockRandomOneMerge(segments.subList(0, segsToMerge),random.nextLong()));
-      } else {
-        mergeSpec.add(new OneMerge(segments.subList(0, segsToMerge)));
-      }
+      mergeSpec.add(new OneMerge(segments.subList(0, segsToMerge)));
     }
 
     return mergeSpec;
@@ -106,11 +93,7 @@
       while(upto < eligibleSegments.size()) {
         int max = Math.min(10, eligibleSegments.size()-upto);
         int inc = max <= 2 ? max : TestUtil.nextInt(random, 2, max);
-        if (doNonBulkMerges) {
-          mergeSpec.add(new MockRandomOneMerge(eligibleSegments.subList(upto, upto+inc), random.nextLong()));
-        } else {
-          mergeSpec.add(new OneMerge(eligibleSegments.subList(upto, upto+inc)));
-        }
+        mergeSpec.add(new OneMerge(eligibleSegments.subList(upto, upto+inc)));
         upto += inc;
       }
     }
@@ -135,28 +118,4 @@
     // 80% of the time we create CFS:
     return random.nextInt(5) != 1;
   }
-  
-  static class MockRandomOneMerge extends OneMerge {
-    final Random r;
-    ArrayList<LeafReader> readers;
-
-    MockRandomOneMerge(List<SegmentCommitInfo> segments, long seed) {
-      super(segments);
-      r = new Random(seed);
-    }
-
-    @Override
-    public List<LeafReader> getMergeReaders() throws IOException {
-      if (readers == null) {
-        readers = new ArrayList<LeafReader>(super.getMergeReaders());
-        for (int i = 0; i < readers.size(); i++) {
-          // wrap it (e.g. prevent bulk merge etc)
-          if (r.nextInt(4) == 0) {
-            readers.set(i, new FilterLeafReader(readers.get(i)));
-          }
-        }
-      }
-      return readers;
-    }
-  }
 }
Index: lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java	(revision 1640668)
+++ lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java	(working copy)
@@ -445,9 +445,6 @@
     analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));
     final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setCommitOnClose(false);
     conf.setInfoStream(new FailOnNonBulkMergesInfoStream());
-    if (conf.getMergePolicy() instanceof MockRandomMergePolicy) {
-      ((MockRandomMergePolicy)conf.getMergePolicy()).setDoNonBulkMerges(false);
-    }
 
     if (LuceneTestCase.TEST_NIGHTLY) {
       // newIWConfig makes smallish max seg size, which
Index: lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java	(revision 1640668)
+++ lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java	(working copy)
@@ -141,11 +141,6 @@
     public Object getCoreCacheKey() {
       return cacheKey;
     }
-    
-    @Override
-    public Object getCombinedCoreAndDeletesKey() {
-      return cacheKey;
-    }
   }
 
   /**
Index: lucene/test-framework/src/java/org/apache/lucene/util/TestUtil.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/TestUtil.java	(revision 1640668)
+++ lucene/test-framework/src/java/org/apache/lucene/util/TestUtil.java	(working copy)
@@ -248,7 +248,6 @@
     ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);
     PrintStream infoStream = new PrintStream(bos, false, IOUtils.UTF_8);
 
-    reader.checkIntegrity();
     CheckIndex.testLiveDocs(reader, infoStream, true);
     CheckIndex.testFieldInfos(reader, infoStream, true);
     CheckIndex.testFieldNorms(reader, infoStream, true);
Index: solr/core/src/java/org/apache/solr/search/Insanity.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/Insanity.java	(revision 1640668)
+++ solr/core/src/java/org/apache/solr/search/Insanity.java	(working copy)
@@ -115,16 +115,11 @@
       return fieldInfos;
     }
 
-    // important to override these, so fieldcaches are shared on what we wrap
+    // important to override this, so fieldcaches are shared on what we wrap
     
     @Override
     public Object getCoreCacheKey() {
       return in.getCoreCacheKey();
     }
-
-    @Override
-    public Object getCombinedCoreAndDeletesKey() {
-      return in.getCombinedCoreAndDeletesKey();
-    }
   }
 }
Index: solr/core/src/test/org/apache/solr/search/TestDocSet.java
===================================================================
--- solr/core/src/test/org/apache/solr/search/TestDocSet.java	(revision 1640668)
+++ solr/core/src/test/org/apache/solr/search/TestDocSet.java	(working copy)
@@ -434,10 +434,6 @@
       @Override
       public void document(int doc, StoredFieldVisitor visitor) {
       }
-
-      @Override
-      public void checkIntegrity() throws IOException {
-      }
     };
   }
 
