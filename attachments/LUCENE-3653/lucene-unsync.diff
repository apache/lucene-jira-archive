Only in lucene-3.5.0-unsync/: build
diff -r lucene-3.5.0/src/java/org/apache/lucene/index/AllTermDocs.java lucene-3.5.0-unsync//src/java/org/apache/lucene/index/AllTermDocs.java
28c28
<     synchronized (parent) {
---
> //    synchronized (parent) {
30c30
<     }
---
> //    }
diff -r lucene-3.5.0/src/java/org/apache/lucene/index/DocumentsWriter.java lucene-3.5.0-unsync//src/java/org/apache/lucene/index/DocumentsWriter.java
202c202,203
<       if (buffers.size() > 0) {
---
> /*
>       if sbuffers.size() > 0) {
211a213
> */
212a215
> 
diff -r lucene-3.5.0/src/java/org/apache/lucene/index/SegmentCoreReaders.java lucene-3.5.0-unsync//src/java/org/apache/lucene/index/SegmentCoreReaders.java
107c107
<   synchronized TermVectorsReader getTermVectorsReaderOrig() {
---
>   TermVectorsReader getTermVectorsReaderOrig() {
111c111
<   synchronized FieldsReader getFieldsReaderOrig() {
---
>   FieldsReader getFieldsReaderOrig() {
115c115
<   synchronized void incRef() {
---
>   void incRef() {
119c119
<   synchronized Directory getCFSReader() {
---
>   Directory getCFSReader() {
123c123
<   synchronized TermInfosReader getTermsReader() {
---
>   TermInfosReader getTermsReader() {
131c131
<   synchronized boolean termsIndexIsLoaded() {
---
>   boolean termsIndexIsLoaded() {
140c140
<   synchronized void loadTermsIndex(SegmentInfo si, int termsIndexDivisor) throws IOException {
---
>   void loadTermsIndex(SegmentInfo si, int termsIndexDivisor) throws IOException {
160c160
<   synchronized void decRef() throws IOException {
---
>   void decRef() throws IOException {
173c173
<   synchronized void openDocStores(SegmentInfo si) throws IOException {
---
>   void openDocStores(SegmentInfo si) throws IOException {
diff -r lucene-3.5.0/src/java/org/apache/lucene/index/SegmentNorms.java lucene-3.5.0-unsync//src/java/org/apache/lucene/index/SegmentNorms.java
66c66
<   public synchronized void incRef() {
---
>   public void incRef() {
89c89
<   public synchronized void decRef() throws IOException {
---
>   public void decRef() throws IOException {
113c113
<   public synchronized void bytes(byte[] bytesOut, int offset, int len) throws IOException {
---
>   public void bytes(byte[] bytesOut, int offset, int len) throws IOException {
135c135
<   public synchronized byte[] bytes() throws IOException {
---
>   public byte[] bytes() throws IOException {
182c182
<   public synchronized byte[] copyOnWrite() throws IOException {
---
>   public byte[] copyOnWrite() throws IOException {
204c204
<   public synchronized Object clone() {
---
>   public Object clone() {
diff -r lucene-3.5.0/src/java/org/apache/lucene/index/SegmentReader.java lucene-3.5.0-unsync//src/java/org/apache/lucene/index/SegmentReader.java
496c496
<     ensureOpen();
---
> //    ensureOpen();
diff -r lucene-3.5.0/src/java/org/apache/lucene/index/SegmentTermDocs.java lucene-3.5.0-unsync//src/java/org/apache/lucene/index/SegmentTermDocs.java
50,52c50
<     synchronized (parent) {
<       this.deletedDocs = parent.deletedDocs;
<     }
---
>     this.deletedDocs = parent.deletedDocs;
diff -r lucene-3.5.0/src/java/org/apache/lucene/search/HitQueue.java lucene-3.5.0-unsync//src/java/org/apache/lucene/search/HitQueue.java
23a24,25
>   private static final ScoreDoc MAX_SCORE_DOC = new ScoreDoc(Integer.MAX_VALUE, Float.NEGATIVE_INFINITY);
>   
76c78
<     return !prePopulate ? null : new ScoreDoc(Integer.MAX_VALUE, Float.NEGATIVE_INFINITY);
---
>     return !prePopulate ? null : MAX_SCORE_DOC;
diff -r lucene-3.5.0/src/java/org/apache/lucene/search/Similarity.java lucene-3.5.0-unsync//src/java/org/apache/lucene/search/Similarity.java
533,540c533,540
<   private static final VirtualMethod<Similarity> withoutDocFreqMethod =
<     new VirtualMethod<Similarity>(Similarity.class, "idfExplain", Term.class, Searcher.class);
<   private static final VirtualMethod<Similarity> withDocFreqMethod =
<     new VirtualMethod<Similarity>(Similarity.class, "idfExplain", Term.class, Searcher.class, int.class);
< 
<   private final boolean hasIDFExplainWithDocFreqAPI =
<     VirtualMethod.compareImplementationDistance(getClass(),
<         withDocFreqMethod, withoutDocFreqMethod) >= 0; // its ok for both to be overridden
---
> //  private static final VirtualMethod<Similarity> withoutDocFreqMethod =
> //    new VirtualMethod<Similarity>(Similarity.class, "idfExplain", Term.class, Searcher.class);
> //  private static final VirtualMethod<Similarity> withDocFreqMethod =
> //    new VirtualMethod<Similarity>(Similarity.class, "idfExplain", Term.class, Searcher.class, int.class);
> 
> //  private static final boolean hasIDFExplainWithDocFreqAPI =
> //    VirtualMethod.compareImplementationDistance(Similarity.class,
> //        withDocFreqMethod, withoutDocFreqMethod) >= 0; // its ok for both to be overridden
798,801c798,801
<     if (!hasIDFExplainWithDocFreqAPI) {
<       // Fallback to slow impl
<       return idfExplain(term, searcher);
<     }
---
> //    if (!hasIDFExplainWithDocFreqAPI) {
> //      // Fallback to slow impl
> //      return idfExplain(term, searcher);
> //    }
diff -r lucene-3.5.0/src/java/org/apache/lucene/search/TermScorer.java lucene-3.5.0-unsync//src/java/org/apache/lucene/search/TermScorer.java
60a61
>     Similarity sim = getSimilarity();
62c63,64
<       scoreCache[i] = getSimilarity().tf(i) * weightValue;
---
>       scoreCache[i] = sim.tf(i) * weightValue;
>     
diff -r lucene-3.5.0/src/java/org/apache/lucene/search/TopDocs.java lucene-3.5.0-unsync//src/java/org/apache/lucene/search/TopDocs.java
95c95
<       assert first != second;
---
> //      assert first != second;
112c112
<           assert first.hitIndex != second.hitIndex;
---
> //          assert first.hitIndex != second.hitIndex;
160c160
<       assert first != second;
---
> //      assert first != second;
188c188
<         assert first.hitIndex != second.hitIndex;
---
> //        assert first.hitIndex != second.hitIndex;
232c232
<       assert queue.size() > 0;
---
> //      assert queue.size() > 0;
diff -r lucene-3.5.0/src/java/org/apache/lucene/search/TopScoreDocCollector.java lucene-3.5.0-unsync//src/java/org/apache/lucene/search/TopScoreDocCollector.java
50,51c50,56
<       assert score != Float.NEGATIVE_INFINITY;
<       assert !Float.isNaN(score);
---
> //      if( score == Float.NEGATIVE_INFINITY ){
> //    	  throw new RuntimeException("score[" + score + "]  == Float.NEGATIVE_INFINITY");
> //      }
> //      
> //      if(Float.isNaN(score)){
> //    	  throw new RuntimeException("Float.isNaN(score[" + score + "])");
> //      }
88,89c93,94
<       assert score != Float.NEGATIVE_INFINITY;
<       assert !Float.isNaN(score);
---
> //      assert score != Float.NEGATIVE_INFINITY;
> //      assert !Float.isNaN(score);
143c148
<       assert !Float.isNaN(score);
---
> //      assert !Float.isNaN(score);
183c188
<       assert !Float.isNaN(score);
---
> //      assert !Float.isNaN(score);
diff -r lucene-3.5.0/src/java/org/apache/lucene/store/DataInput.java lucene-3.5.0-unsync//src/java/org/apache/lucene/store/DataInput.java
118c118
<     assert (b & 0x80) == 0;
---
> //    assert (b & 0x80) == 0;
169c169
<     assert (b & 0x80) == 0;
---
> //    assert (b & 0x80) == 0;
diff -r lucene-3.5.0/src/java/org/apache/lucene/store/RAMFile.java lucene-3.5.0-unsync//src/java/org/apache/lucene/store/RAMFile.java
21a22
> import java.util.concurrent.CopyOnWriteArrayList;
28c29
<   protected ArrayList<byte[]> buffers = new ArrayList<byte[]>();
---
>   protected CopyOnWriteArrayList<byte[]> buffers = new CopyOnWriteArrayList<byte[]>();
44c45
<   public synchronized long getLength() {
---
>   public long getLength() {
48c49
<   protected synchronized void setLength(long length) {
---
>   protected void setLength(long length) {
53c54
<   public synchronized long getLastModified() {
---
>   public long getLastModified() {
57c58
<   protected synchronized void setLastModified(long lastModified) {
---
>   protected void setLastModified(long lastModified) {
74c75
<   protected final synchronized byte[] getBuffer(int index) {
---
>   protected final byte[] getBuffer(int index) {
78c79
<   protected final synchronized int numBuffers() {
---
>   protected final int numBuffers() {
92c93
<   public synchronized long getSizeInBytes() {
---
>   public long getSizeInBytes() {
diff -r lucene-3.5.0/src/java/org/apache/lucene/store/RAMInputStream.java lucene-3.5.0-unsync//src/java/org/apache/lucene/store/RAMInputStream.java
23,25c23,27
< /** A memory-resident {@link IndexInput} implementation. 
<  *  
<  *  @lucene.internal */
---
> /**
>  * A memory-resident {@link IndexInput} implementation.
>  * 
>  * @lucene.internal
>  */
27c29
<   static final int BUFFER_SIZE = RAMOutputStream.BUFFER_SIZE;
---
> 	static final int BUFFER_SIZE = RAMOutputStream.BUFFER_SIZE;
29,30c31,32
<   private RAMFile file;
<   private long length;
---
> 	private RAMFile file;
> 	private long length;
32,147c34,172
<   private byte[] currentBuffer;
<   private int currentBufferIndex;
<   
<   private int bufferPosition;
<   private long bufferStart;
<   private int bufferLength;
< 
<   /** Please pass String name */
<   @Deprecated
<   public RAMInputStream(RAMFile f) throws IOException {
<     this("anonymous", f);
<   }
< 
<   public RAMInputStream(String name, RAMFile f) throws IOException {
<     super("RAMInputStream(name=" + name + ")");
<     file = f;
<     length = file.length;
<     if (length/BUFFER_SIZE >= Integer.MAX_VALUE) {
<       throw new IOException("RAMInputStream too large length=" + length + ": " + name); 
<     }
< 
<     // make sure that we switch to the
<     // first needed buffer lazily
<     currentBufferIndex = -1;
<     currentBuffer = null;
<   }
< 
<   @Override
<   public void close() {
<     // nothing to do here
<   }
< 
<   @Override
<   public long length() {
<     return length;
<   }
< 
<   @Override
<   public byte readByte() throws IOException {
<     if (bufferPosition >= bufferLength) {
<       currentBufferIndex++;
<       switchCurrentBuffer(true);
<     }
<     return currentBuffer[bufferPosition++];
<   }
< 
<   @Override
<   public void readBytes(byte[] b, int offset, int len) throws IOException {
<     while (len > 0) {
<       if (bufferPosition >= bufferLength) {
<         currentBufferIndex++;
<         switchCurrentBuffer(true);
<       }
< 
<       int remainInBuffer = bufferLength - bufferPosition;
<       int bytesToCopy = len < remainInBuffer ? len : remainInBuffer;
<       System.arraycopy(currentBuffer, bufferPosition, b, offset, bytesToCopy);
<       offset += bytesToCopy;
<       len -= bytesToCopy;
<       bufferPosition += bytesToCopy;
<     }
<   }
< 
<   private final void switchCurrentBuffer(boolean enforceEOF) throws IOException {
<     bufferStart = (long) BUFFER_SIZE * (long) currentBufferIndex;
<     if (currentBufferIndex >= file.numBuffers()) {
<       // end of file reached, no more buffers left
<       if (enforceEOF) {
<         throw new EOFException("Read past EOF (resource: " + this + ")");
<       } else {
<         // Force EOF if a read takes place at this position
<         currentBufferIndex--;
<         bufferPosition = BUFFER_SIZE;
<       }
<     } else {
<       currentBuffer = file.getBuffer(currentBufferIndex);
<       bufferPosition = 0;
<       long buflen = length - bufferStart;
<       bufferLength = buflen > BUFFER_SIZE ? BUFFER_SIZE : (int) buflen;
<     }
<   }
< 
<   @Override
<   public void copyBytes(IndexOutput out, long numBytes) throws IOException {
<     assert numBytes >= 0: "numBytes=" + numBytes;
<     
<     long left = numBytes;
<     while (left > 0) {
<       if (bufferPosition == bufferLength) {
<         ++currentBufferIndex;
<         switchCurrentBuffer(true);
<       }
<       
<       final int bytesInBuffer = bufferLength - bufferPosition;
<       final int toCopy = (int) (bytesInBuffer < left ? bytesInBuffer : left);
<       out.writeBytes(currentBuffer, bufferPosition, toCopy);
<       bufferPosition += toCopy;
<       left -= toCopy;
<     }
<     
<     assert left == 0: "Insufficient bytes to copy: numBytes=" + numBytes + " copied=" + (numBytes - left);
<   }
<   
<   @Override
<   public long getFilePointer() {
<     return currentBufferIndex < 0 ? 0 : bufferStart + bufferPosition;
<   }
< 
<   @Override
<   public void seek(long pos) throws IOException {
<     if (currentBuffer==null || pos < bufferStart || pos >= bufferStart + BUFFER_SIZE) {
<       currentBufferIndex = (int) (pos / BUFFER_SIZE);
<       switchCurrentBuffer(false);
<     }
<     bufferPosition = (int) (pos % BUFFER_SIZE);
<   }
---
> 	private byte[] currentBuffer;
> 	private int currentBufferIndex;
> 
> 	private int bufferPosition;
> 	private long bufferStart;
> 	private int bufferLength;
> 
> 	String name = null;
> 
> 	/** Please pass String name */
> 	@Deprecated
> 	public RAMInputStream(RAMFile f) throws IOException {
> 		this("anonymous", f);
> 	}
> 
> 	public RAMInputStream(String name, RAMFile f) throws IOException {
> 		super("RAMInputStream(name=" + name + ")");
> 		this.name = name;
> 		file = f;
> 		length = file.length;
> 		if (length / BUFFER_SIZE >= Integer.MAX_VALUE) {
> 			throw new IOException("RAMInputStream too large length=" + length
> 					+ ": " + name);
> 		}
> 
> 		// make sure that we switch to the
> 		// first needed buffer lazily
> 		currentBufferIndex = -1;
> 		currentBuffer = null;
> 	}
> 	
> 	RAMInputStream(String name){
> 		super(name);
> 	}
> 
> 	public Object clone() {
> 			RAMInputStream in = new RAMInputStream(name);
> 			in.name = name;
> 			in.file = file;
> 			in.length = length;
> 			in.currentBuffer = currentBuffer;
> 			in.currentBufferIndex = currentBufferIndex;
> 			return in;
> 	}
> 
> 	@Override
> 	public void close() {
> 		// nothing to do here
> 	}
> 
> 	@Override
> 	public long length() {
> 		return length;
> 	}
> 
> 	@Override
> 	public byte readByte() throws IOException {
> 		if (bufferPosition >= bufferLength) {
> 			currentBufferIndex++;
> 			switchCurrentBuffer(true);
> 		}
> 		return currentBuffer[bufferPosition++];
> 	}
> 
> 	@Override
> 	public void readBytes(byte[] b, int offset, int len) throws IOException {
> 		while (len > 0) {
> 			if (bufferPosition >= bufferLength) {
> 				currentBufferIndex++;
> 				switchCurrentBuffer(true);
> 			}
> 
> 			int remainInBuffer = bufferLength - bufferPosition;
> 			int bytesToCopy = len < remainInBuffer ? len : remainInBuffer;
> 			System.arraycopy(currentBuffer, bufferPosition, b, offset,
> 					bytesToCopy);
> 			offset += bytesToCopy;
> 			len -= bytesToCopy;
> 			bufferPosition += bytesToCopy;
> 		}
> 	}
> 
> 	private final void switchCurrentBuffer(boolean enforceEOF)
> 			throws IOException {
> 		bufferStart = (long) BUFFER_SIZE * (long) currentBufferIndex;
> 		if (currentBufferIndex >= file.numBuffers()) {
> 			// end of file reached, no more buffers left
> 			if (enforceEOF) {
> 				throw new EOFException("Read past EOF (resource: " + this + ")");
> 			} else {
> 				// Force EOF if a read takes place at this position
> 				currentBufferIndex--;
> 				bufferPosition = BUFFER_SIZE;
> 			}
> 		} else {
> 			currentBuffer = file.getBuffer(currentBufferIndex);
> 			bufferPosition = 0;
> 			long buflen = length - bufferStart;
> 			bufferLength = buflen > BUFFER_SIZE ? BUFFER_SIZE : (int) buflen;
> 		}
> 	}
> 
> 	@Override
> 	public void copyBytes(IndexOutput out, long numBytes) throws IOException {
> 		assert numBytes >= 0 : "numBytes=" + numBytes;
> 
> 		long left = numBytes;
> 		while (left > 0) {
> 			if (bufferPosition == bufferLength) {
> 				++currentBufferIndex;
> 				switchCurrentBuffer(true);
> 			}
> 
> 			final int bytesInBuffer = bufferLength - bufferPosition;
> 			final int toCopy = (int) (bytesInBuffer < left ? bytesInBuffer
> 					: left);
> 			out.writeBytes(currentBuffer, bufferPosition, toCopy);
> 			bufferPosition += toCopy;
> 			left -= toCopy;
> 		}
> 
> 		assert left == 0 : "Insufficient bytes to copy: numBytes=" + numBytes
> 				+ " copied=" + (numBytes - left);
> 	}
> 
> 	@Override
> 	public long getFilePointer() {
> 		return currentBufferIndex < 0 ? 0 : bufferStart + bufferPosition;
> 	}
> 
> 	@Override
> 	public void seek(long pos) throws IOException {
> 		if (currentBuffer == null || pos < bufferStart
> 				|| pos >= bufferStart + BUFFER_SIZE) {
> 			currentBufferIndex = (int) (pos / BUFFER_SIZE);
> 			switchCurrentBuffer(false);
> 		}
> 		bufferPosition = (int) (pos % BUFFER_SIZE);
> 	}
diff -r lucene-3.5.0/src/java/org/apache/lucene/util/AttributeSource.java lucene-3.5.0-unsync//src/java/org/apache/lucene/util/AttributeSource.java
77d76
<         synchronized(attClassImplMap) {
99d97
<         }
214d211
<     synchronized(knownImplClasses) {
233d229
<     }
diff -r lucene-3.5.0/src/java/org/apache/lucene/util/CloseableThreadLocal.java lucene-3.5.0-unsync//src/java/org/apache/lucene/util/CloseableThreadLocal.java
24a25
> import java.util.concurrent.ConcurrentHashMap;
59c60
<   private Map<Thread,T> hardRefs = new HashMap<Thread,T>();
---
>   private Map<Thread,T> hardRefs = new ConcurrentHashMap<Thread,T>();
83c84
<     synchronized(hardRefs) {
---
> //    synchronized(hardRefs) {
92c93
<     }
---
> //    }
diff -r lucene-3.5.0/src/java/org/apache/lucene/util/VirtualMethod.java lucene-3.5.0-unsync//src/java/org/apache/lucene/util/VirtualMethod.java
96c96
<   public synchronized int getImplementationDistance(final Class<? extends C> subclazz) {
---
>   public int getImplementationDistance(final Class<? extends C> subclazz) {
