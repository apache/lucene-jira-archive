Index: lucene/src/test/org/apache/lucene/index/TestAddIndexes.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestAddIndexes.java	(revision 1211282)
+++ lucene/src/test/org/apache/lucene/index/TestAddIndexes.java	(working copy)
@@ -27,6 +27,7 @@
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
+import org.apache.lucene.document.IndexDocValuesField;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
@@ -44,6 +45,7 @@
 import org.apache.lucene.index.codecs.lucene40.Lucene40StoredFieldsFormat;
 import org.apache.lucene.index.codecs.lucene40.Lucene40TermVectorsFormat;
 import org.apache.lucene.index.codecs.pulsing.Pulsing40PostingsFormat;
+import org.apache.lucene.index.values.IndexDocValues;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.store.AlreadyClosedException;
@@ -1212,5 +1214,48 @@
     }
     r3.close();
     d3.close();
-  } 
+  }
+  
+  public void testDocValues() throws IOException {
+    assumeFalse("preflex does not support docvalues", Codec.getDefault().getName().equals("Lucene3x"));
+    Directory d1 = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random, d1);
+    Document doc = new Document();
+    doc.add(newField("id", "1", StringField.TYPE_STORED));
+    IndexDocValuesField dv = new IndexDocValuesField("dv");
+    dv.setInt(1);
+    doc.add(dv);
+    w.addDocument(doc);
+    IndexReader r1 = w.getReader();
+    w.close();
+
+    Directory d2 = newDirectory();
+    w = new RandomIndexWriter(random, d2);
+    doc = new Document();
+    doc.add(newField("id", "2", StringField.TYPE_STORED));
+    dv = new IndexDocValuesField("dv");
+    dv.setInt(2);
+    doc.add(dv);
+    w.addDocument(doc);
+    IndexReader r2 = w.getReader();
+    w.close();
+
+    Directory d3 = newDirectory();
+    w = new RandomIndexWriter(random, d3);
+    w.addIndexes(new SlowMultiReaderWrapper(r1), new SlowMultiReaderWrapper(r2));
+    r1.close();
+    d1.close();
+    r2.close();
+    d2.close();
+
+    w.forceMerge(1);
+    IndexReader r3 = w.getReader();
+    w.close();
+    IndexReader sr = getOnlySegmentReader(r3);
+    assertEquals(2, sr.numDocs());
+    IndexDocValues docValues = sr.perDocValues().docValues("dv");
+    assertNotNull(docValues);
+    r3.close();
+    d3.close();
+  }
 }
Index: lucene/src/test/org/apache/lucene/index/values/TestTypePromotion.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/values/TestTypePromotion.java	(revision 1211277)
+++ lucene/src/test/org/apache/lucene/index/values/TestTypePromotion.java	(working copy)
@@ -15,6 +15,7 @@
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.NoMergePolicy;
+import org.apache.lucene.index.SlowMultiReaderWrapper;
 import org.apache.lucene.index.codecs.Codec;
 import org.apache.lucene.index.values.IndexDocValues.Source;
 import org.apache.lucene.store.Directory;
@@ -101,7 +102,7 @@
       } else {
         // do a real merge here
         IndexReader open = IndexReader.open(dir_2);
-        writer.addIndexes(open);
+        writer.addIndexes(random.nextBoolean() ? new SlowMultiReaderWrapper(open) : open);
         open.close();
       }
       dir_2.close();
Index: lucene/src/java/org/apache/lucene/index/SegmentReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/SegmentReader.java	(revision 1211277)
+++ lucene/src/java/org/apache/lucene/index/SegmentReader.java	(working copy)
@@ -536,6 +536,9 @@
       else if ((fi.storeOffsetWithTermVector && fi.storePositionWithTermVector) &&
                 fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET) {
         fieldSet.add(fi.name);
+      } 
+      else if (fi.hasDocValues() && fieldOption == IndexReader.FieldOption.DOC_VALUES) {
+        fieldSet.add(fi.name);
       }
     }
     return fieldSet;
Index: lucene/src/java/org/apache/lucene/index/SegmentMerger.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/SegmentMerger.java	(revision 1211277)
+++ lucene/src/java/org/apache/lucene/index/SegmentMerger.java	(working copy)
@@ -31,6 +31,7 @@
 import org.apache.lucene.index.codecs.StoredFieldsWriter;
 import org.apache.lucene.index.codecs.PerDocConsumer;
 import org.apache.lucene.index.codecs.TermVectorsWriter;
+import org.apache.lucene.index.values.ValueType;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexOutput;
@@ -202,7 +203,11 @@
         addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
         addIndexed(reader, mergeState.fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
         mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.UNINDEXED), false);
-        mergeState.fieldInfos.addOrUpdate(reader.getFieldNames(FieldOption.DOC_VALUES), false);
+        Collection<String> dvNames = reader.getFieldNames(FieldOption.DOC_VALUES);
+        mergeState.fieldInfos.addOrUpdate(dvNames, false);
+        for (String dvName : dvNames) {
+          mergeState.fieldInfos.fieldInfo(dvName).setDocValues(reader.docValues(dvName).type());
+        }
       }
     }
   }
