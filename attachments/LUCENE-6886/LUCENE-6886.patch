Index: lucene/codecs/src/java/org/apache/lucene/codecs/memory/FSTTermsWriter.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/memory/FSTTermsWriter.java	(revision 1712939)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/memory/FSTTermsWriter.java	(working copy)
@@ -120,7 +120,7 @@
  */
 
 public class FSTTermsWriter extends FieldsConsumer {
-  static final String TERMS_EXTENSION = "tmp";
+  static final String TERMS_EXTENSION = "tfp";
   static final String TERMS_CODEC_NAME = "FSTTerms";
   public static final int TERMS_VERSION_START = 2;
   public static final int TERMS_VERSION_CURRENT = TERMS_VERSION_START;
Index: lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java	(revision 1712939)
+++ lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java	(working copy)
@@ -17,13 +17,6 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.store.AlreadyClosedException;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.CollectionUtil;
-import org.apache.lucene.util.Constants;
-import org.apache.lucene.util.IOUtils;
-import org.apache.lucene.util.InfoStream;
-
 import java.io.Closeable;
 import java.io.FileNotFoundException;
 import java.io.IOException;
@@ -34,11 +27,19 @@
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
 import java.util.regex.Matcher;
 
+import org.apache.lucene.store.AlreadyClosedException;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.CollectionUtil;
+import org.apache.lucene.util.Constants;
+import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.InfoStream;
+
 /*
  * This class keeps track of each SegmentInfos instance that
  * is still "live", either because it corresponds to a
@@ -284,6 +285,11 @@
         String segmentName = IndexFileNames.parseSegmentName(fileName);
         assert segmentName.startsWith("_"): "wtf? file=" + fileName;
 
+        if (fileName.toLowerCase(Locale.ROOT).endsWith(".tmp")) {
+          // A temp file: don't try to look at its gen
+          continue;
+        }
+
         maxSegmentName = Math.max(maxSegmentName, Integer.parseInt(segmentName.substring(1), Character.MAX_RADIX));
 
         Long curGen = maxPerSegmentGen.get(segmentName);
Index: lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java	(revision 1712939)
+++ lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java	(working copy)
@@ -21,6 +21,7 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
@@ -268,6 +269,9 @@
       if (!m.matches()) {
         throw new IllegalArgumentException("invalid codec filename '" + file + "', must match: " + IndexFileNames.CODEC_FILE_PATTERN.pattern());
       }
+      if (file.toLowerCase(Locale.ROOT).endsWith(".tmp")) {
+        throw new IllegalArgumentException("invalid codec filename '" + file + "', cannot end with .tmp extension");
+      }
     }
   }
   
Index: lucene/core/src/java/org/apache/lucene/store/BaseDirectory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/BaseDirectory.java	(revision 1712939)
+++ lucene/core/src/java/org/apache/lucene/store/BaseDirectory.java	(working copy)
@@ -20,6 +20,8 @@
 import java.io.IOException;
 import java.util.Random;
 
+import org.apache.lucene.index.IndexFileNames;
+
 /**
  * Base implementation for a concrete {@link Directory} that uses a {@link LockFactory} for locking.
  * @lucene.experimental
@@ -32,22 +34,6 @@
    * this Directory instance). */
   protected final LockFactory lockFactory;
 
-  /** Subclasses can use this to generate temp file name candidates */
-  protected static final Random tempFileRandom;
-
-  static {
-    String prop = System.getProperty("tests.seed");
-    int seed;
-    if (prop != null) {
-      // So if there is a test failure that relied on temp file names,
-      //we remain reproducible based on the test seed:
-      seed = prop.hashCode();
-    } else {
-      seed = (int) System.currentTimeMillis();
-    }
-    tempFileRandom = new Random(seed);
-  }
-
   /** Sole constructor. */
   protected BaseDirectory(LockFactory lockFactory) {
     super();
@@ -72,5 +58,4 @@
   public String toString() {
     return super.toString()  + " lockFactory=" + lockFactory;
   }
-  
 }
Index: lucene/core/src/java/org/apache/lucene/store/Directory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/Directory.java	(revision 1712939)
+++ lucene/core/src/java/org/apache/lucene/store/Directory.java	(working copy)
@@ -73,7 +73,8 @@
   public abstract IndexOutput createOutput(String name, IOContext context) throws IOException;
 
   /** Creates a new, empty file for writing in the directory, with a
-   *  temporary file name derived from prefix and suffix.  Use
+   *  temporary file name including prefix and suffix, ending with the
+   *  reserved extension <code>.tmp</code>.  Use
    *  {@link IndexOutput#getName} to see what name was used.  */
   public abstract IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException;
 
Index: lucene/core/src/java/org/apache/lucene/store/FSDirectory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/FSDirectory.java	(revision 1712939)
+++ lucene/core/src/java/org/apache/lucene/store/FSDirectory.java	(working copy)
@@ -32,6 +32,7 @@
 import java.util.List;
 import java.util.concurrent.Future;
 
+import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.IOUtils;
 
@@ -118,6 +119,9 @@
 
   protected final Path directory; // The underlying filesystem directory
 
+  /** Used to generate temp file names in {@link #createTempOutput}. */
+  private long nextTempFileCounter;
+
   /** Create a new FSDirectory for the named location (ctor for subclasses).
    * The directory is created at the named location if it does not yet exist.
    * 
@@ -227,13 +231,18 @@
     return new FSIndexOutput(name);
   }
 
+  private synchronized String getPossibleTempName(String prefix, String suffix) {
+    // TODO: we are abusing segmentSuffix here
+    return IndexFileNames.segmentFileName(prefix, suffix + "_" + Long.toString(nextTempFileCounter++, Character.MAX_RADIX), "tmp");
+  }
+
   @Override
   public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {
     ensureOpen();
     while (true) {
-      String name = prefix + tempFileRandom.nextInt(Integer.MAX_VALUE) + "." + suffix;
       try {
-        return new FSIndexOutput(name, StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW);
+        return new FSIndexOutput(getPossibleTempName(prefix, suffix),
+                                 StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.CREATE_NEW);
       } catch (FileAlreadyExistsException faee) {
         // Retry with next random name
       }
Index: lucene/core/src/java/org/apache/lucene/store/RAMDirectory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/RAMDirectory.java	(revision 1712939)
+++ lucene/core/src/java/org/apache/lucene/store/RAMDirectory.java	(working copy)
@@ -28,6 +28,7 @@
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicLong;
 
+import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.util.Accountable;
 import org.apache.lucene.util.Accountables;
 
@@ -51,6 +52,9 @@
   protected final Map<String,RAMFile> fileMap = new ConcurrentHashMap<>();
   protected final AtomicLong sizeInBytes = new AtomicLong();
   
+  /** Used to generate temp file names in {@link #createTempOutput}. */
+  private long nextTempFileCounter;
+
   /** Constructs an empty {@link Directory}. */
   public RAMDirectory() {
     this(new SingleInstanceLockFactory());
@@ -177,6 +181,11 @@
     return new RAMOutputStream(name, file, true);
   }
 
+  private synchronized String getPossibleTempName(String prefix, String suffix) {
+    // TODO: we are abusing segmentSuffix here:
+    return IndexFileNames.segmentFileName(prefix, suffix + "_" + Long.toString(nextTempFileCounter++, Character.MAX_RADIX), "tmp");
+  }
+
   @Override
   public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {
     ensureOpen();
@@ -186,7 +195,7 @@
 
     // ... then try to find a unique name for it:
     while (true) {
-      String name = prefix + tempFileRandom.nextInt(Integer.MAX_VALUE) + "." + suffix;
+      String name = getPossibleTempName(prefix, suffix);
       if (fileMap.putIfAbsent(name, file) == null) {
         return new RAMOutputStream(name, file, true);
       }
Index: lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java	(revision 1712939)
+++ lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java	(working copy)
@@ -18,9 +18,11 @@
  */
 
 import java.io.ByteArrayOutputStream;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.io.StringReader;
+import java.nio.file.NoSuchFileException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -2810,5 +2812,31 @@
     assertFalse(r2.getIndexCommit().getSegmentsFileName().equals(r.getIndexCommit().getSegmentsFileName()));
     IOUtils.close(r, r2, w, dir);
   }
+
+  public void testLeftoverTempFiles() throws Exception {
+    Directory dir = newDirectory();
+    if (dir instanceof MockDirectoryWrapper) {
+      ((MockDirectoryWrapper) dir).setEnableVirusScanner(false);
+    }
+    IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()));
+    IndexWriter w = new IndexWriter(dir, iwc);
+    w.close();
+    
+    IndexOutput out = dir.createTempOutput("_0", "bkd", IOContext.DEFAULT);
+    String tempName = out.getName();
+    out.close();
+    iwc = new IndexWriterConfig(new MockAnalyzer(random()));
+    w = new IndexWriter(dir, iwc);
+
+    // Make sure IW deleted the unref'd file:
+    try {
+      dir.openInput(tempName, IOContext.DEFAULT);
+      fail("did not hit exception");
+    } catch (FileNotFoundException | NoSuchFileException e) {
+      // expected
+    }
+    w.close();
+    dir.close();
+  }
 }
 
Index: lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper.java	(revision 1712939)
+++ lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper.java	(working copy)
@@ -30,6 +30,7 @@
 import java.util.IdentityHashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Random;
 import java.util.Set;
@@ -620,6 +621,10 @@
     
     IndexOutput delegateOutput = in.createTempOutput(prefix, suffix, LuceneTestCase.newIOContext(randomState, context));
     String name = delegateOutput.getName();
+    if (name.toLowerCase(Locale.ROOT).endsWith(".tmp") == false) {
+      throw new IllegalStateException("wrapped directory failed to use .tmp extension: got: " + name);
+    }
+
     unSyncedFiles.add(name);
     createdFiles.add(name);
     final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);
