Index: docs/queryparsersyntax.html
===================================================================
--- docs/queryparsersyntax.html	(revision 574284)
+++ docs/queryparsersyntax.html	(working copy)
@@ -415,10 +415,13 @@
 <p>This will find documents whose mod_date fields have values between 20020101 and 20030101, inclusive.
             Note that Range Queries are not reserved for date fields.  You could also use range queries with non-date fields:</p>
 <pre class="code">title:{Aida TO Carmen}</pre>
-<p>This will find all documents whose titles are between Aida and Carmen, but not including Aida and Carmen.</p>
-<p>Inclusive range queries are denoted by square brackets.  Exclusive range queries are denoted by
+<p>This will find all documents whose titles are between Aida and Carmen, but not including Aida and Carmen.
+            Note that Range Queries need not be solely inclusive or exclusive:</p>
+<pre class="code">firstName:[Bob TO Mike}</pre>
+<p>This will find all documents whose firstName fields have values between Bob and Mike, including Bob but not Mike.</p>
+<p>Inclusive range query bounds are denoted by square brackets.  Exclusive range query bounds are denoted by
             curly brackets.</p>
-<a name="N100DA"></a><a name="Boosting a Term"></a>
+<a name="N100E0"></a><a name="Boosting a Term"></a>
 <h3 class="boxed">Boosting a Term</h3>
 <p>Lucene provides the relevance level of matching documents based on the terms found. To boost a term use the caret, "^", symbol with a boost factor (a number) at the end of the term you are searching. The higher the boost factor, the more relevant the term will be.</p>
 <p>Boosting allows you to control the relevance of a document by boosting its term. For example, if you are searching for</p>
@@ -433,12 +436,12 @@
 
 
         
-<a name="N100FA"></a><a name="Boolean operators"></a>
+<a name="N10100"></a><a name="Boolean operators"></a>
 <h2 class="boxed">Boolean Operators</h2>
 <div class="section">
 <p>Boolean operators allow terms to be combined through logic operators.
         Lucene supports AND, "+", OR, NOT and "-" as Boolean operators(Note: Boolean operators must be ALL CAPS).</p>
-<a name="N10103"></a><a name="OR"></a>
+<a name="N10109"></a><a name="OR"></a>
 <h3 class="boxed"></h3>
 <p>The OR operator is the default conjunction operator. This means that if there is no Boolean operator between two terms, the OR operator is used.
         The OR operator links two terms and finds a matching document if either of the terms exist in a document. This is equivalent to a union using sets.
@@ -447,18 +450,18 @@
 <pre class="code">"jakarta apache" jakarta</pre>
 <p>or</p>
 <pre class="code">"jakarta apache" OR jakarta</pre>
-<a name="N10116"></a><a name="AND"></a>
+<a name="N1011C"></a><a name="AND"></a>
 <h3 class="boxed">AND</h3>
 <p>The AND operator matches documents where both terms exist anywhere in the text of a single document.
         This is equivalent to an intersection using sets. The symbol &amp;&amp; can be used in place of the word AND.</p>
 <p>To search for documents that contain "jakarta apache" and "Apache Lucene" use the query: </p>
 <pre class="code">"jakarta apache" AND "Apache Lucene"</pre>
-<a name="N10126"></a><a name="+"></a>
+<a name="N1012C"></a><a name="+"></a>
 <h3 class="boxed">+</h3>
 <p>The "+" or required operator requires that the term after the "+" symbol exist somewhere in a the field of a single document.</p>
 <p>To search for documents that must contain "jakarta" and may contain "lucene" use the query:</p>
 <pre class="code">+jakarta lucene</pre>
-<a name="N10136"></a><a name="NOT"></a>
+<a name="N1013C"></a><a name="NOT"></a>
 <h3 class="boxed">NOT</h3>
 <p>The NOT operator excludes documents that contain the term after NOT.
         This is equivalent to a difference using sets. The symbol ! can be used in place of the word NOT.</p>
@@ -466,7 +469,7 @@
 <pre class="code">"jakarta apache" NOT "Apache Lucene"</pre>
 <p>Note: The NOT operator cannot be used with just one term. For example, the following search will return no results:</p>
 <pre class="code">NOT "jakarta apache"</pre>
-<a name="N1014C"></a><a name="-"></a>
+<a name="N10152"></a><a name="-"></a>
 <h3 class="boxed">-</h3>
 <p>The "-" or prohibit operator excludes documents that contain the term after the "-" symbol.</p>
 <p>To search for documents that contain "jakarta apache" but not "Apache Lucene" use the query: </p>
@@ -474,7 +477,7 @@
 </div>
 
         
-<a name="N1015D"></a><a name="Grouping"></a>
+<a name="N10163"></a><a name="Grouping"></a>
 <h2 class="boxed">Grouping</h2>
 <div class="section">
 <p>Lucene supports using parentheses to group clauses to form sub queries. This can be very useful if you want to control the boolean logic for a query.</p>
@@ -484,7 +487,7 @@
 </div>
 
         
-<a name="N10170"></a><a name="Field Grouping"></a>
+<a name="N10176"></a><a name="Field Grouping"></a>
 <h2 class="boxed">Field Grouping</h2>
 <div class="section">
 <p>Lucene supports using parentheses to group multiple clauses to a single field.</p>
@@ -493,7 +496,7 @@
 </div>
 
         
-<a name="N10180"></a><a name="Escaping Special Characters"></a>
+<a name="N10186"></a><a name="Escaping Special Characters"></a>
 <h2 class="boxed">Escaping Special Characters</h2>
 <div class="section">
 <p>Lucene supports escaping special characters that are part of the query syntax. The current list special characters are</p>
Index: docs/queryparsersyntax.pdf
===================================================================
--- docs/queryparsersyntax.pdf	(revision 574284)
+++ docs/queryparsersyntax.pdf	(working copy)
@@ -5,10 +5,10 @@
 /Producer (FOP 0.20.5) >>
 endobj
 5 0 obj
-<< /Length 1002 /Filter [ /ASCII85Decode /FlateDecode ]
+<< /Length 1003 /Filter [ /ASCII85Decode /FlateDecode ]
  >>
 stream
-Gb!$GbAu>[(kq^5$C8tZ6H)sQ1.gNOFP9u7c#h?V6"TCr7Zgq$kP"NOaTe8,NO,mK(DbHXnprdui]J0.S.L3"N'K9C7HQ6F7:7i:+OWIW;KIoJ#SN_ZllQ'ET.NK\-VqN,NYDA-r,n:Jb0-EgbM/:]cRsPh<$R[O:S4[g4Iq#[+T%o1JH3Q85IMJC$%aS!IH*8lokV&KWbgtC<Y5F%hl;8Qa9h=9aMa^VlRjuS`qA+mkB5=tWblR#%%q:G4qsDK1(qJ]md!6Sq@s"qMYl])#H8aOq02tP(?'d8F!hY7PJA#jR8F=O2$FIGHg4;)qrS072q/])G@3oHZ8Dmo@sdK4+j8QdE-KdEk2p%jj\9]_&4kA#1^NNMc$[,lorXf#o0TJ97RHhQnTZkO]?-&7:sL3;OMdXT)\^<$oKS4RQ4#Qkr)5&/2U$g6)f#9lC<EYO;7L\$pXGd`Z?geA*Zj!TZej:^fR@o!k/N7#.U=ULmHJOgrD_PgmI9JR")2RQpE%i\2RCmpf6:$Xl+`-k+U9C'gm%HdGTUgd@cqKf"hB'[H!N@G;(Wd!E0n9&*IJ"6gR^g&<R-3!:1@tOC+"F2gfJ:f;MrU/?SA5gD*<uc)t4p'/G%]Uh8D*]m>C:>lG!8%AH,ApZf1lF\jP%gB5E^JNpc5ZY!*jpjC2FS_VtLCXQ*&fRDWq1lTZ?mnN*(W/_S?*%s.'PP?@7WTDSJclg-UP[l:QG1tFsj27#Higt//>#P'oiEh;\XgP-,XC<_S??//M2<qU4\m9tXr)`p^W4.p`3\Zr%l%.1%+0/9qU%6k%$S_2I5LXC7g\T+SoN:*YuRp7MR@[?7Vk(P5>NJfll7,B!M$dGnSoU>_6)u].6T"5"C'^;/Z#G#-*,D[46'$NkTUN:KaL$^9W0YoJThK]hkgGW[e-$BPHlK,?%(3clB2u84GE]G+.guU<kE9m1*f<h-YO$\,9-M=C-M70?5kS5U@Qg*4A]Y&'VHB9rHd/O,Eal-;~>
+Gb!$GbAu>[(kq^5$C8tZ6H)sq1.gNOFP9u7c#h?V6"TCr7Zgq$kP"NOaT@u(NO,mK(DbHXnprdui]J60S.^?$N'Ork7HQ6B7:8,B+OWIW-KZAI&L9I>krnf%5$Nm1:7cu7*%1U9q!0u)V3aDhQa^b0SmD%ZW*1[;T08O#GWGl?62F%E!s+(eIV^me&d2&u]>ec"j4A5n<)H_nXWdt*^/Y>,O;$JNObu@lgKeD4NN7cFcDn14AQ.@[(dQJlI4-k!A0cnn\>p/9l;mta/af[C+/F5(jl6Y\>D*)*c(.[%9EJ]DAk!FND^]Rlfi+eHh:G-sgf%^Ahgldka>P.dN:!UB\Lcl5_qe)^L7<g4PW-Em66OsSclfj%2Y6;Oe[K:b064%H)[Y=:`8c<hGEWtMTq"EuPJ`sW)\^<$oKVnUSd@8ur%fdd2U$g6)f#9lC<EYO;7L\$GLW45\pepM*Zj!TZd./NfR@o!k/N7#.U=ULmHJOgop"@sc1()2"-_B?mQINAD.]bkY4%D)dsi1q;@ZH<\LHdQnNP`=Jt8r.(?G2^k>bM@H+A%\_Hh>^GOQ1uDgN,iX.0?!S]'$(eP>tL\?FKUKbU@.^0XAWRVEsT2rG^b=m!?4gPKReg(iA[e:%:(ao7c5B>aVkFc3?]cIa=r*So>>?%"bkaMkf0K_KB0_ot10A<o7Bk.^i4;%RZ/$.k>hY4pl*JL@_X@6aMZ=4c\VODf&H@;)`p:2=HgR(9Cb4V$OIdc>e]heX5ebc*HI*cuC/rE3.d<P+"q:2fK86JhgG"4#bpi\7a;DSO-F`\mZ2(j'4gG8s*(0k]rQ8Jp8^?e1WID8e'4Q-=8G\/Q6.6A_d(e/+Q^Vs$#8ANK\B*^$h82CR!8OUaG,%Rq!cTHmWuDF`mP^^AgnMI;$Gb.R<qA@?@#^kC>`\>WHS.UV$imbI"BB#s(Q'QKI4rPPbhLL%6$d6%cth3h=0E\<fn.\TqF-sWWd]Ctg$QKgc]TgShb=eXeV~>
 endstream
 endobj
 6 0 obj
@@ -253,10 +253,10 @@
 >>
 endobj
 48 0 obj
-<< /Length 2113 /Filter [ /ASCII85Decode /FlateDecode ]
+<< /Length 2136 /Filter [ /ASCII85Decode /FlateDecode ]
  >>
 stream
-Gb!#]gMYb8&:O:S&:/AKGe5oknkp`I*4,uT-e:p&#K;R*8SfeQk/Fc,1uI/`8;a_d2mQXN'S\1ka^*2^3HJeUrH`e`G'\=Y`gd51^,l]OToS;]n5m3GpBt&#'!fk5Znjf@E;'/'"AZI^*rk3IFVolqe+jm;cD'gGS9?5Am8<+A=3d`8ht-]4F2>?/S4>%J"tD4r@8rS>(fX-b\51O4;FN]Q.CCY"V(RNR8S4C'9&_g!j*Zjq5]_%P,0ue*cLdG=$;*GF;qI_]B>WiVV[liKVcYqPRigNJ*I(JFTEd+qJVd[r0\TuKi[0'4Z50l@5Hd+p0\5CXS.ShG3<,FKqW6Y^53uEY=g1@D4@_@G_tP5bnse/\:XS7OK)7YZ9(^,:W<s@@b"!](`ca!N5o<GW1nTr9k0p/8d)X"DF,1!2`0Ym+QmC/r7Q>dNM%P!gO:e.+$a1hG$q=RS?b^K5iUr4lK@*.@\Ubl0i9tK$I3Q0ISP0uM8pK!.idDj3$t3DllZHN5-j4V?Y/<AiWD]KZb&(ka?Jk"K>ZMajek\k?W@ZIN`bG!%:9)3e4%r>O^jk'bV:%e=,h6phn=:b3M"=K8N4Sj&3N58=YR?Y5P8E+"G\(#IBCShO?ROM.MpHg3<G[OLa+Qqi+EIe6-&,MdW7;fi=QO]3k'6$[etH6g.S1A$&kBT>lSJbm`a:\SEj_>u#4p5M]f`"F\cRc>OC4,L>aG]6&,d:.`g^ne1tRG^J`pQ!>pcBgJ#HS-8FlrtVMP>BRO2Aq>$qVn*1kd7=H8P62JUb]G$V)A1?*Hf)2?Rd:IuB0nI*b=(m6r%1PIs%3R?=E[@:gHeMRX18fJ+U<-t99Pfu'%Je\'i:5VN07Qg8E,(%Ws\gGr3b6;5;:8KfdiX!eNFg!YXMHXD"05S]Yl\hJo0<t72;](hUFCXE`oj,aOZ"t0t6-"$Q5=EO]_\qm%<!Ceq`cZ,dCegCq&qjW_-`:\M337qa'WV)99U.pWk3k&?q&Se3W`):;Z-6^te4-uBjqdfRO<:Z81gc1%%T<p'7u;T8`^`A!,<Z"jSWBSnmeC5Jq$=p#X!3#nP#Y<BIRNB3_0-i$_ZALu_D"=[*-NdIURN?%=B"gagnO\G)"2d?Ur,V32ksU)8g;3E?!FX^r*F63f".pf$kMr4GTikYkOee[X1;CLcp]!QNW7S(9[m5HV'_r;\K:+#3e.XhT)>S%5i#?PHYaQtr&o@6DmdG_k1*@6)C1#h*Ru[2fsY#fbboB0KS3*4aK`c8X,m_m\_BIEpjntWD;B!Fn?%9/A?mJj#M8soL.j:^pn$*\P!g#^W3QTDpUDKrJ-;,(Ck2JPs/6AE%p^A&&mH=KhYNqs7=o_f.S]M]>l$$dYq<nL9Yue*1,"XC[8,bOo+EuigNLL^G6a\"5tA/"]Xcsn^qBEma>He$S.i6A`cjN#`3jYuC]-^fgt3iuJ?dL4ipJ/8U9lPHfV/?_3jlR_i\uZImJY=I<IYM]".p'$".p4:Fe.tYkdV.Z%Aort+c5bYU"7C4!_R<)Gu2IC"qbHCeICpR.*Z%=[E@Mo@TDZZT/`[O(hJ>O9Re"q_d1[FrHt\hj2*1;FN6:BhqM*Nc^We>]hCa+QKi@;0Cc^b"EG?c@"_B^'#/Xi#NE].>7jAo,<]7pH;o30p)EsCTjaF2LJu[#_IN'XS'5rm]M?j8m=F\]n#SOIm!LaL@UXS&]C1Ha+3O0@@a)J`eko29'$)H`"+q@jm`o^6$FWZY]h2`kSd976!Bg>X=;nDo&fEel%2?O!4=@Sg5.YWR:5qhOlP8FOXKF)ogp4V1edq#^4J2-"mA'+h4Ubc)3=b>?q"_-**93T@6*.nG>:D(@CD3p=7:1.j;s*JbM;CJVVr/iarPW;:Fb,SkOB!=_\.]F1)(.a:!oJ&A0aQgqhXB"'s(g3U6'6SVj.iC*V$ge?/`=X6.og[=,J-V#S#fKu7c$IYf(qd_ik&It;Sq6:s5nb/Z$j5iYZCtE#pktrR=1nIVM,ZYh<-FJVS#deiLa2qF\1f-:*9Rg/skJVlV3KmQ<WqV5m-6YGM+YO/bausGL"PF&:-WHoB4YP(Y\T*A^_EnjtMdfBl3jXKC-9D2"&j4o`5!lV7(R$~>
+Gb!#]gMYb8&:O:S&:/?uHcs+lk*I8`irDN:3jE"K3%.he8n(/-'j`FA7J#meMPN3^OeL:)5[i<n0"L&eR58Jff.Y/\YK%Gd/uUX_h_u@&9l/!q?2,q?o)#i43H;^I8sM9EG^o7(GQB&57CW;9lWBCfQ1=4XhQF0CLK`5#\D+EF2-sH.07VHi1[CKH+*0H-8NW#RVV=t1WHO@VcsRm5iDc[_4-M+]:)>BqB;227nM1Hh(le1s)1^;:F@i',T<.S/'biQGKkEK59g$Q]<do?K@p/'OlG*,QNE(TY"S!H#!of^%"W"KrlqH3E7iY^KQE01oD%FY?]Ur'\L`5H#3`e8B6i4)83q'm'U$s&\Pd]J!7*';4'-3je=V'r,.*^*XV[Jp8.A/d?M(5r\Z1%kQk#V:,-nRY(47J_AoNZ3B@8l0B-5]\ngYkU]4H&b?Gb'?tTQ14>+H3ZshA0J5DVF(JNfU<i7P6\b-a)q*CiDMR=\h)H2L%,g6-Y7q`De,hj/c@bFIJs9bY5VYo40%$Kb?uOV9N6;W01tZ/"B^+79M7,WOhAlam1Y'%r\U*0tdYgmD^XocZL/fM^?5aN.`A(SNQ.Yob]^25u+WlUMlp.mgqVMH&PA45q_%baW-5b>%89d,L%t%&KJks_fL_Z<_mbH_GABu56NdTE_l#JWb<9h'&ABhSuks3K+m&o*2Qgk8&o#o)6B;`lE.st=LAHYXPu:b-XP_28=/1\)q%srApn"+B"Wr*If,mW+X5/T9UIR>BPAH7`b9oH-usQ<Bk,^c)H!M7A(Z2^e(fc6)DV_tpR[OE'&XS#mi`s!U_ASIH+;A)C@:%`41bQF?ReG%NG8u'RRXVX%ma+dV23PtRQ<S&Hm0KTC:Zn1#0R1!e>%s11rKupW-k]]1<T$9R9oP0-[T2WNHKuha-f9!jMmZq*q[0^&^;-R_`Q4b*Pr<6l(d2?pI6onl4Dsdefcs79N(u/0A+B\>2B`b6tm!.IOJ+u(PI+H9LXDcC*nkk&9]VrQna:l/u)P[I65N2T40WaoB6cb&Dq+6kF@NmJ6n#ChW^SlYbBm(m6TS(E5[jM<'LE*nl*+A*k6mP>mFDNTPlJlR)+2?!pUl`r.)YQRKqpi?'f8Lf39RB/pb#Fh255i7GQS(27qVpEcYFMZ>)*Vb\->JO?U)$s3%S-DNR7%3M7;jY!j5MPls^=3WX8+fHo&J)6,jr6[jd$-V+-?V+C.Nk^gEI&mM@,L$EB6,S'OT=K808Rq9B_rW\/dk[`Be4'#LpTHM>K(:(aelu_X;]daHJ9%_E99:WOHpCB/mS@ZX[h+!\5U>Q9EbRqS,P%=I.\*;0B%i!/N7[$s4&-7pGg9C>&pOu3a]\AThXOjuSpS>d:&0EY62[0Y\)7sZ!LC]^hDSW^J8>"ZXF?TmL_923.Jq4!0``j\>5^dWI9QYihf"-]RkG5<SlMtqR+5$aTN@#<_2c2>iM[YIp$@ngK]?;4DK*^4khn$#VmpTV^;aY<XP9IF'oj392qgd%$9!"VYWLg#.[>:\FWQdF6WgHF&_Xpg`?k.t?>W5_W*W@,&>hsd<[LEbRBr`B:?eb$gQ'YQ:%CL)4HR'.tf-]g1S#YG[Be8)`,d^r&+8>LBhqLC=LG9/t(rZXJ)OD?bXub3m3)Ug^oei_$dY"m`kW_uLgQY3uRRS%[Jd9t>Sh'(M7aJ%DF?=lJjZ-o>]298@du,mV?C:V`6mpSlk+/i=17LY$:<j(O/[!`sh*sD@S,RdIKsEcP?HEn+qU\O^:u<V:5<0/u^,2>n>AK;&)mrUMP#lp_3'A_]*Y*)@?8_&(FJ5j-=QB,5qp(EZM8C-=(lO;EVIP>Sn&H33F&J5`!RThJME6^Ck#?>I4T>obX>_5.l:Ep-Iu-@i@?,Ap0_SjpFD($pKY-fdMcQ\/=$*mZjV*3YjoHjDk?8E;6<UulI^/:(b@c&r\NH5;,IZFX[5$An3l]C79^<@fh:2BMalS^P*b]%6jDBs&:<`j05R`/GZ\AU)hei\cjZ^-T!Tr!GhoWECTg4&c,_?5lQ'JEK-QdIN'"Et`$UC@3e185dUsXRpbo=t^JUCi8D+@FogicYha&E.oSmV.[Z[?'%:c3;u[SO1kF<kO&`M%%NI<UFcFd5>-dbb9.\?u~>
 endstream
 endobj
 49 0 obj
@@ -268,10 +268,10 @@
 >>
 endobj
 50 0 obj
-<< /Length 2028 /Filter [ /ASCII85Decode /FlateDecode ]
+<< /Length 2018 /Filter [ /ASCII85Decode /FlateDecode ]
  >>
 stream
-Gatm=gMYb*&:Ml+#_"0?Cs*PB;O;f)gMML1Oef*d(7Qm@gU+(`(0ucSA"XoN8sZQP9\Ktk"L1Bf,j041b`)I3I.d7/lGjY5(Ae'K<T57\$c>ej;H@/>-Bt5a#eWKKPH.J\DqY@YMNc[']_\+,>^nOoM*8%EGj_&n5BuQ-N:obLIEg[VJ%gt+*9^Veq3Bi.k3G7um?Z0#-(&r;Q1s0/MAWqU68fdrHm<4%dX9HgnG[GZMUf-/^Gl/4VK0IK6DM6B>,3Q),[qfA4,HXF#XOF.SMVFhWQ7MXjLUG6ktI??N*:hfKuh1Wc_k/C:Pc(ob'AKMibH%]Pafd/[1^"OqbMGcAmg&T3*L$+J7We)jYL;cZ"u"'lKT`Fk]EBF[^I)X22:Ng<@JnC9R.f2X+!2-3Wc's]:)8uMG:+:f&HsdbkY5[U)uV8BCfjq&]MXFfLS#u'D]l?LBBWl9Z</+iQbD,=b-Y_Ye1[_BUfEH&,0G.MkqgALKcWcj`l"rMaQ^=PW)mX8Mf:\M*P+$,DqXZ@nRqVRG7e\))b>)TL.e@J;ui/1=.tqeQm+o_7'Nq)$6ZhN,&<B9A\9NZD\aP'Qkm`-b`bs!gl3C44LZ*!(LH!M98=3NI7U+1r;OHlL.9iFB%S9\YiWN!_@/7MF3$K&eFjT@Uh5_+cCNdIH041Tk`nJr_A/)T@SI*Ui_bE$ab.MCEO)hb-8qK>Tf&13C\2U9V):Z60tE*\ge/-)"N&s',8b<>diZC$YXL4BP3OXi=*4h4=Ro!#8REgrRWa1X>8]:[9\^*/r;EU+2[gK8Fm,p&eetdl#X+!it0V2[Hi(*QI$A.^K17o0UF)@R[N:D*;c\u+L#2<BKcSdQZo;hLM/1!!Ak;67&'aE:@%dg_-sbmRn93(ldSoOZnuqt=O<-Q8tHJ"b$q/jgo32P0[L(,ATZBFV46,fA##77T`j>Q93iZ5bf$#QR<#.R'*/IaLk4#n1:<@s_M,6.]<3W.(K0*nQDmIuN>/0.n<t1OB3AEC7:MKLH_uD<0s%P]K&qoO86oRgo__af5W,P!E/u'a1aqRl=.g>4#"aaT]lbS!TM*?/eE1X#$Ef@n3no:[rmXY=f,j.on!!72rZI#=)XU@KE3eh+2@:aoEF<5789\"CR\VqprRJ2-6'fV]3jfq:/2QX"b%eVUKsIEt#Qr>\X^X5umpI==#;"s)5(g]=h&*'t.tZ/aOOYLS\W-=PnlDcZW_Pd):Aimpr+K)0h^+hfDf>'Y4C"Whi]GLE'()B8ZkkX^,!H>^lgTmr)nd/X6+fEJGH;*2#J3Ao:_M50V$cG86Q=d:c_._4:Q8i`>Equa.P4COH6Tl^9)I7#!]G%tfrDjk%/7i>"ZD.]-S[tcB7`KF-UM['J@Tb(l`rQp?-2,S'C$'Rk3<J<mujOCp[X\jK35ME*tcFPrT@lYK1fTHja&joGDo(XdFKB+YJH@\.5e.!gaZ$B[M(pq>5Y>I8"LTm6C-_6Z`lhf<,7dL2rHc2+%i5!QhQ4d`6Y&gV!H0J_ZNW;cFBo02N550"k_f%ZaHDQJM+_2_(VKKFi+On'Sn_A3GjL`h;33$oFM?S93'eIH9a4Spc!iN/IeHOrR6g"'\c7r\jTJBca2fc\V+X>:JR.brP\\lj#&FY,D8WY>aKi1J.mojnm!bdU88:Df!=6lX2^LI\N&##Gkh3$X6WS])l69>";^[>n!s1iCUTo8^4`U%r]03Zdh)<l>LIG2R%*dg2MQ.@D,%1$)CNtsH&o6`caSPWc>HMtmjnZ]l4,fZ#6`#:`\i`fQ;7B6XI_fD[D&IS<$B"Bj"F`/:#g(%'/.q((]lrmTT7us)YUirdGR`nOMGmb5P<_IIB"11R(;B`e&%LKZIOp3A42agn'3#D6mC4A<`d,=L@)X+/[c"W:_ZF%bkHKnMT:7e*DPbe,a#6>qk&-f@jhYO(K7GbMh\]]]e.[OZLMQAf+r`V%/2"+qdD^(rNdFCdl$/=Eiq=f9A&(Eqtg$t?3:1YA\5E@]0UL]$-#<dnZaOe3lCmtSk;Vk~>
+Gatm=>Ar7S'Roe[&H($c%4=cD/q$C)[b/qbC$V*o=TM-lD)JW_kRtp$J,H5QX[AS:SKTCbM\JUOo:>@*fXJ3/qq:%ZJt8b9qf*7\aE<(WOT,sI5%"/hMhpg`-$PNof?)d2+&IgrYkn))eA7`(0j@?,mNYg4_+t"RohaQZB=<!_H'K+YhTW<8H/W"Sh-R;AMI[\P9g&sn!=#1&4,tq`J">8"#Q+B8&[hY2mJ^,Z^rHsY<\2)V^>\/`*%77b?B&GqK!fYP7Gr6k)LP]D2qm8eAEb,<.l:#7J,Gqe(pq3nns#I'$^ina^,*pa*RU;.78Y&8^=3&oN8%_)`f];G9?7&&gIJ.h#)siq'JV:-0(h):KF[^&C1mt%-pg,kHA)X!#Vn_G[Die:50eD`L=0i_V3-[`&h7TX.8C^_LoO)mfc=#H9Co,SGl\K5Pi<jUF23rb"\m-\rkOC*9Z[U4O$g/hT@^/>=.4/NOZ$u]e6r<0<R@J7YT-qA0Yh=ZQ9G;iR4qKp;BLTbf;-C>#^"l'X[Z%(/Ma,bNV2UW4T-u<UM@85"FssNeLT["#D+L/>)RD@hnlciZVGajHN?%)/^j/uDRRFpN^ft'Ml;5B-Q5XJW&Q:hUI+>+ri9kGihbaUUZSa3Mq=[cVOgM-h1XN6#DPdnd?NW-q+>.L,NcPh!lerAe,lj@'Qj]kJ')>qD1JUNF-sjLE[5#sh5JjGR,gV-."fZ[J?Vq>5I0r/k5bKt@8YWM!U,N>*bGKe\l;/G&Gr0Qre>G_KiuUBI@)<9b_"1WUI`_HZ%H=L?m@Cl&NT3CqoS8.=h!T!DQgp3V6+#a.BUFKKG:ue!"abmV;\[BQ\a*VNiAF-aYW.0i&_g$QAHD]6^-\g4[?8W^sDk%F\E\d@$qT39MW2ULgBq`2X>dE(ng<S)UP5#JJ%2'L;/"*VGWc"UZXFm"=T4OVYqX`k*dqR%"H'8[`U(5$5gP/ljadsa#R,F1f)J<oEn$<bsm$N.2(@9PHk7qW=h_N0X(k=-r=+)X@`]'m7^=H$p812_I*XZ01lUR1;S<$/R/f`J"Xd1&qQpA.+>5J.;GT\a/5c5j$s-ETh8T59?d3`20j%3W@&Z$;@ir*?fgrQ1eSe.:@,Q0i*.&h2PS?/fe^DX<*SROBJjF6ll>rM7t.t/<:Fr;lRS!'q;NU%Xfl'49CQN?8V90Q0LaVALOB4Y=d=4[PZr@k+*7fLLY?!OGf_5PQ*idEIF@f!W]cI9U7m'3J)GZ/N@G\cSLhdE[6dHG33Y*AUq9U-PH9;2J%[=SP3$/@V1t`G15Gg$eSI.<XNg*N6Q'eI`NHrQ!=S_\?m1$u%1KsUc[`%",+)\gX:@U_*OOR&?Xs99k+&:2ps7Kg:F8NDR)fh#./NAsk54Pb96S-X80j5poD;oKO?G(eMVf7Rg$@%Ym:OlTSqgeD*:A,@#(VN.Pff[oO"iNt4tX,NnPh%4Il9`!B>S%5XXA^IY,.,c,@D1Ol)bjt^i5?$(hdD5^8rfgK&Bb[K\'GR@4pBQ\ubR1>Oj`q6J4ZND>iGB]B!+7=$7kbJM.r6`rV'_rejIbnU`W`m;BdW(nT8]>Phr\%?BM1R9$^37VUB*<W^*MIc"ZH/D!:D;3i).EII(K""[0?dJ';^W:ZQBc$G-s`33N\V!CL^iIMPVEb9*G2,LcV"?Tk<1\UE"P3(<Pq#s`rD-0)T!Z>W!Vfh`MgNs-Y5,?'F:fV_)*`*7rs/C]n6\B'eJ*O15?aA%t+TZTVgc?5V+X6H513]8@YB[XU`=sQ^WPJ1ipBar6"o7/g>5EfOT[),oMea)f4f>tP5!2)fMm,.u\8MM_0LTmtGd+X0:L._1YNeT*5BF`bWi,!.lMF?)pJF:VB%gQY=V-:/^dV;?["W(b@)5=+ASDa1K?Q8jWJa8t`X5YRmA+:@+9/AE;i9Rb3Y@M>&&nB,Z.YDqEn,G)(ptLCH5)Db=hk7%BS]7Y!'o.q^PbOo*H%tTR1J[r0l(hg!h]-;G!G39Y/$Dt*$;aCVL\OS)>+lM~>
 endstream
 endobj
 51 0 obj
@@ -283,10 +283,10 @@
 >>
 endobj
 52 0 obj
-<< /Length 1715 /Filter [ /ASCII85Decode /FlateDecode ]
+<< /Length 1716 /Filter [ /ASCII85Decode /FlateDecode ]
  >>
 stream
-Gb!SlgQ(#H&:O:SW;DfJ\h(%ZPddH*!Ye)+IV\dFHRW0U/3:A\n_\P,8_-]gAaOT/!6&Da%jd)h_fO*3okZhhI6RNbA&/NO?d)tOBFonAHqJPVI3[a5E"rV3%2Q9/ZY0#-:n7"dh>YT='eg,!k/iQ'B2SG65r02B%]Km!S)CJ?Bmq)XnDdFgD)8N*^$1^ZGI9mVG-8@BXf!h%,M0ch_>KA114g+k/MhVLK[Q;u\aJk''tnVQQM&8[<Jf<c<GsHp?5`,&eHb]n'U@oQbgn>sp'M8iaPX%ra34FsTCpXpq"D;+'9RdED6\T=7XNo(8j]MV$7O:qBR]a-0G4N-.[[sFp-m?r+r;NkFtk>+^PQsGBX<PEAm%Y-CD)Q"&*Y55FoXG!2u;amJQ)2#VC7J'#S,aTZ,=&FER_raENtR]188=r'U+2"iJ"*1-:YjM0dD4n-8%^il1=lk]B@R,7?G;UGH6FTa=/>.MePe.ga7$$p\=#.Jc^[=@6`:V@1eaZeeY,$\RuPg*h"Q_C_0,NYUAl2Hn+l[L!+esIS!2>7-QUQ\$cI/Np1#m\>kc?[*+35Eg#,b8"=g"3j"h4Wsm8<=?J&A8gqIbHY?j?eE&\G0dR2HZiAbGlj&E$iXqkI`m9nV`Sj\!DY!`#N_VDC4Ws2.KrW,bji!K^m[/eli_)];Q`oP8e<a$#(_Rb48^,N>^=3d9*0"q;\D/pQm?_BbhdUb9?EVRT!,r-R@_PUb,5CmuE^#s$]Kd!NA'C,[,H;+kdJ#On&eL!A=9&-4C!=i%oXmK!%L))E'YZl,0>,>8+oV.@8<^-;O<l44[+@OL$X)!C!P(S;\$RD*TlLTiBL@2e&X"]"7*8.k80/Tbag7J%L4SMF/!C*#oZrK(R<[sGqd]c=p[B3Mlg<.XJ9P^]Yk5a^74oZ9*qAI)0/$qDc0WaiJ59F9\_WC5G;iksTRL1f6Yu5>%+2Dc<F+Z&MYL@XB3"bh^_'bdAm>`a&S_sK(-"K-VGZtn[7htL-a7N&@YGMLKje'+'\_lBa\!nQ,N=qngr'QF8-I$VBju!-Rb2K9f'+B\^'=K'>NVqW^RMei.dI-o5!2:5^Qs!`BfJV`s%(_ONZjPO;Kd**i<Xc/)>*&QS3&_N@^J7O_E`9t*-,)?"X?AIl*aG!&S#/^Y28l(H^D6I7$,*r1V]-f$0#t8K^[@`BA867+C&ioY.u/#oO;#,]c*Q?oZik\"KR14#h>?B-gq4jD"--drudNZEj?"BD!jIh84TA$84FCR\<PLA/>];mgUeA(0/Ms20jP1BH$WZ"E%\KL`QYI4jb,H-5OA?Il7i!lfVKrs$bZQV]TJC+^A[>gf2k&G.+@Gd*CX*67?:c&'P5VnB\"s*rM)H#n`oL<45O=OO2&JF_nWAYA1Ap0S_ig[kG9`cUq*HY,>@NtrY(rpb9s`+@m8n_AW>TTGgQ,abK9G+K=jBfn/fVSEepEdU5g?1UeGo>hl0m&i!6[3HiJ)-Kq*2-K8<'g@M&uEbV0$a&B<IgHXH0I-F"&+J>DQhFQ6MBlD%=OOk6HYRn-=Bn+KSC^N_.2&T6U)T_YUA,DDHNJB"BP,9-K]^g@\1+I:r7lh5,#ni[CYg`;i7pKU@F?DTHS80"WPP)t5QiP2tk^.;>kj"BW\ONI6%Z/4K)L:u,\ClO"OGI68<UtV4<NBDE-IVUFK,sg"KcFu#nCR<+s&lF%b\"q@+5A=Ypo)~>
+Gb!kt>BALf(k(RKW.)f5j*IK696j1a3]!=cRl%dcI1WW5;Sh@XAB_g7-Zo4gOq!G@4EN[iG'3U53p5j4]c3#])inl,e6B`gqbcPjhc!.`Vi\md.j5eXP^1Q!PL6;U]BTHi"C^50YP8lt(>mON"4)#rDtr7_n%C3('Q"*_^ElA^?=.K/E]>nIO8OE<55\9]]Mrh_6:0^tpX`&0(jY4KZ2KYg^:j@8Q1p=urk5K`/kII5*E*22WD6"K;-&G<L1?058]u)5V)a?4&+%<G.'p(I=[h"cC!q06AuGIIX>;]@>oJLd33h/B*G*6md(/:&::#*\X`k"Oa(ocK:,Fd$kX%@$2lYN]Xk4-jY:EB.occ-27A-fEQSD)Gs#.?3Hl")J3_IEO)K>CHDec.PCsd'*`,CF1ajNppPZbS%9l/7<?bC'%:N<1e_=omp^)k?l&R+o/2g1BQ;q'XJ:=$E#brSZE]j\8j@08-?$]WpU@:>1YeH;U`)5/*Im5g/Eee_\fIj::KW:cVcd!:27"j6T!mJ_&dnKFNn2*N$!2c0<eDVXXhk+PS8d(TW#d$/<HHu#+K[:8'%UD6[@6<iT,,j5k"oVgY7>UeW*WQX.m"t9ME!S'S0kA&@%TUKO4JBRd9$'YM0/'oZ#@(.gd1)bnT!-1J`b<brf9G>E7*DK*L:6IgJ.0McsOhZfI":#?2=4#eA"K,aLXNh\On:?&!'a!Y?`WKjsE]Onf!s)-`aul>i^!\;0%'&_b-h9AX$*LcgZ;&PO2*DErF@\gKqI^Is<M#d+'gpERMKTM9SbtaH&=UJb&a'LT:kEX0b!'/R#t8"E1D4&N&5j>-'4:6j.&a*h^-KWOq-uNXIDIA[N&L4Ad"La"mL'pEc=@I[pYgk[D=4;n5't6F4L/LgXoOR-2n>%lk4t[SFlA.jZZnY=_,sJp%cYS?jen:O8tS@3c&%\03\Hg*i2W8ZrBm-s,Y'dq>;US^/a4]aK65V>5._)?<R?Yq.mdK5cn9XM>:CG7RTgXT3%kD'<LpY)R<^T=gdh,Lkj:L1@/t4U]YjQn=c2SBJFSFcf3NZY<h%&*495/e9bP(oZa/cQ1Bl(%.esY1gGhLkF=,2e)FG)Y9CjE%T+s>mfTMg:*(gOh'l^a_(e2oZX^qq78V'[`?cuQEMGDZ:R7,BtC2bJ/Y\Vi738;A,30R"dB4A%K9^KdPANYgULLC.1QapodmrD^uQ$"DVlsn`K6.QqJ@5#n),?\Z<_^73"Q^s(-i(S*qXC$C2N@4<HCcn1b+@?L5q1,fGV\fc5JlP9C+i_6?2W(lnHV@Z_0S!SAH&K)u'])^kI':0VU%7.OK(I7,3fMGg/%1;MWW?5Mc8H>U?r<_Z5b1==i46Xa'okHAmUK^i%XQJfDg)F'm6`X_rlDZe884Zj<@LC$DeF-uGXY!'fa>/KCcjdW19i_l35rfgiottK7,>.m]qPUJ!kCI<j(c@J@(kmZLuQl:*dNCG23TlBT!/lVIEfET#Rj0DEY<'IJN1HZTR-4XMO)g=e;AMWU<V1fBCmY15B8UP0lgu2FYi]9#NC'e+Zs_Cm&[CA&/C1P![\[b1p:%M&+_D[hLMm*636=PBn)'Wh$b$u]@JYI%AnhIYMKX\L>\O&=AN&\2L_p#SVn<-4mZQjL/.`m,]-&qpJj;T(>a(^]!ic2[e";S3AbeooCXXa?3_-c=_Z7*_*3%"`^"ZjB4dt,h,i:oXss~>
 endstream
 endobj
 53 0 obj
@@ -298,10 +298,10 @@
 >>
 endobj
 54 0 obj
-<< /Length 1062 /Filter [ /ASCII85Decode /FlateDecode ]
+<< /Length 1251 /Filter [ /ASCII85Decode /FlateDecode ]
  >>
 stream
-Gatm:hf"u<&:WfGnFBC%MsB$7`mC&dXkHCr*nlmgdRfZa$!I\c^t*8Vrq;bP4rVctD2K%qN.(GKa5$tJ^3/RBNu#R7kE6R[Y)Lfob),:*Uc)o_k*HHdGm"fAE2NXQYO"X!0jQN0,eC=bX:sJP3Z!TQ)uR*4d)OKGoT,a/-sPs'%e:^gc!9013je3,oCH)PmYuRedP?`EblZ]Fs&4Q=f"itB$nI'<a6?D[*&D4-Jg5"h+GKl4MOA/KIkDt68<Yk`ZRf*FDH=om`mD8!W+8eBAM1fj+uT(kJo0:uE`^34%]"o(@6&To"Aj2HG]$fP#Ii5#&g@J5/Kl2=b@RWH/VoLgd7cu6^dQ."/-+H^.De%FGjj'i$[75u5>hZVi(V7e<65Oo:$sB(Am6#4^n9j]rsb:-._;(bk9@r]_-MU`>Dke!a&8r#A(XHX4%p3g]3EXIYcFhO/):J)h!@O]$P2!hrB/noKC8=B,pV6d"i['HgV9ohEA1`XQ-s?HB;s9248uA>nIHC&#6-NuS.!Pso;45`EaTC>b\fDM@"cks.*MneEh1<#%X2ODF;q56.\t37#Fho%h9U7OftGg/$oYT&+EXIYqddl5Yk`(=&HFmV*a0$XiW*kml\SrO>7kCoee@`[Wp%@F;5l%a0akTQ01J$q;XAMlho)>1^)r0qJ(=d,RdGmM4?,%gbDWX_))IW^HXZ95`r'Dl)e7_Co.//iA,\CKHXhLYjtXpsN&#MIk]RB.@b*+cO?s7BWA!6])&dqG<U*mGV:OM&NI=e$/qd+ST>HB"/#7Eja9QdtUqu'C*j#KfZrFJ6R-*qrKp/e#Ge[*8)'ddT>L<`Y9e?W-3F1bikQr<$gW7?Mn$'f`WU2Qu5A"?R0GL80@N,?Uka)bahGlM@rQ8]Mntm)sV<`Gj#Gok[<Wf!_@)6'mqK:%5b3P'C*<kh1En4^6$o^Ou!\j'-V'Xt6N.Wc9auT/8Na/IGdjERYRQ[]rZ`Q)R\94FrS/T^#`%bT!7Z@LB=8UV6](jZf@'amFQH=PW`+ah>Z/*\bFm^7EHH+HYfmhc?_YjMclYBW~>
+Gatm:>Ar7S'Roe[i:9^s$c7cX.8"k7g9(`Y$sVK]X_Il+Te/.1Uf,VRA)2V2W%/AlBaqKpLij1\kJlt<jK$Pbc"?Kg6.!pT?S4YUHcYr0o?2A'T.u)"O0h7*Mt`-2rGiGG9R%P&=HKq`bu^8EK_,c!:O]fA'+R>K5l8k\6:@9!c$&'R;0h;bTPbtbN)?rBTT@90q*j.4?-*gBo=\aZq>1CIb<j4*MH4o]j_qn9j\B*JBr+ko'AC)V:,sN*F6Yes'FVoAO..CHN<S%U]i=n$OCkdr?qb0&X2K:lXiiQIi;AR7%e:D'/ShJiG0Fa&</I]X2MOC6W_5%JmSg&F/lc($8cut'+8QV[C"!Xb+`1HGITI"1FCg1u*?TrdHNu]QJhZ]FW;/28RP4EP?i\KrU]lbpRc>6H6T?E.k$U\%_Bt;*LB.m<hrQ)eNUS,lHVg>-S_$<!m9n"1CN/n2Hi=S-cS9LW4+eb1"K">$J$!4G.<t>NOm<?>_4[Z^@8I?2<Fu`DKQ*o2/+8q2+Wg>W>3pfuGVAC9h;Df_^Mr)=.1`":#j8(=qh-lC=K/*V'4AWW$O@lWTHb93VK45TAg#sr]Lq*sYk9X#huli_WbS)qbVXjVZUhGSJUV'grYCg5.Cq]okFs;=@7VU+CZ.8J=t>"`GOb^JLm,#&p+6.@Kf\#iWA#ZGppZMQO-Z\LV(<pa%f,kqOFP0A5HKJt=_#>Hs3SV(`AF5n%KU8%2e=NJVdHS6'rQ(j#@8cUbLhn^3SW1;1en>t/,Q9P1QBW\F)"'V^Yd`0;6]0"?t0c7FF-Q';&F<R;u(S@lR`g%f;%T7HVhZj>TDA,@2qA5Dm,DGaCi6&CrlTIRC'4p(h15<a551B?%-D)B@![Wm@0AjZ=:0Do#f+)>4F6rI^J)^.t.\M@)]m_pp1]B=RdAUN[?QXVKIY&+_.sBE2ZT!;AtJgJ;,CH\T'c1VD?pg[rA\]mm9Rql<YO%/#7J@a[]!E8tsirSZDl9L+<'MbieN6M3E4&HU!WPf:e6/m7A[_9PRF8Ou$[0U+sLI(DI%?4k_G*WhX"3q;qBH1,"2Tp_3b;(l-BVmJYD<j2a<]b74j=crJiB:8nZ*[/gibcp$o>p+YT&b1e(N1)[Hm_*IWI^QU`<4972Yhrm%mJoU9X-_05Dk9s^brVfuJSJOeemZNl77*sqHEagn@Xu39QCt'o,FKL"WDl^LA"1s\R]ZtD*AY.TmCtnE\deYSIDL,"VTl.[+oH.P,pr<~>
 endstream
 endobj
 55 0 obj
@@ -566,61 +566,61 @@
 25 0 obj
 <<
 /S /GoTo
-/D [51 0 R /XYZ 85.0 659.0 null]
+/D [51 0 R /XYZ 85.0 603.4 null]
 >>
 endobj
 27 0 obj
 <<
 /S /GoTo
-/D [51 0 R /XYZ 85.0 414.167 null]
+/D [51 0 R /XYZ 85.0 358.567 null]
 >>
 endobj
 29 0 obj
 <<
 /S /GoTo
-/D [51 0 R /XYZ 85.0 335.433 null]
+/D [51 0 R /XYZ 85.0 279.833 null]
 >>
 endobj
 31 0 obj
 <<
 /S /GoTo
-/D [51 0 R /XYZ 85.0 182.46 null]
+/D [53 0 R /XYZ 85.0 659.0 null]
 >>
 endobj
 33 0 obj
 <<
 /S /GoTo
-/D [53 0 R /XYZ 85.0 606.74 null]
+/D [53 0 R /XYZ 85.0 550.287 null]
 >>
 endobj
 35 0 obj
 <<
 /S /GoTo
-/D [53 0 R /XYZ 85.0 511.227 null]
+/D [53 0 R /XYZ 85.0 454.774 null]
 >>
 endobj
 37 0 obj
 <<
 /S /GoTo
-/D [53 0 R /XYZ 85.0 358.254 null]
+/D [53 0 R /XYZ 85.0 301.801 null]
 >>
 endobj
 39 0 obj
 <<
 /S /GoTo
-/D [53 0 R /XYZ 85.0 262.741 null]
+/D [53 0 R /XYZ 85.0 206.288 null]
 >>
 endobj
 41 0 obj
 <<
 /S /GoTo
-/D [55 0 R /XYZ 85.0 659.0 null]
+/D [55 0 R /XYZ 85.0 614.74 null]
 >>
 endobj
 43 0 obj
 <<
 /S /GoTo
-/D [55 0 R /XYZ 85.0 562.406 null]
+/D [55 0 R /XYZ 85.0 518.146 null]
 >>
 endobj
 56 0 obj
@@ -631,86 +631,86 @@
 xref
 0 81
 0000000000 65535 f 
-0000019745 00000 n 
-0000019845 00000 n 
-0000019937 00000 n 
+0000019949 00000 n 
+0000020049 00000 n 
+0000020141 00000 n 
 0000000015 00000 n 
 0000000071 00000 n 
-0000001165 00000 n 
-0000001285 00000 n 
-0000001429 00000 n 
-0000020071 00000 n 
-0000001564 00000 n 
-0000020134 00000 n 
-0000001700 00000 n 
-0000020200 00000 n 
-0000001836 00000 n 
-0000020264 00000 n 
-0000001972 00000 n 
-0000020330 00000 n 
-0000002107 00000 n 
-0000020396 00000 n 
-0000002244 00000 n 
-0000020461 00000 n 
-0000002380 00000 n 
-0000020527 00000 n 
-0000002517 00000 n 
-0000020593 00000 n 
-0000002654 00000 n 
-0000020657 00000 n 
-0000002791 00000 n 
-0000020723 00000 n 
-0000002926 00000 n 
-0000020789 00000 n 
-0000003063 00000 n 
-0000020854 00000 n 
-0000003200 00000 n 
-0000020919 00000 n 
-0000003336 00000 n 
-0000020985 00000 n 
-0000003473 00000 n 
-0000021051 00000 n 
-0000003610 00000 n 
-0000021117 00000 n 
-0000003747 00000 n 
-0000021181 00000 n 
-0000003884 00000 n 
-0000006124 00000 n 
-0000006232 00000 n 
-0000008153 00000 n 
-0000008261 00000 n 
-0000010467 00000 n 
-0000010575 00000 n 
-0000012696 00000 n 
-0000012804 00000 n 
-0000014612 00000 n 
-0000014720 00000 n 
-0000015875 00000 n 
-0000021247 00000 n 
-0000015983 00000 n 
-0000016122 00000 n 
-0000016258 00000 n 
-0000016400 00000 n 
-0000016629 00000 n 
-0000016832 00000 n 
-0000017031 00000 n 
-0000017254 00000 n 
-0000017453 00000 n 
-0000017643 00000 n 
-0000017890 00000 n 
-0000017992 00000 n 
-0000018126 00000 n 
-0000018247 00000 n 
-0000018381 00000 n 
-0000018488 00000 n 
-0000018642 00000 n 
-0000018831 00000 n 
-0000019083 00000 n 
-0000019196 00000 n 
-0000019306 00000 n 
-0000019414 00000 n 
-0000019520 00000 n 
-0000019636 00000 n 
+0000001166 00000 n 
+0000001286 00000 n 
+0000001430 00000 n 
+0000020275 00000 n 
+0000001565 00000 n 
+0000020338 00000 n 
+0000001701 00000 n 
+0000020404 00000 n 
+0000001837 00000 n 
+0000020468 00000 n 
+0000001973 00000 n 
+0000020534 00000 n 
+0000002108 00000 n 
+0000020600 00000 n 
+0000002245 00000 n 
+0000020665 00000 n 
+0000002381 00000 n 
+0000020731 00000 n 
+0000002518 00000 n 
+0000020797 00000 n 
+0000002655 00000 n 
+0000020861 00000 n 
+0000002792 00000 n 
+0000020927 00000 n 
+0000002927 00000 n 
+0000020993 00000 n 
+0000003064 00000 n 
+0000021057 00000 n 
+0000003201 00000 n 
+0000021123 00000 n 
+0000003337 00000 n 
+0000021189 00000 n 
+0000003474 00000 n 
+0000021255 00000 n 
+0000003611 00000 n 
+0000021321 00000 n 
+0000003748 00000 n 
+0000021386 00000 n 
+0000003885 00000 n 
+0000006125 00000 n 
+0000006233 00000 n 
+0000008154 00000 n 
+0000008262 00000 n 
+0000010491 00000 n 
+0000010599 00000 n 
+0000012710 00000 n 
+0000012818 00000 n 
+0000014627 00000 n 
+0000014735 00000 n 
+0000016079 00000 n 
+0000021452 00000 n 
+0000016187 00000 n 
+0000016326 00000 n 
+0000016462 00000 n 
+0000016604 00000 n 
+0000016833 00000 n 
+0000017036 00000 n 
+0000017235 00000 n 
+0000017458 00000 n 
+0000017657 00000 n 
+0000017847 00000 n 
+0000018094 00000 n 
+0000018196 00000 n 
+0000018330 00000 n 
+0000018451 00000 n 
+0000018585 00000 n 
+0000018692 00000 n 
+0000018846 00000 n 
+0000019035 00000 n 
+0000019287 00000 n 
+0000019400 00000 n 
+0000019510 00000 n 
+0000019618 00000 n 
+0000019724 00000 n 
+0000019840 00000 n 
 trailer
 <<
 /Size 81
@@ -718,5 +718,5 @@
 /Info 4 0 R
 >>
 startxref
-21298
+21503
 %%EOF
Index: src/java/org/apache/lucene/queryParser/CharStream.java
===================================================================
--- src/java/org/apache/lucene/queryParser/CharStream.java	(revision 574284)
+++ src/java/org/apache/lucene/queryParser/CharStream.java	(working copy)
@@ -1,4 +1,4 @@
-/* Generated By:JavaCC: Do not edit this line. CharStream.java Version 3.0 */
+/* Generated By:JavaCC: Do not edit this line. CharStream.java Version 4.0 */
 package org.apache.lucene.queryParser;
 
 /**
Index: src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java
===================================================================
--- src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java	(revision 574284)
+++ src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java	(working copy)
@@ -170,16 +170,16 @@
   }
 
  
-  protected Query getRangeQuery(String field, String part1, String part2, boolean inclusive) throws ParseException {
+  protected Query getRangeQuery(String field, String part1, String part2, boolean startInclusive, boolean endInclusive) throws ParseException {
     if (field == null) {
       Vector clauses = new Vector();
       for (int i = 0; i < fields.length; i++) {
-        clauses.add(new BooleanClause(getRangeQuery(fields[i], part1, part2, inclusive),
+        clauses.add(new BooleanClause(getRangeQuery(fields[i], part1, part2, startInclusive, endInclusive),
             BooleanClause.Occur.SHOULD));
       }
       return getBooleanQuery(clauses, true);
     }
-    return super.getRangeQuery(field, part1, part2, inclusive);
+    return super.getRangeQuery(field, part1, part2, startInclusive, endInclusive);
   }
 
   /**
Index: src/java/org/apache/lucene/queryParser/QueryParser.java
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParser.java	(revision 574284)
+++ src/java/org/apache/lucene/queryParser/QueryParser.java	(working copy)
@@ -67,7 +67,7 @@
  * If you use neither {@link DateField} nor {@link DateTools} in your
  * index, you can create your own
  * query parser that inherits QueryParser and overwrites
- * {@link #getRangeQuery(String, String, String, boolean)} to
+ * {@link #getRangeQuery(String, String, String, boolean, boolean)} to
  * use a different method for date conversion.
  * </p>
  *
@@ -528,12 +528,16 @@
 
   /**
    * @exception ParseException throw in overridden method to disallow
+   * @deprecated This method has been deprecated in order to conform to the
+   *             updated range query syntax. Update code to use
+   *             {@link #getRangeQuery(String, String, String, boolean, boolean)}.
    */
   protected Query getRangeQuery(String field,
                                 String part1,
                                 String part2,
                                 boolean inclusive) throws ParseException
   {
+    // Allow code duplication here in order not to break the old API
     if (lowercaseExpandedTerms) {
       part1 = part1.toLowerCase();
       part2 = part2.toLowerCase();
@@ -582,6 +586,72 @@
   }
 
   /**
+   * @exception ParseException throw in overridden method to disallow
+   */
+  protected Query getRangeQuery(String field,
+                                String part1,
+                                String part2,
+                                boolean startInclusive,
+                                boolean endInclusive) throws ParseException
+  {
+    if (startInclusive & endInclusive) {
+      // Use the old method for the time being while it's still apart of the API
+      return getRangeQuery(field, part1, part2, true);
+    }
+
+    if ((startInclusive ^ endInclusive) && useOldRangeQuery) {
+      throw new ParseException("Cannot mix inclusive/exclusive on range query"
+             + " with useOldRangeQuery=true");
+    }
+
+    if (lowercaseExpandedTerms) {
+      part1 = part1.toLowerCase();
+      part2 = part2.toLowerCase();
+    }
+    try {
+      DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT, locale);
+      df.setLenient(true);
+      Date d1 = df.parse(part1);
+      Date d2 = df.parse(part2);
+      if (endInclusive) {
+        // The user can only specify the date, not the time, so make sure
+        // the time is set to the latest possible time of that date to really
+        // include all documents:
+        Calendar cal = Calendar.getInstance(locale);
+        cal.setTime(d2);
+        cal.set(Calendar.HOUR_OF_DAY, 23);
+        cal.set(Calendar.MINUTE, 59);
+        cal.set(Calendar.SECOND, 59);
+        cal.set(Calendar.MILLISECOND, 999);
+        d2 = cal.getTime();
+      }
+      DateTools.Resolution resolution = getDateResolution(field);
+      if (resolution == null) {
+        // no default or field specific date resolution has been set,
+        // use deprecated DateField to maintain compatibilty with
+        // pre-1.9 Lucene versions.
+        part1 = DateField.dateToString(d1);
+        part2 = DateField.dateToString(d2);
+      } else {
+        part1 = DateTools.dateToString(d1, resolution);
+        part2 = DateTools.dateToString(d2, resolution);
+      }
+    }
+    catch (Exception e) { }
+
+    if(useOldRangeQuery)
+    {
+        return new RangeQuery(new Term(field, part1),
+                      new Term(field, part2),
+                      startInclusive & endInclusive);
+    }
+    else
+    {
+      return new ConstantScoreRangeQuery(field,part1,part2,startInclusive,endInclusive);
+    }
+  }
+
+  /**
    * Factory method for generating query, given a set of clauses.
    * By default creates a boolean query composed of clauses passed in.
    *
@@ -1013,7 +1083,7 @@
   }
 
   final public Query Term(String field) throws ParseException {
-  Token term, boost=null, fuzzySlop=null, goop1, goop2;
+  Token term, boost=null, fuzzySlop=null, goop1, goop2, goop3;
   boolean prefix = false;
   boolean wildcard = false;
   boolean fuzzy = false;
@@ -1099,11 +1169,11 @@
     case RANGEIN_START:
       jj_consume_token(RANGEIN_START);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEIN_GOOP:
-        goop1 = jj_consume_token(RANGEIN_GOOP);
+      case RANGE_GOOP:
+        goop1 = jj_consume_token(RANGE_GOOP);
         break;
-      case RANGEIN_QUOTED:
-        goop1 = jj_consume_token(RANGEIN_QUOTED);
+      case RANGE_QUOTED:
+        goop1 = jj_consume_token(RANGE_QUOTED);
         break;
       default:
         jj_la1[12] = jj_gen;
@@ -1111,95 +1181,126 @@
         throw new ParseException();
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEIN_TO:
-        jj_consume_token(RANGEIN_TO);
+      case RANGE_TO:
+        jj_consume_token(RANGE_TO);
         break;
       default:
         jj_la1[13] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEIN_GOOP:
-        goop2 = jj_consume_token(RANGEIN_GOOP);
+      case RANGE_GOOP:
+        goop2 = jj_consume_token(RANGE_GOOP);
         break;
-      case RANGEIN_QUOTED:
-        goop2 = jj_consume_token(RANGEIN_QUOTED);
+      case RANGE_QUOTED:
+        goop2 = jj_consume_token(RANGE_QUOTED);
         break;
       default:
         jj_la1[14] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
-      jj_consume_token(RANGEIN_END);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case RANGEIN_END:
+        goop3 = jj_consume_token(RANGEIN_END);
+        break;
+      case RANGEEX_END:
+        goop3 = jj_consume_token(RANGEEX_END);
+        break;
+      default:
+        jj_la1[15] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case CARAT:
         jj_consume_token(CARAT);
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[15] = jj_gen;
+        jj_la1[16] = jj_gen;
         ;
       }
-          if (goop1.kind == RANGEIN_QUOTED) {
+          if (goop1.kind == RANGE_QUOTED) {
             goop1.image = goop1.image.substring(1, goop1.image.length()-1);
           }
-          if (goop2.kind == RANGEIN_QUOTED) {
+          if (goop2.kind == RANGE_QUOTED) {
             goop2.image = goop2.image.substring(1, goop2.image.length()-1);
           }
-          q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), true);
+
+          if (goop3.kind == RANGEEX_END) {
+            q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), true, false);
+          } else {
+            q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), true, true);
+          }
       break;
     case RANGEEX_START:
       jj_consume_token(RANGEEX_START);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEEX_GOOP:
-        goop1 = jj_consume_token(RANGEEX_GOOP);
+      case RANGE_GOOP:
+        goop1 = jj_consume_token(RANGE_GOOP);
         break;
-      case RANGEEX_QUOTED:
-        goop1 = jj_consume_token(RANGEEX_QUOTED);
+      case RANGE_QUOTED:
+        goop1 = jj_consume_token(RANGE_QUOTED);
         break;
       default:
-        jj_la1[16] = jj_gen;
+        jj_la1[17] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEEX_TO:
-        jj_consume_token(RANGEEX_TO);
+      case RANGE_TO:
+        jj_consume_token(RANGE_TO);
         break;
       default:
-        jj_la1[17] = jj_gen;
+        jj_la1[18] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case RANGEEX_GOOP:
-        goop2 = jj_consume_token(RANGEEX_GOOP);
+      case RANGE_GOOP:
+        goop2 = jj_consume_token(RANGE_GOOP);
         break;
-      case RANGEEX_QUOTED:
-        goop2 = jj_consume_token(RANGEEX_QUOTED);
+      case RANGE_QUOTED:
+        goop2 = jj_consume_token(RANGE_QUOTED);
         break;
       default:
-        jj_la1[18] = jj_gen;
+        jj_la1[19] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
-      jj_consume_token(RANGEEX_END);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case RANGEEX_END:
+        goop3 = jj_consume_token(RANGEEX_END);
+        break;
+      case RANGEIN_END:
+        goop3 = jj_consume_token(RANGEIN_END);
+        break;
+      default:
+        jj_la1[20] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case CARAT:
         jj_consume_token(CARAT);
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[19] = jj_gen;
+        jj_la1[21] = jj_gen;
         ;
       }
-          if (goop1.kind == RANGEEX_QUOTED) {
+          if (goop1.kind == RANGE_QUOTED) {
             goop1.image = goop1.image.substring(1, goop1.image.length()-1);
           }
-          if (goop2.kind == RANGEEX_QUOTED) {
+          if (goop2.kind == RANGE_QUOTED) {
             goop2.image = goop2.image.substring(1, goop2.image.length()-1);
           }
 
-          q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), false);
+          if (goop3.kind == RANGEIN_END) {
+            q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), false, true);
+          } else {
+            q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), false, false);
+          }
       break;
     case QUOTED:
       term = jj_consume_token(QUOTED);
@@ -1208,7 +1309,7 @@
         fuzzySlop = jj_consume_token(FUZZY_SLOP);
         break;
       default:
-        jj_la1[20] = jj_gen;
+        jj_la1[22] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -1217,7 +1318,7 @@
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[21] = jj_gen;
+        jj_la1[23] = jj_gen;
         ;
       }
          int s = phraseSlop;
@@ -1231,7 +1332,7 @@
          q = getFieldQuery(field, discardEscapeChar(term.image.substring(1, term.image.length()-1)), s);
       break;
     default:
-      jj_la1[22] = jj_gen;
+      jj_la1[24] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -1292,19 +1393,14 @@
   public boolean lookingAhead = false;
   private boolean jj_semLA;
   private int jj_gen;
-  final private int[] jj_la1 = new int[23];
+  final private int[] jj_la1 = new int[25];
   static private int[] jj_la1_0;
-  static private int[] jj_la1_1;
   static {
       jj_la1_0();
-      jj_la1_1();
    }
    private static void jj_la1_0() {
-      jj_la1_0 = new int[] {0x180,0x180,0xe00,0xe00,0x1f69f80,0x48000,0x10000,0x1f69000,0x1348000,0x80000,0x80000,0x10000,0x18000000,0x2000000,0x18000000,0x10000,0x80000000,0x20000000,0x80000000,0x10000,0x80000,0x10000,0x1f68000,};
+      jj_la1_0 = new int[] {0x180,0x180,0xe00,0xe00,0x1f69f80,0x48000,0x10000,0x1f69000,0x1348000,0x80000,0x80000,0x10000,0x30000000,0x2000000,0x30000000,0xc000000,0x10000,0x30000000,0x2000000,0x30000000,0xc000000,0x10000,0x80000,0x10000,0x1f68000,};
    }
-   private static void jj_la1_1() {
-      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x0,};
-   }
   final private JJCalls[] jj_2_rtns = new JJCalls[1];
   private boolean jj_rescan = false;
   private int jj_gc = 0;
@@ -1314,7 +1410,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 23; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -1323,7 +1419,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 23; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -1332,7 +1428,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 23; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -1341,7 +1437,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 23; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 25; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -1452,27 +1548,24 @@
 
   public ParseException generateParseException() {
     jj_expentries.removeAllElements();
-    boolean[] la1tokens = new boolean[33];
-    for (int i = 0; i < 33; i++) {
+    boolean[] la1tokens = new boolean[30];
+    for (int i = 0; i < 30; i++) {
       la1tokens[i] = false;
     }
     if (jj_kind >= 0) {
       la1tokens[jj_kind] = true;
       jj_kind = -1;
     }
-    for (int i = 0; i < 23; i++) {
+    for (int i = 0; i < 25; i++) {
       if (jj_la1[i] == jj_gen) {
         for (int j = 0; j < 32; j++) {
           if ((jj_la1_0[i] & (1<<j)) != 0) {
             la1tokens[j] = true;
           }
-          if ((jj_la1_1[i] & (1<<j)) != 0) {
-            la1tokens[32+j] = true;
-          }
         }
       }
     }
-    for (int i = 0; i < 33; i++) {
+    for (int i = 0; i < 30; i++) {
       if (la1tokens[i]) {
         jj_expentry = new int[1];
         jj_expentry[0] = i;
@@ -1498,6 +1591,7 @@
   final private void jj_rescan_token() {
     jj_rescan = true;
     for (int i = 0; i < 1; i++) {
+    try {
       JJCalls p = jj_2_rtns[i];
       do {
         if (p.gen > jj_gen) {
@@ -1508,6 +1602,7 @@
         }
         p = p.next;
       } while (p != null);
+      } catch(LookaheadSuccess ls) { }
     }
     jj_rescan = false;
   }
Index: src/java/org/apache/lucene/queryParser/QueryParser.jj
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParser.jj	(revision 574284)
+++ src/java/org/apache/lucene/queryParser/QueryParser.jj	(working copy)
@@ -91,7 +91,7 @@
  * If you use neither {@link DateField} nor {@link DateTools} in your
  * index, you can create your own
  * query parser that inherits QueryParser and overwrites
- * {@link #getRangeQuery(String, String, String, boolean)} to
+ * {@link #getRangeQuery(String, String, String, boolean, boolean)} to
  * use a different method for date conversion.
  * </p>
  *
@@ -552,12 +552,16 @@
 
   /**
    * @exception ParseException throw in overridden method to disallow
+   * @deprecated This method has been deprecated in order to conform to the
+   *             updated range query syntax. Update code to use
+   *             {@link #getRangeQuery(String, String, String, boolean, boolean)}.
    */
   protected Query getRangeQuery(String field,
                                 String part1,
                                 String part2,
                                 boolean inclusive) throws ParseException
   {
+    // Allow code duplication here in order not to break the old API
     if (lowercaseExpandedTerms) {
       part1 = part1.toLowerCase();
       part2 = part2.toLowerCase();
@@ -606,6 +610,72 @@
   }
 
   /**
+   * @exception ParseException throw in overridden method to disallow
+   */
+  protected Query getRangeQuery(String field,
+                                String part1,
+                                String part2,
+                                boolean startInclusive,
+                                boolean endInclusive) throws ParseException
+  {
+    if (startInclusive & endInclusive) {
+      // Use the old method for the time being while it's still apart of the API
+      return getRangeQuery(field, part1, part2, true);
+    }
+
+    if ((startInclusive ^ endInclusive) && useOldRangeQuery) {
+      throw new ParseException("Cannot mix inclusive/exclusive on range query"
+             + " with useOldRangeQuery=true");    
+    }
+
+    if (lowercaseExpandedTerms) {
+      part1 = part1.toLowerCase();
+      part2 = part2.toLowerCase();
+    }
+    try {
+      DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT, locale);
+      df.setLenient(true);
+      Date d1 = df.parse(part1);
+      Date d2 = df.parse(part2);
+      if (endInclusive) {
+        // The user can only specify the date, not the time, so make sure
+        // the time is set to the latest possible time of that date to really
+        // include all documents:
+        Calendar cal = Calendar.getInstance(locale);
+        cal.setTime(d2);
+        cal.set(Calendar.HOUR_OF_DAY, 23);
+        cal.set(Calendar.MINUTE, 59);
+        cal.set(Calendar.SECOND, 59);
+        cal.set(Calendar.MILLISECOND, 999);
+        d2 = cal.getTime();
+      }
+      DateTools.Resolution resolution = getDateResolution(field);
+      if (resolution == null) {
+        // no default or field specific date resolution has been set,
+        // use deprecated DateField to maintain compatibilty with
+        // pre-1.9 Lucene versions.
+        part1 = DateField.dateToString(d1);
+        part2 = DateField.dateToString(d2);
+      } else {
+        part1 = DateTools.dateToString(d1, resolution);
+        part2 = DateTools.dateToString(d2, resolution);
+      }
+    }
+    catch (Exception e) { }
+
+    if(useOldRangeQuery)
+    {
+        return new RangeQuery(new Term(field, part1),
+                      new Term(field, part2),
+                      startInclusive & endInclusive);
+    }
+    else
+    {
+      return new ConstantScoreRangeQuery(field,part1,part2,startInclusive,endInclusive);
+    }
+  }
+
+  /**
    * Factory method for generating query, given a set of clauses.
    * By default creates a boolean query composed of clauses passed in.
    *
@@ -873,7 +943,7 @@
 | <#_WHITESPACE: ( " " | "\t" | "\n" | "\r") >
 }
 
-<DEFAULT, RangeIn, RangeEx> SKIP : {
+<DEFAULT, Range> SKIP : {
   < <_WHITESPACE>>
 }
 
@@ -893,26 +963,20 @@
 | <FUZZY_SLOP:     "~" ( (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? )? >
 | <PREFIXTERM:  ("*") | ( <_TERM_START_CHAR> (<_TERM_CHAR>)* "*" ) >
 | <WILDTERM:  (<_TERM_START_CHAR> | [ "*", "?" ]) (<_TERM_CHAR> | ( [ "*", "?" ] ))* >
-| <RANGEIN_START: "[" > : RangeIn
-| <RANGEEX_START: "{" > : RangeEx
+| <RANGEIN_START: "[" > : Range
+| <RANGEEX_START: "{" > : Range
 }
 
 <Boost> TOKEN : {
 <NUMBER:    (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? > : DEFAULT
 }
 
-<RangeIn> TOKEN : {
-<RANGEIN_TO: "TO">
+<Range> TOKEN : {
+<RANGE_TO: "TO">
 | <RANGEIN_END: "]"> : DEFAULT
-| <RANGEIN_QUOTED: "\"" (~["\""] | "\\\"")+ "\"">
-| <RANGEIN_GOOP: (~[ " ", "]" ])+ >
-}
-
-<RangeEx> TOKEN : {
-<RANGEEX_TO: "TO">
 | <RANGEEX_END: "}"> : DEFAULT
-| <RANGEEX_QUOTED: "\"" (~["\""] | "\\\"")+ "\"">
-| <RANGEEX_GOOP: (~[ " ", "}" ])+ >
+| <RANGE_QUOTED: "\"" (~["\""] | "\\\"")+ "\"">
+| <RANGE_GOOP: (~[ " ", "]", "}" ])+ >
 }
 
 // *   Query  ::= ( Clause )*
@@ -1011,7 +1075,7 @@
 
 
 Query Term(String field) : {
-  Token term, boost=null, fuzzySlop=null, goop1, goop2;
+  Token term, boost=null, fuzzySlop=null, goop1, goop2, goop3;
   boolean prefix = false;
   boolean wildcard = false;
   boolean fuzzy = false;
@@ -1050,32 +1114,41 @@
          q = getFieldQuery(field, termImage);
        }
      }
-     | ( <RANGEIN_START> ( goop1=<RANGEIN_GOOP>|goop1=<RANGEIN_QUOTED> )
-         [ <RANGEIN_TO> ] ( goop2=<RANGEIN_GOOP>|goop2=<RANGEIN_QUOTED> )
-         <RANGEIN_END> )
+     | ( <RANGEIN_START> ( goop1=<RANGE_GOOP>|goop1=<RANGE_QUOTED> )
+         [ <RANGE_TO> ] ( goop2=<RANGE_GOOP>|goop2=<RANGE_QUOTED> )
+         ( goop3=<RANGEIN_END>|goop3=<RANGEEX_END> ) )
        [ <CARAT> boost=<NUMBER> ]
         {
-          if (goop1.kind == RANGEIN_QUOTED) {
+          if (goop1.kind == RANGE_QUOTED) {
             goop1.image = goop1.image.substring(1, goop1.image.length()-1);
           }
-          if (goop2.kind == RANGEIN_QUOTED) {
+          if (goop2.kind == RANGE_QUOTED) {
             goop2.image = goop2.image.substring(1, goop2.image.length()-1);
           }
-          q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), true);
+
+          if (goop3.kind == RANGEEX_END) {
+            q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), true, false);
+          } else {
+            q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), true, true);
+          }
         }
-     | ( <RANGEEX_START> ( goop1=<RANGEEX_GOOP>|goop1=<RANGEEX_QUOTED> )
-         [ <RANGEEX_TO> ] ( goop2=<RANGEEX_GOOP>|goop2=<RANGEEX_QUOTED> )
-         <RANGEEX_END> )
+     | ( <RANGEEX_START> ( goop1=<RANGE_GOOP>|goop1=<RANGE_QUOTED> )
+         [ <RANGE_TO> ] ( goop2=<RANGE_GOOP>|goop2=<RANGE_QUOTED> )
+         ( goop3=<RANGEEX_END>|goop3=<RANGEIN_END> ) )
        [ <CARAT> boost=<NUMBER> ]
         {
-          if (goop1.kind == RANGEEX_QUOTED) {
+          if (goop1.kind == RANGE_QUOTED) {
             goop1.image = goop1.image.substring(1, goop1.image.length()-1);
           }
-          if (goop2.kind == RANGEEX_QUOTED) {
+          if (goop2.kind == RANGE_QUOTED) {
             goop2.image = goop2.image.substring(1, goop2.image.length()-1);
           }
 
-          q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), false);
+          if (goop3.kind == RANGEIN_END) {
+            q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), false, true);
+          } else {
+            q = getRangeQuery(field, discardEscapeChar(goop1.image), discardEscapeChar(goop2.image), false, false);
+          }
         }
      | term=<QUOTED>
        [ fuzzySlop=<FUZZY_SLOP> ]
Index: src/java/org/apache/lucene/queryParser/QueryParserConstants.java
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParserConstants.java	(revision 574284)
+++ src/java/org/apache/lucene/queryParser/QueryParserConstants.java	(working copy)
@@ -27,19 +27,15 @@
   int RANGEIN_START = 22;
   int RANGEEX_START = 23;
   int NUMBER = 24;
-  int RANGEIN_TO = 25;
+  int RANGE_TO = 25;
   int RANGEIN_END = 26;
-  int RANGEIN_QUOTED = 27;
-  int RANGEIN_GOOP = 28;
-  int RANGEEX_TO = 29;
-  int RANGEEX_END = 30;
-  int RANGEEX_QUOTED = 31;
-  int RANGEEX_GOOP = 32;
+  int RANGEEX_END = 27;
+  int RANGE_QUOTED = 28;
+  int RANGE_GOOP = 29;
 
   int Boost = 0;
-  int RangeEx = 1;
-  int RangeIn = 2;
-  int DEFAULT = 3;
+  int Range = 1;
+  int DEFAULT = 2;
 
   String[] tokenImage = {
     "<EOF>",
@@ -69,12 +65,9 @@
     "<NUMBER>",
     "\"TO\"",
     "\"]\"",
-    "<RANGEIN_QUOTED>",
-    "<RANGEIN_GOOP>",
-    "\"TO\"",
     "\"}\"",
-    "<RANGEEX_QUOTED>",
-    "<RANGEEX_GOOP>",
+    "<RANGE_QUOTED>",
+    "<RANGE_GOOP>",
   };
 
 }
Index: src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java	(revision 574284)
+++ src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java	(working copy)
@@ -14,7 +14,7 @@
 {
   public  java.io.PrintStream debugStream = System.out;
   public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
-private final int jjStopStringLiteralDfa_3(int pos, long active0)
+private final int jjStopStringLiteralDfa_2(int pos, long active0)
 {
    switch (pos)
    {
@@ -22,9 +22,9 @@
          return -1;
    }
 }
-private final int jjStartNfa_3(int pos, long active0)
+private final int jjStartNfa_2(int pos, long active0)
 {
-   return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
+   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
 }
 private final int jjStopAtPos(int pos, int kind)
 {
@@ -32,15 +32,15 @@
    jjmatchedPos = pos;
    return pos + 1;
 }
-private final int jjStartNfaWithStates_3(int pos, int kind, int state)
+private final int jjStartNfaWithStates_2(int pos, int kind, int state)
 {
    jjmatchedKind = kind;
    jjmatchedPos = pos;
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_3(state, pos + 1);
+   return jjMoveNfa_2(state, pos + 1);
 }
-private final int jjMoveStringLiteralDfa0_3()
+private final int jjMoveStringLiteralDfa0_2()
 {
    switch(curChar)
    {
@@ -49,7 +49,7 @@
       case 41:
          return jjStopAtPos(0, 13);
       case 42:
-         return jjStartNfaWithStates_3(0, 15, 36);
+         return jjStartNfaWithStates_2(0, 15, 36);
       case 43:
          return jjStopAtPos(0, 10);
       case 45:
@@ -63,7 +63,7 @@
       case 123:
          return jjStopAtPos(0, 23);
       default :
-         return jjMoveNfa_3(0, 0);
+         return jjMoveNfa_2(0, 0);
    }
 }
 private final void jjCheckNAdd(int state)
@@ -102,7 +102,7 @@
 static final long[] jjbitVec2 = {
    0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
 };
-private final int jjMoveNfa_3(int startState, int curPos)
+private final int jjMoveNfa_2(int startState, int curPos)
 {
    int[] nextStates;
    int startsAt = 0;
@@ -502,190 +502,6 @@
       catch(java.io.IOException e) { return curPos; }
    }
 }
-private final int jjStopStringLiteralDfa_1(int pos, long active0)
-{
-   switch (pos)
-   {
-      case 0:
-         if ((active0 & 0x20000000L) != 0L)
-         {
-            jjmatchedKind = 32;
-            return 6;
-         }
-         return -1;
-      default :
-         return -1;
-   }
-}
-private final int jjStartNfa_1(int pos, long active0)
-{
-   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
-}
-private final int jjStartNfaWithStates_1(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_1(state, pos + 1);
-}
-private final int jjMoveStringLiteralDfa0_1()
-{
-   switch(curChar)
-   {
-      case 84:
-         return jjMoveStringLiteralDfa1_1(0x20000000L);
-      case 125:
-         return jjStopAtPos(0, 30);
-      default :
-         return jjMoveNfa_1(0, 0);
-   }
-}
-private final int jjMoveStringLiteralDfa1_1(long active0)
-{
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_1(0, active0);
-      return 1;
-   }
-   switch(curChar)
-   {
-      case 79:
-         if ((active0 & 0x20000000L) != 0L)
-            return jjStartNfaWithStates_1(1, 29, 6);
-         break;
-      default :
-         break;
-   }
-   return jjStartNfa_1(0, active0);
-}
-private final int jjMoveNfa_1(int startState, int curPos)
-{
-   int[] nextStates;
-   int startsAt = 0;
-   jjnewStateCnt = 7;
-   int i = 1;
-   jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
-   for (;;)
-   {
-      if (++jjround == 0x7fffffff)
-         ReInitRounds();
-      if (curChar < 64)
-      {
-         long l = 1L << curChar;
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-                  if ((0xfffffffeffffffffL & l) != 0L)
-                  {
-                     if (kind > 32)
-                        kind = 32;
-                     jjCheckNAdd(6);
-                  }
-                  if ((0x100002600L & l) != 0L)
-                  {
-                     if (kind > 6)
-                        kind = 6;
-                  }
-                  else if (curChar == 34)
-                     jjCheckNAddTwoStates(2, 4);
-                  break;
-               case 1:
-                  if (curChar == 34)
-                     jjCheckNAddTwoStates(2, 4);
-                  break;
-               case 2:
-                  if ((0xfffffffbffffffffL & l) != 0L)
-                     jjCheckNAddStates(16, 18);
-                  break;
-               case 3:
-                  if (curChar == 34)
-                     jjCheckNAddStates(16, 18);
-                  break;
-               case 5:
-                  if (curChar == 34 && kind > 31)
-                     kind = 31;
-                  break;
-               case 6:
-                  if ((0xfffffffeffffffffL & l) == 0L)
-                     break;
-                  if (kind > 32)
-                     kind = 32;
-                  jjCheckNAdd(6);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else if (curChar < 128)
-      {
-         long l = 1L << (curChar & 077);
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-               case 6:
-                  if ((0xdfffffffffffffffL & l) == 0L)
-                     break;
-                  if (kind > 32)
-                     kind = 32;
-                  jjCheckNAdd(6);
-                  break;
-               case 2:
-                  jjAddStates(16, 18);
-                  break;
-               case 4:
-                  if (curChar == 92)
-                     jjstateSet[jjnewStateCnt++] = 3;
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      else
-      {
-         int hiByte = (int)(curChar >> 8);
-         int i1 = hiByte >> 6;
-         long l1 = 1L << (hiByte & 077);
-         int i2 = (curChar & 0xff) >> 6;
-         long l2 = 1L << (curChar & 077);
-         MatchLoop: do
-         {
-            switch(jjstateSet[--i])
-            {
-               case 0:
-               case 6:
-                  if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     break;
-                  if (kind > 32)
-                     kind = 32;
-                  jjCheckNAdd(6);
-                  break;
-               case 2:
-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     jjAddStates(16, 18);
-                  break;
-               default : break;
-            }
-         } while(i != startsAt);
-      }
-      if (kind != 0x7fffffff)
-      {
-         jjmatchedKind = kind;
-         jjmatchedPos = curPos;
-         kind = 0x7fffffff;
-      }
-      ++curPos;
-      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
-         return curPos;
-      try { curChar = input_stream.readChar(); }
-      catch(java.io.IOException e) { return curPos; }
-   }
-}
 private final int jjMoveStringLiteralDfa0_0()
 {
    return jjMoveNfa_0(0, 0);
@@ -714,7 +530,7 @@
                      break;
                   if (kind > 24)
                      kind = 24;
-                  jjAddStates(19, 20);
+                  jjAddStates(16, 17);
                   break;
                case 1:
                   if (curChar == 46)
@@ -770,14 +586,14 @@
       catch(java.io.IOException e) { return curPos; }
    }
 }
-private final int jjStopStringLiteralDfa_2(int pos, long active0)
+private final int jjStopStringLiteralDfa_1(int pos, long active0)
 {
    switch (pos)
    {
       case 0:
          if ((active0 & 0x2000000L) != 0L)
          {
-            jjmatchedKind = 28;
+            jjmatchedKind = 29;
             return 6;
          }
          return -1;
@@ -785,49 +601,51 @@
          return -1;
    }
 }
-private final int jjStartNfa_2(int pos, long active0)
+private final int jjStartNfa_1(int pos, long active0)
 {
-   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
+   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
 }
-private final int jjStartNfaWithStates_2(int pos, int kind, int state)
+private final int jjStartNfaWithStates_1(int pos, int kind, int state)
 {
    jjmatchedKind = kind;
    jjmatchedPos = pos;
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_2(state, pos + 1);
+   return jjMoveNfa_1(state, pos + 1);
 }
-private final int jjMoveStringLiteralDfa0_2()
+private final int jjMoveStringLiteralDfa0_1()
 {
    switch(curChar)
    {
       case 84:
-         return jjMoveStringLiteralDfa1_2(0x2000000L);
+         return jjMoveStringLiteralDfa1_1(0x2000000L);
       case 93:
          return jjStopAtPos(0, 26);
+      case 125:
+         return jjStopAtPos(0, 27);
       default :
-         return jjMoveNfa_2(0, 0);
+         return jjMoveNfa_1(0, 0);
    }
 }
-private final int jjMoveStringLiteralDfa1_2(long active0)
+private final int jjMoveStringLiteralDfa1_1(long active0)
 {
    try { curChar = input_stream.readChar(); }
    catch(java.io.IOException e) {
-      jjStopStringLiteralDfa_2(0, active0);
+      jjStopStringLiteralDfa_1(0, active0);
       return 1;
    }
    switch(curChar)
    {
       case 79:
          if ((active0 & 0x2000000L) != 0L)
-            return jjStartNfaWithStates_2(1, 25, 6);
+            return jjStartNfaWithStates_1(1, 25, 6);
          break;
       default :
          break;
    }
-   return jjStartNfa_2(0, active0);
+   return jjStartNfa_1(0, active0);
 }
-private final int jjMoveNfa_2(int startState, int curPos)
+private final int jjMoveNfa_1(int startState, int curPos)
 {
    int[] nextStates;
    int startsAt = 0;
@@ -849,8 +667,8 @@
                case 0:
                   if ((0xfffffffeffffffffL & l) != 0L)
                   {
-                     if (kind > 28)
-                        kind = 28;
+                     if (kind > 29)
+                        kind = 29;
                      jjCheckNAdd(6);
                   }
                   if ((0x100002600L & l) != 0L)
@@ -867,21 +685,21 @@
                   break;
                case 2:
                   if ((0xfffffffbffffffffL & l) != 0L)
-                     jjCheckNAddStates(16, 18);
+                     jjCheckNAddStates(18, 20);
                   break;
                case 3:
                   if (curChar == 34)
-                     jjCheckNAddStates(16, 18);
+                     jjCheckNAddStates(18, 20);
                   break;
                case 5:
-                  if (curChar == 34 && kind > 27)
-                     kind = 27;
+                  if (curChar == 34 && kind > 28)
+                     kind = 28;
                   break;
                case 6:
                   if ((0xfffffffeffffffffL & l) == 0L)
                      break;
-                  if (kind > 28)
-                     kind = 28;
+                  if (kind > 29)
+                     kind = 29;
                   jjCheckNAdd(6);
                   break;
                default : break;
@@ -897,14 +715,14 @@
             {
                case 0:
                case 6:
-                  if ((0xffffffffdfffffffL & l) == 0L)
+                  if ((0xdfffffffdfffffffL & l) == 0L)
                      break;
-                  if (kind > 28)
-                     kind = 28;
+                  if (kind > 29)
+                     kind = 29;
                   jjCheckNAdd(6);
                   break;
                case 2:
-                  jjAddStates(16, 18);
+                  jjAddStates(18, 20);
                   break;
                case 4:
                   if (curChar == 92)
@@ -929,13 +747,13 @@
                case 6:
                   if (!jjCanMove_0(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 28)
-                     kind = 28;
+                  if (kind > 29)
+                     kind = 29;
                   jjCheckNAdd(6);
                   break;
                case 2:
                   if (jjCanMove_0(hiByte, i1, i2, l1, l2))
-                     jjAddStates(16, 18);
+                     jjAddStates(18, 20);
                   break;
                default : break;
             }
@@ -955,8 +773,8 @@
    }
 }
 static final int[] jjnextStates = {
-   29, 32, 23, 33, 30, 15, 17, 18, 20, 21, 32, 23, 33, 31, 34, 27, 
-   2, 4, 5, 0, 1, 
+   29, 32, 23, 33, 30, 15, 17, 18, 20, 21, 32, 23, 33, 31, 34, 27,
+   0, 1, 2, 4, 5,
 };
 private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
 {
@@ -964,42 +782,39 @@
    {
       case 0:
          return ((jjbitVec2[i2] & l2) != 0L);
-      default : 
+      default :
          if ((jjbitVec0[i1] & l1) != 0L)
             return true;
          return false;
    }
 }
 public static final String[] jjstrLiteralImages = {
-"", null, null, null, null, null, null, null, null, null, "\53", "\55", "\50", 
-"\51", "\72", "\52", "\136", null, null, null, null, null, "\133", "\173", null, 
-"\124\117", "\135", null, null, "\124\117", "\175", null, null, };
+"", null, null, null, null, null, null, null, null, null, "\53", "\55", "\50",
+"\51", "\72", "\52", "\136", null, null, null, null, null, "\133", "\173", null,
+"\124\117", "\135", "\175", null, null, };
 public static final String[] lexStateNames = {
-   "Boost", 
-   "RangeEx", 
-   "RangeIn", 
-   "DEFAULT", 
+   "Boost",
+   "Range",
+   "DEFAULT",
 };
 public static final int[] jjnewLexState = {
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 2, 1, 3, 
-   -1, 3, -1, -1, -1, 3, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1, -1, -1, -1, -1, 1, 1, 2,
+   -1, 2, 2, -1, -1,
 };
 static final long[] jjtoToken = {
-   0x1ffffff81L, 
+   0x3fffff81L,
 };
 static final long[] jjtoSkip = {
-   0x40L, 
+   0x40L,
 };
 protected CharStream input_stream;
 private final int[] jjrounds = new int[36];
 private final int[] jjstateSet = new int[72];
 protected char curChar;
-public QueryParserTokenManager(CharStream stream)
-{
+public QueryParserTokenManager(CharStream stream){
    input_stream = stream;
 }
-public QueryParserTokenManager(CharStream stream, int lexState)
-{
+public QueryParserTokenManager(CharStream stream, int lexState){
    this(stream);
    SwitchTo(lexState);
 }
@@ -1024,7 +839,7 @@
 }
 public void SwitchTo(int lexState)
 {
-   if (lexState >= 4 || lexState < 0)
+   if (lexState >= 3 || lexState < 0)
       throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
    else
       curLexState = lexState;
@@ -1043,14 +858,14 @@
    return t;
 }
 
-int curLexState = 3;
-int defaultLexState = 3;
+int curLexState = 2;
+int defaultLexState = 2;
 int jjnewStateCnt;
 int jjround;
 int jjmatchedPos;
 int jjmatchedKind;
 
-public Token getNextToken() 
+public Token getNextToken()
 {
   int kind;
   Token specialToken = null;
@@ -1059,13 +874,13 @@
 
   EOFLoop :
   for (;;)
-  {   
-   try   
-   {     
+  {
+   try
+   {
       curChar = input_stream.BeginToken();
-   }     
+   }
    catch(java.io.IOException e)
-   {        
+   {
       jjmatchedKind = 0;
       matchedToken = jjFillToken();
       return matchedToken;
@@ -1088,11 +903,6 @@
        jjmatchedPos = 0;
        curPos = jjMoveStringLiteralDfa0_2();
        break;
-     case 3:
-       jjmatchedKind = 0x7fffffff;
-       jjmatchedPos = 0;
-       curPos = jjMoveStringLiteralDfa0_3();
-       break;
    }
      if (jjmatchedKind != 0x7fffffff)
      {
Index: src/site/src/documentation/content/xdocs/queryparsersyntax.xml
===================================================================
--- src/site/src/documentation/content/xdocs/queryparsersyntax.xml	(revision 574284)
+++ src/site/src/documentation/content/xdocs/queryparsersyntax.xml	(working copy)
@@ -129,8 +129,11 @@
             <p>This will find documents whose mod_date fields have values between 20020101 and 20030101, inclusive.
             Note that Range Queries are not reserved for date fields.  You could also use range queries with non-date fields:</p>
             <source>title:{Aida TO Carmen}</source>
-            <p>This will find all documents whose titles are between Aida and Carmen, but not including Aida and Carmen.</p>
-            <p>Inclusive range queries are denoted by square brackets.  Exclusive range queries are denoted by
+            <p>This will find all documents whose titles are between Aida and Carmen, but not including Aida and Carmen.
+            Note that Range Queries need not be solely inclusive or exclusive:</p>
+            <source>firstName:[Bob TO Mike}</source>
+            <p>This will find all documents whose firstName fields have values between Bob and Mike, including Bob but not Mike.</p>
+            <p>Inclusive range query bounds are denoted by square brackets.  Exclusive range query bounds are denoted by
             curly brackets.</p>
         </section>
 
Index: src/test/org/apache/lucene/queryParser/TestQueryParser.java
===================================================================
--- src/test/org/apache/lucene/queryParser/TestQueryParser.java	(revision 574284)
+++ src/test/org/apache/lucene/queryParser/TestQueryParser.java	(working copy)
@@ -128,6 +128,16 @@
            + "/, expecting /" + result + "/");
     }
   }
+  
+  public void assertQueryNotEquals(String query1, String query2, Analyzer a)
+    throws Exception {
+    Query q1 = getQuery(query1, a);
+    Query q2 = getQuery(query2, a);
+    if (q1.equals(q2)) {
+      fail("Query /" + query1 + "/ is equal to /" + query2
+           + "/, expected not equal");
+    }
+  }
 
   public void assertQueryEquals(QueryParser qp, String field, String query, String result) 
     throws Exception {
@@ -409,6 +419,55 @@
     assertQueryEquals("[ a TO z] AND bar", null, "+[a TO z] +bar");
     assertQueryEquals("( bar blar { a TO z}) ", null, "bar blar {a TO z}");
     assertQueryEquals("gack ( bar blar { a TO z}) ", null, "gack (bar blar {a TO z})");
+
+    try {
+      qp.parse("[a TO z}");
+      fail();
+    } catch (ParseException e) {
+      // Expected exception
+    }
+    try {
+      qp.parse("{a TO z]");
+      fail();
+    } catch (ParseException e) {
+      // Expected exception
+    }
+
+    qp.setUseOldRangeQuery(false);    
+    try {
+      qp.parse("[a TO z}");
+    } catch (ParseException e) {
+      fail();
+    }
+    try {
+      qp.parse("{a TO z]");
+    } catch (ParseException e) {
+      fail();
+    }
+    
+    assertQueryNotEquals("[a TO z}", "{a TO z]", null);
+    assertQueryNotEquals("[a TO z}", "{a TO z}", null);
+    assertQueryNotEquals("{a TO z]", "[a TO z}", null);
+    assertQueryNotEquals("{a TO z]", "[a TO z]", null);
+    assertQueryNotEquals("[a TO z]", "{a TO z}", null);
+    assertQueryNotEquals("[a TO z]", "{a TO z]", null);
+    assertQueryNotEquals("[a TO z]", "[a TO z}", null);
+    assertQueryNotEquals("{a TO z}", "[a TO z}", null);
+    assertQueryNotEquals("{a TO z}", "{a TO z]", null);
+    
+    assertQueryEquals("[ a TO z }", null, "[a TO z}");
+    assertQueryEquals("{ a TO z ]", null, "{a TO z]");
+    assertQueryEquals("[ a TO z}", null, "[a TO z}");
+    assertQueryEquals("{ a TO z]", null, "{a TO z]");
+    assertQueryEquals("[ a TO z }^2.0", null, "[a TO z}^2.0");
+    assertQueryEquals("[ a TO z} OR bar", null, "[a TO z} bar");
+    assertQueryEquals("{ a TO z] OR bar", null, "{a TO z] bar");
+    assertQueryEquals("[ a TO z} AND bar", null, "+[a TO z} +bar");
+    assertQueryEquals("{ a TO z] AND bar", null, "+{a TO z] +bar");
+    assertQueryEquals("( bar blar [ a TO z}) ", null, "bar blar [a TO z}");
+    assertQueryEquals("( bar blar { a TO z]) ", null, "bar blar {a TO z]");
+    assertQueryEquals("gack ( bar blar [ a TO z}) ", null, "gack (bar blar [a TO z})");
+    assertQueryEquals("gack ( bar blar { a TO z]) ", null, "gack (bar blar {a TO z])");
   }
   
   /** for testing legacy DateField support */
