Index: lucene/src/java/org/apache/lucene/search/BooleanQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/BooleanQuery.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/BooleanQuery.java	(working copy)
@@ -31,6 +31,30 @@
   * BooleanQuerys.
   */
 public class BooleanQuery extends Query implements Iterable<BooleanClause> {
+	
+	@Override
+	public void setDisallowCrossMatches(boolean dcm) { 
+		this.disallowCrossMatches = dcm; 
+		for(BooleanClause clause : clauses) {
+			clause.getQuery().setDisallowCrossMatches(dcm);
+		}
+	}
+	
+	@Override
+  public void setPositionIncrementGap(int gap) { 
+		this.positionIncrementGap = gap; 
+		for(BooleanClause clause : clauses) {
+			clause.getQuery().setPositionIncrementGap(gap);
+		}
+	}
+	
+	@Override
+  public boolean isDisallowCrossMatches() { return disallowCrossMatches && positionIncrementGap > 0; }
+  
+	public int getPositionIncrementGap() { return positionIncrementGap; }
+  
+  private int positionIncrementGap = 0;
+  private boolean disallowCrossMatches = false;
 
   private static int maxClauseCount = 1024;
 
Index: lucene/src/java/org/apache/lucene/search/ConjunctionScorer.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/ConjunctionScorer.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/ConjunctionScorer.java	(working copy)
@@ -19,8 +19,15 @@
 
 import org.apache.lucene.util.ArrayUtil;
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Comparator;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
 
 /** Scorer for conjunctions, sets of queries, all of which are required. */
 class ConjunctionScorer extends Scorer {
@@ -28,6 +35,9 @@
   private final Scorer[] scorers;
   private final float coord;
   private int lastDoc = -1;
+  //TODO: use something leaner.
+  private Map<String, List<Scorer>> mvp;
+  private boolean disallowCrossMatches = false;
 
   public ConjunctionScorer(Weight weight, float coord, Collection<Scorer> scorers) throws IOException {
     this(weight, coord, scorers.toArray(new Scorer[scorers.size()]));
@@ -45,6 +55,9 @@
         lastDoc = NO_MORE_DOCS;
         return;
       }
+      if (scorers[i].weight.getQuery().isDisallowCrossMatches()) {
+      	disallowCrossMatches = true;
+      }
     }
 
     // Sort the array the first time...
@@ -59,6 +72,26 @@
         return o1.docID() - o2.docID();
       }
     });
+    
+    if(disallowCrossMatches) {
+	    //Field Name vs Scorers that use the field
+	    mvp = new HashMap<String, List<Scorer>>();
+	    for(Scorer s : scorers) {
+	    	Query q = s.weight.getQuery();
+	    	if(q.isDisallowCrossMatches()) {
+	    		assert(q instanceof FieldRevealingQuery);
+	    		
+    			FieldRevealingQuery frq = (FieldRevealingQuery) q;
+	    		String field = frq.getField();
+	    		List<Scorer> mvpScorers = mvp.get(field);
+	    		if(mvpScorers==null) {
+	    			mvpScorers = new ArrayList<Scorer>();
+	    			mvp.put(field, mvpScorers);
+	    		}
+	    		mvpScorers.add(s);	    		
+	    	}
+	    }
+    }
 
     // NOTE: doNext() must be called before the re-sorting of the array later on.
     // The reason is this: assume there are 5 scorers, whose first docs are 1,
@@ -91,17 +124,64 @@
     }
   }
 
-  private int doNext() throws IOException {
+  private int doNextAllowCrossMatch() throws IOException {
     int first = 0;
     int doc = scorers[scorers.length - 1].docID();
     Scorer firstScorer;
     while ((firstScorer = scorers[first]).docID() < doc) {
-      doc = firstScorer.advance(doc);
+    	doc = firstScorer.advance(doc);
       first = first == scorers.length - 1 ? 0 : first + 1;
     }
     return doc;
   }
   
+  private int doNext() throws IOException {
+  	if(!disallowCrossMatches) {
+  		return doNextAllowCrossMatch();
+  	}
+  	boolean crossMatchViolation = false;
+  	int doc = doNextAllowCrossMatch();
+  	while(true) {
+  		if(doc == NO_MORE_DOCS) {
+  			return doc;
+  		}
+  		for(List<Scorer> ls : mvp.values()) {
+  			Scorer s = ls.get(0);
+  			int posIncGap = s.weight.getQuery().getPositionIncrementGap();
+  			int[] firstPoses = s.positions();
+  			for(int i=1 ; i<ls.size() ; i++) {
+  				int[] poses = ls.get(i).positions();
+  				boolean violation = true;
+  				for(int firstPos : firstPoses) {
+  					for(int pos : poses) {
+  						if(Math.abs(firstPos-pos)<posIncGap) {
+  							violation = false;
+  							break;
+  						}
+  					}
+  					if(!violation) {
+  						break;
+  					}
+  				}
+  				if(violation) {
+  					crossMatchViolation = true;
+  					break;
+  				}
+  			}
+  			if(crossMatchViolation) {
+					break;
+				}
+  		}
+  		if(!crossMatchViolation) {
+				break;
+			}
+  		scorers[(scorers.length - 1)].nextDoc();
+  		doc = doNextAllowCrossMatch();
+  	}
+  	return crossMatchViolation ? NO_MORE_DOCS : doc;
+  }
+  
+  
   @Override
   public int advance(int target) throws IOException {
     if (lastDoc == NO_MORE_DOCS) {
Index: lucene/src/java/org/apache/lucene/search/ConstantScoreQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/ConstantScoreQuery.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/ConstantScoreQuery.java	(working copy)
@@ -17,10 +17,12 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.util.ToStringUtils;
+import org.apache.lucene.util.OpenBitSetAndPositions.OpenBitSetAndPositionsIterator;
 
 import java.io.IOException;
 import java.util.Set;
@@ -36,7 +38,7 @@
  * CachingWrapperFilter.DeletesMode#RECACHE} or {@link
  * CachingWrapperFilter.DeletesMode#DYNAMIC}).
  */
-public class ConstantScoreQuery extends Query {
+public class ConstantScoreQuery extends Query implements FieldRevealingQuery {
   protected final Filter filter;
   protected final Query query;
 
@@ -71,6 +73,29 @@
   public Query getQuery() {
     return query;
   }
+  
+  @Override
+  public String getField() { 
+  	if(query !=null && query instanceof FieldRevealingQuery) {
+  		FieldRevealingQuery frq = (FieldRevealingQuery) query;
+  		return frq.getField();
+  	}
+  	if(filter != null && filter instanceof FieldRevealingQuery) {
+  		FieldRevealingQuery frq = (FieldRevealingQuery) filter;
+  		return frq.getField();
+  	}
+  	throw new UnsupportedOperationException("the enclosed query or filter does not support this.");
+  }
+  
+  @Override
+  public boolean isDisallowCrossMatches() { 
+  	return query == null ? filter.isDisallowCrossMatches() : query.isDisallowCrossMatches(); 
+  }
+	
+	@Override
+	public int getPositionIncrementGap() { 
+		return query == null ? filter.getPositionIncrementGap() : query.getPositionIncrementGap();
+	}
 
   @Override
   public Query rewrite(IndexReader reader) throws IOException {
@@ -202,6 +227,14 @@
       return docIdSetIterator.advance(target);
     }
     
+    public int[] positions() {
+    	if(docIdSetIterator instanceof OpenBitSetAndPositionsIterator) {
+    		OpenBitSetAndPositionsIterator obsapi = (OpenBitSetAndPositionsIterator) docIdSetIterator;
+    		return obsapi.positions();
+    	}
+    	throw new UnsupportedOperationException();
+    }
+    
     private Collector wrapCollector(final Collector collector) {
       return new Collector() {
         @Override
Index: lucene/src/java/org/apache/lucene/search/ExactPhraseScorer.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/ExactPhraseScorer.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/ExactPhraseScorer.java	(working copy)
@@ -191,6 +191,15 @@
   public int docID() {
     return docID;
   }
+  
+  @Override
+  public int[] positions() {
+  	int[] pos = new int[chunkStates.length];
+  	for(int i=0 ; i<chunkStates.length ; i++) {
+  		pos[i] = chunkStates[i].pos - chunkStates[i].offset;
+  	}
+  	return pos;
+  }
 
   @Override
   public float score() throws IOException {
Index: lucene/src/java/org/apache/lucene/search/FieldRevealingQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/FieldRevealingQuery.java	(revision 0)
+++ lucene/src/java/org/apache/lucene/search/FieldRevealingQuery.java	(revision 0)
@@ -0,0 +1,6 @@
+package org.apache.lucene.search;
+
+public interface FieldRevealingQuery {
+	 	/** Returns the field name for this query */
+  	public String getField() ;
+}
Index: lucene/src/java/org/apache/lucene/search/Filter.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/Filter.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/Filter.java	(working copy)
@@ -54,4 +54,8 @@
    * @see DocIdBitSet
    */
   public abstract DocIdSet getDocIdSet(AtomicReaderContext context) throws IOException;
+  
+  
+  public boolean isDisallowCrossMatches() { return false; }
+  public int getPositionIncrementGap() { throw new UnsupportedOperationException(); }
 }
Index: lucene/src/java/org/apache/lucene/search/FuzzyQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/FuzzyQuery.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/FuzzyQuery.java	(working copy)
@@ -118,6 +118,21 @@
     this(term, defaultMinSimilarity, defaultPrefixLength, defaultMaxExpansions);
   }
   
+  @Override
+	public void setDisallowCrossMatches(boolean dcm) { this.disallowCrossMatches = dcm; }
+	
+	@Override
+  public void setPositionIncrementGap(int gap) { this.positionIncrementGap = gap; }
+	
+	@Override
+  public boolean isDisallowCrossMatches() { return disallowCrossMatches && positionIncrementGap > 0; }
+	
+	@Override
+	public int getPositionIncrementGap() { return positionIncrementGap; }
+  
+  private int positionIncrementGap = 0;
+  private boolean disallowCrossMatches = false;
+  
   /**
    * Returns the minimum similarity that is required for this query to match.
    * @return float value between 0.0 and 1.0
Index: lucene/src/java/org/apache/lucene/search/MultiPhraseQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/MultiPhraseQuery.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/MultiPhraseQuery.java	(working copy)
@@ -43,7 +43,7 @@
  * terms) to add them to the query.
  *
  */
-public class MultiPhraseQuery extends Query {
+public class MultiPhraseQuery extends Query implements FieldRevealingQuery {
   private String field;
   private ArrayList<Term[]> termArrays = new ArrayList<Term[]>();
   private ArrayList<Integer> positions = new ArrayList<Integer>();
@@ -128,6 +128,9 @@
       }
     }
   }
+  
+  @Override
+  public String getField() { return field; }
 
 
   private class MultiPhraseWeight extends Weight {
Index: lucene/src/java/org/apache/lucene/search/MultiTermQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/MultiTermQuery.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/MultiTermQuery.java	(working copy)
@@ -59,7 +59,7 @@
  * MultiTermQueries using {@link
  * #CONSTANT_SCORE_AUTO_REWRITE_DEFAULT} by default.
  */
-public abstract class MultiTermQuery extends Query {
+public abstract class MultiTermQuery extends Query implements FieldRevealingQuery {
   protected final String field;
   protected RewriteMethod rewriteMethod = CONSTANT_SCORE_AUTO_REWRITE_DEFAULT;
   transient int numberOfTerms = 0;
@@ -245,6 +245,7 @@
   }
 
   /** Returns the field name for this query */
+  @Override
   public final String getField() { return field; }
 
   /** Construct the enumeration to be used, expanding the
Index: lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java	(working copy)
@@ -20,6 +20,7 @@
 import java.io.IOException;
 
 import org.apache.lucene.index.DocsEnum;
+import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.Fields;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
@@ -27,6 +28,7 @@
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.OpenBitSetAndPositions;
 
 /**
  * A wrapper for {@link MultiTermQuery}, that exposes its
@@ -42,7 +44,7 @@
  * {@link MultiTermQuery#CONSTANT_SCORE_FILTER_REWRITE};
  * this is why it is not abstract.
  */
-public class MultiTermQueryWrapperFilter<Q extends MultiTermQuery> extends Filter {
+public class MultiTermQueryWrapperFilter<Q extends MultiTermQuery> extends Filter implements FieldRevealingQuery {
     
   protected final Q query;
 
@@ -75,6 +77,7 @@
   }
 
   /** Returns the field name for this query */
+  @Override
   public final String getField() { return query.getField(); }
   
   /**
@@ -123,34 +126,58 @@
     assert termsEnum != null;
     if (termsEnum.next() != null) {
       // fill into a FixedBitSet
-      final FixedBitSet bitSet = new FixedBitSet(context.reader.maxDoc());
+      final FixedBitSet bitSet;
+      final OpenBitSetAndPositions bitSetAndPos;
+      if(isDisallowCrossMatches()) {
+      	bitSetAndPos = new OpenBitSetAndPositions(context.reader.maxDoc());
+      	bitSet = null;
+      } else {
+      		bitSet = new FixedBitSet(context.reader.maxDoc());
+      	bitSetAndPos = null;
+      }
       int termCount = 0;
       final Bits liveDocs = reader.getLiveDocs();
       DocsEnum docsEnum = null;
+      DocsAndPositionsEnum docsPosEnum = null;
       do {
         termCount++;
         // System.out.println("  iter termCount=" + termCount + " term=" +
         // enumerator.term().toBytesString());
-        docsEnum = termsEnum.docs(liveDocs, docsEnum);
-        final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();
-        while (true) {
-          final int count = docsEnum.read();
-          if (count != 0) {
-            final int[] docs = result.docs.ints;
-            for (int i = 0; i < count; i++) {
-              bitSet.set(docs[i]);
-            }
-          } else {
-            break;
-          }
+      	if(isDisallowCrossMatches()) {
+					docsPosEnum = termsEnum.docsAndPositions(liveDocs, docsPosEnum);
+					int doc = 0;
+					while((doc = docsPosEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
+						int[] pos = new int[docsPosEnum.freq()];
+						for(int i=0 ; i<pos.length ; i++) {
+							pos[i] = docsPosEnum.nextPosition();
+						}
+						bitSetAndPos.set(doc, pos);
+					}
+      	} else {
+					docsEnum = termsEnum.docs(liveDocs, docsEnum);
+					final DocsEnum.BulkReadResult result = docsEnum.getBulkResult();
+					while (true) {
+						final int count = docsEnum.read();
+						if (count != 0) {
+							final int[] docs = result.docs.ints;
+							for (int i = 0; i < count; i++) {
+								bitSet.set(docs[i]);
+							}
+						} else {
+						 break;
+						}
+        	}
         }
       } while (termsEnum.next() != null);
       // System.out.println("  done termCount=" + termCount);
 
       query.incTotalNumberOfTerms(termCount);
-      return bitSet;
+      return bitSet==null ? bitSetAndPos : bitSet;
     } else {
       return DocIdSet.EMPTY_DOCIDSET;
     }
   }
+  
+  public boolean isDisallowCrossMatches() { return query.isDisallowCrossMatches(); }
+  public int getPositionIncrementGap() { return query.getPositionIncrementGap(); }
 }
Index: lucene/src/java/org/apache/lucene/search/PhraseQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/PhraseQuery.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/PhraseQuery.java	(working copy)
@@ -41,13 +41,28 @@
  * 
  * <p>This query may be combined with other terms or queries with a {@link BooleanQuery}.
  */
-public class PhraseQuery extends Query {
+public class PhraseQuery extends Query implements FieldRevealingQuery {
   private String field;
   private ArrayList<Term> terms = new ArrayList<Term>(4);
   private ArrayList<Integer> positions = new ArrayList<Integer>(4);
   private int maxPosition = 0;
   private int slop = 0;
-
+  
+  private int positionIncrementGap = 0;
+  private boolean disallowCrossMatches = false;
+  
+  @Override
+	public void setDisallowCrossMatches(boolean dcm) { this.disallowCrossMatches = dcm; }
+	
+	@Override
+  public void setPositionIncrementGap(int gap) { this.positionIncrementGap = gap; }
+	
+	@Override
+  public boolean isDisallowCrossMatches() { return disallowCrossMatches && positionIncrementGap > 0; }
+	
+	@Override
+	public int getPositionIncrementGap() { return positionIncrementGap; }
+  
   /** Constructs an empty phrase query. */
   public PhraseQuery() {}
 
@@ -106,6 +121,9 @@
   public Term[] getTerms() {
     return terms.toArray(new Term[0]);
   }
+  
+  @Override
+  public String getField() { return field; }
 
   /**
    * Returns the relative positions of terms in this phrase.
Index: lucene/src/java/org/apache/lucene/search/PrefixQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/PrefixQuery.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/PrefixQuery.java	(working copy)
@@ -33,7 +33,22 @@
  * rewrite method. */
 public class PrefixQuery extends MultiTermQuery {
   private Term prefix;
-
+  
+  private int positionIncrementGap = 0;
+  private boolean disallowCrossMatches = false;
+  
+  @Override
+	public void setDisallowCrossMatches(boolean dcm) { this.disallowCrossMatches = dcm; }
+	
+	@Override
+  public void setPositionIncrementGap(int gap) { this.positionIncrementGap = gap; }
+	
+	@Override
+  public boolean isDisallowCrossMatches() { return disallowCrossMatches && positionIncrementGap > 0; }
+	
+	@Override
+	public int getPositionIncrementGap() { return positionIncrementGap; }
+  
   /** Constructs a query for terms starting with <code>prefix</code>. */
   public PrefixQuery(Term prefix) {
     super(prefix.field());
Index: lucene/src/java/org/apache/lucene/search/Query.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/Query.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/Query.java	(working copy)
@@ -54,6 +54,26 @@
    * multiplied by <code>b</code>.   The boost is 1.0 by default.
    */
   public float getBoost() { return boost; }
+  
+  /**
+   * Specify true to prevent cross-matches on multi-valued fields.  If set, you must also use {@link setPositionIncrementGap}
+   * to the correct value used when the field was analyzed and indexed.  Note that not all query implementations support 
+   * this feature.  If not supported, this setter will throw UnsupportedOperationException.
+   * 
+   * @param dcm
+   */
+  public void setDisallowCrossMatches(boolean dcm) { throw new UnsupportedOperationException(); }
+  
+  /**
+   * For use with {@link setDisallowCrossMatches}.  Note that not all query implementations support 
+   * this feature.  If not supported, this setter will throw UnsupportedOperationException.
+   * 
+   * @param gap
+   */
+  public void setPositionIncrementGap(int gap) { throw new UnsupportedOperationException(); }
+  
+  public boolean isDisallowCrossMatches() { return false; }
+  public int getPositionIncrementGap() { throw new UnsupportedOperationException(); }
 
   /** Prints a query to a string, with <code>field</code> assumed to be the 
    * default field and omitted.
Index: lucene/src/java/org/apache/lucene/search/Scorer.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/Scorer.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/Scorer.java	(working copy)
@@ -49,6 +49,10 @@
   protected Scorer(Weight weight) {
     this.weight = weight;
   }
+  
+  public int[] positions() {
+  	throw new UnsupportedOperationException();
+  }
 
   /** Scores and collects all matching documents.
    * @param collector The collector to which all matching documents are passed.
Index: lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/SloppyPhraseScorer.java	(working copy)
@@ -226,4 +226,18 @@
         }
         return null; 
     }
+    
+    @Override
+    public int[] positions() {
+    	//TODO:  test w/more rigor.  Not so sure this is valid...
+    	int[] pos = new int[pq.size()];
+    	PhrasePositions pp = first;
+    	int i=0;
+    	do {
+    		pos[i] = pp.position;
+    		pp = pp.next;
+    		i++;
+    	} while(pp != null);
+    	return pos;
+    }
 }
Index: lucene/src/java/org/apache/lucene/search/TermPositionScorer.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/TermPositionScorer.java	(revision 0)
+++ lucene/src/java/org/apache/lucene/search/TermPositionScorer.java	(revision 0)
@@ -0,0 +1,120 @@
+package org.apache.lucene.search;
+
+import java.io.IOException;
+
+import org.apache.lucene.index.DocsAndPositionsEnum;
+import org.apache.lucene.index.DocsEnum;
+
+//TODO:  need to find a way to do this without the cost.  Maybe develop a bulk enum that returns postions too ??
+public class TermPositionScorer extends Scorer {
+	private DocsAndPositionsEnum docsEnum;
+  private int doc = -1;
+  private int freq;
+  private int[] pos = null;
+
+  private static final int SCORE_CACHE_SIZE = 32;
+  private float[] scoreCache = new float[SCORE_CACHE_SIZE];
+  private final Similarity.ExactDocScorer docScorer;
+  
+  /**
+   * Construct a <code>TermPositionScorer</code>.  Like {@link TermScorer} but also gets
+   * and retains position data from the index.  As this is less efficient, always use 
+   * {@link TermScorer} instead of this if positions are not needed.
+   * 
+   * @param weight
+   *          The weight of the <code>Term</code> in the query.
+   * @param td
+   *          An iterator over the documents matching the <code>Term</code>.
+   * @param similarity
+   *          The </code>Similarity</code> implementation to be used for score
+   *          computations.
+   * @param norms
+   *          The field norms of the document fields for the <code>Term</code>.
+   */
+  TermPositionScorer(Weight weight, DocsAndPositionsEnum td, Similarity.ExactDocScorer docScorer) {
+    super(weight);
+    this.docScorer = docScorer;
+    this.docsEnum = td;
+  }
+  
+  @Override
+  public int[] positions() {
+  	return pos;
+  }
+
+  @Override
+  public void score(Collector c) throws IOException {
+    score(c, Integer.MAX_VALUE, nextDoc());
+  }
+
+
+  // firstDocID is ignored since nextDoc() sets 'doc'
+  @Override
+  public boolean score(Collector c, int end, int firstDocID) throws IOException {
+    c.setScorer(this);
+    while (doc < end) {                           // for docs in window
+      c.collect(doc);                      // collect score
+      nextDoc();   
+    }
+    return true;
+  }
+
+  @Override
+  public int docID() {
+    return doc;
+  }
+
+  @Override
+  public float freq() {
+    return freq;
+  }
+
+  /**
+   * Advances to the next document matching the query. <br>
+   * The iterator over the matching documents is buffered using
+   * {@link TermDocs#read(int[],int[])}.
+   * 
+   * @return the document matching the query or NO_MORE_DOCS if there are no more documents.
+   */
+  @Override
+  public int nextDoc() throws IOException {
+  	doc = docsEnum.nextDoc();
+    if(doc == NO_MORE_DOCS) {
+    	return doc;
+    }
+    freq = docsEnum.freq();
+  	pos = new int[freq];
+  	for(int i=0 ; i<freq ; i++) {    		
+  		pos[i] = docsEnum.nextPosition();
+  	}
+       
+    assert doc != NO_MORE_DOCS;
+    return doc;
+  }
+  
+  @Override
+  public float score() {
+  	assert doc != NO_MORE_DOCS;
+    return docScorer.score(doc, freq);
+  }
+
+  /**
+   * Advances to the first match beyond the current whose document number is
+   * greater than or equal to a given target. <br>
+   * The implementation uses {@link DocsEnum#advance(int)}.
+   * 
+   * @param target The target document number.
+   * @return the matching document or NO_MORE_DOCS if none exist.
+   */
+  @Override
+  public int advance(int target) throws IOException {
+    while(doc<target) {
+    	nextDoc();
+    }
+    return doc;
+  }
+
+  /** Returns a string representation of this <code>TermPositionScorer</code>. */
+  @Override
+  public String toString() { return "scorer(" + weight + ")"; }
+}
Index: lucene/src/java/org/apache/lucene/search/TermQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/TermQuery.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/TermQuery.java	(working copy)
@@ -20,6 +20,7 @@
 import java.io.IOException;
 import java.util.Set;
 
+import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.TermState;
@@ -36,15 +37,17 @@
 /** A Query that matches documents containing a term.
   This may be combined with other terms with a {@link BooleanQuery}.
   */
-public class TermQuery extends Query {
+public class TermQuery extends Query implements FieldRevealingQuery {
   private final Term term;
   private int docFreq;
   private transient TermContext perReaderTermState;
+  private int positionIncrementGap = 0;
+  private boolean disallowCrossMatches = false;
 
   private class TermWeight extends Weight {
     private final Similarity similarity;
     private final Similarity.Stats stats;
-    private transient TermContext termStates;
+    private transient TermContext termStates;    
 
     public TermWeight(IndexSearcher searcher, TermContext termStates)
       throws IOException {
@@ -53,7 +56,7 @@
       this.similarity = searcher.getSimilarityProvider().get(term.field());
       this.stats = similarity.computeStats(searcher, term.field(), getBoost(), termStates);
     }
-
+    
     @Override
     public String toString() { return "weight(" + TermQuery.this + ")"; }
 
@@ -80,9 +83,15 @@
         assert termNotInReader(reader, field, term.bytes()) : "no termstate found but term exists in reader";
         return null;
       }
-      final DocsEnum docs = reader.termDocsEnum(reader.getLiveDocs(), field, term.bytes(), state);
-      assert docs != null;
-      return new TermScorer(this, docs, similarity.exactDocScorer(stats, field, context));
+      if(disallowCrossMatches) {
+      	final DocsAndPositionsEnum docs = reader.termPositionsEnum(reader.getLiveDocs(), field, term.bytes(), state);
+      	assert docs != null;
+      	return new TermPositionScorer(this, docs, similarity.exactDocScorer(stats, field, context));
+      } else {
+      	final DocsEnum docs = reader.termDocsEnum(reader.getLiveDocs(), field, term.bytes(), state);
+      	assert docs != null;
+      	return new TermScorer(this, docs, similarity.exactDocScorer(stats, field, context));
+      }
     }
     
     private boolean termNotInReader(IndexReader reader, String field, BytesRef bytes) throws IOException {
@@ -137,9 +146,24 @@
     docFreq = states.docFreq();
     perReaderTermState = states;
   }
+  
+  @Override
+  public void setDisallowCrossMatches(boolean dcm) { this.disallowCrossMatches = dcm; }
+  	
+  @Override
+  public void setPositionIncrementGap(int gap) { this.positionIncrementGap = gap; }
+  	
+  @Override
+  public boolean isDisallowCrossMatches() { return disallowCrossMatches && positionIncrementGap > 0; }
+  
+  @Override
+  public int getPositionIncrementGap() { return positionIncrementGap; }
 
   /** Returns the term of this query. */
   public Term getTerm() { return term; }
+  
+  @Override
+  public String getField() { return term.field(); }
 
   @Override
   public Weight createWeight(IndexSearcher searcher) throws IOException {
Index: lucene/src/java/org/apache/lucene/search/TermRangeQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/TermRangeQuery.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/TermRangeQuery.java	(working copy)
@@ -84,7 +84,7 @@
     BytesRef upper = upperTerm == null ? null : new BytesRef(upperTerm);
     return new TermRangeQuery(field, lower, upper, includeLower, includeUpper);
   }
-
+  
   /** Returns the lower value of this range query */
   public BytesRef getLowerTerm() { return lowerTerm; }
 
@@ -98,6 +98,21 @@
   public boolean includesUpper() { return includeUpper; }
   
   @Override
+	public void setDisallowCrossMatches(boolean dcm) { this.disallowCrossMatches = dcm; }
+	
+	@Override
+  public void setPositionIncrementGap(int gap) { this.positionIncrementGap = gap; }
+	
+	@Override
+  public boolean isDisallowCrossMatches() { return disallowCrossMatches && positionIncrementGap > 0; }
+	
+	@Override
+	public int getPositionIncrementGap() { return positionIncrementGap; }
+  
+  private int positionIncrementGap = 0;
+  private boolean disallowCrossMatches = false;
+  
+  @Override
   protected TermsEnum getTermsEnum(Terms terms, AttributeSource atts) throws IOException {
     if (lowerTerm != null && upperTerm != null && lowerTerm.compareTo(upperTerm) > 0) {
       return TermsEnum.EMPTY;
Index: lucene/src/java/org/apache/lucene/search/TopTermsRewrite.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/TopTermsRewrite.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/TopTermsRewrite.java	(working copy)
@@ -140,6 +140,10 @@
       addClause(q, term, st.termState.docFreq(), query.getBoost() * st.boost, st.termState); // add to query
     }
     query.incTotalNumberOfTerms(scoreTerms.length);
+    if(query.isDisallowCrossMatches()) {
+    	q.setDisallowCrossMatches(true);
+    	q.setPositionIncrementGap(query.getPositionIncrementGap());
+    }
     return q;
   }
 
Index: lucene/src/java/org/apache/lucene/search/WildcardQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/WildcardQuery.java	(revision 1147295)
+++ lucene/src/java/org/apache/lucene/search/WildcardQuery.java	(working copy)
@@ -55,6 +55,21 @@
     super(term, toAutomaton(term));
   }
   
+  @Override
+	public void setDisallowCrossMatches(boolean dcm) { this.disallowCrossMatches = dcm; }
+	
+	@Override
+  public void setPositionIncrementGap(int gap) { this.positionIncrementGap = gap; }
+	
+	@Override
+  public boolean isDisallowCrossMatches() { return disallowCrossMatches && positionIncrementGap > 0; }
+	
+	@Override
+	public int getPositionIncrementGap() { return positionIncrementGap; }
+  
+  private int positionIncrementGap = 0;
+  private boolean disallowCrossMatches = false;
+  
   /**
    * Convert Lucene wildcard syntax into an automaton.
    * @lucene.internal
Index: lucene/src/java/org/apache/lucene/util/OpenBitSetAndPositions.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/OpenBitSetAndPositions.java	(revision 0)
+++ lucene/src/java/org/apache/lucene/util/OpenBitSetAndPositions.java	(revision 0)
@@ -0,0 +1,70 @@
+package org.apache.lucene.util;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.lucene.search.DocIdSetIterator;
+
+public class OpenBitSetAndPositions extends OpenBitSet {
+	//TODO: use something leaner.
+	private Map<Integer, List<Integer>> docVsPositions = new HashMap<Integer, List<Integer>>();	
+	
+	public OpenBitSetAndPositions(long numBits) {
+    super(numBits);
+  }
+
+  public OpenBitSetAndPositions() {
+  	super();
+  }
+  public void set(long index, int[] positions) {
+  	super.set(index);
+  	int indexInt = (int) index;
+  	List<Integer> prevPos = docVsPositions.get( indexInt);
+  	if(prevPos==null) {
+  		prevPos = new ArrayList<Integer>();
+  		docVsPositions.put(indexInt, prevPos);  		
+  	}
+  	for(int pos : positions) {
+  		prevPos.add(pos);
+  	}  	
+  }
+
+	@Override
+	public DocIdSetIterator iterator() {
+		return new OpenBitSetAndPositionsIterator(super.bits, super.wlen);
+	}
+	
+	public class OpenBitSetAndPositionsIterator extends OpenBitSetIterator {
+		private int doc;
+		
+		public OpenBitSetAndPositionsIterator(OpenBitSet obs) {
+			super(obs);
+	  }
+
+	  public OpenBitSetAndPositionsIterator(long[] bits, int numWords) {
+	  	super(bits, numWords);
+	  }
+	  
+	  @Override
+	  public int nextDoc() {
+	  	doc = super.nextDoc();
+	  	return doc;
+	  }
+	  
+	  public int[] positions() {
+	  	List<Integer> posList = docVsPositions.get(doc);
+	  	if(posList==null) {
+	  		return null;
+	  	}
+	  	int[] posInt = new int[posList.size()];
+	  	for(int i=0 ; i<posList.size() ; i++) {
+	  		posInt[i] = posList.get(i);
+	  	}
+	  	return posInt;
+	  }
+
+	}
+
+}
Index: lucene/src/test/org/apache/lucene/search/TestMultivaluedCrossMatches.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestMultivaluedCrossMatches.java	(revision 0)
+++ lucene/src/test/org/apache/lucene/search/TestMultivaluedCrossMatches.java	(revision 0)
@@ -0,0 +1,227 @@
+package org.apache.lucene.search;
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.document.Field.Index;
+import org.apache.lucene.document.Field.Store;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.queryparser.classic.QueryParser;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.Version;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class TestMultivaluedCrossMatches extends LuceneTestCase {
+	private static final Version matchVersion = Version.LUCENE_40;
+	private MockAnalyzer mockAnalyzer = null;
+	private Directory dir = null;
+	
+	@Override
+  public void setUp() throws Exception {
+    super.setUp();
+    dir = newDirectory();
+    mockAnalyzer = new MockAnalyzer(random);
+    mockAnalyzer.setPositionIncrementGap(100);
+    RandomIndexWriter writer = new RandomIndexWriter(random, dir, mockAnalyzer);
+		
+		Document doc1 = new Document();
+		doc1.add(new Field("id", "1", Store.YES, Index.NOT_ANALYZED_NO_NORMS));
+		doc1.add(new Field("name", "john paul smith", Store.YES, Index.ANALYZED_NO_NORMS));
+		doc1.add(new Field("name", "brian xavier thompson", Store.YES, Index.ANALYZED_NO_NORMS));		
+		writer.addDocument(doc1);
+				
+		writer.commit();
+		writer.close();
+  }
+  
+  @Override
+  public void tearDown() throws Exception {
+    dir.close();
+    super.tearDown();
+  }
+  
+  /**
+   * As normal, cross-matches occur.
+   */
+  private void nameQuery_CrossMatch(String queryStr, IndexReader reader, IndexSearcher searcher) throws Exception {
+  	QueryParser parser = new QueryParser(matchVersion, "name", mockAnalyzer);
+  	Query query = parser.parse(queryStr);		
+		
+		TopDocs docs = searcher.search(query, 10);
+		Assert.assertTrue(docs.totalHits==1);
+		
+		Document d = reader.document(docs.scoreDocs[0].doc);
+		Fieldable[] names = d.getFieldables("name");
+		Assert.assertTrue(names[0].stringValue().equals("john paul smith"));
+		Assert.assertTrue(names[1].stringValue().equals("brian xavier thompson"));
+  }
+  
+  /**
+   * Heart of the test:  cross-matches are disabled
+   */
+  private void nameQuery_NoCrossMatch(String queryStr, IndexReader reader, IndexSearcher searcher) throws Exception {
+  	QueryParser parser = new QueryParser(matchVersion, "name", mockAnalyzer);
+  	Query query = parser.parse(queryStr);
+		query.setDisallowCrossMatches(true);
+		query.setPositionIncrementGap(100);
+		
+		TopDocs docs = searcher.search(query, 10);
+		Assert.assertTrue(docs.totalHits==0);
+  }
+  
+  /**
+   * Shows that regular matches still work even with cross-matches disabled.
+   */
+  private void nameQuery_NoCrossMatch_WithRegularMatch(String queryStr, IndexReader reader, IndexSearcher searcher) throws Exception {
+  	QueryParser parser = new QueryParser(matchVersion, "name", mockAnalyzer);
+  	Query query = parser.parse(queryStr);
+		query.setDisallowCrossMatches(true);
+		query.setPositionIncrementGap(100);
+		
+		TopDocs docs = searcher.search(query, 10);
+		Assert.assertTrue(docs.totalHits==1);
+		
+		Document d = reader.document(docs.scoreDocs[0].doc);
+		Fieldable[] names = d.getFieldables("name");
+		Assert.assertTrue(names[0].stringValue().equals("john paul smith"));
+		Assert.assertTrue(names[1].stringValue().equals("brian xavier thompson"));		
+  }
+	@Test
+	public void testWithTermQueries() throws Exception {		
+		IndexReader reader = null;
+		IndexSearcher searcher = null;
+		try {
+			reader = IndexReader.open(dir);
+			searcher = new IndexSearcher(reader);		
+		
+			nameQuery_CrossMatch("+john +thompson", reader, searcher);
+			nameQuery_NoCrossMatch("+john +thompson", reader, searcher);
+			nameQuery_NoCrossMatch_WithRegularMatch("+brian +thompson", reader, searcher);
+			
+			searcher.close();
+			reader.close();
+		} catch(Exception e) {
+			throw e;
+		} finally {
+			if(searcher != null) { searcher.close(); }
+			if(reader != null) { reader.close(); }
+		}
+	}
+	
+	@Test
+	public void testWithTermRangeQueries() throws Exception {	
+		IndexReader reader = null;
+		IndexSearcher searcher = null;
+		try {
+			reader = IndexReader.open(dir);
+			searcher = new IndexSearcher(reader);		
+			
+			                     //match "john" but not "thompson"  //match "brian" but not "smith" 
+			nameQuery_CrossMatch(    "name:[joh TO koh]             AND name:[baa TO coo]", reader, searcher);
+			nameQuery_NoCrossMatch(  "name:[joh TO koh]             AND name:[baa TO coo]", reader, searcher);
+			
+			//This one matches "brian thompson" and should work with cross-matches disabled...
+			nameQuery_NoCrossMatch_WithRegularMatch("name:[aaa TO zzz] AND name:[baa TO coo]", reader, searcher);
+		} catch(Exception e) {
+			throw e;
+		} finally {
+			if(searcher != null) { searcher.close(); }
+			if(reader != null) { reader.close(); }
+		}
+	}
+	
+	@Test
+	public void testWithPrefixQueries() throws Exception {		
+		IndexReader reader = null;
+		IndexSearcher searcher = null;
+		try {
+			reader = IndexReader.open(dir);
+			searcher = new IndexSearcher(reader);		
+		
+			//nameQuery_CrossMatch("+joh* +thomp*", reader, searcher);
+			nameQuery_NoCrossMatch("+joh* +thomp*", reader, searcher);
+			//nameQuery_NoCrossMatch_WithRegularMatch("+bria* +thomp*", reader, searcher);
+			
+			searcher.close();
+			reader.close();
+		} catch(Exception e) {
+			throw e;
+		} finally {
+			if(searcher != null) { searcher.close(); }
+			if(reader != null) { reader.close(); }
+		}
+	}
+	
+	@Test
+	public void testWithPhraseQueries() throws Exception {		
+		IndexReader reader = null;
+		IndexSearcher searcher = null;
+		try {
+			reader = IndexReader.open(dir);
+			searcher = new IndexSearcher(reader);		
+		
+			nameQuery_CrossMatch("\"john paul\" AND \"thompson xavier\"~2", reader, searcher);
+			nameQuery_NoCrossMatch("\"john paul\" AND \"thompson xavier\"~2", reader, searcher);
+			nameQuery_NoCrossMatch_WithRegularMatch("\"john paul\" AND \"smith paul\"~2", reader, searcher);
+			
+			searcher.close();
+			reader.close();
+		} catch(Exception e) {
+			throw e;
+		} finally {
+			if(searcher != null) { searcher.close(); }
+			if(reader != null) { reader.close(); }
+		}
+	}
+	
+	@Test
+	public void testWithWildcardQueries() throws Exception {		
+		IndexReader reader = null;
+		IndexSearcher searcher = null;
+		try {
+			reader = IndexReader.open(dir);
+			searcher = new IndexSearcher(reader);		
+		
+			nameQuery_CrossMatch("+jo?n +thomps?n", reader, searcher);
+			nameQuery_NoCrossMatch("+jo?n +thomps?n", reader, searcher);
+			nameQuery_NoCrossMatch_WithRegularMatch("+bri?n +thomps?n", reader, searcher);
+			
+			searcher.close();
+			reader.close();
+		} catch(Exception e) {
+			throw e;
+		} finally {
+			if(searcher != null) { searcher.close(); }
+			if(reader != null) { reader.close(); }
+		}
+	}
+	
+	@Test
+	public void testWithFuzzyQueries() throws Exception {		
+		IndexReader reader = null;
+		IndexSearcher searcher = null;
+		try {
+			reader = IndexReader.open(dir);
+			searcher = new IndexSearcher(reader);		
+		
+			nameQuery_CrossMatch("+joqn~ +thompsqn~", reader, searcher);
+			nameQuery_NoCrossMatch("+joqn~ +thompsqn~", reader, searcher);
+			nameQuery_NoCrossMatch_WithRegularMatch("+briqn~ +thompsqn~", reader, searcher);
+			
+			searcher.close();
+			reader.close();
+		} catch(Exception e) {
+			throw e;
+		} finally {
+			if(searcher != null) { searcher.close(); }
+			if(reader != null) { reader.close(); }
+		}
+	}	
+}
