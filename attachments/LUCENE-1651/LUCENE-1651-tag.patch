Index: tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestOmitTf.java
===================================================================
--- tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestOmitTf.java	(revision 781441)
+++ tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestOmitTf.java	(working copy)
@@ -88,9 +88,8 @@
     writer.close();
     _TestUtil.checkIndex(ram);
 
-    // only one segment in the index, so we can cast to SegmentReader
-    SegmentReader reader = (SegmentReader) IndexReader.open(ram);
-    FieldInfos fi = reader.fieldInfos();
+	SegmentReader reader = SegmentReader.getOnlySegmentReader(ram);    
+	FieldInfos fi = reader.fieldInfos();
     assertTrue("OmitTf field bit should be set.", fi.fieldInfo("f1").omitTermFreqAndPositions);
     assertTrue("OmitTf field bit should be set.", fi.fieldInfo("f2").omitTermFreqAndPositions);
         
@@ -141,8 +140,7 @@
 
     _TestUtil.checkIndex(ram);
 
-    // only one segment in the index, so we can cast to SegmentReader
-    SegmentReader reader = (SegmentReader) IndexReader.open(ram);
+	SegmentReader reader = SegmentReader.getOnlySegmentReader(ram);
     FieldInfos fi = reader.fieldInfos();
     assertTrue("OmitTf field bit should be set.", fi.fieldInfo("f1").omitTermFreqAndPositions);
     assertTrue("OmitTf field bit should be set.", fi.fieldInfo("f2").omitTermFreqAndPositions);
@@ -186,8 +184,7 @@
 
     _TestUtil.checkIndex(ram);
 
-    // only one segment in the index, so we can cast to SegmentReader
-    SegmentReader reader = (SegmentReader) IndexReader.open(ram);
+	SegmentReader reader = SegmentReader.getOnlySegmentReader(ram);
     FieldInfos fi = reader.fieldInfos();
     assertTrue("OmitTf field bit should not be set.", !fi.fieldInfo("f1").omitTermFreqAndPositions);
     assertTrue("OmitTf field bit should be set.", fi.fieldInfo("f2").omitTermFreqAndPositions);
Index: tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestSegmentTermEnum.java
===================================================================
--- tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestSegmentTermEnum.java	(revision 781441)
+++ tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestSegmentTermEnum.java	(working copy)
@@ -71,7 +71,7 @@
     IndexWriter writer  = new IndexWriter(dir, new WhitespaceAnalyzer(), true, IndexWriter.MaxFieldLength.LIMITED);
     addDoc(writer, "aaa bbb");
     writer.close();
-    IndexReader reader = IndexReader.open(dir);
+    SegmentReader reader = SegmentReader.getOnlySegmentReader(dir);
     SegmentTermEnum termEnum = (SegmentTermEnum) reader.terms();
     assertTrue(termEnum.next());
     assertEquals("aaa", termEnum.term().text());
Index: tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestMultiSegmentReader.java
===================================================================
--- tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestMultiSegmentReader.java	(revision 781441)
+++ tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestMultiSegmentReader.java	(working copy)
@@ -55,7 +55,7 @@
   protected IndexReader openReader() throws IOException {
     IndexReader reader;
     reader = IndexReader.open(dir);
-    assertTrue(reader instanceof MultiSegmentReader);
+    assertNotNull(reader.getSequentialSubReaders());
 
     assertTrue(dir != null);
     assertTrue(sis != null);
Index: tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestIndexReaderReopen.java
===================================================================
--- tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestIndexReaderReopen.java	(revision 781441)
+++ tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestIndexReaderReopen.java	(working copy)
@@ -319,9 +319,9 @@
       IndexReader reader0 = IndexReader.open(dir1);
       assertRefCountEquals(1, reader0);
 
-      assertTrue(reader0 instanceof MultiSegmentReader);
-      IndexReader[] subReaders0 = ((MultiSegmentReader) reader0).getSequentialSubReaders();
-      for (int i = 0; i < subReaders0.length; i++) {
+      IndexReader[] subReaders0 = reader0.getSequentialSubReaders();
+      assertNotNull(subReaders0);
+	  for (int i = 0; i < subReaders0.length; i++) {
         assertRefCountEquals(1, subReaders0[i]);
       }
       
@@ -331,8 +331,8 @@
       modifier.close();
       
       IndexReader reader1 = refreshReader(reader0, true).refreshedReader;
-      assertTrue(reader1 instanceof MultiSegmentReader);
-      IndexReader[] subReaders1 = ((MultiSegmentReader) reader1).getSequentialSubReaders();
+      IndexReader[] subReaders1 = reader1.getSequentialSubReaders();
+      assertNotNull(subReaders1);
       assertEquals(subReaders0.length, subReaders1.length);
       
       for (int i = 0; i < subReaders0.length; i++) {
@@ -350,8 +350,8 @@
       modifier.close();
 
       IndexReader reader2 = refreshReader(reader1, true).refreshedReader;
-      assertTrue(reader2 instanceof MultiSegmentReader);
-      IndexReader[] subReaders2 = ((MultiSegmentReader) reader2).getSequentialSubReaders();
+      IndexReader[] subReaders2 = reader2.getSequentialSubReaders();
+      assertNotNull(subReaders2);
       assertEquals(subReaders1.length, subReaders2.length);
       
       for (int i = 0; i < subReaders2.length; i++) {
@@ -374,8 +374,8 @@
       }
       
       IndexReader reader3 = refreshReader(reader0, true).refreshedReader;
-      assertTrue(reader3 instanceof MultiSegmentReader);
-      IndexReader[] subReaders3 = ((MultiSegmentReader) reader3).getSequentialSubReaders();
+      IndexReader[] subReaders3 = reader3.getSequentialSubReaders();
+      assertNotNull(subReaders3);
       assertEquals(subReaders3.length, subReaders0.length);
       
       // try some permutations
@@ -541,60 +541,62 @@
     Directory dir1 = new RAMDirectory();
     createIndex(dir1, false);
     
-    SegmentReader reader1 = (SegmentReader) IndexReader.open(dir1);
+    IndexReader reader1 = IndexReader.open(dir1);
+    SegmentReader segmentReader1 = SegmentReader.getOnlySegmentReader(reader1);
     IndexReader modifier = IndexReader.open(dir1);
     modifier.deleteDocument(0);
     modifier.close();
     
-    SegmentReader reader2 = (SegmentReader) reader1.reopen();
+    IndexReader reader2 = reader1.reopen();
     modifier = IndexReader.open(dir1);
     modifier.setNorm(1, "field1", 50);
     modifier.setNorm(1, "field2", 50);
     modifier.close();
     
-    SegmentReader reader3 = (SegmentReader) reader2.reopen();
+    IndexReader reader3 = reader2.reopen();
+    SegmentReader segmentReader3 = SegmentReader.getOnlySegmentReader(reader3);
     modifier = IndexReader.open(dir1);
     modifier.deleteDocument(2);
     modifier.close();
-    SegmentReader reader4 = (SegmentReader) reader3.reopen();
+    IndexReader reader4 = reader3.reopen();
 
     modifier = IndexReader.open(dir1);
     modifier.deleteDocument(3);
     modifier.close();
-    SegmentReader reader5 = (SegmentReader) reader3.reopen();
+    IndexReader reader5 = reader3.reopen();
     
     // Now reader2-reader5 references reader1. reader1 and reader2
     // share the same norms. reader3, reader4, reader5 also share norms.
     assertRefCountEquals(1, reader1);
-    assertFalse(reader1.normsClosed());
+    assertFalse(segmentReader1.normsClosed());
     reader1.close();
     assertRefCountEquals(0, reader1);
-    assertFalse(reader1.normsClosed());
+    assertFalse(segmentReader1.normsClosed());
     reader2.close();
     assertRefCountEquals(0, reader1);
     // now the norms for field1 and field2 should be closed
-    assertTrue(reader1.normsClosed("field1"));
-    assertTrue(reader1.normsClosed("field2"));
+    assertTrue(segmentReader1.normsClosed("field1"));
+    assertTrue(segmentReader1.normsClosed("field2"));
     // but the norms for field3 and field4 should still be open
-    assertFalse(reader1.normsClosed("field3"));
-    assertFalse(reader1.normsClosed("field4"));
+    assertFalse(segmentReader1.normsClosed("field3"));
+    assertFalse(segmentReader1.normsClosed("field4"));
     
     reader3.close();
     assertRefCountEquals(0, reader1);
-    assertFalse(reader3.normsClosed());
+    assertFalse(segmentReader3.normsClosed());
     reader5.close();
     assertRefCountEquals(0, reader1);
-    assertFalse(reader3.normsClosed());
+    assertFalse(segmentReader3.normsClosed());
     reader4.close();
     assertRefCountEquals(0, reader1);
     
     // and now all norms that reader1 used should be closed
-    assertTrue(reader1.normsClosed());
+    assertTrue(segmentReader1.normsClosed());
     
     // now that reader3, reader4 and reader5 are closed,
     // the norms that those three readers shared should be
     // closed as well
-    assertTrue(reader3.normsClosed());
+    assertTrue(segmentReader3.normsClosed());
   }
   
   private void performTestsWithExceptionInReopen(TestReopen test) throws Exception {
@@ -871,14 +873,6 @@
     }
     
     w.close();
-    
-    IndexReader r = IndexReader.open(dir);
-    if (multiSegment) {
-      assertTrue(r instanceof MultiSegmentReader);
-    } else {
-      assertTrue(r instanceof SegmentReader);
-    }
-    r.close();
   }
 
   private static Document createDocument(int n, int numFields) {
@@ -946,38 +940,20 @@
     }
     
     if (checkSubReaders) {
-      if (reader instanceof MultiSegmentReader) {
-        IndexReader[] subReaders = ((MultiSegmentReader) reader).getSequentialSubReaders();
-        for (int i = 0; i < subReaders.length; i++) {
+      IndexReader[] subReaders = reader.getSequentialSubReaders();
+	  if (subReaders != null)
+        for (int i = 0; i < subReaders.length; i++)
           assertReaderClosed(subReaders[i], checkSubReaders, checkNormsClosed);
-        }
-      }
-      
-      if (reader instanceof MultiReader) {
-        IndexReader[] subReaders = ((MultiReader) reader).getSequentialSubReaders();
-        for (int i = 0; i < subReaders.length; i++) {
-          assertReaderClosed(subReaders[i], checkSubReaders, checkNormsClosed);
-        }
-      }
-      
-      if (reader instanceof ParallelReader) {
-        IndexReader[] subReaders = ((ParallelReader) reader).getSubReaders();
-        for (int i = 0; i < subReaders.length; i++) {
-          assertReaderClosed(subReaders[i], checkSubReaders, checkNormsClosed);
-        }
-      }
     }
   }
 
   private void assertReaderOpen(IndexReader reader) {
     reader.ensureOpen();
     
-    if (reader instanceof MultiSegmentReader) {
-      IndexReader[] subReaders = ((MultiSegmentReader) reader).getSequentialSubReaders();
-      for (int i = 0; i < subReaders.length; i++) {
+    IndexReader[] subReaders = reader.getSequentialSubReaders();
+    if (subReaders != null)
+      for (int i = 0; i < subReaders.length; i++)
         assertReaderOpen(subReaders[i]);
-      }
-    }
   }
 
   private void assertRefCountEquals(int refCount, IndexReader reader) {
Index: tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestMultiLevelSkipList.java
===================================================================
--- tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestMultiLevelSkipList.java	(revision 781441)
+++ tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestMultiLevelSkipList.java	(working copy)
@@ -56,7 +56,7 @@
     writer.optimize();
     writer.close();
 
-    IndexReader reader = IndexReader.open(dir);
+    IndexReader reader = SegmentReader.getOnlySegmentReader(dir);
     SegmentTermPositions tp = (SegmentTermPositions) reader.termPositions();
     tp.freqStream = new CountingStream(tp.freqStream);
 
Index: tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestPayloads.java
===================================================================
--- tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestPayloads.java	(revision 781441)
+++ tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestPayloads.java	(working copy)
@@ -115,9 +115,8 @@
         // flush
         writer.close();        
         
-        // only one segment in the index, so we can cast to SegmentReader
-        SegmentReader reader = (SegmentReader) IndexReader.open(ram);
-        FieldInfos fi = reader.fieldInfos();
+        SegmentReader reader = SegmentReader.getOnlySegmentReader(ram);
+		FieldInfos fi = reader.fieldInfos();
         assertFalse("Payload field bit should not be set.", fi.fieldInfo("f1").storePayloads);
         assertTrue("Payload field bit should be set.", fi.fieldInfo("f2").storePayloads);
         assertFalse("Payload field bit should not be set.", fi.fieldInfo("f3").storePayloads);
@@ -140,8 +139,7 @@
         // flush
         writer.close();
 
-        // only one segment in the index, so we can cast to SegmentReader
-        reader = (SegmentReader) IndexReader.open(ram);
+        reader = SegmentReader.getOnlySegmentReader(ram);
         fi = reader.fieldInfos();
         assertFalse("Payload field bit should not be set.", fi.fieldInfo("f1").storePayloads);
         assertTrue("Payload field bit should be set.", fi.fieldInfo("f2").storePayloads);
Index: tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestLazyProxSkipping.java
===================================================================
--- tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestLazyProxSkipping.java	(revision 781441)
+++ tags/lucene_2_4_back_compat_tests_20090601a/src/test/org/apache/lucene/index/TestLazyProxSkipping.java	(working copy)
@@ -72,8 +72,7 @@
         writer.optimize();
         writer.close();
         
-        // the index is a single segment, thus IndexReader.open() returns an instance of SegmentReader
-        SegmentReader reader = (SegmentReader) IndexReader.open(directory);
+        SegmentReader reader = SegmentReader.getOnlySegmentReader(directory);
 
         // we decorate the proxStream with a wrapper class that allows to count the number of calls of seek()
         reader.proxStream = new SeeksCountingStream(reader.proxStream);
Index: tags/lucene_2_4_back_compat_tests_20090601a/src/java/org/apache/lucene/index/SegmentReader.java
===================================================================
--- tags/lucene_2_4_back_compat_tests_20090601a/src/java/org/apache/lucene/index/SegmentReader.java	(revision 781441)
+++ tags/lucene_2_4_back_compat_tests_20090601a/src/java/org/apache/lucene/index/SegmentReader.java	(working copy)
@@ -1110,4 +1110,13 @@
       norm.dirty = norm.rollbackDirty;
     }
   }
+
+  // NOTE: STANDIN so back-compat tests compile
+  static SegmentReader getOnlySegmentReader(Directory dir) throws IOException {
+    return null;
+  }
+
+  static SegmentReader getOnlySegmentReader(IndexReader reader) {
+	return null;
+  }
 }
Index: tags/lucene_2_4_back_compat_tests_20090601a/src/java/org/apache/lucene/index/MultiReader.java
===================================================================
--- tags/lucene_2_4_back_compat_tests_20090601a/src/java/org/apache/lucene/index/MultiReader.java	(revision 781441)
+++ tags/lucene_2_4_back_compat_tests_20090601a/src/java/org/apache/lucene/index/MultiReader.java	(working copy)
@@ -369,9 +369,4 @@
   IndexReader[] getSubReaders() {
     return subReaders;
   }
-
-  // NOTE: STANDIN so back-compat tests compile
-  IndexReader[] getSequentialSubReaders() {
-    return subReaders;
-  }
 }
Index: tags/lucene_2_4_back_compat_tests_20090601a/src/java/org/apache/lucene/index/IndexReader.java
===================================================================
--- tags/lucene_2_4_back_compat_tests_20090601a/src/java/org/apache/lucene/index/IndexReader.java	(revision 781441)
+++ tags/lucene_2_4_back_compat_tests_20090601a/src/java/org/apache/lucene/index/IndexReader.java	(working copy)
@@ -1134,4 +1134,9 @@
   public static Collection listCommits(Directory dir) throws IOException {
     return DirectoryIndexReader.listCommits(dir);
   }
+
+  // NOTE: STANDIN so back-compat tests compile
+  IndexReader[] getSequentialSubReaders() {
+    return null;
+  }
 }
Index: tags/lucene_2_4_back_compat_tests_20090601a/src/java/org/apache/lucene/index/MultiSegmentReader.java
===================================================================
--- tags/lucene_2_4_back_compat_tests_20090601a/src/java/org/apache/lucene/index/MultiSegmentReader.java	(revision 781441)
+++ tags/lucene_2_4_back_compat_tests_20090601a/src/java/org/apache/lucene/index/MultiSegmentReader.java	(working copy)
@@ -437,11 +437,6 @@
     return subReaders;
   }
 
-  // NOTE: STANDIN so back-compat tests compile
-  IndexReader[] getSequentialSubReaders() {
-    return subReaders;
-  }
-
   public void setTermInfosIndexDivisor(int indexDivisor) throws IllegalStateException {
     for (int i = 0; i < subReaders.length; i++)
       subReaders[i].setTermInfosIndexDivisor(indexDivisor);
