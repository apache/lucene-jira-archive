
Property changes on: .
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0_back_compat_tests:r889632-889908*,893652-912395*
   Merged /lucene/java/branches/lucene_3_0:r912383
   Merged /lucene/java/trunk:r912319,912324,912328,912335,912372


Property changes on: src
___________________________________________________________________
Added: svn:mergeinfo
   Merged /lucene/java/branches/lucene_2_9_back_compat_tests/src:r818601-821336
   Merged /lucene/java/branches/lucene_3_0/src:r880754,880793,880823,881216,881317,881376,881473,881549,881820,882467,882890,883076,883080
   Merged /lucene/java/trunk/src:r881213,881315,881466,881819,882374,882807,882888,882977,883074-883075,885214
   Merged /lucene/java/branches/lucene_2_4/src:r748824
   Merged /lucene/java/branches/lucene_3_0_back_compat_tests/src:r880869-912395
   Merged /lucene/java/branches/lucene_2_9/src:r817269-818600,825998,829134,829881,831036

Index: src/test/org/apache/lucene/analysis/tokenattributes/TestTermAttributeImpl.java
===================================================================
--- src/test/org/apache/lucene/analysis/tokenattributes/TestTermAttributeImpl.java	(revision 915852)
+++ src/test/org/apache/lucene/analysis/tokenattributes/TestTermAttributeImpl.java	(working copy)
@@ -49,7 +49,6 @@
       buf.append(buf.toString());
     }
     assertEquals(1048576, t.termLength());
-    assertEquals(1179654, t.termBuffer().length);
 
     // now as a string, first variant
     t = new TermAttributeImpl();
@@ -63,7 +62,6 @@
       buf.append(content);
     }
     assertEquals(1048576, t.termLength());
-    assertEquals(1179654, t.termBuffer().length);
 
     // now as a string, second variant
     t = new TermAttributeImpl();
@@ -77,7 +75,6 @@
       buf.append(content);
     }
     assertEquals(1048576, t.termLength());
-    assertEquals(1179654, t.termBuffer().length);
 
     // Test for slow growth to a long term
     t = new TermAttributeImpl();
@@ -91,7 +88,6 @@
       buf.append("a");
     }
     assertEquals(20000, t.termLength());
-    assertEquals(20167, t.termBuffer().length);
 
     // Test for slow growth to a long term
     t = new TermAttributeImpl();
@@ -105,7 +101,6 @@
       buf.append("a");
     }
     assertEquals(20000, t.termLength());
-    assertEquals(20167, t.termBuffer().length);
   }
 
   public void testToString() throws Exception {
Index: src/test/org/apache/lucene/analysis/TestToken.java
===================================================================
--- src/test/org/apache/lucene/analysis/TestToken.java	(revision 915852)
+++ src/test/org/apache/lucene/analysis/TestToken.java	(working copy)
@@ -85,7 +85,6 @@
       buf.append(buf.toString());
     }
     assertEquals(1048576, t.termLength());
-    assertEquals(1179654, t.termBuffer().length);
 
     // now as a string, first variant
     t = new Token();
@@ -99,7 +98,6 @@
       buf.append(content);
     }
     assertEquals(1048576, t.termLength());
-    assertEquals(1179654, t.termBuffer().length);
 
     // now as a string, second variant
     t = new Token();
@@ -113,7 +111,6 @@
       buf.append(content);
     }
     assertEquals(1048576, t.termLength());
-    assertEquals(1179654, t.termBuffer().length);
 
     // Test for slow growth to a long term
     t = new Token();
@@ -127,7 +124,6 @@
       buf.append("a");
     }
     assertEquals(20000, t.termLength());
-    assertEquals(20167, t.termBuffer().length);
 
     // Test for slow growth to a long term
     t = new Token();
@@ -141,7 +137,6 @@
       buf.append("a");
     }
     assertEquals(20000, t.termLength());
-    assertEquals(20167, t.termBuffer().length);
   }
 
   public void testToString() throws Exception {

Property changes on: src\test\org\apache\lucene\analysis\TestISOLatin1AccentFilter.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/test/org/apache/lucene/analysis/TestISOLatin1AccentFilter.java:r912383
   Merged /lucene/java/trunk/src/test/org/apache/lucene/analysis/TestISOLatin1AccentFilter.java:r912319,912324,912328,912335,912372
   Merged /lucene/java/branches/lucene_3_0_back_compat_tests/src/test/org/apache/lucene/analysis/TestISOLatin1AccentFilter.java:r889632-889908,893652-912395

Index: src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java
===================================================================
--- src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java	(revision 915852)
+++ src/test/org/apache/lucene/search/function/TestCustomScoreQuery.java	(working copy)
@@ -21,6 +21,7 @@
 import java.util.HashMap;
 import java.util.Iterator;
 
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.queryParser.QueryParser;
 import org.apache.lucene.search.Explanation;
@@ -73,32 +74,38 @@
   // must have static class otherwise serialization tests fail
   private static class CustomAddQuery extends CustomScoreQuery {
     // constructor
-    CustomAddQuery (Query q, ValueSourceQuery qValSrc) {
-      super(q,qValSrc);
+    CustomAddQuery(Query q, ValueSourceQuery qValSrc) {
+      super(q, qValSrc);
     }
+
     /*(non-Javadoc) @see org.apache.lucene.search.function.CustomScoreQuery#name() */
     @Override
     public String name() {
       return "customAdd";
     }
-    /*(non-Javadoc) @see org.apache.lucene.search.function.CustomScoreQuery#customScore(int, float, float) */
+    
     @Override
-    public float customScore(int doc, float subQueryScore, float valSrcScore) {
-      return subQueryScore + valSrcScore;
+    protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) {
+      return new CustomScoreProvider(reader) {
+        @Override
+        public float customScore(int doc, float subQueryScore, float valSrcScore) {
+          return subQueryScore + valSrcScore;
+        }
+
+        @Override
+        public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) {
+          float valSrcScore = valSrcExpl == null ? 0 : valSrcExpl.getValue();
+          Explanation exp = new Explanation(valSrcScore + subQueryExpl.getValue(), "custom score: sum of:");
+          exp.addDetail(subQueryExpl);
+          if (valSrcExpl != null) {
+            exp.addDetail(valSrcExpl);
+          }
+          return exp;
+        }
+      };
     }
-    /* (non-Javadoc)@see org.apache.lucene.search.function.CustomScoreQuery#customExplain(int, org.apache.lucene.search.Explanation, org.apache.lucene.search.Explanation)*/
-    @Override
-    public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) {
-      float valSrcScore = valSrcExpl==null ? 0 : valSrcExpl.getValue();
-      Explanation exp = new Explanation( valSrcScore + subQueryExpl.getValue(), "custom score: sum of:");
-      exp.addDetail(subQueryExpl);
-      if (valSrcExpl != null) {
-        exp.addDetail(valSrcExpl);
-      }
-      return exp;      
-    } 
   }
-  
+
   // must have static class otherwise serialization tests fail
   private static class CustomMulAddQuery extends CustomScoreQuery {
     // constructor
@@ -112,33 +119,40 @@
     }
     /*(non-Javadoc) @see org.apache.lucene.search.function.CustomScoreQuery#customScore(int, float, float) */
     @Override
-    public float customScore(int doc, float subQueryScore, float valSrcScores[]) {
-      if (valSrcScores.length == 0) {
-        return subQueryScore;
-      }
-      if (valSrcScores.length == 1) {
-        return subQueryScore + valSrcScores[0];
-      }
-      return (subQueryScore + valSrcScores[0]) * valSrcScores[1]; // we know there are two
-    } 
-    /* (non-Javadoc)@see org.apache.lucene.search.function.CustomScoreQuery#customExplain(int, org.apache.lucene.search.Explanation, org.apache.lucene.search.Explanation)*/
-    @Override
-    public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) {
-      if (valSrcExpls.length == 0) {
-        return subQueryExpl;
-      }
-      Explanation exp = new Explanation(valSrcExpls[0].getValue() + subQueryExpl.getValue(), "sum of:");
-      exp.addDetail(subQueryExpl);
-      exp.addDetail(valSrcExpls[0]);
-      if (valSrcExpls.length == 1) {
-        exp.setDescription("CustomMulAdd, sum of:");
-        return exp;
-      }
-      Explanation exp2 = new Explanation(valSrcExpls[1].getValue() * exp.getValue(), "custom score: product of:");
-      exp2.addDetail(valSrcExpls[1]);
-      exp2.addDetail(exp);
-      return exp2;      
-    } 
+    protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) {
+      return new CustomScoreProvider(reader) {
+        @Override
+        public float customScore(int doc, float subQueryScore, float valSrcScores[]) {
+          if (valSrcScores.length == 0) {
+            return subQueryScore;
+          }
+          if (valSrcScores.length == 1) {
+            return subQueryScore + valSrcScores[0];
+            // confirm that skipping beyond the last doc, on the
+            // previous reader, hits NO_MORE_DOCS
+          }
+          return (subQueryScore + valSrcScores[0]) * valSrcScores[1]; // we know there are two
+        }
+
+        @Override
+        public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) {
+          if (valSrcExpls.length == 0) {
+            return subQueryExpl;
+          }
+          Explanation exp = new Explanation(valSrcExpls[0].getValue() + subQueryExpl.getValue(), "sum of:");
+          exp.addDetail(subQueryExpl);
+          exp.addDetail(valSrcExpls[0]);
+          if (valSrcExpls.length == 1) {
+            exp.setDescription("CustomMulAdd, sum of:");
+            return exp;
+          }
+          Explanation exp2 = new Explanation(valSrcExpls[1].getValue() * exp.getValue(), "custom score: product of:");
+          exp2.addDetail(valSrcExpls[1]);
+          exp2.addDetail(exp);
+          return exp2;
+        }
+      };
+    }
   }
   
   // Test that FieldScoreQuery returns docs with expected score.
Index: src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
===================================================================
--- src/test/org/apache/lucene/search/TestNumericRangeQuery32.java	(revision 915852)
+++ src/test/org/apache/lucene/search/TestNumericRangeQuery32.java	(working copy)
@@ -42,9 +42,6 @@
   private static final IndexSearcher searcher;
   static {
     try {    
-      // set the theoretical maximum term count for 8bit (see docs for the number)
-      BooleanQuery.setMaxClauseCount(3*255*2 + 255);
-      
       directory = new RAMDirectory();
       IndexWriter writer = new IndexWriter(directory, new WhitespaceAnalyzer(),
       true, MaxFieldLength.UNLIMITED);
@@ -87,6 +84,14 @@
     }
   }
   
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    // set the theoretical maximum term count for 8bit (see docs for the number)
+    // super.tearDown will restore the default
+    BooleanQuery.setMaxClauseCount(3*255*2 + 255);
+  }
+  
   /** test for both constant score and boolean query, the other tests only use the constant score mode */
   private void testRange(int precisionStep) throws Exception {
     String field="field"+precisionStep;
Index: src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
===================================================================
--- src/test/org/apache/lucene/search/TestNumericRangeQuery64.java	(revision 915852)
+++ src/test/org/apache/lucene/search/TestNumericRangeQuery64.java	(working copy)
@@ -41,9 +41,6 @@
   private static final IndexSearcher searcher;
   static {
     try {
-      // set the theoretical maximum term count for 8bit (see docs for the number)
-      BooleanQuery.setMaxClauseCount(7*255*2 + 255);
-      
       directory = new RAMDirectory();
       IndexWriter writer = new IndexWriter(directory, new WhitespaceAnalyzer(),
       true, MaxFieldLength.UNLIMITED);
@@ -90,6 +87,14 @@
     }
   }
   
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    // set the theoretical maximum term count for 8bit (see docs for the number)
+    // super.tearDown will restore the default
+    BooleanQuery.setMaxClauseCount(7*255*2 + 255);
+  }
+  
   /** test for constant score + boolean query + filter, the other tests only use the constant score mode */
   private void testRange(int precisionStep) throws Exception {
     String field="field"+precisionStep;
Index: src/test/org/apache/lucene/index/TestIndexWriter.java
===================================================================
--- src/test/org/apache/lucene/index/TestIndexWriter.java	(revision 915852)
+++ src/test/org/apache/lucene/index/TestIndexWriter.java	(working copy)
@@ -83,12 +83,16 @@
         IndexReader reader = null;
         int i;
 
-        IndexWriter.setDefaultWriteLockTimeout(2000);
-        assertEquals(2000, IndexWriter.getDefaultWriteLockTimeout());
+        long savedWriteLockTimeout = IndexWriter.getDefaultWriteLockTimeout();
+        try {
+          IndexWriter.setDefaultWriteLockTimeout(2000);
+          assertEquals(2000, IndexWriter.getDefaultWriteLockTimeout());
 
-        writer  = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);
+          writer  = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.LIMITED);
 
-        IndexWriter.setDefaultWriteLockTimeout(1000);
+        } finally {
+          IndexWriter.setDefaultWriteLockTimeout(savedWriteLockTimeout);
+        }
 
         // add 100 documents
         for (i = 0; i < 100; i++) {
Index: src/test/org/apache/lucene/index/TestNRTReaderWithThreads.java
===================================================================
--- src/test/org/apache/lucene/index/TestNRTReaderWithThreads.java	(revision 915852)
+++ src/test/org/apache/lucene/index/TestNRTReaderWithThreads.java	(working copy)
@@ -54,13 +54,16 @@
     int addCount = 0;
     for (int x=0; x < indexThreads.length; x++) {
       indexThreads[x].run = false;
-      assertTrue(indexThreads[x].ex == null);
+      assertNull("Exception thrown: "+indexThreads[x].ex, indexThreads[x].ex);
       addCount += indexThreads[x].addCount;
       delCount += indexThreads[x].delCount;
     }
     for (int x=0; x < indexThreads.length; x++) {
       indexThreads[x].join();
     }
+    for (int x=0; x < indexThreads.length; x++) {
+      assertNull("Exception thrown: "+indexThreads[x].ex, indexThreads[x].ex);
+    }
     //System.out.println("addCount:"+addCount);
     //System.out.println("delCount:"+delCount);
     writer.close();
@@ -69,8 +72,8 @@
 
   public class RunThread extends Thread {
     IndexWriter writer;
-    boolean run = true;
-    Throwable ex;
+    volatile boolean run = true;
+    volatile Throwable ex;
     int delCount = 0;
     int addCount = 0;
     int type;

Property changes on: src\test\org\apache\lucene\index\TestBackwardsCompatibility.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java:r912383
   Merged /lucene/java/trunk/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java:r912319,912324,912328,912335,912372
   Merged /lucene/java/branches/lucene_3_0_back_compat_tests/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java:r889632-889908,893652-912395

Index: src/test/org/apache/lucene/index/TestNorms.java
===================================================================
--- src/test/org/apache/lucene/index/TestNorms.java	(revision 915852)
+++ src/test/org/apache/lucene/index/TestNorms.java	(working copy)
@@ -28,7 +28,7 @@
 import org.apache.lucene.search.DefaultSimilarity;
 import org.apache.lucene.search.Similarity;
 import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.FSDirectory;
+import org.apache.lucene.store.RAMDirectory;
 
 import java.io.File;
 import java.io.IOException;
@@ -75,15 +75,7 @@
    * Including optimize. 
    */
   public void testNorms() throws IOException {
-    // tmp dir
-    String tempDir = System.getProperty("java.io.tmpdir");
-    if (tempDir == null) {
-      throw new IOException("java.io.tmpdir undefined, cannot run test");
-    }
-    
-    // test with a single index: index1
-    File indexDir1 = new File(tempDir, "lucenetestindex1");
-    Directory dir1 = FSDirectory.open(indexDir1);
+    Directory dir1 = new RAMDirectory();
 
     norms = new ArrayList();
     modifiedNorms = new ArrayList();
@@ -100,15 +92,13 @@
     modifiedNorms = new ArrayList();
     numDocNorms = 0;
     
-    File indexDir2 = new File(tempDir, "lucenetestindex2");
-    Directory dir2 = FSDirectory.open(indexDir2);
+    Directory dir2 = new RAMDirectory();
 
     createIndex(dir2);
     doTestNorms(dir2);
 
     // add index1 and index2 to a third index: index3
-    File indexDir3 = new File(tempDir, "lucenetestindex3");
-    Directory dir3 = FSDirectory.open(indexDir3);
+    Directory dir3 = new RAMDirectory();
 
     createIndex(dir3);
     IndexWriter iw = new IndexWriter(dir3,anlzr,false, IndexWriter.MaxFieldLength.LIMITED);
Index: src/test/org/apache/lucene/store/TestRAMDirectory.java
===================================================================
--- src/test/org/apache/lucene/store/TestRAMDirectory.java	(revision 915852)
+++ src/test/org/apache/lucene/store/TestRAMDirectory.java	(working copy)
@@ -125,9 +125,6 @@
             } catch (IOException e) {
               throw new RuntimeException(e);
             }
-            synchronized (ramDir) {
-              assertEquals(ramDir.sizeInBytes(), ramDir.getRecomputedSizeInBytes());
-            }
           }
         }
       };
Index: src/test/org/apache/lucene/util/LuceneTestCase.java
===================================================================
--- src/test/org/apache/lucene/util/LuceneTestCase.java	(revision 915852)
+++ src/test/org/apache/lucene/util/LuceneTestCase.java	(working copy)
@@ -21,10 +21,14 @@
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.Random;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Collections;
 
 import junit.framework.TestCase;
 
 import org.apache.lucene.index.ConcurrentMergeScheduler;
+import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.FieldCache;
 import org.apache.lucene.search.FieldCache.CacheEntry;
 import org.apache.lucene.util.FieldCacheSanityChecker.Insanity;
@@ -49,6 +53,22 @@
  */
 public abstract class LuceneTestCase extends TestCase {
 
+
+  private int savedBoolMaxClauseCount;
+  
+  private volatile Thread.UncaughtExceptionHandler savedUncaughtExceptionHandler = null;
+  
+  private static class UncaughtExceptionEntry {
+    public final Thread thread;
+    public final Throwable exception;
+    
+    public UncaughtExceptionEntry(Thread thread, Throwable exception) {
+      this.thread = thread;
+      this.exception = exception;
+    }
+  }
+  private List<UncaughtExceptionEntry> uncaughtExceptions = Collections.synchronizedList(new ArrayList<UncaughtExceptionEntry>());
+
   public LuceneTestCase() {
     super();
   }
@@ -60,7 +80,18 @@
   @Override
   protected void setUp() throws Exception {
     super.setUp();
+    
+    savedUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
+    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
+      public void uncaughtException(Thread t, Throwable e) {
+        uncaughtExceptions.add(new UncaughtExceptionEntry(t, e));
+        if (savedUncaughtExceptionHandler != null)
+          savedUncaughtExceptionHandler.uncaughtException(t, e);
+      }
+    });
+    
     ConcurrentMergeScheduler.setTestMode();
+    savedBoolMaxClauseCount = BooleanQuery.getMaxClauseCount();
   }
 
   /**
@@ -83,6 +114,7 @@
 
   @Override
   protected void tearDown() throws Exception {
+    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);
     try {
       // this isn't as useful as calling directly from the scope where the 
       // index readers are used, because they could be gc'ed just before
@@ -100,6 +132,16 @@
       purgeFieldCache(FieldCache.DEFAULT);
     }
     
+    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);
+    if (!uncaughtExceptions.isEmpty()) {
+      System.err.println("The following exceptions were thrown by threads:");
+      for (UncaughtExceptionEntry entry : uncaughtExceptions) {
+        System.err.println("*** Thread: " + entry.thread.getName() + " ***");
+        entry.exception.printStackTrace(System.err);
+      }
+      fail("Some threads throwed uncaught exceptions!");
+    }
+    
     super.tearDown();
   }
 

Property changes on: src\test\org\apache\lucene\util\TestAttributeSource.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/test/org/apache/lucene/util/TestAttributeSource.java:r912383
   Merged /lucene/java/trunk/src/test/org/apache/lucene/util/TestAttributeSource.java:r912319,912324,912328,912335,912372
   Merged /lucene/java/branches/lucene_3_0_back_compat_tests/src/test/org/apache/lucene/util/TestAttributeSource.java:r889632-889908,893652-912395


Property changes on: src\test\org\apache\lucene\document\TestNumberTools.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0_back_compat_tests/src/test/org/apache/lucene/document/TestNumberTools.java:r889632-889908,893652-912395
   Merged /lucene/java/branches/lucene_3_0/src/test/org/apache/lucene/document/TestNumberTools.java:r912383
   Merged /lucene/java/trunk/src/test/org/apache/lucene/document/TestNumberTools.java:r912319,912324,912328,912335,912372


Property changes on: src\test\org\apache\lucene\document\TestDateTools.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/test/org/apache/lucene/document/TestDateTools.java:r912383
   Merged /lucene/java/trunk/src/test/org/apache/lucene/document/TestDateTools.java:r912319,912324,912328,912335,912372
   Merged /lucene/java/branches/lucene_3_0_back_compat_tests/src/test/org/apache/lucene/document/TestDateTools.java:r889632-889908,893652-912395


Property changes on: src\java\org\apache\lucene\search\MultiTermQueryWrapperFilter.java
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0_back_compat_tests/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java:r889632-889908,893652-912395
   Merged /lucene/java/branches/lucene_3_0/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java:r912383
   Merged /lucene/java/trunk/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java:r912319,912324,912328,912335,912372

Index: src/java/org/apache/lucene/search/function/CustomScoreQuery.java
===================================================================
--- src/java/org/apache/lucene/search/function/CustomScoreQuery.java	(revision 915852)
+++ src/java/org/apache/lucene/search/function/CustomScoreQuery.java	(working copy)
@@ -40,7 +40,7 @@
  *        For most simple/convenient use cases this query is likely to be a 
  *        {@link org.apache.lucene.search.function.FieldScoreQuery FieldScoreQuery}</li>
  * </ol>
- * Subclasses can modify the computation by overriding {@link #customScore(int, float, float)}.
+ * Subclasses can modify the computation by overriding {@link #getCustomScoreProvider}.
  * 
  * <p><font color="#FF0000">
  * WARNING: The status of the <b>search.function</b> package is experimental. 
@@ -83,7 +83,6 @@
    * This parameter is optional - it can be null or even an empty array.
    */
   public CustomScoreQuery(Query subQuery, ValueSourceQuery... valSrcQueries) {
-    super();
     this.subQuery = subQuery;
     this.valSrcQueries = valSrcQueries!=null?
         valSrcQueries : new ValueSourceQuery[0];
@@ -93,11 +92,23 @@
   /*(non-Javadoc) @see org.apache.lucene.search.Query#rewrite(org.apache.lucene.index.IndexReader) */
   @Override
   public Query rewrite(IndexReader reader) throws IOException {
-    subQuery = subQuery.rewrite(reader);
+    CustomScoreQuery clone = null;
+    
+    final Query sq = subQuery.rewrite(reader);
+    if (sq != subQuery) {
+      clone = (CustomScoreQuery) clone();
+      clone.subQuery = sq;
+    }
+
     for(int i = 0; i < valSrcQueries.length; i++) {
-      valSrcQueries[i] = (ValueSourceQuery) valSrcQueries[i].rewrite(reader);
+      final ValueSourceQuery v = (ValueSourceQuery) valSrcQueries[i].rewrite(reader);
+      if (v != valSrcQueries[i]) {
+        if (clone == null) clone = (CustomScoreQuery) clone();
+        clone.valSrcQueries[i] = v;
+      }
     }
-    return this;
+    
+    return (clone == null) ? this : clone;
   }
 
   /*(non-Javadoc) @see org.apache.lucene.search.Query#extractTerms(java.util.Set) */
@@ -142,7 +153,8 @@
     }
     CustomScoreQuery other = (CustomScoreQuery)o;
     if (this.getBoost() != other.getBoost() ||
-        !this.subQuery.equals(other.subQuery)||
+        !this.subQuery.equals(other.subQuery) ||
+        this.strict != other.strict ||
         this.valSrcQueries.length != other.valSrcQueries.length) {
       return false;
     }
@@ -153,32 +165,52 @@
   @Override
   public int hashCode() {
     return (getClass().hashCode() + subQuery.hashCode() + Arrays.hashCode(valSrcQueries))
-      ^ Float.floatToIntBits(getBoost());
-  }  
+      ^ Float.floatToIntBits(getBoost()) ^ (strict ? 1234 : 4321);
+  }
   
   /**
+   * Returns a {@link CustomScoreProvider} that calculates the custom scores
+   * for the given {@link IndexReader}. The default implementation returns a default
+   * implementation as specified in the docs of {@link CustomScoreProvider}.
+   * @since 2.9.2
+   */
+  protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) throws IOException {
+    // when deprecated methods are removed, do not extend class here, just return new default CustomScoreProvider
+    return new CustomScoreProvider(reader) {
+      
+      @Override
+      public float customScore(int doc, float subQueryScore, float valSrcScores[]) throws IOException {
+        return CustomScoreQuery.this.customScore(doc, subQueryScore, valSrcScores);
+      }
+      
+      @Override
+      public float customScore(int doc, float subQueryScore, float valSrcScore) throws IOException {
+        return CustomScoreQuery.this.customScore(doc, subQueryScore, valSrcScore);
+      }
+      
+      @Override
+      public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) throws IOException {
+        return CustomScoreQuery.this.customExplain(doc, subQueryExpl, valSrcExpls);
+      }
+      
+      @Override
+      public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) throws IOException {
+        return CustomScoreQuery.this.customExplain(doc, subQueryExpl, valSrcExpl);
+      }
+      
+    };
+  }
+
+  /**
    * Compute a custom score by the subQuery score and a number of 
    * ValueSourceQuery scores.
-   * <p> 
-   * Subclasses can override this method to modify the custom score.  
-   * <p>
-   * If your custom scoring is different than the default herein you 
-   * should override at least one of the two customScore() methods.
-   * If the number of ValueSourceQueries is always &lt; 2 it is 
-   * sufficient to override the other 
-   * {@link #customScore(int, float, float) customScore()} 
-   * method, which is simpler. 
-   * <p>
-   * The default computation herein is a multiplication of given scores:
-   * <pre>
-   *     ModifiedScore = valSrcScore * valSrcScores[0] * valSrcScores[1] * ...
-   * </pre>
-   * 
-   * @param doc id of scored doc. 
-   * @param subQueryScore score of that doc by the subQuery.
-   * @param valSrcScores scores of that doc by the ValueSourceQuery.
-   * @return custom score.
+   * @deprecated The doc is relative to the current reader, which is
+   * unknown to CustomScoreQuery when using per-segment search (since Lucene 2.9).
+   * Please override {@link #getCustomScoreProvider} and return a subclass
+   * of {@link CustomScoreProvider} for the given {@link IndexReader}.
+   * @see CustomScoreProvider#customScore(int,float,float[])
    */
+  @Deprecated
   public float customScore(int doc, float subQueryScore, float valSrcScores[]) {
     if (valSrcScores.length == 1) {
       return customScore(doc, subQueryScore, valSrcScores[0]);
@@ -195,39 +227,26 @@
 
   /**
    * Compute a custom score by the subQuery score and the ValueSourceQuery score.
-   * <p> 
-   * Subclasses can override this method to modify the custom score.
-   * <p>
-   * If your custom scoring is different than the default herein you 
-   * should override at least one of the two customScore() methods.
-   * If the number of ValueSourceQueries is always &lt; 2 it is 
-   * sufficient to override this customScore() method, which is simpler. 
-   * <p>
-   * The default computation herein is a multiplication of the two scores:
-   * <pre>
-   *     ModifiedScore = subQueryScore * valSrcScore
-   * </pre>
-   * 
-   * @param doc id of scored doc. 
-   * @param subQueryScore score of that doc by the subQuery.
-   * @param valSrcScore score of that doc by the ValueSourceQuery.
-   * @return custom score.
+   * @deprecated The doc is relative to the current reader, which is
+   * unknown to CustomScoreQuery when using per-segment search (since Lucene 2.9).
+   * Please override {@link #getCustomScoreProvider} and return a subclass
+   * of {@link CustomScoreProvider} for the given {@link IndexReader}.
+   * @see CustomScoreProvider#customScore(int,float,float)
    */
+  @Deprecated
   public float customScore(int doc, float subQueryScore, float valSrcScore) {
     return subQueryScore * valSrcScore;
   }
 
   /**
    * Explain the custom score.
-   * Whenever overriding {@link #customScore(int, float, float[])}, 
-   * this method should also be overridden to provide the correct explanation
-   * for the part of the custom scoring.
-   *  
-   * @param doc doc being explained.
-   * @param subQueryExpl explanation for the sub-query part.
-   * @param valSrcExpls explanation for the value source part.
-   * @return an explanation for the custom score
+   * @deprecated The doc is relative to the current reader, which is
+   * unknown to CustomScoreQuery when using per-segment search (since Lucene 2.9).
+   * Please override {@link #getCustomScoreProvider} and return a subclass
+   * of {@link CustomScoreProvider} for the given {@link IndexReader}.
+   * @see CustomScoreProvider#customExplain(int,Explanation,Explanation[])
    */
+  @Deprecated
   public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpls[]) {
     if (valSrcExpls.length == 1) {
       return customExplain(doc, subQueryExpl, valSrcExpls[0]);
@@ -249,15 +268,13 @@
 
   /**
    * Explain the custom score.
-   * Whenever overriding {@link #customScore(int, float, float)}, 
-   * this method should also be overridden to provide the correct explanation
-   * for the part of the custom scoring.
-   *  
-   * @param doc doc being explained.
-   * @param subQueryExpl explanation for the sub-query part.
-   * @param valSrcExpl explanation for the value source part.
-   * @return an explanation for the custom score
+   * @deprecated The doc is relative to the current reader, which is
+   * unknown to CustomScoreQuery when using per-segment search (since Lucene 2.9).
+   * Please override {@link #getCustomScoreProvider} and return a subclass
+   * of {@link CustomScoreProvider} for the given {@link IndexReader}.
+   * @see CustomScoreProvider#customExplain(int,Explanation,Explanation[])
    */
+  @Deprecated
   public Explanation customExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl) {
     float valSrcScore = 1;
     if (valSrcExpl != null) {
@@ -362,7 +379,7 @@
       for(int i = 0; i < valSrcWeights.length; i++) {
         valSrcExpls[i] = valSrcWeights[i].explain(reader, doc);
       }
-      Explanation customExp = customExplain(doc,subQueryExpl,valSrcExpls);
+      Explanation customExp = CustomScoreQuery.this.getCustomScoreProvider(reader).customExplain(doc,subQueryExpl,valSrcExpls);
       float sc = getValue() * customExp.getValue();
       Explanation res = new ComplexExplanation(
         true, sc, CustomScoreQuery.this.toString() + ", product of:");
@@ -390,6 +407,7 @@
     private Scorer subQueryScorer;
     private Scorer[] valSrcScorers;
     private IndexReader reader;
+    private final CustomScoreProvider provider;
     private float vScores[]; // reused in score() to avoid allocating this array for each doc 
 
     // constructor
@@ -402,6 +420,7 @@
       this.valSrcScorers = valSrcScorers;
       this.reader = reader;
       this.vScores = new float[valSrcScorers.length];
+      this.provider = CustomScoreQuery.this.getCustomScoreProvider(reader);
     }
 
     @Override
@@ -426,7 +445,7 @@
       for (int i = 0; i < valSrcScorers.length; i++) {
         vScores[i] = valSrcScorers[i].score();
       }
-      return qWeight * customScore(subQueryScorer.docID(), subQueryScorer.score(), vScores);
+      return qWeight * provider.customScore(subQueryScorer.docID(), subQueryScorer.score(), vScores);
     }
 
     @Override
