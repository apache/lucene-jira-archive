Index: lucene/src/test/org/apache/lucene/index/TestRTTermsDict.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestRTTermsDict.java	(revision 0)
+++ lucene/src/test/org/apache/lucene/index/TestRTTermsDict.java	(revision 0)
@@ -0,0 +1,80 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.index;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestIntSkipList;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class TestRTTermsDict extends LuceneTestCase {
+  public void testBasicAIA() {
+    List<BytesRef> terms = getRandomTerms(10);
+    RTTermsDictAIA aia = new RTTermsDictAIA(100);
+    int c = 0;
+    for (BytesRef r : terms) {
+      //System.out.println("c:"+c+" "+r.utf8ToString());
+      aia.add(r);
+      c++;
+    }
+    
+    Collections.sort(terms, BytesRef.getUTF8SortedAsUnicodeComparator());
+    
+    List<BytesRef> brs = aia.getSortedBRs();
+    // for (BytesRef br : brs) {
+      //System.out.println(""+br.utf8ToString());
+    //}
+    Assert.assertTrue(terms.equals(brs));
+  }
+  
+  public static List<BytesRef> getRandomTerms(int num) {
+    List<BytesRef> list = new ArrayList<BytesRef>();
+    int[] arr = TestIntSkipList.getUniqueRandoms(10, 100);
+    for (int i : arr) {
+      //System.out.println(i);
+      String s = String.format("%07d", i);
+      //System.out.println(s);
+      list.add(new BytesRef(s));
+    }
+    return list;
+  }
+  
+  @Test
+  public void testBasicCSLM() {
+    RTTermsDictCSLM cslm = new RTTermsDictCSLM();
+    // get the terms
+    List<BytesRef> terms = getRandomTerms(10);
+    // add the terms to the terms dict
+    for (BytesRef r : terms) {
+      cslm.add(r);
+    }
+    // sort the list
+    Collections.sort(terms, BytesRef.getUTF8SortedAsUnicodeComparator());
+    // compare the list with the terms dict
+    List<BytesRef> cslmTerms = cslm.getSortedBRs();
+    //for (BytesRef r : cslmTerms) {
+    //  System.out.println("r: "+r.utf8ToString());
+    //}
+    // the lists should be equal, same order and terms
+    Assert.assertTrue(terms.equals(cslmTerms));
+  }
+}
Index: lucene/src/test/org/apache/lucene/util/TestIntLinkedList.java
===================================================================
--- lucene/src/test/org/apache/lucene/util/TestIntLinkedList.java	(revision 0)
+++ lucene/src/test/org/apache/lucene/util/TestIntLinkedList.java	(revision 0)
@@ -0,0 +1,90 @@
+/**
+ * Copyright 2010 The Apache Software Foundation
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.util;
+
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.Random;
+import java.util.Set;
+
+import junit.framework.Assert;
+
+import org.junit.Test;
+
+public class TestIntLinkedList {
+  static Random random = new Random();
+  
+  @Test
+  public void testResize() throws Exception {
+    IntLinkedList li = new IntLinkedList(10, new IntSkipList.DefaultIntComparator());
+    for (int x=0; x < 20; x++) {
+      li.add(x, -1);
+    }
+    int[] arr = li.toArray().vals;
+    Assert.assertEquals(arr.length, 20);
+    for (int x=0; x < 20; x++) {
+      Assert.assertEquals(x, arr[x]);
+    }
+  }
+  
+  @Test
+  public void testRepeats() throws Exception {
+    for (int x=0; x < 1000; x++) {
+      Assert.assertTrue(test(6000));
+    }
+  }
+  
+  public static boolean test(int s) {
+    int[] arr = getRandomArray(s);
+    int[] sorted = Arrays.copyOf(arr, arr.length);
+    Arrays.sort(sorted);
+    IntLinkedList list = new IntLinkedList(arr.length, new IntSkipList.DefaultIntComparator());
+    for (int i = 0; i < arr.length; i++) {
+      list.add(arr[i], i+1);
+    }
+    IntLinkedList.Arrays arrs = list.toArray();
+    int[] vals = arrs.vals;//twodim[0];
+    int[] dows = arrs.dows;//twodim[1];
+    if (!Arrays.equals(vals, sorted)) {
+      System.out.println("arrays not equal");
+      return false;
+    }
+    return true;
+  }
+  
+  public static int[] getRandomArray(int s) {
+    int size = random.nextInt(s);
+    if (size == 0) {
+      size = 66;
+    }
+    int[] array = new int[size];
+    Set<Integer> set = new HashSet<Integer>(size);
+    int c = 0;
+    while (true) {
+      int v = random.nextInt(s*10);
+      if (!set.contains(v)) {
+        array[c++] = v;
+        set.add(v);
+      }
+      if (c >= size) break;
+    }
+    return array;
+  }
+}
Index: lucene/src/test/org/apache/lucene/util/TestIntSkipList.java
===================================================================
--- lucene/src/test/org/apache/lucene/util/TestIntSkipList.java	(revision 0)
+++ lucene/src/test/org/apache/lucene/util/TestIntSkipList.java	(revision 0)
@@ -0,0 +1,233 @@
+/**
+ * Copyright 2010 The Apache Software Foundation
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.util;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicIntegerArray;
+
+import org.apache.lucene.util.IntLinkedList.Node;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class TestIntSkipList {
+  static Random random = new Random();
+  
+  //@Test
+  public void testArrays() throws Exception {
+    for (int x=0; x < 3; x++) {
+      testArrays2();
+    }
+  }
+  
+  @Test
+  public void testIterating2() throws Exception {
+    IntSkipList isl = new IntSkipList(50);
+    
+    int[] arr = new int[]    {8, 1, 4, 9, 2, 18, 14, 11};
+    int[] levels = new int[] {0, 0, 2, 2, 0,  0,  0,  2};
+    for (int x=0; x < arr.length; x++) {
+      isl.add(arr[x], levels[x]);
+    }
+    Node n = new Node();
+    
+    int pos = isl.findZeroLevelPos(14, n);
+    
+    IntLinkedList illzero = isl.getLinkedList(0);
+    int val = illzero.getVal(pos);
+    Assert.assertEquals(14, val);
+    
+    Node node = new Node();
+    int i = pos;
+    while (true) {
+      isl.iterateZeroLevel(i, node);
+      i = node.next;
+      if (node.next == -1) break;
+    }
+  }
+  
+  @Test
+  public void testIterating1() throws Exception {
+    IntSkipList isl = new IntSkipList(50);
+    
+    int[] arr = new int[]    {8, 1, 4, 9, 2, 18, 14, 11};
+    int[] levels = new int[] {0, 0, 2, 2, 0,  0,  0,  2};
+    for (int x=0; x < arr.length; x++) {
+      isl.add(arr[x], levels[x]);
+    }
+    Node n = new Node();
+    
+    int pos = isl.findZeroLevelPos(9, n);
+    
+    IntLinkedList illzero = isl.getLinkedList(0);
+    int val = illzero.getVal(pos);
+    Assert.assertEquals(9, val);
+    
+    Node node = new Node();
+    int i = pos;
+    while (true) {
+      isl.iterateZeroLevel(i, node);
+      i = node.next;
+      if (node.next == -1) break;
+    }
+  }
+  
+  public void testArrays2() throws Exception {
+    int[] arr = new int[1024*1024];
+    AtomicIntegerArray aia = new AtomicIntegerArray(arr.length);
+    long startTime = System.currentTimeMillis();
+    for (int x=0; x < 10000; x++) {
+      runTest(arr);
+    }
+    long duration = System.currentTimeMillis() - startTime;
+    System.out.println("duration arr:"+duration);
+    
+    long startTime2 = System.currentTimeMillis();
+    for (int x=0; x < 10000; x++) {
+      runTest(aia);
+    }
+    long duration2 = System.currentTimeMillis() - startTime2;
+    System.out.println("duration aia:"+duration2);
+  }
+  
+  public void runTest(AtomicIntegerArray aia) {
+    int length = aia.length();
+    for (int x=0; x < length; x++) {
+      aia.set(x, x);
+    }
+  }
+  
+  public void runTest(int[] arr) {
+    for (int x=0; x < arr.length; x++) {
+      arr[x] = x;
+    }
+  }
+  
+  @Test
+  public void testLevelsRandomly() throws Exception {
+    // add by level by manually selecting the level
+    // record the levels added to
+    int[] randomInts = getUniqueRandoms(500, 1000);
+    
+    // value, level
+    Map<Integer,Integer> valLevMap = new HashMap<Integer,Integer>();
+    // level, values
+    Map<Integer,List<Integer>> levValsMap = new HashMap<Integer,List<Integer>>();
+    
+    IntSkipList isl = new IntSkipList(1000);
+    for (int x=0; x < randomInts.length; x++) {
+      int level = isl.randomLevel();
+      int val = randomInts[x];
+      
+      isl.add(val, level);
+      valLevMap.put(val, level);
+      
+      for (int l=0; l <= level; l++) {
+        List<Integer> vals = levValsMap.get(l);
+        if (vals == null) {
+          vals = new ArrayList<Integer>();
+          levValsMap.put(l, vals);
+        }
+        vals.add(val);
+      }
+    }
+    System.out.println("valLevMap:"+valLevMap);
+    System.out.println("levValsMap:"+levValsMap);
+    
+    // assert the values exist correctly at each level
+    for (Map.Entry<Integer,List<Integer>> is : levValsMap.entrySet()) {
+      int level = is.getKey();
+      int[] arr = toSortedArray(is.getValue());
+      int[] vals = isl.getIntArray(level);
+      
+      System.out.println(level+". "+Arrays.toString(arr));
+      System.out.println(level+". "+Arrays.toString(vals));
+      
+      Assert.assertArrayEquals(arr, vals);
+    }
+    // assert the returned int array is correct
+  }
+
+  public static int[] toSortedArray(List<Integer> list) {
+    int[] arr = new int[list.size()];
+    Integer[] is = (Integer[])list.toArray(new Integer[0]);
+    for (int x=0; x < arr.length; x++) {
+      arr[x] = is[x].intValue();
+    }
+    Arrays.sort(arr);
+    return arr;
+  }
+  
+  public static int[] getUniqueRandoms(int num, int max) {
+    Set<Integer> set = new HashSet<Integer>(num);
+    for (int x=0; x < num; x++) {
+      if (!set.add(random.nextInt(max))) 
+        x--;
+    }
+    int[] ints = new int[set.size()];
+    Iterator<Integer> it = set.iterator();
+    int c = 0;
+    while (it.hasNext()) {
+      int i = it.next();
+      ints[c++] = i;
+    }
+    return ints;
+  }
+  
+  @Test
+  public void testLevels() throws Exception {
+    IntSkipList isl = new IntSkipList(100);
+    isl.add(0, 1);
+    isl.add(1, 2);
+        
+    int[] a1 = isl.getIntArray(1);
+    Assert.assertArrayEquals(new int[] {0, 1}, a1);
+    
+    isl.add(2, 2);
+    int[] a3 = isl.getIntArray(2);
+    Assert.assertArrayEquals(new int[] {1, 2}, a3);
+    
+    int[] a4 = isl.getIntArray(2);
+    Assert.assertArrayEquals(new int[] {1, 2}, a4);
+    
+    isl.add(4, 3);
+    int[] a5 = isl.getIntArray(3);
+    Assert.assertArrayEquals(new int[] {4}, a5);
+    
+    isl.add(5, 0);
+    isl.add(6, 0);
+    isl.add(8, 0);
+    isl.add(9, 0);
+    isl.add(7, 3);
+    int[] a6 = isl.getIntArray(3);
+    Assert.assertArrayEquals(new int[] {4, 7}, a6);
+    
+    // TODO: add assertions for the down links
+    
+    System.out.println(""+isl);
+  }
+}
Index: lucene/src/java/org/apache/lucene/index/RTTermsDictAIA.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/RTTermsDictAIA.java	(revision 0)
+++ lucene/src/java/org/apache/lucene/index/RTTermsDictAIA.java	(revision 0)
@@ -0,0 +1,112 @@
+/**
+ * Copyright 2010 The Apache Software Foundation
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.index;
+
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.List;
+
+import org.apache.lucene.util.ByteBlockPool;
+import org.apache.lucene.util.ByteBlockPool.DirectAllocator;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.BytesRefHash;
+import org.apache.lucene.util.IntLinkedList;
+import org.apache.lucene.util.IntLinkedList.Node;
+import org.apache.lucene.util.IntSkipList;
+import org.apache.lucene.util.IntSkipList.IntComparator;
+
+public class RTTermsDictAIA {
+  private final IntSkipList isl;
+  private final ByteBlockPool bbp;
+  private final BytesRefHash brh;
+  
+  public RTTermsDictAIA(int size) {
+    bbp = new ByteBlockPool(new DirectAllocator());
+    brh = new BytesRefHash(bbp);
+    isl = new IntSkipList(size, new BytesRefIntCompartor(bbp, brh));
+  }
+  
+  public List<BytesRef> getSortedBRs() {
+    List<BytesRef> brs = new ArrayList<BytesRef>();
+    
+    int pos = isl.getHeadPos(0);
+    if (pos == -1) return brs;
+    
+    IntLinkedList illzero = isl.getLinkedList(0);
+    int val = illzero.getVal(pos);
+    
+    Node node = new Node();
+    int i = pos;
+    while (true) {
+      isl.iterateZeroLevel(i, node);
+      
+      int ord = node.val;
+      
+      BytesRef br = new BytesRef();
+      int s1 = brh.bytesStart[ord];
+      bbp.setBytesRef(br, s1);
+      //System.out.println("br: "+br.utf8ToString());
+      brs.add(br);
+      
+      i = node.next;
+      if (node.next == -1) break;
+    }
+    return brs;
+  }
+  
+  public void add(BytesRef term) {
+    int ord = brh.add(term);
+    isl.add(ord);
+  }
+  
+  public static class BytesRefIntCompartor implements IntComparator {
+    final ByteBlockPool bbp;
+    final BytesRefHash brh;
+    final BytesRef br1 = new BytesRef();
+    final BytesRef br2 = new BytesRef();
+    final Comparator<BytesRef> comparator;
+    
+    public BytesRefIntCompartor(ByteBlockPool bbp, BytesRefHash brh) {
+      this.bbp = bbp;
+      this.brh = brh;
+      comparator = BytesRef.getUTF8SortedAsUnicodeComparator();
+    }
+    
+    public String toString(int i) {
+      BytesRef r = new BytesRef();
+      int s = brh.bytesStart[i];
+      bbp.setBytesRef(r, s);
+      return r.utf8ToString();
+    }
+    
+    public int compareTo(int i1, int i2) {
+      int s1 = brh.bytesStart[i1];
+      bbp.setBytesRef(br1, s1);
+      
+      int s2 = brh.bytesStart[i2];
+      bbp.setBytesRef(br2, s2);
+      
+      int c = comparator.compare(br1, br2);
+      
+      //System.out.println("compare:"+c+" "+br1.utf8ToString()+" "+br2.utf8ToString());
+      return c;
+    }
+  }
+}
Index: lucene/src/java/org/apache/lucene/index/RTTermsDictCSLM.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/RTTermsDictCSLM.java	(revision 0)
+++ lucene/src/java/org/apache/lucene/index/RTTermsDictCSLM.java	(revision 0)
@@ -0,0 +1,64 @@
+package org.apache.lucene.index;
+
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.ConcurrentSkipListMap;
+
+import org.apache.lucene.util.ByteBlockPool;
+import org.apache.lucene.util.ByteBlockPool.DirectAllocator;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.BytesRefHash;
+
+public class RTTermsDictCSLM {
+  private final ByteBlockPool bbp;
+  private final BytesRefHash brh;
+  private ConcurrentSkipListMap<Integer,Integer> cslm;
+  
+  public RTTermsDictCSLM() {
+    bbp = new ByteBlockPool(new DirectAllocator());
+    brh = new BytesRefHash(bbp);
+    cslm = new ConcurrentSkipListMap<Integer,Integer>(new BytesRefComparator(bbp, brh));
+  }
+  
+  public List<BytesRef> getSortedBRs() {
+    List<BytesRef> brs = new ArrayList<BytesRef>();
+    Iterator<Integer> keys = cslm.navigableKeySet().iterator();
+    while (keys.hasNext()) {
+      int ord = keys.next();
+      BytesRef br = new BytesRef();
+      int s1 = brh.bytesStart[ord];
+      bbp.setBytesRef(br, s1);
+      brs.add(br);
+    }
+    return brs;
+  }
+  
+  public void add(BytesRef term) {
+    int ord = brh.add(term);
+    cslm.put(ord, ord);
+  }
+  
+  public static class BytesRefComparator implements Comparator<Integer> {
+    final ByteBlockPool bbp;
+    final BytesRefHash brh;
+    final BytesRef br1 = new BytesRef();
+    final BytesRef br2 = new BytesRef();
+    
+    public BytesRefComparator(ByteBlockPool bbp, BytesRefHash brh) {
+      this.bbp = bbp;
+      this.brh = brh;
+    }
+    
+    public int compare(Integer i1, Integer i2) {
+      int s1 = brh.bytesStart[i1];
+      bbp.setBytesRef(br1, s1);
+      
+      int s2 = brh.bytesStart[i2];
+      bbp.setBytesRef(br2, s2);
+      
+      return br1.compareTo(br2);
+    }
+  }
+}
Index: lucene/src/java/org/apache/lucene/util/IntSkipList.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/IntSkipList.java	(revision 0)
+++ lucene/src/java/org/apache/lucene/util/IntSkipList.java	(revision 0)
@@ -0,0 +1,208 @@
+package org.apache.lucene.util;
+
+/**
+ * Copyright 2010 The Apache Software Foundation
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Arrays;
+import java.util.Random;
+
+import org.apache.lucene.util.IntLinkedList.Node;
+
+public class IntSkipList {
+  private static final Random seedGenerator = new Random();
+  private transient int randomSeed;
+  volatile IntLinkedList[] lis;
+  private int maxLevel = 1;
+  private IntComparator comparator;
+  private IntArray sts = new IntArray();
+  
+  public IntSkipList(int initSize) {
+    this(initSize, new DefaultIntComparator());
+  }
+  
+  // TODO: put boolean constraint on duplicate addition
+  public IntSkipList(int initSize, IntComparator comparator) {
+    this.comparator = comparator;
+    randomSeed = seedGenerator.nextInt() | 0x0100; // ensure nonzero
+    lis = new IntLinkedList[10];
+  }
+
+  public int getHeadPos(int level) {
+    return lis[level].getHeadPos();
+  }
+  
+  public String toString() {
+    String str = "";
+    for (int x=lis.length-1; x >= 0; x--) {
+      if (lis[x] != null) {
+        str += Arrays.toString(lis[x].toArray().vals)+"\n";
+      }
+    }
+    return str;
+  }
+
+  public int[] getIntArray(int level) {
+    if (lis[level] == null) {
+      return null;
+    }
+    return lis[level].toArray().vals;
+  }
+
+  public static interface IntComparator {
+    public int compareTo(int i1, int i2);
+    
+    public String toString(int i);
+  }
+  
+  public static class DefaultIntComparator implements IntComparator {
+    public int compareTo(int i1, int i2) {
+      return (i1 < i2) ? -1 : ((i1 == i2) ? 0 : 1);
+    }
+    
+    public String toString(int i) {
+      return Integer.toString(i);
+    }
+  }
+  /**
+  private void growArr(int level) {
+    if (level > maxLevel - 1) {
+      if (lis.length < level - 1) {
+        lis = Arrays.copyOf(lis, (int) (lis.length * 1.5));
+        maxLevel = level;
+      }
+    }
+  }
+  **/
+  public void add(int val) {
+    int level = randomLevel();
+    add(val, level);
+  }
+  
+  private static class IntArray {
+    public int length = 0;
+    public int[] array = new int[100];
+    
+    public void reset(int length) {
+      this.length = length;
+      Arrays.fill(array, -1);
+    }
+  }
+  
+  public void add(int val, int level) {
+    sts.reset(level+1);
+    if (sts.length > maxLevel) {
+      maxLevel = sts.length;
+    }    
+    fillStarts(val, sts);
+    
+    add(val, sts, level);
+  }
+
+  // add val to each level
+  // using the starts as a guide
+  public void add(int val, IntArray starts, int level) {
+    // traverse the levels
+    // add a value, record the position
+    // add the value and position/down to the next level
+    int p = -1; // first level's down is always -1
+    for (int x = 0; x < starts.length; x++) {
+      if (lis[x] == null) 
+        lis[x] = new IntLinkedList(512, comparator);
+      if (starts.array[x] == -1) {
+        p = lis[x].add(val, p);
+      } else {
+        p = lis[x].add(val, p, starts.array[x]);
+      }
+    }
+  }
+  
+  // find the starts for each level
+  // starting at the topmost level
+  // eg, we go backwards
+  public void fillStarts(int val, IntArray starts) {
+    int d = -1; // down pos
+    for (int x=starts.length-1; x >= 0; x--) {
+      if (lis[x] != null) {
+        int start;
+        if (d == -1) {
+          start = lis[x].findPrevPos(val);
+        } else {
+          start = lis[x].findPrevPos(d, val);
+        }
+        starts.array[x] = start;
+        if (start != -1) {
+          d = lis[x].getDown(start);
+        }
+      }
+    }
+  }
+  
+  // find the position in level zero
+  // where this val exists or it's previous position
+  public int findZeroLevelPos(int val, Node node) {
+    int d = -1;
+    int start = -1;
+    for (int x=maxLevel-1; x >=0; x--) {
+      if (lis[x] != null) {
+        if (d == -1) {
+          start = lis[x].findPrevEqPos(val, node);
+        } else {
+          start = lis[x].findPrevEqPos(d, val, node);
+        }
+        if (start != -1) {
+          d = lis[x].getDown(start);
+        }
+      }
+    }
+    // return level zero start
+    return start;
+  }
+  
+  public IntLinkedList getLinkedList(int level) {
+    return lis[level];
+  }
+  
+  // from the given position
+  // iterate over level zero
+  public boolean iterateZeroLevel(int pos, Node node) {
+    return lis[0].iterate(pos, node);
+  }
+  
+  /**
+   * Returns a random level for inserting a new node. Hardwired to k=1, p=0.5,
+   * max 31 (see above and Pugh's "Skip List Cookbook", sec 3.4).
+   * 
+   * This uses the simplest of the generators described in George Marsaglia's
+   * "Xorshift RNGs" paper. This is not a high-quality generator but is
+   * acceptable here.
+   */
+  public int randomLevel() {
+    int x = randomSeed;
+    x ^= x << 13;
+    x ^= x >>> 17;
+    randomSeed = x ^= x << 5;
+    if ((x & 0x8001) != 0) // test highest and lowest bits
+    return 0;
+    int level = 1;
+    while (((x >>>= 1) & 1) != 0)
+      ++level;
+    return level;
+  }
+}
Index: lucene/src/java/org/apache/lucene/util/BytesRefHash.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/BytesRefHash.java	(revision 1140013)
+++ lucene/src/java/org/apache/lucene/util/BytesRefHash.java	(working copy)
@@ -49,8 +49,8 @@
 
   // the following fields are needed by comparator,
   // so package private to prevent access$-methods:
-  final ByteBlockPool pool;
-  int[] bytesStart;
+  public final ByteBlockPool pool;
+  public int[] bytesStart;
 
   private final BytesRef scratch1 = new BytesRef();
   private int hashSize;
Index: lucene/src/java/org/apache/lucene/util/IntLinkedList.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/IntLinkedList.java	(revision 0)
+++ lucene/src/java/org/apache/lucene/util/IntLinkedList.java	(revision 0)
@@ -0,0 +1,318 @@
+package org.apache.lucene.util;
+
+/**
+ * Copyright 2010 The Apache Software Foundation
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicIntegerArray;
+
+import org.apache.lucene.util.IntSkipList.IntComparator;
+
+// val,next,down 
+public class IntLinkedList {
+  public static final int CONST = 3;
+  private volatile AtomicIntegerArray linkedList;
+  private AtomicInteger linkedListSize;
+  private AtomicInteger headPos = new AtomicInteger(-1);
+  private AtomicInteger tailPos = new AtomicInteger(-1);
+  private IntComparator comparator;
+  
+  public IntLinkedList(int size, IntComparator comparator) {
+    linkedList = new AtomicIntegerArray(size * CONST);
+    linkedListSize = new AtomicInteger(0);
+    this.comparator = comparator;
+  }
+  
+  public int getHeadPos() {
+    return headPos.get();
+  }
+  
+  public int getSize() {
+    return linkedListSize.get();
+  }
+  
+  public String toStringValues() {
+    Arrays arr = toArray();
+    List<String> ls = new ArrayList<String>();
+    for (int i : arr.vals) {
+      ls.add(comparator.toString(i));
+    }
+    return ls.toString();
+  }
+  
+  public String toString() {
+    return "head:" + headPos.get() + " tail:" + tailPos.get()
+        +"\n"+toStringValues()
+        +"\n"+ linkedList;
+  }
+  
+  //public String toString() {
+  //  return "head:" + headPos.get() + " tail:" + tailPos.get() + " "
+  //      + linkedList;
+  //}
+  
+  public static void fill(int pos, Node node, AtomicIntegerArray linkedList) {
+    int val = linkedList.get((pos * CONST));
+    int next = linkedList.get((pos * CONST) + 1);
+    int down = linkedList.get((pos * CONST) + 2);
+    node.val = val;
+    node.next = next;
+    node.down = down;
+    node.pos = pos;
+  }
+  
+  public static void set(int pos, int val, int next, int down,
+      AtomicIntegerArray linkedList) {
+    linkedList.set((pos * CONST), val);
+    linkedList.set((pos * CONST) + 1, next);
+    linkedList.set((pos * CONST) + 2, down);
+  }
+  
+  public static void setNex(int pos, int next, AtomicIntegerArray linkedList) {
+    linkedList.set((pos * CONST) + 1, next);
+  }
+  
+  public static void setDow(int pos, int down, AtomicIntegerArray linkedList) {
+    linkedList.set((pos * CONST) + 2, down);
+  }
+  
+  public int getDown(int pos) {
+    return getDown(pos, linkedList);
+  }
+  
+  public int getNex(int pos) {
+    return getNex(pos, linkedList);
+  }
+  
+  public int getVal(int pos) {
+    return getVal(pos, linkedList);
+  }
+  
+  public static int getVal(int pos, AtomicIntegerArray array) {
+    return array.get(pos * CONST);
+  }
+  
+  public static int getNex(int pos, AtomicIntegerArray array) {
+    return array.get((pos * CONST) + 1);
+  }
+  
+  public static int getDown(int pos, AtomicIntegerArray array) {
+    return array.get((pos * CONST) + 2);
+  }
+  
+  private int append(int val, int next, int down) {
+    int pos = linkedListSize.getAndIncrement();
+    set(pos, val, next, down, linkedList);
+    return pos;
+  }
+  
+  public static AtomicIntegerArray copyOf(int newSize, AtomicIntegerArray source) {
+    AtomicIntegerArray newone = new AtomicIntegerArray(newSize);
+    int size = source.length();
+    for (int x = 0; x < size; x++) {
+      newone.set(x, source.get(x));
+    }
+    return newone;
+  }
+  
+  public int add(int val, int down) {
+    int hpos = headPos.get();
+    return add(val, down, hpos);
+  }
+  
+  public int add(int val, int down, int start) {
+    // we need to grow the int array
+    if ((linkedListSize.get() * CONST) >= (linkedList.length())) {
+      // nocommit: use Lucene's ArrayUtil.grow
+      linkedList = copyOf((int) ((double) linkedList.length() * 1.5),
+          linkedList);
+    }
+    int hpos = headPos.get();
+    if (hpos == -1) {
+      append(val, -1, down);
+      headPos.set(0);
+      tailPos.set(0);
+      return 0;
+    } else {
+      int headVal = getVal(hpos, linkedList);
+      //int headNext = getNex(hpos, linkedList);
+      int c = comparator.compareTo(headVal, val);
+      if (c > 0) {
+        int pos = append(val, hpos, down);
+        headPos.set(pos);
+        return pos;
+      }
+      
+      // the tail needs to be changed
+      int tpos = tailPos.get();
+      int tailVal = getVal(tpos, linkedList);
+      int tailNex = getNex(tpos, linkedList);
+      
+      assert tailNex == -1;
+      
+      if (comparator.compareTo(val, tailVal) > 0) {
+        int pos = append(val, -1, down);
+        setNex(tpos, pos, linkedList);
+        tailPos.set(pos);
+        return pos;
+      }
+    }
+    // if it's regular
+    int prevPos = findPrevPos(start, val);
+    
+    assert prevPos != -1;
+    
+    int prevNex = getNex(prevPos, linkedList);
+    int pos = append(val, prevNex, down);
+    setNex(prevPos, pos, linkedList);
+    return pos;
+  }
+  
+  public int findPrevPos(int val) {
+    int hp = headPos.get();
+    if (hp == -1) {
+      return -1;
+    }
+    return findPrevPos(hp, val);
+  }
+  
+  public int findPrevPos(int pos, int val) {
+    Node node = new Node();
+    int prevPos = -1;
+    while (true) {
+      fill(pos, node, linkedList);
+      int c = comparator.compareTo(node.val, val);
+      if (node.next == -1 || c > 0) {
+        break;
+      }
+      prevPos = pos;
+      pos = node.next;
+    }
+    return prevPos;
+  }
+  
+  public int findPrevEqPos(int val, Node node) {
+    int hp = headPos.get();
+    if (hp == -1) {
+      return -1;
+    }
+    return findPrevEqPos(hp, val, node);
+  }
+  
+  public int findPrevEqPos(int pos, int val, Node node) {
+    int prevPos = -1;
+    while (true) {
+      fill(pos, node, linkedList);
+      // we found an exact match
+      if (comparator.compareTo(node.val, val) == 0) {
+        return node.pos;
+      }
+      int c = comparator.compareTo(node.val, val);
+      if (node.next == -1 || c > 0) {
+        break;
+      }
+      prevPos = pos;
+      pos = node.next;
+    }
+    return prevPos;
+  }
+  
+  public static class Arrays {
+    public int[] vals;
+    public int[] dows;
+    
+    public Arrays(int[] vals, int[] dows) {
+      this.vals = vals;
+      this.dows = dows;
+    }
+  }
+  
+  // return a 2-dim parallel array
+  // where the first dim are the values
+  // the second dim is the down
+  public Arrays toArray() {
+    int[] vals = new int[linkedListSize.get()];
+    int[] dows = new int[linkedListSize.get()];
+    int pos = headPos.get();
+    Node node = new Node();
+    int prevPos = -1;
+    int c = 0;
+    while (true) {
+      fill(pos, node, linkedList);
+      vals[c] = node.val;
+      dows[c++] = node.down;
+      if (node.next == -1) {
+        break;
+      }
+      prevPos = pos;
+      pos = node.next;
+    }
+    return new Arrays(vals, dows);
+  }
+  
+  public boolean iterate(Node node) {
+    int pos = headPos.get();
+    if (pos == -1) return false;
+    return iterate(pos, node);
+  }
+  
+  // places the values into the Node
+  public boolean iterate(int pos, Node node) {
+    int val = linkedList.get(pos * CONST);
+    int next = linkedList.get((pos * CONST) + 1);
+    node.val = val;
+    node.next = next;
+    return true;
+  }
+  
+  public static class Node {
+    public int val;
+    public int pos;
+    public int next;
+    public int down;
+    
+    public Node() {}
+    
+    public Node(int value, int pos, int next) {
+      this.val = value;
+      this.pos = pos;
+      this.next = next;
+    }
+    
+    @Override
+    public String toString() {
+      return "Node [val=" + val + ", pos=" + pos + ", next=" + next + "]";
+    }
+    
+    // public void fill(AtomicIntegerArray arr) {
+    // append the value
+    // arr.set((pos * CONST), val);
+    // arr.set((pos * CONST) + 1, next);
+    // }
+    
+    // public void fill(Node node) {
+    // node.val = val;
+    // node.pos = pos;
+    // node.next = next;
+    // }
+  }
+}
\ No newline at end of file
