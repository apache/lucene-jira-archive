Index: lucene/core/src/java/org/apache/lucene/index/FieldInfos.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/FieldInfos.java	(revision 1687773)
+++ lucene/core/src/java/org/apache/lucene/index/FieldInfos.java	(working copy)
@@ -25,6 +25,8 @@
 import java.util.SortedMap;
 import java.util.TreeMap;
 
+import org.apache.lucene.util.ArrayUtil;
+
 /** 
  * Collection of {@link FieldInfo}s (accessible by number or by name).
  *  @lucene.experimental
@@ -38,7 +40,10 @@
   private final boolean hasNorms;
   private final boolean hasDocValues;
   
-  private final SortedMap<Integer,FieldInfo> byNumber = new TreeMap<>();
+  // used only by fieldInfo(int)
+  private final FieldInfo[] byNumberTable; // contiguous
+  private final SortedMap<Integer,FieldInfo> byNumberMap; // sparse
+  
   private final HashMap<String,FieldInfo> byName = new HashMap<>();
   private final Collection<FieldInfo> values; // for an unmodifiable iterator
   
@@ -54,6 +59,7 @@
     boolean hasNorms = false;
     boolean hasDocValues = false;
     
+    TreeMap<Integer, FieldInfo> byNumber = new TreeMap<>();
     for (FieldInfo info : infos) {
       if (info.number < 0) {
         throw new IllegalArgumentException("illegal field number: " + info.number + " for field " + info.name);
@@ -84,6 +90,22 @@
     this.hasNorms = hasNorms;
     this.hasDocValues = hasDocValues;
     this.values = Collections.unmodifiableCollection(byNumber.values());
+    Integer max = byNumber.isEmpty() ? null : Collections.max(byNumber.keySet());
+    
+    // Only usee TreeMap in the very sparse case (< 1/16th of the numbers are used),
+    // because TreeMap uses ~ 64 (32 bit JVM) or 120 (64 bit JVM w/o compressed oops)
+    // overall bytes per entry, but array uses 4 (32 bit JMV) or 8
+    // (64 bit JVM w/o compressed oops):
+    if (max != null && max < ArrayUtil.MAX_ARRAY_LENGTH && max < 16*byNumber.size()) {
+      byNumberMap = null;
+      byNumberTable = new FieldInfo[max+1];
+      for (Map.Entry<Integer,FieldInfo> entry : byNumber.entrySet()) {
+        byNumberTable[entry.getKey()] = entry.getValue();
+      }
+    } else {
+      byNumberMap = byNumber;
+      byNumberTable = null;
+    }
   }
   
   /** Returns true if any fields have freqs */
@@ -123,8 +145,7 @@
   
   /** Returns the number of fields */
   public int size() {
-    assert byNumber.size() == byName.size();
-    return byNumber.size();
+    return byName.size();
   }
   
   /**
@@ -157,7 +178,14 @@
     if (fieldNumber < 0) {
       throw new IllegalArgumentException("Illegal field number: " + fieldNumber);
     }
-    return byNumber.get(fieldNumber);
+    if (byNumberTable != null) {
+      if (fieldNumber >= byNumberTable.length) {
+        return null;
+      }
+      return byNumberTable[fieldNumber];
+    } else {
+      return byNumberMap.get(fieldNumber);
+    }
   }
   
   static final class FieldNumbers {
