Index: lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonShape.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonShape.java	(date 1547133179000)
+++ lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonShape.java	(date 1547218684000)
@@ -64,6 +64,13 @@
     }
   }
 
+  protected void addPointToDoc(String field, Document doc, double lat, double lon) {
+    Field[] fields = LatLonShape.createIndexableFields(field, lat, lon);
+    for (Field f : fields) {
+      doc.add(f);
+    }
+  }
+
   protected Query newRectQuery(String field, double minLat, double maxLat, double minLon, double maxLon) {
     return LatLonShape.newBoxQuery(field, QueryRelation.INTERSECTS, minLat, maxLat, minLon, maxLon);
   }
@@ -246,6 +253,142 @@
     Query q = LatLonShape.newBoxQuery(FIELDNAME, QueryRelation.DISJOINT,-29.46555603761226d, 0.0d, 8.381903171539307E-8d, 0.9999999403953552d);
     assertEquals(expected, searcher.count(q));
 
+    IOUtils.close(reader, dir);
+  }
+
+  public void testIndexQuerySamePoint() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+
+    double lon = 1.401298464324817E-45;
+    double lat = 0.0;
+
+    Document document = new Document();
+    addPointToDoc(FIELDNAME, document, lat, lon);
+    writer.addDocument(document);
+
+    ///// search //////
+    IndexReader reader = writer.getReader();
+    writer.close();
+    IndexSearcher searcher = newSearcher(reader);
+
+    // search with the equivalent bounding box
+    Query q = LatLonShape.newBoxQuery(FIELDNAME, QueryRelation.INTERSECTS, lat, lat, lon, lon);
+    assertEquals(1, searcher.count(q));
+
+    IOUtils.close(reader, dir);
+  }
+
+  public void testRandomIndexQuerySamePoint() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+
+    double lon = GeoTestUtil.nextLongitude();
+    double lat = GeoTestUtil.nextLatitude();
+
+    Document document = new Document();
+    addPointToDoc(FIELDNAME, document, lat, lon);
+    writer.addDocument(document);
+
+    ///// search //////
+    IndexReader reader = writer.getReader();
+    writer.close();
+    IndexSearcher searcher = newSearcher(reader);
+
+    // search with the equivalent bounding box
+    Query q = LatLonShape.newBoxQuery(FIELDNAME, QueryRelation.INTERSECTS, lat, lat, lon, lon);
+    assertEquals(1, searcher.count(q));
+
+    IOUtils.close(reader, dir);
+  }
+
+  public void testIndexQuerySamePolygon() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+
+    Polygon poly = new Polygon(new double[]{22.0, 69.0, 69.0, 22.0,22.0},
+                               new double[]{1.401298464324817E-45, 1.401298464324817E-45, 4.8202184588118395E-40, 4.8202184588118395E-40, 1.401298464324817E-45});
+
+    Document document = new Document();
+    addPolygonsToDoc(FIELDNAME, document, poly);
+    writer.addDocument(document);
+
+    ///// search //////
+    IndexReader reader = writer.getReader();
+    writer.close();
+    IndexSearcher searcher = newSearcher(reader);
+
+    // search with the same polygon
+    Query q = LatLonShape.newPolygonQuery(FIELDNAME, QueryRelation.INTERSECTS, poly);
+    assertEquals(1, searcher.count(q));
+
+    IOUtils.close(reader, dir);
+  }
+
+  public void testRandomIndexQuerySamePolygon() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+
+    Polygon poly = GeoTestUtil.nextPolygon();
+
+    Document document = new Document();
+    addPolygonsToDoc(FIELDNAME, document, poly);
+    writer.addDocument(document);
+
+    ///// search //////
+    IndexReader reader = writer.getReader();
+    writer.close();
+    IndexSearcher searcher = newSearcher(reader);
+
+    // search with the same polygon
+    Query q = LatLonShape.newPolygonQuery(FIELDNAME, QueryRelation.INTERSECTS, poly);
+    assertEquals(1, searcher.count(q));
+
+    IOUtils.close(reader, dir);
+  }
+
+  public void testIndexQuerySameLine() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+
+    Line line = new Line(new double[] {3.695366940109445E-170, 3.695366940109445E-170, 1.401298464324817E-45},
+                         new double[]{-18.94969129449734,-1.6109661419330052, -1.6109661419330052});
+
+    Document document = new Document();
+    addLineToDoc(FIELDNAME, document, line);
+    writer.addDocument(document);
+
+    ///// search //////
+    IndexReader reader = writer.getReader();
+    writer.close();
+    IndexSearcher searcher = newSearcher(reader);
+
+    // search with the same line
+    Query q = LatLonShape.newLineQuery(FIELDNAME, QueryRelation.INTERSECTS, line);
+    assertEquals(line.toString(), 1, searcher.count(q));
+
+    IOUtils.close(reader, dir);
+  }
+
+  public void testRandomIndexQuerySameLine() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+
+    Line line = TestLatLonLineShapeQueries.nextLine();
+
+    Document document = new Document();
+    addLineToDoc(FIELDNAME, document, line);
+    writer.addDocument(document);
+
+    ///// search //////
+    IndexReader reader = writer.getReader();
+    writer.close();
+    IndexSearcher searcher = newSearcher(reader);
+
+    // search with the same line
+    Query q = LatLonShape.newLineQuery(FIELDNAME, QueryRelation.INTERSECTS, line);
+    assertEquals(line.toString(), 1, searcher.count(q));
+
     IOUtils.close(reader, dir);
   }
 
Index: lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapeLineQuery.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapeLineQuery.java	(date 1547133179000)
+++ lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapeLineQuery.java	(date 1547217022000)
@@ -67,8 +67,32 @@
         throw new IllegalArgumentException("LatLonShapeLineQuery does not currently support querying across dateline.");
       }
     }
-    this.lines = lines.clone();
-    this.line2D = Line2D.create(lines);
+    this.lines = encodeLines(lines);
+    this.line2D = Line2D.create(this.lines);
+  }
+
+  /**
+   * encode/decode the points for the provided lines.
+   */
+  protected static Line[] encodeLines(Line[] lines) {
+    Line[] clones = new Line[lines.length];
+    for (int i =0; i < lines.length; i++) {
+      clones[i] = encodeLine(lines[i]);
+    }
+    return clones;
+  }
+
+  /**
+   * encode/decode the points for the provided line.
+   */
+  protected static Line encodeLine(Line line) {
+    double[] lats  = new double[line.getLats().length];
+    double[] lons  = new double[line.getLats().length];
+    for (int i =0; i < line.getLats().length; i++) {
+      lats[i] = GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(line.getLat(i)));
+      lons[i] = GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(line.getLon(i)));
+    }
+    return new Line(lats, lons);
   }
 
   @Override
Index: lucene/sandbox/src/test/org/apache/lucene/document/BaseLatLonShapeTestCase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/document/BaseLatLonShapeTestCase.java	(date 1547133179000)
+++ lucene/sandbox/src/test/org/apache/lucene/document/BaseLatLonShapeTestCase.java	(date 1547217022000)
@@ -110,7 +110,7 @@
   }
 
   /** use {@link GeoTestUtil#nextPolygon()} to create a random line; TODO: move to GeoTestUtil */
-  public Line nextLine() {
+  public static Line nextLine() {
     Polygon poly = GeoTestUtil.nextPolygon();
     double[] lats = new double[poly.numPoints() - 1];
     double[] lons = new double[lats.length];
@@ -377,7 +377,6 @@
 
       // line
       Line queryLine = randomQueryLine(shapes);
-      Line2D queryLine2D = Line2D.create(queryLine);
       QueryRelation queryRelation = RandomPicks.randomFrom(random(), POINT_LINE_RELATIONS);
       Query query = newLineQuery(FIELD_NAME, queryRelation, queryLine);
 
@@ -418,7 +417,8 @@
         } else if (shapes[id] == null) {
           expected = false;
         } else {
-          expected = getValidator(queryRelation).testLineQuery(queryLine2D, shapes[id]);
+          Line encodedLine = LatLonShapeLineQuery.encodeLine(queryLine);
+          expected = getValidator(queryRelation).testLineQuery(Line2D.create(encodedLine), shapes[id]);
         }
 
         if (hits.get(docID) != expected) {
@@ -464,7 +464,6 @@
 
       // Polygon
       Polygon queryPolygon = GeoTestUtil.nextPolygon();
-      Polygon2D queryPoly2D = Polygon2D.create(queryPolygon);
       QueryRelation queryRelation = RandomPicks.randomFrom(random(), QueryRelation.values());
       Query query = newPolygonQuery(FIELD_NAME, queryRelation, queryPolygon);
 
@@ -505,7 +504,8 @@
         } else if (shapes[id] == null) {
           expected = false;
         } else {
-          expected = getValidator(queryRelation).testPolygonQuery(queryPoly2D, shapes[id]);
+          Polygon encodedPolygon = LatLonShapePolygonQuery.encodePolygon(queryPolygon);
+          expected = getValidator(queryRelation).testPolygonQuery(Polygon2D.create(encodedPolygon), shapes[id]);
         }
 
         if (hits.get(docID) != expected) {
Index: lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapePolygonQuery.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapePolygonQuery.java	(date 1547133179000)
+++ lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapePolygonQuery.java	(date 1547217022000)
@@ -55,8 +55,40 @@
         throw new IllegalArgumentException("LatLonShapePolygonQuery does not currently support querying across dateline.");
       }
     }
-    this.polygons = polygons.clone();
-    this.poly2D = Polygon2D.create(polygons);
+    this.polygons = encodePolygons(polygons);
+    this.poly2D = Polygon2D.create(this.polygons);
+  }
+
+  /**
+   * encode/decode the points for the provided polygons.
+   */
+  protected static Polygon[] encodePolygons(Polygon[] polygons) {
+    Polygon[] clones = new Polygon[polygons.length];
+    for (int i =0; i < polygons.length; i++) {
+      clones[i] = encodePolygon(polygons[i]);
+    }
+    return clones;
+  }
+
+  /**
+   * encode/decode the points for the provided polygon.
+   */
+  protected static Polygon encodePolygon(Polygon polygon) {
+    double[] lats  = new double[polygon.getPolyLats().length];
+    double[] lons  = new double[polygon.getPolyLats().length];
+    for (int i =0; i < polygon.getPolyLats().length; i++) {
+      lats[i] = GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(polygon.getPolyLat(i)));
+      lons[i] = GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(polygon.getPolyLon(i)));
+    }
+    Polygon[] holes = polygon.getHoles();
+    if (holes != null && holes.length > 0) {
+      Polygon[] encodedHoles = new Polygon[holes.length];
+      for (int i =0; i <holes.length; i++) {
+        encodedHoles[i] = encodePolygon(holes[i]);
+      }
+      return new Polygon(lats, lons, holes);
+    }
+    return new Polygon(lats, lons);
   }
 
   @Override
