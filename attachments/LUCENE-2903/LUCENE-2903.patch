Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 1071187)
+++ lucene/CHANGES.txt	(working copy)
@@ -1,3 +1,11 @@
+This version removed the previous PatchedFrameOfRef4, PatchedFrameOfRef5 and PatchedFrameOfRef6. And added a new PatchedFrameOfRef4, which is faster then them.
+
+Based on the current performance tests, PatchedFrameOfRef4 is faster than BulkVInt and comparable to PatchedFrameOfRef.
+
+PatchedFrameOfRef4 uses the IntBuffer as to save int[]<->byte[] conversions. 
+It also hardcodes the decompression(with the Unpack128WithBuffer class). It also contains some other optimizations.
+
+The detailed experimental results can be found at: https://issues.apache.org/jira/browse/LUCENE-2903?focusedCommentId=12992687#comment-12992687
 Lucene Change Log
 
 ======================= Trunk (not yet released) =======================
Index: lucene/src/test/org/apache/lucene/index/codecs/pfordelta2/TestPForDelta2.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/codecs/pfordelta2/TestPForDelta2.java	(revision 1071187)
+++ lucene/src/test/org/apache/lucene/index/codecs/pfordelta2/TestPForDelta2.java	(working copy)
@@ -1,96 +0,0 @@
-package org.apache.lucene.index.codecs.pfordelta2;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.index.BulkPostingsEnum;
-import org.apache.lucene.index.codecs.sep.*;
-import org.apache.lucene.store.*;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util._TestUtil;
-
-import org.junit.Ignore;
-
-/**
- * This class is to test the PForDeltaFixedIntBlockCodec 
- * 
- *
- */
-
-public class TestPForDelta2 extends LuceneTestCase {
-
-  @Ignore("doens't pass yet")
-  public void testRandomInts() throws Exception {
-    // nocommit mix up block size too once pfor1 supports it
-    int blockSize = 128;
-    IntStreamFactory f = new PForDeltaFixedIntBlockCodec(blockSize).getIntFactory();
-    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {
-      Directory dir = newDirectory();
-      int testDataSize = _TestUtil.nextInt(random, 10000, 100000);
-      int[] testData = new int[testDataSize];
-      for(int i=0; i<testDataSize; ++i) {
-        // nocommit -- do a better job here -- pick
-        // numFrameBits, numExceptions, hten gen according
-        // to that
-        testData[i] = random.nextInt() & Integer.MAX_VALUE;
-      }
-    
-      IntIndexOutput out = f.createOutput(dir, "test");
-      for(int i=0;i<testDataSize;i++) {
-        out.write(testData[i]);
-      }
-      out.close();
-
-      IntIndexInput in = f.openInput(dir, "test");
-      BulkPostingsEnum.BlockReader r = in.reader();
-      final int[] buffer = r.getBuffer();
-      int pointer = 0;
-      int pointerMax = r.fill();
-      assertTrue(pointerMax > 0);
-
-      for(int i=0;i<testDataSize;i++) {
-        if (pointer == pointerMax) {
-          pointerMax = r.fill();
-          assertTrue(pointerMax > 0);
-          pointer = 0;
-        }
-        final int expected = testData[i];
-        final int actual = buffer[pointer++];
-        assertEquals(actual + " != " + expected, expected, actual);
-      }
-      in.close();
-      dir.close();
-    }
-  }
-
-  public void testEmpty() throws Exception {
-    Directory dir = newDirectory();
-    int blockSize = 128;
-    IntStreamFactory f = new PForDeltaFixedIntBlockCodec(blockSize).getIntFactory();
-    IntIndexOutput out = f.createOutput(dir, "test");
-
-    // write no ints
-    out.close();
-
-    IntIndexInput in = f.openInput(dir, "test");
-    in.reader();
-    // read no ints
-    in.close();
-    dir.close();
-  }
-}
-
Index: lucene/src/test/org/apache/lucene/index/codecs/pfordelta2/TestPForDeltaFixedIntBlockWithIntBufferCodec.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/codecs/pfordelta2/TestPForDeltaFixedIntBlockWithIntBufferCodec.java	(revision 0)
+++ lucene/src/test/org/apache/lucene/index/codecs/pfordelta2/TestPForDeltaFixedIntBlockWithIntBufferCodec.java	(revision 0)
@@ -0,0 +1,95 @@
+package org.apache.lucene.index.codecs.pfordelta2;
+
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.BulkPostingsEnum;
+import org.apache.lucene.index.codecs.sep.*;
+import org.apache.lucene.store.*;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util._TestUtil;
+
+/**
+ * This class is to test the PForDeltaFixedIntBlockCodec 
+ * 
+ *
+ */
+
+public class TestPForDeltaFixedIntBlockWithIntBufferCodec extends LuceneTestCase {
+
+  public void testRandomInts() throws Exception {
+	  System.out.println("test int buffer");
+    // nocommit mix up block size too once pfor1 supports it
+    int blockSize = 128;
+    IntStreamFactory f = new PForDeltaFixedIntBlockWithIntBufferFactory(blockSize);
+    for(int iter=0;iter<10*RANDOM_MULTIPLIER;iter++) {
+      Directory dir = newDirectory();
+      int testDataSize = _TestUtil.nextInt(random, 10000, 100000);
+      int[] testData = new int[testDataSize];
+
+      for(int i=0; i<testDataSize; ++i) {
+        // nocommit -- do a better job here -- pick
+        // numFrameBits, numExceptions, hten gen according
+        // to that
+        testData[i] = random.nextInt() & Integer.MAX_VALUE;
+      }
+    
+      IntIndexOutput out = f.createOutput(dir, "test");
+      for(int i=0;i<testDataSize;i++) {
+        out.write(testData[i]);
+      }
+      out.close();
+
+      IntIndexInput in = f.openInput(dir, "test");
+      BulkPostingsEnum.BlockReader r = in.reader();
+      final int[] buffer = r.getBuffer();
+      int pointer = 0;
+      int pointerMax = r.fill();
+      assertTrue(pointerMax > 0);
+
+      for(int i=0;i<testDataSize;i++) {
+        assertEquals(testData[i], buffer[pointer++]);
+        if (pointer == pointerMax) {
+          pointerMax = r.fill();
+          assertTrue(pointerMax > 0);
+          pointer = 0;
+        }
+      }
+      in.close();
+      dir.close();
+    }
+  }
+
+  public void testEmpty() throws Exception {
+    Directory dir = newDirectory();
+    int blockSize = 128;
+    IntStreamFactory f = new PForDeltaFixedIntBlockWithIntBufferFactory(blockSize);
+    IntIndexOutput out = f.createOutput(dir, "test");
+
+    // write no ints
+    out.close();
+
+    IntIndexInput in = f.openInput(dir, "test");
+    in.reader();
+    // read no ints
+    in.close();
+    dir.close();
+  }
+}
+
+

Property changes on: lucene/src/test/org/apache/lucene/index/codecs/pfordelta2/TestPForDeltaFixedIntBlockWithIntBufferCodec.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: lucene/src/java/org/apache/lucene/index/codecs/CoreCodecProvider.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/CoreCodecProvider.java	(revision 1071187)
+++ lucene/src/java/org/apache/lucene/index/codecs/CoreCodecProvider.java	(working copy)
@@ -20,7 +20,7 @@
 import org.apache.lucene.index.codecs.bulkvint.BulkVIntCodec;
 import org.apache.lucene.index.codecs.pfordelta.FrameOfRefCodec;
 import org.apache.lucene.index.codecs.pfordelta.PatchedFrameOfRefCodec;
-import org.apache.lucene.index.codecs.pfordelta2.PForDeltaFixedIntBlockCodec;
+import org.apache.lucene.index.codecs.pfordelta2.PForDeltaFixedIntBlockWithIntBufferCodec;
 import org.apache.lucene.index.codecs.preflex.PreFlexCodec;
 import org.apache.lucene.index.codecs.pulsing.PulsingCodec;
 import org.apache.lucene.index.codecs.simple64.Simple64Codec;
@@ -52,7 +52,7 @@
     register(new SimpleTextCodec());
     register(new PatchedFrameOfRefCodec());
     register(new FrameOfRefCodec());
-    register(new PForDeltaFixedIntBlockCodec(128));
+    register(new PForDeltaFixedIntBlockWithIntBufferCodec(128)); // patchedFrameOfRef6
     register(new BulkVIntCodec(128));
     register(new Simple64Codec(4));
   }
Index: lucene/src/java/org/apache/lucene/index/codecs/bulkvint/BulkVIntCodec.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/bulkvint/BulkVIntCodec.java	(revision 1071187)
+++ lucene/src/java/org/apache/lucene/index/codecs/bulkvint/BulkVIntCodec.java	(working copy)
@@ -28,8 +28,6 @@
 import org.apache.lucene.index.codecs.FieldsConsumer;
 import org.apache.lucene.index.codecs.FieldsProducer;
 import org.apache.lucene.index.codecs.fixed.FixedIntStreamFactory;
-import org.apache.lucene.index.codecs.fixed.FixedPostingsReaderImpl;
-import org.apache.lucene.index.codecs.fixed.FixedPostingsWriterImpl;
 import org.apache.lucene.index.codecs.intblock.FixedIntBlockIndexInput;
 import org.apache.lucene.index.codecs.intblock.FixedIntBlockIndexOutput;
 import org.apache.lucene.index.codecs.PostingsWriterBase;
@@ -40,6 +38,8 @@
 import org.apache.lucene.index.codecs.BlockTermsReader;
 import org.apache.lucene.index.codecs.VariableGapTermsIndexReader;
 import org.apache.lucene.index.codecs.VariableGapTermsIndexWriter;
+import org.apache.lucene.index.codecs.sep.SepPostingsReaderImpl;
+import org.apache.lucene.index.codecs.sep.SepPostingsWriterImpl;
 import org.apache.lucene.index.codecs.standard.StandardCodec;
 import org.apache.lucene.store.*;
 import org.apache.lucene.util.BytesRef;
@@ -152,7 +152,7 @@
 
   @Override
   public FieldsConsumer fieldsConsumer(SegmentWriteState state) throws IOException {
-    PostingsWriterBase postingsWriter = new FixedPostingsWriterImpl(state, new BulkVIntFactory());
+    PostingsWriterBase postingsWriter = new SepPostingsWriterImpl(state, new BulkVIntFactory());
 
     boolean success = false;
     TermsIndexWriterBase indexWriter;
@@ -183,7 +183,7 @@
 
   @Override
   public FieldsProducer fieldsProducer(SegmentReadState state) throws IOException {
-    PostingsReaderBase postingsReader = new FixedPostingsReaderImpl(state.dir,
+    PostingsReaderBase postingsReader = new SepPostingsReaderImpl(state.dir,
                                                                       state.segmentInfo,
                                                                       state.readBufferSize,
                                                                       new BulkVIntFactory(), state.codecId);
@@ -229,14 +229,14 @@
 
   @Override
   public void files(Directory dir, SegmentInfo segmentInfo, String codecId, Set<String> files) {
-    FixedPostingsReaderImpl.files(segmentInfo, codecId, files);
+    SepPostingsReaderImpl.files(segmentInfo, codecId, files);
     BlockTermsReader.files(dir, segmentInfo, codecId, files);
     VariableGapTermsIndexReader.files(dir, segmentInfo, codecId, files);
   }
 
   @Override
   public void getExtensions(Set<String> extensions) {
-    FixedPostingsWriterImpl.getExtensions(extensions);
+    SepPostingsWriterImpl.getExtensions(extensions);
     BlockTermsReader.getExtensions(extensions);
     VariableGapTermsIndexReader.getIndexExtensions(extensions);
   }
Index: lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferFactory.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferFactory.java	(revision 0)
+++ lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferFactory.java	(revision 0)
@@ -0,0 +1,46 @@
+package org.apache.lucene.index.codecs.pfordelta2;
+
+
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.index.codecs.sep.IntStreamFactory;
+import org.apache.lucene.index.codecs.sep.IntIndexInput;
+import org.apache.lucene.index.codecs.sep.IntIndexOutput;
+
+import java.io.IOException;
+
+public class PForDeltaFixedIntBlockWithIntBufferFactory extends IntStreamFactory {
+  private final int blockSize;
+
+  /** blockSize is only used when creating the
+   *  IntIndexOutput */
+  public PForDeltaFixedIntBlockWithIntBufferFactory(int blockSize) {
+    this.blockSize = blockSize;
+  }
+
+  public IntIndexInput openInput(Directory dir, String fileName, int readBufferSize) throws IOException {
+    return new PForDeltaFixedIntBlockWithIntBufferIndexInput(dir, fileName, readBufferSize);
+  }
+  
+
+  public IntIndexOutput createOutput(Directory dir, String fileName) throws IOException {
+    return new PForDeltaFixedIntBlockWithIntBufferIndexOutput(dir, fileName, blockSize);
+  }
+}
\ No newline at end of file

Property changes on: lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferFactory.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferIndexInput.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferIndexInput.java	(revision 0)
+++ lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferIndexInput.java	(revision 0)
@@ -0,0 +1,89 @@
+package org.apache.lucene.index.codecs.pfordelta2;
+
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.util.pfor2.LCPForDelta;
+import org.apache.lucene.index.codecs.intblock.FixedIntBlockIndexInput;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+
+public class PForDeltaFixedIntBlockWithIntBufferIndexInput extends FixedIntBlockIndexInput {
+
+  public PForDeltaFixedIntBlockWithIntBufferIndexInput(Directory dir, String fileName, int readBufferSize) throws IOException {
+    super(dir.openInput(fileName, readBufferSize));
+    
+  }
+
+  private static class BlockReader implements FixedIntBlockIndexInput.BlockReader {
+    private final LCPForDelta decompressor;
+    private final IndexInput input;
+    private final int[] decompBlock;
+    
+    private  final ByteBuffer byteCompBuffer;
+    private  final IntBuffer intCompBuffer;
+    private  final byte[] byteCompBlock;
+    private  final int[] expPosIntBlock;
+    private  final int[] expHighBitIntBlock;
+    
+    private static final int MAX_BLOCK_SIZE = 128;
+    
+    public BlockReader(IndexInput in, int[] buffer) {
+      decompressor = new LCPForDelta();
+      input = in;
+      decompBlock = buffer;
+      
+      byteCompBuffer = ByteBuffer.allocate(MAX_BLOCK_SIZE*4*4);
+      byteCompBlock = byteCompBuffer.array();
+      intCompBuffer = byteCompBuffer.asIntBuffer();
+      
+      expPosIntBlock = new int[MAX_BLOCK_SIZE];
+      expHighBitIntBlock = new int[MAX_BLOCK_SIZE];
+    }
+
+    public void seek(long pos) throws IOException {
+      //
+    }
+
+    public void readBlock() throws IOException {
+
+        //  read the compressed data
+        final int compressedSizeInInt = input.readInt();
+        
+        int blockSize = 128;
+        input.readBytes(byteCompBlock, 0, compressedSizeInInt*4);
+        intCompBuffer.rewind();
+        
+        decompressor.decompressOneBlockWithSizeWithIntBuffer(decompBlock, intCompBuffer, blockSize, expPosIntBlock, expHighBitIntBlock, compressedSizeInInt);
+    }
+
+    public void skipBlock() throws IOException {
+      int numInts = input.readInt(); // nocommit: should PFOR use vint header?
+      input.seek(input.getFilePointer() + numInts*4); // seek past block
+    }
+  }
+
+  protected BlockReader getBlockReader(IndexInput in, int[] buffer) {
+    return new BlockReader(in, buffer);
+  }
+}
+

Property changes on: lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferIndexInput.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferIndexOutput.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferIndexOutput.java	(revision 0)
+++ lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferIndexOutput.java	(revision 0)
@@ -0,0 +1,54 @@
+package org.apache.lucene.index.codecs.pfordelta2;
+
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.codecs.intblock.FixedIntBlockIndexOutput;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.pfor2.LCPForDelta;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+
+public class PForDeltaFixedIntBlockWithIntBufferIndexOutput extends FixedIntBlockIndexOutput {
+  private final LCPForDelta compressor;
+  private final int blockSize;
+  public PForDeltaFixedIntBlockWithIntBufferIndexOutput(Directory dir, String fileName, int blockSize) throws IOException {
+    super(dir.createOutput(fileName), blockSize);
+    this.blockSize = blockSize;
+    compressor = new LCPForDelta();
+  }
+
+  @Override
+  protected void flushBlock() throws IOException {
+      int compressedSizeInInts = compressor.compress(buffer, blockSize);
+      // write out the compressed size in ints 
+      out.writeInt(compressedSizeInInts);
+      
+      int[] compBlock = compressor.getCompBuffer(); 
+      ByteBuffer byteCompBuffer = ByteBuffer.allocate(compressedSizeInInts*4);
+      byte[] byteCompBlock = byteCompBuffer.array();
+      IntBuffer intCompBuffer = byteCompBuffer.asIntBuffer();
+      intCompBuffer.put(compBlock, 0, compressedSizeInInts);
+      
+      out.writeBytes(byteCompBlock, byteCompBlock.length);
+      compressor.setCompBuffer(null);
+  }
+}
+
+

Property changes on: lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferIndexOutput.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockCodec.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockCodec.java	(revision 1071187)
+++ lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockCodec.java	(working copy)
@@ -1,259 +0,0 @@
-package org.apache.lucene.index.codecs.pfordelta2;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import java.io.IOException;
-import java.util.Set;
-
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.index.SegmentWriteState;
-import org.apache.lucene.index.SegmentReadState;
-import org.apache.lucene.index.codecs.Codec;
-import org.apache.lucene.index.codecs.FieldsConsumer;
-import org.apache.lucene.index.codecs.FieldsProducer;
-import org.apache.lucene.index.codecs.fixed.FixedIntStreamFactory;
-import org.apache.lucene.index.codecs.fixed.FixedPostingsReaderImpl;
-import org.apache.lucene.index.codecs.fixed.FixedPostingsWriterImpl;
-import org.apache.lucene.index.codecs.intblock.FixedIntBlockIndexInput;
-import org.apache.lucene.index.codecs.intblock.FixedIntBlockIndexOutput;
-import org.apache.lucene.index.codecs.PostingsWriterBase;
-import org.apache.lucene.index.codecs.PostingsReaderBase;
-import org.apache.lucene.index.codecs.BlockTermsReader;
-import org.apache.lucene.index.codecs.BlockTermsWriter;
-import org.apache.lucene.index.codecs.TermsIndexReaderBase;
-import org.apache.lucene.index.codecs.TermsIndexWriterBase;
-import org.apache.lucene.index.codecs.VariableGapTermsIndexReader;
-import org.apache.lucene.index.codecs.VariableGapTermsIndexWriter;
-import org.apache.lucene.index.codecs.sep.IntStreamFactory;
-import org.apache.lucene.index.codecs.standard.StandardCodec;
-import org.apache.lucene.store.*;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.pfor2.PForDelta;
-
-/**
- * A codec for fixed sized int block encoders. The int encoder
- * used here writes each block as data encoded by PForDelta.
- */
-
-public class PForDeltaFixedIntBlockCodec extends Codec {
-
-  private final int blockSize;
-
-  public PForDeltaFixedIntBlockCodec(int blockSize) {
-    this.blockSize = blockSize;
-    name = "PatchedFrameOfRef2";
-  }
-
-  @Override
-  public String toString() {
-    return name + "(blockSize=" + blockSize + ")";
-  }
-
-  /**
-   * Encode a block of integers using PForDelta and 
-   * @param block the input block to be compressed
-   * @param elementNum the number of elements in the block to be compressed 
-   * @return the compressed size in the number of integers of the compressed data
-   * @throws Exception
-   */
-  int[] encodeOneBlockWithPForDelta(final int[] block, int elementNum) // throws Exception
-    {
-      assert block != null && block.length > 0;
-      /*
-      if(block == null || block.length == 0)
-      {
-        throw new Exception("input block is empty");
-      }
-      */
-      
-      final int[] compressedBlock = PForDelta.compressOneBlock(block, elementNum);
-      assert compressedBlock != null;
-
-      //if(compressedBlock == null) 
-      //{
-      //throw new Exception("compressed buffer is null");
-      //}
-      return compressedBlock;
-    }
-    
-    /**
-     * Decode a block of compressed data (using PForDelta) into a block of elementNum uncompressed integers
-     * @param block the input block to be decompressed
-     * @param elementNum the number of elements in the block to be compressed 
-     */
-    void decodeOneBlockWithPForDelta(final int[] block, int elementNum, final int[] output)
-    {
-      int[] decompressedBlock = PForDelta.decompressOneBlock(block, elementNum);
-      System.arraycopy(decompressedBlock, 0, output, 0, decompressedBlock.length);
-    }
-    
-    
-    public IntStreamFactory getIntFactory() {
-      return new PForDeltaIntFactory();
-    }
-
-    private class PForDeltaIntFactory extends FixedIntStreamFactory {
-
-      @Override
-      public FixedIntBlockIndexInput openInput(IndexInput in, String filename, boolean isChild) throws IOException {
-        return new FixedIntBlockIndexInput(in) {
-
-          @Override
-          protected BlockReader getBlockReader(final IndexInput in, final int[] buffer) throws IOException {
-            return new BlockReader() {
-              // nocommit fixed size:
-              private final int[] compressedData = new int[256];
-              public void seek(long pos) {}
-              public void readBlock() throws IOException {
-                if(buffer != null)
-                {
-                  // retrieve the compressed size in ints
-                  final int compressedSizeInInt = in.readInt();
-                  // read the compressed data (compressedSizeInInt ints)
-                  for(int i=0;i<compressedSizeInInt;i++) {
-                    compressedData[i] = in.readInt();
-                  }
-                  // decompress the block
-                  decodeOneBlockWithPForDelta(compressedData, blockSize, buffer);
-                }
-              }
-              
-              public void skipBlock() throws IOException {
-                final int compressedSizeInInt = in.readInt(); // nocommit: should vint header be used?
-                in.seek(in.getFilePointer() + (compressedSizeInInt * 4)); // seek past block
-              }
-            };
-          }
-        };
-      }
-
-      @Override
-      public FixedIntBlockIndexOutput createOutput(IndexOutput out, String fileName, boolean isChild) throws IOException {
-        return new FixedIntBlockIndexOutput(out, blockSize) {
-          @Override
-          protected void flushBlock() throws IOException {
-            int compressedSizeInInts = 0; 
-            // compress the data
-            //try {
-            final int[] compressedBuffer = encodeOneBlockWithPForDelta(buffer, blockSize);
-            //catch(Exception e) {
-            //e.printStackTrace();
-            //}
-            // write out the compressed size in ints 
-            out.writeInt(compressedBuffer.length);
-            // write out the compressed data
-            for(int i=0;i<compressedBuffer.length;i++) {
-              out.writeInt(compressedBuffer[i]);
-            }
-          }
-        };
-      }
-    }
-
-  @Override
-  public FieldsConsumer fieldsConsumer(SegmentWriteState state) throws IOException {
-    PostingsWriterBase postingsWriter = new FixedPostingsWriterImpl(state, new PForDeltaIntFactory());
-
-    boolean success = false;
-    TermsIndexWriterBase indexWriter;
-    try {
-      indexWriter = new VariableGapTermsIndexWriter(state, new VariableGapTermsIndexWriter.EveryNTermSelector(state.termIndexInterval));
-      success = true;
-    } finally {
-      if (!success) {
-        postingsWriter.close();
-      }
-    }
-
-    success = false;
-    try {
-      FieldsConsumer ret = new BlockTermsWriter(indexWriter, state, postingsWriter, BytesRef.getUTF8SortedAsUnicodeComparator());
-      success = true;
-      return ret;
-    } finally {
-      if (!success) {
-        try {
-          postingsWriter.close();
-        } finally {
-          indexWriter.close();
-        }
-      }
-    }
-  }
-
-  @Override
-  public FieldsProducer fieldsProducer(SegmentReadState state) throws IOException {
-    PostingsReaderBase postingsReader = new FixedPostingsReaderImpl(state.dir,
-                                                                      state.segmentInfo,
-                                                                      state.readBufferSize,
-                                                                      new PForDeltaIntFactory(), state.codecId);
-
-    TermsIndexReaderBase indexReader;
-    boolean success = false;
-    try {
-      indexReader = new VariableGapTermsIndexReader(state.dir,
-                                                    state.fieldInfos,
-                                                    state.segmentInfo.name,
-                                                    state.termsIndexDivisor,
-                                                    state.codecId);
-      success = true;
-    } finally {
-      if (!success) {
-        postingsReader.close();
-      }
-    }
-
-    success = false;
-    try {
-      FieldsProducer ret = new BlockTermsReader(indexReader,
-                                                       state.dir,
-                                                       state.fieldInfos,
-                                                       state.segmentInfo.name,
-                                                       postingsReader,
-                                                       state.readBufferSize,
-                                                       BytesRef.getUTF8SortedAsUnicodeComparator(),
-                                                       StandardCodec.TERMS_CACHE_SIZE,
-                                                       state.codecId);
-      success = true;
-      return ret;
-    } finally {
-      if (!success) {
-        try {
-          postingsReader.close();
-        } finally {
-          indexReader.close();
-        }
-      }
-    }
-  }
-
-  @Override
-  public void files(Directory dir, SegmentInfo segmentInfo, String codecId, Set<String> files) {
-    FixedPostingsReaderImpl.files(segmentInfo, codecId, files);
-    BlockTermsReader.files(dir, segmentInfo, codecId, files);
-    VariableGapTermsIndexReader.files(dir, segmentInfo, codecId, files);
-  }
-
-  @Override
-  public void getExtensions(Set<String> extensions) {
-    FixedPostingsWriterImpl.getExtensions(extensions);
-    BlockTermsReader.getExtensions(extensions);
-    VariableGapTermsIndexReader.getIndexExtensions(extensions);
-  }
-}
Index: lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferCodec.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferCodec.java	(revision 0)
+++ lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferCodec.java	(revision 0)
@@ -0,0 +1,157 @@
+package org.apache.lucene.index.codecs.pfordelta2;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import java.io.IOException;
+import java.util.Set;
+
+import org.apache.lucene.index.SegmentInfo;
+import org.apache.lucene.index.SegmentWriteState;
+import org.apache.lucene.index.SegmentReadState;
+import org.apache.lucene.index.codecs.Codec;
+import org.apache.lucene.index.codecs.FieldsConsumer;
+import org.apache.lucene.index.codecs.FieldsProducer;
+import org.apache.lucene.index.codecs.sep.SepPostingsReaderImpl;
+import org.apache.lucene.index.codecs.sep.SepPostingsWriterImpl;
+import org.apache.lucene.index.codecs.VariableGapTermsIndexReader;
+import org.apache.lucene.index.codecs.VariableGapTermsIndexWriter;
+import org.apache.lucene.index.codecs.PostingsWriterBase;
+import org.apache.lucene.index.codecs.PostingsReaderBase;
+import org.apache.lucene.index.codecs.BlockTermsReader;
+import org.apache.lucene.index.codecs.BlockTermsWriter;
+import org.apache.lucene.index.codecs.TermsIndexReaderBase;
+import org.apache.lucene.index.codecs.TermsIndexWriterBase;
+import org.apache.lucene.index.codecs.standard.StandardCodec;
+import org.apache.lucene.store.*;
+import org.apache.lucene.util.BytesRef;
+
+
+
+/**
+ * A codec for fixed sized int block encoders. The int encoder
+ * used here writes each block as data encoded by PForDelta.
+ */
+
+public class PForDeltaFixedIntBlockWithIntBufferCodec extends Codec {
+
+  private final int blockSize;
+
+  public PForDeltaFixedIntBlockWithIntBufferCodec(int blockSize) {
+    this.blockSize = blockSize;
+    name = "PatchedFrameOfRef4";
+  }
+
+  @Override
+  public String toString() {
+    return name + "(blockSize=" + blockSize + ")";
+  }
+
+
+  @Override
+  public FieldsConsumer fieldsConsumer(SegmentWriteState state) throws IOException {
+    PostingsWriterBase postingsWriter = new SepPostingsWriterImpl(state, new PForDeltaFixedIntBlockWithIntBufferFactory(blockSize));
+
+    boolean success = false;
+    TermsIndexWriterBase indexWriter;
+    try {
+      indexWriter = new VariableGapTermsIndexWriter(state, new VariableGapTermsIndexWriter.EveryNTermSelector(state.termIndexInterval));
+      success = true;
+    } finally {
+      if (!success) {
+        postingsWriter.close();
+      }
+    }
+
+    success = false;
+    try {
+      FieldsConsumer ret = new BlockTermsWriter(indexWriter, state, postingsWriter, BytesRef.getUTF8SortedAsUnicodeComparator());
+      success = true;
+      return ret;
+    } finally {
+      if (!success) {
+        try {
+          postingsWriter.close();
+        } finally {
+          indexWriter.close();
+        }
+      }
+    }
+  }
+
+  @Override
+  public FieldsProducer fieldsProducer(SegmentReadState state) throws IOException {
+    PostingsReaderBase postingsReader = new SepPostingsReaderImpl(state.dir,
+                                                                      state.segmentInfo,
+                                                                      state.readBufferSize,
+                                                                      new PForDeltaFixedIntBlockWithIntBufferFactory(blockSize), state.codecId);
+
+    TermsIndexReaderBase indexReader;
+    boolean success = false;
+    try {
+      indexReader = new VariableGapTermsIndexReader(state.dir,
+                                                    state.fieldInfos,
+                                                    state.segmentInfo.name,
+                                                    state.termsIndexDivisor,
+                                                    state.codecId);
+      success = true;
+    } finally {
+      if (!success) {
+        postingsReader.close();
+      }
+    }
+
+    success = false;
+    try {
+      FieldsProducer ret = new BlockTermsReader(indexReader,
+                                                       state.dir,
+                                                       state.fieldInfos,
+                                                       state.segmentInfo.name,
+                                                       postingsReader,
+                                                       state.readBufferSize,
+                                                       BytesRef.getUTF8SortedAsUnicodeComparator(),
+                                                       StandardCodec.TERMS_CACHE_SIZE,
+                                                       state.codecId);
+      success = true;
+      return ret;
+    } finally {
+      if (!success) {
+        try {
+          postingsReader.close();
+        } finally {
+          indexReader.close();
+        }
+      }
+    }
+  }
+
+  @Override
+  public void files(Directory dir, SegmentInfo segmentInfo, String codecId, Set<String> files) {
+    SepPostingsReaderImpl.files(segmentInfo, codecId, files);
+    BlockTermsReader.files(dir, segmentInfo, codecId, files);
+    VariableGapTermsIndexReader.files(dir, segmentInfo, codecId, files);
+  }
+
+  @Override
+  public void getExtensions(Set<String> extensions) {
+    SepPostingsWriterImpl.getExtensions(extensions);
+    BlockTermsReader.getExtensions(extensions);
+    VariableGapTermsIndexReader.getIndexExtensions(extensions);
+  }
+}
+

Property changes on: lucene/src/java/org/apache/lucene/index/codecs/pfordelta2/PForDeltaFixedIntBlockWithIntBufferCodec.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: lucene/src/java/org/apache/lucene/index/codecs/CodecProvider.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/CodecProvider.java	(revision 1071187)
+++ lucene/src/java/org/apache/lucene/index/codecs/CodecProvider.java	(working copy)
@@ -42,7 +42,7 @@
 
   private final Set<String> knownExtensions = new HashSet<String>();
 
-  public final static String[] CORE_CODECS = new String[] {"Standard", "Pulsing", "PreFlex", "SimpleText", "PatchedFrameOfRef", "FrameOfRef", "PatchedFrameOfRef2", "BulkVInt", "Simple64" };
+  public final static String[] CORE_CODECS = new String[] {"Standard", "Pulsing", "PreFlex", "SimpleText", "PatchedFrameOfRef", "FrameOfRef", "PatchedFrameOfRef2","PatchedFrameOfRef4","BulkVInt", "Simple64" };
 
   public synchronized void register(Codec codec) {
     if (codec.name == null) {
Index: lucene/src/java/org/apache/lucene/util/pfor2/LCPForDelta.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/pfor2/LCPForDelta.java	(revision 0)
+++ lucene/src/java/org/apache/lucene/util/pfor2/LCPForDelta.java	(revision 0)
@@ -0,0 +1,548 @@
+package org.apache.lucene.util.pfor2;
+
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Arrays;
+import java.nio.IntBuffer;
+
+/**
+ * Implementation of the optimized PForDelta algorithm for sorted integer arrays. The basic ideas are based on
+ * 
+ * 1. Original algorithm from
+ * http://homepages.cwi.nl/~heman/downloads/msthesis.pdf 
+ * 
+ * 2. Optimization and
+ * variation from http://www2008.org/papers/pdf/p387-zhangA.pdf 
+ * 
+ * 3. Further optimization
+ * http://www2009.org/proceedings/pdf/p401.pdf
+ *  
+ *  As a part of the PForDelta implementation, Simple16 is used to compress exceptions. 
+ *  The original Simple16 algorithm can also be found in the above literatures.
+ *  
+ *  This implementation overcomes the problem that Simple16 cannot deal with >2^28 numbers. 
+ *  
+ *  This implemtatation is almost same as PForDelta in the same package, except that it is tuned especially for Lucene-4.0 Codec to achieve
+ *  the best performance in Lucene-4.0.
+ *  
+ * @author hao yan, hyan2008@gmail.com
+ */
+public class LCPForDelta{
+      
+      // NOTE: we expect the blockSize is always < (1<<(31-POSSIBLE_B_BITS)). For example, in the current default settings,
+      //  the blockSize < (1<<(31-5)), that is, < 2^27
+      
+      //All possible values of b in the PForDelta algorithm
+      private static final int[] POSSIBLE_B = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,16,20,28}; 
+      
+      // POSSIBLE_B.length < (1<<POSSIBLE_B_BITS)
+      private static final int POSSIBLE_B_BITS = 5; 
+      // Max number of bits to store an uncompressed value
+      private static final int MAX_BITS = 32;
+      // Header records the value of b and the number of exceptions in the block
+      private static final int HEADER_NUM = 1;
+      // Header size in bits
+      private static final int HEADER_SIZE = MAX_BITS * HEADER_NUM;
+
+      private static final int[] MASK = {0x00000000,
+        0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f,
+        0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff,
+        0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff, 0x0001ffff, 0x0003ffff,
+        0x0007ffff, 0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
+        0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff, 0x1fffffff, 0x3fffffff,
+        0x7fffffff, 0xffffffff};
+     
+      private int[] compBuffer; // buffer to hold the compressed data
+      
+      public int[] getCompBuffer()
+      {
+          return compBuffer;
+      }
+      
+      public void setCompBuffer(int[] buffer)
+      {
+          compBuffer = buffer;
+      }
+      
+      
+      /**
+       * Compress one block of blockSize integers using PForDelta with the optimal parameter b
+       * @param inBlock the block to be compressed
+       * @param blockSize the block size
+       * @return the compressed block
+       */
+      public int compress(int[] inBlock, int blockSize)
+      { 
+        // find the best b that can lead to the smallest overall compressed size
+        int currentB = POSSIBLE_B[0];   
+        int tmpB = currentB;
+        boolean hasBigNum = checkBigNumbers(inBlock, blockSize, POSSIBLE_B[POSSIBLE_B.length-1]);
+        if(hasBigNum)
+        {
+          currentB = 4;
+        }
+        else
+        {
+          int optSize = estimateCompressedSize(inBlock, blockSize, tmpB);
+          for (int i = 1; i < POSSIBLE_B.length; ++i)
+          {
+            tmpB = POSSIBLE_B[i];
+            int curSize = estimateCompressedSize(inBlock, blockSize, tmpB);
+            if(curSize < optSize)
+            {
+              currentB = tmpB;
+              optSize = curSize;
+            }
+          }
+        }
+        
+        // compress the block using the above best b 
+        int compressedSizeInInts = compressOneBlockCore(inBlock, blockSize, currentB);
+
+        return compressedSizeInInts;  
+      }
+      
+      /**
+       * The core implementation of compressing a block with blockSize integers using PForDelta with the given parameter b 
+       * @param inputBlock the block to be compressed
+       * @param blockSize the block size
+       * @param bits the the value of the parameter b
+       * @return the size of the compressed block (the number of ints)
+       * @throws IllegalArgumentException
+       */
+      public int compressOneBlockCore(int[] inputBlock, int blockSize, int bits) throws IllegalArgumentException {
+            int outputOffset = HEADER_SIZE;
+            int expUpperBound = 1<<bits;
+            int expNum = 0;      
+            int maxCompBitSize =  HEADER_SIZE + blockSize * (MAX_BITS  + MAX_BITS + MAX_BITS) + 32;
+            int[] tmpCompBuffer = new int[(maxCompBitSize>>>5)];
+            
+            int[] expPosBuffer = new int[blockSize];
+            int[] expHighBitsBuffer = new int[blockSize]; 
+            
+            // compress the b-bit slots
+            for (int i = 0; i<blockSize; ++i)
+            {
+              int value = inputBlock[i];
+              if (value < expUpperBound) 
+              {
+                writeBits(tmpCompBuffer, value, outputOffset, bits);
+              } 
+              else // exp
+              {
+                // store the lower bits-bits of the exception
+                writeBits(tmpCompBuffer, value & MASK[bits], outputOffset, bits); 
+                // write the position of exception
+                expPosBuffer[expNum] = i; 
+                // write the higher 32-bits bits of the exception
+                expHighBitsBuffer[expNum] = (value >>> bits) & MASK[32-bits];
+                expNum++;
+              }
+              outputOffset += bits;
+            }    
+
+            tmpCompBuffer[0] = ((bits & MASK[POSSIBLE_B_BITS]) << (31-POSSIBLE_B_BITS)) | (expNum & MASK[31-POSSIBLE_B_BITS]);
+
+            // compress exceptions
+            if(expNum>0)
+            {
+              int compressedBitSize;
+              
+              compressedBitSize = compressBlockByS16(tmpCompBuffer, outputOffset, expPosBuffer, expNum, blockSize, inputBlock);
+              outputOffset += compressedBitSize;
+              
+              compressedBitSize = compressBlockByS16(tmpCompBuffer, outputOffset, expHighBitsBuffer, expNum, blockSize, inputBlock);
+              outputOffset += compressedBitSize;
+            }
+
+            // discard the redundant parts in the tmpCompressedBlock
+            int compressedSizeInInts = (outputOffset+31)>>>5;
+
+            compBuffer = tmpCompBuffer;
+            return compressedSizeInInts;
+          }
+
+      public int compressOneBlockCore2(int[] inputBlock, int blockSize, int bits) throws IllegalArgumentException {
+          int outputOffset = HEADER_SIZE;
+          int expUpperBound = 1<<bits;
+          int expNum = 0;      
+          int maxCompBitSize =  HEADER_SIZE + blockSize * (MAX_BITS  + MAX_BITS + MAX_BITS) + 32;
+          int[] tmpCompBuffer = new int[(maxCompBitSize>>>5)];
+          
+          int[] expPosBuffer = new int[blockSize];
+          int[] expHighBitsBuffer = new int[blockSize]; 
+          
+          // compress the b-bit slots
+          for (int i = 0; i<blockSize; ++i)
+          {
+            int value = inputBlock[i];
+            if (value < expUpperBound) 
+            {
+              writeBits(tmpCompBuffer, value, outputOffset, bits);
+            } 
+            else // exp
+            {
+              // store the lower bits-bits of the exception
+              writeBits(tmpCompBuffer, value & MASK[bits], outputOffset, bits); 
+              // write the position of exception
+              expPosBuffer[expNum] = i; 
+              // write the higher 32-bits bits of the exception
+              expHighBitsBuffer[expNum] = (value >>> bits) & MASK[32-bits];
+              expNum++;
+            }
+            outputOffset += bits;
+          }    
+
+          tmpCompBuffer[0] = ((bits & MASK[POSSIBLE_B_BITS]) << (31-POSSIBLE_B_BITS)) | (expNum & MASK[31-POSSIBLE_B_BITS]);
+
+          // compress exceptions
+          if(expNum>0)
+          {
+            int compressedBitSize;
+            
+            int[] expBuffer = new int[expNum*2];
+            System.arraycopy(expPosBuffer,0, expBuffer,0,expNum);
+            System.arraycopy(expHighBitsBuffer,0,expBuffer,expNum,expNum);
+            
+            compressedBitSize = compressBlockByS16(tmpCompBuffer, outputOffset, expBuffer, expNum*2, blockSize, inputBlock);
+            outputOffset += compressedBitSize;
+          }
+
+          // discard the redundant parts in the tmpCompressedBlock
+          int compressedSizeInInts = (outputOffset+31)>>>5;
+
+          compBuffer = tmpCompBuffer;
+          return compressedSizeInInts;
+        }
+      
+      /**
+       * Decompress one block using PForDelta
+       * @param decompBlock the block that was decompressed
+       * @param inBlock the block to be decompressed
+       * @param blockSize the number of elements in the decompressed block
+       * 
+       */
+      public void decompressOneBlock(int[] decompBlock, int[] inBlock, int blockSize)
+      {
+        int expNum = inBlock[0] & MASK[31-POSSIBLE_B_BITS]; 
+        int bits = (inBlock[0]>>>(31-POSSIBLE_B_BITS)) & (0x1f);    
+
+        int[] expPosBuffer = new int[blockSize];
+        int[] expHighBitsBuffer = new int[blockSize];
+        
+        // decompress the b-bit slots
+        int offset = HEADER_SIZE;
+        int compressedBits = 0;
+        if(bits == 0)
+        {
+          Arrays.fill(decompBlock,0);
+        }
+        else
+        {
+          compressedBits = decompressBBitSlots(decompBlock, inBlock, blockSize, bits);
+          //compressedBits = decompressBBitSlotsWithHardCodes(decompBlock, inBlock, blockSize, bits);
+        }
+        offset += compressedBits;
+
+        // decompress exceptions
+        if(expNum>0)
+        {
+          compressedBits = decompressBlockByS16(expPosBuffer, inBlock, offset, expNum);
+          offset += compressedBits;
+          compressedBits = decompressBlockByS16(expHighBitsBuffer, inBlock, offset, expNum);
+          offset += compressedBits;
+
+          for (int i = 0; i < expNum; i++) 
+          { 
+            int curExpPos = expPosBuffer[i]  ;
+            int curHighBits = expHighBitsBuffer[i];
+            decompBlock[curExpPos] = (decompBlock[curExpPos] & MASK[bits]) | ((curHighBits & MASK[32-bits] ) << bits);
+          }
+        }
+      }
+      
+      public void decompressOneBlockWithSize(int[] decompBlock, int[] inBlock, int blockSize, int[] expPosBuffer, int[] expHighBitsBuffer, int inBlockLen)
+      {
+        int expNum = inBlock[0] & MASK[31-POSSIBLE_B_BITS]; 
+        int bits = (inBlock[0]>>>(31-POSSIBLE_B_BITS)) & (0x1f);    
+
+        // decompress the b-bit slots
+        int offset = HEADER_SIZE;
+        int compressedBits = 0;
+        if(bits == 0)
+        {
+          Arrays.fill(decompBlock,0, inBlockLen, 0);
+        }
+        else
+        {
+          //compressedBits = decompressBBitSlotsWithHardCodes(decompBlock, inBlock, blockSize, bits);
+          compressedBits = decompressBBitSlots(decompBlock, inBlock, blockSize, bits);
+        }
+        offset += compressedBits;
+
+        // decompress exceptions
+        if(expNum>0)
+        {
+          compressedBits = decompressBlockByS16(expPosBuffer, inBlock, offset, expNum);
+          offset += compressedBits;
+          compressedBits = decompressBlockByS16(expHighBitsBuffer, inBlock, offset, expNum);
+          offset += compressedBits;
+
+          for (int i = 0; i < expNum; i++) 
+          { 
+            int curExpPos = expPosBuffer[i]  ;
+            int curHighBits = expHighBitsBuffer[i];
+            decompBlock[curExpPos] = (decompBlock[curExpPos] & MASK[bits]) | ((curHighBits & MASK[32-bits] ) << bits);
+          }
+        }
+      }
+      
+      public void decompressOneBlockWithSizeWithIntBuffer(final int[] decompBlock, final IntBuffer inBlock, final int blockSize, final int[] expPosBuffer, final int[] expHighBitsBuffer, final int inBlockLen)
+      {
+    	final int flag = inBlock.get();
+    	final int expNum = flag & MASK[31-POSSIBLE_B_BITS]; 
+    	final int bits = (flag>>>(31-POSSIBLE_B_BITS)) & (0x1f); 
+    	if(bits == 0)
+    	{
+    		Arrays.fill(decompBlock,0, inBlockLen, 0);
+    	}
+    	else
+    	{
+    		Unpack128WithBuffer.unpack(decompBlock, inBlock, bits);
+    	}
+    	
+    	if(expNum>0)
+    	{
+    		// decompress expPos
+    		int num, outOffset=0, numLeft;
+    		for(numLeft=expNum; numLeft>0; numLeft -= num)
+    		{
+    			num = Simple16.s16DecompressWithIntBufferWithHardCodes(expPosBuffer, outOffset, inBlock.get(), numLeft);
+    			outOffset += num;
+    		}
+
+    		// decompress expHighBits and decompBlock at the same time
+    		for(outOffset=0, numLeft=expNum; numLeft>0; numLeft -= num)
+    		{
+    			num = Simple16.s16DecompressWithIntBufferIntegrated2(decompBlock, outOffset, inBlock.get(), numLeft, expPosBuffer, bits);
+    			outOffset += num;
+    		}
+    	}
+      }
+      
+
+      /**
+       * Estimate the compressed size in ints of a block
+       * @param inputBlock the block to be compressed
+       * @param bits the value of the parameter b
+       * @param blockSize the block size 
+       * @return the compressed size in ints
+       * @throws IllegalArgumentException
+       */
+      public int estimateCompressedSize(int[] inputBlock, int blockSize, int bits) throws IllegalArgumentException {
+        int maxNoExp = (1<<bits)-1;
+        // Size of the header and the bits-bit slots
+        int outputOffset = HEADER_SIZE + bits * blockSize; 
+        int expNum = 0;      
+
+        for (int i = 0; i<blockSize; ++i)
+        {      
+          if (inputBlock[i] > maxNoExp) 
+          {
+            expNum++;
+          }
+        }    
+        outputOffset += (expNum<<5);
+
+        return outputOffset;
+      }
+      
+      /**
+       * Check if the block contains big numbers that is greater than ((1<< bits)-1)
+       * @param inputBlock the block to be compressed
+       * @param bits the numbers of bits to decide whether a number is a big number
+       * @param blockSize the block size
+       * @return true if there is any big numbers in the block
+       * @throws IllegalArgumentException
+       */
+      public boolean checkBigNumbers(int[] inputBlock, int blockSize, int bits) throws IllegalArgumentException {
+        int maxNoExp = (1<<bits)-1;
+        for (int i = 0; i<blockSize; ++i)
+        {      
+          if (inputBlock[i] > maxNoExp) return true; 
+        }    
+        return false;
+      }
+     
+      
+      /**
+       * Decompress b-bit slots
+       * @param outDecompSlots decompressed block which is the output
+       * @param inCompBlock the compressed block which is the input
+       * @param blockSize the block size
+       * @param bits the value of the parameter b
+       * @return the compressed size in bits of the data that has been decompressed
+       */
+      public int decompressBBitSlots(int[] outDecompSlots, int[] inCompBlock, int blockSize, int bits)
+      {
+        int compressedBitSize = 0;
+        int offset = HEADER_SIZE;
+        for(int i =0; i<blockSize; i++)
+        {
+          outDecompSlots[i] = readBits(inCompBlock, offset, bits);
+          offset += bits;
+        }
+        compressedBitSize = bits * blockSize;
+
+        return compressedBitSize;    
+      } 
+      
+      
+      public int decompressBBitSlotsWithHardCodes(final int[] outDecompSlots, final int[] inCompBlock, final int blockSize, final int bits)
+      {
+        int compressedBitSize = 0;
+        Unpack128.unpack(outDecompSlots, inCompBlock, bits);
+        compressedBitSize = bits * blockSize;
+        return compressedBitSize;    
+      } 
+      
+      public int decompressBBitSlotsWithHardCodesWithIntBuffer(final int[] outDecompSlots, final IntBuffer inCompBlock, final int blockSize, final int bits)
+      {
+        Unpack128WithBuffer.unpack(outDecompSlots, inCompBlock, bits);
+        return bits * blockSize;    
+      } 
+      
+
+      /**
+       * Compress a block of blockSize integers using Simple16 algorithm 
+       * @param outCompBlock the compressed block which is the output
+       * @param outStartOffsetInBits the start offset in bits of the compressed block 
+       * @param inBlock the block to be compressed
+       * @param blockSize the block size
+       * @return the compressed size in bits
+       */
+      private int compressBlockByS16(int[] outCompBlock, int outStartOffsetInBits, int[] inBlock, int blockSize, int oriBlockSize, int[] oriInputBlock)
+      {
+        int outOffset  = (outStartOffsetInBits+31)>>>5; 
+        int num, inOffset=0, numLeft;
+        for(numLeft=blockSize; numLeft>0; numLeft -= num)
+        {
+          num = Simple16.s16Compress(outCompBlock, outOffset, inBlock, inOffset, numLeft, blockSize, oriBlockSize, oriInputBlock);
+          outOffset++;
+          inOffset += num;
+        }
+        int compressedBitSize = (outOffset<<5)-outStartOffsetInBits;
+        return compressedBitSize;    
+      }
+
+      /**
+       * Decompress a block of blockSize integers using Simple16 algorithm
+       * @param outDecompBlock the decompressed block which is the output
+       * @param inCompBlock the compressed block which is the input
+       * @param blockSize the block size 
+       * @param inStartOffsetInBits  the start offset in bits of the compressed block
+       * @return the compressed size in bits of the data that has been decompressed
+       */
+      public int decompressBlockByS16(int[] outDecompBlock, int[] inCompBlock, int inStartOffsetInBits, int blockSize)
+      {    
+        int inOffset  = (inStartOffsetInBits+31)>>>5;
+        int num, outOffset=0, numLeft;
+        for(numLeft=blockSize; numLeft>0; numLeft -= num)
+        {
+          num = Simple16.s16Decompress(outDecompBlock, outOffset, inCompBlock, inOffset, numLeft);
+          outOffset += num;
+          inOffset++;
+        }
+        int compressedBitSize = (inOffset<<5)-inStartOffsetInBits;
+        return compressedBitSize;    
+      }
+
+      public void decompressBlockByS16WithIntBuffer(final int[] outDecompBlock, final IntBuffer inCompBlock, final int blockSize)
+      {    
+        int num, outOffset=0, numLeft;
+        for(numLeft=blockSize; numLeft>0; numLeft -= num)
+        {
+          num = Simple16.s16DecompressWithIntBuffer(outDecompBlock, outOffset, inCompBlock.get(), numLeft);
+          outOffset += num;
+        }
+      }
+      
+      public void decompressBlockByS16WithIntBufferIntegrated(final int[] outDecompBlock, final IntBuffer inCompBlock, final int blockSize, int[] expPosBuffer, int oribits)
+      {    
+        int num, outOffset=0, numLeft;
+        for(numLeft=blockSize; numLeft>0; numLeft -= num)
+        {
+          num = Simple16.s16DecompressWithIntBufferIntegrated(outDecompBlock, outOffset, inCompBlock.get(), numLeft, expPosBuffer, oribits);
+          outOffset += num;
+        }
+      }
+      
+
+      /**
+       * Write a certain number of bits of an integer into an integer array starting from the given start offset
+       * 
+       * @param out the output array 
+       * @param val the integer to be written
+       * @param outOffset the start offset in bits in the output array
+       * @param bits the number of bits to be written (bits>=0)
+       */
+      public static final void writeBits(int[] out, int val, int outOffset, int bits) {
+        if(bits == 0)
+          return;
+        final int index = outOffset >>> 5;
+        final int skip = outOffset & 0x1f;
+        val &= (0xffffffff >>> (32 - bits));   
+        out[index] |= (val << skip);
+        if (32 - skip < bits) {
+          out[index + 1] |= (val >>> (32 - skip));
+        }
+      }
+
+      /**
+       * Read a certain number of bits of an integer into an integer array starting from the given start offset
+       * 
+       * @param in the input array 
+       * @param val the integer to be read
+       * @param inOffset the start offset in bits in the input array
+       * @param bits the number of bits to be read, unlike writeBits(), readBits() does not deal with bits==0 and thus bits must > 0. When bits ==0, the calling functions will just skip the entire bits-bit slots without decoding them
+       * @return the bits bits of the input
+       */
+      public static final int readBits(int[] in, final int inOffset, final int bits) {
+        final int index = inOffset >>> 5;
+        final int skip = inOffset & 0x1f;
+        int val = in[index] >>> skip;
+        if (32 - skip < bits) {      
+          val |= (in[index + 1] << (32 - skip));
+        }
+        return val & (0xffffffff >>> (32 - bits));
+      }
+
+      public static final int readBitsWithBuffer(int[] in, final int inOffset, final int bits) {
+          final int index = inOffset >>> 5;
+          final int skip = inOffset & 0x1f;
+          int val = in[index] >>> skip;
+          if (32 - skip < bits) {      
+            val |= (in[index + 1] << (32 - skip));
+          }
+          return val & (0xffffffff >>> (32 - bits));
+        }
+      
+    }
+
+

Property changes on: lucene/src/java/org/apache/lucene/util/pfor2/LCPForDelta.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: lucene/src/java/org/apache/lucene/util/pfor2/Simple16.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/pfor2/Simple16.java	(revision 1071187)
+++ lucene/src/java/org/apache/lucene/util/pfor2/Simple16.java	(working copy)
@@ -17,6 +17,9 @@
  * limitations under the License.
  */
 
+import java.nio.IntBuffer;
+
+
 /**
  * Implementation of the Simple16 algorithm for sorted integer arrays. The basic ideas are based on papers from
  * 
@@ -24,15 +27,22 @@
  * 
  * 2. http://www2009.org/proceedings/pdf/p401.pdf
  * 
+ * The maximum possible integer value Simple16 can encode is < 2^28 (this is dertermined by the Simple16 algorithm itself).
+ * Therefore, in order to use Simple16, the application must write their own code to encode numbers in the range of [2^28, 2^32).
+ * A simple way is just write those numbers as 32-bit integers (that is, no compression for very big numbers).
+ * 
+ * Author: Hao Yan, hyan2008@gmail.com
  */
 
-public class Simple16 {
+public class Simple16{
   
   private static final int S16_NUMSIZE = 16;
   private static final int S16_BITSSIZE = 28;
-  // the possible number of bits used to represent one integer 
+  
+  //the possible number of compressed numbers hold in a single 32-bit integer
   private static final int[] S16_NUM = {28, 21, 21, 21, 14, 9, 8, 7, 6, 6, 5, 5, 4, 3, 2, 1};
-  // the corresponding number of elements for each value of the number of bits
+  
+  //the possible number of bits used to compress one number 
   private static final int[][] S16_BITS = { {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
       {2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0},
       {1,1,1,1,1,1,1,2,2,2,2,2,2,2,1,1,1,1,1,1,1,0,0,0,0,0,0,0},
@@ -50,6 +60,14 @@
       {14,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
       {28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} };
   
+  private static final int[] MASK = {0x00000000,
+      0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f,
+      0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff,
+      0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff, 0x0001ffff, 0x0003ffff,
+      0x0007ffff, 0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
+      0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff, 0x1fffffff, 0x3fffffff,
+      0x7fffffff, 0xffffffff};
+  
   /**
    * Compress an integer array using Simple16
    * 
@@ -66,6 +84,33 @@
     for (numIdx = 0; numIdx < S16_NUMSIZE; numIdx++) 
     { 
       out[outOffset] = numIdx<<S16_BITSSIZE;
+      //num = (S16_NUM[numIdx] < n) ? S16_NUM[numIdx] : n;
+      
+      if(S16_NUM[numIdx] > n) continue;
+      num = S16_NUM[numIdx];
+      
+      for (j = 0, bits = 0; (j < num) && in[inOffset+j] < (1<<S16_BITS[numIdx][j]); ) 
+      { 
+        out[outOffset] |= (in[inOffset+j]<<bits); 
+        bits += S16_BITS[numIdx][j]; 
+        j++;
+      }
+      
+      if (j == num) 
+      { 
+        return num;
+      } 
+    } 
+
+    return -1;
+  }
+  
+  public static final int s16CompressBackup(int[] out, int outOffset, int[] in, int inOffset, int n, int blockSize, int oriBlockSize, int[] oriInputBlock)
+  {
+    int numIdx, j, num, bits;
+    for (numIdx = 0; numIdx < S16_NUMSIZE; numIdx++) 
+    { 
+      out[outOffset] = numIdx<<S16_BITSSIZE;
       num = (S16_NUM[numIdx] < n) ? S16_NUM[numIdx] : n; 
       
       for (j = 0, bits = 0; (j < num) && in[inOffset+j] < (1<<S16_BITS[numIdx][j]); ) 
@@ -107,8 +152,549 @@
      return num;
   }
   
+  public static final int s16DecompressWithIntBufferBackup(final int[] out, int outOffset, final int value, final int n)
+  {
+     int j=0, shift;
+     final int numIdx = value >>>S16_BITSSIZE;
+     final int num = S16_NUM[numIdx] < n ? S16_NUM[numIdx] : n;
+     int s16Bits;
+     for(shift=0; j<num; ++j)
+     {
+    	 s16Bits = S16_BITS[numIdx][j];
+    	 out[outOffset++]  = (value >>> shift) & (0xffffffff >>> (32 - s16Bits));
+    	 shift += s16Bits;
+     }
+     return num;
+  }
+  
+  public static final int s16DecompressWithIntBuffer(final int[] out, int outOffset, final int value, final int n)
+  {
+     int j=0, shift;
+     final int numIdx = value >>>S16_BITSSIZE;
+    
+     final int num = S16_NUM[numIdx];
+     int s16Bits;
+     for(shift=0; j<num; ++j)
+     {
+    	 s16Bits = S16_BITS[numIdx][j];
+    	 out[outOffset++]  = (value >>> shift) & (0xffffffff >>> (32 - s16Bits));
+    	 shift += s16Bits;
+     }
+     return num;
+  }
+  
+  
+  public static final int s16DecompressWithIntBufferWithHardCodes(final int[] out, int outOffset, final int value, final int n)
+  {
+     final int numIdx = value >>>S16_BITSSIZE;
+     return s16DecompressOneNumberWithHardCodes(out, outOffset, value, numIdx);
+  }
+  
+  public static final int s16DecompressWithIntBufferIntegrated(final int[] out, int outOffset, final int value, final int n, int[] expPos, int oribits)
+  {
+     int j=0, shift=0;
+     final int numIdx = value >>>S16_BITSSIZE;
+     
+     final int num = S16_NUM[numIdx];
+     int s16Bits ;
+     for(; j<num; ++j)
+     {
+       s16Bits = S16_BITS[numIdx][j];
+       out[expPos[outOffset+j]] |= (((value >>> shift)  & (0xffffffff >>> (32 - s16Bits)))<<oribits);
+       shift += s16Bits;
+     }
+     return num;
+  }
+  
+  public static final int s16DecompressWithIntBufferIntegrated2(final int[] out, int outOffset, final int value, final int n, int[] expPos, int oribits)
+  {
+     final int numIdx = value >>>S16_BITSSIZE;
+     return s16DecompressOneNumberWithHardCodesIntegrated(out, outOffset, value, numIdx, oribits, expPos);
+  }
+  
+  
+  
+  public static final int s16DecompressWithIntBufferIntegratedBackup(final int[] out, int outOffset, final int value, final int n, int[] expPos, int oribits)
+  {
+     int j=0, shift=0;
+     final int numIdx = value >>>S16_BITSSIZE;
+     final int num = S16_NUM[numIdx] < n ? S16_NUM[numIdx] : n;
+     int s16Bits ;
+     for(; j<num; ++j, ++outOffset)
+     {
+       s16Bits = S16_BITS[numIdx][j];
+       out[expPos[outOffset]] |= (((value >>> shift)  & (0xffffffff >>> (32 - s16Bits)))<<oribits);
+       shift += s16Bits;
+     }
+     return num;
+  }
+  
+  public static int s16DecompressOneNumberWithHardCodes(int[] out, int outOffset, int value, int numIdx){
+	  switch(numIdx){
+	    case 0:
+	    {
+	      out[outOffset] = value  & 0x00000001;
+	      out[outOffset+1] = (value >>> 1) & 0x00000001;
+	      out[outOffset+2] = (value >>> 2) & 0x00000001;
+	      out[outOffset+3] = (value >>> 3) & 0x00000001;
+	      out[outOffset+4] = (value >>> 4) & 0x00000001;
+	      out[outOffset+5] = (value >>> 5) & 0x00000001;
+	      out[outOffset+6] = (value >>> 6) & 0x00000001;
+	      out[outOffset+7] = (value >>> 7) & 0x00000001;
+	      out[outOffset+8] = (value >>> 8) & 0x00000001;
+	      out[outOffset+9] = (value >>> 9) & 0x00000001;
+	      out[outOffset+10] = (value >>> 10) & 0x00000001;
+	      out[outOffset+11] = (value >>> 11) & 0x00000001;
+	      out[outOffset+12] = (value >>> 12) & 0x00000001;
+	      out[outOffset+13] = (value >>> 13) & 0x00000001;
+	      out[outOffset+14] = (value >>> 14) & 0x00000001;
+	      out[outOffset+15] = (value >>> 15) & 0x00000001;
+	      out[outOffset+16] = (value >>> 16) & 0x00000001;
+	      out[outOffset+17] = (value >>> 17) & 0x00000001;
+	      out[outOffset+18] = (value >>> 18) & 0x00000001;
+	      out[outOffset+19] = (value >>> 19) & 0x00000001;
+	      out[outOffset+20] = (value >>> 20) & 0x00000001;
+	      out[outOffset+21] = (value >>> 21) & 0x00000001;
+	      out[outOffset+22] = (value >>> 22) & 0x00000001;
+	      out[outOffset+23] = (value >>> 23) & 0x00000001;
+	      out[outOffset+24] = (value >>> 24) & 0x00000001;
+	      out[outOffset+25] = (value >>> 25) & 0x00000001;
+	      out[outOffset+26] = (value >>> 26) & 0x00000001;
+	      out[outOffset+27] = (value >>> 27) & 0x00000001;
+	      return 28;
+	    }
+	    case 1:
+	    {
+	      out[outOffset] = value  & 0x00000003;
+	      out[outOffset+1] = (value >>> 2) & 0x00000003;
+	      out[outOffset+2] = (value >>> 4) & 0x00000003;
+	      out[outOffset+3] = (value >>> 6) & 0x00000003;
+	      out[outOffset+4] = (value >>> 8) & 0x00000003;
+	      out[outOffset+5] = (value >>> 10) & 0x00000003;
+	      out[outOffset+6] = (value >>> 12) & 0x00000003;
+	      out[outOffset+7] = (value >>> 14) & 0x00000001;
+	      out[outOffset+8] = (value >>> 15) & 0x00000001;
+	      out[outOffset+9] = (value >>> 16) & 0x00000001;
+	      out[outOffset+10] = (value >>> 17) & 0x00000001;
+	      out[outOffset+11] = (value >>> 18) & 0x00000001;
+	      out[outOffset+12] = (value >>> 19) & 0x00000001;
+	      out[outOffset+13] = (value >>> 20) & 0x00000001;
+	      out[outOffset+14] = (value >>> 21) & 0x00000001;
+	      out[outOffset+15] = (value >>> 22) & 0x00000001;
+	      out[outOffset+16] = (value >>> 23) & 0x00000001;
+	      out[outOffset+17] = (value >>> 24) & 0x00000001;
+	      out[outOffset+18] = (value >>> 25) & 0x00000001;
+	      out[outOffset+19] = (value >>> 26) & 0x00000001;
+	      out[outOffset+20] = (value >>> 27) & 0x00000001;
+	      return 21;
+	    }
+	    case 2:
+	    {
+	      out[outOffset] = value  & 0x00000001;
+	      out[outOffset+1] = (value >>> 1) & 0x00000001;
+	      out[outOffset+2] = (value >>> 2) & 0x00000001;
+	      out[outOffset+3] = (value >>> 3) & 0x00000001;
+	      out[outOffset+4] = (value >>> 4) & 0x00000001;
+	      out[outOffset+5] = (value >>> 5) & 0x00000001;
+	      out[outOffset+6] = (value >>> 6) & 0x00000001;
+	      out[outOffset+7] = (value >>> 7) & 0x00000003;
+	      out[outOffset+8] = (value >>> 9) & 0x00000003;
+	      out[outOffset+9] = (value >>> 11) & 0x00000003;
+	      out[outOffset+10] = (value >>> 13) & 0x00000003;
+	      out[outOffset+11] = (value >>> 15) & 0x00000003;
+	      out[outOffset+12] = (value >>> 17) & 0x00000003;
+	      out[outOffset+13] = (value >>> 19) & 0x00000003;
+	      out[outOffset+14] = (value >>> 21) & 0x00000001;
+	      out[outOffset+15] = (value >>> 22) & 0x00000001;
+	      out[outOffset+16] = (value >>> 23) & 0x00000001;
+	      out[outOffset+17] = (value >>> 24) & 0x00000001;
+	      out[outOffset+18] = (value >>> 25) & 0x00000001;
+	      out[outOffset+19] = (value >>> 26) & 0x00000001;
+	      out[outOffset+20] = (value >>> 27) & 0x00000001;
+	      return 21;
+	    }
+	    case 3:
+	    {
+	      out[outOffset] = value  & 0x00000001;
+	      out[outOffset+1] = (value >>> 1) & 0x00000001;
+	      out[outOffset+2] = (value >>> 2) & 0x00000001;
+	      out[outOffset+3] = (value >>> 3) & 0x00000001;
+	      out[outOffset+4] = (value >>> 4) & 0x00000001;
+	      out[outOffset+5] = (value >>> 5) & 0x00000001;
+	      out[outOffset+6] = (value >>> 6) & 0x00000001;
+	      out[outOffset+7] = (value >>> 7) & 0x00000001;
+	      out[outOffset+8] = (value >>> 8) & 0x00000001;
+	      out[outOffset+9] = (value >>> 9) & 0x00000001;
+	      out[outOffset+10] = (value >>> 10) & 0x00000001;
+	      out[outOffset+11] = (value >>> 11) & 0x00000001;
+	      out[outOffset+12] = (value >>> 12) & 0x00000001;
+	      out[outOffset+13] = (value >>> 13) & 0x00000001;
+	      out[outOffset+14] = (value >>> 14) & 0x00000003;
+	      out[outOffset+15] = (value >>> 16) & 0x00000003;
+	      out[outOffset+16] = (value >>> 18) & 0x00000003;
+	      out[outOffset+17] = (value >>> 20) & 0x00000003;
+	      out[outOffset+18] = (value >>> 22) & 0x00000003;
+	      out[outOffset+19] = (value >>> 24) & 0x00000003;
+	      out[outOffset+20] = (value >>> 26) & 0x00000003;
+	      return 21;
+	    }
+	    case 4:
+	    {
+	      out[outOffset] = value  & 0x00000003;
+	      out[outOffset+1] = (value >>> 2) & 0x00000003;
+	      out[outOffset+2] = (value >>> 4) & 0x00000003;
+	      out[outOffset+3] = (value >>> 6) & 0x00000003;
+	      out[outOffset+4] = (value >>> 8) & 0x00000003;
+	      out[outOffset+5] = (value >>> 10) & 0x00000003;
+	      out[outOffset+6] = (value >>> 12) & 0x00000003;
+	      out[outOffset+7] = (value >>> 14) & 0x00000003;
+	      out[outOffset+8] = (value >>> 16) & 0x00000003;
+	      out[outOffset+9] = (value >>> 18) & 0x00000003;
+	      out[outOffset+10] = (value >>> 20) & 0x00000003;
+	      out[outOffset+11] = (value >>> 22) & 0x00000003;
+	      out[outOffset+12] = (value >>> 24) & 0x00000003;
+	      out[outOffset+13] = (value >>> 26) & 0x00000003;
+	      return 14;
+	    }
+	    case 5:
+	    {
+	      out[outOffset] = value  & 0x0000000f;
+	      out[outOffset+1] = (value >>> 4) & 0x00000007;
+	      out[outOffset+2] = (value >>> 7) & 0x00000007;
+	      out[outOffset+3] = (value >>> 10) & 0x00000007;
+	      out[outOffset+4] = (value >>> 13) & 0x00000007;
+	      out[outOffset+5] = (value >>> 16) & 0x00000007;
+	      out[outOffset+6] = (value >>> 19) & 0x00000007;
+	      out[outOffset+7] = (value >>> 22) & 0x00000007;
+	      out[outOffset+8] = (value >>> 25) & 0x00000007;
+	      return 9;
+	    }
+	    case 6:
+	    {
+	      out[outOffset] = value  & 0x00000007;
+	      out[outOffset+1] = (value >>> 3) & 0x0000000f;
+	      out[outOffset+2] = (value >>> 7) & 0x0000000f;
+	      out[outOffset+3] = (value >>> 11) & 0x0000000f;
+	      out[outOffset+4] = (value >>> 15) & 0x0000000f;
+	      out[outOffset+5] = (value >>> 19) & 0x00000007;
+	      out[outOffset+6] = (value >>> 22) & 0x00000007;
+	      out[outOffset+7] = (value >>> 25) & 0x00000007;
+	      return 8;
+	    }
+	    case 7:
+	    {
+	      out[outOffset] = value  & 0x0000000f;
+	      out[outOffset+1] = (value >>> 4) & 0x0000000f;
+	      out[outOffset+2] = (value >>> 8) & 0x0000000f;
+	      out[outOffset+3] = (value >>> 12) & 0x0000000f;
+	      out[outOffset+4] = (value >>> 16) & 0x0000000f;
+	      out[outOffset+5] = (value >>> 20) & 0x0000000f;
+	      out[outOffset+6] = (value >>> 24) & 0x0000000f;
+	      return 7;
+	    }
+	    case 8:
+	    {
+	      out[outOffset] = value  & 0x0000001f;
+	      out[outOffset+1] = (value >>> 5) & 0x0000001f;
+	      out[outOffset+2] = (value >>> 10) & 0x0000001f;
+	      out[outOffset+3] = (value >>> 15) & 0x0000001f;
+	      out[outOffset+4] = (value >>> 20) & 0x0000000f;
+	      out[outOffset+5] = (value >>> 24) & 0x0000000f;
+	      return 6;
+	    }
+	    case 9:
+	    {
+	      out[outOffset] = value  & 0x0000000f;
+	      out[outOffset+1] = (value >>> 4) & 0x0000000f;
+	      out[outOffset+2] = (value >>> 8) & 0x0000001f;
+	      out[outOffset+3] = (value >>> 13) & 0x0000001f;
+	      out[outOffset+4] = (value >>> 18) & 0x0000001f;
+	      out[outOffset+5] = (value >>> 23) & 0x0000001f;
+	      return 6;
+	    }
+	    case 10:
+	    {
+	      out[outOffset] = value  & 0x0000003f;
+	      out[outOffset+1] = (value >>> 6) & 0x0000003f;
+	      out[outOffset+2] = (value >>> 12) & 0x0000003f;
+	      out[outOffset+3] = (value >>> 18) & 0x0000001f;
+	      out[outOffset+4] = (value >>> 23) & 0x0000001f;
+	      return 5;
+	    }
+	    case 11:
+	    {
+	      out[outOffset] = value  & 0x0000001f;
+	      out[outOffset+1] = (value >>> 5) & 0x0000001f;
+	      out[outOffset+2] = (value >>> 10) & 0x0000003f;
+	      out[outOffset+3] = (value >>> 16) & 0x0000003f;
+	      out[outOffset+4] = (value >>> 22) & 0x0000003f;
+	      return 5;
+	    }
+	    case 12:
+	    {
+	      out[outOffset] = value  & 0x0000007f;
+	      out[outOffset+1] = (value >>> 7) & 0x0000007f;
+	      out[outOffset+2] = (value >>> 14) & 0x0000007f;
+	      out[outOffset+3] = (value >>> 21) & 0x0000007f;
+	      return 4;
+	    }
+	    case 13:
+	    {
+	      out[outOffset] = value  & 0x000003ff;
+	      out[outOffset+1] = (value >>> 10) & 0x000001ff;
+	      out[outOffset+2] = (value >>> 19) & 0x000001ff;
+	      return 3;
+	    }
+	    case 14:
+	    {
+	      out[outOffset] = value  & 0x00003fff;
+	      out[outOffset+1] = (value >>> 14) & 0x00003fff;
+	      return 2;
+	    }
+	    case 15:
+	    {
+	      out[outOffset] = value  & 0x0fffffff;
+	      return 1;
+	    }
+	    default:
+	      return -1;
+	  }
+	}
 
-    /**
+  
+  public static int s16DecompressOneNumberWithHardCodesIntegrated(int[] out, int outOffset, int value, int numIdx, int oribits, int[] expPos){
+	  switch(numIdx){
+	    case 0:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 1)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+2]] |= (((value >>> 2)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+3]] |= (((value >>> 3)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+4]] |= (((value >>> 4)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+5]] |= (((value >>> 5)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+6]] |= (((value >>> 6)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+7]] |= (((value >>> 7)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+8]] |= (((value >>> 8)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+9]] |= (((value >>> 9)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+10]] |= (((value >>> 10)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+11]] |= (((value >>> 11)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+12]] |= (((value >>> 12)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+13]] |= (((value >>> 13)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+14]] |= (((value >>> 14)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+15]] |= (((value >>> 15)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+16]] |= (((value >>> 16)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+17]] |= (((value >>> 17)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+18]] |= (((value >>> 18)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+19]] |= (((value >>> 19)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+20]] |= (((value >>> 20)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+21]] |= (((value >>> 21)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+22]] |= (((value >>> 22)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+23]] |= (((value >>> 23)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+24]] |= (((value >>> 24)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+25]] |= (((value >>> 25)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+26]] |= (((value >>> 26)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+27]] |= (((value >>> 27)  & 0x00000001)<<oribits);
+	      return 28;
+	    }
+	    case 1:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 2)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+2]] |= (((value >>> 4)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+3]] |= (((value >>> 6)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+4]] |= (((value >>> 8)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+5]] |= (((value >>> 10)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+6]] |= (((value >>> 12)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+7]] |= (((value >>> 14)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+8]] |= (((value >>> 15)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+9]] |= (((value >>> 16)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+10]] |= (((value >>> 17)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+11]] |= (((value >>> 18)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+12]] |= (((value >>> 19)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+13]] |= (((value >>> 20)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+14]] |= (((value >>> 21)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+15]] |= (((value >>> 22)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+16]] |= (((value >>> 23)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+17]] |= (((value >>> 24)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+18]] |= (((value >>> 25)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+19]] |= (((value >>> 26)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+20]] |= (((value >>> 27)  & 0x00000001)<<oribits);
+	      return 21;
+	    }
+	    case 2:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 1)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+2]] |= (((value >>> 2)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+3]] |= (((value >>> 3)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+4]] |= (((value >>> 4)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+5]] |= (((value >>> 5)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+6]] |= (((value >>> 6)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+7]] |= (((value >>> 7)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+8]] |= (((value >>> 9)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+9]] |= (((value >>> 11)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+10]] |= (((value >>> 13)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+11]] |= (((value >>> 15)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+12]] |= (((value >>> 17)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+13]] |= (((value >>> 19)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+14]] |= (((value >>> 21)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+15]] |= (((value >>> 22)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+16]] |= (((value >>> 23)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+17]] |= (((value >>> 24)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+18]] |= (((value >>> 25)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+19]] |= (((value >>> 26)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+20]] |= (((value >>> 27)  & 0x00000001)<<oribits);
+	      return 21;
+	    }
+	    case 3:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 1)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+2]] |= (((value >>> 2)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+3]] |= (((value >>> 3)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+4]] |= (((value >>> 4)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+5]] |= (((value >>> 5)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+6]] |= (((value >>> 6)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+7]] |= (((value >>> 7)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+8]] |= (((value >>> 8)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+9]] |= (((value >>> 9)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+10]] |= (((value >>> 10)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+11]] |= (((value >>> 11)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+12]] |= (((value >>> 12)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+13]] |= (((value >>> 13)  & 0x00000001)<<oribits);
+	      out[expPos[outOffset+14]] |= (((value >>> 14)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+15]] |= (((value >>> 16)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+16]] |= (((value >>> 18)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+17]] |= (((value >>> 20)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+18]] |= (((value >>> 22)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+19]] |= (((value >>> 24)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+20]] |= (((value >>> 26)  & 0x00000003)<<oribits);
+	      return 21;
+	    }
+	    case 4:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 2)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+2]] |= (((value >>> 4)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+3]] |= (((value >>> 6)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+4]] |= (((value >>> 8)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+5]] |= (((value >>> 10)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+6]] |= (((value >>> 12)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+7]] |= (((value >>> 14)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+8]] |= (((value >>> 16)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+9]] |= (((value >>> 18)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+10]] |= (((value >>> 20)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+11]] |= (((value >>> 22)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+12]] |= (((value >>> 24)  & 0x00000003)<<oribits);
+	      out[expPos[outOffset+13]] |= (((value >>> 26)  & 0x00000003)<<oribits);
+	      return 14;
+	    }
+	    case 5:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x0000000f)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 4)  & 0x00000007)<<oribits);
+	      out[expPos[outOffset+2]] |= (((value >>> 7)  & 0x00000007)<<oribits);
+	      out[expPos[outOffset+3]] |= (((value >>> 10)  & 0x00000007)<<oribits);
+	      out[expPos[outOffset+4]] |= (((value >>> 13)  & 0x00000007)<<oribits);
+	      out[expPos[outOffset+5]] |= (((value >>> 16)  & 0x00000007)<<oribits);
+	      out[expPos[outOffset+6]] |= (((value >>> 19)  & 0x00000007)<<oribits);
+	      out[expPos[outOffset+7]] |= (((value >>> 22)  & 0x00000007)<<oribits);
+	      out[expPos[outOffset+8]] |= (((value >>> 25)  & 0x00000007)<<oribits);
+	      return 9;
+	    }
+	    case 6:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x00000007)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 3)  & 0x0000000f)<<oribits);
+	      out[expPos[outOffset+2]] |= (((value >>> 7)  & 0x0000000f)<<oribits);
+	      out[expPos[outOffset+3]] |= (((value >>> 11)  & 0x0000000f)<<oribits);
+	      out[expPos[outOffset+4]] |= (((value >>> 15)  & 0x0000000f)<<oribits);
+	      out[expPos[outOffset+5]] |= (((value >>> 19)  & 0x00000007)<<oribits);
+	      out[expPos[outOffset+6]] |= (((value >>> 22)  & 0x00000007)<<oribits);
+	      out[expPos[outOffset+7]] |= (((value >>> 25)  & 0x00000007)<<oribits);
+	      return 8;
+	    }
+	    case 7:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x0000000f)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 4)  & 0x0000000f)<<oribits);
+	      out[expPos[outOffset+2]] |= (((value >>> 8)  & 0x0000000f)<<oribits);
+	      out[expPos[outOffset+3]] |= (((value >>> 12)  & 0x0000000f)<<oribits);
+	      out[expPos[outOffset+4]] |= (((value >>> 16)  & 0x0000000f)<<oribits);
+	      out[expPos[outOffset+5]] |= (((value >>> 20)  & 0x0000000f)<<oribits);
+	      out[expPos[outOffset+6]] |= (((value >>> 24)  & 0x0000000f)<<oribits);
+	      return 7;
+	    }
+	    case 8:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x0000001f)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 5)  & 0x0000001f)<<oribits);
+	      out[expPos[outOffset+2]] |= (((value >>> 10)  & 0x0000001f)<<oribits);
+	      out[expPos[outOffset+3]] |= (((value >>> 15)  & 0x0000001f)<<oribits);
+	      out[expPos[outOffset+4]] |= (((value >>> 20)  & 0x0000000f)<<oribits);
+	      out[expPos[outOffset+5]] |= (((value >>> 24)  & 0x0000000f)<<oribits);
+	      return 6;
+	    }
+	    case 9:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x0000000f)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 4)  & 0x0000000f)<<oribits);
+	      out[expPos[outOffset+2]] |= (((value >>> 8)  & 0x0000001f)<<oribits);
+	      out[expPos[outOffset+3]] |= (((value >>> 13)  & 0x0000001f)<<oribits);
+	      out[expPos[outOffset+4]] |= (((value >>> 18)  & 0x0000001f)<<oribits);
+	      out[expPos[outOffset+5]] |= (((value >>> 23)  & 0x0000001f)<<oribits);
+	      return 6;
+	    }
+	    case 10:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x0000003f)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 6)  & 0x0000003f)<<oribits);
+	      out[expPos[outOffset+2]] |= (((value >>> 12)  & 0x0000003f)<<oribits);
+	      out[expPos[outOffset+3]] |= (((value >>> 18)  & 0x0000001f)<<oribits);
+	      out[expPos[outOffset+4]] |= (((value >>> 23)  & 0x0000001f)<<oribits);
+	      return 5;
+	    }
+	    case 11:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x0000001f)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 5)  & 0x0000001f)<<oribits);
+	      out[expPos[outOffset+2]] |= (((value >>> 10)  & 0x0000003f)<<oribits);
+	      out[expPos[outOffset+3]] |= (((value >>> 16)  & 0x0000003f)<<oribits);
+	      out[expPos[outOffset+4]] |= (((value >>> 22)  & 0x0000003f)<<oribits);
+	      return 5;
+	    }
+	    case 12:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x0000007f)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 7)  & 0x0000007f)<<oribits);
+	      out[expPos[outOffset+2]] |= (((value >>> 14)  & 0x0000007f)<<oribits);
+	      out[expPos[outOffset+3]] |= (((value >>> 21)  & 0x0000007f)<<oribits);
+	      return 4;
+	    }
+	    case 13:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x000003ff)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 10)  & 0x000001ff)<<oribits);
+	      out[expPos[outOffset+2]] |= (((value >>> 19)  & 0x000001ff)<<oribits);
+	      return 3;
+	    }
+	    case 14:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x00003fff)<<oribits);
+	      out[expPos[outOffset+1]] |= (((value >>> 14)  & 0x00003fff)<<oribits);
+	      return 2;
+	    }
+	    case 15:
+	    {
+	      out[expPos[outOffset]] |= ((value  & 0x0fffffff)<<oribits);
+	      return 1;
+	    }
+	    default:
+	      return -1;
+	  }
+	}
+
+  /**
      * Read a certain number of bits of a integer on the input array
      * @param in the input array
      * @param inIntOffset the start offset in ints in the input array
@@ -120,4 +706,12 @@
      final int val = (in[inIntOffset] >>> inWithIntOffset);
      return val & (0xffffffff >>> (32 - bits));
    }
+   
+   static private int readBitsForS16WithValue(final int value, final int inWithIntOffset, final int bits) {
+	     final int val = (value >>> inWithIntOffset);
+	     return val & (0xffffffff >>> (32 - bits));
+	   }
+
   }
+
+
Index: lucene/src/java/org/apache/lucene/util/pfor2/PForDelta.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/pfor2/PForDelta.java	(revision 1071187)
+++ lucene/src/java/org/apache/lucene/util/pfor2/PForDelta.java	(working copy)
@@ -1,350 +0,0 @@
-package org.apache.lucene.util.pfor2;
-
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Arrays;
-
-/**
- * Implementation of the optimized PForDelta algorithm for sorted integer arrays. The basic ideas are based on
- * 
- * 1. Original algorithm from
- * http://homepages.cwi.nl/~heman/downloads/msthesis.pdf 
- * 
- * 2. Optimization and
- * variation from http://www2008.org/papers/pdf/p387-zhangA.pdf 
- * 
- * 3. Further optimization
- * http://www2009.org/proceedings/pdf/p401.pdf
- *  
- *  As a part of the PForDelta implementation, Simple16 is used to compress exceptions. The original Simple16 algorithm can also be found in the above literatures.
- * @author hao yan, hyan2008@gmail.com
- */
-// nocommit -- must merge our 2 pfor impls before landing on trunk
-// nocommit -- need serious random unit test for these int encoders
-public class PForDelta{
-  
-  //All possible values of b in the PForDelta algorithm
-  private static final int[] POSSIBLE_B = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,16,20,28}; 
-  // Max number of bits to store an uncompressed value
-  private static final int MAX_BITS = 32;
-  // Header records the value of b and the number of exceptions in the block
-  private static final int HEADER_NUM = 1;
-  // Header size in bits
-  private static final int HEADER_SIZE = MAX_BITS * HEADER_NUM;
-
-  private static final int[] MASK = {0x00000000,
-    0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f,
-    0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff,
-    0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff, 0x0001ffff, 0x0003ffff,
-    0x0007ffff, 0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
-    0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff, 0x1fffffff, 0x3fffffff,
-    0x7fffffff, 0xffffffff};
-  
-  /**
-   * Compress one block of blockSize integers using PForDelta with the optimal parameter b
-   * @param inBlock the block to be compressed
-   * @param blockSize the block size
-   * @return the compressed block
-   */
-  public static int[] compressOneBlock(final int[] inBlock, int blockSize)
-  { 
-    // find the best b that can lead to the smallest overall compressed size
-    int currentB = POSSIBLE_B[0];   
-    int tmpB = currentB;
-    int optSize = estimateCompressedSize(inBlock, tmpB, blockSize);
-    for (int i = 1; i < POSSIBLE_B.length; ++i)
-    {
-      tmpB = POSSIBLE_B[i];
-      int curSize = estimateCompressedSize(inBlock, tmpB, blockSize);
-      if(curSize < optSize)
-      {
-        currentB = tmpB;
-        optSize = curSize;
-      }
-    }
-    
-    // compress the block using the above best b 
-    int[] outBlock = compressOneBlockCore(inBlock, currentB, blockSize);
-
-    return outBlock;  
-  }
-
-  /**
-   * Decompress one block using PForDelta
-   * @param inBlock the block to be decompressed
-   * @param blockSize the number of elements in the decompressed block
-   * @return the decompressed block
-   */
-  public static int[] decompressOneBlock(int[] inBlock, int blockSize)
-  {
-    int[] expPos = new int[blockSize];
-    int[] expHighBits = new int[blockSize];
-    int[] outBlock = new int[blockSize];
-    assert inBlock != null;
-    /*
-    if(inBlock == null)
-    {
-      System.out.println("error: compBlock is null");
-      return null;
-    }
-    */
-
-    int expNum = inBlock[0] & 0x3ff; 
-    int bits = (inBlock[0]>>>10) & (0x1f);    
-
-    // decompress the b-bit slots
-    int offset = HEADER_SIZE;
-    int compressedBits = 0;
-    if(bits == 0)
-    {
-      Arrays.fill(outBlock,0);
-    }
-    else
-    {
-      compressedBits = decompressBBitSlots(outBlock, inBlock, blockSize, bits);
-    }
-    offset += compressedBits;
-
-    // decompress exceptions
-    if(expNum>0)
-    {
-      compressedBits = decompressBlockByS16(expPos, inBlock, offset, expNum);
-      offset += compressedBits;
-      compressedBits = decompressBlockByS16(expHighBits, inBlock, offset, expNum);
-      offset += compressedBits;
-
-      for (int i = 0; i < expNum; i++) 
-      { 
-        int curExpPos = expPos[i]  ;
-        int curHighBits = expHighBits[i];
-        outBlock[curExpPos] = (outBlock[curExpPos] & MASK[bits]) | ((curHighBits & MASK[32-bits] ) << bits);
-      }
-    }
-    return outBlock;
-  }
-
-  /**
-   * Estimate the compressed size in ints of a block
-   * @param inputBlock the block to be compressed
-   * @param bits the value of the parameter b
-   * @param blockSize the block size 
-   * @return the compressed size in ints
-   * @throws IllegalArgumentException
-   */
-  private static int estimateCompressedSize(int[] inputBlock, int bits, int blockSize) throws IllegalArgumentException {
-    int maxNoExp = (1<<bits)-1;
-    // Size of the header and the bits-bit slots
-    int outputOffset = HEADER_SIZE + bits * blockSize; 
-    int expNum = 0;      
-
-    for (int i = 0; i<blockSize; ++i)
-    {      
-      if (inputBlock[i] > maxNoExp) 
-      {
-        expNum++;
-      }
-    }    
-    outputOffset += (expNum<<5);
-
-    return outputOffset;
-  }
-  
-  /**
-   * The core implementation of compressing a block with blockSize integers using PForDelta with the given parameter b 
-   * @param inputBlock the block to be compressed
-   * @param bits the the value of the parameter b
-   * @param blockSize the block size
-   * @return the compressed block
-   * @throws IllegalArgumentException
-   */
-  private static int[] compressOneBlockCore(int[] inputBlock, int bits, int blockSize) throws IllegalArgumentException {
-    int[] expPos = new int[blockSize];
-    int[] expHighBits = new int[blockSize];
-
-    int maxCompBitSize =  HEADER_SIZE + blockSize * (MAX_BITS  + MAX_BITS + MAX_BITS) + 32;
-    int[] tmpCompressedBlock = new int[(maxCompBitSize>>>5)];
-
-    int outputOffset = HEADER_SIZE;
-    int expUpperBound = 1<<bits;
-    int expNum = 0;      
-
-    // compress the b-bit slots
-    for (int i = 0; i<blockSize; ++i)
-    {
-      assert inputBlock[i] >= 0: "input value is " + inputBlock[i];
-      /*
-      if(inputBlock[i] < 0)
-      {
-        System.out.println("haha<0: [" + i +"]" + inputBlock[i]);
-      }
-      */
-      if (inputBlock[i] < expUpperBound) 
-      {
-        writeBits(tmpCompressedBlock, inputBlock[i], outputOffset, bits);
-      } 
-      else // exp
-      {
-        // store the lower bits-bits of the exception
-        writeBits(tmpCompressedBlock, inputBlock[i] & MASK[bits], outputOffset, bits); 
-        // write the position of exception
-        expPos[expNum] = i; 
-        // write the higher 32-bits bits of the exception
-        expHighBits[expNum] = (inputBlock[i] >>> bits) & MASK[32-bits];  
-        expNum++;
-      }
-      outputOffset += bits;
-    }    
-
-    // the first int in the compressed block stores the value of b and the number of exceptions
-    tmpCompressedBlock[0] = ((bits & MASK[10]) << 10) | (expNum & 0x3ff);
-
-    // compress exceptions
-    if(expNum>0)
-    {
-      int compressedBitSize = compressBlockByS16(tmpCompressedBlock, outputOffset, expPos, expNum, blockSize, inputBlock);
-      outputOffset += compressedBitSize;
-      compressedBitSize = compressBlockByS16(tmpCompressedBlock, outputOffset, expHighBits, expNum, blockSize, inputBlock);
-      outputOffset += compressedBitSize;
-    }
-
-    // discard the redundant parts in the tmpCompressedBlock
-    int compressedSizeInInts = (outputOffset+31)>>>5;
-    int[] compBlock;
-    compBlock = new int[compressedSizeInInts];
-    System.arraycopy(tmpCompressedBlock,0, compBlock, 0, compressedSizeInInts);
-
-    return compBlock;
-  }
-  
-  /**
-   * Decompress b-bit slots
-   * @param outDecompSlots decompressed block which is the output
-   * @param inCompBlock the compressed block which is the input
-   * @param blockSize the block size
-   * @param bits the value of the parameter b
-   * @return the compressed size in bits of the data that has been decompressed
-   */
-  private static int decompressBBitSlots(int[] outDecompSlots, int[] inCompBlock, int blockSize, int bits)
-  {
-    int compressedBitSize = 0;
-    int offset = HEADER_SIZE;
-    for(int i =0; i<blockSize; i++)
-    {
-      outDecompSlots[i] = readBits(inCompBlock, offset, bits);
-      offset += bits;
-    }
-    compressedBitSize = bits * blockSize;
-
-    return compressedBitSize;    
-  } 
-
-  /**
-   * Compress a block of blockSize integers using Simple16 algorithm 
-   * @param outCompBlock the compressed block which is the output
-   * @param outStartOffsetInBits the start offset in bits of the compressed block 
-   * @param inBlock the block to be compressed
-   * @param blockSize the block size
-   * @return the compressed size in bits
-   */
-  private static int compressBlockByS16(int[] outCompBlock, int outStartOffsetInBits, int[] inBlock, int blockSize, int oriBlockSize, int[] oriInputBlock)
-  {
-    int outOffset  = (outStartOffsetInBits+31)>>>5; 
-    int num, inOffset=0, numLeft;
-    for(numLeft=blockSize; numLeft>0; numLeft -= num)
-    {
-      num = Simple16.s16Compress(outCompBlock, outOffset, inBlock, inOffset, numLeft, blockSize, oriBlockSize, oriInputBlock);
-      assert num >= 0;
-      /*
-      if(num<0)
-      {
-        System.out.println("oops: s16 get -1 ");
-      }
-      */
-      outOffset++;
-      inOffset += num;
-    }
-    int compressedBitSize = (outOffset<<5)-outStartOffsetInBits;
-    return compressedBitSize;    
-  }
-
-  /**
-   * Decompress a block of blockSize integers using Simple16 algorithm
-   * @param outDecompBlock the decompressed block which is the output
-   * @param inCompBlock the compressed block which is the input
-   * @param blockSize the block size 
-   * @param inStartOffsetInBits  the start offset in bits of the compressed block
-   * @return the compressed size in bits of the data that has been decompressed
-   */
-  private static int decompressBlockByS16(int[] outDecompBlock, int[] inCompBlock, int inStartOffsetInBits, int blockSize)
-  {    
-    int inOffset  = (inStartOffsetInBits+31)>>>5;
-    int num, outOffset=0, numLeft;
-    for(numLeft=blockSize; numLeft>0; numLeft -= num)
-    {
-      num = Simple16.s16Decompress(outDecompBlock, outOffset, inCompBlock, inOffset, numLeft);
-      outOffset += num;
-      inOffset++;
-    }
-    int compressedBitSize = (inOffset<<5)-inStartOffsetInBits;
-    return compressedBitSize;    
-  }
-
-
-  /**
-   * Write a certain number of bits of an integer into an integer array starting from the given start offset
-   * 
-   * @param out the output array 
-   * @param val the integer to be written
-   * @param outOffset the start offset in bits in the output array
-   * @param bits the number of bits to be written (bits>=0)
-   */
-  private static final void writeBits(int[] out, int val, int outOffset, int bits) {
-    if(bits == 0)
-      return;
-    final int index = outOffset >>> 5;
-    final int skip = outOffset & 0x1f;
-    val &= (0xffffffff >>> (32 - bits));   
-    out[index] |= (val << skip);
-    if (32 - skip < bits) {
-      out[index + 1] |= (val >>> (32 - skip));
-    }
-  }
-
-  /**
-   * Read a certain number of bits of an integer into an integer array starting from the given start offset
-   * 
-   * @param in the input array 
-   * @param val the integer to be read
-   * @param inOffset the start offset in bits in the input array
-   * @param bits the number of bits to be read, unlike writeBits(), readBits() does not deal with bits==0 and thus bits must > 0. When bits ==0, the calling functions will just skip the entire bits-bit slots without decoding them
-   * @return the bits bits of the input
-   */
-  private static final int readBits(int[] in, final int inOffset, final int bits) {
-    final int index = inOffset >>> 5;
-    final int skip = inOffset & 0x1f;
-    int val = in[index] >>> skip;
-    if (32 - skip < bits) {      
-      val |= (in[index + 1] << (32 - skip));
-    }
-    return val & (0xffffffff >>> (32 - bits));
-  }
-
-}
-
-
Index: lucene/src/java/org/apache/lucene/util/pfor2/Unpack128WithBuffer.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/pfor2/Unpack128WithBuffer.java	(revision 0)
+++ lucene/src/java/org/apache/lucene/util/pfor2/Unpack128WithBuffer.java	(revision 0)
@@ -0,0 +1,862 @@
+package org.apache.lucene.util.pfor2;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.nio.IntBuffer;
+
+
+public class Unpack128WithBuffer{
+ 
+  static public void unpack(int[] out, IntBuffer in, int bits) {
+    switch (bits) {
+      case 0:  unpack0(out, in); break;
+      case 1:  unpack1(out, in); break;
+      case 2:  unpack2(out, in); break;
+      case 3:  unpack3(out, in); break;
+      case 4:  unpack4(out, in); break;
+      case 5:  unpack5(out, in); break;
+      case 6:  unpack6(out, in); break;
+      case 7:  unpack7(out, in); break;
+      case 8:  unpack8(out, in); break;
+      case 9:  unpack9(out, in); break;
+      case 10:  unpack10(out, in); break;
+      case 11:  unpack11(out, in); break;
+      case 12:  unpack12(out, in); break;
+      case 13:  unpack13(out, in); break;
+      case 16:  unpack16(out, in); break;
+      case 20:  unpack20(out, in); break;
+      case 28:  unpack28(out, in); break;
+      default: break;
+    }
+  }
+ 
+  static private void unpack0(int[] out, IntBuffer in)
+  {
+  }
+ 
+  static private void unpack1(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 1;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 1) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 2) & mask;
+    out[3+outOffset] = (curInputValue0 >>> 3) & mask;
+    out[4+outOffset] = (curInputValue0 >>> 4) & mask;
+    out[5+outOffset] = (curInputValue0 >>> 5) & mask;
+    out[6+outOffset] = (curInputValue0 >>> 6) & mask;
+    out[7+outOffset] = (curInputValue0 >>> 7) & mask;
+    out[8+outOffset] = (curInputValue0 >>> 8) & mask;
+    out[9+outOffset] = (curInputValue0 >>> 9) & mask;
+    out[10+outOffset] = (curInputValue0 >>> 10) & mask;
+    out[11+outOffset] = (curInputValue0 >>> 11) & mask;
+    out[12+outOffset] = (curInputValue0 >>> 12) & mask;
+    out[13+outOffset] = (curInputValue0 >>> 13) & mask;
+    out[14+outOffset] = (curInputValue0 >>> 14) & mask;
+    out[15+outOffset] = (curInputValue0 >>> 15) & mask;
+    out[16+outOffset] = (curInputValue0 >>> 16) & mask;
+    out[17+outOffset] = (curInputValue0 >>> 17) & mask;
+    out[18+outOffset] = (curInputValue0 >>> 18) & mask;
+    out[19+outOffset] = (curInputValue0 >>> 19) & mask;
+    out[20+outOffset] = (curInputValue0 >>> 20) & mask;
+    out[21+outOffset] = (curInputValue0 >>> 21) & mask;
+    out[22+outOffset] = (curInputValue0 >>> 22) & mask;
+    out[23+outOffset] = (curInputValue0 >>> 23) & mask;
+    out[24+outOffset] = (curInputValue0 >>> 24) & mask;
+    out[25+outOffset] = (curInputValue0 >>> 25) & mask;
+    out[26+outOffset] = (curInputValue0 >>> 26) & mask;
+    out[27+outOffset] = (curInputValue0 >>> 27) & mask;
+    out[28+outOffset] = (curInputValue0 >>> 28) & mask;
+    out[29+outOffset] = (curInputValue0 >>> 29) & mask;
+    out[30+outOffset] = (curInputValue0 >>> 30) & mask;
+    out[31+outOffset] = curInputValue0 >>> 31;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack2(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 3;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 2) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 4) & mask;
+    out[3+outOffset] = (curInputValue0 >>> 6) & mask;
+    out[4+outOffset] = (curInputValue0 >>> 8) & mask;
+    out[5+outOffset] = (curInputValue0 >>> 10) & mask;
+    out[6+outOffset] = (curInputValue0 >>> 12) & mask;
+    out[7+outOffset] = (curInputValue0 >>> 14) & mask;
+    out[8+outOffset] = (curInputValue0 >>> 16) & mask;
+    out[9+outOffset] = (curInputValue0 >>> 18) & mask;
+    out[10+outOffset] = (curInputValue0 >>> 20) & mask;
+    out[11+outOffset] = (curInputValue0 >>> 22) & mask;
+    out[12+outOffset] = (curInputValue0 >>> 24) & mask;
+    out[13+outOffset] = (curInputValue0 >>> 26) & mask;
+    out[14+outOffset] = (curInputValue0 >>> 28) & mask;
+    out[15+outOffset] = curInputValue0 >>> 30;
+    out[16+outOffset] = curInputValue1 & mask;
+    out[17+outOffset] = (curInputValue1 >>> 2) & mask;
+    out[18+outOffset] = (curInputValue1 >>> 4) & mask;
+    out[19+outOffset] = (curInputValue1 >>> 6) & mask;
+    out[20+outOffset] = (curInputValue1 >>> 8) & mask;
+    out[21+outOffset] = (curInputValue1 >>> 10) & mask;
+    out[22+outOffset] = (curInputValue1 >>> 12) & mask;
+    out[23+outOffset] = (curInputValue1 >>> 14) & mask;
+    out[24+outOffset] = (curInputValue1 >>> 16) & mask;
+    out[25+outOffset] = (curInputValue1 >>> 18) & mask;
+    out[26+outOffset] = (curInputValue1 >>> 20) & mask;
+    out[27+outOffset] = (curInputValue1 >>> 22) & mask;
+    out[28+outOffset] = (curInputValue1 >>> 24) & mask;
+    out[29+outOffset] = (curInputValue1 >>> 26) & mask;
+    out[30+outOffset] = (curInputValue1 >>> 28) & mask;
+    out[31+outOffset] = curInputValue1 >>> 30;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack3(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 7;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    int curInputValue2 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 3) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 6) & mask;
+    out[3+outOffset] = (curInputValue0 >>> 9) & mask;
+    out[4+outOffset] = (curInputValue0 >>> 12) & mask;
+    out[5+outOffset] = (curInputValue0 >>> 15) & mask;
+    out[6+outOffset] = (curInputValue0 >>> 18) & mask;
+    out[7+outOffset] = (curInputValue0 >>> 21) & mask;
+    out[8+outOffset] = (curInputValue0 >>> 24) & mask;
+    out[9+outOffset] = (curInputValue0 >>> 27) & mask;
+    out[10+outOffset] = ((curInputValue0 >>> 30) | (curInputValue1 << 2)) & mask;
+    out[11+outOffset] = (curInputValue1 >>> 1) & mask;
+    out[12+outOffset] = (curInputValue1 >>> 4) & mask;
+    out[13+outOffset] = (curInputValue1 >>> 7) & mask;
+    out[14+outOffset] = (curInputValue1 >>> 10) & mask;
+    out[15+outOffset] = (curInputValue1 >>> 13) & mask;
+    out[16+outOffset] = (curInputValue1 >>> 16) & mask;
+    out[17+outOffset] = (curInputValue1 >>> 19) & mask;
+    out[18+outOffset] = (curInputValue1 >>> 22) & mask;
+    out[19+outOffset] = (curInputValue1 >>> 25) & mask;
+    out[20+outOffset] = (curInputValue1 >>> 28) & mask;
+    out[21+outOffset] = ((curInputValue1 >>> 31) | (curInputValue2 << 1)) & mask;
+    out[22+outOffset] = (curInputValue2 >>> 2) & mask;
+    out[23+outOffset] = (curInputValue2 >>> 5) & mask;
+    out[24+outOffset] = (curInputValue2 >>> 8) & mask;
+    out[25+outOffset] = (curInputValue2 >>> 11) & mask;
+    out[26+outOffset] = (curInputValue2 >>> 14) & mask;
+    out[27+outOffset] = (curInputValue2 >>> 17) & mask;
+    out[28+outOffset] = (curInputValue2 >>> 20) & mask;
+    out[29+outOffset] = (curInputValue2 >>> 23) & mask;
+    out[30+outOffset] = (curInputValue2 >>> 26) & mask;
+    out[31+outOffset] = curInputValue2 >>> 29;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack4(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 15;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    int curInputValue2 = in.get();
+    int curInputValue3 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 4) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 8) & mask;
+    out[3+outOffset] = (curInputValue0 >>> 12) & mask;
+    out[4+outOffset] = (curInputValue0 >>> 16) & mask;
+    out[5+outOffset] = (curInputValue0 >>> 20) & mask;
+    out[6+outOffset] = (curInputValue0 >>> 24) & mask;
+    out[7+outOffset] = curInputValue0 >>> 28;
+    out[8+outOffset] = curInputValue1 & mask;
+    out[9+outOffset] = (curInputValue1 >>> 4) & mask;
+    out[10+outOffset] = (curInputValue1 >>> 8) & mask;
+    out[11+outOffset] = (curInputValue1 >>> 12) & mask;
+    out[12+outOffset] = (curInputValue1 >>> 16) & mask;
+    out[13+outOffset] = (curInputValue1 >>> 20) & mask;
+    out[14+outOffset] = (curInputValue1 >>> 24) & mask;
+    out[15+outOffset] = curInputValue1 >>> 28;
+    out[16+outOffset] = curInputValue2 & mask;
+    out[17+outOffset] = (curInputValue2 >>> 4) & mask;
+    out[18+outOffset] = (curInputValue2 >>> 8) & mask;
+    out[19+outOffset] = (curInputValue2 >>> 12) & mask;
+    out[20+outOffset] = (curInputValue2 >>> 16) & mask;
+    out[21+outOffset] = (curInputValue2 >>> 20) & mask;
+    out[22+outOffset] = (curInputValue2 >>> 24) & mask;
+    out[23+outOffset] = curInputValue2 >>> 28;
+    out[24+outOffset] = curInputValue3 & mask;
+    out[25+outOffset] = (curInputValue3 >>> 4) & mask;
+    out[26+outOffset] = (curInputValue3 >>> 8) & mask;
+    out[27+outOffset] = (curInputValue3 >>> 12) & mask;
+    out[28+outOffset] = (curInputValue3 >>> 16) & mask;
+    out[29+outOffset] = (curInputValue3 >>> 20) & mask;
+    out[30+outOffset] = (curInputValue3 >>> 24) & mask;
+    out[31+outOffset] = curInputValue3 >>> 28;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack5(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 31;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    int curInputValue2 = in.get();
+    int curInputValue3 = in.get();
+    int curInputValue4 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 5) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 10) & mask;
+    out[3+outOffset] = (curInputValue0 >>> 15) & mask;
+    out[4+outOffset] = (curInputValue0 >>> 20) & mask;
+    out[5+outOffset] = (curInputValue0 >>> 25) & mask;
+    out[6+outOffset] = ((curInputValue0 >>> 30) | (curInputValue1 << 2)) & mask;
+    out[7+outOffset] = (curInputValue1 >>> 3) & mask;
+    out[8+outOffset] = (curInputValue1 >>> 8) & mask;
+    out[9+outOffset] = (curInputValue1 >>> 13) & mask;
+    out[10+outOffset] = (curInputValue1 >>> 18) & mask;
+    out[11+outOffset] = (curInputValue1 >>> 23) & mask;
+    out[12+outOffset] = ((curInputValue1 >>> 28) | (curInputValue2 << 4)) & mask;
+    out[13+outOffset] = (curInputValue2 >>> 1) & mask;
+    out[14+outOffset] = (curInputValue2 >>> 6) & mask;
+    out[15+outOffset] = (curInputValue2 >>> 11) & mask;
+    out[16+outOffset] = (curInputValue2 >>> 16) & mask;
+    out[17+outOffset] = (curInputValue2 >>> 21) & mask;
+    out[18+outOffset] = (curInputValue2 >>> 26) & mask;
+    out[19+outOffset] = ((curInputValue2 >>> 31) | (curInputValue3 << 1)) & mask;
+    out[20+outOffset] = (curInputValue3 >>> 4) & mask;
+    out[21+outOffset] = (curInputValue3 >>> 9) & mask;
+    out[22+outOffset] = (curInputValue3 >>> 14) & mask;
+    out[23+outOffset] = (curInputValue3 >>> 19) & mask;
+    out[24+outOffset] = (curInputValue3 >>> 24) & mask;
+    out[25+outOffset] = ((curInputValue3 >>> 29) | (curInputValue4 << 3)) & mask;
+    out[26+outOffset] = (curInputValue4 >>> 2) & mask;
+    out[27+outOffset] = (curInputValue4 >>> 7) & mask;
+    out[28+outOffset] = (curInputValue4 >>> 12) & mask;
+    out[29+outOffset] = (curInputValue4 >>> 17) & mask;
+    out[30+outOffset] = (curInputValue4 >>> 22) & mask;
+    out[31+outOffset] = curInputValue4 >>> 27;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack6(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 63;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    int curInputValue2 = in.get();
+    int curInputValue3 = in.get();
+    int curInputValue4 = in.get();
+    int curInputValue5 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 6) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 12) & mask;
+    out[3+outOffset] = (curInputValue0 >>> 18) & mask;
+    out[4+outOffset] = (curInputValue0 >>> 24) & mask;
+    out[5+outOffset] = ((curInputValue0 >>> 30) | (curInputValue1 << 2)) & mask;
+    out[6+outOffset] = (curInputValue1 >>> 4) & mask;
+    out[7+outOffset] = (curInputValue1 >>> 10) & mask;
+    out[8+outOffset] = (curInputValue1 >>> 16) & mask;
+    out[9+outOffset] = (curInputValue1 >>> 22) & mask;
+    out[10+outOffset] = ((curInputValue1 >>> 28) | (curInputValue2 << 4)) & mask;
+    out[11+outOffset] = (curInputValue2 >>> 2) & mask;
+    out[12+outOffset] = (curInputValue2 >>> 8) & mask;
+    out[13+outOffset] = (curInputValue2 >>> 14) & mask;
+    out[14+outOffset] = (curInputValue2 >>> 20) & mask;
+    out[15+outOffset] = curInputValue2 >>> 26;
+    out[16+outOffset] = curInputValue3 & mask;
+    out[17+outOffset] = (curInputValue3 >>> 6) & mask;
+    out[18+outOffset] = (curInputValue3 >>> 12) & mask;
+    out[19+outOffset] = (curInputValue3 >>> 18) & mask;
+    out[20+outOffset] = (curInputValue3 >>> 24) & mask;
+    out[21+outOffset] = ((curInputValue3 >>> 30) | (curInputValue4 << 2)) & mask;
+    out[22+outOffset] = (curInputValue4 >>> 4) & mask;
+    out[23+outOffset] = (curInputValue4 >>> 10) & mask;
+    out[24+outOffset] = (curInputValue4 >>> 16) & mask;
+    out[25+outOffset] = (curInputValue4 >>> 22) & mask;
+    out[26+outOffset] = ((curInputValue4 >>> 28) | (curInputValue5 << 4)) & mask;
+    out[27+outOffset] = (curInputValue5 >>> 2) & mask;
+    out[28+outOffset] = (curInputValue5 >>> 8) & mask;
+    out[29+outOffset] = (curInputValue5 >>> 14) & mask;
+    out[30+outOffset] = (curInputValue5 >>> 20) & mask;
+    out[31+outOffset] = curInputValue5 >>> 26;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack7(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 127;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    int curInputValue2 = in.get();
+    int curInputValue3 = in.get();
+    int curInputValue4 = in.get();
+    int curInputValue5 = in.get();
+    int curInputValue6 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 7) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 14) & mask;
+    out[3+outOffset] = (curInputValue0 >>> 21) & mask;
+    out[4+outOffset] = ((curInputValue0 >>> 28) | (curInputValue1 << 4)) & mask;
+    out[5+outOffset] = (curInputValue1 >>> 3) & mask;
+    out[6+outOffset] = (curInputValue1 >>> 10) & mask;
+    out[7+outOffset] = (curInputValue1 >>> 17) & mask;
+    out[8+outOffset] = (curInputValue1 >>> 24) & mask;
+    out[9+outOffset] = ((curInputValue1 >>> 31) | (curInputValue2 << 1)) & mask;
+    out[10+outOffset] = (curInputValue2 >>> 6) & mask;
+    out[11+outOffset] = (curInputValue2 >>> 13) & mask;
+    out[12+outOffset] = (curInputValue2 >>> 20) & mask;
+    out[13+outOffset] = ((curInputValue2 >>> 27) | (curInputValue3 << 5)) & mask;
+    out[14+outOffset] = (curInputValue3 >>> 2) & mask;
+    out[15+outOffset] = (curInputValue3 >>> 9) & mask;
+    out[16+outOffset] = (curInputValue3 >>> 16) & mask;
+    out[17+outOffset] = (curInputValue3 >>> 23) & mask;
+    out[18+outOffset] = ((curInputValue3 >>> 30) | (curInputValue4 << 2)) & mask;
+    out[19+outOffset] = (curInputValue4 >>> 5) & mask;
+    out[20+outOffset] = (curInputValue4 >>> 12) & mask;
+    out[21+outOffset] = (curInputValue4 >>> 19) & mask;
+    out[22+outOffset] = ((curInputValue4 >>> 26) | (curInputValue5 << 6)) & mask;
+    out[23+outOffset] = (curInputValue5 >>> 1) & mask;
+    out[24+outOffset] = (curInputValue5 >>> 8) & mask;
+    out[25+outOffset] = (curInputValue5 >>> 15) & mask;
+    out[26+outOffset] = (curInputValue5 >>> 22) & mask;
+    out[27+outOffset] = ((curInputValue5 >>> 29) | (curInputValue6 << 3)) & mask;
+    out[28+outOffset] = (curInputValue6 >>> 4) & mask;
+    out[29+outOffset] = (curInputValue6 >>> 11) & mask;
+    out[30+outOffset] = (curInputValue6 >>> 18) & mask;
+    out[31+outOffset] = curInputValue6 >>> 25;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack8(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 255;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    int curInputValue2 = in.get();
+    int curInputValue3 = in.get();
+    int curInputValue4 = in.get();
+    int curInputValue5 = in.get();
+    int curInputValue6 = in.get();
+    int curInputValue7 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 8) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 16) & mask;
+    out[3+outOffset] = curInputValue0 >>> 24;
+    out[4+outOffset] = curInputValue1 & mask;
+    out[5+outOffset] = (curInputValue1 >>> 8) & mask;
+    out[6+outOffset] = (curInputValue1 >>> 16) & mask;
+    out[7+outOffset] = curInputValue1 >>> 24;
+    out[8+outOffset] = curInputValue2 & mask;
+    out[9+outOffset] = (curInputValue2 >>> 8) & mask;
+    out[10+outOffset] = (curInputValue2 >>> 16) & mask;
+    out[11+outOffset] = curInputValue2 >>> 24;
+    out[12+outOffset] = curInputValue3 & mask;
+    out[13+outOffset] = (curInputValue3 >>> 8) & mask;
+    out[14+outOffset] = (curInputValue3 >>> 16) & mask;
+    out[15+outOffset] = curInputValue3 >>> 24;
+    out[16+outOffset] = curInputValue4 & mask;
+    out[17+outOffset] = (curInputValue4 >>> 8) & mask;
+    out[18+outOffset] = (curInputValue4 >>> 16) & mask;
+    out[19+outOffset] = curInputValue4 >>> 24;
+    out[20+outOffset] = curInputValue5 & mask;
+    out[21+outOffset] = (curInputValue5 >>> 8) & mask;
+    out[22+outOffset] = (curInputValue5 >>> 16) & mask;
+    out[23+outOffset] = curInputValue5 >>> 24;
+    out[24+outOffset] = curInputValue6 & mask;
+    out[25+outOffset] = (curInputValue6 >>> 8) & mask;
+    out[26+outOffset] = (curInputValue6 >>> 16) & mask;
+    out[27+outOffset] = curInputValue6 >>> 24;
+    out[28+outOffset] = curInputValue7 & mask;
+    out[29+outOffset] = (curInputValue7 >>> 8) & mask;
+    out[30+outOffset] = (curInputValue7 >>> 16) & mask;
+    out[31+outOffset] = curInputValue7 >>> 24;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack9(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 511;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    int curInputValue2 = in.get();
+    int curInputValue3 = in.get();
+    int curInputValue4 = in.get();
+    int curInputValue5 = in.get();
+    int curInputValue6 = in.get();
+    int curInputValue7 = in.get();
+    int curInputValue8 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 9) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 18) & mask;
+    out[3+outOffset] = ((curInputValue0 >>> 27) | (curInputValue1 << 5)) & mask;
+    out[4+outOffset] = (curInputValue1 >>> 4) & mask;
+    out[5+outOffset] = (curInputValue1 >>> 13) & mask;
+    out[6+outOffset] = (curInputValue1 >>> 22) & mask;
+    out[7+outOffset] = ((curInputValue1 >>> 31) | (curInputValue2 << 1)) & mask;
+    out[8+outOffset] = (curInputValue2 >>> 8) & mask;
+    out[9+outOffset] = (curInputValue2 >>> 17) & mask;
+    out[10+outOffset] = ((curInputValue2 >>> 26) | (curInputValue3 << 6)) & mask;
+    out[11+outOffset] = (curInputValue3 >>> 3) & mask;
+    out[12+outOffset] = (curInputValue3 >>> 12) & mask;
+    out[13+outOffset] = (curInputValue3 >>> 21) & mask;
+    out[14+outOffset] = ((curInputValue3 >>> 30) | (curInputValue4 << 2)) & mask;
+    out[15+outOffset] = (curInputValue4 >>> 7) & mask;
+    out[16+outOffset] = (curInputValue4 >>> 16) & mask;
+    out[17+outOffset] = ((curInputValue4 >>> 25) | (curInputValue5 << 7)) & mask;
+    out[18+outOffset] = (curInputValue5 >>> 2) & mask;
+    out[19+outOffset] = (curInputValue5 >>> 11) & mask;
+    out[20+outOffset] = (curInputValue5 >>> 20) & mask;
+    out[21+outOffset] = ((curInputValue5 >>> 29) | (curInputValue6 << 3)) & mask;
+    out[22+outOffset] = (curInputValue6 >>> 6) & mask;
+    out[23+outOffset] = (curInputValue6 >>> 15) & mask;
+    out[24+outOffset] = ((curInputValue6 >>> 24) | (curInputValue7 << 8)) & mask;
+    out[25+outOffset] = (curInputValue7 >>> 1) & mask;
+    out[26+outOffset] = (curInputValue7 >>> 10) & mask;
+    out[27+outOffset] = (curInputValue7 >>> 19) & mask;
+    out[28+outOffset] = ((curInputValue7 >>> 28) | (curInputValue8 << 4)) & mask;
+    out[29+outOffset] = (curInputValue8 >>> 5) & mask;
+    out[30+outOffset] = (curInputValue8 >>> 14) & mask;
+    out[31+outOffset] = curInputValue8 >>> 23;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack10(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 1023;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    int curInputValue2 = in.get();
+    int curInputValue3 = in.get();
+    int curInputValue4 = in.get();
+    int curInputValue5 = in.get();
+    int curInputValue6 = in.get();
+    int curInputValue7 = in.get();
+    int curInputValue8 = in.get();
+    int curInputValue9 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 10) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 20) & mask;
+    out[3+outOffset] = ((curInputValue0 >>> 30) | (curInputValue1 << 2)) & mask;
+    out[4+outOffset] = (curInputValue1 >>> 8) & mask;
+    out[5+outOffset] = (curInputValue1 >>> 18) & mask;
+    out[6+outOffset] = ((curInputValue1 >>> 28) | (curInputValue2 << 4)) & mask;
+    out[7+outOffset] = (curInputValue2 >>> 6) & mask;
+    out[8+outOffset] = (curInputValue2 >>> 16) & mask;
+    out[9+outOffset] = ((curInputValue2 >>> 26) | (curInputValue3 << 6)) & mask;
+    out[10+outOffset] = (curInputValue3 >>> 4) & mask;
+    out[11+outOffset] = (curInputValue3 >>> 14) & mask;
+    out[12+outOffset] = ((curInputValue3 >>> 24) | (curInputValue4 << 8)) & mask;
+    out[13+outOffset] = (curInputValue4 >>> 2) & mask;
+    out[14+outOffset] = (curInputValue4 >>> 12) & mask;
+    out[15+outOffset] = curInputValue4 >>> 22;
+    out[16+outOffset] = curInputValue5 & mask;
+    out[17+outOffset] = (curInputValue5 >>> 10) & mask;
+    out[18+outOffset] = (curInputValue5 >>> 20) & mask;
+    out[19+outOffset] = ((curInputValue5 >>> 30) | (curInputValue6 << 2)) & mask;
+    out[20+outOffset] = (curInputValue6 >>> 8) & mask;
+    out[21+outOffset] = (curInputValue6 >>> 18) & mask;
+    out[22+outOffset] = ((curInputValue6 >>> 28) | (curInputValue7 << 4)) & mask;
+    out[23+outOffset] = (curInputValue7 >>> 6) & mask;
+    out[24+outOffset] = (curInputValue7 >>> 16) & mask;
+    out[25+outOffset] = ((curInputValue7 >>> 26) | (curInputValue8 << 6)) & mask;
+    out[26+outOffset] = (curInputValue8 >>> 4) & mask;
+    out[27+outOffset] = (curInputValue8 >>> 14) & mask;
+    out[28+outOffset] = ((curInputValue8 >>> 24) | (curInputValue9 << 8)) & mask;
+    out[29+outOffset] = (curInputValue9 >>> 2) & mask;
+    out[30+outOffset] = (curInputValue9 >>> 12) & mask;
+    out[31+outOffset] = curInputValue9 >>> 22;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack11(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 2047;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    int curInputValue2 = in.get();
+    int curInputValue3 = in.get();
+    int curInputValue4 = in.get();
+    int curInputValue5 = in.get();
+    int curInputValue6 = in.get();
+    int curInputValue7 = in.get();
+    int curInputValue8 = in.get();
+    int curInputValue9 = in.get();
+    int curInputValue10 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 11) & mask;
+    out[2+outOffset] = ((curInputValue0 >>> 22) | (curInputValue1 << 10)) & mask;
+    out[3+outOffset] = (curInputValue1 >>> 1) & mask;
+    out[4+outOffset] = (curInputValue1 >>> 12) & mask;
+    out[5+outOffset] = ((curInputValue1 >>> 23) | (curInputValue2 << 9)) & mask;
+    out[6+outOffset] = (curInputValue2 >>> 2) & mask;
+    out[7+outOffset] = (curInputValue2 >>> 13) & mask;
+    out[8+outOffset] = ((curInputValue2 >>> 24) | (curInputValue3 << 8)) & mask;
+    out[9+outOffset] = (curInputValue3 >>> 3) & mask;
+    out[10+outOffset] = (curInputValue3 >>> 14) & mask;
+    out[11+outOffset] = ((curInputValue3 >>> 25) | (curInputValue4 << 7)) & mask;
+    out[12+outOffset] = (curInputValue4 >>> 4) & mask;
+    out[13+outOffset] = (curInputValue4 >>> 15) & mask;
+    out[14+outOffset] = ((curInputValue4 >>> 26) | (curInputValue5 << 6)) & mask;
+    out[15+outOffset] = (curInputValue5 >>> 5) & mask;
+    out[16+outOffset] = (curInputValue5 >>> 16) & mask;
+    out[17+outOffset] = ((curInputValue5 >>> 27) | (curInputValue6 << 5)) & mask;
+    out[18+outOffset] = (curInputValue6 >>> 6) & mask;
+    out[19+outOffset] = (curInputValue6 >>> 17) & mask;
+    out[20+outOffset] = ((curInputValue6 >>> 28) | (curInputValue7 << 4)) & mask;
+    out[21+outOffset] = (curInputValue7 >>> 7) & mask;
+    out[22+outOffset] = (curInputValue7 >>> 18) & mask;
+    out[23+outOffset] = ((curInputValue7 >>> 29) | (curInputValue8 << 3)) & mask;
+    out[24+outOffset] = (curInputValue8 >>> 8) & mask;
+    out[25+outOffset] = (curInputValue8 >>> 19) & mask;
+    out[26+outOffset] = ((curInputValue8 >>> 30) | (curInputValue9 << 2)) & mask;
+    out[27+outOffset] = (curInputValue9 >>> 9) & mask;
+    out[28+outOffset] = (curInputValue9 >>> 20) & mask;
+    out[29+outOffset] = ((curInputValue9 >>> 31) | (curInputValue10 << 1)) & mask;
+    out[30+outOffset] = (curInputValue10 >>> 10) & mask;
+    out[31+outOffset] = curInputValue10 >>> 21;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack12(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 4095;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    int curInputValue2 = in.get();
+    int curInputValue3 = in.get();
+    int curInputValue4 = in.get();
+    int curInputValue5 = in.get();
+    int curInputValue6 = in.get();
+    int curInputValue7 = in.get();
+    int curInputValue8 = in.get();
+    int curInputValue9 = in.get();
+    int curInputValue10 = in.get();
+    int curInputValue11 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 12) & mask;
+    out[2+outOffset] = ((curInputValue0 >>> 24) | (curInputValue1 << 8)) & mask;
+    out[3+outOffset] = (curInputValue1 >>> 4) & mask;
+    out[4+outOffset] = (curInputValue1 >>> 16) & mask;
+    out[5+outOffset] = ((curInputValue1 >>> 28) | (curInputValue2 << 4)) & mask;
+    out[6+outOffset] = (curInputValue2 >>> 8) & mask;
+    out[7+outOffset] = curInputValue2 >>> 20;
+    out[8+outOffset] = curInputValue3 & mask;
+    out[9+outOffset] = (curInputValue3 >>> 12) & mask;
+    out[10+outOffset] = ((curInputValue3 >>> 24) | (curInputValue4 << 8)) & mask;
+    out[11+outOffset] = (curInputValue4 >>> 4) & mask;
+    out[12+outOffset] = (curInputValue4 >>> 16) & mask;
+    out[13+outOffset] = ((curInputValue4 >>> 28) | (curInputValue5 << 4)) & mask;
+    out[14+outOffset] = (curInputValue5 >>> 8) & mask;
+    out[15+outOffset] = curInputValue5 >>> 20;
+    out[16+outOffset] = curInputValue6 & mask;
+    out[17+outOffset] = (curInputValue6 >>> 12) & mask;
+    out[18+outOffset] = ((curInputValue6 >>> 24) | (curInputValue7 << 8)) & mask;
+    out[19+outOffset] = (curInputValue7 >>> 4) & mask;
+    out[20+outOffset] = (curInputValue7 >>> 16) & mask;
+    out[21+outOffset] = ((curInputValue7 >>> 28) | (curInputValue8 << 4)) & mask;
+    out[22+outOffset] = (curInputValue8 >>> 8) & mask;
+    out[23+outOffset] = curInputValue8 >>> 20;
+    out[24+outOffset] = curInputValue9 & mask;
+    out[25+outOffset] = (curInputValue9 >>> 12) & mask;
+    out[26+outOffset] = ((curInputValue9 >>> 24) | (curInputValue10 << 8)) & mask;
+    out[27+outOffset] = (curInputValue10 >>> 4) & mask;
+    out[28+outOffset] = (curInputValue10 >>> 16) & mask;
+    out[29+outOffset] = ((curInputValue10 >>> 28) | (curInputValue11 << 4)) & mask;
+    out[30+outOffset] = (curInputValue11 >>> 8) & mask;
+    out[31+outOffset] = curInputValue11 >>> 20;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack13(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 8191;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    int curInputValue2 = in.get();
+    int curInputValue3 = in.get();
+    int curInputValue4 = in.get();
+    int curInputValue5 = in.get();
+    int curInputValue6 = in.get();
+    int curInputValue7 = in.get();
+    int curInputValue8 = in.get();
+    int curInputValue9 = in.get();
+    int curInputValue10 = in.get();
+    int curInputValue11 = in.get();
+    int curInputValue12 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 13) & mask;
+    out[2+outOffset] = ((curInputValue0 >>> 26) | (curInputValue1 << 6)) & mask;
+    out[3+outOffset] = (curInputValue1 >>> 7) & mask;
+    out[4+outOffset] = ((curInputValue1 >>> 20) | (curInputValue2 << 12)) & mask;
+    out[5+outOffset] = (curInputValue2 >>> 1) & mask;
+    out[6+outOffset] = (curInputValue2 >>> 14) & mask;
+    out[7+outOffset] = ((curInputValue2 >>> 27) | (curInputValue3 << 5)) & mask;
+    out[8+outOffset] = (curInputValue3 >>> 8) & mask;
+    out[9+outOffset] = ((curInputValue3 >>> 21) | (curInputValue4 << 11)) & mask;
+    out[10+outOffset] = (curInputValue4 >>> 2) & mask;
+    out[11+outOffset] = (curInputValue4 >>> 15) & mask;
+    out[12+outOffset] = ((curInputValue4 >>> 28) | (curInputValue5 << 4)) & mask;
+    out[13+outOffset] = (curInputValue5 >>> 9) & mask;
+    out[14+outOffset] = ((curInputValue5 >>> 22) | (curInputValue6 << 10)) & mask;
+    out[15+outOffset] = (curInputValue6 >>> 3) & mask;
+    out[16+outOffset] = (curInputValue6 >>> 16) & mask;
+    out[17+outOffset] = ((curInputValue6 >>> 29) | (curInputValue7 << 3)) & mask;
+    out[18+outOffset] = (curInputValue7 >>> 10) & mask;
+    out[19+outOffset] = ((curInputValue7 >>> 23) | (curInputValue8 << 9)) & mask;
+    out[20+outOffset] = (curInputValue8 >>> 4) & mask;
+    out[21+outOffset] = (curInputValue8 >>> 17) & mask;
+    out[22+outOffset] = ((curInputValue8 >>> 30) | (curInputValue9 << 2)) & mask;
+    out[23+outOffset] = (curInputValue9 >>> 11) & mask;
+    out[24+outOffset] = ((curInputValue9 >>> 24) | (curInputValue10 << 8)) & mask;
+    out[25+outOffset] = (curInputValue10 >>> 5) & mask;
+    out[26+outOffset] = (curInputValue10 >>> 18) & mask;
+    out[27+outOffset] = ((curInputValue10 >>> 31) | (curInputValue11 << 1)) & mask;
+    out[28+outOffset] = (curInputValue11 >>> 12) & mask;
+    out[29+outOffset] = ((curInputValue11 >>> 25) | (curInputValue12 << 7)) & mask;
+    out[30+outOffset] = (curInputValue12 >>> 6) & mask;
+    out[31+outOffset] = curInputValue12 >>> 19;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack16(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 65535;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    int curInputValue2 = in.get();
+    int curInputValue3 = in.get();
+    int curInputValue4 = in.get();
+    int curInputValue5 = in.get();
+    int curInputValue6 = in.get();
+    int curInputValue7 = in.get();
+    int curInputValue8 = in.get();
+    int curInputValue9 = in.get();
+    int curInputValue10 = in.get();
+    int curInputValue11 = in.get();
+    int curInputValue12 = in.get();
+    int curInputValue13 = in.get();
+    int curInputValue14 = in.get();
+    int curInputValue15 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = curInputValue0 >>> 16;
+    out[2+outOffset] = curInputValue1 & mask;
+    out[3+outOffset] = curInputValue1 >>> 16;
+    out[4+outOffset] = curInputValue2 & mask;
+    out[5+outOffset] = curInputValue2 >>> 16;
+    out[6+outOffset] = curInputValue3 & mask;
+    out[7+outOffset] = curInputValue3 >>> 16;
+    out[8+outOffset] = curInputValue4 & mask;
+    out[9+outOffset] = curInputValue4 >>> 16;
+    out[10+outOffset] = curInputValue5 & mask;
+    out[11+outOffset] = curInputValue5 >>> 16;
+    out[12+outOffset] = curInputValue6 & mask;
+    out[13+outOffset] = curInputValue6 >>> 16;
+    out[14+outOffset] = curInputValue7 & mask;
+    out[15+outOffset] = curInputValue7 >>> 16;
+    out[16+outOffset] = curInputValue8 & mask;
+    out[17+outOffset] = curInputValue8 >>> 16;
+    out[18+outOffset] = curInputValue9 & mask;
+    out[19+outOffset] = curInputValue9 >>> 16;
+    out[20+outOffset] = curInputValue10 & mask;
+    out[21+outOffset] = curInputValue10 >>> 16;
+    out[22+outOffset] = curInputValue11 & mask;
+    out[23+outOffset] = curInputValue11 >>> 16;
+    out[24+outOffset] = curInputValue12 & mask;
+    out[25+outOffset] = curInputValue12 >>> 16;
+    out[26+outOffset] = curInputValue13 & mask;
+    out[27+outOffset] = curInputValue13 >>> 16;
+    out[28+outOffset] = curInputValue14 & mask;
+    out[29+outOffset] = curInputValue14 >>> 16;
+    out[30+outOffset] = curInputValue15 & mask;
+    out[31+outOffset] = curInputValue15 >>> 16;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack20(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 1048575;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    int curInputValue2 = in.get();
+    int curInputValue3 = in.get();
+    int curInputValue4 = in.get();
+    int curInputValue5 = in.get();
+    int curInputValue6 = in.get();
+    int curInputValue7 = in.get();
+    int curInputValue8 = in.get();
+    int curInputValue9 = in.get();
+    int curInputValue10 = in.get();
+    int curInputValue11 = in.get();
+    int curInputValue12 = in.get();
+    int curInputValue13 = in.get();
+    int curInputValue14 = in.get();
+    int curInputValue15 = in.get();
+    int curInputValue16 = in.get();
+    int curInputValue17 = in.get();
+    int curInputValue18 = in.get();
+    int curInputValue19 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = ((curInputValue0 >>> 20) | (curInputValue1 << 12)) & mask;
+    out[2+outOffset] = (curInputValue1 >>> 8) & mask;
+    out[3+outOffset] = ((curInputValue1 >>> 28) | (curInputValue2 << 4)) & mask;
+    out[4+outOffset] = ((curInputValue2 >>> 16) | (curInputValue3 << 16)) & mask;
+    out[5+outOffset] = (curInputValue3 >>> 4) & mask;
+    out[6+outOffset] = ((curInputValue3 >>> 24) | (curInputValue4 << 8)) & mask;
+    out[7+outOffset] = curInputValue4 >>> 12;
+    out[8+outOffset] = curInputValue5 & mask;
+    out[9+outOffset] = ((curInputValue5 >>> 20) | (curInputValue6 << 12)) & mask;
+    out[10+outOffset] = (curInputValue6 >>> 8) & mask;
+    out[11+outOffset] = ((curInputValue6 >>> 28) | (curInputValue7 << 4)) & mask;
+    out[12+outOffset] = ((curInputValue7 >>> 16) | (curInputValue8 << 16)) & mask;
+    out[13+outOffset] = (curInputValue8 >>> 4) & mask;
+    out[14+outOffset] = ((curInputValue8 >>> 24) | (curInputValue9 << 8)) & mask;
+    out[15+outOffset] = curInputValue9 >>> 12;
+    out[16+outOffset] = curInputValue10 & mask;
+    out[17+outOffset] = ((curInputValue10 >>> 20) | (curInputValue11 << 12)) & mask;
+    out[18+outOffset] = (curInputValue11 >>> 8) & mask;
+    out[19+outOffset] = ((curInputValue11 >>> 28) | (curInputValue12 << 4)) & mask;
+    out[20+outOffset] = ((curInputValue12 >>> 16) | (curInputValue13 << 16)) & mask;
+    out[21+outOffset] = (curInputValue13 >>> 4) & mask;
+    out[22+outOffset] = ((curInputValue13 >>> 24) | (curInputValue14 << 8)) & mask;
+    out[23+outOffset] = curInputValue14 >>> 12;
+    out[24+outOffset] = curInputValue15 & mask;
+    out[25+outOffset] = ((curInputValue15 >>> 20) | (curInputValue16 << 12)) & mask;
+    out[26+outOffset] = (curInputValue16 >>> 8) & mask;
+    out[27+outOffset] = ((curInputValue16 >>> 28) | (curInputValue17 << 4)) & mask;
+    out[28+outOffset] = ((curInputValue17 >>> 16) | (curInputValue18 << 16)) & mask;
+    out[29+outOffset] = (curInputValue18 >>> 4) & mask;
+    out[30+outOffset] = ((curInputValue18 >>> 24) | (curInputValue19 << 8)) & mask;
+    out[31+outOffset] = curInputValue19 >>> 12;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack28(int[] out, IntBuffer in)
+  {
+  int outOffset = 0;
+  final int mask = 268435455;
+  for(int i=0; i<4; ++i){
+    int curInputValue0 = in.get();
+    int curInputValue1 = in.get();
+    int curInputValue2 = in.get();
+    int curInputValue3 = in.get();
+    int curInputValue4 = in.get();
+    int curInputValue5 = in.get();
+    int curInputValue6 = in.get();
+    int curInputValue7 = in.get();
+    int curInputValue8 = in.get();
+    int curInputValue9 = in.get();
+    int curInputValue10 = in.get();
+    int curInputValue11 = in.get();
+    int curInputValue12 = in.get();
+    int curInputValue13 = in.get();
+    int curInputValue14 = in.get();
+    int curInputValue15 = in.get();
+    int curInputValue16 = in.get();
+    int curInputValue17 = in.get();
+    int curInputValue18 = in.get();
+    int curInputValue19 = in.get();
+    int curInputValue20 = in.get();
+    int curInputValue21 = in.get();
+    int curInputValue22 = in.get();
+    int curInputValue23 = in.get();
+    int curInputValue24 = in.get();
+    int curInputValue25 = in.get();
+    int curInputValue26 = in.get();
+    int curInputValue27 = in.get();
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = ((curInputValue0 >>> 28) | (curInputValue1 << 4)) & mask;
+    out[2+outOffset] = ((curInputValue1 >>> 24) | (curInputValue2 << 8)) & mask;
+    out[3+outOffset] = ((curInputValue2 >>> 20) | (curInputValue3 << 12)) & mask;
+    out[4+outOffset] = ((curInputValue3 >>> 16) | (curInputValue4 << 16)) & mask;
+    out[5+outOffset] = ((curInputValue4 >>> 12) | (curInputValue5 << 20)) & mask;
+    out[6+outOffset] = ((curInputValue5 >>> 8) | (curInputValue6 << 24)) & mask;
+    out[7+outOffset] = curInputValue6 >>> 4;
+    out[8+outOffset] = curInputValue7 & mask;
+    out[9+outOffset] = ((curInputValue7 >>> 28) | (curInputValue8 << 4)) & mask;
+    out[10+outOffset] = ((curInputValue8 >>> 24) | (curInputValue9 << 8)) & mask;
+    out[11+outOffset] = ((curInputValue9 >>> 20) | (curInputValue10 << 12)) & mask;
+    out[12+outOffset] = ((curInputValue10 >>> 16) | (curInputValue11 << 16)) & mask;
+    out[13+outOffset] = ((curInputValue11 >>> 12) | (curInputValue12 << 20)) & mask;
+    out[14+outOffset] = ((curInputValue12 >>> 8) | (curInputValue13 << 24)) & mask;
+    out[15+outOffset] = curInputValue13 >>> 4;
+    out[16+outOffset] = curInputValue14 & mask;
+    out[17+outOffset] = ((curInputValue14 >>> 28) | (curInputValue15 << 4)) & mask;
+    out[18+outOffset] = ((curInputValue15 >>> 24) | (curInputValue16 << 8)) & mask;
+    out[19+outOffset] = ((curInputValue16 >>> 20) | (curInputValue17 << 12)) & mask;
+    out[20+outOffset] = ((curInputValue17 >>> 16) | (curInputValue18 << 16)) & mask;
+    out[21+outOffset] = ((curInputValue18 >>> 12) | (curInputValue19 << 20)) & mask;
+    out[22+outOffset] = ((curInputValue19 >>> 8) | (curInputValue20 << 24)) & mask;
+    out[23+outOffset] = curInputValue20 >>> 4;
+    out[24+outOffset] = curInputValue21 & mask;
+    out[25+outOffset] = ((curInputValue21 >>> 28) | (curInputValue22 << 4)) & mask;
+    out[26+outOffset] = ((curInputValue22 >>> 24) | (curInputValue23 << 8)) & mask;
+    out[27+outOffset] = ((curInputValue23 >>> 20) | (curInputValue24 << 12)) & mask;
+    out[28+outOffset] = ((curInputValue24 >>> 16) | (curInputValue25 << 16)) & mask;
+    out[29+outOffset] = ((curInputValue25 >>> 12) | (curInputValue26 << 20)) & mask;
+    out[30+outOffset] = ((curInputValue26 >>> 8) | (curInputValue27 << 24)) & mask;
+    out[31+outOffset] = curInputValue27 >>> 4;
+    outOffset += 32;
+  }
+  }
+}

Property changes on: lucene/src/java/org/apache/lucene/util/pfor2/Unpack128WithBuffer.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: lucene/src/java/org/apache/lucene/util/pfor2/Unpack128.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/pfor2/Unpack128.java	(revision 0)
+++ lucene/src/java/org/apache/lucene/util/pfor2/Unpack128.java	(revision 0)
@@ -0,0 +1,876 @@
+package org.apache.lucene.util.pfor2;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+public class Unpack128{
+ 
+  static public void unpack(int[] out, int[] in, int bits) {
+    switch (bits) {
+      case 0:  unpack0(out, in); break;
+      case 1:  unpack1(out, in); break;
+      case 2:  unpack2(out, in); break;
+      case 3:  unpack3(out, in); break;
+      case 4:  unpack4(out, in); break;
+      case 5:  unpack5(out, in); break;
+      case 6:  unpack6(out, in); break;
+      case 7:  unpack7(out, in); break;
+      case 8:  unpack8(out, in); break;
+      case 9:  unpack9(out, in); break;
+      case 10:  unpack10(out, in); break;
+      case 11:  unpack11(out, in); break;
+      case 12:  unpack12(out, in); break;
+      case 13:  unpack13(out, in); break;
+      case 16:  unpack16(out, in); break;
+      case 20:  unpack20(out, in); break;
+      case 28:  unpack28(out, in); break;
+      default: break;
+    }
+  }
+ 
+  static private void unpack0(int[] out, int[] in)
+  {
+  }
+ 
+  static private void unpack1(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 1;
+  for(i=0, w=1; i<4; ++i, w+=1){
+    int curInputValue0 = in[w];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 1) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 2) & mask;
+    out[3+outOffset] = (curInputValue0 >>> 3) & mask;
+    out[4+outOffset] = (curInputValue0 >>> 4) & mask;
+    out[5+outOffset] = (curInputValue0 >>> 5) & mask;
+    out[6+outOffset] = (curInputValue0 >>> 6) & mask;
+    out[7+outOffset] = (curInputValue0 >>> 7) & mask;
+    out[8+outOffset] = (curInputValue0 >>> 8) & mask;
+    out[9+outOffset] = (curInputValue0 >>> 9) & mask;
+    out[10+outOffset] = (curInputValue0 >>> 10) & mask;
+    out[11+outOffset] = (curInputValue0 >>> 11) & mask;
+    out[12+outOffset] = (curInputValue0 >>> 12) & mask;
+    out[13+outOffset] = (curInputValue0 >>> 13) & mask;
+    out[14+outOffset] = (curInputValue0 >>> 14) & mask;
+    out[15+outOffset] = (curInputValue0 >>> 15) & mask;
+    out[16+outOffset] = (curInputValue0 >>> 16) & mask;
+    out[17+outOffset] = (curInputValue0 >>> 17) & mask;
+    out[18+outOffset] = (curInputValue0 >>> 18) & mask;
+    out[19+outOffset] = (curInputValue0 >>> 19) & mask;
+    out[20+outOffset] = (curInputValue0 >>> 20) & mask;
+    out[21+outOffset] = (curInputValue0 >>> 21) & mask;
+    out[22+outOffset] = (curInputValue0 >>> 22) & mask;
+    out[23+outOffset] = (curInputValue0 >>> 23) & mask;
+    out[24+outOffset] = (curInputValue0 >>> 24) & mask;
+    out[25+outOffset] = (curInputValue0 >>> 25) & mask;
+    out[26+outOffset] = (curInputValue0 >>> 26) & mask;
+    out[27+outOffset] = (curInputValue0 >>> 27) & mask;
+    out[28+outOffset] = (curInputValue0 >>> 28) & mask;
+    out[29+outOffset] = (curInputValue0 >>> 29) & mask;
+    out[30+outOffset] = (curInputValue0 >>> 30) & mask;
+    out[31+outOffset] = curInputValue0 >>> 31;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack2(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 3;
+  for(i=0, w=1; i<4; ++i, w+=2){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 2) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 4) & mask;
+    out[3+outOffset] = (curInputValue0 >>> 6) & mask;
+    out[4+outOffset] = (curInputValue0 >>> 8) & mask;
+    out[5+outOffset] = (curInputValue0 >>> 10) & mask;
+    out[6+outOffset] = (curInputValue0 >>> 12) & mask;
+    out[7+outOffset] = (curInputValue0 >>> 14) & mask;
+    out[8+outOffset] = (curInputValue0 >>> 16) & mask;
+    out[9+outOffset] = (curInputValue0 >>> 18) & mask;
+    out[10+outOffset] = (curInputValue0 >>> 20) & mask;
+    out[11+outOffset] = (curInputValue0 >>> 22) & mask;
+    out[12+outOffset] = (curInputValue0 >>> 24) & mask;
+    out[13+outOffset] = (curInputValue0 >>> 26) & mask;
+    out[14+outOffset] = (curInputValue0 >>> 28) & mask;
+    out[15+outOffset] = curInputValue0 >>> 30;
+    out[16+outOffset] = curInputValue1 & mask;
+    out[17+outOffset] = (curInputValue1 >>> 2) & mask;
+    out[18+outOffset] = (curInputValue1 >>> 4) & mask;
+    out[19+outOffset] = (curInputValue1 >>> 6) & mask;
+    out[20+outOffset] = (curInputValue1 >>> 8) & mask;
+    out[21+outOffset] = (curInputValue1 >>> 10) & mask;
+    out[22+outOffset] = (curInputValue1 >>> 12) & mask;
+    out[23+outOffset] = (curInputValue1 >>> 14) & mask;
+    out[24+outOffset] = (curInputValue1 >>> 16) & mask;
+    out[25+outOffset] = (curInputValue1 >>> 18) & mask;
+    out[26+outOffset] = (curInputValue1 >>> 20) & mask;
+    out[27+outOffset] = (curInputValue1 >>> 22) & mask;
+    out[28+outOffset] = (curInputValue1 >>> 24) & mask;
+    out[29+outOffset] = (curInputValue1 >>> 26) & mask;
+    out[30+outOffset] = (curInputValue1 >>> 28) & mask;
+    out[31+outOffset] = curInputValue1 >>> 30;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack3(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 7;
+  for(i=0, w=1; i<4; ++i, w+=3){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    int curInputValue2 = in[w+2];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 3) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 6) & mask;
+    out[3+outOffset] = (curInputValue0 >>> 9) & mask;
+    out[4+outOffset] = (curInputValue0 >>> 12) & mask;
+    out[5+outOffset] = (curInputValue0 >>> 15) & mask;
+    out[6+outOffset] = (curInputValue0 >>> 18) & mask;
+    out[7+outOffset] = (curInputValue0 >>> 21) & mask;
+    out[8+outOffset] = (curInputValue0 >>> 24) & mask;
+    out[9+outOffset] = (curInputValue0 >>> 27) & mask;
+    out[10+outOffset] = ((curInputValue0 >>> 30) | (curInputValue1 << 2)) & mask;
+    out[11+outOffset] = (curInputValue1 >>> 1) & mask;
+    out[12+outOffset] = (curInputValue1 >>> 4) & mask;
+    out[13+outOffset] = (curInputValue1 >>> 7) & mask;
+    out[14+outOffset] = (curInputValue1 >>> 10) & mask;
+    out[15+outOffset] = (curInputValue1 >>> 13) & mask;
+    out[16+outOffset] = (curInputValue1 >>> 16) & mask;
+    out[17+outOffset] = (curInputValue1 >>> 19) & mask;
+    out[18+outOffset] = (curInputValue1 >>> 22) & mask;
+    out[19+outOffset] = (curInputValue1 >>> 25) & mask;
+    out[20+outOffset] = (curInputValue1 >>> 28) & mask;
+    out[21+outOffset] = ((curInputValue1 >>> 31) | (curInputValue2 << 1)) & mask;
+    out[22+outOffset] = (curInputValue2 >>> 2) & mask;
+    out[23+outOffset] = (curInputValue2 >>> 5) & mask;
+    out[24+outOffset] = (curInputValue2 >>> 8) & mask;
+    out[25+outOffset] = (curInputValue2 >>> 11) & mask;
+    out[26+outOffset] = (curInputValue2 >>> 14) & mask;
+    out[27+outOffset] = (curInputValue2 >>> 17) & mask;
+    out[28+outOffset] = (curInputValue2 >>> 20) & mask;
+    out[29+outOffset] = (curInputValue2 >>> 23) & mask;
+    out[30+outOffset] = (curInputValue2 >>> 26) & mask;
+    out[31+outOffset] = curInputValue2 >>> 29;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack4(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 15;
+  for(i=0, w=1; i<4; ++i, w+=4){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    int curInputValue2 = in[w+2];
+    int curInputValue3 = in[w+3];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 4) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 8) & mask;
+    out[3+outOffset] = (curInputValue0 >>> 12) & mask;
+    out[4+outOffset] = (curInputValue0 >>> 16) & mask;
+    out[5+outOffset] = (curInputValue0 >>> 20) & mask;
+    out[6+outOffset] = (curInputValue0 >>> 24) & mask;
+    out[7+outOffset] = curInputValue0 >>> 28;
+    out[8+outOffset] = curInputValue1 & mask;
+    out[9+outOffset] = (curInputValue1 >>> 4) & mask;
+    out[10+outOffset] = (curInputValue1 >>> 8) & mask;
+    out[11+outOffset] = (curInputValue1 >>> 12) & mask;
+    out[12+outOffset] = (curInputValue1 >>> 16) & mask;
+    out[13+outOffset] = (curInputValue1 >>> 20) & mask;
+    out[14+outOffset] = (curInputValue1 >>> 24) & mask;
+    out[15+outOffset] = curInputValue1 >>> 28;
+    out[16+outOffset] = curInputValue2 & mask;
+    out[17+outOffset] = (curInputValue2 >>> 4) & mask;
+    out[18+outOffset] = (curInputValue2 >>> 8) & mask;
+    out[19+outOffset] = (curInputValue2 >>> 12) & mask;
+    out[20+outOffset] = (curInputValue2 >>> 16) & mask;
+    out[21+outOffset] = (curInputValue2 >>> 20) & mask;
+    out[22+outOffset] = (curInputValue2 >>> 24) & mask;
+    out[23+outOffset] = curInputValue2 >>> 28;
+    out[24+outOffset] = curInputValue3 & mask;
+    out[25+outOffset] = (curInputValue3 >>> 4) & mask;
+    out[26+outOffset] = (curInputValue3 >>> 8) & mask;
+    out[27+outOffset] = (curInputValue3 >>> 12) & mask;
+    out[28+outOffset] = (curInputValue3 >>> 16) & mask;
+    out[29+outOffset] = (curInputValue3 >>> 20) & mask;
+    out[30+outOffset] = (curInputValue3 >>> 24) & mask;
+    out[31+outOffset] = curInputValue3 >>> 28;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack5(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 31;
+  for(i=0, w=1; i<4; ++i, w+=5){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    int curInputValue2 = in[w+2];
+    int curInputValue3 = in[w+3];
+    int curInputValue4 = in[w+4];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 5) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 10) & mask;
+    out[3+outOffset] = (curInputValue0 >>> 15) & mask;
+    out[4+outOffset] = (curInputValue0 >>> 20) & mask;
+    out[5+outOffset] = (curInputValue0 >>> 25) & mask;
+    out[6+outOffset] = ((curInputValue0 >>> 30) | (curInputValue1 << 2)) & mask;
+    out[7+outOffset] = (curInputValue1 >>> 3) & mask;
+    out[8+outOffset] = (curInputValue1 >>> 8) & mask;
+    out[9+outOffset] = (curInputValue1 >>> 13) & mask;
+    out[10+outOffset] = (curInputValue1 >>> 18) & mask;
+    out[11+outOffset] = (curInputValue1 >>> 23) & mask;
+    out[12+outOffset] = ((curInputValue1 >>> 28) | (curInputValue2 << 4)) & mask;
+    out[13+outOffset] = (curInputValue2 >>> 1) & mask;
+    out[14+outOffset] = (curInputValue2 >>> 6) & mask;
+    out[15+outOffset] = (curInputValue2 >>> 11) & mask;
+    out[16+outOffset] = (curInputValue2 >>> 16) & mask;
+    out[17+outOffset] = (curInputValue2 >>> 21) & mask;
+    out[18+outOffset] = (curInputValue2 >>> 26) & mask;
+    out[19+outOffset] = ((curInputValue2 >>> 31) | (curInputValue3 << 1)) & mask;
+    out[20+outOffset] = (curInputValue3 >>> 4) & mask;
+    out[21+outOffset] = (curInputValue3 >>> 9) & mask;
+    out[22+outOffset] = (curInputValue3 >>> 14) & mask;
+    out[23+outOffset] = (curInputValue3 >>> 19) & mask;
+    out[24+outOffset] = (curInputValue3 >>> 24) & mask;
+    out[25+outOffset] = ((curInputValue3 >>> 29) | (curInputValue4 << 3)) & mask;
+    out[26+outOffset] = (curInputValue4 >>> 2) & mask;
+    out[27+outOffset] = (curInputValue4 >>> 7) & mask;
+    out[28+outOffset] = (curInputValue4 >>> 12) & mask;
+    out[29+outOffset] = (curInputValue4 >>> 17) & mask;
+    out[30+outOffset] = (curInputValue4 >>> 22) & mask;
+    out[31+outOffset] = curInputValue4 >>> 27;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack6(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 63;
+  for(i=0, w=1; i<4; ++i, w+=6){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    int curInputValue2 = in[w+2];
+    int curInputValue3 = in[w+3];
+    int curInputValue4 = in[w+4];
+    int curInputValue5 = in[w+5];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 6) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 12) & mask;
+    out[3+outOffset] = (curInputValue0 >>> 18) & mask;
+    out[4+outOffset] = (curInputValue0 >>> 24) & mask;
+    out[5+outOffset] = ((curInputValue0 >>> 30) | (curInputValue1 << 2)) & mask;
+    out[6+outOffset] = (curInputValue1 >>> 4) & mask;
+    out[7+outOffset] = (curInputValue1 >>> 10) & mask;
+    out[8+outOffset] = (curInputValue1 >>> 16) & mask;
+    out[9+outOffset] = (curInputValue1 >>> 22) & mask;
+    out[10+outOffset] = ((curInputValue1 >>> 28) | (curInputValue2 << 4)) & mask;
+    out[11+outOffset] = (curInputValue2 >>> 2) & mask;
+    out[12+outOffset] = (curInputValue2 >>> 8) & mask;
+    out[13+outOffset] = (curInputValue2 >>> 14) & mask;
+    out[14+outOffset] = (curInputValue2 >>> 20) & mask;
+    out[15+outOffset] = curInputValue2 >>> 26;
+    out[16+outOffset] = curInputValue3 & mask;
+    out[17+outOffset] = (curInputValue3 >>> 6) & mask;
+    out[18+outOffset] = (curInputValue3 >>> 12) & mask;
+    out[19+outOffset] = (curInputValue3 >>> 18) & mask;
+    out[20+outOffset] = (curInputValue3 >>> 24) & mask;
+    out[21+outOffset] = ((curInputValue3 >>> 30) | (curInputValue4 << 2)) & mask;
+    out[22+outOffset] = (curInputValue4 >>> 4) & mask;
+    out[23+outOffset] = (curInputValue4 >>> 10) & mask;
+    out[24+outOffset] = (curInputValue4 >>> 16) & mask;
+    out[25+outOffset] = (curInputValue4 >>> 22) & mask;
+    out[26+outOffset] = ((curInputValue4 >>> 28) | (curInputValue5 << 4)) & mask;
+    out[27+outOffset] = (curInputValue5 >>> 2) & mask;
+    out[28+outOffset] = (curInputValue5 >>> 8) & mask;
+    out[29+outOffset] = (curInputValue5 >>> 14) & mask;
+    out[30+outOffset] = (curInputValue5 >>> 20) & mask;
+    out[31+outOffset] = curInputValue5 >>> 26;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack7(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 127;
+  for(i=0, w=1; i<4; ++i, w+=7){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    int curInputValue2 = in[w+2];
+    int curInputValue3 = in[w+3];
+    int curInputValue4 = in[w+4];
+    int curInputValue5 = in[w+5];
+    int curInputValue6 = in[w+6];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 7) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 14) & mask;
+    out[3+outOffset] = (curInputValue0 >>> 21) & mask;
+    out[4+outOffset] = ((curInputValue0 >>> 28) | (curInputValue1 << 4)) & mask;
+    out[5+outOffset] = (curInputValue1 >>> 3) & mask;
+    out[6+outOffset] = (curInputValue1 >>> 10) & mask;
+    out[7+outOffset] = (curInputValue1 >>> 17) & mask;
+    out[8+outOffset] = (curInputValue1 >>> 24) & mask;
+    out[9+outOffset] = ((curInputValue1 >>> 31) | (curInputValue2 << 1)) & mask;
+    out[10+outOffset] = (curInputValue2 >>> 6) & mask;
+    out[11+outOffset] = (curInputValue2 >>> 13) & mask;
+    out[12+outOffset] = (curInputValue2 >>> 20) & mask;
+    out[13+outOffset] = ((curInputValue2 >>> 27) | (curInputValue3 << 5)) & mask;
+    out[14+outOffset] = (curInputValue3 >>> 2) & mask;
+    out[15+outOffset] = (curInputValue3 >>> 9) & mask;
+    out[16+outOffset] = (curInputValue3 >>> 16) & mask;
+    out[17+outOffset] = (curInputValue3 >>> 23) & mask;
+    out[18+outOffset] = ((curInputValue3 >>> 30) | (curInputValue4 << 2)) & mask;
+    out[19+outOffset] = (curInputValue4 >>> 5) & mask;
+    out[20+outOffset] = (curInputValue4 >>> 12) & mask;
+    out[21+outOffset] = (curInputValue4 >>> 19) & mask;
+    out[22+outOffset] = ((curInputValue4 >>> 26) | (curInputValue5 << 6)) & mask;
+    out[23+outOffset] = (curInputValue5 >>> 1) & mask;
+    out[24+outOffset] = (curInputValue5 >>> 8) & mask;
+    out[25+outOffset] = (curInputValue5 >>> 15) & mask;
+    out[26+outOffset] = (curInputValue5 >>> 22) & mask;
+    out[27+outOffset] = ((curInputValue5 >>> 29) | (curInputValue6 << 3)) & mask;
+    out[28+outOffset] = (curInputValue6 >>> 4) & mask;
+    out[29+outOffset] = (curInputValue6 >>> 11) & mask;
+    out[30+outOffset] = (curInputValue6 >>> 18) & mask;
+    out[31+outOffset] = curInputValue6 >>> 25;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack8(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 255;
+  for(i=0, w=1; i<4; ++i, w+=8){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    int curInputValue2 = in[w+2];
+    int curInputValue3 = in[w+3];
+    int curInputValue4 = in[w+4];
+    int curInputValue5 = in[w+5];
+    int curInputValue6 = in[w+6];
+    int curInputValue7 = in[w+7];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 8) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 16) & mask;
+    out[3+outOffset] = curInputValue0 >>> 24;
+    out[4+outOffset] = curInputValue1 & mask;
+    out[5+outOffset] = (curInputValue1 >>> 8) & mask;
+    out[6+outOffset] = (curInputValue1 >>> 16) & mask;
+    out[7+outOffset] = curInputValue1 >>> 24;
+    out[8+outOffset] = curInputValue2 & mask;
+    out[9+outOffset] = (curInputValue2 >>> 8) & mask;
+    out[10+outOffset] = (curInputValue2 >>> 16) & mask;
+    out[11+outOffset] = curInputValue2 >>> 24;
+    out[12+outOffset] = curInputValue3 & mask;
+    out[13+outOffset] = (curInputValue3 >>> 8) & mask;
+    out[14+outOffset] = (curInputValue3 >>> 16) & mask;
+    out[15+outOffset] = curInputValue3 >>> 24;
+    out[16+outOffset] = curInputValue4 & mask;
+    out[17+outOffset] = (curInputValue4 >>> 8) & mask;
+    out[18+outOffset] = (curInputValue4 >>> 16) & mask;
+    out[19+outOffset] = curInputValue4 >>> 24;
+    out[20+outOffset] = curInputValue5 & mask;
+    out[21+outOffset] = (curInputValue5 >>> 8) & mask;
+    out[22+outOffset] = (curInputValue5 >>> 16) & mask;
+    out[23+outOffset] = curInputValue5 >>> 24;
+    out[24+outOffset] = curInputValue6 & mask;
+    out[25+outOffset] = (curInputValue6 >>> 8) & mask;
+    out[26+outOffset] = (curInputValue6 >>> 16) & mask;
+    out[27+outOffset] = curInputValue6 >>> 24;
+    out[28+outOffset] = curInputValue7 & mask;
+    out[29+outOffset] = (curInputValue7 >>> 8) & mask;
+    out[30+outOffset] = (curInputValue7 >>> 16) & mask;
+    out[31+outOffset] = curInputValue7 >>> 24;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack9(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 511;
+  for(i=0, w=1; i<4; ++i, w+=9){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    int curInputValue2 = in[w+2];
+    int curInputValue3 = in[w+3];
+    int curInputValue4 = in[w+4];
+    int curInputValue5 = in[w+5];
+    int curInputValue6 = in[w+6];
+    int curInputValue7 = in[w+7];
+    int curInputValue8 = in[w+8];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 9) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 18) & mask;
+    out[3+outOffset] = ((curInputValue0 >>> 27) | (curInputValue1 << 5)) & mask;
+    out[4+outOffset] = (curInputValue1 >>> 4) & mask;
+    out[5+outOffset] = (curInputValue1 >>> 13) & mask;
+    out[6+outOffset] = (curInputValue1 >>> 22) & mask;
+    out[7+outOffset] = ((curInputValue1 >>> 31) | (curInputValue2 << 1)) & mask;
+    out[8+outOffset] = (curInputValue2 >>> 8) & mask;
+    out[9+outOffset] = (curInputValue2 >>> 17) & mask;
+    out[10+outOffset] = ((curInputValue2 >>> 26) | (curInputValue3 << 6)) & mask;
+    out[11+outOffset] = (curInputValue3 >>> 3) & mask;
+    out[12+outOffset] = (curInputValue3 >>> 12) & mask;
+    out[13+outOffset] = (curInputValue3 >>> 21) & mask;
+    out[14+outOffset] = ((curInputValue3 >>> 30) | (curInputValue4 << 2)) & mask;
+    out[15+outOffset] = (curInputValue4 >>> 7) & mask;
+    out[16+outOffset] = (curInputValue4 >>> 16) & mask;
+    out[17+outOffset] = ((curInputValue4 >>> 25) | (curInputValue5 << 7)) & mask;
+    out[18+outOffset] = (curInputValue5 >>> 2) & mask;
+    out[19+outOffset] = (curInputValue5 >>> 11) & mask;
+    out[20+outOffset] = (curInputValue5 >>> 20) & mask;
+    out[21+outOffset] = ((curInputValue5 >>> 29) | (curInputValue6 << 3)) & mask;
+    out[22+outOffset] = (curInputValue6 >>> 6) & mask;
+    out[23+outOffset] = (curInputValue6 >>> 15) & mask;
+    out[24+outOffset] = ((curInputValue6 >>> 24) | (curInputValue7 << 8)) & mask;
+    out[25+outOffset] = (curInputValue7 >>> 1) & mask;
+    out[26+outOffset] = (curInputValue7 >>> 10) & mask;
+    out[27+outOffset] = (curInputValue7 >>> 19) & mask;
+    out[28+outOffset] = ((curInputValue7 >>> 28) | (curInputValue8 << 4)) & mask;
+    out[29+outOffset] = (curInputValue8 >>> 5) & mask;
+    out[30+outOffset] = (curInputValue8 >>> 14) & mask;
+    out[31+outOffset] = curInputValue8 >>> 23;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack10(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 1023;
+  for(i=0, w=1; i<4; ++i, w+=10){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    int curInputValue2 = in[w+2];
+    int curInputValue3 = in[w+3];
+    int curInputValue4 = in[w+4];
+    int curInputValue5 = in[w+5];
+    int curInputValue6 = in[w+6];
+    int curInputValue7 = in[w+7];
+    int curInputValue8 = in[w+8];
+    int curInputValue9 = in[w+9];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 10) & mask;
+    out[2+outOffset] = (curInputValue0 >>> 20) & mask;
+    out[3+outOffset] = ((curInputValue0 >>> 30) | (curInputValue1 << 2)) & mask;
+    out[4+outOffset] = (curInputValue1 >>> 8) & mask;
+    out[5+outOffset] = (curInputValue1 >>> 18) & mask;
+    out[6+outOffset] = ((curInputValue1 >>> 28) | (curInputValue2 << 4)) & mask;
+    out[7+outOffset] = (curInputValue2 >>> 6) & mask;
+    out[8+outOffset] = (curInputValue2 >>> 16) & mask;
+    out[9+outOffset] = ((curInputValue2 >>> 26) | (curInputValue3 << 6)) & mask;
+    out[10+outOffset] = (curInputValue3 >>> 4) & mask;
+    out[11+outOffset] = (curInputValue3 >>> 14) & mask;
+    out[12+outOffset] = ((curInputValue3 >>> 24) | (curInputValue4 << 8)) & mask;
+    out[13+outOffset] = (curInputValue4 >>> 2) & mask;
+    out[14+outOffset] = (curInputValue4 >>> 12) & mask;
+    out[15+outOffset] = curInputValue4 >>> 22;
+    out[16+outOffset] = curInputValue5 & mask;
+    out[17+outOffset] = (curInputValue5 >>> 10) & mask;
+    out[18+outOffset] = (curInputValue5 >>> 20) & mask;
+    out[19+outOffset] = ((curInputValue5 >>> 30) | (curInputValue6 << 2)) & mask;
+    out[20+outOffset] = (curInputValue6 >>> 8) & mask;
+    out[21+outOffset] = (curInputValue6 >>> 18) & mask;
+    out[22+outOffset] = ((curInputValue6 >>> 28) | (curInputValue7 << 4)) & mask;
+    out[23+outOffset] = (curInputValue7 >>> 6) & mask;
+    out[24+outOffset] = (curInputValue7 >>> 16) & mask;
+    out[25+outOffset] = ((curInputValue7 >>> 26) | (curInputValue8 << 6)) & mask;
+    out[26+outOffset] = (curInputValue8 >>> 4) & mask;
+    out[27+outOffset] = (curInputValue8 >>> 14) & mask;
+    out[28+outOffset] = ((curInputValue8 >>> 24) | (curInputValue9 << 8)) & mask;
+    out[29+outOffset] = (curInputValue9 >>> 2) & mask;
+    out[30+outOffset] = (curInputValue9 >>> 12) & mask;
+    out[31+outOffset] = curInputValue9 >>> 22;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack11(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 2047;
+  for(i=0, w=1; i<4; ++i, w+=11){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    int curInputValue2 = in[w+2];
+    int curInputValue3 = in[w+3];
+    int curInputValue4 = in[w+4];
+    int curInputValue5 = in[w+5];
+    int curInputValue6 = in[w+6];
+    int curInputValue7 = in[w+7];
+    int curInputValue8 = in[w+8];
+    int curInputValue9 = in[w+9];
+    int curInputValue10 = in[w+10];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 11) & mask;
+    out[2+outOffset] = ((curInputValue0 >>> 22) | (curInputValue1 << 10)) & mask;
+    out[3+outOffset] = (curInputValue1 >>> 1) & mask;
+    out[4+outOffset] = (curInputValue1 >>> 12) & mask;
+    out[5+outOffset] = ((curInputValue1 >>> 23) | (curInputValue2 << 9)) & mask;
+    out[6+outOffset] = (curInputValue2 >>> 2) & mask;
+    out[7+outOffset] = (curInputValue2 >>> 13) & mask;
+    out[8+outOffset] = ((curInputValue2 >>> 24) | (curInputValue3 << 8)) & mask;
+    out[9+outOffset] = (curInputValue3 >>> 3) & mask;
+    out[10+outOffset] = (curInputValue3 >>> 14) & mask;
+    out[11+outOffset] = ((curInputValue3 >>> 25) | (curInputValue4 << 7)) & mask;
+    out[12+outOffset] = (curInputValue4 >>> 4) & mask;
+    out[13+outOffset] = (curInputValue4 >>> 15) & mask;
+    out[14+outOffset] = ((curInputValue4 >>> 26) | (curInputValue5 << 6)) & mask;
+    out[15+outOffset] = (curInputValue5 >>> 5) & mask;
+    out[16+outOffset] = (curInputValue5 >>> 16) & mask;
+    out[17+outOffset] = ((curInputValue5 >>> 27) | (curInputValue6 << 5)) & mask;
+    out[18+outOffset] = (curInputValue6 >>> 6) & mask;
+    out[19+outOffset] = (curInputValue6 >>> 17) & mask;
+    out[20+outOffset] = ((curInputValue6 >>> 28) | (curInputValue7 << 4)) & mask;
+    out[21+outOffset] = (curInputValue7 >>> 7) & mask;
+    out[22+outOffset] = (curInputValue7 >>> 18) & mask;
+    out[23+outOffset] = ((curInputValue7 >>> 29) | (curInputValue8 << 3)) & mask;
+    out[24+outOffset] = (curInputValue8 >>> 8) & mask;
+    out[25+outOffset] = (curInputValue8 >>> 19) & mask;
+    out[26+outOffset] = ((curInputValue8 >>> 30) | (curInputValue9 << 2)) & mask;
+    out[27+outOffset] = (curInputValue9 >>> 9) & mask;
+    out[28+outOffset] = (curInputValue9 >>> 20) & mask;
+    out[29+outOffset] = ((curInputValue9 >>> 31) | (curInputValue10 << 1)) & mask;
+    out[30+outOffset] = (curInputValue10 >>> 10) & mask;
+    out[31+outOffset] = curInputValue10 >>> 21;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack12(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 4095;
+  for(i=0, w=1; i<4; ++i, w+=12){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    int curInputValue2 = in[w+2];
+    int curInputValue3 = in[w+3];
+    int curInputValue4 = in[w+4];
+    int curInputValue5 = in[w+5];
+    int curInputValue6 = in[w+6];
+    int curInputValue7 = in[w+7];
+    int curInputValue8 = in[w+8];
+    int curInputValue9 = in[w+9];
+    int curInputValue10 = in[w+10];
+    int curInputValue11 = in[w+11];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 12) & mask;
+    out[2+outOffset] = ((curInputValue0 >>> 24) | (curInputValue1 << 8)) & mask;
+    out[3+outOffset] = (curInputValue1 >>> 4) & mask;
+    out[4+outOffset] = (curInputValue1 >>> 16) & mask;
+    out[5+outOffset] = ((curInputValue1 >>> 28) | (curInputValue2 << 4)) & mask;
+    out[6+outOffset] = (curInputValue2 >>> 8) & mask;
+    out[7+outOffset] = curInputValue2 >>> 20;
+    out[8+outOffset] = curInputValue3 & mask;
+    out[9+outOffset] = (curInputValue3 >>> 12) & mask;
+    out[10+outOffset] = ((curInputValue3 >>> 24) | (curInputValue4 << 8)) & mask;
+    out[11+outOffset] = (curInputValue4 >>> 4) & mask;
+    out[12+outOffset] = (curInputValue4 >>> 16) & mask;
+    out[13+outOffset] = ((curInputValue4 >>> 28) | (curInputValue5 << 4)) & mask;
+    out[14+outOffset] = (curInputValue5 >>> 8) & mask;
+    out[15+outOffset] = curInputValue5 >>> 20;
+    out[16+outOffset] = curInputValue6 & mask;
+    out[17+outOffset] = (curInputValue6 >>> 12) & mask;
+    out[18+outOffset] = ((curInputValue6 >>> 24) | (curInputValue7 << 8)) & mask;
+    out[19+outOffset] = (curInputValue7 >>> 4) & mask;
+    out[20+outOffset] = (curInputValue7 >>> 16) & mask;
+    out[21+outOffset] = ((curInputValue7 >>> 28) | (curInputValue8 << 4)) & mask;
+    out[22+outOffset] = (curInputValue8 >>> 8) & mask;
+    out[23+outOffset] = curInputValue8 >>> 20;
+    out[24+outOffset] = curInputValue9 & mask;
+    out[25+outOffset] = (curInputValue9 >>> 12) & mask;
+    out[26+outOffset] = ((curInputValue9 >>> 24) | (curInputValue10 << 8)) & mask;
+    out[27+outOffset] = (curInputValue10 >>> 4) & mask;
+    out[28+outOffset] = (curInputValue10 >>> 16) & mask;
+    out[29+outOffset] = ((curInputValue10 >>> 28) | (curInputValue11 << 4)) & mask;
+    out[30+outOffset] = (curInputValue11 >>> 8) & mask;
+    out[31+outOffset] = curInputValue11 >>> 20;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack13(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 8191;
+  for(i=0, w=1; i<4; ++i, w+=13){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    int curInputValue2 = in[w+2];
+    int curInputValue3 = in[w+3];
+    int curInputValue4 = in[w+4];
+    int curInputValue5 = in[w+5];
+    int curInputValue6 = in[w+6];
+    int curInputValue7 = in[w+7];
+    int curInputValue8 = in[w+8];
+    int curInputValue9 = in[w+9];
+    int curInputValue10 = in[w+10];
+    int curInputValue11 = in[w+11];
+    int curInputValue12 = in[w+12];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = (curInputValue0 >>> 13) & mask;
+    out[2+outOffset] = ((curInputValue0 >>> 26) | (curInputValue1 << 6)) & mask;
+    out[3+outOffset] = (curInputValue1 >>> 7) & mask;
+    out[4+outOffset] = ((curInputValue1 >>> 20) | (curInputValue2 << 12)) & mask;
+    out[5+outOffset] = (curInputValue2 >>> 1) & mask;
+    out[6+outOffset] = (curInputValue2 >>> 14) & mask;
+    out[7+outOffset] = ((curInputValue2 >>> 27) | (curInputValue3 << 5)) & mask;
+    out[8+outOffset] = (curInputValue3 >>> 8) & mask;
+    out[9+outOffset] = ((curInputValue3 >>> 21) | (curInputValue4 << 11)) & mask;
+    out[10+outOffset] = (curInputValue4 >>> 2) & mask;
+    out[11+outOffset] = (curInputValue4 >>> 15) & mask;
+    out[12+outOffset] = ((curInputValue4 >>> 28) | (curInputValue5 << 4)) & mask;
+    out[13+outOffset] = (curInputValue5 >>> 9) & mask;
+    out[14+outOffset] = ((curInputValue5 >>> 22) | (curInputValue6 << 10)) & mask;
+    out[15+outOffset] = (curInputValue6 >>> 3) & mask;
+    out[16+outOffset] = (curInputValue6 >>> 16) & mask;
+    out[17+outOffset] = ((curInputValue6 >>> 29) | (curInputValue7 << 3)) & mask;
+    out[18+outOffset] = (curInputValue7 >>> 10) & mask;
+    out[19+outOffset] = ((curInputValue7 >>> 23) | (curInputValue8 << 9)) & mask;
+    out[20+outOffset] = (curInputValue8 >>> 4) & mask;
+    out[21+outOffset] = (curInputValue8 >>> 17) & mask;
+    out[22+outOffset] = ((curInputValue8 >>> 30) | (curInputValue9 << 2)) & mask;
+    out[23+outOffset] = (curInputValue9 >>> 11) & mask;
+    out[24+outOffset] = ((curInputValue9 >>> 24) | (curInputValue10 << 8)) & mask;
+    out[25+outOffset] = (curInputValue10 >>> 5) & mask;
+    out[26+outOffset] = (curInputValue10 >>> 18) & mask;
+    out[27+outOffset] = ((curInputValue10 >>> 31) | (curInputValue11 << 1)) & mask;
+    out[28+outOffset] = (curInputValue11 >>> 12) & mask;
+    out[29+outOffset] = ((curInputValue11 >>> 25) | (curInputValue12 << 7)) & mask;
+    out[30+outOffset] = (curInputValue12 >>> 6) & mask;
+    out[31+outOffset] = curInputValue12 >>> 19;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack16(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 65535;
+  for(i=0, w=1; i<4; ++i, w+=16){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    int curInputValue2 = in[w+2];
+    int curInputValue3 = in[w+3];
+    int curInputValue4 = in[w+4];
+    int curInputValue5 = in[w+5];
+    int curInputValue6 = in[w+6];
+    int curInputValue7 = in[w+7];
+    int curInputValue8 = in[w+8];
+    int curInputValue9 = in[w+9];
+    int curInputValue10 = in[w+10];
+    int curInputValue11 = in[w+11];
+    int curInputValue12 = in[w+12];
+    int curInputValue13 = in[w+13];
+    int curInputValue14 = in[w+14];
+    int curInputValue15 = in[w+15];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = curInputValue0 >>> 16;
+    out[2+outOffset] = curInputValue1 & mask;
+    out[3+outOffset] = curInputValue1 >>> 16;
+    out[4+outOffset] = curInputValue2 & mask;
+    out[5+outOffset] = curInputValue2 >>> 16;
+    out[6+outOffset] = curInputValue3 & mask;
+    out[7+outOffset] = curInputValue3 >>> 16;
+    out[8+outOffset] = curInputValue4 & mask;
+    out[9+outOffset] = curInputValue4 >>> 16;
+    out[10+outOffset] = curInputValue5 & mask;
+    out[11+outOffset] = curInputValue5 >>> 16;
+    out[12+outOffset] = curInputValue6 & mask;
+    out[13+outOffset] = curInputValue6 >>> 16;
+    out[14+outOffset] = curInputValue7 & mask;
+    out[15+outOffset] = curInputValue7 >>> 16;
+    out[16+outOffset] = curInputValue8 & mask;
+    out[17+outOffset] = curInputValue8 >>> 16;
+    out[18+outOffset] = curInputValue9 & mask;
+    out[19+outOffset] = curInputValue9 >>> 16;
+    out[20+outOffset] = curInputValue10 & mask;
+    out[21+outOffset] = curInputValue10 >>> 16;
+    out[22+outOffset] = curInputValue11 & mask;
+    out[23+outOffset] = curInputValue11 >>> 16;
+    out[24+outOffset] = curInputValue12 & mask;
+    out[25+outOffset] = curInputValue12 >>> 16;
+    out[26+outOffset] = curInputValue13 & mask;
+    out[27+outOffset] = curInputValue13 >>> 16;
+    out[28+outOffset] = curInputValue14 & mask;
+    out[29+outOffset] = curInputValue14 >>> 16;
+    out[30+outOffset] = curInputValue15 & mask;
+    out[31+outOffset] = curInputValue15 >>> 16;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack20(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 1048575;
+  for(i=0, w=1; i<4; ++i, w+=20){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    int curInputValue2 = in[w+2];
+    int curInputValue3 = in[w+3];
+    int curInputValue4 = in[w+4];
+    int curInputValue5 = in[w+5];
+    int curInputValue6 = in[w+6];
+    int curInputValue7 = in[w+7];
+    int curInputValue8 = in[w+8];
+    int curInputValue9 = in[w+9];
+    int curInputValue10 = in[w+10];
+    int curInputValue11 = in[w+11];
+    int curInputValue12 = in[w+12];
+    int curInputValue13 = in[w+13];
+    int curInputValue14 = in[w+14];
+    int curInputValue15 = in[w+15];
+    int curInputValue16 = in[w+16];
+    int curInputValue17 = in[w+17];
+    int curInputValue18 = in[w+18];
+    int curInputValue19 = in[w+19];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = ((curInputValue0 >>> 20) | (curInputValue1 << 12)) & mask;
+    out[2+outOffset] = (curInputValue1 >>> 8) & mask;
+    out[3+outOffset] = ((curInputValue1 >>> 28) | (curInputValue2 << 4)) & mask;
+    out[4+outOffset] = ((curInputValue2 >>> 16) | (curInputValue3 << 16)) & mask;
+    out[5+outOffset] = (curInputValue3 >>> 4) & mask;
+    out[6+outOffset] = ((curInputValue3 >>> 24) | (curInputValue4 << 8)) & mask;
+    out[7+outOffset] = curInputValue4 >>> 12;
+    out[8+outOffset] = curInputValue5 & mask;
+    out[9+outOffset] = ((curInputValue5 >>> 20) | (curInputValue6 << 12)) & mask;
+    out[10+outOffset] = (curInputValue6 >>> 8) & mask;
+    out[11+outOffset] = ((curInputValue6 >>> 28) | (curInputValue7 << 4)) & mask;
+    out[12+outOffset] = ((curInputValue7 >>> 16) | (curInputValue8 << 16)) & mask;
+    out[13+outOffset] = (curInputValue8 >>> 4) & mask;
+    out[14+outOffset] = ((curInputValue8 >>> 24) | (curInputValue9 << 8)) & mask;
+    out[15+outOffset] = curInputValue9 >>> 12;
+    out[16+outOffset] = curInputValue10 & mask;
+    out[17+outOffset] = ((curInputValue10 >>> 20) | (curInputValue11 << 12)) & mask;
+    out[18+outOffset] = (curInputValue11 >>> 8) & mask;
+    out[19+outOffset] = ((curInputValue11 >>> 28) | (curInputValue12 << 4)) & mask;
+    out[20+outOffset] = ((curInputValue12 >>> 16) | (curInputValue13 << 16)) & mask;
+    out[21+outOffset] = (curInputValue13 >>> 4) & mask;
+    out[22+outOffset] = ((curInputValue13 >>> 24) | (curInputValue14 << 8)) & mask;
+    out[23+outOffset] = curInputValue14 >>> 12;
+    out[24+outOffset] = curInputValue15 & mask;
+    out[25+outOffset] = ((curInputValue15 >>> 20) | (curInputValue16 << 12)) & mask;
+    out[26+outOffset] = (curInputValue16 >>> 8) & mask;
+    out[27+outOffset] = ((curInputValue16 >>> 28) | (curInputValue17 << 4)) & mask;
+    out[28+outOffset] = ((curInputValue17 >>> 16) | (curInputValue18 << 16)) & mask;
+    out[29+outOffset] = (curInputValue18 >>> 4) & mask;
+    out[30+outOffset] = ((curInputValue18 >>> 24) | (curInputValue19 << 8)) & mask;
+    out[31+outOffset] = curInputValue19 >>> 12;
+    outOffset += 32;
+  }
+  }
+ 
+  static private void unpack28(int[] out, int[] in)
+  {
+  int i, w;
+  int outOffset = 0;
+  final int mask = 268435455;
+  for(i=0, w=1; i<4; ++i, w+=28){
+    int curInputValue0 = in[w];
+    int curInputValue1 = in[w+1];
+    int curInputValue2 = in[w+2];
+    int curInputValue3 = in[w+3];
+    int curInputValue4 = in[w+4];
+    int curInputValue5 = in[w+5];
+    int curInputValue6 = in[w+6];
+    int curInputValue7 = in[w+7];
+    int curInputValue8 = in[w+8];
+    int curInputValue9 = in[w+9];
+    int curInputValue10 = in[w+10];
+    int curInputValue11 = in[w+11];
+    int curInputValue12 = in[w+12];
+    int curInputValue13 = in[w+13];
+    int curInputValue14 = in[w+14];
+    int curInputValue15 = in[w+15];
+    int curInputValue16 = in[w+16];
+    int curInputValue17 = in[w+17];
+    int curInputValue18 = in[w+18];
+    int curInputValue19 = in[w+19];
+    int curInputValue20 = in[w+20];
+    int curInputValue21 = in[w+21];
+    int curInputValue22 = in[w+22];
+    int curInputValue23 = in[w+23];
+    int curInputValue24 = in[w+24];
+    int curInputValue25 = in[w+25];
+    int curInputValue26 = in[w+26];
+    int curInputValue27 = in[w+27];
+    out[0+outOffset] = curInputValue0 & mask;
+    out[1+outOffset] = ((curInputValue0 >>> 28) | (curInputValue1 << 4)) & mask;
+    out[2+outOffset] = ((curInputValue1 >>> 24) | (curInputValue2 << 8)) & mask;
+    out[3+outOffset] = ((curInputValue2 >>> 20) | (curInputValue3 << 12)) & mask;
+    out[4+outOffset] = ((curInputValue3 >>> 16) | (curInputValue4 << 16)) & mask;
+    out[5+outOffset] = ((curInputValue4 >>> 12) | (curInputValue5 << 20)) & mask;
+    out[6+outOffset] = ((curInputValue5 >>> 8) | (curInputValue6 << 24)) & mask;
+    out[7+outOffset] = curInputValue6 >>> 4;
+    out[8+outOffset] = curInputValue7 & mask;
+    out[9+outOffset] = ((curInputValue7 >>> 28) | (curInputValue8 << 4)) & mask;
+    out[10+outOffset] = ((curInputValue8 >>> 24) | (curInputValue9 << 8)) & mask;
+    out[11+outOffset] = ((curInputValue9 >>> 20) | (curInputValue10 << 12)) & mask;
+    out[12+outOffset] = ((curInputValue10 >>> 16) | (curInputValue11 << 16)) & mask;
+    out[13+outOffset] = ((curInputValue11 >>> 12) | (curInputValue12 << 20)) & mask;
+    out[14+outOffset] = ((curInputValue12 >>> 8) | (curInputValue13 << 24)) & mask;
+    out[15+outOffset] = curInputValue13 >>> 4;
+    out[16+outOffset] = curInputValue14 & mask;
+    out[17+outOffset] = ((curInputValue14 >>> 28) | (curInputValue15 << 4)) & mask;
+    out[18+outOffset] = ((curInputValue15 >>> 24) | (curInputValue16 << 8)) & mask;
+    out[19+outOffset] = ((curInputValue16 >>> 20) | (curInputValue17 << 12)) & mask;
+    out[20+outOffset] = ((curInputValue17 >>> 16) | (curInputValue18 << 16)) & mask;
+    out[21+outOffset] = ((curInputValue18 >>> 12) | (curInputValue19 << 20)) & mask;
+    out[22+outOffset] = ((curInputValue19 >>> 8) | (curInputValue20 << 24)) & mask;
+    out[23+outOffset] = curInputValue20 >>> 4;
+    out[24+outOffset] = curInputValue21 & mask;
+    out[25+outOffset] = ((curInputValue21 >>> 28) | (curInputValue22 << 4)) & mask;
+    out[26+outOffset] = ((curInputValue22 >>> 24) | (curInputValue23 << 8)) & mask;
+    out[27+outOffset] = ((curInputValue23 >>> 20) | (curInputValue24 << 12)) & mask;
+    out[28+outOffset] = ((curInputValue24 >>> 16) | (curInputValue25 << 16)) & mask;
+    out[29+outOffset] = ((curInputValue25 >>> 12) | (curInputValue26 << 20)) & mask;
+    out[30+outOffset] = ((curInputValue26 >>> 8) | (curInputValue27 << 24)) & mask;
+    out[31+outOffset] = curInputValue27 >>> 4;
+    outOffset += 32;
+  }
+  }
+}

Property changes on: lucene/src/java/org/apache/lucene/util/pfor2/Unpack128.java
___________________________________________________________________
Added: svn:eol-style
   + native

