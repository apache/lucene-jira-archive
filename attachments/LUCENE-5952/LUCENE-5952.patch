Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 1626137)
+++ lucene/CHANGES.txt	(working copy)
@@ -145,6 +145,11 @@
   for every IndexWriter method: instead such disasters will cause IW to close itself
   defensively. (Robert Muir, Mike McCandless)
 
+* LUCENE-5952: Improve error messages when version cannot be parsed;
+  don't check for too old or too new major version (it's too low level
+  to enforce here); use simple string tokenizer.  (Ryan Ernst, Uwe Schindler,
+  Robert Muir, Mike McCandless)
+
 Documentation
 
 * LUCENE-5392: Add/improve analysis package documentation to reflect

Property changes on: lucene/CHANGES.txt
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/dev/branches/lucene_solr_4_10/lucene/CHANGES.txt:r1626006
Index: lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AbstractAnalysisFactory.java
===================================================================
--- lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AbstractAnalysisFactory.java	(revision 1626137)
+++ lucene/analysis/common/src/java/org/apache/lucene/analysis/util/AbstractAnalysisFactory.java	(working copy)
@@ -17,10 +17,6 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.analysis.core.StopFilter;
-import org.apache.lucene.util.IOUtils;
-import org.apache.lucene.util.Version;
-
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -28,6 +24,7 @@
 import java.nio.charset.CharsetDecoder;
 import java.nio.charset.CodingErrorAction;
 import java.nio.charset.StandardCharsets;
+import java.text.ParseException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -40,6 +37,10 @@
 import java.util.regex.Pattern;
 import java.util.regex.PatternSyntaxException;
 
+import org.apache.lucene.analysis.core.StopFilter;
+import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.Version;
+
 /**
  * Abstract parent class for analysis factories {@link TokenizerFactory},
  * {@link TokenFilterFactory} and {@link CharFilterFactory}.
@@ -68,7 +69,15 @@
   protected AbstractAnalysisFactory(Map<String,String> args) {
     originalArgs = Collections.unmodifiableMap(new HashMap<>(args));
     String version = get(args, LUCENE_MATCH_VERSION_PARAM);
-    luceneMatchVersion = version == null ? null : Version.parseLeniently(version);
+    if (version == null) {
+      luceneMatchVersion = null;
+    } else {
+      try {
+        luceneMatchVersion = Version.parseLeniently(version);
+      } catch (ParseException pe) {
+        throw new IllegalArgumentException(pe);
+      }
+    }
     args.remove(CLASS_NAME);  // consume the class arg
   }
   
Index: lucene/analysis
===================================================================
--- lucene/analysis	(revision 1626137)
+++ lucene/analysis	(working copy)

Property changes on: lucene/analysis
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/dev/branches/lucene_solr_4_10/lucene/analysis:r1626006
Index: lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java
===================================================================
--- lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java	(revision 1626137)
+++ lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import java.io.IOException;
+import java.text.ParseException;
 import java.util.Map;
 import java.util.Set;
 
@@ -55,7 +56,12 @@
       CodecUtil.checkHeader(input, Lucene40SegmentInfoFormat.CODEC_NAME,
                                    Lucene40SegmentInfoFormat.VERSION_START,
                                    Lucene40SegmentInfoFormat.VERSION_CURRENT);
-      final Version version = Version.parse(input.readString());
+      final Version version;
+      try {
+        version = Version.parse(input.readString());
+      } catch (ParseException pe) {
+        throw new CorruptIndexException("unable to parse version string (resource=" + input + "): " + pe.getMessage(), pe);
+      }
       final int docCount = input.readInt();
       if (docCount < 0) {
         throw new CorruptIndexException("invalid docCount: " + docCount + " (resource=" + input + ")");
Index: lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask.java
===================================================================
--- lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask.java	(revision 1626137)
+++ lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTask.java	(working copy)
@@ -17,6 +17,15 @@
  * limitations under the License.
  */
 
+import java.io.BufferedOutputStream;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.nio.charset.Charset;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.text.ParseException;
+
 import org.apache.lucene.benchmark.byTask.PerfRunData;
 import org.apache.lucene.benchmark.byTask.utils.Config;
 import org.apache.lucene.codecs.Codec;
@@ -26,8 +35,8 @@
 import org.apache.lucene.index.IndexCommit;
 import org.apache.lucene.index.IndexDeletionPolicy;
 import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.index.IndexWriterConfig;
-import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.index.LogMergePolicy;
 import org.apache.lucene.index.MergePolicy;
 import org.apache.lucene.index.MergeScheduler;
@@ -36,14 +45,6 @@
 import org.apache.lucene.index.NoMergeScheduler;
 import org.apache.lucene.util.Version;
 
-import java.io.BufferedOutputStream;
-import java.io.IOException;
-import java.io.PrintStream;
-import java.nio.charset.Charset;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-
 /**
  * Create an index. <br>
  * Other side effects: index writer object in perfRunData is set. <br>
@@ -100,6 +101,12 @@
   
   public static IndexWriterConfig createWriterConfig(Config config, PerfRunData runData, OpenMode mode, IndexCommit commit) {
     @SuppressWarnings("deprecation")
+    Version version;
+    try {
+      version = Version.parseLeniently(config.get("writer.version", Version.LATEST.toString()));
+    } catch (ParseException pe) {
+      throw new IllegalArgumentException(pe);
+    }
     IndexWriterConfig iwConf = new IndexWriterConfig(runData.getAnalyzer());
     iwConf.setOpenMode(mode);
     IndexDeletionPolicy indexDeletionPolicy = getIndexDeletionPolicy(config);
Index: lucene/benchmark
===================================================================
--- lucene/benchmark	(revision 1626137)
+++ lucene/benchmark	(working copy)

Property changes on: lucene/benchmark
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/dev/branches/lucene_solr_4_10/lucene/benchmark:r1626006
Index: lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoReader.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoReader.java	(revision 1626137)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoReader.java	(working copy)
@@ -19,6 +19,7 @@
 
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
+import java.text.ParseException;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
@@ -25,6 +26,7 @@
 import java.util.Set;
 
 import org.apache.lucene.codecs.SegmentInfoReader;
+import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.ChecksumIndexInput;
@@ -62,7 +64,12 @@
     try {
       SimpleTextUtil.readLine(input, scratch);
       assert StringHelper.startsWith(scratch.get(), SI_VERSION);
-      final Version version = Version.parse(readString(SI_VERSION.length, scratch));
+      final Version version;
+      try {
+        version = Version.parse(readString(SI_VERSION.length, scratch));
+      } catch (ParseException pe) {
+        throw new CorruptIndexException("unable to parse version string (resource=" + input + "): " + pe.getMessage(), pe);
+      }
     
       SimpleTextUtil.readLine(input, scratch);
       assert StringHelper.startsWith(scratch.get(), SI_DOCCOUNT);
Index: lucene/codecs
===================================================================
--- lucene/codecs	(revision 1626137)
+++ lucene/codecs	(working copy)

Property changes on: lucene/codecs
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/dev/branches/lucene_solr_4_10/lucene/codecs:r1626006
Index: lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoFormat.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoFormat.java	(revision 1626137)
+++ lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoFormat.java	(working copy)
@@ -25,6 +25,7 @@
 import org.apache.lucene.index.SegmentInfo; // javadocs
 import org.apache.lucene.index.SegmentInfos; // javadocs
 import org.apache.lucene.store.DataOutput; // javadocs
+import org.apache.lucene.util.Version;
 
 /**
  * Lucene 4.6 Segment info format.
@@ -39,7 +40,7 @@
  * <ul>
  *   <li>Header --&gt; {@link CodecUtil#writeHeader CodecHeader}</li>
  *   <li>SegSize --&gt; {@link DataOutput#writeInt Int32}</li>
- *   <li>SegVersion --&gt; {@link DataOutput#writeString String}</li>
+ *   <li>SegVersion --&gt; {@link DataOutput#writeVInt VInt} * 4 </li>
  *   <li>Files --&gt; {@link DataOutput#writeStringSet Set&lt;String&gt;}</li>
  *   <li>Diagnostics --&gt; {@link DataOutput#writeStringStringMap Map&lt;String,String&gt;}</li>
  *   <li>IsCompoundFile --&gt; {@link DataOutput#writeByte Int8}</li>
@@ -50,7 +51,8 @@
  * Field Descriptions:
  * <p>
  * <ul>
- *   <li>SegVersion is the code version that created the segment.</li>
+ *   <li>SegVersion is the code version that created the segment, written as 4 unsigned bytes
+ *       containing major, minor, bugfix, prerelease values from {@link Version}</li>
  *   <li>SegSize is the number of documents contained in the segment index.</li>
  *   <li>IsCompoundFile records whether the segment is written as a compound file or
  *       not. If this is -1, the segment is not a compound file. If it is 1, the segment
@@ -90,5 +92,6 @@
   static final int VERSION_START = 0;
   static final int VERSION_CHECKSUM = 1;
   static final int VERSION_ID = 2;
-  static final int VERSION_CURRENT = VERSION_ID;
+  static final int VERSION_EXPLICIT_VERSION = 3;
+  static final int VERSION_CURRENT = VERSION_EXPLICIT_VERSION;
 }
Index: lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java	(revision 1626137)
+++ lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import java.io.IOException;
+import java.text.ParseException;
 import java.util.Map;
 import java.util.Set;
 
@@ -53,7 +54,24 @@
       int codecVersion = CodecUtil.checkHeader(input, Lucene46SegmentInfoFormat.CODEC_NAME,
                                                       Lucene46SegmentInfoFormat.VERSION_START,
                                                       Lucene46SegmentInfoFormat.VERSION_CURRENT);
-      final Version version = Version.parse(input.readString());
+      final Version version;
+
+      if (codecVersion >= Lucene46SegmentInfoFormat.VERSION_EXPLICIT_VERSION) {
+        // We switched to encoding version directly so there's no string parsing at read time:
+        try {
+          version = Version.read(input);
+        } catch (IllegalArgumentException iae) {
+          throw new CorruptIndexException("unable to create valid version (resource: " + fileName + ")", iae);
+        }
+      } else {
+        // Before, version was written as String:
+        try {
+          version = Version.parse(input.readString());
+        } catch (ParseException pe) {
+          throw new CorruptIndexException("unable to parse version string (resource=" + input + "): " + pe.getMessage(), pe);
+        }
+      }
+
       final int docCount = input.readInt();
       if (docCount < 0) {
         throw new CorruptIndexException("invalid docCount: " + docCount + " (resource=" + input + ")");
Index: lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java	(revision 1626137)
+++ lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java	(working copy)
@@ -58,7 +58,7 @@
         throw new IllegalArgumentException("invalid major version: should be 4 or 5 but got: " + version.major + " segment=" + si);
       }
       // Write the Lucene version that created this segment, since 3.1
-      output.writeString(version.toString());
+      Version.write(version, output);
       output.writeInt(si.getDocCount());
 
       output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));
Index: lucene/core/src/java/org/apache/lucene/util/StrictStringTokenizer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/StrictStringTokenizer.java	(revision 1626006)
+++ lucene/core/src/java/org/apache/lucene/util/StrictStringTokenizer.java	(working copy)
@@ -19,8 +19,7 @@
 
 /** Used for parsing Version strings so we don't have to
  *  use overkill String.split nor StringTokenizer (which silently
- *  skips empty tokens).  This also may sidestep a possible
- *  1.8.0_20 JVM bug in String.split. */
+ *  skips empty tokens). */
 
 final class StrictStringTokenizer {
 
Index: lucene/core/src/java/org/apache/lucene/util/Version.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/Version.java	(revision 1626137)
+++ lucene/core/src/java/org/apache/lucene/util/Version.java	(working copy)
@@ -18,8 +18,13 @@
  */
 
 
+import java.io.IOException;
+import java.text.ParseException;
 import java.util.Locale;
 
+import org.apache.lucene.store.DataInput;
+import org.apache.lucene.store.DataOutput;
+
 /**
  * Use by certain classes to match version compatibility
  * across releases of Lucene.
@@ -260,28 +265,72 @@
    * Part {@code ".bugfix"} and part {@code ".prerelease"} are optional.
    * Note that this is forwards compatible: the parsed version does not have to exist as
    * a constant.
+   *
+   * @lucene.internal
    */
-  public static Version parse(String version) {
-    String[] pieces = version.split("\\.");
-    if (pieces.length < 2 || pieces.length > 4) {
-      throw new IllegalArgumentException("Version is not in form major.minor.bugfix(.prerelease): " + version);
+  public static Version parse(String version) throws ParseException {
+
+    StrictStringTokenizer tokens = new StrictStringTokenizer(version, '.');
+    if (tokens.hasMoreTokens() == false) {
+      throw new ParseException("Version is not in form major.minor.bugfix(.prerelease) (got: " + version + ")", 0);
     }
 
-    int major = Integer.parseInt(pieces[0]);
-    int minor = Integer.parseInt(pieces[1]);
+    int major;
+    String token = tokens.nextToken();
+    try {
+      major = Integer.parseInt(token);
+    } catch (NumberFormatException nfe) {
+      throw new ParseException("Failed to parse major version from \"" + token + "\" (got: " + version + ")", 0);
+    }
+
+    if (tokens.hasMoreTokens() == false) {
+      throw new ParseException("Version is not in form major.minor.bugfix(.prerelease) (got: " + version + ")", 0);
+    }
+
+    int minor;
+    token = tokens.nextToken();
+    try {
+      minor = Integer.parseInt(token);
+    } catch (NumberFormatException nfe) {
+      throw new ParseException("Failed to parse minor version from \"" + token + "\" (got: " + version + ")", 0);
+    }
+
     int bugfix = 0;
     int prerelease = 0;
-    if (pieces.length > 2) {
-      bugfix = Integer.parseInt(pieces[2]);
-    }
-    if (pieces.length > 3) {
-      prerelease = Integer.parseInt(pieces[3]);
-      if (prerelease == 0) {
-        throw new IllegalArgumentException("Invalid value " + prerelease + " for prerelease of version " + version +", should be 1 or 2");
+    if (tokens.hasMoreTokens()) {
+
+      token = tokens.nextToken();
+      try {
+        bugfix = Integer.parseInt(token);
+      } catch (NumberFormatException nfe) {
+        throw new ParseException("Failed to parse bugfix version from \"" + token + "\" (got: " + version + ")", 0);
       }
+
+      if (tokens.hasMoreTokens()) {
+        token = tokens.nextToken();
+        try {
+          prerelease = Integer.parseInt(token);
+        } catch (NumberFormatException nfe) {
+          throw new ParseException("Failed to parse prerelease version from \"" + token + "\" (got: " + version + ")", 0);
+        }
+        if (prerelease == 0) {
+          throw new ParseException("Invalid value " + prerelease + " for prerelease; should be 1 or 2 (got: " + version + ")", 0);
+        }
+
+        if (tokens.hasMoreTokens()) {
+          // Too many tokens!
+          throw new ParseException("Version is not in form major.minor.bugfix(.prerelease) (got: " + version + ")", 0);
+        }
+      }
     }
 
-    return new Version(major, minor, bugfix, prerelease);
+    try {
+      return new Version(major, minor, bugfix, prerelease);
+    } catch (IllegalArgumentException iae) {
+      ParseException pe = new ParseException("failed to parse version string \"" + version + "\": " + iae.getMessage(), 0);
+      pe.initCause(iae);
+      throw pe;
+    }
   }
 
   /**
@@ -288,8 +337,11 @@
    * Parse the given version number as a constant or dot based version.
    * <p>This method allows to use {@code "LUCENE_X_Y"} constant names,
    * or version numbers in the format {@code "x.y.z"}.
+   *
+   * @lucene.internal
    */
-  public static Version parseLeniently(String version) {
+  public static Version parseLeniently(String version) throws ParseException {
+    String versionOrig = version;
     version = version.toUpperCase(Locale.ROOT);
     switch (version) {
       case "LATEST":
@@ -306,7 +358,13 @@
           .replaceFirst("^LUCENE_(\\d+)_(\\d+)_(\\d+)$", "$1.$2.$3")
           .replaceFirst("^LUCENE_(\\d+)_(\\d+)$", "$1.$2.0")
           .replaceFirst("^LUCENE_(\\d)(\\d)$", "$1.$2.0");
-        return parse(version);
+        try {
+          return parse(version);
+        } catch (ParseException pe) {
+          ParseException pe2 = new ParseException("failed to parse lenient version string \"" + versionOrig + "\": " + pe.getMessage(), 0);
+          pe2.initCause(pe);
+          throw pe2;
+        }
     }
   }
 
@@ -333,23 +391,28 @@
     this.minor = minor;
     this.bugfix = bugfix;
     this.prerelease = prerelease;
-    if (major > 5 || major < 4) {
-      throw new IllegalArgumentException("Lucene 5.x only supports 5.x and 4.x versions");
+
+    // NOTE: do not enforce major version so we remain future proof, except to
+    // make sure it fits in the 8 bits we encode it into:
+    if (major > 255 || major < 0) {
+      throw new IllegalArgumentException("Illegal major version: " + major);
     }
-    if (minor > 255 | minor < 0) {
+    if (minor > 255 || minor < 0) {
       throw new IllegalArgumentException("Illegal minor version: " + minor);
     }
-    if (bugfix > 255 | bugfix < 0) {
+    if (bugfix > 255 || bugfix < 0) {
       throw new IllegalArgumentException("Illegal bugfix version: " + bugfix);
     }
-    if (prerelease > 2 | prerelease < 0) {
+    if (prerelease > 2 || prerelease < 0) {
       throw new IllegalArgumentException("Illegal prerelease version: " + prerelease);
     }
     if (prerelease != 0 && (minor != 0 || bugfix != 0)) {
-      throw new IllegalArgumentException("Prerelease version only supported with major release");
+      throw new IllegalArgumentException("Prerelease version only supported with major release (got prerelease: " + prerelease + ", minor: " + minor + ", bugfix: " + bugfix + ")");
     }
 
     encodedValue = major << 18 | minor << 10 | bugfix << 2 | prerelease;
+
+    assert encodedIsValid();
   }
 
   /**
@@ -361,10 +424,6 @@
 
   @Override
   public String toString() {
-    int major = (encodedValue >>> 18) & 0xFF;
-    int minor = (encodedValue >>> 10) & 0xFF;
-    int bugfix = (encodedValue >>> 2) & 0xFF;
-    int prerelease = encodedValue & 0x3;
     if (prerelease == 0) {
       return "" + major + "." + minor + "." + bugfix;
     }
@@ -376,8 +435,37 @@
     return o != null && o instanceof Version && ((Version)o).encodedValue == encodedValue;
   }
 
+  // Used only by assert:
+  private boolean encodedIsValid() {
+    assert major == ((encodedValue >>> 18) & 0xFF);
+    assert minor == ((encodedValue >>> 10) & 0xFF);
+    assert bugfix == ((encodedValue >>> 2) & 0xFF);
+    assert prerelease == (encodedValue & 0x03);
+    return true;
+  }
+
   @Override
   public int hashCode() {
     return encodedValue;
   }
+
+  /** Writes this {@code Version} to the privded {@link DataOutput}. */
+  public static void write(Version version, DataOutput out) throws IOException {
+    // NOTE: do NOT change this format; Codec components rely on this to work across versions:
+    out.writeByte((byte) version.major);
+    out.writeByte((byte) version.minor);
+    out.writeByte((byte) version.bugfix);
+    out.writeByte((byte) version.prerelease);
+  }
+
+  /** Returns a {@code Version} previoiusly written with {@link #write}. */
+  public static Version read(DataInput in) throws IOException {
+    // NOTE: do NOT change this format; Codec components rely on this to work across versions:
+    int major = in.readByte() & 0xff;
+    int minor = in.readByte() & 0xff;
+    int bugfix = in.readByte() & 0xff;
+    int prerelease = in.readByte() & 0xff;
+
+    return new Version(major, minor, bugfix, prerelease);
+  }
 }
Index: lucene/core/src/test/org/apache/lucene/util/TestVersion.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/util/TestVersion.java	(revision 1626137)
+++ lucene/core/src/test/org/apache/lucene/util/TestVersion.java	(working copy)
@@ -1,3 +1,5 @@
+package org.apache.lucene.util;
+
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -15,10 +17,9 @@
  * limitations under the License.
  */
 
-package org.apache.lucene.util;
-
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
+import java.text.ParseException;
 import java.util.Locale;
 import java.util.Random;
 
@@ -48,7 +49,7 @@
     assertEquals("4.0.0.2", Version.LUCENE_4_0_0.toString());
   }
 
-  public void testParseLeniently() {
+  public void testParseLeniently() throws Exception {
     assertEquals(Version.LUCENE_4_9_0, Version.parseLeniently("LUCENE_49"));
     assertEquals(Version.LUCENE_4_9_0, Version.parseLeniently("LUCENE_4_9"));
     assertEquals(Version.LUCENE_4_9_0, Version.parseLeniently("LUCENE_4_9_0"));
@@ -72,21 +73,31 @@
     try {
       Version.parseLeniently("LUCENE");
       fail();
-    } catch (IllegalArgumentException iae) {
+    } catch (ParseException pe) {
       // pass
+      assertTrue(pe.getMessage().contains("LUCENE"));
     }
     try {
       Version.parseLeniently("LUCENE_410");
       fail();
-    } catch (IllegalArgumentException iae) {
+    } catch (ParseException pe) {
       // pass
+      assertTrue(pe.getMessage().contains("LUCENE_410"));
     }
     try {
       Version.parseLeniently("LUCENE41");
       fail();
-    } catch (IllegalArgumentException iae) {
+    } catch (ParseException pe) {
       // pass
+      assertTrue(pe.getMessage().contains("LUCENE41"));
     }
+    try {
+      Version.parseLeniently("LUCENE_6.0.0");
+      fail();
+    } catch (ParseException pe) {
+      // pass
+      assertTrue(pe.getMessage().contains("LUCENE_6.0.0"));
+    }
   }
 
   public void testParseLenientlyOnAllConstants() throws Exception {
@@ -103,7 +114,7 @@
     assertTrue(atLeastOne);
   }
 
-  public void testParse() {
+  public void testParse() throws Exception {
     assertEquals(Version.LUCENE_5_0_0, Version.parse("5.0.0"));
     assertEquals(Version.LUCENE_4_1_0, Version.parse("4.1"));
     assertEquals(Version.LUCENE_4_1_0, Version.parse("4.1.0"));
@@ -110,9 +121,13 @@
     assertEquals(Version.LUCENE_4_0_0_ALPHA, Version.parse("4.0.0"));
     assertEquals(Version.LUCENE_4_0_0_BETA, Version.parse("4.0.0.1"));
     assertEquals(Version.LUCENE_4_0_0, Version.parse("4.0.0.2"));
+    
+    // Version does not pass judgement on the major version:
+    assertEquals(1, Version.parse("1.0").major);
+    assertEquals(6, Version.parse("6.0.0").major);
   }
 
-  public void testForwardsCompatibility() {
+  public void testForwardsCompatibility() throws Exception {
     assertTrue(Version.parse("4.7.10").onOrAfter(Version.LUCENE_4_7_2));
     assertTrue(Version.parse("4.20.0").onOrAfter(Version.LUCENE_4_8_1));
     assertTrue(Version.parse("5.10.20").onOrAfter(Version.LUCENE_5_0_0));
@@ -120,81 +135,100 @@
 
   public void testParseExceptions() {
     try {
-      Version.parse("1.0");
-      fail();
-    } catch (IllegalArgumentException iae) {
-      // pass
-    }
-
-    try {
       Version.parse("LUCENE_4_0_0");
       fail();
-    } catch (IllegalArgumentException iae) {
+    } catch (ParseException pe) {
       // pass
+      assertTrue(pe.getMessage().contains("LUCENE_4_0_0"));
     }
 
     try {
       Version.parse("4.256");
       fail();
-    } catch (IllegalArgumentException iae) {
+    } catch (ParseException pe) {
       // pass
+      assertTrue(pe.getMessage().contains("4.256"));
     }
 
     try {
       Version.parse("4.-1");
       fail();
-    } catch (IllegalArgumentException iae) {
+    } catch (ParseException pe) {
       // pass
+      assertTrue(pe.getMessage().contains("4.-1"));
     }
 
     try {
       Version.parse("4.1.256");
       fail();
-    } catch (IllegalArgumentException iae) {
+    } catch (ParseException pe) {
       // pass
+      assertTrue(pe.getMessage().contains("4.1.256"));
     }
 
     try {
       Version.parse("4.1.-1");
       fail();
-    } catch (IllegalArgumentException iae) {
+    } catch (ParseException pe) {
       // pass
+      assertTrue(pe.getMessage().contains("4.1.-1"));
     }
 
     try {
       Version.parse("4.1.1.3");
       fail();
-    } catch (IllegalArgumentException iae) {
+    } catch (ParseException pe) {
       // pass
+      assertTrue(pe.getMessage().contains("4.1.1.3"));
     }
 
     try {
       Version.parse("4.1.1.-1");
       fail();
-    } catch (IllegalArgumentException iae) {
+    } catch (ParseException pe) {
       // pass
+      assertTrue(pe.getMessage().contains("4.1.1.-1"));
     }
 
     try {
       Version.parse("4.1.1.1");
       fail();
-    } catch (IllegalArgumentException iae) {
+    } catch (ParseException pe) {
       // pass
+      assertTrue(pe.getMessage().contains("4.1.1.1"));
     }
 
     try {
       Version.parse("4.1.1.2");
       fail();
-    } catch (IllegalArgumentException iae) {
+    } catch (ParseException pe) {
       // pass
+      assertTrue(pe.getMessage().contains("4.1.1.2"));
     }
 
     try {
       Version.parse("4.0.0.0");
       fail();
-    } catch (IllegalArgumentException iae) {
+    } catch (ParseException pe) {
       // pass
+      assertTrue(pe.getMessage().contains("4.0.0.0"));
     }
+
+    try {
+      Version.parse("4.0.0.1.42");
+      fail();
+    } catch (ParseException pe) {
+      // pass
+      assertTrue(pe.getMessage().contains("4.0.0.1.42"));
+    }
+
+    try {
+      Version.parse("4..0.1");
+      fail();
+    } catch (ParseException pe) {
+      // pass
+      assertTrue(pe.getMessage().contains("4..0.1"));
+    }
   }
   
   public void testDeprecations() throws Exception {
@@ -224,7 +258,7 @@
         Version.LATEST.toString(), commonBuildVersion);
   }
 
-  public void testEqualsHashCode() {
+  public void testEqualsHashCode() throws Exception {
     Random random = random();
     String version = "" + (4 + random.nextInt(1)) + "."  + random.nextInt(10) + "." + random.nextInt(10);
     Version v1 = Version.parseLeniently(version);
Index: lucene/core
===================================================================
--- lucene/core	(revision 1626137)
+++ lucene/core	(working copy)

Property changes on: lucene/core
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/dev/branches/lucene_solr_4_10/lucene/core:r1626006,1626038
Index: lucene
===================================================================
--- lucene	(revision 1626137)
+++ lucene	(working copy)

Property changes on: lucene
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/dev/branches/lucene_solr_4_10/lucene:r1626006,1626038
Index: solr/core/src/java/org/apache/solr/core/Config.java
===================================================================
--- solr/core/src/java/org/apache/solr/core/Config.java	(revision 1626137)
+++ solr/core/src/java/org/apache/solr/core/Config.java	(working copy)
@@ -48,6 +48,7 @@
 import javax.xml.xpath.XPathFactory;
 
 import java.io.IOException;
+import java.text.ParseException;
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.Map;
@@ -441,9 +442,9 @@
     final Version version;
     try {
       version = Version.parseLeniently(matchVersion);
-    } catch (IllegalArgumentException iae) {
+    } catch (ParseException pe) {
       throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
-        "Invalid luceneMatchVersion.  Should be of the form 'V.V.V' (e.g. 4.8.0)", iae);
+        "Invalid luceneMatchVersion.  Should be of the form 'V.V.V' (e.g. 4.8.0)", pe);
     }
     
     if (version == Version.LATEST && !versionWarningAlreadyLogged.getAndSet(true)) {
Index: solr/core
===================================================================
--- solr/core	(revision 1626137)
+++ solr/core	(working copy)

Property changes on: solr/core
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/dev/branches/lucene_solr_4_10/solr/core:r1626006
Index: solr
===================================================================
--- solr	(revision 1626137)
+++ solr	(working copy)

Property changes on: solr
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/dev/branches/lucene_solr_4_10/solr:r1626006
Index: .
===================================================================
--- .	(revision 1626137)
+++ .	(working copy)

Property changes on: .
___________________________________________________________________
Modified: svn:mergeinfo
   Merged /lucene/dev/branches/lucene_solr_4_10:r1626006,1626038
