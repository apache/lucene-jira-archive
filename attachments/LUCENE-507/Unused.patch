Index: src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java
===================================================================
--- src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java	(revision 383736)
+++ src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java	(working copy)
@@ -17,25 +17,19 @@
  */
 
 
-import org.apache.lucene.store.RAMDirectory;
-import org.apache.lucene.store.Directory;
+import java.text.DecimalFormat;
+import java.util.Random;
 
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
+import junit.framework.TestCase;
 
 import org.apache.lucene.analysis.WhitespaceAnalyzer;
-
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-
-import org.apache.lucene.queryParser.QueryParser;
-import org.apache.lucene.queryParser.ParseException;
-
-import junit.framework.TestCase;
-
-import java.text.DecimalFormat;
-import java.util.Random;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.RAMDirectory;
 
 /** Test that BooleanQuery.setMinimumNumberShouldMatch works.
  */
Index: src/test/org/apache/lucene/search/TestSort.java
===================================================================
--- src/test/org/apache/lucene/search/TestSort.java	(revision 383736)
+++ src/test/org/apache/lucene/search/TestSort.java	(working copy)
@@ -16,28 +16,29 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.store.RAMDirectory;
-import org.apache.lucene.index.*;
-import org.apache.lucene.analysis.SimpleAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-
-import java.rmi.Naming;
-import java.rmi.registry.LocateRegistry;
-import java.rmi.registry.Registry;
 import java.io.IOException;
 import java.io.Serializable;
-import java.util.regex.Pattern;
+import java.rmi.Naming;
+import java.rmi.registry.LocateRegistry;
+import java.util.BitSet;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Locale;
-import java.util.BitSet;
+import java.util.regex.Pattern;
 
-import junit.framework.TestCase;
 import junit.framework.Test;
+import junit.framework.TestCase;
 import junit.framework.TestSuite;
 import junit.textui.TestRunner;
 
+import org.apache.lucene.analysis.SimpleAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.store.RAMDirectory;
+
 /**
  * Unit tests for sorting code.
  *
@@ -663,7 +664,7 @@
 		// local.search (queryA, new Sort());
 
 		// publish it
-		Registry reg = LocateRegistry.createRegistry (1099);
+		LocateRegistry.createRegistry (1099);
 		RemoteSearchable impl = new RemoteSearchable (local);
 		Naming.rebind ("//localhost/SortedSearchable", impl);
 	}
Index: src/test/org/apache/lucene/search/TestCustomSearcherSort.java
===================================================================
--- src/test/org/apache/lucene/search/TestCustomSearcherSort.java	(revision 383736)
+++ src/test/org/apache/lucene/search/TestCustomSearcherSort.java	(working copy)
@@ -165,7 +165,6 @@
 		Hits resultSort = searcher.search (query, sort);
 		checkHits(resultSort, "Sort by custom criteria: "); // check for duplicates
 		
-        String lf = System.getProperty("line.separator", "\n");
         // besides the sorting both sets of hits must be identical
         for(int hitid=0;hitid<resultSort.length(); ++hitid) {
             Integer idHitDate = new Integer(resultSort.id(hitid)); // document ID from sorted search
Index: src/test/org/apache/lucene/search/TestMultiSearcher.java
===================================================================
--- src/test/org/apache/lucene/search/TestMultiSearcher.java	(revision 383736)
+++ src/test/org/apache/lucene/search/TestMultiSearcher.java	(working copy)
@@ -115,7 +115,7 @@
 
         // iterating over the hit documents
         for (int i = 0; i < hits.length(); i++) {
-            Document d = hits.doc(i);
+            hits.doc(i);
         }
         mSearcher.close();
 
@@ -145,7 +145,7 @@
         // iterating over the hit documents
         for (int i = 0; i < hits2.length(); i++) {
             // no exception should happen at this point
-            Document d = hits2.doc(i);
+            hits2.doc(i);
         }
         mSearcher2.close();
 
@@ -178,7 +178,7 @@
 
         // iterating over the hit documents
         for (int i = 0; i < hits3.length(); i++) {
-            Document d = hits3.doc(i);
+            hits3.doc(i);
         }
         mSearcher3.close();
     }
Index: src/test/org/apache/lucene/search/TestTermVectors.java
===================================================================
--- src/test/org/apache/lucene/search/TestTermVectors.java	(revision 383736)
+++ src/test/org/apache/lucene/search/TestTermVectors.java	(working copy)
@@ -134,19 +134,13 @@
           }
         }
         else{
-          try{
-            TermPositionVector posVec = (TermPositionVector)vector[0];
-            assertTrue(false);
-          }
-          catch(ClassCastException ignore){
+            assertFalse(vector[0] instanceof TermPositionVector);
             TermFreqVector freqVec = vector[0];
             String [] terms = freqVec.getTerms();
             assertTrue(terms != null && terms.length > 0);
           }
           
         }
-       
-      }
     } catch (IOException e) {
       assertTrue(false);
     }
@@ -213,7 +207,7 @@
       TermDocs termDocs = knownSearcher.reader.termDocs();
       //System.out.println("Terms: " + termEnum.size() + " Orig Len: " + termArray.length);
       
-      Similarity sim = knownSearcher.getSimilarity();
+      knownSearcher.getSimilarity();
       while (termEnum.next() == true)
       {
         Term term = termEnum.term();
@@ -225,11 +219,11 @@
           int freq = termDocs.freq();
           //System.out.println("Doc Id: " + docId + " freq " + freq);
           TermFreqVector vector = knownSearcher.reader.getTermFreqVector(docId, "field");
-          float tf = sim.tf(freq);
-          float idf = sim.idf(term, knownSearcher);
+          //float tf = sim.tf(freq);
+          //float idf = sim.idf(term, knownSearcher);
           //float qNorm = sim.queryNorm()
           //This is fine since we don't have stop words
-          float lNorm = sim.lengthNorm("field", vector.getTerms().length);
+          //float lNorm = sim.lengthNorm("field", vector.getTerms().length);
           //float coord = sim.coord()
           //System.out.println("TF: " + tf + " IDF: " + idf + " LenNorm: " + lNorm);
           assertTrue(vector != null);
@@ -250,7 +244,7 @@
       Hits hits = knownSearcher.search(query);
       //doc 3 should be the first hit b/c it is the shortest match
       assertTrue(hits.length() == 3);
-      float score = hits.score(0);
+      //float score = hits.score(0);
       /*System.out.println("Hit 0: " + hits.id(0) + " Score: " + hits.score(0) + " String: " + hits.doc(0).toString());
       System.out.println("Explain: " + knownSearcher.explain(query, hits.id(0)));
       System.out.println("Hit 1: " + hits.id(1) + " Score: " + hits.score(1) + " String: " + hits.doc(1).toString());
Index: src/test/org/apache/lucene/search/TestConstantScoreRangeQuery.java
===================================================================
--- src/test/org/apache/lucene/search/TestConstantScoreRangeQuery.java	(revision 383736)
+++ src/test/org/apache/lucene/search/TestConstantScoreRangeQuery.java	(working copy)
@@ -295,7 +295,7 @@
         assertEquals("num of docs", numDocs, 1+ maxId - minId);
         
 	Hits result;
-        Query q = new TermQuery(new Term("body","body"));
+    new TermQuery(new Term("body","body"));
 
         // test extremes, bounded on both ends
         
Index: src/test/org/apache/lucene/index/TestCompoundFile.java
===================================================================
--- src/test/org/apache/lucene/index/TestCompoundFile.java	(revision 383736)
+++ src/test/org/apache/lucene/index/TestCompoundFile.java	(working copy)
@@ -322,14 +322,14 @@
         IndexInput in = fsdir.openInput(file);
 
         // This read primes the buffer in IndexInput
-        byte b = in.readByte();
+        in.readByte();
 
         // Close the file
         in.close();
 
         // ERROR: this call should fail, but succeeds because the buffer
         // is still filled
-        b = in.readByte();
+        in.readByte();
 
         // ERROR: this call should fail, but succeeds for some reason as well
         in.seek(1099);
@@ -337,7 +337,7 @@
         try {
             // OK: this call correctly fails. We are now past the 1024 internal
             // buffer, so an actual IO is attempted, which fails
-            b = in.readByte();
+            in.readByte();
             fail("expected readByte() to throw exception");
         } catch (IOException e) {
           // expected exception
@@ -582,7 +582,7 @@
 
         // Open two files
         try {
-            IndexInput e1 = cr.openInput("bogus");
+             cr.openInput("bogus");
             fail("File not found");
 
         } catch (IOException e) {
@@ -603,7 +603,7 @@
         is.readBytes(b, 0, 10);
 
         try {
-            byte test = is.readByte();
+            is.readByte();
             fail("Single byte read past end of file");
         } catch (IOException e) {
             /* success */
Index: src/java/org/apache/lucene/queryParser/QueryParser.java
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParser.java	(revision 383736)
+++ src/java/org/apache/lucene/queryParser/QueryParser.java	(working copy)
@@ -882,7 +882,6 @@
   boolean prefix = false;
   boolean wildcard = false;
   boolean fuzzy = false;
-  boolean rangein = false;
   Query q;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case TERM:
@@ -1145,7 +1144,6 @@
   private Token jj_scanpos, jj_lastpos;
   private int jj_la;
   public boolean lookingAhead = false;
-  private boolean jj_semLA;
   private int jj_gen;
   final private int[] jj_la1 = new int[22];
   static private int[] jj_la1_0;
Index: src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java	(revision 383736)
+++ src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java	(working copy)
@@ -1,45 +1,18 @@
 /* Generated By:JavaCC: Do not edit this line. QueryParserTokenManager.java */
 package org.apache.lucene.queryParser;
-import java.util.Vector;
-import java.io.*;
-import java.text.*;
-import java.util.*;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.analysis.*;
-import org.apache.lucene.document.*;
-import org.apache.lucene.search.*;
-import org.apache.lucene.util.Parameter;
 
 public class QueryParserTokenManager implements QueryParserConstants
 {
   public  java.io.PrintStream debugStream = System.out;
   public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
-private final int jjStopStringLiteralDfa_3(int pos, long active0)
-{
-   switch (pos)
-   {
-      default :
-         return -1;
-   }
-}
-private final int jjStartNfa_3(int pos, long active0)
-{
-   return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
-}
+
 private final int jjStopAtPos(int pos, int kind)
 {
    jjmatchedKind = kind;
    jjmatchedPos = pos;
    return pos + 1;
 }
-private final int jjStartNfaWithStates_3(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_3(state, pos + 1);
-}
+
 private final int jjMoveStringLiteralDfa0_3()
 {
    switch(curChar)
@@ -89,11 +62,7 @@
       jjCheckNAdd(jjnextStates[start]);
    } while (start++ != end);
 }
-private final void jjCheckNAddStates(int start)
-{
-   jjCheckNAdd(jjnextStates[start]);
-   jjCheckNAdd(jjnextStates[start + 1]);
-}
+
 static final long[] jjbitVec0 = {
    0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
 };
@@ -102,12 +71,11 @@
 };
 private final int jjMoveNfa_3(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 33;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -380,7 +348,7 @@
       }
       else
       {
-         int hiByte = (int)(curChar >> 8);
+         int hiByte = (curChar >> 8);
          int i1 = hiByte >> 6;
          long l1 = 1L << (hiByte & 077);
          int i2 = (curChar & 0xff) >> 6;
@@ -494,12 +462,11 @@
 }
 private final int jjMoveNfa_1(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 5;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -573,7 +540,7 @@
       }
       else
       {
-         int hiByte = (int)(curChar >> 8);
+         int hiByte = (curChar >> 8);
          int i1 = hiByte >> 6;
          long l1 = 1L << (hiByte & 077);
          int i2 = (curChar & 0xff) >> 6;
@@ -617,12 +584,11 @@
 }
 private final int jjMoveNfa_0(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 3;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -658,7 +624,6 @@
       }
       else if (curChar < 128)
       {
-         long l = 1L << (curChar & 077);
          MatchLoop: do
          {
             switch(jjstateSet[--i])
@@ -669,11 +634,6 @@
       }
       else
       {
-         int hiByte = (int)(curChar >> 8);
-         int i1 = hiByte >> 6;
-         long l1 = 1L << (hiByte & 077);
-         int i2 = (curChar & 0xff) >> 6;
-         long l2 = 1L << (curChar & 077);
          MatchLoop: do
          {
             switch(jjstateSet[--i])
@@ -754,12 +714,11 @@
 }
 private final int jjMoveNfa_2(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 5;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -833,7 +792,7 @@
       }
       else
       {
-         int hiByte = (int)(curChar >> 8);
+         int hiByte = (curChar >> 8);
          int i1 = hiByte >> 6;
          long l1 = 1L << (hiByte & 077);
          int i2 = (curChar & 0xff) >> 6;
@@ -969,8 +928,6 @@
 
 public Token getNextToken() 
 {
-  int kind;
-  Token specialToken = null;
   Token matchedToken;
   int curPos = 0;
 
Index: src/java/org/apache/lucene/analysis/de/WordlistLoader.java
===================================================================
--- src/java/org/apache/lucene/analysis/de/WordlistLoader.java	(revision 383736)
+++ src/java/org/apache/lucene/analysis/de/WordlistLoader.java	(working copy)
@@ -89,7 +89,7 @@
    * @deprecated Use {@link #getWordSet(File)} getWordSet(File)} instead
    */
   public static Hashtable getWordtable(File wordfile) throws IOException {
-    HashSet wordSet = (HashSet)getWordSet(wordfile);
+    HashSet wordSet = getWordSet(wordfile);
     Hashtable result = makeWordTable(wordSet);
     return result;
   }
Index: src/java/org/apache/lucene/analysis/standard/StandardTokenizerTokenManager.java
===================================================================
--- src/java/org/apache/lucene/analysis/standard/StandardTokenizerTokenManager.java	(revision 383736)
+++ src/java/org/apache/lucene/analysis/standard/StandardTokenizerTokenManager.java	(working copy)
@@ -1,6 +1,5 @@
 /* Generated By:JavaCC: Do not edit this line. StandardTokenizerTokenManager.java */
 package org.apache.lucene.analysis.standard;
-import java.io.*;
 
 public class StandardTokenizerTokenManager implements StandardTokenizerConstants
 {
@@ -35,11 +34,13 @@
       jjCheckNAdd(jjnextStates[start]);
    } while (start++ != end);
 }
+/*
 private final void jjCheckNAddStates(int start)
 {
    jjCheckNAdd(jjnextStates[start]);
    jjCheckNAdd(jjnextStates[start + 1]);
 }
+*/
 static final long[] jjbitVec0 = {
    0x1ff0000000000000L, 0xffffffffffffc000L, 0xffffffffL, 0x600000000000000L
 };
@@ -93,12 +94,11 @@
 };
 private final int jjMoveNfa_0(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 75;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -685,7 +685,7 @@
       }
       else
       {
-         int hiByte = (int)(curChar >> 8);
+         int hiByte = (curChar >> 8);
          int i1 = hiByte >> 6;
          long l1 = 1L << (hiByte & 077);
          int i2 = (curChar & 0xff) >> 6;
@@ -1155,8 +1155,6 @@
 
 public Token getNextToken() 
 {
-  int kind;
-  Token specialToken = null;
   Token matchedToken;
   int curPos = 0;
 
Index: src/java/org/apache/lucene/analysis/WordlistLoader.java
===================================================================
--- src/java/org/apache/lucene/analysis/WordlistLoader.java	(revision 383736)
+++ src/java/org/apache/lucene/analysis/WordlistLoader.java	(working copy)
@@ -111,7 +111,7 @@
    * @deprecated Use {@link #getWordSet(File)} instead
    */
   public static Hashtable getWordtable(File wordfile) throws IOException {
-    HashSet wordSet = (HashSet)getWordSet(wordfile);
+    HashSet wordSet = getWordSet(wordfile);
     Hashtable result = makeWordTable(wordSet);
     return result;
   }
Index: src/java/org/apache/lucene/search/TopFieldDocCollector.java
===================================================================
--- src/java/org/apache/lucene/search/TopFieldDocCollector.java	(revision 383736)
+++ src/java/org/apache/lucene/search/TopFieldDocCollector.java	(working copy)
@@ -17,12 +17,8 @@
  */
 
 import java.io.IOException;
-import java.util.BitSet;
 
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.document.Document;
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
 
 /** A {@link HitCollector} implementation that collects the top-sorting
  * documents, returning them as a {@link TopFieldDocs}.  This is used by {@link
Index: src/java/org/apache/lucene/search/BooleanScorer2.java
===================================================================
--- src/java/org/apache/lucene/search/BooleanScorer2.java	(revision 383736)
+++ src/java/org/apache/lucene/search/BooleanScorer2.java	(working copy)
@@ -194,7 +194,6 @@
   }
 
   private Scorer dualConjunctionSumScorer(Scorer req1, Scorer req2) { // non counting. 
-    final int requiredNrMatchers = requiredScorers.size();
     ConjunctionScorer cs = new ConjunctionScorer(defaultSimilarity);
     // All scorers match, so defaultSimilarity super.score() always has 1 as
     // the coordination factor.
Index: src/java/org/apache/lucene/search/TopDocCollector.java
===================================================================
--- src/java/org/apache/lucene/search/TopDocCollector.java	(revision 383736)
+++ src/java/org/apache/lucene/search/TopDocCollector.java	(working copy)
@@ -16,13 +16,6 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.BitSet;
-
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
 import org.apache.lucene.util.PriorityQueue;
 
 /** A {@link HitCollector} implementation that collects the top-scoring
Index: src/java/org/apache/lucene/search/spans/SpanScorer.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanScorer.java	(revision 383736)
+++ src/java/org/apache/lucene/search/spans/SpanScorer.java	(working copy)
@@ -26,7 +26,6 @@
 
 class SpanScorer extends Scorer {
   private Spans spans;
-  private Weight weight;
   private byte[] norms;
   private float value;
 
@@ -41,7 +40,6 @@
     super(similarity);
     this.spans = spans;
     this.norms = norms;
-    this.weight = weight;
     this.value = weight.getValue();
   }
 
Index: src/java/org/apache/lucene/search/FuzzyTermEnum.java
===================================================================
--- src/java/org/apache/lucene/search/FuzzyTermEnum.java	(revision 383736)
+++ src/java/org/apache/lucene/search/FuzzyTermEnum.java	(working copy)
@@ -141,7 +141,7 @@
   }
   
   public final float difference() {
-    return (float)((similarity - minimumSimilarity) * scale_factor);
+    return ((similarity - minimumSimilarity) * scale_factor);
   }
   
   public final boolean endEnum() {
Index: src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
===================================================================
--- src/java/org/apache/lucene/search/DisjunctionMaxScorer.java	(revision 383736)
+++ src/java/org/apache/lucene/search/DisjunctionMaxScorer.java	(working copy)
@@ -18,8 +18,6 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Comparator;
 
 /**
  * The Scorer for DisjunctionMaxQuery's.  The union of all documents generated by the the subquery scorers
Index: src/java/org/apache/lucene/search/BooleanScorer.java
===================================================================
--- src/java/org/apache/lucene/search/BooleanScorer.java	(revision 383736)
+++ src/java/org/apache/lucene/search/BooleanScorer.java	(working copy)
@@ -200,10 +200,8 @@
     final Bucket[] buckets = new Bucket[SIZE];
     Bucket first = null;                          // head of valid list
   
-    private BooleanScorer scorer;
 
     public BucketTable(BooleanScorer scorer) {
-      this.scorer = scorer;
     }
 
     public final int size() { return SIZE; }
Index: src/java/org/apache/lucene/search/ExactPhraseScorer.java
===================================================================
--- src/java/org/apache/lucene/search/ExactPhraseScorer.java	(revision 383736)
+++ src/java/org/apache/lucene/search/ExactPhraseScorer.java	(working copy)
@@ -39,13 +39,13 @@
       while (first.position < last.position) {	  // scan forward in first
 	do {
 	  if (!first.nextPosition())
-	    return (float)freq;
+	    return freq;
 	} while (first.position < last.position);
 	firstToLast();
       }
       freq++;					  // all equal: a match
     } while (last.nextPosition());
   
-    return (float)freq;
+    return freq;
   }
 }
Index: src/java/org/apache/lucene/search/FieldCacheImpl.java
===================================================================
--- src/java/org/apache/lucene/search/FieldCacheImpl.java	(revision 383736)
+++ src/java/org/apache/lucene/search/FieldCacheImpl.java	(working copy)
@@ -16,16 +16,15 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.WeakHashMap;
+
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermDocs;
 import org.apache.lucene.index.TermEnum;
-import org.apache.lucene.search.FieldCache.StringIndex; // required by GCJ
-
-import java.io.IOException;
-import java.util.Map;
-import java.util.WeakHashMap;
-import java.util.HashMap;
 
 /**
  * Expert: The default cache implementation, storing all values in memory.
@@ -241,7 +240,7 @@
   }
 
   // inherit javadocs
-  public StringIndex getStringIndex (IndexReader reader, String field)
+  public FieldCache.StringIndex getStringIndex (IndexReader reader, String field)
   throws IOException {
     field = field.intern();
     Object ret = lookup (reader, field, STRING_INDEX);
@@ -294,11 +293,11 @@
         mterms = terms;
       }
 
-      StringIndex value = new StringIndex (retArray, mterms);
+      FieldCache.StringIndex value = new FieldCache.StringIndex (retArray, mterms);
       store (reader, field, STRING_INDEX, value);
       return value;
     }
-    return (StringIndex) ret;
+    return (FieldCache.StringIndex) ret;
   }
 
   /** The pattern used to detect integer values in a field */
Index: src/java/org/apache/lucene/index/MultiReader.java
===================================================================
--- src/java/org/apache/lucene/index/MultiReader.java	(revision 383736)
+++ src/java/org/apache/lucene/index/MultiReader.java	(working copy)
@@ -451,7 +451,7 @@
   }
 
   protected TermDocs termDocs(IndexReader reader) throws IOException {
-    return (TermDocs)reader.termPositions();
+    return reader.termPositions();
   }
 
   public int nextPosition() throws IOException {
Index: src/java/org/apache/lucene/index/SegmentInfos.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentInfos.java	(revision 383736)
+++ src/java/org/apache/lucene/index/SegmentInfos.java	(working copy)
@@ -16,12 +16,12 @@
  * limitations under the License.
  */
 
-import java.util.Vector;
 import java.io.IOException;
+import java.util.Vector;
+
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.Constants;
 
 final class SegmentInfos extends Vector {
   
Index: src/java/org/apache/lucene/store/Directory.java
===================================================================
--- src/java/org/apache/lucene/store/Directory.java	(revision 383736)
+++ src/java/org/apache/lucene/store/Directory.java	(working copy)
@@ -72,7 +72,7 @@
   public IndexOutput createOutput(String name) throws IOException {
     // default implementation for back compatibility
     // this method should be abstract
-    return (IndexOutput)createFile(name);
+    return createFile(name);
   }
 
   /** @deprecated use {@link #openInput(String)} */
@@ -85,7 +85,7 @@
     throws IOException {
     // default implementation for back compatibility
     // this method should be abstract
-    return (IndexInput)openFile(name);
+    return openFile(name);
   }
 
   /** Construct a {@link Lock}.
Index: src/java/org/apache/lucene/store/IndexOutput.java
===================================================================
--- src/java/org/apache/lucene/store/IndexOutput.java	(revision 383736)
+++ src/java/org/apache/lucene/store/IndexOutput.java	(working copy)
@@ -100,7 +100,7 @@
        throws IOException {
     final int end = start + length;
     for (int i = start; i < end; i++) {
-      final int code = (int)s.charAt(i);
+      final int code = s.charAt(i);
       if (code >= 0x01 && code <= 0x7F)
 	writeByte((byte)code);
       else if (((code >= 0x80) && (code <= 0x7FF)) || code == 0) {
Index: src/java/org/apache/lucene/store/BufferedIndexInput.java
===================================================================
--- src/java/org/apache/lucene/store/BufferedIndexInput.java	(revision 383736)
+++ src/java/org/apache/lucene/store/BufferedIndexInput.java	(working copy)
@@ -38,7 +38,7 @@
        throws IOException {
     if (len < BUFFER_SIZE) {
       for (int i = 0; i < len; i++)		  // read byte-by-byte
-	b[i + offset] = (byte)readByte();
+	b[i + offset] = readByte();
     } else {					  // read all-at-once
       long start = getFilePointer();
       seekInternal(start);
Index: src/demo/org/apache/lucene/demo/html/HTMLParser.java
===================================================================
--- src/demo/org/apache/lucene/demo/html/HTMLParser.java	(revision 383736)
+++ src/demo/org/apache/lucene/demo/html/HTMLParser.java	(working copy)
@@ -472,7 +472,6 @@
   private Token jj_scanpos, jj_lastpos;
   private int jj_la;
   public boolean lookingAhead = false;
-  private boolean jj_semLA;
   private int jj_gen;
   final private int[] jj_la1 = new int[14];
   static private int[] jj_la1_0;
Index: src/demo/org/apache/lucene/demo/html/Entities.java
===================================================================
--- src/demo/org/apache/lucene/demo/html/Entities.java	(revision 383736)
+++ src/demo/org/apache/lucene/demo/html/Entities.java	(working copy)
@@ -48,7 +48,7 @@
     StringBuffer buffer = new StringBuffer(length * 2);
     for (int i = 0; i < length; i++) {
       char c = s.charAt(i);
-      int j = (int)c;
+      int j = c;
       if (j < 0x100 && encoder[j] != null) {
 	buffer.append(encoder[j]);		  // have a named encoding
 	buffer.append(';');
Index: src/demo/org/apache/lucene/demo/html/HTMLParserTokenManager.java
===================================================================
--- src/demo/org/apache/lucene/demo/html/HTMLParserTokenManager.java	(revision 383736)
+++ src/demo/org/apache/lucene/demo/html/HTMLParserTokenManager.java	(working copy)
@@ -1,7 +1,5 @@
 /* Generated By:JavaCC: Do not edit this line. HTMLParserTokenManager.java */
 package org.apache.lucene.demo.html;
-import java.io.*;
-import java.util.Properties;
 
 public class HTMLParserTokenManager implements HTMLParserConstants
 {
@@ -238,22 +236,16 @@
       jjCheckNAdd(jjnextStates[start]);
    } while (start++ != end);
 }
-private final void jjCheckNAddStates(int start)
-{
-   jjCheckNAdd(jjnextStates[start]);
-   jjCheckNAdd(jjnextStates[start + 1]);
-}
 static final long[] jjbitVec0 = {
    0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
 };
 private final int jjMoveNfa_0(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 28;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -532,12 +524,11 @@
 }
 private final int jjMoveNfa_5(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 2;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -574,7 +565,6 @@
       }
       else if (curChar < 128)
       {
-         long l = 1L << (curChar & 077);
          MatchLoop: do
          {
             switch(jjstateSet[--i])
@@ -621,26 +611,6 @@
       catch(java.io.IOException e) { return curPos; }
    }
 }
-private final int jjStopStringLiteralDfa_7(int pos, long active0)
-{
-   switch (pos)
-   {
-      default :
-         return -1;
-   }
-}
-private final int jjStartNfa_7(int pos, long active0)
-{
-   return jjMoveNfa_7(jjStopStringLiteralDfa_7(pos, active0), pos + 1);
-}
-private final int jjStartNfaWithStates_7(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_7(state, pos + 1);
-}
 private final int jjMoveStringLiteralDfa0_7()
 {
    switch(curChar)
@@ -653,12 +623,11 @@
 }
 private final int jjMoveNfa_7(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 1;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -682,7 +651,6 @@
       }
       else if (curChar < 128)
       {
-         long l = 1L << (curChar & 077);
          MatchLoop: do
          {
             switch(jjstateSet[--i])
@@ -733,12 +701,11 @@
 }
 private final int jjMoveNfa_4(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 2;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -775,7 +742,6 @@
       }
       else if (curChar < 128)
       {
-         long l = 1L << (curChar & 077);
          MatchLoop: do
          {
             switch(jjstateSet[--i])
@@ -822,26 +788,7 @@
       catch(java.io.IOException e) { return curPos; }
    }
 }
-private final int jjStopStringLiteralDfa_3(int pos, long active0)
-{
-   switch (pos)
-   {
-      default :
-         return -1;
-   }
-}
-private final int jjStartNfa_3(int pos, long active0)
-{
-   return jjMoveNfa_3(jjStopStringLiteralDfa_3(pos, active0), pos + 1);
-}
-private final int jjStartNfaWithStates_3(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_3(state, pos + 1);
-}
+
 private final int jjMoveStringLiteralDfa0_3()
 {
    switch(curChar)
@@ -856,12 +803,11 @@
 }
 private final int jjMoveNfa_3(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 3;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -906,7 +852,6 @@
       }
       else if (curChar < 128)
       {
-         long l = 1L << (curChar & 077);
          MatchLoop: do
          {
             switch(jjstateSet[--i])
@@ -984,14 +929,6 @@
 {
    return jjMoveNfa_6(jjStopStringLiteralDfa_6(pos, active0), pos + 1);
 }
-private final int jjStartNfaWithStates_6(int pos, int kind, int state)
-{
-   jjmatchedKind = kind;
-   jjmatchedPos = pos;
-   try { curChar = input_stream.readChar(); }
-   catch(java.io.IOException e) { return pos + 1; }
-   return jjMoveNfa_6(state, pos + 1);
-}
 private final int jjMoveStringLiteralDfa0_6()
 {
    switch(curChar)
@@ -1040,12 +977,11 @@
 }
 private final int jjMoveNfa_6(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 2;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -1082,7 +1018,6 @@
       }
       else if (curChar < 128)
       {
-         long l = 1L << (curChar & 077);
          MatchLoop: do
          {
             switch(jjstateSet[--i])
@@ -1135,12 +1070,11 @@
 }
 private final int jjMoveNfa_1(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 12;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -1196,7 +1130,6 @@
       }
       else if (curChar < 128)
       {
-         long l = 1L << (curChar & 077);
          MatchLoop: do
          {
             switch(jjstateSet[--i])
@@ -1275,18 +1208,6 @@
       catch(java.io.IOException e) { return curPos; }
    }
 }
-private final int jjStopStringLiteralDfa_2(int pos, long active0)
-{
-   switch (pos)
-   {
-      default :
-         return -1;
-   }
-}
-private final int jjStartNfa_2(int pos, long active0)
-{
-   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
-}
 private final int jjStartNfaWithStates_2(int pos, int kind, int state)
 {
    jjmatchedKind = kind;
@@ -1311,12 +1232,11 @@
 }
 private final int jjMoveNfa_2(int startState, int curPos)
 {
-   int[] nextStates;
    int startsAt = 0;
    jjnewStateCnt = 6;
    int i = 1;
    jjstateSet[0] = startState;
-   int j, kind = 0x7fffffff;
+   int kind = 0x7fffffff;
    for (;;)
    {
       if (++jjround == 0x7fffffff)
@@ -1377,7 +1297,6 @@
       }
       else if (curChar < 128)
       {
-         long l = 1L << (curChar & 077);
          MatchLoop: do
          {
             switch(jjstateSet[--i])
@@ -1517,8 +1436,6 @@
 
 public Token getNextToken() 
 {
-  int kind;
-  Token specialToken = null;
   Token matchedToken;
   int curPos = 0;
 
