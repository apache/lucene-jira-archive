Index: /home/dnaber/workspace/Lucene/src/java/org/apache/lucene/index/MultiReader.java
===================================================================
--- /home/dnaber/workspace/Lucene/src/java/org/apache/lucene/index/MultiReader.java	(revision 499176)
+++ /home/dnaber/workspace/Lucene/src/java/org/apache/lucene/index/MultiReader.java	(working copy)
@@ -38,6 +38,7 @@
   private int maxDoc = 0;
   private int numDocs = -1;
   private boolean hasDeletions = false;
+  private boolean hasSegmentInfos = true;
 
  /**
   * <p>Construct a MultiReader aggregating the named set of (sub)readers.
@@ -42,10 +43,12 @@
  /**
   * <p>Construct a MultiReader aggregating the named set of (sub)readers.
   * Directory locking for delete, undeleteAll, and setNorm operations is
-  * left to the subreaders. </p>
-  * <p>Note that all subreaders are closed if this Multireader is closed.</p>
+  * left to the subreaders. Note that some operations throw an
+  * UnsupportedOperationException when the MultiReader has been created
+  * with this constructor.</p>
+  * <p>Note that all subreaders are closed if this MultiReader is closed.</p>
   * @param subReaders set of (sub)readers
-  * @throws IOException
+  * @throws IOException may be thrown in subclasses
   */
   public MultiReader(IndexReader[] subReaders) throws IOException {
     super(subReaders.length == 0 ? null : subReaders[0].directory());
@@ -50,6 +53,7 @@
   public MultiReader(IndexReader[] subReaders) throws IOException {
     super(subReaders.length == 0 ? null : subReaders[0].directory());
     initialize(subReaders);
+    hasSegmentInfos = false;
   }
 
   /** Construct reading the named set of readers. */
@@ -56,6 +60,7 @@
   MultiReader(Directory directory, SegmentInfos sis, boolean closeDirectory, IndexReader[] subReaders) {
     super(directory, sis, closeDirectory);
     initialize(subReaders);
+    hasSegmentInfos = true;
   }
 
   private void initialize(IndexReader[] subReaders) {
@@ -262,7 +267,54 @@
     }
     return fieldSet;
   }
+
+  /**
+   * Check whether this IndexReader still works on a current version of the index.
+   * If this is not the case you will need to re-open the IndexReader to
+   * make sure you see the latest changes made to the index.
+   * 
+   * @throws IOException 
+   * @throws UnsupportedOperationException if the MultiReader was constructed
+   *  with an array of IndexReaders
+   */
+  public boolean isCurrent() throws IOException {
+    if (hasSegmentInfos) {
+      return super.isCurrent();
+    } else {
+      throw new UnsupportedOperationException("This method cannot be called with " +
+        "a MultiReader built by the public constructor");
+    }
+  }
   
+  /**
+   * Version number when this IndexReader was opened.
+   * @throws UnsupportedOperationException if the MultiReader was constructed
+   *  with an array of IndexReaders
+   */
+  public long getVersion() {
+    if (hasSegmentInfos) {
+      return super.getVersion();
+    } else {
+      throw new UnsupportedOperationException("This method cannot be called with " +
+        "a MultiReader built by the public constructor");
+    }
+  }
+
+  /**
+   * Checks is the index is optimized (if it has a single segment and no deletions)
+   * @return <code>true</code> if the index is optimized; <code>false</code> otherwise
+   * @throws UnsupportedOperationException if the MultiReader was constructed
+   *  with an array of IndexReaders
+   */
+  public boolean isOptimized() {
+    if (hasSegmentInfos) {
+      return super.isOptimized();
+    } else {
+      throw new UnsupportedOperationException("This method cannot be called with " +
+        "a MultiReader built by the public constructor");
+    }
+  }
+
 }
 
 class MultiTermEnum extends TermEnum {
