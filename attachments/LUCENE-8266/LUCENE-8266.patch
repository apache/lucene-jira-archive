Index: src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java	(date 1524255736000)
+++ src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java	(revision )
@@ -1237,14 +1237,14 @@
         break;
       }
       final Edge newLastEdge = edgeBuffer.getNext(lastEdge);
+      if (Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newLastEdge.endPoint)) {
+        break;
+      }
       // Planes that are almost identical cannot be properly handled by the standard polygon logic.  Detect this case and, if found,
       // give up on the tiling -- we'll need to create a large poly instead.
       if (lastEdge.plane.isFunctionallyIdentical(newLastEdge.plane)) {
         throw new TileException("Two adjacent edge planes are effectively parallel despite filtering; give up on tiling");
       }
-      if (Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newLastEdge.endPoint)) {
-        break;
-      }
       if (isWithin(newLastEdge.endPoint, includedEdges)) {
         //System.out.println(" maybe can extend to next edge");
         // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon
@@ -1308,6 +1308,11 @@
       if (Plane.arePointsCoplanar(newFirstEdge.startPoint, newFirstEdge.endPoint, firstEdge.endPoint)) {
         break;
       }
+      // Planes that are almost identical cannot be properly handled by the standard polygon logic.  Detect this case and, if found,
+      // give up on the tiling -- we'll need to create a large poly instead.
+      if (firstEdge.plane.isFunctionallyIdentical(newFirstEdge.plane)) {
+        throw new TileException("Two adjacent edge planes are effectively parallel despite filtering; give up on tiling");
+      }
       if (isWithin(newFirstEdge.startPoint, includedEdges)) {
         //System.out.println(" maybe can extend to previous edge");
         // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon
@@ -1387,6 +1392,10 @@
         // has no contents, so we generate no polygon.
         return false;
       }
+
+      if (firstEdge.plane.isFunctionallyIdentical(lastEdge.plane)) {
+        throw new TileException("Two adjacent edge planes are effectively parallel despite filtering; give up on tiling");
+      }
       
       // Now look for completely planar points.  This too is a degeneracy condition that we should
       // return "false" for.
@@ -1407,7 +1416,10 @@
       // Build the return edge (internal, of course)
       final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);
       final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);
-
+      if (returnEdge.plane.isFunctionallyIdentical(lastEdge.plane) ||
+          returnEdge.plane.isFunctionallyIdentical(firstEdge.plane)) {
+        throw new TileException("Two adjacent edge planes are effectively parallel despite filtering; give up on tiling");
+      }
       // Build point list and edge list
       final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());
       returnIsInternal = true;
