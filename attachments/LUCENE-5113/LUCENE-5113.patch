Index: lucene/misc/src/java/org/apache/lucene/index/sorter/Sorter.java
===================================================================
--- lucene/misc/src/java/org/apache/lucene/index/sorter/Sorter.java	(revision 1502686)
+++ lucene/misc/src/java/org/apache/lucene/index/sorter/Sorter.java	(working copy)
@@ -191,6 +191,7 @@
     for (int i = 0; i < maxDoc; ++i) {
       newToOld.add(docs[i]);
     }
+    newToOld.freeze();
 
     for (int i = 0; i < maxDoc; ++i) {
       docs[(int) newToOld.get(i)] = i;
@@ -200,6 +201,7 @@
     for (int i = 0; i < maxDoc; ++i) {
       oldToNew.add(docs[i]);
     }
+    oldToNew.freeze();
     
     return new Sorter.DocMap() {
 
Index: lucene/misc/src/java/org/apache/lucene/index/sorter/SortingMergePolicy.java
===================================================================
--- lucene/misc/src/java/org/apache/lucene/index/sorter/SortingMergePolicy.java	(revision 1502686)
+++ lucene/misc/src/java/org/apache/lucene/index/sorter/SortingMergePolicy.java	(working copy)
@@ -107,6 +107,7 @@
           }
         }
       }
+      deletes.freeze();
       return deletes;
     }
 
Index: lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts.java	(revision 1502686)
+++ lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts.java	(working copy)
@@ -958,6 +958,14 @@
           buf.add(arr[i]);
         }
         assertEquals(arr.length, buf.size());
+        if (random().nextBoolean()) {
+          buf.freeze();
+          if (random().nextBoolean()) {
+            // Make sure double freeze doesn't break anything
+            buf.freeze();
+          }
+        }
+        assertEquals(arr.length, buf.size());
         final AbstractAppendingLongBuffer.Iterator it = buf.iterator();
         for (int i = 0; i < arr.length; ++i) {
           if (random().nextBoolean()) {
@@ -973,8 +981,7 @@
   
         final long expectedBytesUsed = RamUsageEstimator.sizeOf(buf);
         final long computedBytesUsed = buf.ramBytesUsed();
-        assertEquals("got " + computedBytesUsed + ", expected: " + expectedBytesUsed,
-            expectedBytesUsed, computedBytesUsed);
+        assertEquals(expectedBytesUsed, computedBytesUsed);
       }
     }
   }
Index: lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java	(revision 1502686)
+++ lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java	(working copy)
@@ -1037,6 +1037,7 @@
           termOrd++;
         }
       }
+      termOrdToBytesOffset.freeze();
 
       // maybe an int-only impl?
       return new SortedDocValuesImpl(bytes.freeze(true), termOrdToBytesOffset, docToTermOrd.getMutable(), termOrd);
Index: lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java	(revision 1502686)
+++ lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java	(working copy)
@@ -328,6 +328,11 @@
         }
         globalOrd++;
       }
+      subIndexes.freeze();
+      globalOrdDeltas.freeze();
+      for (int i = 0; i < ordDeltas.length; ++i) {
+        ordDeltas[i].freeze();
+      }
     }
     
     /** 
Index: lucene/core/src/java/org/apache/lucene/index/MergeState.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/MergeState.java	(revision 1502686)
+++ lucene/core/src/java/org/apache/lucene/index/MergeState.java	(working copy)
@@ -77,6 +77,7 @@
           ++del;
         }
       }
+      docMap.freeze();
       final int numDeletedDocs = del;
       assert docMap.size() == maxDoc;
       return new DocMap() {
Index: lucene/core/src/java/org/apache/lucene/util/packed/MonotonicAppendingLongBuffer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/MonotonicAppendingLongBuffer.java	(revision 1502686)
+++ lucene/core/src/java/org/apache/lucene/util/packed/MonotonicAppendingLongBuffer.java	(working copy)
@@ -43,7 +43,7 @@
    *  @param pageSize         the size of a single page */
   public MonotonicAppendingLongBuffer(int initialPageCount, int pageSize) {
     super(initialPageCount, pageSize);
-    averages = new float[pending.length];
+    averages = new float[pageSize];
   }
 
   /** Create an {@link MonotonicAppendingLongBuffer} with initialPageCount=16
@@ -74,16 +74,15 @@
 
   @Override
   void packPendingValues() {
-    assert pendingOff == pending.length;
-
+    assert pendingOff > 0;
     minValues[valuesOff] = pending[0];
-    averages[valuesOff] = (float) (pending[pending.length - 1] - pending[0]) / (pending.length - 1);
+    averages[valuesOff] = pendingOff == 1 ? 0 : (float) (pending[pendingOff - 1] - pending[0]) / (pendingOff - 1);
 
-    for (int i = 0; i < pending.length; ++i) {
+    for (int i = 0; i < pendingOff; ++i) {
       pending[i] = zigZagEncode(pending[i] - minValues[valuesOff] - (long) (averages[valuesOff] * (long) i));
     }
     long maxDelta = 0;
-    for (int i = 0; i < pending.length; ++i) {
+    for (int i = 0; i < pendingOff; ++i) {
       if (pending[i] < 0) {
         maxDelta = -1;
         break;
@@ -91,7 +90,9 @@
         maxDelta = Math.max(maxDelta, pending[i]);
       }
     }
-    if (maxDelta != 0) {
+    if (maxDelta == 0) {
+      deltas[valuesOff] = new  PackedInts.NullReader(pendingOff);
+    } else {
       final int bitsRequired = maxDelta < 0 ? 64 : PackedInts.bitsRequired(maxDelta);
       final PackedInts.Mutable mutable = PackedInts.getMutable(pendingOff, bitsRequired, PackedInts.COMPACT);
       for (int i = 0; i < pendingOff; ) {
@@ -118,15 +119,13 @@
     void fillValues() {
       if (vOff == valuesOff) {
         currentValues = pending;
-      } else if (deltas[vOff] == null) {
-        for (int k = 0; k < pending.length; ++k) {
-          currentValues[k] = minValues[vOff] + (long) (averages[vOff] * (long) k);
-        }
+        currentCount = pendingOff;
       } else {
-        for (int k = 0; k < pending.length; ) {
-          k += deltas[vOff].get(k, currentValues, k, pending.length - k);
+        currentCount = deltas[vOff].size();
+        for (int k = 0; k < currentCount; ) {
+          k += deltas[vOff].get(k, currentValues, k, currentCount - k);
         }
-        for (int k = 0; k < pending.length; ++k) {
+        for (int k = 0; k < currentCount; ++k) {
           currentValues[k] = minValues[vOff] + (long) (averages[vOff] * (long) k) + zigZagDecode(currentValues[k]);
         }
       }
Index: lucene/core/src/java/org/apache/lucene/util/packed/AbstractAppendingLongBuffer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/AbstractAppendingLongBuffer.java	(revision 1502686)
+++ lucene/core/src/java/org/apache/lucene/util/packed/AbstractAppendingLongBuffer.java	(working copy)
@@ -37,7 +37,7 @@
   PackedInts.Reader[] deltas;
   private long deltasBytes;
   int valuesOff;
-  final long[] pending;
+  long[] pending;
   int pendingOff;
 
   AbstractAppendingLongBuffer(int initialBlockCount, int pageSize) {
@@ -50,13 +50,27 @@
     pendingOff = 0;
   }
 
+  final int pageSize() {
+    return pageMask + 1;
+  }
+
   /** Get the number of values that have been added to the buffer. */
   public final long size() {
-    return valuesOff * (long) pending.length + pendingOff;
+    long size = pendingOff;
+    if (valuesOff > 0) {
+      size += deltas[valuesOff - 1].size();
+    }
+    if (valuesOff > 1) {
+      size += (long) (valuesOff - 1) * pageSize();
+    }
+    return size;
   }
 
   /** Append a value to this buffer. */
   public final void add(long l) {
+    if (pending == null) {
+      throw new IllegalStateException("This buffer is frozen");
+    }
     if (pendingOff == pending.length) {
       // check size
       if (deltas.length == valuesOff) {
@@ -64,9 +78,7 @@
         grow(newLength);
       }
       packPendingValues();
-      if (deltas[valuesOff] != null) {
-        deltasBytes += deltas[valuesOff].ramBytesUsed();
-      }
+      deltasBytes += deltas[valuesOff].ramBytesUsed();
       ++valuesOff;
       // reset pending buffer
       pendingOff = 0;
@@ -99,13 +111,15 @@
 
     long[] currentValues;
     int vOff, pOff;
+    int currentCount; // number of entries of the current page
 
     Iterator() {
       vOff = pOff = 0;
       if (valuesOff == 0) {
         currentValues = pending;
+        currentCount = pendingOff;
       } else {
-        currentValues = new long[pending.length];
+        currentValues = new long[deltas[0].size()];
         fillValues();
       }
     }
@@ -114,18 +128,20 @@
 
     /** Whether or not there are remaining values. */
     public final boolean hasNext() {
-      return vOff < valuesOff || (vOff == valuesOff && pOff < pendingOff);
+      return pOff < currentCount;
     }
 
     /** Return the next long in the buffer. */
     public final long next() {
       assert hasNext();
       long result = currentValues[pOff++];
-      if (pOff == pending.length) {
+      if (pOff == currentCount) {
         vOff += 1;
         pOff = 0;
         if (vOff <= valuesOff) {
           fillValues();
+        } else {
+          currentCount = 0;
         }
       }
       return result;
@@ -136,7 +152,9 @@
   long baseRamBytesUsed() {
     return RamUsageEstimator.NUM_BYTES_OBJECT_HEADER
         + 3 * RamUsageEstimator.NUM_BYTES_OBJECT_REF // the 3 arrays
-        + 2 * RamUsageEstimator.NUM_BYTES_INT; // the 2 offsets
+        + 2 * RamUsageEstimator.NUM_BYTES_INT // the 2 offsets
+        + 2 * RamUsageEstimator.NUM_BYTES_INT // pageShift, pageMask
+        + RamUsageEstimator.NUM_BYTES_LONG; // deltasBytes
   }
 
   /**
@@ -145,13 +163,25 @@
   public long ramBytesUsed() {
     // TODO: this is called per-doc-per-norms/dv-field, can we optimize this?
     long bytesUsed = RamUsageEstimator.alignObjectSize(baseRamBytesUsed())
-        + 2 * RamUsageEstimator.NUM_BYTES_INT // pageShift, pageMask
-        + RamUsageEstimator.NUM_BYTES_LONG // valuesBytes
-        + RamUsageEstimator.sizeOf(pending)
+        + (pending != null ? RamUsageEstimator.sizeOf(pending) : 0L)
         + RamUsageEstimator.sizeOf(minValues)
         + RamUsageEstimator.alignObjectSize(RamUsageEstimator.NUM_BYTES_ARRAY_HEADER + (long) RamUsageEstimator.NUM_BYTES_OBJECT_REF * deltas.length); // values
 
     return bytesUsed + deltasBytes;
   }
 
+  /** Pack all pending values in this buffer. Subsequent calls to {@link #add(long)} will fail. */
+  public void freeze() {
+    if (pendingOff > 0) {
+      if (deltas.length == valuesOff) {
+        grow(valuesOff + 1); // don't oversize!
+      }
+      packPendingValues();
+      deltasBytes += deltas[valuesOff].ramBytesUsed();
+      ++valuesOff;
+      pendingOff = 0;
+    }
+    pending = null;
+  }
+
 }
Index: lucene/core/src/java/org/apache/lucene/util/packed/AppendingLongBuffer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/AppendingLongBuffer.java	(revision 1502686)
+++ lucene/core/src/java/org/apache/lucene/util/packed/AppendingLongBuffer.java	(working copy)
@@ -17,7 +17,6 @@
  * limitations under the License.
  */
 
-import java.util.Arrays;
 
 /**
  * Utility class to buffer a list of signed longs in memory. This class only
@@ -52,8 +51,6 @@
 
   @Override
   void packPendingValues() {
-    assert pendingOff == pending.length;
-
     // compute max delta
     long minValue = pending[0];
     long maxValue = pending[0];
@@ -64,7 +61,9 @@
     final long delta = maxValue - minValue;
 
     minValues[valuesOff] = minValue;
-    if (delta != 0) {
+    if (delta == 0) {
+      deltas[valuesOff] = new PackedInts.NullReader(pendingOff);
+    } else {
       // build a new packed reader
       final int bitsRequired = delta < 0 ? 64 : PackedInts.bitsRequired(delta);
       for (int i = 0; i < pendingOff; ++i) {
@@ -95,13 +94,13 @@
     void fillValues() {
       if (vOff == valuesOff) {
         currentValues = pending;
-      } else if (deltas[vOff] == null) {
-        Arrays.fill(currentValues, minValues[vOff]);
+        currentCount = pendingOff;
       } else {
-        for (int k = 0; k < pending.length; ) {
-          k += deltas[vOff].get(k, currentValues, k, pending.length - k);
+        currentCount = deltas[vOff].size();
+        for (int k = 0; k < currentCount; ) {
+          k += deltas[vOff].get(k, currentValues, k, currentCount - k);
         }
-        for (int k = 0; k < pending.length; ++k) {
+        for (int k = 0; k < currentCount; ++k) {
           currentValues[k] += minValues[vOff];
         }
       }
Index: lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java	(revision 1502686)
+++ lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java	(working copy)
@@ -18,12 +18,14 @@
  */
 
 import java.io.IOException;
+import java.util.Arrays;
 
 import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.store.DataInput;
 import org.apache.lucene.store.DataOutput;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.util.LongsRef;
+import org.apache.lucene.util.RamUsageEstimator;
 
 /**
  * Simplistic compression for array of unsigned long values.
@@ -703,7 +705,8 @@
 
     @Override
     public int get(int index, long[] arr, int off, int len) {
-      return 0;
+      Arrays.fill(arr, off, off + len, 0);
+      return len;
     }
 
     @Override
@@ -718,7 +721,7 @@
 
     @Override
     public long ramBytesUsed() {
-      return 0;
+      return RamUsageEstimator.alignObjectSize(RamUsageEstimator.NUM_BYTES_OBJECT_HEADER + RamUsageEstimator.NUM_BYTES_INT);
     }
 
     @Override
