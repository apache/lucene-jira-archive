Index: lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector.java	(date 1516710914000)
+++ lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/Vector.java	(revision )
@@ -27,7 +27,7 @@
    * Values that are all considered to be essentially zero have a magnitude
    * less than this.
    */
-  public static final double MINIMUM_RESOLUTION = 1.5e-12;
+  public static final double MINIMUM_RESOLUTION = 1.0e-12;
   /**
    * Angular version of minimum resolution.
    */
@@ -72,20 +72,7 @@
    * @param BZ is the Z value of the second
    */
   public Vector(final Vector A, final double BX, final double BY, final double BZ) {
-    // x = u2v3 - u3v2
-    // y = u3v1 - u1v3
-    // z = u1v2 - u2v1
-    final double thisX = A.y * BZ - A.z * BY;
-    final double thisY = A.z * BX - A.x * BZ;
-    final double thisZ = A.x * BY - A.y * BX;
-    final double magnitude = magnitude(thisX, thisY, thisZ);
-    if (Math.abs(magnitude) < MINIMUM_RESOLUTION) {
-      throw new IllegalArgumentException("Degenerate/parallel vector constructed");
-    }
-    final double inverseMagnitude = 1.0 / magnitude;
-    this.x = thisX * inverseMagnitude;
-    this.y = thisY * inverseMagnitude;
-    this.z = thisZ * inverseMagnitude;
+    this (A, new Vector(BX, BY, BZ));
   }
 
   /**
@@ -109,9 +96,42 @@
       throw new IllegalArgumentException("Degenerate/parallel vector constructed");
     }
     final double inverseMagnitude = 1.0 / magnitude;
-    this.x = thisX * inverseMagnitude;
-    this.y = thisY * inverseMagnitude;
-    this.z = thisZ * inverseMagnitude;
+    double normalizedX = thisX * inverseMagnitude;
+    double normalizedY = thisY * inverseMagnitude;
+    double normalizedZ = thisZ * inverseMagnitude;
+    // For a plane to work, the dot product between the normal vector
+    // and the points needs to be less than the minimum resolution.
+    // This is sometimes not true for points that are very close. Therefore
+    // we need to adjust
+    int i = 0;
+    double AdotProduct = A.dotProduct(normalizedX, normalizedY, normalizedZ);
+    double BdotProduct = B.dotProduct(normalizedX, normalizedY, normalizedZ);
+    while (Math.abs(AdotProduct) > MINIMUM_RESOLUTION || Math.abs(BdotProduct) > MINIMUM_RESOLUTION) {
+      // Choose which vector we are going to work on.
+      final Vector currentVector = (i % 2 == 0) ? A : B;
+      final double currentDotProduct = (i % 2 == 0) ? AdotProduct : BdotProduct;
+      //Adjust the normal with the vector.
+      normalizedX -= currentDotProduct * currentVector.x;
+      normalizedY -= currentDotProduct * currentVector.y;
+      normalizedZ -= currentDotProduct * currentVector.z;
+      final double correctedMagnitude = magnitude(normalizedX, normalizedY, normalizedZ);
+      final double inverseCorrectedMagnitude = 1.0 / correctedMagnitude;
+      normalizedX *= inverseCorrectedMagnitude;
+      normalizedY *= inverseCorrectedMagnitude;
+      normalizedZ *= inverseCorrectedMagnitude;
+      //This is  probably not needed as the method seems to converge
+      //quite quickly. But it is safer to have a way out.
+      if (i++ > 10) {
+        throw new IllegalArgumentException("Could not find the normal vector from the " +
+            "provided vectors: [Vector 1: " + A.toString() +", Vector 2: " + B.toString() + "].");
+      }
+      //recalculate the dot products.
+      AdotProduct = A.dotProduct(normalizedX, normalizedY, normalizedZ);
+      BdotProduct = B.dotProduct(normalizedX, normalizedY, normalizedZ);
+    }
+    this.x = normalizedX;
+    this.y = normalizedY;
+    this.z = normalizedZ;
   }
 
   /** Compute a magnitude of an x,y,z value.
