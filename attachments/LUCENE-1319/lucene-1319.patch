Index: org/apache/lucene/store/RAMDirectory.java
===================================================================
--- org/apache/lucene/store/RAMDirectory.java	(revision 671210)
+++ org/apache/lucene/store/RAMDirectory.java	(working copy)
@@ -36,8 +36,9 @@
 
   private static final long serialVersionUID = 1l;
 
-  HashMap fileMap = new HashMap();
-  long sizeInBytes = 0;
+  protected HashMap fileMap = new HashMap();
+  protected long sizeInBytes = 0;
+  protected int bufferSize = 1024;
   
   // *****
   // Lock acquisition sequence:  RAMDirectory, then RAMFile
@@ -47,6 +48,15 @@
   public RAMDirectory() {
     setLockFactory(new SingleInstanceLockFactory());
   }
+  
+  /**
+   * Construct with buffer size
+   * @param bufferSize buffer size for RAMFiles
+   */
+  public RAMDirectory(int bufferSize) {
+    this.bufferSize = bufferSize;
+    setLockFactory(new SingleInstanceLockFactory());
+  }
 
   /**
    * Creates a new <code>RAMDirectory</code> instance from a different
@@ -220,7 +230,7 @@
       }
       fileMap.put(name, file);
     }
-    return new RAMOutputStream(file);
+    return new RAMOutputStream(file, bufferSize);
   }
 
   /** Returns a stream reading an existing file. */
@@ -232,7 +242,7 @@
     }
     if (file == null)
       throw new FileNotFoundException(name);
-    return new RAMInputStream(file);
+    return new RAMInputStream(file, bufferSize);
   }
 
   /** Closes the store to future operations, releasing associated memory. */
Index: org/apache/lucene/store/RAMFile.java
===================================================================
--- org/apache/lucene/store/RAMFile.java	(revision 671210)
+++ org/apache/lucene/store/RAMFile.java	(working copy)
@@ -20,44 +20,44 @@
 import java.util.ArrayList;
 import java.io.Serializable;
 
-class RAMFile implements Serializable {
+public class RAMFile implements Serializable {
 
   private static final long serialVersionUID = 1l;
 
-  private ArrayList buffers = new ArrayList();
-  long length;
-  RAMDirectory directory;
-  long sizeInBytes;                  // Only maintained if in a directory; updates synchronized on directory
+  protected ArrayList buffers = new ArrayList();
+  protected long length;
+  protected RAMDirectory directory;
+  protected long sizeInBytes;                  // Only maintained if in a directory; updates synchronized on directory
 
   // This is publicly modifiable via Directory.touchFile(), so direct access not supported
   private long lastModified = System.currentTimeMillis();
 
   // File used as buffer, in no RAMDirectory
-  RAMFile() {}
+  public RAMFile() {}
   
-  RAMFile(RAMDirectory directory) {
+  public RAMFile(RAMDirectory directory) {
     this.directory = directory;
   }
 
   // For non-stream access from thread that might be concurrent with writing
-  synchronized long getLength() {
+  public synchronized long getLength() {
     return length;
   }
 
-  synchronized void setLength(long length) {
+  public synchronized void setLength(long length) {
     this.length = length;
   }
 
   // For non-stream access from thread that might be concurrent with writing
-  synchronized long getLastModified() {
+  public synchronized long getLastModified() {
     return lastModified;
   }
 
-  synchronized void setLastModified(long lastModified) {
+  public synchronized void setLastModified(long lastModified) {
     this.lastModified = lastModified;
   }
 
-  final synchronized byte[] addBuffer(int size) {
+  protected final synchronized byte[] addBuffer(int size) {
     byte[] buffer = newBuffer(size);
     if (directory!=null)
       synchronized (directory) {             // Ensure addition of buffer and adjustment to directory size are atomic wrt directory
@@ -70,11 +70,11 @@
     return buffer;
   }
 
-  final synchronized byte[] getBuffer(int index) {
+  public final synchronized byte[] getBuffer(int index) {
     return (byte[]) buffers.get(index);
   }
 
-  final synchronized int numBuffers() {
+  public final synchronized int numBuffers() {
     return buffers.size();
   }
 
@@ -84,12 +84,12 @@
    * @param size size of allocated buffer.
    * @return allocated buffer.
    */
-  byte[] newBuffer(int size) {
+  protected byte[] newBuffer(int size) {
     return new byte[size];
   }
 
   // Only valid if in a directory
-  long getSizeInBytes() {
+  public long getSizeInBytes() {
     synchronized (directory) {
       return sizeInBytes;
     }
Index: org/apache/lucene/store/RAMInputStream.java
===================================================================
--- org/apache/lucene/store/RAMInputStream.java	(revision 671210)
+++ org/apache/lucene/store/RAMInputStream.java	(working copy)
@@ -25,23 +25,23 @@
  * @version $Id$
  */
 
-class RAMInputStream extends IndexInput implements Cloneable {
-  static final int BUFFER_SIZE = RAMOutputStream.BUFFER_SIZE;
+public class RAMInputStream extends IndexInput implements Cloneable {
+  protected int bufferSize;
+  protected RAMFile file;
+  protected long length;
 
-  private RAMFile file;
-  private long length;
-
-  private byte[] currentBuffer;
-  private int currentBufferIndex;
+  protected byte[] currentBuffer;
+  protected int currentBufferIndex;
   
-  private int bufferPosition;
-  private long bufferStart;
-  private int bufferLength;
+  protected int bufferPosition;
+  protected long bufferStart;
+  protected int bufferLength;
 
-  RAMInputStream(RAMFile f) throws IOException {
+  public RAMInputStream(RAMFile f, int bufferSize) throws IOException {
     file = f;
+    this.bufferSize = bufferSize;
     length = file.length;
-    if (length/BUFFER_SIZE >= Integer.MAX_VALUE) {
+    if (length/bufferSize >= Integer.MAX_VALUE) {
       throw new IOException("Too large RAMFile! "+length); 
     }
 
@@ -50,7 +50,26 @@
     currentBufferIndex = -1;
     currentBuffer = null;
   }
-
+  
+  public void writeTo(IndexOutput out) throws IOException {
+    final long end = file.length;
+    long pos = 0;
+    int buffer = 0;
+    while (pos < end) {
+      int length = bufferSize;
+      long nextPos = pos + length;
+      if (nextPos > end) {                        // at the last buffer
+        length = (int)(end - pos);
+      }
+      out.writeBytes((byte[])file.getBuffer(buffer++), length);
+      pos = nextPos;
+    }
+  }
+  
+  public RAMFile getRAMFile() {
+    return file;
+  }
+  
   public void close() {
     // nothing to do here
   }
@@ -91,14 +110,14 @@
       else {
         // Force EOF if a read takes place at this position
         currentBufferIndex--;
-        bufferPosition = BUFFER_SIZE;
+        bufferPosition = bufferSize;
       }
     } else {
       currentBuffer = (byte[]) file.getBuffer(currentBufferIndex);
       bufferPosition = 0;
-      bufferStart = (long) BUFFER_SIZE * (long) currentBufferIndex;
+      bufferStart = (long) bufferSize * (long) currentBufferIndex;
       long buflen = length - bufferStart;
-      bufferLength = buflen > BUFFER_SIZE ? BUFFER_SIZE : (int) buflen;
+      bufferLength = buflen > bufferSize ? bufferSize : (int) buflen;
     }
   }
 
@@ -107,10 +126,10 @@
   }
 
   public void seek(long pos) throws IOException {
-    if (currentBuffer==null || pos < bufferStart || pos >= bufferStart + BUFFER_SIZE) {
-      currentBufferIndex = (int) (pos / BUFFER_SIZE);
+    if (currentBuffer==null || pos < bufferStart || pos >= bufferStart + bufferSize) {
+      currentBufferIndex = (int) (pos / bufferSize);
       switchCurrentBuffer(false);
     }
-    bufferPosition = (int) (pos % BUFFER_SIZE);
+    bufferPosition = (int) (pos % bufferSize);
   }
 }
Index: org/apache/lucene/store/RAMOutputStream.java
===================================================================
--- org/apache/lucene/store/RAMOutputStream.java	(revision 671210)
+++ org/apache/lucene/store/RAMOutputStream.java	(working copy)
@@ -26,8 +26,7 @@
  */
 
 public class RAMOutputStream extends IndexOutput {
-  static final int BUFFER_SIZE = 1024;
-
+  private int bufferSize;
   private RAMFile file;
 
   private byte[] currentBuffer;
@@ -36,14 +35,19 @@
   private int bufferPosition;
   private long bufferStart;
   private int bufferLength;
-
-  /** Construct an empty output buffer. */
+  
   public RAMOutputStream() {
-    this(new RAMFile());
+    this(new RAMFile(), 1024);
   }
+  
+  /** Construct an empty output buffer. */
+  public RAMOutputStream(int bufferSize) {
+    this(new RAMFile(), bufferSize);
+  }
 
-  RAMOutputStream(RAMFile f) {
+  public RAMOutputStream(RAMFile f, int bufferSize) {
     file = f;
+    this.bufferSize = bufferSize;
 
     // make sure that we switch to the
     // first needed buffer lazily
@@ -58,7 +62,7 @@
     long pos = 0;
     int buffer = 0;
     while (pos < end) {
-      int length = BUFFER_SIZE;
+      int length = bufferSize;
       long nextPos = pos + length;
       if (nextPos > end) {                        // at the last buffer
         length = (int)(end - pos);
@@ -88,11 +92,11 @@
     // and flush() has not been called yet
     setFileLength();
     if (pos < bufferStart || pos >= bufferStart + bufferLength) {
-      currentBufferIndex = (int) (pos / BUFFER_SIZE);
+      currentBufferIndex = (int) (pos / bufferSize);
       switchCurrentBuffer();
     }
 
-    bufferPosition = (int) (pos % BUFFER_SIZE);
+    bufferPosition = (int) (pos % bufferSize);
   }
 
   public long length() {
@@ -125,12 +129,12 @@
 
   private final void switchCurrentBuffer() throws IOException {
     if (currentBufferIndex == file.numBuffers()) {
-      currentBuffer = file.addBuffer(BUFFER_SIZE);
+      currentBuffer = file.addBuffer(bufferSize);
     } else {
       currentBuffer = (byte[]) file.getBuffer(currentBufferIndex);
     }
     bufferPosition = 0;
-    bufferStart = (long) BUFFER_SIZE * (long) currentBufferIndex;
+    bufferStart = (long) bufferSize * (long) currentBufferIndex;
     bufferLength = currentBuffer.length;
   }
 
