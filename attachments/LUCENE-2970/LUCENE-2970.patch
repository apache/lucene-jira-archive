Index: lucene/src/test/org/apache/lucene/util/automaton/TestSpecialOperations.java
===================================================================
--- lucene/src/test/org/apache/lucene/util/automaton/TestSpecialOperations.java	(revision 0)
+++ lucene/src/test/org/apache/lucene/util/automaton/TestSpecialOperations.java	(revision 0)
@@ -0,0 +1,31 @@
+package org.apache.lucene.util.automaton;
+
+import org.apache.lucene.util.LuceneTestCase;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class TestSpecialOperations extends LuceneTestCase {
+  public void testIsFinite() {
+    int num = 2000 * RANDOM_MULTIPLIER;
+    for (int i = 0; i < num; i++) {
+      Automaton a = AutomatonTestUtil.randomAutomaton(random);
+      Automaton b = a.clone();
+      assertEquals(AutomatonTestUtil.isFiniteSimple(a), SpecialOperations.isFinite(b));
+    }
+  }
+}

Property changes on: lucene\src\test\org\apache\lucene\util\automaton\TestSpecialOperations.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: lucene/src/java/org/apache/lucene/util/automaton/SpecialOperations.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/automaton/SpecialOperations.java	(revision 1081496)
+++ lucene/src/java/org/apache/lucene/util/automaton/SpecialOperations.java	(working copy)
@@ -29,6 +29,7 @@
 
 package org.apache.lucene.util.automaton;
 
+import java.util.BitSet;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Set;
@@ -65,7 +66,7 @@
    */
   public static boolean isFinite(Automaton a) {
     if (a.isSingleton()) return true;
-    return isFinite(a.initial, new HashSet<State>());
+    return isFinite(a.initial, new BitSet(a.getNumberOfStates()), new BitSet(a.getNumberOfStates()));
   }
   
   /**
@@ -74,11 +75,12 @@
    */
   // TODO: not great that this is recursive... in theory a
   // large automata could exceed java's stack
-  private static boolean isFinite(State s, HashSet<State> path) {
-    path.add(s);
+  private static boolean isFinite(State s, BitSet path, BitSet visited) {
+    path.set(s.number);
     for (Transition t : s.getTransitions())
-      if (path.contains(t.to) || !isFinite(t.to, path)) return false;
-    path.remove(s);
+      if (path.get(t.to.number) || (!visited.get(t.to.number) && !isFinite(t.to, path, visited))) return false;
+    path.clear(s.number);
+    visited.set(s.number);
     return true;
   }
   
Index: lucene/src/test-framework/org/apache/lucene/util/automaton/AutomatonTestUtil.java
===================================================================
--- lucene/src/test-framework/org/apache/lucene/util/automaton/AutomatonTestUtil.java	(revision 1081496)
+++ lucene/src/test-framework/org/apache/lucene/util/automaton/AutomatonTestUtil.java	(working copy)
@@ -373,4 +373,25 @@
     a.removeDeadTransitions();
   }
 
+  /**
+   * Returns true if the language of this automaton is finite.
+   */
+  public static boolean isFiniteSimple(Automaton a) {
+    if (a.isSingleton()) return true;
+    return isFiniteSimple(a.initial, new HashSet<State>());
+  }
+  
+  /**
+   * Checks whether there is a loop containing s. (This is sufficient since
+   * there are never transitions to dead states.)
+   */
+  // TODO: not great that this is recursive... in theory a
+  // large automata could exceed java's stack
+  private static boolean isFiniteSimple(State s, HashSet<State> path) {
+    path.add(s);
+    for (Transition t : s.getTransitions())
+      if (path.contains(t.to) || !isFiniteSimple(t.to, path)) return false;
+    path.remove(s);
+    return true;
+  }
 }
