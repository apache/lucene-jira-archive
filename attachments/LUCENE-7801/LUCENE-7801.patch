diff --git a/lucene/facet/src/java/org/apache/lucene/facet/FacetsConfig.java b/lucene/facet/src/java/org/apache/lucene/facet/FacetsConfig.java
index 96db60f..ea67294 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/FacetsConfig.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/FacetsConfig.java
@@ -105,7 +105,7 @@ public class FacetsConfig {
    *
    *  @return The default configuration to be used for dimensions that 
    *  are not yet set in the {@link FacetsConfig} */
-  protected DimConfig getDefaultDimConfig(){
+  protected DimConfig getDefaultDimConfig() {
     return DEFAULT_DIM_CONFIG;
   }
   
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState.java b/lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState.java
index 6bcfa46..8727332 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/sortedset/DefaultSortedSetDocValuesReaderState.java
@@ -17,8 +17,11 @@
 package org.apache.lucene.facet.sortedset;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 
 import org.apache.lucene.facet.FacetsConfig;
@@ -33,6 +36,8 @@ import org.apache.lucene.index.MultiDocValues.MultiSortedSetDocValues;
 import org.apache.lucene.index.MultiDocValues.OrdinalMap;
 import org.apache.lucene.index.MultiDocValues;
 import org.apache.lucene.index.SortedSetDocValues;
+import org.apache.lucene.util.Accountable;
+import org.apache.lucene.util.Accountables;
 import org.apache.lucene.util.BytesRef;
 
 /**
@@ -104,11 +109,38 @@ public class DefaultSortedSetDocValuesReaderState extends SortedSetDocValuesRead
     }
   }
 
+  @Override
+  public long ramBytesUsed() {
+    synchronized (cachedOrdMaps) {
+      long bytes = 0;
+      for (OrdinalMap map : cachedOrdMaps.values()) {
+        bytes += map.ramBytesUsed();
+      }
+
+      return bytes;
+    }
+  }
+
+  @Override
+  public Collection<Accountable> getChildResources() {
+    synchronized (cachedOrdMaps) {
+      return Accountables.namedAccountables("DefaultSortedSetDocValuesReaderState", cachedOrdMaps);
+    }
+  }
+
+  @Override
+  public String toString() {
+    return "DefaultSortedSetDocValuesReaderState(field=" + field + " origReader=" + origReader + ")";
+  }
+  
   /** Return top-level doc values. */
   @Override
   public SortedSetDocValues getDocValues() throws IOException {
     // TODO: this is dup'd from slow composite reader wrapper ... can we factor it out to share?
     OrdinalMap map = null;
+    // TODO: why are we lazy about this?  It's better if ctor pays the cost, not first query?  Oh, but we
+    // call this method from ctor, ok.  Also, we only ever store one entry in the map (for key=field) so
+    // why are we using a map?
     synchronized (cachedOrdMaps) {
       map = cachedOrdMaps.get(field);
       if (map == null) {
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState.java b/lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState.java
index 83ed3f0..546b319 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/sortedset/SortedSetDocValuesReaderState.java
@@ -21,6 +21,7 @@ import java.util.Map;
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.SortedSetDocValues;
+import org.apache.lucene.util.Accountable;
 
 /** Wraps a {@link IndexReader} and resolves ords
  *  using existing {@link SortedSetDocValues} APIs without a
@@ -38,7 +39,7 @@ import org.apache.lucene.index.SortedSetDocValues;
  *  so you should create it once and re-use that one instance
  *  for a given {@link IndexReader}. */
 
-public abstract class SortedSetDocValuesReaderState {
+public abstract class SortedSetDocValuesReaderState implements Accountable {
 
   /** Holds start/end range of ords, which maps to one
    *  dimension (someday we may generalize it to map to
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets.java b/lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets.java
index 5aed22b..3ad6e68 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets.java
@@ -18,6 +18,7 @@ package org.apache.lucene.facet.sortedset;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -39,6 +40,7 @@ import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.Accountable;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.TestUtil;
 
@@ -178,6 +180,17 @@ public class TestSortedSetDocValuesFacets extends FacetTestCase {
     assertEquals("dim=b path=[] value=2 childCount=2\n  bar1 (1)\n  bar2 (1)\n", results.get(1).toString());
     assertEquals("dim=c path=[] value=1 childCount=1\n  baz1 (1)\n", results.get(2).toString());
 
+    Collection<Accountable> resources = state.getChildResources();
+    assertTrue(state.toString().contains(FacetsConfig.DEFAULT_INDEX_FIELD_NAME));
+    if (searcher.getIndexReader().leaves().size() > 1) {
+      assertTrue(state.ramBytesUsed() > 0);
+      assertFalse(resources.isEmpty());
+      assertTrue(resources.toString().contains(FacetsConfig.DEFAULT_INDEX_FIELD_NAME));
+    } else {
+      assertEquals(0, state.ramBytesUsed());
+      assertTrue(resources.isEmpty());
+    }
+
     searcher.getIndexReader().close();
     dir.close();
   }
