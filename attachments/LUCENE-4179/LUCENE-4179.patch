Index: lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java	(revision 1354962)
+++ lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java	(working copy)
@@ -66,6 +66,7 @@
 import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 
 /*
   Verify we can read the pre-5.0 file format, do searches
@@ -77,6 +78,7 @@
 // @SuppressCodecs("Lucene4x")
 // Sep codec cannot yet handle the offsets in our 4.x index!
 @SuppressCodecs({"MockFixedIntBlock", "MockVariableIntBlock", "MockSep", "MockRandom"})
+@Ignore("nocommit")
 public class TestBackwardsCompatibility extends LuceneTestCase {
 
   // Uncomment these cases & run them on an older Lucene
Index: lucene/core/src/test/org/apache/lucene/util/TestSimple64.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/util/TestSimple64.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/util/TestSimple64.java	(working copy)
@@ -0,0 +1,59 @@
+package org.apache.lucene.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class TestSimple64 extends LuceneTestCase {
+  
+  public void test() {
+    for (int i = 0; i < 31; i++) {
+      doTest(1 << i);
+    }
+    
+    doTest(Integer.MAX_VALUE);
+  }
+
+  public void doTest(int maxValue) {
+    int numInts = atLeast(1000);
+    
+    // generate random integers
+    int uncompressed[] = new int[numInts];
+    for (int i = 0; i < uncompressed.length; i++) {
+      uncompressed[i] = random().nextInt(maxValue);
+    }
+    
+    // compress into a long[]
+    long compressed[] = new long[numInts]; // worst case
+    int length = 0;
+    
+    for (int offset = 0 ; offset < compressed.length; ) {
+      long v = Simple64.compressSingle(uncompressed, offset, uncompressed.length - offset);
+      compressed[length++] = v;
+      offset += Simple64.size(v);
+    }
+    
+    // decompress back into an int
+    int uncompressed2[] = new int[numInts];
+    int upto = 0;
+    for (int offset = 0; offset < length; offset++) {
+      upto += Simple64.decompressSingle(compressed[offset], uncompressed2, upto);
+    }
+    
+    assertEquals(numInts, upto);
+    assertArrayEquals(uncompressed, uncompressed2);
+  }
+}

Property changes on: lucene/core/src/test/org/apache/lucene/util/TestSimple64.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
Index: lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.java	(revision 1354962)
+++ lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.java	(working copy)
@@ -43,6 +43,7 @@
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.RamUsageEstimator;
+import org.apache.lucene.util.Simple64;
 import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.automaton.CompiledAutomaton;
 import org.apache.lucene.util.automaton.RunAutomaton;
@@ -510,6 +511,8 @@
 
         byte[] suffixBytes = new byte[128];
         final ByteArrayDataInput suffixesReader = new ByteArrayDataInput();
+        
+        int[] suffixLengths = new int[48];
 
         byte[] statBytes = new byte[64];
         final ByteArrayDataInput statsReader = new ByteArrayDataInput();
@@ -628,7 +631,12 @@
           entCount = code >>> 1;
           assert entCount > 0;
           isLastInFloor = (code & 1) != 0;
-
+          if (suffixLengths.length < entCount) {
+            suffixLengths = new int[ArrayUtil.oversize(entCount, 4)];
+          }
+          for (int i = 0; i < entCount; ) {
+            i += Simple64.decompressSingle(in.readLong(), suffixLengths, i);
+          }
           // term suffixes:
           code = in.readVInt();
           isLeafBlock = (code & 1) != 0;
@@ -671,8 +679,7 @@
         public boolean nextLeaf() {
           //if (DEBUG) System.out.println("  frame.next ord=" + ord + " nextEnt=" + nextEnt + " entCount=" + entCount);
           assert nextEnt != -1 && nextEnt < entCount: "nextEnt=" + nextEnt + " entCount=" + entCount + " fp=" + fp;
-          nextEnt++;
-          suffix = suffixesReader.readVInt();
+          suffix = suffixLengths[nextEnt++];
           startBytePos = suffixesReader.getPosition();
           suffixesReader.skipBytes(suffix);
           return false;
@@ -681,8 +688,7 @@
         public boolean nextNonLeaf() {
           //if (DEBUG) System.out.println("  frame.next ord=" + ord + " nextEnt=" + nextEnt + " entCount=" + entCount);
           assert nextEnt != -1 && nextEnt < entCount: "nextEnt=" + nextEnt + " entCount=" + entCount + " fp=" + fp;
-          nextEnt++;
-          final int code = suffixesReader.readVInt();
+          final int code = suffixLengths[nextEnt++];
           suffix = code >>> 1;
           startBytePos = suffixesReader.getPosition();
           suffixesReader.skipBytes(suffix);
@@ -2203,6 +2209,8 @@
         byte[] suffixBytes = new byte[128];
         final ByteArrayDataInput suffixesReader = new ByteArrayDataInput();
 
+        int[] suffixLengths = new int[48];
+
         byte[] statBytes = new byte[64];
         final ByteArrayDataInput statsReader = new ByteArrayDataInput();
 
@@ -2303,6 +2311,13 @@
           isLastInFloor = (code & 1) != 0;
           assert arc == null || (isLastInFloor || isFloor);
 
+          if (suffixLengths.length < entCount) {
+            suffixLengths = new int[ArrayUtil.oversize(entCount, 4)];
+          }
+          for (int i = 0; i < entCount; ) {
+            i += Simple64.decompressSingle(in.readLong(), suffixLengths, i);
+          }
+
           // TODO: if suffixes were stored in random-access
           // array structure, then we could do binary search
           // instead of linear scan to find target term; eg
@@ -2406,8 +2421,7 @@
         public boolean nextLeaf() {
           //if (DEBUG) System.out.println("  frame.next ord=" + ord + " nextEnt=" + nextEnt + " entCount=" + entCount);
           assert nextEnt != -1 && nextEnt < entCount: "nextEnt=" + nextEnt + " entCount=" + entCount + " fp=" + fp;
-          nextEnt++;
-          suffix = suffixesReader.readVInt();
+          suffix = suffixLengths[nextEnt++];
           startBytePos = suffixesReader.getPosition();
           term.length = prefix + suffix;
           if (term.bytes.length < term.length) {
@@ -2422,8 +2436,7 @@
         public boolean nextNonLeaf() {
           //if (DEBUG) System.out.println("  frame.next ord=" + ord + " nextEnt=" + nextEnt + " entCount=" + entCount);
           assert nextEnt != -1 && nextEnt < entCount: "nextEnt=" + nextEnt + " entCount=" + entCount + " fp=" + fp;
-          nextEnt++;
-          final int code = suffixesReader.readVInt();
+          final int code = suffixLengths[nextEnt++];
           suffix = code >>> 1;
           startBytePos = suffixesReader.getPosition();
           term.length = prefix + suffix;
@@ -2582,8 +2595,7 @@
           //if (DEBUG) System.out.println("    targetSubCode=" + targetSubCode);
           while(true) {
             assert nextEnt < entCount;
-            nextEnt++;
-            final int code = suffixesReader.readVInt();
+            final int code = suffixLengths[nextEnt++];
             suffixesReader.skipBytes(isLeafBlock ? code : code >>> 1);
             //if (DEBUG) System.out.println("    " + nextEnt + " (of " + entCount + ") ent isSubBlock=" + ((code&1)==1));
             if ((code & 1) != 0) {
@@ -2632,9 +2644,8 @@
           // Loop over each entry (term or sub-block) in this block:
           //nextTerm: while(nextEnt < entCount) {
           nextTerm: while (true) {
-            nextEnt++;
 
-            suffix = suffixesReader.readVInt();
+            suffix = suffixLengths[nextEnt++];
 
             // if (DEBUG) {
             //   BytesRef suffixBytesRef = new BytesRef();
@@ -2756,9 +2767,8 @@
           // Loop over each entry (term or sub-block) in this block:
           //nextTerm: while(nextEnt < entCount) {
           nextTerm: while (true) {
-            nextEnt++;
 
-            final int code = suffixesReader.readVInt();
+            final int code = suffixLengths[nextEnt++];
             suffix = code >>> 1;
             // if (DEBUG) {
             //   BytesRef suffixBytesRef = new BytesRef();
Index: lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsWriter.java	(revision 1354962)
+++ lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsWriter.java	(working copy)
@@ -33,6 +33,7 @@
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.IntsRef;
+import org.apache.lucene.util.Simple64;
 import org.apache.lucene.util.fst.Builder;
 import org.apache.lucene.util.fst.ByteSequenceOutputs;
 import org.apache.lucene.util.fst.BytesRefFSTEnum;
@@ -703,7 +704,9 @@
       }
 
       final List<FST<BytesRef>> subIndices;
-
+      int suffixLengths[] = new int[length]; // nocommit
+      int suffixUpto = 0;
+      
       int termCount;
       if (isLeafBlock) {
         subIndices = null;
@@ -718,7 +721,7 @@
           //   System.out.println("    write term suffix=" + suffixBytes);
           // }
           // For leaf block we write suffix straight
-          bytesWriter.writeVInt(suffix);
+          suffixLengths[suffixUpto++] = suffix;
           bytesWriter.writeBytes(term.term.bytes, prefixLength, suffix);
 
           // Write term stats, to separate byte[] blob:
@@ -744,7 +747,7 @@
             // }
             // For non-leaf block we borrow 1 bit to record
             // if entry is term or sub-block
-            bytesWriter.writeVInt(suffix<<1);
+            suffixLengths[suffixUpto++] = suffix<<1;
             bytesWriter.writeBytes(term.term.bytes, prefixLength, suffix);
 
             // Write term stats, to separate byte[] blob:
@@ -763,7 +766,7 @@
 
             // For non-leaf block we borrow 1 bit to record
             // if entry is term or sub-block
-            bytesWriter.writeVInt((suffix<<1)|1);
+            suffixLengths[suffixUpto++] = (suffix<<1)|1;
             bytesWriter.writeBytes(block.prefix.bytes, prefixLength, suffix);
             assert block.fp < startFP;
 
@@ -785,6 +788,12 @@
       // TODO: we could block-write the term suffix pointers;
       // this would take more space but would enable binary
       // search on lookup
+      // Write suffix lengths
+      for (int i = 0; i < length; ) {
+        long v = Simple64.compressSingle(suffixLengths, i, length - i);
+        out.writeLong(v);
+        i += Simple64.size(v);
+      }
 
       // Write suffixes byte[] blob to terms dict output:
       out.writeVInt((int) (bytesWriter.getFilePointer() << 1) | (isLeafBlock ? 1:0));
Index: lucene/core/src/java/org/apache/lucene/util/Simple64.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/Simple64.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/util/Simple64.java	(working copy)
@@ -0,0 +1,578 @@
+package org.apache.lucene.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.store.DataInput;
+
+public class Simple64 {
+
+  private static final int NUM_DATA_BITS = 60;
+  private static final long BITS_60_MASK = (1L << 60) - 1;
+  private static final long BITS_30_MASK = (1 << 30) - 1;
+  private static final long BITS_20_MASK = (1 << 20) - 1;
+  private static final long BITS_15_MASK = (1 << 15) - 1;
+  private static final long BITS_12_MASK = (1 << 12) - 1;
+  private static final long BITS_11_MASK = (1 << 11) - 1;
+  private static final long BITS_10_MASK = (1 << 10) - 1;
+  private static final long BITS_8_MASK = (1 << 8) - 1; // 4 bits unused, then the last value take them
+  private static final long BITS_7_MASK = (1 << 7) - 1; // 4 bits unused, then the last value take them
+  private static final long BITS_6_MASK = (1 << 6) - 1;
+  private static final long BITS_5_MASK = (1 << 5) - 1;
+  private static final long BITS_4_MASK = (1 << 4) - 1;
+  private static final long BITS_3_MASK = (1 << 3) - 1;
+  private static final long BITS_2_MASK = (1 << 2) - 1;
+  private static final long BITS_1_MASK = (1 << 1) - 1;
+
+  private static final int STATUS_1NUM_60BITS = 14;
+  private static final int STATUS_2NUM_30BITS = 13;
+  private static final int STATUS_3NUM_20BITS = 12;
+  private static final int STATUS_4NUM_15BITS = 11;
+  private static final int STATUS_5NUM_12BITS = 10;
+  private static final int STATUS_6NUM_10BITS = 9;
+  private static final int STATUS_7NUM_8BITS = 8;
+  private static final int STATUS_8NUM_7BITS = 7;
+  private static final int STATUS_10NUM_6BITS = 6;
+  private static final int STATUS_12NUM_5BITS = 5;
+  private static final int STATUS_15NUM_4BITS = 4;
+  private static final int STATUS_20NUM_3BITS = 3;
+  private static final int STATUS_30NUM_2BITS = 2;
+  private static final int STATUS_60NUM_1BITS = 1;
+
+  public static long compressSingle(final int[] uncompressed, final int offset, final int length) {
+    if (length < 1) {
+      throw new IllegalArgumentException("Cannot compress input with non positive size " + length);
+    }
+    int inputCompressable = 1;
+    int minBits = 1;
+    long maxFitPlus1 = (1 << minBits);
+    long nextData;
+
+    do {
+      nextData = uncompressed[offset + inputCompressable - 1] & 0xFFFFFFFFL;
+      if (nextData < 0) {
+        throw new IllegalArgumentException("Cannot compress negative input " + nextData + " (at index " + (offset+inputCompressable-1) + ")");
+      }
+      while ((nextData >= maxFitPlus1) && (minBits < NUM_DATA_BITS))
+      {
+        if ((minBits == 7) && (inputCompressable == 8) && (nextData < (maxFitPlus1 << 4))) {
+          break;
+        } else if ((minBits == 8) && (inputCompressable == 7) && (nextData < (maxFitPlus1 << 4))) {
+          break;
+        } else {
+          minBits++;
+          maxFitPlus1 <<= 1;
+          if ((inputCompressable * minBits) > NUM_DATA_BITS) {
+            inputCompressable--;
+            break;
+          }
+        }
+      }
+      inputCompressable++;
+    } while (((inputCompressable * minBits) <= NUM_DATA_BITS) && (inputCompressable <= length));
+
+    inputCompressable--;
+    if (inputCompressable == 0) {
+      throw new IllegalArgumentException("Cannot compress input " + nextData + " with more than " + NUM_DATA_BITS + " bits (at offSet " + offset + ")");
+    }
+
+    // Check whether a bigger number of bits can be used:
+    while ((inputCompressable * (minBits+1)) <= NUM_DATA_BITS) {
+      minBits++;
+    }
+
+    if (((inputCompressable+1) * minBits) <= NUM_DATA_BITS) {
+      // not enough input available for minBits
+      minBits++;
+      // do not compress all available input
+      inputCompressable = NUM_DATA_BITS / minBits;
+    }
+
+    // Put compression method in status bits and encode input data
+    long s9;
+    switch (minBits) { // add status bits and later input values
+    case 60:
+      s9 = STATUS_1NUM_60BITS;
+      s9 |= (long) (uncompressed[offset]) << 4;
+      return s9;
+    case 30:
+      s9 = STATUS_2NUM_30BITS;
+      s9 |= (long) (uncompressed[offset]) << 4;
+      s9 |= (long) (uncompressed[offset+1]) << 34;
+      return s9;
+    case 20:
+      s9 = STATUS_3NUM_20BITS;
+      s9 |= (long) (uncompressed[offset]) << 4;
+      s9 |= (long) (uncompressed[offset+1]) << 24;
+      s9 |= (long) (uncompressed[offset+2]) << 44;
+      return s9;
+    case 15:
+      s9 = STATUS_4NUM_15BITS;
+      s9 |= ((long) (uncompressed[offset]) << 4);
+      s9 |= (long) (uncompressed[offset+1]) << 19;
+      s9 |= (long) (uncompressed[offset+2]) << 34;
+      s9 |= (long) (uncompressed[offset+3]) << 49;
+      return s9;
+    case 12:
+      s9 = STATUS_5NUM_12BITS;
+      s9 |= ((long) (uncompressed[offset]) << 4);
+      s9 |= (long) (uncompressed[offset+1]) << 16;
+      s9 |= (long) (uncompressed[offset+2]) << 28;
+      s9 |= (long) (uncompressed[offset+3]) << 40;
+      s9 |= (long) (uncompressed[offset+4]) << 52;
+      return s9;
+    case 10:
+      s9 = STATUS_6NUM_10BITS;
+      s9 |= ((long) (uncompressed[offset]) << 4);
+      s9 |= (long) (uncompressed[offset+1]) << 14;
+      s9 |= (long) (uncompressed[offset+2]) << 24;
+      s9 |= (long) (uncompressed[offset+3]) << 34;
+      s9 |= (long) (uncompressed[offset+4]) << 44;
+      s9 |= (long) (uncompressed[offset+5]) << 54;
+      return s9;
+    case 8:
+      s9 = STATUS_7NUM_8BITS;
+      s9 |= ((long) (uncompressed[offset]) << 4);
+      s9 |= (long) (uncompressed[offset+1]) << 12;
+      s9 |= (long) (uncompressed[offset+2]) << 20;
+      s9 |= (long) (uncompressed[offset+3]) << 28;
+      s9 |= (long) (uncompressed[offset+4]) << 36;
+      s9 |= (long) (uncompressed[offset+5]) << 44;
+      s9 |= (long) (uncompressed[offset+6]) << 52; // 4 more bits
+      return s9;
+    case 7:
+      s9 = STATUS_8NUM_7BITS;
+      s9 |= ((long) (uncompressed[offset]) << 4);
+      s9 |= (long) (uncompressed[offset+1]) << 11;
+      s9 |= (long) (uncompressed[offset+2]) << 18;
+      s9 |= (long) (uncompressed[offset+3]) << 25;
+      s9 |= (long) (uncompressed[offset+4]) << 32;
+      s9 |= (long) (uncompressed[offset+5]) << 39;
+      s9 |= (long) (uncompressed[offset+6]) << 46;
+      s9 |= (long) (uncompressed[offset+7]) << 53; // 4 more bits
+      return s9;
+    case 6:
+      s9 = STATUS_10NUM_6BITS;
+      s9 |= (long) (uncompressed[offset]) << 4;
+      s9 |= (long) (uncompressed[offset+1]) << 10;
+      s9 |= (long) (uncompressed[offset+2]) << 16;
+      s9 |= (long) (uncompressed[offset+3]) << 22;
+      s9 |= (long) (uncompressed[offset+4]) << 28;
+      s9 |= (long) (uncompressed[offset+5]) << 34;
+      s9 |= (long) (uncompressed[offset+6]) << 40;
+      s9 |= (long) (uncompressed[offset+7]) << 46;
+      s9 |= (long) (uncompressed[offset+8]) << 52;
+      s9 |= (long) (uncompressed[offset+9]) << 58;
+      return s9;
+    case 5:
+      s9 = STATUS_12NUM_5BITS;
+      s9 |= (long) (uncompressed[offset]) << 4;
+      s9 |= (long) (uncompressed[offset+1]) << 9;
+      s9 |= (long) (uncompressed[offset+2]) << 14;
+      s9 |= (long) (uncompressed[offset+3]) << 19;
+      s9 |= (long) (uncompressed[offset+4]) << 24;
+      s9 |= (long) (uncompressed[offset+5]) << 29;
+      s9 |= (long) (uncompressed[offset+6]) << 34;
+      s9 |= (long) (uncompressed[offset+7]) << 39;
+      s9 |= (long) (uncompressed[offset+8]) << 44;
+      s9 |= (long) (uncompressed[offset+9]) << 49;
+      s9 |= (long) (uncompressed[offset+10]) << 54;
+      s9 |= (long) (uncompressed[offset+11]) << 59;
+      return s9;
+    case 4:
+      s9 = STATUS_15NUM_4BITS;
+      s9 |= (long) (uncompressed[offset]) << 4;
+      s9 |= (long) (uncompressed[offset+1]) << 8;
+      s9 |= (long) (uncompressed[offset+2]) << 12;
+      s9 |= (long) (uncompressed[offset+3]) << 16;
+      s9 |= (long) (uncompressed[offset+4]) << 20;
+      s9 |= (long) (uncompressed[offset+5]) << 24;
+      s9 |= (long) (uncompressed[offset+6]) << 28;
+      s9 |= (long) (uncompressed[offset+7]) << 32;
+      s9 |= (long) (uncompressed[offset+8]) << 36;
+      s9 |= (long) (uncompressed[offset+9]) << 40;
+      s9 |= (long) (uncompressed[offset+10]) << 44;
+      s9 |= (long) (uncompressed[offset+11]) << 48;
+      s9 |= (long) (uncompressed[offset+12]) << 52;
+      s9 |= (long) (uncompressed[offset+13]) << 56;
+      s9 |= (long) (uncompressed[offset+14]) << 60;
+      return s9;
+    case 3:
+      s9 = STATUS_20NUM_3BITS;
+      s9 |= (long) (uncompressed[offset]) << 4;
+      s9 |= (long) (uncompressed[offset+1]) << 7;
+      s9 |= (long) (uncompressed[offset+2]) << 10;
+      s9 |= (long) (uncompressed[offset+3]) << 13;
+      s9 |= (long) (uncompressed[offset+4]) << 16;
+      s9 |= (long) (uncompressed[offset+5]) << 19;
+      s9 |= (long) (uncompressed[offset+6]) << 22;
+      s9 |= (long) (uncompressed[offset+7]) << 25;
+      s9 |= (long) (uncompressed[offset+8]) << 28;
+      s9 |= (long) (uncompressed[offset+9]) << 31;
+      s9 |= (long) (uncompressed[offset+10]) << 34;
+      s9 |= (long) (uncompressed[offset+11]) << 37;
+      s9 |= (long) (uncompressed[offset+12]) << 40;
+      s9 |= (long) (uncompressed[offset+13]) << 43;
+      s9 |= (long) (uncompressed[offset+14]) << 46;
+      s9 |= (long) (uncompressed[offset+15]) << 49;
+      s9 |= (long) (uncompressed[offset+16]) << 52;
+      s9 |= (long) (uncompressed[offset+17]) << 55;
+      s9 |= (long) (uncompressed[offset+18]) << 58;
+      s9 |= (long) (uncompressed[offset+19]) << 61;
+      return s9;
+    case 2:
+      s9 = STATUS_30NUM_2BITS;
+      s9 |= (long) (uncompressed[offset]) << 4;
+      s9 |= (long) (uncompressed[offset+1]) << 6;
+      s9 |= (long) (uncompressed[offset+2]) << 8;
+      s9 |= (long) (uncompressed[offset+3]) << 10;
+      s9 |= (long) (uncompressed[offset+4]) << 12;
+      s9 |= (long) (uncompressed[offset+5]) << 14;
+      s9 |= (long) (uncompressed[offset+6]) << 16;
+      s9 |= (long) (uncompressed[offset+7]) << 18;
+      s9 |= (long) (uncompressed[offset+8]) << 20;
+      s9 |= (long) (uncompressed[offset+9]) << 22;
+      s9 |= (long) (uncompressed[offset+10]) << 24;
+      s9 |= (long) (uncompressed[offset+11]) << 26;
+      s9 |= (long) (uncompressed[offset+12]) << 28;
+      s9 |= (long) (uncompressed[offset+13]) << 30;
+      s9 |= (long) (uncompressed[offset+14]) << 32;
+      s9 |= (long) (uncompressed[offset+15]) << 34;
+      s9 |= (long) (uncompressed[offset+16]) << 36;
+      s9 |= (long) (uncompressed[offset+17]) << 38;
+      s9 |= (long) (uncompressed[offset+18]) << 40;
+      s9 |= (long) (uncompressed[offset+19]) << 42;
+      s9 |= (long) (uncompressed[offset+20]) << 44;
+      s9 |= (long) (uncompressed[offset+21]) << 46;
+      s9 |= (long) (uncompressed[offset+22]) << 48;
+      s9 |= (long) (uncompressed[offset+23]) << 50;
+      s9 |= (long) (uncompressed[offset+24]) << 52;
+      s9 |= (long) (uncompressed[offset+25]) << 54;
+      s9 |= (long) (uncompressed[offset+26]) << 56;
+      s9 |= (long) (uncompressed[offset+27]) << 58;
+      s9 |= (long) (uncompressed[offset+28]) << 60;
+      s9 |= (long) (uncompressed[offset+29]) << 62;
+      return s9;
+    case 1:
+      s9 = STATUS_60NUM_1BITS;
+      s9 |= (long) (uncompressed[offset]) << 4;
+      s9 |= (long) (uncompressed[offset+1]) << 5;
+      s9 |= (long) (uncompressed[offset+2]) << 6;
+      s9 |= (long) (uncompressed[offset+3]) << 7;
+      s9 |= (long) (uncompressed[offset+4]) << 8;
+      s9 |= (long) (uncompressed[offset+5]) << 9;
+      s9 |= (long) (uncompressed[offset+6]) << 10;
+      s9 |= (long) (uncompressed[offset+7]) << 11;
+      s9 |= (long) (uncompressed[offset+8]) << 12;
+      s9 |= (long) (uncompressed[offset+9]) << 13;
+      s9 |= (long) (uncompressed[offset+10]) << 14;
+      s9 |= (long) (uncompressed[offset+11]) << 15;
+      s9 |= (long) (uncompressed[offset+12]) << 16;
+      s9 |= (long) (uncompressed[offset+13]) << 17;
+      s9 |= (long) (uncompressed[offset+14]) << 18;
+      s9 |= (long) (uncompressed[offset+15]) << 19;
+      s9 |= (long) (uncompressed[offset+16]) << 20;
+      s9 |= (long) (uncompressed[offset+17]) << 21;
+      s9 |= (long) (uncompressed[offset+18]) << 22;
+      s9 |= (long) (uncompressed[offset+19]) << 23;
+      s9 |= (long) (uncompressed[offset+20]) << 24;
+      s9 |= (long) (uncompressed[offset+21]) << 25;
+      s9 |= (long) (uncompressed[offset+22]) << 26;
+      s9 |= (long) (uncompressed[offset+23]) << 27;
+      s9 |= (long) (uncompressed[offset+24]) << 28;
+      s9 |= (long) (uncompressed[offset+25]) << 29;
+      s9 |= (long) (uncompressed[offset+26]) << 30;
+      s9 |= (long) (uncompressed[offset+27]) << 31;
+      s9 |= (long) (uncompressed[offset+28]) << 32;
+      s9 |= (long) (uncompressed[offset+29]) << 33;
+      s9 |= (long) (uncompressed[offset+30]) << 34;
+      s9 |= (long) (uncompressed[offset+31]) << 35;
+      s9 |= (long) (uncompressed[offset+32]) << 36;
+      s9 |= (long) (uncompressed[offset+33]) << 37;
+      s9 |= (long) (uncompressed[offset+34]) << 38;
+      s9 |= (long) (uncompressed[offset+35]) << 39;
+      s9 |= (long) (uncompressed[offset+36]) << 40;
+      s9 |= (long) (uncompressed[offset+37]) << 41;
+      s9 |= (long) (uncompressed[offset+38]) << 42;
+      s9 |= (long) (uncompressed[offset+39]) << 43;
+      s9 |= (long) (uncompressed[offset+40]) << 44;
+      s9 |= (long) (uncompressed[offset+41]) << 45;
+      s9 |= (long) (uncompressed[offset+42]) << 46;
+      s9 |= (long) (uncompressed[offset+43]) << 47;
+      s9 |= (long) (uncompressed[offset+44]) << 48;
+      s9 |= (long) (uncompressed[offset+45]) << 49;
+      s9 |= (long) (uncompressed[offset+46]) << 50;
+      s9 |= (long) (uncompressed[offset+47]) << 51;
+      s9 |= (long) (uncompressed[offset+48]) << 52;
+      s9 |= (long) (uncompressed[offset+49]) << 53;
+      s9 |= (long) (uncompressed[offset+50]) << 54;
+      s9 |= (long) (uncompressed[offset+51]) << 55;
+      s9 |= (long) (uncompressed[offset+52]) << 56;
+      s9 |= (long) (uncompressed[offset+53]) << 57;
+      s9 |= (long) (uncompressed[offset+54]) << 58;
+      s9 |= (long) (uncompressed[offset+55]) << 59;
+      s9 |= (long) (uncompressed[offset+56]) << 60;
+      s9 |= (long) (uncompressed[offset+57]) << 61;
+      s9 |= (long) (uncompressed[offset+58]) << 62;
+      s9 |= (long) (uncompressed[offset+59]) << 63;
+      return s9;
+    default:
+      throw new Error("S98b.compressSingle internal error: unknown minBits: " + minBits);
+    }
+  }
+
+  public static int decompressSingle(final long compressed, final int[] decompressed, final int offset) {
+    switch ((int) (compressed & 15)) {
+    case STATUS_1NUM_60BITS:
+      decompressed[offset] = (int) ((compressed >>> 4) & BITS_60_MASK); // The value can't be bigger than 2^32-1
+      return 1;
+    case STATUS_2NUM_30BITS:
+      decompressed[offset] = (int) ((compressed >>> 4) & BITS_30_MASK);
+      decompressed[offset+1] = (int) ((compressed >>> 34) & BITS_30_MASK);
+      return 2;
+    case STATUS_3NUM_20BITS:
+      decompressed[offset] = (int) ((compressed >>> 4) & BITS_20_MASK);
+      decompressed[offset+1] = (int) ((compressed >>> 24) & BITS_20_MASK);
+      decompressed[offset+2] = (int) ((compressed >>> 44) & BITS_20_MASK);
+      return 3;
+    case STATUS_4NUM_15BITS:
+      decompressed[offset] = (int) ((compressed >>> 4) & BITS_15_MASK);
+      decompressed[offset+1] = (int) ((compressed >>> 19) & BITS_15_MASK);
+      decompressed[offset+2] = (int) ((compressed >>> 34) & BITS_15_MASK);
+      decompressed[offset+3] = (int) ((compressed >>> 49) & BITS_15_MASK);
+      return 4;
+    case STATUS_5NUM_12BITS:
+      decompressed[offset] = (int) ((compressed >>> 4) & BITS_12_MASK);
+      decompressed[offset+1] = (int) ((compressed >>> 16) & BITS_12_MASK);
+      decompressed[offset+2] = (int) ((compressed >>> 28) & BITS_12_MASK);
+      decompressed[offset+3] = (int) ((compressed >>> 40) & BITS_12_MASK);
+      decompressed[offset+4] = (int) ((compressed >>> 52) & BITS_12_MASK);
+      return 5;
+    case STATUS_6NUM_10BITS:
+      decompressed[offset] = (int) ((compressed >>> 4) & BITS_10_MASK);
+      decompressed[offset+1] = (int) ((compressed >>> 14) & BITS_10_MASK);
+      decompressed[offset+2] = (int) ((compressed >>> 24) & BITS_10_MASK);
+      decompressed[offset+3] = (int) ((compressed >>> 34) & BITS_10_MASK);
+      decompressed[offset+4] = (int) ((compressed >>> 44) & BITS_10_MASK);
+      decompressed[offset+5] = (int) ((compressed >>> 54) & BITS_10_MASK);
+      return 6;
+    case STATUS_7NUM_8BITS:
+      decompressed[offset] = (int) ((compressed >>> 4) & BITS_8_MASK);
+      decompressed[offset+1] = (int) ((compressed >>> 12) & BITS_8_MASK);
+      decompressed[offset+2] = (int) ((compressed >>> 20) & BITS_8_MASK);
+      decompressed[offset+3] = (int) ((compressed >>> 28) & BITS_8_MASK);
+      decompressed[offset+4] = (int) ((compressed >>> 36) & BITS_8_MASK);
+      decompressed[offset+5] = (int) ((compressed >>> 44) & BITS_8_MASK);
+      decompressed[offset+6] = (int) ((compressed >>> 52) & BITS_12_MASK);
+      return 7;
+    case STATUS_8NUM_7BITS:
+      decompressed[offset] = (int) ((compressed >>> 4) & BITS_7_MASK);
+      decompressed[offset+1] = (int) ((compressed >>> 11) & BITS_7_MASK);
+      decompressed[offset+2] = (int) ((compressed >>> 18) & BITS_7_MASK);
+      decompressed[offset+3] = (int) ((compressed >>> 25) & BITS_7_MASK);
+      decompressed[offset+4] = (int) ((compressed >>> 32) & BITS_7_MASK);
+      decompressed[offset+5] = (int) ((compressed >>> 39) & BITS_7_MASK);
+      decompressed[offset+6] = (int) ((compressed >>> 46) & BITS_7_MASK);
+      decompressed[offset+7] = (int) ((compressed >>> 53) & BITS_11_MASK);
+      return 8;
+    case STATUS_10NUM_6BITS:
+      decompressed[offset] = (int) ((compressed >>> 4) & BITS_6_MASK);
+      decompressed[offset+1] = (int) ((compressed >>> 10) & BITS_6_MASK);
+      decompressed[offset+2] = (int) ((compressed >>> 16) & BITS_6_MASK);
+      decompressed[offset+3] = (int) ((compressed >>> 22) & BITS_6_MASK);
+      decompressed[offset+4] = (int) ((compressed >>> 28) & BITS_6_MASK);
+      decompressed[offset+5] = (int) ((compressed >>> 34) & BITS_6_MASK);
+      decompressed[offset+6] = (int) ((compressed >>> 40) & BITS_6_MASK);
+      decompressed[offset+7] = (int) ((compressed >>> 46) & BITS_6_MASK);
+      decompressed[offset+8] = (int) ((compressed >>> 52) & BITS_6_MASK);
+      decompressed[offset+9] = (int) ((compressed >>> 58) & BITS_6_MASK);
+      return 10;
+    case STATUS_12NUM_5BITS:
+      decompressed[offset] = (int) ((compressed >>> 4) & BITS_5_MASK);
+      decompressed[offset+1] = (int) ((compressed >>> 9) & BITS_5_MASK);
+      decompressed[offset+2] = (int) ((compressed >>> 14) & BITS_5_MASK);
+      decompressed[offset+3] = (int) ((compressed >>> 19) & BITS_5_MASK);
+      decompressed[offset+4] = (int) ((compressed >>> 24) & BITS_5_MASK);
+      decompressed[offset+5] = (int) ((compressed >>> 29) & BITS_5_MASK);
+      decompressed[offset+6] = (int) ((compressed >>> 34) & BITS_5_MASK);
+      decompressed[offset+7] = (int) ((compressed >>> 39) & BITS_5_MASK);
+      decompressed[offset+8] = (int) ((compressed >>> 44) & BITS_5_MASK);
+      decompressed[offset+9] = (int) ((compressed >>> 49) & BITS_5_MASK);
+      decompressed[offset+10] = (int) ((compressed >>> 54) & BITS_5_MASK);
+      decompressed[offset+11] = (int) ((compressed >>> 59) & BITS_5_MASK);
+      return 12;
+    case STATUS_15NUM_4BITS:
+      decompressed[offset] = (int) ((compressed >>> 4) & BITS_4_MASK);
+      decompressed[offset+1] = (int) ((compressed >>> 8) & BITS_4_MASK);
+      decompressed[offset+2] = (int) ((compressed >>> 12) & BITS_4_MASK);
+      decompressed[offset+3] = (int) ((compressed >>> 16) & BITS_4_MASK);
+      decompressed[offset+4] = (int) ((compressed >>> 20) & BITS_4_MASK);
+      decompressed[offset+5] = (int) ((compressed >>> 24) & BITS_4_MASK);
+      decompressed[offset+6] = (int) ((compressed >>> 28) & BITS_4_MASK);
+      decompressed[offset+7] = (int) ((compressed >>> 32) & BITS_4_MASK);
+      decompressed[offset+8] = (int) ((compressed >>> 36) & BITS_4_MASK);
+      decompressed[offset+9] = (int) ((compressed >>> 40) & BITS_4_MASK);
+      decompressed[offset+10] = (int) ((compressed >>> 44) & BITS_4_MASK);
+      decompressed[offset+11] = (int) ((compressed >>> 48) & BITS_4_MASK);
+      decompressed[offset+12] = (int) ((compressed >>> 52) & BITS_4_MASK);
+      decompressed[offset+13] = (int) ((compressed >>> 56) & BITS_4_MASK);
+      decompressed[offset+14] = (int) ((compressed >>> 60) & BITS_4_MASK);
+      return 15;
+    case STATUS_20NUM_3BITS:
+      decompressed[offset] = (int) ((compressed >>> 4) & BITS_3_MASK);
+      decompressed[offset+1] = (int) ((compressed >>> 7) & BITS_3_MASK);
+      decompressed[offset+2] = (int) ((compressed >>> 10) & BITS_3_MASK);
+      decompressed[offset+3] = (int) ((compressed >>> 13) & BITS_3_MASK);
+      decompressed[offset+4] = (int) ((compressed >>> 16) & BITS_3_MASK);
+      decompressed[offset+5] = (int) ((compressed >>> 19) & BITS_3_MASK);
+      decompressed[offset+6] = (int) ((compressed >>> 22) & BITS_3_MASK);
+      decompressed[offset+7] = (int) ((compressed >>> 25) & BITS_3_MASK);
+      decompressed[offset+8] = (int) ((compressed >>> 28) & BITS_3_MASK);
+      decompressed[offset+9] = (int) ((compressed >>> 31) & BITS_3_MASK);
+      decompressed[offset+10] = (int) ((compressed >>> 34) & BITS_3_MASK);
+      decompressed[offset+11] = (int) ((compressed >>> 37) & BITS_3_MASK);
+      decompressed[offset+12] = (int) ((compressed >>> 40) & BITS_3_MASK);
+      decompressed[offset+13] = (int) ((compressed >>> 43) & BITS_3_MASK);
+      decompressed[offset+14] = (int) ((compressed >>> 46) & BITS_3_MASK);
+      decompressed[offset+15] = (int) ((compressed >>> 49) & BITS_3_MASK);
+      decompressed[offset+16] = (int) ((compressed >>> 52) & BITS_3_MASK);
+      decompressed[offset+17] = (int) ((compressed >>> 55) & BITS_3_MASK);
+      decompressed[offset+18] = (int) ((compressed >>> 58) & BITS_3_MASK);
+      decompressed[offset+19] = (int) ((compressed >>> 61) & BITS_3_MASK);
+      return 20;
+    case STATUS_30NUM_2BITS:
+      decompressed[offset] = (int) ((compressed >>> 4) & BITS_2_MASK);
+      decompressed[offset+1] = (int) ((compressed >>> 6) & BITS_2_MASK);
+      decompressed[offset+2] = (int) ((compressed >>> 8) & BITS_2_MASK);
+      decompressed[offset+3] = (int) ((compressed >>> 10) & BITS_2_MASK);
+      decompressed[offset+4] = (int) ((compressed >>> 12) & BITS_2_MASK);
+      decompressed[offset+5] = (int) ((compressed >>> 14) & BITS_2_MASK);
+      decompressed[offset+6] = (int) ((compressed >>> 16) & BITS_2_MASK);
+      decompressed[offset+7] = (int) ((compressed >>> 18) & BITS_2_MASK);
+      decompressed[offset+8] = (int) ((compressed >>> 20) & BITS_2_MASK);
+      decompressed[offset+9] = (int) ((compressed >>> 22) & BITS_2_MASK);
+      decompressed[offset+10] = (int) ((compressed >>> 24) & BITS_2_MASK);
+      decompressed[offset+11] = (int) ((compressed >>> 26) & BITS_2_MASK);
+      decompressed[offset+12] = (int) ((compressed >>> 28) & BITS_2_MASK);
+      decompressed[offset+13] = (int) ((compressed >>> 30) & BITS_2_MASK);
+      decompressed[offset+14] = (int) ((compressed >>> 32) & BITS_2_MASK);
+      decompressed[offset+15] = (int) ((compressed >>> 34) & BITS_2_MASK);
+      decompressed[offset+16] = (int) ((compressed >>> 36) & BITS_2_MASK);
+      decompressed[offset+17] = (int) ((compressed >>> 38) & BITS_2_MASK);
+      decompressed[offset+18] = (int) ((compressed >>> 40) & BITS_2_MASK);
+      decompressed[offset+19] = (int) ((compressed >>> 42) & BITS_2_MASK);
+      decompressed[offset+20] = (int) ((compressed >>> 44) & BITS_2_MASK);
+      decompressed[offset+21] = (int) ((compressed >>> 46) & BITS_2_MASK);
+      decompressed[offset+22] = (int) ((compressed >>> 48) & BITS_2_MASK);
+      decompressed[offset+23] = (int) ((compressed >>> 50) & BITS_2_MASK);
+      decompressed[offset+24] = (int) ((compressed >>> 52) & BITS_2_MASK);
+      decompressed[offset+25] = (int) ((compressed >>> 54) & BITS_2_MASK);
+      decompressed[offset+26] = (int) ((compressed >>> 56) & BITS_2_MASK);
+      decompressed[offset+27] = (int) ((compressed >>> 58) & BITS_2_MASK);
+      decompressed[offset+28] = (int) ((compressed >>> 60) & BITS_2_MASK);
+      decompressed[offset+29] = (int) ((compressed >>> 62) & BITS_2_MASK);
+      return 30;
+    case STATUS_60NUM_1BITS:
+      decompressed[offset] = (int) ((compressed >>> 4) & BITS_1_MASK);
+      decompressed[offset+1] = (int) ((compressed >>> 5) & BITS_1_MASK);
+      decompressed[offset+2] = (int) ((compressed >>> 6) & BITS_1_MASK);
+      decompressed[offset+3] = (int) ((compressed >>> 7) & BITS_1_MASK);
+      decompressed[offset+4] = (int) ((compressed >>> 8) & BITS_1_MASK);
+      decompressed[offset+5] = (int) ((compressed >>> 9) & BITS_1_MASK);
+      decompressed[offset+6] = (int) ((compressed >>> 10) & BITS_1_MASK);
+      decompressed[offset+7] = (int) ((compressed >>> 11) & BITS_1_MASK);
+      decompressed[offset+8] = (int) ((compressed >>> 12) & BITS_1_MASK);
+      decompressed[offset+9] = (int) ((compressed >>> 13) & BITS_1_MASK);
+      decompressed[offset+10] = (int) ((compressed >>> 14) & BITS_1_MASK);
+      decompressed[offset+11] = (int) ((compressed >>> 15) & BITS_1_MASK);
+      decompressed[offset+12] = (int) ((compressed >>> 16) & BITS_1_MASK);
+      decompressed[offset+13] = (int) ((compressed >>> 17) & BITS_1_MASK);
+      decompressed[offset+14] = (int) ((compressed >>> 18) & BITS_1_MASK);
+      decompressed[offset+15] = (int) ((compressed >>> 19) & BITS_1_MASK);
+      decompressed[offset+16] = (int) ((compressed >>> 20) & BITS_1_MASK);
+      decompressed[offset+17] = (int) ((compressed >>> 21) & BITS_1_MASK);
+      decompressed[offset+18] = (int) ((compressed >>> 22) & BITS_1_MASK);
+      decompressed[offset+19] = (int) ((compressed >>> 23) & BITS_1_MASK);
+      decompressed[offset+20] = (int) ((compressed >>> 24) & BITS_1_MASK);
+      decompressed[offset+21] = (int) ((compressed >>> 25) & BITS_1_MASK);
+      decompressed[offset+22] = (int) ((compressed >>> 26) & BITS_1_MASK);
+      decompressed[offset+23] = (int) ((compressed >>> 27) & BITS_1_MASK);
+      decompressed[offset+24] = (int) ((compressed >>> 28) & BITS_1_MASK);
+      decompressed[offset+25] = (int) ((compressed >>> 29) & BITS_1_MASK);
+      decompressed[offset+26] = (int) ((compressed >>> 30) & BITS_1_MASK);
+      decompressed[offset+27] = (int) ((compressed >>> 31) & BITS_1_MASK);
+      decompressed[offset+28] = (int) ((compressed >>> 32) & BITS_1_MASK);
+      decompressed[offset+29] = (int) ((compressed >>> 33) & BITS_1_MASK);
+      decompressed[offset+30] = (int) ((compressed >>> 34) & BITS_1_MASK);
+      decompressed[offset+31] = (int) ((compressed >>> 35) & BITS_1_MASK);
+      decompressed[offset+32] = (int) ((compressed >>> 36) & BITS_1_MASK);
+      decompressed[offset+33] = (int) ((compressed >>> 37) & BITS_1_MASK);
+      decompressed[offset+34] = (int) ((compressed >>> 38) & BITS_1_MASK);
+      decompressed[offset+35] = (int) ((compressed >>> 39) & BITS_1_MASK);
+      decompressed[offset+36] = (int) ((compressed >>> 40) & BITS_1_MASK);
+      decompressed[offset+37] = (int) ((compressed >>> 41) & BITS_1_MASK);
+      decompressed[offset+38] = (int) ((compressed >>> 42) & BITS_1_MASK);
+      decompressed[offset+39] = (int) ((compressed >>> 43) & BITS_1_MASK);
+      decompressed[offset+40] = (int) ((compressed >>> 44) & BITS_1_MASK);
+      decompressed[offset+41] = (int) ((compressed >>> 45) & BITS_1_MASK);
+      decompressed[offset+42] = (int) ((compressed >>> 46) & BITS_1_MASK);
+      decompressed[offset+43] = (int) ((compressed >>> 47) & BITS_1_MASK);
+      decompressed[offset+44] = (int) ((compressed >>> 48) & BITS_1_MASK);
+      decompressed[offset+45] = (int) ((compressed >>> 49) & BITS_1_MASK);
+      decompressed[offset+46] = (int) ((compressed >>> 50) & BITS_1_MASK);
+      decompressed[offset+47] = (int) ((compressed >>> 51) & BITS_1_MASK);
+      decompressed[offset+48] = (int) ((compressed >>> 52) & BITS_1_MASK);
+      decompressed[offset+49] = (int) ((compressed >>> 53) & BITS_1_MASK);
+      decompressed[offset+50] = (int) ((compressed >>> 54) & BITS_1_MASK);
+      decompressed[offset+51] = (int) ((compressed >>> 55) & BITS_1_MASK);
+      decompressed[offset+52] = (int) ((compressed >>> 56) & BITS_1_MASK);
+      decompressed[offset+53] = (int) ((compressed >>> 57) & BITS_1_MASK);
+      decompressed[offset+54] = (int) ((compressed >>> 58) & BITS_1_MASK);
+      decompressed[offset+55] = (int) ((compressed >>> 59) & BITS_1_MASK);
+      decompressed[offset+56] = (int) ((compressed >>> 60) & BITS_1_MASK);
+      decompressed[offset+57] = (int) ((compressed >>> 61) & BITS_1_MASK);
+      decompressed[offset+58] = (int) ((compressed >>> 62) & BITS_1_MASK);
+      decompressed[offset+59] = (int) ((compressed >>> 63) & BITS_1_MASK);
+      return 60;
+    default:
+      throw new IllegalArgumentException("Unknown Simple9 status: " + (compressed >>> NUM_DATA_BITS));
+    }
+  }
+  
+  public static int size(long compressed) {
+    switch ((int) (compressed & 15)) {
+      case STATUS_1NUM_60BITS: return 1;
+      case STATUS_2NUM_30BITS: return 2;
+      case STATUS_3NUM_20BITS: return 3;
+      case STATUS_4NUM_15BITS: return 4;
+      case STATUS_5NUM_12BITS: return 5;
+      case STATUS_6NUM_10BITS: return 6;
+      case STATUS_7NUM_8BITS:  return 7;
+      case STATUS_8NUM_7BITS:  return 8;
+      case STATUS_10NUM_6BITS: return 10;
+      case STATUS_12NUM_5BITS: return 12;
+      case STATUS_15NUM_4BITS: return 15;
+      case STATUS_20NUM_3BITS: return 20;
+      case STATUS_30NUM_2BITS: return 30;
+      case STATUS_60NUM_1BITS: return 60;
+      default:
+        throw new IllegalArgumentException("Unknown Simple9 status: " + (compressed >>> NUM_DATA_BITS));
+    }
+  }
+}

Property changes on: lucene/core/src/java/org/apache/lucene/util/Simple64.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
