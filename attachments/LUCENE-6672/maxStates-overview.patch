diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java b/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java
index e7ca8a9..4835748 100644
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java
@@ -691,10 +691,24 @@
     private final BitSet isAccept;
     private int[] transitions;
     private int nextTransition = 0;
+    private final int maxStates;
 
     /** Default constructor, pre-allocating for 16 states and transitions. */
     public Builder() {
        this(16, 16);
+    }
+
+    /**
+     * Constructor which creates a builder with enough space for the given
+     * number of states and transitions.
+     *
+     * @param numStates
+     *           Number of states.
+     * @param numTransitions
+     *           Number of transitions.
+     */
+    public Builder(int numStates, int numTransitions) {
+      this(numStates, numTransitions, Integer.MAX_VALUE);
     }
 
     /**
@@ -705,10 +719,13 @@
      *           Number of states.
      * @param numTransitions
      *           Number of transitions.
+     * @param maxStates
+     *           Maximum number of states.
      */
-    public Builder(int numStates, int numTransitions) {
+    public Builder(int numStates, int numTransitions, int maxStates) {
        isAccept = new BitSet(numStates);
        transitions = new int[numTransitions * 4];
+       this.maxStates = maxStates;
     }
 
     /** Add a new transition with min = max = label. */
@@ -719,6 +736,8 @@
     /** Add a new transition with the specified source, dest, min, max. */
     public void addTransition(int source, int dest, int min, int max) {
       if (transitions.length < nextTransition+4) {
+        // check the number of states before allocating more memory
+        checkSize();
         transitions = ArrayUtil.grow(transitions, nextTransition+4);
       }
       transitions[nextTransition++] = source;
@@ -741,6 +760,14 @@
       }
     }
 
+    /** Check if the builder could result in a automaton that has more than maxStates.
+     * @throws TooManyStatesException if the current builder generate an automata with
+     * more than maxStates */
+    private void checkSize() {
+      if(nextState >= maxStates) {
+        throw new TooManyStatesException("Building the automaton would result in more than " + maxStates + " states.");
+      }
+    }
     /** Sorts transitions first then min label ascending, then
      *  max label ascending, then dest ascending */
     private final Sorter sorter = new InPlaceMergeSorter() {
@@ -809,6 +836,7 @@
     /** Compiles all added states and transitions into a new {@code Automaton}
      *  and returns it. */
     public Automaton finish() {
+      checkSize();
       // Create automaton with the correct size.
       int numStates = nextState;
       int numTransitions = nextTransition / 4;
@@ -887,6 +915,13 @@
     }
   }
 
+  /** Exception thrown to avoid the Automaton Builder to generate too many states */
+  public static class TooManyStatesException extends RuntimeException {
+    public TooManyStatesException(String message) {
+      super(message);
+    }
+  }
+
   @Override
   public long ramBytesUsed() {
     // TODO: BitSet RAM usage (isAccept.size()/8) isn't fully accurate...