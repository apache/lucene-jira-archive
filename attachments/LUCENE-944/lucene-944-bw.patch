Index: test/org/apache/lucene/search/TestSort.java
===================================================================
--- test/org/apache/lucene/search/TestSort.java	(revision 824841)
+++ test/org/apache/lucene/search/TestSort.java	(working copy)
@@ -837,11 +837,6 @@
         "OutOfOrderOneComparatorScoringMaxScoreCollector" 
     };
     
-    // Save the original value to set later.
-    boolean origVal = BooleanQuery.getAllowDocsOutOfOrder();
-    
-    BooleanQuery.setAllowDocsOutOfOrder(true);
-    
     BooleanQuery bq = new BooleanQuery();
     // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2
     // which delegates to BS if there are no mandatory clauses.
@@ -849,28 +844,20 @@
     // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return
     // the clause instead of BQ.
     bq.setMinimumNumberShouldMatch(1);
-    try {
-      for (int i = 0; i < sort.length; i++) {
-        for (int j = 0; j < tfcOptions.length; j++) {
-          TopDocsCollector tdc = TopFieldCollector.create(sort[i], 10,
-              tfcOptions[j][0], tfcOptions[j][1], tfcOptions[j][2], false);
+    for (int i = 0; i < sort.length; i++) {
+      for (int j = 0; j < tfcOptions.length; j++) {
+        TopDocsCollector tdc = TopFieldCollector.create(sort[i], 10,
+            tfcOptions[j][0], tfcOptions[j][1], tfcOptions[j][2], false);
 
-          assertTrue(tdc.getClass().getName().endsWith("$"+actualTFCClasses[j]));
-          
-          full.search(bq, tdc);
-          
-          TopDocs td = tdc.topDocs();
-          ScoreDoc[] sd = td.scoreDocs;
-          assertEquals(10, sd.length);
-        }
+        assertTrue(tdc.getClass().getName().endsWith("$"+actualTFCClasses[j]));
+        
+        full.search(bq, tdc);
+        
+        TopDocs td = tdc.topDocs();
+        ScoreDoc[] sd = td.scoreDocs;
+        assertEquals(10, sd.length);
       }
-    } finally {
-      // Whatever happens, reset BooleanQuery.allowDocsOutOfOrder to the
-      // original value. Don't set it to false in case the implementation in BQ
-      // will change some day.
-      BooleanQuery.setAllowDocsOutOfOrder(origVal);
     }
-
   }
   
   public void testSortWithScoreAndMaxScoreTrackingNoResults() throws Exception {
Index: test/org/apache/lucene/search/TestBoolean2.java
===================================================================
--- test/org/apache/lucene/search/TestBoolean2.java	(revision 824841)
+++ test/org/apache/lucene/search/TestBoolean2.java	(working copy)
@@ -66,19 +66,18 @@
   public void queriesTest(String queryText, int[] expDocNrs) throws Exception {
 //System.out.println();
 //System.out.println("Query: " + queryText);
-    try {
-      Query query1 = makeQuery(queryText);
-      BooleanQuery.setAllowDocsOutOfOrder(true);
-      ScoreDoc[] hits1 = searcher.search(query1, null, 1000).scoreDocs;
 
-      Query query2 = makeQuery(queryText); // there should be no need to parse again...
-      BooleanQuery.setAllowDocsOutOfOrder(false);
-      ScoreDoc[] hits2 = searcher.search(query2, null, 1000).scoreDocs;
-
-      CheckHits.checkHitsQuery(query2, hits1, hits2, expDocNrs);
-    } finally { // even when a test fails.
-      BooleanQuery.setAllowDocsOutOfOrder(false);
-    }
+    Query query1 = makeQuery(queryText);
+    TopScoreDocCollector collector = TopScoreDocCollector.create(1000, false);
+    searcher.search(query1, null, collector);
+    ScoreDoc[] hits1 = collector.topDocs().scoreDocs;
+    
+    Query query2 = makeQuery(queryText); // there should be no need to parse again...
+    collector = TopScoreDocCollector.create(1000, true);
+    searcher.search(query2, null, collector);
+    ScoreDoc[] hits2 = collector.topDocs().scoreDocs; 
+      
+    CheckHits.checkHitsQuery(query2, hits1, hits2, expDocNrs);
   }
 
   public void testQueries01() throws Exception {
@@ -165,14 +164,19 @@
         // match up.
         Sort sort = Sort.INDEXORDER;
 
-        BooleanQuery.setAllowDocsOutOfOrder(false);
-
         QueryUtils.check(q1,searcher);
 
-        ScoreDoc[] hits1 = searcher.search(q1,null, 1000, sort).scoreDocs;
+        TopFieldCollector collector = TopFieldCollector.create(sort, 1000,
+            false, true, true, true);
 
-        BooleanQuery.setAllowDocsOutOfOrder(true);
-        ScoreDoc[] hits2 = searcher.search(q1,null, 1000, sort).scoreDocs;
+        searcher.search(q1, null, collector);
+        ScoreDoc[] hits1 = collector.topDocs().scoreDocs;
+
+        collector = TopFieldCollector.create(sort, 1000,
+            false, true, true, false);
+        
+        searcher.search(q1, null, collector);
+        ScoreDoc[] hits2 = collector.topDocs().scoreDocs;
         tot+=hits2.length;
         CheckHits.checkEqual(q1, hits1, hits2);
       }
@@ -181,8 +185,6 @@
       // For easier debugging
       System.out.println("failed query: " + q1);
       throw e;
-    } finally { // even when a test fails.
-      BooleanQuery.setAllowDocsOutOfOrder(false);
     }
 
     // System.out.println("Total hits:"+tot);
Index: test/org/apache/lucene/search/TestTopScoreDocCollector.java
===================================================================
--- test/org/apache/lucene/search/TestTopScoreDocCollector.java	(revision 824841)
+++ test/org/apache/lucene/search/TestTopScoreDocCollector.java	(working copy)
@@ -50,11 +50,6 @@
         "InOrderTopScoreDocCollector" 
     };
     
-    // Save the original value to set later.
-    boolean origVal = BooleanQuery.getAllowDocsOutOfOrder();
-
-    BooleanQuery.setAllowDocsOutOfOrder(true);
-
     BooleanQuery bq = new BooleanQuery();
     // Add a Query with SHOULD, since bw.scorer() returns BooleanScorer2
     // which delegates to BS if there are no mandatory clauses.
@@ -62,28 +57,19 @@
     // Set minNrShouldMatch to 1 so that BQ will not optimize rewrite to return
     // the clause instead of BQ.
     bq.setMinimumNumberShouldMatch(1);
-    try {
+    IndexSearcher searcher = new IndexSearcher(dir, true);
+    for (int i = 0; i < inOrder.length; i++) {
+      TopDocsCollector tdc = TopScoreDocCollector.create(3, inOrder[i]);
+      assertEquals("org.apache.lucene.search.TopScoreDocCollector$" + actualTSDCClass[i], tdc.getClass().getName());
       
-      IndexSearcher searcher = new IndexSearcher(dir, true);
-      for (int i = 0; i < inOrder.length; i++) {
-        TopDocsCollector tdc = TopScoreDocCollector.create(3, inOrder[i]);
-        assertEquals("org.apache.lucene.search.TopScoreDocCollector$" + actualTSDCClass[i], tdc.getClass().getName());
-        
-        searcher.search(new MatchAllDocsQuery(), tdc);
-        
-        ScoreDoc[] sd = tdc.topDocs().scoreDocs;
-        assertEquals(3, sd.length);
-        for (int j = 0; j < sd.length; j++) {
-          assertEquals("expected doc Id " + j + " found " + sd[j].doc, j, sd[j].doc);
-        }
+      searcher.search(new MatchAllDocsQuery(), tdc);
+      
+      ScoreDoc[] sd = tdc.topDocs().scoreDocs;
+      assertEquals(3, sd.length);
+      for (int j = 0; j < sd.length; j++) {
+        assertEquals("expected doc Id " + j + " found " + sd[j].doc, j, sd[j].doc);
       }
-    } finally {
-      // Whatever happens, reset BooleanQuery.allowDocsOutOfOrder to the
-      // original value. Don't set it to false in case the implementation in BQ
-      // will change some day.
-      BooleanQuery.setAllowDocsOutOfOrder(origVal);
     }
-
   }
   
 }
Index: test/org/apache/lucene/search/QueryUtils.java
===================================================================
--- test/org/apache/lucene/search/QueryUtils.java	(revision 824841)
+++ test/org/apache/lucene/search/QueryUtils.java	(working copy)
@@ -16,6 +16,12 @@
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.MultiReader;
 import org.apache.lucene.index.IndexWriter.MaxFieldLength;
+import org.apache.lucene.search.Collector;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.Weight;
 import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.ReaderUtil;
 
@@ -257,7 +263,7 @@
   public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {
     //System.out.println("Checking "+q);
     
-    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().
+    if (q.weight(s).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().
 
     final int skip_op = 0;
     final int next_op = 1;
@@ -277,46 +283,46 @@
         // System.out.print(order[i]==skip_op ? " skip()":" next()");
         // System.out.println();
         final int opidx[] = { 0 };
+        final int lastDoc[] = {-1};
 
-        final Weight w = q.weight(s);
-        final Scorer scorer = w.scorer(s.getIndexReader(), true, false);
-        if (scorer == null) {
-          continue;
-        }
-
         // FUTURE: ensure scorer.doc()==-1
 
-        final int[] sdoc = new int[] { -1 };
         final float maxDiff = 1e-5f;
         s.search(q, new Collector() {
-          private int base = 0;
           private Scorer sc;
+          private IndexReader reader;
+          private Scorer scorer;
 
           public void setScorer(Scorer scorer) throws IOException {
             this.sc = scorer;
           }
 
           public void collect(int doc) throws IOException {
-            doc = doc + base;
             float score = sc.score();
+            lastDoc[0] = doc;
             try {
+              if (scorer == null) {
+                Weight w = q.weight(s);
+                scorer = w.scorer(reader, true, false);
+              }
+              
               int op = order[(opidx[0]++) % order.length];
               // System.out.println(op==skip_op ?
               // "skip("+(sdoc[0]+1)+")":"next()");
-              boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS
+              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS
                   : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;
-              sdoc[0] = scorer.docID();
+              int scorerDoc = scorer.docID();
               float scorerScore = scorer.score();
               float scorerScore2 = scorer.score();
               float scoreDiff = Math.abs(score - scorerScore);
               float scorerDiff = Math.abs(scorerScore2 - scorerScore);
-              if (!more || doc != sdoc[0] || scoreDiff > maxDiff
+              if (!more || doc != scorerDoc || scoreDiff > maxDiff
                   || scorerDiff > maxDiff) {
-                StringBuffer sbord = new StringBuffer();
+                StringBuilder sbord = new StringBuilder();
                 for (int i = 0; i < order.length; i++)
                   sbord.append(order[i] == skip_op ? " skip()" : " next()");
                 throw new RuntimeException("ERROR matching docs:" + "\n\t"
-                    + (doc != sdoc[0] ? "--> " : "") + "doc=" + sdoc[0]
+                    + (doc != scorerDoc ? "--> " : "") + "doc=" + doc + ", scorerDoc=" + scorerDoc
                     + "\n\t" + (!more ? "--> " : "") + "tscorer.more=" + more
                     + "\n\t" + (scoreDiff > maxDiff ? "--> " : "")
                     + "scorerScore=" + scorerScore + " scoreDiff=" + scoreDiff
@@ -335,7 +341,9 @@
           }
 
           public void setNextReader(IndexReader reader, int docBase) {
-            base = docBase;
+            this.reader = reader;
+            this.scorer = null;
+            lastDoc[0] = -1;
           }
 
           public boolean acceptsDocsOutOfOrder() {
@@ -343,12 +351,21 @@
           }
         });
 
-        // make sure next call to scorer is false.
-        int op = order[(opidx[0]++) % order.length];
-        // System.out.println(op==skip_op ? "last: skip()":"last: next()");
-        boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer
-            .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;
-        Assert.assertFalse(more);
+        List readerList = new ArrayList();
+        ReaderUtil.gatherSubReaders(readerList, s.getIndexReader());
+        IndexReader[] readers = (IndexReader[]) readerList.toArray(new IndexReader[0]);
+        for(int i = 0; i < readers.length; i++) {
+          IndexReader reader = readers[i];
+          Weight w = q.weight(s);
+          Scorer scorer = w.scorer(reader, true, false);
+          
+          if (scorer != null) {
+            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;
+      
+            if (more && lastDoc[0] != -1) 
+              Assert.assertFalse("query's last doc was "+ lastDoc[0] +" but skipTo("+(lastDoc[0]+1)+") got to "+scorer.docID(),more);
+          }
+        }
       }
   }
     
