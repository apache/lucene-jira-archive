diff --git a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomBinaryCodecTest.java b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomBinaryCodecTest.java
index ba9ee6e636..250b652306 100644
--- a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomBinaryCodecTest.java
+++ b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomBinaryCodecTest.java
@@ -27,18 +27,18 @@ import org.junit.Test;
 /**
  * Test to check Serialization
  */
-public class RandomBinaryCodecTest extends RandomGeoShapeGenerator{
+public class RandomBinaryCodecTest extends RandomGeo3dShapeGenerator {
 
   @Test
   @Repeat(iterations = 10)
   public void testRandomPointCodec() throws IOException{
     PlanetModel planetModel = randomPlanetModel();
-    GeoPoint shape = randomGeoPoint(planetModel, getEmptyConstraint());
+    GeoPoint shape = randomGeoPoint(planetModel);
     ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
     SerializableObject.writeObject(outputStream, shape);
     ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
     SerializableObject shapeCopy = SerializableObject.readObject(planetModel, inputStream);
-    assertEquals(shape, shapeCopy);
+    assertEquals(shape.toString(), shape, shapeCopy);
   }
 
   @Test
@@ -51,7 +51,7 @@ public class RandomBinaryCodecTest extends RandomGeoShapeGenerator{
     SerializableObject.writePlanetObject(outputStream, shape);
     ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
     SerializableObject shapeCopy = SerializableObject.readPlanetObject(inputStream);
-    assertEquals(shape, shapeCopy);
+    assertEquals(shape.toString(), shape, shapeCopy);
   }
 
   @Test
@@ -64,6 +64,6 @@ public class RandomBinaryCodecTest extends RandomGeoShapeGenerator{
     SerializableObject.writeObject(outputStream, shape);
     ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
     SerializableObject shapeCopy = SerializableObject.readObject(planetModel, inputStream);
-    assertEquals(shape, shapeCopy);
+    assertEquals(shape.toString(), shape, shapeCopy);
   }
 }
diff --git a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoShapeGenerator.java b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeo3dShapeGenerator.java
similarity index 92%
rename from lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoShapeGenerator.java
rename to lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeo3dShapeGenerator.java
index ca7aecdcc0..72b7109726 100644
--- a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoShapeGenerator.java
+++ b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeo3dShapeGenerator.java
@@ -36,7 +36,7 @@ import static com.carrotsearch.randomizedtesting.RandomizedTest.randomDouble;
  * created using GeoConvexPolygons and GeoConcavePolygons.
  *
  */
-public class RandomGeoShapeGenerator extends LuceneTestCase {
+public class RandomGeo3dShapeGenerator extends LuceneTestCase {
 
   /* Max num of iterations to find right shape under given constrains */
   final private static int MAX_SHAPE_ITERATIONS = 50;
@@ -53,19 +53,31 @@ public class RandomGeoShapeGenerator extends LuceneTestCase {
   final protected static int RECTANGLE = 6;
   final protected static int PATH = 7;
   final protected static int COLLECTION = 8;
+  final protected static int POINT = 9;
+  final protected static int LINE = 10;
 
   /* Helper shapes for generating constraints whch are just three sided polygons */
   final protected static int CONVEX_SIMPLE_POLYGON = 500;
   final protected static int CONCAVE_SIMPLE_POLYGON = 501;
 
-
   /**
-   * Method that returns empty Constraints object..
+   * Method that returns a random generated Planet model from the supported
+   * Planet models. currently SPHERE and WGS84
    *
-   * @return an empty Constraints object
+   * @return a random generated Planet model
    */
-  public Constraints getEmptyConstraint(){
-    return new Constraints();
+  public PlanetModel randomPlanetModel() {
+    final int shapeType = random().nextInt(2);
+    switch (shapeType) {
+      case 0: {
+        return PlanetModel.SPHERE;
+      }
+      case 1: {
+        return PlanetModel.WGS84;
+      }
+      default:
+        throw new IllegalStateException("Unexpected planet model");
+    }
   }
 
   /**
@@ -75,7 +87,20 @@ public class RandomGeoShapeGenerator extends LuceneTestCase {
    * @return a random generated shape code
    */
   public int randomShapeType(){
-    return random().nextInt(9);
+    return random().nextInt(11);
+  }
+
+  /**
+   * Method that returns a random generated GeoAreaShape code from all
+   * supported GeoAreaShapes.
+   *
+   * We are removing Collections because it is difficult to create shapes
+   * with properties in some cases.
+   *
+   * @return a random generated polygon code
+   */
+  public int randomGeoAreaShapeType(){
+    return random().nextInt(11);
   }
 
   /**
@@ -107,45 +132,35 @@ public class RandomGeoShapeGenerator extends LuceneTestCase {
   }
 
   /**
-   * Method that returns a random generated GeoAreaShape code from all
-   * supported GeoAreaShapes.
-   *
-   * We are removing Collections because it is difficult to create shapes
-   * with properties in some cases.
+   * Check if a shape code represents a concave shape
    *
-   * @return a random generated polygon code
+   * @return true if the shape represented by the code is concave
    */
-  public int randomGeoAreaShapeType(){
-    return random().nextInt(8);
+  public boolean isConcave(int shapeType){
+    return (shapeType == CONCAVE_POLYGON);
   }
 
   /**
-   * Check if a shape code represents a concave shape
+   * Method that returns empty Constraints object..
    *
-   * @return true if the shape represented by the code is concave
+   * @return an empty Constraints object
    */
-  public boolean isConcave(int shapeType){
-    return (shapeType == CONCAVE_POLYGON);
+  public Constraints getEmptyConstraint(){
+    return new Constraints();
   }
 
   /**
-   * Method that returns a random generated Planet model from the supported
-   * Planet models. currently SPHERE and WGS84
+   * Method that returns a random generated GeoPoint.
    *
-   * @return a random generated Planet model
+   * @param planetModel The planet model.
+   * @return The random generated GeoPoint.
    */
-  public PlanetModel randomPlanetModel() {
-    final int shapeType = random().nextInt(2);
-    switch (shapeType) {
-      case 0: {
-        return PlanetModel.SPHERE;
-      }
-      case 1: {
-        return PlanetModel.WGS84;
-      }
-      default:
-        throw new IllegalStateException("Unexpected planet model");
+  public GeoPoint randomGeoPoint(PlanetModel planetModel) {
+    GeoPoint point = null;
+    while (point == null) {
+      point = randomGeoPoint(planetModel, getEmptyConstraint());
     }
+    return point;
   }
 
   /**
@@ -257,6 +272,12 @@ public class RandomGeoShapeGenerator extends LuceneTestCase {
       case COLLECTION: {
         return collection(planetModel, constraints);
       }
+      case POINT: {
+        return point(planetModel, constraints);
+      }
+      case LINE: {
+        return line(planetModel, constraints);
+      }
       case CONVEX_SIMPLE_POLYGON: {
         return simpleConvexPolygon(planetModel, constraints);
       }
@@ -269,6 +290,36 @@ public class RandomGeoShapeGenerator extends LuceneTestCase {
   }
 
   /**
+   * Method that returns a random generated a GeoPointShape under given constraints. Returns
+   * NULL if it cannot build the GeoCircle under the given constraints.
+   *
+   * @param planetModel The planet model.
+   * @param constraints The given constraints.
+   * @return The random generated GeoPointShape.
+   */
+  private GeoPointShape point(PlanetModel planetModel , Constraints constraints) {
+    int iterations=0;
+    while (iterations < MAX_SHAPE_ITERATIONS) {
+      iterations++;
+      final GeoPoint point = randomGeoPoint(planetModel, constraints);
+      if (point == null){
+        continue;
+      }
+      try {
+
+        GeoPointShape pointShape = GeoPointShapeFactory.makeGeoPointShape(planetModel, point.getLatitude(), point.getLongitude());
+        if (!constraints.valid(pointShape)) {
+          continue;
+        }
+        return pointShape;
+      } catch (IllegalArgumentException e) {
+        continue;
+      }
+    }
+    return null;
+  }
+
+  /**
    * Method that returns a random generated a GeoCircle under given constraints. Returns
    * NULL if it cannot build the GeoCircle under the given constraints.
    *
@@ -340,6 +391,33 @@ public class RandomGeoShapeGenerator extends LuceneTestCase {
   }
 
   /**
+   * Method that returns a random generated degenerate GeoPath under given constraints. Returns
+   * NULL if it cannot build the degenerate GeoPath under the given constraints.
+   *
+   * @param planetModel The planet model.
+   * @param constraints The given constraints.
+   * @return The random generated degenerated GeoPath.
+   */
+  private GeoPath line(PlanetModel planetModel, Constraints constraints) {
+    int iterations = 0;
+    while (iterations < MAX_SHAPE_ITERATIONS) {
+      iterations++;
+      int vertexCount =  random().nextInt(2) + 2;
+      List<GeoPoint> geoPoints = points(vertexCount, planetModel, constraints);
+      try {
+        GeoPath path = GeoPathFactory.makeGeoPath(planetModel, 0, geoPoints.toArray(new GeoPoint[geoPoints.size()]));
+        if (!constraints.valid(path)) {
+          continue;
+        }
+        return path;
+      } catch (IllegalArgumentException e) {
+        continue;
+      }
+    }
+    return null;
+  }
+
+  /**
    * Method that returns a random generated a GeoPath under given constraints. Returns
    * NULL if it cannot build the GeoPath under the given constraints.
    *
@@ -939,6 +1017,3 @@ public class RandomGeoShapeGenerator extends LuceneTestCase {
     }
   }
 }
-
-
-
diff --git a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoShapeRelationshipTest.java b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoShapeRelationshipTest.java
index 75a8c28572..9c791b7f23 100644
--- a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoShapeRelationshipTest.java
+++ b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoShapeRelationshipTest.java
@@ -23,8 +23,7 @@ import org.junit.Test;
 /**
  * Random test to check relationship between GeoAreaShapes and GeoShapes.
  */
-public class RandomGeoShapeRelationshipTest extends RandomGeoShapeGenerator {
-
+public class RandomGeoShapeRelationshipTest extends RandomGeo3dShapeGenerator {
 
   /**
    * Test for WITHIN points. We build a WITHIN shape with respect the geoAreaShape
@@ -38,6 +37,9 @@ public class RandomGeoShapeRelationshipTest extends RandomGeoShapeGenerator {
     int referenceShapeType = CONVEX_POLYGON;
     PlanetModel planetModel = randomPlanetModel();
     int shapeType = randomShapeType();
+    while (shapeType == POINT || shapeType == LINE) {
+      shapeType = randomShapeType();
+    }
     GeoAreaShape shape = null;
     GeoPoint point = null;
     while (point == null) {
@@ -51,7 +53,10 @@ public class RandomGeoShapeRelationshipTest extends RandomGeoShapeGenerator {
         point = randomGeoPoint(planetModel, constraints);
       }
     }
-    assertTrue(shape.isWithin(point));
+    StringBuilder b = new StringBuilder();
+    b.append("shape: " + shape + "\n");
+    b.append("point: " + point);
+    assertTrue(b.toString(), shape.isWithin(point));
   }
 
   /**
@@ -78,7 +83,10 @@ public class RandomGeoShapeRelationshipTest extends RandomGeoShapeGenerator {
         point = randomGeoPoint(planetModel, constraints);
       }
     }
-    assertFalse(shape.isWithin(point));
+    StringBuilder b = new StringBuilder();
+    b.append("shape: " + shape + "\n");
+    b.append("point: " + point);
+    assertFalse(b.toString(), shape.isWithin(point));
   }
 
   /**
@@ -94,7 +102,7 @@ public class RandomGeoShapeRelationshipTest extends RandomGeoShapeGenerator {
     int referenceShapeType = CONVEX_SIMPLE_POLYGON;
     PlanetModel planetModel = randomPlanetModel();
     int geoAreaShapeType = randomGeoAreaShapeType();
-    int shapeType =randomConvexShapeType();
+    int shapeType = randomConvexShapeType();
 
     GeoShape shape = null;
     GeoAreaShape geoAreaShape = null;
@@ -109,11 +117,14 @@ public class RandomGeoShapeRelationshipTest extends RandomGeoShapeGenerator {
         shape = randomGeoShape(shapeType, planetModel, constraints);
       }
     }
+    StringBuilder b = new StringBuilder();
+    b.append("geoAreaShape: " + geoAreaShape + "\n");
+    b.append("shape: " + shape);
     int rel = geoAreaShape.getRelationship(shape);
-    assertEquals(GeoArea.DISJOINT, rel);
+    assertEquals(b.toString(), GeoArea.DISJOINT, rel);
     if (shape instanceof GeoArea) {
       rel = ((GeoArea)shape).getRelationship(geoAreaShape);
-      assertEquals(GeoArea.DISJOINT, rel);
+      assertEquals(b.toString(), GeoArea.DISJOINT, rel);
     }
   }
 
@@ -129,7 +140,11 @@ public class RandomGeoShapeRelationshipTest extends RandomGeoShapeGenerator {
   public void testRandomWithIn() {
     PlanetModel planetModel = randomPlanetModel();
     int geoAreaShapeType = randomGeoAreaShapeType();
-    int shapeType =randomShapeType();
+    //shapes cannot be point or line -- no area!
+    while(geoAreaShapeType == POINT || geoAreaShapeType == LINE) {
+      geoAreaShapeType = randomGeoAreaShapeType();
+    }
+    int shapeType = LINE;//randomShapeType();
     int referenceShapeType = CONVEX_SIMPLE_POLYGON;
     if (!isConcave(geoAreaShapeType)){
       shapeType =randomConvexShapeType();
@@ -150,11 +165,14 @@ public class RandomGeoShapeRelationshipTest extends RandomGeoShapeGenerator {
         shape = randomGeoShape(shapeType, planetModel, constraints);
       }
     }
+    StringBuilder b = new StringBuilder();
+    b.append("geoAreaShape: " + geoAreaShape + "\n");
+    b.append("shape: " + shape);
     int rel = geoAreaShape.getRelationship(shape);
-    assertEquals(GeoArea.WITHIN, rel);
+    assertEquals(b.toString(), GeoArea.WITHIN, rel);
     if (shape instanceof GeoArea) {
       rel = ((GeoArea)shape).getRelationship(geoAreaShape);
-      assertEquals(GeoArea.CONTAINS, rel);
+      assertEquals(b.toString(), GeoArea.CONTAINS, rel);
     }
   }
 
@@ -174,10 +192,13 @@ public class RandomGeoShapeRelationshipTest extends RandomGeoShapeGenerator {
     int referenceShapeType = CONVEX_SIMPLE_POLYGON;
     PlanetModel planetModel = randomPlanetModel();
     int geoAreaShapeType = randomGeoAreaShapeType();
-    while (geoAreaShapeType == COLLECTION){
+    while (geoAreaShapeType == COLLECTION ){
       geoAreaShapeType = randomGeoAreaShapeType();
     }
     int shapeType = randomShapeType();
+    while (shapeType == POINT || shapeType == LINE) {
+      shapeType = randomShapeType();
+    }
     if (isConcave(geoAreaShapeType)){
       shapeType = randomConcaveShapeType();
     }
@@ -197,11 +218,14 @@ public class RandomGeoShapeRelationshipTest extends RandomGeoShapeGenerator {
         shape = randomGeoShape(shapeType, planetModel, constraints);
       }
     }
+    StringBuilder b = new StringBuilder();
+    b.append("geoAreaShape: " + geoAreaShape + "\n");
+    b.append("shape: " + shape);
     int rel = geoAreaShape.getRelationship(shape);
-    assertEquals(GeoArea.CONTAINS, rel);
+    assertEquals(b.toString(), GeoArea.CONTAINS, rel);
     if (shape instanceof GeoArea) {
       rel = ((GeoArea)shape).getRelationship(geoAreaShape);
-      assertEquals(GeoArea.WITHIN, rel);
+      assertEquals(b.toString(), GeoArea.WITHIN, rel);
     }
   }
 
@@ -216,8 +240,13 @@ public class RandomGeoShapeRelationshipTest extends RandomGeoShapeGenerator {
   public void testRandomOverlaps() {
     PlanetModel planetModel = randomPlanetModel();
     int geoAreaShapeType = randomGeoAreaShapeType();
+    while (geoAreaShapeType == POINT || geoAreaShapeType == LINE) {
+      geoAreaShapeType = randomGeoAreaShapeType();
+    }
     int shapeType = randomShapeType();
-
+    while (shapeType == POINT || shapeType == LINE) {
+      shapeType = randomShapeType();
+    }
     GeoShape shape = null;
     GeoAreaShape geoAreaShape = null;
     while (shape == null) {
@@ -246,12 +275,14 @@ public class RandomGeoShapeRelationshipTest extends RandomGeoShapeGenerator {
         shape = randomGeoShape(shapeType, planetModel, constraints);
       }
     }
+    StringBuilder b = new StringBuilder();
+    b.append("geoAreaShape: " + geoAreaShape + "\n");
+    b.append("shape: " + shape);
     int rel = geoAreaShape.getRelationship(shape);
-    assertEquals(GeoArea.OVERLAPS, rel);
+    assertEquals(b.toString(), GeoArea.OVERLAPS, rel);
     if (shape instanceof GeoArea) {
       rel = ((GeoArea)shape).getRelationship(geoAreaShape);
-      assertEquals(GeoArea.OVERLAPS, rel);
+      assertEquals(b.toString(), GeoArea.OVERLAPS, rel);
     }
   }
 }
-
