Index: lucene/src/java/org/apache/lucene/util/ArrayUtil.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/ArrayUtil.java	(revision 1045029)
+++ lucene/src/java/org/apache/lucene/util/ArrayUtil.java	(working copy)
@@ -430,25 +430,25 @@
     return false;
   }
 
-  public static <T> T[] grow(T[] array, int minSize) {
+  public static <T> T[] grow(T[] array, Class<T> componentType, int minSize) {
     if (array.length < minSize) {
       @SuppressWarnings("unchecked") final T[] newArray =
-        (T[]) Array.newInstance(array.getClass().getComponentType(), oversize(minSize, RamUsageEstimator.NUM_BYTES_OBJECT_REF));
+        (T[]) Array.newInstance(componentType, oversize(minSize, RamUsageEstimator.NUM_BYTES_OBJECT_REF));
       System.arraycopy(array, 0, newArray, 0, array.length);
       return newArray;
     } else
       return array;
   }
 
-  public static <T> T[] grow(T[] array) {
-    return grow(array, 1 + array.length);
+  public static <T> T[] grow(T[] array, Class<T> componentType) {
+    return grow(array, componentType, 1 + array.length);
   }
 
-  public static <T> T[] shrink(T[] array, int targetSize) {
+  public static <T> T[] shrink(T[] array, Class<T> componentType, int targetSize) {
     final int newSize = getShrinkSize(array.length, targetSize, RamUsageEstimator.NUM_BYTES_OBJECT_REF);
     if (newSize != array.length) {
       @SuppressWarnings("unchecked") final T[] newArray =
-        (T[]) Array.newInstance(array.getClass().getComponentType(), newSize);
+        (T[]) Array.newInstance(componentType, newSize);
       System.arraycopy(array, 0, newArray, 0, newSize);
       return newArray;
     } else
Index: lucene/src/java/org/apache/lucene/util/automaton/Automaton.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/automaton/Automaton.java	(revision 1045029)
+++ lucene/src/java/org/apache/lucene/util/automaton/Automaton.java	(working copy)
@@ -40,7 +40,6 @@
 import java.util.Set;
 
 import org.apache.lucene.util.ArrayUtil;
-import org.apache.lucene.util.RamUsageEstimator;
 
 /**
  * Finite-state automaton with regular expression operations.
@@ -281,9 +280,7 @@
             worklist.add(t.to);
             t.to.number = upto;
             if (upto == numberedStates.length) {
-              final State[] newArray = new State[ArrayUtil.oversize(1+upto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
-              System.arraycopy(numberedStates, 0, newArray, 0, upto);
-              numberedStates = newArray;
+              numberedStates = ArrayUtil.grow(numberedStates, State.class);
             }
             numberedStates[upto] = t.to;
             upto++;
Index: lucene/src/java/org/apache/lucene/util/automaton/BasicOperations.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/automaton/BasicOperations.java	(revision 1045029)
+++ lucene/src/java/org/apache/lucene/util/automaton/BasicOperations.java	(working copy)
@@ -30,7 +30,6 @@
 package org.apache.lucene.util.automaton;
 
 import org.apache.lucene.util.ArrayUtil;
-import org.apache.lucene.util.RamUsageEstimator;
 
 import java.util.ArrayList;
 import java.util.BitSet;
@@ -459,9 +458,7 @@
 
     public void add(Transition t) {
       if (transitions.length == count) {
-        Transition[] newArray = new Transition[ArrayUtil.oversize(1+count, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
-        System.arraycopy(transitions, 0, newArray, 0, count);
-        transitions = newArray;
+        transitions = ArrayUtil.grow(transitions, Transition.class);
       }
       transitions[count++] = t;
     }
@@ -503,9 +500,7 @@
     private PointTransitions next(int point) {
       // 1st time we are seeing this point
       if (count == points.length) {
-        final PointTransitions[] newArray = new PointTransitions[ArrayUtil.oversize(1+count, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
-        System.arraycopy(points, 0, newArray, 0, count);
-        points = newArray;
+        points = ArrayUtil.grow(points, PointTransitions.class);
       }
       PointTransitions points0 = points[count];
       if (points0 == null) {
@@ -650,9 +645,7 @@
             final SortedIntSet.FrozenIntSet p = statesSet.freeze(q);
             worklist.add(p);
             if (newStateUpto == newStatesArray.length) {
-              final State[] newArray = new State[ArrayUtil.oversize(1+newStateUpto, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
-              System.arraycopy(newStatesArray, 0, newArray, 0, newStateUpto);
-              newStatesArray = newArray;
+              newStatesArray = ArrayUtil.grow(newStatesArray, State.class);
             }
             newStatesArray[newStateUpto] = q;
             q.number = newStateUpto;
Index: lucene/src/java/org/apache/lucene/util/automaton/fst/Builder.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/automaton/fst/Builder.java	(revision 1045029)
+++ lucene/src/java/org/apache/lucene/util/automaton/fst/Builder.java	(working copy)
@@ -287,7 +287,7 @@
     final int prefixLenPlus1 = pos1+1;
       
     if (frontier.length < input.length+1) {
-      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, input.length+1);
+      final UnCompiledNode<T>[] next = ArrayUtil.grow(frontier, UnCompiledNode.class, input.length+1);
       for(int idx=frontier.length;idx<next.length;idx++) {
         next[idx] = new UnCompiledNode<T>(this);
       }
@@ -450,7 +450,7 @@
       assert label >= 0;
       assert numArcs == 0 || label > arcs[numArcs-1].label: "arc[-1].label=" + arcs[numArcs-1].label + " new label=" + label + " numArcs=" + numArcs;
       if (numArcs == arcs.length) {
-        final Arc<T>[] newArcs = ArrayUtil.grow(arcs);
+        final Arc<T>[] newArcs = ArrayUtil.grow(arcs, Arc.class);
         for(int arcIdx=numArcs;arcIdx<newArcs.length;arcIdx++) {
           newArcs[arcIdx] = new Arc<T>();
         }
Index: lucene/src/java/org/apache/lucene/util/automaton/fst/BytesRefFSTEnum.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/automaton/fst/BytesRefFSTEnum.java	(revision 1045029)
+++ lucene/src/java/org/apache/lucene/util/automaton/fst/BytesRefFSTEnum.java	(working copy)
@@ -235,8 +235,8 @@
   private void grow() {
     final int l = current.length + 1;
     current.grow(l);
-    arcs = ArrayUtil.grow(arcs, l);
-    output = ArrayUtil.grow(output, l);
+    arcs = ArrayUtil.grow(arcs, FST.Arc.class, l);
+    output = ArrayUtil.grow(output, (Class<T>) Object.class, l);
   }
 
   private void appendOutput(T addedOutput) {
Index: lucene/src/java/org/apache/lucene/util/automaton/fst/IntsRefFSTEnum.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/automaton/fst/IntsRefFSTEnum.java	(revision 1045029)
+++ lucene/src/java/org/apache/lucene/util/automaton/fst/IntsRefFSTEnum.java	(working copy)
@@ -235,8 +235,8 @@
   private void grow() {
     final int l = current.length + 1;
     current.grow(l);
-    arcs = ArrayUtil.grow(arcs, l);
-    output = ArrayUtil.grow(output, l);
+    arcs = ArrayUtil.grow(arcs, FST.Arc.class, l);
+    output = ArrayUtil.grow(output, (Class<T>) Object.class, l);
   }
 
   private void appendOutput(T addedOutput) {
Index: lucene/src/java/org/apache/lucene/util/automaton/State.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/automaton/State.java	(revision 1045029)
+++ lucene/src/java/org/apache/lucene/util/automaton/State.java	(working copy)
@@ -29,7 +29,6 @@
 
 package org.apache.lucene.util.automaton;
 import org.apache.lucene.util.ArrayUtil;
-import org.apache.lucene.util.RamUsageEstimator;
 
 import java.io.Serializable;
 import java.util.Collection;
@@ -111,9 +110,7 @@
    */
   public void addTransition(Transition t) {
     if (numTransitions == transitionsArray.length) {
-      final Transition[] newArray = new Transition[ArrayUtil.oversize(1+numTransitions, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
-      System.arraycopy(transitionsArray, 0, newArray, 0, numTransitions);
-      transitionsArray = newArray;
+      transitionsArray = ArrayUtil.grow(transitionsArray, Transition.class);
     }
     transitionsArray[numTransitions++] = t;
   }
Index: lucene/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8.java	(revision 1045029)
+++ lucene/src/java/org/apache/lucene/util/automaton/UTF32ToUTF8.java	(working copy)
@@ -17,7 +17,6 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.util.RamUsageEstimator;
 import org.apache.lucene.util.ArrayUtil;
 
 import java.util.List;
@@ -299,9 +298,7 @@
   private State newUTF8State() {
     State s = new State();
     if (utf8StateCount == utf8States.length) {
-      final State[] newArray = new State[ArrayUtil.oversize(1+utf8StateCount, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
-      System.arraycopy(utf8States, 0, newArray, 0, utf8StateCount);
-      utf8States = newArray;
+      utf8States = ArrayUtil.grow(utf8States, State.class);
     }
     utf8States[utf8StateCount] = s;
     s.number = utf8StateCount;
Index: lucene/src/java/org/apache/lucene/util/ByteBlockPool.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/ByteBlockPool.java	(revision 1045029)
+++ lucene/src/java/org/apache/lucene/util/ByteBlockPool.java	(working copy)
@@ -18,7 +18,6 @@
  */
 import java.util.Arrays;
 import java.util.List;
-import static org.apache.lucene.util.RamUsageEstimator.NUM_BYTES_OBJECT_REF;
 
 /** 
  * Class that Posting and PostingVector use to write byte
@@ -117,12 +116,7 @@
   }
 
   public void nextBuffer() {
-    if (1+bufferUpto == buffers.length) {
-      byte[][] newBuffers = new byte[ArrayUtil.oversize(buffers.length+1,
-                                                        NUM_BYTES_OBJECT_REF)][];
-      System.arraycopy(buffers, 0, newBuffers, 0, buffers.length);
-      buffers = newBuffers;
-    }
+    buffers = ArrayUtil.grow(buffers, byte[].class, 2+bufferUpto);
     buffer = buffers[1+bufferUpto] = allocator.getByteBlock();
     bufferUpto++;
 
Index: lucene/src/java/org/apache/lucene/util/RecyclingByteBlockAllocator.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/RecyclingByteBlockAllocator.java	(revision 1045029)
+++ lucene/src/java/org/apache/lucene/util/RecyclingByteBlockAllocator.java	(working copy)
@@ -93,13 +93,7 @@
   @Override
   public synchronized void recycleByteBlocks(byte[][] blocks, int start, int end) {
     final int numBlocks = Math.min(maxBufferedBlocks - freeBlocks, end - start);
-    final int size = freeBlocks + numBlocks;
-    if (size >= freeByteBlocks.length) {
-      final byte[][] newBlocks = new byte[ArrayUtil.oversize(size,
-          RamUsageEstimator.NUM_BYTES_OBJECT_REF)][];
-      System.arraycopy(freeByteBlocks, 0, newBlocks, 0, freeBlocks);
-      freeByteBlocks = newBlocks;
-    }
+    freeByteBlocks = ArrayUtil.grow(freeByteBlocks, byte[].class, freeBlocks + numBlocks);
     final int stop = start + numBlocks;
     for (int i = start; i < stop; i++) {
       freeByteBlocks[freeBlocks++] = blocks[i];
