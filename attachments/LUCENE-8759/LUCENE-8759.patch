diff --git a/lucene/core/src/java/org/apache/lucene/search/BlockMaxConjunctionScorer.java b/lucene/core/src/java/org/apache/lucene/search/BlockMaxConjunctionScorer.java
index 91fe76c1d8..d55bf9fc56 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BlockMaxConjunctionScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BlockMaxConjunctionScorer.java
@@ -90,9 +90,11 @@ final class BlockMaxConjunctionScorer extends Scorer {
         maxScore = getMaxScore(upTo);
 
         // Also compute the minimum required scores for a hit to be competitive
-        // A double that is less than 'score' might still be converted to 'score'
-        // when casted to a float, so we go to the previous float to avoid this issue
-        minScores[minScores.length - 1] = minScore > 0 ? Math.nextDown(minScore) : 0;
+        // A double that is less than 'minScore' might still be converted to 'minScore'
+        // when casted to a float, so we find the smallest double that is equals to 'minScore'
+        // to avoid this issue
+        minScores[minScores.length - 1] = minScore > 0 ?
+            MaxScoreSumPropagator.positiveFloatToSmallestDouble(minScore) : 0;
         for (int i = scorers.length - 1; i > 0; --i) {
           double minScore = minScores[i];
           float clauseMaxScore = scorers[i].getMaxScore(upTo);
diff --git a/lucene/core/src/java/org/apache/lucene/search/MaxScoreSumPropagator.java b/lucene/core/src/java/org/apache/lucene/search/MaxScoreSumPropagator.java
index 1a4b3b5115..85739f3e9a 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MaxScoreSumPropagator.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MaxScoreSumPropagator.java
@@ -115,8 +115,9 @@ final class MaxScoreSumPropagator {
       return ;
     }
     // A double that is less than 'minScore' might still be converted to 'minScore'
-    // when casted to a float, so we go to the previous float to avoid this issue
-    float minScoreDown = Math.nextDown(minScore);
+    // when casted to a float, so we find the smallest double that is equals to 'minScore'
+    // to avoid this issue
+    double minScoreDown = positiveFloatToSmallestDouble(minScore);
     for (int i = 0; i < numClauses; ++i) {
       double sumOfOtherMaxScores = this.sumOfOtherMaxScores[i];
       float minCompetitiveScore = getMinCompetitiveScore(minScoreDown, sumOfOtherMaxScores);
@@ -133,7 +134,7 @@ final class MaxScoreSumPropagator {
    * Return the minimum score that a Scorer must produce in order for a hit to
    * be competitive.
    */
-  private float getMinCompetitiveScore(float minScoreSum, double sumOfOtherMaxScores) {
+  private float getMinCompetitiveScore(double minScoreSum, double sumOfOtherMaxScores) {
     assert numClauses > 0;
     if (minScoreSum <= sumOfOtherMaxScores) {
       return 0f;
@@ -141,12 +142,13 @@ final class MaxScoreSumPropagator {
 
     // We need to find a value 'minScore' so that 'minScore + sumOfOtherMaxScores <= minScoreSum'
     // TODO: is there an efficient way to find the greatest value that meets this requirement?
+    float minScoreSumFloat = (float) minScoreSum;
     float minScore = (float) (minScoreSum - sumOfOtherMaxScores);
     int iters = 0;
     while (scoreSumUpperBound(minScore + sumOfOtherMaxScores) > minScoreSum) {
-      // Important: use ulp of minScoreSum and not minScore to make sure that we
+      // Important: use ulp of minScoreSumFloat and not minScore to make sure that we
       // converge quickly.
-      minScore -= Math.ulp(minScoreSum);
+      minScore -= Math.ulp(minScoreSumFloat);
       // this should converge in at most two iterations:
       //  - one because of the subtraction rounding error
       //  - one because of the error introduced by sumUpperBound
@@ -173,4 +175,56 @@ final class MaxScoreSumPropagator {
     double b = MathUtil.sumRelativeErrorBound(numClauses);
     return (float) ((1.0 + 2 * b) * sum);
   }
+
+  /**
+   * Returns the smallest positive double that is equals to
+   * the provided <code>value</code> when casted to a float:
+   * <ol>
+   *  <li><code>(float) Math.nextDown(ret) < value)</code></li>
+   *  <li><code>(float) ret == value</code></li>
+   * </ol>
+   * {@link Float#NaN} and {@link Float#POSITIVE_INFINITY} are preserved
+   * and returns {@link Double#NaN} and {@link Double#POSITIVE_INFINITY}
+   * respectively.
+   */
+  static double positiveFloatToSmallestDouble(float value) {
+    // preserve infinity and nan
+    if (value == Float.POSITIVE_INFINITY) {
+      return Double.POSITIVE_INFINITY;
+    } else if (value != value) {
+      return Double.NaN;
+    }
+    assert value > 0 : "value must be > 0, got " + value;
+
+    int bits = Float.floatToIntBits(value);
+    long sign = bits >>> 31;
+    long exp = (bits >> 23) & 0xff;
+    long significantD = (bits & 0x7fffff);
+    final int plusOne = (significantD % 2) != 0 ? 1 : 0;
+
+    int shift = (52 - 23);
+    if (exp == 0x0) {
+      // denormal float becomes a normal double
+      int leadingZeros = Integer.numberOfLeadingZeros((int) significantD) - (31-23);
+      int numOne = Integer.bitCount((int) significantD);
+      exp = 1 - leadingZeros;
+      shift += leadingZeros + (numOne == 1 ? 1 : 0); // add one if the mantissa is a power of two
+    } else {
+      if (exp == 1 && significantD == 0) {
+        // special case for smallest positive normal float
+        shift ++;
+      }
+    }
+    significantD <<= shift; // shift to double
+    significantD &= 0xfffffffffffffL;  // clear the implicit bit
+    exp = exp - 127 + 1023; // apply the double exponent bias
+
+    // round to the smallest double
+    significantD |= (exp << 52);
+    significantD -= (1L << (shift - 1)); // round down
+    significantD += plusOne; // round to odd in case of tie
+    exp = significantD >>> 52;
+
+    return Double.longBitsToDouble((sign << 63) | (exp << 52) | significantD);
+  }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestMaxScoreSumPropagator.java b/lucene/core/src/test/org/apache/lucene/search/TestMaxScoreSumPropagator.java
index 9da8d1d86d..e3cd8df646 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestMaxScoreSumPropagator.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestMaxScoreSumPropagator.java
@@ -200,6 +200,42 @@ public class TestMaxScoreSumPropagator extends LuceneTestCase {
     }
   }
 
+  public void testFloatToSmallestDouble() throws IOException {
+    assertEquals(MaxScoreSumPropagator.positiveFloatToSmallestDouble(Float.POSITIVE_INFINITY),
+        Double.POSITIVE_INFINITY, 0f);
+    assertEquals(MaxScoreSumPropagator.positiveFloatToSmallestDouble(Float.NaN),
+        Double.NaN, 0f);
+
+    // check denormalized positive floats
+    float f = 0f;
+    for (int i = 0; i < 0x7FFFFF; i++) {
+      f = Math.nextUp(f);
+      assertSmallestDouble(f);
+    }
+
+    // check random positive floats
+    for (int i = 0; i < 1000000; i++) {
+      int upperBound = Math.max(1, random().nextInt(Integer.MAX_VALUE));
+      f = random().nextFloat();
+      if (f == 0f) {
+        f = Float.MIN_NORMAL;
+      }
+      assertSmallestDouble(f*upperBound);
+      assertSmallestDouble(f);
+
+      // check integers
+      assertSmallestDouble(i+1);
+      assertSmallestDouble(Math.max(1, random().nextInt(Integer.MAX_VALUE)));
+    }
+  }
+
+  private void assertSmallestDouble(float f) {
+    double d = MaxScoreSumPropagator.positiveFloatToSmallestDouble(f);
+    assertTrue((float) Math.nextDown(d) < f);
+    assertEquals((float) d, f, 0f);
+    assert(d > 0);
+  }
+
   private void assertMinCompetitiveScore(Collection<FakeScorer> scorers, MaxScoreSumPropagator p, float minCompetitiveScore) throws IOException {
     p.setMinCompetitiveScore(minCompetitiveScore);
 
