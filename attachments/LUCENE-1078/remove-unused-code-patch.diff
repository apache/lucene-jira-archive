Index: src/java/org/apache/lucene/analysis/standard/StandardTokenizerImpl.java
===================================================================
--- src/java/org/apache/lucene/analysis/standard/StandardTokenizerImpl.java	(revision 601199)
+++ src/java/org/apache/lucene/analysis/standard/StandardTokenizerImpl.java	(working copy)
@@ -258,23 +258,9 @@
       from input */
   private int zzEndRead;
 
-  /** number of newlines encountered up to the start of the matched text */
-  private int yyline;
-
   /** the number of characters up to the start of the matched text */
   private int yychar;
 
-  /**
-   * the number of characters from the last newline up to the start of the 
-   * matched text
-   */
-  private int yycolumn;
-
-  /** 
-   * zzAtBOL == true <=> the scanner is currently at the beginning of a line
-   */
-  private boolean zzAtBOL = true;
-
   /** zzAtEOF == true <=> the scanner is at the EOF */
   private boolean zzAtEOF;
 
@@ -421,11 +407,10 @@
    */
   public final void yyreset(java.io.Reader reader) {
     zzReader = reader;
-    zzAtBOL  = true;
     zzAtEOF  = false;
     zzEndRead = zzStartRead = 0;
     zzCurrentPos = zzMarkedPos = zzPushbackPos = 0;
-    yyline = yychar = yycolumn = 0;
+    yychar = 0;
     zzLexicalState = YYINITIAL;
   }
 
Index: src/java/org/apache/lucene/analysis/StopFilter.java
===================================================================
--- src/java/org/apache/lucene/analysis/StopFilter.java	(revision 601199)
+++ src/java/org/apache/lucene/analysis/StopFilter.java	(working copy)
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 import java.util.Arrays;
-import java.util.Iterator;
 import java.util.Set;
 
 /**
Index: src/java/org/apache/lucene/search/Similarity.java
===================================================================
--- src/java/org/apache/lucene/search/Similarity.java	(revision 601199)
+++ src/java/org/apache/lucene/search/Similarity.java	(working copy)
@@ -17,8 +17,6 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.util.SmallFloat;
 
Index: src/java/org/apache/lucene/search/function/ValueSource.java
===================================================================
--- src/java/org/apache/lucene/search/function/ValueSource.java	(revision 601199)
+++ src/java/org/apache/lucene/search/function/ValueSource.java	(working copy)
@@ -19,7 +19,6 @@
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.function.DocValues;
-import org.apache.lucene.util.ToStringUtils;
 
 import java.io.IOException;
 import java.io.Serializable;
Index: src/java/org/apache/lucene/search/ComplexExplanation.java
===================================================================
--- src/java/org/apache/lucene/search/ComplexExplanation.java	(revision 601199)
+++ src/java/org/apache/lucene/search/ComplexExplanation.java	(working copy)
@@ -17,8 +17,6 @@
  * limitations under the License.
  */
 
-import java.util.ArrayList;
-
 /** Expert: Describes the score computation for document and query, andcan distinguish a match independent of a positive value. */
 public class ComplexExplanation extends Explanation {
   private Boolean match;
Index: src/java/org/apache/lucene/index/SegmentReader.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentReader.java	(revision 601199)
+++ src/java/org/apache/lucene/index/SegmentReader.java	(working copy)
@@ -36,9 +36,6 @@
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.util.BitVector;
 
-import java.io.IOException;
-import java.util.*;
-
 /**
  * @version $Id$
  */
@@ -301,7 +298,6 @@
       fieldInfos = new FieldInfos(cfsDir, segment + ".fnm");
 
       final String fieldsSegment;
-      final Directory dir;
 
       if (si.getDocStoreOffset() != -1)
         fieldsSegment = si.getDocStoreSegment();
@@ -424,7 +420,6 @@
       // and can thus not be shared among multiple SegmentReaders
       // TODO: Change this in case FieldsReader becomes thread-safe in the future
       final String fieldsSegment;
-      final Directory dir;
   
       Directory storeDir = directory();
       
Index: src/java/org/apache/lucene/index/DocumentsWriter.java
===================================================================
--- src/java/org/apache/lucene/index/DocumentsWriter.java	(revision 601199)
+++ src/java/org/apache/lucene/index/DocumentsWriter.java	(working copy)
@@ -1900,7 +1900,6 @@
     private ByteSliceReader freq = new ByteSliceReader();
     private ByteSliceReader prox = new ByteSliceReader();
 
-    private int lastDocID;
     private int docID;
     private int termFreq;
 
Index: src/java/org/apache/lucene/index/TermVectorsReader.java
===================================================================
--- src/java/org/apache/lucene/index/TermVectorsReader.java	(revision 601199)
+++ src/java/org/apache/lucene/index/TermVectorsReader.java	(working copy)
@@ -429,18 +429,16 @@
 class ParallelArrayTermVectorMapper extends TermVectorMapper
 {
 
-  private int numTerms;
   private String[] terms;
   private int[] termFreqs;
-  private int positions[][] = null;
-  private TermVectorOffsetInfo offsets[][] = null;
+  private int positions[][];
+  private TermVectorOffsetInfo offsets[][];
   private int currentPosition;
   private boolean storingOffsets;
   private boolean storingPositions;
   private String field;
 
   public void setExpectations(String field, int numTerms, boolean storeOffsets, boolean storePositions) {
-    this.numTerms = numTerms;
     this.field = field;
     terms = new String[numTerms];
     termFreqs = new int[numTerms];
Index: src/java/org/apache/lucene/index/TermVectorsWriter.java
===================================================================
--- src/java/org/apache/lucene/index/TermVectorsWriter.java	(revision 601199)
+++ src/java/org/apache/lucene/index/TermVectorsWriter.java	(working copy)
@@ -72,7 +72,6 @@
         tvf.writeVInt(numTerms);
 
         final TermPositionVector tpVector;
-        final TermFreqVector tfVector;
 
         final byte bits;
         final boolean storePositions;
@@ -81,14 +80,12 @@
         if (vectors[i] instanceof TermPositionVector) {
           // May have positions & offsets
           tpVector = (TermPositionVector) vectors[i];
-          tfVector = null;
           storePositions = tpVector.size() > 0 && tpVector.getTermPositions(0) != null;
           storeOffsets = tpVector.size() > 0 && tpVector.getOffsets(0) != null;
           bits = (byte) ((storePositions ? TermVectorsReader.STORE_POSITIONS_WITH_TERMVECTOR : 0) +
                          (storeOffsets ? TermVectorsReader.STORE_OFFSET_WITH_TERMVECTOR : 0));
         } else {
           tpVector = null;
-          tfVector = vectors[i];
           bits = 0;
           storePositions = false;
           storeOffsets = false;
Index: src/java/org/apache/lucene/store/SingleInstanceLockFactory.java
===================================================================
--- src/java/org/apache/lucene/store/SingleInstanceLockFactory.java	(revision 601199)
+++ src/java/org/apache/lucene/store/SingleInstanceLockFactory.java	(working copy)
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 import java.util.HashSet;
-import java.util.Enumeration;
 
 /**
  * Implements {@link LockFactory} for a single in-process instance,
