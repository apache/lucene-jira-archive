Index: lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java	(revision 1585174)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java	(working copy)
@@ -26,6 +26,7 @@
 import org.apache.lucene.codecs.DocValuesProducer;
 import org.apache.lucene.index.BinaryDocValues;
 import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.NumericDocValues;
@@ -446,9 +447,9 @@
   public Bits getDocsWithField(FieldInfo field) throws IOException {
     switch(field.getDocValuesType()) {
       case SORTED_SET:
-        return new SortedSetDocsWithField(getSortedSet(field), maxDoc);
+        return DocValues.docsWithValue(getSortedSet(field), maxDoc);
       case SORTED:
-        return new SortedDocsWithField(getSorted(field), maxDoc);
+        return DocValues.docsWithValue(getSorted(field), maxDoc);
       case BINARY:
         BinaryEntry be = binaries.get(field.number);
         return getMissingBits(field.number, be.missingOffset, be.missingBytes);
Index: lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer.java	(revision 1585174)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/memory/MemoryDocValuesProducer.java	(working copy)
@@ -26,6 +26,7 @@
 import org.apache.lucene.codecs.DocValuesProducer;
 import org.apache.lucene.index.BinaryDocValues;
 import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.FieldInfo;
@@ -321,7 +322,7 @@
   public SortedDocValues getSorted(FieldInfo field) throws IOException {
     final FSTEntry entry = fsts.get(field.number);
     if (entry.numOrds == 0) {
-      return SortedDocValues.EMPTY;
+      return DocValues.EMPTY_SORTED;
     }
     FST<Long> instance;
     synchronized(this) {
@@ -396,7 +397,7 @@
   public SortedSetDocValues getSortedSet(FieldInfo field) throws IOException {
     final FSTEntry entry = fsts.get(field.number);
     if (entry.numOrds == 0) {
-      return SortedSetDocValues.EMPTY; // empty FST!
+      return DocValues.EMPTY_SORTED_SET; // empty FST!
     }
     FST<Long> instance;
     synchronized(this) {
@@ -509,9 +510,9 @@
   public Bits getDocsWithField(FieldInfo field) throws IOException {
     switch(field.getDocValuesType()) {
       case SORTED_SET:
-        return new SortedSetDocsWithField(getSortedSet(field), maxDoc);
+        return DocValues.docsWithValue(getSortedSet(field), maxDoc);
       case SORTED:
-        return new SortedDocsWithField(getSorted(field), maxDoc);
+        return DocValues.docsWithValue(getSorted(field), maxDoc);
       case BINARY:
         BinaryEntry be = binaries.get(field.number);
         return getMissingBits(field.number, be.missingOffset, be.missingBytes);
Index: lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java
===================================================================
--- lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java	(revision 1585174)
+++ lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextDocValuesReader.java	(working copy)
@@ -42,6 +42,7 @@
 import org.apache.lucene.codecs.DocValuesProducer;
 import org.apache.lucene.index.BinaryDocValues;
 import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.FieldInfo.DocValuesType;
 import org.apache.lucene.index.IndexFileNames;
@@ -434,9 +435,9 @@
   public Bits getDocsWithField(FieldInfo field) throws IOException {
     switch (field.getDocValuesType()) {
       case SORTED_SET:
-        return new SortedSetDocsWithField(getSortedSet(field), maxDoc);
+        return DocValues.docsWithValue(getSortedSet(field), maxDoc);
       case SORTED:
-        return new SortedDocsWithField(getSorted(field), maxDoc);
+        return DocValues.docsWithValue(getSorted(field), maxDoc);
       case BINARY:
         return getBinaryDocsWithField(field);
       case NUMERIC:
Index: lucene/core/src/java/org/apache/lucene/codecs/DocValuesProducer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/DocValuesProducer.java	(revision 1585174)
+++ lucene/core/src/java/org/apache/lucene/codecs/DocValuesProducer.java	(working copy)
@@ -75,61 +75,4 @@
    * @lucene.internal
    */
   public abstract void checkIntegrity() throws IOException;
-  
-  /** 
-   * A simple implementation of {@link DocValuesProducer#getDocsWithField} that 
-   * returns {@code true} if a document has an ordinal &gt;= 0
-   * <p>
-   * Codecs can choose to use this (or implement it more efficiently another way), but
-   * in most cases a Bits is unnecessary anyway: users can check this as they go.
-   */
-  public static class SortedDocsWithField implements Bits {
-    final SortedDocValues in;
-    final int maxDoc;
-    
-    /** Creates a {@link Bits} returning true if the document has a value */
-    public SortedDocsWithField(SortedDocValues in, int maxDoc) {
-      this.in = in;
-      this.maxDoc = maxDoc;
-    }
-    
-    @Override
-    public boolean get(int index) {
-      return in.getOrd(index) >= 0;
-    }
-
-    @Override
-    public int length() {
-      return maxDoc;
-    }
-  }
-  
-  /** 
-   * A simple implementation of {@link DocValuesProducer#getDocsWithField} that 
-   * returns {@code true} if a document has any ordinals.
-   * <p>
-   * Codecs can choose to use this (or implement it more efficiently another way), but
-   * in most cases a Bits is unnecessary anyway: users can check this as they go.
-   */
-  public static class SortedSetDocsWithField implements Bits {
-    final SortedSetDocValues in;
-    final int maxDoc;
-    
-    /** Creates a {@link Bits} returning true if the document has a value */
-    public SortedSetDocsWithField(SortedSetDocValues in, int maxDoc) {
-      this.in = in;
-      this.maxDoc = maxDoc;
-    }
-    
-    @Override
-    public boolean get(int index) {
-      in.setDocument(index);
-      return in.nextOrd() != SortedSetDocValues.NO_MORE_ORDS;
-    }
-
-    @Override
-    public int length() {
-      return maxDoc;
-    }
-  }
 }
Index: lucene/core/src/java/org/apache/lucene/codecs/lucene42/Lucene42DocValuesProducer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/lucene42/Lucene42DocValuesProducer.java	(revision 1585174)
+++ lucene/core/src/java/org/apache/lucene/codecs/lucene42/Lucene42DocValuesProducer.java	(working copy)
@@ -26,6 +26,7 @@
 import org.apache.lucene.codecs.DocValuesProducer;
 import org.apache.lucene.index.BinaryDocValues;
 import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.FieldInfo;
@@ -380,7 +381,7 @@
   public SortedSetDocValues getSortedSet(FieldInfo field) throws IOException {
     final FSTEntry entry = fsts.get(field.number);
     if (entry.numOrds == 0) {
-      return SortedSetDocValues.EMPTY; // empty FST!
+      return DocValues.EMPTY_SORTED_SET; // empty FST!
     }
     FST<Long> instance;
     synchronized(this) {
@@ -469,7 +470,7 @@
   @Override
   public Bits getDocsWithField(FieldInfo field) throws IOException {
     if (field.getDocValuesType() == FieldInfo.DocValuesType.SORTED_SET) {
-      return new SortedSetDocsWithField(getSortedSet(field), maxDoc);
+      return DocValues.docsWithValue(getSortedSet(field), maxDoc);
     } else {
       return new Bits.MatchAllBits(maxDoc);
     }
Index: lucene/core/src/java/org/apache/lucene/codecs/lucene45/Lucene45DocValuesProducer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/lucene45/Lucene45DocValuesProducer.java	(revision 1585174)
+++ lucene/core/src/java/org/apache/lucene/codecs/lucene45/Lucene45DocValuesProducer.java	(working copy)
@@ -37,6 +37,7 @@
 import org.apache.lucene.codecs.DocValuesProducer;
 import org.apache.lucene.index.BinaryDocValues;
 import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.FieldInfo;
@@ -45,7 +46,6 @@
 import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.RandomAccessOrds;
 import org.apache.lucene.index.SegmentReadState;
-import org.apache.lucene.index.SingletonSortedSetDocValues;
 import org.apache.lucene.index.SortedDocValues;
 import org.apache.lucene.index.SortedSetDocValues;
 import org.apache.lucene.index.TermsEnum;
@@ -525,7 +525,7 @@
     SortedSetEntry ss = sortedSets.get(field.number);
     if (ss.format == SORTED_SET_SINGLE_VALUED_SORTED) {
       final SortedDocValues values = getSorted(field);
-      return new SingletonSortedSetDocValues(values);
+      return DocValues.singleton(values);
     } else if (ss.format != SORTED_SET_WITH_ADDRESSES) {
       throw new AssertionError();
     }
@@ -629,9 +629,9 @@
   public Bits getDocsWithField(FieldInfo field) throws IOException {
     switch(field.getDocValuesType()) {
       case SORTED_SET:
-        return new SortedSetDocsWithField(getSortedSet(field), maxDoc);
+        return DocValues.docsWithValue(getSortedSet(field), maxDoc);
       case SORTED:
-        return new SortedDocsWithField(getSorted(field), maxDoc);
+        return DocValues.docsWithValue(getSorted(field), maxDoc);
       case BINARY:
         BinaryEntry be = binaries.get(field.number);
         return getMissingBits(be.missingOffset);
Index: lucene/core/src/java/org/apache/lucene/index/BinaryDocValues.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/BinaryDocValues.java	(revision 1585174)
+++ lucene/core/src/java/org/apache/lucene/index/BinaryDocValues.java	(working copy)
@@ -30,14 +30,4 @@
 
   /** Lookup the value for document. */
   public abstract void get(int docID, BytesRef result);
-  
-  /** An empty BinaryDocValues which returns {@link BytesRef#EMPTY_BYTES} for every document */
-  public static final BinaryDocValues EMPTY = new BinaryDocValues() {
-    @Override
-    public void get(int docID, BytesRef result) {
-      result.bytes = BytesRef.EMPTY_BYTES;
-      result.offset = 0;
-      result.length = 0;
-    }
-  };
 }
Index: lucene/core/src/java/org/apache/lucene/index/DocTermOrds.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/DocTermOrds.java	(revision 1585174)
+++ lucene/core/src/java/org/apache/lucene/index/DocTermOrds.java	(working copy)
@@ -762,7 +762,7 @@
   /** Returns a SortedSetDocValues view of this instance */
   public SortedSetDocValues iterator(AtomicReader reader) throws IOException {
     if (isEmpty()) {
-      return SortedSetDocValues.EMPTY;
+      return DocValues.EMPTY_SORTED_SET;
     } else {
       return new Iterator(reader);
     }
Index: lucene/core/src/java/org/apache/lucene/index/DocValues.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/DocValues.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/index/DocValues.java	(working copy)
@@ -0,0 +1,162 @@
+package org.apache.lucene.index;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
+
+/** 
+ * This class contains utility methods and constants for DocValues
+ */
+public final class DocValues {
+  
+  /* no instantiation */
+  private DocValues() {}
+  
+  /** 
+   * An empty BinaryDocValues which returns {@link BytesRef#EMPTY_BYTES} for every document 
+   */
+  public static final BinaryDocValues EMPTY_BINARY = new BinaryDocValues() {
+    @Override
+    public void get(int docID, BytesRef result) {
+      result.bytes = BytesRef.EMPTY_BYTES;
+      result.offset = 0;
+      result.length = 0;
+    }
+  };
+
+  /** 
+   * An empty NumericDocValues which returns zero for every document 
+   */
+  public static final NumericDocValues EMPTY_NUMERIC = new NumericDocValues() {
+    @Override
+    public long get(int docID) {
+      return 0;
+    }
+  };
+
+  /** 
+   * An empty SortedDocValues which returns {@link BytesRef#EMPTY_BYTES} for every document 
+   */
+  public static final SortedDocValues EMPTY_SORTED = new SortedDocValues() {
+    @Override
+    public int getOrd(int docID) {
+      return -1;
+    }
+
+    @Override
+    public void lookupOrd(int ord, BytesRef result) {
+      result.bytes = BytesRef.EMPTY_BYTES;
+      result.offset = 0;
+      result.length = 0;
+    }
+
+    @Override
+    public int getValueCount() {
+      return 0;
+    }
+  };
+
+  /** 
+   * An empty SortedDocValues which returns {@link SortedSetDocValues#NO_MORE_ORDS} for every document 
+   */
+  public static final SortedSetDocValues EMPTY_SORTED_SET = new RandomAccessOrds() {
+
+    @Override
+    public long nextOrd() {
+      return NO_MORE_ORDS;
+    }
+
+    @Override
+    public void setDocument(int docID) {}
+
+    @Override
+    public void lookupOrd(long ord, BytesRef result) {
+      throw new IndexOutOfBoundsException();
+    }
+
+    @Override
+    public long getValueCount() {
+      return 0;
+    }
+
+    @Override
+    public long ordAt(int index) {
+      throw new IndexOutOfBoundsException();
+    }
+
+    @Override
+    public int cardinality() {
+      return 0;
+    }
+  };
+  
+  /** 
+   * Returns a multi-valued view over the provided SortedDocValues 
+   */
+  public static SortedSetDocValues singleton(SortedDocValues dv) {
+    return new SingletonSortedSetDocValues(dv);
+  }
+  
+  /** 
+   * Returns a single-valued view of the SortedSetDocValues, if it was previously
+   * wrapped with {@link #singleton}, or null. 
+   */
+  public static SortedDocValues unwrapSingleton(SortedSetDocValues dv) {
+    if (dv instanceof SingletonSortedSetDocValues) {
+      return ((SingletonSortedSetDocValues)dv).getSortedDocValues();
+    } else {
+      return null;
+    }
+  }
+  
+  /**
+   * Returns a Bits representing all documents from <code>dv</code> that have a value.
+   */
+  public static Bits docsWithValue(final SortedDocValues dv, final int maxDoc) {
+    return new Bits() {
+      @Override
+      public boolean get(int index) {
+        return dv.getOrd(index) >= 0;
+      }
+
+      @Override
+      public int length() {
+        return maxDoc;
+      }
+    };
+  }
+  
+  /**
+   * Returns a Bits representing all documents from <code>dv</code> that have a value.
+   */
+  public static Bits docsWithValue(final SortedSetDocValues dv, final int maxDoc) {
+    return new Bits() {
+      @Override
+      public boolean get(int index) {
+        dv.setDocument(index);
+        return dv.nextOrd() != SortedSetDocValues.NO_MORE_ORDS;
+      }
+
+      @Override
+      public int length() {
+        return maxDoc;
+      }
+    };
+  }
+}

Property changes on: lucene/core/src/java/org/apache/lucene/index/DocValues.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java	(revision 1585174)
+++ lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java	(working copy)
@@ -73,7 +73,7 @@
       AtomicReaderContext context = leaves.get(i);
       NumericDocValues v = context.reader().getNormValues(field);
       if (v == null) {
-        v = NumericDocValues.EMPTY;
+        v = DocValues.EMPTY_NUMERIC;
       } else {
         anyReal = true;
       }
@@ -115,7 +115,7 @@
       AtomicReaderContext context = leaves.get(i);
       NumericDocValues v = context.reader().getNumericDocValues(field);
       if (v == null) {
-        v = NumericDocValues.EMPTY;
+        v = DocValues.EMPTY_NUMERIC;
       } else {
         anyReal = true;
       }
@@ -205,7 +205,7 @@
       AtomicReaderContext context = leaves.get(i);
       BinaryDocValues v = context.reader().getBinaryDocValues(field);
       if (v == null) {
-        v = BinaryDocValues.EMPTY;
+        v = DocValues.EMPTY_BINARY;
       } else {
         anyReal = true;
       }
@@ -250,7 +250,7 @@
       AtomicReaderContext context = leaves.get(i);
       SortedDocValues v = context.reader().getSortedDocValues(field);
       if (v == null) {
-        v = SortedDocValues.EMPTY;
+        v = DocValues.EMPTY_SORTED;
       } else {
         anyReal = true;
       }
@@ -294,7 +294,7 @@
       AtomicReaderContext context = leaves.get(i);
       SortedSetDocValues v = context.reader().getSortedSetDocValues(field);
       if (v == null) {
-        v = SortedSetDocValues.EMPTY;
+        v = DocValues.EMPTY_SORTED_SET;
       } else {
         anyReal = true;
       }
Index: lucene/core/src/java/org/apache/lucene/index/NumericDocValues.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/NumericDocValues.java	(revision 1585174)
+++ lucene/core/src/java/org/apache/lucene/index/NumericDocValues.java	(working copy)
@@ -32,12 +32,4 @@
    * @return numeric value
    */
   public abstract long get(int docID);
-
-  /** An empty NumericDocValues which returns zero for every document */
-  public static final NumericDocValues EMPTY = new NumericDocValues() {
-    @Override
-    public long get(int docID) {
-      return 0;
-    }
-  };
 }
Index: lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java	(revision 1585174)
+++ lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java	(working copy)
@@ -167,7 +167,7 @@
               NumericDocValues values = reader.getNumericDocValues(field.name);
               Bits bits = reader.getDocsWithField(field.name);
               if (values == null) {
-                values = NumericDocValues.EMPTY;
+                values = DocValues.EMPTY_NUMERIC;
                 bits = new Bits.MatchNoBits(reader.maxDoc());
               }
               toMerge.add(values);
@@ -181,7 +181,7 @@
               BinaryDocValues values = reader.getBinaryDocValues(field.name);
               Bits bits = reader.getDocsWithField(field.name);
               if (values == null) {
-                values = BinaryDocValues.EMPTY;
+                values = DocValues.EMPTY_BINARY;
                 bits = new Bits.MatchNoBits(reader.maxDoc());
               }
               toMerge.add(values);
@@ -193,7 +193,7 @@
             for (AtomicReader reader : mergeState.readers) {
               SortedDocValues values = reader.getSortedDocValues(field.name);
               if (values == null) {
-                values = SortedDocValues.EMPTY;
+                values = DocValues.EMPTY_SORTED;
               }
               toMerge.add(values);
             }
@@ -203,7 +203,7 @@
             for (AtomicReader reader : mergeState.readers) {
               SortedSetDocValues values = reader.getSortedSetDocValues(field.name);
               if (values == null) {
-                values = SortedSetDocValues.EMPTY;
+                values = DocValues.EMPTY_SORTED_SET;
               }
               toMerge.add(values);
             }
@@ -234,7 +234,7 @@
           for (AtomicReader reader : mergeState.readers) {
             NumericDocValues norms = reader.getNormValues(field.name);
             if (norms == null) {
-              norms = NumericDocValues.EMPTY;
+              norms = DocValues.EMPTY_NUMERIC;
             }
             toMerge.add(norms);
             docsWithField.add(new Bits.MatchAllBits(reader.maxDoc()));
Index: lucene/core/src/java/org/apache/lucene/index/SingletonSortedSetDocValues.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SingletonSortedSetDocValues.java	(revision 1585174)
+++ lucene/core/src/java/org/apache/lucene/index/SingletonSortedSetDocValues.java	(working copy)
@@ -26,7 +26,7 @@
  * against e.g. FieldCache.getDocTermOrds that also works for single-valued 
  * fields.
  */
-public class SingletonSortedSetDocValues extends SortedSetDocValues {
+final class SingletonSortedSetDocValues extends SortedSetDocValues {
   private final SortedDocValues in;
   private int docID;
   private boolean set;
Index: lucene/core/src/java/org/apache/lucene/index/SlowCompositeReaderWrapper.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SlowCompositeReaderWrapper.java	(revision 1585174)
+++ lucene/core/src/java/org/apache/lucene/index/SlowCompositeReaderWrapper.java	(working copy)
@@ -130,7 +130,7 @@
       AtomicReaderContext context = in.leaves().get(i);
       SortedDocValues v = context.reader().getSortedDocValues(field);
       if (v == null) {
-        v = SortedDocValues.EMPTY;
+        v = DocValues.EMPTY_SORTED;
       }
       values[i] = v;
       starts[i] = context.docBase;
@@ -169,7 +169,7 @@
       AtomicReaderContext context = in.leaves().get(i);
       SortedSetDocValues v = context.reader().getSortedSetDocValues(field);
       if (v == null) {
-        v = SortedSetDocValues.EMPTY;
+        v = DocValues.EMPTY_SORTED_SET;
       }
       values[i] = v;
       starts[i] = context.docBase;
Index: lucene/core/src/java/org/apache/lucene/index/SortedDocValues.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SortedDocValues.java	(revision 1585174)
+++ lucene/core/src/java/org/apache/lucene/index/SortedDocValues.java	(working copy)
@@ -68,26 +68,6 @@
     }
   }
 
-  /** An empty SortedDocValues which returns {@link BytesRef#EMPTY_BYTES} for every document */
-  public static final SortedDocValues EMPTY = new SortedDocValues() {
-    @Override
-    public int getOrd(int docID) {
-      return -1;
-    }
-
-    @Override
-    public void lookupOrd(int ord, BytesRef result) {
-      result.bytes = BytesRef.EMPTY_BYTES;
-      result.offset = 0;
-      result.length = 0;
-    }
-
-    @Override
-    public int getValueCount() {
-      return 0;
-    }
-  };
-
   /** If {@code key} exists, returns its ordinal, else
    *  returns {@code -insertionPoint-1}, like {@code
    *  Arrays.binarySearch}.
Index: lucene/core/src/java/org/apache/lucene/index/SortedSetDocValues.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SortedSetDocValues.java	(revision 1585174)
+++ lucene/core/src/java/org/apache/lucene/index/SortedSetDocValues.java	(working copy)
@@ -67,39 +67,6 @@
    */
   public abstract long getValueCount();
 
-
-  /** An empty SortedDocValues which returns {@link #NO_MORE_ORDS} for every document */
-  public static final SortedSetDocValues EMPTY = new RandomAccessOrds() {
-
-    @Override
-    public long nextOrd() {
-      return NO_MORE_ORDS;
-    }
-
-    @Override
-    public void setDocument(int docID) {}
-
-    @Override
-    public void lookupOrd(long ord, BytesRef result) {
-      throw new IndexOutOfBoundsException();
-    }
-
-    @Override
-    public long getValueCount() {
-      return 0;
-    }
-
-    @Override
-    public long ordAt(int index) {
-      throw new IndexOutOfBoundsException();
-    }
-
-    @Override
-    public int cardinality() {
-      return 0;
-    }
-  };
-
   /** If {@code key} exists, returns its ordinal, else
    *  returns {@code -insertionPoint-1}, like {@code
    *  Arrays.binarySearch}.
Index: lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java	(revision 1585174)
+++ lucene/core/src/java/org/apache/lucene/search/FieldCacheImpl.java	(working copy)
@@ -28,12 +28,12 @@
 import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.BinaryDocValues;
 import org.apache.lucene.index.DocTermOrds;
+import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.SegmentReader;
-import org.apache.lucene.index.SingletonSortedSetDocValues;
 import org.apache.lucene.index.SortedDocValues;
 import org.apache.lucene.index.SortedSetDocValues;
 import org.apache.lucene.index.Terms;
@@ -942,13 +942,13 @@
     } else {
       final FieldInfo info = reader.getFieldInfos().fieldInfo(field);
       if (info == null) {
-        return SortedDocValues.EMPTY;
+        return DocValues.EMPTY_SORTED;
       } else if (info.hasDocValues()) {
         // we don't try to build a sorted instance from numeric/binary doc
         // values because dedup can be very costly
         throw new IllegalStateException("Type mismatch: " + field + " was indexed as " + info.getDocValuesType());
       } else if (!info.isIndexed()) {
-        return SortedDocValues.EMPTY;
+        return DocValues.EMPTY_SORTED;
       }
       return (SortedDocValues) caches.get(SortedDocValues.class).get(reader, new CacheKey(field, acceptableOverheadRatio), false);
     }
@@ -1084,11 +1084,11 @@
 
     final FieldInfo info = reader.getFieldInfos().fieldInfo(field);
     if (info == null) {
-      return BinaryDocValues.EMPTY;
+      return DocValues.EMPTY_BINARY;
     } else if (info.hasDocValues()) {
       throw new IllegalStateException("Type mismatch: " + field + " was indexed as " + info.getDocValuesType());
     } else if (!info.isIndexed()) {
-      return BinaryDocValues.EMPTY;
+      return DocValues.EMPTY_BINARY;
     }
 
     return (BinaryDocValues) caches.get(BinaryDocValues.class).get(reader, new CacheKey(field, acceptableOverheadRatio), setDocsWithField);
@@ -1198,16 +1198,16 @@
     
     SortedDocValues sdv = reader.getSortedDocValues(field);
     if (sdv != null) {
-      return new SingletonSortedSetDocValues(sdv);
+      return DocValues.singleton(sdv);
     }
     
     final FieldInfo info = reader.getFieldInfos().fieldInfo(field);
     if (info == null) {
-      return SortedSetDocValues.EMPTY;
+      return DocValues.EMPTY_SORTED_SET;
     } else if (info.hasDocValues()) {
       throw new IllegalStateException("Type mismatch: " + field + " was indexed as " + info.getDocValuesType());
     } else if (!info.isIndexed()) {
-      return SortedSetDocValues.EMPTY;
+      return DocValues.EMPTY_SORTED_SET;
     }
     
     DocTermOrds dto = (DocTermOrds) caches.get(DocTermOrds.class).get(reader, new CacheKey(field, null), false);
Index: lucene/facet/src/java/org/apache/lucene/facet/taxonomy/DocValuesOrdinalsReader.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/taxonomy/DocValuesOrdinalsReader.java	(revision 1585174)
+++ lucene/facet/src/java/org/apache/lucene/facet/taxonomy/DocValuesOrdinalsReader.java	(working copy)
@@ -22,6 +22,7 @@
 import org.apache.lucene.facet.FacetsConfig;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.BinaryDocValues;
+import org.apache.lucene.index.DocValues;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IntsRef;
@@ -45,7 +46,7 @@
   public OrdinalsSegmentReader getReader(AtomicReaderContext context) throws IOException {
     BinaryDocValues values0 = context.reader().getBinaryDocValues(field);
     if (values0 == null) {
-      values0 = BinaryDocValues.EMPTY;
+      values0 = DocValues.EMPTY_BINARY;
     }
 
     final BinaryDocValues values = values0;
Index: lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField.java	(revision 1585174)
+++ lucene/sandbox/src/java/org/apache/lucene/sandbox/queries/SortedSetSortField.java	(working copy)
@@ -20,8 +20,8 @@
 import java.io.IOException;
 
 import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.RandomAccessOrds;
-import org.apache.lucene.index.SingletonSortedSetDocValues;
 import org.apache.lucene.index.SortedDocValues;
 import org.apache.lucene.index.SortedSetDocValues;
 import org.apache.lucene.search.FieldCache;
@@ -165,11 +165,12 @@
           throw new UnsupportedOperationException("fields containing more than " + (Integer.MAX_VALUE-1) + " unique terms are unsupported");
         }
         
-        if (sortedSet instanceof SingletonSortedSetDocValues) {
+        SortedDocValues singleton = DocValues.unwrapSingleton(sortedSet);
+        if (singleton != null) {
           // it's actually single-valued in practice, but indexed as multi-valued,
           // so just sort on the underlying single-valued dv directly.
           // regardless of selector type, this optimization is safe!
-          return ((SingletonSortedSetDocValues) sortedSet).getSortedDocValues();
+          return singleton;
         } else if (selector == Selector.MIN) {
           return new MinValue(sortedSet);
         } else {
Index: lucene/test-framework/src/java/org/apache/lucene/index/BaseDocValuesFormatTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/index/BaseDocValuesFormatTestCase.java	(revision 1585174)
+++ lucene/test-framework/src/java/org/apache/lucene/index/BaseDocValuesFormatTestCase.java	(working copy)
@@ -2191,7 +2191,7 @@
     // can be null for the segment if no docs actually had any SortedDocValues
     // in this case FC.getDocTermsOrds returns EMPTY
     if (actual == null) {
-      assertEquals(SortedSetDocValues.EMPTY, expected);
+      assertEquals(DocValues.EMPTY_SORTED_SET, expected);
       return;
     }
     assertEquals(expected.getValueCount(), actual.getValueCount());
Index: solr/core/src/java/org/apache/solr/request/DocValuesFacets.java
===================================================================
--- solr/core/src/java/org/apache/solr/request/DocValuesFacets.java	(revision 1585174)
+++ solr/core/src/java/org/apache/solr/request/DocValuesFacets.java	(working copy)
@@ -21,10 +21,10 @@
 import java.util.List;
 
 import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.MultiDocValues.MultiSortedDocValues;
 import org.apache.lucene.index.MultiDocValues.MultiSortedSetDocValues;
 import org.apache.lucene.index.MultiDocValues.OrdinalMap;
-import org.apache.lucene.index.SingletonSortedSetDocValues;
 import org.apache.lucene.index.SortedDocValues;
 import org.apache.lucene.index.SortedSetDocValues;
 import org.apache.lucene.search.DocIdSet;
@@ -70,7 +70,7 @@
       }
     } else {
       SortedDocValues single = searcher.getAtomicReader().getSortedDocValues(fieldName);
-      si = single == null ? null : new SingletonSortedSetDocValues(single);
+      si = single == null ? null : DocValues.singleton(single);
       if (single instanceof MultiSortedDocValues) {
         ordinalMap = ((MultiSortedDocValues)single).mapping;
       }
@@ -129,12 +129,12 @@
           if (schemaField.multiValued()) {
             SortedSetDocValues sub = leaf.reader().getSortedSetDocValues(fieldName);
             if (sub == null) {
-              sub = SortedSetDocValues.EMPTY;
+              sub = DocValues.EMPTY_SORTED_SET;
             }
-            if (sub instanceof SingletonSortedSetDocValues) {
+            final SortedDocValues singleton = DocValues.unwrapSingleton(sub);
+            if (singleton != null) {
               // some codecs may optimize SORTED_SET storage for single-valued fields
-              final SortedDocValues values = ((SingletonSortedSetDocValues) sub).getSortedDocValues();
-              accumSingle(counts, startTermIndex, values, disi, subIndex, ordinalMap);
+              accumSingle(counts, startTermIndex, singleton, disi, subIndex, ordinalMap);
             } else {
               accumMulti(counts, startTermIndex, sub, disi, subIndex, ordinalMap);
             }
@@ -141,7 +141,7 @@
           } else {
             SortedDocValues sub = leaf.reader().getSortedDocValues(fieldName);
             if (sub == null) {
-              sub = SortedDocValues.EMPTY;
+              sub = DocValues.EMPTY_SORTED;
             }
             accumSingle(counts, startTermIndex, sub, disi, subIndex, ordinalMap);
           }
