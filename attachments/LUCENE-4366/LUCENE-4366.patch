Index: lucene/core/src/test/org/apache/lucene/search/TestBooleanOr.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBooleanOr.java	(revision 1385075)
+++ lucene/core/src/test/org/apache/lucene/search/TestBooleanOr.java	(working copy)
@@ -16,15 +16,18 @@
  * limitations under the License.
  */
 import java.io.IOException;
+import java.util.concurrent.atomic.AtomicInteger;
 
-import org.apache.lucene.util.LuceneTestCase;
-
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.FixedBitSet;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util._TestUtil;
 
 public class TestBooleanOr extends LuceneTestCase {
 
@@ -162,4 +165,64 @@
     dir.close();
     super.tearDown();
   }
+
+  public void testBooleanScorerMax() throws IOException {
+    Directory dir = newDirectory();
+    RandomIndexWriter riw = new RandomIndexWriter(random(), dir);
+
+    int docCount = atLeast(10000);
+
+    for(int i=0;i<docCount;i++) {
+      Document doc = new Document();
+      doc.add(newField("field", "a", TextField.TYPE_NOT_STORED));
+      riw.addDocument(doc);
+    }
+
+    riw.forceMerge(1);
+    IndexReader r = riw.getReader();
+    riw.close();
+
+    IndexSearcher s = newSearcher(r);
+    BooleanQuery bq = new BooleanQuery();
+    bq.add(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD);
+    bq.add(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD);
+
+    Weight w = s.createNormalizedWeight(bq);
+
+    assertEquals(1, s.getIndexReader().leaves().size());
+    Scorer scorer = w.scorer(s.getIndexReader().leaves().get(0), false, true, null);
+
+    final FixedBitSet hits = new FixedBitSet(docCount);
+    final AtomicInteger end = new AtomicInteger();
+    Collector c = new Collector() {
+        @Override
+        public void setNextReader(AtomicReaderContext sub) {
+        }
+
+        @Override
+        public void collect(int doc) {
+          assertTrue("collected doc=" + doc + " beyond max=" + end, doc < end.intValue());
+          hits.set(doc);
+        }
+
+        @Override
+        public void setScorer(Scorer scorer) {
+        }
+
+        @Override
+        public boolean acceptsDocsOutOfOrder() {
+          return true;
+        }
+      };
+
+    while (end.intValue() < docCount) {
+      final int inc = _TestUtil.nextInt(random(), 1, 1000);
+      end.getAndAdd(inc);
+      scorer.score(c, end.intValue(), scorer.docID());
+    }
+
+    assertEquals(docCount, hits.cardinality());
+    r.close();
+    dir.close();
+  }
 }
Index: lucene/core/src/test/org/apache/lucene/search/TestSort.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestSort.java	(revision 1385075)
+++ lucene/core/src/test/org/apache/lucene/search/TestSort.java	(working copy)
@@ -1039,7 +1039,7 @@
         
         TopDocs td = tdc.topDocs();
         ScoreDoc[] sd = td.scoreDocs;
-        assertEquals(10, sd.length);
+        assertEquals("collector=" + tdc + " sort=" + sort[i], 10, sd.length);
       }
     }
   }
Index: lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer.java	(revision 1385075)
+++ lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer.java	(working copy)
@@ -154,7 +154,7 @@
       public void setScorer(Scorer scorer) {
         // Make sure we got BooleanScorer:
         this.scorer = scorer;
-        assertEquals("Scorer is implemented by wrong class", BooleanScorer.class.getName() + "$BucketScorer", scorer.getClass().getName());
+        assertEquals("Scorer is implemented by wrong class", BooleanScorer.class.getName(), scorer.getClass().getName());
       }
       
       @Override
Index: lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java	(revision 1385075)
+++ lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java	(working copy)
@@ -121,7 +121,7 @@
       checkHits(searcher, csq2, csq2.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), ConstantScoreQuery.ConstantScorer.class.getName());
       
       // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!
-      final String bucketScorerClass = BooleanScorer.class.getName() + "$BucketScorer";
+      final String bucketScorerClass = BooleanScorer.class.getName();
       checkHits(searcher, bq, csq1.getBoost() + csq2.getBoost(), bucketScorerClass, null);
       checkHits(searcher, csqbq, csqbq.getBoost(), ConstantScoreQuery.ConstantScorer.class.getName(), bucketScorerClass);
     } finally {
Index: lucene/core/src/java/org/apache/lucene/search/BooleanScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/BooleanScorer.java	(revision 1385075)
+++ lucene/core/src/java/org/apache/lucene/search/BooleanScorer.java	(working copy)
@@ -60,37 +60,50 @@
 
 final class BooleanScorer extends Scorer {
   
-  private static final class BooleanScorerCollector extends Collector {
-    private BucketTable bucketTable;
-    private int mask;
+  static final int TABLE_SIZE = 1 << 11;
+  static final int TABLE_MASK = TABLE_SIZE - 1;
+
+  final Bucket[] buckets = new Bucket[TABLE_SIZE];
+
+  // Which slots are valid for the current chunk
+  final int[] validSlots = new int[TABLE_SIZE];
+
+  // How many valid slots are filled
+  int validCount;
+
+  // End of current chunk we are processing
+  private int end;
+
+  private final SubScorer[] scorers;
+  private final float[] coordFactors;
+  private final int minNrShouldMatch;
+  private Bucket current;
+
+  private final class BooleanScorerCollector extends Collector {
     private Scorer scorer;
-    
-    public BooleanScorerCollector(int mask, BucketTable bucketTable) {
-      this.mask = mask;
-      this.bucketTable = bucketTable;
+    private final boolean prohibited;
+
+    protected BooleanScorerCollector(boolean prohibited) {
+      this.prohibited = prohibited;
     }
-    
+
     @Override
     public void collect(final int doc) throws IOException {
-      final BucketTable table = bucketTable;
-      final int i = doc & BucketTable.MASK;
-      final Bucket bucket = table.buckets[i];
-      
+      final int slot = doc & TABLE_MASK;
+      final Bucket bucket = buckets[slot];
       if (bucket.doc != doc) {                    // invalid bucket
         bucket.doc = doc;                         // set doc
         bucket.score = scorer.score();            // initialize score
-        bucket.bits = mask;                       // initialize mask
         bucket.coord = 1;                         // initialize coord
-
-        bucket.next = table.first;                // push onto valid list
-        table.first = bucket;
-      } else {                                    // valid bucket
+        bucket.prohibited = prohibited;
+        validSlots[validCount++] = slot;
+      } else {
         bucket.score += scorer.score();           // increment score
-        bucket.bits |= mask;                      // add bits in mask
         bucket.coord++;                           // increment coord
+        bucket.prohibited |= prohibited;
       }
     }
-    
+
     @Override
     public void setNextReader(AtomicReaderContext context) {
       // not needed by this implementation
@@ -105,198 +118,131 @@
     public boolean acceptsDocsOutOfOrder() {
       return true;
     }
-
   }
-  
-  // An internal class which is used in score(Collector, int) for setting the
-  // current score. This is required since Collector exposes a setScorer method
-  // and implementations that need the score will call scorer.score().
-  // Therefore the only methods that are implemented are score() and doc().
-  private static final class BucketScorer extends Scorer {
 
-    double score;
-    int doc = NO_MORE_DOCS;
-    int freq;
-    
-    public BucketScorer(Weight weight) { super(weight); }
-    
-    @Override
-    public int advance(int target) { return NO_MORE_DOCS; }
+  // TODO for prohibited:
+  //  - don't call .score()
+  //  - don't call score on non-prohibited clause if the
+  //    bucket is already marked prohibited by prior
+  //    clause
+  //  - don't add prohibited slots to the live set
 
-    @Override
-    public int docID() { return doc; }
-
-    @Override
-    public float freq() { return freq; }
-
-    @Override
-    public int nextDoc() { return NO_MORE_DOCS; }
-    
-    @Override
-    public float score() { return (float)score; }
-    
-  }
-
   static final class Bucket {
     int doc = -1;            // tells if bucket is valid
     double score;             // incremental score
-    // TODO: break out bool anyProhibited, int
-    // numRequiredMatched; then we can remove 32 limit on
-    // required clauses
-    int bits;                // used for bool constraints
+    boolean prohibited;      // used for NOT constraint
     int coord;               // count of terms in score
-    Bucket next;             // next valid bucket
   }
   
-  /** A simple hash table of document scores within a range. */
-  static final class BucketTable {
-    public static final int SIZE = 1 << 11;
-    public static final int MASK = SIZE - 1;
-
-    final Bucket[] buckets = new Bucket[SIZE];
-    Bucket first = null;                          // head of valid list
-  
-    public BucketTable() {
-      // Pre-fill to save the lazy init when collecting
-      // each sub:
-      for(int idx=0;idx<SIZE;idx++) {
-        buckets[idx] = new Bucket();
-      }
-    }
-
-    public Collector newCollector(int mask) {
-      return new BooleanScorerCollector(mask, this);
-    }
-
-    public int size() { return SIZE; }
-  }
-
   static final class SubScorer {
-    public Scorer scorer;
-    // TODO: re-enable this if BQ ever sends us required clauses
-    //public boolean required = false;
-    public boolean prohibited;
-    public Collector collector;
-    public SubScorer next;
+    public final Scorer scorer;
+    public final boolean prohibited;
+    public final Collector collector;
 
     public SubScorer(Scorer scorer, boolean required, boolean prohibited,
-        Collector collector, SubScorer next) {
+                     Collector collector) {
       if (required) {
         throw new IllegalArgumentException("this scorer cannot handle required=true");
       }
       this.scorer = scorer;
-      // TODO: re-enable this if BQ ever sends us required clauses
-      //this.required = required;
       this.prohibited = prohibited;
       this.collector = collector;
-      this.next = next;
     }
   }
-  
-  private SubScorer scorers = null;
-  private BucketTable bucketTable = new BucketTable();
-  private final float[] coordFactors;
-  // TODO: re-enable this if BQ ever sends us required clauses
-  //private int requiredMask = 0;
-  private final int minNrShouldMatch;
-  private int end;
-  private Bucket current;
-  // Any time a prohibited clause matches we set bit 0:
-  private static final int PROHIBITED_MASK = 1;
-  
+
   BooleanScorer(BooleanWeight weight, boolean disableCoord, int minNrShouldMatch,
       List<Scorer> optionalScorers, List<Scorer> prohibitedScorers, int maxCoord) throws IOException {
     super(weight);
     this.minNrShouldMatch = minNrShouldMatch;
 
-    if (optionalScorers != null && optionalScorers.size() > 0) {
+    // Pre-fill to save the lazy init when collecting
+    // each sub:
+    for(int idx=0;idx<TABLE_SIZE;idx++) {
+      buckets[idx] = new Bucket();
+    }
+
+    List<SubScorer> subs = new ArrayList<SubScorer>();
+
+    if (optionalScorers != null) {
       for (Scorer scorer : optionalScorers) {
-        if (scorer.nextDoc() != NO_MORE_DOCS) {
-          scorers = new SubScorer(scorer, false, false, bucketTable.newCollector(0), scorers);
+        int doc = scorer.nextDoc();
+        if (doc != NO_MORE_DOCS) {
+          subs.add(new SubScorer(scorer, false, false, new BooleanScorerCollector(false)));
         }
       }
     }
     
-    if (prohibitedScorers != null && prohibitedScorers.size() > 0) {
+    if (prohibitedScorers != null) {
       for (Scorer scorer : prohibitedScorers) {
-        if (scorer.nextDoc() != NO_MORE_DOCS) {
-          scorers = new SubScorer(scorer, false, true, bucketTable.newCollector(PROHIBITED_MASK), scorers);
+        int doc = scorer.nextDoc();
+        if (doc != NO_MORE_DOCS) {
+          subs.add(new SubScorer(scorer, false, true, new BooleanScorerCollector(true)));
         }
       }
     }
 
+    scorers = subs.toArray(new SubScorer[subs.size()]);
+
     coordFactors = new float[optionalScorers.size() + 1];
     for (int i = 0; i < coordFactors.length; i++) {
       coordFactors[i] = disableCoord ? 1.0f : weight.coord(i, maxCoord); 
     }
   }
 
-  // firstDocID is ignored since nextDoc() initializes 'current'
   @Override
   public boolean score(Collector collector, int max, int firstDocID) throws IOException {
-    // Make sure it's only BooleanScorer that calls us:
-    assert firstDocID == -1;
-    boolean more;
-    Bucket tmp;
-    BucketScorer bs = new BucketScorer(weight);
 
     // The internal loop will set the score and doc before calling collect.
-    collector.setScorer(bs);
-    do {
-      bucketTable.first = null;
-      
-      while (current != null) {         // more queued 
+    collector.setScorer(this);
+    boolean more = true;
 
-        // check prohibited & required
-        if ((current.bits & PROHIBITED_MASK) == 0) {
+    while(true) {
 
-          // TODO: re-enable this if BQ ever sends us required
-          // clauses
-          //&& (current.bits & requiredMask) == requiredMask) {
-          
-          // NOTE: Lucene always passes max =
-          // Integer.MAX_VALUE today, because we never embed
-          // a BooleanScorer inside another (even though
-          // that should work)... but in theory an outside
-          // app could pass a different max so we must check
-          // it:
-          if (current.doc >= max){
-            tmp = current;
-            current = current.next;
-            tmp.next = bucketTable.first;
-            bucketTable.first = tmp;
-            continue;
-          }
-          
-          if (current.coord >= minNrShouldMatch) {
-            bs.score = current.score * coordFactors[current.coord];
-            bs.doc = current.doc;
-            bs.freq = current.coord;
-            collector.collect(current.doc);
-          }
+      final int limit = validCount;
+      validCount = 0;
+
+      for(int i=0;i<limit;i++) {
+        final int slot = validSlots[i];
+        current = buckets[slot];
+
+        // NOTE: Lucene always passes max =
+        // Integer.MAX_VALUE today, because we never embed
+        // a BooleanScorer inside another (even though
+        // that should work)... but in theory an outside
+        // app could pass a different max so we must check
+        // it:
+        if (current.doc >= max) {
+          // Save any too-large docIDs for next time we are
+          // called:
+          validSlots[validCount++] = slot;
+          continue;
         }
-        
-        current = current.next;         // pop the queue
+      
+        // check prohibited & minShouldMatch
+        if (!current.prohibited && current.coord >= minNrShouldMatch) {
+          collector.collect(current.doc);
+        }
       }
-      
-      if (bucketTable.first != null){
-        current = bucketTable.first;
-        bucketTable.first = current.next;
+
+      if (validCount != 0) {
         return true;
       }
 
+      if (!more) {
+        break;
+      }
+      
       // refill the queue
       more = false;
-      end += BucketTable.SIZE;
-      for (SubScorer sub = scorers; sub != null; sub = sub.next) {
-        int subScorerDocID = sub.scorer.docID();
-        if (subScorerDocID != NO_MORE_DOCS) {
-          more |= sub.scorer.score(sub.collector, end, subScorerDocID);
+      end += TABLE_SIZE;
+
+      for (SubScorer sub : scorers) {
+        int doc = sub.scorer.docID();
+        if (doc != NO_MORE_DOCS) {
+          more |= sub.scorer.score(sub.collector, end, doc);
         }
       }
-      current = bucketTable.first;
-      
-    } while (current != null || more);
+    }
 
     return false;
   }
@@ -308,7 +254,7 @@
 
   @Override
   public int docID() {
-    throw new UnsupportedOperationException();
+    return current == null ? -1 : current.doc;
   }
 
   @Override
@@ -318,12 +264,12 @@
 
   @Override
   public float score() {
-    throw new UnsupportedOperationException();
+    return (float) (current.score * coordFactors[current.coord]);
   }
 
   @Override
   public float freq() throws IOException {
-    throw new UnsupportedOperationException();
+    return current.coord;
   }
 
   @Override
@@ -335,7 +281,10 @@
   public String toString() {
     StringBuilder buffer = new StringBuilder();
     buffer.append("boolean(");
-    for (SubScorer sub = scorers; sub != null; sub = sub.next) {
+    for (SubScorer sub : scorers) {
+      if (sub.prohibited) {
+        buffer.append('-');
+      }
       buffer.append(sub.scorer.toString());
       buffer.append(" ");
     }
