diff --git a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DPoint.java b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DPoint.java
index 955a2bc..4c67004 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DPoint.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/Geo3DPoint.java
@@ -16,12 +16,20 @@
  */
 package org.apache.lucene.spatial3d;
 
+import java.util.List;
+import java.util.ArrayList;
+
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
 import org.apache.lucene.index.PointValues;
 import org.apache.lucene.spatial3d.geom.GeoPoint;
 import org.apache.lucene.spatial3d.geom.GeoShape;
 import org.apache.lucene.spatial3d.geom.PlanetModel;
+import org.apache.lucene.spatial3d.geom.GeoCircleFactory;
+import org.apache.lucene.spatial3d.geom.GeoBBoxFactory;
+import org.apache.lucene.spatial3d.geom.GeoPolygonFactory;
+import org.apache.lucene.spatial3d.geom.GeoPath;
+//import org.apache.lucene.spatial.util.GeoUtils;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.NumericUtils;
@@ -39,6 +47,10 @@ import org.apache.lucene.util.NumericUtils;
  *  @lucene.experimental */
 public final class Geo3DPoint extends Field {
 
+  protected final static double MEAN_EARTH_RADIUS_METERS = 6371008.7714;
+  
+  protected final static double RADIANS_PER_METER = 1.0 / MEAN_EARTH_RADIUS_METERS;
+  
   /** Indexing {@link FieldType}. */
   public static final FieldType TYPE = new FieldType();
   static {
@@ -47,17 +59,83 @@ public final class Geo3DPoint extends Field {
   }
 
   /** 
-   * Creates a new Geo3DPoint field with the specified lat, lon (in radians).
+   * Creates a new Geo3DPoint field with the specified lat, lon (in degrees).
    *
    * @throws IllegalArgumentException if the field name is null or lat or lon are out of bounds
    */
   public Geo3DPoint(String name, double lat, double lon) {
     super(name, TYPE);
+    //GeoUtils.checkLatitude(lat);
+    //GeoUtils.checkLongitude(lon);
     // Translate lat/lon to x,y,z:
-    final GeoPoint point = new GeoPoint(PlanetModel.WGS84, lat, lon);
+    final GeoPoint point = new GeoPoint(PlanetModel.SPHERE, fromDegrees(lat), fromDegrees(lon));
     fillFieldsData(point.x, point.y, point.z);
   }
 
+  protected static double fromDegrees(final double degrees) {
+    return Math.toRadians(degrees);
+  }
+  
+  protected static double fromMeters(final double meters) {
+    return meters * RADIANS_PER_METER;
+  }
+  
+  public static Query newDistanceQuery(final String field, final double lat, final double lon, final double distMeters) {
+    //GeoUtils.checkLatitude(lat);
+    //GeoUtils.checkLongitude(lon);
+    final GeoShape shape = GeoCircleFactory.makeGeoCircle(PlanetModel.SPHERE, fromDegrees(lat), fromDegrees(lon), fromMeters(distMeters));
+    return newShapeQuery(field, shape);
+  }
+  
+  public static Query newBBoxQuery(final String field, final double minLat, final double maxLat, final double minLon, final double maxLon) {
+    //GeoUtils.checkLatitude(minLat);
+    //GeoUtils.checkLongitude(minLon);
+    //GeoUtils.checkLatitude(maxLat);
+    //GeoUtils.checkLongitude(maxLon);
+    final GeoShape shape = GeoBBoxFactory.makeGeoBBox(PlanetModel.SPHERE, 
+      fromDegrees(maxLat), fromDegrees(minLat), fromDegrees(minLon), fromDegrees(maxLon));
+    return newShapeQuery(field, shape);
+  }
+
+  public static Query newPolygonQuery(final String field, final double[] polyLats, final double[] polyLons) {
+    if (polyLats.length != polyLons.length) {
+      throw new IllegalArgumentException("same number of lats and lons required");
+    }
+    if (polyLats.length < 3) {
+      throw new IllegalArgumentException("need three or more points");
+    }
+    final List<GeoPoint> polyPoints = new ArrayList<>();
+    for (int i = 0; i < polyLats.length; i++) {
+      final double lat = polyLats[i];
+      final double lon = polyLons[i];
+    //  GeoUtils.checkLatitude(lat);
+    //  GeoUtils.checkLongitude(lon);
+      polyPoints.add(new GeoPoint(PlanetModel.SPHERE, fromDegrees(lat), fromDegrees(lon)));
+    }
+    // We don't know what the sense of the polygon is without providing the index of one vertex we know to be convex.
+    // Since that doesn't fit with the "super-simple API" requirements, we just use the index of the first one, and people have to just
+    // know to do it that way.
+    final int convexPointIndex = 0;
+    final GeoShape shape = GeoPolygonFactory.makeGeoPolygon(PlanetModel.SPHERE, polyPoints, convexPointIndex);
+    return newShapeQuery(field, shape);
+  }
+  
+  public static Query newPathQuery(final String field, final double[] pathLats, final double[] pathLons, final double pathWidthMeters) {
+    if (pathLats.length != pathLons.length) {
+      throw new IllegalArgumentException("same number of lats and lons required");
+    }
+    final GeoPoint[] points = new GeoPoint[pathLats.length];
+    for (int i = 0; i < pathLats.length; i++) {
+      final double lat = pathLats[i];
+      final double lon = pathLons[i];
+      //  GeoUtils.checkLatitude(lat);
+      //  GeoUtils.checkLongitude(lon);
+      points[i] = new GeoPoint(PlanetModel.SPHERE, fromDegrees(lat), fromDegrees(lon));
+    }
+    final GeoShape shape = new GeoPath(PlanetModel.SPHERE, fromMeters(pathWidthMeters), points);
+    return newShapeQuery(field, shape);
+  }
+  
   /** 
    * Creates a new Geo3DPoint field with the specified x,y,z.
    *
@@ -80,12 +158,12 @@ public final class Geo3DPoint extends Field {
   
   /** Encode single dimension */
   public static void encodeDimension(double value, byte bytes[], int offset) {
-    NumericUtils.intToSortableBytes(Geo3DUtil.encodeValue(PlanetModel.WGS84.getMaximumMagnitude(), value), bytes, offset);
+    NumericUtils.intToSortableBytes(Geo3DUtil.encodeValue(PlanetModel.SPHERE.getMaximumMagnitude(), value), bytes, offset);
   }
   
   /** Decode single dimension */
   public static double decodeDimension(byte value[], int offset) {
-    return Geo3DUtil.decodeValueCenter(PlanetModel.WGS84.getMaximumMagnitude(), NumericUtils.sortableBytesToInt(value, offset));
+    return Geo3DUtil.decodeValueCenter(PlanetModel.SPHERE.getMaximumMagnitude(), NumericUtils.sortableBytesToInt(value, offset));
   }
 
   /** Returns a query matching all points inside the provided shape.
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInGeo3DShapeQuery.java b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInGeo3DShapeQuery.java
index 3cc9530..12b4341 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInGeo3DShapeQuery.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInGeo3DShapeQuery.java
@@ -54,8 +54,8 @@ final class PointInGeo3DShapeQuery extends Query {
 
     if (shape instanceof BasePlanetObject) {
       BasePlanetObject planetObject = (BasePlanetObject) shape;
-      if (planetObject.getPlanetModel().equals(PlanetModel.WGS84) == false) {
-        throw new IllegalArgumentException("this qurey requires PlanetModel.WGS84, but got: " + planetObject.getPlanetModel());
+      if (planetObject.getPlanetModel().equals(PlanetModel.SPHERE) == false) {
+        throw new IllegalArgumentException("this qurey requires PlanetModel.SPHERE, but got: " + planetObject.getPlanetModel());
       }
     }
   }
@@ -98,7 +98,7 @@ final class PointInGeo3DShapeQuery extends Query {
         assert xyzSolid.getRelationship(shape) == GeoArea.WITHIN || xyzSolid.getRelationship(shape) == GeoArea.OVERLAPS: "expected WITHIN (1) or OVERLAPS (2) but got " + xyzSolid.getRelationship(shape) + "; shape="+shape+"; XYZSolid="+xyzSolid;
         */
 
-        double planetMax = PlanetModel.WGS84.getMaximumMagnitude();
+        double planetMax = PlanetModel.SPHERE.getMaximumMagnitude();
 
         DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());
 
@@ -139,7 +139,7 @@ final class PointInGeo3DShapeQuery extends Query {
                              assert yMin <= yMax;
                              assert zMin <= zMax;
 
-                             GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.WGS84, xMin, xMax, yMin, yMax, zMin, zMax);
+                             GeoArea xyzSolid = GeoAreaFactory.makeGeoArea(PlanetModel.SPHERE, xMin, xMax, yMin, yMax, zMin, zMax);
 
                              switch(xyzSolid.getRelationship(shape)) {
                              case GeoArea.CONTAINS:
diff --git a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint.java b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint.java
index 5c0044f..ccaf093 100644
--- a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint.java
+++ b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint.java
@@ -115,7 +115,7 @@ public class TestGeo3DPoint extends LuceneTestCase {
     iwc.setCodec(getCodec());
     IndexWriter w = new IndexWriter(dir, iwc);
     Document doc = new Document();
-    doc.add(new Geo3DPoint("field", toRadians(50.7345267), toRadians(-97.5303555)));
+    doc.add(new Geo3DPoint("field", 50.7345267, -97.5303555));
     w.addDocument(doc);
     IndexReader r = DirectoryReader.open(w);
     // We can't wrap with "exotic" readers because the query must see the BKD3DDVFormat:
@@ -128,7 +128,7 @@ public class TestGeo3DPoint extends LuceneTestCase {
   }
 
   private static double toRadians(double degrees) {
-    return Math.PI*(degrees/360.0);
+    return Math.PI*(degrees/180.0);
   }
 
   private static PlanetModel getPlanetModel() {
@@ -508,13 +508,13 @@ public class TestGeo3DPoint extends LuceneTestCase {
         if (x == 0) {
           // Identical lat to old point
           lats[docID] = lats[oldDocID];
-          lons[docID] = toRadians(randomLon());
+          lons[docID] = randomLon();
           if (VERBOSE) {
             System.err.println("  doc=" + docID + " lat=" + lats[docID] + " lon=" + lons[docID] + " (same lat as doc=" + oldDocID + ")");
           }
         } else if (x == 1) {
           // Identical lon to old point
-          lats[docID] = toRadians(randomLat());
+          lats[docID] = randomLat();
           lons[docID] = lons[oldDocID];
           if (VERBOSE) {
             System.err.println("  doc=" + docID + " lat=" + lats[docID] + " lon=" + lons[docID] + " (same lon as doc=" + oldDocID + ")");
@@ -529,8 +529,8 @@ public class TestGeo3DPoint extends LuceneTestCase {
           }
         }
       } else {
-        lats[docID] = toRadians(randomLat());
-        lons[docID] = toRadians(randomLon());
+        lats[docID] = randomLat();
+        lons[docID] = randomLon();
         haveRealDoc = true;
         if (VERBOSE) {
           System.err.println("  doc=" + docID + " lat=" + lats[docID] + " lon=" + lons[docID]);
@@ -759,7 +759,7 @@ public class TestGeo3DPoint extends LuceneTestCase {
                 if (Double.isNaN(lats[id]) == false) {
 
                   // Accurate point:
-                  GeoPoint point1 = new GeoPoint(PlanetModel.WGS84, lats[id], lons[id]);
+                  GeoPoint point1 = new GeoPoint(PlanetModel.WGS84, toRadians(lats[id]), toRadians(lons[id]));
 
                   // Quantized point (32 bits per dim):
                   GeoPoint point2 = quantize(PlanetModel.WGS84.getMaximumMagnitude(), point1);
@@ -795,12 +795,12 @@ public class TestGeo3DPoint extends LuceneTestCase {
   }
 
   public void testToString() {
-    Geo3DPoint point = new Geo3DPoint("point", toRadians(44.244272), toRadians(7.769736));
-    assertEquals("Geo3DPoint <point: x=0.9248467864160119 y=0.06280434265368656 z=0.37682349005486243>", point.toString());
+    Geo3DPoint point = new Geo3DPoint("point", 44.244272, 7.769736);
+    assertEquals("Geo3DPoint <point: x=0.709426287693908 y=0.09679758561541502 z=0.6973564369288621>", point.toString());
   }
 
   public void testShapeQueryToString() {
-    assertEquals("PointInGeo3DShapeQuery: field=point: Shape: GeoStandardCircle: {planetmodel=PlanetModel.WGS84, center=[lat=0.3861041107739683, lon=0.06780373760536706], radius=0.1(5.729577951308232)}",
+    assertEquals("PointInGeo3DShapeQuery: field=point: Shape: GeoStandardCircle: {planetmodel=PlanetModel.WGS84, center=[lat=0.7722082215479366, lon=0.13560747521073413], radius=0.1(5.729577951308232)}",
                  Geo3DPoint.newShapeQuery("point", GeoCircleFactory.makeGeoCircle(PlanetModel.WGS84, toRadians(44.244272), toRadians(7.769736), 0.1)).toString());
   }
 
