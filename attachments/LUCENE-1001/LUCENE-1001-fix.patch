Index: src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
===================================================================
--- src/java/org/apache/lucene/search/spans/NearSpansOrdered.java	(revision 719429)
+++ src/java/org/apache/lucene/search/spans/NearSpansOrdered.java	(working copy)
@@ -20,8 +20,10 @@
 import org.apache.lucene.index.IndexReader;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Comparator;
+import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Collection;
@@ -237,14 +239,18 @@
     if (subSpans[subSpans.length - 1].isPayloadAvailable()) {
       matchPayload.addAll(subSpans[subSpans.length - 1].getPayload());
     }
+    boolean usePossiblePayload = true;
+    Collection possiblePayload = null;
+    
     int matchSlop = 0;
     int lastStart = matchStart;
     int lastEnd = matchEnd;
     for (int i = subSpans.length - 2; i >= 0; i--) {
       PayloadSpans prevSpans = subSpans[i];
-      
-      if (subSpans[i].isPayloadAvailable()) {
-        matchPayload.addAll(0, subSpans[i].getPayload());
+      if (prevSpans.isPayloadAvailable()) {
+        Collection payload = prevSpans.getPayload();
+        possiblePayload = new ArrayList(payload.size());
+        possiblePayload.addAll(payload);
       }
       
       int prevStart = prevSpans.start();
@@ -263,11 +269,25 @@
           if (! docSpansOrdered(ppStart, ppEnd, lastStart, lastEnd)) {
             break; // Check remaining subSpans.
           } else { // prevSpans still before (lastStart, lastEnd)
+            usePossiblePayload = false;
             prevStart = ppStart;
             prevEnd = ppEnd;
           }
         }
       }
+
+      if (usePossiblePayload) {
+        if (possiblePayload != null) {
+          matchPayload.addAll(0, possiblePayload);
+        }
+      } else {
+        possiblePayload.clear();
+        if (subSpans[i].isPayloadAvailable()) {
+          Collection payload = prevSpans.getPayload();
+          matchPayload.addAll(0, payload);
+        }
+      }
+      
       assert prevStart <= matchStart;
       if (matchStart > prevEnd) { // Only non overlapping spans add to slop.
         matchSlop += (matchStart - prevEnd);
Index: src/test/org/apache/lucene/search/spans/TestPayloadSpans.java
===================================================================
--- src/test/org/apache/lucene/search/spans/TestPayloadSpans.java	(revision 719429)
+++ src/test/org/apache/lucene/search/spans/TestPayloadSpans.java	(working copy)
@@ -18,15 +18,15 @@
 
 import java.io.IOException;
 import java.io.Reader;
+import java.io.StringReader;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 
-import junit.framework.TestCase;
-
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.LowerCaseTokenizer;
+import org.apache.lucene.analysis.Token;
 import org.apache.lucene.analysis.TokenFilter;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
@@ -34,6 +34,7 @@
 import org.apache.lucene.analysis.tokenattributes.TermAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
+import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.Payload;
@@ -42,13 +43,15 @@
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Similarity;
 import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.payloads.PayloadHelper;
 import org.apache.lucene.search.payloads.PayloadSpanUtil;
+import org.apache.lucene.store.LockObtainFailedException;
 import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.LuceneTestCase;
 
 public class TestPayloadSpans extends LuceneTestCase {
-  private final static boolean DEBUG = false;
+  private final static boolean DEBUG = true;
   private IndexSearcher searcher;
   private Similarity similarity = new DefaultSimilarity();
   protected IndexReader indexReader;
@@ -143,13 +146,16 @@
 
     spanNearQuery = new SpanNearQuery(clauses, 6, true);
      
-   
+    // xx within 6 of rr
+    
     SpanQuery[] clauses2 = new SpanQuery[2];
      
     clauses2[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "yy"));
     clauses2[1] = spanNearQuery;
      
     SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses2, 6, false);
+    
+    // yy within 6 of xx within 6 of rr
 
     spans = nestedSpanNearQuery.getPayloadSpans(searcher.getIndexReader());
     assertTrue("spans is null and it shouldn't be", spans != null);
@@ -221,6 +227,42 @@
     checkSpans(spans, 2, new int[]{8, 8});
   }
   
+  public void testShrinkToAfterShortestMatch() throws CorruptIndexException,
+      LockObtainFailedException, IOException {
+    RAMDirectory directory = new RAMDirectory();
+    IndexWriter writer = new IndexWriter(directory, new TestPayloadAnalyzer(),
+        IndexWriter.MaxFieldLength.LIMITED);
+    Document doc = new Document();
+    doc.add(new Field("content", new StringReader("a b c d e f g h i j a k")));
+    writer.addDocument(doc);
+    writer.close();
+
+    IndexSearcher is = new IndexSearcher(directory);
+
+    SpanTermQuery stq1 = new SpanTermQuery(new Term("content", "a"));
+    SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
+    SpanQuery[] sqs = { stq1, stq2 };
+    SpanNearQuery snq = new SpanNearQuery(sqs, 1, true);
+    PayloadSpans spans = snq.getPayloadSpans(is.getIndexReader());
+
+    TopDocs topDocs = is.search(snq, 1);
+
+    for (int i = 0; i < topDocs.scoreDocs.length; i++) {
+      while (spans.next()) {
+        Collection<byte[]> payloads = spans.getPayload();
+        int cnt = 0;
+        for (Iterator<byte[]> it = payloads.iterator(); it.hasNext();) {
+          if(cnt == 0) {
+            assertEquals(new String(it.next()), "a:Noise:10");
+          } else if(cnt == 1) {
+            assertEquals(new String(it.next()), "k:Noise:11");
+          }
+          cnt++;
+        }
+      }
+    }
+  }
+  
   public void testPayloadSpanUtil() throws Exception {
     RAMDirectory directory = new RAMDirectory();
     PayloadAnalyzer analyzer = new PayloadAnalyzer();
@@ -383,4 +425,13 @@
       return false;
     }
   }
+  
+  public class TestPayloadAnalyzer extends Analyzer {
+
+    public TokenStream tokenStream(String fieldName, Reader reader) {
+      TokenStream result = new LowerCaseTokenizer(reader);
+      result = new PayloadFilter(result, fieldName);
+      return result;
+    }
+  }
 }
\ No newline at end of file

