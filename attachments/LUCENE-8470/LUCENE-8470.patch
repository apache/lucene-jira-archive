diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesConsumer.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesConsumer.java
index 7d096a4..54ec424 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesConsumer.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesConsumer.java
@@ -23,7 +23,6 @@ import java.util.Iterator;
 import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.DocValuesConsumer;
 import org.apache.lucene.codecs.DocValuesProducer;
-import org.apache.lucene.codecs.LegacyDocValuesIterables;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.SegmentWriteState;
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java
index fe6c8f6..9b00aff 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/DirectDocValuesProducer.java
@@ -28,8 +28,17 @@ import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.DocValuesProducer;
-import org.apache.lucene.index.*;
+import org.apache.lucene.index.BinaryDocValues;
+import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.NumericDocValues;
+import org.apache.lucene.index.SegmentReadState;
 import org.apache.lucene.index.SortedDocValues;
+import org.apache.lucene.index.SortedNumericDocValues;
+import org.apache.lucene.index.SortedSetDocValues;
 import org.apache.lucene.store.ChecksumIndexInput;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.util.Accountable;
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyBinaryDocValues.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyBinaryDocValues.java
new file mode 100644
index 0000000..211ec20
--- /dev/null
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyBinaryDocValues.java
@@ -0,0 +1,40 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.codecs.memory;
+
+
+import org.apache.lucene.index.BinaryDocValues;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * A per-document byte[]
+ *
+ * @deprecated Use {@link BinaryDocValues} instead.
+ */
+@Deprecated
+abstract class LegacyBinaryDocValues {
+  
+  /** Sole constructor. (For invocation by subclass 
+   * constructors, typically implicit.) */
+  protected LegacyBinaryDocValues() {}
+
+  /** Lookup the value for document.  The returned {@link BytesRef} may be
+   * re-used across calls to {@link #get(int)} so make sure to
+   * {@link BytesRef#deepCopyOf(BytesRef) copy it} if you want to keep it
+   * around. */
+  public abstract BytesRef get(int docID);
+}
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyBinaryDocValuesWrapper.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyBinaryDocValuesWrapper.java
new file mode 100644
index 0000000..5aeaafb
--- /dev/null
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyBinaryDocValuesWrapper.java
@@ -0,0 +1,91 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.codecs.memory;
+
+import java.io.IOException;
+
+import org.apache.lucene.index.BinaryDocValues;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * Wraps a {@link LegacyBinaryDocValues} into a {@link BinaryDocValues}.
+ *
+ * @deprecated Implement {@link BinaryDocValues} directly.
+ */
+@Deprecated
+final class LegacyBinaryDocValuesWrapper extends BinaryDocValues {
+  private final Bits docsWithField;
+  private final LegacyBinaryDocValues values;
+  private final int maxDoc;
+  private int docID = -1;
+  
+  public LegacyBinaryDocValuesWrapper(Bits docsWithField, LegacyBinaryDocValues values) {
+    this.docsWithField = docsWithField;
+    this.values = values;
+    this.maxDoc = docsWithField.length();
+  }
+
+  @Override
+  public int docID() {
+    return docID;
+  }
+
+  @Override
+  public int nextDoc() {
+    docID++;
+    while (docID < maxDoc) {
+      if (docsWithField.get(docID)) {
+        return docID;
+      }
+      docID++;
+    }
+    docID = NO_MORE_DOCS;
+    return NO_MORE_DOCS;
+  }
+
+  @Override
+  public int advance(int target) {
+    if (target < docID) {
+      throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
+    }
+    if (target == NO_MORE_DOCS) {
+      this.docID = NO_MORE_DOCS;
+    } else {
+      this.docID = target-1;
+      nextDoc();
+    }
+    return docID;
+  }
+
+  @Override
+  public boolean advanceExact(int target) throws IOException {
+    docID = target;
+    return docsWithField.get(target);
+  }
+
+  @Override
+  public long cost() {
+    return 0;
+  }
+
+  @Override
+  public BytesRef binaryValue() {
+    return values.get(docID);
+  }
+}
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyDocValuesIterables.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyDocValuesIterables.java
new file mode 100644
index 0000000..6c587da
--- /dev/null
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyDocValuesIterables.java
@@ -0,0 +1,536 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.codecs.memory;
+
+import static org.apache.lucene.index.SortedSetDocValues.NO_MORE_ORDS;
+import static org.apache.lucene.search.DocIdSetIterator.NO_MORE_DOCS;
+
+import java.io.IOException;
+import java.util.Iterator;
+
+import org.apache.lucene.codecs.DocValuesProducer;
+import org.apache.lucene.codecs.NormsProducer;
+import org.apache.lucene.index.BinaryDocValues;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.NumericDocValues;
+import org.apache.lucene.index.SortedDocValues;
+import org.apache.lucene.index.SortedNumericDocValues;
+import org.apache.lucene.index.SortedSetDocValues;
+import org.apache.lucene.util.BytesRef;
+
+/** Bridge helper methods for legacy codecs to map sorted doc values to iterables. */
+
+class LegacyDocValuesIterables {
+
+  private LegacyDocValuesIterables() {
+    // no
+  }
+
+  /** Converts {@link SortedDocValues} into an {@code Iterable&lt;BytesRef&gt;} for all the values.
+   *
+   * @deprecated Consume {@link SortedDocValues} instead. */
+  @Deprecated
+  public static Iterable<BytesRef> valuesIterable(final SortedDocValues values) {
+    return new Iterable<BytesRef>() {
+      @Override
+      public Iterator<BytesRef> iterator() {
+        return new Iterator<BytesRef>() {
+          private int nextOrd;
+    
+          @Override
+          public boolean hasNext() {
+            return nextOrd < values.getValueCount();
+          }
+
+          @Override
+          public BytesRef next() {
+            try {
+              return values.lookupOrd(nextOrd++);
+            } catch (IOException e) {
+              throw new RuntimeException(e);
+            }
+          }
+        };
+      }
+    };
+  }
+
+  /** Converts {@link SortedSetDocValues} into an {@code Iterable&lt;BytesRef&gt;} for all the values.
+   *
+   * @deprecated Consume {@link SortedSetDocValues} instead. */
+  @Deprecated
+  public static Iterable<BytesRef> valuesIterable(final SortedSetDocValues values) {
+    return new Iterable<BytesRef>() {
+      @Override
+      public Iterator<BytesRef> iterator() {
+        return new Iterator<BytesRef>() {
+          private long nextOrd;
+    
+          @Override
+          public boolean hasNext() {
+            return nextOrd < values.getValueCount();
+          }
+
+          @Override
+          public BytesRef next() {
+            try {
+              return values.lookupOrd(nextOrd++);
+            } catch (IOException e) {
+              throw new RuntimeException(e);
+            }
+          }
+        };
+      }
+    };
+  }
+
+  /** Converts {@link SortedDocValues} into the ord for each document as an {@code Iterable&lt;Number&gt;}.
+   *
+   * @deprecated Consume {@link SortedDocValues} instead. */
+  @Deprecated
+  public static Iterable<Number> sortedOrdIterable(final DocValuesProducer valuesProducer, FieldInfo fieldInfo, int maxDoc) {
+    return new Iterable<Number>() {
+      @Override
+      public Iterator<Number> iterator() {
+
+        final SortedDocValues values;
+        try {
+          values = valuesProducer.getSorted(fieldInfo);
+        } catch (IOException ioe) {
+          throw new RuntimeException(ioe);
+        }
+        
+        return new Iterator<Number>() {
+          private int nextDocID;
+    
+          @Override
+          public boolean hasNext() {
+            return nextDocID < maxDoc;
+          }
+
+          @Override
+          public Number next() {
+            try {
+              if (nextDocID > values.docID()) {
+                values.nextDoc();
+              }
+              int result;
+              if (nextDocID == values.docID()) {
+                result = values.ordValue();
+              } else {
+                result = -1;
+              }
+              nextDocID++;
+              return result;
+            } catch (IOException ioe) {
+              throw new RuntimeException(ioe);
+            }
+          }
+        };
+      }
+    };
+  }
+
+  /** Converts number-of-ords per document from {@link SortedSetDocValues} into {@code Iterable&lt;Number&gt;}.
+   *
+   * @deprecated Consume {@link SortedSetDocValues} instead. */
+  @Deprecated
+  public static Iterable<Number> sortedSetOrdCountIterable(final DocValuesProducer valuesProducer, final FieldInfo fieldInfo, final int maxDoc) {
+
+    return new Iterable<Number>() {
+
+      @Override
+      public Iterator<Number> iterator() {
+
+        final SortedSetDocValues values;
+        try {
+          values = valuesProducer.getSortedSet(fieldInfo);
+        } catch (IOException ioe) {
+          throw new RuntimeException(ioe);
+        }
+
+        return new Iterator<Number>() {
+          private int nextDocID;
+          private int ordCount;
+          
+          @Override
+          public boolean hasNext() {
+            return nextDocID < maxDoc;
+          }
+
+          @Override
+          public Number next() {
+            try {
+              if (nextDocID > values.docID()) {
+                if (values.nextDoc() != NO_MORE_DOCS) {
+                  ordCount = 0;
+                  while (values.nextOrd() != NO_MORE_ORDS) {
+                    ordCount++;
+                  }
+                }
+              }
+              int result;
+              if (nextDocID == values.docID()) {
+                result = ordCount;
+              } else {
+                result = 0;
+              }
+              nextDocID++;
+              return result;
+            } catch (IOException ioe) {
+              throw new RuntimeException(ioe);
+            }
+          }
+        };
+      }
+    };
+  }
+
+  /** Converts all concatenated ords (in docID order) from {@link SortedSetDocValues} into {@code Iterable&lt;Number&gt;}.
+   *
+   * @deprecated Consume {@link SortedSetDocValues} instead. */
+  @Deprecated
+  public static Iterable<Number> sortedSetOrdsIterable(final DocValuesProducer valuesProducer, final FieldInfo fieldInfo) {
+
+    return new Iterable<Number>() {
+
+      @Override
+      public Iterator<Number> iterator() {
+
+        final SortedSetDocValues values;
+        try {
+          values = valuesProducer.getSortedSet(fieldInfo);
+        } catch (IOException ioe) {
+          throw new RuntimeException(ioe);
+        }
+
+        return new Iterator<Number>() {
+          private boolean nextIsSet;
+          private long nextOrd;
+
+          private void setNext() {
+            try {
+              if (nextIsSet == false) {
+                if (values.docID() == -1) {
+                  values.nextDoc();
+                }
+                while (true) {
+                  if (values.docID() == NO_MORE_DOCS) {
+                    nextOrd = -1;
+                    break;
+                  }
+                  nextOrd = values.nextOrd();
+                  if (nextOrd != -1) {
+                    break;
+                  }
+                  values.nextDoc();
+                }
+                nextIsSet = true;
+              }
+            } catch (IOException ioe) {
+              throw new RuntimeException(ioe);
+            }
+          }
+          
+          @Override
+          public boolean hasNext() {
+            setNext();
+            return nextOrd != -1;
+          }
+
+          @Override
+          public Number next() {
+            setNext();
+            assert nextOrd != -1;
+            nextIsSet = false;
+            return nextOrd;
+          }
+        };
+      }
+    };
+  }
+
+  /** Converts number-of-values per document from {@link SortedNumericDocValues} into {@code Iterable&lt;Number&gt;}.
+   *
+   * @deprecated Consume {@link SortedDocValues} instead. */
+  @Deprecated
+  public static Iterable<Number> sortedNumericToDocCount(final DocValuesProducer valuesProducer, final FieldInfo fieldInfo, int maxDoc) {
+    return new Iterable<Number>() {
+
+      @Override
+      public Iterator<Number> iterator() {
+
+        final SortedNumericDocValues values;
+        try {
+          values = valuesProducer.getSortedNumeric(fieldInfo);
+        } catch (IOException ioe) {
+          throw new RuntimeException(ioe);
+        }
+
+        return new Iterator<Number>() {
+          private int nextDocID;
+
+          @Override
+          public boolean hasNext() {
+            return nextDocID < maxDoc;
+          }
+
+          @Override
+          public Number next() {
+            try {
+              if (nextDocID > values.docID()) {
+                values.nextDoc();
+              }
+              int result;
+              if (nextDocID == values.docID()) {
+                result = values.docValueCount();
+              } else {
+                result = 0;
+              }
+              nextDocID++;
+              return result;
+            } catch (IOException ioe) {
+              throw new RuntimeException(ioe);
+            }
+          }
+        };
+      }
+    };
+  }
+
+  /** Converts all concatenated values (in docID order) from {@link SortedNumericDocValues} into {@code Iterable&lt;Number&gt;}.
+   *
+   * @deprecated Consume {@link SortedDocValues} instead. */
+  @Deprecated
+  public static Iterable<Number> sortedNumericToValues(final DocValuesProducer valuesProducer, final FieldInfo fieldInfo) {
+    return new Iterable<Number>() {
+
+      @Override
+      public Iterator<Number> iterator() {
+
+        final SortedNumericDocValues values;
+        try {
+          values = valuesProducer.getSortedNumeric(fieldInfo);
+        } catch (IOException ioe) {
+          throw new RuntimeException(ioe);
+        }
+
+        return new Iterator<Number>() {
+          private boolean nextIsSet;
+          private int nextCount;
+          private int upto;
+          private long nextValue;
+
+          private void setNext() {
+            try {
+              if (nextIsSet == false) {
+                if (upto == nextCount) {
+                  values.nextDoc();
+                  if (values.docID() == NO_MORE_DOCS) {
+                    nextCount = 0;
+                    nextIsSet = false;
+                    return;
+                  } else {
+                    nextCount = values.docValueCount();
+                  }
+                  upto = 0;
+                }
+                nextValue = values.nextValue();
+                upto++;
+                nextIsSet = true;
+              }
+            } catch (IOException ioe) {
+              throw new RuntimeException(ioe);
+            }
+          }
+          
+          @Override
+          public boolean hasNext() {
+            setNext();
+            return nextCount != 0;
+          }
+
+          @Override
+          public Number next() {
+            setNext();
+            assert nextCount != 0;
+            nextIsSet = false;
+            return nextValue;
+          }
+        };
+      }
+    };
+  }
+
+  /** Converts norms into {@code Iterable&lt;Number&gt;}.
+   *
+   * @deprecated Consume {@link NumericDocValues} instead. */
+  @Deprecated
+  public static Iterable<Number> normsIterable(final FieldInfo field,
+      final NormsProducer normsProducer, final int maxDoc) {
+
+    return new Iterable<Number>() {
+
+      @Override
+      public Iterator<Number> iterator() {
+
+        final NumericDocValues values;
+        try {
+          values = normsProducer.getNorms(field);
+        } catch (IOException ioe) {
+          throw new RuntimeException(ioe);
+        }
+    
+        return new Iterator<Number>() {
+          private int docIDUpto = -1;
+
+          @Override
+          public boolean hasNext() {
+            return docIDUpto+1 < maxDoc;
+          }
+
+          @Override
+          public Number next() {
+            docIDUpto++;
+            if (docIDUpto > values.docID()) {
+              try {
+                values.nextDoc();
+              } catch (IOException ioe) {
+                throw new RuntimeException(ioe);
+              }
+            }
+            Number result;
+            if (docIDUpto == values.docID()) {
+              try {
+                result = values.longValue();
+              } catch (IOException ioe) {
+                throw new RuntimeException(ioe);
+              }
+            } else {
+              // Unlike NumericDocValues, norms used to return 0 for missing values:
+              result = 0;
+            }
+            return result;
+          }
+        };
+      }
+    };
+  }
+
+  /** Converts values from {@link BinaryDocValues} into {@code Iterable&lt;BytesRef&gt;}.
+   *
+   * @deprecated Consume {@link BinaryDocValues} instead. */
+  @Deprecated
+  public static Iterable<BytesRef> binaryIterable(final FieldInfo field, final DocValuesProducer valuesProducer, final int maxDoc) {
+    return new Iterable<BytesRef>() {
+      @Override
+      public Iterator<BytesRef> iterator() {
+
+        final BinaryDocValues values;
+        try {
+          values = valuesProducer.getBinary(field);
+        } catch (IOException ioe) {
+          throw new RuntimeException(ioe);
+        }
+
+        return new Iterator<BytesRef>() {
+          private int docIDUpto = -1;
+
+          @Override
+          public boolean hasNext() {
+            return docIDUpto+1 < maxDoc;
+          }
+
+          @Override
+          public BytesRef next() {
+            docIDUpto++;
+            if (docIDUpto > values.docID()) {
+              try {
+                values.nextDoc();
+              } catch (IOException ioe) {
+                throw new RuntimeException(ioe);
+              }
+            }
+            BytesRef result;
+            if (docIDUpto == values.docID()) {
+              try {
+                result = values.binaryValue();
+              } catch (IOException e) {
+                throw new RuntimeException(e);
+              }
+            } else {
+              result = null;
+            }
+            return result;
+          }
+        };
+      }
+    };
+  }
+
+  /** Converts values from {@link NumericDocValues} into {@code Iterable&lt;Number&gt;}.
+   *
+   * @deprecated Consume {@link NumericDocValues} instead. */
+  @Deprecated
+  public static Iterable<Number> numericIterable(final FieldInfo field, final DocValuesProducer valuesProducer, final int maxDoc) {
+    return new Iterable<Number>() {
+      @Override
+      public Iterator<Number> iterator() {
+
+        final NumericDocValues values;
+        try {
+          values = valuesProducer.getNumeric(field);
+        } catch (IOException ioe) {
+          throw new RuntimeException(ioe);
+        }
+    
+        return new Iterator<Number>() {
+          private int docIDUpto = -1;
+
+          @Override
+          public boolean hasNext() {
+            return docIDUpto+1 < maxDoc;
+          }
+
+          @Override
+          public Number next() {
+            docIDUpto++;
+            if (docIDUpto > values.docID()) {
+              try {
+                values.nextDoc();
+              } catch (IOException ioe) {
+                throw new RuntimeException(ioe);
+              }
+            }
+            Number result;
+            if (docIDUpto == values.docID()) {
+              try {
+                result = values.longValue();
+              } catch (IOException ioe) {
+                throw new RuntimeException(ioe);
+              }
+            } else {
+              result = null;
+            }
+            return result;
+          }
+        };
+      }
+    };
+  }
+}
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyNumericDocValues.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyNumericDocValues.java
new file mode 100644
index 0000000..1aa5a7d
--- /dev/null
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyNumericDocValues.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.codecs.memory;
+
+import org.apache.lucene.index.NumericDocValues;
+
+/**
+ * A per-document numeric value.
+ *
+ * @deprecated Use {@link NumericDocValues} instead.
+ */
+@Deprecated
+abstract class LegacyNumericDocValues {
+  
+  /** Sole constructor. (For invocation by subclass 
+   *  constructors, typically implicit.) */
+  protected LegacyNumericDocValues() {}
+
+  /**
+   * Returns the numeric value for the specified document ID.
+   * @param docID document ID to lookup
+   * @return numeric value
+   */
+  public abstract long get(int docID);
+}
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyNumericDocValuesWrapper.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyNumericDocValuesWrapper.java
new file mode 100644
index 0000000..7320dfc
--- /dev/null
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacyNumericDocValuesWrapper.java
@@ -0,0 +1,97 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.codecs.memory;
+
+import java.io.IOException;
+
+import org.apache.lucene.index.NumericDocValues;
+import org.apache.lucene.util.Bits;
+
+/**
+ * Wraps a {@link LegacyNumericDocValues} into a {@link NumericDocValues}.
+ *
+ * @deprecated Implement {@link NumericDocValues} directly.
+ */
+@Deprecated
+final class LegacyNumericDocValuesWrapper extends NumericDocValues {
+  private final Bits docsWithField;
+  private final LegacyNumericDocValues values;
+  private final int maxDoc;
+  private int docID = -1;
+  private long value;
+  
+  public LegacyNumericDocValuesWrapper(Bits docsWithField, LegacyNumericDocValues values) {
+    this.docsWithField = docsWithField;
+    this.values = values;
+    this.maxDoc = docsWithField.length();
+  }
+
+  @Override
+  public int docID() {
+    return docID;
+  }
+
+  @Override
+  public int nextDoc() {
+    docID++;
+    while (docID < maxDoc) {
+      value = values.get(docID);
+      if (value != 0 || docsWithField.get(docID)) {
+        return docID;
+      }
+      docID++;
+    }
+    docID = NO_MORE_DOCS;
+    return NO_MORE_DOCS;
+  }
+
+  @Override
+  public int advance(int target) {
+    assert target >= docID: "target=" + target + " docID=" + docID;
+    if (target == NO_MORE_DOCS) {
+      this.docID = NO_MORE_DOCS;
+    } else {
+      this.docID = target-1;
+      nextDoc();
+    }
+    return docID;
+  }
+
+  @Override
+  public boolean advanceExact(int target) throws IOException {
+    docID = target;
+    value = values.get(docID);
+    return value != 0 || docsWithField.get(docID);
+  }
+
+  @Override
+  public long cost() {
+    // TODO
+    return 0;
+  }
+
+  @Override
+  public long longValue() {
+    return value;
+  }
+
+  @Override
+  public String toString() {
+    return "LegacyNumericDocValuesWrapper(" + values + ")";
+  }
+}
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedDocValues.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedDocValues.java
new file mode 100644
index 0000000..20da293
--- /dev/null
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedDocValues.java
@@ -0,0 +1,112 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.codecs.memory;
+
+
+import org.apache.lucene.index.SortedDocValues;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * A per-document byte[] with presorted values.
+ * <p>
+ * Per-Document values in a SortedDocValues are deduplicated, dereferenced,
+ * and sorted into a dictionary of unique values. A pointer to the
+ * dictionary value (ordinal) can be retrieved for each document. Ordinals
+ * are dense and in increasing sorted order.
+ *
+ * @deprecated Use {@link SortedDocValues} instead.
+ */
+@Deprecated
+abstract class LegacySortedDocValues extends LegacyBinaryDocValues {
+
+  /** Sole constructor. (For invocation by subclass 
+   *  constructors, typically implicit.) */
+  protected LegacySortedDocValues() {}
+
+  /**
+   * Returns the ordinal for the specified docID.
+   * @param  docID document ID to lookup
+   * @return ordinal for the document: this is dense, starts at 0, then
+   *         increments by 1 for the next value in sorted order. Note that
+   *         missing values are indicated by -1.
+   */
+  public abstract int getOrd(int docID);
+
+  /** Retrieves the value for the specified ordinal. The returned
+   * {@link BytesRef} may be re-used across calls to {@link #lookupOrd(int)}
+   * so make sure to {@link BytesRef#deepCopyOf(BytesRef) copy it} if you want
+   * to keep it around.
+   * @param ord ordinal to lookup (must be &gt;= 0 and &lt; {@link #getValueCount()})
+   * @see #getOrd(int) 
+   */
+  public abstract BytesRef lookupOrd(int ord);
+
+  /**
+   * Returns the number of unique values.
+   * @return number of unique values in this SortedDocValues. This is
+   *         also equivalent to one plus the maximum ordinal.
+   */
+  public abstract int getValueCount();
+
+  private final BytesRef empty = new BytesRef();
+
+  @Override
+  public BytesRef get(int docID) {
+    int ord = getOrd(docID);
+    if (ord == -1) {
+      return empty;
+    } else {
+      return lookupOrd(ord);
+    }
+  }
+
+  /** If {@code key} exists, returns its ordinal, else
+   *  returns {@code -insertionPoint-1}, like {@code
+   *  Arrays.binarySearch}.
+   *
+   *  @param key Key to look up
+   **/
+  public int lookupTerm(BytesRef key) {
+    int low = 0;
+    int high = getValueCount()-1;
+
+    while (low <= high) {
+      int mid = (low + high) >>> 1;
+      final BytesRef term = lookupOrd(mid);
+      int cmp = term.compareTo(key);
+
+      if (cmp < 0) {
+        low = mid + 1;
+      } else if (cmp > 0) {
+        high = mid - 1;
+      } else {
+        return mid; // key found
+      }
+    }
+
+    return -(low + 1);  // key not found.
+  }
+  
+  /** 
+   * Returns a {@link TermsEnum} over the values.
+   * The enum supports {@link TermsEnum#ord()} and {@link TermsEnum#seekExact(long)}.
+   */
+  public TermsEnum termsEnum() {
+    throw new UnsupportedOperationException();
+  }
+}
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedDocValuesWrapper.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedDocValuesWrapper.java
new file mode 100644
index 0000000..250ea5f
--- /dev/null
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedDocValuesWrapper.java
@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.codecs.memory;
+
+import java.io.IOException;
+
+import org.apache.lucene.index.SortedDocValues;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * Wraps a {@link LegacySortedDocValues} into a {@link SortedDocValues}.
+ *
+ * @deprecated Implement {@link SortedDocValues} directly.
+ */
+@Deprecated
+final class LegacySortedDocValuesWrapper extends SortedDocValues {
+  private final LegacySortedDocValues values;
+  private final int maxDoc;
+  private int docID = -1;
+  private int ord;
+  
+  public LegacySortedDocValuesWrapper(LegacySortedDocValues values, int maxDoc) {
+    this.values = values;
+    this.maxDoc = maxDoc;
+  }
+
+  @Override
+  public int docID() {
+    return docID;
+  }
+
+  @Override
+  public int nextDoc() {
+    assert docID != NO_MORE_DOCS;
+    docID++;
+    while (docID < maxDoc) {
+      ord = values.getOrd(docID);
+      if (ord != -1) {
+        return docID;
+      }
+      docID++;
+    }
+    docID = NO_MORE_DOCS;
+    return NO_MORE_DOCS;
+  }
+
+  @Override
+  public int advance(int target) {
+    if (target < docID) {
+      throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
+    }
+    if (target >= maxDoc) {
+      this.docID = NO_MORE_DOCS;
+    } else {
+      this.docID = target-1;
+      nextDoc();
+    }
+    return docID;
+  }
+
+  @Override
+  public boolean advanceExact(int target) throws IOException {
+    docID = target;
+    ord = values.getOrd(docID);
+    return ord != -1;
+  }
+
+  @Override
+  public long cost() {
+    return 0;
+  }
+
+  @Override
+  public int ordValue() {
+    return ord;
+  }
+
+  @Override
+  public BytesRef lookupOrd(int ord) {
+    return values.lookupOrd(ord);
+  }
+
+  @Override
+  public int getValueCount() {
+    return values.getValueCount();
+  }
+}
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedNumericDocValues.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedNumericDocValues.java
new file mode 100644
index 0000000..c45eeee
--- /dev/null
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedNumericDocValues.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.codecs.memory;
+
+import org.apache.lucene.index.SortedNumericDocValues;
+
+/**
+ * A list of per-document numeric values, sorted 
+ * according to {@link Long#compare(long, long)}.
+ *
+ * @deprecated Use {@link SortedNumericDocValues} instead.
+ */
+@Deprecated
+abstract class LegacySortedNumericDocValues {
+  
+  /** Sole constructor. (For invocation by subclass 
+   *  constructors, typically implicit.) */
+  protected LegacySortedNumericDocValues() {}
+
+  /** 
+   * Positions to the specified document 
+   */
+  public abstract void setDocument(int doc);
+  
+  /** 
+   * Retrieve the value for the current document at the specified index. 
+   * An index ranges from {@code 0} to {@code count()-1}. 
+   */
+  public abstract long valueAt(int index);
+  
+  /** 
+   * Retrieves the count of values for the current document. 
+   * This may be zero if a document has no values.
+   */
+  public abstract int count();
+}
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedNumericDocValuesWrapper.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedNumericDocValuesWrapper.java
new file mode 100644
index 0000000..83d3a74
--- /dev/null
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedNumericDocValuesWrapper.java
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.codecs.memory;
+
+import java.io.IOException;
+
+import org.apache.lucene.index.SortedNumericDocValues;
+
+/**
+ * Wraps a {@link LegacySortedNumericDocValues} into a {@link SortedNumericDocValues}.
+ *
+ * @deprecated Implement {@link SortedNumericDocValues} directly.
+ */
+@Deprecated
+final class LegacySortedNumericDocValuesWrapper extends SortedNumericDocValues {
+  private final LegacySortedNumericDocValues values;
+  private final int maxDoc;
+  private int docID = -1;
+  private int upto;
+  
+  public LegacySortedNumericDocValuesWrapper(LegacySortedNumericDocValues values, int maxDoc) {
+    this.values = values;
+    this.maxDoc = maxDoc;
+  }
+
+  @Override
+  public int docID() {
+    return docID;
+  }
+
+  @Override
+  public int nextDoc() {
+    assert docID != NO_MORE_DOCS;
+    while (true) {
+      docID++;
+      if (docID == maxDoc) {
+        docID = NO_MORE_DOCS;
+        break;
+      }
+      values.setDocument(docID);
+      if (values.count() != 0) {
+        break;
+      }
+    }
+    upto = 0;
+    return docID;
+  }
+
+  @Override
+  public int advance(int target) {
+    if (target < docID) {
+      throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
+    }
+    if (target >= maxDoc) {
+      docID = NO_MORE_DOCS;
+    } else {
+      docID = target-1;
+      nextDoc();
+    }
+    return docID;
+  }
+
+  @Override
+  public boolean advanceExact(int target) throws IOException {
+    docID = target;
+    values.setDocument(docID);
+    upto = 0;
+    return values.count() != 0;
+  }
+
+  @Override
+  public long cost() {
+    return 0;
+  }
+
+  @Override
+  public long nextValue() {
+    return values.valueAt(upto++);
+  }
+
+  @Override
+  public int docValueCount() {
+    return values.count();
+  }
+}
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedSetDocValues.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedSetDocValues.java
new file mode 100644
index 0000000..0d00743
--- /dev/null
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedSetDocValues.java
@@ -0,0 +1,113 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.codecs.memory;
+
+
+import java.io.IOException;
+
+import org.apache.lucene.index.SortedSetDocValues;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * A per-document set of presorted byte[] values.
+ * <p>
+ * Per-Document values in a SortedDocValues are deduplicated, dereferenced,
+ * and sorted into a dictionary of unique values. A pointer to the
+ * dictionary value (ordinal) can be retrieved for each document. Ordinals
+ * are dense and in increasing sorted order.
+ *
+ * @deprecated Use {@link SortedSetDocValues} instead.
+ */
+@Deprecated
+abstract class LegacySortedSetDocValues {
+  
+  /** Sole constructor. (For invocation by subclass 
+   * constructors, typically implicit.) */
+  protected LegacySortedSetDocValues() {}
+
+  /** When returned by {@link #nextOrd()} it means there are no more 
+   *  ordinals for the document.
+   */
+  public static final long NO_MORE_ORDS = -1;
+
+  /** 
+   * Returns the next ordinal for the current document (previously
+   * set by {@link #setDocument(int)}.
+   * @return next ordinal for the document, or {@link #NO_MORE_ORDS}. 
+   *         ordinals are dense, start at 0, then increment by 1 for 
+   *         the next value in sorted order. 
+   */
+  public abstract long nextOrd();
+  
+  /** 
+   * Sets iteration to the specified docID 
+   * @param docID document ID 
+   */
+  public abstract void setDocument(int docID);
+
+  /** Retrieves the value for the specified ordinal. The returned
+   * {@link BytesRef} may be re-used across calls to lookupOrd so make sure to
+   * {@link BytesRef#deepCopyOf(BytesRef) copy it} if you want to keep it
+   * around.
+   * @param ord ordinal to lookup
+   * @see #nextOrd
+   */
+  public abstract BytesRef lookupOrd(long ord);
+
+  /**
+   * Returns the number of unique values.
+   * @return number of unique values in this SortedDocValues. This is
+   *         also equivalent to one plus the maximum ordinal.
+   */
+  public abstract long getValueCount();
+
+  /** If {@code key} exists, returns its ordinal, else
+   *  returns {@code -insertionPoint-1}, like {@code
+   *  Arrays.binarySearch}.
+   *
+   *  @param key Key to look up
+   **/
+  public long lookupTerm(BytesRef key) {
+    long low = 0;
+    long high = getValueCount()-1;
+
+    while (low <= high) {
+      long mid = (low + high) >>> 1;
+      final BytesRef term = lookupOrd(mid);
+      int cmp = term.compareTo(key);
+
+      if (cmp < 0) {
+        low = mid + 1;
+      } else if (cmp > 0) {
+        high = mid - 1;
+      } else {
+        return mid; // key found
+      }
+    }
+
+    return -(low + 1);  // key not found.
+  }
+  
+  /** 
+   * Returns a {@link TermsEnum} over the values.
+   * The enum supports {@link TermsEnum#ord()} and {@link TermsEnum#seekExact(long)}.
+   */
+  public TermsEnum termsEnum() throws IOException {
+    throw new UnsupportedOperationException();
+  }
+}
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedSetDocValuesWrapper.java b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedSetDocValuesWrapper.java
new file mode 100644
index 0000000..10b2290
--- /dev/null
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/memory/LegacySortedSetDocValuesWrapper.java
@@ -0,0 +1,113 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.codecs.memory;
+
+import java.io.IOException;
+
+import org.apache.lucene.index.SortedSetDocValues;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * Wraps a {@link LegacySortedSetDocValues} into a {@link SortedSetDocValues}.
+ *
+ * @deprecated Implement {@link SortedSetDocValues} directly.
+ */
+@Deprecated
+public final class LegacySortedSetDocValuesWrapper extends SortedSetDocValues {
+  private final LegacySortedSetDocValues values;
+  private final int maxDoc;
+  private int docID = -1;
+  private long ord;
+  
+  public LegacySortedSetDocValuesWrapper(LegacySortedSetDocValues values, int maxDoc) {
+    this.values = values;
+    this.maxDoc = maxDoc;
+  }
+
+  @Override
+  public int docID() {
+    return docID;
+  }
+
+  @Override
+  public int nextDoc() {
+    assert docID != NO_MORE_DOCS;
+    docID++;
+    while (docID < maxDoc) {
+      values.setDocument(docID);
+      ord = values.nextOrd();
+      if (ord != NO_MORE_ORDS) {
+        return docID;
+      }
+      docID++;
+    }
+    docID = NO_MORE_DOCS;
+    return NO_MORE_DOCS;
+  }
+
+  @Override
+  public int advance(int target) {
+    if (target < docID) {
+      throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
+    }
+    if (target >= maxDoc) {
+      this.docID = NO_MORE_DOCS;
+    } else {
+      this.docID = target-1;
+      nextDoc();
+    }
+    return docID;
+  }
+
+  @Override
+  public boolean advanceExact(int target) throws IOException {
+    docID = target;
+    values.setDocument(docID);
+    ord = values.nextOrd();
+    return ord != NO_MORE_ORDS;
+  }
+
+  @Override
+  public long cost() {
+    return 0;
+  }
+
+  @Override
+  public long nextOrd() {
+    long result = ord;
+    if (result != NO_MORE_ORDS) {
+      ord = values.nextOrd();
+    }
+    return result;
+  }
+
+  @Override
+  public BytesRef lookupOrd(long ord) {
+    return values.lookupOrd((int) ord);
+  }
+
+  @Override
+  public long getValueCount() {
+    return values.getValueCount();
+  }
+
+  @Override
+  public String toString() {
+    return "LegacySortedSetDocValuesWrapper(" + values + ")";
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/LegacyDocValuesIterables.java b/lucene/core/src/java/org/apache/lucene/codecs/LegacyDocValuesIterables.java
deleted file mode 100644
index 717bbab..0000000
--- a/lucene/core/src/java/org/apache/lucene/codecs/LegacyDocValuesIterables.java
+++ /dev/null
@@ -1,534 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.codecs;
-
-import java.io.IOException;
-import java.util.Iterator;
-
-import org.apache.lucene.index.BinaryDocValues;
-import org.apache.lucene.index.FieldInfo;
-import org.apache.lucene.index.NumericDocValues;
-import org.apache.lucene.index.SortedDocValues;
-import org.apache.lucene.index.SortedNumericDocValues;
-import org.apache.lucene.index.SortedSetDocValues;
-import org.apache.lucene.util.BytesRef;
-
-import static org.apache.lucene.index.SortedSetDocValues.NO_MORE_ORDS;
-import static org.apache.lucene.search.DocIdSetIterator.NO_MORE_DOCS;
-
-/** Bridge helper methods for legacy codecs to map sorted doc values to iterables. */
-
-public class LegacyDocValuesIterables {
-
-  private LegacyDocValuesIterables() {
-    // no
-  }
-
-  /** Converts {@link SortedDocValues} into an {@code Iterable&lt;BytesRef&gt;} for all the values.
-   *
-   * @deprecated Consume {@link SortedDocValues} instead. */
-  @Deprecated
-  public static Iterable<BytesRef> valuesIterable(final SortedDocValues values) {
-    return new Iterable<BytesRef>() {
-      @Override
-      public Iterator<BytesRef> iterator() {
-        return new Iterator<BytesRef>() {
-          private int nextOrd;
-    
-          @Override
-          public boolean hasNext() {
-            return nextOrd < values.getValueCount();
-          }
-
-          @Override
-          public BytesRef next() {
-            try {
-              return values.lookupOrd(nextOrd++);
-            } catch (IOException e) {
-              throw new RuntimeException(e);
-            }
-          }
-        };
-      }
-    };
-  }
-
-  /** Converts {@link SortedSetDocValues} into an {@code Iterable&lt;BytesRef&gt;} for all the values.
-   *
-   * @deprecated Consume {@link SortedSetDocValues} instead. */
-  @Deprecated
-  public static Iterable<BytesRef> valuesIterable(final SortedSetDocValues values) {
-    return new Iterable<BytesRef>() {
-      @Override
-      public Iterator<BytesRef> iterator() {
-        return new Iterator<BytesRef>() {
-          private long nextOrd;
-    
-          @Override
-          public boolean hasNext() {
-            return nextOrd < values.getValueCount();
-          }
-
-          @Override
-          public BytesRef next() {
-            try {
-              return values.lookupOrd(nextOrd++);
-            } catch (IOException e) {
-              throw new RuntimeException(e);
-            }
-          }
-        };
-      }
-    };
-  }
-
-  /** Converts {@link SortedDocValues} into the ord for each document as an {@code Iterable&lt;Number&gt;}.
-   *
-   * @deprecated Consume {@link SortedDocValues} instead. */
-  @Deprecated
-  public static Iterable<Number> sortedOrdIterable(final DocValuesProducer valuesProducer, FieldInfo fieldInfo, int maxDoc) {
-    return new Iterable<Number>() {
-      @Override
-      public Iterator<Number> iterator() {
-
-        final SortedDocValues values;
-        try {
-          values = valuesProducer.getSorted(fieldInfo);
-        } catch (IOException ioe) {
-          throw new RuntimeException(ioe);
-        }
-        
-        return new Iterator<Number>() {
-          private int nextDocID;
-    
-          @Override
-          public boolean hasNext() {
-            return nextDocID < maxDoc;
-          }
-
-          @Override
-          public Number next() {
-            try {
-              if (nextDocID > values.docID()) {
-                values.nextDoc();
-              }
-              int result;
-              if (nextDocID == values.docID()) {
-                result = values.ordValue();
-              } else {
-                result = -1;
-              }
-              nextDocID++;
-              return result;
-            } catch (IOException ioe) {
-              throw new RuntimeException(ioe);
-            }
-          }
-        };
-      }
-    };
-  }
-
-  /** Converts number-of-ords per document from {@link SortedSetDocValues} into {@code Iterable&lt;Number&gt;}.
-   *
-   * @deprecated Consume {@link SortedSetDocValues} instead. */
-  @Deprecated
-  public static Iterable<Number> sortedSetOrdCountIterable(final DocValuesProducer valuesProducer, final FieldInfo fieldInfo, final int maxDoc) {
-
-    return new Iterable<Number>() {
-
-      @Override
-      public Iterator<Number> iterator() {
-
-        final SortedSetDocValues values;
-        try {
-          values = valuesProducer.getSortedSet(fieldInfo);
-        } catch (IOException ioe) {
-          throw new RuntimeException(ioe);
-        }
-
-        return new Iterator<Number>() {
-          private int nextDocID;
-          private int ordCount;
-          
-          @Override
-          public boolean hasNext() {
-            return nextDocID < maxDoc;
-          }
-
-          @Override
-          public Number next() {
-            try {
-              if (nextDocID > values.docID()) {
-                if (values.nextDoc() != NO_MORE_DOCS) {
-                  ordCount = 0;
-                  while (values.nextOrd() != NO_MORE_ORDS) {
-                    ordCount++;
-                  }
-                }
-              }
-              int result;
-              if (nextDocID == values.docID()) {
-                result = ordCount;
-              } else {
-                result = 0;
-              }
-              nextDocID++;
-              return result;
-            } catch (IOException ioe) {
-              throw new RuntimeException(ioe);
-            }
-          }
-        };
-      }
-    };
-  }
-
-  /** Converts all concatenated ords (in docID order) from {@link SortedSetDocValues} into {@code Iterable&lt;Number&gt;}.
-   *
-   * @deprecated Consume {@link SortedSetDocValues} instead. */
-  @Deprecated
-  public static Iterable<Number> sortedSetOrdsIterable(final DocValuesProducer valuesProducer, final FieldInfo fieldInfo) {
-
-    return new Iterable<Number>() {
-
-      @Override
-      public Iterator<Number> iterator() {
-
-        final SortedSetDocValues values;
-        try {
-          values = valuesProducer.getSortedSet(fieldInfo);
-        } catch (IOException ioe) {
-          throw new RuntimeException(ioe);
-        }
-
-        return new Iterator<Number>() {
-          private boolean nextIsSet;
-          private long nextOrd;
-
-          private void setNext() {
-            try {
-              if (nextIsSet == false) {
-                if (values.docID() == -1) {
-                  values.nextDoc();
-                }
-                while (true) {
-                  if (values.docID() == NO_MORE_DOCS) {
-                    nextOrd = -1;
-                    break;
-                  }
-                  nextOrd = values.nextOrd();
-                  if (nextOrd != -1) {
-                    break;
-                  }
-                  values.nextDoc();
-                }
-                nextIsSet = true;
-              }
-            } catch (IOException ioe) {
-              throw new RuntimeException(ioe);
-            }
-          }
-          
-          @Override
-          public boolean hasNext() {
-            setNext();
-            return nextOrd != -1;
-          }
-
-          @Override
-          public Number next() {
-            setNext();
-            assert nextOrd != -1;
-            nextIsSet = false;
-            return nextOrd;
-          }
-        };
-      }
-    };
-  }
-
-  /** Converts number-of-values per document from {@link SortedNumericDocValues} into {@code Iterable&lt;Number&gt;}.
-   *
-   * @deprecated Consume {@link SortedDocValues} instead. */
-  @Deprecated
-  public static Iterable<Number> sortedNumericToDocCount(final DocValuesProducer valuesProducer, final FieldInfo fieldInfo, int maxDoc) {
-    return new Iterable<Number>() {
-
-      @Override
-      public Iterator<Number> iterator() {
-
-        final SortedNumericDocValues values;
-        try {
-          values = valuesProducer.getSortedNumeric(fieldInfo);
-        } catch (IOException ioe) {
-          throw new RuntimeException(ioe);
-        }
-
-        return new Iterator<Number>() {
-          private int nextDocID;
-
-          @Override
-          public boolean hasNext() {
-            return nextDocID < maxDoc;
-          }
-
-          @Override
-          public Number next() {
-            try {
-              if (nextDocID > values.docID()) {
-                values.nextDoc();
-              }
-              int result;
-              if (nextDocID == values.docID()) {
-                result = values.docValueCount();
-              } else {
-                result = 0;
-              }
-              nextDocID++;
-              return result;
-            } catch (IOException ioe) {
-              throw new RuntimeException(ioe);
-            }
-          }
-        };
-      }
-    };
-  }
-
-  /** Converts all concatenated values (in docID order) from {@link SortedNumericDocValues} into {@code Iterable&lt;Number&gt;}.
-   *
-   * @deprecated Consume {@link SortedDocValues} instead. */
-  @Deprecated
-  public static Iterable<Number> sortedNumericToValues(final DocValuesProducer valuesProducer, final FieldInfo fieldInfo) {
-    return new Iterable<Number>() {
-
-      @Override
-      public Iterator<Number> iterator() {
-
-        final SortedNumericDocValues values;
-        try {
-          values = valuesProducer.getSortedNumeric(fieldInfo);
-        } catch (IOException ioe) {
-          throw new RuntimeException(ioe);
-        }
-
-        return new Iterator<Number>() {
-          private boolean nextIsSet;
-          private int nextCount;
-          private int upto;
-          private long nextValue;
-
-          private void setNext() {
-            try {
-              if (nextIsSet == false) {
-                if (upto == nextCount) {
-                  values.nextDoc();
-                  if (values.docID() == NO_MORE_DOCS) {
-                    nextCount = 0;
-                    nextIsSet = false;
-                    return;
-                  } else {
-                    nextCount = values.docValueCount();
-                  }
-                  upto = 0;
-                }
-                nextValue = values.nextValue();
-                upto++;
-                nextIsSet = true;
-              }
-            } catch (IOException ioe) {
-              throw new RuntimeException(ioe);
-            }
-          }
-          
-          @Override
-          public boolean hasNext() {
-            setNext();
-            return nextCount != 0;
-          }
-
-          @Override
-          public Number next() {
-            setNext();
-            assert nextCount != 0;
-            nextIsSet = false;
-            return nextValue;
-          }
-        };
-      }
-    };
-  }
-
-  /** Converts norms into {@code Iterable&lt;Number&gt;}.
-   *
-   * @deprecated Consume {@link NumericDocValues} instead. */
-  @Deprecated
-  public static Iterable<Number> normsIterable(final FieldInfo field,
-      final NormsProducer normsProducer, final int maxDoc) {
-
-    return new Iterable<Number>() {
-
-      @Override
-      public Iterator<Number> iterator() {
-
-        final NumericDocValues values;
-        try {
-          values = normsProducer.getNorms(field);
-        } catch (IOException ioe) {
-          throw new RuntimeException(ioe);
-        }
-    
-        return new Iterator<Number>() {
-          private int docIDUpto = -1;
-
-          @Override
-          public boolean hasNext() {
-            return docIDUpto+1 < maxDoc;
-          }
-
-          @Override
-          public Number next() {
-            docIDUpto++;
-            if (docIDUpto > values.docID()) {
-              try {
-                values.nextDoc();
-              } catch (IOException ioe) {
-                throw new RuntimeException(ioe);
-              }
-            }
-            Number result;
-            if (docIDUpto == values.docID()) {
-              try {
-                result = values.longValue();
-              } catch (IOException ioe) {
-                throw new RuntimeException(ioe);
-              }
-            } else {
-              // Unlike NumericDocValues, norms used to return 0 for missing values:
-              result = 0;
-            }
-            return result;
-          }
-        };
-      }
-    };
-  }
-
-  /** Converts values from {@link BinaryDocValues} into {@code Iterable&lt;BytesRef&gt;}.
-   *
-   * @deprecated Consume {@link BinaryDocValues} instead. */
-  @Deprecated
-  public static Iterable<BytesRef> binaryIterable(final FieldInfo field, final DocValuesProducer valuesProducer, final int maxDoc) {
-    return new Iterable<BytesRef>() {
-      @Override
-      public Iterator<BytesRef> iterator() {
-
-        final BinaryDocValues values;
-        try {
-          values = valuesProducer.getBinary(field);
-        } catch (IOException ioe) {
-          throw new RuntimeException(ioe);
-        }
-
-        return new Iterator<BytesRef>() {
-          private int docIDUpto = -1;
-
-          @Override
-          public boolean hasNext() {
-            return docIDUpto+1 < maxDoc;
-          }
-
-          @Override
-          public BytesRef next() {
-            docIDUpto++;
-            if (docIDUpto > values.docID()) {
-              try {
-                values.nextDoc();
-              } catch (IOException ioe) {
-                throw new RuntimeException(ioe);
-              }
-            }
-            BytesRef result;
-            if (docIDUpto == values.docID()) {
-              try {
-                result = values.binaryValue();
-              } catch (IOException e) {
-                throw new RuntimeException(e);
-              }
-            } else {
-              result = null;
-            }
-            return result;
-          }
-        };
-      }
-    };
-  }
-
-  /** Converts values from {@link NumericDocValues} into {@code Iterable&lt;Number&gt;}.
-   *
-   * @deprecated Consume {@link NumericDocValues} instead. */
-  @Deprecated
-  public static Iterable<Number> numericIterable(final FieldInfo field, final DocValuesProducer valuesProducer, final int maxDoc) {
-    return new Iterable<Number>() {
-      @Override
-      public Iterator<Number> iterator() {
-
-        final NumericDocValues values;
-        try {
-          values = valuesProducer.getNumeric(field);
-        } catch (IOException ioe) {
-          throw new RuntimeException(ioe);
-        }
-    
-        return new Iterator<Number>() {
-          private int docIDUpto = -1;
-
-          @Override
-          public boolean hasNext() {
-            return docIDUpto+1 < maxDoc;
-          }
-
-          @Override
-          public Number next() {
-            docIDUpto++;
-            if (docIDUpto > values.docID()) {
-              try {
-                values.nextDoc();
-              } catch (IOException ioe) {
-                throw new RuntimeException(ioe);
-              }
-            }
-            Number result;
-            if (docIDUpto == values.docID()) {
-              try {
-                result = values.longValue();
-              } catch (IOException ioe) {
-                throw new RuntimeException(ioe);
-              }
-            } else {
-              result = null;
-            }
-            return result;
-          }
-        };
-      }
-    };
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/index/DocValues.java b/lucene/core/src/java/org/apache/lucene/index/DocValues.java
index 598c097..63488d0 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DocValues.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DocValues.java
@@ -113,29 +113,6 @@ public final class DocValues {
   }
 
   /** 
-   * An empty SortedDocValues which returns {@link BytesRef#EMPTY_BYTES} for every document 
-   */
-  public static final LegacySortedDocValues emptyLegacySorted() {
-    final BytesRef empty = new BytesRef();
-    return new LegacySortedDocValues() {
-      @Override
-      public int getOrd(int docID) {
-        return -1;
-      }
-
-      @Override
-      public BytesRef lookupOrd(int ord) {
-        return empty;
-      }
-
-      @Override
-      public int getValueCount() {
-        return 0;
-      }
-    };
-  }
-
-  /** 
    * An empty SortedDocValues which returns {@link BytesRef#EMPTY_BYTES} for every document
    */
   public static final SortedDocValues emptySorted() {
diff --git a/lucene/core/src/java/org/apache/lucene/index/LegacyBinaryDocValues.java b/lucene/core/src/java/org/apache/lucene/index/LegacyBinaryDocValues.java
deleted file mode 100644
index 7aeff7f..0000000
--- a/lucene/core/src/java/org/apache/lucene/index/LegacyBinaryDocValues.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.index;
-
-
-import org.apache.lucene.util.BytesRef;
-
-/**
- * A per-document byte[]
- *
- * @deprecated Use {@link BinaryDocValues} instead.
- */
-@Deprecated
-public abstract class LegacyBinaryDocValues {
-  
-  /** Sole constructor. (For invocation by subclass 
-   * constructors, typically implicit.) */
-  protected LegacyBinaryDocValues() {}
-
-  /** Lookup the value for document.  The returned {@link BytesRef} may be
-   * re-used across calls to {@link #get(int)} so make sure to
-   * {@link BytesRef#deepCopyOf(BytesRef) copy it} if you want to keep it
-   * around. */
-  public abstract BytesRef get(int docID);
-}
diff --git a/lucene/core/src/java/org/apache/lucene/index/LegacyBinaryDocValuesWrapper.java b/lucene/core/src/java/org/apache/lucene/index/LegacyBinaryDocValuesWrapper.java
deleted file mode 100644
index 919b1ff..0000000
--- a/lucene/core/src/java/org/apache/lucene/index/LegacyBinaryDocValuesWrapper.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.index;
-
-import java.io.IOException;
-
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.BytesRef;
-
-/**
- * Wraps a {@link LegacyBinaryDocValues} into a {@link BinaryDocValues}.
- *
- * @deprecated Implement {@link BinaryDocValues} directly.
- */
-@Deprecated
-public final class LegacyBinaryDocValuesWrapper extends BinaryDocValues {
-  private final Bits docsWithField;
-  private final LegacyBinaryDocValues values;
-  private final int maxDoc;
-  private int docID = -1;
-  
-  public LegacyBinaryDocValuesWrapper(Bits docsWithField, LegacyBinaryDocValues values) {
-    this.docsWithField = docsWithField;
-    this.values = values;
-    this.maxDoc = docsWithField.length();
-  }
-
-  @Override
-  public int docID() {
-    return docID;
-  }
-
-  @Override
-  public int nextDoc() {
-    docID++;
-    while (docID < maxDoc) {
-      if (docsWithField.get(docID)) {
-        return docID;
-      }
-      docID++;
-    }
-    docID = NO_MORE_DOCS;
-    return NO_MORE_DOCS;
-  }
-
-  @Override
-  public int advance(int target) {
-    if (target < docID) {
-      throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
-    }
-    if (target == NO_MORE_DOCS) {
-      this.docID = NO_MORE_DOCS;
-    } else {
-      this.docID = target-1;
-      nextDoc();
-    }
-    return docID;
-  }
-
-  @Override
-  public boolean advanceExact(int target) throws IOException {
-    docID = target;
-    return docsWithField.get(target);
-  }
-
-  @Override
-  public long cost() {
-    return 0;
-  }
-
-  @Override
-  public BytesRef binaryValue() {
-    return values.get(docID);
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/index/LegacyNumericDocValues.java b/lucene/core/src/java/org/apache/lucene/index/LegacyNumericDocValues.java
deleted file mode 100644
index df71435..0000000
--- a/lucene/core/src/java/org/apache/lucene/index/LegacyNumericDocValues.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.index;
-
-
-/**
- * A per-document numeric value.
- *
- * @deprecated Use {@link NumericDocValues} instead.
- */
-@Deprecated
-public abstract class LegacyNumericDocValues {
-  
-  /** Sole constructor. (For invocation by subclass 
-   *  constructors, typically implicit.) */
-  protected LegacyNumericDocValues() {}
-
-  /**
-   * Returns the numeric value for the specified document ID.
-   * @param docID document ID to lookup
-   * @return numeric value
-   */
-  public abstract long get(int docID);
-}
diff --git a/lucene/core/src/java/org/apache/lucene/index/LegacyNumericDocValuesWrapper.java b/lucene/core/src/java/org/apache/lucene/index/LegacyNumericDocValuesWrapper.java
deleted file mode 100644
index aaccc05..0000000
--- a/lucene/core/src/java/org/apache/lucene/index/LegacyNumericDocValuesWrapper.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.index;
-
-import java.io.IOException;
-
-import org.apache.lucene.util.Bits;
-
-/**
- * Wraps a {@link LegacyNumericDocValues} into a {@link NumericDocValues}.
- *
- * @deprecated Implement {@link NumericDocValues} directly.
- */
-@Deprecated
-public final class LegacyNumericDocValuesWrapper extends NumericDocValues {
-  private final Bits docsWithField;
-  private final LegacyNumericDocValues values;
-  private final int maxDoc;
-  private int docID = -1;
-  private long value;
-  
-  public LegacyNumericDocValuesWrapper(Bits docsWithField, LegacyNumericDocValues values) {
-    this.docsWithField = docsWithField;
-    this.values = values;
-    this.maxDoc = docsWithField.length();
-  }
-
-  @Override
-  public int docID() {
-    return docID;
-  }
-
-  @Override
-  public int nextDoc() {
-    docID++;
-    while (docID < maxDoc) {
-      value = values.get(docID);
-      if (value != 0 || docsWithField.get(docID)) {
-        return docID;
-      }
-      docID++;
-    }
-    docID = NO_MORE_DOCS;
-    return NO_MORE_DOCS;
-  }
-
-  @Override
-  public int advance(int target) {
-    assert target >= docID: "target=" + target + " docID=" + docID;
-    if (target == NO_MORE_DOCS) {
-      this.docID = NO_MORE_DOCS;
-    } else {
-      this.docID = target-1;
-      nextDoc();
-    }
-    return docID;
-  }
-
-  @Override
-  public boolean advanceExact(int target) throws IOException {
-    docID = target;
-    value = values.get(docID);
-    return value != 0 || docsWithField.get(docID);
-  }
-
-  @Override
-  public long cost() {
-    // TODO
-    return 0;
-  }
-
-  @Override
-  public long longValue() {
-    return value;
-  }
-
-  @Override
-  public String toString() {
-    return "LegacyNumericDocValuesWrapper(" + values + ")";
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/index/LegacySortedDocValues.java b/lucene/core/src/java/org/apache/lucene/index/LegacySortedDocValues.java
deleted file mode 100644
index 089040f..0000000
--- a/lucene/core/src/java/org/apache/lucene/index/LegacySortedDocValues.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.index;
-
-
-import org.apache.lucene.util.BytesRef;
-
-/**
- * A per-document byte[] with presorted values.
- * <p>
- * Per-Document values in a SortedDocValues are deduplicated, dereferenced,
- * and sorted into a dictionary of unique values. A pointer to the
- * dictionary value (ordinal) can be retrieved for each document. Ordinals
- * are dense and in increasing sorted order.
- *
- * @deprecated Use {@link SortedDocValues} instead.
- */
-@Deprecated
-public abstract class LegacySortedDocValues extends LegacyBinaryDocValues {
-
-  /** Sole constructor. (For invocation by subclass 
-   *  constructors, typically implicit.) */
-  protected LegacySortedDocValues() {}
-
-  /**
-   * Returns the ordinal for the specified docID.
-   * @param  docID document ID to lookup
-   * @return ordinal for the document: this is dense, starts at 0, then
-   *         increments by 1 for the next value in sorted order. Note that
-   *         missing values are indicated by -1.
-   */
-  public abstract int getOrd(int docID);
-
-  /** Retrieves the value for the specified ordinal. The returned
-   * {@link BytesRef} may be re-used across calls to {@link #lookupOrd(int)}
-   * so make sure to {@link BytesRef#deepCopyOf(BytesRef) copy it} if you want
-   * to keep it around.
-   * @param ord ordinal to lookup (must be &gt;= 0 and &lt; {@link #getValueCount()})
-   * @see #getOrd(int) 
-   */
-  public abstract BytesRef lookupOrd(int ord);
-
-  /**
-   * Returns the number of unique values.
-   * @return number of unique values in this SortedDocValues. This is
-   *         also equivalent to one plus the maximum ordinal.
-   */
-  public abstract int getValueCount();
-
-  private final BytesRef empty = new BytesRef();
-
-  @Override
-  public BytesRef get(int docID) {
-    int ord = getOrd(docID);
-    if (ord == -1) {
-      return empty;
-    } else {
-      return lookupOrd(ord);
-    }
-  }
-
-  /** If {@code key} exists, returns its ordinal, else
-   *  returns {@code -insertionPoint-1}, like {@code
-   *  Arrays.binarySearch}.
-   *
-   *  @param key Key to look up
-   **/
-  public int lookupTerm(BytesRef key) {
-    int low = 0;
-    int high = getValueCount()-1;
-
-    while (low <= high) {
-      int mid = (low + high) >>> 1;
-      final BytesRef term = lookupOrd(mid);
-      int cmp = term.compareTo(key);
-
-      if (cmp < 0) {
-        low = mid + 1;
-      } else if (cmp > 0) {
-        high = mid - 1;
-      } else {
-        return mid; // key found
-      }
-    }
-
-    return -(low + 1);  // key not found.
-  }
-  
-  /** 
-   * Returns a {@link TermsEnum} over the values.
-   * The enum supports {@link TermsEnum#ord()} and {@link TermsEnum#seekExact(long)}.
-   */
-  public TermsEnum termsEnum() {
-    throw new UnsupportedOperationException();
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/index/LegacySortedDocValuesWrapper.java b/lucene/core/src/java/org/apache/lucene/index/LegacySortedDocValuesWrapper.java
deleted file mode 100644
index ecc114b..0000000
--- a/lucene/core/src/java/org/apache/lucene/index/LegacySortedDocValuesWrapper.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.index;
-
-import java.io.IOException;
-
-import org.apache.lucene.util.BytesRef;
-
-/**
- * Wraps a {@link LegacySortedDocValues} into a {@link SortedDocValues}.
- *
- * @deprecated Implement {@link SortedDocValues} directly.
- */
-@Deprecated
-public final class LegacySortedDocValuesWrapper extends SortedDocValues {
-  private final LegacySortedDocValues values;
-  private final int maxDoc;
-  private int docID = -1;
-  private int ord;
-  
-  public LegacySortedDocValuesWrapper(LegacySortedDocValues values, int maxDoc) {
-    this.values = values;
-    this.maxDoc = maxDoc;
-  }
-
-  @Override
-  public int docID() {
-    return docID;
-  }
-
-  @Override
-  public int nextDoc() {
-    assert docID != NO_MORE_DOCS;
-    docID++;
-    while (docID < maxDoc) {
-      ord = values.getOrd(docID);
-      if (ord != -1) {
-        return docID;
-      }
-      docID++;
-    }
-    docID = NO_MORE_DOCS;
-    return NO_MORE_DOCS;
-  }
-
-  @Override
-  public int advance(int target) {
-    if (target < docID) {
-      throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
-    }
-    if (target >= maxDoc) {
-      this.docID = NO_MORE_DOCS;
-    } else {
-      this.docID = target-1;
-      nextDoc();
-    }
-    return docID;
-  }
-
-  @Override
-  public boolean advanceExact(int target) throws IOException {
-    docID = target;
-    ord = values.getOrd(docID);
-    return ord != -1;
-  }
-
-  @Override
-  public long cost() {
-    return 0;
-  }
-
-  @Override
-  public int ordValue() {
-    return ord;
-  }
-
-  @Override
-  public BytesRef lookupOrd(int ord) {
-    return values.lookupOrd(ord);
-  }
-
-  @Override
-  public int getValueCount() {
-    return values.getValueCount();
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/index/LegacySortedNumericDocValues.java b/lucene/core/src/java/org/apache/lucene/index/LegacySortedNumericDocValues.java
deleted file mode 100644
index 42e9a5d..0000000
--- a/lucene/core/src/java/org/apache/lucene/index/LegacySortedNumericDocValues.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.index;
-
-
-/**
- * A list of per-document numeric values, sorted 
- * according to {@link Long#compare(long, long)}.
- *
- * @deprecated Use {@link SortedNumericDocValues} instead.
- */
-@Deprecated
-public abstract class LegacySortedNumericDocValues {
-  
-  /** Sole constructor. (For invocation by subclass 
-   *  constructors, typically implicit.) */
-  protected LegacySortedNumericDocValues() {}
-
-  /** 
-   * Positions to the specified document 
-   */
-  public abstract void setDocument(int doc);
-  
-  /** 
-   * Retrieve the value for the current document at the specified index. 
-   * An index ranges from {@code 0} to {@code count()-1}. 
-   */
-  public abstract long valueAt(int index);
-  
-  /** 
-   * Retrieves the count of values for the current document. 
-   * This may be zero if a document has no values.
-   */
-  public abstract int count();
-}
diff --git a/lucene/core/src/java/org/apache/lucene/index/LegacySortedNumericDocValuesWrapper.java b/lucene/core/src/java/org/apache/lucene/index/LegacySortedNumericDocValuesWrapper.java
deleted file mode 100644
index a75274e..0000000
--- a/lucene/core/src/java/org/apache/lucene/index/LegacySortedNumericDocValuesWrapper.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.index;
-
-import java.io.IOException;
-
-/**
- * Wraps a {@link LegacySortedNumericDocValues} into a {@link SortedNumericDocValues}.
- *
- * @deprecated Implement {@link SortedNumericDocValues} directly.
- */
-@Deprecated
-public final class LegacySortedNumericDocValuesWrapper extends SortedNumericDocValues {
-  private final LegacySortedNumericDocValues values;
-  private final int maxDoc;
-  private int docID = -1;
-  private int upto;
-  
-  public LegacySortedNumericDocValuesWrapper(LegacySortedNumericDocValues values, int maxDoc) {
-    this.values = values;
-    this.maxDoc = maxDoc;
-  }
-
-  @Override
-  public int docID() {
-    return docID;
-  }
-
-  @Override
-  public int nextDoc() {
-    assert docID != NO_MORE_DOCS;
-    while (true) {
-      docID++;
-      if (docID == maxDoc) {
-        docID = NO_MORE_DOCS;
-        break;
-      }
-      values.setDocument(docID);
-      if (values.count() != 0) {
-        break;
-      }
-    }
-    upto = 0;
-    return docID;
-  }
-
-  @Override
-  public int advance(int target) {
-    if (target < docID) {
-      throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
-    }
-    if (target >= maxDoc) {
-      docID = NO_MORE_DOCS;
-    } else {
-      docID = target-1;
-      nextDoc();
-    }
-    return docID;
-  }
-
-  @Override
-  public boolean advanceExact(int target) throws IOException {
-    docID = target;
-    values.setDocument(docID);
-    upto = 0;
-    return values.count() != 0;
-  }
-
-  @Override
-  public long cost() {
-    return 0;
-  }
-
-  @Override
-  public long nextValue() {
-    return values.valueAt(upto++);
-  }
-
-  @Override
-  public int docValueCount() {
-    return values.count();
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/index/LegacySortedSetDocValues.java b/lucene/core/src/java/org/apache/lucene/index/LegacySortedSetDocValues.java
deleted file mode 100644
index 0c6c809..0000000
--- a/lucene/core/src/java/org/apache/lucene/index/LegacySortedSetDocValues.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.index;
-
-
-import java.io.IOException;
-
-import org.apache.lucene.util.BytesRef;
-
-/**
- * A per-document set of presorted byte[] values.
- * <p>
- * Per-Document values in a SortedDocValues are deduplicated, dereferenced,
- * and sorted into a dictionary of unique values. A pointer to the
- * dictionary value (ordinal) can be retrieved for each document. Ordinals
- * are dense and in increasing sorted order.
- *
- * @deprecated Use {@link SortedSetDocValues} instead.
- */
-@Deprecated
-public abstract class LegacySortedSetDocValues {
-  
-  /** Sole constructor. (For invocation by subclass 
-   * constructors, typically implicit.) */
-  protected LegacySortedSetDocValues() {}
-
-  /** When returned by {@link #nextOrd()} it means there are no more 
-   *  ordinals for the document.
-   */
-  public static final long NO_MORE_ORDS = -1;
-
-  /** 
-   * Returns the next ordinal for the current document (previously
-   * set by {@link #setDocument(int)}.
-   * @return next ordinal for the document, or {@link #NO_MORE_ORDS}. 
-   *         ordinals are dense, start at 0, then increment by 1 for 
-   *         the next value in sorted order. 
-   */
-  public abstract long nextOrd();
-  
-  /** 
-   * Sets iteration to the specified docID 
-   * @param docID document ID 
-   */
-  public abstract void setDocument(int docID);
-
-  /** Retrieves the value for the specified ordinal. The returned
-   * {@link BytesRef} may be re-used across calls to lookupOrd so make sure to
-   * {@link BytesRef#deepCopyOf(BytesRef) copy it} if you want to keep it
-   * around.
-   * @param ord ordinal to lookup
-   * @see #nextOrd
-   */
-  public abstract BytesRef lookupOrd(long ord);
-
-  /**
-   * Returns the number of unique values.
-   * @return number of unique values in this SortedDocValues. This is
-   *         also equivalent to one plus the maximum ordinal.
-   */
-  public abstract long getValueCount();
-
-  /** If {@code key} exists, returns its ordinal, else
-   *  returns {@code -insertionPoint-1}, like {@code
-   *  Arrays.binarySearch}.
-   *
-   *  @param key Key to look up
-   **/
-  public long lookupTerm(BytesRef key) {
-    long low = 0;
-    long high = getValueCount()-1;
-
-    while (low <= high) {
-      long mid = (low + high) >>> 1;
-      final BytesRef term = lookupOrd(mid);
-      int cmp = term.compareTo(key);
-
-      if (cmp < 0) {
-        low = mid + 1;
-      } else if (cmp > 0) {
-        high = mid - 1;
-      } else {
-        return mid; // key found
-      }
-    }
-
-    return -(low + 1);  // key not found.
-  }
-  
-  /** 
-   * Returns a {@link TermsEnum} over the values.
-   * The enum supports {@link TermsEnum#ord()} and {@link TermsEnum#seekExact(long)}.
-   */
-  public TermsEnum termsEnum() throws IOException {
-    throw new UnsupportedOperationException();
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/index/LegacySortedSetDocValuesWrapper.java b/lucene/core/src/java/org/apache/lucene/index/LegacySortedSetDocValuesWrapper.java
deleted file mode 100644
index 0e96e02..0000000
--- a/lucene/core/src/java/org/apache/lucene/index/LegacySortedSetDocValuesWrapper.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.index;
-
-import java.io.IOException;
-
-import org.apache.lucene.util.BytesRef;
-
-/**
- * Wraps a {@link LegacySortedSetDocValues} into a {@link SortedSetDocValues}.
- *
- * @deprecated Implement {@link SortedSetDocValues} directly.
- */
-@Deprecated
-public final class LegacySortedSetDocValuesWrapper extends SortedSetDocValues {
-  private final LegacySortedSetDocValues values;
-  private final int maxDoc;
-  private int docID = -1;
-  private long ord;
-  
-  public LegacySortedSetDocValuesWrapper(LegacySortedSetDocValues values, int maxDoc) {
-    this.values = values;
-    this.maxDoc = maxDoc;
-  }
-
-  @Override
-  public int docID() {
-    return docID;
-  }
-
-  @Override
-  public int nextDoc() {
-    assert docID != NO_MORE_DOCS;
-    docID++;
-    while (docID < maxDoc) {
-      values.setDocument(docID);
-      ord = values.nextOrd();
-      if (ord != NO_MORE_ORDS) {
-        return docID;
-      }
-      docID++;
-    }
-    docID = NO_MORE_DOCS;
-    return NO_MORE_DOCS;
-  }
-
-  @Override
-  public int advance(int target) {
-    if (target < docID) {
-      throw new IllegalArgumentException("cannot advance backwards: docID=" + docID + " target=" + target);
-    }
-    if (target >= maxDoc) {
-      this.docID = NO_MORE_DOCS;
-    } else {
-      this.docID = target-1;
-      nextDoc();
-    }
-    return docID;
-  }
-
-  @Override
-  public boolean advanceExact(int target) throws IOException {
-    docID = target;
-    values.setDocument(docID);
-    ord = values.nextOrd();
-    return ord != NO_MORE_ORDS;
-  }
-
-  @Override
-  public long cost() {
-    return 0;
-  }
-
-  @Override
-  public long nextOrd() {
-    long result = ord;
-    if (result != NO_MORE_ORDS) {
-      ord = values.nextOrd();
-    }
-    return result;
-  }
-
-  @Override
-  public BytesRef lookupOrd(long ord) {
-    return values.lookupOrd((int) ord);
-  }
-
-  @Override
-  public long getValueCount() {
-    return values.getValueCount();
-  }
-
-  @Override
-  public String toString() {
-    return "LegacySortedSetDocValuesWrapper(" + values + ")";
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java b/lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java
index 054f3a3..8446e0e 100644
--- a/lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java
+++ b/lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java
@@ -21,7 +21,6 @@ import java.io.IOException;
 import java.util.Arrays;
 
 import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.index.LegacyNumericDocValues;
 import org.apache.lucene.store.DataInput;
 import org.apache.lucene.store.DataOutput;
 import org.apache.lucene.store.IndexInput;
@@ -449,7 +448,10 @@ public class PackedInts {
    * A read-only random access array of positive integers.
    * @lucene.internal
    */
-  public static abstract class Reader extends LegacyNumericDocValues implements Accountable {
+  public static abstract class Reader implements Accountable {
+
+    /** Get the long at the given index. Behavior is undefined for out-of-range indices. */
+    public abstract long get(int index);
 
     /**
      * Bulk get: read at least one and at most <code>len</code> longs starting
diff --git a/solr/core/src/java/org/apache/solr/uninverting/DocTermOrds.java b/solr/core/src/java/org/apache/solr/uninverting/DocTermOrds.java
index 580a971..736be37 100644
--- a/solr/core/src/java/org/apache/solr/uninverting/DocTermOrds.java
+++ b/solr/core/src/java/org/apache/solr/uninverting/DocTermOrds.java
@@ -28,8 +28,6 @@ import org.apache.lucene.index.DocValuesType;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.ImpactsEnum;
 import org.apache.lucene.index.LeafReader;
-import org.apache.lucene.index.LegacySortedSetDocValues;
-import org.apache.lucene.index.LegacySortedSetDocValuesWrapper;
 import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.SortedSetDocValues;
 import org.apache.lucene.index.Terms;
@@ -756,24 +754,27 @@ public class DocTermOrds implements Accountable {
     if (isEmpty()) {
       return DocValues.emptySortedSet();
     } else {
-      return new LegacySortedSetDocValuesWrapper(new Iterator(reader), reader.maxDoc());
+      return new Iterator(reader);
     }
   }
   
-  private class Iterator extends LegacySortedSetDocValues {
+  private class Iterator extends SortedSetDocValues {
     final LeafReader reader;
     final TermsEnum te;  // used internally for lookupOrd() and lookupTerm()
+    final int maxDoc;
     // currently we read 5 at a time (using the logic of the old iterator)
     final int buffer[] = new int[5];
     int bufferUpto;
     int bufferLength;
     
+    private int doc = -1;
     private int tnum;
     private int upto;
     private byte[] arr;
     
     Iterator(LeafReader reader) throws IOException {
       this.reader = reader;
+      this.maxDoc = reader.maxDoc();
       this.te = termsEnum();
     }
     
@@ -835,8 +836,8 @@ public class DocTermOrds implements Accountable {
       return bufferUpto;
     }
 
-    @Override
-    public void setDocument(int docID) {
+    private void setDocument(int docID) {
+      this.doc = docID;
       tnum = 0;
       final int code = index[docID];
       if ((code & 0x80000000) != 0) {
@@ -855,6 +856,37 @@ public class DocTermOrds implements Accountable {
     }
 
     @Override
+    public boolean advanceExact(int target) throws IOException {
+      setDocument(target);
+      return bufferLength > 0;
+    }
+
+    @Override
+    public int docID() {
+      return doc;
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      return advance(docID() + 1);
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      for (int d = target; d < maxDoc; ++d) {
+        if (advanceExact(d)) {
+          return d;
+        }
+      }
+      return doc = NO_MORE_DOCS;
+    }
+
+    @Override
+    public long cost() {
+      return maxDoc;
+    }
+
+    @Override
     public BytesRef lookupOrd(long ord) {
       try {
         return DocTermOrds.this.lookupTerm(te, (int) ord);
