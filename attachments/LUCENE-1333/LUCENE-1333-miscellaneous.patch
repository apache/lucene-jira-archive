Index: lucene/contrib/miscellaneous/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java
===================================================================
--- lucene/contrib/miscellaneous/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java	(revision 682416)
+++ lucene/contrib/miscellaneous/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java	(working copy)
@@ -57,19 +57,25 @@
     boolean inPhrase = false;
     int savedStart = 0, savedEnd = 0;
 
-    public Token next() throws IOException {
+    public Token next(Token token) throws IOException {
       if (inPhrase) {
         inPhrase = false;
-        return new Token("phrase2", savedStart, savedEnd);
+        token.setTermBuffer("phrase2");
+        token.setStartOffset(savedStart);
+        token.setEndOffset(savedEnd);
+        return token;
       } else
-        for (Token token = input.next(); token != null; token = input.next()) {
-          if (token.termText().equals("phrase")) {
+        for (token = input.next(token); token != null; token = input.next(token)) {
+          if (token.term().equals("phrase")) {
             inPhrase = true;
             savedStart = token.startOffset();
             savedEnd = token.endOffset();
-            return new Token("phrase1", savedStart, savedEnd);
-          } else if (!token.termText().equals("stop"))
+            token.setTermBuffer("phrase1");
+            token.setStartOffset(savedStart);
+            token.setEndOffset(savedEnd);
             return token;
+          } else if (!token.term().equals("stop"))
+            return token;
         }
       return null;
     }
Index: lucene/contrib/miscellaneous/src/java/org/apache/lucene/queryParser/analyzing/AnalyzingQueryParser.java
===================================================================
--- lucene/contrib/miscellaneous/src/java/org/apache/lucene/queryParser/analyzing/AnalyzingQueryParser.java	(revision 682416)
+++ lucene/contrib/miscellaneous/src/java/org/apache/lucene/queryParser/analyzing/AnalyzingQueryParser.java	(working copy)
@@ -105,21 +105,22 @@
 
     // get Analyzer from superclass and tokenize the term
     TokenStream source = getAnalyzer().tokenStream(field, new StringReader(termStr));
-    org.apache.lucene.analysis.Token t;
+    org.apache.lucene.analysis.Token token = new org.apache.lucene.analysis.Token();
 
     int countTokens = 0;
     while (true) {
       try {
-        t = source.next();
+        token = source.next(token);
       } catch (IOException e) {
-        t = null;
+        token = null;
       }
-      if (t == null) {
+      if (token == null) {
         break;
       }
-      if (!"".equals(t.termText())) {
+      String term = token.term();
+      if (!"".equals(term)) {
         try {
-          tlist.set(countTokens++, t.termText());
+          tlist.set(countTokens++, term);
         } catch (IndexOutOfBoundsException ioobe) {
           countTokens = -1;
         }
@@ -189,18 +190,18 @@
     // get Analyzer from superclass and tokenize the term
     TokenStream source = getAnalyzer().tokenStream(field, new StringReader(termStr));
     List tlist = new ArrayList();
-    org.apache.lucene.analysis.Token t;
+    org.apache.lucene.analysis.Token token = new org.apache.lucene.analysis.Token();
 
     while (true) {
       try {
-        t = source.next();
+        token = source.next(token);
       } catch (IOException e) {
-        t = null;
+        token = null;
       }
-      if (t == null) {
+      if (token == null) {
         break;
       }
-      tlist.add(t.termText());
+      tlist.add(token.term());
     }
 
     try {
@@ -238,14 +239,15 @@
       throws ParseException {
     // get Analyzer from superclass and tokenize the term
     TokenStream source = getAnalyzer().tokenStream(field, new StringReader(termStr));
-    org.apache.lucene.analysis.Token t;
+    org.apache.lucene.analysis.Token token = new org.apache.lucene.analysis.Token();
+    org.apache.lucene.analysis.Token multipleToken = new org.apache.lucene.analysis.Token();
     boolean multipleTokens = false;
 
     try {
-      t = source.next();
-      multipleTokens = source.next() != null;
+      token = source.next(token);
+      multipleTokens = source.next(multipleToken) != null;
     } catch (IOException e) {
-      t = null;
+      token = null;
     }
 
     try {
@@ -259,7 +261,7 @@
           + " - tokens were added");
     }
 
-    return (t == null) ? null : super.getFuzzyQuery(field, t.termText(), minSimilarity);
+    return (token == null) ? null : super.getFuzzyQuery(field, token.term(), minSimilarity);
   }
 
   /**
@@ -270,18 +272,19 @@
       throws ParseException {
     // get Analyzer from superclass and tokenize the terms
     TokenStream source = getAnalyzer().tokenStream(field, new StringReader(part1));
-    org.apache.lucene.analysis.Token t;
+    org.apache.lucene.analysis.Token token = new org.apache.lucene.analysis.Token();
+    org.apache.lucene.analysis.Token multipleToken = new org.apache.lucene.analysis.Token();
     boolean multipleTokens = false;
 
     // part1
     try {
-      t = source.next();
-      if (t != null) {
-        part1 = t.termText();
+      token = source.next(token);
+      if (token != null) {
+        part1 = token.term();
       }
-      multipleTokens = source.next() != null;
+      multipleTokens = source.next(multipleToken) != null;
     } catch (IOException e) {
-      t = null;
+      token = null;
     }
     try {
       source.close();
@@ -293,16 +296,20 @@
           + " - tokens were added to part1");
     }
 
+    // part2
     source = getAnalyzer().tokenStream(field, new StringReader(part2));
-    // part2
+    if (token == null)
+      token = new org.apache.lucene.analysis.Token();
+    if (multipleToken == null)
+      multipleToken = new org.apache.lucene.analysis.Token();
     try {
-      t = source.next();
-      if (t != null) {
-        part2 = t.termText();
+      token = source.next(token);
+      if (token != null) {
+        part2 = token.term();
       }
-      multipleTokens = source.next() != null;
+      multipleTokens = source.next(multipleToken) != null;
     } catch (IOException e) {
-      t = null;
+      token = null;
     }
     try {
       source.close();
Index: lucene/contrib/miscellaneous/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.java
===================================================================
--- lucene/contrib/miscellaneous/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.java	(revision 682416)
+++ lucene/contrib/miscellaneous/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.java	(working copy)
@@ -1,14 +1,29 @@
 /* Generated By:JavaCC: Do not edit this line. PrecedenceQueryParser.java */
 package org.apache.lucene.queryParser.precedence;
 
+import java.io.IOException;
+import java.io.StringReader;
+import java.text.DateFormat;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
 import java.util.Vector;
-import java.io.*;
-import java.text.*;
-import java.util.*;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.document.DateTools;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.analysis.*;
-import org.apache.lucene.document.*;
-import org.apache.lucene.search.*;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.FuzzyQuery;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PrefixQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.util.Parameter;
 
 /**
@@ -296,21 +311,21 @@
 
     TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));
     Vector v = new Vector();
-    org.apache.lucene.analysis.Token t;
+    org.apache.lucene.analysis.Token token = new org.apache.lucene.analysis.Token();
     int positionCount = 0;
     boolean severalTokensAtSamePosition = false;
 
     while (true) {
       try {
-        t = source.next();
+        token = source.next(token);
       }
       catch (IOException e) {
-        t = null;
+        token = null;
       }
-      if (t == null)
+      if (token == null)
         break;
-      v.addElement(t);
-      if (t.getPositionIncrement() == 1)
+      v.addElement(token.clone());
+      if (token.getPositionIncrement() == 1)
         positionCount++;
       else
         severalTokensAtSamePosition = true;
@@ -325,17 +340,17 @@
     if (v.size() == 0)
       return null;
     else if (v.size() == 1) {
-      t = (org.apache.lucene.analysis.Token) v.elementAt(0);
-      return new TermQuery(new Term(field, t.termText()));
+      token = (org.apache.lucene.analysis.Token) v.elementAt(0);
+      return new TermQuery(new Term(field, token.term()));
     } else {
       if (severalTokensAtSamePosition) {
         if (positionCount == 1) {
           // no phrase query:
           BooleanQuery q = new BooleanQuery();
           for (int i = 0; i < v.size(); i++) {
-            t = (org.apache.lucene.analysis.Token) v.elementAt(i);
+            token = (org.apache.lucene.analysis.Token) v.elementAt(i);
             TermQuery currentQuery = new TermQuery(
-                new Term(field, t.termText()));
+                new Term(field, token.term()));
             q.add(currentQuery, BooleanClause.Occur.SHOULD);
           }
           return q;
@@ -345,12 +360,12 @@
           MultiPhraseQuery mpq = new MultiPhraseQuery();
           List multiTerms = new ArrayList();
           for (int i = 0; i < v.size(); i++) {
-            t = (org.apache.lucene.analysis.Token) v.elementAt(i);
-            if (t.getPositionIncrement() == 1 && multiTerms.size() > 0) {
+            token = (org.apache.lucene.analysis.Token) v.elementAt(i);
+            if (token.getPositionIncrement() == 1 && multiTerms.size() > 0) {
               mpq.add((Term[])multiTerms.toArray(new Term[0]));
               multiTerms.clear();
             }
-            multiTerms.add(new Term(field, t.termText()));
+            multiTerms.add(new Term(field, token.term()));
           }
           mpq.add((Term[])multiTerms.toArray(new Term[0]));
           return mpq;
@@ -361,7 +376,7 @@
         q.setSlop(phraseSlop);
         for (int i = 0; i < v.size(); i++) {
           q.add(new Term(field, ((org.apache.lucene.analysis.Token)
-              v.elementAt(i)).termText()));
+              v.elementAt(i)).term()));
 
         }
         return q;
