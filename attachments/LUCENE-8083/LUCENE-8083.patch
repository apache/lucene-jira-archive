diff --git a/lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer.java b/lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer.java
index dc5490a..3048fbc 100644
--- a/lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer.java
@@ -558,7 +558,7 @@ final class SloppyPhraseScorer extends Scorer {
 
   @Override
   public float maxScore() {
-    return docScorer.maxScore(Float.POSITIVE_INFINITY);
+    return docScorer.maxScore(Float.MAX_VALUE);
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java b/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
index ce9d6e0..fd334dd 100644
--- a/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
@@ -216,7 +216,7 @@ public final class SynonymQuery extends Query {
           if (simScorer == null) {
             simScorer = similarity.simScorer(simWeight, context);
           }
-          subScorers.add(new TermScorer(this, postings, simScorer, Float.POSITIVE_INFINITY));
+          subScorers.add(new TermScorer(this, postings, simScorer, Float.MAX_VALUE));
         }
       }
       if (subScorers.isEmpty()) {
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/Axiomatic.java b/lucene/core/src/java/org/apache/lucene/search/similarities/Axiomatic.java
index 2a7f353..6a4fb7e 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/Axiomatic.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/Axiomatic.java
@@ -109,9 +109,10 @@ public abstract class Axiomatic extends SimilarityBase {
   }
 
   @Override
-  protected double maxScore(BasicStats stats, double maxFreq) {
-    // TODO: can we compute a better upper bound on the produced scores
-    return Double.POSITIVE_INFINITY;
+  protected final double maxScore(BasicStats stats, double maxFreq) {
+    // Since scores must increase with freq and decrease with docLen, the maximum score
+    // is obtained for freq=maxFreq and docLen=1
+    return score(stats, maxFreq, 1);
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java
index c920891..ef77632 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java
@@ -227,7 +227,13 @@ public class BM25Similarity extends Similarity {
     @Override
     public float maxScore(float maxFreq) {
       // TODO: leverage maxFreq and the min norm from the cache
-      return weightValue;
+      double minNorm;
+      if (norms == null) {
+        minNorm = k1;
+      } else {
+        minNorm = cache[0];
+      }
+      return weightValue * (float) (maxFreq / (maxFreq + minNorm));
     }
 
     @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/DFISimilarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/DFISimilarity.java
index ca0f4aa..4ec26c9 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/DFISimilarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/DFISimilarity.java
@@ -63,9 +63,10 @@ public class DFISimilarity extends SimilarityBase {
   }
 
   @Override
-  protected double maxScore(BasicStats stats, double maxFreq) {
-    // TODO: can we compute a better upper bound on the produced scores
-    return Double.POSITIVE_INFINITY;
+  protected final double maxScore(BasicStats stats, double maxFreq) {
+    // Since scores must increase with freq and decrease with docLen, the maximum score
+    // is obtained for freq=maxFreq and docLen=1
+    return score(stats, maxFreq, 1);
   }
 
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/DFRSimilarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/DFRSimilarity.java
index 788f30a..bac6b89 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/DFRSimilarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/DFRSimilarity.java
@@ -113,9 +113,10 @@ public class DFRSimilarity extends SimilarityBase {
   }
 
   @Override
-  protected double maxScore(BasicStats stats, double maxFreq) {
-    // TODO: can we compute a better upper bound on the produced scores
-    return Double.POSITIVE_INFINITY;
+  protected final double maxScore(BasicStats stats, double maxFreq) {
+    // Since scores must increase with freq and decrease with docLen, the maximum score
+    // is obtained for freq=maxFreq and docLen=1
+    return score(stats, maxFreq, 1);
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/IBSimilarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/IBSimilarity.java
index a71614c..d438a8f 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/IBSimilarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/IBSimilarity.java
@@ -104,9 +104,10 @@ public class IBSimilarity extends SimilarityBase {
   }
 
   @Override
-  protected double maxScore(BasicStats stats, double maxFreq) {
-    // TODO: can we compute a better upper bound on the produced scores
-    return Double.POSITIVE_INFINITY;
+  protected final double maxScore(BasicStats stats, double maxFreq) {
+    // Since scores must increase with freq and decrease with docLen, the maximum score
+    // is obtained for freq=maxFreq and docLen=1
+    return score(stats, maxFreq, 1);
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/LMDirichletSimilarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/LMDirichletSimilarity.java
index 2a4354e..e46991f 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/LMDirichletSimilarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/LMDirichletSimilarity.java
@@ -77,9 +77,10 @@ public class LMDirichletSimilarity extends LMSimilarity {
   }
 
   @Override
-  protected double maxScore(BasicStats stats, double maxFreq) {
-    // TODO: can we compute a better upper bound on the produced scores
-    return Double.POSITIVE_INFINITY;
+  protected final double maxScore(BasicStats stats, double maxFreq) {
+    // Since scores must increase with freq and decrease with docLen, the maximum score
+    // is obtained for freq=maxFreq and docLen=1
+    return score(stats, maxFreq, 1);
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/LMJelinekMercerSimilarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/LMJelinekMercerSimilarity.java
index fa0ebcf..832fcb1 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/LMJelinekMercerSimilarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/LMJelinekMercerSimilarity.java
@@ -67,9 +67,10 @@ public class LMJelinekMercerSimilarity extends LMSimilarity {
   }
 
   @Override
-  protected double maxScore(BasicStats stats, double maxFreq) {
-    // TODO: can we compute a better upper bound on the produced scores
-    return Double.POSITIVE_INFINITY;
+  protected final double maxScore(BasicStats stats, double maxFreq) {
+    // Since scores must increase with freq and decrease with docLen, the maximum score
+    // is obtained for freq=maxFreq and docLen=1
+    return score(stats, maxFreq, 1);
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java
index 30895eb..1e0c2f2 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java
@@ -160,6 +160,8 @@ public abstract class Similarity {
 
     /**
      * Return the maximum score that this scorer may produce for freqs in {@code ]0, maxFreq]}.
+     * {@code maxFreq} must be a positive finite float. If you need an upper
+     * bound of scores regardless of the frequency, pass {@link Float#MAX_VALUE}.
      * {@code Float.POSITIVE_INFINITY} is a fine return value if scores are not bounded.
      * @param maxFreq the maximum frequency
      */
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/similarities/AssertingSimilarity.java b/lucene/test-framework/src/java/org/apache/lucene/search/similarities/AssertingSimilarity.java
index 98e49eb..e68140c 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/similarities/AssertingSimilarity.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/similarities/AssertingSimilarity.java
@@ -98,6 +98,8 @@ public class AssertingSimilarity extends Similarity {
 
       @Override
       public float maxScore(float maxFreq) {
+        assert maxFreq > 0;
+        assert Float.isFinite(maxFreq);
         float maxScore = delegateScorer.maxScore(maxFreq);
         assert Float.isNaN(maxScore) == false;
         return maxScore;
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase.java
index 5eb64fc..854a6d5 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase.java
@@ -60,7 +60,7 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
   static LeafReader WITH_NORM_BASE;
   static Directory WITH_NORM_DIR;
   static List<LeafReader> NORM_VALUES;
-  
+
   @BeforeClass
   public static void beforeClass() throws Exception {
     // without norms
@@ -82,7 +82,7 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
     writer.addDocument(doc);
     WITH_NORM_BASE = getOnlyLeafReader(writer.getReader());
     writer.close();
-    
+
     // all possible norm values for the doc
     NORM_VALUES = new ArrayList<>();
     NORM_VALUES.add(WITHOUT_NORM);
@@ -110,7 +110,7 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
       });
     }
   }
-  
+
   @AfterClass
   public static void afterClass() throws Exception {
     IOUtils.close(WITH_NORM_BASE, WITH_NORM_DIR, WITHOUT_NORM, WITHOUT_NORM_DIR);
@@ -118,12 +118,12 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
     WITH_NORM_DIR = WITHOUT_NORM_DIR = null;
     NORM_VALUES = null;
   }
-  
+
   /** 1-document norms impl of the given value */
   static class CannedNorm extends NumericDocValues {
     int docID = -1;
     final long value;
-    
+
     CannedNorm(long value) {
       this.value = value;
     }
@@ -173,7 +173,7 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
    * Return a new similarity with all parameters randomized within valid ranges.
    */
   protected abstract Similarity getSimilarity(Random random);
-  
+
   static final long MAXDOC_FORTESTING = 1L << 48;
   // must be at least MAXDOC_FORTESTING + Integer.MAX_VALUE
   static final long MAXTOKENS_FORTESTING = 1L << 49;
@@ -187,7 +187,7 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
     final int lowerBound;
     if (norm == 0) {
       // norms are omitted, but there must have been at least one token to produce that norm
-      lowerBound = 1;    
+      lowerBound = 1;
     } else {
       // minimum value that would decode to such a norm
       lowerBound = SmallFloat.byte4ToInt((byte) norm);
@@ -278,7 +278,7 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
     }
     return new CollectionStatistics("field", maxDoc, docCount, sumTotalTermFreq, sumDocFreq);
   }
-  
+
   private static final BytesRef TERM = new BytesRef("term");
 
   /**
@@ -330,6 +330,75 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
     return new TermStatistics(TERM, docFreq, totalTermFreq);
   }
 
+  static float randomBoost(Random random) {
+    // we just limit the test to "reasonable" boost values but don't enforce this anywhere.
+    // too big, and you are asking for overflow. that's hard for a sim to enforce (but definitely possible)
+    // for now, we just want to detect overflow where its a real bug/hazard in the computation with reasonable inputs.
+    switch (random.nextInt(5)) {
+      case 0:
+        // minimum value
+        return 0F;
+      case 1:
+        // tiny value
+        return Float.MIN_VALUE;
+      case 2:
+        // no-op value (sometimes treated special in explanations)
+        return 1F;
+      case 3:
+        // maximum value (not enforceD)
+        return Integer.MAX_VALUE;
+      default:
+        // random value
+        return random.nextFloat() * Integer.MAX_VALUE;
+    }
+  }
+
+  static float randomFreq(Random random, TermStatistics term) {
+    if (term.totalTermFreq() == term.docFreq()) {
+      // omit TF
+      return 1;
+    } else if (term.docFreq() == 1) {
+      // only one document, all the instances must be here.
+      return Math.toIntExact(term.totalTermFreq());
+    } else {
+      // there is at least one other document, and those must have at least 1 instance each.
+      int upperBound = Math.toIntExact(Math.min(term.totalTermFreq() - term.docFreq() + 1, Integer.MAX_VALUE));
+      if (random.nextBoolean()) {
+        // integer freq
+        switch (random.nextInt(3)) {
+          case 0:
+            // smallest freq
+            return 1;
+          case 1:
+            // largest freq
+            return upperBound;
+          default:
+            // random freq
+            return TestUtil.nextInt(random, 1, upperBound);
+        }
+      } else {
+        // float freq
+        float freqCandidate;
+        switch (random.nextInt(2)) {
+          case 0:
+            // smallest freq
+            freqCandidate = Float.MIN_VALUE;
+            break;
+          default:
+            // random freq
+            freqCandidate = upperBound * random.nextFloat();
+            break;
+        }
+        // we need to be 2nd float value at a minimum, the pairwise test will check MIN_VALUE in this case.
+        // this avoids testing frequencies of 0 which seem wrong to allow (we should enforce computeSlopFactor etc)
+        if (freqCandidate <= Float.MIN_VALUE) {
+          freqCandidate = Math.nextUp(Float.MIN_VALUE);
+        }
+        return freqCandidate;
+      }
+    }
+  }
+
   /**
    * Tests scoring across a bunch of random terms/corpora/frequencies for each possible document length.
    * It does the following checks:
@@ -358,86 +427,48 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
           CollectionStatistics corpus = newCorpus(random, k);
           for (int l = 0; l < 10; l++) {
             TermStatistics term = newTerm(random, corpus);
-            final float freq;
-            if (term.totalTermFreq() == term.docFreq()) {
-              // omit TF
-              freq = 1;
-            } else if (term.docFreq() == 1) {
-              // only one document, all the instances must be here.
-              freq = Math.toIntExact(term.totalTermFreq());
-            } else {
-              // there is at least one other document, and those must have at least 1 instance each.
-              int upperBound = Math.toIntExact(Math.min(term.totalTermFreq() - term.docFreq() + 1, Integer.MAX_VALUE));
-              if (random.nextBoolean()) {
-                // integer freq
-                switch (random.nextInt(3)) {
-                  case 0:
-                    // smallest freq
-                    freq = 1;
-                    break;
-                  case 1:
-                    // largest freq
-                    freq = upperBound;
-                    break;
-                  default:
-                    // random freq
-                    freq = TestUtil.nextInt(random, 1, upperBound);
-                    break;
-                }
-              } else {
-                // float freq
-                float freqCandidate;
-                switch (random.nextInt(2)) {
-                  case 0:
-                    // smallest freq
-                    freqCandidate = Float.MIN_VALUE;
-                    break;
-                  default:
-                    // random freq
-                    freqCandidate = upperBound * random.nextFloat();
-                    break;
-                }
-                // we need to be 2nd float value at a minimum, the pairwise test will check MIN_VALUE in this case.
-                // this avoids testing frequencies of 0 which seem wrong to allow (we should enforce computeSlopFactor etc)
-                if (freqCandidate <= Float.MIN_VALUE) {
-                  freqCandidate = Math.nextUp(Float.MIN_VALUE);
-                }
-                freq = freqCandidate;
-              }
-            }
-            // we just limit the test to "reasonable" boost values but don't enforce this anywhere.
-            // too big, and you are asking for overflow. that's hard for a sim to enforce (but definitely possible)
-            // for now, we just want to detect overflow where its a real bug/hazard in the computation with reasonable inputs.
-            final float boost;
-            switch (random.nextInt(5)) {
-              case 0:
-                // minimum value (not enforced)
-                boost = 0F;
-                break;
-              case 1:
-                // tiny value
-                boost = Float.MIN_VALUE;
-                break;
-              case 2:
-                // no-op value (sometimes treated special in explanations)
-                boost = 1F;
-                break;
-              case 3:
-                // maximum value (not enforceD)
-                boost = Integer.MAX_VALUE;
-                break;
-              default:
-                // random value
-                boost = random.nextFloat() * Integer.MAX_VALUE;
-                break;
-            }
+            final float freq = randomFreq(random, term);
+            final float boost = randomBoost(random);
             doTestScoring(similarity, corpus, term, boost, freq, k);
           }
         }
       }
     }
   }
-  
+
+  public void testMaxScore() throws IOException {
+    Random random = random();
+    final int iterations = atLeast(10);
+    for (int i = 0; i < iterations; i++) {
+      // pull a new similarity to switch up parameters
+      Similarity similarity = getSimilarity(random);
+      for (int j = 0; j < 10; j++) {
+        // for each norm value...
+        for (int norm = 0; norm < NORM_VALUES.size(); norm++) {
+          doTestMaxScore(random, similarity, norm);
+        }
+      }
+    }
+  }
+
+  private void doTestMaxScore(Random random, Similarity similarity, int norm) throws IOException {
+    CollectionStatistics corpus = newCorpus(random, norm);
+    TermStatistics term = newTerm(random, corpus);
+    for (int iter = 0; iter < 10; ++iter) {
+      final float boost = randomBoost(random);
+      SimWeight weight = similarity.computeWeight(boost, corpus, term);
+      SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());
+      float maxScore0 = scorer.maxScore(Float.MIN_VALUE);
+      assertTrue("maxScore(min_value) < 0: " + maxScore0, maxScore0 >= 0);
+      float freq = randomFreq(random, term);
+      float maxScore = scorer.maxScore(freq);
+      assertTrue("maxScore(min_value) > maxScore(freq)", maxScore0 <= maxScore);
+      // Scorers that cannot bound the freq, like SloppyPhraseScorer, pass max_value as a max frequency
+      float maxScoreMaxValue = scorer.maxScore(Float.MAX_VALUE);
+      assertTrue("maxScore(freq) > maxScore(Inf)", maxScore <= maxScoreMaxValue);
+    }
+  }
+
   /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */
   private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {
     boolean success = false;
@@ -456,7 +487,7 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
         fail("expected: " + score + ", got: " + explanation);
       }
       CheckHits.verifyExplanation("<test query>", 0, score, true, explanation);
-      
+
       // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]
       final float prevFreq;
       if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {
@@ -466,7 +497,7 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
         // previous in float space (e.g. for sloppyPhrase)
         prevFreq = Math.nextDown(freq);
       }
-      
+
       float prevScore = scorer.score(0, prevFreq);
       // check that score isn't infinite or negative
       assertTrue(Float.isFinite(prevScore));
@@ -483,7 +514,7 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
         System.out.println(explanation);
         fail("score(" + prevFreq + ")=" + prevScore + " > score(" + freq + ")=" + score);
       }
-      
+
       // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]
       if (norm > 1) {
         SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());
@@ -504,7 +535,7 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
           fail("score(" + freq + "," + (norm-1) + ")=" + prevNormScore + " < score(" + freq + "," + norm + ")=" + score);
         }
       }
-      
+
       // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]
       if (term.docFreq() > 1 && freq < term.totalTermFreq()) {
         TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);
@@ -527,7 +558,7 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
           fail("score(" + freq + "," + (prevTerm) + ")=" + prevTermScore + " < score(" + freq + "," + term + ")=" + score);
         }
       }
-      
+
       success = true;
     } finally {
       if (!success) {
@@ -542,5 +573,5 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
         System.out.println("freq=" + freq);
       }
     }
-  }  
+  }
 }
