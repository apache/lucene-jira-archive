diff --git a/lucene/core/src/java/org/apache/lucene/geo/GeoEncodingUtils.java b/lucene/core/src/java/org/apache/lucene/geo/GeoEncodingUtils.java
index 663cb2e..c177c77 100644
--- a/lucene/core/src/java/org/apache/lucene/geo/GeoEncodingUtils.java
+++ b/lucene/core/src/java/org/apache/lucene/geo/GeoEncodingUtils.java
@@ -377,4 +377,160 @@ public final class GeoEncodingUtils {
       }
     }
   }
+  
+  // nocommit: hacky duplication for experimentation only!!!!
+  
+  private static class IntGrid {
+    static final int ARITY = 64;
+
+    final int latShift, lonShift;
+    final int latBase, lonBase;
+    final int maxLatDelta, maxLonDelta;
+    final int[] relations;
+
+    private IntGrid(
+        int latShift, int lonShift,
+        int latBase, int lonBase,
+        int maxLatDelta, int maxLonDelta,
+        int[] relations) {
+      if (latShift < 1 || latShift > 31) {
+        throw new IllegalArgumentException();
+      }
+      if (lonShift < 1 || lonShift > 31) {
+        throw new IllegalArgumentException();
+      }
+      this.latShift = latShift;
+      this.lonShift = lonShift;
+      this.latBase = latBase;
+      this.lonBase = lonBase;
+      this.maxLatDelta = maxLatDelta;
+      this.maxLonDelta = maxLonDelta;
+      this.relations = relations;
+    }
+  }
+  
+  private static IntGrid createIntSubBoxes(Rectangle boundingBox, Function<Rectangle, Integer> boxToID) {
+    final int minLat = encodeLatitudeCeil(boundingBox.minLat);
+    final int maxLat = encodeLatitude(boundingBox.maxLat);
+    final int minLon = encodeLongitudeCeil(boundingBox.minLon);
+    final int maxLon = encodeLongitude(boundingBox.maxLon);
+
+    if (maxLat < minLat || (boundingBox.crossesDateline() == false && maxLon < minLon)) {
+      // the box cannot match any quantized point
+      return new IntGrid(1, 1, 0, 0, 0, 0, new int[0]);
+    }
+
+    final int latShift, lonShift;
+    final int latBase, lonBase;
+    final int maxLatDelta, maxLonDelta;
+    {
+      long minLat2 = (long) minLat - Integer.MIN_VALUE;
+      long maxLat2 = (long) maxLat - Integer.MIN_VALUE;
+      latShift = computeShift(minLat2, maxLat2);
+      latBase = (int) (minLat2 >>> latShift);
+      maxLatDelta = (int) (maxLat2 >>> latShift) - latBase + 1;
+      assert maxLatDelta > 0;
+    }
+    {
+      long minLon2 = (long) minLon - Integer.MIN_VALUE;
+      long maxLon2 = (long) maxLon - Integer.MIN_VALUE;
+      if (boundingBox.crossesDateline()) {
+        maxLon2 += 1L << 32; // wrap
+      }
+      lonShift = computeShift(minLon2, maxLon2);
+      lonBase = (int) (minLon2 >>> lonShift);
+      maxLonDelta = (int) (maxLon2 >>> lonShift) - lonBase + 1;
+      assert maxLonDelta > 0;
+    }
+
+    final int[] relations = new int[maxLatDelta * maxLonDelta];
+    for (int i = 0; i < maxLatDelta; ++i) {
+      for (int j = 0; j < maxLonDelta; ++j) {
+        final int boxMinLat = ((latBase + i) << latShift) + Integer.MIN_VALUE;
+        final int boxMinLon = ((lonBase + j) << lonShift) + Integer.MIN_VALUE;
+        final int boxMaxLat = boxMinLat + (1 << latShift) - 1;
+        final int boxMaxLon = boxMinLon + (1 << lonShift) - 1;
+
+        relations[i * maxLonDelta + j] = boxToID.apply(new Rectangle(
+            decodeLatitude(boxMinLat), decodeLatitude(boxMaxLat),
+            decodeLongitude(boxMinLon), decodeLongitude(boxMaxLon)));
+      }
+    }
+
+    return new IntGrid(
+        latShift, lonShift,
+        latBase, lonBase,
+        maxLatDelta, maxLonDelta,
+        relations);
+  }
+  
+  /** A predicate that checks whether a given point is within a polygon. */
+  public static class PolygonIDPredicate extends IntGrid {
+
+    private final Polygon2D tree;
+
+    private PolygonIDPredicate(
+        int latShift, int lonShift,
+        int latBase, int lonBase,
+        int maxLatDelta, int maxLonDelta,
+        int[] relations,
+        Polygon2D tree) {
+      super(latShift, lonShift, latBase, lonBase, maxLatDelta, maxLonDelta, relations);
+      this.tree = tree;
+    }
+
+    /** Check whether the given point is within the considered polygon.
+     *  NOTE: this operates directly on the encoded representation of points. */
+    public int find(int lat, int lon) {
+      final int lat2 = ((lat - Integer.MIN_VALUE) >>> latShift);
+      if (lat2 < latBase || lat2 >= latBase + maxLatDelta) {
+        return -1;
+      }
+      int lon2 = ((lon - Integer.MIN_VALUE) >>> lonShift);
+      if (lon2 < lonBase) { // wrap
+        lon2 += 1 << (32 - lonShift);
+      }
+      assert Integer.toUnsignedLong(lon2) >= lonBase;
+      assert lon2 - lonBase >= 0;
+      if (lon2 - lonBase >= maxLonDelta) {
+        return -1;
+      }
+
+      final int relation = relations[(lat2 - latBase) * maxLonDelta + (lon2 - lonBase)];
+      if (relation >= 0) {
+        return relation;
+      } else if (relation == -1) {
+        return -1;
+      } else {
+        assert relation == -2; // -2 means don't know
+        return tree.find(decodeLatitude(lat), decodeLongitude(lon));
+      }
+    }
+  }
+  
+  /** Create a predicate that checks whether points are within a polygon.
+   *  It works the same way as {@link #createDistancePredicate}.
+   *  @lucene.internal */
+  public static PolygonIDPredicate createPolygonIDPredicate(Polygon[] polygons, Polygon2D tree) {
+    final Rectangle boundingBox = Rectangle.fromPolygon(polygons);
+    final Function<Rectangle, Integer> boxToID = box -> { 
+      Relation relation = tree.relate(box.minLat, box.maxLat, box.minLon, box.maxLon);
+      if (relation == Relation.CELL_INSIDE_QUERY) {
+        return tree.find(box.minLat, box.minLon); // we're inside, look up a point to get ID
+      } else if (relation == Relation.CELL_OUTSIDE_QUERY) {
+        return -1; // -1 means no match
+      } else {
+        return -2; // -2 means dont know
+      }
+    };
+    final IntGrid subBoxes = createIntSubBoxes(boundingBox, boxToID);
+
+    return new PolygonIDPredicate(
+        subBoxes.latShift, subBoxes.lonShift,
+        subBoxes.latBase, subBoxes.lonBase,
+        subBoxes.maxLatDelta, subBoxes.maxLonDelta,
+        subBoxes.relations,
+        tree);
+  }
+  
 }
diff --git a/lucene/core/src/java/org/apache/lucene/geo/Polygon2D.java b/lucene/core/src/java/org/apache/lucene/geo/Polygon2D.java
index 699b874..00b8ded 100644
--- a/lucene/core/src/java/org/apache/lucene/geo/Polygon2D.java
+++ b/lucene/core/src/java/org/apache/lucene/geo/Polygon2D.java
@@ -67,7 +67,11 @@ public final class Polygon2D {
   /** root node of edge tree */
   private final Edge tree;
 
-  private Polygon2D(Polygon polygon, Polygon2D holes) {
+  /** polygon's ID */
+  private final int id;
+
+  private Polygon2D(int id, Polygon polygon, Polygon2D holes) {
+    this.id = id;
     this.holes = holes;
     this.minLat = polygon.minLat;
     this.maxLat = polygon.maxLat;
@@ -87,22 +91,34 @@ public final class Polygon2D {
    * https://www.ecse.rpi.edu/~wrf/Research/Short_Notes/pnpoly.html</a> for more information.
    */
   public boolean contains(double latitude, double longitude) {
+    return find(latitude, longitude) >= 0;
+  }
+
+  /**
+   * Returns the index of the polygon passed to {@link #create(Polygon...)} that
+   * contains this point, or {@code -1} if its not found.
+   * <p>
+   * @lucene.experimental
+   */
+  public int find(double latitude, double longitude) {
     if (latitude <= maxY && longitude <= maxX) {
       if (componentContains(latitude, longitude)) {
-        return true;
+        return id;
       }
       if (left != null) {
-        if (left.contains(latitude, longitude)) {
-          return true;
+        int leftID = left.find(latitude, longitude);
+        if (leftID >= 0) {
+          return leftID;
         }
       }
       if (right != null && ((splitX == false && latitude >= minLat) || (splitX && longitude >= minLon))) {
-        if (right.contains(latitude, longitude)) {
-          return true;
+        int rightID = right.find(latitude, longitude);
+        if (rightID >= 0) {
+          return rightID;
         }
       }
     }
-    return false;
+    return -1;
   }
   
   /** Returns true if the point is contained within this polygon component. */
@@ -262,7 +278,7 @@ public final class Polygon2D {
       if (gonHoles.length > 0) {
         holes = create(gonHoles);
       }
-      components[i] = new Polygon2D(gon, holes);
+      components[i] = new Polygon2D(i, gon, holes);
     }
     return createTree(components, 0, components.length - 1, false);
   }
diff --git a/lucene/core/src/test/org/apache/lucene/geo/TestPolygon2D.java b/lucene/core/src/test/org/apache/lucene/geo/TestPolygon2D.java
index 31a42c0..f93a56b 100644
--- a/lucene/core/src/test/org/apache/lucene/geo/TestPolygon2D.java
+++ b/lucene/core/src/test/org/apache/lucene/geo/TestPolygon2D.java
@@ -39,6 +39,12 @@ public class TestPolygon2D extends LuceneTestCase {
     assertTrue(polygon.contains(-25, 25)); // on the mainland
     assertFalse(polygon.contains(-51, 51)); // in the ocean
     
+    // find(point)
+    assertEquals(1, polygon.find(-2, 2));  // on the island
+    assertEquals(-1, polygon.find(-6, 6)); // in the hole
+    assertEquals(0, polygon.find(-25, 25)); // on the mainland
+    assertEquals(-1, polygon.find(-51, 51)); // in the ocean
+
     // relate(box): this can conservatively return CELL_CROSSES_QUERY
     assertEquals(Relation.CELL_INSIDE_QUERY, polygon.relate(-2, 2, -2, 2)); // on the island
     assertEquals(Relation.CELL_OUTSIDE_QUERY, polygon.relate(6, 7, 6, 7)); // in the hole
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/range/PolygonFacetSource.java b/lucene/facet/src/java/org/apache/lucene/facet/range/PolygonFacetSource.java
new file mode 100644
index 0000000..4b96202
--- /dev/null
+++ b/lucene/facet/src/java/org/apache/lucene/facet/range/PolygonFacetSource.java
@@ -0,0 +1,111 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.facet.range;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Objects;
+
+import org.apache.lucene.geo.GeoEncodingUtils;
+import org.apache.lucene.geo.Polygon;
+import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.SortedNumericDocValues;
+import org.apache.lucene.search.DoubleValues;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.LongValues;
+import org.apache.lucene.search.LongValuesSource;
+
+/** 
+ * ValueSource that returns the index into {@code polygons} that contains the point
+ */
+final class PolygonFacetSource extends LongValuesSource {
+  private final String field;
+  private final Polygon[] polygons;
+  private final GeoEncodingUtils.PolygonIDPredicate tree;
+
+  PolygonFacetSource(String field, Polygon[] polygons, GeoEncodingUtils.PolygonIDPredicate tree) {
+    this.field = Objects.requireNonNull(field);
+    this.polygons = Objects.requireNonNull(polygons);
+    this.tree = Objects.requireNonNull(tree);
+  }
+
+  @Override
+  public boolean isCacheable(LeafReaderContext ctx) {
+    return true; // you can't update sorted numeric
+  }
+  
+  @Override
+  public LongValues getValues(LeafReaderContext ctx, DoubleValues scores) throws IOException {
+    LeafReader reader = ctx.reader();
+    SortedNumericDocValues raw = DocValues.getSortedNumeric(reader, field);
+    return new LongValues() {
+      @Override
+      public long longValue() throws IOException {
+        long bits = raw.nextValue(); // nocommit, don't use LongValues abstraction, we don't need it, and it only supports single-valued
+        int polygonID = tree.find((int)(bits >> 32), (int)(bits & 0xFFFFFFFF));
+        assert polygonID == -1 || polygonID < polygons.length;
+        return polygonID;
+      }
+
+      @Override
+      public boolean advanceExact(int doc) throws IOException {
+        return raw.advanceExact(doc);
+      }
+    };
+  }
+
+  @Override
+  public boolean needsScores() {
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + field.hashCode();
+    result = prime * result + Arrays.hashCode(polygons);
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) return true;
+    if (obj == null) return false;
+    if (getClass() != obj.getClass()) return false;
+    PolygonFacetSource other = (PolygonFacetSource) obj;
+    if (field != other.field) {
+      return false;
+    }
+    if (polygons != other.polygons) {
+      return false;
+    }
+    return true;
+  }
+
+  @Override
+  public String toString() {
+    return "polygonFacet(" + field + ")";
+  }
+
+  @Override
+  public LongValuesSource rewrite(IndexSearcher searcher) throws IOException {
+    return null;
+  }
+}
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/range/PolygonFacets.java b/lucene/facet/src/java/org/apache/lucene/facet/range/PolygonFacets.java
new file mode 100644
index 0000000..556d348
--- /dev/null
+++ b/lucene/facet/src/java/org/apache/lucene/facet/range/PolygonFacets.java
@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.facet.range;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.apache.lucene.facet.Facets;
+import org.apache.lucene.facet.FacetsCollector;
+import org.apache.lucene.geo.GeoEncodingUtils;
+import org.apache.lucene.geo.Polygon;
+import org.apache.lucene.geo.Polygon2D;
+import org.apache.lucene.geo.Rectangle;
+import org.apache.lucene.search.DocIdSet;
+import org.apache.lucene.search.LongValuesSource;
+import org.apache.lucene.search.Query;
+
+/**
+ * Facets a {@code LatLonDocValuesField} by polygon.
+ * <p>
+ * Add a number of (multi)polygons to it, associating each with a label, then call build()
+ * for a facets implementation. Behind the scenes, all the (multi)polygons are arranged
+ * into a datastructure that can bucket points reasonably efficiently.
+ * <p>
+ * This is slower than doing work to compute the labels at index time and indexing them as 
+ * strings, but allows for the set of polygons to be managed at query-time instead.
+ * <p>
+ * Example:
+ * <pre class="prettyprint">
+ *  // create a new builder and add polygons to it
+ *  PolygonFacets.Builder builder = new PolygonFacets.Builder();
+ *  builder.add("Russia", Polygon.fromGeoJSON(russiaJSON));
+ *  builder.add("Canada", Polygon.fromGeoJSON(canadaJSON));
+ *  PolygonFacets tree = builder.build();
+ *  // after calling build(), the tree datastructure can be re-used across queries
+ *  for (Query query : queries) {
+ *    FacetsCollector fc = new FacetsCollector();
+ *    searcher.search(query, fc);
+ *    Facets facets = tree.create("field", fc);
+ *    FacetResult result = facets.getTopChildren(10, "field");
+ *  }
+ * </pre>
+ * @lucene.experimental
+ */
+// nocommit: this extra indirection was an experiment, its not worth the api costs, collapse back into one class.
+public class PolygonFacets {
+  
+  /** 
+   * Constructs a PolygonFacets by adding polygons associated with labels.
+   * When {@link #build()} is invoked, it will create the data structure needed.
+   */
+  public static class Builder {
+    private final ArrayList<Polygon> polygons = new ArrayList<>();
+    private final ArrayList<LongRange> ranges = new ArrayList<>();
+
+    /** Adds a (multi)polygon, associated with a label */
+    public Builder add(String label, Polygon... polygon) {
+      int rangeStart = polygons.size();
+      polygons.addAll(Arrays.asList(polygon));
+      int rangeEnd = polygons.size();
+      ranges.add(new LongRange(label, rangeStart, true, rangeEnd, false));
+      return this;
+    }
+    
+    /** Returns a built polygon facets, which can be reused for multiple queries */
+    public PolygonFacets build() {
+      return new PolygonFacets(polygons, ranges);
+    }
+  }
+  
+  private final Polygon[] polygons;
+  private final LongRange[] ranges;
+  private final Polygon2D tree;
+  private final GeoEncodingUtils.PolygonIDPredicate predicate;
+
+  /* no instance */
+  private PolygonFacets(ArrayList<Polygon> polygons, ArrayList<LongRange> ranges) {
+    this.polygons = polygons.toArray(new Polygon[0]);
+    this.ranges = ranges.toArray(new LongRange[0]);
+    this.tree = Polygon2D.create(this.polygons);
+    this.predicate = GeoEncodingUtils.createPolygonIDPredicate(this.polygons, tree);
+  }
+  
+  /** nocommit: just for benchmarking purposes */
+  public Rectangle getBoundingBox() {
+    return Rectangle.fromPolygon(polygons);
+  }
+
+  /** Builds a facet implementation for the field using the specified collector */
+  public Facets create(String field, FacetsCollector hits) throws IOException {
+    return create(field, hits, null);
+  }
+
+  /** 
+   * Builds a facet implementation for the field using the specified collector.
+   * The provided fastMatchQuery must be random access (implement {@link DocIdSet#bits})
+   */
+  public Facets create(String field, FacetsCollector hits, Query fastMatchQuery) throws IOException {
+    LongValuesSource source = new PolygonFacetSource(field, polygons, predicate);
+    return new LongRangeFacetCounts(field, source, hits, fastMatchQuery, ranges);
+  }
+}
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java b/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java
index 8a7f913..65510e7 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java
@@ -16,6 +16,9 @@
  */
 package org.apache.lucene.facet.range;
 
+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLatitude;
+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLongitude;
+
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.List;
@@ -27,6 +30,7 @@ import org.apache.lucene.document.DoubleDocValuesField;
 import org.apache.lucene.document.DoublePoint;
 import org.apache.lucene.document.LongPoint;
 import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.document.SortedNumericDocValuesField;
 import org.apache.lucene.facet.DrillDownQuery;
 import org.apache.lucene.facet.DrillSideways;
 import org.apache.lucene.facet.DrillSideways.DrillSidewaysResult;
@@ -41,6 +45,7 @@ import org.apache.lucene.facet.MultiFacets;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.geo.Polygon;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.LeafReaderContext;
@@ -867,4 +872,62 @@ public class TestRangeFacetCounts extends FacetTestCase {
     writer.close();
     IOUtils.close(r, dir);
   }
+
+  private long encodeLatLon(double latitude, double longitude) {
+    int latitudeEncoded = encodeLatitude(latitude);
+    int longitudeEncoded = encodeLongitude(longitude);
+    return (((long)latitudeEncoded) << 32) | (longitudeEncoded & 0xFFFFFFFFL);
+  }
+
+  public void testBasicPolygons() throws Exception {
+    Directory d = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random(), d);
+    Document doc = new Document();
+    // simulate LatLonDocValues field since we can't use it...
+    SortedNumericDocValuesField field = new SortedNumericDocValuesField("field", 0L);
+    doc.add(field);
+
+    // country1 on the island
+    field.setLongValue(encodeLatLon(-2, 2));
+    w.addDocument(doc);
+    // country1 in the hole, but not the island (not a match)
+    field.setLongValue(encodeLatLon(-6, 6));
+    w.addDocument(doc);
+    // country1 on the mainland
+    field.setLongValue(encodeLatLon(-25, 25));
+    w.addDocument(doc);
+    // country1 in the ocean (not a match)
+    field.setLongValue(encodeLatLon(-51, 51));
+    w.addDocument(doc);
+
+    // country2 
+    field.setLongValue(encodeLatLon(-80, -10));
+    w.addDocument(doc);
+
+    IndexReader r = w.getReader();
+    w.close();
+
+    IndexSearcher searcher = newSearcher(r);
+
+    PolygonFacets.Builder builder = new PolygonFacets.Builder();
+    // "country1" multipolygon
+    Polygon hole = new Polygon(new double[] { -10, -10, 10, 10, -10 }, new double[] { -10, 10, 10, -10, -10 });
+    Polygon outer = new Polygon(new double[] { -50, -50, 50, 50, -50 }, new double[] { -50, 50, 50, -50, -50 }, hole);
+    Polygon island = new Polygon(new double[] { -5, -5, 5, 5, -5 }, new double[] { -5, 5, 5, -5, -5 } );
+    builder.add("country1", outer, island);
+
+    // "country2" simple polygon
+    Polygon country2 = new Polygon(new double[] { -90, -90, -70, -70, -90}, new double[] { -11, 7, 7, -11, -11 });
+    builder.add("country2", country2);
+    PolygonFacets tree = builder.build();
+
+    FacetsCollector fc = new FacetsCollector();
+    searcher.search(new MatchAllDocsQuery(), fc);
+    Facets facets = tree.create("field", fc);
+    FacetResult result = facets.getTopChildren(10, "field");
+    assertEquals("dim=field path=[] value=3 childCount=2\n  country1 (2)\n  country2 (1)\n",
+                 result.toString());
+    r.close();
+    d.close();
+  }
 }
