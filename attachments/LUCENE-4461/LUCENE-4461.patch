Index: lucene/facet/src/java/org/apache/lucene/facet/search/StandardFacetsAccumulator.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/search/StandardFacetsAccumulator.java	(revision 1420359)
+++ lucene/facet/src/java/org/apache/lucene/facet/search/StandardFacetsAccumulator.java	(working copy)
@@ -3,6 +3,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map.Entry;
 import java.util.logging.Level;
@@ -161,14 +162,18 @@
           // In this implementation merges happen after each
           // partition,
           // but other impl could merge only at the end.
+          final HashSet<FacetRequest> handledRequests = new HashSet<FacetRequest>();
           for (FacetRequest fr : searchParams.getFacetRequests()) {
-            FacetResultsHandler frHndlr = fr.createFacetResultsHandler(taxonomyReader);
-            IntermediateFacetResult res4fr = frHndlr.fetchPartitionResult(facetArrays, offset);
-            IntermediateFacetResult oldRes = fr2tmpRes.get(fr);
-            if (oldRes != null) {
-              res4fr = frHndlr.mergeResults(oldRes, res4fr);
-            }
-            fr2tmpRes.put(fr, res4fr);
+            // Handle and merge only facet requests which had not already been handled.  
+            if (handledRequests.add(fr)) {
+              FacetResultsHandler frHndlr = fr.createFacetResultsHandler(taxonomyReader);
+              IntermediateFacetResult res4fr = frHndlr.fetchPartitionResult(facetArrays, offset);
+              IntermediateFacetResult oldRes = fr2tmpRes.get(fr);
+              if (oldRes != null) {
+                res4fr = frHndlr.mergeResults(oldRes, res4fr);
+              }
+              fr2tmpRes.put(fr, res4fr);
+            } 
           }
         }
       } finally {
@@ -264,7 +269,7 @@
     int[] intArray = facetArrays.getIntArray();
     totalFacetCounts.fillTotalCountsForPartition(intArray, partition);
     double totalCountsFactor = getTotalCountsFactor();
-    // fix total counts, but only if the effect of this would be meaningfull. 
+    // fix total counts, but only if the effect of this would be meaningful. 
     if (totalCountsFactor < 0.99999) {
       int delta = nAccumulatedDocs + 1;
       for (int i = 0; i < intArray.length; i++) {
Index: lucene/facet/src/test/org/apache/lucene/facet/TestSameRequestAcculumation.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/TestSameRequestAcculumation.java	(revision 0)
+++ lucene/facet/src/test/org/apache/lucene/facet/TestSameRequestAcculumation.java	(working copy)
@@ -0,0 +1,71 @@
+package org.apache.lucene.facet;
+
+import java.util.List;
+
+import org.apache.lucene.facet.search.FacetsCollector;
+import org.apache.lucene.facet.search.params.CountFacetRequest;
+import org.apache.lucene.facet.search.params.FacetSearchParams;
+import org.apache.lucene.facet.search.results.FacetResult;
+import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.junit.After;
+import org.junit.Before;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class TestSameRequestAcculumation extends FacetTestBase {
+  
+  @Override
+  @Before
+  public void setUp() throws Exception {
+    super.setUp();
+    initIndex();
+  }
+  
+  // Following LUCENE-4461 - ensure requesting the (exact) same request more
+  // than once does not alter the results
+  public void testTwoSameRequasts() throws Exception {
+    final FacetSearchParams fsp = getFacetedSearchParams();
+    final CountFacetRequest facetRequest = new CountFacetRequest(new CategoryPath("root"), 10);
+    
+    fsp.addFacetRequest(facetRequest);
+    FacetsCollector fc = new FacetsCollector(fsp, indexReader, taxoReader);
+    searcher.search(new MatchAllDocsQuery(), fc);
+    
+    final int expected = fc.getFacetResults().get(0).getNumValidDescendants();
+    
+    fsp.addFacetRequest(facetRequest);
+
+    // make sure the search params holds 2 requests now
+    assertEquals(2, fsp.getFacetRequests().size());
+    
+    fc = new FacetsCollector(fsp, indexReader, taxoReader);
+    searcher.search(new MatchAllDocsQuery(), fc);
+    List<FacetResult> actual = fc.getFacetResults();
+
+    assertEquals("Wrong number of descendants", expected, actual.get(0).getNumValidDescendants());
+    assertEquals("Wrong number of descendants", expected, actual.get(1).getNumValidDescendants());
+  }
+  
+  @Override
+  @After
+  public void tearDown() throws Exception {
+    closeAll();
+    super.tearDown();
+  }
+}
