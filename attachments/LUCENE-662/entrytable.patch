Index: src/test/org/apache/lucene/Utils.java
===================================================================
--- src/test/org/apache/lucene/Utils.java	(révision 0)
+++ src/test/org/apache/lucene/Utils.java	(révision 0)
@@ -0,0 +1,47 @@
+package org.apache.lucene;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.FSDirectory;
+
+/**
+ * Usefull functions when debugging
+ * 
+ * $Id$
+ */
+public class Utils {
+
+  /**
+   * Function that serialize a index on a filesystem.
+   * 
+   * @param dir the directory of the index to serialize
+   * @param file path of the index to write
+   * @throws IOException
+   */
+  public static void writeIndex(Directory dir, String file) throws IOException {
+    FSDirectory fsdir = FSDirectory.getDirectory(file, true);
+    IndexWriter writer = new IndexWriter(fsdir, new StandardAnalyzer(), true);
+    writer.addIndexes(new Directory[] { dir });
+    writer.close();
+  }
+}
Index: src/test/org/apache/lucene/store/IndexInputTest.java
===================================================================
--- src/test/org/apache/lucene/store/IndexInputTest.java	(révision 0)
+++ src/test/org/apache/lucene/store/IndexInputTest.java	(révision 0)
@@ -0,0 +1,104 @@
+package org.apache.lucene.store;
+
+import junit.framework.TestCase;
+
+public class IndexInputTest extends TestCase {
+
+  public void testInt() throws Exception {
+    genericTestInt(0);
+    genericTestInt(1);
+    genericTestInt(-1);
+    genericTestInt(Integer.MAX_VALUE);
+    genericTestInt(Integer.MIN_VALUE);
+  }
+
+  public void testVInt() throws Exception {
+    genericTestVInt(0);
+    genericTestVInt(1);
+    genericTestVInt(-1);
+    genericTestVInt(Integer.MAX_VALUE);
+    genericTestVInt(Integer.MIN_VALUE);
+  }
+
+  public void testLong() throws Exception {
+    genericTestLong(0);
+    genericTestLong(1);
+    genericTestLong(-1);
+    genericTestLong(Long.MAX_VALUE);
+    genericTestLong(Long.MIN_VALUE);
+  }
+
+  public void testVLong() throws Exception {
+    genericTestVLong(0);
+    genericTestVLong(1);
+    genericTestVLong(-1);
+    genericTestVLong(Long.MAX_VALUE);
+    genericTestVLong(Long.MIN_VALUE);
+  }
+
+  public void testString() throws Exception {
+    genericTestString("");
+    genericTestString("a");
+    genericTestString("GiyNNKHhnivNKKHgcNiCniCH716534912é_è'-(é(_çà-é$*ù!:;,!:;,");
+  }
+
+  private void genericTestInt(int i) throws Exception {
+    RAMFile fileA = new RAMFile();
+    RAMFile fileB = new RAMFile();
+    RAMOutputStream outA = new RAMOutputStream(fileA);
+    outA.writeInt(i);
+    outA.close();
+    RAMOutputStream outB = new RAMOutputStream(fileB);
+    outB.writeInt(new RAMInputStream(fileA));
+    outB.close();
+    assertEquals(i, new RAMInputStream(fileB).readInt());
+  }
+
+  private void genericTestVInt(int i) throws Exception {
+    RAMFile fileA = new RAMFile();
+    RAMFile fileB = new RAMFile();
+    RAMOutputStream outA = new RAMOutputStream(fileA);
+    outA.writeVInt(i);
+    outA.close();
+    RAMOutputStream outB = new RAMOutputStream(fileB);
+    outB.writeVInt(new RAMInputStream(fileA));
+    outB.close();
+    assertEquals(i, new RAMInputStream(fileB).readVInt());
+  }
+
+  private void genericTestLong(long l) throws Exception {
+    RAMFile fileA = new RAMFile();
+    RAMFile fileB = new RAMFile();
+    RAMOutputStream outA = new RAMOutputStream(fileA);
+    outA.writeLong(l);
+    outA.close();
+    RAMOutputStream outB = new RAMOutputStream(fileB);
+    outB.writeLong(new RAMInputStream(fileA));
+    outB.close();
+    assertEquals(l, new RAMInputStream(fileB).readLong());
+  }
+
+  private void genericTestVLong(long l) throws Exception {
+    RAMFile fileA = new RAMFile();
+    RAMFile fileB = new RAMFile();
+    RAMOutputStream outA = new RAMOutputStream(fileA);
+    outA.writeVLong(l);
+    outA.close();
+    RAMOutputStream outB = new RAMOutputStream(fileB);
+    outB.writeVLong(new RAMInputStream(fileA));
+    outB.close();
+    assertEquals(l, new RAMInputStream(fileB).readVLong());
+  }
+
+  private void genericTestString(String s) throws Exception {
+    RAMFile fileA = new RAMFile();
+    RAMFile fileB = new RAMFile();
+    RAMOutputStream outA = new RAMOutputStream(fileA);
+    outA.writeString(s);
+    outA.close();
+    RAMOutputStream outB = new RAMOutputStream(fileB);
+    outB.writeString(new RAMInputStream(fileA));
+    outB.close();
+    assertEquals(s, new RAMInputStream(fileB).readString());
+  }
+}
Index: src/test/org/apache/lucene/index/SimpleEntryTableTest.java
===================================================================
--- src/test/org/apache/lucene/index/SimpleEntryTableTest.java	(révision 0)
+++ src/test/org/apache/lucene/index/SimpleEntryTableTest.java	(révision 0)
@@ -0,0 +1,99 @@
+package org.apache.lucene.index;
+
+/**
+ * Copyright 2005 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.store.RAMDirectory;
+
+import junit.framework.TestCase;
+
+public class SimpleEntryTableTest extends TestCase {
+
+  public void test() throws Exception {
+    SimpleEntryTable table = new SimpleEntryTable();
+    assertEquals(0, table.add("id1"));
+    assertEquals(1, table.add("id2"));
+    assertEquals(1, table.add("id2"));
+    assertEquals(2, table.size());
+
+    Entry entry = table.getEntry(0);
+    assertNotNull(entry);
+    assertEquals("id1", entry.getId());
+    assertEquals(0, entry.getIndex());
+
+    entry = table.getEntry(1);
+    assertNotNull(entry);
+    assertEquals("id2", entry.getId());
+    assertEquals(1, entry.getIndex());
+
+    entry = table.getEntry(2);
+    assertNull(entry);
+
+    entry = table.getEntry(-1);
+    assertNull(entry);
+
+    entry = table.getEntry("id1");
+    assertNotNull(entry);
+    assertEquals("id1", entry.getId());
+    assertEquals(0, entry.getIndex());
+
+    entry = table.getEntry("id2");
+    assertNotNull(entry);
+    assertEquals("id2", entry.getId());
+    assertEquals(1, entry.getIndex());
+
+    entry = table.getEntry("");
+    assertNull(entry);
+
+    entry = table.getEntry(null);
+    assertNull(entry);
+
+    assertEquals("id1", table.getId(0));
+    assertEquals("id2", table.getId(1));
+    assertNull(table.getId(2));
+    assertNull(table.getId(-1));
+
+    assertEquals(0, table.getIndex("id1"));
+    assertEquals(1, table.getIndex("id2"));
+    assertEquals(-1, table.getIndex(""));
+    assertEquals(-1, table.getIndex(null));
+  }
+
+  public void testIO() throws Exception {
+    SimpleEntryTable table = new SimpleEntryTable();
+    table.add("id1");
+    table.add("id2");
+    RAMDirectory dir = new RAMDirectory();
+    table.write(dir, "data");
+
+    SimpleEntryTable table2 = new SimpleEntryTable(dir, "data");
+
+    assertEquals(2, table2.size());
+
+    Entry entry = table2.getEntry(0);
+    assertNotNull(entry);
+    assertEquals("id1", entry.getId());
+    assertEquals(0, entry.getIndex());
+
+    entry = table2.getEntry(1);
+    assertNotNull(entry);
+    assertEquals("id2", entry.getId());
+    assertEquals(1, entry.getIndex());
+
+    entry = table2.getEntry(2);
+    assertNull(entry);
+  }
+}
Index: src/test/org/apache/lucene/index/TestIndexFileDeleter.java
===================================================================
--- src/test/org/apache/lucene/index/TestIndexFileDeleter.java	(révision 493447)
+++ src/test/org/apache/lucene/index/TestIndexFileDeleter.java	(copie de travail)
@@ -75,7 +75,7 @@
     int contentFieldIndex = -1;
     for(i=0;i<fieldInfos.size();i++) {
       FieldInfo fi = fieldInfos.fieldInfo(i);
-      if (fi.name.equals("content")) {
+      if (fi.getId().equals("content")) {
         contentFieldIndex = i;
         break;
       }
Index: src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
===================================================================
--- src/test/org/apache/lucene/index/TestBackwardsCompatibility.java	(révision 493447)
+++ src/test/org/apache/lucene/index/TestBackwardsCompatibility.java	(copie de travail)
@@ -306,7 +306,7 @@
     int contentFieldIndex = -1;
     for(int i=0;i<fieldInfos.size();i++) {
       FieldInfo fi = fieldInfos.fieldInfo(i);
-      if (fi.name.equals("content")) {
+      if (fi.getId().equals("content")) {
         contentFieldIndex = i;
         break;
       }
Index: src/java/org/apache/lucene/index/FieldInfo.java
===================================================================
--- src/java/org/apache/lucene/index/FieldInfo.java	(révision 493447)
+++ src/java/org/apache/lucene/index/FieldInfo.java	(copie de travail)
@@ -1,5 +1,8 @@
 package org.apache.lucene.index;
 
+import org.apache.lucene.document.Field;
+
+
 /**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -17,10 +20,8 @@
  * limitations under the License.
  */
 
-final class FieldInfo {
-  String name;
+public final class FieldInfo extends Entry {
   boolean isIndexed;
-  int number;
 
   // true if term vector for this field should be stored
   boolean storeTermVector;
@@ -29,14 +30,33 @@
 
   boolean omitNorms; // omit norms associated with indexed fields
 
-  FieldInfo(String na, boolean tk, int nu, boolean storeTermVector, 
-            boolean storePositionWithTermVector,  boolean storeOffsetWithTermVector, boolean omitNorms) {
-    name = na;
+  FieldInfo(String na, boolean tk, int nu, boolean storeTermVector, boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,
+      boolean omitNorms) {
+    super(na, nu);
     isIndexed = tk;
-    number = nu;
     this.storeTermVector = storeTermVector;
     this.storeOffsetWithTermVector = storeOffsetWithTermVector;
     this.storePositionWithTermVector = storePositionWithTermVector;
     this.omitNorms = omitNorms;
   }
+
+  public boolean omitNorms() {
+    return omitNorms;
+  }
+
+  public boolean isIndexed() {
+    return isIndexed;
+  }
+
+  public boolean storeOffsetWithTermVector() {
+    return storeOffsetWithTermVector;
+  }
+
+  public boolean storePositionWithTermVector() {
+    return storePositionWithTermVector;
+  }
+
+  public boolean storeTermVector() {
+    return storeTermVector;
+  }
 }
Index: src/java/org/apache/lucene/index/FieldInfos.java
===================================================================
--- src/java/org/apache/lucene/index/FieldInfos.java	(révision 493447)
+++ src/java/org/apache/lucene/index/FieldInfos.java	(copie de travail)
@@ -32,7 +32,7 @@
  *  be adding documents at a time, with no other reader or writer threads
  *  accessing this object.
  */
-final class FieldInfos {
+public final class FieldInfos extends EntryTable {
   
   static final byte IS_INDEXED = 0x1;
   static final byte STORE_TERMVECTOR = 0x2;
@@ -40,10 +40,9 @@
   static final byte STORE_OFFSET_WITH_TERMVECTOR = 0x8;
   static final byte OMIT_NORMS = 0x10;
   
-  private ArrayList byNumber = new ArrayList();
-  private HashMap byName = new HashMap();
 
-  FieldInfos() { }
+  public FieldInfos() {
+  }
 
   /**
    * Construct a FieldInfos object using the directory and the name of the file
@@ -53,12 +52,7 @@
    * @throws IOException
    */
   FieldInfos(Directory d, String name) throws IOException {
-    IndexInput input = d.openInput(name);
-    try {
-      read(input);
-    } finally {
-      input.close();
-    }
+    super(d, name);
   }
 
   /** Adds field info for a Document. */
@@ -156,9 +150,11 @@
    */
   public void add(String name, boolean isIndexed, boolean storeTermVector,
                   boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean omitNorms) {
-    FieldInfo fi = fieldInfo(name);
+    FieldInfo fi = (FieldInfo) getEntry(name);
     if (fi == null) {
-      addInternal(name, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms);
+      int n = size();
+      fi = new FieldInfo(name, isIndexed, n, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms);
+      add(fi);
     } else {
       if (fi.isIndexed != isIndexed) {
         fi.isIndexed = true;                      // once indexed, always index
@@ -179,116 +175,67 @@
     }
   }
 
-
-  private void addInternal(String name, boolean isIndexed,
-                           boolean storeTermVector, boolean storePositionWithTermVector, 
-                           boolean storeOffsetWithTermVector, boolean omitNorms) {
-    FieldInfo fi =
-      new FieldInfo(name, isIndexed, byNumber.size(), storeTermVector, storePositionWithTermVector,
-              storeOffsetWithTermVector, omitNorms);
-    byNumber.add(fi);
-    byName.put(name, fi);
-  }
-
-  public int fieldNumber(String fieldName) {
-    try {
-      FieldInfo fi = fieldInfo(fieldName);
-      if (fi != null)
-        return fi.number;
+  public boolean hasVectors() {
+    boolean hasVectors = false;
+    for (int i = 0; i < size(); i++) {
+      if (((FieldInfo) getEntry(i)).storeTermVector) {
+        hasVectors = true;
+        break;
+      }
     }
-    catch (IndexOutOfBoundsException ioobe) {
-      return -1;
-    }
-    return -1;
+    return hasVectors;
   }
 
-  public FieldInfo fieldInfo(String fieldName) {
-    return (FieldInfo) byName.get(fieldName);
-  }
-
   /**
-   * Return the fieldName identified by its number.
-   * 
-   * @param fieldNumber
-   * @return the fieldName or an empty string when the field
-   * with the given number doesn't exist.
-   */  
-  public String fieldName(int fieldNumber) {
-    try {
-      return fieldInfo(fieldNumber).name;
-    }
-    catch (NullPointerException npe) {
+   * Just change the behaviour to never return <code>null</code> but return an empty string
+   */
+  public String getId(int index) {
+    String id = super.getId(index);
+    if (id == null) {
       return "";
     }
+    return id;
   }
 
-  /**
-   * Return the fieldinfo object referenced by the fieldNumber.
-   * @param fieldNumber
-   * @return the FieldInfo object or null when the given fieldNumber
-   * doesn't exist.
-   */  
-  public FieldInfo fieldInfo(int fieldNumber) {
-    try {
-      return (FieldInfo) byNumber.get(fieldNumber);
-    }
-    catch (IndexOutOfBoundsException ioobe) {
-      return null;
-    }
+  protected void writeEntry(Entry info, IndexOutput output) throws IOException {
+    FieldInfo fi = (FieldInfo) info;
+    byte bits = 0x0;
+    if (fi.isIndexed) bits |= IS_INDEXED;
+    if (fi.storeTermVector) bits |= STORE_TERMVECTOR;
+    if (fi.storePositionWithTermVector) bits |= STORE_POSITIONS_WITH_TERMVECTOR;
+    if (fi.storeOffsetWithTermVector) bits |= STORE_OFFSET_WITH_TERMVECTOR;
+    if (fi.omitNorms) bits |= OMIT_NORMS;
+    output.writeString(fi.getId());
+    output.writeByte(bits);
   }
 
-  public int size() {
-    return byNumber.size();
+  protected Entry readEntry(int number, IndexInput input) throws IOException {
+    String name = input.readString().intern();
+    byte bits = input.readByte();
+    boolean isIndexed = (bits & IS_INDEXED) != 0;
+    boolean storeTermVector = (bits & STORE_TERMVECTOR) != 0;
+    boolean storePositionsWithTermVector = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;
+    boolean storeOffsetWithTermVector = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;
+    boolean omitNorms = (bits & OMIT_NORMS) != 0;
+
+    return new FieldInfo(name, isIndexed, size(), storeTermVector, storePositionsWithTermVector,
+              storeOffsetWithTermVector, omitNorms);
   }
 
-  public boolean hasVectors() {
-    boolean hasVectors = false;
-    for (int i = 0; i < size(); i++) {
-      if (fieldInfo(i).storeTermVector) {
-        hasVectors = true;
-        break;
-      }
-    }
-    return hasVectors;
+  public FieldInfo fieldInfo(int i) {
+    return (FieldInfo) getEntry(i);
   }
 
-  public void write(Directory d, String name) throws IOException {
-    IndexOutput output = d.createOutput(name);
-    try {
-      write(output);
-    } finally {
-      output.close();
-    }
+  public int fieldNumber(String fieldName) {
+    return getIndex(fieldName);
   }
 
-  public void write(IndexOutput output) throws IOException {
-    output.writeVInt(size());
-    for (int i = 0; i < size(); i++) {
-      FieldInfo fi = fieldInfo(i);
-      byte bits = 0x0;
-      if (fi.isIndexed) bits |= IS_INDEXED;
-      if (fi.storeTermVector) bits |= STORE_TERMVECTOR;
-      if (fi.storePositionWithTermVector) bits |= STORE_POSITIONS_WITH_TERMVECTOR;
-      if (fi.storeOffsetWithTermVector) bits |= STORE_OFFSET_WITH_TERMVECTOR;
-      if (fi.omitNorms) bits |= OMIT_NORMS;
-      output.writeString(fi.name);
-      output.writeByte(bits);
-    }
+  public FieldInfo fieldInfo(String id) {
+    return (FieldInfo) getEntry(id);
   }
 
-  private void read(IndexInput input) throws IOException {
-    int size = input.readVInt();//read in the size
-    for (int i = 0; i < size; i++) {
-      String name = input.readString().intern();
-      byte bits = input.readByte();
-      boolean isIndexed = (bits & IS_INDEXED) != 0;
-      boolean storeTermVector = (bits & STORE_TERMVECTOR) != 0;
-      boolean storePositionsWithTermVector = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;
-      boolean storeOffsetWithTermVector = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;
-      boolean omitNorms = (bits & OMIT_NORMS) != 0;
-
-      addInternal(name, isIndexed, storeTermVector, storePositionsWithTermVector, storeOffsetWithTermVector, omitNorms);
-    }    
+  public String fieldName(int number) {
+    return getId(number);
   }
 
 }
Index: src/java/org/apache/lucene/index/SimpleEntryTable.java
===================================================================
--- src/java/org/apache/lucene/index/SimpleEntryTable.java	(révision 0)
+++ src/java/org/apache/lucene/index/SimpleEntryTable.java	(révision 0)
@@ -0,0 +1,88 @@
+package org.apache.lucene.index;
+
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+
+/**
+ * A simple implementation of a Lucene-serialized table of entries. It only stores
+ * the ids of the entries.
+ *
+ * $Id$
+ */
+public class SimpleEntryTable extends EntryTable {
+
+  /**
+   * Constructor used to populate a table from scratch
+   *
+   */
+  public SimpleEntryTable() {
+    super();
+  }
+
+  /**
+   * Construct a SimpleEntryTable object using the directory and the name of the file
+   * IndexInput
+   * 
+   * @param d The directory to open the IndexInput from
+   * @param name The name of the file to open the IndexInput from in the Directory
+   * @throws IOException
+   */
+  public SimpleEntryTable(Directory d, String name) throws IOException {
+    super(d, name);
+  }
+
+  /**
+   * Just write the ID
+   */
+  protected void writeEntry(Entry entry, IndexOutput output) throws IOException {
+    String id = entry.getId();
+    output.writeString(id);
+  }
+
+  /**
+   * Just read the ID
+   */
+  protected Entry readEntry(int index, IndexInput input) throws IOException {
+    String id = input.readString().intern();
+    return new Entry(id, index);
+  }
+
+  /**
+   * Add an entry with the specified Id. If an entry already exist
+   * in the table, no entry is added, it just returns the index of
+   * the entry already stored.
+   * 
+   * @param id the id to insert
+   * @return the created or found index of the entry
+   */
+  public int add(String id) {
+    Entry entry = getEntry(id);
+    if (entry != null) {
+      return entry.getIndex();
+    }
+    int index = size();
+    entry = new Entry(id, index);
+    add(entry);
+    return index;
+  }
+
+}
Index: src/java/org/apache/lucene/index/FieldsReader.java
===================================================================
--- src/java/org/apache/lucene/index/FieldsReader.java	(révision 493447)
+++ src/java/org/apache/lucene/index/FieldsReader.java	(copie de travail)
@@ -94,7 +94,7 @@
     for (int i = 0; i < numFields; i++) {
       int fieldNumber = fieldsStream.readVInt();
       FieldInfo fi = fieldInfos.fieldInfo(fieldNumber);
-      FieldSelectorResult acceptField = fieldSelector == null ? FieldSelectorResult.LOAD : fieldSelector.accept(fi.name);
+      FieldSelectorResult acceptField = fieldSelector == null ? FieldSelectorResult.LOAD : fieldSelector.accept(fi.getId());
       boolean lazy = acceptField.equals(FieldSelectorResult.LAZY_LOAD) == true;
       
       byte bits = fieldsStream.readByte();
@@ -145,10 +145,10 @@
       long pointer = fieldsStream.getFilePointer();
       if (compressed) {
         //was: doc.add(new Fieldable(fi.name, uncompress(b), Fieldable.Store.COMPRESS));
-        doc.add(new LazyField(fi.name, Field.Store.COMPRESS, toRead, pointer));
+        doc.add(new LazyField(fi.getId(), Field.Store.COMPRESS, toRead, pointer));
       } else {
         //was: doc.add(new Fieldable(fi.name, b, Fieldable.Store.YES));
-        doc.add(new LazyField(fi.name, Field.Store.YES, toRead, pointer));
+        doc.add(new LazyField(fi.getId(), Field.Store.YES, toRead, pointer));
       }
       //Need to move the pointer ahead by toRead positions
       fieldsStream.seek(pointer + toRead);
@@ -162,7 +162,7 @@
         store = Field.Store.COMPRESS;
         int toRead = fieldsStream.readVInt();
         long pointer = fieldsStream.getFilePointer();
-        f = new LazyField(fi.name, store, toRead, pointer);
+        f = new LazyField(fi.getId(), store, toRead, pointer);
         //skip over the part that we aren't loading
         fieldsStream.seek(pointer + toRead);
         f.setOmitNorms(fi.omitNorms);
@@ -171,7 +171,7 @@
         long pointer = fieldsStream.getFilePointer();
         //Skip ahead of where we are by the length of what is stored
         fieldsStream.skipChars(length);
-        f = new LazyField(fi.name, store, index, termVector, length, pointer);
+        f = new LazyField(fi.getId(), store, index, termVector, length, pointer);
         f.setOmitNorms(fi.omitNorms);
       }
       doc.add(f);
@@ -203,9 +203,9 @@
       final byte[] b = new byte[toRead];
       fieldsStream.readBytes(b, 0, b.length);
       if (compressed)
-        doc.add(new Field(fi.name, uncompress(b), Field.Store.COMPRESS));
+        doc.add(new Field(fi.getId(), uncompress(b), Field.Store.COMPRESS));
       else
-        doc.add(new Field(fi.name, b, Field.Store.YES));
+        doc.add(new Field(fi.getId(), b, Field.Store.YES));
 
     } else {
       Field.Store store = Field.Store.YES;
@@ -219,14 +219,14 @@
 
         final byte[] b = new byte[toRead];
         fieldsStream.readBytes(b, 0, b.length);
-        f = new Field(fi.name,      // field name
+        f = new Field(fi.getId(),      // field name
                 new String(uncompress(b), "UTF-8"), // uncompress the value and add as string
                 store,
                 index,
                 termVector);
         f.setOmitNorms(fi.omitNorms);
       } else {
-        f = new Field(fi.name,     // name
+        f = new Field(fi.getId(),     // name
                 fieldsStream.readString(), // read value
                 store,
                 index,
@@ -425,7 +425,7 @@
       this.isBinary = binary;
       this.isTokenized = tokenize;
 
-      this.name = fi.name.intern();
+      this.name = fi.getId().intern();
       this.isIndexed = fi.isIndexed;
       this.omitNorms = fi.omitNorms;          
       this.storeOffsetWithTermVector = fi.storeOffsetWithTermVector;
Index: src/java/org/apache/lucene/index/Entry.java
===================================================================
--- src/java/org/apache/lucene/index/Entry.java	(révision 0)
+++ src/java/org/apache/lucene/index/Entry.java	(révision 0)
@@ -0,0 +1,57 @@
+package org.apache.lucene.index;
+
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * An antry is some a data in a Lucene-serialized table. This is the simplest
+ * kind of entry, it has an index and an ID.
+ * 
+ * $Id$
+ */
+public class Entry {
+
+  private int index;
+
+  private String id;
+
+  /**
+   * Contructor
+   * 
+   * @param id the id of the entry
+   * @param index the index of the entry
+   */
+  protected Entry(String id, int index) {
+    this.index = index;
+    this.id = id;
+  }
+
+  /**
+   * 
+   * @return the id of the entry
+   */
+  public String getId() {
+    return id;
+  }
+
+  /**
+   * 
+   * @return the index of the entry
+   */
+  public int getIndex() {
+    return index;
+  }
+}
Index: src/java/org/apache/lucene/index/SegmentMerger.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentMerger.java	(révision 493447)
+++ src/java/org/apache/lucene/index/SegmentMerger.java	(copie de travail)
@@ -420,7 +420,7 @@
               // the buffer is too small for the current segment
               normBuffer = new byte[maxDoc];
             }
-            reader.norms(fi.name, normBuffer, 0);
+            reader.norms(fi.getId(), normBuffer, 0);
             if (!reader.hasDeletions()) {
               //optimized case for segments without deleted docs
               output.writeBytes(normBuffer, maxDoc);
Index: src/java/org/apache/lucene/index/EntryTable.java
===================================================================
--- src/java/org/apache/lucene/index/EntryTable.java	(révision 0)
+++ src/java/org/apache/lucene/index/EntryTable.java	(révision 0)
@@ -0,0 +1,194 @@
+package org.apache.lucene.index;
+
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+
+/**
+ * Access to a Lucene-serialized table of values
+ *
+ * $Id$
+ */
+public abstract class EntryTable {
+
+  private ArrayList byIndex = new ArrayList();
+
+  private HashMap byId = new HashMap();
+
+  /**
+   * Constructor used to populate a table from scratch
+   *
+   */
+  public EntryTable() {
+    //nothing to initilaize
+  }
+
+  /**
+   * Construct a EntryTable object using the directory and the name of the file
+   * IndexInput
+   * 
+   * @param d The directory to open the IndexInput from
+   * @param name The name of the file to open the IndexInput from in the Directory
+   * @throws IOException
+   */
+  public EntryTable(Directory d, String name) throws IOException {
+    IndexInput input = d.openInput(name);
+    try {
+      read(input);
+    } finally {
+      input.close();
+    }
+  }
+
+  /**
+   * Read the table from an input stream
+   * 
+   * @param input the stream to read 
+   * @throws IOException in case or read error in stream
+   */
+  public void read(IndexInput input) throws IOException {
+    int size = input.readVInt();//read in the size
+    for (int i = 0; i < size; i++) {
+      Entry entry = readEntry(i, input);
+      add(entry);
+    }
+  }
+
+  /**
+   * Read an entry from an input stream
+   * 
+   * @param index the index of the entry
+   * @param input the input stream to read
+   * @return the read entry
+   * @throws IOException in case of read error on the stream
+   */
+  abstract protected Entry readEntry(int index, IndexInput input) throws IOException;
+
+  /**
+   * Write the table in a segment
+   * 
+   * @param d the directory to write in
+   * @param name the name of the file
+   * @throws IOException in case or read/write error in the directory
+   */
+  public void write(Directory d, String name) throws IOException {
+    IndexOutput output = d.createOutput(name);
+    try {
+      write(output);
+    } finally {
+      output.close();
+    }
+  }
+
+  /**
+   * Write the table in a stream
+   * 
+   * @param output the stream to write into
+   * @throws IOException in case or read/write error in stream
+   */
+  public void write(IndexOutput output) throws IOException {
+    output.writeVInt(size());
+    for (int i = 0; i < size(); i++) {
+      writeEntry(getEntry(i), output);
+    }
+  }
+
+  /**
+   * Write an entry in the stream
+   * 
+   * @param entry the netry to serialize
+   * @param output the stream to write in
+   * @throws IOException in case of write error on the stream
+   */
+  abstract protected void writeEntry(Entry entry, IndexOutput output) throws IOException;
+
+  /**
+   * 
+   * @return the size of the table, aka the number of entries in there
+   */
+  public int size() {
+    return byIndex.size();
+  }
+
+  /**
+   * Return the entry object referenced by the index.
+   * 
+   * @param index the request index
+   * @return the Info object or null when the given number doesn't exist.
+   */
+  public Entry getEntry(int index) {
+    if (index < 0 || index > byIndex.size() - 1) {
+      return null;
+    }
+    return (Entry) byIndex.get(index);
+  }
+
+  /**
+   * Get the number of the info from it's ID
+   * 
+   * @param id the ID of the info
+   * @return the number of the info, <code>-1</code> if not found
+   */
+  public int getIndex(String id) {
+    Entry entry = getEntry(id);
+    if (entry == null) {
+      return -1;
+    }
+    return entry.getIndex();
+  }
+
+  /**
+   * Get the entry from it's id
+   * 
+   * @param id the ID of the info 
+   * @return the entry of the table, <code>null</code> if not found
+   */
+  public Entry getEntry(String id) {
+    return (Entry) byId.get(id);
+  }
+
+  /**
+   * Return the ID of an entry from it's index.
+   * 
+   * @param index the index of the entry
+   * @return the ID or <code>null</code> when the index doesn't exist.
+   */
+  public String getId(int index) {
+    Entry entry = getEntry(index);
+    if (entry == null) {
+      return null;
+    }
+    return entry.getId();
+  }
+
+  /**
+   * Add an entry to the table
+   * 
+   * @param entry the ntry to add
+   */
+  public void add(Entry entry) {
+    byIndex.add(entry);
+    byId.put(entry.getId(), entry);
+  }
+
+}
Index: src/java/org/apache/lucene/index/TermVectorsWriter.java
===================================================================
--- src/java/org/apache/lucene/index/TermVectorsWriter.java	(révision 493447)
+++ src/java/org/apache/lucene/index/TermVectorsWriter.java	(copie de travail)
@@ -117,7 +117,7 @@
    */
   public final void openField(String field) throws IOException {
     FieldInfo fieldInfo = fieldInfos.fieldInfo(field);
-    openField(fieldInfo.number, fieldInfo.storePositionWithTermVector, fieldInfo.storeOffsetWithTermVector);
+    openField(fieldInfo.getIndex(), fieldInfo.storePositionWithTermVector, fieldInfo.storeOffsetWithTermVector);
   }
   
   private void openField(int fieldNumber, boolean storePositionWithTermVector, 
@@ -207,7 +207,7 @@
             storeOffsetWithTermVector = true;
 
           FieldInfo fieldInfo = fieldInfos.fieldInfo(tpVector.getField());
-          openField(fieldInfo.number, storePositionWithTermVector, storeOffsetWithTermVector);
+          openField(fieldInfo.getIndex(), storePositionWithTermVector, storeOffsetWithTermVector);
 
           for (int j = 0; j < tpVector.size(); j++)
             addTermInternal(tpVector.getTerms()[j], tpVector.getTermFrequencies()[j], tpVector.getTermPositions(j),
@@ -220,7 +220,7 @@
           TermFreqVector tfVector = vectors[i];
 
           FieldInfo fieldInfo = fieldInfos.fieldInfo(tfVector.getField());
-          openField(fieldInfo.number, storePositionWithTermVector, storeOffsetWithTermVector);
+          openField(fieldInfo.getIndex(), storePositionWithTermVector, storeOffsetWithTermVector);
 
           for (int j = 0; j < tfVector.size(); j++)
             addTermInternal(tfVector.getTerms()[j], tfVector.getTermFrequencies()[j], null, null);
Index: src/java/org/apache/lucene/index/DocumentWriter.java
===================================================================
--- src/java/org/apache/lucene/index/DocumentWriter.java	(révision 493447)
+++ src/java/org/apache/lucene/index/DocumentWriter.java	(copie de travail)
@@ -371,7 +371,7 @@
     for(int n = 0; n < fieldInfos.size(); n++){
       FieldInfo fi = fieldInfos.fieldInfo(n);
       if(fi.isIndexed && !fi.omitNorms){
-        float norm = fieldBoosts[n] * similarity.lengthNorm(fi.name, fieldLengths[n]);
+        float norm = fieldBoosts[n] * similarity.lengthNorm(fi.getId(), fieldLengths[n]);
         IndexOutput norms = directory.createOutput(segment + ".f" + n);
         try {
           norms.writeByte(Similarity.encodeNorm(norm));
Index: src/java/org/apache/lucene/index/SegmentReader.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentReader.java	(révision 493447)
+++ src/java/org/apache/lucene/index/SegmentReader.java	(copie de travail)
@@ -364,35 +364,35 @@
     for (int i = 0; i < fieldInfos.size(); i++) {
       FieldInfo fi = fieldInfos.fieldInfo(i);
       if (fieldOption == IndexReader.FieldOption.ALL) {
-        fieldSet.add(fi.name);
+        fieldSet.add(fi.getId());
       }
       else if (!fi.isIndexed && fieldOption == IndexReader.FieldOption.UNINDEXED) {
-        fieldSet.add(fi.name);
+        fieldSet.add(fi.getId());
       }
       else if (fi.isIndexed && fieldOption == IndexReader.FieldOption.INDEXED) {
-        fieldSet.add(fi.name);
+        fieldSet.add(fi.getId());
       }
       else if (fi.isIndexed && fi.storeTermVector == false && fieldOption == IndexReader.FieldOption.INDEXED_NO_TERMVECTOR) {
-        fieldSet.add(fi.name);
+        fieldSet.add(fi.getId());
       }
       else if (fi.storeTermVector == true &&
                fi.storePositionWithTermVector == false &&
                fi.storeOffsetWithTermVector == false &&
                fieldOption == IndexReader.FieldOption.TERMVECTOR) {
-        fieldSet.add(fi.name);
+        fieldSet.add(fi.getId());
       }
       else if (fi.isIndexed && fi.storeTermVector && fieldOption == IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR) {
-        fieldSet.add(fi.name);
+        fieldSet.add(fi.getId());
       }
       else if (fi.storePositionWithTermVector && fi.storeOffsetWithTermVector == false && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_POSITION) {
-        fieldSet.add(fi.name);
+        fieldSet.add(fi.getId());
       }
       else if (fi.storeOffsetWithTermVector && fi.storePositionWithTermVector == false && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET) {
-        fieldSet.add(fi.name);
+        fieldSet.add(fi.getId());
       }
       else if ((fi.storeOffsetWithTermVector && fi.storePositionWithTermVector) &&
                 fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET) {
-        fieldSet.add(fi.name);
+        fieldSet.add(fi.getId());
       }
     }
     return fieldSet;
@@ -475,11 +475,11 @@
       FieldInfo fi = fieldInfos.fieldInfo(i);
       if (fi.isIndexed && !fi.omitNorms) {
         Directory d = directory();
-        String fileName = si.getNormFileName(fi.number);
-        if (!si.hasSeparateNorms(fi.number)) {
+        String fileName = si.getNormFileName(fi.getIndex());
+        if (!si.hasSeparateNorms(fi.getIndex())) {
           d = cfsDir;
         }
-        norms.put(fi.name, new Norm(d.openInput(fileName), fi.number));
+        norms.put(fi.getId(), new Norm(d.openInput(fileName), fi.getIndex()));
       }
     }
   }
Index: src/java/org/apache/lucene/store/IndexOutput.java
===================================================================
--- src/java/org/apache/lucene/store/IndexOutput.java	(révision 493447)
+++ src/java/org/apache/lucene/store/IndexOutput.java	(copie de travail)
@@ -31,6 +31,17 @@
    */
   public abstract void writeByte(byte b) throws IOException;
 
+  /**
+   * Write a byte directly from an input stream.
+   * 
+   * @param in the stream to read
+   * @throws IOException
+   * @see #writeByte(byte)
+   */
+  public void writeByte(IndexInput in) throws IOException {
+    writeByte(in.readByte());
+  }
+
   /** Writes an array of bytes.
    * @param b the bytes to write
    * @param length the number of bytes to write
@@ -38,6 +49,20 @@
    */
   public abstract void writeBytes(byte[] b, int length) throws IOException;
 
+  /**
+   * Write a batch of bytes directly from an input stream.
+   * 
+   * @param in the stream to read
+   * @param length the number of bytes to write
+   * @throws IOException
+   * @see #writeBytes(byte[], int)
+   */
+  public void writeBytes(IndexInput in, long length) throws IOException {
+    while (length-- > 0) {
+      writeByte(in.readByte());
+    }
+  }
+  
   /** Writes an int as four bytes.
    * @see IndexInput#readInt()
    */
@@ -48,6 +73,20 @@
     writeByte((byte) i);
   }
 
+  /**
+   * Writes an int as four bytes directly from an input stream.
+   * 
+   * @param in the stream to read
+   * @throws IOException 
+   * @see #writeInt(int)
+   */
+  public void writeInt(IndexInput in) throws IOException {
+    writeByte(in.readByte());
+    writeByte(in.readByte());
+    writeByte(in.readByte());
+    writeByte(in.readByte());
+  }
+
   /** Writes an int in a variable-length format.  Writes between one and
    * five bytes.  Smaller values take fewer bytes.  Negative numbers are not
    * supported.
@@ -61,6 +100,22 @@
     writeByte((byte)i);
   }
 
+  /**
+   * Writes an int in a variable-length format directly from an input stream.
+   * 
+   * @param in the stream to read
+   * @throws IOException 
+   * @see #writeVInt(int)
+   */
+  public void writeVInt(IndexInput in) throws IOException {
+    byte b = in.readByte();
+    writeByte(b);
+    while ((b & 0x80) != 0) {
+      b = in.readByte();
+      writeByte(b);
+    }
+  }
+
   /** Writes a long as eight bytes.
    * @see IndexInput#readLong()
    */
@@ -69,6 +124,24 @@
     writeInt((int) i);
   }
 
+  /**
+   * Writes a long as eight bytes directly from an input stream.
+   * 
+   * @param in the stream to read
+   * @throws IOException 
+   * @see #writeLong(long)
+   */
+  public void writeLong(IndexInput in) throws IOException {
+    writeByte(in.readByte());
+    writeByte(in.readByte());
+    writeByte(in.readByte());
+    writeByte(in.readByte());
+    writeByte(in.readByte());
+    writeByte(in.readByte());
+    writeByte(in.readByte());
+    writeByte(in.readByte());
+  }
+
   /** Writes an long in a variable-length format.  Writes between one and five
    * bytes.  Smaller values take fewer bytes.  Negative numbers are not
    * supported.
@@ -82,6 +155,22 @@
     writeByte((byte)i);
   }
 
+  /**
+   * Writes an long in a variable-length format directly from an input stream.
+   * 
+   * @param in the stream to read
+   * @throws IOException 
+   * @see #writeVLong(long)
+   */
+  public void writeVLong(IndexInput in) throws IOException {
+    byte b = in.readByte();
+    writeByte(b);
+    while ((b & 0x80) != 0) {
+      b = in.readByte();
+      writeByte(b);
+    }
+  }
+
   /** Writes a string.
    * @see IndexInput#readString()
    */
@@ -91,6 +180,19 @@
     writeChars(s, 0, length);
   }
 
+  /**
+   * Writes a string directly from an input stream.
+   * 
+   * @param in the stream to read
+   * @throws IOException 
+   * @see #writeString(String)
+   */
+  public void writeString(IndexInput in) throws IOException {
+    int length = in.readVInt();
+    writeVInt(length);
+    writeChars(in, length);
+  }
+
   /** Writes a sequence of UTF-8 encoded characters from a string.
    * @param s the source of the characters
    * @param start the first character in the sequence
@@ -103,18 +205,40 @@
     for (int i = start; i < end; i++) {
       final int code = (int)s.charAt(i);
       if (code >= 0x01 && code <= 0x7F)
-	writeByte((byte)code);
+        writeByte((byte)code);
       else if (((code >= 0x80) && (code <= 0x7FF)) || code == 0) {
-	writeByte((byte)(0xC0 | (code >> 6)));
-	writeByte((byte)(0x80 | (code & 0x3F)));
+        writeByte((byte)(0xC0 | (code >> 6)));
+        writeByte((byte)(0x80 | (code & 0x3F)));
       } else {
-	writeByte((byte)(0xE0 | (code >>> 12)));
-	writeByte((byte)(0x80 | ((code >> 6) & 0x3F)));
-	writeByte((byte)(0x80 | (code & 0x3F)));
+        writeByte((byte)(0xE0 | (code >>> 12)));
+        writeByte((byte)(0x80 | ((code >> 6) & 0x3F)));
+        writeByte((byte)(0x80 | (code & 0x3F)));
       }
     }
   }
 
+  /**
+   * Writes a sequence of UTF-8 encoded characters directly from an input stream.
+   * 
+   * @param in the stream to read
+   * @param length the number of characters in the sequence
+   * @throws IOException 
+   * @see #writeChars(String,int,int)
+   */
+  public void writeChars(IndexInput in, int length)
+       throws IOException {
+    for (int i = 0; i < length; i++) {
+      byte b = in.readByte();
+      writeByte(b);
+      if ((b & 0x80) != 0) {
+        writeByte(in.readByte());
+        if ((b & 0xE0) == 0xE0) {
+          writeByte(in.readByte());
+        }
+      }
+    }
+  }
+
   /** Forces any buffered output to be written. */
   public abstract void flush() throws IOException;
 
