Index: src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java
===================================================================
--- src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java	(revision 585596)
+++ src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java	(working copy)
@@ -33,8 +33,6 @@
 
 public class ConcurrentMergeScheduler implements MergeScheduler {
 
-  public static boolean VERBOSE = false;
-
   private int mergeThreadPriority = -1;
 
   private List mergeThreads = new ArrayList();
@@ -44,6 +42,7 @@
   private Directory dir;
 
   private boolean closed;
+  private IndexWriter writer;
 
   public ConcurrentMergeScheduler() {
     if (allInstances != null) {
@@ -94,7 +93,8 @@
   }
 
   private void message(String message) {
-    System.out.println("CMS [" + Thread.currentThread().getName() + "]: " + message);
+    if (writer != null)
+      writer.message("CMS: " + message);
   }
 
   private synchronized void initMergeThreadPriority() {
@@ -110,11 +110,10 @@
 
   public synchronized void sync() {
     while(mergeThreadCount() > 0) {
-      if (VERBOSE) {
-        message("now wait for threads; currently " + mergeThreads.size() + " still running");
-        for(int i=0;i<mergeThreads.size();i++)
-          message("    " + i + ": " + ((MergeThread) mergeThreads.get(i)));
-      }
+      message("now wait for threads; currently " + mergeThreads.size() + " still running");
+      final int count = mergeThreads.size();
+      for(int i=0;i<count;i++)
+        message("    " + i + ": " + ((MergeThread) mergeThreads.get(i)));
 
       try {
         wait();
@@ -129,6 +128,8 @@
   public void merge(IndexWriter writer)
     throws CorruptIndexException, IOException {
 
+    this.writer = writer;
+
     initMergeThreadPriority();
 
     dir = writer.getDirectory();
@@ -140,10 +141,8 @@
     // these newly proposed merges will likely already be
     // registered.
 
-    if (VERBOSE) {
-      message("now merge");
-      message("  index: " + writer.segString());
-    }
+    message("now merge");
+    message("  index: " + writer.segString());
 
     // Iterate, pulling from the IndexWriter's queue of
     // pending merges, until its empty:
@@ -155,8 +154,7 @@
 
       MergePolicy.OneMerge merge = writer.getNextMerge();
       if (merge == null) {
-        if (VERBOSE)
-          message("  no more merges pending; now return");
+        message("  no more merges pending; now return");
         return;
       }
 
@@ -164,12 +162,10 @@
       // deterministic assignment of segment names
       writer.mergeInit(merge);
 
-      if (VERBOSE)
-        message("  consider merge " + merge.segString(dir));
+      message("  consider merge " + merge.segString(dir));
       
       if (merge.isExternal) {
-        if (VERBOSE)
-          message("    merge involves segments from an external directory; now run in foreground");
+        message("    merge involves segments from an external directory; now run in foreground");
       } else {
         synchronized(this) {
           if (mergeThreadCount() < maxThreadCount) {
@@ -177,8 +173,7 @@
             // merge:
             MergeThread merger = new MergeThread(writer, merge);
             mergeThreads.add(merger);
-            if (VERBOSE)
-              message("    launch new thread [" + merger.getName() + "]");
+            message("    launch new thread [" + merger.getName() + "]");
             try {
               merger.setPriority(mergeThreadPriority);
             } catch (NullPointerException npe) {
@@ -187,7 +182,7 @@
             }
             merger.start();
             continue;
-          } else if (VERBOSE)
+          } else
             message("    too many merge threads running; run merge in foreground");
         }
       }
@@ -225,8 +220,7 @@
       
       try {
 
-        if (VERBOSE)
-          message("  merge thread: start");
+        message("  merge thread: start");
 
         while(true) {
           setRunningMerge(merge);
@@ -237,14 +231,12 @@
           merge = writer.getNextMerge();
           if (merge != null) {
             writer.mergeInit(merge);
-            if (VERBOSE)
-              message("  merge thread: do another merge " + merge.segString(dir));
+            message("  merge thread: do another merge " + merge.segString(dir));
           } else
             break;
         }
 
-        if (VERBOSE)
-          message("  merge thread: done");
+        message("  merge thread: done");
 
       } catch (Throwable exc) {
         // When a merge was aborted & IndexWriter closed,
Index: src/java/org/apache/lucene/index/LogMergePolicy.java
===================================================================
--- src/java/org/apache/lucene/index/LogMergePolicy.java	(revision 585596)
+++ src/java/org/apache/lucene/index/LogMergePolicy.java	(working copy)
@@ -61,7 +61,13 @@
 
   private boolean useCompoundFile = true;
   private boolean useCompoundDocStore = true;
+  private IndexWriter writer;
 
+  private void message(String message) {
+    if (writer != null)
+      writer.message("LMP: " + message);
+  }
+
   /** <p>Returns the number of segments that are merged at
    * once and also controls the total number of segments
    * allowed to accumulate in the index.</p> */
@@ -211,6 +217,8 @@
   public MergeSpecification findMerges(SegmentInfos infos, IndexWriter writer) throws IOException {
 
     final int numSegments = infos.size();
+    this.writer = writer;
+    message("findMerges: " + numSegments + " segments");
 
     // Compute levels, which is just log (base mergeFactor)
     // of the size of each segment
@@ -284,6 +292,7 @@
         }
         upto--;
       }
+      message("  level " + levelBottom + " to " + maxLevel + ": " + (1+upto-start) + " segments");
 
       // Finally, record all merges that are viable at this level:
       int end = start + mergeFactor;
@@ -297,8 +306,11 @@
         if (!anyTooLarge) {
           if (spec == null)
             spec = new MergeSpecification();
+          message("    " + start + " to " + end + ": add this merge");
           spec.add(new OneMerge(infos.range(start, end), useCompoundFile));
-        }
+        } else
+          message("    " + start + " to " + end + ": contains segment over maxMergeSize or maxMergeDocs; skipping");
+
         start = end;
         end = start + mergeFactor;
       }
Index: src/java/org/apache/lucene/index/IndexWriter.java
===================================================================
--- src/java/org/apache/lucene/index/IndexWriter.java	(revision 585596)
+++ src/java/org/apache/lucene/index/IndexWriter.java	(working copy)
@@ -304,8 +304,14 @@
     }
   }
 
-  private void message(String message) {
-    infoStream.println("IW " + messageID + " [" + Thread.currentThread().getName() + "]: " + message);
+  /**
+   * Prints a message to the infoStream (if non-null),
+   * prefixed with the identifying information for this
+   * writer and the thread that's calling it.
+   */
+  public void message(String message) {
+    if (infoStream != null)
+      infoStream.println("IW " + messageID + " [" + Thread.currentThread().getName() + "]: " + message);
   }
 
   private synchronized void setMessageID() {
