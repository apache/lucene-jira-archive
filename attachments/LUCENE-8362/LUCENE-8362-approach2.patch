From 6f5339c1f774139149400fc4aa7d8f7212175e9a Mon Sep 17 00:00:00 2001
From: Atri Sharma <atris@amazon.com>
Date: Mon, 27 May 2019 17:57:25 +0530
Subject: [PATCH] LUCENE-8362: Introduction of Binary Range Query Type and
 corresponding Int query

---
 .../document/BinaryRangeDocValuesField.java   |  58 ++++++++
 .../document/BinaryRangeFieldRangeQuery.java  | 136 ++++++++++++++++++
 .../org/apache/lucene/document/IntRange.java  |  12 +-
 .../document/IntRangeDocValuesField.java      |  58 ++++++++
 .../document/IntRangeSlowRangeQuery.java      | 101 +++++++++++++
 .../lucene/search/TestDocValuesQueries.java   |  30 +++-
 6 files changed, 393 insertions(+), 2 deletions(-)
 create mode 100644 lucene/core/src/java/org/apache/lucene/document/BinaryRangeDocValuesField.java
 create mode 100644 lucene/core/src/java/org/apache/lucene/document/BinaryRangeFieldRangeQuery.java
 create mode 100644 lucene/core/src/java/org/apache/lucene/document/IntRangeDocValuesField.java
 create mode 100644 lucene/core/src/java/org/apache/lucene/document/IntRangeSlowRangeQuery.java

diff --git a/lucene/core/src/java/org/apache/lucene/document/BinaryRangeDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/BinaryRangeDocValuesField.java
new file mode 100644
index 0000000000..e523256b4b
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/document/BinaryRangeDocValuesField.java
@@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.document;
+
+import org.apache.lucene.util.BytesRef;
+
+public abstract class BinaryRangeDocValuesField extends BinaryDocValuesField {
+  public final String field;
+  public final byte[] min;
+  public final byte[] max;
+  public final int numDims;
+  public final int numBytesPerDimension;
+
+  public BinaryRangeDocValuesField(String field, byte[] min, byte[] max, int numDims, int numBytesPerDimension) {
+    super(field, buildFinalBytesRefInstance(min, max));
+    this.field = field;
+    this.min = min;
+    this.max = max;
+    this.numDims = numDims;
+    this.numBytesPerDimension = numBytesPerDimension;
+  }
+
+  private static BytesRef buildFinalBytesRefInstance(final byte[] min, final byte[] max) {
+    checkArgs(min, max);
+    byte[] finalArray = new byte[min.length + max.length];
+    System.arraycopy(min, 0, finalArray, 0, min.length);
+    System.arraycopy(max, 0, finalArray, min.length, max.length);
+
+    return new BytesRef(finalArray);
+  }
+
+  /**
+   * validate the arguments
+   */
+  private static void checkArgs(final byte[] min, final byte[] max) {
+    if (min == null || max == null || min.length == 0 || max.length == 0) {
+      throw new IllegalArgumentException("min/max range values cannot be null or empty");
+    }
+    if (min.length != max.length) {
+      throw new IllegalArgumentException("min/max ranges must agree");
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/document/BinaryRangeFieldRangeQuery.java b/lucene/core/src/java/org/apache/lucene/document/BinaryRangeFieldRangeQuery.java
new file mode 100644
index 0000000000..48ae5f8594
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/document/BinaryRangeFieldRangeQuery.java
@@ -0,0 +1,136 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.document;
+
+import java.io.IOException;
+import java.util.Objects;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.search.ConstantScoreScorer;
+import org.apache.lucene.search.ConstantScoreWeight;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.QueryVisitor;
+import org.apache.lucene.search.ScoreMode;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.Weight;
+import org.apache.lucene.util.DocIdSetBuilder;
+
+public abstract class BinaryRangeFieldRangeQuery extends Query {
+  private final String field;
+  private final byte[] min;
+  private final byte[] max;
+  private final int numBytesPerDimension;
+  private final int numDims;
+
+  BinaryRangeFieldRangeQuery(String field, byte[] min, byte[] max, int numBytesPerDimension, int numDims) {
+    this.field = field;
+    this.min = min;
+    this.max = max;
+    this.numBytesPerDimension = numBytesPerDimension;
+    this.numDims = numDims;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (sameClassAs(obj) == false) {
+      return false;
+    }
+    BinaryRangeFieldRangeQuery that = (BinaryRangeFieldRangeQuery) obj;
+    return Objects.equals(field, that.field)
+        && min == that.min
+        && max == that.max;
+  }
+
+  @Override
+  public int hashCode() {
+    int h = classHash();
+    h = 31 * h + field.hashCode();
+    h = 31 * h + min.hashCode();
+    h = 31 * h + max.hashCode();
+    return h;
+  }
+
+  @Override
+  public void visit(QueryVisitor visitor) {
+    if (visitor.acceptField(field)) {
+      visitor.visitLeaf(this);
+    }
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder b = new StringBuilder();
+    if (this.field.equals(field) == false) {
+      b.append(this.field).append(":");
+    }
+    return b
+        .append("[")
+        .append(min)
+        .append(" TO ")
+        .append(max)
+        .append("]")
+        .toString();
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    return super.rewrite(reader);
+  }
+
+  abstract public BinaryRangeDocValuesField getValues(LeafReader reader, String field) throws IOException;
+
+
+  @Override
+  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {
+    return new ConstantScoreWeight(this, boost) {
+
+      @Override
+      public Scorer scorer(LeafReaderContext context) throws IOException {
+        LeafReader reader = context.reader();
+
+        BinaryRangeDocValuesField values = getValues(context.reader(), field);
+        if (values == null) {
+          return null;
+        }
+
+        if (values.numDims != numDims) {
+          throw new IllegalArgumentException("field=\"" + field + "\" was indexed with numIndexDims="
+              + values.numDims + " but this query has numIndexDims=" + numDims);
+        }
+        if (values.numBytesPerDimension != numBytesPerDimension) {
+          throw new IllegalArgumentException("field=\"" + field + "\" was indexed with bytesPerDim="
+              + values.numDims + " but this query has bytesPerDim=" + numBytesPerDimension);
+        }
+
+        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());
+
+
+        return new ConstantScoreScorer(this, score(), scoreMode, result.build().iterator());
+      }
+
+      @Override
+      public boolean isCacheable(LeafReaderContext ctx) {
+        return true;
+      }
+
+    };
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/document/IntRange.java b/lucene/core/src/java/org/apache/lucene/document/IntRange.java
index 374d011b74..155b958c1d 100644
--- a/lucene/core/src/java/org/apache/lucene/document/IntRange.java
+++ b/lucene/core/src/java/org/apache/lucene/document/IntRange.java
@@ -109,7 +109,7 @@ public class IntRange extends Field {
   /**
    * Encodes the min, max ranges into a byte array
    */
-  private static byte[] encode(int[] min, int[] max) {
+  public static byte[] encode(int[] min, int[] max) {
     checkArgs(min, max);
     byte[] b = new byte[BYTES*2*min.length];
     verifyAndEncode(min, max, b);
@@ -138,6 +138,16 @@ public class IntRange extends Field {
     }
   }
 
+  //TODO: atris -- use this in verifyAndEncode
+  public static byte[] encodeArray(int[] val) {
+    byte[] resultArray = new byte[val.length * IntRange.BYTES];
+    for (int i = 0, j=0;i < val.length;i++, j+=IntRange.BYTES) {
+      encode(val[i], resultArray, j);
+    }
+
+    return resultArray;
+  }
+
   /** encode the given value into the byte array at the defined offset */
   private static void encode(int val, byte[] bytes, int offset) {
     NumericUtils.intToSortableBytes(val, bytes, offset);
diff --git a/lucene/core/src/java/org/apache/lucene/document/IntRangeDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/IntRangeDocValuesField.java
new file mode 100644
index 0000000000..13230de2c3
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/document/IntRangeDocValuesField.java
@@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.document;
+
+import org.apache.lucene.search.Query;
+
+/**
+ * DocValues field for IntRange. This is a single valued field
+ * due to being an extension of BinaryDocValuesField.
+ */
+public class IntRangeDocValuesField extends BinaryRangeDocValuesField{
+  final String field;
+  final int[] min;
+  final int[] max;
+
+  public IntRangeDocValuesField(String field, final int[] min, final int[] max) {
+    super(field, IntRange.encodeArray(min), IntRange.encodeArray(max), min.length, IntRange.BYTES);
+
+    this.field = field;
+    this.min = min;
+    this.max = max;
+  }
+
+  public int getMin(int dimension) {
+    if (dimension > 4 || dimension > min.length) {
+      throw new IllegalArgumentException("Dimension out of valid range");
+    }
+
+    return min[dimension];
+  }
+
+  public int getMax(int dimension) {
+    if (dimension > 4 || dimension > min.length) {
+      throw new IllegalArgumentException("Dimension out of valid range");
+    }
+
+    return max[dimension];
+  }
+
+  public static Query newSlowRangeQuery(String field, final int[] min, final int[] max) {
+    return new IntRangeSlowRangeQuery(field, min, max);
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/document/IntRangeSlowRangeQuery.java b/lucene/core/src/java/org/apache/lucene/document/IntRangeSlowRangeQuery.java
new file mode 100644
index 0000000000..6c170afc01
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/document/IntRangeSlowRangeQuery.java
@@ -0,0 +1,101 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.document;
+
+import java.io.IOException;
+import java.util.Objects;
+
+import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.NumericDocValues;
+import org.apache.lucene.index.SortedNumericDocValues;
+import org.apache.lucene.search.ConstantScoreScorer;
+import org.apache.lucene.search.ConstantScoreWeight;
+import org.apache.lucene.search.DocValuesFieldExistsQuery;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.QueryVisitor;
+import org.apache.lucene.search.ScoreMode;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.Weight;
+
+public class IntRangeSlowRangeQuery extends BinaryRangeFieldRangeQuery {
+  private final String field;
+  private final int[] min;
+  private final int[] max;
+
+  IntRangeSlowRangeQuery(String field, int[] min, int[] max) {
+    super(field, IntRange.encodeArray(min), IntRange.encodeArray(max), IntRange.BYTES, min.length);
+    this.field = field;
+    this.min = min;
+    this.max = max;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (sameClassAs(obj) == false) {
+      return false;
+    }
+    IntRangeSlowRangeQuery that = (IntRangeSlowRangeQuery) obj;
+    return Objects.equals(field, that.field)
+        && min == that.min
+        && max == that.max;
+  }
+
+  @Override
+  public int hashCode() {
+    int h = classHash();
+    h = 31 * h + field.hashCode();
+    h = 31 * h + min.hashCode();
+    h = 31 * h + max.hashCode();
+    return h;
+  }
+
+  @Override
+  public void visit(QueryVisitor visitor) {
+    if (visitor.acceptField(field)) {
+      visitor.visitLeaf(this);
+    }
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder b = new StringBuilder();
+    if (this.field.equals(field) == false) {
+      b.append(this.field).append(":");
+    }
+    return b
+        .append("[")
+        .append(min)
+        .append(" TO ")
+        .append(max)
+        .append("]")
+        .toString();
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    return super.rewrite(reader);
+  }
+
+  public BinaryRangeDocValuesField getValues(LeafReader reader, String field) throws IOException {
+    return new IntRangeDocValuesField(field, this.min, this.max);
+  }
+}
\ No newline at end of file
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestDocValuesQueries.java b/lucene/core/src/test/org/apache/lucene/search/TestDocValuesQueries.java
index 0664709c47..3789d757a1 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestDocValuesQueries.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestDocValuesQueries.java
@@ -20,6 +20,7 @@ import java.io.IOException;
 import java.util.Arrays;
 
 import org.apache.lucene.document.Document;
+import org.apache.lucene.document.IntRangeDocValuesField;
 import org.apache.lucene.document.LongPoint;
 import org.apache.lucene.document.NumericDocValuesField;
 import org.apache.lucene.document.SortedDocValuesField;
@@ -267,5 +268,32 @@ public class TestDocValuesQueries extends LuceneTestCase {
     reader.close();
     dir.close();
   }
-   
+
+  public void testIntRangeDocValuesRangeQuery() throws IOException {
+    Directory dir = newDirectory();
+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
+    final int iters = atLeast(10);
+    int[] min = {3, 11, 17};
+    int[] max = {27, 35, 49};
+    for (int i = 0; i < iters; ++i) {
+      Document doc = new Document();
+      doc.add(new IntRangeDocValuesField("dv", min, max));
+      iw.addDocument(doc);
+    }
+    iw.commit();
+
+    final IndexReader reader = iw.getReader();
+    final IndexSearcher searcher = newSearcher(reader);
+    iw.close();
+
+    final int[] lowRange = {6, 17, 19};
+    final int[] highRange = {29, 33, 42};
+
+    Query query = IntRangeDocValuesField.newSlowRangeQuery("dv", lowRange, highRange);
+    // TODO: assert expected matches
+    TopDocs topDocs = searcher.search(query, searcher.reader.maxDoc());
+
+    reader.close();
+    dir.close();
+  }
 }
-- 
2.17.2 (Apple Git-113)

