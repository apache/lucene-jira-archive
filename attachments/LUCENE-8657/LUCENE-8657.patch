diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymMap.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymMap.java
index 97db1deb3e..05a3f9a20d 100644
--- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymMap.java
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymMap.java
@@ -230,8 +230,8 @@ public class SynonymMap {
       final byte[] spare = new byte[5];
       
       Set<CharsRef> keys = workingSet.keySet();
-      CharsRef sortedKeys[] = keys.toArray(new CharsRef[keys.size()]);
-      Arrays.sort(sortedKeys, CharsRef.getUTF16SortedAsUTF8Comparator());
+      CharsRef[] sortedKeys = keys.toArray(new CharsRef[0]);
+      Arrays.sort(sortedKeys);
 
       final IntsRefBuilder scratchIntsRef = new IntsRefBuilder();
       
diff --git a/lucene/core/src/java/org/apache/lucene/util/CharsRef.java b/lucene/core/src/java/org/apache/lucene/util/CharsRef.java
index 7cb8ce900c..00c699e9c8 100644
--- a/lucene/core/src/java/org/apache/lucene/util/CharsRef.java
+++ b/lucene/core/src/java/org/apache/lucene/util/CharsRef.java
@@ -17,8 +17,6 @@
 package org.apache.lucene.util;
 
 
-import java.util.Comparator;
-
 /**
  * Represents char[], as a slice (offset + length) into an existing char[].
  * The {@link #chars} member should never be null; use
@@ -110,11 +108,40 @@ public final class CharsRef implements Comparable<CharsRef>, CharSequence, Clone
                                other.chars, other.offset, other.offset + other.length);
   }
 
-  /** Signed int order comparison */
+  /* In UTF-8 order */
   @Override
   public int compareTo(CharsRef other) {
-    return FutureArrays.compare(this.chars, this.offset, this.offset + this.length, 
-                                other.chars, other.offset, other.offset + other.length);
+    int aEnd = this.offset + this.length;
+    int bEnd = other.offset + other.length;
+    int i = FutureArrays.mismatch(this.chars, this.offset, aEnd,
+        other.chars, other.offset, bEnd);
+
+    if (i >= 0 && i < Math.min(this.length, other.length)) {
+      // http://icu-project.org/docs/papers/utf16_code_point_order.html
+
+      char aChar = this.chars[this.offset + i];
+      char bChar = other.chars[other.offset + i];
+      /* aChar != bChar, fix up each one if they're both in or above the surrogate range, then compare them */
+      if (aChar >= 0xd800 && bChar >= 0xd800) {
+        if (aChar >= 0xe000) {
+          aChar -= 0x800;
+        } else {
+          aChar += 0x2000;
+        }
+
+        if (bChar >= 0xe000) {
+          bChar -= 0x800;
+        } else {
+          bChar += 0x2000;
+        }
+      }
+
+      /* now aChar and bChar are in code point order */
+      return (int)aChar - (int)bChar; /* int must be 32 bits wide */
+    }
+
+    // One is a prefix of the other, or, they are equal:
+    return this.length - other.length;
   }
 
   @Override
@@ -141,58 +168,6 @@ public final class CharsRef implements Comparable<CharsRef>, CharSequence, Clone
     return new CharsRef(chars, offset + start, end - start);
   }
   
-  /** @deprecated This comparator is only a transition mechanism */
-  @Deprecated
-  private final static Comparator<CharsRef> utf16SortedAsUTF8SortOrder = new UTF16SortedAsUTF8Comparator();
-  
-  /** @deprecated This comparator is only a transition mechanism */
-  @Deprecated
-  public static Comparator<CharsRef> getUTF16SortedAsUTF8Comparator() {
-    return utf16SortedAsUTF8SortOrder;
-  }
-  
-  /** @deprecated This comparator is only a transition mechanism */
-  @Deprecated
-  private static class UTF16SortedAsUTF8Comparator implements Comparator<CharsRef> {
-    // Only singleton
-    private UTF16SortedAsUTF8Comparator() {};
-
-    @Override
-    public int compare(CharsRef a, CharsRef b) {
-      int aEnd = a.offset + a.length;
-      int bEnd = b.offset + b.length;
-      int i = FutureArrays.mismatch(a.chars, a.offset, aEnd, 
-                                    b.chars, b.offset, bEnd);
-
-      if (i >= 0 && i < Math.min(a.length, b.length)) {
-        // http://icu-project.org/docs/papers/utf16_code_point_order.html
-
-        char aChar = a.chars[a.offset + i];
-        char bChar = b.chars[b.offset + i];        
-        /* aChar != bChar, fix up each one if they're both in or above the surrogate range, then compare them */
-        if (aChar >= 0xd800 && bChar >= 0xd800) {
-          if (aChar >= 0xe000) {
-            aChar -= 0x800;
-          } else {
-            aChar += 0x2000;
-          }
-          
-          if (bChar >= 0xe000) {
-            bChar -= 0x800;
-          } else {
-            bChar += 0x2000;
-          }
-        }
-
-        /* now aChar and bChar are in code point order */
-        return (int)aChar - (int)bChar; /* int must be 32 bits wide */
-      }
-
-      // One is a prefix of the other, or, they are equal:
-      return a.length - b.length;
-    }
-  }
-  
   /**
    * Creates a new CharsRef that points to a copy of the chars from 
    * <code>other</code>
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java b/lucene/core/src/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java
index 3757e82a3c..93102979ad 100644
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java
@@ -215,12 +215,6 @@ public final class DaciukMihovAutomatonBuilder {
    */
   private CharsRef previous;
 
-  /**
-   * A comparator used for enforcing sorted UTF8 order, used in assertions only.
-   */
-  @SuppressWarnings("deprecation")
-  private static final Comparator<CharsRef> comparator = CharsRef.getUTF16SortedAsUTF8Comparator();
-
   /**
    * Add another character sequence to this automaton. The sequence must be
    * lexicographically larger or equal compared to any previous sequences added
@@ -232,7 +226,7 @@ public final class DaciukMihovAutomatonBuilder {
     }
     assert stateRegistry != null : "Automaton already built.";
     assert previous == null
-        || comparator.compare(previous, current) <= 0 : "Input must be in sorted UTF-8 order: "
+        || previous.compareTo(current) <= 0 : "Input must be in sorted UTF-8 order: "
         + previous + " >= " + current;
     assert setPrevious(current);
 
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestCharsRef.java b/lucene/core/src/test/org/apache/lucene/util/TestCharsRef.java
index 079b3b774b..b939924088 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestCharsRef.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestCharsRef.java
@@ -32,7 +32,7 @@ public class TestCharsRef extends LuceneTestCase {
     }
     
     Arrays.sort(utf8);
-    Arrays.sort(utf16, CharsRef.getUTF16SortedAsUTF8Comparator());
+    Arrays.sort(utf16);
     
     for (int i = 0; i < numStrings; i++) {
       assertEquals(utf8[i].utf8ToString(), utf16[i].toString());
