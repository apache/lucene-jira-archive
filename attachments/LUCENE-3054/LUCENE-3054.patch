Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 1098624)
+++ lucene/CHANGES.txt	(working copy)
@@ -491,6 +491,11 @@
   very special use cases of the TokenStream-API, most users would not
   have recognized it.  (Uwe Schindler, Robert Muir)
 
+* LUCENE-3054: PhraseQuery can in some cases stack overflow in
+  SorterTemplate.quickSort(). This fix also adds an optimization to
+  PhraseQuery as term with lower doc freq will also have less positions.
+  (Uwe Schindler, Robert Muir, Otis Gospodnetic)
+
 ======================= Lucene 3.1.0 =======================
 
 Changes in backwards compatibility policy
Index: lucene/src/java/org/apache/lucene/search/MultiPhraseQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/MultiPhraseQuery.java	(revision 1098624)
+++ lucene/src/java/org/apache/lucene/search/MultiPhraseQuery.java	(working copy)
@@ -214,7 +214,7 @@
           docFreq = reader.docFreq(term.field(), term.bytes());
         }
 
-        postingsFreqs[pos] = new PhraseQuery.PostingsAndFreq(postingsEnum, docFreq, positions.get(pos).intValue());
+        postingsFreqs[pos] = new PhraseQuery.PostingsAndFreq(postingsEnum, docFreq, positions.get(pos).intValue(), terms[0]);
       }
 
       // sort by increasing docFreq order
Index: lucene/src/java/org/apache/lucene/search/PhraseQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/PhraseQuery.java	(revision 1098624)
+++ lucene/src/java/org/apache/lucene/search/PhraseQuery.java	(working copy)
@@ -124,16 +124,48 @@
     final DocsAndPositionsEnum postings;
     final int docFreq;
     final int position;
+    final Term term;
 
-    public PostingsAndFreq(DocsAndPositionsEnum postings, int docFreq, int position) {
+    public PostingsAndFreq(DocsAndPositionsEnum postings, int docFreq, int position, Term term) {
       this.postings = postings;
       this.docFreq = docFreq;
       this.position = position;
+      this.term = term;
     }
 
     public int compareTo(PostingsAndFreq other) {
+      if (docFreq == other.docFreq) {
+        if (position == other.position) {
+          return term.compareTo(other.term);
+        }
+        return position - other.position;
+      }
       return docFreq - other.docFreq;
     }
+
+    @Override
+    public int hashCode() {
+      final int prime = 31;
+      int result = 1;
+      result = prime * result + docFreq;
+      result = prime * result + position;
+      result = prime * result + ((term == null) ? 0 : term.hashCode());
+      return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (this == obj) return true;
+      if (obj == null) return false;
+      if (getClass() != obj.getClass()) return false;
+      PostingsAndFreq other = (PostingsAndFreq) obj;
+      if (docFreq != other.docFreq) return false;
+      if (position != other.position) return false;
+      if (term == null) {
+        if (other.term != null) return false;
+      } else if (!term.equals(other.term)) return false;
+      return true;
+    }
   }
 
   private class PhraseWeight extends Weight {
@@ -197,7 +229,7 @@
             return null;
           }
         }
-        postingsFreqs[i] = new PostingsAndFreq(postingsEnum, reader.docFreq(t.field(), t.bytes()), positions.get(i).intValue());
+        postingsFreqs[i] = new PostingsAndFreq(postingsEnum, reader.docFreq(t.field(), t.bytes()), positions.get(i).intValue(), t);
       }
 
       // sort by increasing docFreq order
Index: lucene/src/java/org/apache/lucene/util/SorterTemplate.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/SorterTemplate.java	(revision 1098624)
+++ lucene/src/java/org/apache/lucene/util/SorterTemplate.java	(working copy)
@@ -30,6 +30,7 @@
 public abstract class SorterTemplate {
 
   private static final int MERGESORT_THRESHOLD = 12;
+  private static final int MERGE_TO_QUICKSORT_THRESHOLD = 40;
   private static final int QUICKSORT_THRESHOLD = 7;
 
   /** Implement this method, that swaps slots {@code i} and {@code j} in your data */
@@ -63,6 +64,10 @@
   /** Sorts via in-place, but unstable, QuickSort algorithm.
    * For small collections falls back to {@link #insertionSort(int,int)}. */
   public final void quickSort(int lo, int hi) {
+    quickSort(lo, hi, MERGE_TO_QUICKSORT_THRESHOLD);
+  }
+  
+  private void quickSort(int lo, int hi, int maxDepth) {
     final int diff = hi - lo;
     if (diff <= QUICKSORT_THRESHOLD) {
       insertionSort(lo, hi);
@@ -101,8 +106,16 @@
       }
     }
 
-    quickSort(lo, left);
-    quickSort(left + 1, hi);
+    // fall back to merge sort when recursion depth gets too big
+    if (maxDepth == 0) {
+      // for testing: new Exception("Hit recursion depth limit").printStackTrace();
+      mergeSort(lo, left);
+      mergeSort(left + 1, hi);
+    } else {
+      --maxDepth;
+      quickSort(lo, left, maxDepth);
+      quickSort(left + 1, hi, maxDepth);
+    }
   }
   
   /** Sorts via stable in-place MergeSort algorithm
Index: lucene/src/test/org/apache/lucene/util/TestArrayUtil.java
===================================================================
--- lucene/src/test/org/apache/lucene/util/TestArrayUtil.java	(revision 1098624)
+++ lucene/src/test/org/apache/lucene/util/TestArrayUtil.java	(working copy)
@@ -144,6 +144,24 @@
     }
   }
   
+  private Integer[] createSparseRandomArray(int maxSize) {
+    final Integer[] a = new Integer[random.nextInt(maxSize) + 1];
+    for (int i = 0; i < a.length; i++) {
+      a[i] = Integer.valueOf(random.nextInt(2));
+    }
+    return a;
+  }
+  
+  // This is a test for LUCENE-3054 (which fails without the merge sort fall back with stack overflow in most cases)
+  public void testQuickToMergeSortFallback() {
+    for (int i = 0, c = 500 * RANDOM_MULTIPLIER; i < c; i++) {
+      Integer[] a1 = createSparseRandomArray(40000), a2 = a1.clone();
+      ArrayUtil.quickSort(a1);
+      Arrays.sort(a2);
+      assertArrayEquals(a2, a1);
+    }
+  }
+  
   public void testMergeSort() {
     for (int i = 0, c = 500 * RANDOM_MULTIPLIER; i < c; i++) {
       Integer[] a1 = createRandomArray(1000), a2 = a1.clone();
