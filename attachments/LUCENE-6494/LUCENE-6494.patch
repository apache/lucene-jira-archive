Index: lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java	(revision 1685577)
+++ lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java	(working copy)
@@ -17,32 +17,18 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReaderContext;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.DisjunctionMaxQuery;
-import org.apache.lucene.search.FilteredQuery;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MultiPhraseQuery;
-import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.spans.SpanQueryWrapper;
 import org.apache.lucene.search.spans.SpanWeight;
 import org.apache.lucene.search.spans.Spans;
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-
 /**
  * Experimental class to get set of payloads for most standard Lucene queries.
  * Operates like Highlighter - IndexReader should only contain doc of interest,
@@ -52,6 +38,7 @@
  * 
  */
 public class PayloadSpanUtil {
+
   private IndexReaderContext context;
 
   /**
@@ -72,128 +59,22 @@
    * @throws IOException if there is a low-level I/O error
    */
   public Collection<byte[]> getPayloadsForQuery(Query query) throws IOException {
-    Collection<byte[]> payloads = new ArrayList<>();
-    queryToSpanQuery(query, payloads);
-    return payloads;
-  }
 
-  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)
-      throws IOException {
-    if (query instanceof BooleanQuery) {
-      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();
-
-      for (int i = 0; i < queryClauses.length; i++) {
-        if (!queryClauses[i].isProhibited()) {
-          queryToSpanQuery(queryClauses[i].getQuery(), payloads);
-        }
-      }
-
-    } else if (query instanceof PhraseQuery) {
-      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();
-      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];
-      for (int i = 0; i < phraseQueryTerms.length; i++) {
-        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);
-      }
-
-      int slop = ((PhraseQuery) query).getSlop();
-      boolean inorder = false;
-
-      if (slop == 0) {
-        inorder = true;
-      }
-
-      SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);
-      sp.setBoost(query.getBoost());
-      getPayloads(payloads, sp);
-    } else if (query instanceof TermQuery) {
-      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());
-      stq.setBoost(query.getBoost());
-      getPayloads(payloads, stq);
-    } else if (query instanceof SpanQuery) {
-      getPayloads(payloads, (SpanQuery) query);
-    } else if (query instanceof FilteredQuery) {
-      queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);
-    } else if (query instanceof DisjunctionMaxQuery) {
-
-      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator
-          .hasNext();) {
-        queryToSpanQuery(iterator.next(), payloads);
-      }
-
-    } else if (query instanceof MultiPhraseQuery) {
-      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;
-      final List<Term[]> termArrays = mpq.getTermArrays();
-      final int[] positions = mpq.getPositions();
-      if (positions.length > 0) {
-
-        int maxPosition = positions[positions.length - 1];
-        for (int i = 0; i < positions.length - 1; ++i) {
-          if (positions[i] > maxPosition) {
-            maxPosition = positions[i];
-          }
-        }
-
-        @SuppressWarnings({"rawtypes","unchecked"}) final List<Query>[] disjunctLists =
-            new List[maxPosition + 1];
-        int distinctPositions = 0;
-
-        for (int i = 0; i < termArrays.size(); ++i) {
-          final Term[] termArray = termArrays.get(i);
-          List<Query> disjuncts = disjunctLists[positions[i]];
-          if (disjuncts == null) {
-            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(
-                termArray.length));
-            ++distinctPositions;
-          }
-          for (final Term term : termArray) {
-            disjuncts.add(new SpanTermQuery(term));
-          }
-        }
-
-        int positionGaps = 0;
-        int position = 0;
-        final SpanQuery[] clauses = new SpanQuery[distinctPositions];
-        for (int i = 0; i < disjunctLists.length; ++i) {
-          List<Query> disjuncts = disjunctLists[i];
-          if (disjuncts != null) {
-            clauses[position++] = new SpanOrQuery(disjuncts
-                .toArray(new SpanQuery[disjuncts.size()]));
-          } else {
-            ++positionGaps;
-          }
-        }
-
-        final int slop = mpq.getSlop();
-        final boolean inorder = (slop == 0);
-
-        SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps,
-                                                      inorder);
-        sp.setBoost(query.getBoost());
-        getPayloads(payloads, sp);
-      }
-    }
-  }
-
-  private void getPayloads(Collection<byte []> payloads, SpanQuery query)
-      throws IOException {
-
-    final IndexSearcher searcher = new IndexSearcher(context);
+    IndexSearcher searcher = new IndexSearcher(context);
     searcher.setQueryCache(null);
 
-    SpanWeight w = (SpanWeight) searcher.createNormalizedWeight(query, false);
+    SpanQueryWrapper spanwrapper = new SpanQueryWrapper(query, searcher, SpanWeight.Postings.PAYLOADS);
+    Spans spans = spanwrapper.advanceTo(0);
 
+    Collection<byte[]> payloads = new ArrayList<>();
     PayloadSpanCollector collector = new PayloadSpanCollector();
-    for (LeafReaderContext leafReaderContext : context.leaves()) {
-      final Spans spans = w.getSpans(leafReaderContext, leafReaderContext.reader().getLiveDocs(), SpanWeight.Postings.PAYLOADS);
-      if (spans != null) {
-        while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-          while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-            collector.reset();
-            spans.collect(collector);
-            payloads.addAll(collector.getPayloads());
-          }
-        }
-      }
+    while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+      collector.reset();
+      spans.collect(collector);
+      payloads.addAll(collector.getPayloads());
     }
+
+    return payloads;
   }
+
 }
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanQueryWrapper.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanQueryWrapper.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanQueryWrapper.java	(working copy)
@@ -0,0 +1,328 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.ReaderUtil;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.DisjunctionMaxQuery;
+import org.apache.lucene.search.FilteredQuery;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.util.PriorityQueue;
+
+/**
+ * Utility class to convert arbitrary queries to SpanQueries, so that postings
+ * data can be collected from matches by SpanCollectors.
+ *
+ * Currently works with the following queries:
+ * <ul>
+ *   <li>TermQuery</li>
+ *   <li>BooleanQuery</li>
+ *   <li>DisjunctionMaxQuery</li>
+ *   <li>FilteredQuery</li>
+ *   <li>SpanQuery</li>
+ *   <li>PhraseQuery</li>
+ *   <li>MultiPhraseQuery</li>
+ *   <li>MultiTermQuery</li>
+ * </ul>
+ *
+ * Override the {@link #rewriteToSpanQueries(Query, List)} method to add other
+ * queries to this list
+ *
+ * WARNING: This should only be used to extract matching Spans for a document
+ * that is already known to match the query.  SpanQueryWrapper does not translate
+ * BooleanQuery MUST_NOT clauses into matching spans, and so may produce incorrect
+ * hits.
+ */
+public class SpanQueryWrapper {
+
+  private final List<SpanWeight> weights = new ArrayList<>();
+  private final IndexSearcher searcher;
+  private final SpanWeight.Postings postings;
+
+  /**
+   * Create a new SpanQueryWrapper for a query
+   * @param query the query to wrap
+   * @param searcher the searcher to query against
+   * @param postings what postings information should be made available by the Spans
+   * @throws IOException on error
+   */
+  public SpanQueryWrapper(Query query, IndexSearcher searcher, SpanWeight.Postings postings) throws IOException {
+
+    this.searcher = searcher;
+    this.postings = postings;
+
+    List<SpanQuery> convertedQueries = new ArrayList<>();
+    rewriteToSpanQueries(query, convertedQueries);
+
+    for (SpanQuery q : convertedQueries) {
+      SpanQuery rewritten = (SpanQuery) q.rewrite(searcher.getIndexReader());
+      weights.add(rewritten.createWeight(searcher, false));
+    }
+
+  }
+
+  /**
+   * Pull a Spans that will iterate over the matches on the given document
+   *
+   * WARNING: The returned Spans does not support document iteration
+   *
+   * @param doc the docid of the document to pull matches from
+   * @return a matching Spans
+   * @throws IOException on error
+   */
+  public Spans advanceTo(int doc) throws IOException {
+    int leaf = ReaderUtil.subIndex(doc, searcher.getTopReaderContext().leaves());
+    LeafReaderContext ctx = searcher.getIndexReader().leaves().get(leaf);
+    int rebasedDoc = doc - ctx.docBase;
+
+    FieldSpanPositionQueue queue = new FieldSpanPositionQueue(weights.size());
+    for (SpanWeight w : weights) {
+      Spans spans = w.getSpans(ctx, ctx.reader().getLiveDocs(), postings);
+      if (spans.advance(rebasedDoc) == rebasedDoc) {
+        spans.nextStartPosition();
+        queue.add(new FieldSpans(w.field, spans));
+      }
+    }
+
+    return new WrappedSpans(queue);
+  }
+
+  private static class WrappedSpans extends Spans {
+
+    final FieldSpanPositionQueue queue;
+    boolean cached = true;
+
+    private WrappedSpans(FieldSpanPositionQueue queue) {
+      this.queue = queue;
+    }
+
+    @Override
+    public int nextStartPosition() throws IOException {
+
+      if (this.queue.size() == 0)
+        return Spans.NO_MORE_POSITIONS;
+
+      if (cached) {
+        cached = false;
+        return this.queue.top().spans.startPosition();
+      }
+
+      if (this.queue.top().spans.startPosition() == Spans.NO_MORE_POSITIONS)
+        return Spans.NO_MORE_POSITIONS;
+
+      if (this.queue.top().spans.nextStartPosition() == Spans.NO_MORE_POSITIONS) {
+        this.queue.pop();
+        if (this.queue.size() == 0)
+          return Spans.NO_MORE_POSITIONS;
+      }
+
+      this.queue.updateTop();
+      return this.queue.top().spans.startPosition();
+    }
+
+    @Override
+    public int startPosition() {
+      return this.queue.top().spans.startPosition();
+    }
+
+    @Override
+    public int endPosition() {
+      return this.queue.top().spans.endPosition();
+    }
+
+    @Override
+    public void collect(SpanCollector collector) throws IOException {
+      this.queue.top().spans.collect(collector);
+    }
+
+    @Override
+    public int docID() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public long cost() {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+  private static class FieldSpans {
+    final String field;
+    final Spans spans;
+
+    private FieldSpans(String field, Spans spans) {
+      this.field = field;
+      this.spans = spans;
+    }
+  }
+
+  private static class FieldSpanPositionQueue extends PriorityQueue<FieldSpans> {
+
+    public FieldSpanPositionQueue(int maxSize) {
+      super(maxSize);
+    }
+
+    @Override
+    protected boolean lessThan(FieldSpans a, FieldSpans b) {
+      int c = a.field.compareTo(b.field);
+      if (c != 0)
+        return c < 0;
+      int start1 = a.spans.startPosition();
+      int start2 = b.spans.startPosition();
+      return (start1 < start2) || ((start1 == start2) && a.spans.endPosition() < b.spans.endPosition());
+    }
+  }
+
+  /**
+   * Convert the passed in query to a list of SpanQueries
+   * @param q the query
+   * @param rewrittenQueries a list to receive rewritten SpanQueries
+   */
+  protected void rewriteToSpanQueries(Query q, List<SpanQuery> rewrittenQueries) {
+    if (q instanceof SpanQuery) {
+      rewrittenQueries.add((SpanQuery)q);
+    }
+    else if (q instanceof TermQuery) {
+      rewrittenQueries.add(new SpanTermQuery(((TermQuery) q).getTerm()));
+    }
+    else if (q instanceof FilteredQuery) {
+      rewriteToSpanQueries(((FilteredQuery) q).getQuery(), rewrittenQueries);
+    }
+    else if (q instanceof BooleanQuery) {
+      for (BooleanClause clause : (BooleanQuery) q) {
+        rewriteToSpanQueries(clause.getQuery(), rewrittenQueries);
+      }
+    }
+    else if (q instanceof DisjunctionMaxQuery) {
+      for (Query clause : (DisjunctionMaxQuery) q) {
+        rewriteToSpanQueries(clause, rewrittenQueries);
+      }
+    }
+    else if (q instanceof MultiTermQuery) {
+      rewrittenQueries.add(new SpanMultiTermQueryWrapper<>((MultiTermQuery) q));
+    }
+    else if (q instanceof PhraseQuery) {
+      rewrittenQueries.add(rewritePhraseQuery((PhraseQuery)q));
+    }
+    else if (q instanceof MultiPhraseQuery) {
+      rewrittenQueries.add(rewriteMultiPhraseQuery((MultiPhraseQuery)q));
+    }
+  }
+
+  /**
+   * Rewrites a PhraseQuery into a SpanNearQuery
+   * @param q a PhraseQuery
+   * @return an equivalent SpanNearQuery
+   */
+  protected SpanQuery rewritePhraseQuery(PhraseQuery q) {
+    Term[] phraseQueryTerms = q.getTerms();
+    SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];
+    for (int i = 0; i < phraseQueryTerms.length; i++) {
+      clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);
+    }
+
+    int slop = q.getSlop();
+    boolean inorder = false;
+
+    if (slop == 0) {
+      inorder = true;
+    }
+
+    SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);
+    sp.setBoost(q.getBoost());
+    return sp;
+  }
+
+  /**
+   * Rewrites a MultiPhraseQuery into a SpanNearQuery
+   * @param mpq a MultiPhraseQuery
+   * @return an equivalent SpanNearQuery
+   */
+  protected SpanQuery rewriteMultiPhraseQuery(MultiPhraseQuery mpq) {
+
+    final List<Term[]> termArrays = mpq.getTermArrays();
+    final int[] positions = mpq.getPositions();
+    if (positions.length == 0) {
+      return new SpanOrQuery();
+    }
+
+    int maxPosition = positions[positions.length - 1];
+    for (int i = 0; i < positions.length - 1; ++i) {
+      if (positions[i] > maxPosition) {
+        maxPosition = positions[i];
+      }
+    }
+
+    @SuppressWarnings({"rawtypes","unchecked"})
+    final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];
+    int distinctPositions = 0;
+
+    for (int i = 0; i < termArrays.size(); ++i) {
+      final Term[] termArray = termArrays.get(i);
+      List<SpanQuery> disjuncts = disjunctLists[positions[i]];
+      if (disjuncts == null) {
+        disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));
+        ++distinctPositions;
+      }
+      for (final Term term : termArray) {
+        disjuncts.add(new SpanTermQuery(term));
+      }
+    }
+
+    int positionGaps = 0;
+    int position = 0;
+    final SpanQuery[] clauses = new SpanQuery[distinctPositions];
+    for (List<SpanQuery> disjuncts : disjunctLists) {
+      if (disjuncts != null) {
+        clauses[position++] = new SpanOrQuery(disjuncts.toArray(new SpanQuery[disjuncts.size()]));
+      } else {
+        ++positionGaps;
+      }
+    }
+
+    final int slop = mpq.getSlop();
+    final boolean inorder = (slop == 0);
+
+    SpanNearQuery sp = new SpanNearQuery(clauses, slop + positionGaps, inorder);
+    sp.setBoost(mpq.getBoost());
+    return sp;
+  }
+
+}

Property changes on: lucene/core/src/java/org/apache/lucene/search/spans/SpanQueryWrapper.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java	(revision 1685577)
+++ lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java	(working copy)
@@ -16,6 +16,13 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.io.StringReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.analysis.TokenFilter;
@@ -28,7 +35,6 @@
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.IndexSearcher;
@@ -48,13 +54,6 @@
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
 
-import java.io.IOException;
-import java.io.StringReader;
-import java.nio.charset.StandardCharsets;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
-
 public class TestPayloadSpans extends LuceneTestCase {
   private IndexSearcher searcher;
   private Similarity similarity = new DefaultSimilarity();
@@ -410,6 +409,8 @@
         System.out.println(new String(bytes, StandardCharsets.UTF_8));
       }
     }
+    assertEquals(1, payloads.size());
+
     reader.close();
     directory.close();
   }
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestSpanQueryWrapper.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestSpanQueryWrapper.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestSpanQueryWrapper.java	(working copy)
@@ -0,0 +1,218 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.FieldType;
+import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.IndexOptions;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.NoMergePolicy;
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.RegexpQuery;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
+
+public class TestSpanQueryWrapper extends LuceneTestCase {
+
+  protected IndexSearcher searcher;
+  protected Directory directory;
+  protected IndexReader reader;
+
+  public static final String FIELD = "field";
+  public static final String ALTFIELD = "altfield";
+
+  public static FieldType OFFSETS = new FieldType(TextField.TYPE_STORED);
+  static {
+    OFFSETS.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    reader.close();
+    directory.close();
+    super.tearDown();
+  }
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(NoMergePolicy.INSTANCE));
+    for (int i = 0; i < docFields.length; i++) {
+      Document doc = new Document();
+      doc.add(newField(FIELD, docFields[i], OFFSETS));
+      doc.add(newField(ALTFIELD, i % 2 == 0 ? "one" : "two", OFFSETS));
+      writer.addDocument(doc);
+    }
+    reader = writer.getReader();
+    writer.close();
+    searcher = newSearcher(reader);
+  }
+
+  public static class OffsetsCollector implements SpanCollector {
+
+    int start;
+    int end;
+    String field;
+
+    @Override
+    public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException {
+      start = start == -1 ? postings.startOffset() : Math.min(start, postings.startOffset());
+      end = Math.max(end, postings.endOffset());
+      field = term.field();
+    }
+
+    @Override
+    public void reset() {
+      start = end = -1;
+    }
+  }
+
+  protected String[] docFields = {
+      "w1 w2 w3 w4 w5",
+      "w1 w3 w2 w3 zz",
+      "w1 xx w2 yy w4",
+      "w1 w3 xx w2 yy w3 zz",
+      "w3 yy w1 w2"
+  };
+
+  @Test
+  public void testTermQuery() throws Exception {
+    SpanQueryWrapper sqw = new SpanQueryWrapper(new TermQuery(new Term(FIELD, "w3")), searcher, SpanWeight.Postings.OFFSETS);
+    checkOffsets(sqw, 0, new int[]{6, 8});
+    checkOffsets(sqw, 1, new int[]{3, 5, 9, 11});
+    checkOffsets(sqw, 2, new int[]{});
+  }
+
+  @Test
+  public void testWildcards() throws Exception {
+    Query q = new RegexpQuery(new Term(FIELD, "w(1|2)"));
+    SpanQueryWrapper sqw = new SpanQueryWrapper(q, searcher, SpanWeight.Postings.OFFSETS);
+    checkOffsets(sqw, 0, new int[]{0, 2, 3, 5});
+    checkOffsets(sqw, 1, new int[]{0, 2, 6, 8});
+  }
+
+  @Test
+  public void testNestedSpanNearQuery() throws Exception {
+    SpanTermQuery w1 = new SpanTermQuery(new Term(FIELD, "w1"));
+    SpanTermQuery w2 = new SpanTermQuery(new Term(FIELD, "w2"));
+    SpanTermQuery w3 = new SpanTermQuery(new Term(FIELD, "w3"));
+    SpanTermQuery yy = new SpanTermQuery(new Term(FIELD, "yy"));
+
+    SpanNearQuery w1nearw2 = new SpanNearQuery(new SpanQuery[]{w1, w2}, 3, true);
+    SpanOrQuery w3oryy = new SpanOrQuery(w3, yy);
+    SpanNearQuery query = new SpanNearQuery(new SpanQuery[]{w1nearw2, w3oryy}, 10, false);
+
+    SpanQueryWrapper sqw = new SpanQueryWrapper(query, searcher, SpanWeight.Postings.OFFSETS);
+    checkOffsets(sqw, 0, new int[]{0, 8});
+    checkOffsets(sqw, 3, new int[]{0, 11});
+    checkOffsets(sqw, 4, new int[]{0, 11, 3, 11});
+  }
+
+  @Test
+  public void testMultiFieldQuery() throws Exception {
+    BooleanQuery bq = new BooleanQuery();
+    bq.add(new TermQuery(new Term(FIELD, "w3")), BooleanClause.Occur.SHOULD);
+    bq.add(new TermQuery(new Term(ALTFIELD, "two")), BooleanClause.Occur.SHOULD);
+
+    SpanQueryWrapper sqw = new SpanQueryWrapper(bq, searcher, SpanWeight.Postings.OFFSETS);
+    Spans spans = sqw.advanceTo(1);
+    OffsetsCollector collector = new OffsetsCollector();
+
+    assertEquals(0, spans.nextStartPosition());
+    collector.reset();
+    spans.collect(collector);
+    assertEquals(ALTFIELD, collector.field);
+    assertEquals(0, collector.start);
+    assertEquals(3, collector.end);
+
+    assertEquals(1, spans.nextStartPosition());
+    collector.reset();
+    spans.collect(collector);
+    assertEquals(FIELD, collector.field);
+    assertEquals(3, collector.start);
+    assertEquals(5, collector.end);
+
+    assertEquals(3, spans.nextStartPosition());
+    collector.reset();
+    spans.collect(collector);
+    assertEquals(FIELD, collector.field);
+    assertEquals(9, collector.start);
+    assertEquals(11, collector.end);
+
+    assertEquals(Spans.NO_MORE_POSITIONS, spans.nextStartPosition());
+
+  }
+
+  @Test
+  public void testPhraseQuery() throws Exception {
+    PhraseQuery pq = new PhraseQuery();
+    pq.add(new Term(FIELD, "w2"));
+    pq.add(new Term(FIELD, "w3"));
+    pq.setSlop(1);
+
+    SpanQueryWrapper sqw = new SpanQueryWrapper(pq, searcher, SpanWeight.Postings.OFFSETS);
+    checkOffsets(sqw, 0, new int[]{3, 8});
+    checkOffsets(sqw, 1, new int[]{3, 8, 6, 11});
+    checkOffsets(sqw, 2, new int[]{});
+  }
+
+  @Test
+  public void testMultiPhraseQuery() throws Exception {
+
+    MultiPhraseQuery mpq = new MultiPhraseQuery();
+    mpq.add(new Term[]{new Term(FIELD, "w1"), new Term(FIELD, "w2")});
+    mpq.add(new Term(FIELD, "w3"));
+
+    SpanQueryWrapper sqw = new SpanQueryWrapper(mpq, searcher, SpanWeight.Postings.OFFSETS);
+    checkOffsets(sqw, 0, new int[]{3, 8});
+    checkOffsets(sqw, 1, new int[]{0, 5, 6, 11});
+    checkOffsets(sqw, 2, new int[]{});
+    checkOffsets(sqw, 3, new int[]{0, 5});
+
+  }
+
+  private static void checkOffsets(SpanQueryWrapper sqw, int doc, int[] offsets) throws IOException {
+    Spans spans = sqw.advanceTo(doc);
+    OffsetsCollector collector = new OffsetsCollector();
+    for (int i = 0; i < offsets.length; i+= 2) {
+      assertNotSame(Spans.NO_MORE_POSITIONS, spans.nextStartPosition());
+      collector.reset();
+      spans.collect(collector);
+      assertEquals(offsets[i], collector.start);
+      assertEquals(offsets[i+1], collector.end);
+    }
+    assertEquals(Spans.NO_MORE_POSITIONS, spans.nextStartPosition());
+  }
+
+}

Property changes on: lucene/core/src/test/org/apache/lucene/search/spans/TestSpanQueryWrapper.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
