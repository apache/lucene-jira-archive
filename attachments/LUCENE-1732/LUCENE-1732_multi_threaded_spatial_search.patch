Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/CartesianTierPlotter.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/CartesianTierPlotter.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/tier/projections/CartesianTierPlotter.java	Fri Jun 26 14:12:04 CEST 2009
@@ -134,11 +134,10 @@
    *  Distances less than a mile return 15, finer granularity is
    *  in accurate
    * 
-   * @param latitude
-   * @param longitude
+   * @param miles
    * @return
    */
-  public int bestFit(int miles){
+  public int bestFit(double miles){
     
     //28,892 a rough circumference of the earth
     int circ = 28892;
@@ -146,7 +145,6 @@
     double r = miles / 2.0;
     
     double corner = r - Math.sqrt(Math.pow(r, 2) / 2.0d);
-    System.out.println("corner "+ corner);
     double times = circ / corner;
     int bestFit =  (int)Math.ceil(log2(times)) + 1;
     
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/LatLongDistanceFilter.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/LatLongDistanceFilter.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/tier/LatLongDistanceFilter.java	(revision 790889)
@@ -1,281 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.tier;
-
-import java.io.IOException;
-import java.util.BitSet;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.WeakHashMap;
-import java.util.logging.Logger;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.TermDocs;
-import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.spatial.NumberUtils;
-import org.apache.lucene.spatial.tier.DistanceHandler.Precision;
-
-
-
-
-public class LatLongDistanceFilter extends DistanceFilter {
-
-  /**
-   * 
-   */
-  private static final long serialVersionUID = 1L;
-  
-  double distance;
-  double lat;
-  double lng;
-  String latField;
-  String lngField;
-  Logger log = Logger.getLogger(getClass().getName());
-
-  int nextOffset = 0;
-  
-  Map<Integer,Double> distances = null;
-  private Precision precise = null;
-  
-  /**
-   * Provide a distance filter based from a center point with a radius
-   * in miles
-   * @param lat
-   * @param lng
-   * @param miles
-   * @param latField
-   * @param lngField
-   */
-  public LatLongDistanceFilter(double lat, double lng, double miles, String latField, String lngField){
-    distance = miles;
-    this.lat = lat;
-    this.lng = lng;
-    this.latField = latField;
-    this.lngField = lngField;
-  }
-  
-  
-  public Map<Integer,Double> getDistances(){
-    return distances;
-  }
-  
-  public Double getDistance(int docid){
-    return distances.get(docid);
-  }
-  
-  @Override
-  public BitSet bits(IndexReader reader) throws IOException {
-
-    /* Create a BitSet to store the result */
-    int maxdocs = reader.maxDoc();
-    BitSet bits = new BitSet(maxdocs);
-    
-    setPrecision(maxdocs);
-    // create an intermediate cache to avoid recomputing
-    //   distances for the same point 
-    //   TODO: Why is this a WeakHashMap? 
-    WeakHashMap<String,Double> cdistance = new WeakHashMap<String,Double>(maxdocs);
-    long start = System.currentTimeMillis();
-    String[] latIndex = FieldCache.DEFAULT.getStrings(reader, latField);
-    String[] lngIndex = FieldCache.DEFAULT.getStrings(reader, lngField);
-
-    /* store calculated distances for reuse by other components */
-    distances = new HashMap<Integer,Double>(maxdocs);
-    
-    if (distances == null){
-    	distances = new HashMap<Integer,Double>();
-    }
-
-    TermDocs td = reader.termDocs(null);
-    while(td.next()) {
-      int doc = td.doc();
-      
-      String sx = latIndex[doc];
-      String sy = lngIndex[doc];
-  
-      double x = NumberUtils.SortableStr2double(sx);
-      double y = NumberUtils.SortableStr2double(sy);
-      
-      // round off lat / longs if necessary
-//      x = DistanceHandler.getPrecision(x, precise);
-//      y = DistanceHandler.getPrecision(y, precise);
-      
-      String ck = new Double(x).toString()+","+new Double(y).toString();
-      Double cachedDistance = cdistance.get(ck);
-      
-      
-      double d;
-      
-      if(cachedDistance != null){
-        d = cachedDistance.doubleValue();
-      } else {
-        d = DistanceUtils.getInstance().getDistanceMi(lat, lng, x, y);
-        cdistance.put(ck, d);
-      }
-      
-   // why was i storing all distances again?
-      if (d < distance){
-        bits.set(doc);
-        distances.put(doc+ nextOffset, d); // include nextOffset for multi segment reader  
-      }
-    }
-    int size = bits.cardinality();
-    nextOffset += reader.maxDoc();  // this should be something that's part of indexReader
-    long end = System.currentTimeMillis();
-    log.fine("Bits 1: Time taken : "+ (end - start) + 
-            ", results : "+ distances.size() + 
-            ", cached : "+ cdistance.size() +
-            ", incoming size: "+ size+
-            ", nextOffset: "+ nextOffset);
-    
-    return bits;
-  }
-
-  
-  @Override
-  public BitSet bits(IndexReader reader, BitSet bits) throws Exception {
-
-  
-    /* Create a BitSet to store the result */
-  	
-    int size = bits.cardinality();
-    BitSet result = new BitSet(size);
-    
-    
-    /* create an intermediate cache to avoid recomputing
-         distances for the same point  */
-    HashMap<String,Double> cdistance = new HashMap<String,Double>(size);
-    
-
-    
-    if (distances == null){
-    	distances = new HashMap<Integer,Double>();
-    }
-    
-    long start = System.currentTimeMillis();
-    String[] latIndex = FieldCache.DEFAULT.getStrings(reader, latField);
-    String[] lngIndex = FieldCache.DEFAULT.getStrings(reader, lngField);
-    
-    /* loop over all set bits (hits from the boundary box filters) */
-    int i = bits.nextSetBit(0);
-    while (i >= 0){
-
-      if (reader.isDeleted(i)) {
-        i = bits.nextSetBit(i+1);
-        continue;
-      }
-
-      double x,y;
-      
-      // if we have a completed
-      // filter chain, lat / lngs can be retrived from 
-      // memory rather than document base.
-
-      String sx = latIndex[i];
-      String sy = lngIndex[i];
-      x = NumberUtils.SortableStr2double(sx);
-      y = NumberUtils.SortableStr2double(sy);
-      
-      // round off lat / longs if necessary
-//      x = DistanceHandler.getPrecision(x, precise);
-//      y = DistanceHandler.getPrecision(y, precise);
-
-      String ck = new Double(x).toString()+","+new Double(y).toString();
-      Double cachedDistance = cdistance.get(ck);
-      double d;
-      
-      if(cachedDistance != null){
-        d = cachedDistance.doubleValue();
-        
-      } else {
-        d = DistanceUtils.getInstance().getDistanceMi(lat, lng, x, y);
-        //d = DistanceUtils.getLLMDistance(lat, lng, x, y);
-        cdistance.put(ck, d);
-      }
-      
-      // why was i storing all distances again?
-      if (d < distance){
-        result.set(i);
-        int did = i + nextOffset;
-        distances.put(did, d); // include nextOffset for multi segment reader  
-        
-      }
-      i = bits.nextSetBit(i+1);
-    }
-    
-    long end = System.currentTimeMillis();
-    nextOffset += reader.maxDoc();  // this should be something that's part of indexReader
-    log.fine("Time taken : "+ (end - start) + 
-        ", results : "+ distances.size() + 
-        ", cached : "+ cdistance.size() +
-        ", incoming size: "+ size+
-        ", nextOffset: "+ nextOffset);
-  
-
-    cdistance = null;
-    
-    
-    return result;
-  }
-
-  /** Returns true if <code>o</code> is equal to this. */
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (!(o instanceof LatLongDistanceFilter)) return false;
-    LatLongDistanceFilter other = (LatLongDistanceFilter) o;
-
-    if (this.distance != other.distance ||
-        this.lat != other.lat ||
-        this.lng != other.lng ||
-        !this.latField.equals(other.latField) ||
-        !this.lngField.equals(other.lngField)) {
-      return false;
-    }
-    return true;
-  }
-
-  /** Returns a hash code value for this object.*/
-  @Override
-  public int hashCode() {
-    int h = new Double(distance).hashCode();
-    h ^= new Double(lat).hashCode();
-    h ^= new Double(lng).hashCode();
-    h ^= latField.hashCode();
-    h ^= lngField.hashCode();
-    return h;
-  }
-  
-
-
-  public void setDistances(Map<Integer, Double> distances) {
-    this.distances = distances;
-  }
-
-  void setPrecision(int maxDocs) {
-    precise = Precision.EXACT;
-    
-    if (maxDocs > 1000 && distance > 10) {
-      precise = Precision.TWENTYFEET;
-    }
-    
-    if (maxDocs > 10000 && distance > 10){
-      precise = Precision.TWOHUNDREDFEET;
-    }
-  }
-}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashDistanceFilter.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashDistanceFilter.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashDistanceFilter.java	(revision 790889)
@@ -1,247 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geohash;
-
-import java.io.IOException;
-import java.util.BitSet;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.WeakHashMap;
-import java.util.logging.Logger;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.spatial.tier.DistanceFilter;
-import org.apache.lucene.spatial.tier.DistanceUtils;
-import org.apache.lucene.spatial.tier.DistanceHandler.Precision;
-
-
-
-public class GeoHashDistanceFilter extends DistanceFilter {
-
-  /**
-   * 
-   */
-  private static final long serialVersionUID = 1L;
-  
-  private double distance;
-  private double lat;
-  private double lng;
-  private String geoHashField;
-  
-  private Logger log = Logger.getLogger(getClass().getName());
-  
-  private Map<Integer,Double> distances = null;
-  private Precision precise = null;
-  int offset = 0; 
-  int nextOffset;
-  
-  /**
-   * Provide a distance filter based from a center point with a radius
-   * in miles
-   * @param lat
-   * @param lng
-   * @param miles
-   * @param latField
-   * @param lngField
-   */
-  public GeoHashDistanceFilter(double lat, double lng, double miles, String geoHashField){
-    distance = miles;
-    this.lat = lat;
-    this.lng = lng;
-    this.geoHashField = geoHashField;
-    
-  }
-  
-  
-  public Map<Integer,Double> getDistances(){
-    return distances;
-  }
-  
-  public Double getDistance(int docid){
-    return distances.get(docid);
-  }
-  
-  @Override
-  public BitSet bits(IndexReader reader) throws IOException {
-
-    /* Create a BitSet to store the result */
-    int maxdocs = reader.numDocs();
-    BitSet bits = new BitSet(maxdocs);
-    
-    setPrecision(maxdocs);
-    // create an intermediate cache to avoid recomputing
-    //   distances for the same point 
-    //   TODO: Why is this a WeakHashMap? 
-    WeakHashMap<String,Double> cdistance = new WeakHashMap<String,Double>(maxdocs);
-    
-    String[] geoHashCache = FieldCache.DEFAULT.getStrings(reader, geoHashField);
-    
-
-    /* store calculated distances for reuse by other components */
-    distances = new HashMap<Integer,Double>(maxdocs);
-    for (int i = 0 ; i < maxdocs; i++) {
-      
-      String geoHash = geoHashCache[i];
-      double[] coords = GeoHashUtils.decode(geoHash);
-      double x = coords[0];
-      double y = coords[1];
-      
-      // round off lat / longs if necessary
-//      x = DistanceHandler.getPrecision(x, precise);
-//      y = DistanceHandler.getPrecision(y, precise);
-      
-      
-      Double cachedDistance = cdistance.get(geoHash);
-      
-      
-      double d;
-      
-      if(cachedDistance != null){
-        d = cachedDistance.doubleValue();
-      } else {
-        d = DistanceUtils.getInstance().getDistanceMi(lat, lng, x, y);
-        cdistance.put(geoHash, d);
-      }
-      distances.put(i, d);
-      
-      if (d < distance){
-        bits.set(i);
-      }
-      
-    }
-    
-    return bits;
-  }
-
-  
-  @Override
-  public BitSet bits(IndexReader reader, BitSet bits) throws Exception {
-
-  
-    /* Create a BitSet to store the result */
-    int size = bits.cardinality();
-    BitSet result = new BitSet(size);
-    
-
-    /* create an intermediate cache to avoid recomputing
-         distances for the same point  */
-    HashMap<String,Double> cdistance = new HashMap<String,Double>(size);
-    
-
-    /* store calculated distances for reuse by other components */
-    offset += reader.maxDoc();
-    if (distances == null)
-    	distances = new HashMap<Integer,Double>(size);
-    
-    long start = System.currentTimeMillis();
-    String[] geoHashCache = FieldCache.DEFAULT.getStrings(reader, geoHashField);
- 
-    /* loop over all set bits (hits from the boundary box filters) */
-    int i = bits.nextSetBit(0);
-    while (i >= 0){
-      
-      // if we have a completed
-      // filter chain, lat / lngs can be retrived from 
-      // memory rather than document base.
-
-      String geoHash = geoHashCache[i];
-      double[] coords = GeoHashUtils.decode(geoHash);
-      double x = coords[0];
-      double y = coords[1];
-      
-      // round off lat / longs if necessary
-//      x = DistanceHandler.getPrecision(x, precise);
-//      y = DistanceHandler.getPrecision(y, precise);
-
-      
-      Double cachedDistance = cdistance.get(geoHash);
-      double d;
-      
-      if(cachedDistance != null){
-        d = cachedDistance.doubleValue();
-        
-      } else {
-        d = DistanceUtils.getInstance().getDistanceMi(lat, lng, x, y);
-        //d = DistanceUtils.getLLMDistance(lat, lng, x, y);
-        cdistance.put(geoHash, d);
-      }
-      
-      distances.put(i, d);
-        
-      if (d < distance){
-        result.set(i);
-      }
-      i = bits.nextSetBit(i+1);
-    }
-    
-    long end = System.currentTimeMillis();
-    log.fine("Time taken : "+ (end - start) + 
-        ", results : "+ distances.size() + 
-        ", cached : "+ cdistance.size() +
-        ", incoming size: "+ size);
-  
-
-    cdistance = null;
-    nextOffset += offset;
-    return result;
-  }
-
-  /** Returns true if <code>o</code> is equal to this. */
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (!(o instanceof GeoHashDistanceFilter)) return false;
-    GeoHashDistanceFilter other = (GeoHashDistanceFilter) o;
-
-    if (this.distance != other.distance ||
-        this.lat != other.lat ||
-        this.lng != other.lng ||
-        !this.geoHashField.equals(other.geoHashField) ) {
-      return false;
-    }
-    return true;
-  }
-
-  /** Returns a hash code value for this object.*/
-  @Override
-  public int hashCode() {
-    int h = new Double(distance).hashCode();
-    h ^= new Double(lat).hashCode();
-    h ^= new Double(lng).hashCode();
-    h ^= geoHashField.hashCode();
-    
-    return h;
-  }
-  
-  private void setPrecision(int maxDocs) {
-    precise = Precision.EXACT;
-    
-    if (maxDocs > 1000 && distance > 10) {
-      precise = Precision.TWENTYFEET;
-    }
-    
-    if (maxDocs > 10000 && distance > 10){
-      precise = Precision.TWOHUNDREDFEET;
-    }
-  }
-
-  public void setDistances(Map<Integer, Double> distances) {
-    this.distances = distances;
-  }
-}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder.java	Thu Jun 25 11:06:02 CEST 2009
@@ -26,6 +26,7 @@
 import org.apache.lucene.spatial.tier.projections.CartesianTierPlotter;
 import org.apache.lucene.spatial.tier.projections.IProjector;
 import org.apache.lucene.spatial.tier.projections.SinusoidalProjector;
+import org.apache.lucene.spatial.util.DistanceUtils;
 
 
 /**
@@ -42,9 +43,9 @@
     this.tierPrefix = tierPrefix;
   }
   
-  public Shape getBoxShape(double latitude, double longitude, int miles)
+  public Shape getBoxShape(double latitude, double longitude, double miles)
   {  
-    Rectangle box = DistanceUtils.getInstance().getBoundary(latitude, longitude, miles);
+    Rectangle box = DistanceUtils.getBoundary(latitude, longitude, miles);
     
     double latY = box.getMaxPoint().getY();//box.getY();
     double latX = box.getMinPoint().getY() ; //box.getMaxY();
@@ -104,7 +105,7 @@
     return shape;
   }
   
-  public Filter getBoundingArea(double latitude, double longitude, int miles) 
+  public Filter getBoundingArea(double latitude, double longitude, double miles)
   {
     Shape shape = getBoxShape(latitude, longitude, miles);
     return new CartesianShapeFilter(shape, shape.getTierId());
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceFilter.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceFilter.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/distance/DistanceFilter.java	Fri Jul 03 14:56:23 CEST 2009
@@ -1,4 +1,5 @@
-/** Licensed to the Apache Software Foundation (ASF) under one or more
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
  * The ASF licenses this file to You under the Apache License, Version 2.0
@@ -14,40 +15,47 @@
  * limitations under the License.
  */
 
-package org.apache.lucene.spatial.tier;
+package org.apache.lucene.spatial.distance;
 
 import java.io.IOException;
 import java.util.BitSet;
 import java.util.Map;
 
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.spatial.ISerialChainFilter;
 
+/**
+ * DistanceFilter is responsible for filtering out documents from an existing BitSet, based on their calculated distance
+ * from the central point.  Because the costing of calculating distances for documents is relatively high, this filter
+ * uses an existing BitSet, which will have been created another filter previously.  As such, this is technicall not
+ * a Lucene Filter.
+ * <p/>
+ * In addition to filtering out documents, the filter also holds onto the calculated distances so they can be used after
+ * the filtering process.
+ */
+public interface DistanceFilter {
 
-public abstract class DistanceFilter extends ISerialChainFilter {
+  /**
+   * Returns a map of calculated distances by document ids
+   *
+   * @return Map of calculated distances by document ids
+   */
+  Map<Integer, Double> getDistances();
 
-	public DistanceFilter() {
-		super();
-	}
+  /**
+   * Returns the calculated distance for a document with the given id
+   *
+   * @param docId ID of the document whose distance is to be returned
+   * @return Calculated distance of the document with the id
+   */
+  Double getDistance(int docId);
 
-	public abstract Map<Integer,Double> getDistances();
-
-	public abstract Double getDistance(int docid);
-
-	@Override
-	public abstract BitSet bits(IndexReader reader) throws IOException;
-
-	@Override
-	public abstract BitSet bits(IndexReader reader, BitSet bits) throws Exception;
-
-	/** Returns true if <code>o</code> is equal to this. */
-	@Override
-	public abstract boolean equals(Object o);
-
-	/** Returns a hash code value for this object.*/
-	@Override
-	public abstract int hashCode();
-
-	public abstract void setDistances(Map<Integer, Double> distances);
-
+  /**
+   * Filters the documents from the given IndexReader who have bits set in the given BitSet.
+   *
+   * @param reader IndexReader from where the documents will be read from
+   * @param bits   BitSet containing bits indicating which documents should be considered to be filtered out
+   * @return BitSet with bits set representing those documents that passed the filter
+   * @throws IOException Can be thrown while reading from the IndexReader
+   */
+  BitSet bits(IndexReader reader, BitSet bits) throws IOException;
 }
\ No newline at end of file
Index: contrib/spatial/src/test/org/apache/lucene/spatial/tier/DistanceCheck.java
===================================================================
--- contrib/spatial/src/test/org/apache/lucene/spatial/tier/DistanceCheck.java	(revision 790889)
+++ contrib/spatial/src/test/org/apache/lucene/spatial/tier/DistanceCheck.java	(revision 790889)
@@ -1,49 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.tier;
-
-import java.text.DecimalFormat;
-
-
-public class DistanceCheck {
-
-  /**
-   * @param args
-   */
-  public static void main(String[] args) {
-    double lat1 = 0;
-    double long1 = 0;
-    double lat2 = 0;
-    double long2 = 0;
-    
-    for (int i =0; i < 90; i++){
-      double dis = DistanceUtils.getInstance().getDistanceMi(lat1, long1, lat2, long2);
-      lat1 +=1;
-      lat2 = lat1 + 0.001;
-      
-      System.out.println(lat1+","+long1+","+lat2+","+long2+","+formatDistance(dis));
-      
-    }
-
-  }
-
-  public static String formatDistance (Double d){
-    DecimalFormat df1 = new DecimalFormat("####.000000");
-    return df1.format(d);
-  }
-  
-}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianShapeFilter.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianShapeFilter.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianShapeFilter.java	Thu Jun 25 11:06:09 CEST 2009
@@ -25,7 +25,7 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermDocs;
 import org.apache.lucene.search.Filter;
-import org.apache.lucene.spatial.NumberUtils;
+import org.apache.lucene.spatial.util.NumberUtils;
 
 public class CartesianShapeFilter extends Filter {
 
@@ -68,7 +68,7 @@
     }
     
     long end = System.currentTimeMillis();
-    log.fine("BoundaryBox Time Taken: "+ (end - start) + " found: "+bits.cardinality()+" candidates");
+    log.fine("CartesianShapeFilter Time Taken: "+ (end - start) + " found: "+bits.cardinality()+" candidates");
     return bits;
   }
 
Index: contrib/spatial/src/java/org/apache/lucene/spatial/distance/LatLongLocationDataSetFactory.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/distance/LatLongLocationDataSetFactory.java	Fri Jul 03 14:56:48 CEST 2009
+++ contrib/spatial/src/java/org/apache/lucene/spatial/distance/LatLongLocationDataSetFactory.java	Fri Jul 03 14:56:48 CEST 2009
@@ -0,0 +1,86 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.distance;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.spatial.geometry.shape.Point2D;
+import org.apache.lucene.spatial.util.NumberUtils;
+import org.apache.lucene.search.FieldCache;
+
+import java.io.IOException;
+
+/**
+ * Implementation of {@link org.apache.lucene.spatial.distance.LocationDataSetFactory} that builds LocationDataSet based
+ * on 2 fields representing latitude and longitude.
+ */
+public class LatLongLocationDataSetFactory implements LocationDataSetFactory {
+
+  private final String latField;
+  private final String lngField;
+
+  /**
+   * Creates a new LatLongLocationDataSetFactory that will use the latitude and longitude data read from the fields
+   * with the given names
+   *
+   * @param latField Name of the latitude field
+   * @param lngField Name of the longitude field
+   */
+  public LatLongLocationDataSetFactory(String latField, String lngField) {
+    this.latField = latField;
+    this.lngField = lngField;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public LocationDataSet buildLocationDataSet(IndexReader indexReader) throws IOException {
+    return new LatLongLocationDataSet(FieldCache.DEFAULT.getStrings(indexReader, latField),
+        FieldCache.DEFAULT.getStrings(indexReader, lngField));
+  }
+
+  // ================================================= Inner Classes =================================================
+
+  /**
+   * Implementation of LocationDataSet that uses fields that represent latitude and longitude to construct the Point2D
+   * for a document.
+   */
+  private class LatLongLocationDataSet implements LocationDataSet {
+
+    private String[] latIndex;
+    private String[] lngIndex;
+
+    /**
+     * Creates a new LatLongLocationDataSet which uses the values in the given latitude and longitude indexes to create
+     * Points for documents
+     *
+     * @param latIndex Array containing the latitude field values taken from the index
+     * @param lngIndex Array containing the longitude field values taken from the index
+     */
+    private LatLongLocationDataSet(String[] latIndex, String[] lngIndex) {
+      this.latIndex = latIndex;
+      this.lngIndex = lngIndex;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Point2D getPoint(int docId) {
+      return new Point2D(NumberUtils.SortableStr2double(latIndex[docId]), NumberUtils.SortableStr2double(lngIndex[docId]));
+    }
+  }
+}
Index: contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
===================================================================
--- contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java	(revision 790889)
+++ contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java	(revision 790889)
@@ -1,312 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.tier;
-
-import java.io.IOException;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.analysis.WhitespaceAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.Hits;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.Sort;
-import org.apache.lucene.search.SortField;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.function.CustomScoreQuery;
-import org.apache.lucene.search.function.FieldScoreQuery;
-import org.apache.lucene.search.function.FieldScoreQuery.Type;
-import org.apache.lucene.spatial.NumberUtils;
-import org.apache.lucene.spatial.geohash.GeoHashUtils;
-import org.apache.lucene.spatial.tier.projections.CartesianTierPlotter;
-import org.apache.lucene.spatial.tier.projections.IProjector;
-import org.apache.lucene.spatial.tier.projections.SinusoidalProjector;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.RAMDirectory;
-
-
-/**
- *
- */
-public class TestCartesian extends TestCase{
-
-  /**
-   * @param args
-   */
-  
-  private Directory directory;
-  private IndexSearcher searcher;
-  // reston va
-  private double lat = 38.969398; 
-  private double lng= -77.386398;
-  private String latField = "lat";
-  private String lngField = "lng";
-  private List<CartesianTierPlotter> ctps = new LinkedList<CartesianTierPlotter>();
-  private String geoHashPrefix = "_geoHash_";
-  
-  private IProjector project = new SinusoidalProjector();
-  
-
-
-  protected void setUp() throws IOException {
-    directory = new RAMDirectory();
-
-    IndexWriter writer = new IndexWriter(directory, new WhitespaceAnalyzer(), true);
-    
-    setUpPlotter( 2, 15);
-    
-    addData(writer);
-    
-  }
-  
-  
-  private void setUpPlotter(int base, int top) {
-    
-    for (; base <= top; base ++){
-      ctps.add(new CartesianTierPlotter(base,project,
-          CartesianTierPlotter.DEFALT_FIELD_PREFIX));
-    }
-  }
-  
-  private void addPoint(IndexWriter writer, String name, double lat, double lng) throws IOException{
-    
-    Document doc = new Document();
-    
-    doc.add(new Field("name", name,Field.Store.YES, Field.Index.TOKENIZED));
-    
-    // convert the lat / long to lucene fields
-    doc.add(new Field(latField, NumberUtils.double2sortableStr(lat),Field.Store.YES, Field.Index.UN_TOKENIZED));
-    doc.add(new Field(lngField, NumberUtils.double2sortableStr(lng),Field.Store.YES, Field.Index.UN_TOKENIZED));
-    
-    // add a default meta field to make searching all documents easy 
-    doc.add(new Field("metafile", "doc",Field.Store.YES, Field.Index.TOKENIZED));
-    
-    int ctpsize = ctps.size();
-    for (int i =0; i < ctpsize; i++){
-      CartesianTierPlotter ctp = ctps.get(i);
-      doc.add(new Field(ctp.getTierFieldName(), 
-          NumberUtils.double2sortableStr(ctp.getTierBoxId(lat,lng)),
-          Field.Store.YES, 
-          Field.Index.NO_NORMS));
-      
-      doc.add(new Field(geoHashPrefix, GeoHashUtils.encode(lat,lng), 
-    		  Field.Store.YES, 
-    		  Field.Index.NO_NORMS));
-    }
-    writer.addDocument(doc);
-    
-  }
-  
-  
-  
-  private void addData(IndexWriter writer) throws IOException {
-    addPoint(writer,"McCormick &amp; Schmick's Seafood Restaurant",38.9579000,-77.3572000);
-    addPoint(writer,"Jimmy's Old Town Tavern",38.9690000,-77.3862000);
-    addPoint(writer,"Ned Devine's",38.9510000,-77.4107000);
-    addPoint(writer,"Old Brogue Irish Pub",38.9955000,-77.2884000);
-    addPoint(writer,"Alf Laylah Wa Laylah",38.8956000,-77.4258000);
-    addPoint(writer,"Sully's Restaurant &amp; Supper",38.9003000,-77.4467000);
-    addPoint(writer,"TGIFriday",38.8725000,-77.3829000);
-    addPoint(writer,"Potomac Swing Dance Club",38.9027000,-77.2639000);
-    addPoint(writer,"White Tiger Restaurant",38.9027000,-77.2638000);
-    addPoint(writer,"Jammin' Java",38.9039000,-77.2622000);
-    addPoint(writer,"Potomac Swing Dance Club",38.9027000,-77.2639000);
-    addPoint(writer,"WiseAcres Comedy Club",38.9248000,-77.2344000);
-    addPoint(writer,"Glen Echo Spanish Ballroom",38.9691000,-77.1400000);
-    addPoint(writer,"Whitlow's on Wilson",38.8889000,-77.0926000);
-    addPoint(writer,"Iota Club and Cafe",38.8890000,-77.0923000);
-    addPoint(writer,"Hilton Washington Embassy Row",38.9103000,-77.0451000);
-    addPoint(writer,"HorseFeathers, Bar & Grill", 39.01220000000001, -77.3942);
-   
-    writer.commit();
-    writer.close();
-  }
-  
-  public void testRange() throws IOException, InvalidGeoException {
-    searcher = new IndexSearcher(directory);
-    
-    final double miles = 6.0;
-    
-    // create a distance query
-    final DistanceQueryBuilder dq = new DistanceQueryBuilder(lat, lng, miles, 
-        latField, lngField, CartesianTierPlotter.DEFALT_FIELD_PREFIX, true);
-     
-    System.out.println(dq);
-    //create a term query to search against all documents
-    Query tq = new TermQuery(new Term("metafile", "doc"));
-    
-    FieldScoreQuery fsQuery = new FieldScoreQuery("geo_distance", Type.FLOAT);
-    
-    CustomScoreQuery customScore = new CustomScoreQuery(dq.getQuery(tq),fsQuery){
-      
-      @Override
-      public float customScore(int doc, float subQueryScore, float valSrcScore){
-        //System.out.println(doc);
-        if (dq.distanceFilter.getDistance(doc) == null)
-          return 0;
-        
-        double distance = dq.distanceFilter.getDistance(doc);
-        // boost score shouldn't exceed 1
-        if (distance < 1.0d)
-          distance = 1.0d;
-        //boost by distance is invertly proportional to
-        // to distance from center point to location
-        float score = new Float((miles - distance) / miles ).floatValue();
-        return score * subQueryScore;
-      }
-    };
-    // Create a distance sort
-    // As the radius filter has performed the distance calculations
-    // already, pass in the filter to reuse the results.
-    // 
-    DistanceFieldComparatorSource dsort = new DistanceFieldComparatorSource(dq.distanceFilter);
-    Sort sort = new Sort(new SortField("foo", dsort,false));
-    
-    // Perform the search, using the term query, the serial chain filter, and the
-    // distance sort
-    Hits hits = searcher.search(customScore,null,sort);
-
-    int results = hits.length();
-    
-    // Get a list of distances 
-    Map<Integer,Double> distances = dq.distanceFilter.getDistances();
-    
-    // distances calculated from filter first pass must be less than total
-    // docs, from the above test of 20 items, 12 will come from the boundary box
-    // filter, but only 5 are actually in the radius of the results.
-    
-    // Note Boundary Box filtering, is not accurate enough for most systems.
-    
-    
-    System.out.println("Distance Filter filtered: " + distances.size());
-    System.out.println("Results: " + results);
-    System.out.println("=============================");
-    System.out.println("Distances should be 7 "+ distances.size());
-    System.out.println("Results should be 7 "+ results);
-
-    assertEquals(7, distances.size()); // fixed a store of only needed distances
-    assertEquals(7, results);
-    double lastDistance = 0;
-    for(int i =0 ; i < results; i++){
-      Document d = hits.doc(i);
-      
-      String name = d.get("name");
-      double rsLat = NumberUtils.SortableStr2double(d.get(latField));
-      double rsLng = NumberUtils.SortableStr2double(d.get(lngField)); 
-      Double geo_distance = distances.get(hits.id(i));
-      
-      double distance = DistanceUtils.getInstance().getDistanceMi(lat, lng, rsLat, rsLng);
-      double llm = DistanceUtils.getInstance().getLLMDistance(lat, lng, rsLat, rsLng);
-      System.out.println("Name: "+ name +", Distance "+ distance); //(res, ortho, harvesine):"+ distance +" |"+ geo_distance +"|"+ llm +" | score "+ hits.score(i));
-      assertTrue(Math.abs((distance - llm)) < 1);
-      assertTrue((distance < miles ));
-      assertTrue(geo_distance > lastDistance);
-      lastDistance = geo_distance;
-    }
-  }
-  
-  
-  
-  public void testGeoHashRange() throws IOException, InvalidGeoException {
-	    searcher = new IndexSearcher(directory);
-	    
-	    final double miles = 6.0;
-	    
-	    // create a distance query
-	    final DistanceQueryBuilder dq = new DistanceQueryBuilder(lat, lng, miles, 
-	        geoHashPrefix, CartesianTierPlotter.DEFALT_FIELD_PREFIX, true);
-	     
-	    System.out.println(dq);
-	    //create a term query to search against all documents
-	    Query tq = new TermQuery(new Term("metafile", "doc"));
-	    
-	    FieldScoreQuery fsQuery = new FieldScoreQuery("geo_distance", Type.FLOAT);
-	    CustomScoreQuery customScore = new CustomScoreQuery(tq,fsQuery){
-	      
-	      @Override
-	      public float customScore(int doc, float subQueryScore, float valSrcScore){
-	        //System.out.println(doc);
-	        if (dq.distanceFilter.getDistance(doc) == null)
-	          return 0;
-	        
-	        double distance = dq.distanceFilter.getDistance(doc);
-	        // boost score shouldn't exceed 1
-	        if (distance < 1.0d)
-	          distance = 1.0d;
-	        //boost by distance is invertly proportional to
-	        // to distance from center point to location
-	        float score = new Float((miles - distance) / miles ).floatValue();
-	        return score * subQueryScore;
-	      }
-	    };
-	    // Create a distance sort
-	    // As the radius filter has performed the distance calculations
-	    // already, pass in the filter to reuse the results.
-	    // 
-	    DistanceSortSource dsort = new DistanceSortSource(dq.distanceFilter);
-	    Sort sort = new Sort(new SortField("foo", dsort));
-	    
-	    // Perform the search, using the term query, the serial chain filter, and the
-	    // distance sort
-	    Hits hits = searcher.search(customScore, dq.getFilter()); //,sort);
-
-	    int results = hits.length();
-	    
-	    // Get a list of distances 
-	    Map<Integer,Double> distances = dq.distanceFilter.getDistances();
-	    
-	    // distances calculated from filter first pass must be less than total
-	    // docs, from the above test of 20 items, 12 will come from the boundary box
-	    // filter, but only 5 are actually in the radius of the results.
-	    
-	    // Note Boundary Box filtering, is not accurate enough for most systems.
-	    
-	    
-	    System.out.println("Distance Filter filtered: " + distances.size());
-	    System.out.println("Results: " + results);
-	    System.out.println("=============================");
-	    System.out.println("Distances should be 14 "+ distances.size());
-	    System.out.println("Results should be 7 "+ results);
-
-	    assertEquals(14, distances.size());
-	    assertEquals(7, results);
-	    
-	    for(int i =0 ; i < results; i++){
-	      Document d = hits.doc(i);
-	      
-	      String name = d.get("name");
-	      double rsLat = NumberUtils.SortableStr2double(d.get(latField));
-	      double rsLng = NumberUtils.SortableStr2double(d.get(lngField)); 
-	      Double geo_distance = distances.get(hits.id(i));
-	      
-	      double distance = DistanceUtils.getInstance().getDistanceMi(lat, lng, rsLat, rsLng);
-	      double llm = DistanceUtils.getInstance().getLLMDistance(lat, lng, rsLat, rsLng);
-	      System.out.println("Name: "+ name +", Distance (res, ortho, harvesine):"+ distance +" |"+ geo_distance +"|"+ llm +" | score "+ hits.score(i));
-	      assertTrue(Math.abs((distance - llm)) < 1);
-	      assertTrue((distance < miles ));
-	      
-	    }
-	  }
-  
-}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/geometry/GeoDistanceCalculator.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/geometry/GeoDistanceCalculator.java	Fri Jul 03 15:04:41 CEST 2009
+++ contrib/spatial/src/java/org/apache/lucene/spatial/geometry/GeoDistanceCalculator.java	Fri Jul 03 15:04:41 CEST 2009
@@ -0,0 +1,40 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.geometry;
+
+import org.apache.lucene.spatial.util.DistanceUnit;
+
+/**
+ * Abstraction of the idea of a calculator of distance between 2 points.  This is useful since while the world is curved,
+ * its not always necessary to calcuate the distance between 2 points as if they are on a curve.
+ */
+public interface GeoDistanceCalculator {
+
+  /**
+   * Calculates the distance between the point defined by the source latitude/longitude and the point defined by the
+   * target latitude/longitude
+   *
+   * @param sourceLongitude Longitude of the point the distance is being calculated from
+   * @param sourceLatitude Latitude of the point the distance is being calculated from
+   * @param targetLongitude Longitude of the point the distance is being calculated to
+   * @param targetLatitude Latitude of the point the distance is being calculated to
+   * @param unit Unit of distance the result should be returned in
+   * @return Distance between the 2 points in the unit of distance requested
+   */
+  double calculate(double sourceLongitude, double sourceLatitude, double targetLongitude, double targetLatitude, DistanceUnit unit);
+}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/geometry/ArcDistanceCalculator.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/geometry/ArcDistanceCalculator.java	Fri Jul 03 14:58:15 CEST 2009
+++ contrib/spatial/src/java/org/apache/lucene/spatial/geometry/ArcDistanceCalculator.java	Fri Jul 03 14:58:15 CEST 2009
@@ -0,0 +1,41 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.geometry;
+
+import org.apache.lucene.spatial.util.DistanceUnit;
+import org.apache.lucene.spatial.util.DistanceUtils;
+
+/**
+ * Implementation of {@link org.apache.lucene.spatial.geometry.GeoDistanceCalculator} that calculates distances as though
+ * the points are on a globe.
+ */
+public class ArcDistanceCalculator implements GeoDistanceCalculator {
+
+  /**
+   * {@inheritDoc}
+   */
+  public double calculate(
+      double sourceLongitude,
+      double sourceLatitude,
+      double targetLongitude,
+      double targetLatitude,
+      DistanceUnit unit) {
+    double arcDistance = DistanceUtils.getDistanceMi(sourceLatitude, sourceLongitude, targetLatitude, targetLongitude);
+    return DistanceUnit.MILES.convert(arcDistance, unit);
+  }
+}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashUtils.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/geohash/GeoHashUtils.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/util/GeoHashUtils.java	Thu Jun 25 11:06:53 CEST 2009
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 
-package org.apache.lucene.spatial.geohash;
+package org.apache.lucene.spatial.util;
 
 import java.util.HashMap;
 import java.util.Map;
Index: contrib/spatial/src/java/org/apache/lucene/spatial/ISerialChainFilter.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/ISerialChainFilter.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/ISerialChainFilter.java	(revision 790889)
@@ -1,34 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial;
-
-import java.io.IOException;
-import java.util.BitSet;
-
-import org.apache.lucene.index.CorruptIndexException;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.Filter;
-
-/**
- * Provide an optimized filter, by allowing the bitset from 
- * previous filters in the bitset to be used in the next part of the chain.
- * 
- */
-public abstract class ISerialChainFilter extends Filter {
-  public abstract BitSet bits(IndexReader reader, BitSet bits) throws CorruptIndexException, IOException, Exception;
-}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/NumberUtils.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/NumberUtils.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/util/NumberUtils.java	Thu Jun 25 11:06:58 CEST 2009
@@ -15,22 +15,14 @@
  * limitations under the License.
  */
 
-package org.apache.lucene.spatial;
+package org.apache.lucene.spatial.util;
 
-import org.apache.lucene.analysis.NumericTokenStream; // for javadocs
-import org.apache.lucene.search.NumericRangeQuery; // for javadocs
-import org.apache.lucene.util.NumericUtils; // for javadocs
-
 /**
  * TODO -- when solr moves NumberUtils to lucene, this should be redundant
  * 
  * This is a copy of solr's number utils with only the functions we use...
  * 
- * @deprecated TODO: This helper class will be removed soonly.
- * For new indexes use {@link NumericUtils} instead, which provides a sortable
- * binary representation (prefix encoded) of numeric values.
- * To index and efficiently query numeric values use {@link NumericTokenStream}
- * and {@link NumericRangeQuery}.
+ * @deprecated will be replaced with lucene version of solr copy...
  */
 @Deprecated
 public class NumberUtils {
Index: contrib/spatial/src/java/org/apache/lucene/spatial/distance/ThreadedDistanceFilter.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/distance/ThreadedDistanceFilter.java	Fri Jul 03 15:02:12 CEST 2009
+++ contrib/spatial/src/java/org/apache/lucene/spatial/distance/ThreadedDistanceFilter.java	Fri Jul 03 15:02:12 CEST 2009
@@ -0,0 +1,250 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.distance;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.spatial.geometry.GeoDistanceCalculator;
+import org.apache.lucene.spatial.geometry.shape.Point2D;
+import org.apache.lucene.spatial.util.DistanceUnit;
+
+import java.io.IOException;
+import java.util.*;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Implementation of {@link org.apache.lucene.spatial.distance.DistanceFilter} that uses multiple threads to iterate in
+ * parallel, over the BitSet to be filtered.
+ * <p/>
+ * To manage the threads, an ExecutorService is used, which allows users of this class to have fine grained control over
+ * how many threads should be created, and what to do when there isn't any threads left in the pool.
+ */
+public class ThreadedDistanceFilter implements DistanceFilter {
+
+  private final Logger log = Logger.getLogger(getClass().getName());
+
+  private final List<Map<Integer, Double>> distanceMaps = new ArrayList<Map<Integer, Double>>();
+  private final double lat;
+  private final double lng;
+  private final double radius;
+  private final DistanceUnit unit;
+
+  private final GeoDistanceCalculator distanceCalculator;
+  private final LocationDataSetFactory dataSetFactory;
+
+  private final ExecutorService executorService;
+  private final int threadCount;
+
+  private int nextOffset = 0;
+
+  /**
+   * Creates a new ThreadedDistanceFilter that will filter out documents that are outside of the given radius of the
+   * central point defined by the given latitude and longitude
+   *
+   * @param lat Latitude of the central point
+   * @param lng Longitude of the central point
+   * @param radius Radius that documents must be within from the central point to pass the filter
+   * @param unit Unit of distance the radius is in
+   * @param dataSetFactory LocationDataSetFactory which can be used to create LocationDataSets from an IndexReader
+   * @param distanceCalculator GeoDistanceCalculator that will be used to calculate the distances between points
+   * @param executorService ExecutorService which will manage the execution of the threads
+   * @param threadCount Number of threads that the filter should try to split its work across
+   */
+  public ThreadedDistanceFilter(
+      double lat,
+      double lng,
+      double radius,
+      DistanceUnit unit,
+      LocationDataSetFactory dataSetFactory,
+      GeoDistanceCalculator distanceCalculator,
+      ExecutorService executorService,
+      int threadCount) {
+
+    this.lat = lat;
+    this.lng = lng;
+    this.radius = radius;
+    this.unit = unit;
+    this.distanceCalculator = distanceCalculator;
+    this.dataSetFactory = dataSetFactory;
+    this.executorService = executorService;
+    this.threadCount = threadCount;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public Map<Integer, Double> getDistances() {
+    Map<Integer, Double> combinedDistances = new HashMap<Integer, Double>();
+    for (Map<Integer, Double> distanceMap : distanceMaps) {
+      combinedDistances.putAll(distanceMap);
+    }
+    return combinedDistances;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public Double getDistance(int docId) {
+    for (Map<Integer, Double> distanceMap : distanceMaps) {
+      Double distance = distanceMap.get(docId);
+      if (distance != null) {
+        return distance;
+      }
+    }
+    return null;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public BitSet bits(final IndexReader reader, final BitSet bits) throws IOException {
+    final LocationDataSet dataSet = dataSetFactory.buildLocationDataSet(reader);
+
+    int maxLength = bits.length();
+    int threadSize = maxLength / threadCount;
+
+    List<Callable<IterationResult>> tasks = new ArrayList<Callable<IterationResult>>();
+
+    long startTime = System.currentTimeMillis();
+
+    for (int i = 0; i < threadCount; i++) {
+      final int start = i * threadSize;
+      final int end = Math.min((i + 1) * threadSize, maxLength);
+      tasks.add(new Callable<IterationResult>() {
+        public IterationResult call() throws Exception {
+          return iterate(dataSet, bits, start, end, end - start, reader);
+        }
+      });
+      if (log.isLoggable(Level.FINE)) {
+        log.fine(String.format("Created thread starting at %d and ending at %d", start, end));
+      }
+    }
+
+    BitSet result = new BitSet(bits.cardinality());
+
+    try {
+      List<Future<IterationResult>> results = executorService.invokeAll(tasks);
+      for (Future<IterationResult> resultFuture : results) {
+        IterationResult iterationResult = resultFuture.get();
+        result.or(iterationResult.getBitSet());
+        distanceMaps.add(iterationResult.getDistanceById());
+      }
+    } catch (InterruptedException ie) {
+      throw new RuntimeException("InterruptedException thrown while executing tasks", ie);
+    } catch (ExecutionException ee) {
+      throw new RuntimeException("ExecutionException thrown while retrieving results of tasks", ee);
+    }
+
+    nextOffset += reader.maxDoc();
+    long endTime = System.currentTimeMillis();
+    if (log.isLoggable(Level.FINE)) {
+      log.fine(String.format("Filter took %dms to complete", endTime - startTime));
+    }
+    return result;
+  }
+
+  // ================================================ Helper Methods =================================================
+
+  /**
+   * Iterates over the set bits in the given BitSet from the given start to end range, calculating the distance of the
+   * documents and determining which are within the distance radius of the central point.
+   *
+   * @param dataSet LocationDataSet containing the document locations that can be used to calculate the distance each
+   *                document is from the central point
+   * @param originalBitSet BitSet which has bits set identifying which documents should be checked to see if their
+   *                       distance falls within the radius
+   * @param start Index in the BitSet that the method will start at
+   * @param end Index in the BitSet that the method will stop at
+   * @param size Size the the resulting BitSet should be created at (most likely end - start)
+   * @param reader IndexReader for checking if the document has been deleted
+   * @return IterationResult containing all the results of the method.
+   */
+  protected IterationResult iterate(LocationDataSet dataSet, BitSet originalBitSet, int start, int end, int size, IndexReader reader) {
+    BitSet bitSet = new BitSet(size);
+
+    Map<Integer, Double> distanceById = new HashMap<Integer, Double>();
+
+    long startTime = System.currentTimeMillis();
+    int docId = originalBitSet.nextSetBit(start);
+    while (docId != -1 && docId < end) {
+      if (reader.isDeleted(docId)) {
+        docId = originalBitSet.nextSetBit(docId + 1);
+        continue;
+      }
+
+      Point2D point = dataSet.getPoint(docId);
+      double distance = distanceCalculator.calculate(lat, lng, point.getX(), point.getY(), unit);
+      if (distance < radius) {
+        bitSet.set(docId);
+        distanceById.put(docId + nextOffset, distance);
+      }
+
+      docId = originalBitSet.nextSetBit(docId + 1);
+    }
+    long endTime = System.currentTimeMillis();
+    if (log.isLoggable(Level.FINE)) {
+      log.fine(String.format("Thread took %dms to complete", endTime - startTime));
+    }
+    return new IterationResult(bitSet, distanceById);
+  }
+
+  // ================================================= Inner Classes =================================================
+
+  /**
+   * Wrapper of the results from {@link ThreadedDistanceFilter#iterate(LocationDataSet, BitSet, int, int, int, IndexReader)}.
+   * This allows the method to operate in almost total isolation in separate threads.
+   */
+  protected class IterationResult {
+
+    private BitSet bitSet;
+    private Map<Integer, Double> distanceById;
+
+    /**
+     * Creates a new IterationResult that wraps the given BitSet
+     *
+     * @param bitSet BitSet to wrap
+     * @param distanceById Document IDs with their calculated distances
+     */
+    public IterationResult(BitSet bitSet, Map<Integer, Double> distanceById) {
+      this.bitSet = bitSet;
+      this.distanceById = distanceById;
+    }
+
+    /**
+     * Returns the wrapped BitSet
+     *
+     * @return Wrapped BitSet
+     */
+    public BitSet getBitSet() {
+      return bitSet;
+    }
+
+    /**
+     * Returns the document IDs and calculated distances contained in this result
+     *
+     * @return Document IDs and calculated distances contained in this result
+     */
+    public Map<Integer, Double> getDistanceById() {
+      return distanceById;
+    }
+  }
+}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/geometry/LatLng.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/geometry/LatLng.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/geometry/LatLng.java	Thu Jun 25 11:05:21 CEST 2009
@@ -17,12 +17,13 @@
 
 package org.apache.lucene.spatial.geometry;
 
+import org.apache.lucene.spatial.util.DistanceUnit;
 
+
 /**
  * Abstract base lat-lng class which can manipulate fixed point or floating
  * point based coordinates. Instances are immutable.
  * 
- * @see FixedLatLngTest
  * @see FloatLatLng
  * 
  */
@@ -99,7 +100,7 @@
    * @return Returns the distance in miles.
    */
   public double arcDistance(LatLng ll2) {
-    return arcDistance(ll2, DistanceUnits.MILES);
+    return arcDistance(ll2, DistanceUnit.MILES);
   }
 
   /**
@@ -113,7 +114,7 @@
    * 
    * @return Returns the distance in meters or miles.
    */
-  public double arcDistance(LatLng ll2, DistanceUnits lUnits) {
+  public double arcDistance(LatLng ll2, DistanceUnit lUnits) {
     LatLng ll1 = normalize();
     ll2 = ll2.normalize();
 
@@ -133,7 +134,7 @@
     double cosB = (Math.cos(a) * Math.cos(c))
         + (Math.sin(a) * Math.sin(c) * Math.cos(radians(dLon)));
 
-    double radius = (lUnits == DistanceUnits.MILES) ? 3963.205/* MILERADIUSOFEARTH */
+    double radius = (lUnits == DistanceUnit.MILES) ? 3963.205/* MILERADIUSOFEARTH */
     : 6378.160187/* KMRADIUSOFEARTH */;
 
     // Find angle subtended (with some bounds checking) in radians and
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceUtils.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceUtils.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/util/DistanceUtils.java	Thu Jun 25 11:06:47 CEST 2009
@@ -15,9 +15,9 @@
  * limitations under the License.
  */
 
-package org.apache.lucene.spatial.tier;
+package org.apache.lucene.spatial.util;
 
-import org.apache.lucene.spatial.geometry.DistanceUnits;
+import org.apache.lucene.spatial.util.DistanceUnit;
 import org.apache.lucene.spatial.geometry.FloatLatLng;
 import org.apache.lucene.spatial.geometry.LatLng;
 import org.apache.lucene.spatial.geometry.shape.LLRect;
@@ -26,15 +26,7 @@
 
 public class DistanceUtils {
 
-  static DistanceUtils instance = new DistanceUtils();
-  
-  public static DistanceUtils getInstance()
-  {
-    return instance;
-  }
-
-  
-  public double getDistanceMi(double x1, double y1, double x2, double y2) {
+  public static double getDistanceMi(double x1, double y1, double x2, double y2) {
     return getLLMDistance(x1, y1, x2, y2);
   }
 
@@ -45,19 +37,13 @@
    * @param miles
    * @return boundary rectangle where getY/getX is top left, getMinY/getMinX is bottom right
    */
-  public Rectangle getBoundary (double x1, double y1, double miles) {
-
-    LLRect box = LLRect.createBox( new FloatLatLng( x1, y1 ), miles, miles );
-    
-    //System.out.println("Box: "+maxX+" | "+ maxY+" | "+ minX + " | "+ minY);
-    return box.toRectangle();
-
+  public static Rectangle getBoundary(double x1, double y1, double miles) {
+    return LLRect.createBox(new FloatLatLng( x1, y1 ), miles, miles).toRectangle();
   }
   
-  public double getLLMDistance (double x1, double y1, double x2, double y2) {  
-
+  public static double getLLMDistance(double x1, double y1, double x2, double y2) {
     LatLng p1 = new FloatLatLng( x1, y1 );
     LatLng p2 = new FloatLatLng( x2, y2 );
-    return p1.arcDistance( p2, DistanceUnits.MILES );
+    return p1.arcDistance( p2, DistanceUnit.MILES );
   }
 }
Index: contrib/spatial/src/test/org/apache/lucene/spatial/tier/CartesianShapeFilterTest.java
===================================================================
--- contrib/spatial/src/test/org/apache/lucene/spatial/tier/CartesianShapeFilterTest.java	Wed Jul 01 10:51:22 CEST 2009
+++ contrib/spatial/src/test/org/apache/lucene/spatial/tier/CartesianShapeFilterTest.java	Wed Jul 01 10:51:22 CEST 2009
@@ -0,0 +1,116 @@
+package org.apache.lucene.spatial.tier;
+
+import org.apache.lucene.spatial.tier.projections.SinusoidalProjector;
+import org.apache.lucene.spatial.tier.projections.IProjector;
+import org.apache.lucene.spatial.tier.projections.CartesianTierPlotter;
+import org.apache.lucene.spatial.util.NumberUtils;
+import org.apache.lucene.spatial.util.GeoHashUtils;
+import org.apache.lucene.search.*;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.analysis.WhitespaceAnalyzer;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.io.IOException;
+
+import junit.framework.TestCase;
+
+/**
+ * Tests for {@link org.apache.lucene.spatial.tier.CartesianShapeFilter}
+ */
+public class CartesianShapeFilterTest extends TestCase {
+
+    private Directory directory;
+    private double lat = 38.969398;
+    private double lng = -77.386398;
+    private String latField = "lat";
+    private String lngField = "lng";
+    private List<CartesianTierPlotter> ctps = new LinkedList<CartesianTierPlotter>();
+    private String geoHashPrefix = "_geoHash_";
+
+    private IProjector project = new SinusoidalProjector();
+
+    public void testCartesianShapeFilter() throws IOException {
+        IndexSearcher searcher = new IndexSearcher(directory, true);
+        double miles = 0.5;
+
+        CartesianPolyFilterBuilder builder = new CartesianPolyFilterBuilder(CartesianTierPlotter.DEFALT_FIELD_PREFIX);
+        Filter cartesianShapeFilter = builder.getBoundingArea(lat, lng, miles);
+
+        Query termQuery = new TermQuery(new Term("metafile", "doc"));
+        Hits hits = searcher.search(termQuery, cartesianShapeFilter);
+
+        assertEquals(9, hits.length());
+    }
+
+    // ================================================ Helper Methods =================================================
+
+    protected void setUp() throws IOException {
+        directory = new RAMDirectory();
+        IndexWriter writer = new IndexWriter(directory, new WhitespaceAnalyzer(), true);
+        setUpPlotter(2, 15);
+        addData(writer);
+    }
+
+    private void setUpPlotter(int base, int top) {
+        for (; base <= top; base++) {
+            ctps.add(new CartesianTierPlotter(base, project,
+                    CartesianTierPlotter.DEFALT_FIELD_PREFIX));
+        }
+    }
+
+    private void addPoint(IndexWriter writer, String name, double lat, double lng) throws IOException {
+        Document doc = new Document();
+
+        doc.add(new Field("name", name, Field.Store.YES, Field.Index.TOKENIZED));
+
+        // convert the lat / long to lucene fields
+        doc.add(new Field(latField, NumberUtils.double2sortableStr(lat), Field.Store.YES, Field.Index.UN_TOKENIZED));
+        doc.add(new Field(lngField, NumberUtils.double2sortableStr(lng), Field.Store.YES, Field.Index.UN_TOKENIZED));
+
+        // add a default meta field to make searching all documents easy
+        doc.add(new Field("metafile", "doc", Field.Store.YES, Field.Index.TOKENIZED));
+
+        int ctpsize = ctps.size();
+        for (int i = 0; i < ctpsize; i++) {
+            CartesianTierPlotter ctp = ctps.get(i);
+            doc.add(new Field(ctp.getTierFieldName(),
+                    NumberUtils.double2sortableStr(ctp.getTierBoxId(lat, lng)),
+                    Field.Store.YES,
+                    Field.Index.NO_NORMS));
+
+            doc.add(new Field(geoHashPrefix, GeoHashUtils.encode(lat, lng),
+                    Field.Store.YES,
+                    Field.Index.NO_NORMS));
+        }
+        writer.addDocument(doc);
+    }
+
+    private void addData(IndexWriter writer) throws IOException {
+        addPoint(writer, "McCormick &amp; Schmick's Seafood Restaurant", 38.9579000, -77.3572000);
+        addPoint(writer, "Jimmy's Old Town Tavern", 38.9690000, -77.3862000);
+        addPoint(writer, "Ned Devine's", 38.9510000, -77.4107000);
+        addPoint(writer, "Old Brogue Irish Pub", 38.9955000, -77.2884000);
+        addPoint(writer, "Alf Laylah Wa Laylah", 38.8956000, -77.4258000);
+        addPoint(writer, "Sully's Restaurant &amp; Supper", 38.9003000, -77.4467000);
+        addPoint(writer, "TGIFriday", 38.8725000, -77.3829000);
+        addPoint(writer, "Potomac Swing Dance Club", 38.9027000, -77.2639000);
+        addPoint(writer, "White Tiger Restaurant", 38.9027000, -77.2638000);
+        addPoint(writer, "Jammin' Java", 38.9039000, -77.2622000);
+        addPoint(writer, "Potomac Swing Dance Club", 38.9027000, -77.2639000);
+        addPoint(writer, "WiseAcres Comedy Club", 38.9248000, -77.2344000);
+        addPoint(writer, "Glen Echo Spanish Ballroom", 38.9691000, -77.1400000);
+        addPoint(writer, "Whitlow's on Wilson", 38.8889000, -77.0926000);
+        addPoint(writer, "Iota Club and Cafe", 38.8890000, -77.0923000);
+        addPoint(writer, "Hilton Washington Embassy Row", 38.9103000, -77.0451000);
+        addPoint(writer, "HorseFeathers, Bar & Grill", 39.01220000000001, -77.3942);
+
+        writer.commit();
+        writer.close();
+    }
+}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/distance/LocationDataSet.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/distance/LocationDataSet.java	Fri Jul 03 14:56:48 CEST 2009
+++ contrib/spatial/src/java/org/apache/lucene/spatial/distance/LocationDataSet.java	Fri Jul 03 14:56:48 CEST 2009
@@ -0,0 +1,36 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.distance;
+
+import org.apache.lucene.spatial.geometry.shape.Point2D;
+
+/**
+ * LocationDataSet is an abstracts away the format of the data that defines the location of a document.  It means that
+ * different formats can be used, whether they be 2 fields for latitude and longitude, or 1 field with a geohash, without
+ * having to change the code that uses the data.
+ */
+public interface LocationDataSet {
+
+  /**
+   * Returns the point (defined by an x/y coordinate) of the document with the given id
+   *
+   * @param docId ID of the document whose point is to be returned
+   * @return Point (defined by an x/y coordinate) of the document with the given id
+   */
+  Point2D getPoint(int docId);
+}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/geometry/DistanceUnits.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/geometry/DistanceUnits.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/util/DistanceUnit.java	Fri Jul 03 15:04:22 CEST 2009
@@ -15,9 +15,67 @@
  * limitations under the License.
  */
 
-package org.apache.lucene.spatial.geometry;
+package org.apache.lucene.spatial.util;
 
-public enum DistanceUnits {
-  MILES,
-  KILOMETERS;
+/**
+ * Enum representing difference distance units, currently only kilometers and miles
+ */
+public enum DistanceUnit {
+
+  MILES("miles"),
+  KILOMETERS("km");
+
+  private String unit;
+
+  /**
+   * Creates a new DistanceUnit that represents the given unit
+   *
+   * @param unit Distance unit in String form
+   */
+  DistanceUnit(String unit) {
+    this.unit = unit;
-}
+  }
+
+  /**
+   * Returns the DistanceUnit which represents the given unit
+   *
+   * @param unit Unit whose DistanceUnit should be found
+   * @return DistanceUnit representing the unit
+   * @throws IllegalArgumentException if no DistanceUnit which represents the given unit is found
+   */
+  public static DistanceUnit findDistanceUnit(String unit) {
+    if (MILES.getUnit().equals(unit)) {
+      return MILES;
+    } else if (KILOMETERS.getUnit().equals(unit)) {
+      return KILOMETERS;
+    } else {
+      throw new IllegalArgumentException("Unknown distance unit " + unit);
+    }
+  }
+
+  /**
+   * Converts the given distance in the current DistanceUnit, to the distance in the given DistanceUnit
+   *
+   * @param distance Distance to convert
+   * @param to Unit of distance to convert to
+   * @return Given distance converted to the distance in the given uni
+   */
+  public double convert(double distance, DistanceUnit to) {
+    if (this == to) {
+      return distance;
+    } else if (MILES == to) {
+      return distance / 1.609344;
+    } else {
+      return distance * 1.609344;
+    }
+  }
+
+  /**
+   * Returns the string representation of the distance unit
+   *
+   * @return String representation of the distance unit
+   */
+  public String getUnit() {
+    return unit;
+  }
+}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceSortSource.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceSortSource.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceSortSource.java	Thu Jun 25 11:06:23 CEST 2009
@@ -25,11 +25,12 @@
 import org.apache.lucene.search.ScoreDocComparator;
 import org.apache.lucene.search.SortComparatorSource;
 import org.apache.lucene.search.SortField;
+import org.apache.lucene.spatial.distance.DistanceFilter;
 
 /**
  * 
  * @deprecated
- * @see DistanceFieldComparatorSource
+ * @see org.apache.lucene.spatial.DistanceFieldComparatorSource
  */
 public class DistanceSortSource implements SortComparatorSource {
 
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceHandler.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceHandler.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceHandler.java	Thu Jun 25 11:06:17 CEST 2009
@@ -17,6 +17,8 @@
 
 package org.apache.lucene.spatial.tier;
 
+import org.apache.lucene.spatial.util.DistanceUtils;
+
 import java.util.HashMap;
 import java.util.Map;
 
@@ -64,7 +66,7 @@
     // check to see if we have distances
     // if not calculate the distance
     if(distances == null){
-      return DistanceUtils.getInstance().getDistanceMi(centerLat, centerLng, lat, lng);
+      return DistanceUtils.getDistanceMi(centerLat, centerLng, lat, lng);
     }
     
     // check to see if the doc id has a cached distance
@@ -89,7 +91,7 @@
     }
     
     //all else fails calculate the distances    
-    return DistanceUtils.getInstance().getDistanceMi(centerLat, centerLng, lat, lng);
+    return DistanceUtils.getDistanceMi(centerLat, centerLng, lat, lng);
   }
   
   
Index: contrib/spatial/src/java/org/apache/lucene/spatial/distance/NoOpDistanceFilter.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/distance/NoOpDistanceFilter.java	Fri Jul 03 14:56:53 CEST 2009
+++ contrib/spatial/src/java/org/apache/lucene/spatial/distance/NoOpDistanceFilter.java	Fri Jul 03 14:56:53 CEST 2009
@@ -0,0 +1,59 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.distance;
+
+import org.apache.lucene.index.IndexReader;
+
+import java.util.Map;
+import java.util.BitSet;
+import java.util.Collections;
+import java.io.IOException;
+
+/**
+ * Implementation of {@link org.apache.lucene.spatial.distance.DistanceFilter} that does no actual filtering.  This means
+ * that there can always be a DistanceFilter instantiated in {@link org.apache.lucene.spatial.SpatialFilter}, but that
+ * the actual process of filtering documents by their distance, which is a computationally expensive process, doesn't
+ * always have to occur.
+ */
+public class NoOpDistanceFilter implements DistanceFilter {
+
+  private Map<Integer, Double> distancesById = Collections.EMPTY_MAP;
+
+  /**
+   * {@inheritDoc}
+   */
+  public Map<Integer, Double> getDistances() {
+    return distancesById;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public Double getDistance(int docId) {
+    return distancesById.get(docId);
+  }
+
+  /**
+   * Executes no filtering.  Simply returns the given BitSet
+   * <p/>
+   * {@inheritDoc}
+   */
+  public BitSet bits(IndexReader reader, BitSet bits) throws IOException {
+    return bits;
+  }
+}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/distance/GeoHashLocationDataSetFactory.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/distance/GeoHashLocationDataSetFactory.java	Fri Jul 03 14:56:29 CEST 2009
+++ contrib/spatial/src/java/org/apache/lucene/spatial/distance/GeoHashLocationDataSetFactory.java	Fri Jul 03 14:56:29 CEST 2009
@@ -0,0 +1,79 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.distance;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.spatial.geometry.shape.Point2D;
+import org.apache.lucene.spatial.util.GeoHashUtils;
+import org.apache.lucene.search.FieldCache;
+
+import java.io.IOException;
+
+/**
+ * Implementation of {@link org.apache.lucene.spatial.distance.LocationDataSetFactory} that supports location information
+ * being contained in a single geohashed field.
+ *
+ * @see org.apache.lucene.spatial.util.GeoHashUtils}
+ */
+public class GeoHashLocationDataSetFactory implements LocationDataSetFactory {
+
+  private final String geoHashField;
+
+  /**
+   * Creates a new GeoHashLocationDataSetFactory that will read from the field with the given name
+   *
+   * @param geoHashField Name of the field containing the geohashes
+   */
+  public GeoHashLocationDataSetFactory(String geoHashField) {
+    this.geoHashField = geoHashField;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public LocationDataSet buildLocationDataSet(IndexReader indexReader) throws IOException {
+    return new GeoHashLocationDataSet(FieldCache.DEFAULT.getStrings(indexReader, geoHashField));
+  }
+
+  // ================================================= Inner Classes =================================================
+
+  /**
+   * Implementation of LocationDataSet which uses a geohash stored in a single index field
+   */
+  private class GeoHashLocationDataSet implements LocationDataSet {
+
+    private String[] geoHashCache;
+
+    /**
+     * Creates a new GeoHashLocationDataSet which uses the values in the given index
+     *
+     * @param geoHashCache Array containing the values of the geohash field taken from the index
+     */
+    private GeoHashLocationDataSet(String[] geoHashCache) {
+      this.geoHashCache = geoHashCache;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public Point2D getPoint(int docId) {
+      double[] coords = GeoHashUtils.decode(geoHashCache[docId]);
+      return new Point2D(coords[0], coords[1]);
+    }
+  }
+}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/geometry/PlaneGeoDistanceCalculator.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/geometry/PlaneGeoDistanceCalculator.java	Fri Jul 03 14:58:23 CEST 2009
+++ contrib/spatial/src/java/org/apache/lucene/spatial/geometry/PlaneGeoDistanceCalculator.java	Fri Jul 03 14:58:23 CEST 2009
@@ -0,0 +1,50 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.geometry;
+
+import org.apache.lucene.spatial.util.DistanceUnit;
+
+/**
+ * Implementation of {@link org.apache.lucene.spatial.geometry.GeoDistanceCalculator} that assumes that the 2 points are
+ * on a flat plane.
+ * <p/>
+ * Obviously since the world is curved, this calculation with have some error.  However in many cases, the bigger the
+ * distance, the less important the error.  The impact of doing such a simple calculation is that the performance of
+ * calculating the distance of millions of points is considerably reduced.
+ */
+public class PlaneGeoDistanceCalculator implements GeoDistanceCalculator {
+
+  private final static double EARTH_CIRCUMFERENCE_MILES = 24901;
+  private final static double DISTANCE_PER_DEGREE = EARTH_CIRCUMFERENCE_MILES / 360;
+
+  /**
+   * {@inheritDoc}
+   */
+  public double calculate(
+      double sourceLongitude,
+      double sourceLatitude,
+      double targetLongitude,
+      double targetLatitude,
+      DistanceUnit unit) {
+
+    double px = targetLongitude - sourceLongitude;
+    double py = targetLatitude - sourceLatitude;
+    double distanceMiles = Math.sqrt(px * px + py * py) * DISTANCE_PER_DEGREE;
+    return DistanceUnit.MILES.convert(distanceMiles, unit);
+  }
+}
Index: contrib/spatial/src/test/org/apache/lucene/spatial/distance/ThreadedDistanceFilterTest.java
===================================================================
--- contrib/spatial/src/test/org/apache/lucene/spatial/distance/ThreadedDistanceFilterTest.java	Fri Jun 26 13:59:22 CEST 2009
+++ contrib/spatial/src/test/org/apache/lucene/spatial/distance/ThreadedDistanceFilterTest.java	Fri Jun 26 13:59:22 CEST 2009
@@ -0,0 +1,142 @@
+package org.apache.lucene.spatial.distance;
+
+import junit.framework.TestCase;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.ParallelReader;
+import org.apache.lucene.spatial.geometry.ArcDistanceCalculator;
+import org.apache.lucene.spatial.geometry.shape.Point2D;
+import org.apache.lucene.spatial.util.DistanceUnit;
+
+import java.io.IOException;
+import java.util.*;
+import java.util.concurrent.*;
+
+/**
+ * Tests for {@link org.apache.lucene.spatial.distance.ThreadedDistanceFilter}
+ */
+public class ThreadedDistanceFilterTest extends TestCase {
+
+    private final LocationDataSet locationDataSet = new LocationDataSet() {
+
+        private List<Point2D> points = Arrays.asList(new Point2D(4.53, 30.61), new Point2D(4.51, 31.01), new Point2D(5.69, 40.89));
+
+        public Point2D getPoint(int docId) {
+            return points.get(docId);
+        }
+    };
+
+
+    /**
+     * Pass condition: 2 threads with the correct start and end indexes are created based on the BitSet given in the method
+     *                 call, and the number of threads that were requested.
+     * @throws IOException Can be thrown by the ParallelReader which is used as the IndexReader for the test
+     */
+    public void testBits() throws IOException {
+        LocationDataSetFactory dataSetFactory = new LocationDataSetFactory() {
+            public LocationDataSet buildLocationDataSet(IndexReader indexReader) throws IOException {
+                return locationDataSet;
+            }
+        };
+
+        ExecutorService executorService = new ThreadPoolExecutor(2, 6, 8, TimeUnit.SECONDS, new LinkedBlockingDeque<Runnable>());
+
+        BitSet bitSet = new BitSet(13);
+        bitSet.set(2, 6);
+        bitSet.set(8, 9);
+        bitSet.set(11);
+
+        final List<IterateCallInfo> infoList = new ArrayList<IterateCallInfo>();
+        ThreadedDistanceFilter distanceFilter = new ThreadedDistanceFilter(4.52, 30.81, 30, DistanceUnit.MILES, dataSetFactory, new ArcDistanceCalculator(), executorService, 2) {
+
+            @Override
+            protected IterationResult iterate(LocationDataSet dataSet, BitSet originalBitSet, int start, int end, int size, IndexReader reader) {
+                infoList.add(new IterateCallInfo(start, end, size));
+                return new IterationResult(new BitSet(), Collections.EMPTY_MAP);
+            }
+        };
+
+        IndexReader indexReader = new ParallelReader() {
+            
+            @Override
+            public int maxDoc() {
+                return 0;
+            }
+        };
+
+        distanceFilter.bits(indexReader, bitSet);
+
+        assertEquals(2, infoList.size());
+        
+        IterateCallInfo callInfo = infoList.get(0);
+        assertEquals(0, callInfo.getStart());
+        assertEquals(6, callInfo.getEnd());
+        assertEquals(6, callInfo.getSize());
+
+        callInfo = infoList.get(1);
+        assertEquals(6, callInfo.getStart());
+        assertEquals(12, callInfo.getEnd());
+        assertEquals(6, callInfo.getSize());
+    }
+
+    /**
+     * Pass condition: Of the 3 documents with points, 1 is outside of the radius and should be filtered out, 1 has been
+     *                 deleted so it should also be filtered out, leaving just 1 that passes the filter.  Its distance
+     *                 should be recorded in the calculated distances of the filter
+     * @throws IOException Can be thrown by the ParallelReader which is used as the IndexReader for the test
+     */
+    public void testIterate() throws IOException {
+        IndexReader indexReader = new ParallelReader() {
+            @Override
+            public boolean isDeleted(int n) {
+                return n == 1;
+            }
+        };
+
+        BitSet bitSet = new BitSet(2);
+        bitSet.set(0);
+        bitSet.set(1);
+        bitSet.set(2);
+
+        ThreadedDistanceFilter distanceFilter = new ThreadedDistanceFilter(4.52, 30.81, 30, DistanceUnit.MILES, null, new ArcDistanceCalculator(), null, 0);
+
+        ThreadedDistanceFilter.IterationResult result = distanceFilter.iterate(locationDataSet, bitSet, 0, 3, 3, indexReader);
+        
+        assertNotNull(result);
+        
+        BitSet resultingBitSet = result.getBitSet();
+        assertNotNull(resultingBitSet);
+        assertTrue(resultingBitSet.get(0));
+        assertFalse(resultingBitSet.get(1));
+        assertFalse(resultingBitSet.get(2));
+
+        assertNotNull(distanceFilter.getDistances());
+        assertEquals(1, distanceFilter.getDistances().size());
+    }
+    
+    // ================================================= Inner Classes =================================================
+
+    private static class IterateCallInfo {
+
+        private int start;
+        private int end;
+        private int size;
+
+        private IterateCallInfo(int start, int end, int size) {
+            this.start = start;
+            this.end = end;
+            this.size = size;
+        }
+
+        public int getStart() {
+            return start;
+        }
+
+        public int getEnd() {
+            return end;
+        }
+
+        public int getSize() {
+            return size;
+        }
+    }
+}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceQueryBuilder.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceQueryBuilder.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/SpatialFilter.java	Fri Jul 03 15:04:11 CEST 2009
@@ -15,152 +15,223 @@
  * limitations under the License.
  */
 
-package org.apache.lucene.spatial.tier;
+package org.apache.lucene.spatial;
 
-import org.apache.lucene.search.ConstantScoreQuery;
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.Filter;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.QueryWrapperFilter;
-import org.apache.lucene.spatial.SerialChainFilter;
-import org.apache.lucene.spatial.geohash.GeoHashDistanceFilter;
+import org.apache.lucene.search.DocIdSet;
+import org.apache.lucene.spatial.distance.*;
+import org.apache.lucene.spatial.tier.CartesianPolyFilterBuilder;
+import org.apache.lucene.spatial.util.DistanceUnit;
+import org.apache.lucene.spatial.geometry.GeoDistanceCalculator;
+import org.apache.lucene.util.DocIdBitSet;
 
+import java.io.IOException;
+import java.util.BitSet;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.LinkedBlockingDeque;
 
-public class DistanceQueryBuilder {
+/**
+ * SpatialFilter is a proper Lucene Filter that filters out documents that are outside of a certain radius of a central
+ * point.  At the heart of the filtering process is the {@link org.apache.lucene.spatial.tier.CartesianShapeFilter} which
+ * uses cartesian tiers to filter out the majority of documents.  The remaining documents are sent through an instance of
+ * {@link org.apache.lucene.spatial.distance.DistanceFilter} which calculates the actual distance of each document.
+ * <p/>
+ * For maximum compatability, distances in both miles and kilometers are supported and for maximum performance, it is
+ * possible to disabled the {@link org.apache.lucene.spatial.distance.DistanceFilter} step.
+ */
+public class SpatialFilter extends Filter {
 
   private static final long serialVersionUID = 1L;
-  
+
-  public BoundaryBoxFilter latFilter;
-  public BoundaryBoxFilter lngFilter;
-  public DistanceFilter distanceFilter;
-  
-  private final double lat;
-  private final double lng;
-  private final double miles;
+  private DistanceFilter distanceFilter;
   private Filter cartesianFilter;
-  private boolean needPrecision = true;
+
   /**
-   * Create a distance query using
-   * a boundary box wrapper around a more precise
-   * DistanceFilter.
+   * Creates a new SpatialFilter which will filter out documents that are outside of the given radius from the central
+   * point defined by the given latitude and longitude
-   * 
+   *
-   * @see SerialChainFilter
-   * @param lat
-   * @param lng
-   * @param miles
+   * @param lat Latitude of the central point
+   * @param lng Longitude of the central point
+   * @param radius Radius from the central point that document must be within in order to pass the filter
+   * @param tierFieldPrefix Prefix of the fields that contain the cartesian tier information
    */
-  public DistanceQueryBuilder (double lat, double lng, double miles, 
-      String latField, String lngField, String tierFieldPrefix,boolean needPrecise){
-
-    this.lat = lat;
-    this.lng = lng;
-    this.miles = miles;
-    this.needPrecision = needPrecise;
-    
-    
-    CartesianPolyFilterBuilder cpf = new CartesianPolyFilterBuilder(tierFieldPrefix);
-    cartesianFilter = cpf.getBoundingArea(lat, lng, (int)miles);
-
-    /* create precise distance filter */
-    if( needPrecise)
-    	distanceFilter = new LatLongDistanceFilter(lat, lng, miles, latField, lngField);
-    
+  public SpatialFilter(double lat, double lng, double radius, String tierFieldPrefix) {
+    CartesianPolyFilterBuilder polyFilterBuilder = new CartesianPolyFilterBuilder(tierFieldPrefix);
+    cartesianFilter = polyFilterBuilder.getBoundingArea(lat, lng, radius);
+    distanceFilter = new NoOpDistanceFilter();
   }
 
   /**
-   * Create a distance query using
-   * a boundary box wrapper around a more precise
-   * DistanceFilter.
+   * Creates a new SpatialFilter that uses latitude and longitude information stored in two separate fields
-   * 
+   *
-   * @see SerialChainFilter
-   * @param lat
-   * @param lng
-   * @param miles
+   * @param lat Latitude of the central point
+   * @param lng Longitude of the central point
+   * @param radius Radius that a document must be within in order to pass the filter
+   * @param unit Unit of distance the radius is in
+   * @param latField Name of the field with the latitude values
+   * @param lngField Name of the field with the longitude values
+   * @param tierFieldPrefix Prefix of the fields that contain the cartesian tier information
+   * @param distanceCalculator GeoDistanceCalculator that will be used to calculate the distances between points in the
+   *                           distance filtering process
+   * @param executorService ExecutorService that will be used to manage any threads created as part of the distance
+   *                        filtering process
+   * @param threadCount Number of threads that the distance filtering process can use to multi-thread its work
    */
-  public DistanceQueryBuilder (double lat, double lng, double miles, 
-      String geoHashFieldPrefix, String tierFieldPrefix,boolean needPrecise){
+  public SpatialFilter(
+      double lat,
+      double lng,
+      double radius,
+      DistanceUnit unit,
+      String latField,
+      String lngField,
+      String tierFieldPrefix,
+      GeoDistanceCalculator distanceCalculator,
+      ExecutorService executorService,
+      int threadCount) {
 
-    this.lat = lat;
-    this.lng = lng;
-    this.miles = miles;
-    this.needPrecision = needPrecise;
-    
-    CartesianPolyFilterBuilder cpf = new CartesianPolyFilterBuilder(tierFieldPrefix);
-    cartesianFilter = cpf.getBoundingArea(lat, lng, (int)miles);
-
-    /* create precise distance filter */
-    if( needPrecise)
-    	distanceFilter = new GeoHashDistanceFilter(lat, lng, miles, geoHashFieldPrefix);
-    
+    this(lat, lng, radius, tierFieldPrefix);
+    LocationDataSetFactory dataSetFactory = new LatLongLocationDataSetFactory(latField, lngField);
+    distanceFilter = new ThreadedDistanceFilter(
+        lat,
+        lng,
+        radius,
+        unit,
+        dataSetFactory,
+        distanceCalculator,
+        executorService,
+        threadCount);
   }
 
-  
-   /**
+  /**
-  * Create a distance query using
-  * a boundary box wrapper around a more precise
-  * DistanceFilter.
+   * Creates a new SpatialFilter that uses latitude and longitude information stored in two separate fields.  This method
+   * assumes that all calculations are to be executed in the calling thread
-  * 
+   *
-  * @see SerialChainFilter
-  * @param lat
-  * @param lng
-  * @param miles
+   * @param lat Latitude of the central point
+   * @param lng Longitude of the central point
+   * @param radius Radius that a document must be within in order to pass the filter
+   * @param unit Unit of distance the radius is in
+   * @param latField Name of the field with the latitude values
+   * @param lngField Name of the field with the longitude values
+   * @param tierFieldPrefix Prefix of the fields that contain the cartesian tier information
+   * @param distanceCalculator GeoDistanceCalculator that will be used to calculate the distances between points in the
+   *                           distance filtering process
-  */
+   */
-  public Filter getFilter() {
-	Filter [] f;
-	int [] chain;
+  public SpatialFilter(
+      double lat,
+      double lng,
+      double radius,
+      DistanceUnit unit,
+      String latField,
+      String lngField,
+      String tierFieldPrefix,
+      GeoDistanceCalculator distanceCalculator) {
-	
+
-	if (needPrecision){
-		f = new Filter[]{cartesianFilter, distanceFilter};
-		chain = new int[] {SerialChainFilter.AND, 
-				SerialChainFilter.SERIALAND};
-	}else{
-		f= new Filter[]{cartesianFilter};
-		chain = new int[] {SerialChainFilter.AND};
+    this(
+        lat,
+        lng,
+        radius,
+        unit,
+        latField,
+        lngField,
+        tierFieldPrefix,
+        distanceCalculator,
+        new ThreadPoolExecutor(0, 1, 10, TimeUnit.SECONDS, new LinkedBlockingDeque<Runnable>(), new ThreadPoolExecutor.CallerRunsPolicy()),
+        1);
-	}
+  }
-    return new SerialChainFilter( f, chain );
-  }
-  
+
-  public Filter getFilter(Query query) {
-    QueryWrapperFilter qf = new QueryWrapperFilter(query);
+  /**
+   * Creates a new SpatialFilter that uses latitude and longitude information stored in a geohash in a single field
+   *
+   * @param lat Latitude of the central point
+   * @param lng Longitude of the central point
+   * @param radius Radius that a document must be within in order to pass the filter
+   * @param unit Unit of distance the radius is in
+   * @param geoHashFieldPrefix Prefix of the field containing the geohas information
+   * @param tierFieldPrefix Prefix of the fields that contain the cartesian tier information
+   * @param distanceCalculator GeoDistanceCalculator that will be used to calculate the distances between points in the
+   *                           distance filtering process
+   * @param executorService ExecutorService that will be used to manage any threads created as part of the distance
+   *                        filtering process
+   * @param threadCount Number of threads that the distance filtering process can use to multi-thread its work
+   */
+  public SpatialFilter(
+      double lat,
+      double lng,
+      double radius,
+      DistanceUnit unit,
+      String geoHashFieldPrefix,
+      String tierFieldPrefix,
+      GeoDistanceCalculator distanceCalculator,
+      ExecutorService executorService,
+      int threadCount) {
-    
+
-    Filter [] f;
-    int [] chain;
-    
-	if (needPrecision){
-		f = new Filter[]{cartesianFilter, qf, distanceFilter};
-		chain = new int[] {SerialChainFilter.AND, 
-	              SerialChainFilter.AND,
-	              SerialChainFilter.SERIALAND};
-	}else{
-		f= new Filter[]{cartesianFilter, qf};
-		chain = new int[] {SerialChainFilter.AND, 
-	              SerialChainFilter.AND};
+    this(lat, lng, radius, tierFieldPrefix);
+    LocationDataSetFactory dataSetFactory = new GeoHashLocationDataSetFactory(geoHashFieldPrefix);
+    distanceFilter = new ThreadedDistanceFilter(
+        lat,
+        lng,
+        radius,
+        unit,
+        dataSetFactory,
+        distanceCalculator,
+        executorService,
+        threadCount);
-	}
+  }
-    return new SerialChainFilter(f,chain); 
-  }
-    
+
-//  public Query getQuery() {
-//      return new ConstantScoreQuery(getFilter());
-//  }
+  /**
+   * Creates a new SpatialFilter that uses latitude and longitude information stored in a geohash in a single field.
+   * This method assumes that all calculations are to be executed in the calling thread
+   *
+   * @param lat Latitude of the central point
+   * @param lng Longitude of the central point
+   * @param radius Radius that a document must be within in order to pass the filter
+   * @param unit Unit of distance the radius is in
+   * @param geoHashFieldPrefix Prefix of the field containing the geohas information
+   * @param tierFieldPrefix Prefix of the fields that contain the cartesian tier information
+   * @param distanceCalculator GeoDistanceCalculator that will be used to calculate the distances between points in the
+   *                           distance filtering process
+   */
+  public SpatialFilter(
+      double lat,
+      double lng,
+      double radius,
+      DistanceUnit unit,
+      String geoHashFieldPrefix,
+      String tierFieldPrefix,
+      GeoDistanceCalculator distanceCalculator) {
 
-  
-  public Query getQuery(Query query){
-  	return new ConstantScoreQuery(getFilter(query));
+    this(
+        lat,
+        lng,
+        radius,
+        unit,
+        geoHashFieldPrefix,
+        tierFieldPrefix,
+        distanceCalculator,
+        new ThreadPoolExecutor(0, 1, 10, TimeUnit.SECONDS, new LinkedBlockingDeque<Runnable>(), new ThreadPoolExecutor.CallerRunsPolicy()),
+        1);
   }
-  
+
-  public double getLat() {
-    return lat;
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public DocIdSet getDocIdSet(IndexReader reader) throws IOException {
+    BitSet bitSet = cartesianFilter.bits(reader);
+    return new DocIdBitSet(distanceFilter.bits(reader, bitSet));
   }
 
-  public double getLng() {
-    return lng;
-  }
+  // =============================================== Getters / Setters ===============================================
 
-  public double getMiles() {
-    return miles;
+  /**
+   * Returns the instantiated {@link org.apache.lucene.spatial.distance.DistanceFilter}.
+   *
+   * @return Instantiated DistanceFilter.  Will always be non-null.
+   */
+  public DistanceFilter getDistanceFilter() {
+    return distanceFilter;
   }
-    
-  @Override
-  public String toString() {
-    return "DistanceQuery lat: " + lat + " lng: " + lng + " miles: "+ miles;
-  }
+}
-}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/BoundaryBoxFilter.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/BoundaryBoxFilter.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/tier/BoundaryBoxFilter.java	Thu Jun 25 11:05:55 CEST 2009
@@ -26,10 +26,9 @@
 import org.apache.lucene.index.TermDocs;
 import org.apache.lucene.index.TermEnum;
 import org.apache.lucene.search.Filter;
-import org.apache.lucene.spatial.NumberUtils;
+import org.apache.lucene.spatial.util.NumberUtils;
 
 
-
 /**
  * An implementation of org.apache.lucene.search.RangeFilter that
  * caches values extracted from the index.
Index: contrib/spatial/src/test/org/apache/lucene/spatial/tier/PolyShape.java
===================================================================
--- contrib/spatial/src/test/org/apache/lucene/spatial/tier/PolyShape.java	(revision 790889)
+++ contrib/spatial/src/test/org/apache/lucene/spatial/tier/PolyShape.java	(revision 790889)
@@ -1,38 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.tier;
-
-
-/**
- *
- */
-public class PolyShape {
-
-  private static double lat = 38.969398; 
-  private static double lng= -77.386398;
-  private static int miles = 1000;
-  /**
-   * @param args
-   */
-  public static void main(String[] args) {
-  
-    CartesianPolyFilterBuilder cpf = new CartesianPolyFilterBuilder( "_localTier" );
-    cpf.getBoxShape(lat, lng, miles);
-    
-  }
-
-}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceFieldComparatorSource.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceFieldComparatorSource.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/DistanceFieldComparatorSource.java	Thu Jun 25 11:07:07 CEST 2009
@@ -15,15 +15,15 @@
  * limitations under the License.
  */
 
-package org.apache.lucene.spatial.tier;
+package org.apache.lucene.spatial;
 
 import java.io.IOException;
 
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.Filter;
 import org.apache.lucene.search.FieldComparator;
 import org.apache.lucene.search.FieldComparatorSource;
 import org.apache.lucene.search.SortField;
+import org.apache.lucene.spatial.distance.DistanceFilter;
 
 public class DistanceFieldComparatorSource extends FieldComparatorSource {
 
@@ -32,10 +32,8 @@
 	private DistanceFilter distanceFilter;
 	private DistanceScoreDocLookupComparator dsdlc;
 
-	public DistanceFieldComparatorSource(Filter distanceFilter) {
-
-		this.distanceFilter = (DistanceFilter) distanceFilter;
-
+	public DistanceFieldComparatorSource(DistanceFilter distanceFilter) {
+		this.distanceFilter = distanceFilter;
 	}
 
 	public void cleanUp() {
@@ -60,7 +58,7 @@
 		private double[] values;
 		private double bottom;
 		private int offset =0;
-		
+
 		public DistanceScoreDocLookupComparator(DistanceFilter distanceFilter,
 				int numHits) {
 			this.distanceFilter = distanceFilter;
@@ -87,7 +85,7 @@
 		@Override
 		public int compareBottom(int doc) {
 			double v2 = distanceFilter.getDistance(doc+ offset);
-			
+
 			if (bottom > v2) {
 				return 1;
 			} else if (bottom < v2) {
@@ -110,7 +108,7 @@
 		@Override
 		public void setNextReader(IndexReader reader, int docBase,
 				int numSlotsFull) throws IOException {
-			
+
 			// each reader in a segmented base
 			// has an offset based on the maxDocs of previous readers
 			offset = docBase;
Index: contrib/spatial/src/java/org/apache/lucene/spatial/distance/LocationDataSetFactory.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/distance/LocationDataSetFactory.java	Fri Jul 03 14:56:48 CEST 2009
+++ contrib/spatial/src/java/org/apache/lucene/spatial/distance/LocationDataSetFactory.java	Fri Jul 03 14:56:48 CEST 2009
@@ -0,0 +1,37 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.distance;
+
+import org.apache.lucene.index.IndexReader;
+
+import java.io.IOException;
+
+/**
+ * Factory for instances of {@link org.apache.lucene.spatial.distance.LocationDataSet}
+ */
+public interface LocationDataSetFactory {
+
+  /**
+   * Builds a LocationDataSet based on the data read from the given IndexReader
+   *
+   * @param indexReader IndexReader from where the location data will be read
+   * @return LocationDataSet representing the location data of the documents in the index
+   * @throws IOException Can be thrown while reading from the IndexReader
+   */
+  LocationDataSet buildLocationDataSet(IndexReader indexReader) throws IOException;
+}
Index: contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestDistance.java
===================================================================
--- contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestDistance.java	(revision 790889)
+++ contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestDistance.java	(revision 790889)
@@ -1,146 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.tier;
-
-import java.io.IOException;
-import java.util.BitSet;
-
-import junit.framework.TestCase;
-
-import org.apache.lucene.analysis.WhitespaceAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.spatial.NumberUtils;
-import org.apache.lucene.spatial.tier.LatLongDistanceFilter;
-import org.apache.lucene.store.RAMDirectory;
-
-
-/**
- *
- */
-public class TestDistance extends TestCase{
-
-  
-  private RAMDirectory directory;
-  private IndexSearcher searcher;
-  // reston va
-  private double lat = 38.969398; 
-  private double lng= -77.386398;
-  private String latField = "lat";
-  private String lngField = "lng";
-  private IndexWriter writer;
-  
-  @Override
-  protected void setUp() throws IOException {
-    directory = new RAMDirectory();
-    writer = new IndexWriter(directory, new WhitespaceAnalyzer(), true);
-    addData(writer);
-    
-  }
-
-  @Override
-  protected void tearDown() throws IOException {
-    writer.close();
-  }
-  
-  private void addPoint(IndexWriter writer, String name, double lat, double lng) throws IOException{
-    
-    Document doc = new Document();
-    
-    doc.add(new Field("name", name,Field.Store.YES, Field.Index.TOKENIZED));
-    
-    // convert the lat / long to lucene fields
-    doc.add(new Field(latField, NumberUtils.double2sortableStr(lat),Field.Store.YES, Field.Index.UN_TOKENIZED));
-    doc.add(new Field(lngField, NumberUtils.double2sortableStr(lng),Field.Store.YES, Field.Index.UN_TOKENIZED));
-    
-    // add a default meta field to make searching all documents easy 
-    doc.add(new Field("metafile", "doc",Field.Store.YES, Field.Index.TOKENIZED));
-    writer.addDocument(doc);
-    
-  }
-  
-
-  private void addData(IndexWriter writer) throws IOException {
-    addPoint(writer,"McCormick &amp; Schmick's Seafood Restaurant",38.9579000,-77.3572000);
-    addPoint(writer,"Jimmy's Old Town Tavern",38.9690000,-77.3862000);
-    addPoint(writer,"Ned Devine's",38.9510000,-77.4107000);
-    addPoint(writer,"Old Brogue Irish Pub",38.9955000,-77.2884000);
-    addPoint(writer,"Alf Laylah Wa Laylah",38.8956000,-77.4258000);
-    addPoint(writer,"Sully's Restaurant &amp; Supper",38.9003000,-77.4467000);
-    addPoint(writer,"TGIFriday",38.8725000,-77.3829000);
-    addPoint(writer,"Potomac Swing Dance Club",38.9027000,-77.2639000);
-    addPoint(writer,"White Tiger Restaurant",38.9027000,-77.2638000);
-    addPoint(writer,"Jammin' Java",38.9039000,-77.2622000);
-    addPoint(writer,"Potomac Swing Dance Club",38.9027000,-77.2639000);
-    addPoint(writer,"WiseAcres Comedy Club",38.9248000,-77.2344000);
-    addPoint(writer,"Glen Echo Spanish Ballroom",38.9691000,-77.1400000);
-    addPoint(writer,"Whitlow's on Wilson",38.8889000,-77.0926000);
-    addPoint(writer,"Iota Club and Cafe",38.8890000,-77.0923000);
-    addPoint(writer,"Hilton Washington Embassy Row",38.9103000,-77.0451000);
-    addPoint(writer,"HorseFeathers, Bar & Grill", 39.01220000000001, -77.3942);
-    writer.flush();
-  }
-
-  public void testLatLongFilterOnDeletedDocs() throws Exception {
-    writer.deleteDocuments(new Term("name", "Potomac"));
-    IndexReader r = writer.getReader();
-    LatLongDistanceFilter f = new LatLongDistanceFilter(lat, lng, 1.0, latField, lngField);
-    f.bits(r);
-
-    BitSet allSet = new BitSet(r.maxDoc());
-    allSet.set(0, r.maxDoc());
-    f.bits(r, allSet);
-    r.close();
-  }
- 
-  
-  public void testMiles() {
-    double LLM = DistanceUtils.getInstance().getLLMDistance(lat, lng,39.012200001, -77.3942);
-    System.out.println(LLM);
-    System.out.println("-->"+DistanceUtils.getInstance().getDistanceMi(lat, lng, 39.0122, -77.3942));
-  }
-  
-  public void testMiles2(){
-    System.out.println("Test Miles 2");
-    double LLM = DistanceUtils.getInstance().getLLMDistance(44.30073, -78.32131,43.687267, -79.39842);
-    System.out.println(LLM);
-    System.out.println("-->"+DistanceUtils.getInstance().getDistanceMi(44.30073, -78.32131, 43.687267, -79.39842));
-    
-  }
-
-  
-//  public void testDistanceQueryCacheable() throws IOException {
-//
-//    // create two of the same distance queries
-//    double miles = 6.0;
-//    DistanceQuery dq1 = new DistanceQuery(lat, lng, miles, latField, lngField, true);
-//    DistanceQuery dq2 = new DistanceQuery(lat, lng, miles, latField, lngField, true);
-//
-//    /* ensure that they hash to the same code, which will cause a cache hit in solr */
-//    System.out.println("hash differences?");
-//    assertEquals(dq1.getQuery().hashCode(), dq2.getQuery().hashCode());
-//    
-//    /* ensure that changing the radius makes a different hash code, creating a cache miss in solr */
-//    DistanceQuery widerQuery = new DistanceQuery(lat, lng, miles + 5.0, latField, lngField, false);
-//    assertTrue(dq1.getQuery().hashCode() != widerQuery.getQuery().hashCode());
-//  }
-}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/SerialChainFilter.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/SerialChainFilter.java	(revision 790889)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/SerialChainFilter.java	(revision 790889)
@@ -1,214 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial;
-
-import java.io.IOException;
-import java.util.BitSet;
-
-import org.apache.lucene.index.CorruptIndexException;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.DocIdSet;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.util.DocIdBitSet;
-
-/**
- * 
- * Provide a serial chain filter, passing the bitset in with the
- * index reader to each of the filters in an ordered fashion.
- * 
- * Based off chain filter, but with some improvements to allow a narrowed down
- * filtering. Traditional filter required iteration through an IndexReader.
- * 
- * By implementing the ISerialChainFilter class, you can create a bits(IndexReader reader, BitSet bits)
- * @see org.apache.lucene.search.ISerialChainFilter
- * 
- */
-public class SerialChainFilter extends Filter {
-
-  /**
-   * $Id: SerialChainFilter.java 136 2008-12-17 16:16:38Z ryantxu $
-   */
-  private static final long serialVersionUID = 1L;
-  private Filter chain[];
-  public static final int SERIALAND = 1;
-  public static final int SERIALOR = 2;
-  public static final int AND = 3;  // regular filters may be used first
-  public static final int OR = 4;    // regular filters may be used first
-  public static final int DEFAULT = SERIALOR;
-  
-  private int actionType[];
-  
-  public SerialChainFilter(Filter chain[]){
-    this.chain = chain;
-    this.actionType = new int[] {DEFAULT};
-  }
-  
-  public SerialChainFilter(Filter chain[], int actionType[]){
-    this.chain= chain;
-    this.actionType = actionType;
-  }
-  
-  /* (non-Javadoc)
-   * @see org.apache.lucene.search.Filter#bits(org.apache.lucene.index.IndexReader)
-   */
-  @Override
-  public BitSet bits(IndexReader reader) throws IOException {
-	  return ((DocIdBitSet)getDocIdSet(reader)).getBitSet();
-  }
-  
-  
-  /* (non-Javadoc)
-   * @see org.apache.lucene.search.Filter#getDocIdSet(org.apache.lucene.index.IndexReader)
-   */
-  @Override
-  public DocIdSet getDocIdSet(IndexReader reader) throws CorruptIndexException, IOException {
-    
-    BitSet bits = new BitSet(reader.maxDoc());
-    int chainSize = chain.length;
-    int actionSize = actionType.length;
-    int i = 0;
-    
-    /**
-     * taken from ChainedFilter, first and on an empty bitset results in 0
-     */
-    if (actionType[i] == AND){
-       try {
-      	//System.out.println(chain[i] );
-        bits = (BitSet) ((DocIdBitSet)chain[i].getDocIdSet(reader)).getBitSet().clone();
-      } catch (IOException e) {
-        // TODO Auto-generated catch block
-        e.printStackTrace();
-      }
-      ++i;
-    }
-    
-    for( ; i < chainSize; i++) {
-    	
-      int action = (i < actionSize)? actionType[i]: DEFAULT;
-      //System.out.println(chain[i] + ": "+  action);
-      switch (action){
-      
-      case (SERIALAND):
-        try {
-            bits.and(((ISerialChainFilter) chain[i]).bits(reader, bits));
-          } catch (CorruptIndexException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-          } catch (IOException e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-          } catch (Exception e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-          }
-        break;
-      case (SERIALOR):
-        try {
-            bits.or(((ISerialChainFilter) chain[i]).bits(reader,bits));
-          } catch (Exception e) {
-            // TODO Auto-generated catch block
-            e.printStackTrace();
-          }
-        break;
-      case (AND):
-        bits.and(chain[i].bits(reader));
-        break;
-      case (OR):
-        bits.or(((DocIdBitSet)chain[i].getDocIdSet(reader)).getBitSet());
-        break;
-      }
-    }
-    
-//    System.out.println("++++++====================");
-//    new Exception().printStackTrace();
-    
-    return new DocIdBitSet(bits);
-  }
-
-  /**
-   * @return the chain
-   */
-  Filter[] getChain() {
-    return chain;
-  }
-
-  /**
-   * @return the actionType
-   */
-  int[] getActionType() {
-    return actionType;
-  }
-
-  /** 
-   * Returns true if <code>o</code> is equal to this.
-   * 
-   * @see org.apache.lucene.search.RangeFilter#equals
-   */
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (!(o instanceof SerialChainFilter)) return false;
-    SerialChainFilter other = (SerialChainFilter) o;
-
-    if (this.chain.length != other.getChain().length ||
-      this.actionType.length != other.getActionType().length)
-      return false;
-    
-    for (int i = 0; i < this.chain.length; i++) {
-      if (this.actionType[i] != other.getActionType()[i]  ||
-        (!this.chain[i].equals(other.getChain()[i])))
-        return false;
-    }
-    return true;
-  }
-    
-  /** 
-   * Returns a hash code value for this object.
-   * 
-   * @see org.apache.lucene.search.RangeFilter#hashCode
-   */
-  @Override
-  public int hashCode() {
-    if (chain.length == 0)
-      return 0;
-
-    int h = chain[0].hashCode() ^ new Integer(actionType[0]).hashCode(); 
-    for (int i = 1; i < this.chain.length; i++) {
-      h ^= chain[i].hashCode();
-      h ^= new Integer(actionType[i]).hashCode();
-    }
-    return h;
-  }
-  
-  @Override
-  public String toString() {
-    StringBuffer buf = new StringBuffer();
-    buf.append("SerialChainFilter(");
-    for (int i = 0; i < chain.length; i++) {
-      switch(actionType[i]) {
-        case (SERIALAND): buf.append("SERIALAND"); break;
-        case (SERIALOR):  buf.append("SERIALOR");  break;
-        case (AND):       buf.append("AND");       break;
-        case (OR):        buf.append("OR");        break;
-        default:          buf.append(actionType[i]);
-      }
-      buf.append(" " + chain[i].toString() + " ");
-    }
-    return buf.toString().trim() + ")";
-  }
-}
Index: contrib/spatial/src/test/org/apache/lucene/spatial/geometry/PlaneGeoDistanceCalculatorTest.java
===================================================================
--- contrib/spatial/src/test/org/apache/lucene/spatial/geometry/PlaneGeoDistanceCalculatorTest.java	Thu Jun 25 11:09:04 CEST 2009
+++ contrib/spatial/src/test/org/apache/lucene/spatial/geometry/PlaneGeoDistanceCalculatorTest.java	Thu Jun 25 11:09:04 CEST 2009
@@ -0,0 +1,26 @@
+package org.apache.lucene.spatial.geometry;
+
+import junit.framework.TestCase;
+import org.apache.lucene.spatial.util.DistanceUnit;
+
+/**
+ * Tests for {@link org.apache.lucene.spatial.geometry.PlaneGeoDistanceCalculator}
+ */
+public class PlaneGeoDistanceCalculatorTest extends TestCase {
+
+    /**
+     * Pass condition: The distance calculated in miles matches the expected distance
+     */
+    public void testCalculate_miles() {
+        double distance = new PlaneGeoDistanceCalculator().calculate(4.51, 53.85, 9.68, 43.22, DistanceUnit.MILES);
+        assertEquals(817.6220401155788, distance);
+    }
+
+    /**
+     * Pass condition: The distance calculated in kilometers matches the expected distance
+     */
+    public void testCalculate_kilometers() {
+        double distance = new PlaneGeoDistanceCalculator().calculate(4.51, 53.85, 9.68, 43.22, DistanceUnit.KILOMETERS);
+        assertEquals(1315.835124527766, distance);
+    }
+}
Index: contrib/spatial/src/test/org/apache/lucene/spatial/geometry/ArcDistanceCalculatorTest.java
===================================================================
--- contrib/spatial/src/test/org/apache/lucene/spatial/geometry/ArcDistanceCalculatorTest.java	Thu Jun 25 11:09:04 CEST 2009
+++ contrib/spatial/src/test/org/apache/lucene/spatial/geometry/ArcDistanceCalculatorTest.java	Thu Jun 25 11:09:04 CEST 2009
@@ -0,0 +1,26 @@
+package org.apache.lucene.spatial.geometry;
+
+import junit.framework.TestCase;
+import org.apache.lucene.spatial.util.DistanceUnit;
+
+/**
+ * Tests for {@link org.apache.lucene.spatial.geometry.ArcDistanceCalculator}
+ */
+public class ArcDistanceCalculatorTest extends TestCase {
+
+    /**
+     * Pass condition: The distance calculated in miles matches the expected distance
+     */
+    public void testCalculate_miles() {
+        double distance = new ArcDistanceCalculator().calculate(4.51, 53.85, 9.68, 43.22, DistanceUnit.MILES);
+        assertEquals(771.9580677520433, distance);
+    }
+
+    /**
+     * Pass condition: The distance calculated in kilometers matches the expected distance
+     */
+    public void testCalculate_kilometers() {
+        double distance = new ArcDistanceCalculator().calculate(4.51, 53.85, 9.68, 43.22, DistanceUnit.KILOMETERS);
+        assertEquals(1242.3460845883446, distance);
+    }
+}
