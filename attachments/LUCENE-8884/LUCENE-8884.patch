diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/MappingCharFilter.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/MappingCharFilter.java
index 5fffda9..5058759 100644
--- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/MappingCharFilter.java
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/charfilter/MappingCharFilter.java
@@ -172,7 +172,7 @@ public class MappingCharFilter extends BaseCharFilter {
         }
         return ret;
       }
-    }
+ }
   }
 
   @Override
diff --git a/lucene/misc/src/java/org/apache/lucene/store/IOTrackingDirectoryWrapper.java b/lucene/misc/src/java/org/apache/lucene/store/IOTrackingDirectoryWrapper.java
new file mode 100644
index 0000000..007b602
--- /dev/null
+++ b/lucene/misc/src/java/org/apache/lucene/store/IOTrackingDirectoryWrapper.java
@@ -0,0 +1,238 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.store;
+
+import java.io.IOException;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.LongAdder;
+
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.FilterDirectory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.RandomAccessInput;
+import org.apache.lucene.util.CloseableThreadLocal;
+
+/** Tracks input bytes and IOPs, by query.  Note that this likely incurs a small performance penalty, so it's
+ *  best to use it only when running profiling/benchmarks. */
+public class IOTrackingDirectoryWrapper extends FilterDirectory {
+
+  /** Tracks per-query IO counters */
+  public static final class IOCounters {
+
+    /** How many bytes the query read. */
+    public final LongAdder bytesRead = new LongAdder();
+
+    /** How many IO read operations executed by the query. */
+    public final LongAdder ioCount = new LongAdder();
+
+    // TODO: separate counters for seeking?  For random access IO?  Clone()?
+  }
+
+  private final CloseableThreadLocal<IOCounters> threadCounters = new CloseableThreadLocal<>();
+  private final ConcurrentHashMap<Object, IOCounters> countersByKey = new ConcurrentHashMap<>();
+
+  public IOTrackingDirectoryWrapper(Directory in) {
+    super(in);
+  }
+
+  /** Call this to notify us that this thread is now working on this query, uniquely
+   *  identified by the provided key.  Do not pass Query as the key unless you can be
+   *  certain the same Query is never run at the same time (in different threads)!
+   *
+   *  @param key the per-query unique object to track counters for this query */
+  public void setKeyForThread(Object key) {
+    threadCounters.set(countersByKey.computeIfAbsent(key, k -> new IOCounters()));
+  }
+
+  /** Returns counters for the provided query and clears this query from the internal map.
+    * @see #setKeyForThread */
+  public IOCounters getAndClearIOCountersByKey(Object key) {
+    return countersByKey.remove(key);
+  }
+
+  /** Tracks IO operation count and total bytes of an open IndexInput. */
+  private class IOTrackingIndexInput extends IndexInput {
+    private final IndexInput input;
+
+    // Counters to use for whole lifetime of this IndexInput -- Lucene always clones a thread-private
+    // IndexInput up front, so that same thread will only/always invoke the methods:
+    private final IOCounters counters;
+
+    private final Thread initThread;
+
+    public IOTrackingIndexInput(String resourceDescription, IndexInput in) {
+      super(resourceDescription);
+      this.input = in;
+      this.counters = threadCounters.get();
+      initThread = Thread.currentThread();
+    }
+
+    private void increment(int numBytes) {
+      // Paranoia: make sure the thread used to clone (init) the IndexInput is the same thread that consumes it
+      assert Thread.currentThread() == initThread;
+      // We must check for null, because not all IO is due to a Query, e.g. when IndexReader is first opened
+      // it does lots of IO to read index file headers, etc.:
+      if (counters != null) {
+        counters.ioCount.increment();
+        counters.bytesRead.add(numBytes);
+      }
+    }
+
+    @Override
+    public void readBytes(byte[] b, int offset, int len) throws IOException {
+      input.readBytes(b, offset, len);
+      increment(len);
+    }
+
+    @Override
+    public byte readByte() throws IOException {
+      byte b = input.readByte();
+      increment(1);
+      return b;
+    }
+
+    @Override
+    public short readShort() throws IOException {
+      short s = input.readShort();
+      increment(Short.BYTES);
+      return s;
+    }
+
+    @Override
+    public int readInt() throws IOException {
+      int i = input.readInt();
+      increment(Integer.BYTES);
+      return i;
+    }
+
+    @Override
+    public long readLong() throws IOException {
+      long l = input.readLong();
+      increment(Long.BYTES);
+      return l;
+    }
+
+    @Override
+    public void close() throws IOException {
+      input.close();
+    }
+
+    @Override
+    public long getFilePointer() {
+      return input.getFilePointer();
+    }
+
+    @Override
+    public IOTrackingIndexInput clone() {
+      return new IOTrackingIndexInput("Clone of " + toString(), input.clone());
+    }
+
+    @Override
+    public void seek(long pos) throws IOException {
+      // TODO: increment IO counters here?
+      input.seek(pos);
+    }
+
+    @Override
+    public long length() {
+      return input.length();
+    }
+
+    @Override
+    public IndexInput slice(String sliceDescription, long offset, long length) throws IOException {
+      return new IOTrackingIndexInput(getFullSliceDescription(sliceDescription),
+                                      input.slice(sliceDescription, offset, length));
+    }
+
+    @Override
+    public RandomAccessInput randomAccessSlice(long offset, long length) throws IOException {
+      return new IOTrackingRandomAccessInput(input.randomAccessSlice(offset, length));
+    }
+  }
+
+  /** RandomAccessInput implementation that tracks IO operation count and total bytes. */
+  private class IOTrackingRandomAccessInput implements RandomAccessInput {
+    private final RandomAccessInput input;
+
+    // Counters to use for whole lifetime of this RandomAccessInput -- Lucene always clones a thread-private
+    // RandomAccessInput up front, so that same thread will only/always invoke the methods:
+    private final IOCounters counters;
+
+    private final Thread initThread;
+
+    public IOTrackingRandomAccessInput(RandomAccessInput input) {
+      this.input = input;
+      this.counters = threadCounters.get();
+      initThread = Thread.currentThread();
+    }
+
+    private void increment(int numBytes) {
+      // Paranoia: make sure the thread used to clone (init) the RandomAccessInput is the same thread that consumes it
+      assert Thread.currentThread() == initThread;
+      // We must check for null, because not all IO is due to a Query, e.g. when IndexReader is first opened
+      // it does lots of IO to read index file headers, etc.:
+      if (counters != null) {
+        counters.bytesRead.add(numBytes);
+        counters.ioCount.increment();
+      }
+    }
+
+    @Override
+    public byte readByte(long pos) throws IOException {
+      byte b = input.readByte(pos);
+      increment(Byte.BYTES);
+      return b;
+    }
+
+    @Override
+    public short readShort(long pos) throws IOException {
+      short s = input.readShort(pos);
+      increment(Short.BYTES);
+      return s;
+    }
+
+    @Override
+    public int readInt(long pos) throws IOException {
+      int i = input.readInt(pos);
+      increment(Integer.BYTES);
+      return i;
+    }
+
+    @Override
+    public long readLong(long pos) throws IOException {
+      long l = input.readLong(pos);
+      increment(Long.BYTES);
+      return l;
+    }
+  }
+
+  @Override
+  public IndexInput openInput(String name, IOContext ioContext) throws IOException {
+    return new IOTrackingIndexInput(name, in.openInput(name, ioContext));
+  }
+
+  @Override
+  public void close() throws IOException {
+    try {
+      super.close();
+    } finally {
+      threadCounters.close();
+    }
+  }
+}
diff --git a/lucene/misc/src/test/org/apache/lucene/store/TestIOTrackingDirectoryWrapper.java b/lucene/misc/src/test/org/apache/lucene/store/TestIOTrackingDirectoryWrapper.java
new file mode 100644
index 0000000..aaa267a
--- /dev/null
+++ b/lucene/misc/src/test/org/apache/lucene/store/TestIOTrackingDirectoryWrapper.java
@@ -0,0 +1,372 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.store;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Objects;
+import java.util.PriorityQueue;
+import java.util.concurrent.AbstractExecutorService;
+import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.RunnableFuture;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.MultiTerms;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.store.IOTrackingDirectoryWrapper.IOCounters;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.LineFileDocs;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.NamedThreadFactory;
+import org.apache.lucene.util.TestUtil;
+
+public class TestIOTrackingDirectoryWrapper extends LuceneTestCase {
+
+  public void testBasic() throws Exception {
+    try (Directory dir = newDirectory(); IOTrackingDirectoryWrapper wrapped = new IOTrackingDirectoryWrapper(dir)) {
+      try (IndexOutput out = wrapped.createOutput("foo", IOContext.DEFAULT)) {
+        out.writeByte((byte) 17);
+      }
+      Object key = new Object();
+      wrapped.setKeyForThread(key);
+      try (IndexInput in = wrapped.openInput("foo", IOContext.DEFAULT)) {
+        assertEquals(17, in.readByte());
+      }
+
+      IOCounters counters = wrapped.getAndClearIOCountersByKey(key);
+      assertEquals(1, counters.ioCount.longValue());
+      assertEquals(1, counters.bytesRead.longValue());
+    }
+  }
+
+  public void testReadShortIntLong() throws Exception {
+    try (Directory dir = newDirectory(); IOTrackingDirectoryWrapper wrapped = new IOTrackingDirectoryWrapper(dir)) {
+      short shortValue = (short) (random().nextInt(65536) - 32768);
+      int intValue = random().nextInt();
+      long longValue = random().nextLong();
+      try (IndexOutput out = wrapped.createOutput("foo", IOContext.DEFAULT)) {
+        out.writeShort(shortValue);
+        out.writeInt(intValue);
+        out.writeLong(longValue);
+      }
+      Object key = new Object();
+      wrapped.setKeyForThread(key);
+      try (IndexInput in = wrapped.openInput("foo", IOContext.DEFAULT)) {
+        assertEquals(shortValue, in.readShort());
+        assertEquals(intValue, in.readInt());
+        assertEquals(longValue, in.readLong());
+      }
+
+      IOCounters counters = wrapped.getAndClearIOCountersByKey(key);
+      assertEquals(3, counters.ioCount.longValue());
+      assertEquals(Short.BYTES + Integer.BYTES + Long.BYTES, counters.bytesRead.longValue());
+    }
+  }
+
+  public void testReadVInt() throws Exception {
+    try (Directory dir = newDirectory(); IOTrackingDirectoryWrapper wrapped = new IOTrackingDirectoryWrapper(dir)) {
+      // don't include negatives:
+      int value = random().nextInt(Integer.MAX_VALUE);
+      try (IndexOutput out = wrapped.createOutput("foo", IOContext.DEFAULT)) {
+        out.writeVInt(value);
+      }
+      Object key = new Object();
+      wrapped.setKeyForThread(key);
+      try (IndexInput in = wrapped.openInput("foo", IOContext.DEFAULT)) {
+        assertEquals(value, in.readVInt());
+      }
+
+      IOCounters counters = wrapped.getAndClearIOCountersByKey(key);
+      long ioCount = counters.ioCount.longValue();
+      assertTrue(ioCount > 0 && ioCount < 6);
+      long bytesRead = counters.bytesRead.longValue();
+      assertTrue(bytesRead > 0 && bytesRead < 6);
+    }
+  }
+
+  public void testBasicWithThreads() throws Exception {
+    try (Directory dir = newDirectory(); IOTrackingDirectoryWrapper wrapped = new IOTrackingDirectoryWrapper(dir)) {
+      try (IndexOutput out = wrapped.createOutput("foo", IOContext.DEFAULT)) {
+        out.writeByte((byte) 17);
+        out.writeByte((byte) 42);
+      }
+
+      Object key = new Object();
+
+      int threadCount = TestUtil.nextInt(random(), 5, 10);
+      CountDownLatch latch = new CountDownLatch(threadCount);
+      
+      for (int i=0; i<threadCount; i++) {
+        new Thread() {
+          @Override
+          public void run() {
+            wrapped.setKeyForThread(key);
+            try (IndexInput in = wrapped.openInput("foo", IOContext.DEFAULT)) {
+              assertEquals(17, in.readByte());
+              assertEquals(42, in.readByte());
+            } catch (IOException ioe) {
+              throw new RuntimeException(ioe);
+            }
+            latch.countDown();
+          }
+          }.start();
+      }
+
+      latch.await();
+
+      IOCounters counters = wrapped.getAndClearIOCountersByKey(key);
+      assertEquals(2 * threadCount, counters.ioCount.longValue());
+      assertEquals(2 * threadCount, counters.bytesRead.longValue());
+    }
+  }
+
+  // An ExecutorService that tracks which searcher thread is working for which Query
+  private final class IOTrackingExecutorService extends AbstractExecutorService {
+    private final IOTrackingDirectoryWrapper dir;
+    private final ExecutorService delegate;
+
+    // Maps main (outer) thread to Query
+    private final ThreadLocal<Object> mainThreadToQueryKey;
+
+    public IOTrackingExecutorService(IOTrackingDirectoryWrapper dir, ExecutorService delegate, ThreadLocal<Object> mainThreadToQueryKey) {
+      this.dir = dir;
+      this.delegate = Objects.requireNonNull(delegate, "delegate must not be null");
+      this.mainThreadToQueryKey = mainThreadToQueryKey;
+    }
+
+    @Override
+    public void shutdown() {
+      delegate.shutdown();
+    }
+
+    @Override
+    public List<Runnable> shutdownNow() {
+      return delegate.shutdownNow();
+    }
+
+    @Override
+    public boolean isShutdown() {
+      return delegate.isShutdown();
+    }
+
+    @Override
+    public boolean isTerminated() {
+      return delegate.isTerminated();
+    }
+
+    @Override
+    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
+      return delegate.awaitTermination(timeout, unit);
+    }
+
+    @Override
+    public void execute(Runnable command) {
+      delegate.execute(command);
+    }
+
+    @Override
+    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
+      return super.newTaskFor(wrapCallable(Executors.callable(runnable, value)));
+    }
+
+    @Override
+    protected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {
+      return super.newTaskFor(wrapCallable(callable));
+    }
+
+    private <T> Callable<T> wrapCallable(Callable<T> callable) {
+      System.out.println("NOW wrap callable: " + callable);
+
+      Object queryKey = mainThreadToQueryKey.get();
+      assert queryKey != null;
+
+      return new Callable<T> () {
+        @Override
+        public T call() throws Exception {
+          dir.setKeyForThread(queryKey);
+          return callable.call();
+        }
+      };
+    }
+  }
+
+  private final static String BODY_FIELD = "body";
+
+  private final class TermAndDocFreq implements Comparable<TermAndDocFreq> {
+    public final BytesRef term;
+    public final int docFreq;
+
+    public TermAndDocFreq(BytesRef term, int docFreq) {
+      this.term = term;
+      this.docFreq = docFreq;
+    }
+
+    @Override
+    public int compareTo(TermAndDocFreq other) {
+      int cmp = Integer.compare(docFreq, other.docFreq);
+      if (cmp == 0) {
+        cmp = term.compareTo(other.term);
+      }
+      return cmp;
+    }
+  }
+
+  /** Find top N most frequent terms */
+  private Collection<TermAndDocFreq> findCommonQueryTerms(IndexReader r, int count) throws IOException {
+
+    TermsEnum bodyTerms = MultiTerms.getTerms(r, BODY_FIELD).iterator();
+    BytesRef term;
+    PriorityQueue<TermAndDocFreq> queue = new PriorityQueue<>();
+    while ((term = bodyTerms.next()) != null) {
+      if (queue.size() == count) {
+        if (queue.peek().docFreq < bodyTerms.docFreq()) {
+          queue.add(new TermAndDocFreq(BytesRef.deepCopyOf(term), bodyTerms.docFreq()));
+          queue.poll();
+        }
+      } else {
+        queue.add(new TermAndDocFreq(BytesRef.deepCopyOf(term), bodyTerms.docFreq()));
+      }
+    }
+
+    return queue;
+  }
+
+  // Build a random Lucene index and search it sometimes with threads, tracking the IO counters:
+  public void testRandomSearch() throws Exception {
+    try (Directory dir = newDirectory()) {
+
+      ThreadLocal<Object> mainThreadToQueryKey = new ThreadLocal<>();
+
+      IOTrackingDirectoryWrapper ioTrackingDir = new IOTrackingDirectoryWrapper(dir);
+
+      try (LineFileDocs docs = new LineFileDocs(random()); RandomIndexWriter w = new RandomIndexWriter(random(), ioTrackingDir)) {
+        int numDocs = atLeast(100);
+        for (int i = 0; i < numDocs; i++) {
+          w.addDocument(docs.nextDoc());
+        }
+
+
+        Executor exec;
+        if (random().nextBoolean()) {
+          // Main thread does entire search
+          if (VERBOSE) {
+            System.out.println("TEST: single thread per query");
+          }
+          exec = null;
+        } else {
+          if (VERBOSE) {
+            System.out.println("TEST: multiple threads per query");
+          }
+          // We use searcher threads to make each search concurrent:
+          exec = new IOTrackingExecutorService(ioTrackingDir, Executors.newCachedThreadPool(new NamedThreadFactory("TestIOTrackingDirectoryWrapper.testRandomSearch")),
+                                               mainThreadToQueryKey);
+        }
+
+        try (IndexReader r = w.getReader()) {
+          IndexSearcher s = new IndexSearcher(r, exec);
+
+          int searchCount = atLeast(1000);
+
+          List<TermAndDocFreq> queryTerms = new ArrayList<>(findCommonQueryTerms(r, searchCount));
+
+          if (random().nextBoolean()) {
+            // Use only one main thread
+            if (VERBOSE) {
+              System.out.println("TEST: single query at once");
+            }
+            runSearches(s, queryTerms, mainThreadToQueryKey, ioTrackingDir);
+          } else {
+            if (VERBOSE) {
+              System.out.println("TEST: multiple queries at once");
+            }
+            // Use N main threads
+            Thread[] threads = new Thread[TestUtil.nextInt(random(), 2, 6)];
+            for (int i = 0; i < threads.length; i++) {
+              threads[i] = new Thread() {
+                  @Override
+                  public void run() {
+                    try {
+                      runSearches(s, queryTerms, mainThreadToQueryKey, ioTrackingDir);
+                    } catch (Exception e) {
+                      throw new RuntimeException(e);
+                    }
+                  }
+                };
+              threads[i].setName("Search thread " + i);
+              threads[i].start();
+            }
+
+            for (Thread thread : threads) {
+              thread.join();
+            }
+          }
+        }
+      }
+    }
+  }
+
+  private static class QueryAndKey {
+    public final Query query;
+    public final Object key;
+
+    public QueryAndKey(Query query) {
+      this.query = query;
+      this.key = new Object();
+    }
+  }
+
+  private void runSearches(IndexSearcher s, List<TermAndDocFreq> queryTerms, ThreadLocal<Object> mainThreadToQueryKey, IOTrackingDirectoryWrapper ioTrackingDir) throws Exception {
+    if (VERBOSE) {
+      System.out.println("\nTEST: now search");
+    }
+
+    for (TermAndDocFreq queryTerm : queryTerms) {
+
+      Query query = new TermQuery(new Term(BODY_FIELD, queryTerm.term));
+      QueryAndKey queryAndKey = new QueryAndKey(query);
+      if (VERBOSE) {
+        System.out.println("SEARCH: " + query);
+      }
+
+      mainThreadToQueryKey.set(queryAndKey.key);
+      ioTrackingDir.setKeyForThread(queryAndKey.key);
+      TopDocs hits = s.search(query, 100);
+      mainThreadToQueryKey.remove();
+
+      IOCounters counters = ioTrackingDir.getAndClearIOCountersByKey(queryAndKey.key);
+      assertNotNull("Search for query " + query + " with thread \"" + Thread.currentThread().getName() + "\" is missing its IOCounters", counters);
+
+      // Since we know all the query terms exist in the index, there should always be some IO:
+      assertTrue(counters.bytesRead.longValue() > 0);
+      assertTrue(counters.ioCount.longValue() > 0);
+    }
+  }
+}
diff --git a/lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase.java
index 4d12f0a..9adb33f 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase.java
@@ -397,6 +397,7 @@ public abstract class BaseDirectoryTestCase extends LuceneTestCase {
     });
   }
 
+  @SuppressWarnings("try")
   public void testThreadSafetyInListAll() throws Exception {
     try (Directory dir = getDirectory(createTempDir("testThreadSafety"))) {
       if (dir instanceof BaseDirectoryWrapper) {
@@ -1045,6 +1046,7 @@ public abstract class BaseDirectoryTestCase extends LuceneTestCase {
     }
   }
 
+  @SuppressWarnings("try")
   public void testCreateOutputForExistingFile() throws IOException {
     try (Directory dir = getDirectory(createTempDir())) {
       String name = "file";
