Index: src/java/org/apache/lucene/search/spans/SpanFirstQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanFirstQuery.java	(revision 605117)
+++ src/java/org/apache/lucene/search/spans/SpanFirstQuery.java	(working copy)
@@ -32,12 +32,27 @@
   private int end;
 
   /** Construct a SpanFirstQuery matching spans in <code>match</code> whose end
-   * position is less than or equal to <code>end</code>. */
+   * position is less than or equal to <code>end</code>.
+   * The matching Spans are provided by #getSpans().
+   */
   public SpanFirstQuery(SpanQuery match, int end) {
+    this(match, end, true);
+  }
+
+  /** Construct a SpanFirstQuery matching spans in <code>match</code> whose end
+   * position is less than or equal to <code>end</code>.
+   * The matching Spans are provided by #getSpans(), unchanged when
+   * <code>passSpansStart</code> is true, otherwise the matching
+   * Spans start at zero.
+   */
+  public SpanFirstQuery(SpanQuery match, int end, boolean passSpansStart) {
     this.match = match;
     this.end = end;
+    this.passSpansStart = passSpansStart;
   }
 
+  private boolean passSpansStart;
+
   /** Return the SpanQuery whose matches are filtered. */
   public SpanQuery getMatch() { return match; }
 
@@ -58,6 +73,8 @@
     buffer.append(match.toString(field));
     buffer.append(", ");
     buffer.append(end);
+    buffer.append(", ");
+    buffer.append(passSpansStart);
     buffer.append(")");
     buffer.append(ToStringUtils.boost(getBoost()));
     return buffer.toString();
@@ -65,39 +82,48 @@
   
   public void extractTerms(Set terms) {
 	    match.extractTerms(terms);
-  }  
+  }
+  
+  private class FirstSpans implements Spans {
+    private Spans spans;
+    FirstSpans(Spans spans) {
+      this.spans = spans;
+    }
 
-  public Spans getSpans(final IndexReader reader) throws IOException {
-    return new Spans() {
-        private Spans spans = match.getSpans(reader);
+    public boolean next() throws IOException {
+      while (spans.next()) {                  // scan to next match
+        if (end() <= end)
+          return true;
+      }
+      return false;
+    }
 
-        public boolean next() throws IOException {
-          while (spans.next()) {                  // scan to next match
-            if (end() <= end)
-              return true;
-          }
-          return false;
-        }
+    public boolean skipTo(int target) throws IOException {
+      if (!spans.skipTo(target))
+        return false;
 
-        public boolean skipTo(int target) throws IOException {
-          if (!spans.skipTo(target))
-            return false;
+      if (spans.end() <= end)                 // there is a match
+        return true;
 
-          if (spans.end() <= end)                 // there is a match
-            return true;
+      return next();                          // scan to next match
+    }
 
-          return next();                          // scan to next match
-        }
+    public int doc() { return spans.doc(); }
+    public int start() { return spans.start(); }
+    public int end() { return spans.end(); }
 
-        public int doc() { return spans.doc(); }
-        public int start() { return spans.start(); }
-        public int end() { return spans.end(); }
+    public String toString() {
+      return "spans(" + SpanFirstQuery.this.toString() + ")";
+    }
+  }
 
-        public String toString() {
-          return "spans(" + SpanFirstQuery.this.toString() + ")";
-        }
-
-      };
+  public Spans getSpans(final IndexReader reader) throws IOException {
+    Spans spans = match.getSpans(reader);
+    return passSpansStart
+      ? new FirstSpans(spans)
+      : new FirstSpans(spans) {
+          public int start() { return 0; }
+        };
   }
 
   public Query rewrite(IndexReader reader) throws IOException {
@@ -123,11 +149,13 @@
     SpanFirstQuery other = (SpanFirstQuery)o;
     return this.end == other.end
          && this.match.equals(other.match)
+         && this.passSpansStart == other.passSpansStart
          && this.getBoost() == other.getBoost();
   }
 
   public int hashCode() {
     int h = match.hashCode();
+    h ^= passSpansStart ? 1 : 0;
     h ^= (h << 8) | (h >>> 25);  // reversible
     h ^= Float.floatToRawIntBits(getBoost()) ^ end;
     return h;
