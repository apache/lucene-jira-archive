diff --git a/lucene/join/src/java/org/apache/lucene/search/join/BlockJoinScorer.java b/lucene/join/src/java/org/apache/lucene/search/join/BlockJoinScorer.java
new file mode 100644
index 0000000..09b3b21
--- /dev/null
+++ b/lucene/join/src/java/org/apache/lucene/search/join/BlockJoinScorer.java
@@ -0,0 +1,67 @@
+package org.apache.lucene.search.join;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Locale;
+
+import org.apache.lucene.search.ComplexExplanation;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.Weight;
+import org.apache.lucene.util.ArrayUtil;
+
+public abstract class BlockJoinScorer extends Scorer {
+  
+  public BlockJoinScorer(Weight weight) {
+    super(weight);
+  }
+
+  public abstract void trackPendingChildHits();
+
+  public abstract long cost();
+
+  public abstract Explanation explain(int docBase) throws IOException;
+
+  public abstract int advance(int parentTarget) throws IOException;
+
+  public abstract int freq();
+
+  public abstract float score() throws IOException;
+
+  public abstract int docID();
+
+  public abstract TwoPhaseIterator asTwoPhaseIterator();
+
+  public abstract int nextDoc() throws IOException;
+
+  protected abstract float[] swapChildScores(float[] other);
+
+  protected abstract int[] swapChildDocs(int[] other);
+
+  protected abstract int getParentDoc();
+
+  protected abstract int getChildCount();
+
+  public abstract Collection<ChildScorer> getChildren();
+  
+}
\ No newline at end of file
diff --git a/lucene/join/src/java/org/apache/lucene/search/join/DefaultBlockJoinScorer.java b/lucene/join/src/java/org/apache/lucene/search/join/DefaultBlockJoinScorer.java
new file mode 100644
index 0000000..32116fb
--- /dev/null
+++ b/lucene/join/src/java/org/apache/lucene/search/join/DefaultBlockJoinScorer.java
@@ -0,0 +1,299 @@
+package org.apache.lucene.search.join;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Locale;
+
+import org.apache.lucene.search.ComplexExplanation;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.Weight;
+import org.apache.lucene.search.Scorer.ChildScorer;
+import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.BitSet;
+import org.apache.lucene.util.Bits;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+class DefaultBlockJoinScorer extends BlockJoinScorer {
+  private final Scorer childScorer;
+  private final BitSet parentBits;
+  private final ScoreMode scoreMode;
+  private final Bits acceptDocs;
+
+  private int parentDoc = -1;
+  private int prevParentDoc;
+  private float parentScore;
+  private int parentFreq;
+  private int nextChildDoc;
+  private int[] pendingChildDocs;
+  private float[] pendingChildScores;
+  private int childDocUpto;
+
+  public DefaultBlockJoinScorer(Weight weight, Scorer childScorer, BitSet parentBits, int firstChildDoc, ScoreMode scoreMode, Bits acceptDocs) {
+    super(weight);
+    //System.out.println("Q.init firstChildDoc=" + firstChildDoc);
+    this.parentBits = parentBits;
+    this.childScorer = childScorer;
+    this.scoreMode = scoreMode;
+    this.acceptDocs = acceptDocs;
+    nextChildDoc = firstChildDoc;
+  }
+
+  @Override
+  public Collection<ChildScorer> getChildren() {
+    return Collections.singleton(new ChildScorer(childScorer, "BLOCK_JOIN"));
+  }
+
+  @Override
+  protected int getChildCount() {
+    return childDocUpto;
+  }
+
+  @Override
+  protected  int getParentDoc() {
+    return parentDoc;
+  }
+
+  @Override
+  protected int[] swapChildDocs(int[] other) {
+    final int[] ret = pendingChildDocs;
+    if (other == null) {
+      pendingChildDocs = new int[5];
+    } else {
+      pendingChildDocs = other;
+    }
+    return ret;
+  }
+
+  @Override
+  protected float[] swapChildScores(float[] other) {
+    if (scoreMode == ScoreMode.None) {
+      throw new IllegalStateException("ScoreMode is None; you must pass trackScores=false to ToParentBlockJoinCollector");
+    }
+    final float[] ret = pendingChildScores;
+    if (other == null) {
+      pendingChildScores = new float[5];
+    } else {
+      pendingChildScores = other;
+    }
+    return ret;
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    //System.out.println("Q.nextDoc() nextChildDoc=" + nextChildDoc);
+    // Loop until we hit a parentDoc that's accepted
+    while (true) {
+      if (nextChildDoc == NO_MORE_DOCS) {
+        //System.out.println("  end");
+        return parentDoc = NO_MORE_DOCS;
+      }
+
+      // Gather all children sharing the same parent as
+      // nextChildDoc
+
+      parentDoc = parentBits.nextSetBit(nextChildDoc);
+
+      // Parent & child docs are supposed to be
+      // orthogonal:
+      if (nextChildDoc == parentDoc) {
+        throw new IllegalStateException("child query must only match non-parent docs, but parent docID=" + nextChildDoc + " matched childScorer=" + childScorer.getClass());
+      }
+
+      //System.out.println("  parentDoc=" + parentDoc);
+      assert parentDoc != DocIdSetIterator.NO_MORE_DOCS;
+
+      //System.out.println("  nextChildDoc=" + nextChildDoc);
+      if (acceptDocs != null && !acceptDocs.get(parentDoc)) {
+        // Parent doc not accepted; skip child docs until
+        // we hit a new parent doc:
+        do {
+          nextChildDoc = childScorer.nextDoc();
+        } while (nextChildDoc < parentDoc);
+
+        // Parent & child docs are supposed to be
+        // orthogonal:
+        if (nextChildDoc == parentDoc) {
+          throw new IllegalStateException("child query must only match non-parent docs, but parent docID=" + nextChildDoc + " matched childScorer=" + childScorer.getClass());
+        }
+
+        continue;
+      }
+
+      float totalScore = 0;
+      float maxScore = Float.NEGATIVE_INFINITY;
+
+      childDocUpto = 0;
+      parentFreq = 0;
+      do {
+        //System.out.println("  c=" + nextChildDoc);
+        if (pendingChildDocs != null && pendingChildDocs.length == childDocUpto) {
+          pendingChildDocs = ArrayUtil.grow(pendingChildDocs);
+        }
+        if (pendingChildScores != null && scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {
+          pendingChildScores = ArrayUtil.grow(pendingChildScores);
+        }
+        if (pendingChildDocs != null) {
+          pendingChildDocs[childDocUpto] = nextChildDoc;
+        }
+        if (scoreMode != ScoreMode.None) {
+          // TODO: specialize this into dedicated classes per-scoreMode
+          final float childScore = childScorer.score();
+          final int childFreq = childScorer.freq();
+          if (pendingChildScores != null) {
+            pendingChildScores[childDocUpto] = childScore;
+          }
+          maxScore = Math.max(childScore, maxScore);
+          totalScore += childScore;
+          parentFreq += childFreq;
+        }
+        childDocUpto++;
+        nextChildDoc = childScorer.nextDoc();
+      } while (nextChildDoc < parentDoc);
+
+      // Parent & child docs are supposed to be
+      // orthogonal:
+      if (nextChildDoc == parentDoc) {
+        throw new IllegalStateException("child query must only match non-parent docs, but parent docID=" + nextChildDoc + " matched childScorer=" + childScorer.getClass());
+      }
+
+      switch(scoreMode) {
+      case Avg:
+        parentScore = totalScore / childDocUpto;
+        break;
+      case Max:
+        parentScore = maxScore;
+        break;
+      case Total:
+        parentScore = totalScore;
+        break;
+      case None:
+        break;
+      }
+
+      //System.out.println("  return parentDoc=" + parentDoc + " childDocUpto=" + childDocUpto);
+      return parentDoc;
+    }
+  }
+
+  
+  @Override
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    return null;
+    // suppress check on default values
+   /* if(minChildren==1 && maxChildren==Integer.MAX_VALUE){
+      return null;
+    }else{
+      return new TwoPhaseIterator() {
+        
+        @Override
+        public boolean matches() throws IOException {
+          return (getChildCount() >= minChildren && getChildCount() <= maxChildren);
+        }
+        
+        @Override
+        public DocIdSetIterator approximation() {
+          return BlockJoinScorer.this;
+        }
+      };
+    }*/
+  }
+
+  @Override
+  public int docID() {
+    return parentDoc;
+  }
+
+  @Override
+  public float score() throws IOException {
+    return parentScore;
+  }
+  
+  @Override
+  public int freq() {
+    return parentFreq;
+  }
+
+  @Override
+  public int advance(int parentTarget) throws IOException {
+
+    //System.out.println("Q.advance parentTarget=" + parentTarget);
+    if (parentTarget == NO_MORE_DOCS) {
+      return parentDoc = NO_MORE_DOCS;
+    }
+
+    if (parentTarget == 0) {
+      // Callers should only be passing in a docID from
+      // the parent space, so this means this parent
+      // has no children (it got docID 0), so it cannot
+      // possibly match.  We must handle this case
+      // separately otherwise we pass invalid -1 to
+      // prevSetBit below:
+      return nextDoc();
+    }
+
+    prevParentDoc = parentBits.prevSetBit(parentTarget-1);
+
+    //System.out.println("  rolled back to prevParentDoc=" + prevParentDoc + " vs parentDoc=" + parentDoc);
+    assert prevParentDoc >= parentDoc;
+    if (prevParentDoc > nextChildDoc) {
+      nextChildDoc = childScorer.advance(prevParentDoc);
+      // System.out.println("  childScorer advanced to child docID=" + nextChildDoc);
+    //} else {
+      //System.out.println("  skip childScorer advance");
+    }
+
+    // Parent & child docs are supposed to be orthogonal:
+    if (nextChildDoc == prevParentDoc) {
+      throw new IllegalStateException("child query must only match non-parent docs, but parent docID=" + nextChildDoc + " matched childScorer=" + childScorer.getClass());
+    }
+
+    final int nd = nextDoc();
+    //System.out.println("  return nextParentDoc=" + nd);
+    return nd;
+  }
+
+  @Override
+  public Explanation explain(int docBase) throws IOException {
+    int start = docBase + prevParentDoc + 1; // +1 b/c prevParentDoc is previous parent doc
+    int end = docBase + parentDoc - 1; // -1 b/c parentDoc is parent doc
+    return new ComplexExplanation(
+        true, score(), String.format(Locale.ROOT, "Score based on child doc range from %d to %d", start, end)
+    );
+  }
+
+  @Override
+  public long cost() {
+    return childScorer.cost();
+  }
+
+  /**
+   * Instructs this scorer to keep track of the child docIds and score ids for retrieval purposes.
+   */
+  @Override
+  public void trackPendingChildHits() {
+    pendingChildDocs = new int[5];
+    if (scoreMode != ScoreMode.None) {
+      pendingChildScores = new float[5];
+    }
+  }
+}
\ No newline at end of file
diff --git a/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector.java b/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector.java
index 1b5c48d..f3c0a73 100644
--- a/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector.java
+++ b/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector.java
@@ -106,7 +106,7 @@ public class ToParentBlockJoinCollector implements Collector {
   private final boolean trackMaxScore;
   private final boolean trackScores;
 
-  private ToParentBlockJoinQuery.BlockJoinScorer[] joinScorers = new ToParentBlockJoinQuery.BlockJoinScorer[0];
+  private BlockJoinScorer[] joinScorers = new BlockJoinScorer[0];
   private boolean queueFull;
 
   private OneGroup bottom;
@@ -184,8 +184,8 @@ public class ToParentBlockJoinCollector implements Collector {
         queue.add(scorer);
         while ((scorer = queue.poll()) != null) {
           //System.out.println("  poll: " + scorer + "; " + scorer.getWeight().getQuery());
-          if (scorer instanceof ToParentBlockJoinQuery.BlockJoinScorer) {
-            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (ToParentBlockJoinQuery.BlockJoinScorer) scorer);
+          if (scorer instanceof BlockJoinScorer) {
+            enroll((ToParentBlockJoinQuery) scorer.getWeight().getQuery(), (BlockJoinScorer) scorer);
           }
 
           for (ChildScorer sub : scorer.getChildren()) {
@@ -292,7 +292,7 @@ public class ToParentBlockJoinCollector implements Collector {
 
         //System.out.println("\ncopyGroups parentDoc=" + og.doc);
         for(int scorerIDX = 0;scorerIDX < numSubScorers;scorerIDX++) {
-          final ToParentBlockJoinQuery.BlockJoinScorer joinScorer = joinScorers[scorerIDX];
+          final BlockJoinScorer joinScorer = joinScorers[scorerIDX];
           //System.out.println("  scorer=" + joinScorer);
           if (joinScorer != null && docBase + joinScorer.getParentDoc() == og.doc) {
             og.counts[scorerIDX] = joinScorer.getChildCount();
@@ -318,13 +318,13 @@ public class ToParentBlockJoinCollector implements Collector {
     };
   }
 
-  private void enroll(ToParentBlockJoinQuery query, ToParentBlockJoinQuery.BlockJoinScorer scorer) {
+  private void enroll(ToParentBlockJoinQuery query, BlockJoinScorer scorer) {
     scorer.trackPendingChildHits();
     final Integer slot = joinQueryID.get(query);
     if (slot == null) {
       joinQueryID.put(query, joinScorers.length);
       //System.out.println("found JQ: " + query + " slot=" + joinScorers.length);
-      final ToParentBlockJoinQuery.BlockJoinScorer[] newArray = new ToParentBlockJoinQuery.BlockJoinScorer[1+joinScorers.length];
+      final BlockJoinScorer[] newArray = new BlockJoinScorer[1+joinScorers.length];
       System.arraycopy(joinScorers, 0, newArray, 0, joinScorers.length);
       joinScorers = newArray;
       joinScorers[joinScorers.length-1] = scorer;
diff --git a/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java b/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java
index cd14443..3c1c484 100644
--- a/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java
+++ b/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java
@@ -17,12 +17,6 @@ package org.apache.lucene.search.join;
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Locale;
-import java.util.Set;
-
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.LeafReaderContext;
@@ -35,11 +29,13 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.grouping.TopGroups;
-import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.BitDocIdSet;
 import org.apache.lucene.util.BitSet;
 import org.apache.lucene.util.Bits;
 
+import java.io.IOException;
+import java.util.Set;
+
 /**
  * This query requires that you index
  * children and parent docs as a single block, using the
@@ -94,6 +90,8 @@ public class ToParentBlockJoinQuery extends Query {
   // query before searching:
   private final Query origChildQuery;
   private final ScoreMode scoreMode;
+  private final int minChildren;
+  private final int maxChildren;
 
   /** Create a ToParentBlockJoinQuery.
    * 
@@ -103,24 +101,41 @@ public class ToParentBlockJoinQuery extends Query {
    * into a single parent score.
    **/
   public ToParentBlockJoinQuery(Query childQuery, BitDocIdSetFilter parentsFilter, ScoreMode scoreMode) {
+    this(childQuery, parentsFilter, scoreMode, 1, Integer.MAX_VALUE);
+  }
+
+  /** Create a ToParentBlockJoinQuery.
+   *
+   * @param childQuery Query matching child documents.
+   * @param parentsFilter Filter identifying the parent documents.
+   * @param scoreMode How to aggregate multiple child scores
+   * @param minChildren The minimum number of matching children documents a parent document needs to have. TODO setting to 0 is a way interesting, at least is need to be asserted. 
+   * @param maxChildren The maximum number of matching children documents a parent document is amount to have.
+   * into a single parent score.
+   **/
+  public ToParentBlockJoinQuery(Query childQuery, BitDocIdSetFilter parentsFilter, ScoreMode scoreMode, int minChildren, int maxChildren) {
     super();
     this.origChildQuery = childQuery;
     this.childQuery = childQuery;
     this.parentsFilter = parentsFilter;
     this.scoreMode = scoreMode;
+    this.minChildren = minChildren;
+    this.maxChildren = maxChildren;
   }
 
-  private ToParentBlockJoinQuery(Query origChildQuery, Query childQuery, BitDocIdSetFilter parentsFilter, ScoreMode scoreMode) {
+  private ToParentBlockJoinQuery(Query origChildQuery, Query childQuery, BitDocIdSetFilter parentsFilter, ScoreMode scoreMode, int minChildren, int maxChildren) {
     super();
     this.origChildQuery = origChildQuery;
     this.childQuery = childQuery;
     this.parentsFilter = parentsFilter;
     this.scoreMode = scoreMode;
+    this.minChildren = minChildren;
+    this.maxChildren = maxChildren;
   }
 
   @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    return new BlockJoinWeight(this, childQuery.createWeight(searcher, needsScores), parentsFilter, scoreMode);
+    return new BlockJoinWeight(this, childQuery.createWeight(searcher, needsScores), parentsFilter, scoreMode, minChildren, maxChildren);
   }
   
   /** Return our child query. */
@@ -133,13 +148,17 @@ public class ToParentBlockJoinQuery extends Query {
     private final Weight childWeight;
     private final BitDocIdSetFilter parentsFilter;
     private final ScoreMode scoreMode;
+    private final int minChildren;
+    private final int maxChildren;
 
-    public BlockJoinWeight(Query joinQuery, Weight childWeight, BitDocIdSetFilter parentsFilter, ScoreMode scoreMode) {
+    public BlockJoinWeight(Query joinQuery, Weight childWeight, BitDocIdSetFilter parentsFilter, ScoreMode scoreMode, int minChildren, int maxChildren) {
       super(joinQuery);
       this.joinQuery = joinQuery;
       this.childWeight = childWeight;
       this.parentsFilter = parentsFilter;
       this.scoreMode = scoreMode;
+      this.minChildren = minChildren;
+      this.maxChildren = maxChildren;
     }
 
     @Override
@@ -178,7 +197,12 @@ public class ToParentBlockJoinQuery extends Query {
         return null;
       }
 
-      return new BlockJoinScorer(this, childScorer, parents.bits(), firstChildDoc, scoreMode, acceptDocs);
+      final DefaultBlockJoinScorer blockJoinScorer = new DefaultBlockJoinScorer(this, childScorer, parents.bits(), firstChildDoc, scoreMode, acceptDocs);
+      if(minChildren==1 && maxChildren==Integer.MAX_VALUE){
+        return blockJoinScorer;
+      }else{
+        return new TwoPhaseBlockJoinScorer(this,blockJoinScorer, minChildren, maxChildren);
+      }
     }
 
     @Override
@@ -191,242 +215,6 @@ public class ToParentBlockJoinQuery extends Query {
     }
   }
 
-  static class BlockJoinScorer extends Scorer {
-    private final Scorer childScorer;
-    private final BitSet parentBits;
-    private final ScoreMode scoreMode;
-    private final Bits acceptDocs;
-    private int parentDoc = -1;
-    private int prevParentDoc;
-    private float parentScore;
-    private int parentFreq;
-    private int nextChildDoc;
-    private int[] pendingChildDocs;
-    private float[] pendingChildScores;
-    private int childDocUpto;
-
-    public BlockJoinScorer(Weight weight, Scorer childScorer, BitSet parentBits, int firstChildDoc, ScoreMode scoreMode, Bits acceptDocs) {
-      super(weight);
-      //System.out.println("Q.init firstChildDoc=" + firstChildDoc);
-      this.parentBits = parentBits;
-      this.childScorer = childScorer;
-      this.scoreMode = scoreMode;
-      this.acceptDocs = acceptDocs;
-      nextChildDoc = firstChildDoc;
-    }
-
-    @Override
-    public Collection<ChildScorer> getChildren() {
-      return Collections.singleton(new ChildScorer(childScorer, "BLOCK_JOIN"));
-    }
-
-    int getChildCount() {
-      return childDocUpto;
-    }
-
-    int getParentDoc() {
-      return parentDoc;
-    }
-
-    int[] swapChildDocs(int[] other) {
-      final int[] ret = pendingChildDocs;
-      if (other == null) {
-        pendingChildDocs = new int[5];
-      } else {
-        pendingChildDocs = other;
-      }
-      return ret;
-    }
-
-    float[] swapChildScores(float[] other) {
-      if (scoreMode == ScoreMode.None) {
-        throw new IllegalStateException("ScoreMode is None; you must pass trackScores=false to ToParentBlockJoinCollector");
-      }
-      final float[] ret = pendingChildScores;
-      if (other == null) {
-        pendingChildScores = new float[5];
-      } else {
-        pendingChildScores = other;
-      }
-      return ret;
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-      //System.out.println("Q.nextDoc() nextChildDoc=" + nextChildDoc);
-      // Loop until we hit a parentDoc that's accepted
-      while (true) {
-        if (nextChildDoc == NO_MORE_DOCS) {
-          //System.out.println("  end");
-          return parentDoc = NO_MORE_DOCS;
-        }
-
-        // Gather all children sharing the same parent as
-        // nextChildDoc
-
-        parentDoc = parentBits.nextSetBit(nextChildDoc);
-
-        // Parent & child docs are supposed to be
-        // orthogonal:
-        if (nextChildDoc == parentDoc) {
-          throw new IllegalStateException("child query must only match non-parent docs, but parent docID=" + nextChildDoc + " matched childScorer=" + childScorer.getClass());
-        }
-
-        //System.out.println("  parentDoc=" + parentDoc);
-        assert parentDoc != DocIdSetIterator.NO_MORE_DOCS;
-
-        //System.out.println("  nextChildDoc=" + nextChildDoc);
-        if (acceptDocs != null && !acceptDocs.get(parentDoc)) {
-          // Parent doc not accepted; skip child docs until
-          // we hit a new parent doc:
-          do {
-            nextChildDoc = childScorer.nextDoc();
-          } while (nextChildDoc < parentDoc);
-
-          // Parent & child docs are supposed to be
-          // orthogonal:
-          if (nextChildDoc == parentDoc) {
-            throw new IllegalStateException("child query must only match non-parent docs, but parent docID=" + nextChildDoc + " matched childScorer=" + childScorer.getClass());
-          }
-
-          continue;
-        }
-
-        float totalScore = 0;
-        float maxScore = Float.NEGATIVE_INFINITY;
-
-        childDocUpto = 0;
-        parentFreq = 0;
-        do {
-
-          //System.out.println("  c=" + nextChildDoc);
-          if (pendingChildDocs != null && pendingChildDocs.length == childDocUpto) {
-            pendingChildDocs = ArrayUtil.grow(pendingChildDocs);
-          }
-          if (pendingChildScores != null && scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {
-            pendingChildScores = ArrayUtil.grow(pendingChildScores);
-          }
-          if (pendingChildDocs != null) {
-            pendingChildDocs[childDocUpto] = nextChildDoc;
-          }
-          if (scoreMode != ScoreMode.None) {
-            // TODO: specialize this into dedicated classes per-scoreMode
-            final float childScore = childScorer.score();
-            final int childFreq = childScorer.freq();
-            if (pendingChildScores != null) {
-              pendingChildScores[childDocUpto] = childScore;
-            }
-            maxScore = Math.max(childScore, maxScore);
-            totalScore += childScore;
-            parentFreq += childFreq;
-          }
-          childDocUpto++;
-          nextChildDoc = childScorer.nextDoc();
-        } while (nextChildDoc < parentDoc);
-
-        // Parent & child docs are supposed to be
-        // orthogonal:
-        if (nextChildDoc == parentDoc) {
-          throw new IllegalStateException("child query must only match non-parent docs, but parent docID=" + nextChildDoc + " matched childScorer=" + childScorer.getClass());
-        }
-
-        switch(scoreMode) {
-        case Avg:
-          parentScore = totalScore / childDocUpto;
-          break;
-        case Max:
-          parentScore = maxScore;
-          break;
-        case Total:
-          parentScore = totalScore;
-          break;
-        case None:
-          break;
-        }
-
-        //System.out.println("  return parentDoc=" + parentDoc + " childDocUpto=" + childDocUpto);
-        return parentDoc;
-      }
-    }
-
-    @Override
-    public int docID() {
-      return parentDoc;
-    }
-
-    @Override
-    public float score() throws IOException {
-      return parentScore;
-    }
-    
-    @Override
-    public int freq() {
-      return parentFreq;
-    }
-
-    @Override
-    public int advance(int parentTarget) throws IOException {
-
-      //System.out.println("Q.advance parentTarget=" + parentTarget);
-      if (parentTarget == NO_MORE_DOCS) {
-        return parentDoc = NO_MORE_DOCS;
-      }
-
-      if (parentTarget == 0) {
-        // Callers should only be passing in a docID from
-        // the parent space, so this means this parent
-        // has no children (it got docID 0), so it cannot
-        // possibly match.  We must handle this case
-        // separately otherwise we pass invalid -1 to
-        // prevSetBit below:
-        return nextDoc();
-      }
-
-      prevParentDoc = parentBits.prevSetBit(parentTarget-1);
-
-      //System.out.println("  rolled back to prevParentDoc=" + prevParentDoc + " vs parentDoc=" + parentDoc);
-      assert prevParentDoc >= parentDoc;
-      if (prevParentDoc > nextChildDoc) {
-        nextChildDoc = childScorer.advance(prevParentDoc);
-        // System.out.println("  childScorer advanced to child docID=" + nextChildDoc);
-      //} else {
-        //System.out.println("  skip childScorer advance");
-      }
-
-      // Parent & child docs are supposed to be orthogonal:
-      if (nextChildDoc == prevParentDoc) {
-        throw new IllegalStateException("child query must only match non-parent docs, but parent docID=" + nextChildDoc + " matched childScorer=" + childScorer.getClass());
-      }
-
-      final int nd = nextDoc();
-      //System.out.println("  return nextParentDoc=" + nd);
-      return nd;
-    }
-
-    public Explanation explain(int docBase) throws IOException {
-      int start = docBase + prevParentDoc + 1; // +1 b/c prevParentDoc is previous parent doc
-      int end = docBase + parentDoc - 1; // -1 b/c parentDoc is parent doc
-      return new ComplexExplanation(
-          true, score(), String.format(Locale.ROOT, "Score based on child doc range from %d to %d", start, end)
-      );
-    }
-
-    @Override
-    public long cost() {
-      return childScorer.cost();
-    }
-
-    /**
-     * Instructs this scorer to keep track of the child docIds and score ids for retrieval purposes.
-     */
-    public void trackPendingChildHits() {
-      pendingChildDocs = new int[5];
-      if (scoreMode != ScoreMode.None) {
-        pendingChildScores = new float[5];
-      }
-    }
-  }
-
   @Override
   public void extractTerms(Set<Term> terms) {
     childQuery.extractTerms(terms);
@@ -439,7 +227,9 @@ public class ToParentBlockJoinQuery extends Query {
       Query rewritten = new ToParentBlockJoinQuery(origChildQuery,
                                 childRewrite,
                                 parentsFilter,
-                                scoreMode);
+                                scoreMode,
+                                minChildren,
+                                maxChildren);
       rewritten.setBoost(getBoost());
       return rewritten;
     } else {
diff --git a/lucene/join/src/java/org/apache/lucene/search/join/TwoPhaseBlockJoinScorer.java b/lucene/join/src/java/org/apache/lucene/search/join/TwoPhaseBlockJoinScorer.java
new file mode 100644
index 0000000..410b8a8
--- /dev/null
+++ b/lucene/join/src/java/org/apache/lucene/search/join/TwoPhaseBlockJoinScorer.java
@@ -0,0 +1,141 @@
+package org.apache.lucene.search.join;
+
+import java.io.IOException;
+import java.util.Collection;
+
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.Weight;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+class TwoPhaseBlockJoinScorer extends BlockJoinScorer {
+  
+  final private BlockJoinScorer blockJoinScorer;
+  final private int minChildren;
+  final private int maxChildren;
+  
+  public TwoPhaseBlockJoinScorer(Weight weight, BlockJoinScorer blockJoinScorer,
+      int minChildren, int maxChildren) {
+    super(weight);
+    this.blockJoinScorer=blockJoinScorer;
+    this.minChildren=minChildren;
+    this.maxChildren=maxChildren;
+    assert this.minChildren >1 || this.maxChildren<Integer.MAX_VALUE;
+  }
+
+  @Override
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    return new TwoPhaseIterator() {
+      
+      @Override
+      public boolean matches() throws IOException {
+        return doesMatch();
+      }
+      
+      @Override
+      public DocIdSetIterator approximation() {
+        return blockJoinScorer;
+      }
+    };
+  }
+  /** fallback to single phase match */
+  @Override
+  public int nextDoc() throws IOException {
+    return doNext(blockJoinScorer.nextDoc());
+  }
+
+  /** fallback to single phase match */
+  @Override
+  public int advance(int target) throws IOException {
+    return doNext(blockJoinScorer.advance(target));
+  }
+  
+  private int doNext(int doc) throws IOException {
+    for (;; doc = blockJoinScorer.nextDoc()) {
+      if (doc == NO_MORE_DOCS) {
+        return NO_MORE_DOCS;
+      } else if (doesMatch()) {
+        return doc;
+      }
+    }
+  }
+  
+  protected boolean doesMatch() {
+    return blockJoinScorer.getChildCount() >= minChildren 
+        && blockJoinScorer.getChildCount() <= maxChildren;
+  }
+
+  public void trackPendingChildHits() {
+    blockJoinScorer.trackPendingChildHits();
+  }
+
+  public long cost() {
+    return blockJoinScorer.cost();
+  }
+
+  public Explanation explain(int docBase) throws IOException {
+    return blockJoinScorer.explain(docBase);
+  }
+
+  public int freq() {
+    return blockJoinScorer.freq();
+  }
+
+  public float score() throws IOException {
+    return blockJoinScorer.score();
+  }
+
+  public int docID() {
+    return blockJoinScorer.docID();
+  }
+
+  public Collection<ChildScorer> getChildren() {
+    return blockJoinScorer.getChildren();
+  }
+
+  public Weight getWeight() {
+    return blockJoinScorer.getWeight();
+  }
+
+  public String toString() {
+    return blockJoinScorer.toString();
+  }
+
+  @Override
+  protected float[] swapChildScores(float[] other) {
+    return blockJoinScorer.swapChildScores(other);
+  }
+
+  @Override
+  protected int[] swapChildDocs(int[] other) {
+    return blockJoinScorer.swapChildDocs(other);
+  }
+
+  @Override
+  protected int getParentDoc() {
+    return blockJoinScorer.getParentDoc();
+  }
+
+  @Override
+  protected int getChildCount() {
+    return blockJoinScorer.getChildCount();
+  }
+  
+}
diff --git a/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java b/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
index 93f2258..5d4c478 100644
--- a/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
+++ b/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
@@ -21,8 +21,10 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
+import java.util.Set;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
@@ -76,6 +78,9 @@ import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.NumericUtils;
 import org.apache.lucene.util.TestUtil;
 
+import com.carrotsearch.randomizedtesting.annotations.Repeat;
+import com.carrotsearch.randomizedtesting.annotations.Seed;
+
 public class TestBlockJoin extends LuceneTestCase {
 
   // One resume...
@@ -255,6 +260,95 @@ public class TestBlockJoin extends LuceneTestCase {
     dir.close();
   }
 
+  //@Seed("cafebabe")
+ //@Repeat(iterations=1000)
+  public void testMinMaxChildren() throws IOException{
+    final Directory dir = newDirectory();
+    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);
+    
+    final int ten = 10;
+    
+    int minChildInc =random().nextBoolean()? 1 : 1+random().nextInt(ten);
+    int maxChildInc = random().nextBoolean()? Integer.MAX_VALUE : minChildInc+random().nextInt(ten) -1;
+    
+    //System.out.println(minChildInc+".."+maxChildInc);
+    Set<String> expect = new HashSet<>();
+    for(int p =0;p<atLeast(ten);p++){
+      List<Document> docs = new ArrayList<>();
+      int docSeed = random().nextInt(Integer.MAX_VALUE);
+      int numChild = numChildForSeed(docSeed, ten); 
+      if(numChild>=minChildInc && numChild<=maxChildInc){
+        final boolean changed = expect.add(""+docSeed);
+        assertTrue("there are no "+docSeed+" in "+expect, changed);
+      }
+      for(int c =0;c<numChild;c++){
+        docs.add(makeJob("java", c));
+      }
+      //System.out.println(docSeed +" ->"+numChild+ "~"+docs.size());
+      docs.add(makeResume(""+docSeed, "US"));
+      w.addDocuments(docs);
+      if(rarely()){
+        w.commit();
+      }
+    }
+    
+    //System.out.println("expect: "+expect);
+    IndexReader r = w.getReader();
+    w.close();
+    IndexSearcher s = newSearcher(r);
+    
+    BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("docType", "resume"))));
+    
+    final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];
+    ToParentBlockJoinQuery bjq = (minChildInc==1 && maxChildInc==Integer.MAX_VALUE) && random().nextBoolean() ? 
+        new ToParentBlockJoinQuery(  new TermQuery(new Term("skill", "java")), parentsFilter, scoreMode):
+          new ToParentBlockJoinQuery(  new TermQuery(new Term("skill", "java")), parentsFilter, scoreMode, minChildInc, maxChildInc);
+    
+    Set<String> expectCp = new HashSet<>(expect);    
+    final Query query = random().nextBoolean() ? bjq :
+        new FilteredQuery( bjq, parentsFilter,FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY);
+    
+    final TopDocs found = s.search( query , expect.size()*2+1);
+    assertEquals(found.totalHits, found.scoreDocs.length);
+    for(ScoreDoc sd :found.scoreDocs){
+      final String seedFound = s.doc(sd.doc).get("name");
+      final boolean changed = expectCp.remove(seedFound);
+      assertTrue("removing "+seedFound+" in "+expectCp, changed);
+    }    
+    assertTrue(expectCp+" is empty",expectCp.isEmpty());
+    
+    if(found.totalHits>0 && scoreMode!=ScoreMode.None){
+      expectCp.addAll(expect);
+      final ToParentBlockJoinCollector groupCollector = new ToParentBlockJoinCollector(Sort.INDEXORDER,
+          expect.size()*2+1, random().nextBoolean(), random().nextBoolean());
+      s.search(query, groupCollector);
+      final TopGroups<Integer> topGroups = groupCollector.getTopGroupsWithAllChildDocs(bjq, Sort.INDEXORDER, 0, 0, random().nextBoolean());
+      for (GroupDocs<Integer> group : topGroups.groups) {
+        final String seedFound = s.doc(group.groupValue).get("name");
+        final boolean changed = expectCp.remove(seedFound);
+        assertTrue("removing "+seedFound+" in "+expectCp, changed);
+        final Integer parentSeed = Integer.valueOf(seedFound);
+        int numChild = numChildForSeed(parentSeed, ten);
+        assertEquals(numChild, group.totalHits);
+        assertEquals(numChild, group.scoreDocs.length);
+        int yearExp=0;
+        for(ScoreDoc ch :group.scoreDocs){
+          final String year = s.doc(ch.doc).get("year");
+          assertEquals(""+(yearExp++), year);
+          assertTrue( ch.doc<group.groupValue && ch.doc>=group.groupValue-group.totalHits);
+          // TODO assert score
+        }
+      }    
+      assertTrue(expectCp+" is empty",expectCp.isEmpty());
+    }
+    r.close();
+    dir.close();
+  }
+
+  private int numChildForSeed(int docSeed, final int ten) {
+    return docSeed%(ten*3);
+  }
+  
   public void testBugCausedByRewritingTwice() throws IOException {
     final Directory dir = newDirectory();
     final RandomIndexWriter w = new RandomIndexWriter(random(), dir);
