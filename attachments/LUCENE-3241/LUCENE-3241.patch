Index: modules/queries/src/test/org/apache/lucene/queries/function/TestOrdValues.java
===================================================================
--- modules/queries/src/test/org/apache/lucene/queries/function/TestOrdValues.java	(revision 1141367)
+++ modules/queries/src/test/org/apache/lucene/queries/function/TestOrdValues.java	(working copy)
@@ -1,4 +1,4 @@
-package org.apache.lucene.search.function;
+package org.apache.lucene.queries.function;
 
 /**
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -19,6 +19,8 @@
 
 import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.valuesource.OrdFieldSource;
+import org.apache.lucene.queries.function.valuesource.ReverseOrdFieldSource;
 import org.apache.lucene.search.*;
 import org.apache.lucene.util.ReaderUtil;
 import org.junit.BeforeClass;
@@ -63,12 +65,12 @@
     IndexSearcher s = new IndexSearcher(dir, true);
     ValueSource vs;
     if (inOrder) {
-      vs = new MultiValueSource(new OrdFieldSource(field));
+      vs = new OrdFieldSource(field);
     } else {
-      vs = new MultiValueSource(new ReverseOrdFieldSource(field));
+      vs = new ReverseOrdFieldSource(field);
     }
 
-    Query q = new ValueSourceQuery(vs);
+    Query q = new FunctionQuery(vs);
     log("test: " + q);
     QueryUtils.check(random, q, s);
     ScoreDoc[] h = s.search(q, null, 1000).scoreDocs;
@@ -117,7 +119,7 @@
     } else {
       vs = new ReverseOrdFieldSource(field);
     }
-    Query q = new ValueSourceQuery(vs);
+    Query q = new FunctionQuery(vs);
     TopDocs td = s.search(q, null, 1000);
     assertEquals("All docs should be matched!", N_DOCS, td.totalHits);
     ScoreDoc sd[] = td.scoreDocs;
@@ -135,125 +137,6 @@
     }
     s.close();
   }
-
-  /**
-   * Test caching OrdFieldSource
-   */
-  @Test
-  public void testCachingOrd() throws CorruptIndexException, Exception {
-    doTestCaching(ID_FIELD, true);
-  }
-
-  /**
-   * Test caching for ReverseOrdFieldSource
-   */
-  @Test
-  public void testCachingReverseOrd() throws CorruptIndexException, Exception {
-    doTestCaching(ID_FIELD, false);
-  }
-
-  // Test that values loaded for FieldScoreQuery are cached properly and consumes the proper RAM resources.
-  private void doTestCaching(String field, boolean inOrder) throws CorruptIndexException, Exception {
-    IndexSearcher s = new IndexSearcher(dir, true);
-    Object innerArray = null;
-
-    boolean warned = false; // print warning once
-
-    for (int i = 0; i < 10; i++) {
-      ValueSource vs;
-      if (inOrder) {
-        vs = new OrdFieldSource(field);
-      } else {
-        vs = new ReverseOrdFieldSource(field);
-      }
-      ValueSourceQuery q = new ValueSourceQuery(vs);
-      ScoreDoc[] h = s.search(q, null, 1000).scoreDocs;
-      try {
-        assertEquals("All docs should be matched!", N_DOCS, h.length);
-        AtomicReaderContext[] leaves = ReaderUtil.leaves(s.getTopReaderContext());
-
-        for (AtomicReaderContext leaf : leaves) {
-          if (i == 0) {
-            innerArray = q.valSrc.getValues(leaf).getInnerArray();
-          } else {
-            log(i + ".  compare: " + innerArray + " to " + q.valSrc.getValues(leaf).getInnerArray());
-            assertSame("field values should be cached and reused!", innerArray, q.valSrc.getValues(leaf).getInnerArray());
-          }
-        }
-      } catch (UnsupportedOperationException e) {
-        if (!warned) {
-          System.err.println("WARNING: " + testName() + " cannot fully test values of " + q);
-          warned = true;
-        }
-      }
-    }
-
-    ValueSource vs;
-    ValueSourceQuery q;
-    ScoreDoc[] h;
-
-    // verify that different values are loaded for a different field
-    String field2 = INT_FIELD;
-    assertFalse(field.equals(field2)); // otherwise this test is meaningless.
-    if (inOrder) {
-      vs = new OrdFieldSource(field2);
-    } else {
-      vs = new ReverseOrdFieldSource(field2);
-    }
-    q = new ValueSourceQuery(vs);
-    h = s.search(q, null, 1000).scoreDocs;
-    assertEquals("All docs should be matched!", N_DOCS, h.length);
-    AtomicReaderContext[] leaves = ReaderUtil.leaves(s.getTopReaderContext());
-
-    for (AtomicReaderContext leaf : leaves) {
-      try {
-        log("compare (should differ): " + innerArray + " to "
-                + q.valSrc.getValues(leaf).getInnerArray());
-        assertNotSame(
-                "different values should be loaded for a different field!",
-                innerArray, q.valSrc.getValues(leaf).getInnerArray());
-      } catch (UnsupportedOperationException e) {
-        if (!warned) {
-          System.err.println("WARNING: " + testName()
-                  + " cannot fully test values of " + q);
-          warned = true;
-        }
-      }
-    }
-    s.close();
-    // verify new values are reloaded (not reused) for a new reader
-    s = new IndexSearcher(dir, true);
-    if (inOrder) {
-      vs = new OrdFieldSource(field);
-    } else {
-      vs = new ReverseOrdFieldSource(field);
-    }
-    q = new ValueSourceQuery(vs);
-    h = s.search(q, null, 1000).scoreDocs;
-    assertEquals("All docs should be matched!", N_DOCS, h.length);
-    leaves = ReaderUtil.leaves(s.getTopReaderContext());
-
-    for (AtomicReaderContext leaf : leaves) {
-      try {
-        log("compare (should differ): " + innerArray + " to "
-                + q.valSrc.getValues(leaf).getInnerArray());
-        assertNotSame(
-                "cached field values should not be reused if reader as changed!",
-                innerArray, q.valSrc.getValues(leaf).getInnerArray());
-      } catch (UnsupportedOperationException e) {
-        if (!warned) {
-          System.err.println("WARNING: " + testName()
-                  + " cannot fully test values of " + q);
-          warned = true;
-        }
-      }
-    }
-    s.close();
-  }
-
-  private String testName() {
-    return getClass().getName() + "." + getName();
-  }
   
   // LUCENE-1250
   public void testEqualsNull() throws Exception {
Index: modules/queries/src/test/org/apache/lucene/queries/function/TestFieldScoreQuery.java
===================================================================
--- modules/queries/src/test/org/apache/lucene/queries/function/TestFieldScoreQuery.java	(revision 1141367)
+++ modules/queries/src/test/org/apache/lucene/queries/function/TestFieldScoreQuery.java	(working copy)
@@ -1,4 +1,4 @@
-package org.apache.lucene.search.function;
+package org.apache.lucene.queries.function;
 
 /**
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -17,15 +17,17 @@
  * limitations under the License.
  */
 
-import java.util.HashMap;
-
-import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.queries.function.FunctionQuery;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.valuesource.ByteFieldSource;
+import org.apache.lucene.queries.function.valuesource.FloatFieldSource;
+import org.apache.lucene.queries.function.valuesource.IntFieldSource;
+import org.apache.lucene.queries.function.valuesource.ShortFieldSource;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
 import org.apache.lucene.search.QueryUtils;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.util.ReaderUtil;
+import org.apache.lucene.search.cache.*;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -51,44 +53,44 @@
   @Test
   public void testRankByte () throws Exception {
     // INT field values are small enough to be parsed as byte
-    doTestRank(INT_FIELD,FieldScoreQuery.Type.BYTE);
+    doTestRank(BYTE_VALUESOURCE);
   }
 
   /** Test that FieldScoreQuery of Type.SHORT returns docs in expected order. */
   @Test
   public void testRankShort () throws Exception {
     // INT field values are small enough to be parsed as short
-    doTestRank(INT_FIELD,FieldScoreQuery.Type.SHORT);
+    doTestRank(SHORT_VALUESOURCE);
   }
 
   /** Test that FieldScoreQuery of Type.INT returns docs in expected order. */
   @Test
   public void testRankInt () throws Exception {
-    doTestRank(INT_FIELD,FieldScoreQuery.Type.INT);
+    doTestRank(INT_VALUESOURCE);
   }
 
   /** Test that FieldScoreQuery of Type.FLOAT returns docs in expected order. */
   @Test
   public void testRankFloat () throws Exception {
     // INT field can be parsed as float
-    doTestRank(INT_FIELD,FieldScoreQuery.Type.FLOAT);
+    doTestRank(INT_AS_FLOAT_VALUESOURCE);
     // same values, but in flot format
-    doTestRank(FLOAT_FIELD,FieldScoreQuery.Type.FLOAT);
+    doTestRank(FLOAT_VALUESOURCE);
   }
 
   // Test that FieldScoreQuery returns docs in expected order.
-  private void doTestRank (String field, FieldScoreQuery.Type tp) throws Exception {
+  private void doTestRank (ValueSource valueSource) throws Exception {
+    FunctionQuery functionQuery = new FunctionQuery(valueSource);
     IndexSearcher s = new IndexSearcher(dir, true);
-    Query q = new FieldScoreQuery(field,tp);
-    log("test: "+q);
-    QueryUtils.check(random, q,s);
-    ScoreDoc[] h = s.search(q, null, 1000).scoreDocs;
+    log("test: "+ functionQuery);
+    QueryUtils.check(random, functionQuery,s);
+    ScoreDoc[] h = s.search(functionQuery, null, 1000).scoreDocs;
     assertEquals("All docs should be matched!",N_DOCS,h.length);
     String prevID = "ID"+(N_DOCS+1); // greater than all ids of docs in this test
     for (int i=0; i<h.length; i++) {
       String resID = s.doc(h[i].doc).get(ID_FIELD);
       log(i+".   score="+h[i].score+"  -  "+resID);
-      log(s.explain(q,h[i].doc));
+      log(s.explain(functionQuery,h[i].doc));
       assertTrue("res id "+resID+" should be < prev res id "+prevID, resID.compareTo(prevID)<0);
       prevID = resID;
     }
@@ -99,41 +101,41 @@
   @Test
   public void testExactScoreByte () throws Exception {
     // INT field values are small enough to be parsed as byte
-    doTestExactScore(INT_FIELD,FieldScoreQuery.Type.BYTE);
+    doTestExactScore(BYTE_VALUESOURCE);
   }
 
   /** Test that FieldScoreQuery of Type.SHORT returns the expected scores. */
   @Test
   public void testExactScoreShort () throws  Exception {
     // INT field values are small enough to be parsed as short
-    doTestExactScore(INT_FIELD,FieldScoreQuery.Type.SHORT);
+    doTestExactScore(SHORT_VALUESOURCE);
   }
 
   /** Test that FieldScoreQuery of Type.INT returns the expected scores. */
   @Test
   public void testExactScoreInt () throws  Exception {
-    doTestExactScore(INT_FIELD,FieldScoreQuery.Type.INT);
+    doTestExactScore(INT_VALUESOURCE);
   }
 
   /** Test that FieldScoreQuery of Type.FLOAT returns the expected scores. */
   @Test
   public void testExactScoreFloat () throws  Exception {
     // INT field can be parsed as float
-    doTestExactScore(INT_FIELD,FieldScoreQuery.Type.FLOAT);
+    doTestExactScore(INT_AS_FLOAT_VALUESOURCE);
     // same values, but in flot format
-    doTestExactScore(FLOAT_FIELD,FieldScoreQuery.Type.FLOAT);
+    doTestExactScore(FLOAT_VALUESOURCE);
   }
 
   // Test that FieldScoreQuery returns docs with expected score.
-  private void doTestExactScore (String field, FieldScoreQuery.Type tp) throws Exception {
+  private void doTestExactScore (ValueSource valueSource) throws Exception {
+    FunctionQuery functionQuery = new FunctionQuery(valueSource);
     IndexSearcher s = new IndexSearcher(dir, true);
-    Query q = new FieldScoreQuery(field,tp);
-    TopDocs td = s.search(q,null,1000);
+    TopDocs td = s.search(functionQuery,null,1000);
     assertEquals("All docs should be matched!",N_DOCS,td.totalHits);
     ScoreDoc sd[] = td.scoreDocs;
     for (ScoreDoc aSd : sd) {
       float score = aSd.score;
-      log(s.explain(q, aSd.doc));
+      log(s.explain(functionQuery, aSd.doc));
       String id = s.getIndexReader().document(aSd.doc).get(ID_FIELD);
       float expectedScore = expectedFieldScore(id); // "ID7" --> 7.0
       assertEquals("score of " + id + " shuould be " + expectedScore + " != " + score, expectedScore, score, TEST_SCORE_TOLERANCE_DELTA);
@@ -141,106 +143,4 @@
     s.close();
   }
 
-  /** Test that FieldScoreQuery of Type.BYTE caches/reuses loaded values and consumes the proper RAM resources. */
-  @Test
-  public void testCachingByte () throws  Exception {
-    // INT field values are small enough to be parsed as byte
-    doTestCaching(INT_FIELD,FieldScoreQuery.Type.BYTE);
-  }
-
-  /** Test that FieldScoreQuery of Type.SHORT caches/reuses loaded values and consumes the proper RAM resources. */
-  @Test
-  public void testCachingShort () throws  Exception {
-    // INT field values are small enough to be parsed as short
-    doTestCaching(INT_FIELD,FieldScoreQuery.Type.SHORT);
-  }
-
-  /** Test that FieldScoreQuery of Type.INT caches/reuses loaded values and consumes the proper RAM resources. */
-  @Test
-  public void testCachingInt () throws Exception {
-    doTestCaching(INT_FIELD,FieldScoreQuery.Type.INT);
-  }
-
-  /** Test that FieldScoreQuery of Type.FLOAT caches/reuses loaded values and consumes the proper RAM resources. */
-  @Test
-  public void testCachingFloat () throws  Exception {
-    // INT field values can be parsed as float
-    doTestCaching(INT_FIELD,FieldScoreQuery.Type.FLOAT);
-    // same values, but in flot format
-    doTestCaching(FLOAT_FIELD,FieldScoreQuery.Type.FLOAT);
-  }
-
-  // Test that values loaded for FieldScoreQuery are cached properly and consumes the proper RAM resources.
-  private void doTestCaching (String field, FieldScoreQuery.Type tp) throws Exception {
-    // prepare expected array types for comparison
-    HashMap<FieldScoreQuery.Type,Object> expectedArrayTypes = new HashMap<FieldScoreQuery.Type,Object>();
-    expectedArrayTypes.put(FieldScoreQuery.Type.BYTE, new byte[0]);
-    expectedArrayTypes.put(FieldScoreQuery.Type.SHORT, new short[0]);
-    expectedArrayTypes.put(FieldScoreQuery.Type.INT, new int[0]);
-    expectedArrayTypes.put(FieldScoreQuery.Type.FLOAT, new float[0]);
-    
-    IndexSearcher s = new IndexSearcher(dir, true);
-    Object[] innerArray = new Object[s.getIndexReader().getSequentialSubReaders().length];
-
-    boolean warned = false; // print warning once.
-    for (int i=0; i<10; i++) {
-      FieldScoreQuery q = new FieldScoreQuery(field,tp);
-      ScoreDoc[] h = s.search(q, null, 1000).scoreDocs;
-      assertEquals("All docs should be matched!",N_DOCS,h.length);
-      AtomicReaderContext[] leaves = ReaderUtil.leaves(s.getTopReaderContext());
-      for (int j = 0; j < leaves.length; j++) {
-        AtomicReaderContext leaf = leaves[j];
-        try {
-          if (i == 0) {
-            innerArray[j] = q.valSrc.getValues(leaf).getInnerArray();
-            log(i + ".  compare: " + innerArray[j].getClass() + " to "
-                + expectedArrayTypes.get(tp).getClass());
-            assertEquals(
-                "field values should be cached in the correct array type!",
-                innerArray[j].getClass(), expectedArrayTypes.get(tp).getClass());
-          } else {
-            log(i + ".  compare: " + innerArray[j] + " to "
-                + q.valSrc.getValues(leaf).getInnerArray());
-            assertSame("field values should be cached and reused!", innerArray[j],
-                q.valSrc.getValues(leaf).getInnerArray());
-          }
-        } catch (UnsupportedOperationException e) {
-          if (!warned) {
-            System.err.println("WARNING: " + testName()
-                + " cannot fully test values of " + q);
-            warned = true;
-          }
-        }
-      }
-    }
-    s.close();
-    // verify new values are reloaded (not reused) for a new reader
-    s = new IndexSearcher(dir, true);
-    FieldScoreQuery q = new FieldScoreQuery(field,tp);
-    ScoreDoc[] h = s.search(q, null, 1000).scoreDocs;
-    assertEquals("All docs should be matched!",N_DOCS,h.length);
-    AtomicReaderContext[] leaves = ReaderUtil.leaves(s.getTopReaderContext());
-    for (int j = 0; j < leaves.length; j++) {
-      AtomicReaderContext leaf = leaves[j];
-      try {
-        log("compare: " + innerArray + " to "
-            + q.valSrc.getValues(leaf).getInnerArray());
-        assertNotSame(
-            "cached field values should not be reused if reader as changed!",
-            innerArray, q.valSrc.getValues(leaf).getInnerArray());
-      } catch (UnsupportedOperationException e) {
-        if (!warned) {
-          System.err.println("WARNING: " + testName()
-              + " cannot fully test values of " + q);
-          warned = true;
-        }
-      }
-    }
-    s.close();
-  }
-
-  private String testName() {
-    return getClass().getName()+"."+ getName();
-  }
-
 }
Index: modules/queries/src/test/org/apache/lucene/queries/function/FunctionTestSetup.java
===================================================================
--- modules/queries/src/test/org/apache/lucene/queries/function/FunctionTestSetup.java	(revision 1141367)
+++ modules/queries/src/test/org/apache/lucene/queries/function/FunctionTestSetup.java	(working copy)
@@ -7,6 +7,11 @@
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.queries.function.valuesource.ByteFieldSource;
+import org.apache.lucene.queries.function.valuesource.FloatFieldSource;
+import org.apache.lucene.queries.function.valuesource.IntFieldSource;
+import org.apache.lucene.queries.function.valuesource.ShortFieldSource;
+import org.apache.lucene.search.cache.*;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util._TestUtil;
@@ -48,6 +53,14 @@
   protected static final String INT_FIELD = "iii";
   protected static final String FLOAT_FIELD = "fff";
 
+  private static final int CREATOR_FLAGS = CachedArrayCreator.CACHE_VALUES_AND_BITS;
+
+  protected ValueSource BYTE_VALUESOURCE = new ByteFieldSource(new ByteValuesCreator(INT_FIELD, null, CREATOR_FLAGS));
+  protected ValueSource SHORT_VALUESOURCE = new ShortFieldSource(new ShortValuesCreator(INT_FIELD, null, CREATOR_FLAGS));
+  protected ValueSource INT_VALUESOURCE = new IntFieldSource(new IntValuesCreator(INT_FIELD, null, CREATOR_FLAGS));
+  protected ValueSource INT_AS_FLOAT_VALUESOURCE = new FloatFieldSource(new FloatValuesCreator(INT_FIELD, null, CREATOR_FLAGS));
+  protected ValueSource FLOAT_VALUESOURCE = new FloatFieldSource(new FloatValuesCreator(FLOAT_FIELD, null, CREATOR_FLAGS));
+
   private static final String DOC_TEXT_LINES[] = {
           "Well, this is just some plain text we use for creating the ",
           "test documents. It used to be a text from an online collection ",
Index: modules/queries/src/test/org/apache/lucene/queries/TestCustomScoreQuery.java
===================================================================
--- modules/queries/src/test/org/apache/lucene/queries/TestCustomScoreQuery.java	(revision 1141367)
+++ modules/queries/src/test/org/apache/lucene/queries/TestCustomScoreQuery.java	(working copy)
@@ -19,6 +19,7 @@
 
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.FunctionTestSetup;
+import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.queries.function.valuesource.ByteFieldSource;
 import org.apache.lucene.queries.function.valuesource.FloatFieldSource;
 import org.apache.lucene.queries.function.valuesource.IntFieldSource;
@@ -51,11 +52,8 @@
   @Test
   public void testCustomScoreByte() throws Exception {
     // INT field values are small enough to be parsed as byte
-    ByteValuesCreator valuesCreator = new ByteValuesCreator(INT_FIELD, null, CachedArrayCreator.CACHE_VALUES_AND_BITS);
-    FunctionQuery functionQuery = new FunctionQuery(new ByteFieldSource(valuesCreator));
-
-    doTestCustomScore(functionQuery, 1.0);
-    doTestCustomScore(functionQuery, 2.0);
+    doTestCustomScore(BYTE_VALUESOURCE, 1.0);
+    doTestCustomScore(BYTE_VALUESOURCE, 2.0);
   }
 
   /**
@@ -64,11 +62,8 @@
   @Test
   public void testCustomScoreShort() throws Exception {
     // INT field values are small enough to be parsed as short
-    ShortValuesCreator valuesCreator = new ShortValuesCreator(INT_FIELD, null, CachedArrayCreator.CACHE_VALUES_AND_BITS);
-    FunctionQuery functionQuery = new FunctionQuery(new ShortFieldSource(valuesCreator));
-
-    doTestCustomScore(functionQuery, 1.0);
-    doTestCustomScore(functionQuery, 3.0);
+    doTestCustomScore(SHORT_VALUESOURCE, 1.0);
+    doTestCustomScore(SHORT_VALUESOURCE, 3.0);
   }
 
   /**
@@ -76,11 +71,8 @@
    */
   @Test
   public void testCustomScoreInt() throws Exception {
-    IntValuesCreator valuesCreator = new IntValuesCreator(INT_FIELD, null, CachedArrayCreator.CACHE_VALUES_AND_BITS);
-    FunctionQuery functionQuery = new FunctionQuery(new IntFieldSource(valuesCreator));
-
-    doTestCustomScore(functionQuery, 1.0);
-    doTestCustomScore(functionQuery, 4.0);
+    doTestCustomScore(INT_VALUESOURCE, 1.0);
+    doTestCustomScore(INT_VALUESOURCE, 4.0);
   }
 
   /**
@@ -90,17 +82,14 @@
   public void testCustomScoreFloat() throws Exception {
     // INT field can be parsed as float
     FloatValuesCreator valuesCreator = new FloatValuesCreator(INT_FIELD, null, CachedArrayCreator.CACHE_VALUES_AND_BITS);
-    FunctionQuery functionQuery = new FunctionQuery(new FloatFieldSource(valuesCreator));
+    FloatFieldSource fieldSource = new FloatFieldSource(valuesCreator);
 
-    doTestCustomScore(functionQuery, 1.0);
-    doTestCustomScore(functionQuery, 5.0);
+    doTestCustomScore(INT_AS_FLOAT_VALUESOURCE, 1.0);
+    doTestCustomScore(INT_AS_FLOAT_VALUESOURCE, 5.0);
 
     // same values, but in float format
-    valuesCreator = new FloatValuesCreator(FLOAT_FIELD, null, CachedArrayCreator.CACHE_VALUES_AND_BITS);
-    functionQuery = new FunctionQuery(new FloatFieldSource(valuesCreator));
-
-    doTestCustomScore(functionQuery, 1.0);
-    doTestCustomScore(functionQuery, 6.0);
+    doTestCustomScore(FLOAT_VALUESOURCE, 1.0);
+    doTestCustomScore(FLOAT_VALUESOURCE, 6.0);
   }
 
   // must have static class otherwise serialization tests fail
@@ -250,7 +239,8 @@
   }
   
   // Test that FieldScoreQuery returns docs with expected score.
-  private void doTestCustomScore(FunctionQuery functionQuery, double dboost) throws Exception {
+  private void doTestCustomScore(ValueSource valueSource, double dboost) throws Exception {
+    FunctionQuery functionQuery = new FunctionQuery(valueSource);
     float boost = (float) dboost;
     IndexSearcher s = new IndexSearcher(dir, true);
     QueryParser qp = new QueryParser(TEST_VERSION_CURRENT, TEXT_FIELD, anlzr);
Index: modules/queries/src/java/org/apache/lucene/queries/function/valuesource/NumericIndexDocValueSource.java
===================================================================
--- modules/queries/src/java/org/apache/lucene/queries/function/valuesource/NumericIndexDocValueSource.java	(revision 1141367)
+++ modules/queries/src/java/org/apache/lucene/queries/function/valuesource/NumericIndexDocValueSource.java	(working copy)
@@ -1,4 +1,4 @@
-package org.apache.lucene.search.function;
+package org.apache.lucene.queries.function.valuesource;
 
 /**
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -17,10 +17,13 @@
  * limitations under the License.
  */
 import java.io.IOException;
+import java.util.Map;
 
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.index.values.IndexDocValues;
 import org.apache.lucene.index.values.ValueType;
+import org.apache.lucene.queries.function.DocValues;
+import org.apache.lucene.queries.function.ValueSource;
 
 /**
  * Expert: obtains numeric field values from a {@link IndexDocValues} field.
@@ -39,13 +42,14 @@
   }
 
   @Override
-  public DocValues getValues(AtomicReaderContext context) throws IOException {
-    final IndexDocValues.Source source = context.reader.docValues(field)
+  public DocValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    final IndexDocValues.Source source = readerContext.reader.docValues(field)
         .getSource();
     ValueType type = source.type();
     switch (type) {
     case FLOAT_32:
     case FLOAT_64:
+      // TODO (chrism) Change to use FloatDocValues and IntDocValues
       return new DocValues() {
 
         @Override
Index: modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ReverseOrdFieldSource.java
===================================================================
--- modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ReverseOrdFieldSource.java	(revision 1141367)
+++ modules/queries/src/java/org/apache/lucene/queries/function/valuesource/ReverseOrdFieldSource.java	(working copy)
@@ -79,7 +79,7 @@
 
   @Override
   public boolean equals(Object o) {
-    if (o.getClass() !=  ReverseOrdFieldSource.class) return false;
+    if (o == null || (o.getClass() !=  ReverseOrdFieldSource.class)) return false;
     ReverseOrdFieldSource other = (ReverseOrdFieldSource)o;
     return this.field.equals(other.field);
   }
Index: modules/queries/src/java/org/apache/lucene/queries/function/valuesource/OrdFieldSource.java
===================================================================
--- modules/queries/src/java/org/apache/lucene/queries/function/valuesource/OrdFieldSource.java	(revision 1141367)
+++ modules/queries/src/java/org/apache/lucene/queries/function/valuesource/OrdFieldSource.java	(working copy)
@@ -110,7 +110,7 @@
 
   @Override
   public boolean equals(Object o) {
-    return o.getClass() == OrdFieldSource.class && this.field.equals(((OrdFieldSource)o).field);
+    return o != null && o.getClass() == OrdFieldSource.class && this.field.equals(((OrdFieldSource)o).field);
   }
 
   private static final int hcode = OrdFieldSource.class.hashCode();
Index: lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
===================================================================
--- lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java	(revision 1141367)
+++ lucene/contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java	(working copy)
@@ -35,8 +35,6 @@
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.function.FieldScoreQuery;
-import org.apache.lucene.search.function.FieldScoreQuery.Type;
 import org.apache.lucene.spatial.DistanceUtils;
 import org.apache.lucene.spatial.geohash.GeoHashUtils;
 import org.apache.lucene.spatial.geometry.DistanceUnits;
Index: lucene/MIGRATE.txt
===================================================================
--- lucene/MIGRATE.txt	(revision 1141367)
+++ lucene/MIGRATE.txt	(working copy)
@@ -364,3 +364,21 @@
   for applications that rely on Lucene's internal document ID
   assigment.  If so, you should instead use LogByteSize/DocMergePolicy
   during indexing.
+
+* LUCENE-2883: Lucene's o.a.l.search.function ValueSource based functionality, was consolidated
+  into module/queries along with Solr's similar functionality.  The following classes were moved:
+   - o.a.l.search.function.CustomScoreQuery -> o.a.l.queries.CustomScoreQuery
+   - o.a.l.search.function.CustomScoreProvider -> o.a.l.queries.CustomScoreProvider
+   - o.a.l.search.function.NumericIndexDocValueSource -> o.a.l.queries.function.valuesource.NumericIndexDocValueSource
+  The following lists the replacement classes for those removed:
+   - o.a.l.search.function.ByteFieldSource -> o.a.l.queries.function.valuesource.ByteFieldSource
+   - o.a.l.search.function.DocValues -> o.a.l.queries.function.DocValues
+   - o.a.l.search.function.FieldCacheSource -> o.a.l.queries.function.valuesource.FieldCacheSource
+   - o.a.l.search.function.FieldScoreQuery ->o.a.l.queries.function.FunctionQuery
+   - o.a.l.search.function.FloatFieldSource -> o.a.l.queries.function.valuesource.FloatFieldSource
+   - o.a.l.search.function.IntFieldSource -> o.a.l.queries.function.valuesource.IntFieldSource
+   - o.a.l.search.function.OrdFieldSource -> o.a.l.queries.function.valuesource.OrdFieldSource
+   - o.a.l.search.function.ReverseOrdFieldSource -> o.a.l.queries.function.valuesource.ReverseOrdFieldSource
+   - o.a.l.search.function.ShortFieldSource -> o.a.l.queries.function.valuesource.ShortFieldSource
+   - o.a.l.search.function.ValueSource -> o.a.l.queries.function.ValueSource
+   - o.a.l.search.function.ValueSourceQuery -> o.a.l.queries.function.FunctionQuery
Index: lucene/src/test/org/apache/lucene/search/function/TestOrdValues.java (deleted)
===================================================================
Index: lucene/src/test/org/apache/lucene/search/function/TestDocValues.java (deleted)
===================================================================
Index: lucene/src/test/org/apache/lucene/search/function/TestFieldScoreQuery.java (deleted)
===================================================================
Index: lucene/src/test/org/apache/lucene/search/function/FunctionTestSetup.java (deleted)
===================================================================
Index: lucene/src/test/org/apache/lucene/search/function/JustCompileSearchSpans.java (deleted)
===================================================================
Index: lucene/src/test/org/apache/lucene/search/function/TestValueSource.java (deleted)
===================================================================
Index: lucene/src/java/org/apache/lucene/search/function/IntFieldSource.java (deleted)
===================================================================
Index: lucene/src/java/org/apache/lucene/search/function/ValueSourceQuery.java (deleted)
===================================================================
Index: lucene/src/java/org/apache/lucene/search/function/ShortFieldSource.java (deleted)
===================================================================
Index: lucene/src/java/org/apache/lucene/search/function/DocValues.java (deleted)
===================================================================
Index: lucene/src/java/org/apache/lucene/search/function/FieldScoreQuery.java (deleted)
===================================================================
Index: lucene/src/java/org/apache/lucene/search/function/ReverseOrdFieldSource.java (deleted)
===================================================================
Index: lucene/src/java/org/apache/lucene/search/function/ByteFieldSource.java (deleted)
===================================================================
Index: lucene/src/java/org/apache/lucene/search/function/FieldCacheSource.java (deleted)
===================================================================
Index: lucene/src/java/org/apache/lucene/search/function/MultiValueSource.java (deleted)
===================================================================
Index: lucene/src/java/org/apache/lucene/search/function/OrdFieldSource.java (deleted)
===================================================================
Index: lucene/src/java/org/apache/lucene/search/function/FloatFieldSource.java (deleted)
===================================================================
Index: lucene/src/java/org/apache/lucene/search/function/ValueSource.java (deleted)
===================================================================
Index: lucene/src/java/org/apache/lucene/search/function/NumericIndexDocValueSource.java (deleted)
===================================================================
Index: lucene/src/java/org/apache/lucene/search/function/package.html (deleted)
===================================================================
