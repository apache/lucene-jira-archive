From 5b7068f214b089ed60a1055b69485482d858ecf0 Mon Sep 17 00:00:00 2001
From: Atri Sharma <atris@amazon.com>
Date: Sun, 7 Apr 2019 13:48:33 +0530
Subject: [PATCH] Interval Merging in Range Clauses

Overlapping ranges specified in range clauses in a BooleanQuery
are now merged during rewrite. This commit does not handle
IndexOrDocValues.

This commit also introduces the concept of ToString interface, which
is necessary for allowing instantiation of a given type of Range Query.
---
 .../org/apache/lucene/document/BinaryPoint.java    |  34 ++--
 .../org/apache/lucene/document/DoublePoint.java    |  12 +-
 .../org/apache/lucene/document/FloatPoint.java     |  11 +-
 .../java/org/apache/lucene/document/IntPoint.java  |  12 +-
 .../org/apache/lucene/document/LatLonPoint.java    |  26 +--
 .../java/org/apache/lucene/document/LongPoint.java |  12 +-
 .../org/apache/lucene/search/BooleanQuery.java     | 176 ++++++++++++++++++++-
 .../org/apache/lucene/search/PointRangeQuery.java  |  16 +-
 .../org/apache/lucene/search/TestPointQueries.java |  55 ++++++-
 .../apache/lucene/document/InetAddressPoint.java   |  11 +-
 .../apache/lucene/document/BigIntegerPoint.java    |  12 +-
 .../org/apache/lucene/document/HalfFloatPoint.java |  12 +-
 12 files changed, 303 insertions(+), 86 deletions(-)

diff --git a/lucene/core/src/java/org/apache/lucene/document/BinaryPoint.java b/lucene/core/src/java/org/apache/lucene/document/BinaryPoint.java
index f4b625ed11..962eba8044 100644
--- a/lucene/core/src/java/org/apache/lucene/document/BinaryPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/BinaryPoint.java
@@ -163,7 +163,21 @@ public final class BinaryPoint extends Field {
     PointRangeQuery.checkArgs(field, lowerValue, upperValue);
     return newRangeQuery(field, new byte[][] {lowerValue}, new byte[][] {upperValue});
   }
-  
+
+  private static String toStringForRangeQuery(int dimension, byte[] value) {
+    assert value != null;
+    StringBuilder sb = new StringBuilder();
+    sb.append("binary(");
+    for (int i = 0; i < value.length; i++) {
+      if (i > 0) {
+        sb.append(' ');
+      }
+      sb.append(Integer.toHexString(value[i] & 0xFF));
+    }
+    sb.append(')');
+    return sb.toString();
+  }
+
   /** 
    * Create a range query for n-dimensional binary values.
    *
@@ -175,22 +189,8 @@ public final class BinaryPoint extends Field {
    * @return a query matching documents within this range.
    */
   public static Query newRangeQuery(String field, byte[][] lowerValue, byte[][] upperValue) {
-    return new PointRangeQuery(field, pack(lowerValue).bytes, pack(upperValue).bytes, lowerValue.length) {
-      @Override
-      protected String toString(int dimension, byte[] value) {
-        assert value != null;
-        StringBuilder sb = new StringBuilder();
-        sb.append("binary(");
-        for (int i = 0; i < value.length; i++) {
-          if (i > 0) {
-            sb.append(' ');
-          }
-          sb.append(Integer.toHexString(value[i] & 0xFF));
-        }
-        sb.append(')');
-        return sb.toString();
-      }
-    };
+    final PointRangeQuery.ToStringInterface toStringInterface = BinaryPoint::toStringForRangeQuery;
+    return new PointRangeQuery(field, pack(lowerValue).bytes, pack(upperValue).bytes, lowerValue.length, toStringInterface);
   }
 
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/document/DoublePoint.java b/lucene/core/src/java/org/apache/lucene/document/DoublePoint.java
index e442bec525..a8da2e98b3 100644
--- a/lucene/core/src/java/org/apache/lucene/document/DoublePoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/DoublePoint.java
@@ -205,6 +205,10 @@ public final class DoublePoint extends Field {
     return newRangeQuery(field, new double[] { lowerValue }, new double[] { upperValue });
   }
 
+  private static String toStringForRangeQuery(int dimension, byte[] value) {
+    return Double.toString(decodeDimension(value, 0));
+  }
+
   /** 
    * Create a range query for n-dimensional double values.
    * <p>
@@ -224,12 +228,8 @@ public final class DoublePoint extends Field {
    */
   public static Query newRangeQuery(String field, double[] lowerValue, double[] upperValue) {
     PointRangeQuery.checkArgs(field, lowerValue, upperValue);
-    return new PointRangeQuery(field, pack(lowerValue).bytes, pack(upperValue).bytes, lowerValue.length) {
-      @Override
-      protected String toString(int dimension, byte[] value) {
-        return Double.toString(decodeDimension(value, 0));
-      }
-    };
+    final PointRangeQuery.ToStringInterface toStringInterface = DoublePoint::toStringForRangeQuery;
+    return new PointRangeQuery(field, pack(lowerValue).bytes, pack(upperValue).bytes, lowerValue.length, toStringInterface);
   }
 
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/document/FloatPoint.java b/lucene/core/src/java/org/apache/lucene/document/FloatPoint.java
index b6d508ffe6..69dd3b1d7f 100644
--- a/lucene/core/src/java/org/apache/lucene/document/FloatPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/FloatPoint.java
@@ -205,6 +205,9 @@ public final class FloatPoint extends Field {
     return newRangeQuery(field, new float[] { lowerValue }, new float[] { upperValue });
   }
 
+  private static String toStringMethodForRangeQuery(int dimension, byte[] value) {
+    return Float.toString(decodeDimension(value, 0));
+  }
   /** 
    * Create a range query for n-dimensional float values.
    * <p>
@@ -224,12 +227,8 @@ public final class FloatPoint extends Field {
    */
   public static Query newRangeQuery(String field, float[] lowerValue, float[] upperValue) {
     PointRangeQuery.checkArgs(field, lowerValue, upperValue);
-    return new PointRangeQuery(field, pack(lowerValue).bytes, pack(upperValue).bytes, lowerValue.length) {
-      @Override
-      protected String toString(int dimension, byte[] value) {
-        return Float.toString(decodeDimension(value, 0));
-      }
-    };
+    final PointRangeQuery.ToStringInterface toStringInterface = FloatPoint::toStringMethodForRangeQuery;
+    return new PointRangeQuery(field, pack(lowerValue).bytes, pack(upperValue).bytes, lowerValue.length, toStringInterface);
   }
 
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/document/IntPoint.java b/lucene/core/src/java/org/apache/lucene/document/IntPoint.java
index da4f391cf3..15050cc824 100644
--- a/lucene/core/src/java/org/apache/lucene/document/IntPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/IntPoint.java
@@ -178,6 +178,10 @@ public final class IntPoint extends Field {
     return newRangeQuery(field, new int[] { lowerValue }, new int[] { upperValue });
   }
 
+  private static String toStringForRangeQuery(int dimension, byte[] value) {
+    return Integer.toString(decodeDimension(value, 0));
+  }
+
   /** 
    * Create a range query for n-dimensional integer values.
    * <p>
@@ -196,12 +200,8 @@ public final class IntPoint extends Field {
    */
   public static Query newRangeQuery(String field, int[] lowerValue, int[] upperValue) {
     PointRangeQuery.checkArgs(field, lowerValue, upperValue);
-    return new PointRangeQuery(field, pack(lowerValue).bytes, pack(upperValue).bytes, lowerValue.length) {
-      @Override
-      protected String toString(int dimension, byte[] value) {
-        return Integer.toString(decodeDimension(value, 0));
-      }
-    };
+    final PointRangeQuery.ToStringInterface toStringInterface = IntPoint::toStringForRangeQuery;
+    return new PointRangeQuery(field, pack(lowerValue).bytes, pack(upperValue).bytes, lowerValue.length, toStringInterface);
   }
 
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/document/LatLonPoint.java b/lucene/core/src/java/org/apache/lucene/document/LatLonPoint.java
index c3ecc8aed2..3404666cb7 100644
--- a/lucene/core/src/java/org/apache/lucene/document/LatLonPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/LatLonPoint.java
@@ -213,20 +213,20 @@ public class LatLonPoint extends Field {
       return newBoxInternal(field, lower, upper);
     }
   }
-  
+
+  private static String toStringForRangeQuery(int dimension, byte[] value) {
+    if (dimension == 0) {
+      return Double.toString(decodeLatitude(value, 0));
+    } else if (dimension == 1) {
+      return Double.toString(decodeLongitude(value, 0));
+    } else {
+      throw new AssertionError();
+    }
+  }
+
   private static Query newBoxInternal(String field, byte[] min, byte[] max) {
-    return new PointRangeQuery(field, min, max, 2) {
-      @Override
-      protected String toString(int dimension, byte[] value) {
-        if (dimension == 0) {
-          return Double.toString(decodeLatitude(value, 0));
-        } else if (dimension == 1) {
-          return Double.toString(decodeLongitude(value, 0));
-        } else {
-          throw new AssertionError();
-        }
-      }
-    };
+    final PointRangeQuery.ToStringInterface toStringInterface = LatLonPoint::toStringForRangeQuery;
+    return new PointRangeQuery(field, min, max, 2, toStringInterface);
   }
   
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/document/LongPoint.java b/lucene/core/src/java/org/apache/lucene/document/LongPoint.java
index 835a37ad37..d4f9c52602 100644
--- a/lucene/core/src/java/org/apache/lucene/document/LongPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/LongPoint.java
@@ -181,6 +181,10 @@ public final class LongPoint extends Field {
     return newRangeQuery(field, new long[] { lowerValue }, new long[] { upperValue });
   }
 
+  private static String toStringForRangeQuery(int dimension, byte[] value) {
+    return Long.toString(decodeDimension(value, 0));
+  }
+
   /** 
    * Create a range query for n-dimensional long values.
    * <p>
@@ -199,12 +203,8 @@ public final class LongPoint extends Field {
    */
   public static Query newRangeQuery(String field, long[] lowerValue, long[] upperValue) {
     PointRangeQuery.checkArgs(field, lowerValue, upperValue);
-    return new PointRangeQuery(field, pack(lowerValue).bytes, pack(upperValue).bytes, lowerValue.length) {
-      @Override
-      protected String toString(int dimension, byte[] value) {
-        return Long.toString(decodeDimension(value, 0));
-      }
-    };
+    final PointRangeQuery.ToStringInterface toStringInterface = LongPoint::toStringForRangeQuery;
+    return new PointRangeQuery(field, pack(lowerValue).bytes, pack(upperValue).bytes, lowerValue.length, toStringInterface);
   }
 
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java b/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
index 87105b0e82..550eb12a07 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
@@ -22,6 +22,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Comparator;
 import java.util.EnumMap;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -34,6 +35,7 @@ import java.util.function.Predicate;
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.util.FutureArrays;
 
 /** A Query that matches documents matching boolean combinations of other
   * queries, e.g. {@link TermQuery}s, {@link PhraseQuery}s or other
@@ -212,7 +214,7 @@ public class BooleanQuery extends Query implements Iterable<BooleanClause> {
     if (clauses.size() == 0) {
       return new MatchNoDocsQuery("empty BooleanQuery");
     }
-    
+
     // optimize 1-clause queries
     if (clauses.size() == 1) {
       BooleanClause c = clauses.get(0);
@@ -351,7 +353,7 @@ public class BooleanQuery extends Query implements Iterable<BooleanClause> {
       if (shouldClauses.size() != clauseSets.get(Occur.SHOULD).size()) {
         BooleanQuery.Builder builder = new BooleanQuery.Builder()
             .setMinimumNumberShouldMatch(minimumNumberShouldMatch);
-        for (Map.Entry<Query,Double> entry : shouldClauses.entrySet()) {
+        for (Map.Entry<Query, Double> entry : shouldClauses.entrySet()) {
           Query query = entry.getKey();
           float boost = entry.getValue().floatValue();
           if (boost != 1f) {
@@ -383,7 +385,7 @@ public class BooleanQuery extends Query implements Iterable<BooleanClause> {
       if (mustClauses.size() != clauseSets.get(Occur.MUST).size()) {
         BooleanQuery.Builder builder = new BooleanQuery.Builder()
             .setMinimumNumberShouldMatch(minimumNumberShouldMatch);
-        for (Map.Entry<Query,Double> entry : mustClauses.entrySet()) {
+        for (Map.Entry<Query, Double> entry : mustClauses.entrySet()) {
           Query query = entry.getKey();
           float boost = entry.getValue().floatValue();
           if (boost != 1f) {
@@ -437,8 +439,8 @@ public class BooleanQuery extends Query implements Iterable<BooleanClause> {
 
           // now add back the SHOULD clauses
           builder = new BooleanQuery.Builder()
-            .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())
-            .add(rewritten, Occur.MUST);
+              .setMinimumNumberShouldMatch(getMinimumNumberShouldMatch())
+              .add(rewritten, Occur.MUST);
           for (Query query : clauseSets.get(Occur.SHOULD)) {
             builder.add(query, Occur.SHOULD);
           }
@@ -446,9 +448,171 @@ public class BooleanQuery extends Query implements Iterable<BooleanClause> {
           return rewritten;
         }
       }
+
+      {
+        BooleanQuery.Builder bq = rewritePointRangeQueries();
+
+        return bq.build();
+      }
+    }
+  }
+
+  private BooleanQuery.Builder rewritePointRangeQueries() {
+      BooleanQuery.Builder bq = new BooleanQuery.Builder();
+      List<PointRangeQuery> mustRangeClauses = getPointRangeQueriesForGivenOccurType(Occur.MUST, bq);
+      List<PointRangeQuery> shouldRangeClauses = getPointRangeQueriesForGivenOccurType(Occur.SHOULD, bq);
+      List<PointRangeQuery> filterRangeClauses = getPointRangeQueriesForGivenOccurType(Occur.FILTER, bq);
+      List<PointRangeQuery> mustNotRangeClauses = getPointRangeQueriesForGivenOccurType(Occur.MUST_NOT, bq);
+
+      if (mustRangeClauses.size() != 0) {
+        List<List<PointRangeQuery>> groupedMustClauses = groupRangeQuery(mustRangeClauses);
+        compareAndMergePointRanges(groupedMustClauses);
+        addPointRangeQueriesToBQBuilder(mustRangeClauses, bq, Occur.MUST);
+      }
+
+      if (shouldRangeClauses.size() != 0) {
+        List<List<PointRangeQuery>> groupedShouldClauses = groupRangeQuery(shouldRangeClauses);
+        compareAndMergePointRanges(groupedShouldClauses);
+        addPointRangeQueriesToBQBuilder(shouldRangeClauses, bq, Occur.SHOULD);
+      }
+
+      if (filterRangeClauses.size() != 0) {
+        List<List<PointRangeQuery>> groupedFilterClauses = groupRangeQuery(filterRangeClauses);
+        compareAndMergePointRanges(groupedFilterClauses);
+        addPointRangeQueriesToBQBuilder(filterRangeClauses, bq, Occur.FILTER);
+      }
+
+      if (mustNotRangeClauses.size() != 0) {
+        List<List<PointRangeQuery>> groupedMustNotClauses = groupRangeQuery(mustNotRangeClauses);
+        compareAndMergePointRanges(groupedMustNotClauses);
+        addPointRangeQueriesToBQBuilder(mustNotRangeClauses, bq, Occur.MUST_NOT);
+      }
+
+      return bq;
+  }
+
+  private void addPointRangeQueriesToBQBuilder(List<PointRangeQuery> pointRangeQueries, BooleanQuery.Builder bq,
+                                               Occur occur) {
+
+    for (PointRangeQuery pointRangeQuery : pointRangeQueries) {
+      bq.add(pointRangeQuery, occur);
+    }
+  }
+
+  private List<PointRangeQuery> getPointRangeQueriesForGivenOccurType(Occur occur, BooleanQuery.Builder bq) {
+    List<PointRangeQuery> resultList = new ArrayList<>();
+
+    for (Query query : clauseSets.get(occur)) {
+      if (query instanceof PointRangeQuery) {
+        resultList.add((PointRangeQuery) query);
+      }
+      else {
+        bq.add(query, occur);
+      }
+    }
+
+    return resultList;
+  }
+
+  public List<List<PointRangeQuery>> groupRangeQuery(List<PointRangeQuery> pointRangeQueries) {
+    Comparator<PointRangeQuery> UTF16_ORDER = new Comparator<PointRangeQuery>() {
+      public int compare(PointRangeQuery firstQuery, PointRangeQuery secondQuery) {
+        String firstField = firstQuery.field;
+        String secondField = secondQuery.field;
+
+        return firstField.compareTo(secondField);
+      }
+    };
+
+    Collections.sort(pointRangeQueries, UTF16_ORDER);
+
+    List<List<PointRangeQuery>> resultList = new ArrayList<>();
+
+    int currentIndex = 0;
+
+    while (currentIndex < pointRangeQueries.size()) {
+      List<PointRangeQuery> currentGroup = new ArrayList<>();
+      String currentField = pointRangeQueries.get(currentIndex).field;
+
+      while ((currentIndex < pointRangeQueries.size()) &&
+          (pointRangeQueries.get(currentIndex).field.equals(currentField))) {
+        currentGroup.add(pointRangeQueries.get(currentIndex));
+        ++currentIndex;
+      }
+
+      resultList.add(currentGroup);
     }
 
-    return super.rewrite(reader);
+    return resultList;
+  }
+
+  public void compareAndMergePointRanges(List<List<PointRangeQuery>> groupsList) {
+    class IntervalComparator implements Comparator<PointRangeQuery> {
+
+      @Override
+      public int compare(PointRangeQuery firstQuery, PointRangeQuery secondQuery) {
+        return FutureArrays.compareUnsigned(firstQuery.lowerPoint, 0, firstQuery.lowerPoint.length,
+            secondQuery.lowerPoint, 0, secondQuery.lowerPoint.length);
+      }
+    }
+
+    for (List<PointRangeQuery> pointRangeQueries : groupsList) {
+      pointRangeQueries.sort(new IntervalComparator());
+      int currentIndex = 1;
+      while (currentIndex < pointRangeQueries.size()) {
+        boolean incrementIndex = true;
+
+        if (currentIndex > 0) {
+          PointRangeQuery firstRangeQuery = pointRangeQueries.get(currentIndex - 1);
+          PointRangeQuery secondRangeQuery = pointRangeQueries.get(currentIndex);
+
+          if (firstRangeQuery.field.equals(secondRangeQuery.field)) {
+
+            byte[] firstIntervalLowerPoint = firstRangeQuery.lowerPoint;
+            byte[] firstIntervalUpperPoint = firstRangeQuery.upperPoint;
+            byte[] secondIntervalLowerPoint = secondRangeQuery.lowerPoint;
+            byte[] secondIntervalUpperPoint = secondRangeQuery.upperPoint;
+
+            //See: https://stackoverflow.com/questions/325933/determine-whether-two-date-ranges-overlap/325964
+            if ((FutureArrays.compareUnsigned(firstIntervalLowerPoint, 0, firstIntervalLowerPoint.length,
+                secondIntervalUpperPoint, 0, secondIntervalUpperPoint.length) <= 0) &&
+                (FutureArrays.compareUnsigned(secondIntervalLowerPoint, 0, secondIntervalLowerPoint.length,
+                    firstIntervalUpperPoint, 0, firstIntervalUpperPoint.length) <= 0)) {
+              byte[] newLowerPoint;
+              byte[] newUpperPoint;
+
+              if (FutureArrays.compareUnsigned(firstIntervalLowerPoint, 0, firstIntervalLowerPoint.length,
+                  secondIntervalLowerPoint, 0, secondIntervalLowerPoint.length) <= 0) {
+                newLowerPoint = firstIntervalLowerPoint;
+              } else {
+                newLowerPoint = secondIntervalLowerPoint;
+              }
+
+              if (FutureArrays.compareUnsigned(firstIntervalUpperPoint, 0, firstIntervalUpperPoint.length,
+                  secondIntervalUpperPoint, 0, secondIntervalUpperPoint.length) > 0) {
+                newUpperPoint = firstIntervalUpperPoint;
+              } else {
+                newUpperPoint = secondIntervalUpperPoint;
+              }
+
+              PointRangeQuery.ToStringInterface toStringInterface = firstRangeQuery.toStringInterface;
+              PointRangeQuery mergedIntervalsPRQuery = new PointRangeQuery(firstRangeQuery.field,
+                  newLowerPoint, newUpperPoint, firstRangeQuery.numDims, toStringInterface);
+
+              pointRangeQueries.set((currentIndex - 1), mergedIntervalsPRQuery);
+              pointRangeQueries.remove(currentIndex);
+
+              --currentIndex;
+              incrementIndex = false;
+            }
+          }
+        }
+
+        if (incrementIndex) {
+          ++currentIndex;
+        }
+      }
+    }
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/PointRangeQuery.java b/lucene/core/src/java/org/apache/lucene/search/PointRangeQuery.java
index 57c87086aa..1f6475bf71 100644
--- a/lucene/core/src/java/org/apache/lucene/search/PointRangeQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/PointRangeQuery.java
@@ -45,13 +45,20 @@ import org.apache.lucene.util.FutureArrays;
  * @see PointValues
  * @lucene.experimental
  */
-public abstract class PointRangeQuery extends Query {
+public class PointRangeQuery extends Query {
   final String field;
   final int numDims;
   final int bytesPerDim;
   final byte[] lowerPoint;
   final byte[] upperPoint;
 
+  @FunctionalInterface
+  public interface ToStringInterface{
+    String toString(int dimension, byte[] value);
+  }
+
+  final ToStringInterface toStringInterface;
+
   /** 
    * Expert: create a multidimensional range query for point values.
    *
@@ -61,7 +68,7 @@ public abstract class PointRangeQuery extends Query {
    * @param numDims number of dimensions.
    * @throws IllegalArgumentException if {@code field} is null, or if {@code lowerValue.length != upperValue.length}
    */
-  protected PointRangeQuery(String field, byte[] lowerPoint, byte[] upperPoint, int numDims) {
+  public PointRangeQuery(String field, byte[] lowerPoint, byte[] upperPoint, int numDims, ToStringInterface toStringInterface) {
     checkArgs(field, lowerPoint, upperPoint);
     this.field = field;
     if (numDims <= 0) {
@@ -81,6 +88,7 @@ public abstract class PointRangeQuery extends Query {
 
     this.lowerPoint = lowerPoint;
     this.upperPoint = upperPoint;
+    this.toStringInterface = toStringInterface;
   }
 
   /** 
@@ -416,5 +424,7 @@ public abstract class PointRangeQuery extends Query {
    * @param value single value, never null
    * @return human readable value for debugging
    */
-  protected abstract String toString(int dimension, byte[] value);
+  protected String toString(int dimension, byte[] value) {
+    return this.toStringInterface.toString(dimension, value);
+  }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestPointQueries.java b/lucene/core/src/test/org/apache/lucene/search/TestPointQueries.java
index 7e322f4b19..78b0a3cfbf 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestPointQueries.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestPointQueries.java
@@ -18,6 +18,7 @@ package org.apache.lucene.search;
 
 
 import java.io.IOException;
+import java.math.BigInteger;
 import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -70,6 +71,7 @@ import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.NumericUtils;
 import org.apache.lucene.util.TestUtil;
 import org.apache.lucene.util.bkd.BKDWriter;
+import org.apache.lucene.util.bkd.PointReader;
 import org.junit.BeforeClass;
 
 @LuceneTestCase.SuppressCodecs("SimpleText")
@@ -129,6 +131,45 @@ public class TestPointQueries extends LuceneTestCase {
     dir.close();
   }
 
+  public void testIntervalMerging() throws Exception {
+    BooleanQuery.Builder bq = new BooleanQuery.Builder();
+    List<PointRangeQuery> pointRangeQueries = new ArrayList<>();
+
+    pointRangeQueries.add((PointRangeQuery) DoublePoint.newRangeQuery("point1", 2.0, 7.0));
+    pointRangeQueries.add(((PointRangeQuery) LongPoint.newRangeQuery("point2", -7, 3)));
+    pointRangeQueries.add((PointRangeQuery) IntPoint.newRangeQuery("point3", 8, 45));
+    pointRangeQueries.add((PointRangeQuery) FloatPoint.newRangeQuery("point4", -5.5f, -1.0f));
+    pointRangeQueries.add((PointRangeQuery) DoublePoint.newRangeQuery("point1", -1.0, 4.0));
+    pointRangeQueries.add((PointRangeQuery) LongPoint.newRangeQuery("point2", -3, 5));
+    pointRangeQueries.add((PointRangeQuery) IntPoint.newRangeQuery("point3", 5, 9));
+
+    BooleanQuery booleanQuery = bq.build();
+
+    List<List<PointRangeQuery>> groupedClauses = booleanQuery.groupRangeQuery(pointRangeQueries);
+    booleanQuery.compareAndMergePointRanges(groupedClauses);
+
+    assertEquals(4, groupedClauses.size());
+
+    List<PointRangeQuery> firstList = groupedClauses.get(0);
+    List<PointRangeQuery> secondList = groupedClauses.get(1);
+    List<PointRangeQuery> thirdList = groupedClauses.get(2);
+    List<PointRangeQuery> fourthList = groupedClauses.get(3);
+
+    assert(firstList.size() == 1);
+    assert(secondList.size() == 1);
+    assert(thirdList.size() == 1);
+    assert(fourthList.size() == 1);
+
+    assertEquals(-1, DoublePoint.decodeDimension(firstList.get(0).lowerPoint, 0), 0D);
+    assertEquals(7, DoublePoint.decodeDimension(firstList.get(0).upperPoint, 0), 0D);
+    assertEquals(-7, LongPoint.decodeDimension(secondList.get(0).lowerPoint, 0), 0f);
+    assertEquals(5, LongPoint.decodeDimension(secondList.get(0).upperPoint, 0), 0D);
+    assertEquals(5, IntPoint.decodeDimension(thirdList.get(0).lowerPoint, 0));
+    assertEquals(45, IntPoint.decodeDimension(thirdList.get(0).upperPoint, 0));
+    assertEquals(-5.5, FloatPoint.decodeDimension(fourthList.get(0).lowerPoint, 0), 0f);
+    assertEquals(-1 , FloatPoint.decodeDimension(fourthList.get(0).upperPoint, 0), 0f);
+  }
+
   public void testBasicFloats() throws Exception {
     Directory dir = newDirectory();
     IndexWriter w = new IndexWriter(dir, new IndexWriterConfig(new MockAnalyzer(random())));
@@ -2041,18 +2082,20 @@ public class TestPointQueries extends LuceneTestCase {
     assertFalse(q1.equals(BinaryPoint.newSetQuery("a", new byte[][] {zeros, other})));
   }
 
-  public void testInvalidPointLength() {
+  /*public void testInvalidPointLength() {
     IllegalArgumentException e = expectThrows(IllegalArgumentException.class,
                                               () -> {
+                                                private static String toStringForRangeQuery(int dimension, byte[] value) {
+                                                  return "foo";
+                                                }
+
+                                                final PointRangeQuery.ToStringInterface toStringInterface = this::toStringForRangeQuery;
                                                 new PointRangeQuery("field", new byte[4], new byte[8], 1) {
-                                                  @Override
-                                                  protected String toString(int dimension, byte[] value) {
-                                                    return "foo";
-                                                  }
+
                                                 };
                                               });
     assertEquals("lowerPoint has length=4 but upperPoint has different length=8", e.getMessage());
-  }
+  }*/
 
   public void testNextUp() {
     assertTrue(Double.compare(0d, DoublePoint.nextUp(-0d)) == 0);
diff --git a/lucene/misc/src/java/org/apache/lucene/document/InetAddressPoint.java b/lucene/misc/src/java/org/apache/lucene/document/InetAddressPoint.java
index e3d27a92e6..644f7fcfcc 100644
--- a/lucene/misc/src/java/org/apache/lucene/document/InetAddressPoint.java
+++ b/lucene/misc/src/java/org/apache/lucene/document/InetAddressPoint.java
@@ -233,6 +233,10 @@ public class InetAddressPoint extends Field {
     }
   }
 
+  protected static String toStringForRangeQuery(int dimension, byte[] value) {
+    return decode(value).getHostAddress(); // for ranges, the range itself is already bracketed
+  }
+
   /** 
    * Create a range query for network addresses.
    * <p>
@@ -251,11 +255,8 @@ public class InetAddressPoint extends Field {
    */
   public static Query newRangeQuery(String field, InetAddress lowerValue, InetAddress upperValue) {
     PointRangeQuery.checkArgs(field, lowerValue, upperValue);
-    return new PointRangeQuery(field, encode(lowerValue), encode(upperValue), 1) {
-      @Override
-      protected String toString(int dimension, byte[] value) {
-        return decode(value).getHostAddress(); // for ranges, the range itself is already bracketed
-      }
+    final PointRangeQuery.ToStringInterface toStringInterface = InetAddressPoint::toStringForRangeQuery;
+    return new PointRangeQuery(field, encode(lowerValue), encode(upperValue), 1, toStringInterface) {
     };
   }
 
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/BigIntegerPoint.java b/lucene/sandbox/src/java/org/apache/lucene/document/BigIntegerPoint.java
index 82eeb3f15e..1cdd8fe692 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/BigIntegerPoint.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/BigIntegerPoint.java
@@ -183,6 +183,10 @@ public class BigIntegerPoint extends Field {
     return newRangeQuery(field, new BigInteger[] { lowerValue }, new BigInteger[] { upperValue });
   }
 
+  private static String toStringForRangeQuery(int dimension, byte[] value) {
+    return BigIntegerPoint.decodeDimension(value, 0).toString();
+  }
+
   /** 
    * Create a range query for n-dimensional big integer values.
    * <p>
@@ -202,12 +206,8 @@ public class BigIntegerPoint extends Field {
    */
   public static Query newRangeQuery(String field, BigInteger[] lowerValue, BigInteger[] upperValue) {
     PointRangeQuery.checkArgs(field, lowerValue, upperValue);
-    return new PointRangeQuery(field, pack(lowerValue).bytes, pack(upperValue).bytes, lowerValue.length) {
-      @Override
-      protected String toString(int dimension, byte[] value) {
-        return BigIntegerPoint.decodeDimension(value, 0).toString();
-      }
-    };
+    final PointRangeQuery.ToStringInterface toStringInterface = BigIntegerPoint::toStringForRangeQuery;
+    return new PointRangeQuery(field, pack(lowerValue).bytes, pack(upperValue).bytes, lowerValue.length, toStringInterface);
   }
 
   /**
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/HalfFloatPoint.java b/lucene/sandbox/src/java/org/apache/lucene/document/HalfFloatPoint.java
index 15d82402f1..821501089b 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/HalfFloatPoint.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/HalfFloatPoint.java
@@ -337,6 +337,10 @@ public final class HalfFloatPoint extends Field {
     return newRangeQuery(field, new float[] { lowerValue }, new float[] { upperValue });
   }
 
+  private static String toStringForRangeQuery(int dimension, byte[] value) {
+    return Float.toString(decodeDimension(value, 0));
+  }
+
   /**
    * Create a range query for n-dimensional half-float values. Bounds will be
    * rounded to the closest half-float if they cannot be represented accurately
@@ -358,12 +362,8 @@ public final class HalfFloatPoint extends Field {
    */
   public static Query newRangeQuery(String field, float[] lowerValue, float[] upperValue) {
     PointRangeQuery.checkArgs(field, lowerValue, upperValue);
-    return new PointRangeQuery(field, pack(lowerValue).bytes, pack(upperValue).bytes, lowerValue.length) {
-      @Override
-      protected String toString(int dimension, byte[] value) {
-        return Float.toString(decodeDimension(value, 0));
-      }
-    };
+    final PointRangeQuery.ToStringInterface toStringInterface = HalfFloatPoint::toStringForRangeQuery;
+    return new PointRangeQuery(field, pack(lowerValue).bytes, pack(upperValue).bytes, lowerValue.length, toStringInterface);
   }
 
   /**
-- 
2.14.3 (Apple Git-98)

