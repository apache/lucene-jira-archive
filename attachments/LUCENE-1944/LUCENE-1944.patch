Index: src/java/org/apache/lucene/index/CompoundFileReader.java
===================================================================
--- src/java/org/apache/lucene/index/CompoundFileReader.java	(revision 821345)
+++ src/java/org/apache/lucene/index/CompoundFileReader.java	(working copy)
@@ -140,7 +140,7 @@
     }
 
     /** Returns an array of strings, one for each file in the directory. */
-    public String[] list() {
+    public String[] listAll() {
         String res[] = new String[entries.size()];
         return (String[]) entries.keySet().toArray(res);
     }
Index: src/java/org/apache/lucene/index/DirectoryOwningReader.java
===================================================================
--- src/java/org/apache/lucene/index/DirectoryOwningReader.java	(revision 821345)
+++ src/java/org/apache/lucene/index/DirectoryOwningReader.java	(working copy)
@@ -1,105 +0,0 @@
-package org.apache.lucene.index;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-/** 
- * This class keeps track of closing the underlying directory. It is used to wrap
- * DirectoryReaders, that are created using a String/File parameter
- * in IndexReader.open() with FSDirectory.getDirectory().
- * @deprecated This helper class is removed with all String/File
- * IndexReader.open() methods in Lucene 3.0
- */
-final class DirectoryOwningReader extends FilterIndexReader implements Cloneable {
-
-  DirectoryOwningReader(final IndexReader in) {
-    super(in);
-    this.ref = new SegmentReader.Ref();
-    assert this.ref.refCount() == 1;
-  }
-
-  private DirectoryOwningReader(final IndexReader in, final SegmentReader.Ref ref) {
-    super(in);
-    this.ref = ref;
-    ref.incRef();
-  }
-
-  public IndexReader reopen() throws CorruptIndexException, IOException {
-    ensureOpen();
-    final IndexReader r = in.reopen();
-    if (r != in)
-      return new DirectoryOwningReader(r, ref);
-    return this;
-  }
-
-  public IndexReader reopen(boolean openReadOnly) throws CorruptIndexException, IOException {
-    ensureOpen();
-    final IndexReader r = in.reopen(openReadOnly);
-    if (r != in)
-      return new DirectoryOwningReader(r, ref);
-    return this;
-  }
-
-  public IndexReader reopen(final IndexCommit commit) throws CorruptIndexException, IOException {
-    ensureOpen();
-    final IndexReader r = in.reopen(commit);
-    if (r != in)
-      return new DirectoryOwningReader(r, ref);
-    return this;
-  }
-
-  public Object clone() {
-    ensureOpen();
-    return new DirectoryOwningReader((IndexReader) in.clone(), ref);
-  }
-
-  public IndexReader clone(boolean openReadOnly) throws CorruptIndexException, IOException {
-    ensureOpen();
-    return new DirectoryOwningReader(in.clone(openReadOnly), ref);
-  }
-
-  protected void doClose() throws IOException {
-    IOException ioe = null;
-    // close the reader, record exception
-    try {
-      super.doClose();
-    } catch (IOException e) {
-      ioe = e;
-    }
-    // close the directory, record exception
-    if (ref.decRef() == 0) {
-      try {
-        in.directory().close();
-      } catch (IOException e) {
-        if (ioe == null) ioe = e;
-      }
-    }
-    // throw the first exception
-    if (ioe != null) throw ioe;
-  }
-
-  /**
-   * This member contains the ref counter, that is passed to each instance after cloning/reopening,
-   * and is global to all DirectoryOwningReader derived from the original one.
-   * This reuses the class {@link SegmentReader.Ref}
-   */
-  private final SegmentReader.Ref ref;
-
-}
-
Index: src/java/org/apache/lucene/index/IndexModifier.java
===================================================================
--- src/java/org/apache/lucene/index/IndexModifier.java	(revision 821345)
+++ src/java/org/apache/lucene/index/IndexModifier.java	(working copy)
@@ -1,611 +0,0 @@
-package org.apache.lucene.index;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.FSDirectory;
-import org.apache.lucene.store.LockObtainFailedException;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.PrintStream;
-
-/**
- * <p>[Note that as of <b>2.1</b>, all but one of the
- * methods in this class are available via {@link
- * IndexWriter}.  The one method that is not available is
- * {@link #deleteDocument(int)}.]</p>
- *
- * A class to modify an index, i.e. to delete and add documents. This
- * class hides {@link IndexReader} and {@link IndexWriter} so that you
- * do not need to care about implementation details such as that adding
- * documents is done via IndexWriter and deletion is done via IndexReader.
- * 
- * <p>Note that you cannot create more than one <code>IndexModifier</code> object
- * on the same directory at the same time.
- * 
- * <p>Example usage:
- * 
-<!-- ======================================================== -->
-<!-- = Java Sourcecode to HTML automatically converted code = -->
-<!-- =   Java2Html Converter V4.1 2004 by Markus Gebhard  markus@jave.de   = -->
-<!-- =     Further information: http://www.java2html.de     = -->
-<div align="left" class="java">
-<table border="0" cellpadding="3" cellspacing="0" bgcolor="#ffffff">
-   <tr>
-  <!-- start source code -->
-   <td nowrap="nowrap" valign="top" align="left">
-    <code>
-<font color="#ffffff">&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#000000">Analyzer&nbsp;analyzer&nbsp;=&nbsp;</font><font color="#7f0055"><b>new&nbsp;</b></font><font color="#000000">StandardAnalyzer</font><font color="#000000">()</font><font color="#000000">;</font><br/>
-<font color="#ffffff">&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#3f7f5f">//&nbsp;create&nbsp;an&nbsp;index&nbsp;in&nbsp;/tmp/index,&nbsp;overwriting&nbsp;an&nbsp;existing&nbsp;one:</font><br/>
-<font color="#ffffff">&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#000000">IndexModifier&nbsp;indexModifier&nbsp;=&nbsp;</font><font color="#7f0055"><b>new&nbsp;</b></font><font color="#000000">IndexModifier</font><font color="#000000">(</font><font color="#2a00ff">&#34;/tmp/index&#34;</font><font color="#000000">,&nbsp;analyzer,&nbsp;</font><font color="#7f0055"><b>true</b></font><font color="#000000">)</font><font color="#000000">;</font><br/>
-<font color="#ffffff">&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#000000">Document&nbsp;doc&nbsp;=&nbsp;</font><font color="#7f0055"><b>new&nbsp;</b></font><font color="#000000">Document</font><font color="#000000">()</font><font color="#000000">;</font><br/>
-<font color="#ffffff">&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#000000">doc.add</font><font color="#000000">(</font><font color="#7f0055"><b>new&nbsp;</b></font><font color="#000000">Field</font><font color="#000000">(</font><font color="#2a00ff">&#34;id&#34;</font><font color="#000000">,&nbsp;</font><font color="#2a00ff">&#34;1&#34;</font><font color="#000000">,&nbsp;Field.Store.YES,&nbsp;Field.Index.NOT_ANALYZED</font><font color="#000000">))</font><font color="#000000">;</font><br/>
-<font color="#ffffff">&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#000000">doc.add</font><font color="#000000">(</font><font color="#7f0055"><b>new&nbsp;</b></font><font color="#000000">Field</font><font color="#000000">(</font><font color="#2a00ff">&#34;body&#34;</font><font color="#000000">,&nbsp;</font><font color="#2a00ff">&#34;a&nbsp;simple&nbsp;test&#34;</font><font color="#000000">,&nbsp;Field.Store.YES,&nbsp;Field.Index.ANALYZED</font><font color="#000000">))</font><font color="#000000">;</font><br/>
-<font color="#ffffff">&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#000000">indexModifier.addDocument</font><font color="#000000">(</font><font color="#000000">doc</font><font color="#000000">)</font><font color="#000000">;</font><br/>
-<font color="#ffffff">&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#7f0055"><b>int&nbsp;</b></font><font color="#000000">deleted&nbsp;=&nbsp;indexModifier.delete</font><font color="#000000">(</font><font color="#7f0055"><b>new&nbsp;</b></font><font color="#000000">Term</font><font color="#000000">(</font><font color="#2a00ff">&#34;id&#34;</font><font color="#000000">,&nbsp;</font><font color="#2a00ff">&#34;1&#34;</font><font color="#000000">))</font><font color="#000000">;</font><br/>
-<font color="#ffffff">&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#000000">System.out.println</font><font color="#000000">(</font><font color="#2a00ff">&#34;Deleted&nbsp;&#34;&nbsp;</font><font color="#000000">+&nbsp;deleted&nbsp;+&nbsp;</font><font color="#2a00ff">&#34;&nbsp;document&#34;</font><font color="#000000">)</font><font color="#000000">;</font><br/>
-<font color="#ffffff">&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#000000">indexModifier.flush</font><font color="#000000">()</font><font color="#000000">;</font><br/>
-<font color="#ffffff">&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#000000">System.out.println</font><font color="#000000">(</font><font color="#000000">indexModifier.docCount</font><font color="#000000">()&nbsp;</font><font color="#000000">+&nbsp;</font><font color="#2a00ff">&#34;&nbsp;docs&nbsp;in&nbsp;index&#34;</font><font color="#000000">)</font><font color="#000000">;</font><br/>
-<font color="#ffffff">&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#000000">indexModifier.close</font><font color="#000000">()</font><font color="#000000">;</font></code>
-
-   </td>
-  <!-- end source code -->
-   </tr>
-</table>
-</div>
-<!-- =       END of automatically generated HTML code       = -->
-<!-- ======================================================== -->
- *
- * <p>Not all methods of IndexReader and IndexWriter are offered by this
- * class. If you need access to additional methods, either use those classes
- * directly or implement your own class that extends <code>IndexModifier</code>.
- *
- * <p>Although an instance of this class can be used from more than one
- * thread, you will not get the best performance. You might want to use
- * IndexReader and IndexWriter directly for that (but you will need to
- * care about synchronization yourself then).
- *
- * <p>While you can freely mix calls to add() and delete() using this class,
- * you should batch you calls for best performance. For example, if you
- * want to update 20 documents, you should first delete all those documents,
- * then add all the new documents.
- *
- * @deprecated Please use {@link IndexWriter} instead.
- */
-public class IndexModifier {
-
-  protected IndexWriter indexWriter = null;
-  protected IndexReader indexReader = null;
-
-  protected Directory directory = null;
-  protected Analyzer analyzer = null;
-  protected boolean open = false, closeDir = false;
-
-  // Lucene defaults:
-  protected PrintStream infoStream = null;
-  protected boolean useCompoundFile = true;
-  protected int maxBufferedDocs = IndexWriter.DEFAULT_MAX_BUFFERED_DOCS;
-  protected int maxFieldLength = IndexWriter.DEFAULT_MAX_FIELD_LENGTH;
-  protected int mergeFactor = IndexWriter.DEFAULT_MERGE_FACTOR;
-
-  /**
-   * Open an index with write access.
-   *
-   * @param directory the index directory
-   * @param analyzer the analyzer to use for adding new documents
-   * @param create <code>true</code> to create the index or overwrite the existing one;
-   * 	<code>false</code> to append to the existing index
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  public IndexModifier(Directory directory, Analyzer analyzer, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(directory, analyzer, create);
-  }
-
-  /**
-   * Open an index with write access.
-   *
-   * @param dirName the index directory
-   * @param analyzer the analyzer to use for adding new documents
-   * @param create <code>true</code> to create the index or overwrite the existing one;
-   * 	<code>false</code> to append to the existing index
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  public IndexModifier(String dirName, Analyzer analyzer, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException {
-    Directory dir = FSDirectory.getDirectory(dirName);
-    this.closeDir = true;
-    init(dir, analyzer, create);
-  }
-
-  /**
-   * Open an index with write access.
-   *
-   * @param file the index directory
-   * @param analyzer the analyzer to use for adding new documents
-   * @param create <code>true</code> to create the index or overwrite the existing one;
-   * 	<code>false</code> to append to the existing index
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  public IndexModifier(File file, Analyzer analyzer, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException {
-    Directory dir = FSDirectory.getDirectory(file);
-    this.closeDir = true;
-    init(dir, analyzer, create);
-  }
-
-  /**
-   * Initialize an IndexWriter.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  protected void init(Directory directory, Analyzer analyzer, boolean create) throws CorruptIndexException, LockObtainFailedException, IOException {
-    this.directory = directory;
-    synchronized(this.directory) {
-      this.analyzer = analyzer;
-      indexWriter = new IndexWriter(directory, analyzer, create, IndexWriter.MaxFieldLength.LIMITED);
-      open = true;
-    }
-  }
-
-  /**
-   * Throw an IllegalStateException if the index is closed.
-   * @throws IllegalStateException
-   */
-  protected void assureOpen() {
-    if (!open) {
-      throw new IllegalStateException("Index is closed");
-    }
-  }
-
-  /**
-   * Close the IndexReader and open an IndexWriter.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  protected void createIndexWriter() throws CorruptIndexException, LockObtainFailedException, IOException {
-    if (indexWriter == null) {
-      if (indexReader != null) {
-        indexReader.close();
-        indexReader = null;
-      }
-      indexWriter = new IndexWriter(directory, analyzer, false, new IndexWriter.MaxFieldLength(maxFieldLength));
-      // IndexModifier cannot use ConcurrentMergeScheduler
-      // because it synchronizes on the directory which can
-      // cause deadlock
-      indexWriter.setMergeScheduler(new SerialMergeScheduler());
-      indexWriter.setInfoStream(infoStream);
-      indexWriter.setUseCompoundFile(useCompoundFile);
-      if (maxBufferedDocs != IndexWriter.DISABLE_AUTO_FLUSH)
-        indexWriter.setMaxBufferedDocs(maxBufferedDocs);
-      indexWriter.setMergeFactor(mergeFactor);
-    }
-  }
-
-  /**
-   * Close the IndexWriter and open an IndexReader.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   */
-  protected void createIndexReader() throws CorruptIndexException, IOException {
-    if (indexReader == null) {
-      if (indexWriter != null) {
-        indexWriter.close();
-        indexWriter = null;
-      }
-      indexReader = IndexReader.open(directory);
-    }
-  }
-
-  /**
-   * Make sure all changes are written to disk.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  public void flush() throws CorruptIndexException, LockObtainFailedException, IOException {
-    synchronized(directory) {
-      assureOpen();
-      if (indexWriter != null) {
-        indexWriter.close();
-        indexWriter = null;
-        createIndexWriter();
-      } else {
-        indexReader.close();
-        indexReader = null;
-        createIndexReader();
-      }
-    }
-  }
-
-  /**
-   * Adds a document to this index, using the provided analyzer instead of the
-   * one specific in the constructor.  If the document contains more than
-   * {@link #setMaxFieldLength(int)} terms for a given field, the remainder are
-   * discarded.
-   * @see IndexWriter#addDocument(Document, Analyzer)
-   * @throws IllegalStateException if the index is closed
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  public void addDocument(Document doc, Analyzer docAnalyzer) throws CorruptIndexException, LockObtainFailedException, IOException {
-    synchronized(directory) {
-      assureOpen();
-      createIndexWriter();
-      if (docAnalyzer != null)
-        indexWriter.addDocument(doc, docAnalyzer);
-      else
-        indexWriter.addDocument(doc);
-    }
-  }
-
-  /**
-   * Adds a document to this index.  If the document contains more than
-   * {@link #setMaxFieldLength(int)} terms for a given field, the remainder are
-   * discarded.
-   * @see IndexWriter#addDocument(Document)
-   * @throws IllegalStateException if the index is closed
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  public void addDocument(Document doc) throws CorruptIndexException, LockObtainFailedException, IOException {
-    addDocument(doc, null);
-  }
-
-  /**
-   * Deletes all documents containing <code>term</code>.
-   * This is useful if one uses a document field to hold a unique ID string for
-   * the document.  Then to delete such a document, one merely constructs a
-   * term with the appropriate field and the unique ID string as its text and
-   * passes it to this method.  Returns the number of documents deleted.
-   * @return the number of documents deleted
-   * @see IndexReader#deleteDocuments(Term)
-   * @throws IllegalStateException if the index is closed
-   * @throws StaleReaderException if the index has changed
-   *  since this reader was opened
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  public int deleteDocuments(Term term) throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
-    synchronized(directory) {
-      assureOpen();
-      createIndexReader();
-      return indexReader.deleteDocuments(term);
-    }
-  }
-
-  /**
-   * Deletes the document numbered <code>docNum</code>.
-   * @see IndexReader#deleteDocument(int)
-   * @throws StaleReaderException if the index has changed
-   *  since this reader was opened
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IllegalStateException if the index is closed
-   */
-  public void deleteDocument(int docNum) throws StaleReaderException, CorruptIndexException, LockObtainFailedException, IOException {
-    synchronized(directory) {
-      assureOpen();
-      createIndexReader();
-      indexReader.deleteDocument(docNum);
-    }
-  }
-
-
-  /**
-   * Returns the number of documents currently in this
-   * index.  If the writer is currently open, this returns
-   * {@link IndexWriter#docCount()}, else {@link
-   * IndexReader#numDocs()}.  But, note that {@link
-   * IndexWriter#docCount()} does not take deletions into
-   * account, unlike {@link IndexReader#numDocs}.
-   * @throws IllegalStateException if the index is closed
-   */
-  public int docCount() {
-    synchronized(directory) {
-      assureOpen();
-      if (indexWriter != null) {
-        return indexWriter.docCount();
-      } else {
-        return indexReader.numDocs();
-      }
-    }
-  }
-
-  /**
-   * Merges all segments together into a single segment, optimizing an index
-   * for search.
-   * @see IndexWriter#optimize()
-   * @throws IllegalStateException if the index is closed
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  public void optimize() throws CorruptIndexException, LockObtainFailedException, IOException {
-    synchronized(directory) {
-      assureOpen();
-      createIndexWriter();
-      indexWriter.optimize();
-    }
-  }
-
-  /**
-   * If non-null, information about merges and a message when
-   * {@link #getMaxFieldLength()} is reached will be printed to this.
-   * <p>Example: <tt>index.setInfoStream(System.err);</tt>
-   * @see IndexWriter#setInfoStream(PrintStream)
-   * @throws IllegalStateException if the index is closed
-   */
-  public void setInfoStream(PrintStream infoStream) {
-    synchronized(directory) {
-      assureOpen();
-      if (indexWriter != null) {
-        indexWriter.setInfoStream(infoStream);
-      }
-      this.infoStream = infoStream;
-    }
-  }
-
-  /**
-   * @see IndexModifier#setInfoStream(PrintStream)
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  public PrintStream getInfoStream() throws CorruptIndexException, LockObtainFailedException, IOException {
-    synchronized(directory) {
-      assureOpen();
-      createIndexWriter();
-      return indexWriter.getInfoStream();
-    }
-  }
-
-  /**
-   * Setting to turn on usage of a compound file. When on, multiple files
-   * for each segment are merged into a single file once the segment creation
-   * is finished. This is done regardless of what directory is in use.
-   * @see IndexWriter#setUseCompoundFile(boolean)
-   * @throws IllegalStateException if the index is closed
-   */
-  public void setUseCompoundFile(boolean useCompoundFile) {
-    synchronized(directory) {
-      assureOpen();
-      if (indexWriter != null) {
-        indexWriter.setUseCompoundFile(useCompoundFile);
-      }
-      this.useCompoundFile = useCompoundFile;
-    }
-  }
-
-  /**
-   * @see IndexModifier#setUseCompoundFile(boolean)
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  public boolean getUseCompoundFile() throws CorruptIndexException, LockObtainFailedException, IOException {
-    synchronized(directory) {
-      assureOpen();
-      createIndexWriter();
-      return indexWriter.getUseCompoundFile();
-    }
-  }
-
-  /**
-   * The maximum number of terms that will be indexed for a single field in a
-   * document.  This limits the amount of memory required for indexing, so that
-   * collections with very large files will not crash the indexing process by
-   * running out of memory.<p/>
-   * Note that this effectively truncates large documents, excluding from the
-   * index terms that occur further in the document.  If you know your source
-   * documents are large, be sure to set this value high enough to accommodate
-   * the expected size.  If you set it to Integer.MAX_VALUE, then the only limit
-   * is your memory, but you should anticipate an OutOfMemoryError.<p/>
-   * By default, no more than 10,000 terms will be indexed for a field.
-   * @see IndexWriter#setMaxFieldLength(int)
-   * @throws IllegalStateException if the index is closed
-   */
-  public void setMaxFieldLength(int maxFieldLength) {
-    synchronized(directory) {
-      assureOpen();
-      if (indexWriter != null) {
-        indexWriter.setMaxFieldLength(maxFieldLength);
-      }
-      this.maxFieldLength = maxFieldLength;
-    }
-  }
-
-  /**
-   * @see IndexModifier#setMaxFieldLength(int)
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  public int getMaxFieldLength() throws CorruptIndexException, LockObtainFailedException, IOException {
-    synchronized(directory) {
-      assureOpen();
-      createIndexWriter();
-      return indexWriter.getMaxFieldLength();
-    }
-  }
-
-  /**
-   * Determines the minimal number of documents required before the buffered
-   * in-memory documents are merging and a new Segment is created.
-   * Since Documents are merged in a {@link org.apache.lucene.store.RAMDirectory},
-   * large value gives faster indexing.  At the same time, mergeFactor limits
-   * the number of files open in a FSDirectory.
-   *
-   * <p>The default value is 10.
-   *
-   * @see IndexWriter#setMaxBufferedDocs(int)
-   * @throws IllegalStateException if the index is closed
-   * @throws IllegalArgumentException if maxBufferedDocs is smaller than 2
-   */
-  public void setMaxBufferedDocs(int maxBufferedDocs) {
-    synchronized(directory) {
-      assureOpen();
-      if (indexWriter != null) {
-        indexWriter.setMaxBufferedDocs(maxBufferedDocs);
-      }
-      this.maxBufferedDocs = maxBufferedDocs;
-    }
-  }
-
-  /**
-   * @see IndexModifier#setMaxBufferedDocs(int)
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  public int getMaxBufferedDocs() throws CorruptIndexException, LockObtainFailedException, IOException {
-    synchronized(directory) {
-      assureOpen();
-      createIndexWriter();
-      return indexWriter.getMaxBufferedDocs();
-    }
-  }
-
-  /**
-   * Determines how often segment indices are merged by addDocument().  With
-   * smaller values, less RAM is used while indexing, and searches on
-   * unoptimized indices are faster, but indexing speed is slower.  With larger
-   * values, more RAM is used during indexing, and while searches on unoptimized
-   * indices are slower, indexing is faster.  Thus larger values (&gt; 10) are best
-   * for batch index creation, and smaller values (&lt; 10) for indices that are
-   * interactively maintained.
-   * <p>This must never be less than 2.  The default value is 10.
-   *
-   * @see IndexWriter#setMergeFactor(int)
-   * @throws IllegalStateException if the index is closed
-   */
-  public void setMergeFactor(int mergeFactor) {
-    synchronized(directory) {
-      assureOpen();
-      if (indexWriter != null) {
-        indexWriter.setMergeFactor(mergeFactor);
-      }
-      this.mergeFactor = mergeFactor;
-    }
-  }
-
-  /**
-   * @see IndexModifier#setMergeFactor(int)
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if there is a low-level IO error
-   */
-  public int getMergeFactor() throws CorruptIndexException, LockObtainFailedException, IOException {
-    synchronized(directory) {
-      assureOpen();
-      createIndexWriter();
-      return indexWriter.getMergeFactor();
-    }
-  }
-
-  /**
-   * Close this index, writing all pending changes to disk.
-   *
-   * @throws IllegalStateException if the index has been closed before already
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   */
-  public void close() throws CorruptIndexException, IOException {
-    synchronized(directory) {
-      if (!open)
-        throw new IllegalStateException("Index is closed already");
-      if (indexWriter != null) {
-        indexWriter.close();
-        indexWriter = null;
-      } else if (indexReader != null) {
-        indexReader.close();
-        indexReader = null;
-      }
-      open = false;
-      if (closeDir) {
-        directory.close();
-      }
-      closeDir = false;
-    }
-  }
-
-  public String toString() {
-    return "Index@" + directory;
-  }
-
-  /*
-  // used as an example in the javadoc:
-  public static void main(String[] args) throws IOException {
-    Analyzer analyzer = new StandardAnalyzer();
-    // create an index in /tmp/index, overwriting an existing one:
-    IndexModifier indexModifier = new IndexModifier("/tmp/index", analyzer, true);
-    Document doc = new Document();
-    doc.add(new Fieldable("id", "1", Fieldable.Store.YES, Fieldable.Index.NOT_ANALYZED));
-    doc.add(new Fieldable("body", "a simple test", Fieldable.Store.YES, Fieldable.Index.ANALYZED));
-    indexModifier.addDocument(doc);
-    int deleted = indexModifier.delete(new Term("id", "1"));
-    System.out.println("Deleted " + deleted + " document");
-    indexModifier.flush();
-    System.out.println(indexModifier.docCount() + " docs in index");
-    indexModifier.close();
-  }*/
-  
-}
Index: src/java/org/apache/lucene/index/IndexReader.java
===================================================================
--- src/java/org/apache/lucene/index/IndexReader.java	(revision 821345)
+++ src/java/org/apache/lucene/index/IndexReader.java	(working copy)
@@ -100,8 +100,6 @@
     public static final FieldOption STORES_PAYLOADS = new FieldOption ("STORES_PAYLOADS");
     /** All fields that omit tf */
     public static final FieldOption OMIT_TERM_FREQ_AND_POSITIONS = new FieldOption ("OMIT_TERM_FREQ_AND_POSITIONS");
-    /** @deprecated Renamed to {@link #OMIT_TERM_FREQ_AND_POSITIONS} */
-    public static final FieldOption OMIT_TF = OMIT_TERM_FREQ_AND_POSITIONS;
     /** All fields which are not indexed */
     public static final FieldOption UNINDEXED = new FieldOption ("UNINDEXED");
     /** All fields which are indexed with termvectors enabled */
@@ -172,31 +170,6 @@
     refCount--;
   }
   
-  /** 
-   * @deprecated will be deleted when IndexReader(Directory) is deleted
-   * @see #directory()
-   */
-  private Directory directory;
-
-  /**
-   * Legacy Constructor for backwards compatibility.
-   *
-   * <p>
-   * This Constructor should not be used, it exists for backwards 
-   * compatibility only to support legacy subclasses that did not "own" 
-   * a specific directory, but needed to specify something to be returned 
-   * by the directory() method.  Future subclasses should delegate to the 
-   * no arg constructor and implement the directory() method as appropriate.
-   * 
-   * @param directory Directory to be returned by the directory() method
-   * @see #directory()
-   * @deprecated - use IndexReader()
-   */
-  protected IndexReader(Directory directory) {
-    this();
-    this.directory = directory;
-  }
-  
   protected IndexReader() { 
     refCount = 1;
   }
@@ -210,96 +183,6 @@
     }
   }
   
-  /** Returns a read/write IndexReader reading the index in an FSDirectory in the named
-   *  path.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   * @deprecated Use {@link #open(Directory, boolean)} instead. 
-   *             This method will be removed in the 3.0 release.
-   * 
-   * @param path the path to the index directory */
-  public static IndexReader open(String path) throws CorruptIndexException, IOException {
-    return open(path, false);
-  }
-
-  /** Returns an IndexReader reading the index in an
-   *  FSDirectory in the named path.  You should pass
-   *  readOnly=true, since it gives much better concurrent
-   *  performance, unless you intend to do write operations
-   *  (delete documents or change norms) with the reader.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   * @param path the path to the index directory
-   * @param readOnly true if this should be a readOnly
-   * reader
-   * @deprecated Use {@link #open(Directory, boolean)} instead.
-   *             This method will be removed in the 3.0 release.
-   * 
-   */
-  public static IndexReader open(String path, boolean readOnly) throws CorruptIndexException, IOException {
-    final Directory dir = FSDirectory.getDirectory(path);
-    IndexReader r = null;
-    try {
-      r = open(dir, null, null, readOnly, DEFAULT_TERMS_INDEX_DIVISOR);
-    } finally {
-      if (r == null)
-        dir.close();
-    }
-    return new DirectoryOwningReader(r);
-  }
-
-  /** Returns a read/write IndexReader reading the index in an FSDirectory in the named
-   *  path.
-   * @param path the path to the index directory
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   * @deprecated Use {@link #open(Directory, boolean)} instead.
-   *             This method will be removed in the 3.0 release.
-   * 
-   */
-  public static IndexReader open(File path) throws CorruptIndexException, IOException {
-    return open(path, false);
-  }
-
-  /** Returns an IndexReader reading the index in an
-   *  FSDirectory in the named path.  You should pass
-   *  readOnly=true, since it gives much better concurrent
-   *  performance, unless you intend to do write operations
-   *  (delete documents or change norms) with the reader.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   * @param path the path to the index directory
-   * @param readOnly true if this should be a readOnly
-   * reader
-   * @deprecated Use {@link #open(Directory, boolean)} instead.
-   *             This method will be removed in the 3.0 release.
-   * 
-   */
-  public static IndexReader open(File path, boolean readOnly) throws CorruptIndexException, IOException {
-    final Directory dir = FSDirectory.getDirectory(path);
-    IndexReader r = null;
-    try {
-      r = open(dir, null, null, readOnly, DEFAULT_TERMS_INDEX_DIVISOR);
-    } finally {
-      if (r == null)
-        dir.close();
-    }
-    return new DirectoryOwningReader(r);
-  }
-
-  /** Returns a read/write IndexReader reading the index in
-   *  the given Directory.
-   * @param directory the index directory
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   * @deprecated Use {@link #open(Directory, boolean)} instead
-   *             This method will be removed in the 3.0 release.
-   * 
-   */
-  public static IndexReader open(final Directory directory) throws CorruptIndexException, IOException {
-    return open(directory, null, null, false, DEFAULT_TERMS_INDEX_DIVISOR);
-  }
-
   /** Returns an IndexReader reading the index in the given
    *  Directory.  You should pass readOnly=true, since it
    *  gives much better concurrent performance, unless you
@@ -314,19 +197,6 @@
     return open(directory, null, null, readOnly, DEFAULT_TERMS_INDEX_DIVISOR);
   }
 
-  /** Expert: returns a read/write IndexReader reading the index in the given
-   * {@link IndexCommit}.
-   * @param commit the commit point to open
-   * @throws CorruptIndexException if the index is corrupt
-   * @deprecated Use {@link #open(IndexCommit, boolean)} instead.
-   *             This method will be removed in the 3.0 release.
-   * 
-   * @throws IOException if there is a low-level IO error
-   */
-  public static IndexReader open(final IndexCommit commit) throws CorruptIndexException, IOException {
-    return open(commit.getDirectory(), null, commit, false, DEFAULT_TERMS_INDEX_DIVISOR);
-  }
-
   /** Expert: returns an IndexReader reading the index in the given
    *  {@link IndexCommit}.  You should pass readOnly=true, since it
    *  gives much better concurrent performance, unless you
@@ -341,22 +211,6 @@
     return open(commit.getDirectory(), null, commit, readOnly, DEFAULT_TERMS_INDEX_DIVISOR);
   }
 
-  /** Expert: returns a read/write IndexReader reading the index in the given
-   *  Directory, with a custom {@link IndexDeletionPolicy}.
-   * @param directory the index directory
-   * @param deletionPolicy a custom deletion policy (only used
-   *  if you use this reader to perform deletes or to set
-   *  norms); see {@link IndexWriter} for details.
-   * @deprecated Use {@link #open(Directory, IndexDeletionPolicy, boolean)} instead.
-   *             This method will be removed in the 3.0 release.
-   * 
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   */
-  public static IndexReader open(final Directory directory, IndexDeletionPolicy deletionPolicy) throws CorruptIndexException, IOException {
-    return open(directory, deletionPolicy, null, false, DEFAULT_TERMS_INDEX_DIVISOR);
-  }
-
   /** Expert: returns an IndexReader reading the index in
    *  the given Directory, with a custom {@link
    *  IndexDeletionPolicy}.  You should pass readOnly=true,
@@ -403,25 +257,6 @@
     return open(directory, deletionPolicy, null, readOnly, termInfosIndexDivisor);
   }
 
-  /** Expert: returns a read/write IndexReader reading the index in the given
-   * Directory, using a specific commit and with a custom
-   * {@link IndexDeletionPolicy}.
-   * @param commit the specific {@link IndexCommit} to open;
-   * see {@link IndexReader#listCommits} to list all commits
-   * in a directory
-   * @param deletionPolicy a custom deletion policy (only used
-   *  if you use this reader to perform deletes or to set
-   *  norms); see {@link IndexWriter} for details.
-   * @deprecated Use {@link #open(IndexCommit, IndexDeletionPolicy, boolean)} instead.
-   *             This method will be removed in the 3.0 release.
-   * 
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   */
-  public static IndexReader open(final IndexCommit commit, IndexDeletionPolicy deletionPolicy) throws CorruptIndexException, IOException {
-    return open(commit.getDirectory(), deletionPolicy, commit, false, DEFAULT_TERMS_INDEX_DIVISOR);
-  }
-
   /** Expert: returns an IndexReader reading the index in
    *  the given Directory, using a specific commit and with
    *  a custom {@link IndexDeletionPolicy}.  You should pass
@@ -586,52 +421,16 @@
    */
   public Directory directory() {
     ensureOpen();
-    if (null != directory) {
-      return directory;
-    } else {
-      throw new UnsupportedOperationException("This reader does not support this method.");  
-    }
+    throw new UnsupportedOperationException("This reader does not support this method.");  
   }
 
   /**
-   * Returns the time the index in the named directory was last modified.
-   * Do not use this to check whether the reader is still up-to-date, use
-   * {@link #isCurrent()} instead. 
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   * @deprecated Use {@link #lastModified(Directory)} instead.
-   *             This method will be removed in the 3.0 release.
-   */
-  public static long lastModified(String directory) throws CorruptIndexException, IOException {
-    return lastModified(new File(directory));
-  }
-
-  /**
    * Returns the time the index in the named directory was last modified. 
    * Do not use this to check whether the reader is still up-to-date, use
    * {@link #isCurrent()} instead. 
    * @throws CorruptIndexException if the index is corrupt
    * @throws IOException if there is a low-level IO error
-   * @deprecated Use {@link #lastModified(Directory)} instead.
-   *             This method will be removed in the 3.0 release.
-   * 
    */
-  public static long lastModified(File fileDirectory) throws CorruptIndexException, IOException {
-    Directory dir = FSDirectory.getDirectory(fileDirectory); // use new static method here
-    try {
-      return lastModified(dir);
-    } finally {
-      dir.close();
-    }
-  }
-
-  /**
-   * Returns the time the index in the named directory was last modified. 
-   * Do not use this to check whether the reader is still up-to-date, use
-   * {@link #isCurrent()} instead. 
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   */
   public static long lastModified(final Directory directory2) throws CorruptIndexException, IOException {
     return ((Long) new SegmentInfos.FindSegmentsFile(directory2) {
         public Object doBody(String segmentFileName) throws IOException {
@@ -649,44 +448,7 @@
    * @return version number.
    * @throws CorruptIndexException if the index is corrupt
    * @throws IOException if there is a low-level IO error
-   * @deprecated Use {@link #getCurrentVersion(Directory)} instead.
-   *             This method will be removed in the 3.0 release.
    */
-  public static long getCurrentVersion(String directory) throws CorruptIndexException, IOException {
-    return getCurrentVersion(new File(directory));
-  }
-
-  /**
-   * Reads version number from segments files. The version number is
-   * initialized with a timestamp and then increased by one for each change of
-   * the index.
-   * 
-   * @param directory where the index resides.
-   * @return version number.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   * @deprecated Use {@link #getCurrentVersion(Directory)} instead.
-   *             This method will be removed in the 3.0 release.
-   */
-  public static long getCurrentVersion(File directory) throws CorruptIndexException, IOException {
-    Directory dir = FSDirectory.getDirectory(directory);
-    try {
-      return getCurrentVersion(dir);
-    } finally {
-      dir.close();
-    }
-  }
-
-  /**
-   * Reads version number from segments files. The version number is
-   * initialized with a timestamp and then increased by one for each change of
-   * the index.
-   * 
-   * @param directory where the index resides.
-   * @return version number.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   */
   public static long getCurrentVersion(Directory directory) throws CorruptIndexException, IOException {
     return SegmentInfos.readCurrentVersion(directory);
   }
@@ -850,36 +612,8 @@
   /**
    * Returns <code>true</code> if an index exists at the specified directory.
    * If the directory does not exist or if there is no index in it.
-   * <code>false</code> is returned.
    * @param  directory the directory to check for an index
    * @return <code>true</code> if an index exists; <code>false</code> otherwise
-   * @deprecated Use {@link #indexExists(Directory)} instead
-   *             This method will be removed in the 3.0 release.
-   * 
-   */
-  public static boolean indexExists(String directory) {
-    return indexExists(new File(directory));
-  }
-
-  /**
-   * Returns <code>true</code> if an index exists at the specified directory.
-   * If the directory does not exist or if there is no index in it.
-   * @param  directory the directory to check for an index
-   * @return <code>true</code> if an index exists; <code>false</code> otherwise
-   * @deprecated Use {@link #indexExists(Directory)} instead.
-   *             This method will be removed in the 3.0 release.
-   * 
-   */
-
-  public static boolean indexExists(File directory) {
-    return SegmentInfos.getCurrentSegmentGeneration(directory.list()) != -1;
-  }
-
-  /**
-   * Returns <code>true</code> if an index exists at the specified directory.
-   * If the directory does not exist or if there is no index in it.
-   * @param  directory the directory to check for an index
-   * @return <code>true</code> if an index exists; <code>false</code> otherwise
    * @throws IOException if there is a problem with accessing the index
    */
   public static boolean indexExists(Directory directory) throws IOException {
@@ -1289,52 +1023,6 @@
   public abstract Collection getFieldNames(FieldOption fldOption);
 
   /**
-   * Returns <code>true</code> iff the index in the named directory is
-   * currently locked.
-   * @param directory the directory to check for a lock
-   * @throws IOException if there is a low-level IO error
-   * @deprecated Please use {@link IndexWriter#isLocked(Directory)} instead.
-   *             This method will be removed in the 3.0 release.
-   * 
-   */
-  public static boolean isLocked(Directory directory) throws IOException {
-    return
-      directory.makeLock(IndexWriter.WRITE_LOCK_NAME).isLocked();
-  }
-
-  /**
-   * Returns <code>true</code> iff the index in the named directory is
-   * currently locked.
-   * @param directory the directory to check for a lock
-   * @throws IOException if there is a low-level IO error
-   * @deprecated Use {@link #isLocked(Directory)} instead.
-   *             This method will be removed in the 3.0 release.
-   * 
-   */
-  public static boolean isLocked(String directory) throws IOException {
-    Directory dir = FSDirectory.getDirectory(directory);
-    try {
-      return isLocked(dir);
-    } finally {
-      dir.close();
-    }
-  }
-
-  /**
-   * Forcibly unlocks the index in the named directory.
-   * <P>
-   * Caution: this should only be used by failure recovery code,
-   * when it is known that no other process nor thread is in fact
-   * currently accessing this index.
-   * @deprecated Please use {@link IndexWriter#unlock(Directory)} instead.
-   *             This method will be removed in the 3.0 release.
-   * 
-   */
-  public static void unlock(Directory directory) throws IOException {
-    directory.makeLock(IndexWriter.WRITE_LOCK_NAME).release();
-  }
-
-  /**
    * Expert: return the IndexCommit that this reader has
    * opened.  This method is only implemented by those
    * readers that correspond to a Directory with its own
@@ -1381,7 +1069,7 @@
       dir = FSDirectory.open(new File(dirname));
       cfr = new CompoundFileReader(dir, filename);
 
-      String [] files = cfr.list();
+      String [] files = cfr.listAll();
       Arrays.sort(files);   // sort the array of filename so that the output is more readable
 
       for (int i = 0; i < files.length; ++i) {
Index: src/java/org/apache/lucene/index/IndexWriter.java
===================================================================
--- src/java/org/apache/lucene/index/IndexWriter.java	(revision 821345)
+++ src/java/org/apache/lucene/index/IndexWriter.java	(working copy)
@@ -346,7 +346,6 @@
 
   private int termIndexInterval = DEFAULT_TERM_INDEX_INTERVAL;
 
-  private boolean closeDir;
   private boolean closed;
   private boolean closing;
 
@@ -913,131 +912,6 @@
   }
 
   /**
-   * Constructs an IndexWriter for the index in <code>path</code>.
-   * Text will be analyzed with <code>a</code>.  If <code>create</code>
-   * is true, then a new, empty index will be created in
-   * <code>path</code>, replacing the index already there,
-   * if any.
-   *
-   * <p><b>NOTE</b>: autoCommit (see <a
-   * href="#autoCommit">above</a>) is set to false with this
-   * constructor.
-   *
-   * @param path the path to the index directory
-   * @param a the analyzer to use
-   * @param create <code>true</code> to create the index or overwrite
-   *  the existing one; <code>false</code> to append to the existing
-   *  index
-   * @param mfl Maximum field length in number of tokens/terms: LIMITED, UNLIMITED, or user-specified
-   *   via the MaxFieldLength constructor.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if the directory cannot be read/written to, or
-   *  if it does not exist and <code>create</code> is
-   *  <code>false</code> or if there is any other low-level
-   *  IO error
-   * @deprecated Use {@link #IndexWriter(Directory, Analyzer,
-   * boolean, MaxFieldLength)}
-   */
-  public IndexWriter(String path, Analyzer a, boolean create, MaxFieldLength mfl)
-       throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(FSDirectory.getDirectory(path), a, create, true, null, false, mfl.getLimit(), null, null);
-  }
-
-  /**
-   * Constructs an IndexWriter for the index in <code>path</code>.
-   * Text will be analyzed with <code>a</code>.  If <code>create</code>
-   * is true, then a new, empty index will be created in
-   * <code>path</code>, replacing the index already there, if any.
-   *
-   * @param path the path to the index directory
-   * @param a the analyzer to use
-   * @param create <code>true</code> to create the index or overwrite
-   *  the existing one; <code>false</code> to append to the existing
-   *  index
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if the directory cannot be read/written to, or
-   *  if it does not exist and <code>create</code> is
-   *  <code>false</code> or if there is any other low-level
-   *  IO error
-   * @deprecated This constructor will be removed in the 3.0 release.
-   *  Use {@link
-   *  #IndexWriter(Directory,Analyzer,boolean,MaxFieldLength)}
-   *  instead, and call {@link #commit()} when needed.
-   */
-  public IndexWriter(String path, Analyzer a, boolean create)
-       throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(FSDirectory.getDirectory(path), a, create, true, null, true, DEFAULT_MAX_FIELD_LENGTH, null, null);
-  }
-
-  /**
-   * Constructs an IndexWriter for the index in <code>path</code>.
-   * Text will be analyzed with <code>a</code>.  If <code>create</code>
-   * is true, then a new, empty index will be created in
-   * <code>path</code>, replacing the index already there, if any.
-   *
-   * <p><b>NOTE</b>: autoCommit (see <a
-   * href="#autoCommit">above</a>) is set to false with this
-   * constructor.
-   *
-   * @param path the path to the index directory
-   * @param a the analyzer to use
-   * @param create <code>true</code> to create the index or overwrite
-   *  the existing one; <code>false</code> to append to the existing
-   *  index
-   * @param mfl Maximum field length in number of terms/tokens: LIMITED, UNLIMITED, or user-specified
-   *   via the MaxFieldLength constructor.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if the directory cannot be read/written to, or
-   *  if it does not exist and <code>create</code> is
-   *  <code>false</code> or if there is any other low-level
-   *  IO error
-   * @deprecated Use {@link #IndexWriter(Directory,
-   * Analyzer, boolean, MaxFieldLength)}
-   */
-  public IndexWriter(File path, Analyzer a, boolean create, MaxFieldLength mfl)
-       throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(FSDirectory.getDirectory(path), a, create, true, null, false, mfl.getLimit(), null, null);
-  }
-
-  /**
-   * Constructs an IndexWriter for the index in <code>path</code>.
-   * Text will be analyzed with <code>a</code>.  If <code>create</code>
-   * is true, then a new, empty index will be created in
-   * <code>path</code>, replacing the index already there, if any.
-   *
-   * @param path the path to the index directory
-   * @param a the analyzer to use
-   * @param create <code>true</code> to create the index or overwrite
-   *  the existing one; <code>false</code> to append to the existing
-   *  index
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if the directory cannot be read/written to, or
-   *  if it does not exist and <code>create</code> is
-   *  <code>false</code> or if there is any other low-level
-   *  IO error
-   * @deprecated This constructor will be removed in the 3.0 release.
-   *  Use {@link
-   *  #IndexWriter(Directory,Analyzer,boolean,MaxFieldLength)}
-   *  instead, and call {@link #commit()} when needed.
-   */
-  public IndexWriter(File path, Analyzer a, boolean create)
-       throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(FSDirectory.getDirectory(path), a, create, true, null, true, DEFAULT_MAX_FIELD_LENGTH, null, null);
-  }
-
-  /**
    * Constructs an IndexWriter for the index in <code>d</code>.
    * Text will be analyzed with <code>a</code>.  If <code>create</code>
    * is true, then a new, empty index will be created in
@@ -1065,7 +939,7 @@
    */
   public IndexWriter(Directory d, Analyzer a, boolean create, MaxFieldLength mfl)
        throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(d, a, create, false, null, false, mfl.getLimit(), null, null);
+    init(d, a, create, null, false, mfl.getLimit(), null, null);
   }
 
   /**
@@ -1093,116 +967,11 @@
    */
   public IndexWriter(Directory d, Analyzer a, boolean create)
        throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(d, a, create, false, null, true, DEFAULT_MAX_FIELD_LENGTH, null, null);
+    init(d, a, create, null, true, DEFAULT_MAX_FIELD_LENGTH, null, null);
   }
 
   /**
    * Constructs an IndexWriter for the index in
-   * <code>path</code>, first creating it if it does not
-   * already exist.  Text will be analyzed with
-   * <code>a</code>.
-   *
-   * <p><b>NOTE</b>: autoCommit (see <a
-   * href="#autoCommit">above</a>) is set to false with this
-   * constructor.
-   *
-   * @param path the path to the index directory
-   * @param a the analyzer to use
-   * @param mfl Maximum field length in number of terms/tokens: LIMITED, UNLIMITED, or user-specified
-   *   via the MaxFieldLength constructor.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if the directory cannot be
-   *  read/written to or if there is any other low-level
-   *  IO error
-   * @deprecated Use {@link #IndexWriter(Directory, Analyzer, MaxFieldLength)}
-   */
-  public IndexWriter(String path, Analyzer a, MaxFieldLength mfl)
-    throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(FSDirectory.getDirectory(path), a, true, null, false, mfl.getLimit(), null, null);
-  }
-
-  /**
-   * Constructs an IndexWriter for the index in
-   * <code>path</code>, first creating it if it does not
-   * already exist.  Text will be analyzed with
-   * <code>a</code>.
-   *
-   * @param path the path to the index directory
-   * @param a the analyzer to use
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if the directory cannot be
-   *  read/written to or if there is any other low-level
-   *  IO error
-   * @deprecated This constructor will be removed in the 3.0
-   *  release, and call {@link #commit()} when needed.
-   *  Use {@link #IndexWriter(Directory,Analyzer,MaxFieldLength)} instead.
-   */
-  public IndexWriter(String path, Analyzer a)
-    throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(FSDirectory.getDirectory(path), a, true, null, true, DEFAULT_MAX_FIELD_LENGTH, null, null);
-  }
-
-  /**
-   * Constructs an IndexWriter for the index in
-   * <code>path</code>, first creating it if it does not
-   * already exist.  Text will be analyzed with
-   * <code>a</code>.
-   *
-   * <p><b>NOTE</b>: autoCommit (see <a
-   * href="#autoCommit">above</a>) is set to false with this
-   * constructor.
-   *
-   * @param path the path to the index directory
-   * @param a the analyzer to use
-   * @param mfl Maximum field length in number of terms/tokens: LIMITED, UNLIMITED, or user-specified
-   *   via the MaxFieldLength constructor.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if the directory cannot be
-   *  read/written to or if there is any other low-level
-   *  IO error
-   * @deprecated Use {@link #IndexWriter(Directory,
-   * Analyzer, MaxFieldLength)}
-   */
-  public IndexWriter(File path, Analyzer a, MaxFieldLength mfl)
-    throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(FSDirectory.getDirectory(path), a, true, null, false, mfl.getLimit(), null, null);
-  }
-
-  /**
-   * Constructs an IndexWriter for the index in
-   * <code>path</code>, first creating it if it does not
-   * already exist.  Text will be analyzed with
-   * <code>a</code>.
-   *
-   * @param path the path to the index directory
-   * @param a the analyzer to use
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws LockObtainFailedException if another writer
-   *  has this index open (<code>write.lock</code> could not
-   *  be obtained)
-   * @throws IOException if the directory cannot be
-   *  read/written to or if there is any other low-level
-   *  IO error
-   * @deprecated This constructor will be removed in the 3.0 release.
-   *  Use {@link #IndexWriter(Directory,Analyzer,MaxFieldLength)}
-   *  instead, and call {@link #commit()} when needed.
-   */
-  public IndexWriter(File path, Analyzer a)
-    throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(FSDirectory.getDirectory(path), a, true, null, true, DEFAULT_MAX_FIELD_LENGTH, null, null);
-  }
-
-  /**
-   * Constructs an IndexWriter for the index in
    * <code>d</code>, first creating it if it does not
    * already exist.  Text will be analyzed with
    * <code>a</code>.
@@ -1225,7 +994,7 @@
    */
   public IndexWriter(Directory d, Analyzer a, MaxFieldLength mfl)
     throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(d, a, false, null, false, mfl.getLimit(), null, null);
+    init(d, a, null, false, mfl.getLimit(), null, null);
   }
 
   /**
@@ -1250,7 +1019,7 @@
    */
   public IndexWriter(Directory d, Analyzer a)
     throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(d, a, false, null, true, DEFAULT_MAX_FIELD_LENGTH, null, null);
+    init(d, a, null, true, DEFAULT_MAX_FIELD_LENGTH, null, null);
   }
 
   /**
@@ -1276,7 +1045,7 @@
    */
   public IndexWriter(Directory d, boolean autoCommit, Analyzer a)
     throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(d, a, false, null, autoCommit, DEFAULT_MAX_FIELD_LENGTH, null, null);
+    init(d, a, null, autoCommit, DEFAULT_MAX_FIELD_LENGTH, null, null);
   }
 
   /**
@@ -1306,7 +1075,7 @@
    */
   public IndexWriter(Directory d, boolean autoCommit, Analyzer a, boolean create)
        throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(d, a, create, false, null, autoCommit, DEFAULT_MAX_FIELD_LENGTH, null, null);
+    init(d, a, create, null, autoCommit, DEFAULT_MAX_FIELD_LENGTH, null, null);
   }
 
   /**
@@ -1333,7 +1102,7 @@
    */
   public IndexWriter(Directory d, Analyzer a, IndexDeletionPolicy deletionPolicy, MaxFieldLength mfl)
     throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(d, a, false, deletionPolicy, false, mfl.getLimit(), null, null);
+    init(d, a, deletionPolicy, false, mfl.getLimit(), null, null);
   }
 
   /**
@@ -1360,7 +1129,7 @@
    */
   public IndexWriter(Directory d, boolean autoCommit, Analyzer a, IndexDeletionPolicy deletionPolicy)
     throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(d, a, false, deletionPolicy, autoCommit, DEFAULT_MAX_FIELD_LENGTH, null, null);
+    init(d, a, deletionPolicy, autoCommit, DEFAULT_MAX_FIELD_LENGTH, null, null);
   }
   
   /**
@@ -1393,7 +1162,7 @@
    */
   public IndexWriter(Directory d, Analyzer a, boolean create, IndexDeletionPolicy deletionPolicy, MaxFieldLength mfl)
        throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(d, a, create, false, deletionPolicy, false, mfl.getLimit(), null, null);
+    init(d, a, create, deletionPolicy, false, mfl.getLimit(), null, null);
   }
   
   /**
@@ -1430,7 +1199,7 @@
    */
   IndexWriter(Directory d, Analyzer a, boolean create, IndexDeletionPolicy deletionPolicy, MaxFieldLength mfl, IndexingChain indexingChain, IndexCommit commit)
        throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(d, a, create, false, deletionPolicy, false, mfl.getLimit(), indexingChain, commit);
+    init(d, a, create, deletionPolicy, false, mfl.getLimit(), indexingChain, commit);
   }
   
   /**
@@ -1463,7 +1232,7 @@
    */
   public IndexWriter(Directory d, boolean autoCommit, Analyzer a, boolean create, IndexDeletionPolicy deletionPolicy)
           throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(d, a, create, false, deletionPolicy, autoCommit, DEFAULT_MAX_FIELD_LENGTH, null, null);
+    init(d, a, create, deletionPolicy, autoCommit, DEFAULT_MAX_FIELD_LENGTH, null, null);
   }
 
   /**
@@ -1504,24 +1273,23 @@
    */
   public IndexWriter(Directory d, Analyzer a, IndexDeletionPolicy deletionPolicy, MaxFieldLength mfl, IndexCommit commit)
        throws CorruptIndexException, LockObtainFailedException, IOException {
-    init(d, a, false, false, deletionPolicy, false, mfl.getLimit(), null, commit);
+    init(d, a, false, deletionPolicy, false, mfl.getLimit(), null, commit);
   }
 
-  private void init(Directory d, Analyzer a, boolean closeDir, IndexDeletionPolicy deletionPolicy, 
+  private void init(Directory d, Analyzer a, IndexDeletionPolicy deletionPolicy, 
                     boolean autoCommit, int maxFieldLength, IndexingChain indexingChain, IndexCommit commit)
     throws CorruptIndexException, LockObtainFailedException, IOException {
     if (IndexReader.indexExists(d)) {
-      init(d, a, false, closeDir, deletionPolicy, autoCommit, maxFieldLength, indexingChain, commit);
+      init(d, a, false, deletionPolicy, autoCommit, maxFieldLength, indexingChain, commit);
     } else {
-      init(d, a, true, closeDir, deletionPolicy, autoCommit, maxFieldLength, indexingChain, commit);
+      init(d, a, true, deletionPolicy, autoCommit, maxFieldLength, indexingChain, commit);
     }
   }
 
-  private void init(Directory d, Analyzer a, final boolean create, boolean closeDir, 
+  private void init(Directory d, Analyzer a, final boolean create,  
                     IndexDeletionPolicy deletionPolicy, boolean autoCommit, int maxFieldLength,
                     IndexingChain indexingChain, IndexCommit commit)
     throws CorruptIndexException, LockObtainFailedException, IOException {
-    this.closeDir = closeDir;
     directory = d;
     analyzer = a;
     setMessageID(defaultInfoStream);
@@ -2201,9 +1969,6 @@
         deleter.close();
       }
       
-      if (closeDir)
-        directory.close();
-
       if (writeLock != null) {
         writeLock.release();                          // release write lock
         writeLock = null;
@@ -5544,22 +5309,6 @@
   }
 
   /**
-   * Returns <code>true</code> iff the index in the named directory is
-   * currently locked.
-   * @param directory the directory to check for a lock
-   * @throws IOException if there is a low-level IO error
-   * @deprecated Use {@link #isLocked(Directory)}
-   */
-  public static boolean isLocked(String directory) throws IOException {
-    Directory dir = FSDirectory.getDirectory(directory);
-    try {
-      return isLocked(dir);
-    } finally {
-      dir.close();
-    }
-  }
-
-  /**
    * Forcibly unlocks the index in the named directory.
    * <P>
    * Caution: this should only be used by failure recovery code,
Index: src/java/org/apache/lucene/index/SegmentInfo.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentInfo.java	(revision 821345)
+++ src/java/org/apache/lucene/index/SegmentInfo.java	(working copy)
@@ -375,16 +375,18 @@
         // This means this segment was saved with pre-LOCKLESS
         // code.  So we must fallback to the original
         // directory list check:
-        String[] result = dir.list();
+        String[] result = dir.listAll();
         if (result == null)
-          throw new IOException("cannot read directory " + dir + ": list() returned null");
-        
+          throw new IOException("cannot read directory " + dir + ": listAll() returned null");
+
+        final IndexFileNameFilter filter = IndexFileNameFilter.getFilter();
         String pattern;
         pattern = name + ".s";
         int patternLength = pattern.length();
         for(int i = 0; i < result.length; i++){
-          if(result[i].startsWith(pattern) && Character.isDigit(result[i].charAt(patternLength)))
-            return true;
+          String fileName = result[i];
+          if (filter.accept(null, fileName) && fileName.startsWith(pattern) && Character.isDigit(fileName.charAt(patternLength)))
+              return true;
         }
         return false;
       }
Index: src/java/org/apache/lucene/index/SegmentReader.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentReader.java	(revision 821345)
+++ src/java/org/apache/lucene/index/SegmentReader.java	(working copy)
@@ -1335,9 +1335,11 @@
    * Lotsa tests did hacks like:<br/>
    * SegmentReader reader = (SegmentReader) IndexReader.open(dir);<br/>
    * They broke. This method serves as a hack to keep hacks working
+   * We do it with R/W access for the tests (BW compatibility)
+   * @deprecated Remove this when tests are fixed!
    */
   static SegmentReader getOnlySegmentReader(Directory dir) throws IOException {
-    return getOnlySegmentReader(IndexReader.open(dir));
+    return getOnlySegmentReader(IndexReader.open(dir,false));
   }
 
   static SegmentReader getOnlySegmentReader(IndexReader reader) {
Index: src/java/org/apache/lucene/search/IndexSearcher.java
===================================================================
--- src/java/org/apache/lucene/search/IndexSearcher.java	(revision 821345)
+++ src/java/org/apache/lucene/search/IndexSearcher.java	(working copy)
@@ -56,47 +56,13 @@
   protected IndexReader[] subReaders;
   protected int[] docStarts;
 
-  /** Creates a searcher searching the index in the named directory.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   * @deprecated Use {@link #IndexSearcher(Directory, boolean)} instead
-   */
-  public IndexSearcher(String path) throws CorruptIndexException, IOException {
-    this(IndexReader.open(path), true);
-  }
-
   /** Creates a searcher searching the index in the named
    *  directory.  You should pass readOnly=true, since it
    *  gives much better concurrent performance, unless you
    *  intend to do write operations (delete documents or
    *  change norms) with the underlying IndexReader.
-   * @param path directory where IndexReader will be opened
-   * @param readOnly if true, the underlying IndexReader
-   * will be opened readOnly
    * @throws CorruptIndexException if the index is corrupt
    * @throws IOException if there is a low-level IO error
-   * @deprecated Use {@link #IndexSearcher(Directory, boolean)} instead
-   */
-  public IndexSearcher(String path, boolean readOnly) throws CorruptIndexException, IOException {
-    this(IndexReader.open(path, readOnly), true);
-  }
-
-  /** Creates a searcher searching the index in the provided directory.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   * @deprecated Use {@link #IndexSearcher(Directory, boolean)} instead
-   */
-  public IndexSearcher(Directory directory) throws CorruptIndexException, IOException {
-    this(IndexReader.open(directory), true);
-  }
-
-  /** Creates a searcher searching the index in the named
-   *  directory.  You should pass readOnly=true, since it
-   *  gives much better concurrent performance, unless you
-   *  intend to do write operations (delete documents or
-   *  change norms) with the underlying IndexReader.
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
    * @param path directory where IndexReader will be opened
    * @param readOnly if true, the underlying IndexReader
    * will be opened readOnly
Index: src/java/org/apache/lucene/store/Directory.java
===================================================================
--- src/java/org/apache/lucene/store/Directory.java	(revision 821345)
+++ src/java/org/apache/lucene/store/Directory.java	(working copy)
@@ -45,30 +45,12 @@
    * this Directory instance). */
   protected LockFactory lockFactory;
 
-  /** List the files in the directory.
-   * 
-   *  @deprecated For some Directory implementations ({@link
-   *  FSDirectory}, and its subclasses), this method
-   *  silently filters its results to include only index
-   *  files.  Please use {@link #listAll} instead, which
-   *  does no filtering. */
-  public abstract String[] list()
-       throws IOException;
-
   /** Returns an array of strings, one for each file in the
    *  directory.  Unlike {@link #list} this method does no
    *  filtering of the contents in a directory, and it will
    *  never return null (throws IOException instead).
-   *
-   *  Currently this method simply falls back to {@link
-   *  #list} for Directory impls outside of Lucene's core &
-   *  contrib, but in 3.0 that method will be removed and
-   *  this method will become abstract. */
-  public String[] listAll()
-    throws IOException
-  {
-    return list();
-  }
+   */
+  public abstract String[] listAll() throws IOException;
 
   /** Returns true iff a file with the given name exists. */
   public abstract boolean fileExists(String name)
@@ -86,14 +68,6 @@
   public abstract void deleteFile(String name)
        throws IOException;
 
-  /** Renames an existing file in the directory.
-   * If a file already exists with the new name, then it is replaced.
-   * This replacement is not guaranteed to be atomic.
-   * @deprecated 
-   */
-  public abstract void renameFile(String from, String to)
-       throws IOException;
-
   /** Returns the length of a file in the directory. */
   public abstract long fileLength(String name)
        throws IOException;
@@ -101,7 +75,8 @@
 
   /** Creates a new, empty file in the directory with the given name.
       Returns a stream writing this file. */
-  public abstract IndexOutput createOutput(String name) throws IOException;
+  public abstract IndexOutput createOutput(String name)
+       throws IOException;
 
   /** Ensure that any writes to this file are moved to
    *  stable storage.  Lucene uses this to properly commit
@@ -156,8 +131,9 @@
    * @param lockFactory instance of {@link LockFactory}.
    */
   public void setLockFactory(LockFactory lockFactory) {
-      this.lockFactory = lockFactory;
-      lockFactory.setLockPrefix(this.getLockID());
+    assert lockFactory != null;
+    this.lockFactory = lockFactory;
+    lockFactory.setLockPrefix(this.getLockID());
   }
 
   /**
Index: src/java/org/apache/lucene/store/FileSwitchDirectory.java
===================================================================
--- src/java/org/apache/lucene/store/FileSwitchDirectory.java	(revision 821345)
+++ src/java/org/apache/lucene/store/FileSwitchDirectory.java	(working copy)
@@ -79,10 +79,6 @@
     System.arraycopy(secondaryFiles, 0, files, primaryFiles.length, secondaryFiles.length);
     return files;
   }
-  
-  public String[] list() throws IOException {
-    return listAll();
-  }
 
   /** Utility method to return a file's extension. */
   public static String getExtension(String name) {
@@ -118,10 +114,6 @@
     getDirectory(name).deleteFile(name);
   }
 
-  public void renameFile(String from, String to) throws IOException {
-    getDirectory(from).renameFile(from, to);
-  }
-
   public long fileLength(String name) throws IOException {
     return getDirectory(name).fileLength(name);
   }
Index: src/java/org/apache/lucene/store/FSDirectory.java
===================================================================
--- src/java/org/apache/lucene/store/FSDirectory.java	(revision 821345)
+++ src/java/org/apache/lucene/store/FSDirectory.java	(working copy)
@@ -28,12 +28,8 @@
 import java.util.HashMap;
 import java.util.Map;
 
-import org.apache.lucene.index.IndexFileNameFilter;
 import org.apache.lucene.util.Constants;
 
-// Used only for WRITE_LOCK_NAME in deprecated create=true case:
-import org.apache.lucene.index.IndexWriter;
-
 /**
  * <a name="subclasses"/>
  * Base class for Directory implementations that store index
@@ -97,105 +93,11 @@
  * <p>The locking implementation is by default {@link
  * NativeFSLockFactory}, but can be changed by
  * passing in a custom {@link LockFactory} instance.
- * The deprecated <code>getDirectory</code> methods default to use
- * {@link SimpleFSLockFactory} for backwards compatibility.
- * The system properties 
- * <code>org.apache.lucene.store.FSDirectoryLockFactoryClass</code>
- * and <code>org.apache.lucene.FSDirectory.class</code>
- * are deprecated and only used by the deprecated
- * <code>getDirectory</code> methods. The system property
- * <code>org.apache.lucene.lockDir</code> is ignored completely,
- * If you really want to store locks
- * elsewhere, you can create your own {@link
- * SimpleFSLockFactory} (or {@link NativeFSLockFactory},
- * etc.) passing in your preferred lock directory.
  *
- * <p><em>In 3.0 this class will become abstract.</em>
- *
  * @see Directory
  */
-// TODO: in 3.0 this will become an abstract base class
-public class FSDirectory extends Directory {
-    
-  /** This cache of directories ensures that there is a unique Directory
-   * instance per path, so that synchronization on the Directory can be used to
-   * synchronize access between readers and writers.  We use
-   * refcounts to ensure when the last use of an FSDirectory
-   * instance for a given canonical path is closed, we remove the
-   * instance from the cache.  See LUCENE-776
-   * for some relevant discussion.
-   * @deprecated Not used by any non-deprecated methods anymore
-   */
-  private static final Map DIRECTORIES = new HashMap();
+public abstract class FSDirectory extends Directory {
 
-  private static boolean disableLocks = false;
-
-  // TODO: should this move up to the Directory base class?  Also: should we
-  // make a per-instance (in addition to the static "default") version?
-
-  /**
-   * Set whether Lucene's use of lock files is disabled. By default, 
-   * lock files are enabled. They should only be disabled if the index
-   * is on a read-only medium like a CD-ROM.
-   * @deprecated Use a {@link #open(File, LockFactory)} or a constructor
-   * that takes a {@link LockFactory} and supply
-   * {@link NoLockFactory#getNoLockFactory}. This setting does not work
-   * with {@link #open(File)} only the deprecated <code>getDirectory</code>
-   * respect this setting.   
-   */
-  public static void setDisableLocks(boolean doDisableLocks) {
-    FSDirectory.disableLocks = doDisableLocks;
-  }
-
-  /**
-   * Returns whether Lucene's use of lock files is disabled.
-   * @return true if locks are disabled, false if locks are enabled.
-   * @see #setDisableLocks
-   * @deprecated Use a constructor that takes a {@link LockFactory} and
-   * supply {@link NoLockFactory#getNoLockFactory}.
-  */
-  public static boolean getDisableLocks() {
-    return FSDirectory.disableLocks;
-  }
-
-  /**
-   * Directory specified by <code>org.apache.lucene.lockDir</code>
-   * or <code>java.io.tmpdir</code> system property.
-
-   * @deprecated As of 2.1, <code>LOCK_DIR</code> is unused
-   * because the write.lock is now stored by default in the
-   * index directory.  If you really want to store locks
-   * elsewhere, you can create your own {@link
-   * SimpleFSLockFactory} (or {@link NativeFSLockFactory},
-   * etc.) passing in your preferred lock directory.  Then,
-   * pass this <code>LockFactory</code> instance to one of
-   * the <code>open</code> methods that take a
-   * <code>lockFactory</code> (for example, {@link #open(File, LockFactory)}).
-   */
-  public static final String LOCK_DIR = System.getProperty("org.apache.lucene.lockDir",
-                                                           System.getProperty("java.io.tmpdir"));
-
-  /** The default class which implements filesystem-based directories. */
-  // deprecated
-  private static Class IMPL;
-  static {
-    try {
-      String name =
-        System.getProperty("org.apache.lucene.FSDirectory.class",
-                           SimpleFSDirectory.class.getName());
-      if (FSDirectory.class.getName().equals(name)) {
-        // FSDirectory will be abstract, so we replace it by the correct class
-        IMPL = SimpleFSDirectory.class;
-      } else {
-        IMPL = Class.forName(name);
-      }
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException("cannot load FSDirectory class: " + e.toString(), e);
-    } catch (SecurityException se) {
-      IMPL = SimpleFSDirectory.class;
-    }
-  }
-
   private static MessageDigest DIGESTER;
 
   static {
@@ -206,135 +108,6 @@
     }
   }
 
-  /** A buffer optionally used in renameTo method */
-  private byte[] buffer = null;
-
-
-  /** Returns the directory instance for the named location.
-   *
-   * @deprecated Use {@link #open(File)}
-   *
-   * @param path the path to the directory.
-   * @return the FSDirectory for the named file.  */
-  public static FSDirectory getDirectory(String path)
-      throws IOException {
-    return getDirectory(new File(path), null);
-  }
-
-  /** Returns the directory instance for the named location.
-   *
-   * @deprecated Use {@link #open(File, LockFactory)}
-   *
-   * @param path the path to the directory.
-   * @param lockFactory instance of {@link LockFactory} providing the
-   *        locking implementation.
-   * @return the FSDirectory for the named file.  */
-  public static FSDirectory getDirectory(String path, LockFactory lockFactory)
-      throws IOException {
-    return getDirectory(new File(path), lockFactory);
-  }
-
-  /** Returns the directory instance for the named location.
-   *
-   * @deprecated Use {@link #open(File)}
-   *
-   * @param file the path to the directory.
-   * @return the FSDirectory for the named file.  */
-  public static FSDirectory getDirectory(File file)
-    throws IOException {
-    return getDirectory(file, null);
-  }
-
-  /** Returns the directory instance for the named location.
-   *
-   * @deprecated Use {@link #open(File, LockFactory)}
-   *
-   * @param file the path to the directory.
-   * @param lockFactory instance of {@link LockFactory} providing the
-   *        locking implementation.
-   * @return the FSDirectory for the named file.  */
-  public static FSDirectory getDirectory(File file, LockFactory lockFactory)
-    throws IOException
-  {
-    file = getCanonicalPath(file);
-
-    FSDirectory dir;
-    synchronized (DIRECTORIES) {
-      dir = (FSDirectory)DIRECTORIES.get(file);
-      if (dir == null) {
-        try {
-          dir = (FSDirectory)IMPL.newInstance();
-        } catch (Exception e) {
-          throw new RuntimeException("cannot load FSDirectory class: " + e.toString(), e);
-        }
-        dir.init(file, lockFactory);
-        DIRECTORIES.put(file, dir);
-      } else {
-        // Catch the case where a Directory is pulled from the cache, but has a
-        // different LockFactory instance.
-        if (lockFactory != null && lockFactory != dir.getLockFactory()) {
-          throw new IOException("Directory was previously created with a different LockFactory instance; please pass null as the lockFactory instance and use setLockFactory to change it");
-        }
-        dir.checked = false;
-      }
-    }
-    synchronized (dir) {
-      dir.refCount++;
-    }
-    return dir;
-  }
-
-
-  /** Returns the directory instance for the named location.
-   *
-   * @deprecated Use IndexWriter's create flag, instead, to
-   * create a new index.
-   *
-   * @param path the path to the directory.
-   * @param create if true, create, or erase any existing contents.
-   * @return the FSDirectory for the named file.  */
-  public static FSDirectory getDirectory(String path, boolean create)
-      throws IOException {
-    return getDirectory(new File(path), create);
-  }
-
-  /** Returns the directory instance for the named location.
-   *
-   * @deprecated Use IndexWriter's create flag, instead, to
-   * create a new index.
-   *
-   * @param file the path to the directory.
-   * @param create if true, create, or erase any existing contents.
-   * @return the FSDirectory for the named file.  */
-  public static FSDirectory getDirectory(File file, boolean create)
-    throws IOException
-  {
-    FSDirectory dir = getDirectory(file, null);
-
-    // This is now deprecated (creation should only be done
-    // by IndexWriter):
-    if (create) {
-      dir.create();
-    }
-
-    return dir;
-  }
-
-  /** @deprecated */
-  private void create() throws IOException {
-    if (directory.exists()) {
-      String[] files = directory.list(IndexFileNameFilter.getFilter());            // clear old files
-      if (files == null)
-        throw new IOException("cannot read directory " + directory.getAbsolutePath() + ": list() returned null");
-      for (int i = 0; i < files.length; i++) {
-        File file = new File(directory, files[i]);
-        if (!file.delete())
-          throw new IOException("Cannot delete " + file);
-      }
-    }
-    lockFactory.clearLock(IndexWriter.WRITE_LOCK_NAME);
-  }
-
   // returns the canonical version of the directory, creating it if it doesn't exist.
   private static File getCanonicalPath(File file) throws IOException {
     return new File(file.getCanonicalPath());
@@ -365,12 +138,6 @@
   /** The underlying filesystem directory */
   protected File directory = null;
   
-  /** @deprecated */
-  private int refCount = 0;
-
-  /** @deprecated */
-  protected FSDirectory() {}; // permit subclassing
-
   /** Create a new FSDirectory for the named location (ctor for subclasses).
    * @param path the path of the directory
    * @param lockFactory the lock factory to use, or null for the default
@@ -383,8 +150,26 @@
     if (lockFactory == null) {
       lockFactory = new NativeFSLockFactory();
     }
-    init(path, lockFactory);
-    refCount = 1;
+    directory = path;
+
+    if (directory.exists() && !directory.isDirectory())
+      throw new NoSuchDirectoryException("file '" + directory + "' exists but is not a directory");
+
+    setLockFactory(lockFactory);
+    
+    // for filesystem based LockFactory, delete the lockPrefix, if the locks are placed
+    // in index dir. If no index dir is given, set ourselves
+    if (lockFactory instanceof FSLockFactory) {
+      final FSLockFactory lf = (FSLockFactory) lockFactory;
+      final File dir = lf.getLockDir();
+      // if the lock factory has no lockDir set, use the this directory as lockDir
+      if (dir == null) {
+        lf.setLockDir(this.directory);
+        lf.setLockPrefix(null);
+      } else if (dir.getCanonicalPath().equals(this.directory.getCanonicalPath())) {
+        lf.setLockPrefix(null);
+      }
+    }
   }
 
   /** Creates an FSDirectory instance, trying to pick the
@@ -427,70 +212,6 @@
     }
   }
 
-  /* will move to ctor, when reflection is removed in 3.0 */
-  private void init(File path, LockFactory lockFactory) throws IOException {
-
-    // Set up lockFactory with cascaded defaults: if an instance was passed in,
-    // use that; else if locks are disabled, use NoLockFactory; else if the
-    // system property org.apache.lucene.store.FSDirectoryLockFactoryClass is set,
-    // instantiate that; else, use SimpleFSLockFactory:
-
-    directory = path;
-
-    if (directory.exists() && !directory.isDirectory())
-      throw new NoSuchDirectoryException("file '" + directory + "' exists but is not a directory");
-
-    if (lockFactory == null) {
-
-      if (disableLocks) {
-        // Locks are disabled:
-        lockFactory = NoLockFactory.getNoLockFactory();
-      } else {
-        String lockClassName = System.getProperty("org.apache.lucene.store.FSDirectoryLockFactoryClass");
-
-        if (lockClassName != null && !lockClassName.equals("")) {
-          Class c;
-
-          try {
-            c = Class.forName(lockClassName);
-          } catch (ClassNotFoundException e) {
-            throw new IOException("unable to find LockClass " + lockClassName);
-          }
-
-          try {
-            lockFactory = (LockFactory) c.newInstance();          
-          } catch (IllegalAccessException e) {
-            throw new IOException("IllegalAccessException when instantiating LockClass " + lockClassName);
-          } catch (InstantiationException e) {
-            throw new IOException("InstantiationException when instantiating LockClass " + lockClassName);
-          } catch (ClassCastException e) {
-            throw new IOException("unable to cast LockClass " + lockClassName + " instance to a LockFactory");
-          }
-        } else {
-          // Our default lock is SimpleFSLockFactory;
-          // default lockDir is our index directory:
-          lockFactory = new SimpleFSLockFactory();
-        }
-      }
-    }
-
-    setLockFactory(lockFactory);
-    
-    // for filesystem based LockFactory, delete the lockPrefix, if the locks are placed
-    // in index dir. If no index dir is given, set ourselves
-    if (lockFactory instanceof FSLockFactory) {
-      final FSLockFactory lf = (FSLockFactory) lockFactory;
-      final File dir = lf.getLockDir();
-      // if the lock factory has no lockDir set, use the this directory as lockDir
-      if (dir == null) {
-        lf.setLockDir(this.directory);
-        lf.setLockPrefix(null);
-      } else if (dir.getCanonicalPath().equals(this.directory.getCanonicalPath())) {
-        lf.setLockPrefix(null);
-      }
-    }
-  }
-
   /** Lists all files (not subdirectories) in the
    *  directory.  This method never returns null (throws
    *  {@link IOException} instead).
@@ -518,11 +239,6 @@
     return result;
   }
 
-  public String[] list() {
-    ensureOpen();
-    return directory.list(IndexFileNameFilter.getFilter());
-  }
-
   /** Lists all files (not subdirectories) in the
    * directory.
    * @see #listAll(File) */
@@ -573,81 +289,6 @@
       throw new IOException("Cannot delete " + file);
   }
 
-  /** Renames an existing file in the directory. 
-   * Warning: This is not atomic.
-   * @deprecated 
-   */
-  public synchronized void renameFile(String from, String to)
-      throws IOException {
-    ensureOpen();
-    File old = new File(directory, from);
-    File nu = new File(directory, to);
-
-    /* This is not atomic.  If the program crashes between the call to
-       delete() and the call to renameTo() then we're screwed, but I've
-       been unable to figure out how else to do this... */
-
-    if (nu.exists())
-      if (!nu.delete())
-        throw new IOException("Cannot delete " + nu);
-
-    // Rename the old file to the new one. Unfortunately, the renameTo()
-    // method does not work reliably under some JVMs.  Therefore, if the
-    // rename fails, we manually rename by copying the old file to the new one
-    if (!old.renameTo(nu)) {
-      java.io.InputStream in = null;
-      java.io.OutputStream out = null;
-      try {
-        in = new FileInputStream(old);
-        out = new FileOutputStream(nu);
-        // see if the buffer needs to be initialized. Initialization is
-        // only done on-demand since many VM's will never run into the renameTo
-        // bug and hence shouldn't waste 1K of mem for no reason.
-        if (buffer == null) {
-          buffer = new byte[1024];
-        }
-        int len;
-        while ((len = in.read(buffer)) >= 0) {
-          out.write(buffer, 0, len);
-        }
-
-        // delete the old file.
-        old.delete();
-      }
-      catch (IOException ioe) {
-        IOException newExc = new IOException("Cannot rename " + old + " to " + nu);
-        newExc.initCause(ioe);
-        throw newExc;
-      }
-      finally {
-        try {
-          if (in != null) {
-            try {
-              in.close();
-            } catch (IOException e) {
-              throw new RuntimeException("Cannot close input stream: " + e.toString(), e);
-            }
-          }
-        } finally {
-          if (out != null) {
-            try {
-              out.close();
-            } catch (IOException e) {
-              throw new RuntimeException("Cannot close output stream: " + e.toString(), e);
-            }
-          }
-        }
-      }
-    }
-  }
-
-  /** Creates an IndexOutput for the file with the given name.
-   * <em>In 3.0 this method will become abstract.</em> */
-  public IndexOutput createOutput(String name) throws IOException {
-    initOutput(name);
-    return new FSIndexOutput(new File(directory, name));
-  }
-
   public void sync(String name) throws IOException {
     ensureOpen();
     File fullFile = new File(directory, name);
@@ -691,13 +332,6 @@
     return openInput(name, BufferedIndexInput.BUFFER_SIZE);
   }
 
-  /** Creates an IndexInput for the file with the given name.
-   * <em>In 3.0 this method will become abstract.</em> */
-  public IndexInput openInput(String name, int bufferSize) throws IOException {
-    ensureOpen();
-    return new FSIndexInput(new File(directory, name), bufferSize);
-  }
-
   /**
    * So we can do some byte-to-hexchar conversion below
    */
@@ -731,12 +365,7 @@
 
   /** Closes the store to future operations. */
   public synchronized void close() {
-    if (isOpen && --refCount <= 0) {
-      isOpen = false;
-      synchronized (DIRECTORIES) {
-        DIRECTORIES.remove(directory);
-      }
-    }
+    isOpen = false;
   }
 
   public File getFile() {
@@ -802,37 +431,4 @@
     return chunkSize;
   }
 
-
-  /** @deprecated Use SimpleFSDirectory.SimpleFSIndexInput instead */
-  protected static class FSIndexInput extends SimpleFSDirectory.SimpleFSIndexInput {
-  
-    /** @deprecated */
-    protected static class Descriptor extends SimpleFSDirectory.SimpleFSIndexInput.Descriptor {
-      /** @deprecated */
-      public Descriptor(File file, String mode) throws IOException {
-        super(file, mode);
-      }
-    }
-  
-    /** @deprecated */
-    public FSIndexInput(File path) throws IOException {
-      super(path);
-    }
-  
-    /** @deprecated */
-    public FSIndexInput(File path, int bufferSize) throws IOException {
-      super(path, bufferSize);
-    }
-  
-  }
-
-  /** @deprecated Use SimpleFSDirectory.SimpleFSIndexOutput instead */
-  protected static class FSIndexOutput extends SimpleFSDirectory.SimpleFSIndexOutput {
-
-    /** @deprecated */
-    public FSIndexOutput(File path) throws IOException {
-      super(path);
-    }
-
-  }
 }
Index: src/java/org/apache/lucene/store/MMapDirectory.java
===================================================================
--- src/java/org/apache/lucene/store/MMapDirectory.java	(revision 821345)
+++ src/java/org/apache/lucene/store/MMapDirectory.java	(working copy)
@@ -91,10 +91,6 @@
     super(path, null);
   }
 
-  // back compatibility so FSDirectory can instantiate via reflection
-  /** @deprecated */
-  MMapDirectory() {}
-  
   static final Class[] NO_PARAM_TYPES = new Class[0];
   static final Object[] NO_PARAMS = new Object[0];
   
Index: src/java/org/apache/lucene/store/NIOFSDirectory.java
===================================================================
--- src/java/org/apache/lucene/store/NIOFSDirectory.java	(revision 821345)
+++ src/java/org/apache/lucene/store/NIOFSDirectory.java	(working copy)
@@ -60,10 +60,6 @@
     super(path, null);
   }
 
-  // back compatibility so FSDirectory can instantiate via reflection
-  /** @deprecated */
-  NIOFSDirectory() {}
-
   /** Creates an IndexInput for the file with the given name. */
   public IndexInput openInput(String name, int bufferSize) throws IOException {
     ensureOpen();
@@ -85,11 +81,6 @@
 
     final FileChannel channel;
 
-    /** @deprecated Please use ctor taking chunkSize */
-    public NIOFSIndexInput(File path, int bufferSize) throws IOException {
-      this(path, bufferSize, FSDirectory.DEFAULT_READ_CHUNK_SIZE);
-    }
-    
     public NIOFSIndexInput(File path, int bufferSize, int chunkSize) throws IOException {
       super(path, bufferSize, chunkSize);
       channel = file.getChannel();
Index: src/java/org/apache/lucene/store/RAMDirectory.java
===================================================================
--- src/java/org/apache/lucene/store/RAMDirectory.java	(revision 821345)
+++ src/java/org/apache/lucene/store/RAMDirectory.java	(working copy)
@@ -73,34 +73,6 @@
     Directory.copy(dir, this, closeDir);
   }
 
-  /**
-   * Creates a new <code>RAMDirectory</code> instance from the {@link FSDirectory}.
-   *
-   * @param dir a <code>File</code> specifying the index directory
-   *
-   * @see #RAMDirectory(Directory)
-   * @deprecated Use {@link #RAMDirectory(Directory)} instead
-   */
-  public RAMDirectory(File dir) throws IOException {
-    this(FSDirectory.getDirectory(dir), true);
-  }
-
-  /**
-   * Creates a new <code>RAMDirectory</code> instance from the {@link FSDirectory}.
-   *
-   * @param dir a <code>String</code> specifying the full index directory path
-   *
-   * @see #RAMDirectory(Directory)
-   * @deprecated Use {@link #RAMDirectory(Directory)} instead
-   */
-  public RAMDirectory(String dir) throws IOException {
-    this(FSDirectory.getDirectory(dir), true);
-  }
-
-  public synchronized final String[] list() {
-    return listAll();
-  }
-
   public synchronized final String[] listAll() {
     ensureOpen();
     Set fileNames = fileMap.keySet();
@@ -200,24 +172,6 @@
       throw new FileNotFoundException(name);
   }
 
-  /** Renames an existing file in the directory.
-   * @throws FileNotFoundException if from does not exist
-   * @deprecated
-   */
-  public synchronized final void renameFile(String from, String to) throws IOException {
-    ensureOpen();
-    RAMFile fromFile = (RAMFile)fileMap.get(from);
-    if (fromFile==null)
-      throw new FileNotFoundException(from);
-    RAMFile toFile = (RAMFile)fileMap.get(to);
-    if (toFile!=null) {
-      sizeInBytes -= toFile.sizeInBytes;       // updates to RAMFile.sizeInBytes synchronized on directory
-      toFile.directory = null;
-    }
-    fileMap.remove(from);
-    fileMap.put(to, fromFile);
-  }
-
   /** Creates a new, empty file in the directory with the given name. Returns a stream writing this file. */
   public IndexOutput createOutput(String name) throws IOException {
     ensureOpen();
Index: src/java/org/apache/lucene/store/SimpleFSDirectory.java
===================================================================
--- src/java/org/apache/lucene/store/SimpleFSDirectory.java	(revision 821345)
+++ src/java/org/apache/lucene/store/SimpleFSDirectory.java	(working copy)
@@ -49,10 +49,6 @@
     super(path, null);
   }
 
-  // back compatibility so FSDirectory can instantiate via reflection
-  /** @deprecated */
-  SimpleFSDirectory() {}
-
   /** Creates an IndexOutput for the file with the given name. */
   public IndexOutput createOutput(String name) throws IOException {
     initOutput(name);
@@ -92,16 +88,6 @@
     boolean isClone;
     //  LUCENE-1566 - maximum read length on a 32bit JVM to prevent incorrect OOM 
     protected final int chunkSize;
-
-    /** @deprecated Please use ctor taking chunkSize */
-    public SimpleFSIndexInput(File path) throws IOException {
-      this(path, BufferedIndexInput.BUFFER_SIZE, SimpleFSDirectory.DEFAULT_READ_CHUNK_SIZE);
-    }
-  
-    /** @deprecated Please use ctor taking chunkSize */
-    public SimpleFSIndexInput(File path, int bufferSize) throws IOException {
-      this(path, bufferSize, SimpleFSDirectory.DEFAULT_READ_CHUNK_SIZE);
-    }
     
     public SimpleFSIndexInput(File path, int bufferSize, int chunkSize) throws IOException {
       super(bufferSize);
