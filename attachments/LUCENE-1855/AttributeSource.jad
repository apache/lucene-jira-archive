// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   AttributeSource.java

package org.apache.lucene.util;

import java.util.*;

// Referenced classes of package org.apache.lucene.util:
//            Attribute, AttributeImpl

public class AttributeSource
{
    public static final class State
        implements Cloneable
    {

        public Object clone()
        {
            State clone = new State();
            clone.attribute = (AttributeImpl)attribute.clone();
            if(next != null)
                clone.next = (State)next.clone();
            return clone;
        }

        private AttributeImpl attribute;
        private State next;





        public State()
        {
        }
    }

    public static abstract class AttributeFactory
    {
        private static final class DefaultAttributeFactory extends AttributeFactory
        {

            public AttributeImpl createAttributeInstance(Class attClass)
            {
                try
                {
                    return (AttributeImpl)getClassForInterface(attClass).newInstance();
                }
                catch(InstantiationException e)
                {
                    throw new IllegalArgumentException((new StringBuilder()).append("Could not instantiate class ").append(attClass).toString());
                }
                catch(IllegalAccessException e)
                {
                    throw new IllegalArgumentException((new StringBuilder()).append("Could not instantiate class ").append(attClass).toString());
                }
            }

            private static Class getClassForInterface(Class attClass)
            {
                IdentityHashMap identityhashmap = attClassImplMap;
                JVM INSTR monitorenter ;
                Class clazz = (Class)attClassImplMap.get(attClass);
                if(clazz == null)
                    try
                    {
                        attClassImplMap.put(attClass, clazz = Class.forName((new StringBuilder()).append(attClass.getName()).append("Impl").toString()).asSubclass(org/apache/lucene/util/AttributeImpl));
                    }
                    catch(ClassNotFoundException e)
                    {
                        throw new IllegalArgumentException((new StringBuilder()).append("Could not find implementing class for ").append(attClass.getName()).toString());
                    }
                return clazz;
                Exception exception;
                exception;
                throw exception;
            }

            private static final IdentityHashMap attClassImplMap = new IdentityHashMap();


            private DefaultAttributeFactory()
            {
            }

        }


        public abstract AttributeImpl createAttributeInstance(Class class1);

        public static final AttributeFactory DEFAULT_ATTRIBUTE_FACTORY = new DefaultAttributeFactory();


        public AttributeFactory()
        {
        }
    }


    public AttributeSource()
    {
        this(AttributeFactory.DEFAULT_ATTRIBUTE_FACTORY);
    }

    public AttributeSource(AttributeSource input)
    {
        currentState = null;
        if(input == null)
        {
            throw new IllegalArgumentException("input AttributeSource must not be null");
        } else
        {
            attributes = input.attributes;
            attributeImpls = input.attributeImpls;
            factory = input.factory;
            return;
        }
    }

    public AttributeSource(AttributeFactory factory)
    {
        currentState = null;
        attributes = new LinkedHashMap();
        attributeImpls = new LinkedHashMap();
        this.factory = factory;
    }

    public AttributeFactory getAttributeFactory()
    {
        return factory;
    }

    public Iterator getAttributeClassesIterator()
    {
        return Collections.unmodifiableSet(attributes.keySet()).iterator();
    }

    public Iterator getAttributeImplsIterator()
    {
        if(hasAttributes())
        {
            if(currentState == null)
                computeCurrentState();
            final State initState = currentState;
            return new Iterator() {

                public void remove()
                {
                    throw new UnsupportedOperationException();
                }

                public AttributeImpl next()
                {
                    if(state == null)
                    {
                        throw new NoSuchElementException();
                    } else
                    {
                        AttributeImpl att = state.attribute;
                        state = state.next;
                        return att;
                    }
                }

                public boolean hasNext()
                {
                    return state != null;
                }

                public volatile Object next()
                {
                    return next();
                }

                private State state;
                final State val$initState;
                final AttributeSource this$0;

            
            {
                this$0 = AttributeSource.this;
                initState = state1;
                super();
                state = initState;
            }
            }
;
        } else
        {
            return Collections.emptySet().iterator();
        }
    }

    public void addAttributeImpl(AttributeImpl att)
    {
        Class clazz = att.getClass();
        if(attributeImpls.containsKey(clazz))
            return;
        LinkedList foundInterfaces;
        synchronized(knownImplClasses)
        {
            foundInterfaces = (LinkedList)knownImplClasses.get(clazz);
            if(foundInterfaces == null)
            {
                knownImplClasses.put(clazz, foundInterfaces = new LinkedList());
                Class actClazz = clazz;
                do
                {
                    Class arr$[] = actClazz.getInterfaces();
                    int len$ = arr$.length;
                    for(int i$ = 0; i$ < len$; i$++)
                    {
                        Class curInterface = arr$[i$];
                        if(curInterface != org/apache/lucene/util/Attribute && org/apache/lucene/util/Attribute.isAssignableFrom(curInterface))
                            foundInterfaces.add(curInterface.asSubclass(org/apache/lucene/util/Attribute));
                    }

                    actClazz = actClazz.getSuperclass();
                } while(actClazz != null);
            }
        }
        Iterator i$ = foundInterfaces.iterator();
        do
        {
            if(!i$.hasNext())
                break;
            Class curInterface = (Class)i$.next();
            if(!attributes.containsKey(curInterface))
            {
                currentState = null;
                attributes.put(curInterface, att);
                attributeImpls.put(clazz, att);
            }
        } while(true);
    }

    public Attribute addAttribute(Class attClass)
    {
        AttributeImpl attImpl = (AttributeImpl)attributes.get(attClass);
        if(attImpl == null)
            addAttributeImpl(attImpl = factory.createAttributeInstance(attClass));
        Attribute att = attImpl;
        return att;
    }

    public boolean hasAttributes()
    {
        return !attributes.isEmpty();
    }

    public boolean hasAttribute(Class attClass)
    {
        return attributes.containsKey(attClass);
    }

    public Attribute getAttribute(Class attClass)
    {
        Attribute att = (Attribute)attributes.get(attClass);
        if(att == null)
            throw new IllegalArgumentException((new StringBuilder()).append("This AttributeSource does not have the attribute '").append(attClass.getName()).append("'.").toString());
        else
            return att;
    }

    private void computeCurrentState()
    {
        currentState = new State();
        State c = currentState;
        Iterator it = attributeImpls.values().iterator();
        c.attribute = (AttributeImpl)it.next();
        while(it.hasNext()) 
        {
            c.next = new State();
            c = c.next;
            c.attribute = (AttributeImpl)it.next();
        }
    }

    public void clearAttributes()
    {
        if(hasAttributes())
        {
            if(currentState == null)
                computeCurrentState();
            for(State state = currentState; state != null; state = state.next)
                state.attribute.clear();

        }
    }

    public State captureState()
    {
        if(!hasAttributes())
            return null;
        if(currentState == null)
            computeCurrentState();
        return (State)currentState.clone();
    }

    public void restoreState(State state)
    {
        if(state == null)
            return;
        do
        {
            AttributeImpl targetImpl = (AttributeImpl)attributeImpls.get(state.attribute.getClass());
            if(targetImpl == null)
                throw new IllegalArgumentException("State contains an AttributeImpl that is not in this AttributeSource");
            state.attribute.copyTo(targetImpl);
            state = state.next;
        } while(state != null);
    }

    public int hashCode()
    {
        int code = 0;
        if(hasAttributes())
        {
            if(currentState == null)
                computeCurrentState();
            for(State state = currentState; state != null; state = state.next)
                code = code * 31 + state.attribute.hashCode();

        }
        return code;
    }

    public boolean equals(Object obj)
    {
        if(obj == this)
            return true;
        if(obj instanceof AttributeSource)
        {
            AttributeSource other = (AttributeSource)obj;
            if(hasAttributes())
            {
                if(!other.hasAttributes())
                    return false;
                if(attributeImpls.size() != other.attributeImpls.size())
                    return false;
                if(currentState == null)
                    computeCurrentState();
                State thisState = currentState;
                if(other.currentState == null)
                    other.computeCurrentState();
                for(State otherState = other.currentState; thisState != null && otherState != null; otherState = otherState.next)
                {
                    if(otherState.attribute.getClass() != thisState.attribute.getClass() || !otherState.attribute.equals(thisState.attribute))
                        return false;
                    thisState = thisState.next;
                }

                return true;
            } else
            {
                return !other.hasAttributes();
            }
        } else
        {
            return false;
        }
    }

    public String toString()
    {
        StringBuilder sb = (new StringBuilder()).append('(');
        if(hasAttributes())
        {
            if(currentState == null)
                computeCurrentState();
            for(State state = currentState; state != null; state = state.next)
            {
                if(state != currentState)
                    sb.append(',');
                sb.append(state.attribute.toString());
            }

        }
        return sb.append(')').toString();
    }

    public AttributeSource cloneAttributes()
    {
        AttributeSource clone = new AttributeSource(factory);
        if(hasAttributes())
        {
            if(currentState == null)
                computeCurrentState();
            for(State state = currentState; state != null; state = state.next)
                clone.attributeImpls.put(state.attribute.getClass(), (AttributeImpl)state.attribute.clone());

        }
        java.util.Map.Entry entry;
        for(Iterator i$ = attributes.entrySet().iterator(); i$.hasNext(); clone.attributes.put(entry.getKey(), clone.attributeImpls.get(((AttributeImpl)entry.getValue()).getClass())))
            entry = (java.util.Map.Entry)i$.next();

        return clone;
    }

    private final Map attributes;
    private final Map attributeImpls;
    private AttributeFactory factory;
    private static final IdentityHashMap knownImplClasses = new IdentityHashMap();
    private State currentState;

}
