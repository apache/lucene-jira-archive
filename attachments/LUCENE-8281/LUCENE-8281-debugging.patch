diff --git a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.java b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.java
index 07c7d99..476a8bd 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.java
@@ -214,6 +214,7 @@ class GeoComplexPolygon extends GeoBasePolygon {
     // We know inset/out-of-set for testPoint1 only right now
     this.testPoint1InSet = testPointInSet;
 
+    System.out.println("Determining in-set-ness of test point2 ("+testPoint2+"):");
     // We must compute the crossings from testPoint1 to testPoint2 in order to figure out whether testPoint2 is in-set or out
     this.testPoint2InSet = isInSet(testPoint2.x, testPoint2.y, testPoint2.z,
       testPoint1, 
@@ -221,6 +222,17 @@ class GeoComplexPolygon extends GeoBasePolygon {
       testPoint1FixedXPlane, testPoint1FixedXAbovePlane, testPoint1FixedXBelowPlane,
       testPoint1FixedYPlane, testPoint1FixedYAbovePlane, testPoint1FixedYBelowPlane,
       testPoint1FixedZPlane, testPoint1FixedZAbovePlane, testPoint1FixedZBelowPlane);
+    
+    System.out.println("\n... done.  Checking against test point1 ("+testPoint1+"):");
+    
+    assert isInSet(testPoint1.x, testPoint1.y, testPoint1.z,
+      testPoint2,
+      testPoint2InSet,
+      testPoint2FixedXPlane, testPoint2FixedXAbovePlane, testPoint2FixedXBelowPlane,
+      testPoint2FixedYPlane, testPoint2FixedYAbovePlane, testPoint2FixedYBelowPlane,
+      testPoint2FixedZPlane, testPoint2FixedZAbovePlane, testPoint2FixedZBelowPlane) == testPoint1InSet : "Test point1 not correctly in/out of set according to test point2";
+
+    System.out.println("\n... done");
   }
 
   /**
@@ -260,8 +272,11 @@ class GeoComplexPolygon extends GeoBasePolygon {
   
   @Override
   public boolean isWithin(final double x, final double y, final double z) {
+    //System.out.println("IsWithin() for ["+x+","+y+","+z+"]");
     try {
       // Try with the primary test point
+      //if (true) throw new IllegalArgumentException("use second point as exercise");
+      //System.out.println(" Trying testPoint1...");
       return isInSet(x, y, z,
         testPoint1,
         testPoint1InSet,
@@ -270,6 +285,8 @@ class GeoComplexPolygon extends GeoBasePolygon {
         testPoint1FixedZPlane, testPoint1FixedZAbovePlane, testPoint1FixedZBelowPlane);
     } catch (IllegalArgumentException e) {
       // Try with an alternate test point
+      //e.printStackTrace(System.out);
+      //System.out.println(" Trying testPoint2...");
       return isInSet(x, y, z,
         testPoint2,
         testPoint2InSet,
@@ -289,7 +306,7 @@ class GeoComplexPolygon extends GeoBasePolygon {
     final Plane testPointFixedYPlane, final Plane testPointFixedYAbovePlane, final Plane testPointFixedYBelowPlane,
     final Plane testPointFixedZPlane, final Plane testPointFixedZAbovePlane, final Plane testPointFixedZBelowPlane) {
 
-    //System.out.println("\nIswithin called for ["+x+","+y+","+z+"]");
+    System.out.println("\nIsInSet called for ["+x+","+y+","+z+"], testPoint="+testPoint+"; is in set? "+testPointInSet);
     // If we're right on top of the point, we know the answer.
     if (testPoint.isNumericallyIdentical(x, y, z)) {
       return testPointInSet;
@@ -298,6 +315,7 @@ class GeoComplexPolygon extends GeoBasePolygon {
     // If we're right on top of any of the test planes, we navigate solely on that plane.
     if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {
       // Use the XZ plane exclusively.
+      System.out.println(" Using XZ plane alone");
       final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);
       // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.
       if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {
@@ -307,6 +325,7 @@ class GeoComplexPolygon extends GeoBasePolygon {
       return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;
     } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {
       // Use the YZ plane exclusively.
+      System.out.println(" Using YZ plane alone");
       final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);
       // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.
       if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {
@@ -315,6 +334,7 @@ class GeoComplexPolygon extends GeoBasePolygon {
       }
       return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;
     } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {
+      System.out.println(" Using XY plane alone");
       final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);
       // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.
       if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {
@@ -322,10 +342,8 @@ class GeoComplexPolygon extends GeoBasePolygon {
         return true;
       }
       return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;
-    } else if (testPointFixedYPlane.evaluateIsZero(x, y, z) || testPointFixedXPlane.evaluateIsZero(x, y, z) || testPointFixedZPlane.evaluateIsZero(x, y, z)) {
-      throw new IllegalArgumentException("Can't compute isWithin for specified point");
     } else {
-
+      System.out.println(" Using two planes");
       // This is the expensive part!!
       // Changing the code below has an enormous impact on the queries per second we see with the benchmark.
       
@@ -398,6 +416,7 @@ class GeoComplexPolygon extends GeoBasePolygon {
             //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);
             //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);
             if (newDistance < bestDistance) {
+              System.out.println(" Picking YZ then XZ");
               bestDistance = newDistance;
               firstLegValue = testPoint.y;
               secondLegValue = x;
@@ -431,6 +450,7 @@ class GeoComplexPolygon extends GeoBasePolygon {
             //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);
             //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);
             if (newDistance < bestDistance) {
+              System.out.println(" Picking YZ then XY");
               bestDistance = newDistance;
               firstLegValue = testPoint.z;
               secondLegValue = x;
@@ -464,6 +484,7 @@ class GeoComplexPolygon extends GeoBasePolygon {
             //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);
             //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);
             if (newDistance < bestDistance) {
+              System.out.println(" Picking XZ then YZ");
               bestDistance = newDistance;
               firstLegValue = testPoint.x;
               secondLegValue = y;
@@ -497,6 +518,7 @@ class GeoComplexPolygon extends GeoBasePolygon {
             //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);
             //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);
             if (newDistance < bestDistance) {
+              System.out.println(" Picking XZ then XY");
               bestDistance = newDistance;
               firstLegValue = testPoint.z;
               secondLegValue = y;
@@ -530,6 +552,7 @@ class GeoComplexPolygon extends GeoBasePolygon {
             //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);
             //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);
             if (newDistance < bestDistance) {
+              System.out.println(" Picking XY then YZ");
               bestDistance = newDistance;
               firstLegValue = testPoint.x;
               secondLegValue = z;
@@ -563,6 +586,7 @@ class GeoComplexPolygon extends GeoBasePolygon {
             //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);
             //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);
             if (newDistance < bestDistance) {
+              System.out.println(" Picking XY then XZ");
               bestDistance = newDistance;
               firstLegValue = testPoint.y;
               secondLegValue = z;
@@ -584,26 +608,39 @@ class GeoComplexPolygon extends GeoBasePolygon {
       assert bestDistance < Double.POSITIVE_INFINITY : "Couldn't find an intersection point of any kind";
 
       // First, we'll determine if the intersection point is in set or not
+      System.out.println(" Finding whether "+intersectionPoint+" is in-set, based on travel from "+testPoint+" along "+firstLegPlane+" (value="+firstLegValue+")");
+      final boolean intersectionPointInSet;
       final CountingEdgeIterator testPointEdgeIterator = createLinearCrossingEdgeIterator(testPoint,
         firstLegPlane, firstLegAbovePlane, firstLegBelowPlane,
         intersectionPoint.x, intersectionPoint.y, intersectionPoint.z);
       // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.
       if (!firstLegTree.traverse(testPointEdgeIterator, firstLegValue)) {
         // Endpoint is on edge
-        return true;
+        System.out.println("  Landed on edge -- in-set");
+        intersectionPointInSet = true;
+      } else {
+        intersectionPointInSet = ((testPointEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;
       }
-      final boolean intersectionPointInSet = ((testPointEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;
+      
+      System.out.println("  Intersection point in-set? "+intersectionPointInSet);
 
       // Now do the final leg
+      System.out.println(" Finding whether ["+x+","+y+","+z+"] is in-set, based on travel from "+intersectionPoint+" along "+secondLegPlane+" (value="+secondLegValue+")");
+      final boolean rval;
       final CountingEdgeIterator travelEdgeIterator = createLinearCrossingEdgeIterator(intersectionPoint,
         secondLegPlane, secondLegAbovePlane, secondLegBelowPlane,
         x, y, z);
-      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.
+      // Traverse our way from the test point to the check point.
       if (!secondLegTree.traverse(travelEdgeIterator, secondLegValue)) {
         // Endpoint is on edge
-        return true;
+        System.out.println("  Landed on edge -- in-set");
+        rval = true;
+      } else {
+        rval = ((travelEdgeIterator.getCrossingCount() & 1) == 0)?intersectionPointInSet:!intersectionPointInSet;
       }
-      return ((travelEdgeIterator.getCrossingCount() & 1) == 0)?intersectionPointInSet:!intersectionPointInSet;
+      
+      System.out.println(" Check point in set? "+rval);
+      return rval;
     }
   }
   
@@ -1085,6 +1122,7 @@ class GeoComplexPolygon extends GeoBasePolygon {
       this.thePointX = thePointX;
       this.thePointY = thePointY;
       this.thePointZ = thePointZ;
+      System.out.println(" Constructing full linear crossing edge iterator");
     }
     
     @Override
@@ -1098,8 +1136,10 @@ class GeoComplexPolygon extends GeoBasePolygon {
     
     @Override
     public boolean matches(final Edge edge) {
+      System.out.println(" Edge ["+edge.startPoint+" --> "+edge.endPoint+"] potentially crosses travel plane "+plane);
       // Early exit if the point is on the edge.
       if (edge.isWithin(thePointX, thePointY, thePointZ)) {
+        System.out.println("  Point is on the edge; in-set");
         return false;
       }
       
@@ -1112,6 +1152,8 @@ class GeoComplexPolygon extends GeoBasePolygon {
           return true;
         }
       }
+
+      System.out.println("  Edge ["+edge.startPoint+" --> "+edge.endPoint+"] intersects travel plane "+plane);
       
       // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.
       aboveCrossingCount += countCrossings(edge, abovePlane, bound);
@@ -1184,6 +1226,7 @@ class GeoComplexPolygon extends GeoBasePolygon {
       this.thePointX = thePointX;
       this.thePointY = thePointY;
       this.thePointZ = thePointZ;
+      System.out.println(" Constructing sector linear crossing edge iterator");
     }
     
     @Override
@@ -1197,8 +1240,11 @@ class GeoComplexPolygon extends GeoBasePolygon {
     
     @Override
     public boolean matches(final Edge edge) {
+      System.out.println(" Edge ["+edge.startPoint+" --> "+edge.endPoint+"] potentially crosses travel plane "+plane);
       // Early exit if the point is on the edge.
       if (edge.isWithin(thePointX, thePointY, thePointZ)) {
+        // The point is on the edge.  This means it's "in-set" by definition, so abort.
+        System.out.println("  Point is on the edge; in-set");
         return false;
       }
       
@@ -1206,12 +1252,21 @@ class GeoComplexPolygon extends GeoBasePolygon {
       // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.
       final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);
       if (planeCrossings != null && planeCrossings.length == 0) {
+        System.out.println("  There are no intersection points within bounds.");
         // Sometimes on the hairy edge an intersection will be missed.  This check finds those.
         if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {
+          System.out.println("   Endpoint(s) of edge are not on travel plane");
+          // Edge doesn't actually intersect the travel plane.
           return true;
+        } else {
+          System.out.println("   Endpoint(s) of edge are on travel plane!");
         }
+      } else {
+        System.out.println("  There were intersection points!");
       }
       
+      System.out.println(" Edge ["+edge.startPoint+" --> "+edge.endPoint+"] intersects travel plane "+plane);
+      
       // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.
       aboveCrossingCount += countCrossings(edge, abovePlane, bound1, bound2);
       belowCrossingCount += countCrossings(edge, belowPlane, bound1, bound2);
diff --git a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPolygonTest.java b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPolygonTest.java
index 4fa3452..3e59143 100755
--- a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPolygonTest.java
+++ b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPolygonTest.java
@@ -1743,7 +1743,7 @@ shape:
   }
   
   @Test
-  @AwaitsFix(bugUrl="https://issues.apache.org/jira/browse/LUCENE-8281")
+  //@AwaitsFix(bugUrl="https://issues.apache.org/jira/browse/LUCENE-8281")
   public void testLUCENE8281() {
     /*
    [junit4]    > Standard polygon: GeoCompositePolygon: {[GeoConvexPolygon: {planetmodel=PlanetModel.WGS84, points=[[lat=-3.89514302068452E-6, lon=6.597839410815709E-6([X=1.0011188539630433, Y=6.605221429683868E-6, Z=-3.89950111699443E-6])], [lat=-2.8213942160840002E-6, lon=1.608008770581648E-5([X=1.0011188538590383, Y=1.60980789753873E-5, Z=-2.8245509442632E-6])], [lat=3.8977187534179774E-6, lon=1.9713406091526053E-5([X=1.0011188537902969, Y=1.973546251320774E-5, Z=3.902079731596721E-6])], [lat=1.980614928404974E-5, lon=4.069266235973146E-6([X=1.0011188537865057, Y=4.07381914993205E-6, Z=1.982830947192924E-5])], [lat=7.4E-323, lon=0.0([X=1.0011188539924791, Y=0.0, Z=7.4E-323])]], internalEdges={4}}, GeoConvexPolygon: {planetmodel=PlanetModel.WGS84, points=[[lat=-3.89514302068452E-6, lon=6.597839410815709E-6([X=1.0011188539630433, Y=6.605221429683868E-6, Z=-3.89950111699443E-6])], [lat=7.4E-323, lon=0.0([X=1.0011188539924791, Y=0.0, Z=7.4E-323])], [lat=-1.261719663233924E-5, lon=-1.5701544210600105E-5([X=1.001118853788849, Y=-1.5719111944122703E-5, Z=-1.2631313432823314E-5])]], internalEdges={0}}]}
diff --git a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest.java b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest.java
index 97829b8..4507450 100644
--- a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest.java
+++ b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomGeoPolygonTest.java
@@ -93,7 +93,7 @@ public class RandomGeoPolygonTest extends RandomGeo3dShapeGenerator {
    */
   @Test
   @Repeat(iterations = 10)
-  @AwaitsFix(bugUrl="https://issues.apache.org/jira/browse/LUCENE-8281")
+  //@AwaitsFix(bugUrl="https://issues.apache.org/jira/browse/LUCENE-8281")
   public void testCompareBigPolygons() {
     testComparePolygons(Math.PI);
   }
@@ -104,7 +104,7 @@ public class RandomGeoPolygonTest extends RandomGeo3dShapeGenerator {
    */
   @Test
   @Repeat(iterations = 10)
-  @AwaitsFix(bugUrl="https://issues.apache.org/jira/browse/LUCENE-8281")
+  //@AwaitsFix(bugUrl="https://issues.apache.org/jira/browse/LUCENE-8281")
   public void testCompareSmallPolygons() {
     testComparePolygons(1e-4 * Math.PI);
   }
