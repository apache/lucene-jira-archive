From e896fec913528abbd44cef562ee3b041fb250d45 Mon Sep 17 00:00:00 2001
From: Jason Baik <jbaik17@bloomberg.net>
Date: Thu, 29 Oct 2020 16:42:09 -0400
Subject: [PATCH] LUCENE-9542 - Unit test to reproduce bug

---
 .../search/SolrIndexSearcherRerankTest.java   | 143 ++++++++++++++++++
 1 file changed, 143 insertions(+)
 create mode 100644 solr/core/src/test/org/apache/solr/search/SolrIndexSearcherRerankTest.java

diff --git a/solr/core/src/test/org/apache/solr/search/SolrIndexSearcherRerankTest.java b/solr/core/src/test/org/apache/solr/search/SolrIndexSearcherRerankTest.java
new file mode 100644
index 00000000000..6ef707885ce
--- /dev/null
+++ b/solr/core/src/test/org/apache/solr/search/SolrIndexSearcherRerankTest.java
@@ -0,0 +1,143 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.search;
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.*;
+import org.apache.solr.SolrTestCaseJ4;
+import org.apache.solr.handler.component.MergeStrategy;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+
+public final class SolrIndexSearcherRerankTest extends SolrTestCaseJ4 {
+
+  @BeforeClass
+  public static void setUpClass() throws Exception {
+    initCore("solrconfig.xml", "schema.xml");
+    assertU(adoc("id", "1", "query_s", "foo", "sort_sortable", "2", "filter_s", "bar"));
+    assertU(adoc("id", "2", "query_s", "foo", "sort_sortable", "1", "filter_s", "bar"));
+    // This extra doc is needed since the bug is triggered only if the filter matches a subset of the corpus
+    // org/apache/solr/search/SolrIndexSearcher.java:1023
+    assertU(adoc("id", "3", "query_s", "baz"));
+    assertU(commit());
+  }
+
+  @Test
+  public void rerankFailsWithSortingAndFiltering() throws Exception {
+
+    List<Float> expectedScores = List.of(1f, 1f);
+
+    // Ideally all three queries below should produce the same scores
+
+    // Without sort, or filter, the rerank works
+    assertEquals(expectedScores, runQueryAndCollectScores("foo", Optional.of("bar"), Optional.empty()));
+    assertEquals(expectedScores, runQueryAndCollectScores("foo", Optional.empty(),
+            Optional.of(new Sort(SortField.FIELD_SCORE, new SortField("sort_sortable", SortField.Type.STRING)))));
+
+    // However, with both sort and filter, the rerank fails bc of query and filter combining at SolrIndexSearcher.java:1536
+    // circumvents the protection at SolrIndexSearcher.java:1608, and the 2nd-pass scores get overwritten with
+    // the re-computed 1st-pass scores
+    assertEquals(expectedScores, runQueryAndCollectScores("foo", Optional.of("bar"),
+            Optional.of(new Sort(SortField.FIELD_SCORE, new SortField("sort_sortable", SortField.Type.STRING)))));
+  }
+
+  private List<Float> runQueryAndCollectScores(String scoreQuery, Optional<String> filterQuery, Optional<Sort> sort) throws IOException {
+
+    QueryCommand cmd = new QueryCommand();
+    cmd.setFlags(SolrIndexSearcher.GET_SCORES);
+    cmd.setQuery(new FixScoreTo1ReRankQuery(new TermQuery(new Term("query_s", scoreQuery))));
+    filterQuery.ifPresent(fq -> cmd.setFilterList(new TermQuery(new Term("filter_s", fq))));
+    sort.ifPresent(cmd::setSort);
+
+    QueryResult queryResult = h.getCore().withSearcher(searcher -> searcher.search(new QueryResult(), cmd));
+
+    List<Float> scores = new ArrayList<>(2);
+    DocIterator iter = queryResult.getDocList().iterator();
+    iter.next();
+    scores.add(iter.score());
+    iter.next();
+    scores.add(iter.score());
+    return scores;
+  }
+
+  static final class FixScoreTo1ReRankQuery extends RankQuery {
+
+    private Query q;
+
+    FixScoreTo1ReRankQuery(Query q) {
+      this.q = q;
+    }
+
+    public Weight createWeight(IndexSearcher indexSearcher, ScoreMode scoreMode, float boost) throws IOException {
+      return q.createWeight(indexSearcher, scoreMode, boost);
+    }
+
+    @Override
+    public void visit(QueryVisitor visitor) {
+      q.visit(visitor);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      return this == obj;
+    }
+
+    @Override
+    public int hashCode() {
+      return q.hashCode();
+    }
+
+    @Override
+    public String toString(String field) {
+      return q.toString(field);
+    }
+
+    @Override
+    public TopDocsCollector getTopDocsCollector(int len, QueryCommand cmd, IndexSearcher searcher) throws IOException {
+      return new ReRankCollector(len, len, new Rescorer() {
+        @Override
+        public TopDocs rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN) {
+          for (ScoreDoc scoreDoc : firstPassTopDocs.scoreDocs) {
+            scoreDoc.score = 1f;
+          }
+          return firstPassTopDocs;
+        }
+
+        @Override
+        public Explanation explain(IndexSearcher searcher, Explanation firstPassExplanation, int docID) {
+          return firstPassExplanation;
+        }
+      }, cmd, searcher, null);
+    }
+
+    @Override
+    public MergeStrategy getMergeStrategy() {
+      return null;
+    }
+
+    public RankQuery wrap(Query q) {
+      this.q = q;
+      return this;
+    }
+  }
+
+}
-- 
2.25.1

