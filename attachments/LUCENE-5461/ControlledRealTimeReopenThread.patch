Index: src/org/apache/lucene/search/ControlledRealTimeReopenThread.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/org/apache/lucene/search/ControlledRealTimeReopenThread.java	(revision 1.1.2.1)
+++ src/org/apache/lucene/search/ControlledRealTimeReopenThread.java	(revision )
@@ -160,12 +160,15 @@
             throw new IllegalArgumentException("targetGen=" + targetGen + " was never returned by the ReferenceManager instance (current gen=" + curGen + ")");
         }
         if (targetGen > searchingGen) {
-            waitingGen = Math.max(waitingGen, targetGen);
 
             // Notify the reopen thread that the waitingGen has
             // changed, so it may wake up and realize it should
             // not sleep for much or any longer before reopening:
             reopenLock.lock();
+            //need to find waitingGen inside lock as its used to determine
+            //stale time
+            waitingGen = Math.max(waitingGen, targetGen);
+
             try {
                 reopenCond.signal();
             } finally {
@@ -206,7 +209,8 @@
             // Loop until we've waiting long enough before the
             // next reopen:
             while (!finish) {
-
+                //need lock before finding out if has waiting
+                reopenLock.lock();
                 // True if we have someone waiting for reopened searcher:
                 boolean hasWaiting = waitingGen > searchingGen;
                 final long nextReopenStartNS = lastReopenStartNS + (hasWaiting ? targetMinStaleNS : targetMaxStaleNS);
@@ -214,7 +218,6 @@
                 final long sleepNS = nextReopenStartNS - System.nanoTime();
 
                 if (sleepNS > 0) {
-                    reopenLock.lock();
                     try {
                         reopenCond.awaitNanos(sleepNS);
                     } catch (InterruptedException ie) {
