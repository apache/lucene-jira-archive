Index: src/java/org/apache/lucene/search/BooleanQuery.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/BooleanQuery.java,v
retrieving revision 1.29
diff -u -r1.29 BooleanQuery.java
--- src/java/org/apache/lucene/search/BooleanQuery.java	24 Jan 2005 19:21:01 -0000	1.29
+++ src/java/org/apache/lucene/search/BooleanQuery.java	18 Feb 2005 11:17:05 -0000
@@ -17,6 +17,9 @@
  */

 import java.io.IOException;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
 import java.util.Vector;
 import org.apache.lucene.index.IndexReader;

@@ -117,16 +120,16 @@
   }

   private class BooleanWeight implements Weight {
-    protected Searcher searcher;
+    protected Similarity similarity;
     protected Vector weights = new Vector();

-    public BooleanWeight(Searcher searcher) {
-      this.searcher = searcher;
+    public BooleanWeight(Similarity similarity, DocFreqSource dfSource)
+      throws IOException {
+      this.similarity = similarity;
       for (int i = 0 ; i < clauses.size(); i++) {
         BooleanClause c = (BooleanClause)clauses.elementAt(i);
-        weights.add(c.getQuery().createWeight(searcher));
+        weights.add(c.getQuery().createWeight(similarity, dfSource));
       }
-  //System.out.println("Creating " + getClass().getName());
     }

     public Query getQuery() { return BooleanQuery.this; }
@@ -177,7 +180,7 @@

       if (allRequired && noneBoolean) {           // ConjunctionScorer is okay
         ConjunctionScorer result =
-          new ConjunctionScorer(getSimilarity(searcher));
+          new ConjunctionScorer(similarity);
         for (int i = 0 ; i < weights.size(); i++) {
           Weight w = (Weight)weights.elementAt(i);
           Scorer subScorer = w.scorer(reader);
@@ -189,7 +192,7 @@
       }

       // Use good-old BooleanScorer instead.
-      BooleanScorer result = new BooleanScorer(getSimilarity(searcher));
+      BooleanScorer result = new BooleanScorer(similarity);

       for (int i = 0 ; i < weights.size(); i++) {
         BooleanClause c = (BooleanClause)clauses.elementAt(i);
@@ -233,7 +236,7 @@
       if (coord == 1)                               // only one clause matched
         sumExpl = sumExpl.getDetails()[0];          // eliminate wrapper

-      float coordFactor = getSimilarity(searcher).coord(coord, maxCoord);
+      float coordFactor = similarity.coord(coord, maxCoord);
       if (coordFactor == 1.0f)                      // coord is no-op
         return sumExpl;                             // eliminate wrapper
       else {
@@ -250,13 +253,16 @@

   private class BooleanWeight2 extends BooleanWeight {
     /* Merge into BooleanWeight in case the 1.4 BooleanScorer is dropped */
-    public BooleanWeight2(Searcher searcher) {  super(searcher); }
+    public BooleanWeight2(Similarity similarity, DocFreqSource dfSource)
+      throws IOException {
+        super(similarity, dfSource);
+    }

     /** @return An alternative Scorer that uses and provides skipTo(),
      *          and scores documents in document number order.
      */
     public Scorer scorer(IndexReader reader) throws IOException {
-      BooleanScorer2 result = new BooleanScorer2(getSimilarity(searcher));
+      BooleanScorer2 result = new BooleanScorer2(similarity);

       for (int i = 0 ; i < weights.size(); i++) {
         BooleanClause c = (BooleanClause)clauses.elementAt(i);
@@ -283,9 +289,9 @@
     return useScorer14;
   }

-  protected Weight createWeight(Searcher searcher) {
-    return getUseScorer14() ? (Weight) new BooleanWeight(searcher)
-                            : (Weight) new BooleanWeight2(searcher);
+  protected Weight createWeight(Similarity similarity, DocFreqSource dfSource) throws IOException {
+    return getUseScorer14() ? (Weight) new BooleanWeight(similarity, dfSource)
+                            : (Weight) new BooleanWeight2(similarity, dfSource);
   }

   public Query rewrite(IndexReader reader) throws IOException {
@@ -322,7 +328,15 @@
       return this;                                // no clauses rewrote
   }

-
+  // inherit javadoc
+  public void extractTerms(Set terms) {
+      for (Iterator i = clauses.iterator(); i.hasNext();) {
+          BooleanClause clause = (BooleanClause) i.next();
+          clause.getQuery().extractTerms(terms);
+        }
+  }
+
+
   public Object clone() {
     BooleanQuery clone = (BooleanQuery)super.clone();
     clone.clauses = (Vector)this.clauses.clone();
@@ -377,4 +391,9 @@
     return Float.floatToIntBits(getBoost()) ^ clauses.hashCode();
   }

+  // inherit javadoc
+  public Query combine(Query[] queries) {
+    return Query.mergeBooleanQueries(queries);
+  }
+
 }
Index: src/java/org/apache/lucene/search/FilteredQuery.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/FilteredQuery.java,v
retrieving revision 1.5
diff -u -r1.5 FilteredQuery.java
--- src/java/org/apache/lucene/search/FilteredQuery.java	18 Jun 2004 09:52:25 -0000	1.5
+++ src/java/org/apache/lucene/search/FilteredQuery.java	18 Feb 2005 11:17:05 -0000
@@ -19,6 +19,8 @@
 import org.apache.lucene.index.IndexReader;
 import java.io.IOException;
 import java.util.BitSet;
+import java.util.Iterator;
+import java.util.Set;


 /**
@@ -56,8 +58,8 @@
    * Returns a Weight that applies the filter to the enclosed query's Weight.
    * This is accomplished by overriding the Scorer returned by the Weight.
    */
-  protected Weight createWeight (final Searcher searcher) {
-    final Weight weight = query.createWeight (searcher);
+  protected Weight createWeight (final Similarity similarity, DocFreqSource dfSource) throws IOException {
+    final Weight weight = query.createWeight (similarity, dfSource);
     return new Weight() {

       // pass these methods through to enclosed query's weight
@@ -74,7 +76,7 @@
       public Scorer scorer (IndexReader indexReader) throws IOException {
         final Scorer scorer = weight.scorer (indexReader);
         final BitSet bitset = filter.bits (indexReader);
-        return new Scorer (query.getSimilarity (searcher)) {
+        return new Scorer (similarity) {

           // pass these methods through to the enclosed scorer
           public boolean next() throws IOException { return scorer.next(); }
@@ -116,6 +118,11 @@
     return query;
   }

+  // inherit javadoc
+  public void extractTerms(Set terms) {
+      getQuery().extractTerms(terms);
+  }
+
   /** Prints a user-readable version of this query. */
   public String toString (String s) {
     return "filtered("+query.toString(s)+")->"+filter;
Index: src/java/org/apache/lucene/search/IndexSearcher.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/IndexSearcher.java,v
retrieving revision 1.23
diff -u -r1.23 IndexSearcher.java
--- src/java/org/apache/lucene/search/IndexSearcher.java	14 Nov 2004 13:26:28 -0000	1.23
+++ src/java/org/apache/lucene/search/IndexSearcher.java	18 Feb 2005 11:17:05 -0000
@@ -86,8 +86,9 @@

     if (nDocs <= 0)  // null might be returned from hq.top() below.
       throw new IllegalArgumentException("nDocs must be > 0");
-
-    Scorer scorer = query.weight(this).scorer(reader);
+
+    Query q = rewrite(query);
+    Scorer scorer = q.weight(this.getSimilarity(), this).scorer(reader);
     if (scorer == null)
       return new TopDocs(0, new ScoreDoc[0]);

@@ -119,7 +120,8 @@
   public TopFieldDocs search(Query query, Filter filter, final int nDocs,
                              Sort sort)
     throws IOException {
-    Scorer scorer = query.weight(this).scorer(reader);
+    Query q = rewrite(query);
+    Scorer scorer = q.weight(this.getSimilarity(), this).scorer(reader);
     if (scorer == null)
       return new TopFieldDocs(0, new ScoreDoc[0], sort.fields);

@@ -160,7 +162,8 @@
         };
     }

-    Scorer scorer = query.weight(this).scorer(reader);
+    Query q = rewrite(query);
+    Scorer scorer = q.weight(this.getSimilarity(), this).scorer(reader);
     if (scorer == null)
       return;
     scorer.score(collector);
@@ -176,7 +179,8 @@
   }

   public Explanation explain(Query query, int doc) throws IOException {
-    return query.weight(this).explain(reader, doc);
+    Query q = rewrite(query);
+    return q.weight(this.getSimilarity(), this).explain(reader, doc);
   }

 }
Index: src/java/org/apache/lucene/search/MultiPhraseQuery.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/MultiPhraseQuery.java,v
retrieving revision 1.2
diff -u -r1.2 MultiPhraseQuery.java
--- src/java/org/apache/lucene/search/MultiPhraseQuery.java	19 Jan 2005 23:32:52 -0000	1.2
+++ src/java/org/apache/lucene/search/MultiPhraseQuery.java	18 Feb 2005 11:17:05 -0000
@@ -107,27 +107,32 @@
   }

   private class MultiPhraseWeight implements Weight {
-    private Searcher searcher;
+    private Similarity similarity;
     private float value;
     private float idf;
     private float queryNorm;
     private float queryWeight;

-    public MultiPhraseWeight(Searcher searcher) {
-      this.searcher = searcher;
+    public MultiPhraseWeight(Similarity similarity, DocFreqSource dfSource)
+      throws IOException {
+      this.similarity = similarity;
+
+      // compute idf
+      Iterator i = termArrays.iterator();
+      int numDocs = dfSource.maxDoc();
+      while (i.hasNext()) {
+        Term[] terms = (Term[])i.next();
+        for (int j=0; j<terms.length; j++) {
+          int df = dfSource.docFreq(terms[j]);
+          idf += similarity.idf(df, numDocs);
+        }
+      }
     }

     public Query getQuery() { return MultiPhraseQuery.this; }
     public float getValue() { return value; }

     public float sumOfSquaredWeights() throws IOException {
-      Iterator i = termArrays.iterator();
-      while (i.hasNext()) {
-        Term[] terms = (Term[])i.next();
-        for (int j=0; j<terms.length; j++)
-          idf += getSimilarity(searcher).idf(terms[j], searcher);
-      }
-
       queryWeight = idf * getBoost();             // compute query weight
       return queryWeight * queryWeight;           // square it
     }
@@ -159,10 +164,10 @@
       }

       if (slop == 0)
-        return new ExactPhraseScorer(this, tps, getPositions(), getSimilarity(searcher),
+        return new ExactPhraseScorer(this, tps, getPositions(), similarity,
                                      reader.norms(field));
       else
-        return new SloppyPhraseScorer(this, tps, getPositions(), getSimilarity(searcher),
+        return new SloppyPhraseScorer(this, tps, getPositions(), similarity,
                                       slop, reader.norms(field));
     }

@@ -239,8 +244,8 @@
     }
   }

-  protected Weight createWeight(Searcher searcher) {
-    return new MultiPhraseWeight(searcher);
+  protected Weight createWeight(Similarity similarity, DocFreqSource dfSource) throws IOException {
+    return new MultiPhraseWeight(similarity, dfSource);
   }

   /** Prints a user-readable version of this query. */
Index: src/java/org/apache/lucene/search/MultiSearcher.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/MultiSearcher.java,v
retrieving revision 1.17
diff -u -r1.17 MultiSearcher.java
--- src/java/org/apache/lucene/search/MultiSearcher.java	29 Mar 2004 22:48:03 -0000	1.17
+++ src/java/org/apache/lucene/search/MultiSearcher.java	18 Feb 2005 11:17:05 -0000
@@ -17,6 +17,10 @@
  */

 import java.io.IOException;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;

 import org.apache.lucene.document.Document;
 import org.apache.lucene.index.Term;
@@ -27,11 +31,49 @@
  * or {@link #search(Query,Filter)} methods.
  */
 public class MultiSearcher extends Searcher {
+    /**
+     * This class is initialized with a df map which is used as cache for the
+     * dfs
+     */
+  public static class CachedDfSource implements DocFreqSource {
+    private Map dfMap; // Map from Terms to corresponding doc freqs
+    private int maxDoc; // document count
+
+    public CachedDfSource(Map dfMap, int maxDoc) {
+      this.dfMap = dfMap;
+      this.maxDoc = maxDoc;
+    }
+
+    public int docFreq(Term term) {
+      int df;
+      try {
+        df = ((Integer) dfMap.get(term)).intValue();
+      } catch (NullPointerException e) {
+        throw new IllegalArgumentException("df for term " + term.text()
+            + " not available");
+      }
+      return df;
+    }
+
+    public int[] docFreqs(Term[] terms) throws IOException {
+      int[] result = new int[terms.length];
+      for (int i = 0; i < terms.length; i++) {
+        result[i] = docFreq(terms[i]);
+      }
+      return result;
+    }
+
+    public int maxDoc() {
+      return maxDoc;
+    }
+  };
+
+
   private Searchable[] searchables;
   private int[] starts;
   private int maxDoc = 0;

-  /** Creates a searcher which searches <i>searchables</i>. */
+  /** Creates a searcher which searches <i>searchables </i>. */
   public MultiSearcher(Searchable[] searchables) throws IOException {
     this.searchables = searchables;

@@ -66,12 +108,6 @@
     return searchables[i].doc(n - starts[i]);	  // dispatch to searcher
   }

-  /** Call {@link #subSearcher} instead.
-   * @deprecated
-   */
-  public int searcherIndex(int n) {
-    return subSearcher(n);
-  }

   /** Returns index of the searcher for document <code>n</code> in the array
    * used to construct this searcher. */
@@ -109,6 +145,8 @@

   public TopDocs search(Query query, Filter filter, int nDocs)
       throws IOException {
+    query = prepareQuery(query);
+
     HitQueue hq = new HitQueue(nDocs);
     int totalHits = 0;

@@ -134,6 +172,8 @@

   public TopFieldDocs search (Query query, Filter filter, int n, Sort sort)
     throws IOException {
+    query = prepareQuery(query);
+
     FieldDocSortedHitQueue hq = null;
     int totalHits = 0;

@@ -161,6 +201,8 @@
   // inherit javadoc
   public void search(Query query, Filter filter, final HitCollector results)
     throws IOException {
+      query = prepareQuery(query);
+
     for (int i = 0; i < searchables.length; i++) {

       final int start = starts[i];
@@ -179,7 +221,7 @@
     for (int i = 0; i < searchables.length; i++) {
       queries[i] = searchables[i].rewrite(original);
     }
-    return original.combine(queries);
+    return queries[0].combine(queries);
   }

   public Explanation explain(Query query, int doc) throws IOException {
@@ -187,4 +229,54 @@
     return searchables[i].explain(query,doc-starts[i]); // dispatch to searcher
   }

+  /**
+   * Distributed query processing is done in the following steps:
+   * 1. rewrite query
+   * 2. extract necessary terms
+   * 3. collect dfs for these terms from the Searchables
+   * 4. create query weights using aggregate dfs and freeze query.
+   * 5. distribute weighted and frozen query to Searchables
+   * 6. merge results
+   *
+   * Steps 1-4 are done here, 5+6 in the search() methods
+   *
+   * @return rewritten queries
+   */
+  private Query prepareQuery(Query original) throws IOException {
+    if(original.isFrozen()){
+      return original;
+    }
+
+    // step 1
+    Query rewrittenQuery = rewrite(original);
+
+    // step 2
+    Set terms = new HashSet();
+    rewrittenQuery.extractTerms(terms);
+
+    // step3
+    Term[] allTermsArray = new Term[terms.size()];
+    terms.toArray(allTermsArray);
+    int[] aggregatedDfs = new int[terms.size()];
+    for (int i = 0; i < searchables.length; i++) {
+      int[] dfs = searchables[i].docFreqs(allTermsArray);
+      for(int j=0; j<aggregatedDfs.length; j++){
+        aggregatedDfs[j] += dfs[j];
+      }
+    }
+
+    HashMap dfMap = new HashMap();
+    for(int i=0; i<allTermsArray.length; i++) {
+      dfMap.put(allTermsArray[i], new Integer(aggregatedDfs[i]));
+    }
+
+    // step4
+    int numDocs = maxDoc();
+    CachedDfSource cacheSim = new CachedDfSource(dfMap, numDocs);
+    rewrittenQuery.weight(getSimilarity(), cacheSim);
+    rewrittenQuery.setFrozen(true);
+
+    return rewrittenQuery;
+  }
+
 }
Index: src/java/org/apache/lucene/search/PhrasePrefixQuery.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/PhrasePrefixQuery.java,v
retrieving revision 1.18
diff -u -r1.18 PhrasePrefixQuery.java
--- src/java/org/apache/lucene/search/PhrasePrefixQuery.java	10 Oct 2004 15:27:15 -0000	1.18
+++ src/java/org/apache/lucene/search/PhrasePrefixQuery.java	18 Feb 2005 11:17:05 -0000
@@ -108,27 +108,32 @@
   }

   private class PhrasePrefixWeight implements Weight {
-    private Searcher searcher;
+    private Similarity similarity;
     private float value;
     private float idf;
     private float queryNorm;
     private float queryWeight;

-    public PhrasePrefixWeight(Searcher searcher) {
-      this.searcher = searcher;
+    public PhrasePrefixWeight(Similarity similarity, DocFreqSource dfSource)
+      throws IOException {
+      this.similarity = similarity;
+
+      // compute idf
+      Iterator i = termArrays.iterator();
+      int numDocs = dfSource.maxDoc();
+      while (i.hasNext()) {
+        Term[] terms = (Term[])i.next();
+        for (int j=0; j<terms.length; j++) {
+          int df = dfSource.docFreq(terms[j]);
+          idf += similarity.idf(df, numDocs);
+        }
+      }
     }

     public Query getQuery() { return PhrasePrefixQuery.this; }
     public float getValue() { return value; }

     public float sumOfSquaredWeights() throws IOException {
-      Iterator i = termArrays.iterator();
-      while (i.hasNext()) {
-        Term[] terms = (Term[])i.next();
-        for (int j=0; j<terms.length; j++)
-          idf += getSimilarity(searcher).idf(terms[j], searcher);
-      }
-
       queryWeight = idf * getBoost();             // compute query weight
       return queryWeight * queryWeight;           // square it
     }
@@ -160,10 +165,10 @@
       }

       if (slop == 0)
-        return new ExactPhraseScorer(this, tps, getPositions(), getSimilarity(searcher),
+        return new ExactPhraseScorer(this, tps, getPositions(), similarity,
                                      reader.norms(field));
       else
-        return new SloppyPhraseScorer(this, tps, getPositions(), getSimilarity(searcher),
+        return new SloppyPhraseScorer(this, tps, getPositions(), similarity,
                                       slop, reader.norms(field));
     }

@@ -226,7 +231,7 @@
     }
   }

-  protected Weight createWeight(Searcher searcher) {
+  protected Weight createWeight(Similarity similarity, DocFreqSource dfSource) throws IOException {
     if (termArrays.size() == 1) {                 // optimize one-term case
       Term[] terms = (Term[])termArrays.get(0);
       BooleanQuery boq = new BooleanQuery();
@@ -234,9 +239,9 @@
         boq.add(new TermQuery(terms[i]), BooleanClause.Occur.SHOULD);
       }
       boq.setBoost(getBoost());
-      return boq.createWeight(searcher);
+      return boq.createWeight(similarity, dfSource);
     }
-    return new PhrasePrefixWeight(searcher);
+    return new PhrasePrefixWeight(similarity, dfSource);
   }

   /** Prints a user-readable version of this query. */
Index: src/java/org/apache/lucene/search/PhraseQuery.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/PhraseQuery.java,v
retrieving revision 1.17
diff -u -r1.17 PhraseQuery.java
--- src/java/org/apache/lucene/search/PhraseQuery.java	15 Sep 2004 21:09:00 -0000	1.17
+++ src/java/org/apache/lucene/search/PhraseQuery.java	18 Feb 2005 11:17:05 -0000
@@ -17,6 +17,10 @@
  */

 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Set;
 import java.util.Vector;

 import org.apache.lucene.index.Term;
@@ -100,14 +104,26 @@
   }

   private class PhraseWeight implements Weight {
-    private Searcher searcher;
+    private Similarity similarity;
     private float value;
     private float idf;
     private float queryNorm;
     private float queryWeight;

-    public PhraseWeight(Searcher searcher) {
-      this.searcher = searcher;
+    public PhraseWeight(Similarity similarity, DocFreqSource dfSource)
+      throws IOException {
+      this.similarity = similarity;
+
+      // compute idf
+      int[] docFreqs = new int[terms.size()];
+      int j=0;
+      for (Iterator i = terms.iterator(); i.hasNext();) {
+        Term term = (Term) i.next();
+        docFreqs[j] = dfSource.docFreq(term);
+        j++;
+      }
+
+      idf = similarity.idf(docFreqs, dfSource.maxDoc());
     }

     public String toString() { return "weight(" + PhraseQuery.this + ")"; }
@@ -116,7 +132,6 @@
     public float getValue() { return value; }

     public float sumOfSquaredWeights() throws IOException {
-      idf = getSimilarity(searcher).idf(terms, searcher);
       queryWeight = idf * getBoost();             // compute query weight
       return queryWeight * queryWeight;           // square it
     }
@@ -140,11 +155,11 @@
       }

       if (slop == 0)				  // optimize exact case
-        return new ExactPhraseScorer(this, tps, getPositions(), getSimilarity(searcher),
+        return new ExactPhraseScorer(this, tps, getPositions(), similarity,
                                      reader.norms(field));
       else
         return
-          new SloppyPhraseScorer(this, tps, getPositions(), getSimilarity(searcher), slop,
+          new SloppyPhraseScorer(this, tps, getPositions(), similarity, slop,
                                  reader.norms(field));

     }
@@ -168,7 +183,7 @@

         docFreqs.append(term.text());
         docFreqs.append("=");
-        docFreqs.append(searcher.docFreq(term));
+        docFreqs.append(reader.docFreq(term));

         query.append(term.text());
       }
@@ -228,16 +243,22 @@
     }
   }

-  protected Weight createWeight(Searcher searcher) {
+  protected Weight createWeight(Similarity similarity, DocFreqSource dfSource) throws IOException {
     if (terms.size() == 1) {			  // optimize one-term case
       Term term = (Term)terms.elementAt(0);
       Query termQuery = new TermQuery(term);
       termQuery.setBoost(getBoost());
-      return termQuery.createWeight(searcher);
+      return termQuery.createWeight(similarity, dfSource);
     }
-    return new PhraseWeight(searcher);
+    return new PhraseWeight(similarity, dfSource);
   }

+  /**
+   * @see org.apache.lucene.search.Query#extractTerms(java.util.Set)
+   */
+  public void extractTerms(Set queryTerms) {
+    queryTerms.addAll(terms);
+  }

   /** Prints a user-readable version of this query. */
   public String toString(String f) {
Index: src/java/org/apache/lucene/search/PrefixQuery.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/PrefixQuery.java,v
retrieving revision 1.10
diff -u -r1.10 PrefixQuery.java
--- src/java/org/apache/lucene/search/PrefixQuery.java	27 Aug 2004 20:20:47 -0000	1.10
+++ src/java/org/apache/lucene/search/PrefixQuery.java	18 Feb 2005 11:17:05 -0000
@@ -60,7 +60,7 @@
   }

   public Query combine(Query[] queries) {
-    return Query.mergeBooleanQueries(queries);
+    return BooleanQuery.mergeBooleanQueries(queries);
   }

   /** Prints a user-readable version of this query. */
Index: src/java/org/apache/lucene/search/Query.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/Query.java,v
retrieving revision 1.18
diff -u -r1.18 Query.java
--- src/java/org/apache/lucene/search/Query.java	15 Oct 2004 19:50:58 -0000	1.18
+++ src/java/org/apache/lucene/search/Query.java	18 Feb 2005 11:17:05 -0000
@@ -20,6 +20,7 @@

 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.Set;

 import org.apache.lucene.index.IndexReader;

@@ -44,6 +45,8 @@
 */
 public abstract class Query implements java.io.Serializable, Cloneable {
   private float boost = 1.0f;                     // query boost factor
+  private boolean frozen;                // indicates if cached weight should be used
+  private Weight cachedWeight = null;    // most recently created weight

   /** Sets the boost for this query clause to <code>b</code>.  Documents
    * matching this clause will (in addition to the normal weightings) have
@@ -81,19 +84,50 @@
    *
    * <p>Only implemented by primitive queries, which re-write to themselves.
    */
-  protected Weight createWeight(Searcher searcher) {
+  protected Weight createWeight(Similarity similarity, DocFreqSource dfSource) throws IOException {
     throw new UnsupportedOperationException();
   }

-  /** Expert: Constructs an initializes a Weight for a top-level query. */
-  public Weight weight(Searcher searcher)
+  /** Expert: Constructs an initializes a Weight for a top-level query.
+   *          precondition: query is already rewritten
+   */
+  public Weight weight(Similarity similarity, DocFreqSource dfSource)
     throws IOException {
-    Query query = searcher.rewrite(this);
-    Weight weight = query.createWeight(searcher);
-    float sum = weight.sumOfSquaredWeights();
-    float norm = getSimilarity(searcher).queryNorm(sum);
-    weight.normalize(norm);
-    return weight;
+    if(frozen) {
+        return cachedWeight;
+    }
+    cachedWeight = createWeight(similarity, dfSource);
+    float sum = cachedWeight.sumOfSquaredWeights();
+    float norm = similarity.queryNorm(sum);
+    cachedWeight.normalize(norm);
+    return cachedWeight;
+  }
+
+  /**
+   * Expert: if a query is set to frozen, it returns always a precomputed
+   * weight instead of creating a new one. Precondition: weight() has to
+   * be called before freezing a query.
+   */
+  public void setFrozen(boolean frozen) {
+      if(frozen && cachedWeight==null){
+          throw new IllegalStateException("can't freeze query before calculating cachedWeight");
+      }
+      this.frozen = frozen;
+  }
+
+  /**
+   * Expert: returns true if query is frozen (see {@link #setFrozen(boolean)})
+   */
+  public boolean isFrozen() {
+    return frozen;
+  }
+
+  /**
+   * Expert: adds all terms occuring in this query to the terms set
+   */
+  public void extractTerms(Set terms) {
+    // needs to be implemented by query subclasses
+    throw new UnsupportedOperationException();
   }

   /** Expert: called to re-write queries into primitive queries. */
@@ -104,11 +138,16 @@
   /** Expert: called when re-writing queries under MultiSearcher.
    *
    * <p>Only implemented by derived queries, with no
-   * {@link #createWeight(Searcher)} implementatation.
+   * {@link #createWeight(Similarity, DfSource)} implementatation.
    */
   public Query combine(Query[] queries) {
-    throw new UnsupportedOperationException();
-  }
+        for (int i = 0; i < queries.length; i++) {
+            if (!this.equals(queries[i])) {
+                throw new IllegalArgumentException();
+            }
+        }
+        return this;
+  }


   /** Expert: merges the clauses of a set of BooleanQuery's into a single
Index: src/java/org/apache/lucene/search/RemoteSearchable.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/RemoteSearchable.java,v
retrieving revision 1.6
diff -u -r1.6 RemoteSearchable.java
--- src/java/org/apache/lucene/search/RemoteSearchable.java	29 Mar 2004 22:48:03 -0000	1.6
+++ src/java/org/apache/lucene/search/RemoteSearchable.java	18 Feb 2005 11:17:06 -0000
@@ -51,6 +51,11 @@
   public int docFreq(Term term) throws IOException {
     return local.docFreq(term);
   }
+
+
+  public int[] docFreqs(Term[] terms) throws IOException {
+    return local.docFreqs(terms);
+  }

   public int maxDoc() throws IOException {
     return local.maxDoc();
Index: src/java/org/apache/lucene/search/Searchable.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/Searchable.java,v
retrieving revision 1.13
diff -u -r1.13 Searchable.java
--- src/java/org/apache/lucene/search/Searchable.java	14 Dec 2004 19:00:01 -0000	1.13
+++ src/java/org/apache/lucene/search/Searchable.java	18 Feb 2005 11:17:06 -0000
@@ -27,7 +27,7 @@
  * <p>Implementations provide search over a single index, over multiple
  * indices, and over indices on remote servers.
  */
-public interface Searchable extends java.rmi.Remote {
+public interface Searchable extends DocFreqSource, java.rmi.Remote {
   /** Lower-level search API.
    *
    * <p>{@link HitCollector#collect(int,float)} is called for every non-zero
@@ -52,18 +52,6 @@
    */
   void close() throws IOException;

-  /** Expert: Returns the number of documents containing <code>term</code>.
-   * Called by search code to compute term weights.
-   * @see IndexReader#docFreq(Term)
-   */
-  int docFreq(Term term) throws IOException;
-
-  /** Expert: Returns one greater than the largest possible document number.
-   * Called by search code to compute term weights.
-   * @see IndexReader#maxDoc()
-   */
-  int maxDoc() throws IOException;
-
   /** Expert: Low-level search implementation.  Finds the top <code>n</code>
    * hits for <code>query</code>, applying <code>filter</code> if non-null.
    *
Index: src/java/org/apache/lucene/search/Searcher.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/Searcher.java,v
retrieving revision 1.13
diff -u -r1.13 Searcher.java
--- src/java/org/apache/lucene/search/Searcher.java	14 Dec 2004 19:00:01 -0000	1.13
+++ src/java/org/apache/lucene/search/Searcher.java	18 Feb 2005 11:17:06 -0000
@@ -18,6 +18,8 @@

 import java.io.IOException;

+import org.apache.lucene.index.Term;
+
 /** An abstract base class for search implementations.
  * Implements some common utility methods.
  */
@@ -93,4 +95,15 @@
   public Similarity getSimilarity() {
     return this.similarity;
   }
+
+
+  // inherit javadoc
+  public int[] docFreqs(Term[] terms) throws IOException {
+    int[] result = new int[terms.length];
+    for (int i = 0; i < terms.length; i++) {
+      result[i] = docFreq(terms[i]);
+    }
+    return result;
+  }
+
 }
Index: src/java/org/apache/lucene/search/Similarity.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/Similarity.java,v
retrieving revision 1.17
diff -u -r1.17 Similarity.java
--- src/java/org/apache/lucene/search/Similarity.java	27 Oct 2004 21:59:02 -0000	1.17
+++ src/java/org/apache/lucene/search/Similarity.java	18 Feb 2005 11:17:06 -0000
@@ -17,13 +17,10 @@
  */

 import java.io.IOException;
-
-import java.util.Collection;
-import java.util.Iterator;
+import java.io.Serializable;

 import org.apache.lucene.index.Term;

-import org.apache.lucene.index.IndexReader;       // for javadoc
 import org.apache.lucene.index.IndexWriter;       // for javadoc
 import org.apache.lucene.document.Field;          // for javadoc

@@ -84,7 +81,7 @@
  * @see IndexWriter#setSimilarity(Similarity)
  * @see Searcher#setSimilarity(Similarity)
  */
-public abstract class Similarity {
+public abstract class Similarity implements Serializable {
   /** The Similarity implementation used by default. */
   private static Similarity defaultImpl = new DefaultSimilarity();

@@ -266,42 +263,23 @@
    */
   public abstract float tf(float freq);

-  /** Computes a score factor for a simple term.
-   *
-   * <p>The default implementation is:<pre>
-   *   return idf(searcher.docFreq(term), searcher.maxDoc());
-   * </pre>
-   *
-   * Note that {@link Searcher#maxDoc()} is used instead of
-   * {@link IndexReader#numDocs()} because it is proportional to
-   * {@link Searcher#docFreq(Term)} , i.e., when one is inaccurate,
-   * so is the other, and in the same direction.
-   *
-   * @param term the term in question
-   * @param searcher the document collection being searched
-   * @return a score factor for the term
-   */
-  public float idf(Term term, Searcher searcher) throws IOException {
-    return idf(searcher.docFreq(term), searcher.maxDoc());
-  }

   /** Computes a score factor for a phrase.
    *
    * <p>The default implementation sums the {@link #idf(Term,Searcher)} factor
    * for each term in the phrase.
    *
-   * @param terms the terms in the phrase
-   * @param searcher the document collection being searched
+   * @param docFreqs the term document frequencies in the phrase
+   * @param numDocs the total number of documents in the collection
    * @return a score factor for the phrase
    */
-  public float idf(Collection terms, Searcher searcher) throws IOException {
+  public float idf(int docFreqs[], int numDocs) throws IOException {
     float idf = 0.0f;
-    Iterator i = terms.iterator();
-    while (i.hasNext()) {
-      idf += idf((Term)i.next(), searcher);
+    for(int i=0; i<docFreqs.length; i++){
+      idf += idf(docFreqs[i], numDocs);
     }
     return idf;
-  }
+  }

   /** Computes a score factor based on a term's document frequency (the number
    * of documents which contain the term).  This value is multiplied by the
Index: src/java/org/apache/lucene/search/TermQuery.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/TermQuery.java,v
retrieving revision 1.13
diff -u -r1.13 TermQuery.java
--- src/java/org/apache/lucene/search/TermQuery.java	6 Sep 2004 22:09:13 -0000	1.13
+++ src/java/org/apache/lucene/search/TermQuery.java	18 Feb 2005 11:17:06 -0000
@@ -17,6 +17,8 @@
  */

 import java.io.IOException;
+import java.util.Set;
+
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermDocs;
 import org.apache.lucene.index.IndexReader;
@@ -28,14 +30,17 @@
   private Term term;

   private class TermWeight implements Weight {
-    private Searcher searcher;
+    private Similarity similarity;
     private float value;
     private float idf;
     private float queryNorm;
     private float queryWeight;

-    public TermWeight(Searcher searcher) {
-      this.searcher = searcher;
+    public TermWeight(Similarity similarity, DocFreqSource dfSource)
+      throws IOException {
+      this.similarity = similarity;
+      int df = dfSource.docFreq(term);
+      this.idf = similarity.idf(df, dfSource.maxDoc()); // compute idf
     }

     public String toString() { return "weight(" + TermQuery.this + ")"; }
@@ -44,7 +49,6 @@
     public float getValue() { return value; }

     public float sumOfSquaredWeights() throws IOException {
-      idf = getSimilarity(searcher).idf(term, searcher); // compute idf
       queryWeight = idf * getBoost();             // compute query weight
       return queryWeight * queryWeight;           // square it
     }
@@ -61,7 +65,7 @@
       if (termDocs == null)
         return null;

-      return new TermScorer(this, termDocs, getSimilarity(searcher),
+      return new TermScorer(this, termDocs, similarity,
                             reader.norms(term.field()));
     }

@@ -72,7 +76,7 @@
       result.setDescription("weight("+getQuery()+" in "+doc+"), product of:");

       Explanation idfExpl =
-        new Explanation(idf, "idf(docFreq=" + searcher.docFreq(term) + ")");
+        new Explanation(idf, "idf(docFreq=" + reader.docFreq(term) + ")");

       // explain query weight
       Explanation queryExpl = new Explanation();
@@ -134,8 +138,12 @@
   /** Returns the term of this query. */
   public Term getTerm() { return term; }

-  protected Weight createWeight(Searcher searcher) {
-    return new TermWeight(searcher);
+  protected Weight createWeight(Similarity similarity, DocFreqSource dfSource) throws IOException {
+    return new TermWeight(similarity, dfSource);
+  }
+
+  public void extractTerms(Set terms) {
+    terms.add(getTerm());
   }

   /** Prints a user-readable version of this query. */
Index: src/java/org/apache/lucene/search/Weight.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/Weight.java,v
retrieving revision 1.5
diff -u -r1.5 Weight.java
--- src/java/org/apache/lucene/search/Weight.java	10 Oct 2004 18:43:18 -0000	1.5
+++ src/java/org/apache/lucene/search/Weight.java	18 Feb 2005 11:17:06 -0000
@@ -24,7 +24,7 @@
  * <br>A <code>Weight</code> is used in the following way:
  * <ol>
  * <li>A <code>Weight</code> is constructed by a top-level query,
- *     given a <code>Searcher</code> ({@link Query#createWeight(Searcher)}).
+ *     given a <code>Searcher</code> ({@link Query#createWeight(Similarity, DfSource)}).
  * <li>The {@link #sumOfSquaredWeights()} method is called
  *     on the <code>Weight</code> to compute
  *     the query normalization factor {@link Similarity#queryNorm(float)}
Index: src/java/org/apache/lucene/search/spans/SpanQuery.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/spans/SpanQuery.java,v
retrieving revision 1.2
diff -u -r1.2 SpanQuery.java
--- src/java/org/apache/lucene/search/spans/SpanQuery.java	2 Feb 2004 13:27:52 -0000	1.2
+++ src/java/org/apache/lucene/search/spans/SpanQuery.java	18 Feb 2005 11:17:06 -0000
@@ -23,7 +23,8 @@
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Weight;
-import org.apache.lucene.search.Searcher;
+import org.apache.lucene.search.Similarity;
+import org.apache.lucene.search.DocFreqSource;

 /** Base class for span-based queries. */
 public abstract class SpanQuery extends Query {
@@ -37,8 +38,8 @@
   /** Returns a collection of all terms matched by this query.*/
   public abstract Collection getTerms();

-  protected Weight createWeight(Searcher searcher) {
-    return new SpanWeight(this, searcher);
+  protected Weight createWeight(Similarity similarity, DocFreqSource dfSource) throws IOException {
+    return new SpanWeight(this, similarity, dfSource);
   }

 }
Index: src/java/org/apache/lucene/search/spans/SpanWeight.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/search/spans/SpanWeight.java,v
retrieving revision 1.3
diff -u -r1.3 SpanWeight.java
--- src/java/org/apache/lucene/search/spans/SpanWeight.java	6 Feb 2004 19:19:20 -0000	1.3
+++ src/java/org/apache/lucene/search/spans/SpanWeight.java	18 Feb 2005 11:17:06 -0000
@@ -26,13 +26,13 @@

 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Weight;
-import org.apache.lucene.search.Searcher;
+import org.apache.lucene.search.DocFreqSource;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.Similarity;

 class SpanWeight implements Weight {
-  private Searcher searcher;
+  private Similarity similarity;
   private float value;
   private float idf;
   private float queryNorm;
@@ -41,17 +41,28 @@
   private Collection terms;
   private SpanQuery query;

-  public SpanWeight(SpanQuery query, Searcher searcher) {
-    this.searcher = searcher;
+  public SpanWeight(SpanQuery query, Similarity similarity, DocFreqSource dfSource)
+    throws IOException {
+    this.similarity = similarity;
     this.query = query;
     this.terms = query.getTerms();
+
+    // compute idf
+    int[] docFreqs = new int[terms.size()];
+    int j=0;
+    for (Iterator i = terms.iterator(); i.hasNext();) {
+      Term term = (Term) i.next();
+      docFreqs[j] = dfSource.docFreq(term);
+      j++;
+    }
+
+    idf = similarity.idf(docFreqs, dfSource.maxDoc());
   }

   public Query getQuery() { return query; }
   public float getValue() { return value; }

   public float sumOfSquaredWeights() throws IOException {
-    idf = this.query.getSimilarity(searcher).idf(terms, searcher);
     queryWeight = idf * query.getBoost();         // compute query weight
     return queryWeight * queryWeight;             // square it
   }
@@ -64,7 +75,7 @@

   public Scorer scorer(IndexReader reader) throws IOException {
     return new SpanScorer(query.getSpans(reader), this,
-                          query.getSimilarity(searcher),
+                          similarity,
                           reader.norms(query.getField()));
   }

@@ -81,7 +92,7 @@
       Term term = (Term)i.next();
       docFreqs.append(term.text());
       docFreqs.append("=");
-      docFreqs.append(searcher.docFreq(term));
+      docFreqs.append(reader.docFreq(term));

       if (i.hasNext()) {
         docFreqs.append(" ");
Index: src/test/org/apache/lucene/search/TestSimilarity.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/test/org/apache/lucene/search/TestSimilarity.java,v
retrieving revision 1.7
diff -u -r1.7 TestSimilarity.java
--- src/test/org/apache/lucene/search/TestSimilarity.java	7 Sep 2004 18:26:36 -0000	1.7
+++ src/test/org/apache/lucene/search/TestSimilarity.java	18 Feb 2005 11:17:06 -0000
@@ -43,7 +43,7 @@
     public float queryNorm(float sumOfSquaredWeights) { return 1.0f; }
     public float tf(float freq) { return freq; }
     public float sloppyFreq(int distance) { return 2.0f; }
-    public float idf(Collection terms, Searcher searcher) { return 1.0f; }
+    public float idf(int[] docFreqs, int numDocs) { return 1.0f; }
     public float idf(int docFreq, int numDocs) { return 1.0f; }
     public float coord(int overlap, int maxOverlap) { return 1.0f; }
   }
Index: src/test/org/apache/lucene/search/TestSort.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/test/org/apache/lucene/search/TestSort.java,v
retrieving revision 1.8
diff -u -r1.8 TestSort.java
--- src/test/org/apache/lucene/search/TestSort.java	30 Aug 2004 20:52:15 -0000	1.8
+++ src/test/org/apache/lucene/search/TestSort.java	18 Feb 2005 11:17:06 -0000
@@ -344,12 +344,9 @@
 		HashMap scoresA = getScores (full.search (queryA));

 		// we'll test searching locally, remote and multi
-		// note: the multi test depends on each separate index containing
-		// the same documents as our local index, so the computed normalization
-		// will be the same.  so we make a multi searcher over two equal document
-		// sets - not realistic, but necessary for testing.
 		MultiSearcher remote = new MultiSearcher (new Searchable[] { getRemote() });
-		MultiSearcher multi  = new MultiSearcher (new Searchable[] { full, full });
+		// multi is not really multi, but tests the MultiSearcher handling
+		MultiSearcher multi  = new MultiSearcher (new Searchable[] { full });

 		// change sorting and make sure relevancy stays the same

Index: src/test/org/apache/lucene/search/TestTermVectors.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/test/org/apache/lucene/search/TestTermVectors.java,v
retrieving revision 1.5
diff -u -r1.5 TestTermVectors.java
--- src/test/org/apache/lucene/search/TestTermVectors.java	5 Oct 2004 17:30:48 -0000	1.5
+++ src/test/org/apache/lucene/search/TestTermVectors.java	18 Feb 2005 11:17:06 -0000
@@ -226,7 +226,8 @@
           //System.out.println("Doc Id: " + docId + " freq " + freq);
           TermFreqVector vector = knownSearcher.reader.getTermFreqVector(docId, "field");
           float tf = sim.tf(freq);
-          float idf = sim.idf(term, knownSearcher);
+          int df = knownSearcher.docFreq(term);
+          float idf = sim.idf(df, knownSearcher.maxDoc());
           //float qNorm = sim.queryNorm()
           //This is fine since we don't have stop words
           float lNorm = sim.lengthNorm("field", vector.getTerms().length);
Index: src/java/org/apache/lucene/search/DocFreqSource.java
===================================================================
RCS file: src/java/org/apache/lucene/search/DocFreqSource.java
diff -N src/java/org/apache/lucene/search/DocFreqSource.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ src/java/org/apache/lucene/search/DocFreqSource.java	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,46 @@
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.search;
+
+import java.io.IOException;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+
+/**
+ * Expert: Abstraction for any source of document frequency values.
+ * Also provides number of documents.
+ */
+public interface DocFreqSource {
+    /** Expert: Returns the number of documents containing <code>term</code>.
+     * Called by search code to compute term weights.
+     * @see IndexReader#docFreq(Term)
+     */
+    public int docFreq(Term term) throws IOException;
+
+    /** Expert: For each term in the terms array, calculates the number of
+     * documents containing <code>term</code>. Returns an array with these
+     * document frequencies. Used to minimize number of remote calls.
+     */
+    int[] docFreqs(Term[] terms) throws IOException;
+
+    /** Expert: Returns one greater than the largest possible document number.
+     * Called by search code to compute term weights.
+     * @see IndexReader#maxDoc()
+     */
+    public int maxDoc() throws IOException;
+}
