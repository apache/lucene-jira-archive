diff --git a/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java b/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
index 022fcd2..917f80b 100644
--- a/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
+++ b/lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
@@ -1025,6 +1025,7 @@ public class MemoryIndex {
   private final class MemoryIndexReader extends LeafReader {
 
     private final PointValues pointValues;
+    private Fields memoryFields = new MemoryFields(fields);
 
     private MemoryIndexReader() {
       super(); // avoid as much superclass baggage as possible
@@ -1178,13 +1179,7 @@ public class MemoryIndex {
 
     @Override
     public Fields fields() {
-      Map<String, Info> filteredFields = fields.entrySet().stream()
-          .filter(entry ->  entry.getValue().numTokens > 0)
-          .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,
-              (u,v) -> { throw new IllegalStateException(String.format(Locale.ROOT, "Duplicate key %s", u));},
-              TreeMap::new
-          ));
-      return new MemoryFields(filteredFields );
+      return memoryFields;
     }
 
     private class MemoryFields extends Fields {
@@ -1197,13 +1192,16 @@ public class MemoryIndex {
 
       @Override
       public Iterator<String> iterator() {
-        return fields.keySet().iterator();
+        return fields.entrySet().stream()
+            .filter(e -> e.getValue().numTokens > 0)
+            .map(Map.Entry::getKey)
+            .iterator();
       }
 
       @Override
       public Terms terms(final String field) {
         final Info info = fields.get(field);
-        if (info == null) {
+        if (info == null || info.numTokens <= 0) {
           return null;
         }
 
@@ -1258,7 +1256,11 @@ public class MemoryIndex {
 
       @Override
       public int size() {
-        return fields.size();
+        int size = 0;
+        for (String ignored : this) {
+          size++;
+        }
+        return size;
       }
     }
 
diff --git a/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndex.java b/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndex.java
index 1010c13..9e80c84 100644
--- a/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndex.java
+++ b/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndex.java
@@ -48,6 +48,7 @@ import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.BinaryDocValues;
 import org.apache.lucene.index.DocValuesType;
 import org.apache.lucene.index.FieldInvertState;
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.NumericDocValues;
@@ -135,6 +136,19 @@ public class TestMemoryIndex extends LuceneTestCase {
     assertEquals("be", terms.term().utf8ToString());
     TestUtil.checkReader(reader);
   }
+
+  public void testFieldsOnlyReturnsIndexedFields() throws IOException {
+    Document doc = new Document();
+
+    doc.add(new NumericDocValuesField("numeric", 29L));
+    doc.add(new TextField("text", "some text", Field.Store.NO));
+
+    MemoryIndex mi = MemoryIndex.fromDocument(doc, analyzer);
+    IndexSearcher searcher = mi.createSearcher();
+    IndexReader reader = searcher.getIndexReader();
+
+    assertEquals(reader.getTermVectors(0).size(), 1);
+  }
   
   public void testReaderConsistency() throws IOException {
     Analyzer analyzer = new MockPayloadAnalyzer();
