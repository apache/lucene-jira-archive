Index: lucene/analysis/common/src/test/org/apache/lucene/analysis/compound/TestCompoundWordTokenFilter.java
===================================================================
--- lucene/analysis/common/src/test/org/apache/lucene/analysis/compound/TestCompoundWordTokenFilter.java	(revision 1688537)
+++ lucene/analysis/common/src/test/org/apache/lucene/analysis/compound/TestCompoundWordTokenFilter.java	(working copy)
@@ -20,6 +20,7 @@
 import java.io.IOException;
 import java.io.Reader;
 import java.io.StringReader;
+import java.lang.invoke.MethodHandles;
 import java.util.Arrays;
 
 import org.apache.lucene.analysis.Analyzer;
@@ -268,19 +269,29 @@
   }
 
   public static final class MockRetainAttributeImpl extends AttributeImpl implements MockRetainAttribute {
+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+    
     private boolean retain = false;
+    
+    public MockRetainAttributeImpl() {
+      super(LOOKUP);
+    }
+    
     @Override
     public void clear() {
       retain = false;
     }
+    
     @Override
     public boolean getRetain() {
       return retain;
     }
+    
     @Override
     public void setRetain(boolean retain) {
       this.retain = retain;
     }
+    
     @Override
     public void copyTo(AttributeImpl target) {
       MockRetainAttribute t = (MockRetainAttribute) target;
Index: lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/tokenattributes/BaseFormAttributeImpl.java
===================================================================
--- lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/tokenattributes/BaseFormAttributeImpl.java	(revision 1688537)
+++ lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/tokenattributes/BaseFormAttributeImpl.java	(working copy)
@@ -26,6 +26,7 @@
  */
 public class BaseFormAttributeImpl extends AttributeImpl implements BaseFormAttribute, Cloneable {
   private Token token;
+
   
   @Override
   public String getBaseForm() {
Index: lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/tokenattributes/InflectionAttributeImpl.java
===================================================================
--- lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/tokenattributes/InflectionAttributeImpl.java	(revision 1688537)
+++ lucene/analysis/kuromoji/src/java/org/apache/lucene/analysis/ja/tokenattributes/InflectionAttributeImpl.java	(working copy)
@@ -17,6 +17,8 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandles;
+
 import org.apache.lucene.analysis.ja.Token;
 import org.apache.lucene.analysis.ja.util.ToStringUtil;
 import org.apache.lucene.util.AttributeImpl;
@@ -26,8 +28,14 @@
  * Attribute for Kuromoji inflection data.
  */
 public class InflectionAttributeImpl extends AttributeImpl implements InflectionAttribute, Cloneable {
+  private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+  
   private Token token;
   
+  public InflectionAttributeImpl() {
+    super(LOOKUP);
+  }
+
   @Override
   public String getInflectionType() {
     return token == null ? null : token.getInflectionType();
Index: lucene/analysis/morfologik/src/java/org/apache/lucene/analysis/morfologik/MorphosyntacticTagsAttributeImpl.java
===================================================================
--- lucene/analysis/morfologik/src/java/org/apache/lucene/analysis/morfologik/MorphosyntacticTagsAttributeImpl.java	(revision 1688537)
+++ lucene/analysis/morfologik/src/java/org/apache/lucene/analysis/morfologik/MorphosyntacticTagsAttributeImpl.java	(working copy)
@@ -18,6 +18,7 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandles;
 import java.util.*;
 
 import org.apache.lucene.util.AttributeImpl;
@@ -28,9 +29,13 @@
  */
 public class MorphosyntacticTagsAttributeImpl extends AttributeImpl 
   implements MorphosyntacticTagsAttribute, Cloneable {
+  private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
   
+  
   /** Initializes this attribute with no tags */
-  public MorphosyntacticTagsAttributeImpl() {}
+  public MorphosyntacticTagsAttributeImpl() {
+    super(LOOKUP);
+  }
   
   /**
    * A list of potential tag variants for the current token.
@@ -96,9 +101,5 @@
     this.copyTo(cloned);
     return cloned;
   }
-  
-  @Override
-  public String toString() {
-    return tags == null ? "<no tags>" : tags.toString();
-  }
+
 }
Index: lucene/codecs/src/test/org/apache/lucene/codecs/autoprefix/TestAutoPrefixTerms.java
===================================================================
--- lucene/codecs/src/test/org/apache/lucene/codecs/autoprefix/TestAutoPrefixTerms.java	(revision 1688537)
+++ lucene/codecs/src/test/org/apache/lucene/codecs/autoprefix/TestAutoPrefixTerms.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import java.io.IOException;
+import java.lang.invoke.MethodHandles;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -59,6 +60,7 @@
 import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.AttributeImpl;
+import org.apache.lucene.util.AttributeReflector;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.FixedBitSet;
@@ -559,6 +561,11 @@
         ByteTermAttributeImpl other = (ByteTermAttributeImpl) target;
         other.bytes = bytes;
       }
+      
+      @Override
+      public void reflectWith(AttributeReflector reflector) {
+        reflector.reflect(TermToBytesRefAttribute.class, "bytes", bytes);
+      }
     }
   }
 
Index: lucene/core/src/java/org/apache/lucene/analysis/NumericTokenStream.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/analysis/NumericTokenStream.java	(revision 1688537)
+++ lucene/core/src/java/org/apache/lucene/analysis/NumericTokenStream.java	(working copy)
@@ -17,6 +17,7 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandles;
 import java.util.Objects;
 
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
@@ -146,6 +147,8 @@
    * @since 4.0
    */
   public static final class NumericTermAttributeImpl extends AttributeImpl implements NumericTermAttribute,TermToBytesRefAttribute {
+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+    
     private long value = 0L;
     private int valueSize = 0, shift = 0, precisionStep = 0;
     private BytesRefBuilder bytes = new BytesRefBuilder();
@@ -154,7 +157,9 @@
      * Creates, but does not yet initialize this attribute instance
      * @see #init(long, int, int, int)
      */
-    public NumericTermAttributeImpl() {}
+    public NumericTermAttributeImpl() {
+      super(LOOKUP);
+    }
 
     @Override
     public BytesRef getBytesRef() {
Index: lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/FlagsAttributeImpl.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/FlagsAttributeImpl.java	(revision 1688537)
+++ lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/FlagsAttributeImpl.java	(working copy)
@@ -17,14 +17,20 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandles;
+
 import org.apache.lucene.util.AttributeImpl;
 
 /** Default implementation of {@link FlagsAttribute}. */
 public class FlagsAttributeImpl extends AttributeImpl implements FlagsAttribute, Cloneable {
+  private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+  
   private int flags = 0;
   
   /** Initialize this attribute with no bits set */
-  public FlagsAttributeImpl() {}
+  public FlagsAttributeImpl() {
+    super(LOOKUP);
+  }
   
   @Override
   public int getFlags() {
Index: lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/KeywordAttributeImpl.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/KeywordAttributeImpl.java	(revision 1688537)
+++ lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/KeywordAttributeImpl.java	(working copy)
@@ -17,15 +17,20 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandles;
+
 import org.apache.lucene.util.AttributeImpl;
 
 /** Default implementation of {@link KeywordAttribute}. */
-public final class KeywordAttributeImpl extends AttributeImpl implements
-    KeywordAttribute {
+public final class KeywordAttributeImpl extends AttributeImpl implements KeywordAttribute {
+  private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+  
   private boolean keyword;
   
   /** Initialize this attribute with the keyword value as false. */
-  public KeywordAttributeImpl() {}
+  public KeywordAttributeImpl() {
+    super(LOOKUP);
+  }
 
   @Override
   public void clear() {
Index: lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/OffsetAttributeImpl.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/OffsetAttributeImpl.java	(revision 1688537)
+++ lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/OffsetAttributeImpl.java	(working copy)
@@ -17,15 +17,21 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandles;
+
 import org.apache.lucene.util.AttributeImpl;
 
 /** Default implementation of {@link OffsetAttribute}. */
 public class OffsetAttributeImpl extends AttributeImpl implements OffsetAttribute, Cloneable {
+  private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+  
   private int startOffset;
   private int endOffset;
   
   /** Initialize this attribute with startOffset and endOffset of 0. */
-  public OffsetAttributeImpl() {}
+  public OffsetAttributeImpl() {
+    super(LOOKUP);
+  }
 
   @Override
   public int startOffset() {
Index: lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/PayloadAttributeImpl.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/PayloadAttributeImpl.java	(revision 1688537)
+++ lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/PayloadAttributeImpl.java	(working copy)
@@ -17,22 +17,29 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandles;
+
 import org.apache.lucene.util.AttributeImpl;
 import org.apache.lucene.util.BytesRef;
 
 /** Default implementation of {@link PayloadAttribute}. */
 public class PayloadAttributeImpl extends AttributeImpl implements PayloadAttribute, Cloneable {
+  private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+  
   private BytesRef payload;  
   
   /**
    * Initialize this attribute with no payload.
    */
-  public PayloadAttributeImpl() {}
+  public PayloadAttributeImpl() {
+    this(null);
+  }
   
   /**
    * Initialize this attribute with the given payload. 
    */
   public PayloadAttributeImpl(BytesRef payload) {
+    super(LOOKUP);
     this.payload = payload;
   }
   
Index: lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/PositionIncrementAttributeImpl.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/PositionIncrementAttributeImpl.java	(revision 1688537)
+++ lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/PositionIncrementAttributeImpl.java	(working copy)
@@ -17,14 +17,20 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandles;
+
 import org.apache.lucene.util.AttributeImpl;
 
 /** Default implementation of {@link PositionIncrementAttribute}. */
 public class PositionIncrementAttributeImpl extends AttributeImpl implements PositionIncrementAttribute, Cloneable {
+  private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+  
   private int positionIncrement = 1;
   
   /** Initialize this attribute with position increment of 1 */
-  public PositionIncrementAttributeImpl() {}
+  public PositionIncrementAttributeImpl() {
+    super(LOOKUP);
+  }
 
   @Override
   public void setPositionIncrement(int positionIncrement) {
Index: lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/PositionLengthAttributeImpl.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/PositionLengthAttributeImpl.java	(revision 1688537)
+++ lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/PositionLengthAttributeImpl.java	(working copy)
@@ -17,14 +17,20 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandles;
+
 import org.apache.lucene.util.AttributeImpl;
 
 /** Default implementation of {@link PositionLengthAttribute}. */
 public class PositionLengthAttributeImpl extends AttributeImpl implements PositionLengthAttribute, Cloneable {
+  private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+  
   private int positionLength = 1;
   
   /** Initializes this attribute with position length of 1. */
-  public PositionLengthAttributeImpl() {}
+  public PositionLengthAttributeImpl() {
+    super(LOOKUP);
+  }
   
   @Override
   public void setPositionLength(int positionLength) {
Index: lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/TypeAttributeImpl.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/TypeAttributeImpl.java	(revision 1688537)
+++ lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/TypeAttributeImpl.java	(working copy)
@@ -17,10 +17,14 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandles;
+
 import org.apache.lucene.util.AttributeImpl;
 
 /** Default implementation of {@link TypeAttribute}. */
 public class TypeAttributeImpl extends AttributeImpl implements TypeAttribute, Cloneable {
+  private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+  
   private String type;
   
   /** Initialize this attribute with {@link TypeAttribute#DEFAULT_TYPE} */
@@ -30,6 +34,7 @@
   
   /** Initialize this attribute with <code>type</code> */
   public TypeAttributeImpl(String type) {
+    super(LOOKUP);
     this.type = type;
   }
   
Index: lucene/core/src/java/org/apache/lucene/document/Field.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/document/Field.java	(revision 1688537)
+++ lucene/core/src/java/org/apache/lucene/document/Field.java	(working copy)
@@ -34,6 +34,7 @@
 import org.apache.lucene.index.IndexableFieldType;
 import org.apache.lucene.index.StorableField;
 import org.apache.lucene.util.AttributeImpl;
+import org.apache.lucene.util.AttributeReflector;
 import org.apache.lucene.util.BytesRef;
 
 /**
@@ -601,6 +602,7 @@
       public void setBytesRef(BytesRef bytes);
     }
   
+    @SuppressWarnings("unused")
     public static class ByteTermAttributeImpl extends AttributeImpl implements ByteTermAttribute, TermToBytesRefAttribute {
       private BytesRef bytes;
     
@@ -624,6 +626,11 @@
       }
     
       @Override
+      public void reflectWith(AttributeReflector reflector) {
+        reflector.reflect(TermToBytesRefAttribute.class, "bytes", bytes);
+      }
+
+      @Override
       public void copyTo(AttributeImpl target) {
         ByteTermAttributeImpl other = (ByteTermAttributeImpl) target;
         other.bytes = bytes;
Index: lucene/core/src/java/org/apache/lucene/search/BoostAttributeImpl.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/BoostAttributeImpl.java	(revision 1688537)
+++ lucene/core/src/java/org/apache/lucene/search/BoostAttributeImpl.java	(working copy)
@@ -17,14 +17,22 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandles;
+
 import org.apache.lucene.util.AttributeImpl;
 
 /** Implementation class for {@link BoostAttribute}.
  * @lucene.internal
  */
 public final class BoostAttributeImpl extends AttributeImpl implements BoostAttribute {
+  private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+  
   private float boost = 1.0f;
 
+  public BoostAttributeImpl() {
+    super(LOOKUP);
+  }
+
   @Override
   public void setBoost(float boost) {
     this.boost = boost;
Index: lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java	(revision 1688537)
+++ lucene/core/src/java/org/apache/lucene/search/FuzzyTermsEnum.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import java.io.IOException;
+import java.lang.invoke.MethodHandles;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.List;
@@ -391,8 +392,14 @@
    * Stores compiled automata as a list (indexed by edit distance)
    * @lucene.internal */
   public static final class LevenshteinAutomataAttributeImpl extends AttributeImpl implements LevenshteinAutomataAttribute {
+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+    
     private final List<CompiledAutomaton> automata = new ArrayList<>();
       
+    public LevenshteinAutomataAttributeImpl() {
+      super(LOOKUP);
+    }
+  
     @Override
     public List<CompiledAutomaton> automata() {
       return automata;
Index: lucene/core/src/java/org/apache/lucene/search/MaxNonCompetitiveBoostAttributeImpl.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/MaxNonCompetitiveBoostAttributeImpl.java	(revision 1688537)
+++ lucene/core/src/java/org/apache/lucene/search/MaxNonCompetitiveBoostAttributeImpl.java	(working copy)
@@ -17,6 +17,8 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandles;
+
 import org.apache.lucene.util.AttributeImpl;
 import org.apache.lucene.util.BytesRef;
 
@@ -24,9 +26,15 @@
  * @lucene.internal
  */
 public final class MaxNonCompetitiveBoostAttributeImpl extends AttributeImpl implements MaxNonCompetitiveBoostAttribute {
+  private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+  
   private float maxNonCompetitiveBoost = Float.NEGATIVE_INFINITY;
   private BytesRef competitiveTerm = null;
 
+  public MaxNonCompetitiveBoostAttributeImpl() {
+    super(LOOKUP);
+  }
+
   @Override
   public void setMaxNonCompetitiveBoost(final float maxNonCompetitiveBoost) {
     this.maxNonCompetitiveBoost = maxNonCompetitiveBoost;
Index: lucene/core/src/java/org/apache/lucene/util/AttributeImpl.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/AttributeImpl.java	(revision 1688537)
+++ lucene/core/src/java/org/apache/lucene/util/AttributeImpl.java	(working copy)
@@ -17,8 +17,15 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodHandles.Lookup;
+import java.lang.invoke.MethodType;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
 
 /**
  * Base class for Attributes that can be added to a 
@@ -27,8 +34,35 @@
  * Attributes are used to add data in a dynamic, yet type-safe way to a source
  * of usually streamed objects, e. g. a {@link org.apache.lucene.analysis.TokenStream}.
  */
-public abstract class AttributeImpl implements Cloneable, Attribute {  
+public abstract class AttributeImpl implements Cloneable, Attribute {
+  
+  private final Lookup reflectorLookup;
+  
   /**
+   * Default constructor.
+   * <p>You need to override {@link #reflectWith(AttributeReflector)} because automatic
+   * reflection only works with a {@link Lookup} object.
+   * @see #AttributeImpl(Lookup)
+   */
+  public AttributeImpl() {
+    this(null);
+  }
+  
+  /**
+   * Subclasses of {@code AttributeImpl} that want to use automatic reflection should
+   * call this constructor with a suitable {@link Lookup} object to access private fields.
+   * <p>A general code pattern is: {@code super(MethodHandles.lookup())}
+   */
+  protected AttributeImpl(Lookup reflectorLookup) {
+    this.reflectorLookup = reflectorLookup;
+    final Class<? extends AttributeImpl> clazz = this.getClass();
+    if (!( (reflectorLookup != null && reflectorLookup.lookupClass() == clazz) || REFLECT_WITH_VM.isOverriddenAsOf(clazz) )) {
+      throw new UnsupportedOperationException(clazz.getName() +
+          " does neither implement reflectWith() nor passes a suitable MethodHandles.Lookup to the super constructor to access its private fields.");
+    }
+  }
+
+  /**
    * Clears the values in this AttributeImpl and resets it to its 
    * default value. If this implementation implements more than one Attribute interface
    * it clears all.
@@ -71,7 +105,8 @@
    * non-static fields from the implementing class, using the field name as key
    * and the field value as value. The Attribute class is also determined by reflection.
    * Please note that the default implementation can only handle single-Attribute
-   * implementations.
+   * implementations. For this to work, you have to pass a {@link Lookup} when calling
+   * the super constructor: {@code super(MethodHandles.lookup())}
    *
    * <p>Custom implementations look like this (e.g. for a combined attribute implementation):
    * <pre class="prettyprint">
@@ -88,25 +123,12 @@
    * @see #reflectAsString(boolean)
    */
   public void reflectWith(AttributeReflector reflector) {
-    final Class<? extends AttributeImpl> clazz = this.getClass();
-    final Class<? extends Attribute>[] interfaces = AttributeSource.getAttributeInterfaces(clazz);
-    if (interfaces.length != 1) {
-      throw new UnsupportedOperationException(clazz.getName() +
-        " implements more than one Attribute interface, the default reflectWith() implementation cannot handle this.");
-    }
-    final Class<? extends Attribute> interf = interfaces[0];
-    final Field[] fields = clazz.getDeclaredFields();
-    try {
-      for (int i = 0; i < fields.length; i++) {
-        final Field f = fields[i];
-        if (Modifier.isStatic(f.getModifiers())) continue;
-        f.setAccessible(true);
-        reflector.reflect(interf, f.getName(), f.get(this));
+    for (final MethodHandle m : makeReflectors()) {
+      try {
+        m.invokeExact(reflector);
+      } catch (Throwable t) {
+        AttributeFactory.rethrow(t);
       }
-    } catch (IllegalAccessException e) {
-      // this should never happen, because we're just accessing fields
-      // from 'this'
-      throw new RuntimeException(e);
     }
   }
   
@@ -131,4 +153,50 @@
     }
     return clone;
   }
+  
+  private MethodHandle[] makeReflectors() {
+    MethodHandle[] ret = REFLECTOR_CACHE.get(this.getClass());
+    if (ret != null) {
+      return ret;
+    }
+    final Class<? extends AttributeImpl> clazz = this.getClass();
+    assert clazz == reflectorLookup.lookupClass();
+    final Class<? extends Attribute>[] interfaces = AttributeSource.getAttributeInterfaces(clazz);
+    if (interfaces.length != 1) {
+      throw new UnsupportedOperationException(clazz.getName() +
+        " implements more than one Attribute interface, the default reflectWith() implementation cannot handle this.");
+    }
+    final Class<? extends Attribute> interf = interfaces[0];
+    final Field[] fields = clazz.getDeclaredFields();
+    Arrays.sort(fields, (a,b) -> a.getName().compareToIgnoreCase(b.getName()));
+    final List<MethodHandle> reflectors = new ArrayList<>();
+    for (final Field f : fields) {
+      if (Modifier.isStatic(f.getModifiers())) continue;
+      try {
+        final MethodHandle fieldGetter = reflectorLookup.unreflectGetter(f).bindTo(this);
+        MethodHandle fieldReflector = REFLECT_METHOD;
+        fieldReflector = MethodHandles.insertArguments(fieldReflector, 1, interf);
+        fieldReflector = MethodHandles.insertArguments(fieldReflector, 1, f.getName());
+        fieldReflector = MethodHandles.collectArguments(fieldReflector, 1, fieldGetter.asType(fieldGetter.type().generic()));
+        reflectors.add(fieldReflector);
+      } catch (IllegalAccessException iae) {
+        throw new AssertionError("Cannot access private field.", iae);
+      }
+    }
+    ret = reflectors.toArray(new MethodHandle[reflectors.size()]);
+    REFLECTOR_CACHE.put(this.getClass(), ret);
+    return ret;
+  }
+  
+  private static final VirtualMethod<AttributeImpl> REFLECT_WITH_VM = new VirtualMethod<>(AttributeImpl.class, "reflectWith", AttributeReflector.class);
+  private static final WeakIdentityMap<Class<?>,MethodHandle[]> REFLECTOR_CACHE = WeakIdentityMap.newConcurrentHashMap();
+  private static final MethodHandle REFLECT_METHOD;
+  static {
+    try {
+      REFLECT_METHOD = MethodHandles.publicLookup().findVirtual(AttributeReflector.class, "reflect", MethodType.methodType(void.class, Class.class, String.class, Object.class));
+    } catch (NoSuchMethodException | IllegalAccessException e) {
+      throw new AssertionError(e);
+    }
+  }
+  
 }
Index: lucene/core/src/test/org/apache/lucene/analysis/TestToken.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/analysis/TestToken.java	(revision 1688537)
+++ lucene/core/src/test/org/apache/lucene/analysis/TestToken.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import org.apache.lucene.analysis.tokenattributes.*;
+import org.apache.lucene.util.AttributeReflector;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.Attribute;
 import org.apache.lucene.util.AttributeImpl;
@@ -94,6 +95,8 @@
     public boolean equals(Object o) { return (o instanceof SenselessAttributeImpl); }
     @Override
     public int hashCode() { return 0; }
+    @Override
+    public void reflectWith(AttributeReflector reflector) {}
   }
 
   public void testTokenAttributeFactory() throws Exception {
Index: lucene/core/src/test/org/apache/lucene/analysis/tokenattributes/TestSimpleAttributeImpl.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/analysis/tokenattributes/TestSimpleAttributeImpl.java	(revision 1688537)
+++ lucene/core/src/test/org/apache/lucene/analysis/tokenattributes/TestSimpleAttributeImpl.java	(working copy)
@@ -26,6 +26,7 @@
 public class TestSimpleAttributeImpl extends LuceneTestCase {
 
   // this checks using reflection API if the defaults are correct
+  @SuppressWarnings("serial")
   public void testAttributes() {
     TestUtil.assertAttributeReflection(new PositionIncrementAttributeImpl(),
         Collections.singletonMap(PositionIncrementAttribute.class.getName() + "#positionIncrement", 1));
Index: lucene/core/src/test/org/apache/lucene/index/BinaryTokenStream.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/BinaryTokenStream.java	(revision 1688537)
+++ lucene/core/src/test/org/apache/lucene/index/BinaryTokenStream.java	(working copy)
@@ -20,6 +20,7 @@
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.util.AttributeImpl;
+import org.apache.lucene.util.AttributeReflector;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.analysis.CannedBinaryTokenStream; // javadocs
 
@@ -82,5 +83,10 @@
       ByteTermAttributeImpl other = (ByteTermAttributeImpl) target;
       other.bytes = bytes;
     }
+    
+    @Override
+    public void reflectWith(AttributeReflector reflector) {
+      reflector.reflect(TermToBytesRefAttribute.class, "bytes", bytes);
+    }
   }
 }
Index: lucene/core/src/test/org/apache/lucene/index/Test2BTerms.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/Test2BTerms.java	(revision 1688537)
+++ lucene/core/src/test/org/apache/lucene/index/Test2BTerms.java	(working copy)
@@ -38,6 +38,7 @@
 import org.apache.lucene.util.Attribute;
 import org.apache.lucene.util.AttributeFactory;
 import org.apache.lucene.util.AttributeImpl;
+import org.apache.lucene.util.AttributeReflector;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase.Monster;
 import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
@@ -45,6 +46,7 @@
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
 import org.apache.lucene.util.TimeUnits;
+
 import com.carrotsearch.randomizedtesting.annotations.TimeoutSuite;
 
 // NOTE: SimpleText codec will consume very large amounts of
@@ -61,7 +63,7 @@
 
   private final static int TOKEN_LEN = 5;
 
-  private final static BytesRef bytes = new BytesRef(TOKEN_LEN);
+  final static BytesRef bytes = new BytesRef(TOKEN_LEN);
 
   private final static class MyTokenStream extends TokenStream {
 
@@ -140,6 +142,11 @@
       public MyTermAttributeImpl clone() {
         throw new UnsupportedOperationException();
       }
+      
+      @Override
+      public void reflectWith(AttributeReflector reflector) {
+        reflector.reflect(TermToBytesRefAttribute.class, "bytes", bytes);
+      }
     }
 
     private static final class MyAttributeFactory extends AttributeFactory {
Index: lucene/core/src/test/org/apache/lucene/search/TestPrefixQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestPrefixQuery.java	(revision 1688537)
+++ lucene/core/src/test/org/apache/lucene/search/TestPrefixQuery.java	(working copy)
@@ -34,6 +34,7 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.AttributeImpl;
+import org.apache.lucene.util.AttributeReflector;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.StringHelper;
@@ -147,6 +148,11 @@
         ByteTermAttributeImpl other = (ByteTermAttributeImpl) target;
         other.bytes = bytes;
       }
+
+      @Override
+      public void reflectWith(AttributeReflector reflector) {
+        reflector.reflect(TermToBytesRefAttribute.class, "bytes", bytes);
+      }
     }
   }
 
Index: lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/UniqueFieldAttributeImpl.java
===================================================================
--- lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/UniqueFieldAttributeImpl.java	(revision 1688537)
+++ lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/UniqueFieldAttributeImpl.java	(working copy)
@@ -17,6 +17,8 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandles;
+
 import org.apache.lucene.queryparser.flexible.core.nodes.FieldableNode;
 import org.apache.lucene.util.AttributeImpl;
 
@@ -27,12 +29,13 @@
  * 
  * @see UniqueFieldQueryNodeProcessor
  */
-public class UniqueFieldAttributeImpl extends AttributeImpl implements
-    UniqueFieldAttribute {
-
+public class UniqueFieldAttributeImpl extends AttributeImpl implements UniqueFieldAttribute {
+  private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+  
   private CharSequence uniqueField;
 
   public UniqueFieldAttributeImpl() {
+    super(LOOKUP);
     clear();
   }
 
Index: lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermsEnum.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermsEnum.java	(revision 1688537)
+++ lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermsEnum.java	(working copy)
@@ -17,6 +17,7 @@
  * limitations under the License.
  */
 
+import java.lang.invoke.MethodHandles;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
@@ -194,7 +195,13 @@
 
   @SuppressWarnings({"unchecked","rawtypes"})
   public static final class ComputedRangesAttributeImpl extends AttributeImpl implements ComputedRangesAttribute {
+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+    
     public final LinkedList<Range> rangeBounds = new LinkedList();
+    
+    public ComputedRangesAttributeImpl() {
+      super(LOOKUP);
+    }
 
     @Override
     public LinkedList<Range> ranges() {
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/BytesRefIteratorTokenStream.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/BytesRefIteratorTokenStream.java	(revision 1688537)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/BytesRefIteratorTokenStream.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import java.io.IOException;
+import java.lang.invoke.MethodHandles;
 
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
@@ -25,6 +26,7 @@
 import org.apache.lucene.util.Attribute;
 import org.apache.lucene.util.AttributeFactory;
 import org.apache.lucene.util.AttributeImpl;
+import org.apache.lucene.util.AttributeReflector;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefIterator;
 
@@ -53,10 +55,15 @@
     }
   }
 
-  private static final class BRTermToBytesRefAttributeImpl extends AttributeImpl
-      implements TermToBytesRefAttribute {
+  private static final class BRTermToBytesRefAttributeImpl extends AttributeImpl implements TermToBytesRefAttribute {
+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+    
     private final BytesRef bytes = new BytesRef();
 
+    public BRTermToBytesRefAttributeImpl() {
+      super(LOOKUP);
+    }
+
     void setBytesRef(BytesRef inputBytes) {
       // shallow clone.  this.bytesRef is final
       bytes.bytes = inputBytes.bytes;
Index: lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionTokenStream.java
===================================================================
--- lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionTokenStream.java	(revision 1688537)
+++ lucene/suggest/src/java/org/apache/lucene/search/suggest/document/CompletionTokenStream.java	(working copy)
@@ -30,6 +30,7 @@
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.util.AttributeImpl;
+import org.apache.lucene.util.AttributeReflector;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefBuilder;
 import org.apache.lucene.util.CharsRefBuilder;
@@ -330,13 +331,6 @@
     private final BytesRefBuilder bytes = new BytesRefBuilder();
     private CharsRefBuilder charsRef;
 
-    /**
-     * Sole constructor
-     * no-op
-     */
-    public ByteTermAttributeImpl() {
-    }
-
     @Override
     public void fillBytesRef() {
       // does nothing - we change in place
@@ -364,6 +358,11 @@
     }
 
     @Override
+    public void reflectWith(AttributeReflector reflector) {
+      reflector.reflect(TermToBytesRefAttribute.class, "bytes", bytes.toBytesRef());
+    }
+
+    @Override
     public CharSequence toUTF16() {
       if (charsRef == null) {
         charsRef = new CharsRefBuilder();
Index: lucene/test-framework/src/java/org/apache/lucene/analysis/BaseTokenStreamTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/analysis/BaseTokenStreamTestCase.java	(revision 1688537)
+++ lucene/test-framework/src/java/org/apache/lucene/analysis/BaseTokenStreamTestCase.java	(working copy)
@@ -23,6 +23,7 @@
 import java.io.StringReader;
 import java.io.StringWriter;
 import java.io.Writer;
+import java.lang.invoke.MethodHandles;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Paths;
@@ -73,8 +74,14 @@
    * for testing that clearAttributes() was called correctly.
    */
   public static final class CheckClearAttributesAttributeImpl extends AttributeImpl implements CheckClearAttributesAttribute {
+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+    
     private boolean clearCalled = false;
     
+    public CheckClearAttributesAttributeImpl() {
+      super(LOOKUP);
+    }
+
     @Override
     public boolean getAndResetClearCalled() {
       try {
Index: lucene/test-framework/src/java/org/apache/lucene/analysis/CannedBinaryTokenStream.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/analysis/CannedBinaryTokenStream.java	(revision 1688537)
+++ lucene/test-framework/src/java/org/apache/lucene/analysis/CannedBinaryTokenStream.java	(working copy)
@@ -22,6 +22,7 @@
 import org.apache.lucene.analysis.tokenattributes.PositionLengthAttribute;
 import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.util.AttributeImpl;
+import org.apache.lucene.util.AttributeReflector;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefBuilder;
 
@@ -73,6 +74,11 @@
     private final BytesRefBuilder bytes = new BytesRefBuilder();
 
     @Override
+    public void reflectWith(AttributeReflector reflector) {
+      reflector.reflect(TermToBytesRefAttribute.class, "bytes", bytes.toBytesRef());
+    }
+
+    @Override
     public void fillBytesRef() {
       bytes.get(); // sets the length on the bytesref
     }
Index: lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase.java	(revision 1688537)
+++ lucene/test-framework/src/java/org/apache/lucene/index/BaseTermVectorsFormatTestCase.java	(working copy)
@@ -25,6 +25,7 @@
 import static org.apache.lucene.index.PostingsEnum.POSITIONS;
 
 import java.io.IOException;
+import java.lang.invoke.MethodHandles;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.EnumSet;
@@ -121,8 +122,13 @@
 
   // custom impl to test cases that are forbidden by the default OffsetAttribute impl
   private static class PermissiveOffsetAttributeImpl extends AttributeImpl implements OffsetAttribute {
+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+    
+    private int start, end;
 
-    int start, end;
+    public PermissiveOffsetAttributeImpl() {
+      super(LOOKUP);
+    }
 
     @Override
     public int startOffset() {
