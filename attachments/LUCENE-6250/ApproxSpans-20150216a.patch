diff --git a/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java b/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
index 885a82a..19d02ba 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
@@ -51,6 +51,8 @@ class ConjunctionScorer extends Scorer {
 
   @Override
   public int advance(int target) throws IOException {
+System.out.println("ConjunctionScorer.advance() this="+this);
+System.out.println("ConjunctionScorer.advance() target="+target);
     return disi.advance(target);
   }
 
@@ -61,14 +63,17 @@ class ConjunctionScorer extends Scorer {
 
   @Override
   public int nextDoc() throws IOException {
+System.out.println("ConjunctionScorer.nextDoc() this="+this);
     return disi.nextDoc();
   }
 
   @Override
   public float score() throws IOException {
+System.out.println("ConjunctionScorer.score() this="+this);
     // TODO: sum into a double and cast to float if we ever send required clauses to BS1
     float sum = 0.0f;
     for (Scorer scorer : scorers) {
+System.out.println("ConjunctionScorer.score() scorer="+scorer);
       sum += scorer.score();
     }
     return sum * coord;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java
index 35cf7b9..d8f32e4 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java
@@ -23,6 +23,7 @@ import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.search.TwoPhaseDocIdSetIterator;
 
 /**
  * Public for extension only.
@@ -42,6 +43,7 @@ public class SpanScorer extends Scorer {
     super(weight);
     this.docScorer = docScorer;
     this.spans = spans;
+System.out.println("SpanScorer created for spans="+spans);
 
     doc = -1;
     more = spans.next();
@@ -52,11 +54,13 @@ public class SpanScorer extends Scorer {
     if (!setFreqCurrentDoc()) {
       doc = NO_MORE_DOCS;
     }
+System.out.println("SpanScorer.nextDoc() doc="+doc);
     return doc;
   }
 
   @Override
   public int advance(int target) throws IOException {
+System.out.println("SpanScorer.advance() target="+target);
     if (!more) {
       return doc = NO_MORE_DOCS;
     }
@@ -86,10 +90,15 @@ public class SpanScorer extends Scorer {
   }
 
   @Override
-  public int docID() { return doc; }
+  public int docID() {
+System.out.println("SpanScorer.docID() doc="+doc);
+    return doc;
+  }
 
   @Override
   public float score() throws IOException {
+System.out.println("SpanScorer.score() doc="+doc);
+System.out.println("SpanScorer.score() freq="+freq);
     return docScorer.score(doc, freq);
   }
   
@@ -130,4 +139,10 @@ public class SpanScorer extends Scorer {
     return spans.cost();
   }
 
+  /** Returns {@link Spans#asTwoPhaseIterator} of the spans that is scored. */
+  @Override
+  public TwoPhaseDocIdSetIterator asTwoPhaseIterator() {
+    return spans.asTwoPhaseIterator(); // test passes when returning null
+    // ant test  -Dtestcase=TestSpansAdvanced -Dtests.method=testBooleanQueryWithSpanQueries -Dtests.seed=E42AB3F90E47161
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java b/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
index 32aff3b..91ec9cc 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
@@ -20,6 +20,8 @@ package org.apache.lucene.search.spans;
 import java.io.IOException;
 import java.util.Collection;
 
+import org.apache.lucene.search.TwoPhaseDocIdSetIterator;
+
 /** Expert: an enumeration of span matches.  Used to implement span searching.
  * Each span represents a range of term positions within a document.  Matches
  * are enumerated in order, by increasing document number, within that by
@@ -97,4 +99,24 @@ public abstract class Spans {
    * completely inaccurate.
    */
   public abstract long cost();
+
+  /**
+   * Optional method: Return a {@link TwoPhaseDocIdSetIterator} view of this
+   * {@link Spans}. A return value of {@code null} indicates that
+   * two-phase iteration is not supported.
+   *
+   * Note that the returned {@link TwoPhaseDocIdSetIterator}'s
+   * {@link TwoPhaseDocIdSetIterator#approximation() approximation} must
+   * advance synchronously with this Spans: advancing the approximation must
+   * advance this spans and vice-versa.
+   *
+   * Implementing this method is typically useful on {@link Spans}
+   * that have a high per-document overhead in order to confirm matches.
+   *
+   * The default implementation returns {@code null}.
+   */
+  public TwoPhaseDocIdSetIterator asTwoPhaseIterator() {
+    return null;
+  }
+  
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
index bca88de..be27bd9 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
@@ -19,6 +19,7 @@ package org.apache.lucene.search.spans;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.TwoPhaseDocIdSetIterator;
 import org.apache.lucene.util.BytesRef;
 
 import java.io.IOException;
@@ -38,12 +39,16 @@ public class TermSpans extends Spans {
   protected int position;
   protected boolean readPayload;
 
-  public TermSpans(PostingsEnum postings, Term term) {
+  public TermSpans(PostingsEnum postings, Term term) throws IOException {
     this.postings = postings;
     this.term = term;
-    doc = -1;
+    this.doc = -1;
+    this.freq = 0;
+    this.count = 0;
+//assert ++numCreated < 2;
   }
-
+//static int numCreated = 0;
+  
   // only for EmptyTermSpans (below)
   TermSpans() {
     term = null;
@@ -52,11 +57,13 @@ public class TermSpans extends Spans {
 
   @Override
   public boolean next() throws IOException {
+System.out.println("TermSpans.next()" + super.toString());
     if (count == freq) {
       if (postings == null) {
         return false;
       }
       doc = postings.nextDoc();
+  System.out.println("TermSpans.next() doc="+doc);
       if (doc == DocIdSetIterator.NO_MORE_DOCS) {
         return false;
       }
@@ -180,4 +187,52 @@ public class TermSpans extends Spans {
   }
 
   public static final TermSpans EMPTY_TERM_SPANS = new EmptyTermSpans();
+
+
+  @Override
+  public TwoPhaseDocIdSetIterator asTwoPhaseIterator() {
+System.out.println("TermSpans asTwoPhaseIterator()");
+    return new TwoPhaseDocIdSetIterator() {
+      
+      @Override
+      public boolean matches() throws IOException {
+    System.out.println("TermSpans asTwoPhaseIterator matches()");
+        return true;
+      }
+      
+      @Override
+      public DocIdSetIterator approximation() {
+    System.out.println("TermSpans asTwoPhaseIterator approximation()");
+
+        return new DocIdSetIterator() {
+          @Override
+          public int docID() {
+            int res = doc();
+        System.out.println("TermSpans asTwoPhaseIterator approximation docID()="+res);
+            return res;
+          }
+
+          @Override
+          public int nextDoc() throws IOException {
+        System.out.println("TermSpans asTwoPhaseIterator approximation nextDoc()");
+            return next() ? doc() : NO_MORE_DOCS;
+          }
+
+          @Override
+          public int advance(int target) throws IOException {
+        System.out.println("TermSpans asTwoPhaseIterator approximation advance()");
+            return skipTo(target) ? doc() : NO_MORE_DOCS;
+          }
+          
+          @Override
+          public long cost() {
+        System.out.println("TermSpans asTwoPhaseIterator approximation cost()");
+            return TermSpans.this.cost();
+          }
+
+        };
+      }
+    };
+  }
+
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestFilterSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestFilterSpans.java
index 239dfbe..88ab2e1 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestFilterSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestFilterSpans.java
@@ -31,6 +31,11 @@ public class TestFilterSpans extends LuceneTestCase {
     // verify that all methods of Spans are overridden by FilterSpans,
     // except those under the 'exclude' list
     Set<Method> exclude = new HashSet<>();
+    for (Method m: Spans.class.getMethods()) {
+      if (m.getName() == "asTwoPhaseIterator") {
+        exclude.add(m);
+      }
+    }
     for (Method m : FilterSpans.class.getMethods()) {
       if (m.getDeclaringClass() == Spans.class) {
         assertTrue("method " + m.getName() + " not overridden!", exclude.contains(m));
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced.java
index 1ae6168..27a678d 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced.java
@@ -130,7 +130,9 @@ public class TestSpansAdvanced extends LuceneTestCase {
   protected static void assertHits(IndexSearcher s, Query query,
       final String description, final String[] expectedIds,
       final float[] expectedScores) throws IOException {
+System.out.println("TestSpansAdvanced.assertHits starting QueryUtils.check()");
     QueryUtils.check(random(), query, s);
+System.out.println("TestSpansAdvanced.assertHits finished QueryUtils.check()");
     
     final float tolerance = 1e-5f;
     
