Index: CHANGES.txt
===================================================================
--- CHANGES.txt	(revision 476325)
+++ CHANGES.txt	(working copy)
@@ -171,6 +171,10 @@
 
 20. LUCENE-706: Updated fileformats.xml|html concerning the docdelta value in the frequency file. (Johan Stuyts, Doron Cohen via Grant Ingersoll)
 
+21. LUCENE-715: Fixed private constructor in IndexWriter.java to properly
+    release the acquired writeLock if accessing the segments file in
+    doBody() generates an exception.
+
 Optimizations
 
   1. LUCENE-586: TermDocs.skipTo() is now more efficient for
Index: src/test/org/apache/lucene/index/TestIndexWriterLockRelease.java
===================================================================
--- src/test/org/apache/lucene/index/TestIndexWriterLockRelease.java	(revision 0)
+++ src/test/org/apache/lucene/index/TestIndexWriterLockRelease.java	(revision 0)
@@ -0,0 +1,67 @@
+package org.apache.lucene.index;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import junit.framework.TestCase;
+import org.apache.lucene.index.IndexModifier;
+
+/**
+ * This tests the patch for issue #LUCENE-715 (IndexWriter does not
+ * release its write lock when trying to open an index which does not yet
+ * exist).
+ *
+ * @author mbogosian
+ * @version $Id$
+ */
+
+public class TestIndexWriterLockRelease extends TestCase {
+    private java.io.File __test_dir;
+
+    public void setUp() throws IOException {
+        if (this.__test_dir == null) {
+            String tmp_dir = System.getProperty("java.io.tmpdir", "tmp");
+            this.__test_dir = new File(tmp_dir, "testIndexWriter");
+
+            if (this.__test_dir.exists()) {
+                throw new IOException("test directory \"" + this.__test_dir.getPath() + "\" already exists (please remove by hand)");
+            }
+
+            if (!this.__test_dir.mkdirs()
+                && !this.__test_dir.isDirectory()) {
+                throw new IOException("unable to create test directory \"" + this.__test_dir.getPath() + "\"");
+            }
+        }
+    }
+
+    public void tearDown() throws IOException {
+        if (this.__test_dir != null) {
+            File[] files = this.__test_dir.listFiles();
+
+            for (int i = 0;
+                i < files.length;
+                ++i) {
+                if (!files[i].delete()) {
+                    throw new IOException("unable to remove file in test directory \"" + this.__test_dir.getPath() + "\" (please remove by hand)");
+                }
+            }
+
+            if (!this.__test_dir.delete()) {
+                throw new IOException("unable to remove test directory \"" + this.__test_dir.getPath() + "\" (please remove by hand)");
+            }
+        }
+    }
+
+    public void testIndexWriterLockRelease() throws IOException {
+        IndexModifier im;
+
+        try {
+            im = new IndexModifier(this.__test_dir, new org.apache.lucene.analysis.standard.StandardAnalyzer(), false);
+        } catch (FileNotFoundException e) {
+            try {
+                im = new IndexModifier(this.__test_dir, new org.apache.lucene.analysis.standard.StandardAnalyzer(), false);
+            } catch (FileNotFoundException e1) {
+            }
+        }
+    }
+}

Property changes on: src/test/org/apache/lucene/index/TestIndexWriterLockRelease.java
___________________________________________________________________
Name: svn:keywords
   + Author Date Id Rev
Name: svn:eol-style
   + native

Index: src/java/org/apache/lucene/index/IndexWriter.java
===================================================================
--- src/java/org/apache/lucene/index/IndexWriter.java	(revision 476325)
+++ src/java/org/apache/lucene/index/IndexWriter.java	(working copy)
@@ -259,16 +259,23 @@
         throw new IOException("Index locked for write: " + writeLock);
       this.writeLock = writeLock;                   // save it
 
-      synchronized (directory) {        // in- & inter-process sync
-        new Lock.With(directory.makeLock(IndexWriter.COMMIT_LOCK_NAME), commitLockTimeout) {
-            public Object doBody() throws IOException {
-              if (create)
-                segmentInfos.write(directory);
-              else
-                segmentInfos.read(directory);
-              return null;
-            }
-          }.run();
+      try {
+        synchronized (directory) {        // in- & inter-process sync
+          new Lock.With(directory.makeLock(IndexWriter.COMMIT_LOCK_NAME), commitLockTimeout) {
+              public Object doBody() throws IOException {
+                if (create)
+                  segmentInfos.write(directory);
+                else
+                  segmentInfos.read(directory);
+                return null;
+              }
+            }.run();
+        }
+      } catch (IOException e) {
+        // the doBody method failed
+        this.writeLock.release();
+        this.writeLock = null;
+        throw e;
       }
   }
 
