diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java
index 6763118..bab14f3 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/BM25Similarity.java
@@ -101,7 +101,10 @@ public class BM25Similarity extends Similarity {
    * Lucene's default implementation.  If you change this, then you should 
    * change {@link #decodeNormValue(byte)} to match. */
   protected byte encodeNormValue(float boost, int fieldLength) {
-    return SmallFloat.floatToByte315(boost / (float) Math.sqrt(fieldLength));
+    if (boost != 1f) {
+      throw new IllegalArgumentException("Index boosts are not supported");
+    }
+    return encodeNorm(fieldLength);
   }
 
   /** The default implementation returns <code>1 / f<sup>2</sup></code>
@@ -135,11 +138,9 @@ public class BM25Similarity extends Similarity {
   private static final float[] NORM_TABLE = new float[256];
 
   static {
-    for (int i = 1; i < 256; i++) {
-      float f = SmallFloat.byte315ToFloat((byte)i);
-      NORM_TABLE[i] = 1.0f / (f*f);
+    for (int i = 0; i < 256; i++) {
+      NORM_TABLE[i] = decodeNorm((byte) i);
     }
-    NORM_TABLE[0] = 1.0f / NORM_TABLE[255]; // otherwise inf
   }
 
 
@@ -354,4 +355,60 @@ public class BM25Similarity extends Similarity {
   public final float getB() {
     return b;
   }
+
+  private static final int MAX_ENCODED_SMALL_INT = encodeSmallInt(Integer.MAX_VALUE);
+  private static final int NUM_FREE_VALUES = 255 - MAX_ENCODED_SMALL_INT;
+
+  private static byte encodeNorm(int length) {
+    if (length < NUM_FREE_VALUES) {
+      return (byte) length;
+    } else {
+      return (byte) (NUM_FREE_VALUES + encodeSmallInt(length - NUM_FREE_VALUES));
+    }
+  }
+
+  /** Float-like encoding for integers that preserves ordering and 4 significant bits. */
+  private static int encodeSmallInt(int i) {
+    int numBits = 32 - Integer.numberOfLeadingZeros(i);
+    if (numBits < 4) {
+      // subnormal value
+      return i;
+    } else {
+      // normal value
+      int shift = numBits - 4;
+      // only keep the 5 most significant bits
+      int encoded = i >>> shift;
+      // clear the most significant bit, which is implicit
+      encoded &= 0x07;
+      // encode the shift, adding 1 because 0 is reserved for subnormal values
+      encoded |= (shift + 1) << 3;
+      return encoded;
+    }
+  }
+
+  private static int decodeNorm(byte b) {
+    int norm = Byte.toUnsignedInt(b);
+    // encodeSmallInt(Integer.MAX_VALUE) is less than 255 so we borrow the
+    // unused encoded values to have better accuracy for short lengths
+    if (norm < NUM_FREE_VALUES) {
+      return norm;
+    } else {
+      return NUM_FREE_VALUES + decodeSmallInt(b - NUM_FREE_VALUES);
+    }
+  }
+
+  private static final int decodeSmallInt(int i) {
+    int bits = i & 0x07;
+    int shift = (i >>> 3) - 1;
+    int decoded;
+    if (shift == -1) {
+      // subnormal value
+      decoded = bits;
+    } else {
+      // normal value
+      decoded = (bits | 0x08) << shift;
+    }
+    return decoded;
+  }
+
 }
