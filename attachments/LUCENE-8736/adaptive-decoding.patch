Index: lucene/sandbox/src/java/org/apache/lucene/document/LatLonShape.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/document/LatLonShape.java	(revision 361d1e84ce927c2cdc3d732da65cfd755800ad0a)
+++ lucene/sandbox/src/java/org/apache/lucene/document/LatLonShape.java	(date 1553678171000)
@@ -290,75 +290,91 @@
   /**
    * Decode a triangle encoded by {@link LatLonShape#encodeTriangle(byte[], int, int, int, int, int, int)}.
    */
-  public static void decodeTriangle(byte[] t, int[] triangle) {
+  public static void decodeTriangle(byte[] t, int[] triangle, QueryRelation queryRelation) {
     assert triangle.length == 6;
+    int minY = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
+    int minX = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
+    int maxY = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
+    int maxX = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
+    int y = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
+    int x = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
+    // Adaptive decoding : For within queries we want to decode triangles so that they cover the least
+    // area possible. Still, this is somewhat not correcting issues with lines.
+    if (queryRelation == QueryRelation.WITHIN && hasArea(minY, minX, maxY, maxX, y, x))  {
+      minY = roundUp(minY);
+      minX = roundUp(minX);
+      maxY = maxY == minY ? maxY  : roundDown(maxY);
+      maxX = maxX == minX ? maxX : roundDown(maxX);
+      y = y < minY ? minY : y > maxY ? maxY : y;
+      x = x < minX ? minX : x > maxX ? maxX : x;
+    }
     int bits = NumericUtils.sortableBytesToInt(t, 6 * LatLonShape.BYTES);
     //extract the first three bits
     int tCode = (((1 << 3) - 1) & (bits >> 0));
     switch (tCode) {
       case MINY_MINX_MAXY_MAXX_Y_X:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
+        triangle[0] = minY;
+        triangle[1] = minX;
+        triangle[2] = maxY;
+        triangle[3] = maxX;
+        triangle[4] = y;
+        triangle[5] = x;
         break;
       case MINY_MINX_Y_X_MAXY_MAXX:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
+        triangle[0] = minY;
+        triangle[1] = minX;
+        triangle[2] = y;
+        triangle[3] = x;
+        triangle[4] = maxY;
+        triangle[5] = maxX;
         break;
       case MAXY_MINX_Y_X_MINY_MAXX:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
+        triangle[0] = maxY;
+        triangle[1] = minX;
+        triangle[2] = y;
+        triangle[3] = x;
+        triangle[4] = minY;
+        triangle[5] = maxX;
         break;
       case MAXY_MINX_MINY_MAXX_Y_X:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
+        triangle[0] = maxY;
+        triangle[1] = minX;
+        triangle[2] = minY;
+        triangle[3] = maxX;
+        triangle[4] = y;
+        triangle[5] = x;
         break;
       case Y_MINX_MINY_X_MAXY_MAXX:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
+        triangle[0] = y;
+        triangle[1] = minX;
+        triangle[2] = minY;
+        triangle[3] = x;
+        triangle[4] = maxY;
+        triangle[5] = maxX;
         break;
       case Y_MINX_MINY_MAXX_MAXY_X:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
+        triangle[0] = y;
+        triangle[1] = minX;
+        triangle[2] = minY;
+        triangle[3] = maxX;
+        triangle[4] = maxY;
+        triangle[5] = x;
         break;
       case MAXY_MINX_MINY_X_Y_MAXX:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
+        triangle[0] = maxY;
+        triangle[1] = minX;
+        triangle[2] = minY;
+        triangle[3] = x;
+        triangle[4] = y;
+        triangle[5] = maxX;
         break;
       case MINY_MINX_Y_MAXX_MAXY_X:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
+        triangle[0] = minY;
+        triangle[1] = minX;
+        triangle[2] = y;
+        triangle[3] = maxX;
+        triangle[4] = maxY;
+        triangle[5] = x;
         break;
       default:
         throw new IllegalArgumentException("Could not decode the provided triangle");
@@ -366,4 +382,22 @@
     //Points of the decoded triangle must be co-planar or CCW oriented
     assert GeoUtils.orient(triangle[1], triangle[0], triangle[3], triangle[2], triangle[5], triangle[4]) >= 0;
   }
+
+  private static int roundUp(int encoded) {
+    if (encoded == Integer.MAX_VALUE) {
+      return encoded;
+    }
+    return encoded + 1;
+  }
+
+  private static int roundDown(int encoded) {
+    if (encoded == Integer.MIN_VALUE) {
+      return encoded;
+    }
+    return encoded - 1;
+  }
+
+  private static boolean hasArea(int minY, int minX, int maxY, int maxX, int y, int x) {
+    return ((minY == maxY && minX == maxX) || (minY == y && minX == x) ||  (maxY == y && maxX == x)) == false;
+  }
 }
