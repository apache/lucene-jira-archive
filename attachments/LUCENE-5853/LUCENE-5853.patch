Index: lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator.java	(revision 1598751)
+++ lucene/core/src/java/org/apache/lucene/util/RamUsageEstimator.java	(working copy)
@@ -35,6 +35,12 @@
  */
 public final class RamUsageEstimator {
   /**
+   * The component used to log messages to the {@link InfoStream#getDefault()
+   * default} {@link InfoStream}.
+   */
+  public static final String INFO_STREAM_COMPONENT = "RamUsageEstimator";
+  
+  /**
    * JVM diagnostic features.
    */
   public static enum JvmFeature {
@@ -152,8 +158,13 @@
       final Field unsafeField = unsafeClass.getDeclaredField("theUnsafe");
       unsafeField.setAccessible(true);
       tempTheUnsafe = unsafeField.get(null);
+    } catch (NoSuchFieldException e) {
+      // Reflection-related, safe to ignore.
     } catch (Exception e) {
-      // Ignore.
+      final InfoStream infoStream = InfoStream.getDefault();
+      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {
+        infoStream.message(INFO_STREAM_COMPONENT, "unexpected exception");
+      }
     }
     theUnsafe = tempTheUnsafe;
 
@@ -162,8 +173,13 @@
       final Method arrayIndexScaleM = unsafeClass.getMethod("arrayIndexScale", Class.class);
       referenceSize = ((Number) arrayIndexScaleM.invoke(theUnsafe, Object[].class)).intValue();
       supportedFeatures.add(JvmFeature.OBJECT_REFERENCE_SIZE);
+    } catch (NoSuchMethodException e) {
+      // Reflection-related, safe to ignore.
     } catch (Exception e) {
-      // ignore.
+      final InfoStream infoStream = InfoStream.getDefault();
+      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {
+        infoStream.message(INFO_STREAM_COMPONENT, "unexpected exception");
+      }
     }
 
     // "best guess" based on reference size. We will attempt to modify
@@ -189,8 +205,15 @@
         supportedFeatures.add(JvmFeature.FIELD_OFFSETS);
         tempObjectFieldOffsetMethod = objectFieldOffsetM;
       }
+    } catch (NoSuchFieldException e) {
+      // Reflection-related, safe to ignore.
+    } catch (NoSuchMethodException e) {
+      // Reflection-related, safe to ignore.
     } catch (Exception e) {
-      // Ignore.
+      final InfoStream infoStream = InfoStream.getDefault();
+      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {
+        infoStream.message(INFO_STREAM_COMPONENT, "unexpected exception");
+      }
     }
     objectFieldOffsetMethod = tempObjectFieldOffsetMethod;
 
@@ -201,8 +224,13 @@
       // we calculate that only for byte[] arrays, it's actually the same for all types:
       arrayHeader = ((Number) arrayBaseOffsetM.invoke(theUnsafe, byte[].class)).intValue();
       supportedFeatures.add(JvmFeature.ARRAY_HEADER_SIZE);
+    } catch (NoSuchMethodException e) {
+      // Reflection-related, safe to ignore.
     } catch (Exception e) {
-      // Ignore.
+      final InfoStream infoStream = InfoStream.getDefault();
+      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {
+        infoStream.message(INFO_STREAM_COMPONENT, "unexpected exception");
+      }
     }
 
     NUM_BYTES_OBJECT_REF = referenceSize;
@@ -224,8 +252,15 @@
         );
         supportedFeatures.add(JvmFeature.OBJECT_ALIGNMENT);
       }
+    } catch (ClassNotFoundException e) {
+      // Reflection-related, safe to ignore.
+    } catch (NoSuchMethodException e) {
+      // Reflection-related, safe to ignore.
     } catch (Exception e) {
-      // Ignore.
+      final InfoStream infoStream = InfoStream.getDefault();
+      if (infoStream.isEnabled(INFO_STREAM_COMPONENT)) {
+        infoStream.message(INFO_STREAM_COMPONENT, "unexpected exception");
+      }
     }
 
     NUM_BYTES_OBJECT_ALIGNMENT = objectAlignment;
