Index: lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
===================================================================
--- lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java	(revision 1614719)
+++ lucene/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java	(working copy)
@@ -955,6 +955,7 @@
       public void seekExact(long ord) {
         assert ord < info.terms.size();
         termUpto = (int) ord;
+        info.terms.get(info.sortedTerms[termUpto], br);
       }
       
       @Override
Index: lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java	(revision 1614719)
+++ lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java	(working copy)
@@ -299,9 +299,146 @@
     if (min != null && max != null && ((Comparable<T>) min).compareTo(max) > 0) {
       return TermsEnum.EMPTY;
     }
+
+    if (terms.size() == 0) {
+      // No terms
+      return TermsEnum.EMPTY;
+    }
+
+    switch (dataType) {
+    case LONG:
+    case DOUBLE:
+      // We must detect this up-front because we don't handle it later
+      // when creating the NumericTermsEnum:
+      if (minInclusive == false && getMinLong() == Long.MAX_VALUE) {
+        return TermsEnum.EMPTY;
+      }
+      if (maxInclusive == false && getMaxLong() == Long.MIN_VALUE) {
+        return TermsEnum.EMPTY;
+      }
+
+      // Optimization: if our range is outside of the range indexed in this segment, skip it:
+      if (NumericUtils.getMinLong(terms) > getMaxLongInclusive()) {
+        return TermsEnum.EMPTY;
+      }
+      if (NumericUtils.getMaxLong(terms) < getMinLongInclusive()) {
+        return TermsEnum.EMPTY;
+      }
+      break;
+
+    case INT:   
+    case FLOAT:
+      // We must detect this up-front because we don't handle it later
+      // when creating the NumericTermsEnum:
+      if (minInclusive == false && getMinInt() == Integer.MAX_VALUE) {
+        return TermsEnum.EMPTY;
+      }
+      if (maxInclusive == false && getMaxInt() == Integer.MIN_VALUE) {
+        return TermsEnum.EMPTY;
+      }
+
+      // Optimization: if our range is outside of the range indexed in this segment, skip it:
+      if (NumericUtils.getMinInt(terms) > getMaxIntInclusive()) {
+        return TermsEnum.EMPTY;
+      }
+      if (NumericUtils.getMaxInt(terms) < getMinIntInclusive()) {
+        return TermsEnum.EMPTY;
+      }
+      break;
+    }
+
     return new NumericRangeTermsEnum(terms.iterator(null));
   }
 
+  private long getMinLong() {
+    long minBound;
+    if (dataType == NumericType.LONG) {
+      minBound = (min == null) ? Long.MIN_VALUE : min.longValue();
+    } else {
+      assert dataType == NumericType.DOUBLE;
+      minBound = (min == null) ? LONG_NEGATIVE_INFINITY
+        : NumericUtils.doubleToSortableLong(min.doubleValue());
+    }
+    return minBound;
+  }
+
+  private long getMinLongInclusive() {
+    long minBound = getMinLong();
+    if (!minInclusive && min != null) {
+      // We detected this above:
+      assert minBound < Long.MAX_VALUE;
+      minBound++;
+    }
+    return minBound;
+  }
+
+  private long getMaxLong() {
+    long maxBound;
+    if (dataType == NumericType.LONG) {
+      maxBound = (max == null) ? Long.MAX_VALUE : max.longValue();
+    } else {
+      assert dataType == NumericType.DOUBLE;
+      maxBound = (max == null) ? LONG_POSITIVE_INFINITY
+        : NumericUtils.doubleToSortableLong(max.doubleValue());
+    }
+    return maxBound;
+  }
+
+  private long getMaxLongInclusive() {
+    long maxBound = getMaxLong();
+    if (!maxInclusive && max != null) {
+      // We detected this above:
+      assert maxBound > Long.MIN_VALUE;
+      maxBound--;
+    }
+    return maxBound;
+  }
+
+  private int getMinInt() {
+    int minBound;
+    if (dataType == NumericType.INT) {
+      minBound = (min == null) ? Integer.MIN_VALUE : min.intValue();
+    } else {
+      assert dataType == NumericType.FLOAT;
+      minBound = (min == null) ? INT_NEGATIVE_INFINITY
+        : NumericUtils.floatToSortableInt(min.floatValue());
+    }
+    return minBound;
+  }
+
+  private int getMinIntInclusive() {
+    int minBound = getMinInt();
+    if (!minInclusive && min != null) {
+      // We detected this above:
+      assert minBound < Integer.MAX_VALUE;
+      minBound++;
+    }
+    return minBound;
+  }
+
+  private int getMaxInt() {
+    int maxBound;
+    if (dataType == NumericType.INT) {
+      maxBound = (max == null) ? Integer.MAX_VALUE : max.intValue();
+    } else {
+      assert dataType == NumericType.FLOAT;
+      maxBound = (max == null) ? INT_POSITIVE_INFINITY
+        : NumericUtils.floatToSortableInt(max.floatValue());
+    }
+    return maxBound;
+  }
+
+  private int getMaxIntInclusive() {
+    int maxBound = getMaxInt();
+    if (!maxInclusive && max != null) {
+      // We detected this above:
+      assert maxBound > Integer.MIN_VALUE;
+      maxBound--;
+    }
+
+    return maxBound;
+  }
+
   /** Returns <code>true</code> if the lower endpoint is inclusive */
   public boolean includesMin() { return minInclusive; }
   
@@ -397,81 +534,25 @@
       switch (dataType) {
         case LONG:
         case DOUBLE: {
-          // lower
-          long minBound;
-          if (dataType == NumericType.LONG) {
-            minBound = (min == null) ? Long.MIN_VALUE : min.longValue();
-          } else {
-            assert dataType == NumericType.DOUBLE;
-            minBound = (min == null) ? LONG_NEGATIVE_INFINITY
-              : NumericUtils.doubleToSortableLong(min.doubleValue());
-          }
-          if (!minInclusive && min != null) {
-            if (minBound == Long.MAX_VALUE) break;
-            minBound++;
-          }
-          
-          // upper
-          long maxBound;
-          if (dataType == NumericType.LONG) {
-            maxBound = (max == null) ? Long.MAX_VALUE : max.longValue();
-          } else {
-            assert dataType == NumericType.DOUBLE;
-            maxBound = (max == null) ? LONG_POSITIVE_INFINITY
-              : NumericUtils.doubleToSortableLong(max.doubleValue());
-          }
-          if (!maxInclusive && max != null) {
-            if (maxBound == Long.MIN_VALUE) break;
-            maxBound--;
-          }
-          
           NumericUtils.splitLongRange(new NumericUtils.LongRangeBuilder() {
             @Override
             public final void addRange(BytesRef minPrefixCoded, BytesRef maxPrefixCoded) {
               rangeBounds.add(minPrefixCoded);
               rangeBounds.add(maxPrefixCoded);
             }
-          }, precisionStep, minBound, maxBound);
+          }, precisionStep, getMinLongInclusive(), getMaxLongInclusive());
           break;
         }
           
         case INT:
         case FLOAT: {
-          // lower
-          int minBound;
-          if (dataType == NumericType.INT) {
-            minBound = (min == null) ? Integer.MIN_VALUE : min.intValue();
-          } else {
-            assert dataType == NumericType.FLOAT;
-            minBound = (min == null) ? INT_NEGATIVE_INFINITY
-              : NumericUtils.floatToSortableInt(min.floatValue());
-          }
-          if (!minInclusive && min != null) {
-            if (minBound == Integer.MAX_VALUE) break;
-            minBound++;
-          }
-          
-          // upper
-          int maxBound;
-          if (dataType == NumericType.INT) {
-            maxBound = (max == null) ? Integer.MAX_VALUE : max.intValue();
-          } else {
-            assert dataType == NumericType.FLOAT;
-            maxBound = (max == null) ? INT_POSITIVE_INFINITY
-              : NumericUtils.floatToSortableInt(max.floatValue());
-          }
-          if (!maxInclusive && max != null) {
-            if (maxBound == Integer.MIN_VALUE) break;
-            maxBound--;
-          }
-          
           NumericUtils.splitIntRange(new NumericUtils.IntRangeBuilder() {
             @Override
             public final void addRange(BytesRef minPrefixCoded, BytesRef maxPrefixCoded) {
               rangeBounds.add(minPrefixCoded);
               rangeBounds.add(maxPrefixCoded);
             }
-          }, precisionStep, minBound, maxBound);
+          }, precisionStep, getMinIntInclusive(), getMaxIntInclusive());
           break;
         }
           
Index: lucene/core/src/java/org/apache/lucene/search/TermRangeQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/TermRangeQuery.java	(revision 1614719)
+++ lucene/core/src/java/org/apache/lucene/search/TermRangeQuery.java	(working copy)
@@ -103,6 +103,19 @@
     if (lowerTerm != null && upperTerm != null && lowerTerm.compareTo(upperTerm) > 0) {
       return TermsEnum.EMPTY;
     }
+
+    if (terms.size() == 0) {
+      // No terms
+      return TermsEnum.EMPTY;
+    }
+
+    // Optimization: if our range is outside of the range indexed in this segment, skip it:
+    if (upperTerm != null && terms.getMin().compareTo(upperTerm) > 0) {
+      return TermsEnum.EMPTY;
+    }
+    if (lowerTerm != null && terms.getMax().compareTo(lowerTerm) < 0) {
+      return TermsEnum.EMPTY;
+    }      
     
     TermsEnum tenum = terms.iterator(null);
     
