diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.java
index 686c7a6..9ef8efd 100644
--- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.java
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/ASCIIFoldingFilter.java
@@ -56,6 +56,7 @@ import org.apache.lucene.util.ArrayUtil;
  * For example, '&agrave;' will be replaced by 'a'.
  */
 public final class ASCIIFoldingFilter extends TokenFilter {
+  private static final int[] CHAR_MAP = buildCharMap();
   private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
   private final PositionIncrementAttribute posIncAttr = addAttribute(PositionIncrementAttribute.class);
   private final boolean preserveOriginal;
@@ -175,7 +176,79 @@ public final class ASCIIFoldingFilter extends TokenFilter {
    * @return length of output
    * @lucene.internal
    */
-  public static final int foldToASCII(char input[], int inputPos, char output[], int outputPos, int length)
+  public static final int foldToASCII(char input[], int inputPos, char output[], int outputPos, int length) {
+    final int end = inputPos + length;
+    for (int pos = inputPos; pos < end ; ++pos) {
+      final char c = input[pos];
+      if (c < '\u0080') {
+        output[outputPos++] = c;
+      } else {
+        int replChars = CHAR_MAP[c - '\u0080'];
+        if (replChars == 0) {
+          // no replacement
+          output[outputPos++] = c;
+        } else {
+          output[outputPos++] = (char) (replChars & 0xFF);
+          int otherChars = replChars >>> 8;
+          while (otherChars != 0) { // usually false
+            output[outputPos++] = (char) (otherChars & 0xFF);
+            otherChars >>>= 8;
+          }
+        }
+      }
+    }
+    return outputPos;
+  }
+
+  /** Encode up to 4 non-null ASCII chars in an int. */
+  private static int encode(char[] chars, int len) {
+    if (len == 0) {
+      throw new IllegalArgumentException("No chars to encode");
+    }
+    if (len > 4) {
+      throw new IllegalArgumentException("More than 4 chars");
+    }
+    for (int i = 0; i < len; ++i) {
+      final int c = chars[i];
+      if (c == '\0') {
+        throw new IllegalArgumentException("Cannot encode the null char");
+      }
+      if (c >= '\u0080') {
+        throw new IllegalArgumentException("Non ASCII value");
+      }
+    }
+    int v = 0;
+    for (int i = 0; i < len; ++i) {
+      v |= chars[i] << (i * 8);
+    }
+    return v;
+  }
+
+  /**
+   * Build a map that maps each non-ASCII character to either 0 if it should
+   * not be replaced, or the sequence of replacement chars, encoded in an int.
+   */
+  // TODO: Use a sparse data-structure: only a minority of non-ascii chars
+  // have a replacement
+  private static int[] buildCharMap() {
+    int[] map = new int[(int) Character.MAX_VALUE - '\u0080' + 1];
+    char[] in = new char[1];
+    char[] out = new char[4];
+    for (int i = 0; i < map.length; ++i) {
+      final char c = (char) (i + '\u0080');
+      in[0] = c;
+      final int outLen = foldToASCIISlow(in, 0, out, 0, 1);
+      if (outLen == 1 && out[0] == c) {
+        map[i] = 0; // means no replacement
+      } else {
+        map[i] = encode(out, outLen);
+      }
+    }
+    return map;
+  }
+
+  // LUCENE-7525 this method proved slow because it is too large to be compiled
+  static final int foldToASCIISlow(char input[], int inputPos, char output[], int outputPos, int length)
   {
     final int end = inputPos + length;
     for (int pos = inputPos; pos < end ; ++pos) {
diff --git a/lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestASCIIFoldingFilter.java b/lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestASCIIFoldingFilter.java
index 0e6e4fb..f906c72 100644
--- a/lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestASCIIFoldingFilter.java
+++ b/lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestASCIIFoldingFilter.java
@@ -28,6 +28,7 @@ import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import java.io.IOException;
 import java.util.List;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Iterator;
 
 public class TestASCIIFoldingFilter extends BaseTokenStreamTestCase {
@@ -1961,4 +1962,16 @@ public class TestASCIIFoldingFilter extends BaseTokenStreamTestCase {
     checkOneTerm(a, "", "");
     a.close();
   }
+
+  public void testDuelAsciiFolding() {
+    final char[] in = new char[1];
+    final char[] out1 = new char[4];
+    final char[] out2 = new char[4];
+    for (int c = 0; c <= Character.MAX_VALUE; ++c) {
+      in[0] = (char) c;
+      final int len1 = ASCIIFoldingFilter.foldToASCIISlow(in, 0, out1, 0, 1);
+      final int len2 = ASCIIFoldingFilter.foldToASCII(in, 0, out2, 0, 1);
+      assertArrayEquals(Arrays.copyOf(out1, len1), Arrays.copyOf(out2, len2));
+    }
+  }
 }
