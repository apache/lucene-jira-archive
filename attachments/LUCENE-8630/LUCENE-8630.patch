diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/BoostingIntervalsSource.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/BoostingIntervalsSource.java
new file mode 100644
index 0000000000..7e78cb380e
--- /dev/null
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/BoostingIntervalsSource.java
@@ -0,0 +1,90 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.search.intervals;
+
+import java.io.IOException;
+import java.util.Objects;
+import java.util.Set;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.MatchesIterator;
+
+class BoostingIntervalsSource extends IntervalsSource {
+
+  private final IntervalsSource in;
+  private final float boost;
+
+  BoostingIntervalsSource(IntervalsSource in, float boost) {
+    this.in = in;
+    this.boost = boost;
+  }
+
+  @Override
+  public IntervalIterator intervals(String field, LeafReaderContext ctx) throws IOException {
+    IntervalIterator it = in.intervals(field, ctx);
+    if (it == null) {
+      return null;
+    }
+    return new FilterIntervalIterator(it) {
+      @Override
+      public float boost() {
+        return it.boost() * boost;
+      }
+    };
+  }
+
+  @Override
+  public MatchesIterator matches(String field, LeafReaderContext ctx, int doc) throws IOException {
+    return in.matches(field, ctx, doc);
+  }
+
+  @Override
+  public void extractTerms(String field, Set<Term> terms) {
+    in.extractTerms(field, terms);
+  }
+
+  @Override
+  public boolean hasBoost() {
+    return boost != 1;
+  }
+
+  @Override
+  public int minExtent() {
+    return in.minExtent();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+    BoostingIntervalsSource that = (BoostingIntervalsSource) o;
+    return Float.compare(that.boost, boost) == 0 &&
+        Objects.equals(in, that.in);
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hash(in, boost);
+  }
+
+  @Override
+  public String toString() {
+    return "BOOST^" + boost + "(" + in + ")";
+  }
+}
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/ConjunctionIntervalsSource.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/ConjunctionIntervalsSource.java
index ec4341de70..3f583ab5ea 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/ConjunctionIntervalsSource.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/ConjunctionIntervalsSource.java
@@ -63,6 +63,15 @@ class ConjunctionIntervalsSource extends IntervalsSource {
   }
 
   @Override
+  public boolean hasBoost() {
+    for (IntervalsSource source : subSources) {
+      if (source.hasBoost()) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   public int minExtent() {
     int minExtent = 0;
     for (IntervalsSource source : subSources) {
@@ -80,7 +89,7 @@ class ConjunctionIntervalsSource extends IntervalsSource {
         return null;
       subIntervals.add(it);
     }
-    return function.apply(subIntervals);
+    return function.apply(subIntervals, hasBoost());
   }
 
   @Override
@@ -93,7 +102,8 @@ class ConjunctionIntervalsSource extends IntervalsSource {
       }
       subs.add(mi);
     }
-    IntervalIterator it = function.apply(subs.stream().map(m -> IntervalMatches.wrapMatches(m, doc)).collect(Collectors.toList()));
+    IntervalIterator it
+        = function.apply(subs.stream().map(m -> IntervalMatches.wrapMatches(m, doc)).collect(Collectors.toList()), hasBoost());
     if (it.advance(doc) != doc) {
       return null;
     }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/DifferenceIntervalFunction.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/DifferenceIntervalFunction.java
index 8479716305..5669db21a0 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/DifferenceIntervalFunction.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/DifferenceIntervalFunction.java
@@ -72,66 +72,40 @@ abstract class DifferenceIntervalFunction {
     }
   };
 
-  private static abstract class RelativeIterator extends IntervalIterator {
+  private static abstract class RelativeIterator extends FilterIntervalIterator {
 
-    final IntervalIterator a;
     final IntervalIterator b;
 
     boolean bpos;
 
     RelativeIterator(IntervalIterator a, IntervalIterator b) {
-      this.a = a;
+      super(a);
       this.b = b;
     }
 
-    @Override
-    public int docID() {
-      return a.docID();
-    }
-
     @Override
     public int nextDoc() throws IOException {
-      int doc = a.nextDoc();
+      int doc = in.nextDoc();
       reset();
       return doc;
     }
 
     @Override
     public int advance(int target) throws IOException {
-      int doc = a.advance(target);
+      int doc = in.advance(target);
       reset();
       return doc;
     }
 
-    @Override
-    public long cost() {
-      return a.cost();
-    }
-
     protected void reset() throws IOException {
-      int doc = a.docID();
+      int doc = in.docID();
       bpos = b.docID() == doc ||
           (b.docID() < doc && b.advance(doc) == doc);
     }
 
-    @Override
-    public int start() {
-      return a.start();
-    }
-
-    @Override
-    public int end() {
-      return a.end();
-    }
-
-    @Override
-    public int gaps() {
-      return a.gaps();
-    }
-
     @Override
     public float matchCost() {
-      return a.matchCost() + b.matchCost();
+      return in.matchCost() + b.matchCost();
     }
   }
 
@@ -144,16 +118,16 @@ abstract class DifferenceIntervalFunction {
     @Override
     public int nextInterval() throws IOException {
       if (bpos == false)
-        return a.nextInterval();
-      while (a.nextInterval() != NO_MORE_INTERVALS) {
-        while (b.end() < a.start()) {
+        return in.nextInterval();
+      while (in.nextInterval() != NO_MORE_INTERVALS) {
+        while (b.end() < in.start()) {
           if (b.nextInterval() == NO_MORE_INTERVALS) {
             bpos = false;
-            return a.start();
+            return in.start();
           }
         }
-        if (b.start() > a.end())
-          return a.start();
+        if (b.start() > in.end())
+          return in.start();
       }
       return NO_MORE_INTERVALS;
     }
@@ -168,16 +142,16 @@ abstract class DifferenceIntervalFunction {
     @Override
     public int nextInterval() throws IOException {
       if (bpos == false)
-        return a.nextInterval();
-      while (a.nextInterval() != NO_MORE_INTERVALS) {
-        while (b.start() < a.start() && b.end() < a.end()) {
+        return in.nextInterval();
+      while (in.nextInterval() != NO_MORE_INTERVALS) {
+        while (b.start() < in.start() && b.end() < in.end()) {
           if (b.nextInterval() == NO_MORE_INTERVALS) {
             bpos = false;
-            return a.start();
+            return in.start();
           }
         }
-        if (b.start() > a.end())
-          return a.start();
+        if (b.start() > in.end())
+          return in.start();
       }
       return NO_MORE_INTERVALS;
     }
@@ -193,14 +167,14 @@ abstract class DifferenceIntervalFunction {
     @Override
     public int nextInterval() throws IOException {
       if (bpos == false)
-        return a.nextInterval();
-      while (a.nextInterval() != NO_MORE_INTERVALS) {
-        while (b.end() < a.end()) {
+        return in.nextInterval();
+      while (in.nextInterval() != NO_MORE_INTERVALS) {
+        while (b.end() < in.end()) {
           if (b.nextInterval() == NO_MORE_INTERVALS)
-            return a.start();
+            return in.start();
         }
-        if (a.start() < b.start())
-          return a.start();
+        if (in.start() < b.start())
+          return in.start();
       }
       return NO_MORE_INTERVALS;
     }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/DifferenceIntervalsSource.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/DifferenceIntervalsSource.java
index 7289d04ba2..fb9a62afa5 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/DifferenceIntervalsSource.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/DifferenceIntervalsSource.java
@@ -62,6 +62,11 @@ class DifferenceIntervalsSource extends IntervalsSource {
     return IntervalMatches.asMatches(difference, minIt, doc);
   }
 
+  @Override
+  public boolean hasBoost() {
+    return minuend.hasBoost();
+  }
+
   @Override
   public boolean equals(Object o) {
     if (this == o) return true;
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/DisjunctionIntervalsSource.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/DisjunctionIntervalsSource.java
index b28088513a..5ba9cb6f2d 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/DisjunctionIntervalsSource.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/DisjunctionIntervalsSource.java
@@ -65,6 +65,16 @@ class DisjunctionIntervalsSource extends IntervalsSource {
     return MatchesUtils.disjunction(subMatches);
   }
 
+  @Override
+  public boolean hasBoost() {
+    for (IntervalsSource source : subSources) {
+      if (source.hasBoost()) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   @Override
   public boolean equals(Object o) {
     if (this == o) return true;
@@ -149,6 +159,11 @@ class DisjunctionIntervalsSource extends IntervalsSource {
       return current.gaps();
     }
 
+    @Override
+    public float boost() {
+      return current.boost();
+    }
+
     private void reset() throws IOException {
       intervalQueue.clear();
       for (DisiWrapper dw = disiQueue.topList(); dw != null; dw = dw.next) {
@@ -247,6 +262,11 @@ class DisjunctionIntervalsSource extends IntervalsSource {
       throw new UnsupportedOperationException();
     }
 
+    @Override
+    public float boost() {
+      throw new UnsupportedOperationException();
+    }
+
     @Override
     public int nextInterval() {
       return NO_MORE_INTERVALS;
@@ -295,6 +315,11 @@ class DisjunctionIntervalsSource extends IntervalsSource {
       throw new UnsupportedOperationException();
     }
 
+    @Override
+    public float boost() {
+      throw new UnsupportedOperationException();
+    }
+
     @Override
     public int nextInterval() {
       return NO_MORE_INTERVALS;
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/ExtendedIntervalIterator.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/ExtendedIntervalIterator.java
index 843b113a80..3a5fb89a9a 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/ExtendedIntervalIterator.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/ExtendedIntervalIterator.java
@@ -28,9 +28,8 @@ import java.io.IOException;
  * An interval with prefix bounds extended by n will skip over matches that
  * appear in positions lower than n
  */
-class ExtendedIntervalIterator extends IntervalIterator {
+class ExtendedIntervalIterator extends FilterIntervalIterator {
 
-  private final IntervalIterator in;
   private final int before;
   private final int after;
 
@@ -43,7 +42,7 @@ class ExtendedIntervalIterator extends IntervalIterator {
    * @param after   the number of positions to extend beyond the delegated interval
    */
   ExtendedIntervalIterator(IntervalIterator in, int before, int after) {
-    this.in = in;
+    super(in);
     this.before = before;
     this.after = after;
   }
@@ -77,11 +76,6 @@ class ExtendedIntervalIterator extends IntervalIterator {
     return end;
   }
 
-  @Override
-  public int gaps() {
-    return in.gaps();
-  }
-
   @Override
   public int nextInterval() throws IOException {
     positioned = true;
@@ -89,16 +83,6 @@ class ExtendedIntervalIterator extends IntervalIterator {
     return start();
   }
 
-  @Override
-  public float matchCost() {
-    return in.matchCost();
-  }
-
-  @Override
-  public int docID() {
-    return in.docID();
-  }
-
   @Override
   public int nextDoc() throws IOException {
     positioned = false;
@@ -111,8 +95,4 @@ class ExtendedIntervalIterator extends IntervalIterator {
     return in.advance(target);
   }
 
-  @Override
-  public long cost() {
-    return in.cost();
-  }
 }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/ExtendedIntervalsSource.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/ExtendedIntervalsSource.java
index 864a4b573c..4d11d45365 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/ExtendedIntervalsSource.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/ExtendedIntervalsSource.java
@@ -62,6 +62,10 @@ class ExtendedIntervalsSource extends IntervalsSource {
   }
 
   @Override
+  public boolean hasBoost() {
+    return source.hasBoost();
+  }
+
   public int minExtent() {
     int minExtent = before + source.minExtent() + after;
     if (minExtent < 0) {
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/FilterIntervalIterator.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/FilterIntervalIterator.java
new file mode 100644
index 0000000000..b4888942fd
--- /dev/null
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/FilterIntervalIterator.java
@@ -0,0 +1,84 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.search.intervals;
+
+import java.io.IOException;
+import java.util.Objects;
+
+/**
+ * An IntervalIterator that wraps another IntervalIterator, delegating
+ * some or all of its methods back.
+ */
+public abstract class FilterIntervalIterator extends IntervalIterator {
+
+  protected final IntervalIterator in;
+
+  protected FilterIntervalIterator(IntervalIterator in) {
+    this.in = Objects.requireNonNull(in);
+  }
+
+  @Override
+  public int docID() {
+    return in.docID();
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    return in.nextDoc();
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    return in.advance(target);
+  }
+
+  @Override
+  public long cost() {
+    return in.cost();
+  }
+
+  @Override
+  public int start() {
+    return in.start();
+  }
+
+  @Override
+  public int end() {
+    return in.end();
+  }
+
+  @Override
+  public int gaps() {
+    return in.gaps();
+  }
+
+  @Override
+  public float boost() {
+    return in.boost();
+  }
+
+  @Override
+  public int nextInterval() throws IOException {
+    return in.nextInterval();
+  }
+
+  @Override
+  public float matchCost() {
+    return in.matchCost();
+  }
+}
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/FilteredIntervalsSource.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/FilteredIntervalsSource.java
index c2b4d6012c..9737e3031b 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/FilteredIntervalsSource.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/FilteredIntervalsSource.java
@@ -87,6 +87,11 @@ public abstract class FilteredIntervalsSource extends IntervalsSource {
     in.extractTerms(field, terms);
   }
 
+  @Override
+  public boolean hasBoost() {
+    return in.hasBoost();
+  }
+
   @Override
   public boolean equals(Object o) {
     if (this == o) return true;
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/FixedFieldIntervalsSource.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/FixedFieldIntervalsSource.java
index 7776a2b543..587a3e7e79 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/FixedFieldIntervalsSource.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/FixedFieldIntervalsSource.java
@@ -50,6 +50,11 @@ class FixedFieldIntervalsSource extends IntervalsSource {
     source.extractTerms(this.field, terms);
   }
 
+  @Override
+  public boolean hasBoost() {
+    return source.hasBoost();
+  }
+
   @Override
   public int minExtent() {
     return source.minExtent();
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalFilter.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalFilter.java
index 46c030217e..060dcc970d 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalFilter.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalFilter.java
@@ -18,60 +18,17 @@
 package org.apache.lucene.search.intervals;
 
 import java.io.IOException;
-import java.util.Objects;
 
 /**
  * Wraps an {@link IntervalIterator} and passes through those intervals that match the {@link #accept()} function
  */
-public abstract class IntervalFilter extends IntervalIterator {
-
-  protected final IntervalIterator in;
+public abstract class IntervalFilter extends FilterIntervalIterator {
 
   /**
    * Create a new filter
    */
   public IntervalFilter(IntervalIterator in) {
-    this.in = Objects.requireNonNull(in);
-  }
-
-  @Override
-  public int docID() {
-    return in.docID();
-  }
-
-  @Override
-  public int nextDoc() throws IOException {
-    return in.nextDoc();
-  }
-
-  @Override
-  public int advance(int target) throws IOException {
-    return in.advance(target);
-  }
-
-  @Override
-  public long cost() {
-    return in.cost();
-  }
-
-  @Override
-  public int start() {
-    return in.start();
-  }
-
-  @Override
-  public int end() {
-    return in.end();
-  }
-
-  @Override
-  public int gaps() {
-    return in.gaps();
-  }
-
-  @Override
-  public float matchCost() {
-    return in.matchCost();
+    super(in);
   }
 
   /**
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalFunction.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalFunction.java
index 862e9a86a5..bc009bdfde 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalFunction.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalFunction.java
@@ -40,21 +40,23 @@ abstract class IntervalFunction {
   /**
    * Combine the iterators into another iterator
    */
-  public abstract IntervalIterator apply(List<IntervalIterator> iterators);
+  public abstract IntervalIterator apply(List<IntervalIterator> iterators, boolean hasBoosts);
 
   static final IntervalFunction BLOCK = new SingletonFunction("BLOCK") {
     @Override
-    public IntervalIterator apply(List<IntervalIterator> iterators) {
-      return new BlockIntervalIterator(iterators);
+    public IntervalIterator apply(List<IntervalIterator> iterators, boolean hasBoosts) {
+      return new BlockIntervalIterator(iterators, hasBoosts);
     }
   };
 
   private static class BlockIntervalIterator extends ConjunctionIntervalIterator {
 
     int start = -1, end = -1;
+    final boolean hasBoosts;
 
-    BlockIntervalIterator(List<IntervalIterator> subIterators) {
+    BlockIntervalIterator(List<IntervalIterator> subIterators, boolean hasBoosts) {
       super(subIterators);
+      this.hasBoosts = hasBoosts;
     }
 
     @Override
@@ -72,6 +74,18 @@ abstract class IntervalFunction {
       return 0;
     }
 
+    @Override
+    public float boost() {
+      float boost = 1f;
+      if (hasBoosts == false) {
+        return boost;
+      }
+      for (IntervalIterator it : subIterators) {
+        boost *= it.boost();
+      }
+      return boost;
+    }
+
     @Override
     public int nextInterval() throws IOException {
       if (subIterators.get(0).nextInterval() == IntervalIterator.NO_MORE_INTERVALS)
@@ -107,18 +121,22 @@ abstract class IntervalFunction {
    */
   static final IntervalFunction ORDERED = new SingletonFunction("ORDERED") {
     @Override
-    public IntervalIterator apply(List<IntervalIterator> intervalIterators) {
-      return new OrderedIntervalIterator(intervalIterators);
+    public IntervalIterator apply(List<IntervalIterator> intervalIterators, boolean hasBoosts) {
+      return new OrderedIntervalIterator(intervalIterators, hasBoosts);
     }
   };
 
   private static class OrderedIntervalIterator extends ConjunctionIntervalIterator {
 
+    final boolean hasBoosts;
+
     int start = -1, end = -1, i;
     int firstEnd;
+    float firstBoost;
 
-    private OrderedIntervalIterator(List<IntervalIterator> subIntervals) {
+    private OrderedIntervalIterator(List<IntervalIterator> subIntervals, boolean hasBoosts) {
       super(subIntervals);
+      this.hasBoosts = hasBoosts;
     }
 
     @Override
@@ -154,6 +172,7 @@ abstract class IntervalFunction {
           return end = NO_MORE_INTERVALS;
         }
         firstEnd = subIterators.get(0).end();
+        firstBoost = hasBoosts ? subIterators.get(0).boost() : 1.0f;
         end = subIterators.get(subIterators.size() - 1).end();
         b = subIterators.get(subIterators.size() - 1).start();
         i = 1;
@@ -171,11 +190,24 @@ abstract class IntervalFunction {
       return gaps;
     }
 
+    @Override
+    public float boost() {
+      if (hasBoosts == false) {
+        return 1;
+      }
+      float boost = firstBoost;
+      for (int i = 1; i < subIterators.size(); i++) {
+        boost *= subIterators.get(i).boost();
+      }
+      return boost;
+    }
+
     @Override
     protected void reset() throws IOException {
       subIterators.get(0).nextInterval();
       i = 1;
       start = end = firstEnd = -1;
+      firstBoost = 1;
     }
   }
 
@@ -184,8 +216,8 @@ abstract class IntervalFunction {
    */
   static final IntervalFunction UNORDERED = new SingletonFunction("UNORDERED") {
     @Override
-    public IntervalIterator apply(List<IntervalIterator> intervalIterators) {
-      return new UnorderedIntervalIterator(intervalIterators, true);
+    public IntervalIterator apply(List<IntervalIterator> intervalIterators, boolean hasBoosts) {
+      return new UnorderedIntervalIterator(intervalIterators, true, hasBoosts);
     }
   };
 
@@ -194,8 +226,8 @@ abstract class IntervalFunction {
    */
   static final IntervalFunction UNORDERED_NO_OVERLAP = new SingletonFunction("UNORDERED_NO_OVERLAP") {
     @Override
-    public IntervalIterator apply(List<IntervalIterator> iterators) {
-      return new UnorderedIntervalIterator(iterators, false);
+    public IntervalIterator apply(List<IntervalIterator> iterators, boolean hasBoosts) {
+      return new UnorderedIntervalIterator(iterators, false, hasBoosts);
     }
   };
 
@@ -205,10 +237,12 @@ abstract class IntervalFunction {
     private final IntervalIterator[] subIterators;
     private final int[] innerPositions;
     private final boolean allowOverlaps;
+    private final boolean hasBoosts;
 
     int start = -1, end = -1, firstEnd, queueEnd;
+    float firstBoost;
 
-    UnorderedIntervalIterator(List<IntervalIterator> subIterators, boolean allowOverlaps) {
+    UnorderedIntervalIterator(List<IntervalIterator> subIterators, boolean allowOverlaps, boolean hasBoosts) {
       super(subIterators);
       this.queue = new PriorityQueue<IntervalIterator>(subIterators.size()) {
         @Override
@@ -219,6 +253,7 @@ abstract class IntervalFunction {
       this.subIterators = new IntervalIterator[subIterators.size()];
       this.innerPositions = new int[subIterators.size() * 2];
       this.allowOverlaps = allowOverlaps;
+      this.hasBoosts = hasBoosts;
 
       for (int i = 0; i < subIterators.size(); i++) {
         this.subIterators[i] = subIterators.get(i);
@@ -264,6 +299,7 @@ abstract class IntervalFunction {
       do {
         start = queue.top().start();
         firstEnd = queue.top().end();
+        firstBoost = hasBoosts ? queue.top().boost() : 1.0f;
         end = queueEnd;
         if (queue.top().end() == end)
           return start;
@@ -303,9 +339,24 @@ abstract class IntervalFunction {
       return gaps;
     }
 
+    @Override
+    public float boost() {
+      if (hasBoosts == false) {
+        return 1.0f;
+      }
+      float boost = firstBoost;
+      for (int i = 0; i < subIterators.length; i++) {
+        if (subIterators[i].end() <= end) {
+          boost *= subIterators[i].boost();
+        }
+      }
+      return boost;
+    }
+
     @Override
     protected void reset() throws IOException {
       queueEnd = start = end = -1;
+      firstBoost = 1;
       this.queue.clear();
       loop: for (IntervalIterator it : subIterators) {
         if (it.nextInterval() == NO_MORE_INTERVALS) {
@@ -348,7 +399,7 @@ abstract class IntervalFunction {
    */
   static final IntervalFunction CONTAINING = new SingletonFunction("CONTAINING") {
     @Override
-    public IntervalIterator apply(List<IntervalIterator> iterators) {
+    public IntervalIterator apply(List<IntervalIterator> iterators, boolean hasBoosts) {
       if (iterators.size() != 2)
         throw new IllegalStateException("CONTAINING function requires two iterators");
       IntervalIterator a = iterators.get(0);
@@ -377,7 +428,7 @@ abstract class IntervalFunction {
    */
   static final IntervalFunction CONTAINED_BY = new SingletonFunction("CONTAINED_BY") {
     @Override
-    public IntervalIterator apply(List<IntervalIterator> iterators) {
+    public IntervalIterator apply(List<IntervalIterator> iterators, boolean hasBoosts) {
       if (iterators.size() != 2)
         throw new IllegalStateException("CONTAINED_BY function requires two iterators");
       IntervalIterator a = iterators.get(0);
@@ -406,7 +457,7 @@ abstract class IntervalFunction {
 
   static final IntervalFunction OVERLAPPING = new SingletonFunction("OVERLAPPING") {
     @Override
-    public IntervalIterator apply(List<IntervalIterator> iterators) {
+    public IntervalIterator apply(List<IntervalIterator> iterators, boolean hasBoosts) {
       if (iterators.size() != 2)
         throw new IllegalStateException("OVERLAPPING function requires two iterators");
       IntervalIterator a = iterators.get(0);
@@ -467,6 +518,11 @@ abstract class IntervalFunction {
       return a.gaps();
     }
 
+    @Override
+    public float boost() {
+      return a.boost();
+    }
+
     @Override
     protected void reset() throws IOException {
       bpos = b.nextInterval() != NO_MORE_INTERVALS;
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalIterator.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalIterator.java
index 305f56cf42..5a4eb57509 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalIterator.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalIterator.java
@@ -32,7 +32,11 @@ import org.apache.lucene.search.TwoPhaseIterator;
  *
  * The limits of the current interval are returned by {@link #start()} and {@link #end()}.
  * When the iterator has been moved to a new document, but before {@link #nextInterval()}
- * has been called, both these methods return {@code -1}.
+ * has been called, both these methods return {@code -1}.  After {@link #nextInterval()}
+ * has returned {@link #NO_MORE_INTERVALS} both these methods return {@link #NO_MORE_INTERVALS}.
+ *
+ * The methods {@link #gaps()} and {@link #boost()} should only be called while intervals
+ * are being iterated.
  *
  * Note that it is possible for a document to return {@link #NO_MORE_INTERVALS}
  * on the first call to {@link #nextInterval()}
@@ -47,17 +51,11 @@ public abstract class IntervalIterator extends DocIdSetIterator {
 
   /**
    * The start of the current interval
-   *
-   * Returns -1 if {@link #nextInterval()} has not yet been called and {@link #NO_MORE_INTERVALS}
-   * once the iterator is exhausted.
    */
   public abstract int start();
 
   /**
    * The end of the current interval
-   *
-   * Returns -1 if {@link #nextInterval()} has not yet been called and {@link #NO_MORE_INTERVALS}
-   * once the iterator is exhausted.
    */
   public abstract int end();
 
@@ -66,12 +64,14 @@ public abstract class IntervalIterator extends DocIdSetIterator {
    *
    * Note that this returns the number of gaps between the immediate sub-intervals
    * of this interval, and does not include the gaps inside those sub-intervals.
-   *
-   * Should not be called before {@link #nextInterval()}, or after it has returned
-   * {@link #NO_MORE_INTERVALS}
    */
   public abstract int gaps();
 
+  /**
+   * An optional boost for the current interval, to be used in scoring
+   */
+  public abstract float boost();
+
   /**
    * Advance the iterator to the next interval
    *
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalMatches.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalMatches.java
index 24424d2159..20e35de66e 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalMatches.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalMatches.java
@@ -107,6 +107,15 @@ final class IntervalMatches {
         return 0;
       }
 
+      @Override
+      public float boost() {
+        assert state == State.ITERATING;
+        if (mi instanceof IntervalMatchesIterator) {
+          return ((IntervalMatchesIterator) mi).boost();
+        }
+        return 1;
+      }
+
       @Override
       public int nextInterval() throws IOException {
         assert state == State.ITERATING;
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalMatchesIterator.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalMatchesIterator.java
index 55482e38cc..67eecefbc8 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalMatchesIterator.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalMatchesIterator.java
@@ -35,4 +35,9 @@ interface IntervalMatchesIterator extends MatchesIterator {
    */
   int gaps();
 
+  /**
+   * The boost of the Interval underlying the current match
+   */
+  float boost();
+
 }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalQuery.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalQuery.java
index 62fe0679bf..db5a748f8e 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalQuery.java
@@ -20,6 +20,7 @@ package org.apache.lucene.search.intervals;
 import java.io.IOException;
 import java.util.Objects;
 import java.util.Set;
+import java.util.function.ToDoubleFunction;
 
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
@@ -134,6 +135,12 @@ public final class IntervalQuery extends Query {
     return Objects.hash(field, intervalsSource);
   }
 
+  private static final ToDoubleFunction<IntervalIterator> DEFAULT_SCORING_FUNCTION =
+      interval -> (1.0 / (interval.end() - interval.start() + 1));
+
+  private static final ToDoubleFunction<IntervalIterator> BOOSTING_SCORING_FUNCTION =
+      interval -> interval.boost() * (1.0 / (interval.end() - interval.start() + 1));
+
   private class IntervalWeight extends Weight {
 
     final ScoreMode scoreMode;
@@ -184,7 +191,10 @@ public final class IntervalQuery extends Query {
       IntervalIterator intervals = intervalsSource.intervals(field, context);
       if (intervals == null)
         return null;
-      return new IntervalScorer(this, intervals, intervalsSource.minExtent(), boost, scoreFunction);
+      ToDoubleFunction<IntervalIterator> freqFunction = intervalsSource.hasBoost() ?
+          interval -> interval.boost() / (interval.end() - interval.start() - intervalsSource.minExtent() + 2) :
+          interval -> 1.0 / (interval.end() - interval.start() - intervalsSource.minExtent() + 2);
+      return new IntervalScorer(this, intervals, boost, scoreFunction, freqFunction);
     }
 
     @Override
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalScorer.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalScorer.java
index 18b88994fc..1e8bdf6531 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalScorer.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalScorer.java
@@ -18,6 +18,7 @@
 package org.apache.lucene.search.intervals;
 
 import java.io.IOException;
+import java.util.function.ToDoubleFunction;
 
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.Scorer;
@@ -28,17 +29,18 @@ import org.apache.lucene.search.similarities.Similarity;
 class IntervalScorer extends Scorer {
 
   private final IntervalIterator intervals;
-  private final Similarity.SimScorer simScorer;
+  private final ToDoubleFunction<IntervalIterator> freqFunction;
   private final float boost;
-  private final int minExtent;
+  private final Similarity.SimScorer simScorer;
 
   private float freq;
   private int lastScoredDoc = -1;
 
-  IntervalScorer(Weight weight, IntervalIterator intervals, int minExtent, float boost, IntervalScoreFunction scoreFunction) {
+  IntervalScorer(Weight weight, IntervalIterator intervals, float boost, IntervalScoreFunction scoreFunction,
+                           ToDoubleFunction<IntervalIterator> freqFunction) {
     super(weight);
     this.intervals = intervals;
-    this.minExtent = minExtent;
+    this.freqFunction = freqFunction;
     this.boost = boost;
     this.simScorer = scoreFunction.scorer(boost);
   }
@@ -64,8 +66,7 @@ class IntervalScorer extends Scorer {
       lastScoredDoc = docID();
       freq = 0;
       do {
-        int length = (intervals.end() - intervals.start() + 1);
-        freq += 1.0 / Math.max(length - minExtent + 1, 1);
+        freq += freqFunction.applyAsDouble(intervals);
       }
       while (intervals.nextInterval() != IntervalIterator.NO_MORE_INTERVALS);
     }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/Intervals.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/Intervals.java
index e8c4cb01aa..7908431baf 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/Intervals.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/Intervals.java
@@ -79,6 +79,13 @@ public final class Intervals {
     return new DisjunctionIntervalsSource(Arrays.asList(subSources));
   }
 
+  /**
+   * Boost an {@link IntervalsSource} so that it counts more for scoring
+   */
+  public static IntervalsSource boost(float boost, IntervalsSource in) {
+    return new BoostingIntervalsSource(in, boost);
+  }
+
   /**
    * Return an {@link IntervalsSource} over the disjunction of all terms that begin with a prefix
    *
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalsSource.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalsSource.java
index dc4161fa05..639f868d12 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalsSource.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalsSource.java
@@ -62,6 +62,11 @@ public abstract class IntervalsSource {
    */
   public abstract void extractTerms(String field, Set<Term> terms);
 
+  /**
+   * @return {@code true} if this source returns intervals that may have a boost other than {@code 1}
+   */
+  public abstract boolean hasBoost();
+
   /**
    * Return the minimum possible width of an interval returned by this source
    */
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/MinimizingConjunctionIntervalsSource.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/MinimizingConjunctionIntervalsSource.java
index 6e6f563b3d..71115b8e5a 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/MinimizingConjunctionIntervalsSource.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/MinimizingConjunctionIntervalsSource.java
@@ -49,7 +49,8 @@ class MinimizingConjunctionIntervalsSource extends ConjunctionIntervalsSource {
       }
       subs.add(new CachingMatchesIterator(mi));
     }
-    IntervalIterator it = function.apply(subs.stream().map(m -> IntervalMatches.wrapMatches(m, doc)).collect(Collectors.toList()));
+    IntervalIterator it
+        = function.apply(subs.stream().map(m -> IntervalMatches.wrapMatches(m, doc)).collect(Collectors.toList()), hasBoost());
     if (it.advance(doc) != doc) {
       return null;
     }
@@ -114,6 +115,11 @@ class MinimizingConjunctionIntervalsSource extends ConjunctionIntervalsSource {
       return iterator.gaps();
     }
 
+    @Override
+    public float boost() {
+      return iterator.boost();
+    }
+
     @Override
     public MatchesIterator getSubMatches() throws IOException {
       List<MatchesIterator> mis = new ArrayList<>();
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/MinimumShouldMatchIntervalsSource.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/MinimumShouldMatchIntervalsSource.java
index 1935c628ee..b6011a4573 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/MinimumShouldMatchIntervalsSource.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/MinimumShouldMatchIntervalsSource.java
@@ -58,7 +58,7 @@ class MinimumShouldMatchIntervalsSource extends IntervalsSource {
     if (iterators.size() < minShouldMatch) {
       return null;
     }
-    return new MinimumShouldMatchIntervalIterator(iterators, minShouldMatch);
+    return new MinimumShouldMatchIntervalIterator(iterators, minShouldMatch, hasBoost());
   }
 
   @Override
@@ -74,7 +74,7 @@ class MinimumShouldMatchIntervalsSource extends IntervalsSource {
     if (lookup.size() < minShouldMatch) {
       return null;
     }
-    MinimumShouldMatchIntervalIterator it = new MinimumShouldMatchIntervalIterator(lookup.keySet(), minShouldMatch);
+    MinimumShouldMatchIntervalIterator it = new MinimumShouldMatchIntervalIterator(lookup.keySet(), minShouldMatch, hasBoost());
     if (it.advance(doc) != doc) {
       return null;
     }
@@ -91,6 +91,16 @@ class MinimumShouldMatchIntervalsSource extends IntervalsSource {
     }
   }
 
+  @Override
+  public boolean hasBoost() {
+    for (IntervalsSource source : sources) {
+      if (source.hasBoost()) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   @Override
   public int minExtent() {
     int[] subExtents = new int[sources.length];
@@ -149,11 +159,13 @@ class MinimumShouldMatchIntervalsSource extends IntervalsSource {
     private final int minShouldMatch;
     private final int[] innerPositions;
     private final Collection<IntervalIterator> currentIterators = new ArrayList<>();
+    private final boolean hasBoost;
 
     private int start, end, queueEnd, firstEnd;
+    private float firstBoost;
     private IntervalIterator lead;
 
-    MinimumShouldMatchIntervalIterator(Collection<IntervalIterator> subs, int minShouldMatch) {
+    MinimumShouldMatchIntervalIterator(Collection<IntervalIterator> subs, int minShouldMatch, boolean hasBoost) {
       this.disiQueue = new DisiPriorityQueue(subs.size());
       float mc = 0;
       for (IntervalIterator it : subs) {
@@ -164,6 +176,7 @@ class MinimumShouldMatchIntervalsSource extends IntervalsSource {
       this.matchCost = mc;
       this.minShouldMatch = minShouldMatch;
       this.innerPositions = new int[minShouldMatch * 2];
+      this.hasBoost = hasBoost;
 
       this.proximityQueue = new PriorityQueue<IntervalIterator>(minShouldMatch) {
         @Override
@@ -216,6 +229,23 @@ class MinimumShouldMatchIntervalsSource extends IntervalsSource {
       return gaps;
     }
 
+    @Override
+    public float boost() {
+      float boost = 1;
+      if (hasBoost == false) {
+        return boost;
+      }
+      for (IntervalIterator it : proximityQueue) {
+        if (it.end() > end) {
+          boost *= firstBoost;
+        }
+        else {
+          boost *= it.boost();
+        }
+      }
+      return boost;
+    }
+
     @Override
     public int nextInterval() throws IOException {
       // first, find a matching interval beyond the current start
@@ -235,6 +265,7 @@ class MinimumShouldMatchIntervalsSource extends IntervalsSource {
       do {
         start = proximityQueue.top().start();
         firstEnd = proximityQueue.top().end();
+        firstBoost = hasBoost ? proximityQueue.top().boost() : 1.0f;
         end = queueEnd;
         if (proximityQueue.top().end() == end)
           return start;
@@ -381,6 +412,11 @@ class MinimumShouldMatchIntervalsSource extends IntervalsSource {
       return iterator.gaps();
     }
 
+    @Override
+    public float boost() {
+      return iterator.boost();
+    }
+
     @Override
     public MatchesIterator getSubMatches() throws IOException {
       List<MatchesIterator> mis = new ArrayList<>();
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/MultiTermIntervalsSource.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/MultiTermIntervalsSource.java
index 7689d1dc48..86177b748f 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/MultiTermIntervalsSource.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/MultiTermIntervalsSource.java
@@ -93,6 +93,11 @@ class MultiTermIntervalsSource extends IntervalsSource {
 
   }
 
+  @Override
+  public boolean hasBoost() {
+    return false;
+  }
+
   @Override
   public int minExtent() {
     return 1;
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/OffsetIntervalsSource.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/OffsetIntervalsSource.java
index b2ca30224e..dc9408fe0c 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/OffsetIntervalsSource.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/OffsetIntervalsSource.java
@@ -84,12 +84,10 @@ class OffsetIntervalsSource extends IntervalsSource {
     }
   }
 
-  private static abstract class OffsetIntervalIterator extends IntervalIterator {
-
-    final IntervalIterator in;
+  private static abstract class OffsetIntervalIterator extends FilterIntervalIterator {
 
     OffsetIntervalIterator(IntervalIterator in) {
-      this.in = in;
+      super(in);
     }
 
     @Override
@@ -108,30 +106,6 @@ class OffsetIntervalsSource extends IntervalsSource {
       return start();
     }
 
-    @Override
-    public float matchCost() {
-      return in.matchCost();
-    }
-
-    @Override
-    public int docID() {
-      return in.docID();
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-      return in.nextDoc();
-    }
-
-    @Override
-    public int advance(int target) throws IOException {
-      return in.advance(target);
-    }
-
-    @Override
-    public long cost() {
-      return in.cost();
-    }
   }
 
   @Override
@@ -148,6 +122,11 @@ class OffsetIntervalsSource extends IntervalsSource {
     in.extractTerms(field, terms);
   }
 
+  @Override
+  public boolean hasBoost() {
+    return in.hasBoost();
+  }
+
   @Override
   public int minExtent() {
     return 1;
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/TermIntervalsSource.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/TermIntervalsSource.java
index 4539d2f2cb..722fdc38a4 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/TermIntervalsSource.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/TermIntervalsSource.java
@@ -104,6 +104,11 @@ class TermIntervalsSource extends IntervalsSource {
         return 0;
       }
 
+      @Override
+      public float boost() {
+        return 1;
+      }
+
       @Override
       public int nextInterval() throws IOException {
         if (upto <= 0)
@@ -203,6 +208,11 @@ class TermIntervalsSource extends IntervalsSource {
     };
   }
 
+  @Override
+  public boolean hasBoost() {
+    return false;
+  }
+
   @Override
   public int minExtent() {
     return 1;
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/intervals/TestIntervalQuery.java b/lucene/sandbox/src/test/org/apache/lucene/search/intervals/TestIntervalQuery.java
index 9cea616b3a..a59812a54e 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/search/intervals/TestIntervalQuery.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/search/intervals/TestIntervalQuery.java
@@ -71,7 +71,8 @@ public class TestIntervalQuery extends LuceneTestCase {
       "w2 w1",
       "w2 w1 w3 w2 w4",
       "coordinate genome mapping research",
-      "coordinate genome research"
+      "coordinate genome research",
+      "coordinate genome investigation"
   };
 
   private void checkHits(Query query, int[] results) throws IOException {
@@ -197,6 +198,38 @@ public class TestIntervalQuery extends LuceneTestCase {
     checkHits(q, new int[]{ 1, 2, 5 });
   }
 
+  public void testIntervalBoosts() throws IOException {
+    IntervalsSource source1 = Intervals.ordered(
+        Intervals.term("coordinate"),
+        Intervals.or(
+            Intervals.term("research"),
+            Intervals.term("investigation")));
+
+    // hits in three docs: first two have the same freq and extent, so appear in doc
+    // order; third has the same freq but a longer extent, resulting in a lower score
+
+    TopDocs td = searcher.search(new IntervalQuery(field, source1), 5);
+    assertEquals(3, td.totalHits.value);
+    assertEquals(7, td.scoreDocs[0].doc);
+    assertEquals(8, td.scoreDocs[1].doc);
+    assertEquals(6, td.scoreDocs[2].doc);
+
+    IntervalsSource source2 = Intervals.ordered(
+        Intervals.term("coordinate"),
+        Intervals.or(
+            Intervals.term("research"),
+            Intervals.boost(4, Intervals.term("investigation"))));
+
+    // same hits, but this time doc 8 appears at the top because its freq is increased by
+    // the boost from matching 'investigation'
+
+    td = searcher.search(new IntervalQuery(field, source2), 5);
+    assertEquals(3, td.totalHits.value);
+    assertEquals(8, td.scoreDocs[0].doc);
+    assertEquals(7, td.scoreDocs[1].doc);
+    assertEquals(6, td.scoreDocs[2].doc);
+  }
+
   public void testScoring() throws IOException {
 
     IntervalsSource source = Intervals.ordered(Intervals.or(Intervals.term("w1"), Intervals.term("w2")), Intervals.term("w3"));
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/intervals/TestIntervals.java b/lucene/sandbox/src/test/org/apache/lucene/search/intervals/TestIntervals.java
index c8452a8b67..997819e4d5 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/search/intervals/TestIntervals.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/search/intervals/TestIntervals.java
@@ -18,6 +18,7 @@
 package org.apache.lucene.search.intervals;
 
 import java.io.IOException;
+import java.util.Set;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.CharArraySet;
@@ -35,6 +36,7 @@ import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.ReaderUtil;
+import org.apache.lucene.index.Term;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchesIterator;
 import org.apache.lucene.store.Directory;
@@ -165,6 +167,20 @@ public class TestIntervals extends LuceneTestCase {
     }
   }
 
+  private void assertBoosts(IntervalsSource source, int doc, String field, float[] expectedBoosts) throws IOException {
+    int ord = ReaderUtil.subIndex(doc, searcher.getIndexReader().leaves());
+    LeafReaderContext ctx = searcher.getIndexReader().leaves().get(ord);
+    IntervalIterator it = source.intervals(field, ctx);
+    doc = doc - ctx.docBase;
+    assertEquals(doc, it.advance(doc));
+    for (float expectedBoost : expectedBoosts) {
+      if (it.nextInterval() == IntervalIterator.NO_MORE_INTERVALS) {
+        fail("Unexpected interval " + it);
+      }
+      assertEquals(expectedBoost, it.boost(), 0f);
+    }
+  }
+
   public void testIntervalsOnFieldWithNoPositions() throws IOException {
     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> {
       Intervals.term("wibble").intervals("id", searcher.getIndexReader().leaves().get(0));
@@ -762,4 +778,143 @@ public class TestIntervals extends LuceneTestCase {
     assertMatch(mi, 17, 17, 97, 100);
   }
 
+  public void testBoosts() throws IOException {
+    IntervalsSource source = Intervals.phrase(
+        Intervals.term("pease"),
+        Intervals.term("porridge"),
+        Intervals.or(Intervals.term("hot"), Intervals.boost(2, Intervals.term("cold"))));
+
+    checkIntervals(source, "field1", 3, new int[][]{
+        {},
+        { 0, 2, 3, 5 },
+        { 0, 2, 3, 5 },
+        {},
+        { 0, 2, 3, 5 },
+        {}
+    });
+
+    assertBoosts(source, 1, "field1", new float[]{ 1, 2 });
+    assertBoosts(source, 2, "field1", new float[]{ 2, 1 });
+
+    IntervalsSource source1 = Intervals.ordered(
+        Intervals.term("pease"),
+        Intervals.term("porridge"),
+        Intervals.or(Intervals.term("hot"), Intervals.boost(2, Intervals.term("cold"))));
+
+    checkIntervals(source1, "field1", 3, new int[][]{
+        {},
+        { 0, 2, 3, 5, 6, 17 },
+        { 0, 2, 3, 5, 6, 17 },
+        {},
+        { 0, 2, 3, 5, 6, 17 },
+        {}
+    });
+
+    assertBoosts(source1, 1, "field1", new float[]{ 1, 2, 1 });
+    assertBoosts(source1, 2, "field1", new float[]{ 2, 1, 2 });
+
+    IntervalsSource source2 = Intervals.unordered(
+        Intervals.term("pease"),
+        Intervals.term("porridge"),
+        Intervals.or(Intervals.term("hot"), Intervals.boost(2, Intervals.term("cold"))));
+
+    checkIntervals(source2, "field1", 3, new int[][]{
+        {},
+        { 0, 2, 1, 3, 2, 4, 3, 5, 4, 6, 5, 7, 6, 17 },
+        { 0, 2, 1, 3, 2, 4, 3, 5, 4, 6, 5, 7, 6, 17 },
+        {},
+        { 0, 2, 1, 3, 2, 4, 3, 5, 4, 6, 5, 7, 6, 17 },
+        {}
+    });
+
+    assertBoosts(source2, 1, "field1", new float[]{ 1, 1, 1, 2, 2, 2, 1 });
+    assertBoosts(source2, 2, "field1", new float[]{ 2, 2, 2, 1, 1, 1, 2 });
+  }
+
+  public void testMinimizingConjunctionAvoidsCallingBoost() throws IOException {
+
+    // minimizing conjunctions (ordered, unordered) need to cache their lead iterator's
+    // boost during minimization.  In order to avoid expensive boost calculations when
+    // the actual boost is just 1, IntervalFunction takes a hasBoost parameter, and avoids
+    // these calculations if it is false.  Here we check that this intercept
+    // is applied by substituting in a source that produces iterators which throw exceptions
+    // if their boost() method is called.
+
+    IntervalsSource source = Intervals.unordered(
+        Intervals.term("pease"),
+        Intervals.term("porridge"),
+        Intervals.or(Intervals.term("hot"), new ExceptionOnBoostIntervalsSource(Intervals.term("cold"))));
+
+    assertBoosts(source, 1, "field1", new float[]{ 1, 1 });
+
+    IntervalsSource source2 = Intervals.atLeast(3,
+        Intervals.term("porridge"), Intervals.term("hot"), Intervals.term("twelve"),
+        Intervals.term("nine"), new ExceptionOnBoostIntervalsSource(Intervals.term("pease")));
+
+    assertBoosts(source2, 1, "field1", new float[]{ 1, 1, 1, 1, 1 });
+
+    IntervalsSource source3 = Intervals.ordered(
+        Intervals.term("pease"),
+        Intervals.term("porridge"),
+        Intervals.or(Intervals.term("hot"), new ExceptionOnBoostIntervalsSource(Intervals.term("cold"))));
+
+    assertBoosts(source3, 1, "field1", new float[]{ 1, 1 });
+
+  }
+
+  private static class ExceptionOnBoostIntervalsSource extends IntervalsSource {
+
+    final IntervalsSource in;
+
+    private ExceptionOnBoostIntervalsSource(IntervalsSource in) {
+      this.in = in;
+    }
+
+    @Override
+    public IntervalIterator intervals(String field, LeafReaderContext ctx) throws IOException {
+      IntervalIterator it = in.intervals(field, ctx);
+      return new FilterIntervalIterator(it) {
+        @Override
+        public float boost() {
+          throw new AssertionError("Boost() should not be called!");
+        }
+      };
+    }
+
+    @Override
+    public MatchesIterator matches(String field, LeafReaderContext ctx, int doc) throws IOException {
+      return in.matches(field, ctx, doc);
+    }
+
+    @Override
+    public void extractTerms(String field, Set<Term> terms) {
+      in.extractTerms(field, terms);
+    }
+
+    @Override
+    public boolean hasBoost() {
+      return false;
+    }
+
+    @Override
+    public int minExtent() {
+      return in.minExtent();
+    }
+
+    @Override
+    public int hashCode() {
+      return 0;
+    }
+
+    @Override
+    public boolean equals(Object other) {
+      return false;
+    }
+
+    @Override
+    public String toString() {
+      return null;
+    }
+  }
+
 }
