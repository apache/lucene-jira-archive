From 13784bfb2299fe5e00c3c71562275778bbe39ac6 Mon Sep 17 00:00:00 2001
From: Mike Drob <mdrob@cloudera.com>
Date: Thu, 27 Aug 2015 09:01:39 -0500
Subject: [PATCH] LUCENE-6762 Add option to skip missing segments

Adds an option to CheckIndex and SegmentInfos to skip missing .si files
on initial read.
---
 .../java/org/apache/lucene/index/CheckIndex.java   | 43 ++++++++++++--
 .../java/org/apache/lucene/index/SegmentInfos.java | 65 ++++++++++++++++++----
 .../org/apache/lucene/index/TestCheckIndex.java    | 29 ++++++++++
 3 files changed, 122 insertions(+), 15 deletions(-)

diff --git a/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java b/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
index 9c4b83b..a68eb83 100644
--- a/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
+++ b/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
@@ -31,6 +31,7 @@ import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
+import java.util.Set;
 
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.codecs.DocValuesProducer;
@@ -134,6 +135,9 @@ public class CheckIndex implements Closeable {
     /** How many bad segments were found. */
     public int numBadSegments;
 
+    /** Set of missing segments info files */
+    public Set<String> missingSegmentInfos;
+
     /** True if we checked only specific segments ({@link
      * #checkIndex(List)}) was called with non-null
      * argument). */
@@ -433,6 +437,9 @@ public class CheckIndex implements Closeable {
   public void setInfoStream(PrintStream out, boolean verbose) {
     infoStream = out;
     this.verbose = verbose;
+    if (verbose) {
+      SegmentInfos.setInfoStream(infoStream);
+    }
   }
 
   /** Set infoStream where messages should go. See {@link #setInfoStream(PrintStream,boolean)}. */
@@ -467,6 +474,19 @@ public class CheckIndex implements Closeable {
    *  segments, on a large index it can take quite a long
    *  time to run. */
   public Status checkIndex(List<String> onlySegments) throws IOException {
+    return checkIndex(onlySegments, false);
+  }
+
+  /** Returns a {@link Status} instance detailing
+   *  the state of the index.
+   *
+   *  @param onlySegments list of specific segment names to check
+   *  @param skipMissing whether to skip missing segment info or error
+   *
+   *  <p>As this method checks every byte in the specified
+   *  segments, on a large index it can take quite a long
+   *  time to run. */
+  public Status checkIndex(List<String> onlySegments, boolean skipMissing) throws IOException {
     ensureOpen();
     long startNS = System.nanoTime();
     NumberFormat nf = NumberFormat.getInstance(Locale.ROOT);
@@ -481,7 +501,7 @@ public class CheckIndex implements Closeable {
     try {
       // Do not use SegmentInfos.read(Directory) since the spooky
       // retrying it does is not necessary here (we hold the write lock):
-      sis = SegmentInfos.readCommit(dir, lastSegmentsFile);
+      sis = SegmentInfos.readCommit(dir, lastSegmentsFile, skipMissing);
     } catch (Throwable t) {
       if (failFast) {
         IOUtils.reThrow(t);
@@ -753,10 +773,18 @@ public class CheckIndex implements Closeable {
       result.newSegments.add(info.clone());
     }
 
-    if (0 == result.numBadSegments) {
-      result.clean = true;
-    } else
+    result.missingSegmentInfos = sis.getMissingSegmentInfos();
+    int numMissingSegments = result.missingSegmentInfos.size();
+
+    result.clean = true; // assume we're good
+    if (0 < result.numBadSegments) {
       msg(infoStream, "WARNING: " + result.numBadSegments + " broken segments (containing " + result.totLoseDocCount + " documents) detected");
+      result.clean = false;
+    }
+    if (0 < numMissingSegments) {
+      msg(infoStream, "WARNING: " + numMissingSegments + " missing segments (containing an unknown number of documents) detected");
+      result.clean = false;
+    }
 
     if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {
       result.clean = false;
@@ -2226,6 +2254,7 @@ public class CheckIndex implements Closeable {
     boolean doExorcise = false;
     boolean doCrossCheckTermVectors = false;
     boolean verbose = false;
+    boolean skipMissing = false;
     boolean doChecksumsOnly = false;
     List<String> onlySegments = new ArrayList<>();
     String indexPath = null;
@@ -2241,6 +2270,8 @@ public class CheckIndex implements Closeable {
         doCrossCheckTermVectors = true;
       } else if (arg.equals("-verbose")) {
         verbose = true;
+      } else if (arg.equals("-skipMissing")) {
+        skipMissing = true;
       } else if (arg.equals("-segment")) {
         if (i == args.length-1) {
           System.out.println("ERROR: missing name for -segment option");
@@ -2274,6 +2305,7 @@ public class CheckIndex implements Closeable {
                          "  -crossCheckTermVectors: verifies that term vectors match postings; THIS IS VERY SLOW!\n" +
                          "  -codec X: when exorcising, codec to write the new segments_N file with\n" +
                          "  -verbose: print additional details\n" +
+                         "  -skipMissing: skip missing .si files instead of erroring immediately. With -exorcise, they will be removed from the segments_n file completely.\n" +
                          "  -segment X: only check the specified segments.  This can be specified multiple\n" + 
                          "              times, to check more than one segment, eg '-segment _2 -segment _a'.\n" +
                          "              You can't use this with the -exorcise option\n" +
@@ -2332,7 +2364,7 @@ public class CheckIndex implements Closeable {
       checker.setChecksumsOnly(doChecksumsOnly);
       checker.setInfoStream(System.out, verbose);
       
-      Status result = checker.checkIndex(onlySegments);
+      Status result = checker.checkIndex(onlySegments, skipMissing);
       if (result.missingSegments) {
         return 1;
       }
@@ -2342,6 +2374,7 @@ public class CheckIndex implements Closeable {
           System.out.println("WARNING: would write new segments file, and " + result.totLoseDocCount + " documents would be lost, if -exorcise were specified\n");
         } else {
           System.out.println("WARNING: " + result.totLoseDocCount + " documents will be lost\n");
+          System.out.println("WARNING: " + result.missingSegmentInfos.size() + " additional segment files will be lost\n");
           System.out.println("NOTE: will write new segments file in 5 seconds; this will remove " + result.totLoseDocCount + " docs from the index. YOU WILL LOSE DATA. THIS IS YOUR LAST CHANCE TO CTRL+C!");
           for(int s=0;s<5;s++) {
             Thread.sleep(1000);
diff --git a/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java b/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
index de5dbff..becc40f 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
@@ -32,6 +32,7 @@ import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.Version;
 
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.PrintStream;
 import java.util.ArrayList;
@@ -145,6 +146,9 @@ public final class SegmentInfos implements Cloneable, Iterable<SegmentCommitInfo
   
   private List<SegmentCommitInfo> segments = new ArrayList<>();
   
+  /** Set of segments for which we could not find .si files, if instructed to skip them */
+  private Set<String> missingSegmentInfo = new HashSet<>();
+
   /**
    * If non-null, information about loading segments_N files
    * will be printed here.  @see #setInfoStream.
@@ -277,7 +281,20 @@ public final class SegmentInfos implements Cloneable, Iterable<SegmentCommitInfo
    * @throws IOException if there is a low-level IO error
    */
   public static final SegmentInfos readCommit(Directory directory, String segmentFileName) throws IOException {
+    return readCommit(directory, segmentFileName, false);
+  }
 
+  /**
+   * Read a particular segmentFileName.  Note that this may
+   * throw an IOException if a commit is in process.
+   *
+   * @param directory -- directory containing the segments file
+   * @param segmentFileName -- segment file to load
+   * @param skipMissing -- behavior for missing segment info
+   * @throws CorruptIndexException if the index is corrupt
+   * @throws IOException if there is a low-level IO error
+   */
+  public static final SegmentInfos readCommit(Directory directory, String segmentFileName, boolean skipMissing) throws IOException {
     long generation = generationFromSegmentsFileName(segmentFileName);
     try (ChecksumIndexInput input = directory.openChecksumInput(segmentFileName, IOContext.READ)) {
       // NOTE: as long as we want to throw indexformattooold (vs corruptindexexception), we need
@@ -338,24 +355,20 @@ public final class SegmentInfos implements Cloneable, Iterable<SegmentCommitInfo
           throw new CorruptIndexException("invalid hasID byte, got: " + hasID, input);
         }
         Codec codec = readCodec(input, format < VERSION_53);
-        SegmentInfo info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);
-        info.setCodec(codec);
-        totalDocs += info.maxDoc();
+
+        // Read everything from input first, in case we skip this segment
         long delGen = input.readLong();
         int delCount = input.readInt();
-        if (delCount < 0 || delCount > info.maxDoc()) {
-          throw new CorruptIndexException("invalid deletion count: " + delCount + " vs maxDoc=" + info.maxDoc(), input);
-        }
         long fieldInfosGen = input.readLong();
         long dvGen = input.readLong();
-        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);
+        Set<String> fieldInfoFiles;
         if (format >= VERSION_51) {
-          siPerCommit.setFieldInfosFiles(input.readSetOfStrings());
+          fieldInfoFiles = input.readSetOfStrings();
         } else {
-          siPerCommit.setFieldInfosFiles(Collections.unmodifiableSet(input.readStringSet()));
+          fieldInfoFiles = Collections.unmodifiableSet(input.readStringSet());
         }
-        final Map<Integer,Set<String>> dvUpdateFiles;
         final int numDVFields = input.readInt();
+        final Map<Integer,Set<String>> dvUpdateFiles;
         if (numDVFields == 0) {
           dvUpdateFiles = Collections.emptyMap();
         } else {
@@ -369,6 +382,28 @@ public final class SegmentInfos implements Cloneable, Iterable<SegmentCommitInfo
           }
           dvUpdateFiles = Collections.unmodifiableMap(map);
         }
+
+        SegmentInfo info;
+        try {
+          info = codec.segmentInfoFormat().read(directory, segName, segmentID, IOContext.READ);
+        } catch (FileNotFoundException e) {
+          if (skipMissing) {
+            if (infoStream != null) {
+              message("Skipping missing segment info file: " + segName);
+            }
+            infos.addMissingSegmentInfo(segName);
+            continue;
+          } else {
+            throw e;
+          }
+        }
+        info.setCodec(codec);
+        totalDocs += info.maxDoc();
+        if (delCount < 0 || delCount > info.maxDoc()) {
+          throw new CorruptIndexException("invalid deletion count: " + delCount + " vs maxDoc=" + info.maxDoc(), input);
+        }
+        SegmentCommitInfo siPerCommit = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, dvGen);
+        siPerCommit.setFieldInfosFiles(fieldInfoFiles);
         siPerCommit.setDocValuesUpdatesFiles(dvUpdateFiles);
         infos.add(siPerCommit);
 
@@ -988,4 +1023,14 @@ public final class SegmentInfos implements Cloneable, Iterable<SegmentCommitInfo
   public Version getMinSegmentLuceneVersion() {
     return minSegmentLuceneVersion;
   }
+
+  /** Record that a segment was missing an info file */
+  private void addMissingSegmentInfo(String segName) {
+    missingSegmentInfo.add(segName);
+  }
+
+  /** Get the set of missing segments from {@link SegmentInfos#readCommit(Directory, String, boolean)} */
+  public Set<String> getMissingSegmentInfos() {
+    return Collections.unmodifiableSet(missingSegmentInfo);
+  }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestCheckIndex.java b/lucene/core/src/test/org/apache/lucene/index/TestCheckIndex.java
index 5d201de..a3163d4 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestCheckIndex.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestCheckIndex.java
@@ -20,6 +20,7 @@ package org.apache.lucene.index;
 import java.io.IOException;
 import java.io.ByteArrayOutputStream;
 import java.io.PrintStream;
+import java.util.Arrays;
 import java.util.List;
 import java.util.ArrayList;
 
@@ -28,6 +29,7 @@ import org.apache.lucene.util.LineFileDocs;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.LockObtainFailedException;
+import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.CannedTokenStream;
 import org.apache.lucene.analysis.MockAnalyzer;
@@ -188,4 +190,31 @@ public class TestCheckIndex extends LuceneTestCase {
     iw.close();
     dir.close();
   }
+
+  public void testMissingSegmentInfo() throws IOException {
+    final int docs = random().nextInt(5) + 2;
+    final CheckIndex.Status status;
+
+    // Can't use newDirectory() because delete will often fail later due to "virus scanner"
+    try (Directory dir = new RAMDirectory()) {
+      try (LineFileDocs lf = new LineFileDocs(random());
+          IndexWriter iw = new IndexWriter(dir, newIndexWriterConfig())) {
+        for (int i = 0; i < docs; i++) {
+          iw.addDocument(lf.nextDoc());
+          iw.commit();
+        }
+      }
+
+      String siFile = Arrays.stream(dir.listAll()).filter(name -> name.endsWith(".si")).findAny().get();
+      dir.deleteFile(siFile);
+
+      try (CheckIndex checker = new CheckIndex(dir)) {
+//        checker.setInfoStream(System.out, true);
+        status = checker.checkIndex(null, true);
+      }
+    }
+
+    assertFalse("Should not be missing segments_n file", status.missingSegments);
+    assertEquals("Should have one fewer segment", docs - 1, status.numSegments);
+  }
 }
-- 
1.9.1

