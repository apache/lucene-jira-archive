diff --git a/lucene/core/src/java/org/apache/lucene/util/FieldQueryBuilder.java b/lucene/core/src/java/org/apache/lucene/util/FieldQueryBuilder.java
new file mode 100644
index 0000000..2b0f6c1
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/FieldQueryBuilder.java
@@ -0,0 +1,112 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.util;
+
+import org.apache.lucene.document.DoublePoint;
+import org.apache.lucene.document.LongPoint;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.FieldValueQuery;
+import org.apache.lucene.search.Query;
+
+public interface FieldQueryBuilder {
+
+  Query newTermQuery(Term term);
+
+  Query newRangeQuery(String field, String lower, String upper, boolean includeLower, boolean includeUpper);
+
+  FieldQueryBuilder LONG_POINT_BUILDER = new FieldQueryBuilder() {
+
+    private long[] parseLongArray(String inputs, long limit) {
+      String[] parts = inputs.split(",");
+      long[] outputs = new long[parts.length];
+      for (int i = 0; i < parts.length; i++) {
+        if (parts[i].equals("*"))
+          outputs[i] = limit;
+        else
+          outputs[i] = Long.parseLong(parts[i]);
+      }
+      return outputs;
+    }
+
+    @Override
+    public Query newTermQuery(Term term) {
+      if (term.text().equals("*"))
+        return new FieldValueQuery(term.field());
+      long[] points = parseLongArray(term.text(), 0);
+      return LongPoint.newRangeQuery(term.field(), points, points);
+    }
+
+    @Override
+    public Query newRangeQuery(String field, String lower, String upper, boolean includeLower, boolean includeUpper) {
+      long[] lowerVals = parseLongArray(lower, Long.MIN_VALUE);
+      if (includeLower == false) {
+        for (int i = 0; i < lowerVals.length; i++) {
+          lowerVals[i] = lowerVals[i] + 1;
+        }
+      }
+      long upperVals[] = parseLongArray(upper, Long.MAX_VALUE);
+      if (includeUpper == false) {
+        for (int i = 0; i < upperVals.length; i++) {
+          upperVals[i] = upperVals[i] - 1;
+        }
+      }
+      return LongPoint.newRangeQuery(field, lowerVals, upperVals);
+    }
+  };
+
+  FieldQueryBuilder DOUBLE_POINT_BUILDER = new FieldQueryBuilder() {
+
+    private double[] parseDoubleArray(String inputs, double limit) {
+      String[] parts = inputs.split(",");
+      double[] outputs = new double[parts.length];
+      for (int i = 0; i < parts.length; i++) {
+        if (parts[i].equals("*"))
+          outputs[i] = limit;
+        else
+          outputs[i] = Double.parseDouble(parts[i]);
+      }
+      return outputs;
+    }
+
+    @Override
+    public Query newTermQuery(Term term) {
+      if (term.text().equals("*"))
+        return new FieldValueQuery(term.field());
+      double[] points = parseDoubleArray(term.text(), 0);
+      return DoublePoint.newRangeQuery(term.field(), points, points);
+    }
+
+    @Override
+    public Query newRangeQuery(String field, String lower, String upper, boolean includeLower, boolean includeUpper) {
+      double[] lowerVals = parseDoubleArray(lower, Double.MIN_VALUE);
+      if (includeLower == false) {
+        for (int i = 0; i < lowerVals.length; i++) {
+          lowerVals[i] = Math.nextUp(lowerVals[i]);
+        }
+      }
+      double upperVals[] = parseDoubleArray(upper, Double.MAX_VALUE);
+      if (includeUpper == false) {
+        for (int i = 0; i < upperVals.length; i++) {
+          upperVals[i] = Math.nextDown(lowerVals[i]);
+        }
+      }
+      return DoublePoint.newRangeQuery(field, lowerVals, upperVals);
+    }
+  };
+
+}
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
index cff9efa..74d53fe 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
@@ -18,7 +18,13 @@ package org.apache.lucene.queryparser.classic;
 
 import java.io.StringReader;
 import java.text.DateFormat;
-import java.util.*;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TimeZone;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -27,11 +33,25 @@ import org.apache.lucene.document.DateTools;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryparser.classic.QueryParser.Operator;
 import org.apache.lucene.queryparser.flexible.standard.CommonQueryParserConfiguration;
-import org.apache.lucene.search.*;
+import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.BooleanQuery.TooManyClauses;
+import org.apache.lucene.search.BoostQuery;
+import org.apache.lucene.search.FuzzyQuery;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PrefixQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.RegexpQuery;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TermRangeQuery;
+import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefBuilder;
+import org.apache.lucene.util.FieldQueryBuilder;
 import org.apache.lucene.util.QueryBuilder;
 import org.apache.lucene.util.automaton.RegExp;
 
@@ -74,6 +94,8 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
   DateTools.Resolution dateResolution = null;
   // maps field names to date resolutions
   Map<String,DateTools.Resolution> fieldToDateResolution = null;
+  // maps field names to specific query builders
+  Map<String, FieldQueryBuilder> fieldBuilders = new HashMap<>();
 
   boolean autoGeneratePhraseQueries;
   int maxDeterminizedStates = DEFAULT_MAX_DETERMINIZED_STATES;
@@ -371,6 +393,13 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
     return maxDeterminizedStates;
   }
 
+  /**
+   * Set a particular builder to use for building term and range queries for a field
+   */
+  public void setFieldBuilder(String field, FieldQueryBuilder builder) {
+    this.fieldBuilders.put(field, builder);
+  }
+
   protected void addClause(List<BooleanClause> clauses, int conj, int mods, Query q) {
     boolean required, prohibited;
 
@@ -514,6 +543,14 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
     return builder.build();
   }
 
+  @Override
+  protected Query newTermQuery(Term term) {
+    if (fieldBuilders.containsKey(term.field())) {
+      return fieldBuilders.get(term.field()).newTermQuery(term);
+    }
+    return super.newTermQuery(term);
+  }
+
   protected Query getRangeQuery(String field,
                                 String part1,
                                 String part2,
@@ -606,6 +643,10 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
    * @return new {@link TermRangeQuery} instance
    */
   protected Query newRangeQuery(String field, String part1, String part2, boolean startInclusive, boolean endInclusive) {
+
+    if (fieldBuilders.containsKey(field))
+      return fieldBuilders.get(field).newRangeQuery(field, part1, part2, startInclusive, endInclusive);
+
     final BytesRef start;
     final BytesRef end;
      
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java
index 3450794..eae91ac 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java
@@ -31,8 +31,10 @@ import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.document.DateTools.Resolution;
 import org.apache.lucene.document.Document;
+import org.apache.lucene.document.DoublePoint;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
+import org.apache.lucene.document.LongPoint;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexOptions;
 import org.apache.lucene.index.RandomIndexWriter;
@@ -55,6 +57,7 @@ import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.FieldQueryBuilder;
 import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;
 
 /**
@@ -927,4 +930,36 @@ public class TestQueryParser extends QueryParserTestBase {
     }
 
   }
+
+  public void testLongPointTypes() throws ParseException {
+    final QueryParser qp = new QueryParser(FIELD, new MockAnalyzer(random()));
+    qp.setFieldBuilder("longpoint", FieldQueryBuilder.LONG_POINT_BUILDER);
+
+    assertEquals(LongPoint.newExactQuery("longpoint", 4), qp.parse("longpoint:4"));
+    assertEquals(LongPoint.newRangeQuery("longpoint", 1, 5),
+        qp.parse("longpoint:[1 TO 5]"));
+
+    assertEquals(LongPoint.newRangeQuery("longpoint", new long[]{4, 3}, new long[]{4, 3}),
+        qp.parse("longpoint:4,3"));
+    assertEquals(LongPoint.newRangeQuery("longpoint", new long[]{0, 0}, new long[]{4, 4}),
+        qp.parse("longpoint:[0,0 TO 4,4]"));
+    assertEquals(LongPoint.newRangeQuery("longpoint", new long[]{1, 1}, new long[]{4, 4}),
+        qp.parse("longpoint:{0,0 TO 4,4]"));
+    assertEquals(LongPoint.newRangeQuery("longpoint", new long[]{0, 0}, new long[]{4, Long.MAX_VALUE}),
+        qp.parse("longpoint:[0,0 TO 4,*]"));
+  }
+
+  public void testDoublePointTypes() throws ParseException {
+    final QueryParser qp = new QueryParser(FIELD, new MockAnalyzer(random()));
+    qp.setFieldBuilder("doublepoint", FieldQueryBuilder.DOUBLE_POINT_BUILDER);
+
+    assertEquals(DoublePoint.newExactQuery("doublepoint", 4), qp.parse("doublepoint:4"));
+    assertEquals(DoublePoint.newRangeQuery("doublepoint", 1, 5),
+        qp.parse("doublepoint:[1 TO 5]"));
+
+    assertEquals(DoublePoint.newRangeQuery("doublepoint", new double[]{4, 3}, new double[]{4, 3}),
+        qp.parse("doublepoint:4,3"));
+    assertEquals(DoublePoint.newRangeQuery("doublepoint", new double[]{0, 0}, new double[]{4, 4}),
+        qp.parse("doublepoint:[0,0 TO 4,4]"));
+  }
 }
