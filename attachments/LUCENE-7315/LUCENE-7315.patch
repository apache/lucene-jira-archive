diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParser.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParser.java
index dc43ab1..eafce66 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParser.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParser.java
@@ -99,6 +99,7 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
   /**
    * @see #setSplitOnWhitespace(boolean)
    */
+  @Override
   public boolean getSplitOnWhitespace() {
     return splitOnWhitespace;
   }
@@ -107,6 +108,7 @@ public class QueryParser extends QueryParserBase implements QueryParserConstants
    * Whether query text should be split on whitespace prior to analysis.
    * Default is <code>{@value #DEFAULT_SPLIT_ON_WHITESPACE}</code>.
    */
+  @Override
   public void setSplitOnWhitespace(boolean splitOnWhitespace) {
     this.splitOnWhitespace = splitOnWhitespace;
   }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryParserHelper.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryParserHelper.java
index 968ba17..9e22d4b 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryParserHelper.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/QueryParserHelper.java
@@ -74,7 +74,7 @@ public class QueryParserHelper {
     if (processor != null) {
       processor.setQueryConfigHandler(queryConfigHandler);
     }
-
+    syntaxParser.setQueryConfigHandler(queryConfigHandler);
   }
 
   /**
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FieldQueryNode.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FieldQueryNode.java
index e9813c4..aa7322f 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FieldQueryNode.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/FieldQueryNode.java
@@ -47,9 +47,9 @@ public class FieldQueryNode extends QueryNodeImpl implements FieldValuePairQuery
   protected int end;
 
   /**
-   * The term's position increment.
+   * The term's position.
    */
-  protected int positionIncrement;
+  protected int position;
 
   /**
    * @param field
@@ -142,12 +142,12 @@ public class FieldQueryNode extends QueryNodeImpl implements FieldValuePairQuery
     this.field = field;
   }
 
-  public int getPositionIncrement() {
-    return this.positionIncrement;
+  public int getPosition() {
+    return this.position;
   }
 
-  public void setPositionIncrement(int pi) {
-    this.positionIncrement = pi;
+  public void setPosition(int position) {
+    this.position = position;
   }
 
   /**
@@ -176,7 +176,7 @@ public class FieldQueryNode extends QueryNodeImpl implements FieldValuePairQuery
     fqn.end = this.end;
     fqn.field = this.field;
     fqn.text = this.text;
-    fqn.positionIncrement = this.positionIncrement;
+    fqn.position = this.position;
     fqn.toQueryStringIgnoreFields = this.toQueryStringIgnoreFields;
 
     return fqn;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNode.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNode.java
index 4f15f7c..0bd24d3 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNode.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNode.java
@@ -17,6 +17,7 @@
 package org.apache.lucene.queryparser.flexible.core.nodes;
 
 import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler;
 
 import java.util.List;
 import java.util.Map;
@@ -68,6 +69,9 @@ public interface QueryNode {
 
   public void add(List<QueryNode> children);
 
+  // add a new child, wrapping with ModifierQueryNode with MOD_REQ if the default operator is AND
+  public void add(QueryNode child, StandardQueryConfigHandler.Operator defaultOperator);
+
   // reset the children of a node
   public void set(List<QueryNode> children);
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNodeImpl.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNodeImpl.java
index fca8386..f1d957b 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNodeImpl.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNodeImpl.java
@@ -27,6 +27,7 @@ import java.util.ResourceBundle;
 import org.apache.lucene.queryparser.flexible.messages.NLS;
 import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
 import org.apache.lucene.queryparser.flexible.core.util.StringUtils;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler;
 
 /**
  * A {@link QueryNodeImpl} is the default implementation of the interface
@@ -83,6 +84,15 @@ public abstract class QueryNodeImpl implements QueryNode, Cloneable {
   }
 
   @Override
+  public final void add(QueryNode child, StandardQueryConfigHandler.Operator defaultOperator) {
+    if (defaultOperator == StandardQueryConfigHandler.Operator.OR) {
+      add(child);
+    } else {
+      add(new ModifierQueryNode(child, ModifierQueryNode.Modifier.MOD_REQ));
+    }
+  }
+
+  @Override
   public boolean isLeaf() {
     return this.isLeaf;
   }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/parser/SyntaxParser.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/parser/SyntaxParser.java
index d08d13c..95361fa 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/parser/SyntaxParser.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/parser/SyntaxParser.java
@@ -17,6 +17,7 @@
 package org.apache.lucene.queryparser.flexible.core.parser;
 
 import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
 import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
 
 /**
@@ -30,6 +31,11 @@ public interface SyntaxParser {
    *          - default field name
    * @return QueryNode tree
    */
-  public QueryNode parse(CharSequence query, CharSequence field)
+  QueryNode parse(CharSequence query, CharSequence field)
       throws QueryNodeParseException;
+
+  /**
+   * Sets the {@link QueryConfigHandler} associated to the query tree.
+   */
+  void setQueryConfigHandler(QueryConfigHandler queryConfigHandler);
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/CommonQueryParserConfiguration.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/CommonQueryParserConfiguration.java
index c44e9e0..e31cb30 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/CommonQueryParserConfiguration.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/CommonQueryParserConfiguration.java
@@ -30,7 +30,7 @@ import org.apache.lucene.search.MultiTermQuery;
  * Configuration options common across queryparser implementations.
  */
 public interface CommonQueryParserConfiguration {
-  
+
   /**
    * Set to <code>true</code> to allow leading wildcard characters.
    * <p>
@@ -141,7 +141,16 @@ public interface CommonQueryParserConfiguration {
    * @param dateResolution the default {@link Resolution}
    */
   public void setDateResolution(DateTools.Resolution dateResolution);
-  
-  
-  
+
+  /**
+   * @see #setSplitOnWhitespace(boolean)
+   */
+  public boolean getSplitOnWhitespace();
+
+  /**
+   * Set to <code>false</code> to not split on whitespace prior to analysis.
+   * <p>
+   * Default: true (text is split on whitespace prior to analysis)
+   */
+  public void setSplitOnWhitespace(boolean splitOnWhitespace);
 }
\ No newline at end of file
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/StandardQueryParser.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/StandardQueryParser.java
index 32cbd02..f359fad 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/StandardQueryParser.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/StandardQueryParser.java
@@ -496,5 +496,22 @@ public class StandardQueryParser extends QueryParserHelper implements CommonQuer
   public void setDateResolutionMap(Map<CharSequence, DateTools.Resolution> dateRes) {
     getQueryConfigHandler().set(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP, dateRes);
   }
-  
+
+  /**
+   * @see #setSplitOnWhitespace(boolean)
+   */
+  @Override
+  public boolean getSplitOnWhitespace() {
+    return getQueryConfigHandler().get(ConfigurationKeys.SPLIT_ON_WHITESPACE);
+  }
+
+  /**
+   * Set to <code>false</code> to not split on whitespace prior to analysis.
+   * <p>
+   * Default: true (text is split on whitespace prior to analysis)
+   */
+  @Override
+  public void setSplitOnWhitespace(boolean splitOnWhitespace) {
+    getQueryConfigHandler().set(ConfigurationKeys.SPLIT_ON_WHITESPACE, splitOnWhitespace);
+  }
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/MultiPhraseQueryNodeBuilder.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/MultiPhraseQueryNodeBuilder.java
index 35debe9..9644a63 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/MultiPhraseQueryNodeBuilder.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/MultiPhraseQueryNodeBuilder.java
@@ -55,11 +55,11 @@ public class MultiPhraseQueryNodeBuilder implements StandardQueryBuilder {
         TermQuery termQuery = (TermQuery) termNode
             .getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
         List<Term> termList = positionTermMap.get(termNode
-            .getPositionIncrement());
+            .getPosition());
 
         if (termList == null) {
           termList = new LinkedList<>();
-          positionTermMap.put(termNode.getPositionIncrement(), termList);
+          positionTermMap.put(termNode.getPosition(), termList);
 
         }
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/PhraseQueryNodeBuilder.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/PhraseQueryNodeBuilder.java
index 60260d8..645192d 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/PhraseQueryNodeBuilder.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/PhraseQueryNodeBuilder.java
@@ -52,7 +52,7 @@ public class PhraseQueryNodeBuilder implements StandardQueryBuilder {
             .getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
         FieldQueryNode termNode = (FieldQueryNode) child;
 
-        builder.add(termQuery.getTerm(), termNode.getPositionIncrement());
+        builder.add(termQuery.getTerm(), termNode.getPosition());
       }
 
     }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/SynonymQueryNodeBuilder.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/SynonymQueryNodeBuilder.java
index 716bcfd..2f0102d 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/SynonymQueryNodeBuilder.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/builders/SynonymQueryNodeBuilder.java
@@ -16,6 +16,10 @@
  */
 package org.apache.lucene.queryparser.flexible.standard.builders;
 
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.index.Term;
 import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
 import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
 import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
@@ -23,8 +27,10 @@ import org.apache.lucene.queryparser.flexible.standard.nodes.SynonymQueryNode;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.SynonymQuery;
+import org.apache.lucene.search.TermQuery;
 
-/** Builer for {@link SynonymQueryNode}. */
+/** Builder for {@link SynonymQueryNode}. */
 public class SynonymQueryNodeBuilder implements StandardQueryBuilder {
 
   /** Sole constructor. */
@@ -32,17 +38,17 @@ public class SynonymQueryNodeBuilder implements StandardQueryBuilder {
 
   @Override
   public Query build(QueryNode queryNode) throws QueryNodeException {
-    // TODO: use SynonymQuery instead
-    SynonymQueryNode node = (SynonymQueryNode) queryNode;
-    BooleanQuery.Builder builder = new BooleanQuery.Builder();
-    for (QueryNode child : node.getChildren()) {
-      Object obj = child.getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
-
-      if (obj != null) {
-        Query query = (Query) obj;
-        builder.add(query, Occur.SHOULD);
+    SynonymQueryNode node = (SynonymQueryNode)queryNode;
+    List<Term> terms = new ArrayList<>();
+    if (node.getChildren() != null) {
+      for (QueryNode child : node.getChildren()) {
+        Object obj = child.getTag(QueryTreeBuilder.QUERY_TREE_BUILDER_TAGID);
+        if (obj != null) {
+          TermQuery query = (TermQuery)obj;
+          terms.add(query.getTerm());
+        }
       }
     }
-    return builder.build();
+    return new SynonymQuery(terms.toArray(new Term[terms.size()]));
   }
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/StandardQueryConfigHandler.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/StandardQueryConfigHandler.java
index 5c53d02..aeb66c8 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/StandardQueryConfigHandler.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/config/StandardQueryConfigHandler.java
@@ -194,6 +194,11 @@ public class StandardQueryConfigHandler extends QueryConfigHandler {
      */
     final public static ConfigurationKey<Map<String,PointsConfig>> POINTS_CONFIG_MAP = ConfigurationKey.newInstance();
 
+    /**
+     * Key used to set whether query text should be split on whitespace prior to analysis.
+     * Default is <code>true</code>.
+     */
+    final public static ConfigurationKey<Boolean> SPLIT_ON_WHITESPACE = ConfigurationKey.newInstance();
   }
   
   /**
@@ -221,7 +226,6 @@ public class StandardQueryConfigHandler extends QueryConfigHandler {
     set(ConfigurationKeys.LOCALE, Locale.getDefault());
     set(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD, MultiTermQuery.CONSTANT_SCORE_REWRITE);
     set(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP, new HashMap<CharSequence, DateTools.Resolution>());
-    
+    set(ConfigurationKeys.SPLIT_ON_WHITESPACE, true);
   }
-
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/SynonymQueryNode.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/SynonymQueryNode.java
index a8c44bc..600db7b 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/SynonymQueryNode.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/nodes/SynonymQueryNode.java
@@ -20,11 +20,43 @@ import java.util.List;
 
 import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.QueryNodeImpl;
+import org.apache.lucene.queryparser.flexible.core.parser.EscapeQuerySyntax;
 
 /** {@link QueryNode} for clauses that are synonym of each other. */
-public class SynonymQueryNode extends BooleanQueryNode {
+public class SynonymQueryNode extends QueryNodeImpl {
   /** Sole constructor. */
   public SynonymQueryNode(List<QueryNode> clauses) {
-    super(clauses);
+    setLeaf(false);
+    allocate();
+    set(clauses);
+  }
+
+  @Override
+  public String toString() {
+    if (getChildren() == null || getChildren().size() == 0)
+      return "<synonym/>";
+    StringBuilder sb = new StringBuilder();
+    sb.append("<synonym>");
+    for (QueryNode child : getChildren()) {
+      sb.append("\n");
+      sb.append(child.toString());
+    }
+    sb.append("\n</synonym>");
+    return sb.toString();
+  }
+
+  @Override
+  public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
+    if (getChildren() == null || getChildren().size() == 0)
+      return "Synonym()";
+
+    StringBuilder sb = new StringBuilder();
+    String filler = "";
+    for (QueryNode child : getChildren()) {
+      sb.append(filler).append(child.toQueryString(escapeSyntaxParser));
+      filler = " ";
+    }
+    return "Synonym(" + sb.toString() + ")";
   }
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.jj b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.jj
index 868b257..7514b46 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.jj
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParser.jj
@@ -7,8 +7,6 @@ options {
 }
 
 PARSER_BEGIN(StandardSyntaxParser)
-package org.apache.lucene.queryparser.flexible.standard.parser;
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -26,63 +24,89 @@ package org.apache.lucene.queryparser.flexible.standard.parser;
  * limitations under the License.
  */
 
+package org.apache.lucene.queryparser.flexible.standard.parser;
+
+
 import java.io.StringReader;
-import java.util.Vector;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
 
-import org.apache.lucene.queryparser.flexible.messages.Message;
-import org.apache.lucene.queryparser.flexible.messages.MessageImpl;
-import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;
+import org.apache.lucene.queryparser.flexible.core.config.QueryConfigHandler;
 import org.apache.lucene.queryparser.flexible.core.messages.QueryParserMessages;
 import org.apache.lucene.queryparser.flexible.core.nodes.AndQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.BoostQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;
-import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.OrQueryNode;
-import org.apache.lucene.queryparser.flexible.standard.nodes.RegexpQueryNode;
-import org.apache.lucene.queryparser.flexible.core.nodes.SlopQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.QuotedFieldQueryNode;
+import org.apache.lucene.queryparser.flexible.core.nodes.SlopQueryNode;
 import org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser;
+import org.apache.lucene.queryparser.flexible.core.QueryNodeParseException;
+import org.apache.lucene.queryparser.flexible.messages.Message;
+import org.apache.lucene.queryparser.flexible.messages.MessageImpl;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryparser.flexible.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryparser.flexible.standard.nodes.RegexpQueryNode;
 import org.apache.lucene.queryparser.flexible.standard.nodes.TermRangeQueryNode;
 
+import static org.apache.lucene.queryparser.flexible.standard.parser.EscapeQuerySyntaxImpl.discardEscapeChar;
+
 /**
  * Parser for the standard Lucene syntax
  */
 public class StandardSyntaxParser implements SyntaxParser {
 
- 
-   // syntax parser constructor
-   public StandardSyntaxParser() {
-     this(new FastCharStream(new StringReader("")));
+  /** constructor */
+  public StandardSyntaxParser() {
+    this(new FastCharStream(new StringReader("")));
   }
-     /** Parses a query string, returning a {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode}.
-     *  @param query  the query string to be parsed.
-     *  @throws ParseException if the parsing fails
-     */
-    public QueryNode parse(CharSequence query, CharSequence field) throws QueryNodeParseException {
-      ReInit(new FastCharStream(new StringReader(query.toString())));
-      try {
-        // TopLevelQuery is a Query followed by the end-of-input (EOF)
-        QueryNode querynode = TopLevelQuery(field);
-        return querynode;
-      }
-      catch (ParseException tme) {
-            tme.setQuery(query);
-            throw tme;
-      }
-      catch (Error tme) {
-          Message message = new MessageImpl(QueryParserMessages.INVALID_SYNTAX_CANNOT_PARSE, query, tme.getMessage());
-          QueryNodeParseException e = new QueryNodeParseException(tme);
-            e.setQuery(query);
-            e.setNonLocalizedMessage(message);
-            throw e;
-      }
+
+  /** Parses a query string, returning a {@link org.apache.lucene.queryparser.flexible.core.nodes.QueryNode}.
+   *  @param query  the query string to be parsed.
+   *  @throws ParseException if the parsing fails
+   */
+  public QueryNode parse(CharSequence query, CharSequence field) throws QueryNodeParseException {
+    ReInit(new FastCharStream(new StringReader(query.toString())));
+    if (queryConfig == null) {
+      queryConfig = new StandardQueryConfigHandler(); // for defaults
+    }
+    try {
+      // TopLevelQuery is a Query followed by the end-of-input (EOF)
+      QueryNode querynode = TopLevelQuery(field);
+      return querynode;
     }
-   
+    catch (ParseException tme) {
+      tme.setQuery(query);
+      throw tme;
+    }
+    catch (Error tme) {
+      Message message = new MessageImpl(QueryParserMessages.INVALID_SYNTAX_CANNOT_PARSE, query, tme.getMessage());
+      QueryNodeParseException e = new QueryNodeParseException(tme);
+      e.setQuery(query);
+      e.setNonLocalizedMessage(message);
+      throw e;
+    }
+  }
+
+  @Override
+  public void setQueryConfigHandler(QueryConfigHandler queryConfigHandler) {
+    this.queryConfig = queryConfigHandler;
+  }
+
+  private QueryConfigHandler queryConfig = null;
+
+  private static Set<Integer> disallowedPostMultiTerm = new HashSet<Integer>(Arrays.asList
+      (AND, OR, OP_COLON, OP_EQUAL, OP_LESSTHAN, OP_LESSTHANEQ, OP_MORETHAN, OP_MORETHANEQ, CARAT, FUZZY_SLOP));
+  private static boolean allowedPostMultiTerm(int tokenKind) {
+    return disallowedPostMultiTerm.contains(tokenKind) == false;
+  }
 }
 
 PARSER_END(StandardSyntaxParser)
@@ -92,15 +116,14 @@ PARSER_END(StandardSyntaxParser)
 /* ***************** */
 
 <*> TOKEN : {
-  <#_NUM_CHAR:   ["0"-"9"] >
-// every character that follows a backslash is considered as an escaped character
-| <#_ESCAPED_CHAR: "\\" ~[] >
+  <#_NUM_CHAR:        ["0"-"9"] >
+| <#_ESCAPED_CHAR:    "\\" ~[] >  // every character that follows a backslash is considered as an escaped character
 | <#_TERM_START_CHAR: ( ~[ " ", "\t", "\n", "\r", "\u3000", "+", "-", "!", "(", ")", ":", "^",
                            "<", ">", "=", "[", "]", "\"", "{", "}", "~", "\\", "/" ]
                        | <_ESCAPED_CHAR> ) >
-| <#_TERM_CHAR: ( <_TERM_START_CHAR> | <_ESCAPED_CHAR> | "-" | "+" ) >
-| <#_WHITESPACE: ( " " | "\t" | "\n" | "\r" | "\u3000") >
-| <#_QUOTED_CHAR: ( ~[ "\"", "\\" ] | <_ESCAPED_CHAR> ) >
+| <#_TERM_CHAR:       ( <_TERM_START_CHAR> | <_ESCAPED_CHAR> | "-" | "+" ) >
+| <#_WHITESPACE:      ( " " | "\t" | "\n" | "\r" | "\u3000") >
+| <#_QUOTED_CHAR:     ( ~[ "\"", "\\" ] | <_ESCAPED_CHAR> ) >
 }
 
 <DEFAULT, Range> SKIP : {
@@ -108,38 +131,38 @@ PARSER_END(StandardSyntaxParser)
 }
 
 <DEFAULT> TOKEN : {
-  <AND:       ("AND" | "&&") >
-| <OR:        ("OR" | "||") >
-| <NOT:       ("NOT" | "!") >
-| <PLUS:      "+" >
-| <MINUS:     "-" >
-| <LPAREN:    "(" >
-| <RPAREN:    ")" >
-| <OP_COLON:  ":" >
-| <OP_EQUAL:  "=" >
+  <AND:           ("AND" | "&&") >
+| <OR:            ("OR" | "||") >
+| <NOT:           ("NOT" | "!") >
+| <PLUS:          "+" >
+| <MINUS:         "-" >
+| <LPAREN:        "(" >
+| <RPAREN:        ")" >
+| <OP_COLON:      ":" >
+| <OP_EQUAL:      "=" >
 | <OP_LESSTHAN:   "<"  >
 | <OP_LESSTHANEQ: "<=" >
 | <OP_MORETHAN:   ">"  >
 | <OP_MORETHANEQ: ">=" >
-| <CARAT:     "^" > : Boost
-| <QUOTED:     "\"" (<_QUOTED_CHAR>)* "\"">
-| <TERM:      <_TERM_START_CHAR> (<_TERM_CHAR>)*  >
-| <FUZZY_SLOP:     "~" ( (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? )? >
-| <REGEXPTERM: "/" (~[ "/" ] | "\\/" )* "/" >
+| <CARAT:         "^" > : Boost
+| <QUOTED:        "\"" (<_QUOTED_CHAR>)* "\"">
+| <TERM:          <_TERM_START_CHAR> (<_TERM_CHAR>)*  >
+| <FUZZY_SLOP:    "~" ( (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? )? >
+| <REGEXPTERM:    "/" (~[ "/" ] | "\\/" )* "/" >
 | <RANGEIN_START: "[" > : Range
 | <RANGEEX_START: "{" > : Range
 }
 
 <Boost> TOKEN : {
-<NUMBER:    (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? > : DEFAULT
+<NUMBER: (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? > : DEFAULT
 }
 
 <Range> TOKEN : {
-<RANGE_TO: "TO">
-| <RANGEIN_END: "]"> : DEFAULT
-| <RANGEEX_END: "}"> : DEFAULT
+  <RANGE_TO: "TO">
+| <RANGEIN_END:  "]"> : DEFAULT
+| <RANGEEX_END:  "}"> : DEFAULT
 | <RANGE_QUOTED: "\"" (~["\""] | "\\\"")+ "\"">
-| <RANGE_GOOP: (~[ " ", "]", "}" ])+ >
+| <RANGE_GOOP:   (~[ " ", "]", "}" ])+ >
 }
 
 ModifierQueryNode.Modifier Modifiers() : {
@@ -147,23 +170,20 @@ ModifierQueryNode.Modifier Modifiers() : {
 }
 {
   [
-     <PLUS> { ret = ModifierQueryNode.Modifier.MOD_REQ; }
-     | <MINUS> { ret = ModifierQueryNode.Modifier.MOD_NOT; }
-     | <NOT> { ret = ModifierQueryNode.Modifier.MOD_NOT; }
+    <PLUS> { ret = ModifierQueryNode.Modifier.MOD_REQ; }
+    | <MINUS> { ret = ModifierQueryNode.Modifier.MOD_NOT; }
+    | <NOT> { ret = ModifierQueryNode.Modifier.MOD_NOT; }
   ]
   { return ret; }
 }
 
 // This makes sure that there is no garbage after the query string
-QueryNode TopLevelQuery(CharSequence field) : 
-{
+QueryNode TopLevelQuery(CharSequence field) : {
   QueryNode q;
 }
 {
   q=Query(field) <EOF>
-  {
-     return q;
-  }
+  { return q; }
 }
 
 // These changes were made to introduce operator precedence:
@@ -180,309 +200,250 @@ QueryNode TopLevelQuery(CharSequence field) :
 
 QueryNode Query(CharSequence field) :
 {
-  Vector<QueryNode> clauses = null;
-  QueryNode c, first=null;
+  List<QueryNode> clauses = new ArrayList<QueryNode>();
+  QueryNode q;
 }
 {
-  first=DisjQuery(field)
   (
-    c=DisjQuery(field)
-    { 
-       if (clauses == null) {
-           clauses = new Vector<QueryNode>();
-           clauses.addElement(first);
+    LOOKAHEAD(2)
+    MultiTerm(field, clauses)
+    | q=DisjQuery(field) { clauses.add(q); }
+  )+
+  {
+    if (clauses.size() > 1) {
+      return new BooleanQueryNode(clauses);
+    } else {
+      // Handle the case of a "pure" negation query which needs to be wrapped
+      // as a boolean query, otherwise the returned result drops the negation.
+      QueryNode first = clauses.get(0);
+      if (first instanceof ModifierQueryNode) {
+        if (((ModifierQueryNode)first).getModifier() == ModifierQueryNode.Modifier.MOD_NOT) {
+          first = new BooleanQueryNode(Arrays.<QueryNode>asList(first));
         }
-        clauses.addElement(c);
-    }
-    )*
-    {
-        if (clauses != null) { 
-        return new BooleanQueryNode(clauses);
-      } else {
-          // Handle the case of a "pure" negation query which
-          // needs to be wrapped as a boolean query, otherwise
-          // the returned result drops the negation.
-          if (first instanceof ModifierQueryNode) {
-            ModifierQueryNode m = (ModifierQueryNode) first;
-            if (m.getModifier() == ModifierQueryNode.Modifier.MOD_NOT) {
-              return new BooleanQueryNode(Arrays.<QueryNode> asList(m));
-            }
-          }
-          return first;
       }
+      return first;
     }
+  }
 }
 
 QueryNode DisjQuery(CharSequence field) : {
-  QueryNode first, c;
-  Vector<QueryNode> clauses = null;
+  QueryNode first, q;
+  List<QueryNode> clauses = null;
 }
 {
   first = ConjQuery(field)
   (
-   <OR> c=ConjQuery(field)
-   { 
-     if (clauses == null) {
-         clauses = new Vector<QueryNode>();
-         clauses.addElement(first); 
-     } 
-     clauses.addElement(c);
-   }
-  )*
-  {
-    if (clauses != null) { 
-      return new OrQueryNode(clauses);
-    } else {
-        return first;
+    <OR> q=ConjQuery(field)
+    {
+      if (clauses == null) {
+        clauses = new ArrayList<QueryNode>();
+        clauses.add(first);
+      }
+      clauses.add(q);
     }
-  }
+  )*
+  { return clauses == null ? first : new OrQueryNode(clauses); }
 }
 
 QueryNode ConjQuery(CharSequence field) : {
-  QueryNode first, c;
-  Vector<QueryNode> clauses = null;
+  QueryNode first, q;
+  List<QueryNode> clauses = null;
 }
 {
-  first = ModClause(field)
+  first=ModClause(field)
   (
-   <AND> c=ModClause(field)
-   { 
-     if (clauses == null) {
-         clauses = new Vector<QueryNode>();
-         clauses.addElement(first);
-     } 
-     clauses.addElement(c); 
-   }
+    <AND> q=ModClause(field)
+    {
+      if (clauses == null) {
+        clauses = new ArrayList<QueryNode>();
+        clauses.add(first);
+      }
+      clauses.add(q);
+    }
   )*
   {
     if (clauses != null) {     
       return new AndQueryNode(clauses);
     } else {
-        return first;
+      return first;
     }
   }
 }
 
-// QueryNode Query(CharSequence field) :
-// {
-// List clauses = new ArrayList();
-//   List modifiers = new ArrayList();
-//   QueryNode q, firstQuery=null;
-//   ModifierQueryNode.Modifier mods;
-//   int conj;
-// }
-// {
-//   mods=Modifiers() q=Clause(field)
-//   {
-//     if (mods == ModifierQueryNode.Modifier.MOD_NONE) firstQuery=q;
-//     
-//     // do not create modifier nodes with MOD_NONE
-//      if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
-//          q = new ModifierQueryNode(q, mods);
-//         }
-//      clauses.add(q);
-//   }
-//   (
-//     conj=Conjunction() mods=Modifiers() q=Clause(field)
-//     { 
-//       // do not create modifier nodes with MOD_NONE
-//         if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
-//          q = new ModifierQueryNode(q, mods);
-//         }
-//          clauses.add(q);
-//        //TODO: figure out what to do with AND and ORs
-//   }
-//   )*
-//     {
-//      if (clauses.size() == 1 && firstQuery != null)
-//         return firstQuery;
-//       else {
-//       return new BooleanQueryNode(clauses);
-//       }
-//     }
-// }
-
 QueryNode ModClause(CharSequence field) : {
   QueryNode q; 
   ModifierQueryNode.Modifier mods;
 }
 {
-   mods=Modifiers() q= Clause(field) {
-        if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
-           q = new ModifierQueryNode(q, mods);
-        }
-        return q;
-   }
+  mods=Modifiers() q=Clause(field) {
+    if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
+      q = new ModifierQueryNode(q, mods);
+    }
+    return q;
+  }
 }
 
 QueryNode Clause(CharSequence field) : {
   QueryNode q;
-  Token fieldToken=null, boost=null, operator=null, term=null;
+  Token fieldToken = null, boost = null, operator = null, term = null;
   FieldQueryNode qLower, qUpper;
   boolean lowerInclusive, upperInclusive;
-  
   boolean group = false;
 }
 {
 (
   LOOKAHEAD(3)
-  fieldToken=<TERM> (
-    ( <OP_COLON> | <OP_EQUAL> ) {field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);} q=Term(field)
-  | ( operator=<OP_LESSTHAN> | operator=<OP_LESSTHANEQ> | operator=<OP_MORETHAN> | operator=<OP_MORETHANEQ> ) {field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);}( term=<TERM> | term=<QUOTED> | term=<NUMBER> )
-    {
+  fieldToken=<TERM>
+  ( ( <OP_COLON> | <OP_EQUAL> ) { field = discardEscapeChar(fieldToken.image); } q=Term(field)
+    | ( operator=<OP_LESSTHAN> | operator=<OP_LESSTHANEQ> | operator=<OP_MORETHAN> | operator=<OP_MORETHANEQ> )
+        { field=discardEscapeChar(fieldToken.image); }
+      ( term=<TERM> | term=<QUOTED> | term=<NUMBER> )
+      {
         if (term.kind == QUOTED) {
-            term.image = term.image.substring(1, term.image.length()-1);
+          term.image = term.image.substring(1, term.image.length()-1);
         }
         switch (operator.kind) {
-            case OP_LESSTHAN:
-              lowerInclusive = true;
-              upperInclusive = false;
-
-               qLower = new FieldQueryNode(field,
-                                         "*", term.beginColumn, term.endColumn);
-            qUpper = new FieldQueryNode(field,
-                                 EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
-                
-                break;
-            case OP_LESSTHANEQ:
-              lowerInclusive = true;
-              upperInclusive = true;
+          case OP_LESSTHAN: {
+            lowerInclusive = true;
+            upperInclusive = false;
+
+            qLower = new FieldQueryNode(field, "*", term.beginColumn, term.endColumn);
+            qUpper = new FieldQueryNode(field, discardEscapeChar(term.image), term.beginColumn, term.endColumn);
+            break;
+          }
+          case OP_LESSTHANEQ: {
+            lowerInclusive = true;
+            upperInclusive = true;
             
-                qLower = new FieldQueryNode(field, 
-                                         "*", term.beginColumn, term.endColumn);
-                qUpper = new FieldQueryNode(field, 
-                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
-                break;
-            case OP_MORETHAN:
-              lowerInclusive = false;
-              upperInclusive = true;
+            qLower = new FieldQueryNode(field, "*", term.beginColumn, term.endColumn);
+            qUpper = new FieldQueryNode(field, discardEscapeChar(term.image), term.beginColumn, term.endColumn);
+            break;
+          }
+          case OP_MORETHAN: {
+            lowerInclusive = false;
+            upperInclusive = true;
             
-                qLower = new FieldQueryNode(field, 
-                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
-                qUpper = new FieldQueryNode(field, 
-                                         "*", term.beginColumn, term.endColumn);
-                break;
-            case OP_MORETHANEQ:
-              lowerInclusive = true;
-              upperInclusive = true;
-
-                qLower = new FieldQueryNode(field, 
-                                         EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
-                qUpper = new FieldQueryNode(field, 
-                                         "*", term.beginColumn, term.endColumn);
-                break;
-            default:
-                throw new Error("Unhandled case: operator="+operator.toString());
+            qLower = new FieldQueryNode(field, discardEscapeChar(term.image), term.beginColumn, term.endColumn);
+            qUpper = new FieldQueryNode(field, "*", term.beginColumn, term.endColumn);
+            break;
+          }
+          case OP_MORETHANEQ: {
+            lowerInclusive = true;
+            upperInclusive = true;
+
+            qLower = new FieldQueryNode(field, discardEscapeChar(term.image), term.beginColumn, term.endColumn);
+            qUpper = new FieldQueryNode(field, "*", term.beginColumn, term.endColumn);
+            break;
+          }
+          default: {
+            throw new Error("Unhandled case: operator=" + operator.toString());
+          }
         }
         q = new TermRangeQueryNode(qLower, qUpper, lowerInclusive, upperInclusive);
-    }
+      }
   )
 | [
     LOOKAHEAD(2)
     fieldToken=<TERM>
-    ( <OP_COLON> | <OP_EQUAL> ) {field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);}
+    ( <OP_COLON> | <OP_EQUAL> ) { field = discardEscapeChar(fieldToken.image); }
   ]
   (
-   q=Term(field)
-   | <LPAREN> q=Query(field) <RPAREN> (<CARAT> boost=<NUMBER>)? {group=true;}
+    q=Term(field)
+    | <LPAREN> q=Query(field) <RPAREN> [ <CARAT> boost=<NUMBER> ] { group = true; }
   )
 )
-    {
-      if (boost != null) {
-      float f = (float)1.0;
-      try {
-        f = Float.valueOf(boost.image).floatValue();
-        // avoid boosting null queries, such as those caused by stop words
-          if (q != null) {
-            q = new BoostQueryNode(q, f);
-          }
-      } catch (Exception ignored) {
-        /* Should this be handled somehow? (defaults to "no boost", if
-             * boost number is invalid)
-             */
-      }
+{
+  if (boost != null) {
+    float f = (float)1.0;
+    try {
+      f = Float.valueOf(boost.image).floatValue();
+      // avoid boosting null queries, such as those caused by stop words
+      if (q != null) {
+        q = new BoostQueryNode(q, f);
       }
-      if (group) { q = new GroupQueryNode(q);}
-      return q;
+    } catch (Exception ignored) {
+      // TODO: Should this be handled somehow? (defaults to "no boost", if boost number is invalid)
     }
+  }
+  if (group) { q = new GroupQueryNode(q);}
+    return q;
+  }
 }
 
-
 QueryNode Term(CharSequence field) : {
-  Token term, boost=null, fuzzySlop=null, goop1, goop2;
+  Token term, boost = null, fuzzySlop = null, goop1, goop2;
   boolean fuzzy = false;
   boolean regexp = false;
-  boolean startInc=false;
-  boolean endInc=false;
-  QueryNode q =null; 
+  boolean startInc = false;
+  boolean endInc = false;
+  QueryNode q = null;
   FieldQueryNode qLower, qUpper;
   float defaultMinSimilarity = org.apache.lucene.search.FuzzyQuery.defaultMinSimilarity;
 }
 {
   (
-     (
-      term=<TERM> { q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn); }
-       | term=<REGEXPTERM> { regexp=true; }
-       | term=<NUMBER>
-     )
-     [ fuzzySlop=<FUZZY_SLOP> { fuzzy=true; } ]
-     [ <CARAT> boost=<NUMBER> [ fuzzySlop=<FUZZY_SLOP> { fuzzy=true; } ] ]
-     {
-       if (fuzzy) {
-           float fms = defaultMinSimilarity;
-           try {
-            fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
-           } catch (Exception ignored) { }
-           if(fms < 0.0f){
-                throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));
-          } else if (fms >= 1.0f && fms != (int) fms) {
-            throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_EDITS));
-          }
-          q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
-       } else if (regexp) {
-         String re = term.image.substring(1, term.image.length()-1);
-         q = new RegexpQueryNode(field, re, 0, re.length());
-       }
-     }
-     | ( ( <RANGEIN_START> {startInc=true;} | <RANGEEX_START> )
-         ( goop1=<RANGE_GOOP>|goop1=<RANGE_QUOTED> )
-         [ <RANGE_TO> ]
-         ( goop2=<RANGE_GOOP>|goop2=<RANGE_QUOTED> )
-         ( <RANGEIN_END> {endInc=true;} | <RANGEEX_END>))
-       [ <CARAT> boost=<NUMBER> ]
+    (
+      term=<TERM> { q = new FieldQueryNode(field, discardEscapeChar(term.image), term.beginColumn, term.endColumn); }
+      | term=<REGEXPTERM> { regexp = true; }
+      | term=<NUMBER>
+    )
+    [ fuzzySlop=<FUZZY_SLOP> { fuzzy = true; } ]
+    [ <CARAT> boost=<NUMBER> [ fuzzySlop=<FUZZY_SLOP> { fuzzy = true; } ] ]
+    {
+      if (fuzzy) {
+        float fms = defaultMinSimilarity;
+        try {
+          fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
+        } catch (Exception ignored) { }
+        if (fms < 0.0f) {
+          throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));
+        } else if (fms >= 1.0f && fms != (int) fms) {
+          throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_EDITS));
+        }
+        q = new FuzzyQueryNode(field, discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
+      } else if (regexp) {
+        String re = term.image.substring(1, term.image.length()-1);
+        q = new RegexpQueryNode(field, re, 0, re.length());
+      }
+    }
+  | ( ( <RANGEIN_START> {startInc=true;} | <RANGEEX_START> )
+      ( goop1=<RANGE_GOOP>|goop1=<RANGE_QUOTED> )
+      [ <RANGE_TO> ]
+      ( goop2=<RANGE_GOOP>|goop2=<RANGE_QUOTED> )
+      ( <RANGEIN_END> {endInc=true;} | <RANGEEX_END>))
+      [ <CARAT> boost=<NUMBER> ]
+      {
+        if (goop1.kind == RANGE_QUOTED) {
+          goop1.image = goop1.image.substring(1, goop1.image.length()-1);
+        }
+        if (goop2.kind == RANGE_QUOTED) {
+          goop2.image = goop2.image.substring(1, goop2.image.length()-1);
+        }
+          
+        qLower = new FieldQueryNode(field, discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
+        qUpper = new FieldQueryNode(field, discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
+        q = new TermRangeQueryNode(qLower, qUpper, startInc, endInc);
+      }
+    | term=<QUOTED>
         {
-          if (goop1.kind == RANGE_QUOTED) {
-            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
+          q = new QuotedFieldQueryNode(field, discardEscapeChar(term.image.substring(1, term.image.length() - 1)),
+                                       term.beginColumn + 1, term.endColumn - 1);
+        }
+      [ fuzzySlop=<FUZZY_SLOP> ]
+      [ <CARAT> boost=<NUMBER> ]
+      {
+        int phraseSlop = 0;
+
+        if (fuzzySlop != null) {
+          try {
+            phraseSlop = Float.valueOf(fuzzySlop.image.substring(1)).intValue();
+            q = new SlopQueryNode(q, phraseSlop);
           }
-          if (goop2.kind == RANGE_QUOTED) {
-            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
+          catch (Exception ignored) {
+            // TODO: Should this be handled somehow? (defaults to "no PhraseSlop", if slop number is invalid)
           }
-          
-          qLower = new FieldQueryNode(field, 
-                                   EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
-      qUpper = new FieldQueryNode(field,
-                                   EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
-          q = new TermRangeQueryNode(qLower, qUpper, startInc ? true : false, endInc ? true : false);
         }
-     | term=<QUOTED> {q = new QuotedFieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image.substring(1, term.image.length()-1)), term.beginColumn + 1, term.endColumn - 1);}
-       [ fuzzySlop=<FUZZY_SLOP> ]
-       [ <CARAT> boost=<NUMBER> ]
-       {       
-         int phraseSlop = 0;
-
-         if (fuzzySlop != null) {
-           try {
-             phraseSlop = Float.valueOf(fuzzySlop.image.substring(1)).intValue();
-             q = new SlopQueryNode(q, phraseSlop);    
-           }
-           catch (Exception ignored) {
-            /* Should this be handled somehow? (defaults to "no PhraseSlop", if
-           * slop number is invalid)
-           */
-           }
-         }
-              
-       }
+      }
   )
   {
     if (boost != null) {
@@ -490,15 +451,47 @@ QueryNode Term(CharSequence field) : {
       try {
         f = Float.valueOf(boost.image).floatValue();
         // avoid boosting null queries, such as those caused by stop words
-          if (q != null) {
-            q = new BoostQueryNode(q, f);
-          }
+        if (q != null) {
+          q = new BoostQueryNode(q, f);
+        }
       } catch (Exception ignored) {
-        /* Should this be handled somehow? (defaults to "no boost", if
-           * boost number is invalid)
-           */
+        // TODO: Should this be handled somehow? (defaults to "no boost", if boost number is invalid)
       }
     }
-      return q;
+    return q;
+  }
+}
+
+void MultiTerm(CharSequence field, List<QueryNode> clauses) : {
+  Token text, followingText;
+  boolean splitOnWhitespace = queryConfig.get(ConfigurationKeys.SPLIT_ON_WHITESPACE);
+}
+{
+  text=<TERM>
+  {
+    if (splitOnWhitespace) {
+      clauses.add(new FieldQueryNode(field, discardEscapeChar(text.image), text.beginColumn, text.endColumn));
+    }
+  }
+  // Both lookaheads are required; the first lookahead vets the first following term and the second lookahead vets the rest
+  LOOKAHEAD({ getToken(1).kind == TERM && allowedPostMultiTerm(getToken(2).kind) })
+  (
+    LOOKAHEAD({ getToken(1).kind == TERM && allowedPostMultiTerm(getToken(2).kind) })
+    followingText=<TERM>
+    {
+      if (splitOnWhitespace) {
+        clauses.add(new FieldQueryNode(field, discardEscapeChar(followingText.image), text.beginColumn, text.endColumn));
+      } else { // build up the text to send to analysis
+        char[] spaces = new char[followingText.beginColumn - text.endColumn];
+        Arrays.fill(spaces, ' ');
+        text.image += String.valueOf(spaces) + followingText.image;
+        text.endColumn = followingText.endColumn;
+      }
+    }
+  )+
+  {
+    if (splitOnWhitespace == false) {
+      clauses.add(new FieldQueryNode(field, discardEscapeChar(text.image), text.beginColumn, text.endColumn));
+    }
   }
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor.java
index 56e9956..88747e2 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/AnalyzerQueryNodeProcessor.java
@@ -18,10 +18,10 @@ package org.apache.lucene.queryparser.flexible.standard.processors;
 
 import java.io.IOException;
 
-import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.regex.Pattern;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.CachingTokenFilter;
@@ -34,8 +34,6 @@ import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.FuzzyQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;
-import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode;
-import org.apache.lucene.queryparser.flexible.core.nodes.ModifierQueryNode.Modifier;
 import org.apache.lucene.queryparser.flexible.core.nodes.NoTokenFoundQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.QuotedFieldQueryNode;
@@ -51,6 +49,8 @@ import org.apache.lucene.queryparser.flexible.standard.nodes.SynonymQueryNode;
 import org.apache.lucene.queryparser.flexible.standard.nodes.WildcardQueryNode;
 
 /**
+ * nocommit review javadocs
+ *
  * This processor verifies if {@link ConfigurationKeys#ANALYZER}
  * is defined in the {@link QueryConfigHandler}. If it is and the analyzer is
  * not <code>null</code>, it looks for every {@link FieldQueryNode} that is not
@@ -61,9 +61,9 @@ import org.apache.lucene.queryparser.flexible.standard.nodes.WildcardQueryNode;
  * If the analyzer return only one term, the returned term is set to the
  * {@link FieldQueryNode} and it's returned. <br>
  * <br>
- * If the analyzer return more than one term, a {@link TokenizedPhraseQueryNode}
- * or {@link MultiPhraseQueryNode} is created, whether there is one or more
- * terms at the same position, and it's returned. <br>
+ * If the analyzer return more than one term, either a {@link TokenizedPhraseQueryNode}
+ * or a {@link MultiPhraseQueryNode} is created (depending on whether there is one or more
+ * terms at the same position, respectively), and it's returned. <br>
  * <br>
  * If no term is returned by the analyzer a {@link NoTokenFoundQueryNode} object
  * is returned.
@@ -75,10 +75,11 @@ import org.apache.lucene.queryparser.flexible.standard.nodes.WildcardQueryNode;
 public class AnalyzerQueryNodeProcessor extends QueryNodeProcessorImpl {
 
   private Analyzer analyzer;
-
   private boolean positionIncrementsEnabled;
-  
   private Operator defaultOperator;
+  private boolean splitOnWhitespace;
+
+  private static final Pattern WHITESPACE_PATTERN = Pattern.compile("\\s");
 
   public AnalyzerQueryNodeProcessor() {
     // empty constructor
@@ -92,20 +93,136 @@ public class AnalyzerQueryNodeProcessor extends QueryNodeProcessorImpl {
       this.analyzer = analyzer;
       this.positionIncrementsEnabled = false;
       Boolean positionIncrementsEnabled = getQueryConfigHandler().get(ConfigurationKeys.ENABLE_POSITION_INCREMENTS);
+      this.positionIncrementsEnabled = positionIncrementsEnabled != null ? positionIncrementsEnabled : false;
       Operator defaultOperator = getQueryConfigHandler().get(ConfigurationKeys.DEFAULT_OPERATOR);
       this.defaultOperator = defaultOperator != null ? defaultOperator : Operator.OR;
-      
-      if (positionIncrementsEnabled != null) {
-          this.positionIncrementsEnabled = positionIncrementsEnabled;
+      Boolean splitOnWhitespace = getQueryConfigHandler().get(ConfigurationKeys.SPLIT_ON_WHITESPACE);
+      this.splitOnWhitespace = splitOnWhitespace != null ? splitOnWhitespace : false;
+      return super.process(queryTree);
+    }
+    return queryTree;
+  }
+
+  private class AnalyzedText {
+    CachingTokenFilter buffer = null;
+    int numTokens = 0;
+    int numPositions = 0;
+    boolean severalTokensAtSamePosition = false;
+    PositionIncrementAttribute posIncrAtt = null;
+    CharTermAttribute termAtt = null;
+    String field = null;
+    String text = null;
+
+    void process(String field, String text) {
+      this.field = field;
+      this.text = text;
+      try (TokenStream source = AnalyzerQueryNodeProcessor.this.analyzer.tokenStream(field, text)) {
+        buffer = new CachingTokenFilter(source);
+        buffer.reset();
+        posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);
+        termAtt = buffer.getAttribute(CharTermAttribute.class);
+
+        try {
+          while (buffer.incrementToken()) {
+            numTokens++;
+            if (getPositionIncrement() == 0) {
+              severalTokensAtSamePosition = true;
+            } else {
+              ++numPositions;
+            }
+          }
+        } catch (IOException e) {
+          // ignore
+        }
+
+        // rewind the buffer stream
+        buffer.reset();//will never throw on subsequent reset calls
+      } catch (IOException e) {
+        throw new RuntimeException(e);
       }
+    }
 
-      if (this.analyzer != null) {
-        return super.process(queryTree);
+    /** If there is a position increment attribute, return its value, otherwise return 1 */
+    public int getPositionIncrement() {
+      return posIncrAtt != null ? posIncrAtt.getPositionIncrement() : 1;
+    }
+  }
+
+  private QueryNode singleTokenQuery(AnalyzedText analyzed, FieldQueryNode fieldNode) {
+    String term = null;
+    try {
+      boolean hasNext = analyzed.buffer.incrementToken();
+      assert hasNext == true;
+      term = analyzed.termAtt.toString();
+    } catch (IOException e) {
+      // safe to ignore, because we know the number of tokens
+    }
+    fieldNode.setText(term);
+    return fieldNode;
+  }
+
+  private QueryNode singlePositionSynonymQuery(AnalyzedText analyzed) {
+    LinkedList<QueryNode> children = new LinkedList<>();
+    try {
+      while (analyzed.buffer.incrementToken()) {
+        String term = analyzed.termAtt.toString();
+        children.add(new FieldQueryNode(analyzed.field, term, -1, -1));
       }
+    } catch (IOException e) {
+      // safe to ignore because it's a cached token stream
     }
+    return new GroupQueryNode(new SynonymQueryNode(children));
+  }
 
-    return queryTree;
+  private QueryNode multiTermQuery(AnalyzedText analyzed) {
+    // multiple positions, maybe with synonyms
+    BooleanQueryNode q = new BooleanQueryNode(Collections.emptyList());
+    QueryNode currentQuery = null;
+    try {
+      while (analyzed.buffer.incrementToken()) {
+        String term = analyzed.termAtt.toString();
+        if (analyzed.getPositionIncrement() == 0) {
+          if (!(currentQuery instanceof SynonymQueryNode)) {
+            // Wrap the current query node in a SynonymQueryNode
+            currentQuery = new SynonymQueryNode(Collections.singletonList(currentQuery));
+          }
+          currentQuery.add(new FieldQueryNode(analyzed.field, term, -1, -1));
+        } else { // First term at this position
+          if (currentQuery != null) { // Add query for previous position
+            q.add(currentQuery, this.defaultOperator);
+          }
+          currentQuery = new FieldQueryNode(analyzed.field, term, -1, -1);
+        }
+      }
+    } catch (IOException e) {
+      // safe to ignore because it's a cached token stream
+    }
+    q.add(currentQuery, this.defaultOperator);
+    if (splitOnWhitespace == false && WHITESPACE_PATTERN.matcher(analyzed.text).find()) {
+      q.setTag(FlattenQueryNodeProcessor.IS_FLATTENABLE_TAG, Boolean.TRUE);
+    }
+    return new GroupQueryNode(q);
+  }
 
+  private QueryNode phraseQuery(AnalyzedText analyzed, QueryNode queryNode) {
+    int position = -1;
+    int positionNum = 0;
+    try {
+      while (analyzed.buffer.incrementToken()) {
+        String term = analyzed.termAtt.toString();
+        FieldQueryNode newFieldNode = new FieldQueryNode(analyzed.field, term, -1, -1);
+        if (this.positionIncrementsEnabled) {
+          position += analyzed.getPositionIncrement();
+          newFieldNode.setPosition(position);
+        } else {
+          newFieldNode.setPosition(positionNum++);
+        }
+        queryNode.add(newFieldNode);
+      }
+    } catch (IOException e) {
+      // safe to ignore because it's a cached token stream
+    }
+    return queryNode;
   }
 
   @Override
@@ -117,275 +234,56 @@ public class AnalyzerQueryNodeProcessor extends QueryNodeProcessorImpl {
         && !(node instanceof RegexpQueryNode)
         && !(node.getParent() instanceof RangeQueryNode)) {
 
-      FieldQueryNode fieldNode = ((FieldQueryNode) node);
-      String text = fieldNode.getTextAsString();
-      String field = fieldNode.getFieldAsString();
+      FieldQueryNode fieldNode = (FieldQueryNode)node;
+      AnalyzedText analyzed = new AnalyzedText();
 
-      CachingTokenFilter buffer = null;
-      PositionIncrementAttribute posIncrAtt = null;
-      int numTokens = 0;
-      int positionCount = 0;
-      boolean severalTokensAtSamePosition = false;
-      
       try {
-        try (TokenStream source = this.analyzer.tokenStream(field, text)) {
-          buffer = new CachingTokenFilter(source);
-          buffer.reset();
-
-          if (buffer.hasAttribute(PositionIncrementAttribute.class)) {
-            posIncrAtt = buffer.getAttribute(PositionIncrementAttribute.class);
-          }
-  
-          try {
-  
-            while (buffer.incrementToken()) {
-              numTokens++;
-              int positionIncrement = (posIncrAtt != null) ? posIncrAtt
-                  .getPositionIncrement() : 1;
-              if (positionIncrement != 0) {
-                positionCount += positionIncrement;
-  
-              } else {
-                severalTokensAtSamePosition = true;
-              }
-  
-            }
-  
-          } catch (IOException e) {
-            // ignore
-          }
-
-          // rewind the buffer stream
-          buffer.reset();//will never through on subsequent reset calls
-        } catch (IOException e) {
-          throw new RuntimeException(e);
-        }
+        analyzed.process(fieldNode.getFieldAsString(), fieldNode.getTextAsString());
 
-        if (!buffer.hasAttribute(CharTermAttribute.class)) {
+        if (analyzed.termAtt == null || analyzed.numTokens == 0) {
           return new NoTokenFoundQueryNode();
         }
-  
-        CharTermAttribute termAtt = buffer.getAttribute(CharTermAttribute.class);
-  
-        if (numTokens == 0) {
-          return new NoTokenFoundQueryNode();
-  
-        } else if (numTokens == 1) {
-          String term = null;
-          try {
-            boolean hasNext;
-            hasNext = buffer.incrementToken();
-            assert hasNext == true;
-            term = termAtt.toString();
-  
-          } catch (IOException e) {
-            // safe to ignore, because we know the number of tokens
-          }
-  
-          fieldNode.setText(term);
-  
-          return fieldNode;
-  
-        } else if (severalTokensAtSamePosition || !(node instanceof QuotedFieldQueryNode)) {
-          if (positionCount == 1 || !(node instanceof QuotedFieldQueryNode)) {
-            // no phrase query:
-            
-            if (positionCount == 1) {
-              // simple case: only one position, with synonyms
-              LinkedList<QueryNode> children = new LinkedList<>();
-              
-              for (int i = 0; i < numTokens; i++) {
-                String term = null;
-                try {
-                  boolean hasNext = buffer.incrementToken();
-                  assert hasNext == true;
-                  term = termAtt.toString();
-                  
-                } catch (IOException e) {
-                  // safe to ignore, because we know the number of tokens
-                }
-                
-                children.add(new FieldQueryNode(field, term, -1, -1));
-                
-              }
-              return new GroupQueryNode(
-                  new SynonymQueryNode(children));
+        if (analyzed.numTokens == 1) {
+          return singleTokenQuery(analyzed, fieldNode);
+        }
+        // More than one token
+        if (node instanceof QuotedFieldQueryNode) {
+          if (analyzed.severalTokensAtSamePosition) {
+            if (analyzed.numPositions == 1) {
+              return singlePositionSynonymQuery(analyzed);
             } else {
-              // multiple positions
-              QueryNode q = new BooleanQueryNode(Collections.<QueryNode>emptyList());
-              QueryNode currentQuery = null;
-              for (int i = 0; i < numTokens; i++) {
-                String term = null;
-                try {
-                  boolean hasNext = buffer.incrementToken();
-                  assert hasNext == true;
-                  term = termAtt.toString();
-                } catch (IOException e) {
-                  // safe to ignore, because we know the number of tokens
-                }
-                if (posIncrAtt != null && posIncrAtt.getPositionIncrement() == 0) {
-                  if (!(currentQuery instanceof BooleanQueryNode)) {
-                    QueryNode t = currentQuery;
-                    currentQuery = new SynonymQueryNode(Collections.<QueryNode>emptyList());
-                    ((BooleanQueryNode)currentQuery).add(t);
-                  }
-                  ((BooleanQueryNode)currentQuery).add(new FieldQueryNode(field, term, -1, -1));
-                } else {
-                  if (currentQuery != null) {
-                    if (this.defaultOperator == Operator.OR) {
-                      q.add(currentQuery);
-                    } else {
-                      q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));
-                    }
-                  }
-                  currentQuery = new FieldQueryNode(field, term, -1, -1);
-                }
-              }
-              if (this.defaultOperator == Operator.OR) {
-                q.add(currentQuery);
-              } else {
-                q.add(new ModifierQueryNode(currentQuery, Modifier.MOD_REQ));
-              }
-              
-              if (q instanceof BooleanQueryNode) {
-                q = new GroupQueryNode(q);
-              }
-              return q;
-            }
-          } else {
-            // phrase query:
-            MultiPhraseQueryNode mpq = new MultiPhraseQueryNode();
-  
-            List<FieldQueryNode> multiTerms = new ArrayList<>();
-            int position = -1;
-            int i = 0;
-            int termGroupCount = 0;
-            for (; i < numTokens; i++) {
-              String term = null;
-              int positionIncrement = 1;
-              try {
-                boolean hasNext = buffer.incrementToken();
-                assert hasNext == true;
-                term = termAtt.toString();
-                if (posIncrAtt != null) {
-                  positionIncrement = posIncrAtt.getPositionIncrement();
-                }
-  
-              } catch (IOException e) {
-                // safe to ignore, because we know the number of tokens
-              }
-  
-              if (positionIncrement > 0 && multiTerms.size() > 0) {
-  
-                for (FieldQueryNode termNode : multiTerms) {
-  
-                  if (this.positionIncrementsEnabled) {
-                    termNode.setPositionIncrement(position);
-                  } else {
-                    termNode.setPositionIncrement(termGroupCount);
-                  }
-  
-                  mpq.add(termNode);
-  
-                }
-  
-                // Only increment once for each "group" of
-                // terms that were in the same position:
-                termGroupCount++;
-  
-                multiTerms.clear();
-  
-              }
-  
-              position += positionIncrement;
-              multiTerms.add(new FieldQueryNode(field, term, -1, -1));
-  
-            }
-  
-            for (FieldQueryNode termNode : multiTerms) {
-  
-              if (this.positionIncrementsEnabled) {
-                termNode.setPositionIncrement(position);
-  
-              } else {
-                termNode.setPositionIncrement(termGroupCount);
-              }
-  
-              mpq.add(termNode);
-  
+              return phraseQuery(analyzed, new MultiPhraseQueryNode());
             }
-  
-            return mpq;
-  
+          } else { // no synonyms
+            return phraseQuery(analyzed, new TokenizedPhraseQueryNode());
           }
-  
-        } else {
-  
-          TokenizedPhraseQueryNode pq = new TokenizedPhraseQueryNode();
-  
-          int position = -1;
-  
-          for (int i = 0; i < numTokens; i++) {
-            String term = null;
-            int positionIncrement = 1;
-  
-            try {
-              boolean hasNext = buffer.incrementToken();
-              assert hasNext == true;
-              term = termAtt.toString();
-  
-              if (posIncrAtt != null) {
-                positionIncrement = posIncrAtt.getPositionIncrement();
-              }
-  
-            } catch (IOException e) {
-              // safe to ignore, because we know the number of tokens
-            }
-  
-            FieldQueryNode newFieldNode = new FieldQueryNode(field, term, -1, -1);
-  
-            if (this.positionIncrementsEnabled) {
-              position += positionIncrement;
-              newFieldNode.setPositionIncrement(position);
-  
-            } else {
-              newFieldNode.setPositionIncrement(i);
-            }
-  
-            pq.add(newFieldNode);
-  
+        } else { // not quoted
+          if (analyzed.numPositions == 1) {
+            return singlePositionSynonymQuery(analyzed);
+          } else {
+            return multiTermQuery(analyzed);
           }
-  
-          return pq;
-  
         }
       } finally {
-        if (buffer != null) {
+        if (analyzed.buffer != null) {
           try {
-            buffer.close();
+            analyzed.buffer.close();
           } catch (IOException e) {
             // safe to ignore
           }
         }
       }
     }
-
     return node;
   }
 
   @Override
   protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
-
     return node;
-
   }
 
   @Override
-  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-      throws QueryNodeException {
-
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children) throws QueryNodeException {
     return children;
-
   }
-
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/FlattenQueryNodeProcessor.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/FlattenQueryNodeProcessor.java
index e574a14..68b7952 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/FlattenQueryNodeProcessor.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/FlattenQueryNodeProcessor.java
@@ -20,7 +20,6 @@ package org.apache.lucene.queryparser.flexible.standard.processors;
 import java.util.List;
 import java.util.ListIterator;
 
-import com.sun.org.apache.xpath.internal.operations.Bool;
 import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
 import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.GroupQueryNode;
@@ -28,15 +27,14 @@ import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
 import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorImpl;
 
 /**
- * nocommit fix javadoc
- *
- * Flattens BooleanQueryNodes that have been marked as flattenable via
- * {@link BooleanQueryNode#setShouldFlatten(boolean)}, e.g. those produced
- * when StandardQueryParser is set to not split on whitespace and a BooleanQueryNode
- * is produced for text containing multiple space-separated terms.
+ * Flattens BooleanQueryNode-s that have been marked as flattenable by
+ * {@link AnalyzerQueryNodeProcessor#multiTermQuery} when StandardQueryParser
+ * is set to not split on whitespace and a BooleanQueryNode
+ * is produced for text containing multiple space-separated terms, by moving
+ * their children to the nearest BooleanQueryNode ancestor.
  */
-public class FlattenBooleanToParentQueryNodeProcessor extends QueryNodeProcessorImpl {
-  public static final String IS_FLATTENABLE_TAG = "is-flattenable"
+public class FlattenQueryNodeProcessor extends QueryNodeProcessorImpl {
+  public static final String IS_FLATTENABLE_TAG = "is-flattenable";
 
   @Override
   protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
@@ -50,26 +48,35 @@ public class FlattenBooleanToParentQueryNodeProcessor extends QueryNodeProcessor
 
   @Override
   protected List<QueryNode> setChildrenOrder(List<QueryNode> children) throws QueryNodeException {
-    if (children != null && children.size() == 1) {
-      QueryNode child = children.get(0);
-      QueryNode flattenable = findFlattenableNode(child);
-      if (flattenable != null) {
-
+    if (children != null) {
+      QueryNode firstChild = children.get(0);
+      if (firstChild.getParent() instanceof BooleanQueryNode) {
+        ListIterator<QueryNode> iterator = children.listIterator();
+        while (iterator.hasNext()) {
+          QueryNode child = iterator.next();
+          QueryNode flattenable = findFlattenableNode(child);
+          if (flattenable != null) {  // replace this child with its descendants
+            iterator.remove();
+            for (QueryNode descendant : flattenable.getChildren()) {
+              iterator.add(descendant);
+            }
+          }
+        }
       }
     }
     return children;
   }
 
-  private findFlattenableNode(QueryNode start) {
-
-    if ()
-  }
-    List<QueryNode> grandChildren = child.getChildren();
-    if (grandChildren != null && grandChildren.size() == 1) {
-      QueryNode grandChild = grandChildren.get(0);
-      if (grandChild instanceof GroupQueryNode) {
-
-      }
-
+  /** Recursively search for an only-child flattenable node, possibly nested within one or more group nodes */
+  private QueryNode findFlattenableNode(QueryNode start) {
+    if (start instanceof BooleanQueryNode && start.containsTag(IS_FLATTENABLE_TAG)
+        && (Boolean)start.getTag(IS_FLATTENABLE_TAG)) {
+      return start;
     }
+    List<QueryNode> children = start.getChildren();
+    if (children != null && children.size() == 1 && children.get(0) instanceof GroupQueryNode) {
+      return findFlattenableNode(children.get(0));
+    }
+    return null; // no flattenable node found
+  }
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/StandardQueryNodeProcessorPipeline.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/StandardQueryNodeProcessorPipeline.java
index 5b681b4..aed5734 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/StandardQueryNodeProcessorPipeline.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/standard/processors/StandardQueryNodeProcessorPipeline.java
@@ -60,6 +60,7 @@ public class StandardQueryNodeProcessorPipeline extends
     add(new TermRangeQueryNodeProcessor());
     add(new AllowLeadingWildcardProcessor());    
     add(new AnalyzerQueryNodeProcessor());
+    add(new FlattenQueryNodeProcessor());
     add(new PhraseSlopQueryNodeProcessor());
     //add(new GroupQueryNodeProcessor());
     add(new BooleanQuery2ModifierNodeProcessor());
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java
index de90e29..d7ca206 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParser.java
@@ -58,7 +58,6 @@ import java.io.IOException;
  */
 public class TestQueryParser extends QueryParserTestBase {
 
-  protected boolean splitOnWhitespace = QueryParser.DEFAULT_SPLIT_ON_WHITESPACE;
   private static final String FIELD = "field";
 
   public static class QPTestParser extends QueryParser {
@@ -83,7 +82,6 @@ public class TestQueryParser extends QueryParserTestBase {
     if (a == null) a = new MockAnalyzer(random(), MockTokenizer.SIMPLE, true);
     QueryParser qp = new QueryParser(getDefaultField(), a);
     qp.setDefaultOperator(QueryParserBase.OR_OPERATOR);
-    qp.setSplitOnWhitespace(splitOnWhitespace);
     return qp;
   }
   
@@ -482,232 +480,6 @@ public class TestQueryParser extends QueryParserTestBase {
     });
   }
 
-  // TODO: Remove this specialization once the flexible standard parser gets multi-word synonym support
-  @Override
-  public void testQPA() throws Exception {
-    boolean oldSplitOnWhitespace = splitOnWhitespace;
-    splitOnWhitespace = false;
-
-    assertQueryEquals("term phrase term", qpAnalyzer, "term phrase1 phrase2 term");
-
-    CommonQueryParserConfiguration cqpc = getParserConfig(qpAnalyzer);
-    setDefaultOperatorAND(cqpc);
-    assertQueryEquals(cqpc, "field", "term phrase term", "+term +phrase1 +phrase2 +term");
-
-    splitOnWhitespace = oldSplitOnWhitespace;
-  }
-
-  // TODO: Move to QueryParserTestBase once standard flexible parser gets this capability
-  public void testMultiWordSynonyms() throws Exception {
-    QueryParser dumb = new QueryParser("field", new Analyzer1());
-    dumb.setSplitOnWhitespace(false);
-
-    // A multi-word synonym source will form a synonym query for the same-starting-position tokens
-    BooleanQuery.Builder multiWordExpandedBqBuilder = new BooleanQuery.Builder();
-    Query multiWordSynonymQuery = new SynonymQuery(new Term("field", "guinea"), new Term("field", "cavy"));
-    multiWordExpandedBqBuilder.add(multiWordSynonymQuery, BooleanClause.Occur.SHOULD);
-    multiWordExpandedBqBuilder.add(new TermQuery(new Term("field", "pig")), BooleanClause.Occur.SHOULD);
-    Query multiWordExpandedBq = multiWordExpandedBqBuilder.build();
-    assertEquals(multiWordExpandedBq, dumb.parse("guinea pig"));
-
-    // With the phrase operator, a multi-word synonym source will form a multiphrase query.
-    // When the number of expanded term(s) is different from that of the original term(s), this is not good.
-    MultiPhraseQuery.Builder multiWordExpandedMpqBuilder = new MultiPhraseQuery.Builder();
-    multiWordExpandedMpqBuilder.add(new Term[]{new Term("field", "guinea"), new Term("field", "cavy")});
-    multiWordExpandedMpqBuilder.add(new Term("field", "pig"));
-    Query multiWordExpandedMPQ = multiWordExpandedMpqBuilder.build();
-    assertEquals(multiWordExpandedMPQ, dumb.parse("\"guinea pig\""));
-
-    // custom behavior, the synonyms are expanded, unless you use quote operator
-    QueryParser smart = new SmartQueryParser();
-    smart.setSplitOnWhitespace(false);
-    assertEquals(multiWordExpandedBq, smart.parse("guinea pig"));
-
-    PhraseQuery.Builder multiWordUnexpandedPqBuilder = new PhraseQuery.Builder();
-    multiWordUnexpandedPqBuilder.add(new Term("field", "guinea"));
-    multiWordUnexpandedPqBuilder.add(new Term("field", "pig"));
-    Query multiWordUnexpandedPq = multiWordUnexpandedPqBuilder.build();
-    assertEquals(multiWordUnexpandedPq, smart.parse("\"guinea pig\""));
-  }
-
-  // TODO: Move to QueryParserTestBase once standard flexible parser gets this capability
-  public void testOperatorsAndMultiWordSynonyms() throws Exception {
-    Analyzer a = new MockSynonymAnalyzer();
-
-    boolean oldSplitOnWhitespace = splitOnWhitespace;
-    splitOnWhitespace = false;
-
-    // Operators should interrupt multiword analysis of adjacent words if they associate
-    assertQueryEquals("+guinea pig", a, "+guinea pig");
-    assertQueryEquals("-guinea pig", a, "-guinea pig");
-    assertQueryEquals("!guinea pig", a, "-guinea pig");
-    assertQueryEquals("guinea* pig", a, "guinea* pig");
-    assertQueryEquals("guinea? pig", a, "guinea? pig");
-    assertQueryEquals("guinea~2 pig", a, "guinea~2 pig");
-    assertQueryEquals("guinea^2 pig", a, "(guinea)^2.0 pig");
-
-    assertQueryEquals("guinea +pig", a, "guinea +pig");
-    assertQueryEquals("guinea -pig", a, "guinea -pig");
-    assertQueryEquals("guinea !pig", a, "guinea -pig");
-    assertQueryEquals("guinea pig*", a, "guinea pig*");
-    assertQueryEquals("guinea pig?", a, "guinea pig?");
-    assertQueryEquals("guinea pig~2", a, "guinea pig~2");
-    assertQueryEquals("guinea pig^2", a, "guinea (pig)^2.0");
-
-    assertQueryEquals("field:guinea pig", a, "guinea pig");
-    assertQueryEquals("guinea field:pig", a, "guinea pig");
-
-    assertQueryEquals("NOT guinea pig", a, "-guinea pig");
-    assertQueryEquals("guinea NOT pig", a, "guinea -pig");
-
-    assertQueryEquals("guinea pig AND dogs", a, "guinea +pig +Synonym(dog dogs)");
-    assertQueryEquals("dogs AND guinea pig", a, "+Synonym(dog dogs) +guinea pig");
-    assertQueryEquals("guinea pig && dogs", a, "guinea +pig +Synonym(dog dogs)");
-    assertQueryEquals("dogs && guinea pig", a, "+Synonym(dog dogs) +guinea pig");
-
-    assertQueryEquals("guinea pig OR dogs", a, "guinea pig Synonym(dog dogs)");
-    assertQueryEquals("dogs OR guinea pig", a, "Synonym(dog dogs) guinea pig");
-    assertQueryEquals("guinea pig || dogs", a, "guinea pig Synonym(dog dogs)");
-    assertQueryEquals("dogs || guinea pig", a, "Synonym(dog dogs) guinea pig");
-
-    assertQueryEquals("\"guinea\" pig", a, "guinea pig");
-    assertQueryEquals("guinea \"pig\"", a, "guinea pig");
-
-    assertQueryEquals("(guinea) pig", a, "guinea pig");
-    assertQueryEquals("guinea (pig)", a, "guinea pig");
-
-    assertQueryEquals("/guinea/ pig", a, "/guinea/ pig");
-    assertQueryEquals("guinea /pig/", a, "guinea /pig/");
-
-    // Operators should not interrupt multiword analysis if not don't associate
-    assertQueryEquals("(guinea pig)", a, "Synonym(cavy guinea) pig");
-    assertQueryEquals("+(guinea pig)", a, "+(Synonym(cavy guinea) pig)");
-    assertQueryEquals("-(guinea pig)", a, "-(Synonym(cavy guinea) pig)");
-    assertQueryEquals("!(guinea pig)", a, "-(Synonym(cavy guinea) pig)");
-    assertQueryEquals("NOT (guinea pig)", a, "-(Synonym(cavy guinea) pig)");
-    assertQueryEquals("(guinea pig)^2", a, "(Synonym(cavy guinea) pig)^2.0");
-
-    assertQueryEquals("field:(guinea pig)", a, "Synonym(cavy guinea) pig");
-
-    assertQueryEquals("+small guinea pig", a, "+small Synonym(cavy guinea) pig");
-    assertQueryEquals("-small guinea pig", a, "-small Synonym(cavy guinea) pig");
-    assertQueryEquals("!small guinea pig", a, "-small Synonym(cavy guinea) pig");
-    assertQueryEquals("NOT small guinea pig", a, "-small Synonym(cavy guinea) pig");
-    assertQueryEquals("small* guinea pig", a, "small* Synonym(cavy guinea) pig");
-    assertQueryEquals("small? guinea pig", a, "small? Synonym(cavy guinea) pig");
-    assertQueryEquals("\"small\" guinea pig", a, "small Synonym(cavy guinea) pig");
-
-    assertQueryEquals("guinea pig +running", a, "Synonym(cavy guinea) pig +running");
-    assertQueryEquals("guinea pig -running", a, "Synonym(cavy guinea) pig -running");
-    assertQueryEquals("guinea pig !running", a, "Synonym(cavy guinea) pig -running");
-    assertQueryEquals("guinea pig NOT running", a, "Synonym(cavy guinea) pig -running");
-    assertQueryEquals("guinea pig running*", a, "Synonym(cavy guinea) pig running*");
-    assertQueryEquals("guinea pig running?", a, "Synonym(cavy guinea) pig running?");
-    assertQueryEquals("guinea pig \"running\"", a, "Synonym(cavy guinea) pig running");
-
-    assertQueryEquals("\"guinea pig\"~2", a, "\"(guinea cavy) pig\"~2");
-
-    assertQueryEquals("field:\"guinea pig\"", a, "\"(guinea cavy) pig\"");
-
-    splitOnWhitespace = oldSplitOnWhitespace;
-  }
-
-  public void testOperatorsAndMultiWordSynonymsSplitOnWhitespace() throws Exception {
-    Analyzer a = new MockSynonymAnalyzer();
-
-    boolean oldSplitOnWhitespace = splitOnWhitespace;
-    splitOnWhitespace = true;
-
-    assertQueryEquals("+guinea pig", a, "+guinea pig");
-    assertQueryEquals("-guinea pig", a, "-guinea pig");
-    assertQueryEquals("!guinea pig", a, "-guinea pig");
-    assertQueryEquals("guinea* pig", a, "guinea* pig");
-    assertQueryEquals("guinea? pig", a, "guinea? pig");
-    assertQueryEquals("guinea~2 pig", a, "guinea~2 pig");
-    assertQueryEquals("guinea^2 pig", a, "(guinea)^2.0 pig");
-
-    assertQueryEquals("guinea +pig", a, "guinea +pig");
-    assertQueryEquals("guinea -pig", a, "guinea -pig");
-    assertQueryEquals("guinea !pig", a, "guinea -pig");
-    assertQueryEquals("guinea pig*", a, "guinea pig*");
-    assertQueryEquals("guinea pig?", a, "guinea pig?");
-    assertQueryEquals("guinea pig~2", a, "guinea pig~2");
-    assertQueryEquals("guinea pig^2", a, "guinea (pig)^2.0");
-
-    assertQueryEquals("field:guinea pig", a, "guinea pig");
-    assertQueryEquals("guinea field:pig", a, "guinea pig");
-
-    assertQueryEquals("NOT guinea pig", a, "-guinea pig");
-    assertQueryEquals("guinea NOT pig", a, "guinea -pig");
-
-    assertQueryEquals("guinea pig AND dogs", a, "guinea +pig +Synonym(dog dogs)");
-    assertQueryEquals("dogs AND guinea pig", a, "+Synonym(dog dogs) +guinea pig");
-    assertQueryEquals("guinea pig && dogs", a, "guinea +pig +Synonym(dog dogs)");
-    assertQueryEquals("dogs && guinea pig", a, "+Synonym(dog dogs) +guinea pig");
-
-    assertQueryEquals("guinea pig OR dogs", a, "guinea pig Synonym(dog dogs)");
-    assertQueryEquals("dogs OR guinea pig", a, "Synonym(dog dogs) guinea pig");
-    assertQueryEquals("guinea pig || dogs", a, "guinea pig Synonym(dog dogs)");
-    assertQueryEquals("dogs || guinea pig", a, "Synonym(dog dogs) guinea pig");
-
-    assertQueryEquals("\"guinea\" pig", a, "guinea pig");
-    assertQueryEquals("guinea \"pig\"", a, "guinea pig");
-
-    assertQueryEquals("(guinea) pig", a, "guinea pig");
-    assertQueryEquals("guinea (pig)", a, "guinea pig");
-
-    assertQueryEquals("/guinea/ pig", a, "/guinea/ pig");
-    assertQueryEquals("guinea /pig/", a, "guinea /pig/");
-
-    assertQueryEquals("(guinea pig)", a, "guinea pig");
-    assertQueryEquals("+(guinea pig)", a, "+(guinea pig)");
-    assertQueryEquals("-(guinea pig)", a, "-(guinea pig)");
-    assertQueryEquals("!(guinea pig)", a, "-(guinea pig)");
-    assertQueryEquals("NOT (guinea pig)", a, "-(guinea pig)");
-    assertQueryEquals("(guinea pig)^2", a, "(guinea pig)^2.0");
-
-    assertQueryEquals("field:(guinea pig)", a, "guinea pig");
-
-    assertQueryEquals("+small guinea pig", a, "+small guinea pig");
-    assertQueryEquals("-small guinea pig", a, "-small guinea pig");
-    assertQueryEquals("!small guinea pig", a, "-small guinea pig");
-    assertQueryEquals("NOT small guinea pig", a, "-small guinea pig");
-    assertQueryEquals("small* guinea pig", a, "small* guinea pig");
-    assertQueryEquals("small? guinea pig", a, "small? guinea pig");
-    assertQueryEquals("\"small\" guinea pig", a, "small guinea pig");
-
-    assertQueryEquals("guinea pig +running", a, "guinea pig +running");
-    assertQueryEquals("guinea pig -running", a, "guinea pig -running");
-    assertQueryEquals("guinea pig !running", a, "guinea pig -running");
-    assertQueryEquals("guinea pig NOT running", a, "guinea pig -running");
-    assertQueryEquals("guinea pig running*", a, "guinea pig running*");
-    assertQueryEquals("guinea pig running?", a, "guinea pig running?");
-    assertQueryEquals("guinea pig \"running\"", a, "guinea pig running");
-
-    assertQueryEquals("\"guinea pig\"~2", a, "\"(guinea cavy) pig\"~2");
-
-    assertQueryEquals("field:\"guinea pig\"", a, "\"(guinea cavy) pig\"");
-
-    splitOnWhitespace = oldSplitOnWhitespace;
-  }
-
-  public void testDefaultSplitOnWhitespace() throws Exception {
-    QueryParser parser = new QueryParser("field", new Analyzer1());
-
-    assertFalse(parser.getSplitOnWhitespace()); // default is false
-
-    // A multi-word synonym source will form a synonym query for the same-starting-position tokens
-    BooleanQuery.Builder bqBuilder = new BooleanQuery.Builder();
-    bqBuilder.add(new SynonymQuery(new Term("field", "guinea"), new Term("field", "cavy")), BooleanClause.Occur.SHOULD);
-    bqBuilder.add(new TermQuery(new Term("field", "pig")), BooleanClause.Occur.SHOULD);
-    assertEquals(bqBuilder.build(), parser.parse("guinea pig"));
-
-    boolean oldSplitOnWhitespace = splitOnWhitespace;
-    splitOnWhitespace = QueryParser.DEFAULT_SPLIT_ON_WHITESPACE;
-    assertQueryEquals("guinea pig", new MockSynonymAnalyzer(), "Synonym(cavy guinea) pig");
-    splitOnWhitespace = oldSplitOnWhitespace;
-  }
-   
   public void testWildcardAlone() throws ParseException {
     //seems like crazy edge case, but can be useful in concordance 
     QueryParser parser = new QueryParser(FIELD, new ASCIIAnalyzer());
@@ -866,4 +638,25 @@ public class TestQueryParser extends QueryParserTestBase {
     }
 
   }
+
+  public void testCustomParserMultiWordSynonyms() throws Exception {
+    // custom behavior, the synonyms are expanded, unless you use quote operator
+    QueryParser smart = new SmartQueryParser();
+    smart.setSplitOnWhitespace(false);
+
+    // A multi-word synonym source will form a synonym query for the same-starting-position tokens
+    BooleanQuery.Builder multiWordExpandedBqBuilder = new BooleanQuery.Builder();
+    Query multiWordSynonymQuery = new SynonymQuery(new Term("field", "guinea"), new Term("field", "cavy"));
+    multiWordExpandedBqBuilder.add(multiWordSynonymQuery, BooleanClause.Occur.SHOULD);
+    multiWordExpandedBqBuilder.add(new TermQuery(new Term("field", "pig")), BooleanClause.Occur.SHOULD);
+    Query multiWordExpandedBq = multiWordExpandedBqBuilder.build();
+    assertEquals(multiWordExpandedBq, smart.parse("guinea pig"));
+
+    PhraseQuery.Builder multiWordUnexpandedPqBuilder = new PhraseQuery.Builder();
+    multiWordUnexpandedPqBuilder.add(new Term("field", "guinea"));
+    multiWordUnexpandedPqBuilder.add(new Term("field", "pig"));
+    Query multiWordUnexpandedPq = multiWordUnexpandedPqBuilder.build();
+    assertEquals(multiWordUnexpandedPq, smart.parse("\"guinea pig\""));
+  }
+
 }
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/ext/TestExtendableQueryParser.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/ext/TestExtendableQueryParser.java
index 934a4da..785dd1c 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/ext/TestExtendableQueryParser.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/ext/TestExtendableQueryParser.java
@@ -50,7 +50,6 @@ public class TestExtendableQueryParser extends TestQueryParser {
         getDefaultField(), a) : new ExtendableQueryParser(
         getDefaultField(), a, extensions);
     qp.setDefaultOperator(QueryParserBase.OR_OPERATOR);
-    qp.setSplitOnWhitespace(splitOnWhitespace);
     return qp;
   }
 
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestMultiAnalyzerQPHelper.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestMultiAnalyzerQPHelper.java
index 56ef65a..42b0140 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestMultiAnalyzerQPHelper.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestMultiAnalyzerQPHelper.java
@@ -51,13 +51,13 @@ public class TestMultiAnalyzerQPHelper extends LuceneTestCase {
         .toString());
 
     // two tokens at the same position:
-    assertEquals("(multi multi2) foo", qp.parse("multi foo", "").toString());
-    assertEquals("foo (multi multi2)", qp.parse("foo multi", "").toString());
-    assertEquals("(multi multi2) (multi multi2)", qp.parse("multi multi", "")
+    assertEquals("Synonym(multi multi2) foo", qp.parse("multi foo", "").toString());
+    assertEquals("foo Synonym(multi multi2)", qp.parse("foo multi", "").toString());
+    assertEquals("Synonym(multi multi2) Synonym(multi multi2)", qp.parse("multi multi", "")
         .toString());
-    assertEquals("+(foo (multi multi2)) +(bar (multi multi2))", qp.parse(
+    assertEquals("+(foo Synonym(multi multi2)) +(bar Synonym(multi multi2))", qp.parse(
         "+(foo multi) +(bar multi)", "").toString());
-    assertEquals("+(foo (multi multi2)) field:\"bar (multi multi2)\"", qp
+    assertEquals("+(foo Synonym(multi multi2)) field:\"bar (multi multi2)\"", qp
         .parse("+(foo multi) field:\"bar multi\"", "").toString());
 
     // phrases:
@@ -69,15 +69,14 @@ public class TestMultiAnalyzerQPHelper extends LuceneTestCase {
         "\"foo multi foobar multi\"", "").toString());
 
     // fields:
-    assertEquals("(field:multi field:multi2) field:foo", qp.parse(
+    assertEquals("Synonym(field:multi field:multi2) field:foo", qp.parse(
         "field:multi field:foo", "").toString());
     assertEquals("field:\"(multi multi2) foo\"", qp.parse(
         "field:\"multi foo\"", "").toString());
 
     // three tokens at one position:
-    assertEquals("triplemulti multi3 multi2", qp.parse("triplemulti", "")
-        .toString());
-    assertEquals("foo (triplemulti multi3 multi2) foobar", qp.parse(
+    assertEquals("Synonym(multi2 multi3 triplemulti)", qp.parse("triplemulti", "").toString());
+    assertEquals("foo Synonym(multi2 multi3 triplemulti) foobar", qp.parse(
         "foo triplemulti foobar", "").toString());
 
     // phrase with non-default slop:
@@ -98,7 +97,7 @@ public class TestMultiAnalyzerQPHelper extends LuceneTestCase {
 
     // non-default operator:
     qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
-    assertEquals("+(multi multi2) +foo", qp.parse("multi foo", "").toString());
+    assertEquals("+Synonym(multi multi2) +foo", qp.parse("multi foo", "").toString());
 
   }
 
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestStandardQP.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestStandardQP.java
index 7e50eeb..a5b558f 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestStandardQP.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestStandardQP.java
@@ -28,6 +28,7 @@ import org.apache.lucene.queryparser.util.QueryParserTestBase;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.SynonymQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
 
@@ -170,32 +171,28 @@ public class TestStandardQP extends QueryParserTestBase {
  
   @Override
   public void testNewFieldQuery() throws Exception {
-    /** ordinary behavior, synonyms form uncoordinated boolean query */
+    // ordinary behavior, synonyms form synonym query
     StandardQueryParser dumb = getParser(new Analyzer1());
-    BooleanQuery.Builder expanded = new BooleanQuery.Builder();
-    expanded.add(new TermQuery(new Term("field", "dogs")),
-        BooleanClause.Occur.SHOULD);
-    expanded.add(new TermQuery(new Term("field", "dog")),
-        BooleanClause.Occur.SHOULD);
-    assertEquals(expanded.build(), dumb.parse("\"dogs\"","field"));
-    /** even with the phrase operator the behavior is the same */
-    assertEquals(expanded.build(), dumb.parse("dogs","field"));
-    
-    /**
-     * custom behavior, the synonyms are expanded, unless you use quote operator
-     */
+    SynonymQuery expected = new SynonymQuery(new Term("field", "dogs"), new Term("field", "dog"));
+    assertEquals(expected, dumb.parse("dogs","field"));
+
+    // even with the phrase operator the behavior is the same
+    assertEquals(expected, dumb.parse("\"dogs\"","field"));
+
+    // custom behavior, the synonyms are expanded, unless you use quote operator
     //TODO test something like "SmartQueryParser()"
   }
 
-  // TODO: Remove this specialization once the flexible standard parser gets multi-word synonym support
+  // nocommit: Remove this specialization once the flexible standard parser gets multi-word synonym support
   @Override
   public void testQPA() throws Exception {
-    super.testQPA();
+//    super.testQPA();
 
-    assertQueryEquals("term phrase term", qpAnalyzer, "term (phrase1 phrase2) term");
+    assertTrue(getQuery("term term term", qpAnalyzer) instanceof BooleanQuery);
+//    assertQueryEquals("term phrase term", qpAnalyzer, "term (phrase1 phrase2) term");
 
-    CommonQueryParserConfiguration cqpc = getParserConfig(qpAnalyzer);
-    setDefaultOperatorAND(cqpc);
-    assertQueryEquals(cqpc, "field", "term phrase term", "+term +(+phrase1 +phrase2) +term");
+ //   CommonQueryParserConfiguration cqpc = getParserConfig(qpAnalyzer);
+//    setDefaultOperatorAND(cqpc);
+//    assertQueryEquals(cqpc, "field", "term phrase term", "+term +(+phrase1 +phrase2) +term");
   }
 }
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/util/QueryParserTestBase.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/util/QueryParserTestBase.java
index 2170193..452d6f6 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/util/QueryParserTestBase.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/util/QueryParserTestBase.java
@@ -57,7 +57,6 @@ import org.junit.BeforeClass;
 // TODO: it would be better to refactor the parts that are specific really
 // to the core QP and subclass/use the parts that are not in the flexible QP
 public abstract class QueryParserTestBase extends LuceneTestCase {
-  
   public static Analyzer qpAnalyzer;
 
   @BeforeClass
@@ -523,9 +522,8 @@ public abstract class QueryParserTestBase extends LuceneTestCase {
     
     assertQueryEquals("drop AND stop AND roll", qpAnalyzer, "+drop +roll");
 
-// TODO: Re-enable once flexible standard parser gets multi-word synonym support
-//    assertQueryEquals("term phrase term", qpAnalyzer,
-//                      "term phrase1 phrase2 term");
+    assertQueryEquals("term phrase term", qpAnalyzer,
+                      "term phrase1 phrase2 term");
     assertQueryEquals("term AND NOT phrase term", qpAnalyzer,
                       "+term -(phrase1 phrase2) term");
     assertMatchNoDocsQuery("stop^3", qpAnalyzer);
@@ -541,9 +539,8 @@ public abstract class QueryParserTestBase extends LuceneTestCase {
     
     CommonQueryParserConfiguration cqpc = getParserConfig(qpAnalyzer);
     setDefaultOperatorAND(cqpc);
-// TODO: Re-enable once flexible standard parser gets multi-word synonym support
-//    assertQueryEquals(cqpc, "field", "term phrase term",
-//        "+term +phrase1 +phrase2 +term");
+    assertQueryEquals(cqpc, "field", "term phrase term",
+        "+term +phrase1 +phrase2 +term");
     assertQueryEquals(cqpc, "field", "phrase",
         "+phrase1 +phrase2");
   }
@@ -1246,4 +1243,190 @@ public abstract class QueryParserTestBase extends LuceneTestCase {
     q.add(new TermQuery(new Term("field2", "z")), BooleanClause.Occur.MUST);
     assertEquals(q.build(), getQuery(query, new MockAnalyzer(random())));
   }
+
+  public void testMultiWordSynonyms() throws Exception {
+    CommonQueryParserConfiguration qp = getParserConfig(new Analyzer1());
+    qp.setSplitOnWhitespace(false);
+
+    // A multi-word synonym source will form a synonym query for the same-starting-position tokens
+    BooleanQuery.Builder multiWordExpandedBqBuilder = new BooleanQuery.Builder();
+    Query multiWordSynonymQuery = new SynonymQuery(new Term("field", "guinea"), new Term("field", "cavy"));
+    multiWordExpandedBqBuilder.add(multiWordSynonymQuery, BooleanClause.Occur.SHOULD);
+    multiWordExpandedBqBuilder.add(new TermQuery(new Term("field", "pig")), BooleanClause.Occur.SHOULD);
+    Query multiWordExpandedBq = multiWordExpandedBqBuilder.build();
+    assertEquals(multiWordExpandedBq, getQuery("guinea pig", qp));
+
+    // With the phrase operator, a multi-word synonym source will form a multiphrase query.
+    // When the number of expanded term(s) is different from that of the original term(s), this is not good.
+    MultiPhraseQuery.Builder multiWordExpandedMpqBuilder = new MultiPhraseQuery.Builder();
+    multiWordExpandedMpqBuilder.add(new Term[]{new Term("field", "guinea"), new Term("field", "cavy")});
+    multiWordExpandedMpqBuilder.add(new Term("field", "pig"));
+    Query multiWordExpandedMPQ = multiWordExpandedMpqBuilder.build();
+    assertEquals(multiWordExpandedMPQ, getQuery("\"guinea pig\"", qp));
+  }
+
+  // TODO: Move to QueryParserTestBase once standard flexible parser gets this capability
+  public void testOperatorsAndMultiWordSynonyms() throws Exception {
+    CommonQueryParserConfiguration qp = getParserConfig(new MockSynonymAnalyzer());
+    qp.setSplitOnWhitespace(false);
+
+    // Operators should interrupt multiword analysis of adjacent words if they associate
+    assertQueryEquals(qp, "field", "+guinea pig", "+guinea pig");
+    assertQueryEquals(qp, "field", "-guinea pig", "-guinea pig");
+    assertQueryEquals(qp, "field", "!guinea pig", "-guinea pig");
+    assertQueryEquals(qp, "field", "guinea* pig", "guinea* pig");
+    assertQueryEquals(qp, "field", "guinea? pig", "guinea? pig");
+    assertQueryEquals(qp, "field", "guinea~2 pig", "guinea~2 pig");
+    assertQueryEquals(qp, "field", "guinea^2 pig", "(guinea)^2.0 pig");
+
+    assertQueryEquals(qp, "field", "guinea +pig", "guinea +pig");
+    assertQueryEquals(qp, "field", "guinea -pig", "guinea -pig");
+    assertQueryEquals(qp, "field", "guinea !pig", "guinea -pig");
+    assertQueryEquals(qp, "field", "guinea pig*", "guinea pig*");
+    assertQueryEquals(qp, "field", "guinea pig?", "guinea pig?");
+    assertQueryEquals(qp, "field", "guinea pig~2", "guinea pig~2");
+    assertQueryEquals(qp, "field", "guinea pig^2", "guinea (pig)^2.0");
+
+    assertQueryEquals(qp, "field", "field:guinea pig", "guinea pig");
+    assertQueryEquals(qp, "field", "guinea field:pig", "guinea pig");
+
+    assertQueryEquals(qp, "field", "NOT guinea pig", "-guinea pig");
+    assertQueryEquals(qp, "field", "guinea NOT pig", "guinea -pig");
+
+    assertQueryEquals(qp, "field", "guinea pig AND dogs", "guinea +pig +Synonym(dog dogs)");
+    assertQueryEquals(qp, "field", "dogs AND guinea pig", "+Synonym(dog dogs) +guinea pig");
+    assertQueryEquals(qp, "field", "guinea pig && dogs", "guinea +pig +Synonym(dog dogs)");
+    assertQueryEquals(qp, "field", "dogs && guinea pig", "+Synonym(dog dogs) +guinea pig");
+
+    assertQueryEquals(qp, "field", "guinea pig OR dogs", "guinea pig Synonym(dog dogs)");
+    assertQueryEquals(qp, "field", "dogs OR guinea pig", "Synonym(dog dogs) guinea pig");
+    assertQueryEquals(qp, "field", "guinea pig || dogs", "guinea pig Synonym(dog dogs)");
+    assertQueryEquals(qp, "field", "dogs || guinea pig", "Synonym(dog dogs) guinea pig");
+
+    assertQueryEquals(qp, "field", "\"guinea\" pig", "guinea pig");
+    assertQueryEquals(qp, "field", "guinea \"pig\"", "guinea pig");
+
+    assertQueryEquals(qp, "field", "(guinea) pig", "guinea pig");
+    assertQueryEquals(qp, "field", "guinea (pig)", "guinea pig");
+
+    assertQueryEquals(qp, "field", "/guinea/ pig", "/guinea/ pig");
+    assertQueryEquals(qp, "field", "guinea /pig/", "guinea /pig/");
+
+    // Operators should not interrupt multiword analysis if they don't associate
+    assertQueryEquals(qp, "field", "(guinea pig)", "Synonym(cavy guinea) pig");
+    assertQueryEquals(qp, "field", "+(guinea pig)", "+(Synonym(cavy guinea) pig)");
+    assertQueryEquals(qp, "field", "-(guinea pig)", "-(Synonym(cavy guinea) pig)");
+    assertQueryEquals(qp, "field", "!(guinea pig)", "-(Synonym(cavy guinea) pig)");
+    assertQueryEquals(qp, "field", "NOT (guinea pig)", "-(Synonym(cavy guinea) pig)");
+    assertQueryEquals(qp, "field", "(guinea pig)^2", "(Synonym(cavy guinea) pig)^2.0");
+
+    assertQueryEquals(qp, "field", "field:(guinea pig)", "Synonym(cavy guinea) pig");
+
+    assertQueryEquals(qp, "field", "+small guinea pig", "+small Synonym(cavy guinea) pig");
+    assertQueryEquals(qp, "field", "-small guinea pig", "-small Synonym(cavy guinea) pig");
+    assertQueryEquals(qp, "field", "!small guinea pig", "-small Synonym(cavy guinea) pig");
+    assertQueryEquals(qp, "field", "NOT small guinea pig", "-small Synonym(cavy guinea) pig");
+    assertQueryEquals(qp, "field", "small* guinea pig", "small* Synonym(cavy guinea) pig");
+    assertQueryEquals(qp, "field", "small? guinea pig", "small? Synonym(cavy guinea) pig");
+    assertQueryEquals(qp, "field", "\"small\" guinea pig", "small Synonym(cavy guinea) pig");
+
+    assertQueryEquals(qp, "field", "guinea pig +running", "Synonym(cavy guinea) pig +running");
+    assertQueryEquals(qp, "field", "guinea pig -running", "Synonym(cavy guinea) pig -running");
+    assertQueryEquals(qp, "field", "guinea pig !running", "Synonym(cavy guinea) pig -running");
+    assertQueryEquals(qp, "field", "guinea pig NOT running", "Synonym(cavy guinea) pig -running");
+    assertQueryEquals(qp, "field", "guinea pig running*", "Synonym(cavy guinea) pig running*");
+    assertQueryEquals(qp, "field", "guinea pig running?", "Synonym(cavy guinea) pig running?");
+    assertQueryEquals(qp, "field", "guinea pig \"running\"", "Synonym(cavy guinea) pig running");
+
+    assertQueryEquals(qp, "field", "\"guinea pig\"~2", "\"(guinea cavy) pig\"~2");
+
+    assertQueryEquals(qp, "field", "field:\"guinea pig\"", "\"(guinea cavy) pig\"");
+  }
+
+  public void testOperatorsAndMultiWordSynonymsSplitOnWhitespace() throws Exception {
+    CommonQueryParserConfiguration qp = getParserConfig(new MockSynonymAnalyzer());
+    qp.setSplitOnWhitespace(true);
+
+    assertQueryEquals(qp, "field", "+guinea pig", "+guinea pig");
+    assertQueryEquals(qp, "field", "-guinea pig", "-guinea pig");
+    assertQueryEquals(qp, "field", "!guinea pig", "-guinea pig");
+    assertQueryEquals(qp, "field", "guinea* pig", "guinea* pig");
+    assertQueryEquals(qp, "field", "guinea? pig", "guinea? pig");
+    assertQueryEquals(qp, "field", "guinea~2 pig", "guinea~2 pig");
+    assertQueryEquals(qp, "field", "guinea^2 pig", "(guinea)^2.0 pig");
+
+    assertQueryEquals(qp, "field", "guinea +pig", "guinea +pig");
+    assertQueryEquals(qp, "field", "guinea -pig", "guinea -pig");
+    assertQueryEquals(qp, "field", "guinea !pig", "guinea -pig");
+    assertQueryEquals(qp, "field", "guinea pig*", "guinea pig*");
+    assertQueryEquals(qp, "field", "guinea pig?", "guinea pig?");
+    assertQueryEquals(qp, "field", "guinea pig~2", "guinea pig~2");
+    assertQueryEquals(qp, "field", "guinea pig^2", "guinea (pig)^2.0");
+
+    assertQueryEquals(qp, "field", "field:guinea pig", "guinea pig");
+    assertQueryEquals(qp, "field", "guinea field:pig", "guinea pig");
+
+    assertQueryEquals(qp, "field", "NOT guinea pig", "-guinea pig");
+    assertQueryEquals(qp, "field", "guinea NOT pig", "guinea -pig");
+
+    assertQueryEquals(qp, "field", "guinea pig AND dogs", "guinea +pig +Synonym(dog dogs)");
+    assertQueryEquals(qp, "field", "dogs AND guinea pig", "+Synonym(dog dogs) +guinea pig");
+    assertQueryEquals(qp, "field", "guinea pig && dogs", "guinea +pig +Synonym(dog dogs)");
+    assertQueryEquals(qp, "field", "dogs && guinea pig", "+Synonym(dog dogs) +guinea pig");
+
+    assertQueryEquals(qp, "field", "guinea pig OR dogs", "guinea pig Synonym(dog dogs)");
+    assertQueryEquals(qp, "field", "dogs OR guinea pig", "Synonym(dog dogs) guinea pig");
+    assertQueryEquals(qp, "field", "guinea pig || dogs", "guinea pig Synonym(dog dogs)");
+    assertQueryEquals(qp, "field", "dogs || guinea pig", "Synonym(dog dogs) guinea pig");
+
+    assertQueryEquals(qp, "field", "\"guinea\" pig", "guinea pig");
+    assertQueryEquals(qp, "field", "guinea \"pig\"", "guinea pig");
+
+    assertQueryEquals(qp, "field", "(guinea) pig", "guinea pig");
+    assertQueryEquals(qp, "field", "guinea (pig)", "guinea pig");
+
+    assertQueryEquals(qp, "field", "/guinea/ pig", "/guinea/ pig");
+    assertQueryEquals(qp, "field", "guinea /pig/", "guinea /pig/");
+
+    assertQueryEquals(qp, "field", "(guinea pig)", "guinea pig");
+    assertQueryEquals(qp, "field", "+(guinea pig)", "+(guinea pig)");
+    assertQueryEquals(qp, "field", "-(guinea pig)", "-(guinea pig)");
+    assertQueryEquals(qp, "field", "!(guinea pig)", "-(guinea pig)");
+    assertQueryEquals(qp, "field", "NOT (guinea pig)", "-(guinea pig)");
+    assertQueryEquals(qp, "field", "(guinea pig)^2", "(guinea pig)^2.0");
+
+    assertQueryEquals(qp, "field", "field:(guinea pig)", "guinea pig");
+
+    assertQueryEquals(qp, "field", "+small guinea pig", "+small guinea pig");
+    assertQueryEquals(qp, "field", "-small guinea pig", "-small guinea pig");
+    assertQueryEquals(qp, "field", "!small guinea pig", "-small guinea pig");
+    assertQueryEquals(qp, "field", "NOT small guinea pig", "-small guinea pig");
+    assertQueryEquals(qp, "field", "small* guinea pig", "small* guinea pig");
+    assertQueryEquals(qp, "field", "small? guinea pig", "small? guinea pig");
+    assertQueryEquals(qp, "field", "\"small\" guinea pig", "small guinea pig");
+
+    assertQueryEquals(qp, "field", "guinea pig +running", "guinea pig +running");
+    assertQueryEquals(qp, "field", "guinea pig -running", "guinea pig -running");
+    assertQueryEquals(qp, "field", "guinea pig !running", "guinea pig -running");
+    assertQueryEquals(qp, "field", "guinea pig NOT running", "guinea pig -running");
+    assertQueryEquals(qp, "field", "guinea pig running*", "guinea pig running*");
+    assertQueryEquals(qp, "field", "guinea pig running?", "guinea pig running?");
+    assertQueryEquals(qp, "field", "guinea pig \"running\"", "guinea pig running");
+
+    assertQueryEquals(qp, "field", "\"guinea pig\"~2", "\"(guinea cavy) pig\"~2");
+
+    assertQueryEquals(qp, "field","field:\"guinea pig\"", "\"(guinea cavy) pig\"");
+  }
+
+  public void testDefaultSplitOnWhitespace() throws Exception {
+    CommonQueryParserConfiguration qp = getParserConfig(new MockSynonymAnalyzer());
+
+    assertTrue(qp.getSplitOnWhitespace()); // default is true
+
+    // A multi-word synonym source will form a synonym query for the same-starting-position tokens
+    BooleanQuery.Builder bqBuilder = new BooleanQuery.Builder();
+    bqBuilder.add(new TermQuery(new Term("field", "guinea")), BooleanClause.Occur.SHOULD);
+    bqBuilder.add(new TermQuery(new Term("field", "pig")), BooleanClause.Occur.SHOULD);
+    assertEquals(bqBuilder.build(), getQuery("guinea pig"));
+  }
 }
