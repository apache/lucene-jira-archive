Index: CHANGES.txt
===================================================================
--- CHANGES.txt	(revision 552535)
+++ CHANGES.txt	(working copy)
@@ -26,6 +26,9 @@
     significantly, especially when the number of Tokens is large. 
     (Mark Miller via Michael Busch)
 
+ 2. LUCENE-892: Fixed extra "buffer to buffer copy" that sometimes
+    takes place when using compound files.  (Mike McCandless)
+
 Documentation
 
 Build
Index: src/java/org/apache/lucene/index/CompoundFileReader.java
===================================================================
--- src/java/org/apache/lucene/index/CompoundFileReader.java	(revision 552535)
+++ src/java/org/apache/lucene/index/CompoundFileReader.java	(working copy)
@@ -237,7 +237,7 @@
               if(start + len > length)
                 throw new IOException("read past EOF");
               base.seek(fileOffset + start);
-              base.readBytes(b, offset, len);
+              base.readBytes(b, offset, len, false);
             }
         }
 
Index: src/java/org/apache/lucene/store/IndexInput.java
===================================================================
--- src/java/org/apache/lucene/store/IndexInput.java	(revision 552535)
+++ src/java/org/apache/lucene/store/IndexInput.java	(working copy)
@@ -40,6 +40,25 @@
   public abstract void readBytes(byte[] b, int offset, int len)
     throws IOException;
 
+  /** Reads a specified number of bytes into an array at the
+   * specified offset with control over whether the read
+   * should be buffered (callers who have their own buffer
+   * should pass in "false" for useBuffer).  Currently only
+   * {@link BufferedIndexInput} respects this parameter.
+   * @param b the array to read bytes into
+   * @param offset the offset in the array to start storing bytes
+   * @param len the number of bytes to read
+   * @param useBuffer set to false if the caller will handle
+   * buffering.
+   * @see IndexOutput#writeBytes(byte[],int)
+   */
+  public void readBytes(byte[] b, int offset, int len, boolean useBuffer)
+    throws IOException
+  {
+    // Default to ignoring useBuffer entirely
+    readBytes(b, offset, len);
+  }
+
   /** Reads four bytes and returns an int.
    * @see IndexOutput#writeInt(int)
    */
Index: src/java/org/apache/lucene/store/BufferedIndexInput.java
===================================================================
--- src/java/org/apache/lucene/store/BufferedIndexInput.java	(revision 552535)
+++ src/java/org/apache/lucene/store/BufferedIndexInput.java	(working copy)
@@ -84,8 +84,13 @@
   }
 
   public void readBytes(byte[] b, int offset, int len) throws IOException {
+    readBytes(b, offset, len, true);
+  }
+
+  public void readBytes(byte[] b, int offset, int len, boolean useBuffer) throws IOException {
+
     if(len <= (bufferLength-bufferPosition)){
-      // the buffer contains enough data to satistfy this request
+      // the buffer contains enough data to satisfy this request
       if(len>0) // to allow b to be null if len is 0...
         System.arraycopy(buffer, bufferPosition, b, offset, len);
       bufferPosition+=len;
@@ -99,7 +104,7 @@
         bufferPosition += available;
       }
       // and now, read the remaining 'len' bytes:
-      if(len<bufferSize){
+      if(useBuffer && len<bufferSize){
         // If the amount left to read is small enough, do it in the usual
         // buffered way: fill the buffer and copy from it:
         refill();
@@ -112,10 +117,13 @@
           bufferPosition=len;
         }
       } else {
-        // The amount left to read is larger than the buffer - there's no
-        // performance reason not to read it all at once. Note that unlike
-        // the previous code of this function, there is no need to do a seek
-        // here, because there's no need to reread what we had in the buffer.
+        // The amount left to read is larger than the buffer
+        // or we've been asked to not use our buffer -
+        // there's no performance reason not to read it all
+        // at once. Note that unlike the previous code of
+        // this function, there is no need to do a seek
+        // here, because there's no need to reread what we
+        // had in the buffer.
         long after = bufferStart+bufferPosition+len;
         if(after > length())
           throw new IOException("read past EOF");
