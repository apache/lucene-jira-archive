diff --git a/lucene/core/src/java/org/apache/lucene/search/AdvancingIntervalIterator.java b/lucene/core/src/java/org/apache/lucene/search/AdvancingIntervalIterator.java
new file mode 100644
index 0000000..df71686
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/AdvancingIntervalIterator.java
@@ -0,0 +1,44 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+/**
+ * An IntervalIterator that will advance its parent Scorer when reset() is
+ * called.  Used for wrapping lazy scorers to ensure that all intervals
+ * are returned.
+ */
+public class AdvancingIntervalIterator extends IntervalFilter {
+
+  private final Scorer scorer;
+
+  public AdvancingIntervalIterator(Scorer scorer) {
+    super(scorer.intervals());
+    this.scorer = scorer;
+  }
+
+  @Override
+  public void reset(int docId) throws IOException {
+    if (scorer.docID() < docId) {
+      scorer.advance(docId);
+    }
+    in.reset(docId);
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java b/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
index c3d2f56..59fdbc7 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
@@ -173,9 +173,9 @@ public class BooleanQuery extends Query implements Iterable<BooleanClause> {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
     BooleanQuery query = this;
-    if (needsScores == false) {
+    if (needsScores == Weight.Postings.DOCS) {
       // we rewrite MUST clauses to FILTER for caching
       query = downgradeMustClauseToFilter(query);
     }
diff --git a/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java b/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java
index a59ac91..4ecf07e 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java
@@ -40,19 +40,21 @@ public class BooleanWeight extends Weight {
   protected final BooleanQuery query;
   protected ArrayList<Weight> weights;
   protected int maxCoord;  // num optional + num required
-  private final boolean disableCoord;
-  private final boolean needsScores;
+  private boolean disableCoord;
+  private final Weight.Postings flags;
   private final float coords[];
 
-  public BooleanWeight(BooleanQuery query, IndexSearcher searcher, boolean needsScores, boolean disableCoord) throws IOException {
+  public BooleanWeight(BooleanQuery query, IndexSearcher searcher, Weight.Postings flags, boolean disableCoord) throws IOException {
     super(query);
     this.query = query;
-    this.needsScores = needsScores;
+    this.flags = flags;
     this.similarity = searcher.getSimilarity();
+    this.disableCoord = disableCoord;
+
     weights = new ArrayList<>(query.clauses().size());
     for (int i = 0 ; i < query.clauses().size(); i++) {
       BooleanClause c = query.clauses().get(i);
-      Weight w = searcher.createWeight(c.getQuery(), needsScores && c.isScoring());
+      Weight w = searcher.createWeight(c.getQuery(), c.isScoring() ? flags : Postings.DOCS);
       weights.add(w);
       if (c.isScoring()) {
         maxCoord++;
@@ -64,7 +66,7 @@ public class BooleanWeight extends Weight {
     coords = new float[maxCoord+1];
     Arrays.fill(coords, 1F);
     coords[0] = 0f;
-    if (maxCoord > 0 && needsScores && disableCoord == false) {
+    if (maxCoord > 0 && flags.compareTo(Postings.DOCS) > 0 && disableCoord == false) {
       // compute coords from the similarity, look for any actual ones.
       boolean seenActualCoord = false;
       for (int i = 1; i < coords.length; i++) {
@@ -321,7 +323,7 @@ public class BooleanWeight extends Weight {
     }
 
     // we don't need scores, so if we have required clauses, drop optional clauses completely
-    if (!needsScores && minShouldMatch == 0 && required.size() > 0) {
+    if (flags == Postings.DOCS && minShouldMatch == 0 && required.size() > 0) {
       optional.clear();
     }
     
@@ -377,7 +379,7 @@ public class BooleanWeight extends Weight {
     if (required.size() == 1) {
       Scorer req = required.get(0);
 
-      if (needsScores == false ||
+      if (flags == Postings.DOCS ||
           (requiredScoring.size() == 1 && (disableCoord || maxCoord == 1))) {
         return req;
       } else {
@@ -421,7 +423,7 @@ public class BooleanWeight extends Weight {
       if (minShouldMatch > 1) {
         return new MinShouldMatchSumScorer(this, optional, minShouldMatch, coords);
       } else {
-        return new DisjunctionSumScorer(this, optional, coords, needsScores);
+        return new DisjunctionSumScorer(this, optional, coords, flags != Postings.DOCS);
       }
     }
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery.java b/lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery.java
index 77b4660..13dbd84 100644
--- a/lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery.java
@@ -107,9 +107,9 @@ public class CachingWrapperQuery extends Query implements Accountable {
   int hitCount, missCount;
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
     final Weight weight = query.createWeight(searcher, needsScores);
-    if (needsScores) {
+    if (needsScores.compareTo(Weight.Postings.DOCS) > 0) {
       // our cache is not sufficient, we need scores too
       return weight;
     }
diff --git a/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java b/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
index d573b10..308a579 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
@@ -63,6 +63,15 @@ class ConjunctionScorer extends Scorer {
   }
 
   @Override
+  public IntervalIterator intervals() {
+    IntervalIterator[] subIntervals = new IntervalIterator[scorers.length];
+    for (int i = 0; i < scorers.length; i++) {
+      subIntervals[i] = scorers[i].intervals();
+    }
+    return new MultiIntervalIterator(subIntervals);
+  }
+
+  @Override
   public float score() throws IOException {
     // TODO: sum into a double and cast to float if we ever send required clauses to BS1
     float sum = 0.0f;
diff --git a/lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java b/lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java
index e8241ac..de0db8d 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java
@@ -76,7 +76,7 @@ public class ConstantScoreQuery extends Query {
     private final Weight innerWeight;
     private float queryNorm;
     private float queryWeight;
-    
+
     public ConstantWeight(Weight innerWeight) throws IOException {
       super(ConstantScoreQuery.this);
       this.innerWeight = innerWeight;
@@ -250,9 +250,9 @@ public class ConstantScoreQuery extends Query {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    final Weight innerWeight = searcher.createWeight(query, false);
-    if (needsScores) {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
+    final Weight innerWeight = searcher.createWeight(query, Weight.Postings.DOCS);
+    if (needsScores.compareTo(Weight.Postings.DOCS) > 0) {
       return new ConstantScoreQuery.ConstantWeight(innerWeight);
     } else {
       return innerWeight;
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
index c931d92..f81cdbc 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
@@ -119,12 +119,12 @@ public class DisjunctionMaxQuery extends Query implements Iterable<Query> {
     private final boolean needsScores;
 
     /** Construct the Weight for this Query searched by searcher.  Recursively construct subquery weights. */
-    public DisjunctionMaxWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    public DisjunctionMaxWeight(IndexSearcher searcher, Weight.Postings flags) throws IOException {
       super(DisjunctionMaxQuery.this);
       for (Query disjunctQuery : disjuncts) {
-        weights.add(disjunctQuery.createWeight(searcher, needsScores));
+        weights.add(disjunctQuery.createWeight(searcher, flags));
       }
-      this.needsScores = needsScores;
+      this.needsScores = flags.compareTo(Postings.DOCS) > 0;
     }
 
     /** Compute the sub of squared weights of us applied to our subqueries.  Used for normalization. */
@@ -196,7 +196,7 @@ public class DisjunctionMaxQuery extends Query implements Iterable<Query> {
 
   /** Create the Weight used to score us */
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
     return new DisjunctionMaxWeight(searcher, needsScores);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java b/lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java
index 09bcdd4..852af29 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java
@@ -234,4 +234,15 @@ abstract class DisjunctionScorer extends Scorer {
     return children;
   }
 
+  @Override
+  public IntervalIterator intervals() {
+    IntervalIterator[] subIntervals = new IntervalIterator[subScorers.size()];
+    int i = 0;
+    for (ScorerWrapper wrapper : subScorers) {
+      subIntervals[i] = wrapper.scorer.intervals();
+      i++;
+    }
+    return new MultiIntervalIterator(subIntervals);
+  }
+
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery.java b/lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery.java
index 5d66d0b..c89855f 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DocValuesRangeQuery.java
@@ -119,7 +119,7 @@ public final class DocValuesRangeQuery extends Query {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
     if (lowerVal == null && upperVal == null) {
       throw new IllegalStateException("Both min and max values cannot be null, call rewrite first");
     }
diff --git a/lucene/core/src/java/org/apache/lucene/search/DocValuesRewriteMethod.java b/lucene/core/src/java/org/apache/lucene/search/DocValuesRewriteMethod.java
index 0a33b05..b0df661 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DocValuesRewriteMethod.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DocValuesRewriteMethod.java
@@ -81,7 +81,7 @@ public final class DocValuesRewriteMethod extends MultiTermQuery.RewriteMethod {
     public final String getField() { return query.getField(); }
     
     @Override
-    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
       return new ConstantScoreWeight(this) {
         @Override
         Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {
diff --git a/lucene/core/src/java/org/apache/lucene/search/DocValuesTermsQuery.java b/lucene/core/src/java/org/apache/lucene/search/DocValuesTermsQuery.java
index 4875b16..6d2f5d5 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DocValuesTermsQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DocValuesTermsQuery.java
@@ -145,7 +145,7 @@ public class DocValuesTermsQuery extends Query {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
     return new ConstantScoreWeight(this) {
 
       @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/FieldValueQuery.java b/lucene/core/src/java/org/apache/lucene/search/FieldValueQuery.java
index 2195ed0..709f647 100644
--- a/lucene/core/src/java/org/apache/lucene/search/FieldValueQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/FieldValueQuery.java
@@ -60,7 +60,7 @@ public final class FieldValueQuery extends Query {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
     return new ConstantScoreWeight(this) {
 
       @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/Filter.java b/lucene/core/src/java/org/apache/lucene/search/Filter.java
index 387c2e1..53717fe 100644
--- a/lucene/core/src/java/org/apache/lucene/search/Filter.java
+++ b/lucene/core/src/java/org/apache/lucene/search/Filter.java
@@ -75,7 +75,7 @@ public abstract class Filter extends Query {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings flags) throws IOException {
     return new Weight(this) {
 
       @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/FilterScorer.java b/lucene/core/src/java/org/apache/lucene/search/FilterScorer.java
index 7b5e340..1cdfc06 100644
--- a/lucene/core/src/java/org/apache/lucene/search/FilterScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/FilterScorer.java
@@ -82,6 +82,10 @@ public abstract class FilterScorer extends Scorer {
   }
   
   @Override
+  public IntervalIterator intervals() {
+    return in.intervals();
+  }
+
   public final TwoPhaseIterator asTwoPhaseIterator() {
     return in.asTwoPhaseIterator();
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java b/lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java
index 38cf257..2e1dd50 100644
--- a/lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java
@@ -85,7 +85,7 @@ public class FilteredQuery extends Query {
    * This is accomplished by overriding the Scorer returned by the Weight.
    */
   @Override
-  public Weight createWeight(final IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(final IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
     final Weight weight = query.createWeight (searcher, needsScores);
     return new Weight(FilteredQuery.this) {
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java b/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
index a165dfd..a757e71 100644
--- a/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
+++ b/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
@@ -344,7 +344,8 @@ public class IndexSearcher {
    */
   public void search(Query query, Collector results)
     throws IOException {
-    search(leafContexts, createNormalizedWeight(query, results.needsScores()), results);
+    Weight.Postings postings = results.needsScores() ? Weight.Postings.DOCS_AND_SCORES : Weight.Postings.DOCS;
+    search(leafContexts, createNormalizedWeight(query, postings), results);
   }
 
   /** Search implementation with arbitrary sorting, plus
@@ -467,11 +468,12 @@ public class IndexSearcher {
       return collectorManager.reduce(Collections.singletonList(collector));
     } else {
       final List<C> collectors = new ArrayList<>(leafSlices.length);
-      boolean needsScores = false;
+      Weight.Postings needsScores = Weight.Postings.DOCS;
       for (int i = 0; i < leafSlices.length; ++i) {
         final C collector = collectorManager.newCollector();
         collectors.add(collector);
-        needsScores |= collector.needsScores();
+        if (collectors.get(i).needsScores())
+          needsScores = Weight.Postings.DOCS_AND_SCORES;
       }
 
       final Weight weight = createNormalizedWeight(query, needsScores);
@@ -571,7 +573,7 @@ public class IndexSearcher {
    * entire index.
    */
   public Explanation explain(Query query, int doc) throws IOException {
-    return explain(createNormalizedWeight(query, true), doc);
+    return explain(createNormalizedWeight(query, Weight.Postings.DOCS_AND_SCORES), doc);
   }
 
   /** Expert: low-level implementation method
@@ -601,7 +603,7 @@ public class IndexSearcher {
    * can then directly be used to get a {@link Scorer}.
    * @lucene.internal
    */
-  public Weight createNormalizedWeight(Query query, boolean needsScores) throws IOException {
+  public Weight createNormalizedWeight(Query query, Weight.Postings needsScores) throws IOException {
     query = rewrite(query);
     Weight weight = createWeight(query, needsScores);
     float v = weight.getValueForNormalization();
@@ -618,10 +620,10 @@ public class IndexSearcher {
    * if possible and configured.
    * @lucene.experimental
    */
-  public Weight createWeight(Query query, boolean needsScores) throws IOException {
+  public Weight createWeight(Query query, Weight.Postings needsScores) throws IOException {
     final QueryCache queryCache = this.queryCache;
     Weight weight = query.createWeight(this, needsScores);
-    if (needsScores == false && queryCache != null) {
+    if (needsScores.compareTo(Weight.Postings.DOCS) == 0 && queryCache != null) {
       weight = queryCache.doCache(weight, queryCachingPolicy);
     }
     return weight;
diff --git a/lucene/core/src/java/org/apache/lucene/search/Interval.java b/lucene/core/src/java/org/apache/lucene/search/Interval.java
new file mode 100644
index 0000000..1bd4aca
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/Interval.java
@@ -0,0 +1,61 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+class Interval {
+  int start;
+  int end;
+
+  public void set(IntervalIterator it) {
+    this.start = it.start();
+    this.end = it.end();
+  }
+
+  public void set(int start, int end) {
+    assert start <= end;
+    this.start = start;
+    this.end = end;
+  }
+
+  public void setMaximum() {
+    this.start = Integer.MAX_VALUE;
+    this.end = Integer.MAX_VALUE;
+  }
+
+  public void setMinimum() {
+    this.start = Integer.MIN_VALUE;
+    this.end = Integer.MIN_VALUE;
+  }
+
+  public boolean isMaximum() {
+    return this.start == Integer.MAX_VALUE && this.end == Integer.MAX_VALUE;
+  }
+
+  @Override
+  public String toString() {
+    return start + "->" + end;
+  }
+
+  public boolean overlaps(Interval other) {
+    if (other.end < this.start)
+      return false;
+    if (other.start > this.end)
+      return false;
+    return true;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IntervalFilter.java b/lucene/core/src/java/org/apache/lucene/search/IntervalFilter.java
new file mode 100644
index 0000000..8463966
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IntervalFilter.java
@@ -0,0 +1,77 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+/**
+ * Filters an {@link IntervalIterator}
+ */
+public class IntervalFilter implements IntervalIterator {
+
+  protected final IntervalIterator in;
+
+  public IntervalFilter(IntervalIterator in) {
+    this.in = in;
+  }
+
+  @Override
+  public int matchDistance() {
+    return in.matchDistance();
+  }
+
+  @Override
+  public boolean nextInterval() throws IOException {
+    return in.nextInterval();
+  }
+
+  @Override
+  public void reset(int docId) throws IOException {
+    in.reset(docId);
+  }
+
+  @Override
+  public int start() {
+    return in.start();
+  }
+
+  @Override
+  public int end() {
+    return in.end();
+  }
+
+  public static class MaxWidthFilter extends IntervalFilter {
+
+    final int width;
+
+    public MaxWidthFilter(IntervalIterator in, int width) {
+      super(in);
+      this.width = width;
+    }
+
+    @Override
+    public boolean nextInterval() throws IOException {
+      while (in.nextInterval()) {
+        int distance = in.matchDistance();
+        if (distance <= width)
+          return true;
+      }
+      return false;
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IntervalFilterQuery.java b/lucene/core/src/java/org/apache/lucene/search/IntervalFilterQuery.java
new file mode 100644
index 0000000..56c3508
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IntervalFilterQuery.java
@@ -0,0 +1,106 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Set;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.util.Bits;
+
+public class IntervalFilterQuery extends Query {
+
+  protected final Query in;
+  protected final IntervalFilterFactory intervalFilterFactory;
+
+  public IntervalFilterQuery(IntervalFilterFactory intervalFilterFactory, Query in) {
+    this.intervalFilterFactory = intervalFilterFactory;
+    this.in = in;
+  }
+
+  @Override
+  public void extractTerms(Set<Term> terms) {
+    in.extractTerms(terms);
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    Query rewritten = in.rewrite(reader);
+    if (rewritten != in)
+      return new IntervalFilterQuery(intervalFilterFactory, rewritten);
+    return this;
+  }
+
+  @Override
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
+    return new IntervalFilterWeight(this, in.createWeight(searcher, Weight.Postings.DOCS_AND_SCORES_AND_POSITIONS), searcher);
+  }
+
+
+  @Override
+  public String toString(String field) {
+    return intervalFilterFactory.getName() + "[" + in.toString(field) + " ]";
+  }
+
+  public class IntervalFilterWeight extends IntervalWeight {
+
+    public IntervalFilterWeight(Query query, Weight in, IndexSearcher searcher) throws IOException {
+      super(query, in, searcher);
+    }
+
+    @Override
+    public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
+      Scorer subScorer = subWeights.get(0).scorer(context, acceptDocs);
+      if (subScorer == null)
+        return null;
+      return new IntervalScorer(subScorer, intervalFilterFactory.filter(subScorer.intervals()), getSimScorer(context));
+    }
+  }
+
+  public static interface IntervalFilterFactory {
+
+    public IntervalIterator filter(IntervalIterator in);
+
+    public String getName();
+
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+    if (!super.equals(o)) return false;
+
+    IntervalFilterQuery that = (IntervalFilterQuery) o;
+
+    if (intervalFilterFactory != null ? !intervalFilterFactory.equals(that.intervalFilterFactory) : that.intervalFilterFactory != null)
+      return false;
+    return in.equals(that.in);
+
+  }
+
+  @Override
+  public int hashCode() {
+    int result = super.hashCode();
+    result = 31 * result + (in.hashCode());
+    result = 31 * result + (intervalFilterFactory != null ? intervalFilterFactory.hashCode() : 0);
+    return result;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IntervalIterator.java b/lucene/core/src/java/org/apache/lucene/search/IntervalIterator.java
new file mode 100644
index 0000000..c84aed6
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IntervalIterator.java
@@ -0,0 +1,88 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+/**
+ * Interface defining how to iterate through a Scorer's intervals.  Intervals
+ * are returned in a strictly ordered manner.
+ */
+public interface IntervalIterator {
+
+  /**
+   * Return the width of the current interval.  Do not call before {@link #nextInterval()}
+   * @return the width of the current interval
+   */
+  public int matchDistance();
+
+  /**
+   * Move to the next interval.  Do not call before {@link #reset(int)}
+   * @return false if intervals are exhausted for this document, otherwise true
+   */
+  public boolean nextInterval() throws IOException;
+
+  /**
+   * Reset the iterator to the given docId
+   * @param docId the docId that the parent Scorer is on
+   */
+  public void reset(int docId) throws IOException;
+
+  /**
+   * @return the starting position of the current interval
+   */
+  public int start();
+
+  /**
+   * @return the ending position of the current interval
+   */
+  public int end();
+
+  /**
+   * An IntervalIterator that always returns {@code false} from {@link #nextInterval()}
+   */
+  public static IntervalIterator EMPTY = new IntervalIterator() {
+
+    @Override
+    public int matchDistance() {
+      return 0;
+    }
+
+    @Override
+    public boolean nextInterval() {
+      return false;
+    }
+
+    @Override
+    public void reset(int docId) {
+    }
+
+    @Override
+    public int start() {
+      throw new IllegalStateException("Cannot call start() when unpositioned");
+    }
+
+    @Override
+    public int end() {
+      throw new IllegalStateException("Cannot call end() when unpositioned");
+    }
+  };
+
+  public enum State { RESET, ITERATING, EXHAUSTED }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IntervalScorer.java b/lucene/core/src/java/org/apache/lucene/search/IntervalScorer.java
new file mode 100644
index 0000000..19a712a
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IntervalScorer.java
@@ -0,0 +1,130 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.search.similarities.Similarity;
+
+public class IntervalScorer extends Scorer {
+
+  protected final Similarity.SimScorer simScorer;
+  protected final IntervalIterator intervals;
+  protected final Scorer driver;
+
+  private boolean cached;
+
+  public IntervalScorer(Scorer driver, IntervalIterator intervals, Similarity.SimScorer simScorer) {
+    super(driver.weight);
+    this.driver = driver;
+    this.intervals = intervals;
+    this.simScorer = simScorer;
+  }
+
+  @Override
+  public float score() throws IOException {
+    float freq = 0;
+    do {
+      freq += simScorer.computeSlopFactor(this.intervals.matchDistance());
+    } while (this.intervals.nextInterval());
+    return this.simScorer.score(docID(), freq);
+  }
+
+  @Override
+  public int freq() throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int docID() {
+    return driver.docID();
+  }
+
+  private int doNext(int doc) throws IOException {
+    cached = false;
+    for (;; doc = driver.nextDoc()) {
+      if (doc == NO_MORE_DOCS)
+        return doc;
+      this.intervals.reset(doc);
+      if (this.intervals.nextInterval()) {
+        cached = true;
+        return doc;
+      }
+    }
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    return doNext(driver.nextDoc());
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    return doNext(driver.nextDoc());
+  }
+
+  @Override
+  public long cost() {
+    return driver.cost();
+  }
+
+  @Override
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    return new TwoPhaseIterator() {
+
+      @Override
+      public DocIdSetIterator approximation() {
+        return driver;
+      }
+
+      @Override
+      public boolean matches() throws IOException {
+        intervals.reset(driver.docID());
+        cached = true;
+        return intervals.nextInterval();
+      }
+    };
+  }
+
+  @Override
+  public IntervalIterator intervals() {
+
+    return new IntervalFilter(intervals) {
+
+      boolean positioned = false;
+
+      @Override
+      public void reset(int docId) throws IOException {
+        positioned = docId == driver.docID();
+        if (positioned && !cached)
+          in.reset(docId);
+      }
+
+      @Override
+      public boolean nextInterval() throws IOException {
+        if (!positioned)
+          return false;
+        if (cached) {
+          cached = false;
+          return true;
+        }
+        return in.nextInterval();
+      }
+    };
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IntervalWeight.java b/lucene/core/src/java/org/apache/lucene/search/IntervalWeight.java
new file mode 100644
index 0000000..86a6006
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IntervalWeight.java
@@ -0,0 +1,92 @@
+package org.apache.lucene.search;
+/*
+ *   Copyright (c) 2015 Lemur Consulting Ltd.
+ *
+ *   Licensed under the Apache License, Version 2.0 (the "License");
+ *   you may not use this file except in compliance with the License.
+ *   You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *   Unless required by applicable law or agreed to in writing, software
+ *   distributed under the License is distributed on an "AS IS" BASIS,
+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *   See the License for the specific language governing permissions and
+ *   limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.TreeSet;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.similarities.Similarity;
+
+public abstract class IntervalWeight extends Weight {
+
+  protected final Similarity similarity;
+  protected final Similarity.SimWeight stats;
+  protected final List<Weight> subWeights;
+
+  public IntervalWeight(Query query, List<Weight> subWeights, IndexSearcher searcher) throws IOException {
+    super(query);
+    this.similarity = searcher.getSimilarity();
+    this.stats = getSimWeight(searcher);
+    this.subWeights = subWeights;
+  }
+
+  public IntervalWeight(Query query, Weight subWeight, IndexSearcher searcher) throws IOException {
+    this(query, list(subWeight), searcher);
+  }
+
+  private static List<Weight> list(Weight w) {
+    List<Weight> ws = new LinkedList<>();
+    ws.add(w);
+    return ws;
+  }
+
+  private Similarity.SimWeight getSimWeight(IndexSearcher searcher)  throws IOException {
+    TreeSet<Term> terms = new TreeSet<>();
+    parentQuery.extractTerms(terms);
+    if (terms.size() == 0)
+      return null;
+
+    int i = 0;
+    TermStatistics[] termStats = new TermStatistics[terms.size()];
+    for (Term term : terms) {
+      TermContext state = TermContext.build(searcher.getTopReaderContext(), term);
+      termStats[i] = searcher.termStatistics(term, state);
+      i++;
+    }
+    // In most cases subqueries will all be on the same field, so use term statistics from
+    // the first term in the collected set.  In the cases where something is funky is happening
+    // with cross-field positional queries, phrase-type scoring isn't going to be useful anyway.
+    final String field = terms.first().field();
+    return similarity.computeWeight(parentQuery.getBoost(), searcher.collectionStatistics(field), termStats);
+  }
+
+  @Override
+  public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+    return null;  // nocommit
+  }
+
+  @Override
+  public float getValueForNormalization() throws IOException {
+    return stats == null ? 1.0f : stats.getValueForNormalization();
+  }
+
+  @Override
+  public void normalize(float queryNorm, float topLevelBoost) {
+    if (stats != null) {
+      stats.normalize(queryNorm, topLevelBoost);
+    }
+  }
+
+  protected Similarity.SimScorer getSimScorer(LeafReaderContext context) throws IOException {
+    return similarity.simScorer(stats, context);
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/MatchAllDocsQuery.java b/lucene/core/src/java/org/apache/lucene/search/MatchAllDocsQuery.java
index 4089bc0..f9f9732 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MatchAllDocsQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MatchAllDocsQuery.java
@@ -129,7 +129,7 @@ public class MatchAllDocsQuery extends Query {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) {
     return new MatchAllDocsWeight(searcher);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/MultiIntervalIterator.java b/lucene/core/src/java/org/apache/lucene/search/MultiIntervalIterator.java
new file mode 100644
index 0000000..853d2ec
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/MultiIntervalIterator.java
@@ -0,0 +1,137 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.util.PriorityQueue;
+
+/**
+ * IntervalIterator that will iterate over all intervals in a collection
+ * of subiterators.
+ */
+public class MultiIntervalIterator implements IntervalIterator {
+
+  protected int start;
+  protected int end;
+  protected int matchDistance;
+
+  protected final IteratorQueue iteratorQueue;
+
+  /**
+   * Create a new MultiIntervalIterator
+   * @param iterators the child iterators
+   */
+  public MultiIntervalIterator(IntervalIterator... iterators) {
+    this.iteratorQueue = new IteratorQueue(iterators.length);
+    for (IntervalIterator iterator : iterators) {
+      this.iteratorQueue.add(new ChildIntervalIterator(iterator));
+    }
+  }
+
+  @Override
+  public int matchDistance() {
+    return matchDistance;
+  }
+
+  @Override
+  public boolean nextInterval() throws IOException {
+    ChildIntervalIterator top  = iteratorQueue.top();
+    if (!top.more)
+      return false;
+    start = top.iterator.start();
+    end = top.iterator.end();
+    matchDistance = top.iterator.matchDistance();
+    top.nextInterval();
+    iteratorQueue.updateTop();
+    return true;
+  }
+
+  @Override
+  public void reset(int docId) throws IOException {
+    iteratorQueue.reset(docId);
+    iteratorQueue.updateTop();
+  }
+
+  @Override
+  public int start() {
+    return start;
+  }
+
+  @Override
+  public int end() {
+    return end;
+  }
+
+  @Override
+  public String toString() {
+    return "[" + start + "->" + end + "]";
+  }
+
+  protected static class ChildIntervalIterator {
+
+    final IntervalIterator iterator;
+    boolean more;
+
+    private ChildIntervalIterator(IntervalIterator iterator) {
+      this.iterator = iterator;
+    }
+
+    boolean nextInterval() throws IOException {
+      return more = iterator.nextInterval();
+    }
+
+    @Override
+    public String toString() {
+      if (!more)
+        return "[exhausted]";
+      return iterator.toString();
+    }
+  }
+
+  protected static class IteratorQueue extends PriorityQueue<ChildIntervalIterator> {
+
+    public IteratorQueue(int maxSize) {
+      super(maxSize);
+    }
+
+    @Override
+    protected boolean lessThan(ChildIntervalIterator a, ChildIntervalIterator b) {
+      if (!a.more)
+        return false;
+      if (!b.more)
+        return true;
+      if (a.iterator.start() < b.iterator.start())
+        return true;
+      if (a.iterator.start() > b.iterator.start())
+        return false;
+      return a.iterator.end() < b.iterator.end();
+    }
+
+    void reset(int docId) throws IOException {
+      for (final Object o : getHeapArray()) {
+        if (o == null)
+          continue;
+        final ChildIntervalIterator it = (ChildIntervalIterator) o;
+        it.iterator.reset(docId);
+        it.more = it.nextInterval();
+      }
+    }
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java b/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
index f6b9ff5..7091dcf 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
@@ -296,8 +296,8 @@ public class MultiPhraseQuery extends Query {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    return new MultiPhraseWeight(searcher, needsScores);
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
+    return new MultiPhraseWeight(searcher, needsScores != Weight.Postings.DOCS);
   }
 
   /** Prints a user-readable version of this query. */
diff --git a/lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java b/lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java
index 1c49c55..5569b5e 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MultiTermQueryConstantScoreWrapper.java
@@ -84,7 +84,7 @@ final class MultiTermQueryConstantScoreWrapper<Q extends MultiTermQuery> extends
   public final String getField() { return query.getField(); }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
     return new ConstantScoreWeight(this) {
       @Override
       Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {
diff --git a/lucene/core/src/java/org/apache/lucene/search/NonOverlappingQuery.java b/lucene/core/src/java/org/apache/lucene/search/NonOverlappingQuery.java
new file mode 100644
index 0000000..d1538f7
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/NonOverlappingQuery.java
@@ -0,0 +1,155 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Set;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.util.Bits;
+
+/**
+ * A query that will return matches from one query that are not overlapped
+ * by queries from another.
+ */
+public class NonOverlappingQuery extends Query {
+
+  private final Query main;
+  private final Query subtrahend;
+
+  /**
+   * Create a new NonOverlappingQuery
+   * @param main the main query
+   * @param subtrahend the exclusion query
+   */
+  public NonOverlappingQuery(Query main, Query subtrahend) {
+    this.main = main;
+    this.subtrahend = subtrahend;
+  }
+
+  @Override
+  public String toString(String field) {
+    return "NonOverlapping[" + main.toString(field) + ", --" + subtrahend.toString(field) + "]";
+  }
+
+  @Override
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings postings) throws IOException {
+    return new NonOverlappingWeight(
+        main.createWeight(searcher, Weight.Postings.DOCS_AND_SCORES_AND_POSITIONS),
+        subtrahend.createWeight(searcher, Weight.Postings.DOCS_AND_SCORES_AND_POSITIONS),
+        searcher
+    );
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    Query rmain = main.rewrite(reader);
+    Query rsub = subtrahend.rewrite(reader);
+    if (rmain.equals(main) && rsub.equals(subtrahend))
+      return this;
+    return new NonOverlappingQuery(rmain, rsub);
+  }
+
+  @Override
+  public void extractTerms(Set<Term> terms) {
+    this.main.extractTerms(terms);
+  }
+
+  private class NonOverlappingWeight extends IntervalWeight {
+
+    final Weight subtrahend;
+
+    public NonOverlappingWeight(Weight main, Weight subtrahend, IndexSearcher searcher) throws IOException {
+      super(NonOverlappingQuery.this, main, searcher);
+      this.subtrahend = subtrahend;
+    }
+
+    @Override
+    public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
+      Scorer mainScorer = subWeights.get(0).scorer(context, acceptDocs);
+      if (mainScorer == null)
+        return null;
+
+      final Scorer subScorer = subtrahend.scorer(context, acceptDocs);
+      if (subScorer == null)
+        return mainScorer;
+
+      IntervalIterator it = new BrouwerianIterator(mainScorer.intervals(), new AdvancingIntervalIterator(subScorer));
+      return new IntervalScorer(mainScorer, it, getSimScorer(context));
+    }
+  }
+
+  private static class BrouwerianIterator implements IntervalIterator {
+
+    int doc = -1;
+    boolean moreExclusions = false;
+
+    final IntervalIterator sub;
+    final IntervalIterator main;
+
+    final Interval current = new Interval();
+    final Interval exclusion = new Interval();
+
+    public BrouwerianIterator(IntervalIterator main, IntervalIterator sub) {
+      this.main = main;
+      this.sub = sub;
+    }
+
+    @Override
+    public void reset(int docId) throws IOException {
+      if (doc == docId)
+        return;
+      doc = docId;
+
+      main.reset(docId);
+      sub.reset(docId);
+      exclusion.setMinimum();
+    }
+
+    @Override
+    public int start() {
+      return current.start;
+    }
+
+    @Override
+    public int end() {
+      return current.end;
+    }
+
+    @Override
+    public int matchDistance() {
+      return current.end - current.start - 1;
+    }
+
+    @Override
+    public boolean nextInterval() throws IOException {
+      while (main.nextInterval()) {
+        current.set(main);
+        while (exclusion.start < current.start && exclusion.end < current.end
+            && (moreExclusions = sub.nextInterval())) {
+          exclusion.set(sub);
+        }
+        if (!moreExclusions || !current.overlaps(exclusion))
+          return true;
+      }
+      return false;
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/OrderedNearQuery.java b/lucene/core/src/java/org/apache/lucene/search/OrderedNearQuery.java
new file mode 100644
index 0000000..3a01232
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/OrderedNearQuery.java
@@ -0,0 +1,202 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.util.Bits;
+
+public class OrderedNearQuery extends Query {
+
+  private int slop;
+  private final List<Query> subQueries = new LinkedList<>();
+
+  public OrderedNearQuery(int slop, Query... subQueries) {
+    this(slop, Arrays.asList(subQueries));
+  }
+
+  public OrderedNearQuery(int slop, List<Query> subQueries) {
+    this.slop = slop;
+    this.subQueries.addAll(subQueries);
+  }
+
+  @Override
+  public void extractTerms(Set<Term> terms) {
+    for (Query q : subQueries) {
+      q.extractTerms(terms);
+    }
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder sb = new StringBuilder("OrderedNearQuery/");
+    sb.append(slop);
+    sb.append("[");
+    for (int i = 0; i < subQueries.size() - 1; i++) {
+      sb.append(subQueries.get(i).toString()).append(" ");
+    }
+    sb.append(subQueries.get(subQueries.size() - 1).toString()).append("]");
+    return sb.toString();
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    boolean changed = false;
+    List<Query> rewritten = new ArrayList<>(subQueries.size());
+    for (Query q : subQueries) {
+      Query rwq = q.rewrite(reader);
+      rewritten.add(rwq);
+      if (!q.equals(rwq))
+        changed = true;
+    }
+
+    if (changed)
+      return new OrderedNearQuery(slop, rewritten);
+    return this;
+  }
+
+  @Override
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings postings) throws IOException {
+    List<Weight> subWeights = new ArrayList<>(subQueries.size());
+    for (Query q : subQueries) {
+      subWeights.add(q.createWeight(searcher, Weight.Postings.DOCS_AND_SCORES_AND_POSITIONS));
+    }
+    return new OrderedNearWeight(subWeights, searcher);
+  }
+
+  private class OrderedNearWeight extends IntervalWeight {
+
+    public OrderedNearWeight(List<Weight> subWeights, IndexSearcher searcher) throws IOException {
+      super(OrderedNearQuery.this, subWeights, searcher);
+    }
+
+    @Override
+    public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
+      List<Scorer> subScorers = new ArrayList<>(subQueries.size());
+      List<IntervalIterator> iterators = new ArrayList<>(subQueries.size());
+      for (Weight w : subWeights) {
+        Scorer s = w.scorer(context, acceptDocs);
+        if (s == null)
+          return null;
+        subScorers.add(s);
+        iterators.add(s.intervals());
+      }
+
+      IntervalIterator it = new IntervalFilter.MaxWidthFilter(new OrderedSpanningIntervalIterator(iterators), slop);
+      return new IntervalScorer(new ConjunctionScorer(this, subScorers, subScorers), it, getSimScorer(context));
+    }
+  }
+
+  private static class OrderedSpanningIntervalIterator implements IntervalIterator {
+
+    IntervalIterator[] subs;
+    Interval[] intervals;
+    final Interval current = new Interval();
+
+    int doc = -1;
+
+    public OrderedSpanningIntervalIterator(List<IntervalIterator> subs) {
+      this.subs = subs.toArray(new IntervalIterator[subs.size()]);
+      this.intervals = new Interval[subs.size()];
+      for (int i = 0; i < subs.size(); i++) {
+        this.intervals[i] = new Interval();
+      }
+    }
+
+    @Override
+    public int matchDistance() {
+      return current.end - current.start - 1;
+    }
+
+    @Override
+    public boolean nextInterval() throws IOException {
+
+      current.setMaximum();
+      int b = Integer.MAX_VALUE;
+      int i = 1;
+
+      while (true) {
+        while (true) {
+          if (intervals[i - 1].end >= b)
+            return !current.isMaximum();
+          if (i == intervals.length || intervals[i].start > intervals[i - 1].end)
+            break;
+          do {
+            if (intervals[i].end >= b || !subs[i].nextInterval())
+              return !current.isMaximum();
+            intervals[i].set(subs[i]);
+          }
+          while (intervals[i].start <= intervals[i - 1].end);
+          i++;
+        }
+        current.set(intervals[0].start, intervals[intervals.length - 1].end);
+        b = intervals[intervals.length - 1].start;
+        i = 1;
+        if (!subs[0].nextInterval()) {
+          intervals[0].setMaximum();
+          return !current.isMaximum();
+        }
+        intervals[0].set(subs[0]);
+      }
+    }
+
+    @Override
+    public void reset(int docId) throws IOException {
+
+      if (this.doc == docId)
+        return;
+      this.doc = docId;
+
+      for (IntervalIterator it : subs) {
+        it.reset(docId);
+      }
+
+      if (subs[0].nextInterval()) {
+        intervals[0].set(subs[0]);
+      }
+      else {
+        intervals[0].setMaximum();
+      }
+
+      for (int i = 1; i < intervals.length; i++) {
+        intervals[i].setMinimum();
+      }
+
+      return;
+    }
+
+    @Override
+    public int start() {
+      return current.start;
+    }
+
+    @Override
+    public int end() {
+      return current.end;
+    }
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
index 20d2551..d2fbad8 100644
--- a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
@@ -360,8 +360,8 @@ public class PhraseQuery extends Query {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    return new PhraseWeight(searcher, needsScores);
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
+    return new PhraseWeight(searcher, needsScores != Weight.Postings.DOCS);
   }
 
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/search/Query.java b/lucene/core/src/java/org/apache/lucene/search/Query.java
index 027a39e..5fb1474 100644
--- a/lucene/core/src/java/org/apache/lucene/search/Query.java
+++ b/lucene/core/src/java/org/apache/lucene/search/Query.java
@@ -74,10 +74,9 @@ public abstract class Query implements Cloneable {
    * <p>
    * Only implemented by primitive queries, which re-write to themselves.
    *
-   * @param needsScores   True if document scores ({@link Scorer#score}) or match
-   *                      frequencies ({@link Scorer#freq}) are needed.
+   * @param postings   The type of postings required (see {@link Weight.Postings})
    */
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings postings) throws IOException {
     throw new UnsupportedOperationException("Query " + this + " does not implement createWeight");
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/QueryRescorer.java b/lucene/core/src/java/org/apache/lucene/search/QueryRescorer.java
index b01668d..f915bf7 100644
--- a/lucene/core/src/java/org/apache/lucene/search/QueryRescorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/QueryRescorer.java
@@ -61,7 +61,7 @@ public abstract class QueryRescorer extends Rescorer {
 
     List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();
 
-    Weight weight = searcher.createNormalizedWeight(query, true);
+    Weight weight = searcher.createNormalizedWeight(query, Weight.Postings.DOCS_AND_SCORES);
 
     // Now merge sort docIDs from hits, with reader's leaves:
     int hitUpto = 0;
diff --git a/lucene/core/src/java/org/apache/lucene/search/QueryWrapperFilter.java b/lucene/core/src/java/org/apache/lucene/search/QueryWrapperFilter.java
index 2a19ff0..5c23f35 100644
--- a/lucene/core/src/java/org/apache/lucene/search/QueryWrapperFilter.java
+++ b/lucene/core/src/java/org/apache/lucene/search/QueryWrapperFilter.java
@@ -60,7 +60,7 @@ public class QueryWrapperFilter extends Filter {
   public DocIdSet getDocIdSet(final LeafReaderContext context, final Bits acceptDocs) throws IOException {
     // get a private context that is used to rewrite, createWeight and score eventually
     final LeafReaderContext privateContext = context.reader().getContext();
-    final Weight weight = new IndexSearcher(privateContext).createNormalizedWeight(query, false);
+    final Weight weight = new IndexSearcher(privateContext).createNormalizedWeight(query, Weight.Postings.DOCS);
     return new DocIdSet() {
       @Override
       public DocIdSetIterator iterator() throws IOException {
diff --git a/lucene/core/src/java/org/apache/lucene/search/RangeFilteredQuery.java b/lucene/core/src/java/org/apache/lucene/search/RangeFilteredQuery.java
new file mode 100644
index 0000000..07dad9f
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/RangeFilteredQuery.java
@@ -0,0 +1,79 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+/**
+ * A query that wraps another query, and only matches documents where the wrapped
+ * query has hits within a given position range.
+ */
+public class RangeFilteredQuery extends IntervalFilterQuery {
+
+  /**
+   * Creates a new RangeFilteredQuery
+   * @param innerQuery  the query to wrap
+   * @param start       the beginning of the matching range
+   * @param end         the end of the matching range
+   */
+  public RangeFilteredQuery(Query innerQuery, int start, int end) {
+    super(new RangeFilterScorerFactory(start, end), innerQuery);
+  }
+
+  /**
+   * Creates a new RangeFilteredQuery with a starting range of 0
+   * @param innerQuery  the query to wrap
+   * @param end         the end of the matching range
+   */
+  public RangeFilteredQuery(Query innerQuery, int end) {
+    this(innerQuery, 0, end);
+  }
+
+  private static class RangeFilterScorerFactory implements IntervalFilterFactory {
+
+    private final int start;
+    private final int end;
+
+    public RangeFilterScorerFactory(int start, int end) {
+      this.start = start;
+      this.end = end;
+    }
+
+    @Override
+    public IntervalIterator filter(IntervalIterator in) {
+      return new IntervalFilter(in) {
+        @Override
+        public boolean nextInterval() throws IOException {
+          while (in.nextInterval()) {
+            if (in.start() > end)
+              return false;
+            if (in.start() >= start && in.end() <= end)
+              return true;
+          }
+          return false;
+        }
+      };
+    }
+
+    @Override
+    public String getName() {
+      return "RangeFilter(" + start + "," + end + ")";
+    }
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/ReqExclScorer.java b/lucene/core/src/java/org/apache/lucene/search/ReqExclScorer.java
index 3b83bec..14844be 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ReqExclScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ReqExclScorer.java
@@ -156,4 +156,9 @@ class ReqExclScorer extends Scorer {
 
     };
   }
+
+  @Override
+  public IntervalIterator intervals() {
+    return reqScorer.intervals();
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer.java b/lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer.java
index a6507fd..5d4f304 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ReqOptSumScorer.java
@@ -106,6 +106,11 @@ class ReqOptSumScorer extends Scorer {
   }
 
   @Override
+  public IntervalIterator intervals() {
+    return new MultiIntervalIterator(reqScorer.intervals(), new AdvancingIntervalIterator(optScorer));
+  }
+
+  @Override
   public long cost() {
     return reqScorer.cost();
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/Scorer.java b/lucene/core/src/java/org/apache/lucene/search/Scorer.java
index d5c90f5..958a7b7 100644
--- a/lucene/core/src/java/org/apache/lucene/search/Scorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/Scorer.java
@@ -74,7 +74,12 @@ public abstract class Scorer extends DocIdSetIterator {
   public Collection<ChildScorer> getChildren() {
     return Collections.emptyList();
   }
-  
+
+  /** Returns an IntervalIterator for this Scorer */
+  public IntervalIterator intervals() {
+    throw new IllegalArgumentException(this.getClass().getName() + " does not support IntervalIterators");
+  }
+
   /** A child Scorer and its relationship to its parent.
    * the meaning of the relationship depends upon the parent query. 
    * @lucene.experimental */
diff --git a/lucene/core/src/java/org/apache/lucene/search/TermQuery.java b/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
index 46b96ef..79b259e 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
@@ -47,12 +47,12 @@ public class TermQuery extends Query {
     private final Similarity similarity;
     private final Similarity.SimWeight stats;
     private final TermContext termStates;
-    private final boolean needsScores;
+    private final Weight.Postings postings;
 
-    public TermWeight(IndexSearcher searcher, boolean needsScores, TermContext termStates)
+    public TermWeight(IndexSearcher searcher, Weight.Postings postings, TermContext termStates)
         throws IOException {
       super(TermQuery.this);
-      this.needsScores = needsScores;
+      this.postings = postings;
       assert termStates != null : "TermContext must not be null";
       this.termStates = termStates;
       this.similarity = searcher.getSimilarity();
@@ -83,7 +83,18 @@ public class TermQuery extends Query {
       if (termsEnum == null) {
         return null;
       }
-      PostingsEnum docs = termsEnum.postings(acceptDocs, null, needsScores ? PostingsEnum.FREQS : PostingsEnum.NONE);
+      int flags = PostingsEnum.NONE;
+      if (postings == Postings.DOCS_AND_SCORES_AND_POSITIONS) {
+        if (!context.reader().terms(term.field()).hasPositions()) {
+          throw new IllegalArgumentException("Asked for positions for field " + term.field() + " that has no positions indexed");
+        }
+        flags = PostingsEnum.POSITIONS;
+      }
+      else if (postings == Postings.DOCS_AND_SCORES) {
+        flags = PostingsEnum.FREQS;
+      }
+
+      PostingsEnum docs = termsEnum.postings(acceptDocs, null, flags);
       assert docs != null;
       return new TermScorer(this, docs, similarity.simScorer(stats, context));
     }
@@ -168,7 +179,7 @@ public class TermQuery extends Query {
   }
   
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings postings) throws IOException {
     final IndexReaderContext context = searcher.getTopReaderContext();
     final TermContext termState;
     if (perReaderTermState == null
@@ -184,7 +195,7 @@ public class TermQuery extends Query {
     // we must not ignore the given docFreq - if set use the given value (lie)
     if (docFreq != -1) termState.setDocFreq(docFreq);
     
-    return new TermWeight(searcher, needsScores, termState);
+    return new TermWeight(searcher, postings, termState);
   }
   
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/TermScorer.java b/lucene/core/src/java/org/apache/lucene/search/TermScorer.java
index 94951dc..525e220 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TermScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TermScorer.java
@@ -93,4 +93,63 @@ final class TermScorer extends Scorer {
   /** Returns a string representation of this <code>TermScorer</code>. */
   @Override
   public String toString() { return "scorer(" + weight + ")[" + super.toString() + "]"; }
+
+  @Override
+  public IntervalIterator intervals() {
+    return new TermIntervalIterator();
+  }
+
+  public class TermIntervalIterator implements IntervalIterator {
+
+    int upto = -1;
+    int pos = -1;
+    State state = State.EXHAUSTED;
+
+    @Override
+    public int matchDistance() {
+      return 1;
+    }
+
+    @Override
+    public boolean nextInterval() throws IOException {
+      assert upto != -1 : "nextInterval() called before reset";
+      if (upto <= 0) {
+        state = State.EXHAUSTED;
+        return false;
+      }
+      state = State.ITERATING;
+      upto--;
+      pos = postingsEnum.nextPosition();
+      return true;
+    }
+
+    @Override
+    public void reset(int docId) throws IOException {
+      state = State.RESET;
+      if (postingsEnum.docID() != docId) {
+        upto = 0;
+      }
+      else {
+        upto = postingsEnum.freq();
+      }
+    }
+
+    @Override
+    public int start() {
+      return pos;
+    }
+
+    @Override
+    public int end() {
+      return pos;
+    }
+
+    @Override
+    public String toString() {
+      if (state == State.ITERATING)
+        return "[" + pos + "->" + pos + "]";
+      else
+        return state.toString();
+    }
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/Weight.java b/lucene/core/src/java/org/apache/lucene/search/Weight.java
index 8ba2403..0291dcd 100644
--- a/lucene/core/src/java/org/apache/lucene/search/Weight.java
+++ b/lucene/core/src/java/org/apache/lucene/search/Weight.java
@@ -41,7 +41,7 @@ import org.apache.lucene.util.Bits;
  * A <code>Weight</code> is used in the following way:
  * <ol>
  * <li>A <code>Weight</code> is constructed by a top-level query, given a
- * <code>IndexSearcher</code> ({@link Query#createWeight(IndexSearcher, boolean)}).
+ * <code>IndexSearcher</code> ({@link Query#createWeight(IndexSearcher, org.apache.lucene.search.Weight.Postings)}).
  * <li>The {@link #getValueForNormalization()} method is called on the
  * <code>Weight</code> to compute the query normalization factor
  * {@link Similarity#queryNorm(float)} of the query clauses contained in the
@@ -56,6 +56,8 @@ import org.apache.lucene.util.Bits;
  */
 public abstract class Weight {
 
+  public enum Postings { DOCS, DOCS_AND_SCORES, DOCS_AND_SCORES_AND_POSITIONS }
+
   protected final Query parentQuery;
 
   /** Sole constructor, typically invoked by sub-classes.
diff --git a/lucene/core/src/java/org/apache/lucene/search/package-info.java b/lucene/core/src/java/org/apache/lucene/search/package-info.java
index 3c36c4c..66b8866 100644
--- a/lucene/core/src/java/org/apache/lucene/search/package-info.java
+++ b/lucene/core/src/java/org/apache/lucene/search/package-info.java
@@ -357,7 +357,7 @@
  *         {@link org.apache.lucene.search.Query Query} class has several methods that are important for
  *         derived classes:
  *         <ol>
- *             <li>{@link org.apache.lucene.search.Query#createWeight(IndexSearcher,boolean) createWeight(IndexSearcher searcher,boolean)} &mdash; A
+ *             <li>{@link org.apache.lucene.search.Query#createWeight(IndexSearcher,org.apache.lucene.search.Weight.Postings) createWeight(IndexSearcher searcher,boolean)} &mdash; A
  *                 {@link org.apache.lucene.search.Weight Weight} is the internal representation of the
  *                 Query, so each Query implementation must
  *                 provide an implementation of Weight. See the subsection on <a
@@ -366,7 +366,7 @@
  *             <li>{@link org.apache.lucene.search.Query#rewrite(org.apache.lucene.index.IndexReader) rewrite(IndexReader reader)} &mdash; Rewrites queries into primitive queries. Primitive queries are:
  *                 {@link org.apache.lucene.search.TermQuery TermQuery},
  *                 {@link org.apache.lucene.search.BooleanQuery BooleanQuery}, <span
- *                     >and other queries that implement {@link org.apache.lucene.search.Query#createWeight(IndexSearcher,boolean) createWeight(IndexSearcher searcher,boolean)}</span></li>
+ *                     >and other queries that implement {@link org.apache.lucene.search.Query#createWeight(IndexSearcher,org.apache.lucene.search.Weight.Postings) createWeight(IndexSearcher searcher,boolean)}</span></li>
  *         </ol>
  * <a name="weightClass"></a>
  * <h3>The Weight Interface</h3>
@@ -508,7 +508,7 @@
  * <p>Assuming we are not sorting (since sorting doesn't affect the raw Lucene score),
  *    we call one of the search methods of the IndexSearcher, passing in the
  *    {@link org.apache.lucene.search.Weight Weight} object created by
- *    {@link org.apache.lucene.search.IndexSearcher#createNormalizedWeight(org.apache.lucene.search.Query,boolean)
+ *    {@link org.apache.lucene.search.IndexSearcher#createNormalizedWeight(org.apache.lucene.search.Query,org.apache.lucene.search.Weight.Postings)
  *     IndexSearcher.createNormalizedWeight(Query,boolean)}, 
  *    {@link org.apache.lucene.search.Filter Filter} and the number of results we want.
  *    This method returns a {@link org.apache.lucene.search.TopDocs TopDocs} object,
diff --git a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java
index e46bb45..97525ec 100644
--- a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java
@@ -71,7 +71,7 @@ public class PayloadNearQuery extends SpanNearQuery {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
     return new PayloadNearSpanWeight(this, searcher);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java
index 463a6a0..5533518 100644
--- a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java
@@ -67,7 +67,7 @@ public class PayloadTermQuery extends SpanTermQuery {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
     return new PayloadTermWeight(this, searcher);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
index 9b740f6..802ac97 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
@@ -106,7 +106,7 @@ public class FieldMaskingSpanQuery extends SpanQuery {
   }  
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
     return maskedQuery.createWeight(searcher, needsScores);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java
index 00bed75..45701d9 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java
@@ -42,7 +42,7 @@ public abstract class SpanQuery extends Query {
   public abstract String getField();
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
     return new SpanWeight(this, searcher);
   }
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/IntervalTestBase.java b/lucene/core/src/test/org/apache/lucene/search/IntervalTestBase.java
new file mode 100644
index 0000000..0b30d10
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/IntervalTestBase.java
@@ -0,0 +1,374 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.FieldType;
+import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.IndexOptions;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.SlowCompositeReaderWrapper;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+public abstract class IntervalTestBase extends LuceneTestCase {
+
+  protected Directory directory;
+  protected IndexSearcher searcher;
+  protected IndexReader reader;
+
+  protected static FieldType fieldWithPositions = new FieldType(TextField.TYPE_STORED);
+  static {
+    fieldWithPositions.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
+  }
+
+  protected abstract void addDocs(IndexWriter writer) throws IOException;
+
+  @Before
+  public void setUp() throws Exception {
+
+    super.setUp();
+
+    directory = newDirectory();
+
+    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))
+        .setMergePolicy(newLogMergePolicy())
+        .setSimilarity(new DefaultSimilarity());
+
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory, iwc);
+
+    addDocs(writer.w);
+
+    reader = SlowCompositeReaderWrapper.wrap(writer.getReader());
+    writer.close();
+
+    searcher = newSearcher(reader);
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    reader.close();
+    directory.close();
+    super.tearDown();
+  }
+
+  protected void checkNoResults(Query query) throws IOException {
+
+    Weight weight = searcher.createNormalizedWeight(query, Weight.Postings.DOCS_AND_SCORES_AND_POSITIONS);
+    LeafReaderContext ctx = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).getContext();
+    Scorer scorer = weight.scorer(ctx, null);
+
+    if (scorer != null)
+      assertEquals("Got an unexpected result: " + scorer.docID(), DocIdSetIterator.NO_MORE_DOCS, scorer.nextDoc());
+
+  }
+
+  protected void checkPositions(Query query, int[][] expectedPositions) throws IOException {
+
+    Weight weight = searcher.createNormalizedWeight(query, Weight.Postings.DOCS_AND_SCORES_AND_POSITIONS);
+    LeafReaderContext ctx = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).getContext();
+    Scorer scorer = weight.scorer(ctx, null);
+
+    int upto = 0;
+    int posUpto = 0;
+
+    IntervalIterator intervals = scorer.intervals();
+    while (scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
+
+      if (upto >= expectedPositions.length)
+        fail("Got unexpected document: " + scorer.docID());
+
+      assertEquals("Got wrong document from scorer", expectedPositions[upto][0], scorer.docID());
+      intervals.reset(scorer.docID());
+
+      int expectedPositionCount = expectedPositions[upto].length - 1;
+      while (intervals.nextInterval()) {
+        if (posUpto >= expectedPositionCount)
+          fail("Unexpected position on doc " + scorer.docID() + ": " + intervals.start() + "->" + intervals.end());
+        assertEquals("Got wrong start position on doc " + scorer.docID(), expectedPositions[upto][posUpto + 1], intervals.start());
+        assertEquals("Got wrong end position on doc " + scorer.docID(), expectedPositions[upto][posUpto + 2], intervals.end());
+        posUpto += 2;
+      }
+
+      if (posUpto < expectedPositionCount)
+        fail("Missing expected position on doc " + scorer.docID() + ": " + expectedPositions[upto][posUpto + 1]);
+
+      upto++;
+      posUpto = 0;
+
+    }
+
+    if (upto < expectedPositions.length - 1)
+      fail("Missing expected document: " + expectedPositions[upto + 1][0]);
+
+    upto = 0;
+    Scorer scorer2 = weight.scorer(ctx, null);
+    while (scorer2.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
+      if (upto >= expectedPositions.length)
+        fail("Got unexpected document when iterating: " + scorer.docID());
+
+      assertEquals("Got wrong document from scorer when iterating", expectedPositions[upto][0], scorer2.docID());
+      upto++;
+    }
+
+    if (upto < expectedPositions.length - 1)
+      fail("Missing expected document when iterating: " + expectedPositions[upto + 1][0]);
+
+
+  }
+
+  public static class TestQueryIntervals extends IntervalTestBase {
+
+    static final String FIELD = "f";
+
+    @Override
+    protected void addDocs(IndexWriter writer) throws IOException {
+      for (String value : docs) {
+        Document doc = new Document();
+        doc.add(new Field(FIELD, value, fieldWithPositions));
+        writer.addDocument(doc);
+      }
+    }
+
+    static final String[] docs = new String[]{
+        "a b c d",
+        "e f g h",
+        "a b f b"
+    };
+
+    @Test
+    public void testNestedQueries() throws IOException {
+      BooleanQuery bq = new BooleanQuery();
+      bq.add(new TermQuery(new Term(FIELD, "a")), BooleanClause.Occur.MUST);
+      bq.add(new TermQuery(new Term(FIELD, "f")), BooleanClause.Occur.MUST_NOT);
+
+      BooleanQuery parent = new BooleanQuery();
+      parent.add(new TermQuery(new Term(FIELD, "b")), BooleanClause.Occur.SHOULD);
+      parent.add(bq, BooleanClause.Occur.SHOULD);
+
+      checkPositions(parent, new int[][]{
+          { 0, 0, 0, 1, 1 },
+          { 2, 1, 1, 3, 3 }
+      });
+    }
+
+    @Test
+    public void testExclusion() throws IOException {
+
+      BooleanQuery bq = new BooleanQuery();
+      bq.add(new TermQuery(new Term(FIELD, "a")), BooleanClause.Occur.MUST);
+      bq.add(new TermQuery(new Term(FIELD, "f")), BooleanClause.Occur.SHOULD);
+      bq.add(new TermQuery(new Term(FIELD, "d")), BooleanClause.Occur.MUST_NOT);
+      checkPositions(bq, new int[][]{
+          { 2, 0, 0, 2, 2 }
+      });
+
+      BooleanQuery bq2 = new BooleanQuery();
+      bq2.add(new TermQuery(new Term(FIELD, "a")), BooleanClause.Occur.SHOULD);
+      bq2.add(new TermQuery(new Term(FIELD, "f")), BooleanClause.Occur.SHOULD);
+      bq2.add(new TermQuery(new Term(FIELD, "d")), BooleanClause.Occur.MUST_NOT);
+      checkPositions(bq2, new int[][]{
+          { 1, 1, 1 },
+          { 2, 0, 0, 2, 2 }
+      });
+    }
+
+    @Test
+    public void testReqOptQueries() throws IOException {
+
+      BooleanQuery bq1 = new BooleanQuery();
+      bq1.add(new TermQuery(new Term(FIELD, "a")), BooleanClause.Occur.MUST);
+      bq1.add(new TermQuery(new Term(FIELD, "f")), BooleanClause.Occur.SHOULD);
+      checkPositions(bq1, new int[][]{
+          { 0, 0, 0 },
+          { 2, 0, 0, 2, 2 }
+      });
+
+    }
+
+    @Test
+    public void testSimpleTermQueries() throws IOException {
+
+      checkPositions(new TermQuery(new Term(FIELD, "g")), new int[][]{
+          { 1, 2, 2 }
+      });
+
+      checkPositions(new TermQuery(new Term(FIELD, "b")), new int[][]{
+          { 0, 1, 1 },
+          { 2, 1, 1, 3, 3 }
+      });
+
+    }
+
+    @Test
+    public void testDisjunctionQuery() throws IOException {
+
+      BooleanQuery bq = new BooleanQuery();
+      bq.add(new TermQuery(new Term(FIELD, "f")), BooleanClause.Occur.SHOULD);
+      bq.add(new TermQuery(new Term(FIELD, "a")), BooleanClause.Occur.SHOULD);
+      checkPositions(bq, new int[][]{
+          { 0, 0, 0 },
+          { 1, 1, 1 },
+          { 2, 0, 0, 2, 2 }
+      });
+
+      BooleanQuery bq2 = new BooleanQuery();
+      bq2.add(new TermQuery(new Term(FIELD, "f")), BooleanClause.Occur.SHOULD);
+      bq2.add(new TermQuery(new Term(FIELD, "q")), BooleanClause.Occur.SHOULD);
+      checkPositions(bq2, new int[][]{
+          { 1, 1, 1 },
+          { 2, 2, 2 }
+      });
+
+
+    }
+
+    @Test
+    public void testConjunctionQuery() throws IOException {
+
+      BooleanQuery bq1 = new BooleanQuery();
+      bq1.add(new TermQuery(new Term(FIELD, "a")), BooleanClause.Occur.MUST);
+      bq1.add(new TermQuery(new Term(FIELD, "b")), BooleanClause.Occur.MUST);
+      checkPositions(bq1, new int[][]{
+          { 0, 0, 0, 1, 1 },
+          { 2, 0, 0, 1, 1, 3, 3 }
+      });
+
+    }
+
+  }
+
+  public static class TestIntervalQueries extends IntervalTestBase {
+
+    static final String FIELD = "f";
+
+    @Override
+    protected void addDocs(IndexWriter writer) throws IOException {
+      for (String value : docs) {
+        Document doc = new Document();
+        doc.add(new Field(FIELD, value, fieldWithPositions));
+        writer.addDocument(doc);
+      }
+    }
+
+    static final String[] docs = new String[]{
+        "a b c d",
+        "a b c e d",
+        "e f g h",
+        "a a d f b d"
+    };
+
+    @Test
+    public void testOrderedNearQuery() throws IOException {
+
+      Query q = new OrderedNearQuery(2, new TermQuery(new Term(FIELD, "a")), new TermQuery(new Term(FIELD, "d")));
+      checkPositions(q, new int[][]{
+          { 0, 0, 3 },
+          { 3, 1, 2 }
+      });
+
+      BooleanQuery bq = new BooleanQuery();
+      bq.add(q, BooleanClause.Occur.SHOULD);
+      bq.add(new TermQuery(new Term(FIELD, "f")), BooleanClause.Occur.MUST);
+      checkPositions(bq, new int[][]{
+          { 2, 1, 1 },
+          { 3, 1, 2, 3, 3 }
+      });
+
+      BooleanQuery bq2 = new BooleanQuery();
+      bq2.add(new TermQuery(new Term(FIELD, "a")), BooleanClause.Occur.SHOULD);
+      bq2.add(new TermQuery(new Term(FIELD, "b")), BooleanClause.Occur.SHOULD);
+      Query q2 = new OrderedNearQuery(2, bq2, new TermQuery(new Term(FIELD, "d")));
+      checkPositions(q2, new int[][]{
+          { 0, 1, 3 },
+          { 1, 1, 4 },
+          { 3, 1, 2, 4, 5 }
+      });
+
+    }
+
+    @Test
+    public void testNestedOrderedNearQuery() throws IOException {
+
+      Query q1 = new OrderedNearQuery(2, new TermQuery(new Term(FIELD, "a")), new TermQuery(new Term(FIELD, "b")));
+      Query q2 = new OrderedNearQuery(3, q1, new TermQuery(new Term(FIELD, "d")));
+      checkPositions(q2, new int[][]{
+          { 0, 0, 3 },
+          { 1, 0, 4 },
+          { 3, 1, 5 }
+      });
+
+    }
+
+  }
+
+  public static class TestNonOverlappingQuery extends IntervalTestBase {
+
+    static final String FIELD = "f";
+
+    @Override
+    protected void addDocs(IndexWriter writer) throws IOException {
+      for (String value : docs) {
+        Document doc = new Document();
+        doc.add(new Field(FIELD, value, fieldWithPositions));
+        writer.addDocument(doc);
+      }
+    }
+
+    static final String[] docs = new String[]{
+        "a b c d",
+        "a b c e d",
+        "e f g h",
+        "a e d a b d"
+    };
+
+    @Test
+    public void testNonOverlapping() throws IOException {
+      Query main = new OrderedNearQuery(5, new TermQuery(new Term(FIELD, "a")), new TermQuery(new Term(FIELD, "d")));
+      Query subtrahend = new TermQuery(new Term(FIELD, "e"));
+      checkPositions(new NonOverlappingQuery(main, subtrahend), new int[][]{
+          { 0, 0, 3 },
+          { 3, 3, 5 }
+      });
+
+      Query emptyMain = new TermQuery(new Term(FIELD, "not here"));
+      checkNoResults(new NonOverlappingQuery(emptyMain, subtrahend));
+
+      checkPositions(new NonOverlappingQuery(main, emptyMain), new int[][]{
+          { 0, 0, 3 },
+          { 1, 0, 4 },
+          { 3, 0, 2, 3, 5 }
+      });
+    }
+
+  }
+
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord.java b/lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord.java
index 593a970..1bfea25 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBooleanCoord.java
@@ -706,7 +706,7 @@ public class TestBooleanCoord extends LuceneTestCase {
   /** asserts score for our single matching good doc */
   private void assertScore(final float expected, Query query) throws Exception {
     // test in-order
-    Weight weight = searcher.createNormalizedWeight(query, true);
+    Weight weight = searcher.createNormalizedWeight(query, Weight.Postings.DOCS_AND_SCORES);
     Scorer scorer = weight.scorer(reader.leaves().get(0), null);
     assertTrue(scorer.docID() == -1 || scorer.docID() == DocIdSetIterator.NO_MORE_DOCS);
     assertEquals(0, scorer.nextDoc());
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBooleanOr.java b/lucene/core/src/test/org/apache/lucene/search/TestBooleanOr.java
index d43c6f1..e58590c 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestBooleanOr.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBooleanOr.java
@@ -185,7 +185,7 @@ public class TestBooleanOr extends LuceneTestCase {
     bq.add(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD);
     bq.add(new TermQuery(new Term("field", "a")), BooleanClause.Occur.SHOULD);
 
-    Weight w = s.createNormalizedWeight(bq, true);
+    Weight w = s.createNormalizedWeight(bq, Weight.Postings.DOCS_AND_SCORES);
 
     assertEquals(1, s.getIndexReader().leaves().size());
     BulkScorer scorer = w.bulkScorer(s.getIndexReader().leaves().get(0), null);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java
index ec99739..d3d86ec 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java
@@ -237,7 +237,7 @@ public class TestBooleanQuery extends LuceneTestCase {
         q.add(new BooleanClause(new TermQuery(new Term("field", term)), BooleanClause.Occur.SHOULD));
       }
 
-      Weight weight = s.createNormalizedWeight(q, true);
+      Weight weight = s.createNormalizedWeight(q, Weight.Postings.DOCS_AND_SCORES);
 
       Scorer scorer = weight.scorer(s.leafContexts.get(0), null);
 
@@ -255,7 +255,7 @@ public class TestBooleanQuery extends LuceneTestCase {
       // verify exact match:
       for(int iter2=0;iter2<10;iter2++) {
 
-        weight = s.createNormalizedWeight(q, true);
+        weight = s.createNormalizedWeight(q, Weight.Postings.DOCS_AND_SCORES);
         scorer = weight.scorer(s.leafContexts.get(0), null);
 
         if (VERBOSE) {
@@ -582,7 +582,7 @@ public class TestBooleanQuery extends LuceneTestCase {
     BooleanQuery query2 = new BooleanQuery();
     query2.add(new TermQuery(new Term("field", "a")), Occur.FILTER);
     query2.add(new TermQuery(new Term("field", "b")), Occur.SHOULD);
-    final Weight weight = searcher.createNormalizedWeight(query2, true);
+    final Weight weight = searcher.createNormalizedWeight(query2, Weight.Postings.DOCS_AND_SCORES);
     final Scorer scorer = weight.scorer(reader.leaves().get(0), null);
     assertTrue(scorer.getClass().getName(), scorer instanceof BooleanTopLevelScorers.BoostedScorer);
     assertEquals(0, ((BooleanTopLevelScorers.BoostedScorer) scorer).boost, 0f);
@@ -613,7 +613,8 @@ public class TestBooleanQuery extends LuceneTestCase {
     q.add(pq, Occur.MUST);
     q.add(new TermQuery(new Term("field", "c")), Occur.FILTER);
 
-    final Weight weight = searcher.createNormalizedWeight(q, random().nextBoolean());
+    final Weight weight
+        = searcher.createNormalizedWeight(q, random().nextBoolean() ? Weight.Postings.DOCS_AND_SCORES : Weight.Postings.DOCS);
     final Scorer scorer = weight.scorer(searcher.getIndexReader().leaves().get(0), null);
     assertTrue(scorer instanceof ConjunctionScorer);
     assertNotNull(scorer.asTwoPhaseIterator());
@@ -644,7 +645,8 @@ public class TestBooleanQuery extends LuceneTestCase {
     q.add(pq, Occur.SHOULD);
     q.add(new TermQuery(new Term("field", "c")), Occur.SHOULD);
 
-    final Weight weight = searcher.createNormalizedWeight(q, random().nextBoolean());
+    final Weight weight
+        = searcher.createNormalizedWeight(q, random().nextBoolean() ? Weight.Postings.DOCS_AND_SCORES : Weight.Postings.DOCS);
     final Scorer scorer = weight.scorer(reader.leaves().get(0), null);
     assertTrue(scorer instanceof DisjunctionScorer);
     assertNotNull(scorer.asTwoPhaseIterator());
@@ -675,7 +677,8 @@ public class TestBooleanQuery extends LuceneTestCase {
     q.add(pq, Occur.SHOULD);
     q.add(new TermQuery(new Term("field", "d")), Occur.SHOULD);
 
-    final Weight weight = searcher.createNormalizedWeight(q, random().nextBoolean());
+    final Weight weight
+        = searcher.createNormalizedWeight(q, random().nextBoolean() ? Weight.Postings.DOCS_AND_SCORES : Weight.Postings.DOCS);
     final Scorer scorer = weight.scorer(searcher.getIndexReader().leaves().get(0), null);
     assertTrue(scorer instanceof BoostedScorer || scorer instanceof ExactPhraseScorer);
     assertNotNull(scorer.asTwoPhaseIterator());
@@ -706,7 +709,8 @@ public class TestBooleanQuery extends LuceneTestCase {
     q.add(pq, Occur.SHOULD);
     q.add(new TermQuery(new Term("field", "c")), Occur.MUST_NOT);
 
-    final Weight weight = searcher.createNormalizedWeight(q, random().nextBoolean());
+    final Weight weight
+        = searcher.createNormalizedWeight(q, random().nextBoolean() ? Weight.Postings.DOCS_AND_SCORES : Weight.Postings.DOCS);
     final Scorer scorer = weight.scorer(reader.leaves().get(0), null);
     assertTrue(scorer instanceof ReqExclScorer);
     assertNotNull(scorer.asTwoPhaseIterator());
@@ -737,7 +741,7 @@ public class TestBooleanQuery extends LuceneTestCase {
     q.add(pq, Occur.MUST);
     q.add(new TermQuery(new Term("field", "c")), Occur.SHOULD);
 
-    final Weight weight = searcher.createNormalizedWeight(q, true);
+    final Weight weight = searcher.createNormalizedWeight(q, Weight.Postings.DOCS_AND_SCORES);
     final Scorer scorer = weight.scorer(reader.leaves().get(0), null);
     assertTrue(scorer instanceof ReqOptSumScorer);
     assertNotNull(scorer.asTwoPhaseIterator());
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java b/lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java
index 5ee8f35..4a4e195 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java
@@ -283,7 +283,7 @@ public class TestBooleanQueryVisitSubscorers extends LuceneTestCase {
   static class BooleanQuery2 extends BooleanQuery {
 
     @Override
-    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
       return new BooleanWeight(this, searcher, needsScores, false) {
         @Override
         public BulkScorer bulkScorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer.java b/lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer.java
index 664cd3b..6459513 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBooleanScorer.java
@@ -70,7 +70,7 @@ public class TestBooleanScorer extends LuceneTestCase {
     }
 
     @Override
-    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
       return new Weight(CrazyMustUseBulkScorerQuery.this) {
         @Override
         public Explanation explain(LeafReaderContext context, int doc) {
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestCachingWrapperQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestCachingWrapperQuery.java
index 15bf518..bb71bf8 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestCachingWrapperQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestCachingWrapperQuery.java
@@ -139,15 +139,15 @@ public class TestCachingWrapperQuery extends LuceneTestCase {
     CachingWrapperQuery cacher = new CachingWrapperQuery(filter, QueryCachingPolicy.ALWAYS_CACHE);
 
     // first time, nested filter is called
-    cacher.createWeight(searcher, false).scorer(context, context.reader().getLiveDocs());
+    cacher.createWeight(searcher, Weight.Postings.DOCS).scorer(context, context.reader().getLiveDocs());
     assertTrue("first time", filter.wasCalled());
 
     // make sure no exception if cache is holding the wrong docIdSet
-    cacher.createWeight(searcher, false).scorer(context, context.reader().getLiveDocs());
+    cacher.createWeight(searcher, Weight.Postings.DOCS).scorer(context, context.reader().getLiveDocs());
 
     // second time, nested filter should not be called
     filter.clear();
-    cacher.createWeight(searcher, false).scorer(context, context.reader().getLiveDocs());
+    cacher.createWeight(searcher, Weight.Postings.DOCS).scorer(context, context.reader().getLiveDocs());
     assertFalse("second time", filter.wasCalled());
 
     reader.close();
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java
index c960782..4a0ece2 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestConstantScoreQuery.java
@@ -223,7 +223,7 @@ public class TestConstantScoreQuery extends LuceneTestCase {
 
     ConstantScoreQuery q = new ConstantScoreQuery(pq);
 
-    final Weight weight = searcher.createNormalizedWeight(q, true);
+    final Weight weight = searcher.createNormalizedWeight(q, Weight.Postings.DOCS_AND_SCORES);
     final Scorer scorer = weight.scorer(searcher.getIndexReader().leaves().get(0), null);
     assertNotNull(scorer.asTwoPhaseIterator());
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java
index 072d14a..2b2f84f 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java
@@ -178,7 +178,7 @@ public class TestDisjunctionMaxQuery extends LuceneTestCase {
     
     QueryUtils.check(random(), dq, s);
     assertTrue(s.getTopReaderContext() instanceof LeafReaderContext);
-    final Weight dw = s.createNormalizedWeight(dq, true);
+    final Weight dw = s.createNormalizedWeight(dq, Weight.Postings.DOCS_AND_SCORES);
     LeafReaderContext context = (LeafReaderContext)s.getTopReaderContext();
     final Scorer ds = dw.scorer(context, context.reader().getLiveDocs());
     final boolean skipOk = ds.advance(3) != DocIdSetIterator.NO_MORE_DOCS;
@@ -194,7 +194,7 @@ public class TestDisjunctionMaxQuery extends LuceneTestCase {
     dq.add(tq("dek", "DOES_NOT_EXIST"));
     assertTrue(s.getTopReaderContext() instanceof LeafReaderContext);
     QueryUtils.check(random(), dq, s);
-    final Weight dw = s.createNormalizedWeight(dq, true);
+    final Weight dw = s.createNormalizedWeight(dq, Weight.Postings.DOCS_AND_SCORES);
     LeafReaderContext context = (LeafReaderContext)s.getTopReaderContext();
     final Scorer ds = dw.scorer(context, context.reader().getLiveDocs());
     assertTrue("firsttime skipTo found no match",
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestDocValuesRangeQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestDocValuesRangeQuery.java
index fc0ed49..bf2cbf7 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestDocValuesRangeQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestDocValuesRangeQuery.java
@@ -267,12 +267,12 @@ public class TestDocValuesRangeQuery extends LuceneTestCase {
     iw.close();
 
     Query q1 = DocValuesRangeQuery.newLongRange("dv1", 0L, 100L, random().nextBoolean(), random().nextBoolean());
-    Weight w = searcher.createNormalizedWeight(q1, true);
+    Weight w = searcher.createNormalizedWeight(q1, Weight.Postings.DOCS_AND_SCORES);
     Scorer s = w.scorer(ctx, null);
     assertNotNull(s.asTwoPhaseIterator());
 
     Query q2 = DocValuesRangeQuery.newBytesRefRange("dv2", toSortableBytes(0L), toSortableBytes(100L), random().nextBoolean(), random().nextBoolean());
-    w = searcher.createNormalizedWeight(q2, true);
+    w = searcher.createNormalizedWeight(q2, Weight.Postings.DOCS_AND_SCORES);
     s = w.scorer(ctx, null);
     assertNotNull(s.asTwoPhaseIterator());
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestIntervalQueryExceptions.java b/lucene/core/src/test/org/apache/lucene/search/TestIntervalQueryExceptions.java
new file mode 100644
index 0000000..4e39502
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestIntervalQueryExceptions.java
@@ -0,0 +1,108 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.FieldType;
+import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.IndexOptions;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.SlowCompositeReaderWrapper;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.ExpectedException;
+
+public class TestIntervalQueryExceptions extends LuceneTestCase {
+
+  @Rule
+  public ExpectedException exception = ExpectedException.none();
+
+  @Test
+  public void testIntervalQueryWithNoPositionsIndexedThrowsException() throws IOException {
+
+    try (Directory directory = newDirectory()) {
+
+      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))
+          .setMergePolicy(newLogMergePolicy())
+          .setSimilarity(new DefaultSimilarity());
+
+      RandomIndexWriter writer = new RandomIndexWriter(random(), directory, iwc);
+
+      FieldType ft = new FieldType(TextField.TYPE_STORED);
+      ft.setIndexOptions(IndexOptions.DOCS_AND_FREQS);
+
+      Document doc = new Document();
+      doc.add(newField("field", "test", ft));
+      writer.addDocument(doc);
+
+      IndexReader indexReader = SlowCompositeReaderWrapper.wrap(writer.getReader());
+      writer.close();
+      IndexSearcher indexSearcher = newSearcher(indexReader);
+
+      Query q = new RangeFilteredQuery(new TermQuery(new Term("field", "noterm")), 5);
+      // non-existent terms just return null
+      assertEquals(0, indexSearcher.search(q, 10).totalHits);
+
+      // existing terms will throw an exception if positions are not indexed
+      exception.expect(IllegalArgumentException.class);
+      q = new RangeFilteredQuery(new TermQuery(new Term("field", "test")), 5);
+      indexSearcher.search(q, 10);
+    }
+
+  }
+
+  @Test
+  public void testIntervalQueryAgainstMatchAllDocsQueryThrowsException() throws IOException {
+
+    try (Directory directory = newDirectory()) {
+
+      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))
+          .setMergePolicy(newLogMergePolicy())
+          .setSimilarity(new DefaultSimilarity());
+
+      RandomIndexWriter writer = new RandomIndexWriter(random(), directory, iwc);
+
+      Document doc = new Document();
+      doc.add(newTextField("field", "test", Field.Store.NO));
+      writer.addDocument(doc);
+
+      IndexReader indexReader = SlowCompositeReaderWrapper.wrap(writer.getReader());
+      writer.close();
+      IndexSearcher indexSearcher = newSearcher(indexReader);
+
+      Query q = new RangeFilteredQuery(new MatchAllDocsQuery(), 5);
+
+      exception.expect(IllegalArgumentException.class);
+      exception.expectMessage("MatchAllScorer does not support IntervalIterators");
+
+      indexSearcher.search(q, 10);
+    }
+
+  }
+
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache.java b/lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache.java
index 3187a8f..0f63eb4 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestLRUQueryCache.java
@@ -343,7 +343,7 @@ public class TestLRUQueryCache extends LuceneTestCase {
     }
 
     @Override
-    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
       return new ConstantScoreWeight(this) {
         @Override
         Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestMinShouldMatch2.java b/lucene/core/src/test/org/apache/lucene/search/TestMinShouldMatch2.java
index 23f4e6b..a133bd4 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestMinShouldMatch2.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestMinShouldMatch2.java
@@ -124,7 +124,7 @@ public class TestMinShouldMatch2 extends LuceneTestCase {
     }
     bq.setMinimumNumberShouldMatch(minShouldMatch);
 
-    BooleanWeight weight = (BooleanWeight) searcher.createNormalizedWeight(bq, true);
+    BooleanWeight weight = (BooleanWeight) searcher.createNormalizedWeight(bq, Weight.Postings.DOCS_AND_SCORES);
     
     switch (mode) {
     case DOC_VALUES:
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery.java
index e2995ab..ed5d277 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestMultiPhraseQuery.java
@@ -344,7 +344,7 @@ public class TestMultiPhraseQuery extends LuceneTestCase {
     MultiPhraseQuery query = new MultiPhraseQuery();
     query.add(new Term[] { new Term("body", "this"), new Term("body", "that") });
     query.add(new Term("body", "is"));
-    Weight weight = query.createWeight(searcher, true);
+    Weight weight = query.createWeight(searcher, Weight.Postings.DOCS_AND_SCORES);
     assertEquals(10f * 10f, weight.getValueForNormalization(), 0.001f);
 
     writer.close();
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestNeedsScores.java b/lucene/core/src/test/org/apache/lucene/search/TestNeedsScores.java
index 91e6ee1..e89c635 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestNeedsScores.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestNeedsScores.java
@@ -63,15 +63,15 @@ public class TestNeedsScores extends LuceneTestCase {
     Query required = new TermQuery(new Term("field", "this"));
     Query prohibited = new TermQuery(new Term("field", "3"));
     BooleanQuery bq = new BooleanQuery();
-    bq.add(new AssertNeedsScores(required, true), BooleanClause.Occur.MUST);
-    bq.add(new AssertNeedsScores(prohibited, false), BooleanClause.Occur.MUST_NOT);
+    bq.add(new AssertNeedsScores(required, Weight.Postings.DOCS_AND_SCORES), BooleanClause.Occur.MUST);
+    bq.add(new AssertNeedsScores(prohibited, Weight.Postings.DOCS), BooleanClause.Occur.MUST_NOT);
     assertEquals(4, searcher.search(bq, 5).totalHits); // we exclude 3
   }
   
   /** nested inside constant score query */
   public void testConstantScoreQuery() throws Exception {
     Query term = new TermQuery(new Term("field", "this"));
-    Query constantScore = new ConstantScoreQuery(new AssertNeedsScores(term, false));
+    Query constantScore = new ConstantScoreQuery(new AssertNeedsScores(term, Weight.Postings.DOCS));
     assertEquals(5, searcher.search(constantScore, 5).totalHits);
   }
   
@@ -79,19 +79,19 @@ public class TestNeedsScores extends LuceneTestCase {
   public void testQueryWrapperFilter() throws Exception {
     Query query = new MatchAllDocsQuery();
     Query term = new TermQuery(new Term("field", "this"));
-    Filter filter = new QueryWrapperFilter(new AssertNeedsScores(term, false));
+    Filter filter = new QueryWrapperFilter(new AssertNeedsScores(term, Weight.Postings.DOCS));
     assertEquals(5, searcher.search(new FilteredQuery(query, filter), 5).totalHits);
   }
   
   /** when not sorting by score */
   public void testSortByField() throws Exception {
-    Query query = new AssertNeedsScores(new MatchAllDocsQuery(), false);
+    Query query = new AssertNeedsScores(new MatchAllDocsQuery(), Weight.Postings.DOCS);
     assertEquals(5, searcher.search(query, 5, Sort.INDEXORDER).totalHits);
   }
   
   /** when sorting by score */
   public void testSortByScore() throws Exception {
-    Query query = new AssertNeedsScores(new MatchAllDocsQuery(), true);
+    Query query = new AssertNeedsScores(new MatchAllDocsQuery(), Weight.Postings.DOCS_AND_SCORES);
     assertEquals(5, searcher.search(query, 5, Sort.RELEVANCE).totalHits);
   }
 
@@ -101,15 +101,15 @@ public class TestNeedsScores extends LuceneTestCase {
    */
   static class AssertNeedsScores extends Query {
     final Query in;
-    final boolean value;
+    final Weight.Postings value;
     
-    AssertNeedsScores(Query in, boolean value) {
+    AssertNeedsScores(Query in, Weight.Postings value) {
       this.in = in;
       this.value = value;
     }
 
     @Override
-    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
       final Weight w = in.createWeight(searcher, needsScores);
       return new Weight(AssertNeedsScores.this) {
         @Override
@@ -155,7 +155,7 @@ public class TestNeedsScores extends LuceneTestCase {
       final int prime = 31;
       int result = super.hashCode();
       result = prime * result + ((in == null) ? 0 : in.hashCode());
-      result = prime * result + (value ? 1231 : 1237);
+      result = prime * result + value.hashCode();
       return result;
     }
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestPositiveScoresOnlyCollector.java b/lucene/core/src/test/org/apache/lucene/search/TestPositiveScoresOnlyCollector.java
index c8017a9..3593b04 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestPositiveScoresOnlyCollector.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestPositiveScoresOnlyCollector.java
@@ -84,7 +84,7 @@ public class TestPositiveScoresOnlyCollector extends LuceneTestCase {
     IndexReader ir = writer.getReader();
     writer.close();
     IndexSearcher searcher = newSearcher(ir);
-    Weight fake = new TermQuery(new Term("fake", "weight")).createWeight(searcher, true);
+    Weight fake = new TermQuery(new Term("fake", "weight")).createWeight(searcher, Weight.Postings.DOCS_AND_SCORES);
     Scorer s = new SimpleScorer(fake);
     TopDocsCollector<ScoreDoc> tdc = TopScoreDocCollector.create(scores.length);
     Collector c = new PositiveScoresOnlyCollector(tdc);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java b/lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java
index 3b78985..ce68873 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java
@@ -424,7 +424,7 @@ public class TestQueryRescorer extends LuceneTestCase {
     }
 
     @Override
-    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
 
       return new Weight(FixedScoreQuery.this) {
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestQueryWrapperFilter.java b/lucene/core/src/test/org/apache/lucene/search/TestQueryWrapperFilter.java
index 76b4def..a32f9a3 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestQueryWrapperFilter.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestQueryWrapperFilter.java
@@ -205,7 +205,7 @@ public class TestQueryWrapperFilter extends LuceneTestCase {
     final IndexSearcher searcher = new IndexSearcher(reader);
     searcher.setQueryCache(null); // to still have approximations
     final Query query = new QueryWrapperFilter(new RandomApproximationQuery(new TermQuery(new Term("foo", "bar")), random()));
-    final Weight weight = searcher.createNormalizedWeight(query, random().nextBoolean());
+    final Weight weight = searcher.createNormalizedWeight(query, random().nextBoolean() ? Weight.Postings.DOCS : Weight.Postings.DOCS_AND_SCORES);
     final Scorer scorer = weight.scorer(reader.leaves().get(0), null);
     assertNotNull(scorer.asTwoPhaseIterator());
     reader.close();
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestRangeFilteredQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestRangeFilteredQuery.java
new file mode 100644
index 0000000..8a2bf9a
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestRangeFilteredQuery.java
@@ -0,0 +1,90 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.SlowCompositeReaderWrapper;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
+
+public class TestRangeFilteredQuery extends LuceneTestCase {
+
+  protected Directory directory;
+  protected IndexReader indexReader;
+  protected IndexSearcher indexSearcher;
+
+  public static final String FIELD = "f";
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    directory = newDirectory();
+
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+        newIndexWriterConfig(new MockAnalyzer(random()))
+            .setMergePolicy(newLogMergePolicy())
+            .setSimilarity(new DefaultSimilarity()));
+    for (String value : values) {
+      Document doc = new Document();
+      doc.add(newTextField(FIELD, value, Field.Store.YES));
+      writer.addDocument(doc);
+    }
+    indexReader = SlowCompositeReaderWrapper.wrap(writer.getReader());
+    writer.close();
+    indexSearcher = newSearcher(indexReader);
+    indexSearcher.setSimilarity(new DefaultSimilarity());
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    indexReader.close();
+    directory.close();
+    super.tearDown();
+  }
+
+  public static final String[] values = new String[]{
+      "a b c d f e a",
+      "e b c d a f g",
+      "f f f f c"
+  };
+
+  @Test
+  public void testRangeFilters() throws IOException {
+
+    RangeFilteredQuery q = new RangeFilteredQuery(new TermQuery(new Term(FIELD, "c")), 3);
+    TopDocs topdocs = indexSearcher.search(q, 10);
+    assertEquals(2, topdocs.totalHits);
+
+    q = new RangeFilteredQuery(new TermQuery(new Term(FIELD, "f")), 5, 6);
+    assertEquals(1, indexSearcher.search(q, 10).totalHits);
+
+    q = new RangeFilteredQuery(new TermQuery(new Term(FIELD, "g")), 4);
+    assertEquals(0, indexSearcher.search(q, 10).totalHits);
+
+  }
+
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestScoreCachingWrappingScorer.java b/lucene/core/src/test/org/apache/lucene/search/TestScoreCachingWrappingScorer.java
index 4fe88f4..b9a136b 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestScoreCachingWrappingScorer.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestScoreCachingWrappingScorer.java
@@ -109,7 +109,7 @@ public class TestScoreCachingWrappingScorer extends LuceneTestCase {
     IndexReader ir = writer.getReader();
     writer.close();
     IndexSearcher searcher = newSearcher(ir);
-    Weight fake = new TermQuery(new Term("fake", "weight")).createWeight(searcher, true);
+    Weight fake = new TermQuery(new Term("fake", "weight")).createWeight(searcher, Weight.Postings.DOCS_AND_SCORES);
     Scorer s = new SimpleScorer(fake);
     ScoreCachingCollector scc = new ScoreCachingCollector(scores.length);
     scc.setScorer(s);
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestTermScorer.java b/lucene/core/src/test/org/apache/lucene/search/TestTermScorer.java
index 751b3dd..5d91b40 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestTermScorer.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestTermScorer.java
@@ -75,7 +75,7 @@ public class TestTermScorer extends LuceneTestCase {
     Term allTerm = new Term(FIELD, "all");
     TermQuery termQuery = new TermQuery(allTerm);
     
-    Weight weight = indexSearcher.createNormalizedWeight(termQuery, true);
+    Weight weight = indexSearcher.createNormalizedWeight(termQuery, Weight.Postings.DOCS_AND_SCORES);
     assertTrue(indexSearcher.getTopReaderContext() instanceof LeafReaderContext);
     LeafReaderContext context = (LeafReaderContext)indexSearcher.getTopReaderContext();
     BulkScorer ts = weight.bulkScorer(context, context.reader().getLiveDocs());
@@ -137,7 +137,7 @@ public class TestTermScorer extends LuceneTestCase {
     Term allTerm = new Term(FIELD, "all");
     TermQuery termQuery = new TermQuery(allTerm);
     
-    Weight weight = indexSearcher.createNormalizedWeight(termQuery, true);
+    Weight weight = indexSearcher.createNormalizedWeight(termQuery, Weight.Postings.DOCS_AND_SCORES);
     assertTrue(indexSearcher.getTopReaderContext() instanceof LeafReaderContext);
     LeafReaderContext context = (LeafReaderContext) indexSearcher.getTopReaderContext();
     Scorer ts = weight.scorer(context, context.reader().getLiveDocs());
@@ -156,7 +156,7 @@ public class TestTermScorer extends LuceneTestCase {
     Term allTerm = new Term(FIELD, "all");
     TermQuery termQuery = new TermQuery(allTerm);
     
-    Weight weight = indexSearcher.createNormalizedWeight(termQuery, true);
+    Weight weight = indexSearcher.createNormalizedWeight(termQuery, Weight.Postings.DOCS_AND_SCORES);
     assertTrue(indexSearcher.getTopReaderContext() instanceof LeafReaderContext);
     LeafReaderContext context = (LeafReaderContext) indexSearcher.getTopReaderContext();
     Scorer ts = weight.scorer(context, context.reader().getLiveDocs());
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java b/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java
index 24e784b..8cb0f52 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java
@@ -251,7 +251,7 @@ public class TestTopDocsMerge extends LuceneTestCase {
       }
 
       // ... then all shards:
-      final Weight w = searcher.createNormalizedWeight(query, true);
+      final Weight w = searcher.createNormalizedWeight(query, Weight.Postings.DOCS_AND_SCORES);
 
       final TopDocs[] shardHits;
       if (sort == null) {
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
index 5eb29cf..863ef6e 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
@@ -181,7 +181,7 @@ public class TestNearSpansOrdered extends LuceneTestCase {
    */
   public void testSpanNearScorerSkipTo1() throws Exception {
     SpanNearQuery q = makeQuery();
-    Weight w = searcher.createNormalizedWeight(q, true);
+    Weight w = searcher.createNormalizedWeight(q, Weight.Postings.DOCS_AND_SCORES);
     IndexReaderContext topReaderContext = searcher.getTopReaderContext();
     LeafReaderContext leave = topReaderContext.leaves().get(0);
     Scorer s = w.scorer(leave, leave.reader().getLiveDocs());
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
index 577679d..78cafb8 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
@@ -36,6 +36,7 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.store.Directory;
@@ -430,7 +431,7 @@ public class TestSpans extends LuceneTestCase {
                                 slop,
                                 ordered);
   
-        spanScorer = searcher.createNormalizedWeight(snq, true).scorer(ctx, ctx.reader().getLiveDocs());
+        spanScorer = searcher.createNormalizedWeight(snq, Weight.Postings.DOCS_AND_SCORES).scorer(ctx, ctx.reader().getLiveDocs());
       } finally {
         searcher.setSimilarity(oldSim);
       }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/TermAutomatonQuery.java b/lucene/sandbox/src/java/org/apache/lucene/search/TermAutomatonQuery.java
index b52cd15..bc33be0 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/TermAutomatonQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/TermAutomatonQuery.java
@@ -188,7 +188,7 @@ public class TermAutomatonQuery extends Query {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores, int flags) throws IOException {
     IndexReaderContext context = searcher.getTopReaderContext();
     Map<Integer,TermContext> termStates = new HashMap<>();
 
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/AssertingIndexSearcher.java b/lucene/test-framework/src/java/org/apache/lucene/search/AssertingIndexSearcher.java
index 09d490e..36a6e05 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/AssertingIndexSearcher.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/AssertingIndexSearcher.java
@@ -55,7 +55,7 @@ public class AssertingIndexSearcher extends IndexSearcher {
   
   /** Ensures, that the returned {@code Weight} is not normalized again, which may produce wrong scores. */
   @Override
-  public Weight createNormalizedWeight(Query query, boolean needsScores) throws IOException {
+  public Weight createNormalizedWeight(Query query, Weight.Postings needsScores) throws IOException {
     final Weight w = super.createNormalizedWeight(query, needsScores);
     return new AssertingWeight(random, w) {
 
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/AssertingQuery.java b/lucene/test-framework/src/java/org/apache/lucene/search/AssertingQuery.java
index ae2f9a3..050d4fe 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/AssertingQuery.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/AssertingQuery.java
@@ -42,7 +42,7 @@ public class AssertingQuery extends Query {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings needsScores) throws IOException {
     return AssertingWeight.wrap(new Random(random.nextLong()), in.createWeight(searcher, needsScores));
   }
 
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java b/lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java
index aa53d17..5e45967 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils.java
@@ -262,7 +262,7 @@ public class QueryUtils {
             lastDoc[0] = doc;
             try {
               if (scorer == null) {
-                Weight w = s.createNormalizedWeight(q, true);
+                Weight w = s.createNormalizedWeight(q, Weight.Postings.DOCS_AND_SCORES);
                 LeafReaderContext context = readerContextArray.get(leafPtr);
                 scorer = w.scorer(context, context.reader().getLiveDocs());
               }
@@ -314,7 +314,7 @@ public class QueryUtils {
               final LeafReader previousReader = lastReader[0];
               IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);
               indexSearcher.setSimilarity(s.getSimilarity());
-              Weight w = indexSearcher.createNormalizedWeight(q, true);
+              Weight w = indexSearcher.createNormalizedWeight(q, Weight.Postings.DOCS_AND_SCORES);
               LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();
               Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());
               if (scorer != null) {
@@ -336,7 +336,7 @@ public class QueryUtils {
           final LeafReader previousReader = lastReader[0];
           IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);
           indexSearcher.setSimilarity(s.getSimilarity());
-          Weight w = indexSearcher.createNormalizedWeight(q, true);
+          Weight w = indexSearcher.createNormalizedWeight(q, Weight.Postings.DOCS_AND_SCORES);
           LeafReaderContext ctx = previousReader.getContext();
           Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());
           if (scorer != null) {
@@ -368,7 +368,7 @@ public class QueryUtils {
         try {
           long startMS = System.currentTimeMillis();
           for (int i=lastDoc[0]+1; i<=doc; i++) {
-            Weight w = s.createNormalizedWeight(q, true);
+            Weight w = s.createNormalizedWeight(q, Weight.Postings.DOCS_AND_SCORES);
             Scorer scorer = w.scorer(context.get(leafPtr), liveDocs);
             Assert.assertTrue("query collected "+doc+" but advance("+i+") says no more docs!",scorer.advance(i) != DocIdSetIterator.NO_MORE_DOCS);
             Assert.assertEquals("query collected "+doc+" but advance("+i+") got to "+scorer.docID(),doc,scorer.docID());
@@ -401,7 +401,7 @@ public class QueryUtils {
           final LeafReader previousReader = lastReader[0];
           IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);
           indexSearcher.setSimilarity(s.getSimilarity());
-          Weight w = indexSearcher.createNormalizedWeight(q, true);
+          Weight w = indexSearcher.createNormalizedWeight(q, Weight.Postings.DOCS_AND_SCORES);
           Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());
           if (scorer != null) {
             boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;
@@ -422,7 +422,7 @@ public class QueryUtils {
       final LeafReader previousReader = lastReader[0];
       IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);
       indexSearcher.setSimilarity(s.getSimilarity());
-      Weight w = indexSearcher.createNormalizedWeight(q, true);
+      Weight w = indexSearcher.createNormalizedWeight(q, Weight.Postings.DOCS_AND_SCORES);
       Scorer scorer = w.scorer((LeafReaderContext)indexSearcher.getTopReaderContext(), previousReader.getLiveDocs());
       if (scorer != null) {
         boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;
@@ -433,7 +433,7 @@ public class QueryUtils {
 
   /** Check that the scorer and bulk scorer advance consistently. */
   public static void checkBulkScorerSkipTo(Random r, Query query, IndexSearcher searcher) throws IOException {
-    Weight weight = searcher.createNormalizedWeight(query, true);
+    Weight weight = searcher.createNormalizedWeight(query, Weight.Postings.DOCS_AND_SCORES);
     for (LeafReaderContext context : searcher.getIndexReader().leaves()) {
       final Scorer scorer = weight.scorer(context, context.reader().getLiveDocs());
       final BulkScorer bulkScorer = weight.bulkScorer(context, context.reader().getLiveDocs());
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/RandomApproximationQuery.java b/lucene/test-framework/src/java/org/apache/lucene/search/RandomApproximationQuery.java
index ddb60cb..554aa96 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/RandomApproximationQuery.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/RandomApproximationQuery.java
@@ -73,8 +73,8 @@ public class RandomApproximationQuery extends Query {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    final Weight weight = query.createWeight(searcher, needsScores);
+  public Weight createWeight(IndexSearcher searcher, Weight.Postings flags) throws IOException {
+    final Weight weight = query.createWeight(searcher, flags);
     return new RandomApproximationWeight(weight, new Random(random.nextLong()));
   }
 
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/SearchEquivalenceTestBase.java b/lucene/test-framework/src/java/org/apache/lucene/search/SearchEquivalenceTestBase.java
index 40ea56e..d7c1d25 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/SearchEquivalenceTestBase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/SearchEquivalenceTestBase.java
@@ -187,7 +187,7 @@ public abstract class SearchEquivalenceTestBase extends LuceneTestCase {
     public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
       // get a private context that is used to rewrite, createWeight and score eventually
       final LeafReaderContext privateContext = context.reader().getContext();
-      final Weight weight = new IndexSearcher(privateContext).createNormalizedWeight(query, false);
+      final Weight weight = new IndexSearcher(privateContext).createNormalizedWeight(query, Weight.Postings.DOCS);
       return new DocIdSet() {
         @Override
         public DocIdSetIterator iterator() throws IOException {
