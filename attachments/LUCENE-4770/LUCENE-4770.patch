Index: src/test/org/apache/lucene/spatial/prefix/JtsPolygonTest.java
===================================================================
--- src/test/org/apache/lucene/spatial/prefix/JtsPolygonTest.java	(revision 1443457)
+++ src/test/org/apache/lucene/spatial/prefix/JtsPolygonTest.java	(working copy)
@@ -17,16 +17,29 @@
  * limitations under the License.
  */
 
-import com.spatial4j.core.context.SpatialContextFactory;
-import com.spatial4j.core.shape.Shape;
+import java.io.IOException;
+import java.util.HashMap;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.Field.Store;
+import org.apache.lucene.document.TextField;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.spatial.StrategyTestCase;
 import org.apache.lucene.spatial.prefix.tree.GeohashPrefixTree;
+import org.apache.lucene.spatial.prefix.tree.QuadPrefixTree;
+import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
 import org.apache.lucene.spatial.query.SpatialArgs;
 import org.apache.lucene.spatial.query.SpatialOperation;
 import org.junit.Test;
 
-import java.io.IOException;
-import java.util.HashMap;
+import com.spatial4j.core.context.SpatialContextFactory;
+import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.Shape;
+import com.spatial4j.core.shape.impl.PointImpl;
+import com.spatial4j.core.shape.impl.RectangleImpl;
 
 public class JtsPolygonTest extends StrategyTestCase {
 
@@ -69,5 +82,36 @@
     args.setDistErrPct(distErrPct);
     return args;
   }
+  
+  @Test
+  public void testEdgeCases() throws Exception {
+  
+    Shape area = ctx.readShape("POLYGON((-122.83 48.57, -122.77 48.56, -122.79 48.53, -122.83 48.57))");
+    
+    SpatialPrefixTree trie = new QuadPrefixTree(ctx, 12);
+    TermQueryPrefixTreeStrategy strategy = new TermQueryPrefixTreeStrategy(trie, "geo");
+    Document doc = new Document();
+    doc.add(new TextField("id", "1", Store.YES));
 
+    Field[] fields = strategy.createIndexableFields(area, 0.025);
+    for (Field field : fields) {
+      doc.add(field);  
+    }
+    addDocument(doc);
+
+    Point upperleft = new PointImpl(-122.88, 48.54, ctx);
+    Point lowerright = new PointImpl(-122.82, 48.62, ctx);
+    
+    Query query = strategy.makeQuery(new SpatialArgs(SpatialOperation.Intersects, new RectangleImpl(upperleft, lowerright, ctx)));
+    commit();
+    
+    TopDocs search = indexSearcher.search(query, 10);
+    ScoreDoc[] scoreDocs = search.scoreDocs;
+    for (int i = 0; i < scoreDocs.length; i++) {
+      System.out.println(indexSearcher.doc(scoreDocs[i].doc));
+    }
+
+    assertEquals(1, search.totalHits);
+  }
+
 }
Index: src/test/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTreeTest.java
===================================================================
--- src/test/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTreeTest.java	(revision 1443457)
+++ src/test/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTreeTest.java	(working copy)
@@ -17,15 +17,28 @@
 
 package org.apache.lucene.spatial.prefix.tree;
 
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.Field.Store;
+import org.apache.lucene.document.TextField;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.spatial.SpatialTestCase;
+import org.apache.lucene.spatial.prefix.TermQueryPrefixTreeStrategy;
+import org.apache.lucene.spatial.query.SpatialArgs;
+import org.apache.lucene.spatial.query.SpatialOperation;
 import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.shape.Point;
 import com.spatial4j.core.shape.Rectangle;
 import com.spatial4j.core.shape.Shape;
+import com.spatial4j.core.shape.impl.PointImpl;
+import com.spatial4j.core.shape.impl.RectangleImpl;
 
-import org.apache.lucene.util.LuceneTestCase;
 import org.junit.Before;
 import org.junit.Test;
 
-public class SpatialPrefixTreeTest extends LuceneTestCase {
+public class SpatialPrefixTreeTest extends SpatialTestCase {
 
   //TODO plug in others and test them
   private SpatialContext ctx;
@@ -57,4 +70,37 @@
       assertTrue(prevNShape.getHeight() > sbox.getHeight());
     }
   }
-}
+  
+  @Test
+  public void testEdgeCases() throws Exception {
+  
+    SpatialPrefixTree trie = new QuadPrefixTree(ctx, 12);
+    TermQueryPrefixTreeStrategy strategy = new TermQueryPrefixTreeStrategy(trie, "geo");
+    Document doc = new Document();
+    doc.add(new TextField("id", "1", Store.YES));
+   
+   Shape area = new RectangleImpl(-122.82, -122.78, 48.54, 48.56, ctx);
+
+    Field[] fields = strategy.createIndexableFields(area, 0.025);
+    for (Field field : fields) {
+      doc.add(field);  
+    }
+    addDocument(doc);
+
+    Point upperleft = new PointImpl(-122.88, 48.54, ctx);
+    Point lowerright = new PointImpl(-122.82, 48.62, ctx);
+    
+    Query query = strategy.makeQuery(new SpatialArgs(SpatialOperation.Intersects, new RectangleImpl(upperleft, lowerright, ctx)));
+
+    commit();
+    
+    TopDocs search = indexSearcher.search(query, 10);
+    ScoreDoc[] scoreDocs = search.scoreDocs;
+    for (int i = 0; i < scoreDocs.length; i++) {
+      System.out.println(indexSearcher.doc(scoreDocs[i].doc));
+    }
+
+    assertEquals(1, search.totalHits);
+  }
+ 
+}
\ No newline at end of file
Index: src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree.java
===================================================================
--- src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree.java	(revision 1443457)
+++ src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTree.java	(working copy)
@@ -156,16 +156,19 @@
     }
     final Collection<Node> subCells = node.getSubCells(shape);
     if (node.getLevel() == detailLevel - 1) {
-      if (subCells.size() < node.getSubCellsSize() || node.getLevel() == 0) {
+      if (subCells.size() == node.getSubCellsSize() && !inclParents) {
+        // A bottom level (i.e. detail level) optimization where all boxes intersect, so use parent cell.
+        // Can optimize at only one of index time or query/filter time; the !inclParents
+        // condition above means we do not optimize at index time.
+        node.setLeaf();
+        result.add(node);
+      } else {
         if (inclParents)
           result.add(node);
         for (Node subCell : subCells) {
           subCell.setLeaf();
         }
         result.addAll(subCells);
-      } else {//a bottom level (i.e. detail level) optimization where all boxes intersect, so use parent cell.
-        node.setLeaf();//the cell may not be strictly within but its close
-        result.add(node);
       }
     } else {
       if (inclParents) {
