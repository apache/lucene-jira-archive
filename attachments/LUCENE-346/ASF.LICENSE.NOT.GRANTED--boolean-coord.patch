Index: src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java
===================================================================
--- src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java	(revision 153087)
+++ src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java	(working copy)
@@ -64,7 +64,7 @@
       for (int i = 0; i < fields.length; i++)
         clauses.add(new BooleanClause(super.getFieldQuery(fields[i], queryText),
             BooleanClause.Occur.SHOULD));
-      return getBooleanQuery(clauses);
+      return getBooleanQuery(clauses, true);
     }
     return super.getFieldQuery(field, queryText);
   }
@@ -84,7 +84,7 @@
         clauses.add(new BooleanClause(super.getFuzzyQuery(fields[i], termStr, minSimilarity),
             BooleanClause.Occur.SHOULD));
       }
-      return getBooleanQuery(clauses);
+      return getBooleanQuery(clauses, true);
     }
     return super.getFuzzyQuery(field, termStr, minSimilarity);
   }
@@ -97,7 +97,7 @@
         clauses.add(new BooleanClause(super.getPrefixQuery(fields[i], termStr),
             BooleanClause.Occur.SHOULD));
       }
-      return getBooleanQuery(clauses);
+      return getBooleanQuery(clauses, true);
     }
     return super.getPrefixQuery(field, termStr);
   }
@@ -117,7 +117,7 @@
         clauses.add(new BooleanClause(super.getRangeQuery(fields[i], part1, part2, inclusive),
             BooleanClause.Occur.SHOULD));
       }
-      return getBooleanQuery(clauses);
+      return getBooleanQuery(clauses, true);
     }
     return super.getRangeQuery(field, part1, part2, inclusive);
   }
Index: src/java/org/apache/lucene/queryParser/QueryParser.java
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParser.java	(revision 153087)
+++ src/java/org/apache/lucene/queryParser/QueryParser.java	(working copy)
@@ -393,7 +393,7 @@
       if (severalTokensAtSamePosition) {
         if (positionCount == 1) {
           // no phrase query:
-          BooleanQuery q = new BooleanQuery();
+          BooleanQuery q = new BooleanQuery(true);
           for (int i = 0; i < v.size(); i++) {
             t = (org.apache.lucene.analysis.Token) v.elementAt(i);
             TermQuery currentQuery = new TermQuery(
@@ -521,9 +521,27 @@
    * @return Resulting {@link Query} object.
    * @exception ParseException throw in overridden method to disallow
    */
-  protected Query getBooleanQuery(Vector clauses) throws ParseException
+  protected Query getBooleanQuery(Vector clauses) throws ParseException {
+    return getBooleanQuery(clauses, false);
+  }
+  /**
+   * Factory method for generating query, given a set of clauses.
+   * By default creates a boolean query composed of clauses passed in.
+   *
+   * Can be overridden by extending classes, to modify query being
+   * returned.
+   *
+   * @param clauses Vector that contains {@link BooleanClause} instances
+   *    to join.
+   * @param disableCoord true if coord scoring should be disabled.
+   *
+   * @return Resulting {@link Query} object.
+   * @exception ParseException throw in overridden method to disallow
+   */
+  protected Query getBooleanQuery(Vector clauses, boolean disableCoord)
+    throws ParseException
   {
-    BooleanQuery query = new BooleanQuery();
+    BooleanQuery query = new BooleanQuery(disableCoord);
     for (int i = 0; i < clauses.size(); i++) {
   query.add((BooleanClause)clauses.elementAt(i));
     }
Index: src/java/org/apache/lucene/queryParser/QueryParser.jj
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParser.jj	(revision 153087)
+++ src/java/org/apache/lucene/queryParser/QueryParser.jj	(working copy)
@@ -416,7 +416,7 @@
       if (severalTokensAtSamePosition) {
         if (positionCount == 1) {
           // no phrase query:
-          BooleanQuery q = new BooleanQuery();
+          BooleanQuery q = new BooleanQuery(true);
           for (int i = 0; i < v.size(); i++) {
             t = (org.apache.lucene.analysis.Token) v.elementAt(i);
             TermQuery currentQuery = new TermQuery(
@@ -544,9 +544,27 @@
    * @return Resulting {@link Query} object.
    * @exception ParseException throw in overridden method to disallow
    */
-  protected Query getBooleanQuery(Vector clauses) throws ParseException
+  protected Query getBooleanQuery(Vector clauses) throws ParseException {
+    getBooleanQuery(clauses, false);
+  }
+  /**
+   * Factory method for generating query, given a set of clauses.
+   * By default creates a boolean query composed of clauses passed in.
+   *
+   * Can be overridden by extending classes, to modify query being
+   * returned.
+   *
+   * @param clauses Vector that contains {@link BooleanClause} instances
+   *    to join.
+   * @param disableCoord true if coord scoring should be disabled.
+   *
+   * @return Resulting {@link Query} object.
+   * @exception ParseException throw in overridden method to disallow
+   */
+  protected Query getBooleanQuery(Vector clauses, boolean disableCoord)
+    throws ParseException
   {
-    BooleanQuery query = new BooleanQuery();
+    BooleanQuery query = new BooleanQuery(disableCoord);
     for (int i = 0; i < clauses.size(); i++) {
   query.add((BooleanClause)clauses.elementAt(i));
     }
Index: src/java/org/apache/lucene/search/MultiTermQuery.java
===================================================================
--- src/java/org/apache/lucene/search/MultiTermQuery.java	(revision 153087)
+++ src/java/org/apache/lucene/search/MultiTermQuery.java	(working copy)
@@ -51,7 +51,7 @@
 
     public Query rewrite(IndexReader reader) throws IOException {
       FilteredTermEnum enumerator = getEnum(reader);
-      BooleanQuery query = new BooleanQuery();
+      BooleanQuery query = new BooleanQuery(true);
       try {
         do {
           Term t = enumerator.term();
Index: src/java/org/apache/lucene/search/FuzzyQuery.java
===================================================================
--- src/java/org/apache/lucene/search/FuzzyQuery.java	(revision 153087)
+++ src/java/org/apache/lucene/search/FuzzyQuery.java	(working copy)
@@ -122,7 +122,7 @@
       enumerator.close();
     }
     
-    BooleanQuery query = new BooleanQuery();
+    BooleanQuery query = new BooleanQuery(true);
     int size = stQueue.size();
     for(int i = 0; i < size; i++){
       ScoreTerm st = (ScoreTerm) stQueue.pop();
Index: src/java/org/apache/lucene/search/SimilarityDelegator.java
===================================================================
--- src/java/org/apache/lucene/search/SimilarityDelegator.java	(revision 0)
+++ src/java/org/apache/lucene/search/SimilarityDelegator.java	(revision 0)
@@ -0,0 +1,58 @@
+package org.apache.lucene.search;
+
+/**
+ * Copyright 2005 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** Expert: Delegating scoring implementation.  Useful in {@link
+ * Query#getSimilarity(Searcher) implementations, to override only certain
+ * methods of a Searcher's Similiarty implementation.. */
+public class SimilarityDelegator extends Similarity {
+
+  private Similarity delegee;
+
+  /** Construct a {@link Similiarity} that delegates all methods to another.
+   *
+   * @param delegee the Similarity implementation to delegate to
+   */
+  public SimilarityDelegator(Similarity delegee) {
+    this.delegee = delegee;
+  }
+
+  public float lengthNorm(String fieldName, int numTerms) {
+    return delegee.lengthNorm(fieldName, numTerms);
+  }
+  
+  public float queryNorm(float sumOfSquaredWeights) {
+    return delegee.queryNorm(sumOfSquaredWeights);
+  }
+
+  public float tf(float freq) {
+    return delegee.tf(freq);
+  }
+    
+  public float sloppyFreq(int distance) {
+    return delegee.sloppyFreq(distance);
+  }
+    
+  public float idf(int docFreq, int numDocs) {
+    return delegee.idf(docFreq, numDocs);
+  }
+    
+  public float coord(int overlap, int maxOverlap) {
+    return delegee.coord(overlap, maxOverlap);
+  }
+
+}
Index: src/java/org/apache/lucene/search/RangeQuery.java
===================================================================
--- src/java/org/apache/lucene/search/RangeQuery.java	(revision 153087)
+++ src/java/org/apache/lucene/search/RangeQuery.java	(working copy)
@@ -64,7 +64,7 @@
 
     public Query rewrite(IndexReader reader) throws IOException {
 
-        BooleanQuery query = new BooleanQuery();
+        BooleanQuery query = new BooleanQuery(true);
         TermEnum enumerator = reader.terms(lowerTerm);
 
         try {
Index: src/java/org/apache/lucene/search/MultiPhraseQuery.java
===================================================================
--- src/java/org/apache/lucene/search/MultiPhraseQuery.java	(revision 153087)
+++ src/java/org/apache/lucene/search/MultiPhraseQuery.java	(working copy)
@@ -228,7 +228,7 @@
   public Query rewrite(IndexReader reader) {
     if (termArrays.size() == 1) {                 // optimize one-term case
       Term[] terms = (Term[])termArrays.get(0);
-      BooleanQuery boq = new BooleanQuery();
+      BooleanQuery boq = new BooleanQuery(true);
       for (int i=0; i<terms.length; i++) {
         boq.add(new TermQuery(terms[i]), BooleanClause.Occur.SHOULD);
       }
Index: src/java/org/apache/lucene/search/PrefixQuery.java
===================================================================
--- src/java/org/apache/lucene/search/PrefixQuery.java	(revision 153087)
+++ src/java/org/apache/lucene/search/PrefixQuery.java	(working copy)
@@ -35,7 +35,7 @@
   public Term getPrefix() { return prefix; }
 
   public Query rewrite(IndexReader reader) throws IOException {
-    BooleanQuery query = new BooleanQuery();
+    BooleanQuery query = new BooleanQuery(true);
     TermEnum enumerator = reader.terms(prefix);
     try {
       String prefixText = prefix.text();
Index: src/java/org/apache/lucene/search/BooleanQuery.java
===================================================================
--- src/java/org/apache/lucene/search/BooleanQuery.java	(revision 153087)
+++ src/java/org/apache/lucene/search/BooleanQuery.java	(working copy)
@@ -63,10 +63,44 @@
   }
 
   private Vector clauses = new Vector();
+  private boolean disableCoord;
 
   /** Constructs an empty boolean query. */
   public BooleanQuery() {}
 
+  /** Constructs an empty boolean query.
+   *
+   * {@link Similarity#coord(int,int)} may be disabled in scoring, as
+   * appropriate. For example, this score factor does not make sense for most
+   * automatically generated queries, like {@link WildCardQuery} and {@link
+   * FuzzyQuery}.
+   *
+   * @param disableCoord disables {@link Similarity#coord(int,int)} in scoring.
+   */
+  public BooleanQuery(boolean disableCoord) {
+    this.disableCoord = disableCoord;
+  }
+
+  /** Returns true iff {@link Similarity#coord(int,int)} is disabled in
+   * scoring for this query instance.
+   * @see BooleanQuery(boolean)
+   */
+  public boolean isCoordDisabled() { return disableCoord; }
+
+  // Implement coord disabling.
+  // Inherit javadoc.
+  public Similarity getSimilarity(Searcher searcher) {
+    Similarity result = super.getSimilarity(searcher);
+    if (disableCoord) {                           // disable coord as requested
+      result = new SimilarityDelegator(result) {
+          public float coord(int overlap, int maxOverlap) {
+            return 1.0f;
+          }
+        };
+    }
+    return result;
+  }
+
   /** Adds a clause to a boolean query.  Clauses may be:
    * <ul>
    * <li><code>required</code> which means that documents which <i>do not</i>
Index: src/java/org/apache/lucene/search/Query.java
===================================================================
--- src/java/org/apache/lucene/search/Query.java	(revision 153087)
+++ src/java/org/apache/lucene/search/Query.java	(working copy)
@@ -125,7 +125,9 @@
       }
     }
 
-    BooleanQuery result = new BooleanQuery();
+    boolean coordDisabled =
+      queries.length==0? false : ((BooleanQuery)queries[0]).isCoordDisabled();
+    BooleanQuery result = new BooleanQuery(coordDisabled);
     Iterator i = allClauses.iterator();
     while (i.hasNext()) {
       result.add((BooleanClause)i.next());
Index: src/java/org/apache/lucene/search/PhrasePrefixQuery.java
===================================================================
--- src/java/org/apache/lucene/search/PhrasePrefixQuery.java	(revision 153087)
+++ src/java/org/apache/lucene/search/PhrasePrefixQuery.java	(working copy)
@@ -229,7 +229,7 @@
   protected Weight createWeight(Searcher searcher) {
     if (termArrays.size() == 1) {                 // optimize one-term case
       Term[] terms = (Term[])termArrays.get(0);
-      BooleanQuery boq = new BooleanQuery();
+      BooleanQuery boq = new BooleanQuery(true);
       for (int i=0; i<terms.length; i++) {
         boq.add(new TermQuery(terms[i]), BooleanClause.Occur.SHOULD);
       }
