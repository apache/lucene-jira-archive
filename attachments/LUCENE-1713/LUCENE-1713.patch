Index: BUILD.txt
===================================================================
--- BUILD.txt	(revision 790805)
+++ BUILD.txt	(working copy)
@@ -67,7 +67,8 @@
 
 Building the Lucene distribution from the source does not require the JavaCC
 parser generator, but if you wish to regenerate any of the pre-generated
-parser pieces, you will need to install JavaCC.
+parser pieces, you will need to install JavaCC. Version 4.1 is tested to
+work correctly.
 
   http://javacc.dev.java.net
 
Index: CHANGES.txt
===================================================================
--- CHANGES.txt	(revision 790805)
+++ CHANGES.txt	(working copy)
@@ -281,6 +281,12 @@
     includes more detailed status than previously.  (Tim Smith via
     Mike McCandless)
 
+28. LUCENE-1713: Deprecated RangeQuery and RangeFilter and renamed
+    to TermRangeQuery and TermRangeFilter. TermRangeQuery is in
+    constant score rewrite mode by default. The new classes also have
+    new ctors taking field and term ranges as Strings (see also
+    LUCENE-1424).  (Uwe Schindler)
+
 Bug fixes
 
 1. LUCENE-1415: MultiPhraseQuery has incorrect hashCode() and equals()
@@ -374,7 +380,7 @@
     packaged as War file (Mark Harwood)    
 
  6. LUCENE-1424: Moved constant score query rewrite capability into
-    MultiTermQuery, allowing RangeQuery, PrefixQuery and WildcardQuery
+    MultiTermQuery, allowing TermRangeQuery, PrefixQuery and WildcardQuery
     to switch betwen constant-score rewriting or BooleanQuery
     expansion rewriting via a new setConstantScoreRewrite method.
     Deprecated ConstantScoreRangeQuery (Mark Miller via Mike
Index: contrib/collation/src/test/org/apache/lucene/collation/CollationTestBase.java
===================================================================
--- contrib/collation/src/test/org/apache/lucene/collation/CollationTestBase.java	(revision 790805)
+++ contrib/collation/src/test/org/apache/lucene/collation/CollationTestBase.java	(working copy)
@@ -29,9 +29,9 @@
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeFilter;
+import org.apache.lucene.search.TermRangeFilter;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.ConstantScoreRangeQuery;
 import org.apache.lucene.search.Searcher;
 import org.apache.lucene.search.Sort;
@@ -102,7 +102,7 @@
     result = is.search(aqp.parse("[ \u0633 TO \u0638 ]"), null, 1000).scoreDocs;
     assertEquals("The index Term should be included.", 1, result.length);
 
-    // Test RangeQuery
+    // Test TermRangeQuery
     aqp.setUseOldRangeQuery(true);
     result = is.search(aqp.parse("[ \u062F TO \u0698 ]"), null, 1000).scoreDocs;
     assertEquals("The index Term should not be included.", 0, result.length);
@@ -132,15 +132,15 @@
 
     // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
     // orders the U+0698 character before the U+0633 character, so the single
-    // index Term below should NOT be returned by a RangeFilter with a Farsi
+    // index Term below should NOT be returned by a TermRangeFilter with a Farsi
     // Collator (or an Arabic one for the case when Farsi searcher not
     // supported).
     ScoreDoc[] result = searcher.search
-      (query, new RangeFilter("content", firstBeg, firstEnd, true, true), 1).scoreDocs;
+      (query, new TermRangeFilter("content", firstBeg, firstEnd, true, true), 1).scoreDocs;
     assertEquals("The index Term should not be included.", 0, result.length);
 
     result = searcher.search
-      (query, new RangeFilter("content", secondBeg, secondEnd, true, true), 1).scoreDocs;
+      (query, new TermRangeFilter("content", secondBeg, secondEnd, true, true), 1).scoreDocs;
     assertEquals("The index Term should be included.", 1, result.length);
 
     searcher.close();
@@ -156,7 +156,7 @@
 
     // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
     // orders the U+0698 character before the U+0633 character, so the single
-    // index Term below should NOT be returned by a RangeQuery with a Farsi
+    // index Term below should NOT be returned by a TermRangeQuery with a Farsi
     // Collator (or an Arabic one for the case when Farsi is not supported).
     doc.add(new Field("content", "\u0633\u0627\u0628", 
                       Field.Store.YES, Field.Index.ANALYZED));
@@ -164,13 +164,11 @@
     writer.close();
     IndexSearcher searcher = new IndexSearcher(ramDir);
 
-    Query query = new RangeQuery(new Term("content", firstBeg),
-                                 new Term("content", firstEnd), true);
+    Query query = new TermRangeQuery("content", firstBeg, firstEnd, true, true);
     ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals("The index Term should not be included.", 0, hits.length);
 
-    query = new RangeQuery(new Term("content", secondBeg),
-                           new Term("content", secondEnd), true);
+    query = new TermRangeQuery("content", secondBeg, secondEnd, true, true);
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals("The index Term should be included.", 1, hits.length);
     searcher.close();
Index: contrib/highlighter/src/java/org/apache/lucene/search/highlight/QueryTermExtractor.java
===================================================================
--- contrib/highlighter/src/java/org/apache/lucene/search/highlight/QueryTermExtractor.java	(revision 790805)
+++ contrib/highlighter/src/java/org/apache/lucene/search/highlight/QueryTermExtractor.java	(working copy)
@@ -29,7 +29,7 @@
 
 /**
  * Utility class used to extract the terms used in a query, plus any weights.
- * This class will not find terms for MultiTermQuery, RangeQuery and PrefixQuery classes
+ * This class will not find terms for MultiTermQuery, TermRangeQuery and PrefixQuery classes
  * so the caller must pass a rewritten query (see Query.rewrite) to obtain a list of 
  * expanded terms. 
  * 
Index: contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
===================================================================
--- contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java	(revision 790805)
+++ contrib/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java	(working copy)
@@ -45,7 +45,7 @@
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.search.spans.SpanNearQuery;
@@ -145,8 +145,8 @@
         query = mtq;
       }
       String field;
-      if(mtq instanceof RangeQuery) {
-        field = ((RangeQuery)mtq).getField();
+      if(mtq instanceof TermRangeQuery) {
+        field = ((TermRangeQuery)mtq).getField();
       } else {
         field = mtq.getTerm().field();
       }
@@ -472,10 +472,10 @@
   }
   
   private MultiTermQuery copyMultiTermQuery(MultiTermQuery query) {
-    if(query instanceof RangeQuery) {
-      RangeQuery q = (RangeQuery)query;
+    if(query instanceof TermRangeQuery) {
+      TermRangeQuery q = (TermRangeQuery)query;
       q.setBoost(query.getBoost());
-      return new RangeQuery(q.getField(), q.getLowerTermText(), q.getUpperTermText(), q.includesLower(), q.includesUpper());
+      return new TermRangeQuery(q.getField(), q.getLowerTerm(), q.getUpperTerm(), q.includesLower(), q.includesUpper());
     } else if(query instanceof WildcardQuery) {
       MultiTermQuery q = new WildcardQuery(query.getTerm());
       q.setBoost(query.getBoost());
Index: contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
===================================================================
--- contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java	(revision 790805)
+++ contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java	(working copy)
@@ -59,7 +59,7 @@
 import org.apache.lucene.search.MultiSearcher;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeFilter;
+import org.apache.lucene.search.TermRangeFilter;
 import org.apache.lucene.search.Searcher;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
@@ -484,7 +484,7 @@
         numHighlights = 0;
         String queryString = FIELD_NAME + ":[kannedy TO kznnedy]";
 
-        // Need to explicitly set the QueryParser property to use RangeQuery
+        // Need to explicitly set the QueryParser property to use TermRangeQuery
         // rather
         // than RangeFilters
         QueryParser parser = new QueryParser(FIELD_NAME, new StandardAnalyzer());
@@ -701,7 +701,7 @@
 
       public void run() throws Exception {
         numHighlights = 0;
-        RangeFilter rf = new RangeFilter("contents", "john", "john", true, true);
+        TermRangeFilter rf = new TermRangeFilter("contents", "john", "john", true, true);
         SpanQuery clauses[] = { new SpanTermQuery(new Term("contents", "john")),
             new SpanTermQuery(new Term("contents", "kennedy")), };
         SpanNearQuery snq = new SpanNearQuery(clauses, 1, true);
@@ -723,7 +723,7 @@
 
       public void run() throws Exception {
         numHighlights = 0;
-        RangeFilter rf = new RangeFilter("contents", "john", "john", true, true);
+        TermRangeFilter rf = new TermRangeFilter("contents", "john", "john", true, true);
         PhraseQuery pq = new PhraseQuery();
         pq.add(new Term("contents", "john"));
         pq.add(new Term("contents", "kennedy"));
Index: contrib/miscellaneous/src/test/org/apache/lucene/misc/ChainedFilterTest.java
===================================================================
--- contrib/miscellaneous/src/test/org/apache/lucene/misc/ChainedFilterTest.java	(revision 790805)
+++ contrib/miscellaneous/src/test/org/apache/lucene/misc/ChainedFilterTest.java	(working copy)
@@ -40,7 +40,7 @@
   private IndexSearcher searcher;
   private Query query;
   // private DateFilter dateFilter;   DateFilter was deprecated and removed
-  private RangeFilter dateFilter;
+  private TermRangeFilter dateFilter;
   private QueryWrapperFilter bobFilter;
   private QueryWrapperFilter sueFilter;
 
@@ -76,7 +76,7 @@
     //Date pastTheEnd = parseDate("2099 Jan 1");
     // dateFilter = DateFilter.Before("date", pastTheEnd);
     // just treat dates as strings and select the whole range for now...
-    dateFilter = new RangeFilter("date","","ZZZZ",true,true);
+    dateFilter = new TermRangeFilter("date","","ZZZZ",true,true);
 
     bobFilter = new QueryWrapperFilter(
         new TermQuery(new Term("owner", "bob")));
Index: contrib/queries/src/test/org/apache/lucene/search/BooleanFilterTest.java
===================================================================
--- contrib/queries/src/test/org/apache/lucene/search/BooleanFilterTest.java	(revision 790805)
+++ contrib/queries/src/test/org/apache/lucene/search/BooleanFilterTest.java	(working copy)
@@ -30,7 +30,7 @@
 import org.apache.lucene.search.BooleanFilter;
 import org.apache.lucene.search.Filter;
 import org.apache.lucene.search.FilterClause;
-import org.apache.lucene.search.RangeFilter;
+import org.apache.lucene.search.TermRangeFilter;
 import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.DocIdBitSet;
 
@@ -84,7 +84,7 @@
 	
   private Filter getRangeFilter(String field,String lowerPrice, String upperPrice, boolean old)
 	{
-    Filter f = new RangeFilter(field,lowerPrice,upperPrice,true,true);
+    Filter f = new TermRangeFilter(field,lowerPrice,upperPrice,true,true);
     if (old) {
       return getOldBitSetFilter(f);
     }
Index: contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/RangeFilterBuilder.java
===================================================================
--- contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/RangeFilterBuilder.java	(revision 790805)
+++ contrib/xml-query-parser/src/java/org/apache/lucene/xmlparser/builders/RangeFilterBuilder.java	(working copy)
@@ -4,7 +4,7 @@
 package org.apache.lucene.xmlparser.builders;
 
 import org.apache.lucene.search.Filter;
-import org.apache.lucene.search.RangeFilter;
+import org.apache.lucene.search.TermRangeFilter;
 import org.apache.lucene.xmlparser.DOMUtils;
 import org.apache.lucene.xmlparser.FilterBuilder;
 import org.apache.lucene.xmlparser.ParserException;
@@ -39,7 +39,7 @@
 		String upperTerm=e.getAttribute("upperTerm");
 		boolean includeLower=DOMUtils.getAttribute(e,"includeLower",true);
 		boolean includeUpper=DOMUtils.getAttribute(e,"includeUpper",true);
-		return new RangeFilter(fieldName,lowerTerm,upperTerm,includeLower,includeUpper);
+		return new TermRangeFilter(fieldName,lowerTerm,upperTerm,includeLower,includeUpper);
 	}
 
 }
Index: src/java/org/apache/lucene/document/DateField.java
===================================================================
--- src/java/org/apache/lucene/document/DateField.java	(revision 790805)
+++ src/java/org/apache/lucene/document/DateField.java	(working copy)
@@ -18,7 +18,7 @@
  */
 
 import org.apache.lucene.search.PrefixQuery;
-import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.NumericRangeQuery; // for javadocs
 import org.apache.lucene.util.NumericUtils; // for javadocs
 
@@ -33,7 +33,7 @@
  * which makes them suitable for use as field values and search terms.
  *
  * <P>Note that this class saves dates with millisecond granularity,
- * which is bad for {@link RangeQuery} and {@link PrefixQuery}, as those
+ * which is bad for {@link TermRangeQuery} and {@link PrefixQuery}, as those
  * queries are expanded to a BooleanQuery with a potentially large number
  * of terms when searching. Thus you might want to use
  * {@link DateTools} instead.
Index: src/java/org/apache/lucene/queryParser/CharStream.java
===================================================================
--- src/java/org/apache/lucene/queryParser/CharStream.java	(revision 790805)
+++ src/java/org/apache/lucene/queryParser/CharStream.java	(working copy)
@@ -109,4 +109,4 @@
   void Done();
 
 }
-/* JavaCC - OriginalChecksum=a83909a2403f969f94d18375f9f143e4 (do not edit this line) */
+/* JavaCC - OriginalChecksum=32a89423891f765dde472f7ef0e3ef7b (do not edit this line) */
Index: src/java/org/apache/lucene/queryParser/ParseException.java
===================================================================
--- src/java/org/apache/lucene/queryParser/ParseException.java	(revision 790805)
+++ src/java/org/apache/lucene/queryParser/ParseException.java	(working copy)
@@ -195,4 +195,4 @@
    }
 
 }
-/* JavaCC - OriginalChecksum=c63b396885c4ff44d7aa48d3feae60cd (do not edit this line) */
+/* JavaCC - OriginalChecksum=c7631a240f7446940695eac31d9483ca (do not edit this line) */
Index: src/java/org/apache/lucene/queryParser/QueryParser.java
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParser.java	(revision 790805)
+++ src/java/org/apache/lucene/queryParser/QueryParser.java	(working copy)
@@ -31,7 +31,7 @@
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.util.Parameter;
@@ -174,7 +174,6 @@
     }
     catch (ParseException tme) {
       // rethrow to include the original query:
-      // rethrow to include the original query:
       ParseException e = new ParseException("Cannot parse '" +query+ "': " + tme.getMessage());
       e.initCause(tme);
       throw e;
@@ -877,22 +876,15 @@
   }
 
   /**
-   * Builds a new RangeQuery instance
+   * Builds a new TermRangeQuery instance
    * @param field Field
    * @param part1 min
    * @param part2 max
    * @param inclusive true if range is inclusive
-   * @return new RangeQuery instance
+   * @return new TermRangeQuery instance
    */
   protected Query newRangeQuery(String field, String part1, String part2, boolean inclusive) {
-    RangeQuery query;
-
-    if (constantScoreRewrite) {
-      // TODO: remove in Lucene 3.0
-      query = new ConstantScoreRangeQuery(field, part1, part2, inclusive, inclusive, rangeCollator);
-    } else {
-      query = new RangeQuery(field, part1, part2, inclusive, inclusive, rangeCollator);
-    }
+    final TermRangeQuery query = new TermRangeQuery(field, part1, part2, inclusive, inclusive, rangeCollator);
     query.setConstantScoreRewrite(constantScoreRewrite);
     return query;
   }
Index: src/java/org/apache/lucene/queryParser/QueryParser.jj
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParser.jj	(revision 790805)
+++ src/java/org/apache/lucene/queryParser/QueryParser.jj	(working copy)
@@ -55,7 +55,7 @@
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.util.Parameter;
@@ -198,13 +198,19 @@
     }
     catch (ParseException tme) {
       // rethrow to include the original query:
-      throw new ParseException("Cannot parse '" +query+ "': " + tme.getMessage());
+      ParseException e = new ParseException("Cannot parse '" +query+ "': " + tme.getMessage());
+      e.initCause(tme);
+      throw e;
     }
     catch (TokenMgrError tme) {
-      throw new ParseException("Cannot parse '" +query+ "': " + tme.getMessage());
+      ParseException e = new ParseException("Cannot parse '" +query+ "': " + tme.getMessage());
+      e.initCause(tme);
+      throw e;
     }
     catch (BooleanQuery.TooManyClauses tmc) {
-      throw new ParseException("Cannot parse '" +query+ "': too many boolean clauses");
+      ParseException e = new ParseException("Cannot parse '" +query+ "': too many boolean clauses");
+      e.initCause(tmc);
+      throw e;
     }
   }
 
@@ -894,22 +900,15 @@
   }
 
   /**
-   * Builds a new RangeQuery instance
+   * Builds a new TermRangeQuery instance
    * @param field Field
    * @param part1 min
    * @param part2 max
    * @param inclusive true if range is inclusive
-   * @return new RangeQuery instance
+   * @return new TermRangeQuery instance
    */
   protected Query newRangeQuery(String field, String part1, String part2, boolean inclusive) {
-    RangeQuery query;  
-  
-    if (constantScoreRewrite) {
-      // TODO: remove in Lucene 3.0
-      query = new ConstantScoreRangeQuery(field, part1, part2, inclusive, inclusive, rangeCollator);
-    } else {
-      query = new RangeQuery(field, part1, part2, inclusive, inclusive, rangeCollator);
-    }
+    final TermRangeQuery query = new TermRangeQuery(field, part1, part2, inclusive, inclusive, rangeCollator);
     query.setConstantScoreRewrite(constantScoreRewrite);
     return query;
   }
Index: src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java	(revision 790805)
+++ src/java/org/apache/lucene/queryParser/QueryParserTokenManager.java	(working copy)
@@ -29,7 +29,7 @@
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.util.Parameter;
Index: src/java/org/apache/lucene/queryParser/Token.java
===================================================================
--- src/java/org/apache/lucene/queryParser/Token.java	(revision 790805)
+++ src/java/org/apache/lucene/queryParser/Token.java	(working copy)
@@ -121,4 +121,4 @@
   }
 
 }
-/* JavaCC - OriginalChecksum=37b1923f964a5a434f5ea3d6952ff200 (do not edit this line) */
+/* JavaCC - OriginalChecksum=c147cc166a7cf8812c7c39bc8c5eb868 (do not edit this line) */
Index: src/java/org/apache/lucene/queryParser/TokenMgrError.java
===================================================================
--- src/java/org/apache/lucene/queryParser/TokenMgrError.java	(revision 790805)
+++ src/java/org/apache/lucene/queryParser/TokenMgrError.java	(working copy)
@@ -137,4 +137,4 @@
       this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
    }
 }
-/* JavaCC - OriginalChecksum=55cddb2336a66b376c0bb59d916b326d (do not edit this line) */
+/* JavaCC - OriginalChecksum=186d5bcc64733844c7daab5ad5a6e349 (do not edit this line) */
Index: src/java/org/apache/lucene/search/BooleanQuery.java
===================================================================
--- src/java/org/apache/lucene/search/BooleanQuery.java	(revision 790805)
+++ src/java/org/apache/lucene/search/BooleanQuery.java	(working copy)
@@ -34,7 +34,7 @@
 
   /** Thrown when an attempt is made to add more than {@link
    * #getMaxClauseCount()} clauses. This typically happens if
-   * a PrefixQuery, FuzzyQuery, WildcardQuery, or RangeQuery 
+   * a PrefixQuery, FuzzyQuery, WildcardQuery, or TermRangeQuery 
    * is expanded to many terms during search. 
    */
   public static class TooManyClauses extends RuntimeException {
@@ -58,8 +58,8 @@
    * so this parameter indirectly controls the maximum buffer requirements for
    * query search.
    * <p>When this parameter becomes a bottleneck for a Query one can use a
-   * Filter. For example instead of a {@link RangeQuery} one can use a
-   * {@link RangeFilter}.
+   * Filter. For example instead of a {@link TermRangeQuery} one can use a
+   * {@link TermRangeFilter}.
    * <p>Normally the buffers are allocated by the JVM. When using for example
    * {@link org.apache.lucene.store.MMapDirectory} the buffering is left to
    * the operating system.
Index: src/java/org/apache/lucene/search/ConstantScoreRangeQuery.java
===================================================================
--- src/java/org/apache/lucene/search/ConstantScoreRangeQuery.java	(revision 790805)
+++ src/java/org/apache/lucene/search/ConstantScoreRangeQuery.java	(working copy)
@@ -29,31 +29,32 @@
  * Either or both endpoints may be open.  Open endpoints may not be exclusive
  * (you can't select all but the first or last term without explicitly specifying the term to exclude.)
  *
- * @deprecated Please use {@link RangeQuery}, and call
- * {@link RangeQuery#setConstantScoreRewrite}, instead.
+ * @deprecated Use {@link TermRangeQuery} for term ranges or
+ * {@link NumericRangeQuery} for numeric ranges instead.
+ * This class will be removed in Lucene 3.0.
  * @version $Id$
  */
-public class ConstantScoreRangeQuery extends RangeQuery
+public class ConstantScoreRangeQuery extends TermRangeQuery
 {
 
   public ConstantScoreRangeQuery(String fieldName, String lowerVal, String upperVal, boolean includeLower, boolean includeUpper)
   {
     super(fieldName, lowerVal, upperVal, includeLower, includeUpper);
-    this.constantScoreRewrite = true;
+    setConstantScoreRewrite(true);
   }
 
   public ConstantScoreRangeQuery(String fieldName, String lowerVal,
                                  String upperVal, boolean includeLower,
                                  boolean includeUpper, Collator collator) {
     super(fieldName, lowerVal, upperVal, includeLower, includeUpper, collator);
-    this.constantScoreRewrite = true;
+    setConstantScoreRewrite(true);
   }
 
   public String getLowerVal() {
-    return getLowerTermText();
+    return getLowerTerm();
   }
 
   public String getUpperVal() {
-    return getUpperTermText();
+    return getUpperTerm();
   }
 }
Index: src/java/org/apache/lucene/search/FieldCacheRangeFilter.java
===================================================================
--- src/java/org/apache/lucene/search/FieldCacheRangeFilter.java	(revision 790805)
+++ src/java/org/apache/lucene/search/FieldCacheRangeFilter.java	(working copy)
@@ -31,9 +31,9 @@
  * even if the range itself changes. 
  * 
  * <p>This means that FieldCacheRangeFilter is much faster (sometimes more than 100x as fast) 
- * as building a {@link RangeFilter} (or {@link ConstantScoreRangeQuery} on a {@link RangeFilter})
+ * as building a {@link TermRangeFilter} (or {@link ConstantScoreRangeQuery} on a {@link TermRangeFilter})
  * for each query, if using a {@link #newStringRange}. However, if the range never changes it
- * is slower (around 2x as slow) than building a CachingWrapperFilter on top of a single RangeFilter.
+ * is slower (around 2x as slow) than building a CachingWrapperFilter on top of a single TermRangeFilter.
  *
  * For numeric data types, this filter may be significantly faster than {@link NumericRangeFilter}.
  * Furthermore, it does not need the numeric values encoded by {@link NumericField}. But
Index: src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java
===================================================================
--- src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java	(revision 790805)
+++ src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java	(working copy)
@@ -34,7 +34,7 @@
  * be used by itself. Normally you subclass it to provide a Filter
  * counterpart for a {@link MultiTermQuery} subclass.
  * <P>
- * For example, {@link RangeFilter} and {@link PrefixFilter} extend
+ * For example, {@link TermRangeFilter} and {@link PrefixFilter} extend
  * <code>MultiTermQueryWrapperFilter</code>.
  * This class also provides the functionality behind
  * {@link MultiTermQuery#getFilter}, this is why it is not abstract.
Index: src/java/org/apache/lucene/search/package.html
===================================================================
--- src/java/org/apache/lucene/search/package.html	(revision 790805)
+++ src/java/org/apache/lucene/search/package.html	(working copy)
@@ -138,11 +138,11 @@
 </p>
 
 <h4>
-    <a href="RangeQuery.html">RangeQuery</a>
+    <a href="TermRangeQuery.html">TermRangeQuery</a>
 </h4>
 
 <p>The
-    <a href="RangeQuery.html">RangeQuery</a>
+    <a href="TermRangeQuery.html">TermRangeQuery</a>
     matches all documents that occur in the
     exclusive range of a lower
     <a href="../index/Term.html">Term</a>
Index: src/java/org/apache/lucene/search/Query.java
===================================================================
--- src/java/org/apache/lucene/search/Query.java	(revision 790805)
+++ src/java/org/apache/lucene/search/Query.java	(working copy)
@@ -36,7 +36,8 @@
     <li> {@link PrefixQuery}
     <li> {@link MultiPhraseQuery}
     <li> {@link FuzzyQuery}
-    <li> {@link RangeQuery}
+    <li> {@link TermRangeQuery}
+    <li> {@link NumericRangeQuery}
     <li> {@link org.apache.lucene.search.spans.SpanQuery}
     </ul>
     <p>A parser for queries is contained in:
@@ -146,7 +147,7 @@
    * correspondence with queries). This is an optimization of the OR of
    * all queries. We handle the common optimization cases of equal
    * queries and overlapping clauses of boolean OR queries (as generated
-   * by MultiTermQuery.rewrite() and RangeQuery.rewrite()).
+   * by MultiTermQuery.rewrite()).
    * Be careful overriding this method as queries[0] determines which
    * method will be called and is not necessarily of the same type as
    * the other queries.
Index: src/java/org/apache/lucene/search/QueryWrapperFilter.java
===================================================================
--- src/java/org/apache/lucene/search/QueryWrapperFilter.java	(revision 790805)
+++ src/java/org/apache/lucene/search/QueryWrapperFilter.java	(working copy)
@@ -26,10 +26,10 @@
  * Constrains search results to only match those which also match a provided
  * query.  
  *
- * <p> This could be used, for example, with a {@link RangeQuery} on a suitably
+ * <p> This could be used, for example, with a {@link TermRangeQuery} on a suitably
  * formatted date field to implement date filtering.  One could re-use a single
  * QueryFilter that matches, e.g., only documents modified within the last
- * week.  The QueryFilter and RangeQuery would only need to be reconstructed
+ * week.  The QueryFilter and TermRangeQuery would only need to be reconstructed
  * once per day.
  *
  * @version $Id:$
Index: src/java/org/apache/lucene/search/RangeFilter.java
===================================================================
--- src/java/org/apache/lucene/search/RangeFilter.java	(revision 790805)
+++ src/java/org/apache/lucene/search/RangeFilter.java	(working copy)
@@ -1,88 +0,0 @@
-package org.apache.lucene.search;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.text.Collator;
-
-/**
- * A Filter that restricts search results to a range of values in a given
- * field.
- *
- * <p>This filter matches the documents looking for terms that fall into the
- * supplied range according to {@link String#compareTo(String)}. It is not intended
- * for numerical ranges, use {@link NumericRangeFilter} instead.
- *
- * <p>If you construct a large number of range filters with different ranges but on the 
- * same field, {@link FieldCacheRangeFilter} may have significantly better performance. 
- */
-public class RangeFilter extends MultiTermQueryWrapperFilter {
-    
-  /**
-     * @param fieldName The field this range applies to
-     * @param lowerTerm The lower bound on this range
-     * @param upperTerm The upper bound on this range
-     * @param includeLower Does this range include the lower bound?
-     * @param includeUpper Does this range include the upper bound?
-     * @throws IllegalArgumentException if both terms are null or if
-     *  lowerTerm is null and includeLower is true (similar for upperTerm
-     *  and includeUpper)
-     */
-    public RangeFilter(String fieldName, String lowerTerm, String upperTerm,
-                       boolean includeLower, boolean includeUpper) {
-        super(new RangeQuery(fieldName, lowerTerm, upperTerm, includeLower, includeUpper));
-    }
-
-    /**
-     * <strong>WARNING:</strong> Using this constructor and supplying a non-null
-     * value in the <code>collator</code> parameter will cause every single 
-     * index Term in the Field referenced by lowerTerm and/or upperTerm to be
-     * examined.  Depending on the number of index Terms in this Field, the 
-     * operation could be very slow.
-     *
-     * @param lowerTerm The lower bound on this range
-     * @param upperTerm The upper bound on this range
-     * @param includeLower Does this range include the lower bound?
-     * @param includeUpper Does this range include the upper bound?
-     * @param collator The collator to use when determining range inclusion; set
-     *  to null to use Unicode code point ordering instead of collation.
-     * @throws IllegalArgumentException if both terms are null or if
-     *  lowerTerm is null and includeLower is true (similar for upperTerm
-     *  and includeUpper)
-     */
-    public RangeFilter(String fieldName, String lowerTerm, String upperTerm,
-                       boolean includeLower, boolean includeUpper,
-                       Collator collator) {
-        super(new RangeQuery(fieldName, lowerTerm, upperTerm, includeLower, includeUpper, collator));
-    }
-
-    /**
-     * Constructs a filter for field <code>fieldName</code> matching
-     * less than or equal to <code>upperTerm</code>.
-     */
-    public static RangeFilter Less(String fieldName, String upperTerm) {
-        return new RangeFilter(fieldName, null, upperTerm, false, true);
-    }
-
-    /**
-     * Constructs a filter for field <code>fieldName</code> matching
-     * greater than or equal to <code>lowerTerm</code>.
-     */
-    public static RangeFilter More(String fieldName, String lowerTerm) {
-        return new RangeFilter(fieldName, lowerTerm, null, true, false);
-    }
-}
Index: src/java/org/apache/lucene/search/RangeQuery.java
===================================================================
--- src/java/org/apache/lucene/search/RangeQuery.java	(revision 790805)
+++ src/java/org/apache/lucene/search/RangeQuery.java	(working copy)
@@ -1,244 +0,0 @@
-package org.apache.lucene.search;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.text.Collator;
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexReader;
-
-/**
- * A Query that matches documents within an exclusive range.
- *
- * <p>This query matches the documents looking for terms that fall into the
- * supplied range according to {@link String#compareTo(String)}. It is not intended
- * for numerical ranges, use {@link NumericRangeQuery} instead.
- *
- * <p>See {@link MultiTermQuery#setConstantScoreRewrite} for the tradeoffs between
- * enabling and disabling constantScoreRewrite mode.
- */
-
-public class RangeQuery extends MultiTermQuery {
-  private Term lowerTerm;
-  private Term upperTerm;
-  private Collator collator;
-  private String field;
-  private boolean includeLower;
-  private boolean includeUpper;
-
-
-  /**
-   * Constructs a query selecting all terms greater/equal than <code>lowerTerm</code>
-   * but less/equal than <code>upperTerm</code>. 
-   * 
-   * <p>
-   * If an endpoint is null, it is said 
-   * to be "open". Either or both endpoints may be open.  Open endpoints may not 
-   * be exclusive (you can't select all but the first or last term without 
-   * explicitly specifying the term to exclude.)
-   * 
-   * @param field The field that holds both lower and upper terms.
-   * @param lowerTerm
-   *          The term text at the lower end of the range
-   * @param upperTerm
-   *          The term text at the upper end of the range
-   * @param includeLower
-   *          If true, the <code>lowerTerm</code> is
-   *          included in the range.
-   * @param includeUpper
-   *          If true, the <code>upperTerm</code> is
-   *          included in the range.
-   */
-  public RangeQuery(String field, String lowerTerm, String upperTerm, boolean includeLower, boolean includeUpper) {
-    init(new Term(field, lowerTerm), new Term(field, upperTerm), includeLower, includeUpper, null);
-  }
-
-  /** Constructs a query selecting all terms greater/equal than
-   * <code>lowerTerm</code> but less/equal than <code>upperTerm</code>.
-   * <p>
-   * If an endpoint is null, it is said 
-   * to be "open". Either or both endpoints may be open.  Open endpoints may not 
-   * be exclusive (you can't select all but the first or last term without 
-   * explicitly specifying the term to exclude.)
-   * <p>
-   * If <code>collator</code> is not null, it will be used to decide whether
-   * index terms are within the given range, rather than using the Unicode code
-   * point order in which index terms are stored.
-   * <p>
-   * <strong>WARNING:</strong> Using this constructor and supplying a non-null
-   * value in the <code>collator</code> parameter will cause every single 
-   * index Term in the Field referenced by lowerTerm and/or upperTerm to be
-   * examined.  Depending on the number of index Terms in this Field, the 
-   * operation could be very slow.
-   *
-   * @param lowerTerm The Term text at the lower end of the range
-   * @param upperTerm The Term text at the upper end of the range
-   * @param includeLower
-   *          If true, the <code>lowerTerm</code> is
-   *          included in the range.
-   * @param includeUpper
-   *          If true, the <code>upperTerm</code> is
-   *          included in the range.
-   * @param collator The collator to use to collate index Terms, to determine
-   *  their membership in the range bounded by <code>lowerTerm</code> and
-   *  <code>upperTerm</code>.
-   */
-  public RangeQuery(String field, String lowerTerm, String upperTerm, boolean includeLower, boolean includeUpper,
-                    Collator collator) {
-    init(new Term(field, lowerTerm), new Term(field,upperTerm), includeLower, includeUpper, collator);
-  }
-
-  /** @deprecated Please use {@link #RangeQuery(String,
-   *  String, String, boolean, boolean, Collator)} instead */
-  public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive,
-                    Collator collator) {
-    init(lowerTerm, upperTerm, inclusive, inclusive, collator);
-  }
-  
-  /** @deprecated Please use {@link #RangeQuery(String,
-   *  String, String, boolean, boolean)} instead */
-  public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive) {
-    init(lowerTerm, upperTerm, inclusive, inclusive, null);
-  }
-
-  private void init(Term lowerTerm, Term upperTerm, boolean includeLower, boolean includeUpper, Collator collator) {
-    if (lowerTerm == null && upperTerm == null)
-      throw new IllegalArgumentException("At least one term must be non-null");
-    if (lowerTerm != null && upperTerm != null && lowerTerm.field() != upperTerm.field())
-      throw new IllegalArgumentException("Both terms must be for the same field");
-
-    if (lowerTerm == null)
-      this.field = upperTerm.field();
-    else
-      this.field = lowerTerm.field();
-    this.lowerTerm = lowerTerm;
-    this.upperTerm = upperTerm;
-    this.includeLower = includeLower;
-    this.includeUpper = includeUpper;
-    this.collator = collator;
-  }
-  
-  /** Returns the field name for this query */
-  public String getField() {
-    return field;
-  }
-
-  /** Returns the lower term of this range query.
-   *  @deprecated Use {@link #getLowerTermText} instead. */
-  public Term getLowerTerm() { return lowerTerm; }
-
-  /** Returns the upper term of this range query.
-   *  @deprecated Use {@link #getUpperTermText} instead. */
-  public Term getUpperTerm() { return upperTerm; }
-  
-  /** Returns the lower value of this range query */
-  public String getLowerTermText() { return lowerTerm == null ? null : lowerTerm.text(); }
-
-  /** Returns the upper value of this range query */
-  public String getUpperTermText() { return upperTerm == null ? null : upperTerm.text(); }
-  
-  /** Returns <code>true</code> if the lower endpoint is inclusive */
-  public boolean includesLower() { return includeLower; }
-  
-  /** Returns <code>true</code> if the upper endpoint is inclusive */
-  public boolean includesUpper() { return includeUpper; }
-
-  /** Returns <code>true</code> if the range query is inclusive 
-   *  @deprecated Use {@link #includesLower}, {@link #includesUpper}  instead. 
-   */
-  public boolean isInclusive() { return includeUpper && includeLower; }
-
-  /** Returns the collator used to determine range inclusion, if any. */
-  public Collator getCollator() { return collator; }
-  
-  protected FilteredTermEnum getEnum(IndexReader reader) throws IOException {
-    //TODO: when the deprecated 'Term' constructors are removed we can remove these null checks
-    return new RangeTermEnum(reader, collator, getField(), lowerTerm == null ? null : lowerTerm.text(),
-        upperTerm == null ? null : upperTerm.text(), includeLower, includeUpper);
-  }
-
-  /** Prints a user-readable version of this query. */
-  public String toString(String field) {
-      StringBuffer buffer = new StringBuffer();
-      if (!getField().equals(field)) {
-          buffer.append(getField());
-          buffer.append(":");
-      }
-      buffer.append(includeLower ? '[' : '{');
-      buffer.append(lowerTerm != null ? lowerTerm.text() : "*");
-      buffer.append(" TO ");
-      buffer.append(upperTerm != null ? upperTerm.text() : "*");
-      buffer.append(includeUpper ? ']' : '}');
-      if (getBoost() != 1.0f) {
-          buffer.append("^");
-          buffer.append(Float.toString(getBoost()));
-      }
-      return buffer.toString();
-  }
-
-  //@Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = super.hashCode();
-    result = prime * result + ((collator == null) ? 0 : collator.hashCode());
-    result = prime * result + ((field == null) ? 0 : field.hashCode());
-    result = prime * result + (includeLower ? 1231 : 1237);
-    result = prime * result + (includeUpper ? 1231 : 1237);
-    result = prime * result + ((lowerTerm == null) ? 0 : lowerTerm.hashCode());
-    result = prime * result + ((upperTerm == null) ? 0 : upperTerm.hashCode());
-    return result;
-  }
-
-  //@Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (!super.equals(obj))
-      return false;
-    if (getClass() != obj.getClass())
-      return false;
-    RangeQuery other = (RangeQuery) obj;
-    if (collator == null) {
-      if (other.collator != null)
-        return false;
-    } else if (!collator.equals(other.collator))
-      return false;
-    if (field == null) {
-      if (other.field != null)
-        return false;
-    } else if (!field.equals(other.field))
-      return false;
-    if (includeLower != other.includeLower)
-      return false;
-    if (includeUpper != other.includeUpper)
-      return false;
-    if (lowerTerm == null) {
-      if (other.lowerTerm != null)
-        return false;
-    } else if (!lowerTerm.equals(other.lowerTerm))
-      return false;
-    if (upperTerm == null) {
-      if (other.upperTerm != null)
-        return false;
-    } else if (!upperTerm.equals(other.upperTerm))
-      return false;
-    return true;
-  }
-
-}
Index: src/java/org/apache/lucene/search/RangeTermEnum.java
===================================================================
--- src/java/org/apache/lucene/search/RangeTermEnum.java	(revision 790805)
+++ src/java/org/apache/lucene/search/RangeTermEnum.java	(working copy)
@@ -1,149 +0,0 @@
-package org.apache.lucene.search;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.text.Collator;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-
-/**
- * Subclass of FilteredTermEnum for enumerating all terms that match the
- * specified range parameters.
- * <p>
- * Term enumerations are always ordered by Term.compareTo().  Each term in
- * the enumeration is greater than all that precede it.
- */
-public class RangeTermEnum extends FilteredTermEnum {
-
-  private Collator collator = null;
-  private boolean endEnum = false;
-  private String field;
-  private String upperTermText;
-  private String lowerTermText;
-  private boolean includeLower;
-  private boolean includeUpper;
-
-  /**
-   * Enumerates all terms greater/equal than <code>lowerTerm</code>
-   * but less/equal than <code>upperTerm</code>. 
-   * 
-   * If an endpoint is null, it is said to be "open". Either or both 
-   * endpoints may be open.  Open endpoints may not be exclusive 
-   * (you can't select all but the first or last term without 
-   * explicitly specifying the term to exclude.)
-   * 
-   * @param reader
-   * @param collator
-   *          The collator to use to collate index Terms, to determine their
-   *          membership in the range bounded by <code>lowerTerm</code> and
-   *          <code>upperTerm</code>.
-   * @param field
-   *          An interned field that holds both lower and upper terms.
-   * @param lowerTermText
-   *          The term text at the lower end of the range
-   * @param upperTermText
-   *          The term text at the upper end of the range
-   * @param includeLower
-   *          If true, the <code>lowerTerm</code> is included in the range.
-   * @param includeUpper
-   *          If true, the <code>upperTerm</code> is included in the range.
-   * 
-   * @throws IOException
-   */
-  public RangeTermEnum(IndexReader reader, Collator collator, String field,
-      String lowerTermText, String upperTermText, boolean includeLower, boolean includeUpper) throws IOException {
-    this.collator = collator;
-    this.upperTermText = upperTermText;
-    this.lowerTermText = lowerTermText;
-    this.includeLower = includeLower;
-    this.includeUpper = includeUpper;
-    this.field = field;
-    
-    // do a little bit of normalization...
-    // open ended range queries should always be inclusive.
-    if (this.lowerTermText == null) {
-      this.lowerTermText = "";
-      this.includeLower = true;
-    }
-    
-    if (this.upperTermText == null) {
-      this.includeUpper = true;
-    }
-
-    String startTermText = collator == null ? this.lowerTermText : "";
-    setEnum(reader.terms(new Term(this.field, startTermText)));
-  }
-
-  public float difference() {
-    return 1.0f;
-  }
-
-  protected boolean endEnum() {
-    return endEnum;
-  }
-
-  protected boolean termCompare(Term term) {
-    if (collator == null) {
-      // Use Unicode code point ordering
-      boolean checkLower = false;
-      if (!includeLower) // make adjustments to set to exclusive
-        checkLower = true;
-      if (term != null && term.field() == field) { // interned comparison
-        if (!checkLower || null==lowerTermText || term.text().compareTo(lowerTermText) > 0) {
-          checkLower = false;
-          if (upperTermText != null) {
-            int compare = upperTermText.compareTo(term.text());
-            /*
-             * if beyond the upper term, or is exclusive and this is equal to
-             * the upper term, break out
-             */
-            if ((compare < 0) ||
-                (!includeUpper && compare==0)) {
-              endEnum = true;
-              return false;
-            }
-          }
-          return true;
-        }
-      } else {
-        // break
-        endEnum = true;
-        return false;
-      }
-      return false;
-    } else {
-      if (term != null && term.field() == field) { // interned comparison
-        if ((lowerTermText == null
-            || (includeLower
-                ? collator.compare(term.text(), lowerTermText) >= 0
-                : collator.compare(term.text(), lowerTermText) > 0))
-           && (upperTermText == null
-               || (includeUpper
-                   ? collator.compare(term.text(), upperTermText) <= 0
-                   : collator.compare(term.text(), upperTermText) < 0))) {
-          return true;
-        }
-        return false;
-      }
-      endEnum = true;
-      return false;
-    }
-  }
-}
Index: src/java/org/apache/lucene/search/TermRangeFilter.java
===================================================================
--- src/java/org/apache/lucene/search/TermRangeFilter.java	(revision 790472)
+++ src/java/org/apache/lucene/search/TermRangeFilter.java	(working copy)
@@ -30,59 +30,59 @@
  * <p>If you construct a large number of range filters with different ranges but on the 
  * same field, {@link FieldCacheRangeFilter} may have significantly better performance. 
  */
-public class RangeFilter extends MultiTermQueryWrapperFilter {
+public class TermRangeFilter extends MultiTermQueryWrapperFilter {
     
   /**
-     * @param fieldName The field this range applies to
-     * @param lowerTerm The lower bound on this range
-     * @param upperTerm The upper bound on this range
-     * @param includeLower Does this range include the lower bound?
-     * @param includeUpper Does this range include the upper bound?
-     * @throws IllegalArgumentException if both terms are null or if
-     *  lowerTerm is null and includeLower is true (similar for upperTerm
-     *  and includeUpper)
-     */
-    public RangeFilter(String fieldName, String lowerTerm, String upperTerm,
-                       boolean includeLower, boolean includeUpper) {
-        super(new RangeQuery(fieldName, lowerTerm, upperTerm, includeLower, includeUpper));
-    }
+   * @param fieldName The field this range applies to
+   * @param lowerTerm The lower bound on this range
+   * @param upperTerm The upper bound on this range
+   * @param includeLower Does this range include the lower bound?
+   * @param includeUpper Does this range include the upper bound?
+   * @throws IllegalArgumentException if both terms are null or if
+   *  lowerTerm is null and includeLower is true (similar for upperTerm
+   *  and includeUpper)
+   */
+  public TermRangeFilter(String fieldName, String lowerTerm, String upperTerm,
+                     boolean includeLower, boolean includeUpper) {
+      super(new TermRangeQuery(fieldName, lowerTerm, upperTerm, includeLower, includeUpper));
+  }
 
-    /**
-     * <strong>WARNING:</strong> Using this constructor and supplying a non-null
-     * value in the <code>collator</code> parameter will cause every single 
-     * index Term in the Field referenced by lowerTerm and/or upperTerm to be
-     * examined.  Depending on the number of index Terms in this Field, the 
-     * operation could be very slow.
-     *
-     * @param lowerTerm The lower bound on this range
-     * @param upperTerm The upper bound on this range
-     * @param includeLower Does this range include the lower bound?
-     * @param includeUpper Does this range include the upper bound?
-     * @param collator The collator to use when determining range inclusion; set
-     *  to null to use Unicode code point ordering instead of collation.
-     * @throws IllegalArgumentException if both terms are null or if
-     *  lowerTerm is null and includeLower is true (similar for upperTerm
-     *  and includeUpper)
-     */
-    public RangeFilter(String fieldName, String lowerTerm, String upperTerm,
-                       boolean includeLower, boolean includeUpper,
-                       Collator collator) {
-        super(new RangeQuery(fieldName, lowerTerm, upperTerm, includeLower, includeUpper, collator));
-    }
+  /**
+   * <strong>WARNING:</strong> Using this constructor and supplying a non-null
+   * value in the <code>collator</code> parameter will cause every single 
+   * index Term in the Field referenced by lowerTerm and/or upperTerm to be
+   * examined.  Depending on the number of index Terms in this Field, the 
+   * operation could be very slow.
+   *
+   * @param lowerTerm The lower bound on this range
+   * @param upperTerm The upper bound on this range
+   * @param includeLower Does this range include the lower bound?
+   * @param includeUpper Does this range include the upper bound?
+   * @param collator The collator to use when determining range inclusion; set
+   *  to null to use Unicode code point ordering instead of collation.
+   * @throws IllegalArgumentException if both terms are null or if
+   *  lowerTerm is null and includeLower is true (similar for upperTerm
+   *  and includeUpper)
+   */
+  public TermRangeFilter(String fieldName, String lowerTerm, String upperTerm,
+                     boolean includeLower, boolean includeUpper,
+                     Collator collator) {
+      super(new TermRangeQuery(fieldName, lowerTerm, upperTerm, includeLower, includeUpper, collator));
+  }
 
-    /**
-     * Constructs a filter for field <code>fieldName</code> matching
-     * less than or equal to <code>upperTerm</code>.
-     */
-    public static RangeFilter Less(String fieldName, String upperTerm) {
-        return new RangeFilter(fieldName, null, upperTerm, false, true);
-    }
+  /**
+   * Constructs a filter for field <code>fieldName</code> matching
+   * less than or equal to <code>upperTerm</code>.
+   */
+  public static TermRangeFilter Less(String fieldName, String upperTerm) {
+      return new TermRangeFilter(fieldName, null, upperTerm, false, true);
+  }
 
-    /**
-     * Constructs a filter for field <code>fieldName</code> matching
-     * greater than or equal to <code>lowerTerm</code>.
-     */
-    public static RangeFilter More(String fieldName, String lowerTerm) {
-        return new RangeFilter(fieldName, lowerTerm, null, true, false);
-    }
+  /**
+   * Constructs a filter for field <code>fieldName</code> matching
+   * greater than or equal to <code>lowerTerm</code>.
+   */
+  public static TermRangeFilter More(String fieldName, String lowerTerm) {
+      return new TermRangeFilter(fieldName, lowerTerm, null, true, false);
+  }
 }
Index: src/java/org/apache/lucene/search/TermRangeQuery.java
===================================================================
--- src/java/org/apache/lucene/search/TermRangeQuery.java	(revision 790472)
+++ src/java/org/apache/lucene/search/TermRangeQuery.java	(working copy)
@@ -22,21 +22,23 @@
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.util.ToStringUtils;
 
 /**
- * A Query that matches documents within an exclusive range.
+ * A Query that matches documents within an exclusive range of terms.
  *
  * <p>This query matches the documents looking for terms that fall into the
  * supplied range according to {@link String#compareTo(String)}. It is not intended
  * for numerical ranges, use {@link NumericRangeQuery} instead.
  *
- * <p>See {@link MultiTermQuery#setConstantScoreRewrite} for the tradeoffs between
+ * <p>This query is in constant score mode per default.
+ * See {@link MultiTermQuery#setConstantScoreRewrite} for the tradeoffs between
  * enabling and disabling constantScoreRewrite mode.
  */
 
-public class RangeQuery extends MultiTermQuery {
-  private Term lowerTerm;
-  private Term upperTerm;
+public class TermRangeQuery extends MultiTermQuery {
+  private String lowerTerm;
+  private String upperTerm;
   private Collator collator;
   private String field;
   private boolean includeLower;
@@ -65,8 +67,8 @@
    *          If true, the <code>upperTerm</code> is
    *          included in the range.
    */
-  public RangeQuery(String field, String lowerTerm, String upperTerm, boolean includeLower, boolean includeUpper) {
-    init(new Term(field, lowerTerm), new Term(field, upperTerm), includeLower, includeUpper, null);
+  public TermRangeQuery(String field, String lowerTerm, String upperTerm, boolean includeLower, boolean includeUpper) {
+    this(field, lowerTerm, upperTerm, includeLower, includeUpper, null);
   }
 
   /** Constructs a query selecting all terms greater/equal than
@@ -99,59 +101,27 @@
    *  their membership in the range bounded by <code>lowerTerm</code> and
    *  <code>upperTerm</code>.
    */
-  public RangeQuery(String field, String lowerTerm, String upperTerm, boolean includeLower, boolean includeUpper,
+  public TermRangeQuery(String field, String lowerTerm, String upperTerm, boolean includeLower, boolean includeUpper,
                     Collator collator) {
-    init(new Term(field, lowerTerm), new Term(field,upperTerm), includeLower, includeUpper, collator);
-  }
-
-  /** @deprecated Please use {@link #RangeQuery(String,
-   *  String, String, boolean, boolean, Collator)} instead */
-  public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive,
-                    Collator collator) {
-    init(lowerTerm, upperTerm, inclusive, inclusive, collator);
-  }
-  
-  /** @deprecated Please use {@link #RangeQuery(String,
-   *  String, String, boolean, boolean)} instead */
-  public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive) {
-    init(lowerTerm, upperTerm, inclusive, inclusive, null);
-  }
-
-  private void init(Term lowerTerm, Term upperTerm, boolean includeLower, boolean includeUpper, Collator collator) {
-    if (lowerTerm == null && upperTerm == null)
-      throw new IllegalArgumentException("At least one term must be non-null");
-    if (lowerTerm != null && upperTerm != null && lowerTerm.field() != upperTerm.field())
-      throw new IllegalArgumentException("Both terms must be for the same field");
-
-    if (lowerTerm == null)
-      this.field = upperTerm.field();
-    else
-      this.field = lowerTerm.field();
+    this.field = field;
     this.lowerTerm = lowerTerm;
     this.upperTerm = upperTerm;
     this.includeLower = includeLower;
     this.includeUpper = includeUpper;
     this.collator = collator;
+    setConstantScoreRewrite(true);
   }
-  
+
   /** Returns the field name for this query */
   public String getField() {
     return field;
   }
-
-  /** Returns the lower term of this range query.
-   *  @deprecated Use {@link #getLowerTermText} instead. */
-  public Term getLowerTerm() { return lowerTerm; }
-
-  /** Returns the upper term of this range query.
-   *  @deprecated Use {@link #getUpperTermText} instead. */
-  public Term getUpperTerm() { return upperTerm; }
   
   /** Returns the lower value of this range query */
-  public String getLowerTermText() { return lowerTerm == null ? null : lowerTerm.text(); }
+  public String getLowerTerm() { return lowerTerm; }
 
   /** Returns the upper value of this range query */
-  public String getUpperTermText() { return upperTerm == null ? null : upperTerm.text(); }
+  public String getUpperTerm() { return upperTerm; }
   
   /** Returns <code>true</code> if the lower endpoint is inclusive */
   public boolean includesLower() { return includeLower; }
@@ -159,18 +129,12 @@
   /** Returns <code>true</code> if the upper endpoint is inclusive */
   public boolean includesUpper() { return includeUpper; }
 
-  /** Returns <code>true</code> if the range query is inclusive 
-   *  @deprecated Use {@link #includesLower}, {@link #includesUpper}  instead. 
-   */
-  public boolean isInclusive() { return includeUpper && includeLower; }
-
   /** Returns the collator used to determine range inclusion, if any. */
   public Collator getCollator() { return collator; }
   
   protected FilteredTermEnum getEnum(IndexReader reader) throws IOException {
-    //TODO: when the deprecated 'Term' constructors are removed we can remove these null checks
-    return new RangeTermEnum(reader, collator, getField(), lowerTerm == null ? null : lowerTerm.text(),
-        upperTerm == null ? null : upperTerm.text(), includeLower, includeUpper);
+    return new TermRangeTermEnum(reader, collator, field, lowerTerm,
+        upperTerm, includeLower, includeUpper);
   }
 
   /** Prints a user-readable version of this query. */
@@ -181,14 +145,11 @@
           buffer.append(":");
       }
       buffer.append(includeLower ? '[' : '{');
-      buffer.append(lowerTerm != null ? lowerTerm.text() : "*");
+      buffer.append(lowerTerm != null ? lowerTerm : "*");
       buffer.append(" TO ");
-      buffer.append(upperTerm != null ? upperTerm.text() : "*");
+      buffer.append(upperTerm != null ? upperTerm : "*");
       buffer.append(includeUpper ? ']' : '}');
-      if (getBoost() != 1.0f) {
-          buffer.append("^");
-          buffer.append(Float.toString(getBoost()));
-      }
+      buffer.append(ToStringUtils.boost(getBoost()));
       return buffer.toString();
   }
 
@@ -213,7 +174,7 @@
       return false;
     if (getClass() != obj.getClass())
       return false;
-    RangeQuery other = (RangeQuery) obj;
+    TermRangeQuery other = (TermRangeQuery) obj;
     if (collator == null) {
       if (other.collator != null)
         return false;
Index: src/java/org/apache/lucene/search/TermRangeTermEnum.java
===================================================================
--- src/java/org/apache/lucene/search/TermRangeTermEnum.java	(revision 790472)
+++ src/java/org/apache/lucene/search/TermRangeTermEnum.java	(working copy)
@@ -1,5 +1,22 @@
 package org.apache.lucene.search;
 
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 import java.io.IOException;
 import java.text.Collator;
 
@@ -13,7 +30,7 @@
  * Term enumerations are always ordered by Term.compareTo().  Each term in
  * the enumeration is greater than all that precede it.
  */
-public class RangeTermEnum extends FilteredTermEnum {
+public class TermRangeTermEnum extends FilteredTermEnum {
 
   private Collator collator = null;
   private boolean endEnum = false;
@@ -50,14 +67,14 @@
    * 
    * @throws IOException
    */
-  public RangeTermEnum(IndexReader reader, Collator collator, String field,
+  public TermRangeTermEnum(IndexReader reader, Collator collator, String field,
       String lowerTermText, String upperTermText, boolean includeLower, boolean includeUpper) throws IOException {
     this.collator = collator;
     this.upperTermText = upperTermText;
     this.lowerTermText = lowerTermText;
     this.includeLower = includeLower;
     this.includeUpper = includeUpper;
-    this.field = field;
+    this.field = field.intern();
     
     // do a little bit of normalization...
     // open ended range queries should always be inclusive.
Index: src/test/org/apache/lucene/queryParser/TestQueryParser.java
===================================================================
--- src/test/org/apache/lucene/queryParser/TestQueryParser.java	(revision 790805)
+++ src/test/org/apache/lucene/queryParser/TestQueryParser.java	(working copy)
@@ -50,7 +50,7 @@
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.RangeQuery;
+import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
@@ -431,11 +431,11 @@
 
   public void testRange() throws Exception {
     assertQueryEquals("[ a TO z]", null, "[a TO z]");
-    assertTrue(((RangeQuery)getQuery("[ a TO z]", null)).getConstantScoreRewrite());
+    assertTrue(((TermRangeQuery)getQuery("[ a TO z]", null)).getConstantScoreRewrite());
 
     QueryParser qp = new QueryParser("field", new SimpleAnalyzer());
 	  qp.setConstantScoreRewrite(false);
-    assertFalse(((RangeQuery)qp.parse("[ a TO z]")).getConstantScoreRewrite());
+    assertFalse(((TermRangeQuery)qp.parse("[ a TO z]")).getConstantScoreRewrite());
     
     assertQueryEquals("[ a TO z ]", null, "[a TO z]");
     assertQueryEquals("{ a TO z}", null, "{a TO z}");
@@ -481,7 +481,7 @@
     result = is.search(qp.parse("[ \u0633 TO \u0638 ]"), null, 1000).scoreDocs;
     assertEquals("The index Term should be included.", 1, result.length);
 
-    // Test RangeQuery
+    // Test TermRangeQuery
     qp.setConstantScoreRewrite(false);
     result = is.search(qp.parse("[ \u062F TO \u0698 ]"), null, 1000).scoreDocs;
     assertEquals("The index Term should not be included.", 0, result.length);
Index: src/test/org/apache/lucene/search/TestDateFilter.java
===================================================================
--- src/test/org/apache/lucene/search/TestDateFilter.java	(revision 790805)
+++ src/test/org/apache/lucene/search/TestDateFilter.java	(working copy)
@@ -66,11 +66,11 @@
 
 	// filter that should preserve matches
 	//DateFilter df1 = DateFilter.Before("datefield", now);
-    RangeFilter df1 = new RangeFilter("datefield", DateTools.timeToString(now - 2000, DateTools.Resolution.MILLISECOND),
+    TermRangeFilter df1 = new TermRangeFilter("datefield", DateTools.timeToString(now - 2000, DateTools.Resolution.MILLISECOND),
                                       DateTools.timeToString(now, DateTools.Resolution.MILLISECOND), false, true);
 	// filter that should discard matches
 	//DateFilter df2 = DateFilter.Before("datefield", now - 999999);
-    RangeFilter df2 = new RangeFilter("datefield", DateTools.timeToString(0, DateTools.Resolution.MILLISECOND),
+    TermRangeFilter df2 = new TermRangeFilter("datefield", DateTools.timeToString(0, DateTools.Resolution.MILLISECOND),
                                       DateTools.timeToString(now - 2000, DateTools.Resolution.MILLISECOND), true, false);
 
     // search something that doesn't exist with DateFilter
@@ -127,11 +127,11 @@
 
 	// filter that should preserve matches
 	//DateFilter df1 = DateFilter.After("datefield", now);
-    RangeFilter df1 = new RangeFilter("datefield", DateTools.timeToString(now, DateTools.Resolution.MILLISECOND),
+    TermRangeFilter df1 = new TermRangeFilter("datefield", DateTools.timeToString(now, DateTools.Resolution.MILLISECOND),
                                       DateTools.timeToString(now + 999999, DateTools.Resolution.MILLISECOND), true, false);
 	// filter that should discard matches
 	//DateFilter df2 = DateFilter.After("datefield", now + 999999);
-    RangeFilter df2 = new RangeFilter("datefield", DateTools.timeToString(now + 999999, DateTools.Resolution.MILLISECOND),
+    TermRangeFilter df2 = new TermRangeFilter("datefield", DateTools.timeToString(now + 999999, DateTools.Resolution.MILLISECOND),
                                           DateTools.timeToString(now + 999999999, DateTools.Resolution.MILLISECOND), false, true);
 
     // search something that doesn't exist with DateFilter
Index: src/test/org/apache/lucene/search/TestFieldCacheRangeFilter.java
===================================================================
--- src/test/org/apache/lucene/search/TestFieldCacheRangeFilter.java	(revision 790805)
+++ src/test/org/apache/lucene/search/TestFieldCacheRangeFilter.java	(working copy)
@@ -30,7 +30,7 @@
 import org.apache.lucene.store.RAMDirectory;
 
 /**
- * A basic 'positive' Unit test class for the RangeFilter class.
+ * A basic 'positive' Unit test class for the FieldCacheRangeFilter class.
  *
  * <p>
  * NOTE: at the moment, this class only tests for 'positive' results,
Index: src/test/org/apache/lucene/search/TestFilteredQuery.java
===================================================================
--- src/test/org/apache/lucene/search/TestFilteredQuery.java	(revision 790805)
+++ src/test/org/apache/lucene/search/TestFilteredQuery.java	(working copy)
@@ -177,8 +177,8 @@
    * This tests FilteredQuery's rewrite correctness
    */
   public void testRangeQuery() throws Exception {
-    RangeQuery rq = new RangeQuery(
-        new Term("sorter", "b"), new Term("sorter", "d"), true);
+    TermRangeQuery rq = new TermRangeQuery(
+        "sorter", "b", "d", true, true);
 
     Query filteredquery = new FilteredQuery(rq, filter);
     ScoreDoc[] hits = searcher.search(filteredquery, null, 1000).scoreDocs;
Index: src/test/org/apache/lucene/search/TestMultiTermConstantScore.java
===================================================================
--- src/test/org/apache/lucene/search/TestMultiTermConstantScore.java	(revision 790805)
+++ src/test/org/apache/lucene/search/TestMultiTermConstantScore.java	(working copy)
@@ -87,7 +87,7 @@
 
   /** macro for readability */
   public static Query csrq(String f, String l, String h, boolean il, boolean ih) {
-    RangeQuery query = new RangeQuery(f, l, h, il, ih);
+    TermRangeQuery query = new TermRangeQuery(f, l, h, il, ih);
     query.setConstantScoreRewrite(true);
     return query;
   }
@@ -95,7 +95,7 @@
   /** macro for readability */
   public static Query csrq(String f, String l, String h, boolean il,
       boolean ih, Collator c) {
-    RangeQuery query = new RangeQuery(f, l, h, il, ih, c);
+    TermRangeQuery query = new TermRangeQuery(f, l, h, il, ih, c);
     query.setConstantScoreRewrite(true);
     return query;
   }
@@ -220,10 +220,10 @@
     IndexReader reader = IndexReader.open(small);
     IndexSearcher search = new IndexSearcher(reader);
 
-    // first do a regular RangeQuery which uses term expansion so
+    // first do a regular TermRangeQuery which uses term expansion so
     // docs with more terms in range get higher scores
 
-    Query rq = new RangeQuery(new Term("data", "1"), new Term("data", "4"), T);
+    Query rq = new TermRangeQuery("data", "1", "4", T, T);
 
     ScoreDoc[] expected = search.search(rq, null, 1000).scoreDocs;
     int numHits = expected.length;
Index: src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
===================================================================
--- src/test/org/apache/lucene/search/TestNumericRangeQuery32.java	(revision 790805)
+++ src/test/org/apache/lucene/search/TestNumericRangeQuery32.java	(working copy)
@@ -226,38 +226,38 @@
       }
       // test inclusive range
       NumericRangeQuery tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), true, true);
-      RangeQuery cq=new RangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, true);
+      TermRangeQuery cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, true);
       cq.setConstantScoreRewrite(true);
       TopDocs tTopDocs = searcher.search(tq, 1);
       TopDocs cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test exclusive range
       tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), false, false);
-      cq=new RangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, false);
+      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, false);
       cq.setConstantScoreRewrite(true);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test left exclusive range
       tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), false, true);
-      cq=new RangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, true);
+      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), false, true);
       cq.setConstantScoreRewrite(true);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test right exclusive range
       tq=NumericRangeQuery.newIntRange(field, precisionStep, new Integer(lower), new Integer(upper), true, false);
-      cq=new RangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, false);
+      cq=new TermRangeQuery(field, NumericUtils.intToPrefixCoded(lower), NumericUtils.intToPrefixCoded(upper), true, false);
       cq.setConstantScoreRewrite(true);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
     }
Index: src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
===================================================================
--- src/test/org/apache/lucene/search/TestNumericRangeQuery64.java	(revision 790805)
+++ src/test/org/apache/lucene/search/TestNumericRangeQuery64.java	(working copy)
@@ -226,38 +226,38 @@
       }
       // test inclusive range
       NumericRangeQuery tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), true, true);
-      RangeQuery cq=new RangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), true, true);
+      TermRangeQuery cq=new TermRangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), true, true);
       cq.setConstantScoreRewrite(true);
       TopDocs tTopDocs = searcher.search(tq, 1);
       TopDocs cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test exclusive range
       tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), false, false);
-      cq=new RangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), false, false);
+      cq=new TermRangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), false, false);
       cq.setConstantScoreRewrite(true);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test left exclusive range
       tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), false, true);
-      cq=new RangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), false, true);
+      cq=new TermRangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), false, true);
       cq.setConstantScoreRewrite(true);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
       // test right exclusive range
       tq=NumericRangeQuery.newLongRange(field, precisionStep, new Long(lower), new Long(upper), true, false);
-      cq=new RangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), true, false);
+      cq=new TermRangeQuery(field, NumericUtils.longToPrefixCoded(lower), NumericUtils.longToPrefixCoded(upper), true, false);
       cq.setConstantScoreRewrite(true);
       tTopDocs = searcher.search(tq, 1);
       cTopDocs = searcher.search(cq, 1);
-      assertEquals("Returned count for NumericRangeQuery and RangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
+      assertEquals("Returned count for NumericRangeQuery and TermRangeQuery must be equal", cTopDocs.totalHits, tTopDocs.totalHits );
       termCountT += tq.getTotalNumberOfTerms();
       termCountC += cq.getTotalNumberOfTerms();
     }
Index: src/test/org/apache/lucene/search/TestRangeFilter.java
===================================================================
--- src/test/org/apache/lucene/search/TestRangeFilter.java	(revision 790805)
+++ src/test/org/apache/lucene/search/TestRangeFilter.java	(working copy)
@@ -1,421 +0,0 @@
-package org.apache.lucene.search;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.text.Collator;
-import java.util.Locale;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.analysis.SimpleAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.store.RAMDirectory;
-
-/**
- * A basic 'positive' Unit test class for the RangeFilter class.
- *
- * <p>
- * NOTE: at the moment, this class only tests for 'positive' results,
- * it does not verify the results to ensure there are no 'false positives',
- * nor does it adequately test 'negative' results.  It also does not test
- * that garbage in results in an Exception.
- */
-public class TestRangeFilter extends BaseTestRangeFilter {
-
-    public TestRangeFilter(String name) {
-	super(name);
-    }
-    public TestRangeFilter() {
-        super();
-    }
-
-    public void testRangeFilterId() throws IOException {
-
-        IndexReader reader = IndexReader.open(signedIndex.index);
-	IndexSearcher search = new IndexSearcher(reader);
-
-        int medId = ((maxId - minId) / 2);
-        
-        String minIP = pad(minId);
-        String maxIP = pad(maxId);
-        String medIP = pad(medId);
-    
-        int numDocs = reader.numDocs();
-        
-        assertEquals("num of docs", numDocs, 1+ maxId - minId);
-        
-  ScoreDoc[] result;
-        Query q = new TermQuery(new Term("body","body"));
-
-        // test id, bounded on both ends
-        
-  result = search.search(q,new RangeFilter("id",minIP,maxIP,T,T), numDocs).scoreDocs;
-  assertEquals("find all", numDocs, result.length);
-
-  result = search.search(q,new RangeFilter("id",minIP,maxIP,T,F), numDocs).scoreDocs;
-  assertEquals("all but last", numDocs-1, result.length);
-
-  result = search.search(q,new RangeFilter("id",minIP,maxIP,F,T), numDocs).scoreDocs;
-  assertEquals("all but first", numDocs-1, result.length);
-        
-  result = search.search(q,new RangeFilter("id",minIP,maxIP,F,F), numDocs).scoreDocs;
-        assertEquals("all but ends", numDocs-2, result.length);
-    
-        result = search.search(q,new RangeFilter("id",medIP,maxIP,T,T), numDocs).scoreDocs;
-        assertEquals("med and up", 1+ maxId-medId, result.length);
-        
-        result = search.search(q,new RangeFilter("id",minIP,medIP,T,T), numDocs).scoreDocs;
-        assertEquals("up to med", 1+ medId-minId, result.length);
-
-        // unbounded id
-
-  result = search.search(q,new RangeFilter("id",minIP,null,T,F), numDocs).scoreDocs;
-  assertEquals("min and up", numDocs, result.length);
-
-  result = search.search(q,new RangeFilter("id",null,maxIP,F,T), numDocs).scoreDocs;
-  assertEquals("max and down", numDocs, result.length);
-
-  result = search.search(q,new RangeFilter("id",minIP,null,F,F), numDocs).scoreDocs;
-  assertEquals("not min, but up", numDocs-1, result.length);
-        
-  result = search.search(q,new RangeFilter("id",null,maxIP,F,F), numDocs).scoreDocs;
-  assertEquals("not max, but down", numDocs-1, result.length);
-        
-        result = search.search(q,new RangeFilter("id",medIP,maxIP,T,F), numDocs).scoreDocs;
-        assertEquals("med and up, not max", maxId-medId, result.length);
-        
-        result = search.search(q,new RangeFilter("id",minIP,medIP,F,T), numDocs).scoreDocs;
-        assertEquals("not min, up to med", medId-minId, result.length);
-
-        // very small sets
-
-  result = search.search(q,new RangeFilter("id",minIP,minIP,F,F), numDocs).scoreDocs;
-  assertEquals("min,min,F,F", 0, result.length);
-  result = search.search(q,new RangeFilter("id",medIP,medIP,F,F), numDocs).scoreDocs;
-  assertEquals("med,med,F,F", 0, result.length);
-  result = search.search(q,new RangeFilter("id",maxIP,maxIP,F,F), numDocs).scoreDocs;
-  assertEquals("max,max,F,F", 0, result.length);
-                     
-  result = search.search(q,new RangeFilter("id",minIP,minIP,T,T), numDocs).scoreDocs;
-  assertEquals("min,min,T,T", 1, result.length);
-  result = search.search(q,new RangeFilter("id",null,minIP,F,T), numDocs).scoreDocs;
-  assertEquals("nul,min,F,T", 1, result.length);
-
-  result = search.search(q,new RangeFilter("id",maxIP,maxIP,T,T), numDocs).scoreDocs;
-  assertEquals("max,max,T,T", 1, result.length);
-  result = search.search(q,new RangeFilter("id",maxIP,null,T,F), numDocs).scoreDocs;
-  assertEquals("max,nul,T,T", 1, result.length);
-
-  result = search.search(q,new RangeFilter("id",medIP,medIP,T,T), numDocs).scoreDocs;
-  assertEquals("med,med,T,T", 1, result.length);
-        
-    }
-
-    public void testRangeFilterIdCollating() throws IOException {
-
-        IndexReader reader = IndexReader.open(signedIndex.index);
-        IndexSearcher search = new IndexSearcher(reader);
-
-        Collator c = Collator.getInstance(Locale.ENGLISH);
-
-        int medId = ((maxId - minId) / 2);
-
-        String minIP = pad(minId);
-        String maxIP = pad(maxId);
-        String medIP = pad(medId);
-
-        int numDocs = reader.numDocs();
-
-        assertEquals("num of docs", numDocs, 1+ maxId - minId);
-
-        Hits result;
-        Query q = new TermQuery(new Term("body","body"));
-
-        // test id, bounded on both ends
-
-        result = search.search(q,new RangeFilter("id",minIP,maxIP,T,T,c));
-        assertEquals("find all", numDocs, result.length());
-
-        result = search.search(q,new RangeFilter("id",minIP,maxIP,T,F,c));
-        assertEquals("all but last", numDocs-1, result.length());
-
-        result = search.search(q,new RangeFilter("id",minIP,maxIP,F,T,c));
-        assertEquals("all but first", numDocs-1, result.length());
-
-        result = search.search(q,new RangeFilter("id",minIP,maxIP,F,F,c));
-        assertEquals("all but ends", numDocs-2, result.length());
-
-        result = search.search(q,new RangeFilter("id",medIP,maxIP,T,T,c));
-        assertEquals("med and up", 1+ maxId-medId, result.length());
-
-        result = search.search(q,new RangeFilter("id",minIP,medIP,T,T,c));
-        assertEquals("up to med", 1+ medId-minId, result.length());
-
-        // unbounded id
-
-        result = search.search(q,new RangeFilter("id",minIP,null,T,F,c));
-        assertEquals("min and up", numDocs, result.length());
-
-        result = search.search(q,new RangeFilter("id",null,maxIP,F,T,c));
-        assertEquals("max and down", numDocs, result.length());
-
-        result = search.search(q,new RangeFilter("id",minIP,null,F,F,c));
-        assertEquals("not min, but up", numDocs-1, result.length());
-
-        result = search.search(q,new RangeFilter("id",null,maxIP,F,F,c));
-        assertEquals("not max, but down", numDocs-1, result.length());
-
-        result = search.search(q,new RangeFilter("id",medIP,maxIP,T,F,c));
-        assertEquals("med and up, not max", maxId-medId, result.length());
-
-        result = search.search(q,new RangeFilter("id",minIP,medIP,F,T,c));
-        assertEquals("not min, up to med", medId-minId, result.length());
-
-        // very small sets
-
-        result = search.search(q,new RangeFilter("id",minIP,minIP,F,F,c));
-        assertEquals("min,min,F,F", 0, result.length());
-        result = search.search(q,new RangeFilter("id",medIP,medIP,F,F,c));
-        assertEquals("med,med,F,F", 0, result.length());
-        result = search.search(q,new RangeFilter("id",maxIP,maxIP,F,F,c));
-        assertEquals("max,max,F,F", 0, result.length());
-
-        result = search.search(q,new RangeFilter("id",minIP,minIP,T,T,c));
-        assertEquals("min,min,T,T", 1, result.length());
-        result = search.search(q,new RangeFilter("id",null,minIP,F,T,c));
-        assertEquals("nul,min,F,T", 1, result.length());
-
-        result = search.search(q,new RangeFilter("id",maxIP,maxIP,T,T,c));
-        assertEquals("max,max,T,T", 1, result.length());
-        result = search.search(q,new RangeFilter("id",maxIP,null,T,F,c));
-        assertEquals("max,nul,T,T", 1, result.length());
-
-        result = search.search(q,new RangeFilter("id",medIP,medIP,T,T,c));
-        assertEquals("med,med,T,T", 1, result.length());
-    }
-
-    public void testRangeFilterRand() throws IOException {
-
-  IndexReader reader = IndexReader.open(signedIndex.index);
-	IndexSearcher search = new IndexSearcher(reader);
-
-        String minRP = pad(signedIndex.minR);
-        String maxRP = pad(signedIndex.maxR);
-    
-        int numDocs = reader.numDocs();
-        
-        assertEquals("num of docs", numDocs, 1+ maxId - minId);
-        
-  ScoreDoc[] result;
-        Query q = new TermQuery(new Term("body","body"));
-
-        // test extremes, bounded on both ends
-        
-  result = search.search(q,new RangeFilter("rand",minRP,maxRP,T,T), numDocs).scoreDocs;
-  assertEquals("find all", numDocs, result.length);
-
-  result = search.search(q,new RangeFilter("rand",minRP,maxRP,T,F), numDocs).scoreDocs;
-  assertEquals("all but biggest", numDocs-1, result.length);
-
-  result = search.search(q,new RangeFilter("rand",minRP,maxRP,F,T), numDocs).scoreDocs;
-  assertEquals("all but smallest", numDocs-1, result.length);
-        
-  result = search.search(q,new RangeFilter("rand",minRP,maxRP,F,F), numDocs).scoreDocs;
-        assertEquals("all but extremes", numDocs-2, result.length);
-    
-        // unbounded
-
-  result = search.search(q,new RangeFilter("rand",minRP,null,T,F), numDocs).scoreDocs;
-  assertEquals("smallest and up", numDocs, result.length);
-
-  result = search.search(q,new RangeFilter("rand",null,maxRP,F,T), numDocs).scoreDocs;
-  assertEquals("biggest and down", numDocs, result.length);
-
-  result = search.search(q,new RangeFilter("rand",minRP,null,F,F), numDocs).scoreDocs;
-  assertEquals("not smallest, but up", numDocs-1, result.length);
-        
-  result = search.search(q,new RangeFilter("rand",null,maxRP,F,F), numDocs).scoreDocs;
-  assertEquals("not biggest, but down", numDocs-1, result.length);
-        
-        // very small sets
-
-  result = search.search(q,new RangeFilter("rand",minRP,minRP,F,F), numDocs).scoreDocs;
-  assertEquals("min,min,F,F", 0, result.length);
-  result = search.search(q,new RangeFilter("rand",maxRP,maxRP,F,F), numDocs).scoreDocs;
-  assertEquals("max,max,F,F", 0, result.length);
-                     
-  result = search.search(q,new RangeFilter("rand",minRP,minRP,T,T), numDocs).scoreDocs;
-  assertEquals("min,min,T,T", 1, result.length);
-  result = search.search(q,new RangeFilter("rand",null,minRP,F,T), numDocs).scoreDocs;
-  assertEquals("nul,min,F,T", 1, result.length);
-
-  result = search.search(q,new RangeFilter("rand",maxRP,maxRP,T,T), numDocs).scoreDocs;
-  assertEquals("max,max,T,T", 1, result.length);
-  result = search.search(q,new RangeFilter("rand",maxRP,null,T,F), numDocs).scoreDocs;
-  assertEquals("max,nul,T,T", 1, result.length);
-        
-    }
-
-    public void testRangeFilterRandCollating() throws IOException {
-
-        // using the unsigned index because collation seems to ignore hyphens
-        IndexReader reader = IndexReader.open(unsignedIndex.index);
-        IndexSearcher search = new IndexSearcher(reader);
-
-        Collator c = Collator.getInstance(Locale.ENGLISH);
-
-        String minRP = pad(unsignedIndex.minR);
-        String maxRP = pad(unsignedIndex.maxR);
-
-        int numDocs = reader.numDocs();
-
-        assertEquals("num of docs", numDocs, 1+ maxId - minId);
-
-        Hits result;
-        Query q = new TermQuery(new Term("body","body"));
-
-        // test extremes, bounded on both ends
-
-        result = search.search(q,new RangeFilter("rand",minRP,maxRP,T,T,c));
-        assertEquals("find all", numDocs, result.length());
-
-        result = search.search(q,new RangeFilter("rand",minRP,maxRP,T,F,c));
-        assertEquals("all but biggest", numDocs-1, result.length());
-
-        result = search.search(q,new RangeFilter("rand",minRP,maxRP,F,T,c));
-        assertEquals("all but smallest", numDocs-1, result.length());
-
-        result = search.search(q,new RangeFilter("rand",minRP,maxRP,F,F,c));
-        assertEquals("all but extremes", numDocs-2, result.length());
-
-        // unbounded
-
-        result = search.search(q,new RangeFilter("rand",minRP,null,T,F,c));
-        assertEquals("smallest and up", numDocs, result.length());
-
-        result = search.search(q,new RangeFilter("rand",null,maxRP,F,T,c));
-        assertEquals("biggest and down", numDocs, result.length());
-
-        result = search.search(q,new RangeFilter("rand",minRP,null,F,F,c));
-        assertEquals("not smallest, but up", numDocs-1, result.length());
-
-        result = search.search(q,new RangeFilter("rand",null,maxRP,F,F,c));
-        assertEquals("not biggest, but down", numDocs-1, result.length());
-
-        // very small sets
-
-        result = search.search(q,new RangeFilter("rand",minRP,minRP,F,F,c));
-        assertEquals("min,min,F,F", 0, result.length());
-        result = search.search(q,new RangeFilter("rand",maxRP,maxRP,F,F,c));
-        assertEquals("max,max,F,F", 0, result.length());
-
-        result = search.search(q,new RangeFilter("rand",minRP,minRP,T,T,c));
-        assertEquals("min,min,T,T", 1, result.length());
-        result = search.search(q,new RangeFilter("rand",null,minRP,F,T,c));
-        assertEquals("nul,min,F,T", 1, result.length());
-
-        result = search.search(q,new RangeFilter("rand",maxRP,maxRP,T,T,c));
-        assertEquals("max,max,T,T", 1, result.length());
-        result = search.search(q,new RangeFilter("rand",maxRP,null,T,F,c));
-        assertEquals("max,nul,T,T", 1, result.length());
-    }
-    
-    public void testFarsi() throws Exception {
-            
-        /* build an index */
-        RAMDirectory farsiIndex = new RAMDirectory();
-        IndexWriter writer = new IndexWriter(farsiIndex, new SimpleAnalyzer(), T, 
-                                             IndexWriter.MaxFieldLength.LIMITED);
-        Document doc = new Document();
-        doc.add(new Field("content","\u0633\u0627\u0628", 
-                          Field.Store.YES, Field.Index.UN_TOKENIZED));
-        doc.add(new Field("body", "body",
-                          Field.Store.YES, Field.Index.UN_TOKENIZED));
-        writer.addDocument(doc);
-            
-        writer.optimize();
-        writer.close();
-
-        IndexReader reader = IndexReader.open(farsiIndex);
-        IndexSearcher search = new IndexSearcher(reader);
-        Query q = new TermQuery(new Term("body","body"));
-
-        // Neither Java 1.4.2 nor 1.5.0 has Farsi Locale collation available in
-        // RuleBasedCollator.  However, the Arabic Locale seems to order the Farsi
-        // characters properly.
-        Collator collator = Collator.getInstance(new Locale("ar"));
-        
-        // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
-        // orders the U+0698 character before the U+0633 character, so the single
-        // index Term below should NOT be returned by a RangeFilter with a Farsi
-        // Collator (or an Arabic one for the case when Farsi is not supported).
-        Hits result = search.search
-            (q, new RangeFilter("content", "\u062F", "\u0698", T, T, collator));
-        assertEquals("The index Term should not be included.", 0, result.length());
-
-        result = search.search
-            (q, new RangeFilter("content", "\u0633", "\u0638", T, T, collator));
-        assertEquals("The index Term should be included.", 1, result.length());
-        search.close();
-    }
-
-    public void testDanish() throws Exception {
-            
-        /* build an index */
-        RAMDirectory danishIndex = new RAMDirectory();
-        IndexWriter writer = new IndexWriter
-            (danishIndex, new SimpleAnalyzer(), T, 
-             IndexWriter.MaxFieldLength.LIMITED);
-        // Danish collation orders the words below in the given order
-        // (example taken from TestSort.testInternationalSort() ).
-        String[] words = { "H\u00D8T", "H\u00C5T", "MAND" };
-        for (int docnum = 0 ; docnum < words.length ; ++docnum) {   
-            Document doc = new Document();
-            doc.add(new Field("content", words[docnum], 
-                              Field.Store.YES, Field.Index.UN_TOKENIZED));
-            doc.add(new Field("body", "body",
-                              Field.Store.YES, Field.Index.UN_TOKENIZED));
-            writer.addDocument(doc);
-        }
-        writer.optimize();
-        writer.close();
-
-        IndexReader reader = IndexReader.open(danishIndex);
-        IndexSearcher search = new IndexSearcher(reader);
-        Query q = new TermQuery(new Term("body","body"));
-
-        Collator collator = Collator.getInstance(new Locale("da", "dk"));
-        Query query = new RangeQuery
-            ("content", "H\u00D8T", "MAND", false, false, collator);
-
-        // Unicode order would not include "H\u00C5T" in [ "H\u00D8T", "MAND" ],
-        // but Danish collation does.
-        Hits result = search.search
-            (q, new RangeFilter("content", "H\u00D8T", "MAND", F, F, collator));
-        assertEquals("The index Term should be included.", 1, result.length());
-
-        result = search.search
-            (q, new RangeFilter("content", "H\u00C5T", "MAND", F, F, collator));
-        assertEquals
-            ("The index Term should not be included.", 0, result.length());
-        search.close();
-    }
-}
Index: src/test/org/apache/lucene/search/TestRangeQuery.java
===================================================================
--- src/test/org/apache/lucene/search/TestRangeQuery.java	(revision 790805)
+++ src/test/org/apache/lucene/search/TestRangeQuery.java	(working copy)
@@ -1,380 +0,0 @@
-package org.apache.lucene.search;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.analysis.WhitespaceAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.store.RAMDirectory;
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.Tokenizer;
-import org.apache.lucene.analysis.tokenattributes.TermAttribute;
-
-import org.apache.lucene.util.LuceneTestCase;
-import java.io.IOException;
-import java.io.Reader;
-import java.util.Locale;
-import java.text.Collator;
-
-
-public class TestRangeQuery extends LuceneTestCase {
-
-  private int docCount = 0;
-  private RAMDirectory dir;
-
-  public void setUp() throws Exception {
-    super.setUp();
-    dir = new RAMDirectory();
-  }
-
-  public void testExclusive() throws Exception {
-    Query query = new RangeQuery("content", "A", "C", false, false);
-    initializeIndex(new String[] {"A", "B", "C", "D"});
-    IndexSearcher searcher = new IndexSearcher(dir);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,C,D, only B in range", 1, hits.length);
-    searcher.close();
-
-    initializeIndex(new String[] {"A", "B", "D"});
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,D, only B in range", 1, hits.length);
-    searcher.close();
-
-    addDoc("C");
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("C added, still only B in range", 1, hits.length);
-    searcher.close();
-  }
-  
-  //TODO: remove in Lucene 3.0
-  public void testDeprecatedCstrctors() throws IOException {
-    Query query = new RangeQuery(null, new Term("content","C"), false);
-    initializeIndex(new String[] {"A", "B", "C", "D"});
-    IndexSearcher searcher = new IndexSearcher(dir);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,C,D, only B in range", 2, hits.length);
-    searcher.close();
-    
-    query = new RangeQuery(new Term("content","C"),null, false);
-    initializeIndex(new String[] {"A", "B", "C", "D"});
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,C,D, only B in range", 1, hits.length);
-    searcher.close();
-  }
-
-  public void testInclusive() throws Exception {
-    Query query = new RangeQuery("content", "A", "C", true, true);
-
-    initializeIndex(new String[]{"A", "B", "C", "D"});
-    IndexSearcher searcher = new IndexSearcher(dir);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,C,D - A,B,C in range", 3, hits.length);
-    searcher.close();
-
-    initializeIndex(new String[]{"A", "B", "D"});
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,D - A and B in range", 2, hits.length);
-    searcher.close();
-
-    addDoc("C");
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("C added - A, B, C in range", 3, hits.length);
-    searcher.close();
-  }
-
-  public void testEqualsHashcode() {
-    Query query = new RangeQuery("content", "A", "C", true, true);
-    
-    query.setBoost(1.0f);
-    Query other = new RangeQuery("content", "A", "C", true, true);
-    other.setBoost(1.0f);
-
-    assertEquals("query equals itself is true", query, query);
-    assertEquals("equivalent queries are equal", query, other);
-    assertEquals("hashcode must return same value when equals is true", query.hashCode(), other.hashCode());
-
-    other.setBoost(2.0f);
-    assertFalse("Different boost queries are not equal", query.equals(other));
-
-    other = new RangeQuery("notcontent", "A", "C", true, true);
-    assertFalse("Different fields are not equal", query.equals(other));
-
-    other = new RangeQuery("content", "X", "C", true, true);
-    assertFalse("Different lower terms are not equal", query.equals(other));
-
-    other = new RangeQuery("content", "A", "Z", true, true);
-    assertFalse("Different upper terms are not equal", query.equals(other));
-
-    query = new RangeQuery("content", null, "C", true, true);
-    other = new RangeQuery("content", null, "C", true, true);
-    assertEquals("equivalent queries with null lowerterms are equal()", query, other);
-    assertEquals("hashcode must return same value when equals is true", query.hashCode(), other.hashCode());
-
-    query = new RangeQuery("content", "C", null, true, true);
-    other = new RangeQuery("content", "C", null, true, true);
-    assertEquals("equivalent queries with null upperterms are equal()", query, other);
-    assertEquals("hashcode returns same value", query.hashCode(), other.hashCode());
-
-    query = new RangeQuery("content", null, "C", true, true);
-    other = new RangeQuery("content", "C", null, true, true);
-    assertFalse("queries with different upper and lower terms are not equal", query.equals(other));
-
-    query = new RangeQuery("content", "A", "C", false, false);
-    other = new RangeQuery("content", "A", "C", true, true);
-    assertFalse("queries with different inclusive are not equal", query.equals(other));
-    
-    query = new RangeQuery("content", "A", "C", false, false);
-    other = new RangeQuery("content", "A", "C", false, false, Collator.getInstance());
-    assertFalse("a query with a collator is not equal to one without", query.equals(other));
-  }
-
-  public void testExclusiveCollating() throws Exception {
-    Query query = new RangeQuery("content", "A", "C", false, false, Collator.getInstance(Locale.ENGLISH));
-    initializeIndex(new String[] {"A", "B", "C", "D"});
-    IndexSearcher searcher = new IndexSearcher(dir);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,C,D, only B in range", 1, hits.length);
-    searcher.close();
-
-    initializeIndex(new String[] {"A", "B", "D"});
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,D, only B in range", 1, hits.length);
-    searcher.close();
-
-    addDoc("C");
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("C added, still only B in range", 1, hits.length);
-    searcher.close();
-  }
-
-  public void testInclusiveCollating() throws Exception {
-    Query query = new RangeQuery("content", "A", "C",true, true, Collator.getInstance(Locale.ENGLISH));
-
-    initializeIndex(new String[]{"A", "B", "C", "D"});
-    IndexSearcher searcher = new IndexSearcher(dir);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,C,D - A,B,C in range", 3, hits.length);
-    searcher.close();
-
-    initializeIndex(new String[]{"A", "B", "D"});
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("A,B,D - A and B in range", 2, hits.length);
-    searcher.close();
-
-    addDoc("C");
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("C added - A, B, C in range", 3, hits.length);
-    searcher.close();
-  }
-
-  public void testFarsi() throws Exception {
-    // Neither Java 1.4.2 nor 1.5.0 has Farsi Locale collation available in
-    // RuleBasedCollator.  However, the Arabic Locale seems to order the Farsi
-    // characters properly.
-    Collator collator = Collator.getInstance(new Locale("ar"));
-    Query query = new RangeQuery("content", "\u062F", "\u0698", true, true, collator);
-    // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
-    // orders the U+0698 character before the U+0633 character, so the single
-    // index Term below should NOT be returned by a RangeQuery with a Farsi
-    // Collator (or an Arabic one for the case when Farsi is not supported).
-    initializeIndex(new String[]{ "\u0633\u0627\u0628"});
-    IndexSearcher searcher = new IndexSearcher(dir);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("The index Term should not be included.", 0, hits.length);
-
-    query = new RangeQuery("content", "\u0633", "\u0638",true, true, collator);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("The index Term should be included.", 1, hits.length);
-    searcher.close();
-  }
-  
-  public void testDanish() throws Exception {
-    Collator collator = Collator.getInstance(new Locale("da", "dk"));
-    // Danish collation orders the words below in the given order (example taken
-    // from TestSort.testInternationalSort() ).
-    String[] words = { "H\u00D8T", "H\u00C5T", "MAND" };
-    Query query = new RangeQuery("content", "H\u00D8T", "MAND", false, false, collator);
-
-    // Unicode order would not include "H\u00C5T" in [ "H\u00D8T", "MAND" ],
-    // but Danish collation does.
-    initializeIndex(words);
-    IndexSearcher searcher = new IndexSearcher(dir);
-    ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("The index Term should be included.", 1, hits.length);
-
-    query = new RangeQuery("content", "H\u00C5T", "MAND", false, false, collator);
-    hits = searcher.search(query, null, 1000).scoreDocs;
-    assertEquals("The index Term should not be included.", 0, hits.length);
-    searcher.close();
-  }
-
-  private static class SingleCharAnalyzer extends Analyzer {
-
-    private static class SingleCharTokenizer extends Tokenizer {
-      char[] buffer = new char[1];
-      boolean done;
-      TermAttribute termAtt;
-      
-      public SingleCharTokenizer(Reader r) {
-        super(r);
-        termAtt = (TermAttribute) addAttribute(TermAttribute.class);
-      }
-
-      public boolean incrementToken() throws IOException {
-        int count = input.read(buffer);
-        if (done)
-          return false;
-        else {
-          done = true;
-          if (count == 1) {
-            termAtt.termBuffer()[0] = buffer[0];
-            termAtt.setTermLength(1);
-          } else
-            termAtt.setTermLength(0);
-          return true;
-        }
-      }
-
-      public final void reset(Reader reader) throws IOException {
-        super.reset(reader);
-        done = false;
-      }
-    }
-
-    public TokenStream reusableTokenStream(String fieldName, Reader reader) throws IOException {
-      Tokenizer tokenizer = (Tokenizer) getPreviousTokenStream();
-      if (tokenizer == null) {
-        tokenizer = new SingleCharTokenizer(reader);
-        setPreviousTokenStream(tokenizer);
-      } else
-        tokenizer.reset(reader);
-      return tokenizer;
-    }
-
-    public TokenStream tokenStream(String fieldName, Reader reader) {
-      return new SingleCharTokenizer(reader);
-    }
-  }
-
-  private void initializeIndex(String[] values) throws IOException {
-    initializeIndex(values, new WhitespaceAnalyzer());
-  }
-
-  private void initializeIndex(String[] values, Analyzer analyzer) throws IOException {
-    IndexWriter writer = new IndexWriter(dir, analyzer, true, IndexWriter.MaxFieldLength.LIMITED);
-    for (int i = 0; i < values.length; i++) {
-      insertDoc(writer, values[i]);
-    }
-    writer.close();
-  }
-
-  private void addDoc(String content) throws IOException {
-    IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(), false, IndexWriter.MaxFieldLength.LIMITED);
-    insertDoc(writer, content);
-    writer.close();
-  }
-
-  private void insertDoc(IndexWriter writer, String content) throws IOException {
-    Document doc = new Document();
-
-    doc.add(new Field("id", "id" + docCount, Field.Store.YES, Field.Index.NOT_ANALYZED));
-    doc.add(new Field("content", content, Field.Store.NO, Field.Index.ANALYZED));
-
-    writer.addDocument(doc);
-    docCount++;
-  }
-
-  // LUCENE-38
-  public void testExclusiveLowerNull() throws Exception {
-    Analyzer analyzer = new SingleCharAnalyzer();
-    //http://issues.apache.org/jira/browse/LUCENE-38
-    Query query = new RangeQuery(null,
-                                 new Term("content", "C"),
-                                 false);
-    initializeIndex(new String[] {"A", "B", "", "C", "D"}, analyzer);
-    IndexSearcher searcher = new IndexSearcher(dir);
-    Hits hits = searcher.search(query);
-    // When Lucene-38 is fixed, use the assert on the next line:
-    assertEquals("A,B,<empty string>,C,D => A, B & <empty string> are in range", 3, hits.length());
-    // until Lucene-38 is fixed, use this assert:
-    //assertEquals("A,B,<empty string>,C,D => A, B & <empty string> are in range", 2, hits.length());
-
-    searcher.close();
-    initializeIndex(new String[] {"A", "B", "", "D"}, analyzer);
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query);
-    // When Lucene-38 is fixed, use the assert on the next line:
-    assertEquals("A,B,<empty string>,D => A, B & <empty string> are in range", 3, hits.length());
-    // until Lucene-38 is fixed, use this assert:
-    //assertEquals("A,B,<empty string>,D => A, B & <empty string> are in range", 2, hits.length());
-    searcher.close();
-    addDoc("C");
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query);
-    // When Lucene-38 is fixed, use the assert on the next line:
-    assertEquals("C added, still A, B & <empty string> are in range", 3, hits.length());
-    // until Lucene-38 is fixed, use this assert
-    //assertEquals("C added, still A, B & <empty string> are in range", 2, hits.length());
-    searcher.close();
-  }
-
-  // LUCENE-38
-  public void testInclusiveLowerNull() throws Exception {
-    //http://issues.apache.org/jira/browse/LUCENE-38
-    Analyzer analyzer = new SingleCharAnalyzer();
-    Query query = new RangeQuery(null,
-                                 new Term("content", "C"),
-                                 true);
-    initializeIndex(new String[]{"A", "B", "","C", "D"}, analyzer);
-    IndexSearcher searcher = new IndexSearcher(dir);
-    Hits hits = searcher.search(query);
-    // When Lucene-38 is fixed, use the assert on the next line:
-    assertEquals("A,B,<empty string>,C,D => A,B,<empty string>,C in range", 4, hits.length());
-    // until Lucene-38 is fixed, use this assert
-    //assertEquals("A,B,<empty string>,C,D => A,B,<empty string>,C in range", 3, hits.length());
-    searcher.close();
-    initializeIndex(new String[]{"A", "B", "", "D"}, analyzer);
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query);
-    // When Lucene-38 is fixed, use the assert on the next line:
-    assertEquals("A,B,<empty string>,D - A, B and <empty string> in range", 3, hits.length());
-    // until Lucene-38 is fixed, use this assert
-    //assertEquals("A,B,<empty string>,D => A, B and <empty string> in range", 2, hits.length());
-    searcher.close();
-    addDoc("C");
-    searcher = new IndexSearcher(dir);
-    hits = searcher.search(query);
-    // When Lucene-38 is fixed, use the assert on the next line:
-    assertEquals("C added => A,B,<empty string>,C in range", 4, hits.length());
-    // until Lucene-38 is fixed, use this assert
-    //assertEquals("C added => A,B,<empty string>,C in range", 3, hits.length());
-     searcher.close();
-  }
-}
Index: src/test/org/apache/lucene/search/TestTermRangeFilter.java
===================================================================
--- src/test/org/apache/lucene/search/TestTermRangeFilter.java	(revision 790584)
+++ src/test/org/apache/lucene/search/TestTermRangeFilter.java	(working copy)
@@ -30,7 +30,7 @@
 import org.apache.lucene.store.RAMDirectory;
 
 /**
- * A basic 'positive' Unit test class for the RangeFilter class.
+ * A basic 'positive' Unit test class for the TermRangeFilter class.
  *
  * <p>
  * NOTE: at the moment, this class only tests for 'positive' results,
@@ -38,12 +38,12 @@
  * nor does it adequately test 'negative' results.  It also does not test
  * that garbage in results in an Exception.
  */
-public class TestRangeFilter extends BaseTestRangeFilter {
+public class TestTermRangeFilter extends BaseTestRangeFilter {
 
-    public TestRangeFilter(String name) {
+    public TestTermRangeFilter(String name) {
 	super(name);
     }
-    public TestRangeFilter() {
+    public TestTermRangeFilter() {
         super();
     }
 
@@ -67,64 +67,64 @@
 
         // test id, bounded on both ends
         
-  result = search.search(q,new RangeFilter("id",minIP,maxIP,T,T), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",minIP,maxIP,T,T), numDocs).scoreDocs;
   assertEquals("find all", numDocs, result.length);
 
-  result = search.search(q,new RangeFilter("id",minIP,maxIP,T,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",minIP,maxIP,T,F), numDocs).scoreDocs;
   assertEquals("all but last", numDocs-1, result.length);
 
-  result = search.search(q,new RangeFilter("id",minIP,maxIP,F,T), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",minIP,maxIP,F,T), numDocs).scoreDocs;
   assertEquals("all but first", numDocs-1, result.length);
         
-  result = search.search(q,new RangeFilter("id",minIP,maxIP,F,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",minIP,maxIP,F,F), numDocs).scoreDocs;
         assertEquals("all but ends", numDocs-2, result.length);
     
-        result = search.search(q,new RangeFilter("id",medIP,maxIP,T,T), numDocs).scoreDocs;
+        result = search.search(q,new TermRangeFilter("id",medIP,maxIP,T,T), numDocs).scoreDocs;
         assertEquals("med and up", 1+ maxId-medId, result.length);
         
-        result = search.search(q,new RangeFilter("id",minIP,medIP,T,T), numDocs).scoreDocs;
+        result = search.search(q,new TermRangeFilter("id",minIP,medIP,T,T), numDocs).scoreDocs;
         assertEquals("up to med", 1+ medId-minId, result.length);
 
         // unbounded id
 
-  result = search.search(q,new RangeFilter("id",minIP,null,T,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",minIP,null,T,F), numDocs).scoreDocs;
   assertEquals("min and up", numDocs, result.length);
 
-  result = search.search(q,new RangeFilter("id",null,maxIP,F,T), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",null,maxIP,F,T), numDocs).scoreDocs;
   assertEquals("max and down", numDocs, result.length);
 
-  result = search.search(q,new RangeFilter("id",minIP,null,F,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",minIP,null,F,F), numDocs).scoreDocs;
   assertEquals("not min, but up", numDocs-1, result.length);
         
-  result = search.search(q,new RangeFilter("id",null,maxIP,F,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",null,maxIP,F,F), numDocs).scoreDocs;
   assertEquals("not max, but down", numDocs-1, result.length);
         
-        result = search.search(q,new RangeFilter("id",medIP,maxIP,T,F), numDocs).scoreDocs;
+        result = search.search(q,new TermRangeFilter("id",medIP,maxIP,T,F), numDocs).scoreDocs;
         assertEquals("med and up, not max", maxId-medId, result.length);
         
-        result = search.search(q,new RangeFilter("id",minIP,medIP,F,T), numDocs).scoreDocs;
+        result = search.search(q,new TermRangeFilter("id",minIP,medIP,F,T), numDocs).scoreDocs;
         assertEquals("not min, up to med", medId-minId, result.length);
 
         // very small sets
 
-  result = search.search(q,new RangeFilter("id",minIP,minIP,F,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",minIP,minIP,F,F), numDocs).scoreDocs;
   assertEquals("min,min,F,F", 0, result.length);
-  result = search.search(q,new RangeFilter("id",medIP,medIP,F,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",medIP,medIP,F,F), numDocs).scoreDocs;
   assertEquals("med,med,F,F", 0, result.length);
-  result = search.search(q,new RangeFilter("id",maxIP,maxIP,F,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",maxIP,maxIP,F,F), numDocs).scoreDocs;
   assertEquals("max,max,F,F", 0, result.length);
                      
-  result = search.search(q,new RangeFilter("id",minIP,minIP,T,T), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",minIP,minIP,T,T), numDocs).scoreDocs;
   assertEquals("min,min,T,T", 1, result.length);
-  result = search.search(q,new RangeFilter("id",null,minIP,F,T), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",null,minIP,F,T), numDocs).scoreDocs;
   assertEquals("nul,min,F,T", 1, result.length);
 
-  result = search.search(q,new RangeFilter("id",maxIP,maxIP,T,T), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",maxIP,maxIP,T,T), numDocs).scoreDocs;
   assertEquals("max,max,T,T", 1, result.length);
-  result = search.search(q,new RangeFilter("id",maxIP,null,T,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",maxIP,null,T,F), numDocs).scoreDocs;
   assertEquals("max,nul,T,T", 1, result.length);
 
-  result = search.search(q,new RangeFilter("id",medIP,medIP,T,T), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("id",medIP,medIP,T,T), numDocs).scoreDocs;
   assertEquals("med,med,T,T", 1, result.length);
         
     }
@@ -151,64 +151,64 @@
 
         // test id, bounded on both ends
 
-        result = search.search(q,new RangeFilter("id",minIP,maxIP,T,T,c));
+        result = search.search(q,new TermRangeFilter("id",minIP,maxIP,T,T,c));
         assertEquals("find all", numDocs, result.length());
 
-        result = search.search(q,new RangeFilter("id",minIP,maxIP,T,F,c));
+        result = search.search(q,new TermRangeFilter("id",minIP,maxIP,T,F,c));
         assertEquals("all but last", numDocs-1, result.length());
 
-        result = search.search(q,new RangeFilter("id",minIP,maxIP,F,T,c));
+        result = search.search(q,new TermRangeFilter("id",minIP,maxIP,F,T,c));
         assertEquals("all but first", numDocs-1, result.length());
 
-        result = search.search(q,new RangeFilter("id",minIP,maxIP,F,F,c));
+        result = search.search(q,new TermRangeFilter("id",minIP,maxIP,F,F,c));
         assertEquals("all but ends", numDocs-2, result.length());
 
-        result = search.search(q,new RangeFilter("id",medIP,maxIP,T,T,c));
+        result = search.search(q,new TermRangeFilter("id",medIP,maxIP,T,T,c));
         assertEquals("med and up", 1+ maxId-medId, result.length());
 
-        result = search.search(q,new RangeFilter("id",minIP,medIP,T,T,c));
+        result = search.search(q,new TermRangeFilter("id",minIP,medIP,T,T,c));
         assertEquals("up to med", 1+ medId-minId, result.length());
 
         // unbounded id
 
-        result = search.search(q,new RangeFilter("id",minIP,null,T,F,c));
+        result = search.search(q,new TermRangeFilter("id",minIP,null,T,F,c));
         assertEquals("min and up", numDocs, result.length());
 
-        result = search.search(q,new RangeFilter("id",null,maxIP,F,T,c));
+        result = search.search(q,new TermRangeFilter("id",null,maxIP,F,T,c));
         assertEquals("max and down", numDocs, result.length());
 
-        result = search.search(q,new RangeFilter("id",minIP,null,F,F,c));
+        result = search.search(q,new TermRangeFilter("id",minIP,null,F,F,c));
         assertEquals("not min, but up", numDocs-1, result.length());
 
-        result = search.search(q,new RangeFilter("id",null,maxIP,F,F,c));
+        result = search.search(q,new TermRangeFilter("id",null,maxIP,F,F,c));
         assertEquals("not max, but down", numDocs-1, result.length());
 
-        result = search.search(q,new RangeFilter("id",medIP,maxIP,T,F,c));
+        result = search.search(q,new TermRangeFilter("id",medIP,maxIP,T,F,c));
         assertEquals("med and up, not max", maxId-medId, result.length());
 
-        result = search.search(q,new RangeFilter("id",minIP,medIP,F,T,c));
+        result = search.search(q,new TermRangeFilter("id",minIP,medIP,F,T,c));
         assertEquals("not min, up to med", medId-minId, result.length());
 
         // very small sets
 
-        result = search.search(q,new RangeFilter("id",minIP,minIP,F,F,c));
+        result = search.search(q,new TermRangeFilter("id",minIP,minIP,F,F,c));
         assertEquals("min,min,F,F", 0, result.length());
-        result = search.search(q,new RangeFilter("id",medIP,medIP,F,F,c));
+        result = search.search(q,new TermRangeFilter("id",medIP,medIP,F,F,c));
         assertEquals("med,med,F,F", 0, result.length());
-        result = search.search(q,new RangeFilter("id",maxIP,maxIP,F,F,c));
+        result = search.search(q,new TermRangeFilter("id",maxIP,maxIP,F,F,c));
         assertEquals("max,max,F,F", 0, result.length());
 
-        result = search.search(q,new RangeFilter("id",minIP,minIP,T,T,c));
+        result = search.search(q,new TermRangeFilter("id",minIP,minIP,T,T,c));
         assertEquals("min,min,T,T", 1, result.length());
-        result = search.search(q,new RangeFilter("id",null,minIP,F,T,c));
+        result = search.search(q,new TermRangeFilter("id",null,minIP,F,T,c));
         assertEquals("nul,min,F,T", 1, result.length());
 
-        result = search.search(q,new RangeFilter("id",maxIP,maxIP,T,T,c));
+        result = search.search(q,new TermRangeFilter("id",maxIP,maxIP,T,T,c));
         assertEquals("max,max,T,T", 1, result.length());
-        result = search.search(q,new RangeFilter("id",maxIP,null,T,F,c));
+        result = search.search(q,new TermRangeFilter("id",maxIP,null,T,F,c));
         assertEquals("max,nul,T,T", 1, result.length());
 
-        result = search.search(q,new RangeFilter("id",medIP,medIP,T,T,c));
+        result = search.search(q,new TermRangeFilter("id",medIP,medIP,T,T,c));
         assertEquals("med,med,T,T", 1, result.length());
     }
 
@@ -229,47 +229,47 @@
 
         // test extremes, bounded on both ends
         
-  result = search.search(q,new RangeFilter("rand",minRP,maxRP,T,T), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,T,T), numDocs).scoreDocs;
   assertEquals("find all", numDocs, result.length);
 
-  result = search.search(q,new RangeFilter("rand",minRP,maxRP,T,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,T,F), numDocs).scoreDocs;
   assertEquals("all but biggest", numDocs-1, result.length);
 
-  result = search.search(q,new RangeFilter("rand",minRP,maxRP,F,T), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,F,T), numDocs).scoreDocs;
   assertEquals("all but smallest", numDocs-1, result.length);
         
-  result = search.search(q,new RangeFilter("rand",minRP,maxRP,F,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,F,F), numDocs).scoreDocs;
         assertEquals("all but extremes", numDocs-2, result.length);
     
         // unbounded
 
-  result = search.search(q,new RangeFilter("rand",minRP,null,T,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("rand",minRP,null,T,F), numDocs).scoreDocs;
   assertEquals("smallest and up", numDocs, result.length);
 
-  result = search.search(q,new RangeFilter("rand",null,maxRP,F,T), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("rand",null,maxRP,F,T), numDocs).scoreDocs;
   assertEquals("biggest and down", numDocs, result.length);
 
-  result = search.search(q,new RangeFilter("rand",minRP,null,F,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("rand",minRP,null,F,F), numDocs).scoreDocs;
   assertEquals("not smallest, but up", numDocs-1, result.length);
         
-  result = search.search(q,new RangeFilter("rand",null,maxRP,F,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("rand",null,maxRP,F,F), numDocs).scoreDocs;
   assertEquals("not biggest, but down", numDocs-1, result.length);
         
         // very small sets
 
-  result = search.search(q,new RangeFilter("rand",minRP,minRP,F,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("rand",minRP,minRP,F,F), numDocs).scoreDocs;
   assertEquals("min,min,F,F", 0, result.length);
-  result = search.search(q,new RangeFilter("rand",maxRP,maxRP,F,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("rand",maxRP,maxRP,F,F), numDocs).scoreDocs;
   assertEquals("max,max,F,F", 0, result.length);
                      
-  result = search.search(q,new RangeFilter("rand",minRP,minRP,T,T), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("rand",minRP,minRP,T,T), numDocs).scoreDocs;
   assertEquals("min,min,T,T", 1, result.length);
-  result = search.search(q,new RangeFilter("rand",null,minRP,F,T), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("rand",null,minRP,F,T), numDocs).scoreDocs;
   assertEquals("nul,min,F,T", 1, result.length);
 
-  result = search.search(q,new RangeFilter("rand",maxRP,maxRP,T,T), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("rand",maxRP,maxRP,T,T), numDocs).scoreDocs;
   assertEquals("max,max,T,T", 1, result.length);
-  result = search.search(q,new RangeFilter("rand",maxRP,null,T,F), numDocs).scoreDocs;
+  result = search.search(q,new TermRangeFilter("rand",maxRP,null,T,F), numDocs).scoreDocs;
   assertEquals("max,nul,T,T", 1, result.length);
         
     }
@@ -294,47 +294,47 @@
 
         // test extremes, bounded on both ends
 
-        result = search.search(q,new RangeFilter("rand",minRP,maxRP,T,T,c));
+        result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,T,T,c));
         assertEquals("find all", numDocs, result.length());
 
-        result = search.search(q,new RangeFilter("rand",minRP,maxRP,T,F,c));
+        result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,T,F,c));
         assertEquals("all but biggest", numDocs-1, result.length());
 
-        result = search.search(q,new RangeFilter("rand",minRP,maxRP,F,T,c));
+        result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,F,T,c));
         assertEquals("all but smallest", numDocs-1, result.length());
 
-        result = search.search(q,new RangeFilter("rand",minRP,maxRP,F,F,c));
+        result = search.search(q,new TermRangeFilter("rand",minRP,maxRP,F,F,c));
         assertEquals("all but extremes", numDocs-2, result.length());
 
         // unbounded
 
-        result = search.search(q,new RangeFilter("rand",minRP,null,T,F,c));
+        result = search.search(q,new TermRangeFilter("rand",minRP,null,T,F,c));
         assertEquals("smallest and up", numDocs, result.length());
 
-        result = search.search(q,new RangeFilter("rand",null,maxRP,F,T,c));
+        result = search.search(q,new TermRangeFilter("rand",null,maxRP,F,T,c));
         assertEquals("biggest and down", numDocs, result.length());
 
-        result = search.search(q,new RangeFilter("rand",minRP,null,F,F,c));
+        result = search.search(q,new TermRangeFilter("rand",minRP,null,F,F,c));
         assertEquals("not smallest, but up", numDocs-1, result.length());
 
-        result = search.search(q,new RangeFilter("rand",null,maxRP,F,F,c));
+        result = search.search(q,new TermRangeFilter("rand",null,maxRP,F,F,c));
         assertEquals("not biggest, but down", numDocs-1, result.length());
 
         // very small sets
 
-        result = search.search(q,new RangeFilter("rand",minRP,minRP,F,F,c));
+        result = search.search(q,new TermRangeFilter("rand",minRP,minRP,F,F,c));
         assertEquals("min,min,F,F", 0, result.length());
-        result = search.search(q,new RangeFilter("rand",maxRP,maxRP,F,F,c));
+        result = search.search(q,new TermRangeFilter("rand",maxRP,maxRP,F,F,c));
         assertEquals("max,max,F,F", 0, result.length());
 
-        result = search.search(q,new RangeFilter("rand",minRP,minRP,T,T,c));
+        result = search.search(q,new TermRangeFilter("rand",minRP,minRP,T,T,c));
         assertEquals("min,min,T,T", 1, result.length());
-        result = search.search(q,new RangeFilter("rand",null,minRP,F,T,c));
+        result = search.search(q,new TermRangeFilter("rand",null,minRP,F,T,c));
         assertEquals("nul,min,F,T", 1, result.length());
 
-        result = search.search(q,new RangeFilter("rand",maxRP,maxRP,T,T,c));
+        result = search.search(q,new TermRangeFilter("rand",maxRP,maxRP,T,T,c));
         assertEquals("max,max,T,T", 1, result.length());
-        result = search.search(q,new RangeFilter("rand",maxRP,null,T,F,c));
+        result = search.search(q,new TermRangeFilter("rand",maxRP,null,T,F,c));
         assertEquals("max,nul,T,T", 1, result.length());
     }
     
@@ -365,14 +365,14 @@
         
         // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
         // orders the U+0698 character before the U+0633 character, so the single
-        // index Term below should NOT be returned by a RangeFilter with a Farsi
+        // index Term below should NOT be returned by a TermRangeFilter with a Farsi
         // Collator (or an Arabic one for the case when Farsi is not supported).
         Hits result = search.search
-            (q, new RangeFilter("content", "\u062F", "\u0698", T, T, collator));
+            (q, new TermRangeFilter("content", "\u062F", "\u0698", T, T, collator));
         assertEquals("The index Term should not be included.", 0, result.length());
 
         result = search.search
-            (q, new RangeFilter("content", "\u0633", "\u0638", T, T, collator));
+            (q, new TermRangeFilter("content", "\u0633", "\u0638", T, T, collator));
         assertEquals("The index Term should be included.", 1, result.length());
         search.close();
     }
@@ -403,17 +403,17 @@
         Query q = new TermQuery(new Term("body","body"));
 
         Collator collator = Collator.getInstance(new Locale("da", "dk"));
-        Query query = new RangeQuery
+        Query query = new TermRangeQuery
             ("content", "H\u00D8T", "MAND", false, false, collator);
 
         // Unicode order would not include "H\u00C5T" in [ "H\u00D8T", "MAND" ],
         // but Danish collation does.
         Hits result = search.search
-            (q, new RangeFilter("content", "H\u00D8T", "MAND", F, F, collator));
+            (q, new TermRangeFilter("content", "H\u00D8T", "MAND", F, F, collator));
         assertEquals("The index Term should be included.", 1, result.length());
 
         result = search.search
-            (q, new RangeFilter("content", "H\u00C5T", "MAND", F, F, collator));
+            (q, new TermRangeFilter("content", "H\u00C5T", "MAND", F, F, collator));
         assertEquals
             ("The index Term should not be included.", 0, result.length());
         search.close();
Index: src/test/org/apache/lucene/search/TestTermRangeQuery.java
===================================================================
--- src/test/org/apache/lucene/search/TestTermRangeQuery.java	(revision 790584)
+++ src/test/org/apache/lucene/search/TestTermRangeQuery.java	(working copy)
@@ -35,7 +35,7 @@
 import java.text.Collator;
 
 
-public class TestRangeQuery extends LuceneTestCase {
+public class TestTermRangeQuery extends LuceneTestCase {
 
   private int docCount = 0;
   private RAMDirectory dir;
@@ -46,7 +46,7 @@
   }
 
   public void testExclusive() throws Exception {
-    Query query = new RangeQuery("content", "A", "C", false, false);
+    Query query = new TermRangeQuery("content", "A", "C", false, false);
     initializeIndex(new String[] {"A", "B", "C", "D"});
     IndexSearcher searcher = new IndexSearcher(dir);
     ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
@@ -84,7 +84,7 @@
   }
 
   public void testInclusive() throws Exception {
-    Query query = new RangeQuery("content", "A", "C", true, true);
+    Query query = new TermRangeQuery("content", "A", "C", true, true);
 
     initializeIndex(new String[]{"A", "B", "C", "D"});
     IndexSearcher searcher = new IndexSearcher(dir);
@@ -106,10 +106,10 @@
   }
 
   public void testEqualsHashcode() {
-    Query query = new RangeQuery("content", "A", "C", true, true);
+    Query query = new TermRangeQuery("content", "A", "C", true, true);
     
     query.setBoost(1.0f);
-    Query other = new RangeQuery("content", "A", "C", true, true);
+    Query other = new TermRangeQuery("content", "A", "C", true, true);
     other.setBoost(1.0f);
 
     assertEquals("query equals itself is true", query, query);
@@ -119,40 +119,40 @@
     other.setBoost(2.0f);
     assertFalse("Different boost queries are not equal", query.equals(other));
 
-    other = new RangeQuery("notcontent", "A", "C", true, true);
+    other = new TermRangeQuery("notcontent", "A", "C", true, true);
     assertFalse("Different fields are not equal", query.equals(other));
 
-    other = new RangeQuery("content", "X", "C", true, true);
+    other = new TermRangeQuery("content", "X", "C", true, true);
     assertFalse("Different lower terms are not equal", query.equals(other));
 
-    other = new RangeQuery("content", "A", "Z", true, true);
+    other = new TermRangeQuery("content", "A", "Z", true, true);
     assertFalse("Different upper terms are not equal", query.equals(other));
 
-    query = new RangeQuery("content", null, "C", true, true);
-    other = new RangeQuery("content", null, "C", true, true);
+    query = new TermRangeQuery("content", null, "C", true, true);
+    other = new TermRangeQuery("content", null, "C", true, true);
     assertEquals("equivalent queries with null lowerterms are equal()", query, other);
     assertEquals("hashcode must return same value when equals is true", query.hashCode(), other.hashCode());
 
-    query = new RangeQuery("content", "C", null, true, true);
-    other = new RangeQuery("content", "C", null, true, true);
+    query = new TermRangeQuery("content", "C", null, true, true);
+    other = new TermRangeQuery("content", "C", null, true, true);
     assertEquals("equivalent queries with null upperterms are equal()", query, other);
     assertEquals("hashcode returns same value", query.hashCode(), other.hashCode());
 
-    query = new RangeQuery("content", null, "C", true, true);
-    other = new RangeQuery("content", "C", null, true, true);
+    query = new TermRangeQuery("content", null, "C", true, true);
+    other = new TermRangeQuery("content", "C", null, true, true);
     assertFalse("queries with different upper and lower terms are not equal", query.equals(other));
 
-    query = new RangeQuery("content", "A", "C", false, false);
-    other = new RangeQuery("content", "A", "C", true, true);
+    query = new TermRangeQuery("content", "A", "C", false, false);
+    other = new TermRangeQuery("content", "A", "C", true, true);
     assertFalse("queries with different inclusive are not equal", query.equals(other));
     
-    query = new RangeQuery("content", "A", "C", false, false);
-    other = new RangeQuery("content", "A", "C", false, false, Collator.getInstance());
+    query = new TermRangeQuery("content", "A", "C", false, false);
+    other = new TermRangeQuery("content", "A", "C", false, false, Collator.getInstance());
     assertFalse("a query with a collator is not equal to one without", query.equals(other));
   }
 
   public void testExclusiveCollating() throws Exception {
-    Query query = new RangeQuery("content", "A", "C", false, false, Collator.getInstance(Locale.ENGLISH));
+    Query query = new TermRangeQuery("content", "A", "C", false, false, Collator.getInstance(Locale.ENGLISH));
     initializeIndex(new String[] {"A", "B", "C", "D"});
     IndexSearcher searcher = new IndexSearcher(dir);
     ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
@@ -173,7 +173,7 @@
   }
 
   public void testInclusiveCollating() throws Exception {
-    Query query = new RangeQuery("content", "A", "C",true, true, Collator.getInstance(Locale.ENGLISH));
+    Query query = new TermRangeQuery("content", "A", "C",true, true, Collator.getInstance(Locale.ENGLISH));
 
     initializeIndex(new String[]{"A", "B", "C", "D"});
     IndexSearcher searcher = new IndexSearcher(dir);
@@ -199,17 +199,17 @@
     // RuleBasedCollator.  However, the Arabic Locale seems to order the Farsi
     // characters properly.
     Collator collator = Collator.getInstance(new Locale("ar"));
-    Query query = new RangeQuery("content", "\u062F", "\u0698", true, true, collator);
+    Query query = new TermRangeQuery("content", "\u062F", "\u0698", true, true, collator);
     // Unicode order would include U+0633 in [ U+062F - U+0698 ], but Farsi
     // orders the U+0698 character before the U+0633 character, so the single
-    // index Term below should NOT be returned by a RangeQuery with a Farsi
+    // index Term below should NOT be returned by a TermRangeQuery with a Farsi
     // Collator (or an Arabic one for the case when Farsi is not supported).
     initializeIndex(new String[]{ "\u0633\u0627\u0628"});
     IndexSearcher searcher = new IndexSearcher(dir);
     ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals("The index Term should not be included.", 0, hits.length);
 
-    query = new RangeQuery("content", "\u0633", "\u0638",true, true, collator);
+    query = new TermRangeQuery("content", "\u0633", "\u0638",true, true, collator);
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals("The index Term should be included.", 1, hits.length);
     searcher.close();
@@ -220,7 +220,7 @@
     // Danish collation orders the words below in the given order (example taken
     // from TestSort.testInternationalSort() ).
     String[] words = { "H\u00D8T", "H\u00C5T", "MAND" };
-    Query query = new RangeQuery("content", "H\u00D8T", "MAND", false, false, collator);
+    Query query = new TermRangeQuery("content", "H\u00D8T", "MAND", false, false, collator);
 
     // Unicode order would not include "H\u00C5T" in [ "H\u00D8T", "MAND" ],
     // but Danish collation does.
@@ -229,7 +229,7 @@
     ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals("The index Term should be included.", 1, hits.length);
 
-    query = new RangeQuery("content", "H\u00C5T", "MAND", false, false, collator);
+    query = new TermRangeQuery("content", "H\u00C5T", "MAND", false, false, collator);
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals("The index Term should not be included.", 0, hits.length);
     searcher.close();
@@ -315,9 +315,8 @@
   public void testExclusiveLowerNull() throws Exception {
     Analyzer analyzer = new SingleCharAnalyzer();
     //http://issues.apache.org/jira/browse/LUCENE-38
-    Query query = new RangeQuery(null,
-                                 new Term("content", "C"),
-                                 false);
+    Query query = new TermRangeQuery("content", null, "C",
+                                 false, false);
     initializeIndex(new String[] {"A", "B", "", "C", "D"}, analyzer);
     IndexSearcher searcher = new IndexSearcher(dir);
     Hits hits = searcher.search(query);
@@ -349,9 +348,7 @@
   public void testInclusiveLowerNull() throws Exception {
     //http://issues.apache.org/jira/browse/LUCENE-38
     Analyzer analyzer = new SingleCharAnalyzer();
-    Query query = new RangeQuery(null,
-                                 new Term("content", "C"),
-                                 true);
+    Query query = new TermRangeQuery("content", null, "C", true, true);
     initializeIndex(new String[]{"A", "B", "","C", "D"}, analyzer);
     IndexSearcher searcher = new IndexSearcher(dir);
     Hits hits = searcher.search(query);
