Index: lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDDistanceQuery.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDDistanceQuery.java	(revision 0)
+++ lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDDistanceQuery.java	(working copy)
@@ -0,0 +1,247 @@
+package org.apache.lucene.bkdtree;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Set;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.SortedNumericDocValues;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.ConstantScoreScorer;
+import org.apache.lucene.search.ConstantScoreWeight;
+import org.apache.lucene.search.DocIdSet;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.Weight;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.GeoProjectionUtils;
+import org.apache.lucene.util.GeoUtils;
+import org.apache.lucene.util.SloppyMath;
+import org.apache.lucene.util.ToStringUtils;
+
+/** Finds all previously indexed points that fall within the specified distance from a center point.
+ *
+ * <p>The field must be indexed with {@link BKDTreeDocValuesFormat}, and {@link BKDPointField} added per document.
+ *
+ * @lucene.experimental */
+
+public class BKDDistanceQuery extends Query {
+  final String field;
+  final double centerLat;
+  final double centerLon;
+  final double radiusMeters;
+  final double minLon, maxLon;
+  final double minLat, maxLat;
+
+  public BKDDistanceQuery(String field, double centerLat, double centerLon, double radiusMeters) {
+    this.field = field;
+    if (BKDTreeWriter.validLat(centerLat) == false) {
+      throw new IllegalArgumentException("centerLat=" + centerLat + " is not a valid latitude");
+    }
+    if (BKDTreeWriter.validLon(centerLon) == false) {
+      throw new IllegalArgumentException("centerLon=" + centerLon + " is not a valid longitude");
+    }
+    if (radiusMeters <= 0.0) {
+      throw new IllegalArgumentException("radiusMeters=" + radiusMeters + " is not a valid radius");
+    }
+    this.centerLat = centerLat;
+    this.centerLon = centerLon;
+    this.radiusMeters = radiusMeters;
+
+    double[] t = GeoProjectionUtils.pointFromLonLatBearing(centerLon, centerLat, 0, radiusMeters, null);
+    double[] r = GeoProjectionUtils.pointFromLonLatBearing(centerLon, centerLat, 90, radiusMeters, null);
+    double[] b = GeoProjectionUtils.pointFromLonLatBearing(centerLon, centerLat, 180, radiusMeters, null);
+    double[] l = GeoProjectionUtils.pointFromLonLatBearing(centerLon, centerLat, 270, radiusMeters, null);
+
+    minLon = GeoUtils.normalizeLon(l[0]);
+    maxLon = GeoUtils.normalizeLon(r[0]);
+    minLat = GeoUtils.normalizeLat(b[1]);
+    maxLat = GeoUtils.normalizeLat(t[1]);
+    System.out.println("distance query bbox: lon=" + minLon + " TO " + maxLon + "; lat=" + minLat + " TO " + maxLat);
+    // nocommit what happens when we cross dateline?
+    assert minLon <= maxLon;
+    assert minLat <= maxLat;
+  }
+
+  /** Used by rewrite, when circle crosses the date line */
+  private BKDDistanceQuery(String field, double centerLat, double centerLon, double radiusMeters,
+                           double minLat, double maxLat, double minLon, double maxLon) {
+    this.field = field;
+    assert BKDTreeWriter.validLat(centerLat);
+    assert BKDTreeWriter.validLon(centerLon);
+    assert radiusMeters > 0.0;
+
+    this.centerLat = centerLat;
+    this.centerLon = centerLon;
+    this.radiusMeters = radiusMeters;
+    this.minLat = minLat;
+    this.maxLat = maxLat;
+    this.minLon = minLon;
+    this.maxLon = maxLon;
+  }    
+
+  @Override
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+
+    // I don't use RandomAccessWeight here: it's no good to approximate with "match all docs"; this is an inverted structure and should be
+    // used in the first pass:
+
+    return new ConstantScoreWeight(this) {
+
+      @Override
+      public Scorer scorer(LeafReaderContext context) throws IOException {
+        LeafReader reader = context.reader();
+        SortedNumericDocValues sdv = reader.getSortedNumericDocValues(field);
+        if (sdv == null) {
+          // No docs in this segment had this field
+          return null;
+        }
+
+        if (sdv instanceof BKDTreeSortedNumericDocValues == false) {
+          throw new IllegalStateException("field \"" + field + "\" was not indexed with BKDTreeDocValuesFormat: got: " + sdv);
+        }
+        BKDTreeSortedNumericDocValues treeDV = (BKDTreeSortedNumericDocValues) sdv;
+        BKDTreeReader tree = treeDV.getBKDTreeReader();
+
+        DocIdSet result = tree.intersect(minLat, maxLat, minLon, maxLon,
+                                         new BKDTreeReader.LatLonFilter() {
+
+                                           @Override
+                                           public boolean accept(double lat, double lon) {
+                                             boolean result = SloppyMath.haversin(centerLat, centerLon, lat, lon) * 1000.0 <= radiusMeters;
+                                             System.out.println("accept? centerLat=" + centerLat + " centerLon=" + centerLon + " lat=" + lat + " lon=" + lon + " result=" + result);
+                                             return result;
+                                           }
+
+                                           @Override
+                                           public BKDTreeReader.Relation compare(double cellLatMin, double cellLatMax, double cellLonMin, double cellLonMax) {
+                                             System.out.println("compare lat=" + cellLatMin + " TO " + cellLatMax + "; lon=" + cellLonMin + " TO " + cellLonMax);
+                                             if (GeoUtils.rectWithinCircle(cellLonMin, cellLatMin, cellLonMax, cellLatMax, centerLon, centerLat, radiusMeters)) {
+                                               System.out.println("  CELL_INSIDE_SHAPE");
+                                               return BKDTreeReader.Relation.CELL_INSIDE_SHAPE;
+                                             } else if (GeoUtils.rectCrossesCircle(cellLonMin, cellLatMin, cellLonMax, cellLatMax, centerLon, centerLat, radiusMeters)) {
+                                               System.out.println("  SHAPE_CROSSES_CELL");
+                                               return BKDTreeReader.Relation.SHAPE_CROSSES_CELL;
+                                             } else {
+                                               System.out.println("  SHAPE_OUTSIDE_CELL");
+                                               return BKDTreeReader.Relation.SHAPE_OUTSIDE_CELL;
+                                             }
+                                           }
+                                         }, treeDV.delegate);
+
+        return new ConstantScoreScorer(this, score(), result.iterator());
+      }
+    };
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    if (radiusMeters >= GeoProjectionUtils.SEMIMINOR_AXIS) {
+      return new MatchAllDocsQuery();
+    }
+
+    // Crosses date line: we just rewrite into OR of two bboxes:
+    if (maxLon < minLon) {
+
+      // Disable coord here because a multi-valued doc could match both circles and get unfairly boosted:
+      BooleanQuery.Builder q = new BooleanQuery.Builder();
+      q.setDisableCoord(true);
+
+      // E.g.: maxLon = -179, minLon = 179
+      BKDDistanceQuery left = new BKDDistanceQuery(field, centerLat, centerLon, radiusMeters, minLat, maxLat, BKDTreeWriter.MIN_LON_INCL, maxLon);
+      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));
+      BKDDistanceQuery right = new BKDDistanceQuery(field, centerLat, centerLon, radiusMeters, minLat, maxLat, minLon, BKDTreeWriter.MAX_LON_INCL);
+      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));
+      return q.build();
+    } else {
+      return this;
+    }
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof BKDDistanceQuery)) return false;
+    if (!super.equals(o)) return false;
+
+    BKDDistanceQuery that = (BKDDistanceQuery) o;
+
+    if (Double.compare(that.centerLat, centerLat) != 0) return false;
+    if (Double.compare(that.centerLon, centerLon) != 0) return false;
+    if (Double.compare(that.radiusMeters, radiusMeters) != 0) return false;
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = super.hashCode();
+    long temp;
+    temp = Double.doubleToLongBits(centerLon);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(centerLat);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(radiusMeters);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    return result;
+  }
+
+  @Override
+  public String toString(String field) {
+    // nocommit get crossesDateLine into this
+    final StringBuilder sb = new StringBuilder();
+    sb.append(getClass().getSimpleName());
+    sb.append(':');
+    if (!this.field.equals(field)) {
+      sb.append(" field=");
+      sb.append(this.field);
+      sb.append(':');
+    }
+    return sb.append( " Center: [")
+        .append(centerLon)
+        .append(',')
+        .append(centerLat)
+        .append(']')
+        .append(" Distance: ")
+        .append(radiusMeters)
+        .append(" meters")
+        .append("]")
+        .toString();
+  }
+
+  public double getCenterLon() {
+    return this.centerLon;
+  }
+
+  public double getCenterLat() {
+    return this.centerLat;
+  }
+
+  public double getRadiusMeters() {
+    return this.radiusMeters;
+  }
+}

Property changes on: lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDDistanceQuery.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDPointInBBoxQuery.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDPointInBBoxQuery.java	(revision 1702193)
+++ lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDPointInBBoxQuery.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import java.io.IOException;
+import java.util.Set;
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReader;
@@ -78,7 +79,6 @@
     // used in the first pass:
 
     return new ConstantScoreWeight(this) {
-
       @Override
       public Scorer scorer(LeafReaderContext context) throws IOException {
         LeafReader reader = context.reader();
@@ -96,9 +96,7 @@
 
         DocIdSet result = tree.intersect(minLat, maxLat, minLon, maxLon, null, treeDV.delegate);
 
-        final DocIdSetIterator disi = result.iterator();
-
-        return new ConstantScoreScorer(this, score(), disi);
+        return new ConstantScoreScorer(this, score(), result.iterator());
       }
     };
   }
Index: lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDPointInPolygonQuery.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDPointInPolygonQuery.java	(revision 1702193)
+++ lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDPointInPolygonQuery.java	(working copy)
@@ -19,6 +19,7 @@
 
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.Set;
 
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
@@ -25,6 +26,8 @@
 import org.apache.lucene.index.SortedNumericDocValues;
 import org.apache.lucene.search.ConstantScoreScorer;
 import org.apache.lucene.search.ConstantScoreWeight;
+import org.apache.lucene.search.ConstantScoreScorer;
+import org.apache.lucene.search.ConstantScoreWeight;
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.IndexSearcher;
@@ -147,9 +150,7 @@
                                            }
                                          }, treeDV.delegate);
 
-        final DocIdSetIterator disi = result.iterator();
-
-        return new ConstantScoreScorer(this, score(), disi);
+        return new ConstantScoreScorer(this, score(), result.iterator());
       }
     };
   }
Index: lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader.java	(revision 1702193)
+++ lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader.java	(working copy)
@@ -131,13 +131,39 @@
     return state.docs.build(hitCount);
   }
 
+  private boolean accept(QueryState state, int docID) throws IOException {
+    System.out.println("    check accept docID=" + docID);
+    state.sndv.setDocument(docID);
+    // How many values this doc has:
+    int count = state.sndv.count();
+    for(int j=0;j<count;j++) {
+      long enc = state.sndv.valueAt(j);
+
+      int latEnc = (int) ((enc>>32) & 0xffffffffL);
+      int lonEnc = (int) (enc & 0xffffffffL);
+
+      if (latEnc >= state.latMinEnc &&
+          latEnc < state.latMaxEnc &&
+          lonEnc >= state.lonMinEnc &&
+          lonEnc < state.lonMaxEnc &&
+          (state.latLonFilter == null ||
+           state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {
+        System.out.println("      yes");
+        return true;
+      }
+    }
+
+    return false;
+  }
+
   /** Fast path: this is called when the query rect fully encompasses all cells under this node. */
   private int addAll(QueryState state, int nodeID) throws IOException {
-
+    System.out.println("  addAll nodeID=" + nodeID);
     //long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;
     //long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;
 
     if (nodeID >= leafNodeOffset) {
+      System.out.println("    leaf");
 
       /*
       System.out.println("A: " + BKDTreeWriter.decodeLat(cellLatMinEnc)
@@ -161,6 +187,7 @@
       state.docs.grow(count);
       for(int i=0;i<count;i++) {
         int docID = state.in.readInt();
+        assert accept(state, docID);
         state.docs.add(docID);
       }
 
@@ -188,6 +215,8 @@
                         int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)
     throws IOException {
 
+    System.out.println("BKD: intersect nodeID=" + nodeID);
+
     // 2.06 sec -> 1.52 sec for 225 OSM London queries:
     if (state.latLonFilter != null) {
 
@@ -230,6 +259,8 @@
     //System.out.println("\nintersect node=" + nodeID + " vs " + leafNodeOffset);
 
     if (nodeID >= leafNodeOffset) {
+      System.out.println("  intersect leaf");
+
       // Leaf node; scan and filter all points in this block:
       //System.out.println("    intersect leaf nodeID=" + nodeID + " vs leafNodeOffset=" + leafNodeOffset + " fp=" + leafBlockFPs[nodeID-leafNodeOffset]);
       int hitCount = 0;
@@ -256,27 +287,9 @@
       state.docs.grow(count);
       for(int i=0;i<count;i++) {
         int docID = state.in.readInt();
-        state.sndv.setDocument(docID);
-        // How many values this doc has:
-        int docValueCount = state.sndv.count();
-        for(int j=0;j<docValueCount;j++) {
-          long enc = state.sndv.valueAt(j);
-
-          int latEnc = (int) ((enc>>32) & 0xffffffffL);
-          int lonEnc = (int) (enc & 0xffffffffL);
-
-          if (latEnc >= state.latMinEnc &&
-              latEnc < state.latMaxEnc &&
-              lonEnc >= state.lonMinEnc &&
-              lonEnc < state.lonMaxEnc &&
-              (state.latLonFilter == null ||
-               state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {
-            state.docs.add(docID);
-            hitCount++;
-
-            // Stop processing values for this doc:
-            break;
-          }
+        if (accept(state, docID)) {
+          state.docs.add(docID);
+          hitCount++;
         }
       }
 
Index: lucene/sandbox/src/java/org/apache/lucene/search/GeoPointDistanceQuery.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/search/GeoPointDistanceQuery.java	(revision 1702193)
+++ lucene/sandbox/src/java/org/apache/lucene/search/GeoPointDistanceQuery.java	(working copy)
@@ -42,15 +42,15 @@
 public final class GeoPointDistanceQuery extends GeoPointInBBoxQuery {
   protected final double centerLon;
   protected final double centerLat;
-  protected final double radius;
+  protected final double radiusMeters;
 
   /** NOTE: radius is in meters. */
-  public GeoPointDistanceQuery(final String field, final double centerLon, final double centerLat, final double radius) {
-    this(field, computeBBox(centerLon, centerLat, radius), centerLon, centerLat, radius);
+  public GeoPointDistanceQuery(final String field, final double centerLon, final double centerLat, final double radiusMeters) {
+    this(field, computeBBox(centerLon, centerLat, radiusMeters), centerLon, centerLat, radiusMeters);
   }
 
   private GeoPointDistanceQuery(final String field, GeoBoundingBox bbox, final double centerLon,
-                                final double centerLat, final double radius) {
+                                final double centerLat, final double radiusMeters) {
     super(field, bbox.minLon, bbox.minLat, bbox.maxLon, bbox.maxLat);
 
     if (GeoUtils.isValidLon(centerLon) == false) {
@@ -61,9 +61,13 @@
       throw new IllegalArgumentException("invalid centerLat " + centerLat);
     }
 
+    if (radiusMeters <= 0.0) {
+      throw new IllegalArgumentException("invalid radiusMeters " + radiusMeters);
+    }
+
     this.centerLon = centerLon;
     this.centerLat = centerLat;
-    this.radius = radius;
+    this.radiusMeters = radiusMeters;
   }
 
   @Override
@@ -82,12 +86,16 @@
     return new GeoPointDistanceQueryImpl(field, this, new GeoBoundingBox(this.minLon, this.maxLon, this.minLat, this.maxLat));
   }
 
-  static GeoBoundingBox computeBBox(final double centerLon, final double centerLat, final double radius) {
-    double[] t = GeoProjectionUtils.pointFromLonLatBearing(centerLon, centerLat, 0, radius, null);
-    double[] r = GeoProjectionUtils.pointFromLonLatBearing(centerLon, centerLat, 90, radius, null);
-    double[] b = GeoProjectionUtils.pointFromLonLatBearing(centerLon, centerLat, 180, radius, null);
-    double[] l = GeoProjectionUtils.pointFromLonLatBearing(centerLon, centerLat, 270, radius, null);
+  static GeoBoundingBox computeBBox(final double centerLon, final double centerLat, final double radiusMeters) {
+    double[] t = GeoProjectionUtils.pointFromLonLatBearing(centerLon, centerLat, 0, radiusMeters, null);
+    double[] r = GeoProjectionUtils.pointFromLonLatBearing(centerLon, centerLat, 90, radiusMeters, null);
+    double[] b = GeoProjectionUtils.pointFromLonLatBearing(centerLon, centerLat, 180, radiusMeters, null);
+    double[] l = GeoProjectionUtils.pointFromLonLatBearing(centerLon, centerLat, 270, radiusMeters, null);
 
+    assert l[0] <= r[0];
+    assert b[1] <= t[1];
+
+    // nocommit is b[1] really the minLat?  confusing!
     return new GeoBoundingBox(GeoUtils.normalizeLon(l[0]), GeoUtils.normalizeLon(r[0]), GeoUtils.normalizeLat(b[1]),
         GeoUtils.normalizeLat(t[1]));
   }
@@ -102,7 +110,7 @@
 
     if (Double.compare(that.centerLat, centerLat) != 0) return false;
     if (Double.compare(that.centerLon, centerLon) != 0) return false;
-    if (Double.compare(that.radius, radius) != 0) return false;
+    if (Double.compare(that.radiusMeters, radiusMeters) != 0) return false;
 
     return true;
   }
@@ -115,7 +123,7 @@
     result = 31 * result + (int) (temp ^ (temp >>> 32));
     temp = Double.doubleToLongBits(centerLat);
     result = 31 * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(radius);
+    temp = Double.doubleToLongBits(radiusMeters);
     result = 31 * result + (int) (temp ^ (temp >>> 32));
     return result;
   }
@@ -136,17 +144,8 @@
         .append(centerLat)
         .append(']')
         .append(" Distance: ")
-        .append(radius)
-        .append(" m")
-        .append(" Lower Left: [")
-        .append(minLon)
-        .append(',')
-        .append(minLat)
-        .append(']')
-        .append(" Upper Right: [")
-        .append(maxLon)
-        .append(',')
-        .append(maxLat)
+        .append(radiusMeters)
+        .append(" meters")
         .append("]")
         .toString();
   }
@@ -159,7 +158,7 @@
     return this.centerLat;
   }
 
-  public double getRadius() {
-    return this.radius;
+  public double getRadiusMeters() {
+    return this.radiusMeters;
   }
 }
Index: lucene/sandbox/src/java/org/apache/lucene/search/GeoPointDistanceQueryImpl.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/search/GeoPointDistanceQueryImpl.java	(revision 1702193)
+++ lucene/sandbox/src/java/org/apache/lucene/search/GeoPointDistanceQueryImpl.java	(working copy)
@@ -55,12 +55,12 @@
 
     @Override
     protected boolean cellCrosses(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoUtils.rectCrossesCircle(minLon, minLat, maxLon, maxLat, query.centerLon, query.centerLat, query.radius);
+      return GeoUtils.rectCrossesCircle(minLon, minLat, maxLon, maxLat, query.centerLon, query.centerLat, query.radiusMeters);
     }
 
     @Override
     protected boolean cellWithin(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoUtils.rectWithinCircle(minLon, minLat, maxLon, maxLat, query.centerLon, query.centerLat, query.radius);
+      return GeoUtils.rectWithinCircle(minLon, minLat, maxLon, maxLat, query.centerLon, query.centerLat, query.radiusMeters);
     }
 
     @Override
@@ -77,7 +77,7 @@
      */
     @Override
     protected boolean postFilter(final double lon, final double lat) {
-      return (SloppyMath.haversin(query.centerLat, query.centerLon, lat, lon) * 1000.0 <= query.radius);
+      return (SloppyMath.haversin(query.centerLat, query.centerLon, lat, lon) * 1000.0 <= query.radiusMeters);
     }
   }
 
Index: lucene/sandbox/src/java/org/apache/lucene/util/GeoProjectionUtils.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/util/GeoProjectionUtils.java	(revision 1702193)
+++ lucene/sandbox/src/java/org/apache/lucene/util/GeoProjectionUtils.java	(working copy)
@@ -24,10 +24,10 @@
  */
 public class GeoProjectionUtils {
   // WGS84 earth-ellipsoid major (a) minor (b) radius, (f) flattening and eccentricity (e)
-  static final double SEMIMAJOR_AXIS = 6_378_137; // [m]
-  static final double FLATTENING = 1.0/298.257223563;
-  static final double SEMIMINOR_AXIS = SEMIMAJOR_AXIS * (1.0 - FLATTENING); //6_356_752.31420; // [m]
-  static final double ECCENTRICITY = StrictMath.sqrt((2.0 - FLATTENING) * FLATTENING);
+  public static final double SEMIMAJOR_AXIS = 6_378_137; // [m]
+  public static final double FLATTENING = 1.0/298.257223563;
+  public static final double SEMIMINOR_AXIS = SEMIMAJOR_AXIS * (1.0 - FLATTENING); //6_356_752.31420; // [m]
+  public static final double ECCENTRICITY = StrictMath.sqrt((2.0 - FLATTENING) * FLATTENING);
   static final double PI_OVER_2 = StrictMath.PI / 2.0D;
   static final double SEMIMAJOR_AXIS2 = SEMIMAJOR_AXIS * SEMIMAJOR_AXIS;
   static final double SEMIMINOR_AXIS2 = SEMIMINOR_AXIS * SEMIMINOR_AXIS;
Index: lucene/sandbox/src/java/org/apache/lucene/util/GeoUtils.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/util/GeoUtils.java	(revision 1702193)
+++ lucene/sandbox/src/java/org/apache/lucene/util/GeoUtils.java	(working copy)
@@ -291,11 +291,11 @@
   }
 
   private static boolean rectAnyCornersOutsideCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                                     final double centerLon, final double centerLat, final double radius) {
-    return (SloppyMath.haversin(centerLat, centerLon, rMinY, rMinX)*1000.0 > radius
-        || SloppyMath.haversin(centerLat, centerLon, rMaxY, rMinX)*1000.0 > radius
-        || SloppyMath.haversin(centerLat, centerLon, rMaxY, rMaxX)*1000.0 > radius
-        || SloppyMath.haversin(centerLat, centerLon, rMinY, rMaxX)*1000.0 > radius);
+                                                     final double centerLon, final double centerLat, final double radiusMeters) {
+    return (SloppyMath.haversin(centerLat, centerLon, rMinY, rMinX)*1000.0 > radiusMeters
+        || SloppyMath.haversin(centerLat, centerLon, rMaxY, rMinX)*1000.0 > radiusMeters
+        || SloppyMath.haversin(centerLat, centerLon, rMaxY, rMaxX)*1000.0 > radiusMeters
+        || SloppyMath.haversin(centerLat, centerLon, rMinY, rMaxX)*1000.0 > radiusMeters);
   }
 
   private static boolean rectAnyCornersInCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
@@ -315,16 +315,16 @@
    * Computes whether a rectangle crosses a circle
    */
   public static boolean rectCrossesCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                          final double centerLon, final double centerLat, final double radius) {
-    return rectAnyCornersInCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radius)
-        || lineCrossesSphere(rMinX, rMinY, 0, rMaxX, rMinY, 0, centerLon, centerLat, 0, radius)
-        || lineCrossesSphere(rMaxX, rMinY, 0, rMaxX, rMaxY, 0, centerLon, centerLat, 0, radius)
-        || lineCrossesSphere(rMaxX, rMaxY, 0, rMinX, rMaxY, 0, centerLon, centerLat, 0, radius)
-        || lineCrossesSphere(rMinX, rMaxY, 0, rMinX, rMinY, 0, centerLon, centerLat, 0, radius);
+                                          final double centerLon, final double centerLat, final double radiusMeters) {
+    return rectAnyCornersInCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters)
+        || lineCrossesSphere(rMinX, rMinY, 0, rMaxX, rMinY, 0, centerLon, centerLat, 0, radiusMeters)
+        || lineCrossesSphere(rMaxX, rMinY, 0, rMaxX, rMaxY, 0, centerLon, centerLat, 0, radiusMeters)
+        || lineCrossesSphere(rMaxX, rMaxY, 0, rMinX, rMaxY, 0, centerLon, centerLat, 0, radiusMeters)
+        || lineCrossesSphere(rMinX, rMaxY, 0, rMinX, rMinY, 0, centerLon, centerLat, 0, radiusMeters);
   }
 
   public static boolean circleWithinRect(double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-  final double centerLon, final double centerLat, final double radius) {
+                                         final double centerLon, final double centerLat, final double radius) {
     return !(centerLon < rMinX || centerLon > rMaxX || centerLat > rMaxY || centerLat < rMinY
         || SloppyMath.haversin(rMinY, centerLon, centerLat, centerLon) < radius
         || SloppyMath.haversin(rMaxY, centerLon, centerLat, centerLon) < radius
Index: lucene/sandbox/src/test/org/apache/lucene/bkdtree/TestBKDTree.java
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/bkdtree/TestBKDTree.java	(revision 1702193)
+++ lucene/sandbox/src/test/org/apache/lucene/bkdtree/TestBKDTree.java	(working copy)
@@ -17,6 +17,15 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.codecs.DocValuesFormat;
 import org.apache.lucene.codecs.lucene53.Lucene53Codec;
@@ -40,21 +49,15 @@
 import org.apache.lucene.util.Accountable;
 import org.apache.lucene.util.Accountables;
 import org.apache.lucene.util.FixedBitSet;
+import org.apache.lucene.util.GeoDistanceUtils;
+import org.apache.lucene.util.GeoUtils;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase.Nightly;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.SloppyMath;
 import org.apache.lucene.util.TestUtil;
 import org.junit.BeforeClass;
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 // TODO: can test framework assert we don't leak temp files?
 
 public class TestBKDTree extends LuceneTestCase {
@@ -61,9 +64,16 @@
 
   private static boolean smallBBox;
 
+  // error threshold for point-distance queries (in meters)
+  // @todo haversine is sloppy, would be good to have a better heuristic for
+  // determining the possible haversine error
+
   @BeforeClass
   public static void beforeClass() {
     smallBBox = random().nextBoolean();
+    if (VERBOSE && smallBBox) {
+      System.out.println("TEST: using small bbox");
+    }
   }
 
   public void testAllLatEqual() throws Exception {
@@ -402,7 +412,8 @@
         }
       }
     }
-    if (random().nextBoolean()) {
+    // nocommit
+    if (true || random().nextBoolean()) {
       w.forceMerge(1);
     }
     final IndexReader r = DirectoryReader.open(w, true);
@@ -412,6 +423,8 @@
     IndexSearcher s = newSearcher(r, false);
 
     int numThreads = TestUtil.nextInt(random(), 2, 5);
+    // nocommit
+    numThreads = 1;
 
     List<Thread> threads = new ArrayList<>();
     final int iters = atLeast(100);
@@ -437,100 +450,105 @@
             NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, "id");
 
             for (int iter=0;iter<iters && failed.get() == false;iter++) {
-              double lat0 = randomLat();
-              double lat1 = randomLat();
-              double lon0 = randomLon();
-              double lon1 = randomLon();
 
-              if (lat1 < lat0) {
-                double x = lat0;
-                lat0 = lat1;
-                lat1 = x;
+              if (VERBOSE) {
+                System.out.println("\nTEST: iter=" + iter);
               }
+              Query query;
+              VerifyHits verifyHits;
 
-              boolean crossesDateLine;
-              if (lon1 < lon0) {
-                if (random().nextBoolean()) {
-                  double x = lon0;
-                  lon0 = lon1;
-                  lon1 = x;
-                  crossesDateLine = false;
-                } else {
-                  crossesDateLine = true;
+              if (random().nextBoolean()) {
+                // BBox 
+                final GeoBoundingBox bbox = randomBBox(true);
+
+                query = new BKDPointInBBoxQuery("point", bbox.minLat, bbox.maxLat, bbox.minLon, bbox.maxLon);
+
+                verifyHits = new VerifyHits() {
+                    @Override
+                    protected Boolean shouldMatch(double pointLat, double pointLon) {
+                      return rectContainsPointEnc(bbox.minLat, bbox.maxLat, bbox.minLon, bbox.maxLon, pointLat, pointLon);
+                    }
+                    @Override
+                    protected void describe(int docID, double lat, double lon) {
+                    }
+                  };
+
+              } else if (random().nextBoolean()) {
+                // Distance
+
+                final double centerLat = randomLat();
+                final double centerLon = randomLon();
+
+                // radius (in meters) as a function of the random generated bbox
+                final double radiusMeters = random().nextDouble() * 200000;
+
+                if (VERBOSE) {
+                  System.out.println("  radiusMeters = " + radiusMeters);
                 }
-              } else {
-                crossesDateLine = false;
-              }
 
-              if (VERBOSE) {
-                System.out.println("\nTEST: iter=" + iter + " lat=" + lat0 + " TO " + lat1 + " lon=" + lon0 + " TO " + lon1 + " crossesDateLine=" + crossesDateLine);
-              }
+                // query using the centroid of the bounding box
+                query = new BKDDistanceQuery("point", centerLat, centerLon, radiusMeters);
 
-              Query query;
+                verifyHits = new VerifyHits() {
+                    @Override
+                    protected Boolean shouldMatch(double pointLat, double pointLon) {
+                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);
+                      boolean result = distanceKM*1000.0 <= radiusMeters;
+                      System.out.println("  shouldMatch?  centerLon=" + centerLon + " centerLat=" + centerLat + " pointLon=" + pointLon + " pointLat=" + pointLat + " result=" + result + " distanceMeters=" + (distanceKM * 1000));
+                      return result;
+                    }
+
+                    @Override
+                    protected void describe(int docID, double pointLat, double pointLon) {
+                      double distanceKM = SloppyMath.haversin(centerLat, centerLon, pointLat, pointLon);
+                      System.out.println("  docID=" + docID + " centerLon=" + centerLon + " centerLat=" + centerLat + " pointLon=" + pointLon + " pointLat=" + pointLat + " distanceMeters=" + (distanceKM * 1000) + " vs radiusMeters=" + radiusMeters);
+                    }
+                   };
+
               // TODO: get poly query working with dateline crossing too (how?)!
-              if (crossesDateLine || random().nextBoolean()) {
-                query = new BKDPointInBBoxQuery("point", lat0, lat1, lon0, lon1);
               } else {
+                final GeoBoundingBox bbox = randomBBox(false);
+
+                // Polygon
                 double[] lats = new double[5];
                 double[] lons = new double[5];
-                lats[0] = lat0;
-                lons[0] = lon0;
-                lats[1] = lat1;
-                lons[1] = lon0;
-                lats[2] = lat1;
-                lons[2] = lon1;
-                lats[3] = lat0;
-                lons[3] = lon1;
-                lats[4] = lat0;
-                lons[4] = lon0;
+                lats[0] = bbox.minLat;
+                lons[0] = bbox.minLon;
+                lats[1] = bbox.maxLat;
+                lons[1] = bbox.minLon;
+                lats[2] = bbox.maxLat;
+                lons[2] = bbox.maxLon;
+                lats[3] = bbox.minLat;
+                lons[3] = bbox.maxLon;
+                lats[4] = bbox.minLat;
+                lons[4] = bbox.minLon;
                 query = new BKDPointInPolygonQuery("point", lats, lons);
+
+                verifyHits = new VerifyHits() {
+                    @Override
+                    protected Boolean shouldMatch(double pointLat, double pointLon) {
+                      if (Math.abs(bbox.minLat-pointLat) < TOLERANCE ||
+                          Math.abs(bbox.maxLat-pointLat) < TOLERANCE ||
+                          Math.abs(bbox.minLon-pointLon) < TOLERANCE ||
+                          Math.abs(bbox.maxLon-pointLon) < TOLERANCE) {
+                        // The poly check quantizes slightly differently, so we allow for boundary cases to disagree
+                        return null;
+                      } else {
+                        return rectContainsPointEnc(bbox.minLat, bbox.maxLat, bbox.minLon, bbox.maxLon, pointLat, pointLon);
+                      }
+                    }
+
+                    @Override
+                    protected void describe(int docID, double lat, double lon) {
+                    }
+                  };
               }
 
               if (VERBOSE) {
-                System.out.println("  using query: " + query);
+                System.out.println("  query=" + query);
               }
 
-              final FixedBitSet hits = new FixedBitSet(r.maxDoc());
-              s.search(query, new SimpleCollector() {
-
-                  private int docBase;
-
-                  @Override
-                  public boolean needsScores() {
-                    return false;
-                  }
-
-                  @Override
-                  protected void doSetNextReader(LeafReaderContext context) throws IOException {
-                    docBase = context.docBase;
-                  }
-
-                  @Override
-                  public void collect(int doc) {
-                    hits.set(docBase+doc);
-                  }
-                });
-
-              if (VERBOSE) {
-                System.out.println("  hitCount: " + hits.cardinality());
-              }
-      
-              for(int docID=0;docID<r.maxDoc();docID++) {
-                int id = (int) docIDToID.get(docID);
-                boolean expected = deleted.contains(id) == false && rectContainsPointEnc(lat0, lat1, lon0, lon1, lats[id], lons[id]);
-                if (hits.get(docID) != expected) {
-                  if (query instanceof BKDPointInPolygonQuery &&
-                      (Math.abs(lat0-lats[id]) < TOLERANCE ||
-                       Math.abs(lat1-lats[id]) < TOLERANCE ||
-                       Math.abs(lon0-lons[id]) < TOLERANCE ||
-                       Math.abs(lon1-lons[id]) < TOLERANCE)) {
-                    // The poly check quantizes slightly differently, so we allow for boundary cases to disagree
-                  } else {
-                    // We do exact quantized comparison so the bbox query should never disagree:
-                    fail(Thread.currentThread().getName() + ": iter=" + iter + " id=" + id + " docID=" + docID + " lat=" + lats[id] + " lon=" + lons[id] + " (bbox: lat=" + lat0 + " TO " + lat1 + " lon=" + lon0 + " TO " + lon1 + ") expected " + expected + " but got: " + hits.get(docID) + " deleted?=" + deleted.contains(id) + " query=" + query + " crossesDateLine=" + crossesDateLine);
-                  }
-                }
-              }
+              verifyHits.test(s, docIDToID, deleted, query, lats, lons);
             }
           }
         };
@@ -550,8 +568,8 @@
                                               double pointLat, double pointLon) {
     if (Double.isNaN(pointLat)) {
       return false;
-    }
-    int rectLatMinEnc = BKDTreeWriter.encodeLat(rectLatMin);
+    } 
+   int rectLatMinEnc = BKDTreeWriter.encodeLat(rectLatMin);
     int rectLatMaxEnc = BKDTreeWriter.encodeLat(rectLatMax);
     int rectLonMinEnc = BKDTreeWriter.encodeLon(rectLonMin);
     int rectLonMaxEnc = BKDTreeWriter.encodeLon(rectLonMax);
@@ -601,6 +619,14 @@
     }
   }
 
+  static double quantizeLat(double lat) {
+    return BKDTreeWriter.decodeLat(BKDTreeWriter.encodeLat(lat));
+  }
+
+  static double quantizeLon(double lon) {
+    return BKDTreeWriter.decodeLon(BKDTreeWriter.encodeLon(lon));
+  }
+
   public void testEncodeDecodeMax() throws Exception {
     int x = BKDTreeWriter.encodeLat(Math.nextAfter(90.0, Double.POSITIVE_INFINITY));
     assertTrue(x < Integer.MAX_VALUE);
@@ -632,6 +658,124 @@
   private static DocValuesFormat getDocValuesFormat() {
     int maxPointsInLeaf = TestUtil.nextInt(random(), 16, 2048);
     int maxPointsSortInHeap = TestUtil.nextInt(random(), maxPointsInLeaf, 1024*1024);
+    if (VERBOSE) {
+      System.out.println("  BKD params: maxPointsInLeaf=" + maxPointsInLeaf + " maxPointsSortInHeap=" + maxPointsSortInHeap);
+    }
     return new BKDTreeDocValuesFormat(maxPointsInLeaf, maxPointsSortInHeap);
   }
+
+  private static abstract class VerifyHits {
+
+    public void test(IndexSearcher s, NumericDocValues docIDToID, Set<Integer> deleted, Query query, double[] lats, double[] lons) throws Exception {
+      int maxDoc = s.getIndexReader().maxDoc();
+      final FixedBitSet hits = new FixedBitSet(maxDoc);
+      s.search(query, new SimpleCollector() {
+
+          private int docBase;
+
+          @Override
+          public boolean needsScores() {
+            return false;
+          }
+
+          @Override
+          protected void doSetNextReader(LeafReaderContext context) throws IOException {
+            docBase = context.docBase;
+          }
+
+          @Override
+          public void collect(int doc) {
+            hits.set(docBase+doc);
+          }
+        });
+
+      for(int docID=0;docID<maxDoc;docID++) {
+        int id = (int) docIDToID.get(docID);
+        Boolean expected;
+        if (deleted.contains(id)) {
+          expected = false;
+        } else if (Double.isNaN(lats[id])) {
+          expected = false;
+        } else {
+          expected = shouldMatch(lats[id], lons[id]);
+        }
+
+        // null means it's a borderline case which is allowed to be wrong:
+        if (expected != null) {
+          if (hits.get(docID) != expected) {
+            if (expected) {
+              System.out.println(Thread.currentThread().getName() + ": id=" + id + " should match but did not");
+            } else {
+              System.out.println(Thread.currentThread().getName() + ": id=" + id + " should not match but did");
+            }
+            System.out.println("  query=" + query +
+                               " docID=" + docID + "\n  lat=" + lats[id] + " lon=" + lons[id] +
+                               "\n  deleted?=" + deleted.contains(id));
+            describe(docID, lats[id], lons[id]);
+            fail("wrong hit");
+          }
+        }
+      }
+    }
+
+    /** Return true if we definitely should match, false if we definitely
+     *  should not match, and null if it's a borderline case which might
+     *  go either way. */
+    protected abstract Boolean shouldMatch(double lat, double lon);
+
+    protected abstract void describe(int docID, double lat, double lon);
+  }
+
+  private static GeoBoundingBox randomBBox(boolean canCrossDateLine) {
+    double lat0 = randomLat();
+    double lat1 = randomLat();
+    double lon0 = randomLon();
+    double lon1 = randomLon();
+
+    if (lat1 < lat0) {
+      double x = lat0;
+      lat0 = lat1;
+      lat1 = x;
+    }
+
+    if (canCrossDateLine == false && lon1 < lon0) {
+      double x = lon0;
+      lon0 = lon1;
+      lon1 = x;
+    }
+
+    // Don't fixup lon0/lon1, so we can sometimes cross dateline:
+    return new GeoBoundingBox(lon0, lon1, lat0, lat1);
+  }
+
+  static class GeoBoundingBox {
+    public final double minLon;
+    public final double maxLon;
+    public final double minLat;
+    public final double maxLat;
+
+    public GeoBoundingBox(double minLon, double maxLon, double minLat, double maxLat) {
+      if (GeoUtils.isValidLon(minLon) == false) {
+        throw new IllegalArgumentException("invalid minLon " + minLon);
+      }
+      if (GeoUtils.isValidLon(maxLon) == false) {
+        throw new IllegalArgumentException("invalid maxLon " + minLon);
+      }
+      if (GeoUtils.isValidLat(minLat) == false) {
+        throw new IllegalArgumentException("invalid minLat " + minLat);
+      }
+      if (GeoUtils.isValidLat(maxLat) == false) {
+        throw new IllegalArgumentException("invalid maxLat " + minLat);
+      }
+      this.minLon = minLon;
+      this.maxLon = maxLon;
+      this.minLat = minLat;
+      this.maxLat = maxLat;
+    }
+
+    @Override
+    public String toString() {
+      return "GeoBoundingBox(lat=" + minLat + " TO " + maxLat + " lon=" + minLon + " TO " + maxLon + " crossesDateLine=" + (maxLon < minLon) + ")";
+    }
+  }
 }
Index: lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery.java
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery.java	(revision 1702193)
+++ lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery.java	(working copy)
@@ -571,6 +571,7 @@
   }
 
   private static boolean distanceContainsPt(double lonA, double latA, double lonB, double latB, final double radius) {
+    // nocommit why quantize here when we have radiusQueryCanBeWrong?
     final long hashedPtA = GeoUtils.mortonHash(lonA, latA);
     lonA = GeoUtils.mortonUnhashLon(hashedPtA);
     latA = GeoUtils.mortonUnhashLat(hashedPtA);
@@ -628,6 +629,7 @@
       lat1 = x;
     }
 
+    // TODO: hmm this means random test doesn't test crossing dateline I think?
     if (lon1 < lon0) {
       double x = lon0;
       lon0 = lon1;
Index: lucene/sandbox/src/test/org/apache/lucene/util/TestGeoUtils.java
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/util/TestGeoUtils.java	(revision 1702193)
+++ lucene/sandbox/src/test/org/apache/lucene/util/TestGeoUtils.java	(working copy)
@@ -54,7 +54,6 @@
     }
   }
 
-  @Test
   public void testGeoHash() {
     int numPoints = atLeast(100);
     String randomGeoHashString;
@@ -90,7 +89,6 @@
    * Pass condition: lat=42.6, lng=-5.6 should be encoded as "ezs42e44yx96",
    * lat=57.64911 lng=10.40744 should be encoded as "u4pruydqqvj8"
    */
-  @Test
   public void testEncode() {
     String hash = GeoHashUtils.stringEncode(-5.6, 42.6, 12);
     assertEquals("ezs42e44yx96", hash);
@@ -103,7 +101,6 @@
    * Pass condition: lat=52.3738007, lng=4.8909347 should be encoded and then
    * decoded within 0.00001 of the original value
    */
-  @Test
   public void testDecodePreciseLongitudeLatitude() {
     final String geohash = GeoHashUtils.stringEncode(4.8909347, 52.3738007);
     final long hash = GeoHashUtils.mortonEncode(geohash);
@@ -116,7 +113,6 @@
    * Pass condition: lat=84.6, lng=10.5 should be encoded and then decoded
    * within 0.00001 of the original value
    */
-  @Test
   public void testDecodeImpreciseLongitudeLatitude() {
     final String geohash = GeoHashUtils.stringEncode(10.5, 84.6);
 
@@ -126,7 +122,6 @@
     assertEquals(10.5, GeoUtils.mortonUnhashLon(hash), 0.00001D);
   }
 
-  @Test
   public void testDecodeEncode() {
     final String geoHash = "u173zq37x014";
     assertEquals(geoHash, GeoHashUtils.stringEncode(4.8909347, 52.3738007));
@@ -139,7 +134,10 @@
     assertEquals(geoHash, GeoHashUtils.stringEncode(lon, lat));
   }
 
-  @Test
+  public void testRectCrossesCircle() throws Exception {
+    assertTrue(GeoUtils.rectCrossesCircle(-180, -90, 180, 0.0, 0.667, 0.0, 88000.0));
+  }
+
   public void testNeighbors() {
     String geohash = "gcpv";
     List<String> expectedNeighbors = new ArrayList<>();
