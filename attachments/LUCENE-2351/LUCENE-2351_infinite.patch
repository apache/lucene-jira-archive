Index: src/java/org/apache/lucene/search/AutomatonTermsEnum.java
===================================================================
--- src/java/org/apache/lucene/search/AutomatonTermsEnum.java	(revision 928398)
+++ src/java/org/apache/lucene/search/AutomatonTermsEnum.java	(working copy)
@@ -22,6 +22,7 @@
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.OpenBitSet;
 import org.apache.lucene.util.UnicodeUtil;
 import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.automaton.RunAutomaton;
@@ -72,6 +73,8 @@
   // visited the state; we use gens to avoid having to clear
   private final long[] visited;
   private long curGen;
+  // set of states with infinite transitions: used for optimizations
+  private final OpenBitSet infiniteStates;
   // used for unicode conversion from BytesRef byte[] to char[]
   private final UnicodeUtil.UTF16Result utf16 = new UnicodeUtil.UTF16Result();
   // the reference used for seeking forwards through the term dictionary
@@ -139,6 +142,7 @@
     }
 
     setUseTermsCache(finite);
+    infiniteStates = (finite || linearMode) ? null : getInfiniteStates();
   }
   
   /**
@@ -201,7 +205,25 @@
   protected AcceptStatus accept(final BytesRef term) {
     if (commonSuffixRef == null || term.endsWith(commonSuffixRef)) {
       UnicodeUtil.UTF8toUTF16(term.bytes, term.offset, term.length, utf16);
-      return runAutomaton.run(utf16.result, 0, utf16.length) ? YES_MATCH : NO_MATCH;
+      if (runAutomaton.run(utf16.result, 0, utf16.length))
+        return YES_MATCH;
+      else {
+        if (infiniteStates == null)
+          return NO_MATCH;
+        boolean infinite = false;
+        int state = runAutomaton.getInitialState();
+          // walk the automaton until a character is rejected.
+          for (int i = 0; i < utf16.length; i++) {
+            state = runAutomaton.step(state, utf16.result[i]);
+            if (state == -1) {
+              break;
+            } else if (infiniteStates.fastGet(state)) {
+              infinite = true;
+              break;
+            }
+          }
+        return infinite ? AcceptStatus.NO : NO_MATCH;
+      }
     } else {
       return NO_MATCH;
     }
@@ -389,4 +411,32 @@
     else
       return suffix;
   }
+  
+  /**
+   * Returns the set of states that contain infinite transitions that will loop
+   * back to previous paths that lead to the same state.
+   */
+  private OpenBitSet getInfiniteStates() {
+    OpenBitSet states = new OpenBitSet(runAutomaton.getSize());
+    getInfiniteStates(runAutomaton.getInitialState(), states,
+        new OpenBitSet(runAutomaton.getSize()));
+    return states;
+  }
+  
+  private void getInfiniteStates(int state, OpenBitSet states, OpenBitSet path) {
+    path.fastSet(state);
+    Transition[] transitions = allTransitions[state];
+    for (int i = 0; i < transitions.length; i++) {
+      Transition t = transitions[i];
+      int dest = t.getDest().getNumber();
+      if (path.fastGet(dest)) {
+        if ((t.getMax() - t.getMin()) > (Character.MAX_VALUE / 3)) {
+          states.fastSet(state);
+        }
+      } else {
+        getInfiniteStates(dest, states, path);
+      }
+    }
+    path.fastClear(state);
+  }
 }
