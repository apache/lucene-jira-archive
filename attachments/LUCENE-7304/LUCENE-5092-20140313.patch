diff --git a/lucene/core/src/java/org/apache/lucene/search/DocBlocksIterator.java b/lucene/core/src/java/org/apache/lucene/search/DocBlocksIterator.java
new file mode 100644
index 0000000..fb109e4
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/DocBlocksIterator.java
@@ -0,0 +1,39 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+/**
+ * This abstract class adds a method to {@link DocIdSetIterator}
+ * to iterate over blocks of doc Ids as done in the join module.
+ */
+public abstract class DocBlocksIterator extends DocIdSetIterator {
+  /**
+   * This method followed by a {@link #nextDoc} has the same
+   * effect as {@link #advance(int)}.
+   * <br>In other words, this method advances to (or stays at) the document
+   * that is the one before a {@link #nextDoc} that
+   * {@link #advance(int)} would advance to from the current document.
+   * <br>In case {@link #advance(int)} would return the first document,
+   * this method returns -1.
+   * <br>In case {@link #advance(int)} would return {@link #NO_MORE_DOCS},
+   * this method advances to (or stays at) the last document in the set.
+   */
+  public abstract int advanceToJustBefore(int target) throws IOException;
+}
diff --git a/lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java b/lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java
index e88429a..02ce848 100644
--- a/lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java
+++ b/lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java
@@ -22,6 +22,7 @@ import java.util.Arrays;
 
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.DocBlocksIterator;
 
 /**
  * BitSet of fixed length (numBits), backed by accessible ({@link #getBits})
@@ -34,10 +35,10 @@ import org.apache.lucene.search.DocIdSetIterator;
 public final class FixedBitSet extends DocIdSet implements Bits {
 
   /**
-   * A {@link DocIdSetIterator} which iterates over set bits in a
+   * A {@link DocBlocksIterator} which iterates over set bits in a
    * {@link FixedBitSet}.
    */
-  public static final class FixedBitSetIterator extends DocIdSetIterator {
+  public static final class FixedBitSetIterator extends DocBlocksIterator {
 
     final int numBits, numWords;
     final long[] bits;
@@ -110,6 +111,29 @@ public final class FixedBitSet extends DocIdSet implements Bits {
 
       return doc = NO_MORE_DOCS;
     }
+
+    @Override
+    public int advanceToJustBefore(int target) throws IOException {
+      assert doc <= target;
+      int advanceDoc = advance(target);
+      int fromDoc = ((advanceDoc != NO_MORE_DOCS) ? advanceDoc : numBits) - 1;
+      if (fromDoc <= 0) {
+        return doc = -1;
+      }
+      int i = fromDoc >> 6;
+      int subIndex = fromDoc & 0x3f;  // index within the word
+      long word = (bits[i] << (63-fromDoc));  // skip all the bits to the left of index
+      if (word != 0) {
+        return doc = (i << 6) + subIndex - Long.numberOfLeadingZeros(word);
+      }
+      while (--i >= 0) {
+        word = bits[i];
+        if (word !=0 ) {
+          return doc = (i << 6) + 63 - Long.numberOfLeadingZeros(word);
+        }
+      }
+      return doc = -1;
+    }
   }
 
   /**
@@ -198,7 +222,7 @@ public final class FixedBitSet extends DocIdSet implements Bits {
   }
 
   @Override
-  public DocIdSetIterator iterator() {
+  public DocBlocksIterator iterator() {
     return new FixedBitSetIterator(bits, numBits, numWords);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoDocIdSet.java b/lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoDocIdSet.java
index f9cd09b..6813f2b 100644
--- a/lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoDocIdSet.java
+++ b/lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoDocIdSet.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.DocBlocksIterator;
 
 import org.apache.lucene.util.FixedBitSet; // for javadocs
 
@@ -70,12 +71,34 @@ public class EliasFanoDocIdSet extends DocIdSet {
    * Provides a {@link DocIdSetIterator} to access encoded document ids.
    */
   @Override
-  public DocIdSetIterator iterator() {
+  public DocBlocksIterator iterator() {
     if (efEncoder.lastEncoded >= DocIdSetIterator.NO_MORE_DOCS) {
       throw new UnsupportedOperationException(
           "Highest encoded value too high for DocIdSetIterator.NO_MORE_DOCS: " + efEncoder.lastEncoded);
     }
-    return new DocIdSetIterator() {
+    return new EliasFanoDocBlocksIterator();
+  }
+
+  /** This DocIdSet implementation is cacheable.
+   * @return <code>true</code>
+   */
+  @Override
+  public boolean isCacheable() {
+    return true;
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    return ((other instanceof EliasFanoDocIdSet))
+        && efEncoder.equals(((EliasFanoDocIdSet) other).efEncoder);
+  }
+
+  @Override
+  public int hashCode() {
+    return efEncoder.hashCode() ^ getClass().hashCode();
+  }
+
+  class EliasFanoDocBlocksIterator extends DocBlocksIterator {
     private int curDocId = -1;
     private final EliasFanoDecoder efDecoder = efEncoder.getDecoder();
 
@@ -85,9 +108,7 @@ public class EliasFanoDocIdSet extends DocIdSet {
     }
 
     private int setCurDocID(long value) {
-        curDocId = (value == EliasFanoDecoder.NO_MORE_VALUES)
-            ?  NO_MORE_DOCS
-                : (int) value;
+      curDocId = (value == EliasFanoDecoder.NO_MORE_VALUES) ?  NO_MORE_DOCS : (int) value;
       return curDocId;
     }
 
@@ -102,29 +123,25 @@ public class EliasFanoDocIdSet extends DocIdSet {
     }
 
     @Override
-      public long cost() {
-        return efDecoder.numEncoded();
-      }
-    };
+    public int advanceToJustBefore(int target) {
+      long advanceValue = efDecoder.advanceToValue(target);
+      if (advanceValue == EliasFanoDecoder.NO_MORE_VALUES) {
+        efDecoder.toAfterSequence();
+      }
+      long previousValue = efDecoder.previousValue();
+      if (previousValue == EliasFanoDecoder.NO_MORE_VALUES) {
+        efDecoder.toBeforeSequence();
+        curDocId = -1;
+      } else {
+        curDocId = (int) previousValue;
       }
-
-  /** This DocIdSet implementation is cacheable.
-   * @return <code>true</code>
-   */
-  @Override
-  public boolean isCacheable() {
-    return true;
+      return curDocId;
     }
 
     @Override
-  public boolean equals(Object other) {
-    return ((other instanceof EliasFanoDocIdSet))
-        && efEncoder.equals(((EliasFanoDocIdSet) other).efEncoder);
+    public long cost() {
+      return efDecoder.numEncoded();
     }
-
-  @Override
-  public int hashCode() {
-    return efEncoder.hashCode() ^ getClass().hashCode();
   }
 }
 
diff --git a/lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java b/lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java
index c555c4a..47b5116 100644
--- a/lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java
+++ b/lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java
@@ -26,6 +26,8 @@ import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.DocIdSet;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.DocBlocksIterator;
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.Filter;
 import org.apache.lucene.search.IndexSearcher;
@@ -33,7 +35,6 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.Weight;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.FixedBitSet;
 
 /**
  * Just like {@link ToParentBlockJoinQuery}, except this
@@ -66,10 +67,10 @@ public class ToChildBlockJoinQuery extends Query {
    * Create a ToChildBlockJoinQuery.
    *
    * @param parentQuery Query that matches parent documents
-   * @param parentsFilter Filter (must produce FixedBitSet
-   * per-segment, like {@link FixedBitSetCachingWrapperFilter})
-   * identifying the parent documents.
-   * @param doScores true if parent scores should be calculated
+   * @param parentsFilter A Filter for which {@link Filter#getDocIdSet} provides
+   * a {@link DocIdSet} for which {@link DocIdSet#iterator} produces
+   * per-segment a {@link DocBlocksIterator} identifying the parent documents.
+   * @param doScores true if parent scores should be calculated.
    */
   public ToChildBlockJoinQuery(Query parentQuery, Filter parentsFilter, boolean doScores) {
     super();
@@ -144,11 +145,12 @@ public class ToChildBlockJoinQuery extends Query {
         // No matches
         return null;
       }
-      if (!(parents instanceof FixedBitSet)) {
-        throw new IllegalStateException("parentFilter must return FixedBitSet; got " + parents);
+      DocIdSetIterator parentsDisi = parents.iterator();
+      if (!(parentsDisi instanceof DocBlocksIterator)) {
+        throw new IllegalStateException("DocIdSet from parentsFilter must provide DocBlocksIterator; got " + parentsDisi);
       }
 
-      return new ToChildBlockJoinScorer(this, parentScorer, (FixedBitSet) parents, doScores, acceptDocs);
+      return new ToChildBlockJoinScorer(this, parentScorer, (DocBlocksIterator)parentsDisi, doScores, acceptDocs);
     }
 
     @Override
@@ -166,7 +168,7 @@ public class ToChildBlockJoinQuery extends Query {
 
   static class ToChildBlockJoinScorer extends Scorer {
     private final Scorer parentScorer;
-    private final FixedBitSet parentBits;
+    private final DocBlocksIterator parentsDbi;
     private final boolean doScores;
     private final Bits acceptDocs;
 
@@ -176,10 +178,10 @@ public class ToChildBlockJoinQuery extends Query {
     private int childDoc = -1;
     private int parentDoc;
 
-    public ToChildBlockJoinScorer(Weight weight, Scorer parentScorer, FixedBitSet parentBits, boolean doScores, Bits acceptDocs) {
+    public ToChildBlockJoinScorer(Weight weight, Scorer parentScorer, DocBlocksIterator parentsDbi, boolean doScores, Bits acceptDocs) {
       super(weight);
       this.doScores = doScores;
-      this.parentBits = parentBits;
+      this.parentsDbi = parentsDbi;
       this.parentScorer = parentScorer;
       this.acceptDocs = acceptDocs;
     }
@@ -191,7 +193,6 @@ public class ToChildBlockJoinQuery extends Query {
 
     @Override
     public int nextDoc() throws IOException {
-      //System.out.println("Q.nextDoc() parentDoc=" + parentDoc + " childDoc=" + childDoc);
 
       // Loop until we hit a childDoc that's accepted
       nextChildDoc:
@@ -204,7 +205,6 @@ public class ToChildBlockJoinQuery extends Query {
           // children:
           while (true) {
             parentDoc = parentScorer.nextDoc();
-            validateParentDoc();
 
             if (parentDoc == 0) {
               // Degenerate but allowed: first parent doc has no children
@@ -212,18 +212,19 @@ public class ToChildBlockJoinQuery extends Query {
               // into ctor so we can skip this if... but it's
               // tricky because scorer must return -1 for
               // .doc() on init...
-              parentDoc = parentScorer.nextDoc();
               validateParentDoc();
+              parentDoc = parentScorer.nextDoc();
             }
 
             if (parentDoc == NO_MORE_DOCS) {
               childDoc = NO_MORE_DOCS;
-              //System.out.println("  END");
               return childDoc;
             }
 
             // Go to first child for this next parentDoc:
-            childDoc = 1 + parentBits.prevSetBit(parentDoc-1);
+            int previousParentDoc = parentsDbi.advanceToJustBefore(parentDoc);
+            validateParentDoc();
+            childDoc = 1 + previousParentDoc;
 
             if (childDoc == parentDoc) {
               // This parent has no children; continue
@@ -240,7 +241,6 @@ public class ToChildBlockJoinQuery extends Query {
                 parentScore = parentScorer.score();
                 parentFreq = parentScorer.freq();
               }
-              //System.out.println("  " + childDoc);
               return childDoc;
             } else {
               // Degenerate but allowed: parent has no children
@@ -252,16 +252,25 @@ public class ToChildBlockJoinQuery extends Query {
           if (acceptDocs != null && !acceptDocs.get(childDoc)) {
             continue;
           }
-          //System.out.println("  " + childDoc);
           return childDoc;
         }
       }
     }
 
-    /** Detect mis-use, where provided parent query in fact
-     *  sometimes returns child documents.  */
-    private void validateParentDoc() {
-      if (parentDoc != NO_MORE_DOCS && !parentBits.get(parentDoc)) {
+    /** Detect mis-use, where provided parent query in fact sometimes returns child documents.
+     *  This normally advances parentsDbi.
+     */
+    private void validateParentDoc() throws IOException {
+      if (parentDoc == NO_MORE_DOCS) {
+        return;
+      }
+      int dbiDoc = parentsDbi.docID();
+      if (parentDoc > dbiDoc) {
+        if (parentsDbi.advance(parentDoc) != parentDoc) {
+          throw new IllegalStateException(INVALID_QUERY_MESSAGE + parentDoc);
+        }
+      }
+      else if (parentDoc != dbiDoc) {
         throw new IllegalStateException(INVALID_QUERY_MESSAGE + parentDoc);
       }
     }
@@ -283,11 +292,9 @@ public class ToChildBlockJoinQuery extends Query {
 
     @Override
     public int advance(int childTarget) throws IOException {
-      assert childTarget >= parentBits.length() || !parentBits.get(childTarget);
+      //assert childTarget >= parentBits.length() || !parentBits.get(childTarget);
 
-      //System.out.println("Q.advance childTarget=" + childTarget);
       if (childTarget == NO_MORE_DOCS) {
-        //System.out.println("  END");
         return childDoc = parentDoc = NO_MORE_DOCS;
       }
 
@@ -295,19 +302,17 @@ public class ToChildBlockJoinQuery extends Query {
       if (childDoc == -1 || childTarget > parentDoc) {
         // Advance to new parent:
         parentDoc = parentScorer.advance(childTarget);
+        int previousParentDoc = parentsDbi.advanceToJustBefore(parentDoc);
         validateParentDoc();
-        //System.out.println("  advance to parentDoc=" + parentDoc);
         assert parentDoc > childTarget;
         if (parentDoc == NO_MORE_DOCS) {
-          //System.out.println("  END");
           return childDoc = NO_MORE_DOCS;
         }
         if (doScores) {
           parentScore = parentScorer.score();
           parentFreq = parentScorer.freq();
         }
-        final int firstChild = parentBits.prevSetBit(parentDoc-1);
-        //System.out.println("  firstChild=" + firstChild);
+        final int firstChild = previousParentDoc;
         childTarget = Math.max(childTarget, firstChild);
       }
 
@@ -315,7 +320,6 @@ public class ToChildBlockJoinQuery extends Query {
 
       // Advance within children of current parent:
       childDoc = childTarget;
-      //System.out.println("  " + childDoc);
       if (acceptDocs != null && !acceptDocs.get(childDoc)) {
         nextDoc();
       }
diff --git a/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java b/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java
index f6985e2..9340934 100644
--- a/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java
+++ b/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java
@@ -30,6 +30,7 @@ import org.apache.lucene.index.Term;
 import org.apache.lucene.search.ComplexExplanation;
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.DocBlocksIterator;
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.Filter;
 import org.apache.lucene.search.IndexSearcher;
@@ -39,7 +40,6 @@ import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.grouping.TopGroups;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.FixedBitSet;
 
 /**
  * This query requires that you index
@@ -47,9 +47,13 @@ import org.apache.lucene.util.FixedBitSet;
  * {@link IndexWriter#addDocuments IndexWriter.addDocuments()} or {@link
  * IndexWriter#updateDocuments IndexWriter.updateDocuments()} API.  In each block, the
  * child documents must appear first, ending with the parent
- * document.  At search time you provide a Filter
- * identifying the parents, however this Filter must provide
- * an {@link FixedBitSet} per sub-reader.
+ * document.
+ * <br>At search time you provide a Filter identifying the parents.
+ * The {@link Filter#getDocIdSet} of this Filter must provide
+ * a {@link DocIdSet} for which {@link DocIdSet#iterator} produces
+ * per-segment a {@link DocBlocksIterator} identifying the parent documents.
+ * This Filter can for example be a {@link org.apache.lucene.util.FixedBitSet}
+ * or a {@link FixedBitSetCachingWrapperFilter}.
  *
  * <p>Once the block index is built, use this query to wrap
  * any sub-query matching only child docs and join matches in that
@@ -99,9 +103,9 @@ public class ToParentBlockJoinQuery extends Query {
   /** Create a ToParentBlockJoinQuery.
    *
    * @param childQuery Query matching child documents.
-   * @param parentsFilter Filter (must produce FixedBitSet
-   * per-segment, like {@link FixedBitSetCachingWrapperFilter})
-   * identifying the parent documents.
+   * @param parentsFilter A Filter for which {@link Filter#getDocIdSet} provides
+   * a {@link DocIdSet} for which {@link DocIdSet#iterator} produces
+   * per-segment a {@link DocBlocksIterator} identifying the parent documents.
    * @param scoreMode How to aggregate multiple child scores
    * into a single parent score.
    **/
@@ -183,11 +187,12 @@ public class ToParentBlockJoinQuery extends Query {
         // No matches
         return null;
       }
-      if (!(parents instanceof FixedBitSet)) {
-        throw new IllegalStateException("parentFilter must return FixedBitSet; got " + parents);
+      DocIdSetIterator parentsDisi = parents.iterator();
+      if (!(parentsDisi instanceof DocBlocksIterator)) {
+        throw new IllegalStateException("DocIdSet from parentsFilter must provide DocBlocksIterator; got " + parentsDisi);
       }
 
-      return new BlockJoinScorer(this, childScorer, (FixedBitSet) parents, firstChildDoc, scoreMode, acceptDocs);
+      return new BlockJoinScorer(this, childScorer, (DocBlocksIterator) parentsDisi, firstChildDoc, scoreMode, acceptDocs);
     }
 
     @Override
@@ -207,7 +212,7 @@ public class ToParentBlockJoinQuery extends Query {
 
   static class BlockJoinScorer extends Scorer {
     private final Scorer childScorer;
-    private final FixedBitSet parentBits;
+    private final DocBlocksIterator parentsDbi;
     private final ScoreMode scoreMode;
     private final Bits acceptDocs;
     private int parentDoc = -1;
@@ -219,10 +224,9 @@ public class ToParentBlockJoinQuery extends Query {
     private float[] pendingChildScores;
     private int childDocUpto;
 
-    public BlockJoinScorer(Weight weight, Scorer childScorer, FixedBitSet parentBits, int firstChildDoc, ScoreMode scoreMode, Bits acceptDocs) {
+    public BlockJoinScorer(Weight weight, Scorer childScorer, DocBlocksIterator parentsDbi, int firstChildDoc, ScoreMode scoreMode, Bits acceptDocs) {
       super(weight);
-      //System.out.println("Q.init firstChildDoc=" + firstChildDoc);
-      this.parentBits = parentBits;
+      this.parentsDbi = parentsDbi;
       this.childScorer = childScorer;
       this.scoreMode = scoreMode;
       this.acceptDocs = acceptDocs;
@@ -267,18 +271,15 @@ public class ToParentBlockJoinQuery extends Query {
 
     @Override
     public int nextDoc() throws IOException {
-      //System.out.println("Q.nextDoc() nextChildDoc=" + nextChildDoc);
       // Loop until we hit a parentDoc that's accepted
       while (true) {
         if (nextChildDoc == NO_MORE_DOCS) {
-          //System.out.println("  end");
           return parentDoc = NO_MORE_DOCS;
         }
 
         // Gather all children sharing the same parent as
         // nextChildDoc
-
-        parentDoc = parentBits.nextSetBit(nextChildDoc);
+        parentDoc = parentsDbi.advance(nextChildDoc);
 
         // Parent & child docs are supposed to be
         // orthogonal:
@@ -286,10 +287,8 @@ public class ToParentBlockJoinQuery extends Query {
           throw new IllegalStateException("child query must only match non-parent docs, but parent docID=" + nextChildDoc + " matched childScorer=" + childScorer.getClass());
         }
 
-        //System.out.println("  parentDoc=" + parentDoc);
         assert parentDoc != -1;
 
-        //System.out.println("  nextChildDoc=" + nextChildDoc);
         if (acceptDocs != null && !acceptDocs.get(parentDoc)) {
           // Parent doc not accepted; skip child docs until
           // we hit a new parent doc:
@@ -313,7 +312,6 @@ public class ToParentBlockJoinQuery extends Query {
         parentFreq = 0;
         do {
 
-          //System.out.println("  c=" + nextChildDoc);
           if (pendingChildDocs != null && pendingChildDocs.length == childDocUpto) {
             pendingChildDocs = ArrayUtil.grow(pendingChildDocs);
           }
@@ -358,7 +356,6 @@ public class ToParentBlockJoinQuery extends Query {
           break;
         }
 
-        //System.out.println("  return parentDoc=" + parentDoc + " childDocUpto=" + childDocUpto);
         return parentDoc;
       }
     }
@@ -381,7 +378,6 @@ public class ToParentBlockJoinQuery extends Query {
     @Override
     public int advance(int parentTarget) throws IOException {
 
-      //System.out.println("Q.advance parentTarget=" + parentTarget);
       if (parentTarget == NO_MORE_DOCS) {
         return parentDoc = NO_MORE_DOCS;
       }
@@ -396,15 +392,11 @@ public class ToParentBlockJoinQuery extends Query {
         return nextDoc();
       }
 
-      prevParentDoc = parentBits.prevSetBit(parentTarget-1);
+      prevParentDoc = parentsDbi.advanceToJustBefore(parentTarget);
 
-      //System.out.println("  rolled back to prevParentDoc=" + prevParentDoc + " vs parentDoc=" + parentDoc);
       assert prevParentDoc >= parentDoc;
       if (prevParentDoc > nextChildDoc) {
         nextChildDoc = childScorer.advance(prevParentDoc);
-        // System.out.println("  childScorer advanced to child docID=" + nextChildDoc);
-      //} else {
-        //System.out.println("  skip childScorer advance");
       }
 
       // Parent & child docs are supposed to be orthogonal:
@@ -413,7 +405,6 @@ public class ToParentBlockJoinQuery extends Query {
       }
 
       final int nd = nextDoc();
-      //System.out.println("  return nextParentDoc=" + nd);
       return nd;
     }
 
@@ -472,8 +463,7 @@ public class ToParentBlockJoinQuery extends Query {
       final ToParentBlockJoinQuery other = (ToParentBlockJoinQuery) _other;
       return origChildQuery.equals(other.origChildQuery) &&
         parentsFilter.equals(other.parentsFilter) &&
-        scoreMode == other.scoreMode && 
-        super.equals(other);
+        scoreMode == other.scoreMode && super.equals(other);
     } else {
       return false;
     }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/BaseDocIdSetTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/util/BaseDocIdSetTestCase.java
index a92d275..fe9f696 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/BaseDocIdSetTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/BaseDocIdSetTestCase.java
@@ -22,6 +22,7 @@ import java.util.BitSet;
 
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.DocBlocksIterator;
 
 /** Base test class for {@link DocIdSet}s. */
 public abstract class BaseDocIdSetTestCase<T extends DocIdSet> extends LuceneTestCase {
@@ -144,11 +145,20 @@ public abstract class BaseDocIdSetTestCase<T extends DocIdSet> extends LuceneTes
           assertEquals(doc, it2.docID());
         } else {
           final int target = doc + 1 + random().nextInt(random().nextBoolean() ? 64 : Math.max(numBits / 8, 1));
+          int previousDoc = doc;
           doc = ds1.nextSetBit(target);
           if (doc == -1) {
             doc = DocIdSetIterator.NO_MORE_DOCS;
           }
+          if ((it2 instanceof DocBlocksIterator) && random().nextBoolean()) {
+            DocBlocksIterator it2dbi = (DocBlocksIterator) it2;
+            int docBeforeTarget = it2dbi.advanceToJustBefore(target);
+            assertTrue(previousDoc <= docBeforeTarget);
+            assertTrue(docBeforeTarget < target);
+            assertEquals(doc, it2.nextDoc());
+          } else {
             assertEquals(doc, it2.advance(target));
+          }
           assertEquals(doc, it2.docID());
         }
       }
