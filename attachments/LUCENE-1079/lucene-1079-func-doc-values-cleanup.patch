Index: src/test/org/apache/lucene/search/function/TestOrdValues.java
===================================================================
--- src/test/org/apache/lucene/search/function/TestOrdValues.java	(revision 601068)
+++ src/test/org/apache/lucene/search/function/TestOrdValues.java	(working copy)
@@ -149,6 +149,8 @@
     IndexSearcher s = new IndexSearcher(dir);
     Object innerArray = null;
 
+    boolean warned = false; // print warning once
+    
     for (int i=0; i<10; i++) {
       ValueSource vs;
       if (inOrder) {
@@ -158,12 +160,19 @@
       }
       ValueSourceQuery q = new ValueSourceQuery(vs);
       Hits h = s.search(q);
-      assertEquals("All docs should be matched!",N_DOCS,h.length());
-      if (i==0) {
-        innerArray = q.valSrc.getValues(s.getIndexReader()).getInnerArray();
-      } else {
-        log(i+".  compare: "+innerArray+" to "+q.valSrc.getValues(s.getIndexReader()).getInnerArray());
-        assertSame("field values should be cached and reused!", innerArray, q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+      try {
+        assertEquals("All docs should be matched!",N_DOCS,h.length());
+        if (i==0) {
+          innerArray = q.valSrc.getValues(s.getIndexReader()).getInnerArray();
+        } else {
+          log(i+".  compare: "+innerArray+" to "+q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+          assertSame("field values should be cached and reused!", innerArray, q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+        }
+      } catch (UnsupportedOperationException e) {
+        if (!warned) {
+          System.err.println("WARNING: "+testName()+" cannot fully test values of "+q);
+          warned = true;
+        }
       }
     }
     
@@ -182,8 +191,15 @@
     q = new ValueSourceQuery(vs);
     h = s.search(q);
     assertEquals("All docs should be matched!",N_DOCS,h.length());
-    log("compare (should differ): "+innerArray+" to "+q.valSrc.getValues(s.getIndexReader()).getInnerArray());
-    assertNotSame("different values shuold be loaded for a different field!", innerArray, q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+    try {
+      log("compare (should differ): "+innerArray+" to "+q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+      assertNotSame("different values shuold be loaded for a different field!", innerArray, q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+    } catch (UnsupportedOperationException e) {
+      if (!warned) {
+        System.err.println("WARNING: "+testName()+" cannot fully test values of "+q);
+        warned = true;
+      }
+    }
 
     // verify new values are reloaded (not reused) for a new reader
     s = new IndexSearcher(dir);
@@ -195,8 +211,19 @@
     q = new ValueSourceQuery(vs);
     h = s.search(q);
     assertEquals("All docs should be matched!",N_DOCS,h.length());
-    log("compare (should differ): "+innerArray+" to "+q.valSrc.getValues(s.getIndexReader()).getInnerArray());
-    assertNotSame("cached field values should not be reused if reader as changed!", innerArray, q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+    try {
+      log("compare (should differ): "+innerArray+" to "+q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+      assertNotSame("cached field values should not be reused if reader as changed!", innerArray, q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+    } catch (UnsupportedOperationException e) {
+      if (!warned) {
+        System.err.println("WARNING: "+testName()+" cannot fully test values of "+q);
+        warned = true;
+      }
+    }
   }
 
+  private String testName() {
+    return getClass().getName()+"."+getName();
+  }
+
 }
Index: src/test/org/apache/lucene/search/function/TestFieldScoreQuery.java
===================================================================
--- src/test/org/apache/lucene/search/function/TestFieldScoreQuery.java	(revision 601068)
+++ src/test/org/apache/lucene/search/function/TestFieldScoreQuery.java	(working copy)
@@ -17,6 +17,7 @@
  * limitations under the License.
  */
 
+import java.io.ObjectInputStream.GetField;
 import java.util.HashMap;
 
 import org.apache.lucene.index.CorruptIndexException;
@@ -177,17 +178,25 @@
     IndexSearcher s = new IndexSearcher(dir);
     Object innerArray = null;
 
+    boolean warned = false; // print warning once.
     for (int i=0; i<10; i++) {
       FieldScoreQuery q = new FieldScoreQuery(field,tp);
       Hits h = s.search(q);
       assertEquals("All docs should be matched!",N_DOCS,h.length());
-      if (i==0) {
-        innerArray = q.valSrc.getValues(s.getIndexReader()).getInnerArray();
-        log(i+".  compare: "+innerArray.getClass()+" to "+expectedArrayTypes.get(tp).getClass());
-        assertEquals("field values should be cached in the correct array type!", innerArray.getClass(),expectedArrayTypes.get(tp).getClass());
-      } else {
-        log(i+".  compare: "+innerArray+" to "+q.valSrc.getValues(s.getIndexReader()).getInnerArray());
-        assertSame("field values should be cached and reused!", innerArray, q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+      try {
+        if (i==0) {
+          innerArray = q.valSrc.getValues(s.getIndexReader()).getInnerArray();
+          log(i+".  compare: "+innerArray.getClass()+" to "+expectedArrayTypes.get(tp).getClass());
+          assertEquals("field values should be cached in the correct array type!", innerArray.getClass(),expectedArrayTypes.get(tp).getClass());
+        } else {
+          log(i+".  compare: "+innerArray+" to "+q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+          assertSame("field values should be cached and reused!", innerArray, q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+        }
+      } catch (UnsupportedOperationException e) {
+        if (!warned) {
+          System.err.println("WARNING: "+testName()+" cannot fully test values of "+q);
+          warned = true;
+        }
       }
     }
     
@@ -196,8 +205,19 @@
     FieldScoreQuery q = new FieldScoreQuery(field,tp);
     Hits h = s.search(q);
     assertEquals("All docs should be matched!",N_DOCS,h.length());
-    log("compare: "+innerArray+" to "+q.valSrc.getValues(s.getIndexReader()).getInnerArray());
-    assertNotSame("cached field values should not be reused if reader as changed!", innerArray, q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+    try {
+      log("compare: "+innerArray+" to "+q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+      assertNotSame("cached field values should not be reused if reader as changed!", innerArray, q.valSrc.getValues(s.getIndexReader()).getInnerArray());
+    } catch (UnsupportedOperationException e) {
+      if (!warned) {
+        System.err.println("WARNING: "+testName()+" cannot fully test values of "+q);
+        warned = true;
+      }
+    }
   }
 
+  private String testName() {
+    return getClass().getName()+"."+getName();
+  }
+
 }
Index: src/java/org/apache/lucene/search/function/IntFieldSource.java
===================================================================
--- src/java/org/apache/lucene/search/function/IntFieldSource.java	(revision 601068)
+++ src/java/org/apache/lucene/search/function/IntFieldSource.java	(working copy)
@@ -67,7 +67,7 @@
     final int[] arr = (parser==null) ?  
       cache.getInts(reader, field) : 
       cache.getInts(reader, field, parser);
-    return new DocValues(reader.maxDoc()) {
+    return new DocValues() {
       /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#floatVal(int) */
       public float floatVal(int doc) { 
         return (float) arr[doc]; 
Index: src/java/org/apache/lucene/search/function/ShortFieldSource.java
===================================================================
--- src/java/org/apache/lucene/search/function/ShortFieldSource.java	(revision 601068)
+++ src/java/org/apache/lucene/search/function/ShortFieldSource.java	(working copy)
@@ -65,10 +65,10 @@
     final short[] arr = (parser==null) ?  
       cache.getShorts(reader, field) : 
       cache.getShorts(reader, field, parser);
-    return new DocValues(reader.maxDoc()) {
+    return new DocValues() {
       /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#floatVal(int) */
       public float floatVal(int doc) { 
-        return (float) arr[doc]; 
+        return (float) arr[doc];
       }
       /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#intVal(int) */
       public  int intVal(int doc) { 
Index: src/java/org/apache/lucene/search/function/DocValues.java
===================================================================
--- src/java/org/apache/lucene/search/function/DocValues.java	(revision 601068)
+++ src/java/org/apache/lucene/search/function/DocValues.java	(working copy)
@@ -42,21 +42,7 @@
    *   want the Query carrying around big objects
    */
 
-  private int nVals;
-  
   /**
-   * Constructor with input number of values(docs).
-   * @param nVals
-   */
-  public DocValues (int nVals) {
-    this.nVals = nVals;
-  }
-  
-  // prevent using this constructor
-  private DocValues () {
-    
-  }
-  /**
    * Return doc value as a float. 
    * <P>Mandatory: every DocValues implementation must implement at least this method. 
    * @param doc document whose float value is requested. 
@@ -119,10 +105,12 @@
    *   <li>indeed cached/reused.</li>
    *   <li>stored in the expected size/type (byte/short/int/float).</li>
    * </ol>
-   * Note: Tested implementations of DocValues must override this method for the test to pass!
+   * Note: implementations of DocValues must override this method for 
+   * these test elements to be tested, Otherwise the test would not fail, just 
+   * print a warning.
    */
   Object getInnerArray() {
-    return new Object[0];
+    throw new UnsupportedOperationException("this optional method is for test purposes only");
   }
 
   // --- some simple statistics on values
@@ -138,13 +126,19 @@
     minVal = Float.MAX_VALUE;
     maxVal = 0;
     float sum = 0;
-    for (int i=0; i<nVals; i++) {
-      float val = floatVal(i); 
+    int n = 0;
+    while (true) {
+      float val;
+      try {
+        val = floatVal(n);
+      } catch (ArrayIndexOutOfBoundsException e) {
+        break;
+      }
       sum += val;
       minVal = Math.min(minVal,val);
       maxVal = Math.max(maxVal,val);
     }
-    avgVal = sum / nVals;
+    avgVal = sum / n;
     computed = true;
   }
   /**
Index: src/java/org/apache/lucene/search/function/ReverseOrdFieldSource.java
===================================================================
--- src/java/org/apache/lucene/search/function/ReverseOrdFieldSource.java	(revision 601068)
+++ src/java/org/apache/lucene/search/function/ReverseOrdFieldSource.java	(working copy)
@@ -71,7 +71,7 @@
     final int arr[] = sindex.order;
     final int end = sindex.lookup.length;
 
-    return new DocValues(arr.length) {
+    return new DocValues() {
       /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#floatVal(int) */
       public float floatVal(int doc) {
         return (float)(end - arr[doc]);
Index: src/java/org/apache/lucene/search/function/ByteFieldSource.java
===================================================================
--- src/java/org/apache/lucene/search/function/ByteFieldSource.java	(revision 601068)
+++ src/java/org/apache/lucene/search/function/ByteFieldSource.java	(working copy)
@@ -65,7 +65,7 @@
     final byte[] arr = (parser==null) ?  
       cache.getBytes(reader, field) : 
       cache.getBytes(reader, field, parser);
-    return new DocValues(reader.maxDoc()) {
+    return new DocValues() {
       /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#floatVal(int) */
       public float floatVal(int doc) { 
         return (float) arr[doc]; 
Index: src/java/org/apache/lucene/search/function/OrdFieldSource.java
===================================================================
--- src/java/org/apache/lucene/search/function/OrdFieldSource.java	(revision 601068)
+++ src/java/org/apache/lucene/search/function/OrdFieldSource.java	(working copy)
@@ -66,7 +66,7 @@
   /*(non-Javadoc) @see org.apache.lucene.search.function.ValueSource#getValues(org.apache.lucene.index.IndexReader) */
   public DocValues getValues(IndexReader reader) throws IOException {
     final int[] arr = FieldCache.DEFAULT.getStringIndex(reader, field).order;
-    return new DocValues(arr.length) {
+    return new DocValues() {
       /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#floatVal(int) */
       public float floatVal(int doc) {
         return (float)arr[doc];
Index: src/java/org/apache/lucene/search/function/FloatFieldSource.java
===================================================================
--- src/java/org/apache/lucene/search/function/FloatFieldSource.java	(revision 601068)
+++ src/java/org/apache/lucene/search/function/FloatFieldSource.java	(working copy)
@@ -67,7 +67,7 @@
     final float[] arr = (parser==null) ?
       cache.getFloats(reader, field) :
       cache.getFloats(reader, field, parser);
-    return new DocValues(reader.maxDoc()) {
+    return new DocValues() {
       /*(non-Javadoc) @see org.apache.lucene.search.function.DocValues#floatVal(int) */
       public float floatVal(int doc) {
         return arr[doc];      
