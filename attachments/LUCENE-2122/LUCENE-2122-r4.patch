Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java	(revision 887524)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java	Wed Dec 09 19:03:40 EST 2009
@@ -21,14 +21,7 @@
 import java.io.Reader;
 import java.text.Collator;
 import java.text.DateFormat;
-import java.util.Arrays;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Collections;
+import java.util.*;
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.KeywordAnalyzer;
@@ -36,7 +29,6 @@
 import org.apache.lucene.analysis.SimpleAnalyzer;
 import org.apache.lucene.analysis.StopAnalyzer;
 import org.apache.lucene.analysis.StopFilter;
-import org.apache.lucene.analysis.Token;
 import org.apache.lucene.analysis.TokenFilter;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.WhitespaceAnalyzer;
@@ -74,6 +66,10 @@
 import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.LocalizedTestCase;
 import org.apache.lucene.util.Version;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import static org.junit.Assert.*;
 
 /**
  * This test case is a copy of the core Lucene query parser test, it was adapted
@@ -83,14 +79,9 @@
  */
 public class TestQueryParserWrapper extends LocalizedTestCase {
 
-  public TestQueryParserWrapper(String name) {
-    super(name, new HashSet<String>(Arrays.asList(new String[]{
-      "testLegacyDateRange", "testDateRange",
-      "testCJK", "testNumber", "testFarsiRangeCollating",
-      "testLocalDateFormat"
-    })));
+  public TestQueryParserWrapper(Locale locale) {
+    super(locale);
   }
-  
   public static Analyzer qpAnalyzer = new QPTestAnalyzer();
 
   public static class QPTestFilter extends TokenFilter {
@@ -209,6 +200,7 @@
   private int originalMaxClauses;
 
   @Override
+  @Before
   public void setUp() throws Exception {
     super.setUp();
     originalMaxClauses = BooleanQuery.getMaxClauseCount();
@@ -317,6 +309,7 @@
     }
   }
 
+  @Test
   public void testCJK() throws Exception {
     // Test Ideographic Space - As wide as a CJK character cell (fullwidth)
     // used google to translate the word "term" to japanese -> ??
@@ -325,6 +318,8 @@
     assertQueryEqualsAllowLeadingWildcard("??\u3000??\u3000??", null, "??\u0020??\u0020??");
   }
 
+
+  @Test
   public void testSimple() throws Exception {
     assertQueryEquals("\"term germ\"~2", null, "\"term germ\"~2");
     assertQueryEquals("term term term", null, "term term term");
@@ -394,6 +389,7 @@
     assertEquals(QueryParserWrapper.OR_OPERATOR, qp.getDefaultOperator());
   }
 
+  @Test
   public void testPunct() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
     assertQueryEquals("a&b", a, "a&b");
@@ -401,6 +397,7 @@
     assertQueryEquals(".NET", a, ".NET");
   }
 
+  @Test
   public void testSlop() throws Exception {
 
     assertQueryEquals("\"term germ\"~2", null, "\"term germ\"~2");
@@ -410,6 +407,7 @@
     assertQueryEquals("\"term germ\"~2^2", null, "\"term germ\"~2^2.0");
   }
 
+  @Test
   public void testNumber() throws Exception {
     // The numbers go away because SimpleAnalzyer ignores them
     assertQueryEquals("3", null, "");
@@ -422,6 +420,7 @@
     assertQueryEquals("term term1 term2", a, "term term1 term2");
   }
 
+  @Test
   public void testWildcard() throws Exception {
     assertQueryEquals("term*", null, "term*");
     assertQueryEquals("term*^2", null, "term*^2.0");
@@ -507,6 +506,7 @@
     assertWildcardQueryEquals("?Term", true, "?term", true);
   }
 
+  @Test
   public void testLeadingWildcardType() throws Exception {
     QueryParserWrapper qp = getParser(null);
     qp.setAllowLeadingWildcard(true);
@@ -515,6 +515,7 @@
     assertEquals(WildcardQuery.class, qp.parse("*term*").getClass());
   }
 
+  @Test
   public void testQPA() throws Exception {
     assertQueryEquals("term term^3.0 term", qpAnalyzer, "term term^3.0 term");
     assertQueryEquals("term stop^3.0 term", qpAnalyzer, "term term");
@@ -546,6 +547,7 @@
     assertTrue(getQuery("term +stop", qpAnalyzer) instanceof TermQuery);
   }
 
+  @Test
   public void testRange() throws Exception {
     assertQueryEquals("[ a TO z]", null, "[a TO z]");
     assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((TermRangeQuery)getQuery("[ a TO z]", null)).getRewriteMethod());
@@ -567,6 +569,7 @@
         "gack (bar blar {a TO z})");
   }
 
+  @Test
   public void testFarsiRangeCollating() throws Exception {
 
     RAMDirectory ramDir = new RAMDirectory();
@@ -659,6 +662,7 @@
   }
 
   /** for testing legacy DateField support */
+  @Test
   public void testLegacyDateRange() throws Exception {
     String startDate = getLocalizedDate(2002, 1, 1, false);
     String endDate = getLocalizedDate(2002, 1, 4, false);
@@ -672,6 +676,7 @@
         + getLegacyDate(startDate) + " TO " + getLegacyDate(endDate) + "}");
   }
 
+  @Test
   public void testDateRange() throws Exception {
     String startDate = getLocalizedDate(2002, 1, 1, false);
     String endDate = getLocalizedDate(2002, 1, 4, false);
@@ -725,6 +730,7 @@
         + getDate(endDate, resolution) + "}");
   }
 
+  @Test
   public void testEscaped() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
 
@@ -822,6 +828,7 @@
     assertQueryEquals("(\"a\\\\\") or (\"b\")", a, "a\\ or b");
   }
 
+  @Test
   public void testQueryStringEscaping() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
 
@@ -861,6 +868,7 @@
     assertEscapedQueryEquals("&& abc &&", a, "\\&\\& abc \\&\\&");
   }
 
+  @Test
   public void testTabNewlineCarriageReturn() throws Exception {
     assertQueryEqualsDOA("+weltbank +worlbank", null, "+weltbank +worlbank");
 
@@ -883,6 +891,7 @@
     assertQueryEqualsDOA("weltbank \t +worlbank", null, "+weltbank +worlbank");
   }
 
+  @Test
   public void testSimpleDAO() throws Exception {
     assertQueryEqualsDOA("term term term", null, "+term +term +term");
     assertQueryEqualsDOA("term +term term", null, "+term +term +term");
@@ -891,6 +900,7 @@
     assertQueryEqualsDOA("-term term term", null, "-term +term +term");
   }
 
+  @Test
   public void testBoost() throws Exception {
     StandardAnalyzer oneStopAnalyzer = new StandardAnalyzer(Version.LUCENE_CURRENT, Collections.singleton("on"));
     QueryParserWrapper qp = new QueryParserWrapper("field", oneStopAnalyzer);
@@ -923,6 +933,7 @@
     fail("ParseException expected, not thrown");
   }
 
+  @Test
   public void testException() throws Exception {
     assertParseException("\"some phrase");
     assertParseException("(foo bar");
@@ -932,6 +943,7 @@
     assertParseException("secret AND illegal) AND access:confidential");
   }
 
+  @Test
   public void testCustomQueryParserWildcard() {
     try {
       new QPTestParser("contents", new WhitespaceAnalyzer()).parse("a?t");
@@ -941,6 +953,7 @@
     }
   }
 
+  @Test
   public void testCustomQueryParserFuzzy() throws Exception {
     try {
       new QPTestParser("contents", new WhitespaceAnalyzer()).parse("xunit~");
@@ -950,6 +963,7 @@
     }
   }
 
+  @Test
   public void testBooleanQuery() throws Exception {
     BooleanQuery.setMaxClauseCount(2);
     try {
@@ -965,6 +979,7 @@
   /**
    * This test differs from TestPrecedenceQueryParser
    */
+  @Test
   public void testPrecedence() throws Exception {
     QueryParserWrapper qp = new QueryParserWrapper("field",
         new WhitespaceAnalyzer());
@@ -974,6 +989,7 @@
     assertEquals(query1, query2);
   }
 
+  @Test
   public void testLocalDateFormat() throws IOException, ParseException {
 
     RAMDirectory ramDir = new RAMDirectory();
@@ -992,6 +1008,7 @@
     is.close();
   }
 
+  @Test
   public void testStarParsing() throws Exception {
     // final int[] type = new int[1];
     // QueryParser qp = new QueryParserWrapper("field", new
@@ -1055,6 +1072,7 @@
 
   }
 
+  @Test
   public void testStopwords() throws Exception {
     QueryParserWrapper qp = new QueryParserWrapper("a", new StopAnalyzer(Version.LUCENE_CURRENT, StopFilter.makeStopSet(Version.LUCENE_CURRENT, "the", "foo")));
     Query result = qp.parse("a:the OR a:foo");
@@ -1069,11 +1087,12 @@
         .parse("(fieldX:xxxxx OR fieldy:xxxxxxxx)^2 AND (fieldx:the OR fieldy:foo)");
     assertNotNull("result is null and it shouldn't be", result);
     assertTrue("result is not a BooleanQuery", result instanceof BooleanQuery);
-    System.out.println("Result: " + result);
+    //System.out.println("Result: " + result);
     assertTrue(((BooleanQuery) result).clauses().size() + " does not equal: "
         + 2, ((BooleanQuery) result).clauses().size() == 2);
   }
 
+  @Test
   public void testPositionIncrement() throws Exception {
     QueryParserWrapper qp = new QueryParserWrapper("a", new StopAnalyzer(Version.LUCENE_CURRENT, StopFilter.makeStopSet(Version.LUCENE_CURRENT, "the", "in", "are", "this")));
     qp.setEnablePositionIncrements(true);
@@ -1092,6 +1111,7 @@
     }
   }
 
+  @Test
   public void testMatchAllDocs() throws Exception {
     QueryParserWrapper qp = new QueryParserWrapper("field",
         new WhitespaceAnalyzer());
@@ -1124,6 +1144,7 @@
   }
 
   @Override
+  @After
   public void tearDown() throws Exception {
     super.tearDown();
     BooleanQuery.setMaxClauseCount(originalMaxClauses);
Index: contrib/misc/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java
===================================================================
--- contrib/misc/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java	(revision 887524)
+++ contrib/misc/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java	Wed Dec 09 18:50:35 EST 2009
@@ -17,41 +17,30 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.LowerCaseTokenizer;
-import org.apache.lucene.analysis.SimpleAnalyzer;
-import org.apache.lucene.analysis.TokenFilter;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.WhitespaceAnalyzer;
+import org.apache.lucene.analysis.*;
 import org.apache.lucene.analysis.standard.StandardAnalyzer;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.TermAttribute;
 import org.apache.lucene.document.DateTools;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.FuzzyQuery;
-import org.apache.lucene.search.PhraseQuery;
-import org.apache.lucene.search.PrefixQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermRangeQuery;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.WildcardQuery;
+import org.apache.lucene.search.*;
 import org.apache.lucene.util.LocalizedTestCase;
+import org.junit.After;
+import static org.junit.Assert.*;
+import org.junit.Test;
+import org.junit.Before;
 
 import java.io.IOException;
 import java.io.Reader;
 import java.text.DateFormat;
-import java.util.Arrays;
 import java.util.Calendar;
-import java.util.GregorianCalendar;
-import java.util.HashSet;
 import java.util.Collections;
+import java.util.GregorianCalendar;
+import java.util.Locale;
 
 public class TestPrecedenceQueryParser extends LocalizedTestCase {
-  
+
-  public TestPrecedenceQueryParser(String name) {
-    super(name, new HashSet<String>(Arrays.asList(new String[]{
-      "testDateRange", "testNumber"
-    })));
+  public TestPrecedenceQueryParser(Locale locale) {
+    super(locale);
   }
 
   public static Analyzer qpAnalyzer = new QPTestAnalyzer();
@@ -70,7 +59,7 @@
 
     TermAttribute termAtt = addAttribute(TermAttribute.class);
     OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);
-    
+
     @Override
     public boolean incrementToken() throws IOException {
       if (inPhrase) {
@@ -79,7 +68,7 @@
         offsetAtt.setOffset(savedStart, savedEnd);
         return true;
       } else
-        while(input.incrementToken())
+        while (input.incrementToken())
           if (termAtt.term().equals("phrase")) {
             inPhrase = true;
             savedStart = offsetAtt.startOffset();
@@ -95,7 +84,9 @@
 
   public static class QPTestAnalyzer extends Analyzer {
 
-    /** Filters LowerCaseTokenizer with StopFilter. */
+    /**
+     * Filters LowerCaseTokenizer with StopFilter.
+     */
     @Override
     public final TokenStream tokenStream(String fieldName, Reader reader) {
       return new QPTestFilter(new LowerCaseTokenizer(reader));
@@ -121,6 +112,7 @@
   private int originalMaxClauses;
 
   @Override
+  @Before
   public void setUp() throws Exception {
     super.setUp();
     originalMaxClauses = BooleanQuery.getMaxClauseCount();
@@ -139,24 +131,24 @@
   }
 
   public void assertQueryEquals(String query, Analyzer a, String result)
-    throws Exception {
+          throws Exception {
     Query q = getQuery(query, a);
     String s = q.toString("field");
     if (!s.equals(result)) {
       fail("Query /" + query + "/ yielded /" + s
-           + "/, expecting /" + result + "/");
+              + "/, expecting /" + result + "/");
     }
   }
 
   public void assertWildcardQueryEquals(String query, boolean lowercase, String result)
-    throws Exception {
+          throws Exception {
     PrecedenceQueryParser qp = getParser(null);
     qp.setLowercaseExpandedTerms(lowercase);
     Query q = qp.parse(query);
     String s = q.toString("field");
     if (!s.equals(result)) {
       fail("WildcardQuery /" + query + "/ yielded /" + s
-           + "/, expecting /" + result + "/");
+              + "/, expecting /" + result + "/");
     }
   }
 
@@ -166,12 +158,12 @@
     String s = q.toString("field");
     if (!s.equals(result)) {
       fail("WildcardQuery /" + query + "/ yielded /" + s + "/, expecting /"
-          + result + "/");
+              + result + "/");
     }
   }
 
   public Query getQueryDOA(String query, Analyzer a)
-    throws Exception {
+          throws Exception {
     if (a == null)
       a = new SimpleAnalyzer();
     PrecedenceQueryParser qp = new PrecedenceQueryParser("field", a);
@@ -180,12 +172,12 @@
   }
 
   public void assertQueryEqualsDOA(String query, Analyzer a, String result)
-    throws Exception {
+          throws Exception {
     Query q = getQueryDOA(query, a);
     String s = q.toString("field");
     if (!s.equals(result)) {
       fail("Query /" + query + "/ yielded /" + s
-           + "/, expecting /" + result + "/");
+              + "/, expecting /" + result + "/");
     }
   }
 
@@ -214,9 +206,9 @@
 
     assertQueryEquals("+term -term term", null, "+term -term term");
     assertQueryEquals("foo:term AND field:anotherTerm", null,
-                      "+foo:term +anotherterm");
+            "+foo:term +anotherterm");
     assertQueryEquals("term AND \"phrase phrase\"", null,
-                      "+term +\"phrase phrase\"");
+            "+term +\"phrase phrase\"");
     assertQueryEquals("\"hello there\"", null, "\"hello there\"");
     assertTrue(getQuery("a AND b", null) instanceof BooleanQuery);
     assertTrue(getQuery("hello", null) instanceof TermQuery);
@@ -231,14 +223,14 @@
     assertQueryEquals("\"term germ\"^2", null, "\"term germ\"^2.0");
 
     assertQueryEquals("(foo OR bar) AND (baz OR boo)", null,
-                      "+(foo bar) +(baz boo)");
+            "+(foo bar) +(baz boo)");
     assertQueryEquals("((a OR b) AND NOT c) OR d", null,
-                      "(+(a b) -c) d");
+            "(+(a b) -c) d");
     assertQueryEquals("+(apple \"steve jobs\") -(foo bar baz)", null,
-                      "+(apple \"steve jobs\") -(foo bar baz)");
+            "+(apple \"steve jobs\") -(foo bar baz)");
     assertQueryEquals("+title:(dog OR cat) -author:\"bob dole\"", null,
-                      "+(title:dog title:cat) -author:\"bob dole\"");
-    
+            "+(title:dog title:cat) -author:\"bob dole\"");
+
     PrecedenceQueryParser qp = new PrecedenceQueryParser("field", new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT));
     // make sure OR is the default:
     assertEquals(PrecedenceQueryParser.OR_OPERATOR, qp.getDefaultOperator());
@@ -252,6 +244,7 @@
     assertQueryEquals("a OR -b", null, "a (-b)");
   }
 
+  @Test
   public void testPunct() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
     assertQueryEquals("a&b", a, "a&b");
@@ -259,6 +252,7 @@
     assertQueryEquals(".NET", a, ".NET");
   }
 
+  @Test
   public void testSlop() throws Exception {
     assertQueryEquals("\"term germ\"~2", null, "\"term germ\"~2");
     assertQueryEquals("\"term germ\"~2 flork", null, "\"term germ\"~2 flork");
@@ -267,6 +261,7 @@
     assertQueryEquals("\"term germ\"~2^2", null, "\"term germ\"~2^2.0");
   }
 
+  @Test
   public void testNumber() throws Exception {
 // The numbers go away because SimpleAnalzyer ignores them
     assertQueryEquals("3", null, "");
@@ -295,16 +290,16 @@
     assertTrue(getQuery("term*^2", null) instanceof PrefixQuery);
     assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
     assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
-    FuzzyQuery fq = (FuzzyQuery)getQuery("term~0.7", null);
+    FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
     assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
     assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-    fq = (FuzzyQuery)getQuery("term~", null);
+    fq = (FuzzyQuery) getQuery("term~", null);
     assertEquals(0.5f, fq.getMinSimilarity(), 0.1f);
     assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
     try {
       getQuery("term~1.1", null);   // value > 1, throws exception
       fail();
-    } catch(ParseException pe) {
+    } catch (ParseException pe) {
       // expected exception
     }
     assertTrue(getQuery("term*germ", null) instanceof WildcardQuery);
@@ -346,23 +341,25 @@
     assertWildcardQueryEquals("[A TO C]", false, "[A TO C]");
   }
 
+  @Test
   public void testQPA() throws Exception {
     assertQueryEquals("term term term", qpAnalyzer, "term term term");
     assertQueryEquals("term +stop term", qpAnalyzer, "term term");
     assertQueryEquals("term -stop term", qpAnalyzer, "term term");
     assertQueryEquals("drop AND stop AND roll", qpAnalyzer, "+drop +roll");
     assertQueryEquals("term phrase term", qpAnalyzer,
-                      "term \"phrase1 phrase2\" term");
+            "term \"phrase1 phrase2\" term");
     // note the parens in this next assertion differ from the original
     // QueryParser behavior
     assertQueryEquals("term AND NOT phrase term", qpAnalyzer,
-                      "(+term -\"phrase1 phrase2\") term");
+            "(+term -\"phrase1 phrase2\") term");
     assertQueryEquals("stop", qpAnalyzer, "");
     assertQueryEquals("stop OR stop AND stop", qpAnalyzer, "");
     assertTrue(getQuery("term term term", qpAnalyzer) instanceof BooleanQuery);
     assertTrue(getQuery("term +stop", qpAnalyzer) instanceof TermQuery);
   }
 
+  @Test
   public void testRange() throws Exception {
     assertQueryEquals("[ a TO z]", null, "[a TO z]");
     assertTrue(getQuery("[ a TO z]", null) instanceof TermRangeQuery);
@@ -375,7 +372,7 @@
     assertQueryEquals("( bar blar { a TO z}) ", null, "bar blar {a TO z}");
     assertQueryEquals("gack ( bar blar { a TO z}) ", null, "gack (bar blar {a TO z})");
   }
-  
+
   private String escapeDateString(String s) {
     if (s.contains(" ")) {
       return "\"" + s + "\"";
@@ -396,41 +393,43 @@
     return df.format(calendar.getTime());
   }
 
+  @Test
   public void testDateRange() throws Exception {
     String startDate = getLocalizedDate(2002, 1, 1);
     String endDate = getLocalizedDate(2002, 1, 4);
     assertQueryEquals("[ " + escapeDateString(startDate) + " TO " + escapeDateString(endDate) + "]", null,
-                      "[" + getDate(startDate) + " TO " + getDate(endDate) + "]");
+            "[" + getDate(startDate) + " TO " + getDate(endDate) + "]");
     assertQueryEquals("{  " + escapeDateString(startDate) + "    " + escapeDateString(endDate) + "   }", null,
-                      "{" + getDate(startDate) + " TO " + getDate(endDate) + "}");
+            "{" + getDate(startDate) + " TO " + getDate(endDate) + "}");
   }
 
+  @Test
   public void testEscaped() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
-    
+
     /*assertQueryEquals("\\[brackets", a, "\\[brackets");
-    assertQueryEquals("\\[brackets", null, "brackets");
-    assertQueryEquals("\\\\", a, "\\\\");
-    assertQueryEquals("\\+blah", a, "\\+blah");
-    assertQueryEquals("\\(blah", a, "\\(blah");
+assertQueryEquals("\\[brackets", null, "brackets");
+assertQueryEquals("\\\\", a, "\\\\");
+assertQueryEquals("\\+blah", a, "\\+blah");
+assertQueryEquals("\\(blah", a, "\\(blah");
 
-    assertQueryEquals("\\-blah", a, "\\-blah");
-    assertQueryEquals("\\!blah", a, "\\!blah");
-    assertQueryEquals("\\{blah", a, "\\{blah");
-    assertQueryEquals("\\}blah", a, "\\}blah");
-    assertQueryEquals("\\:blah", a, "\\:blah");
-    assertQueryEquals("\\^blah", a, "\\^blah");
-    assertQueryEquals("\\[blah", a, "\\[blah");
-    assertQueryEquals("\\]blah", a, "\\]blah");
-    assertQueryEquals("\\\"blah", a, "\\\"blah");
-    assertQueryEquals("\\(blah", a, "\\(blah");
-    assertQueryEquals("\\)blah", a, "\\)blah");
-    assertQueryEquals("\\~blah", a, "\\~blah");
-    assertQueryEquals("\\*blah", a, "\\*blah");
-    assertQueryEquals("\\?blah", a, "\\?blah");
-    //assertQueryEquals("foo \\&\\& bar", a, "foo \\&\\& bar");
-    //assertQueryEquals("foo \\|| bar", a, "foo \\|| bar");
-    //assertQueryEquals("foo \\AND bar", a, "foo \\AND bar");*/
+assertQueryEquals("\\-blah", a, "\\-blah");
+assertQueryEquals("\\!blah", a, "\\!blah");
+assertQueryEquals("\\{blah", a, "\\{blah");
+assertQueryEquals("\\}blah", a, "\\}blah");
+assertQueryEquals("\\:blah", a, "\\:blah");
+assertQueryEquals("\\^blah", a, "\\^blah");
+assertQueryEquals("\\[blah", a, "\\[blah");
+assertQueryEquals("\\]blah", a, "\\]blah");
+assertQueryEquals("\\\"blah", a, "\\\"blah");
+assertQueryEquals("\\(blah", a, "\\(blah");
+assertQueryEquals("\\)blah", a, "\\)blah");
+assertQueryEquals("\\~blah", a, "\\~blah");
+assertQueryEquals("\\*blah", a, "\\*blah");
+assertQueryEquals("\\?blah", a, "\\?blah");
+//assertQueryEquals("foo \\&\\& bar", a, "foo \\&\\& bar");
+//assertQueryEquals("foo \\|| bar", a, "foo \\|| bar");
+//assertQueryEquals("foo \\AND bar", a, "foo \\AND bar");*/
 
     assertQueryEquals("a\\-b:c", a, "a-b:c");
     assertQueryEquals("a\\+b:c", a, "a+b:c");
@@ -464,44 +463,46 @@
     assertQueryEquals("[ a\\\\ TO a\\* ]", null, "[a\\ TO a*]");
   }
 
+  @Test
   public void testTabNewlineCarriageReturn()
-    throws Exception {
+          throws Exception {
     assertQueryEqualsDOA("+weltbank +worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
 
     assertQueryEqualsDOA("+weltbank\n+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \n+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \n +worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
 
     assertQueryEqualsDOA("+weltbank\r+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \r+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \r +worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
 
     assertQueryEqualsDOA("+weltbank\r\n+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \r\n+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \r\n +worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \r \n +worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
 
     assertQueryEqualsDOA("+weltbank\t+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \t+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \t +worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
   }
 
+  @Test
   public void testSimpleDAO()
-    throws Exception {
+          throws Exception {
     assertQueryEqualsDOA("term term term", null, "+term +term +term");
     assertQueryEqualsDOA("term +term term", null, "+term +term +term");
     assertQueryEqualsDOA("term term +term", null, "+term +term +term");
@@ -509,8 +510,9 @@
     assertQueryEqualsDOA("-term term term", null, "-term +term +term");
   }
 
+  @Test
   public void testBoost()
-    throws Exception {
+          throws Exception {
     StandardAnalyzer oneStopAnalyzer = new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT, Collections.singleton("on"));
     PrecedenceQueryParser qp = new PrecedenceQueryParser("field", oneStopAnalyzer);
     Query q = qp.parse("on^1.0");
@@ -528,6 +530,7 @@
     assertNotNull(q);
   }
 
+  @Test
   public void testException() throws Exception {
     try {
       assertQueryEquals("\"some phrase", null, "abc");
@@ -536,6 +539,7 @@
     }
   }
 
+  @Test
   public void testCustomQueryParserWildcard() {
     try {
       new QPTestParser("contents", new WhitespaceAnalyzer()).parse("a?t");
@@ -545,6 +549,7 @@
     fail("Wildcard queries should not be allowed");
   }
 
+  @Test
   public void testCustomQueryParserFuzzy() throws Exception {
     try {
       new QPTestParser("contents", new WhitespaceAnalyzer()).parse("xunit~");
@@ -554,6 +559,7 @@
     fail("Fuzzy queries should not be allowed");
   }
 
+  @Test
   public void testBooleanQuery() throws Exception {
     BooleanQuery.setMaxClauseCount(2);
     try {
@@ -599,7 +605,10 @@
 
 
   @Override
-  public void tearDown() {
+  @After
+  public void tearDown() throws Exception {
+
+    super.tearDown();
     BooleanQuery.setMaxClauseCount(originalMaxClauses);
   }
 
Index: contrib/misc/src/test/org/apache/lucene/queryParser/ext/TestExtendableQueryParser.java
===================================================================
--- contrib/misc/src/test/org/apache/lucene/queryParser/ext/TestExtendableQueryParser.java	(revision 887533)
+++ contrib/misc/src/test/org/apache/lucene/queryParser/ext/TestExtendableQueryParser.java	Sun Dec 06 10:30:04 EST 2009
@@ -27,7 +27,13 @@
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.util.Version;
+import static org.junit.Assert.fail;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import org.junit.Test;
 
+import java.util.Locale;
+
 /**
  * Testcase for the class {@link ExtendableQueryParser}
  */
@@ -35,8 +41,8 @@
   private static char[] DELIMITERS = new char[] {
       Extensions.DEFAULT_EXTENSION_FIELD_DELIMITER, '-', '|' };
 
-  public TestExtendableQueryParser(String name) {
-    super(name);
+  public TestExtendableQueryParser(Locale locale) {
+    super(locale);
   }
 
   @Override
@@ -55,6 +61,7 @@
     return qp;
   }
 
+  @Test
   public void testUnescapedExtDelimiter() throws Exception {
     Extensions ext = newExtensions(':');
     ext.add("testExt", new ExtensionStub());
@@ -66,6 +73,7 @@
     }
   }
 
+  @Test
   public void testExtFieldUnqoted() throws Exception {
     for (int i = 0; i < DELIMITERS.length; i++) {
       Extensions ext = newExtensions(DELIMITERS[i]);
@@ -98,6 +106,7 @@
     }
   }
 
+  @Test
   public void testExtDefaultField() throws Exception {
     for (int i = 0; i < DELIMITERS.length; i++) {
       Extensions ext = newExtensions(DELIMITERS[i]);
@@ -118,6 +127,7 @@
     return new Extensions(delimiter);
   }
 
+  @Test
   public void testExtField() throws Exception {
     for (int i = 0; i < DELIMITERS.length; i++) {
       Extensions ext = newExtensions(DELIMITERS[i]);
Index: src/test/org/apache/lucene/document/TestDateTools.java
===================================================================
--- src/test/org/apache/lucene/document/TestDateTools.java	(revision 887181)
+++ src/test/org/apache/lucene/document/TestDateTools.java	Wed Dec 09 18:49:59 EST 2009
@@ -1,15 +1,15 @@
 package org.apache.lucene.document;
 
+import org.apache.lucene.util.LocalizedTestCase;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import org.junit.Test;
+
+import java.text.DateFormat;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.TimeZone;
-import java.util.Locale;
+import java.util.*;
 
-import org.apache.lucene.util.LocalizedTestCase;
-
 /**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -17,22 +17,26 @@
  * The ASF licenses this file to You under the Apache License, Version 2.0
  * (the "License"); you may not use this file except in compliance with
  * the License.  You may obtain a copy of the License at
- *
+ * <p/>
- *     http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- *
+ * <p/>
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+@SuppressWarnings({"MagicNumber"})
 public class TestDateTools extends LocalizedTestCase {
 
+  public TestDateTools(Locale locale) {
+    super(locale);
+  }
+
+  @Test
   public void testStringToDate() throws ParseException {
-    
+
-    Date d = null;
-    d = DateTools.stringToDate("2004");
+    Date d = DateTools.stringToDate("2004");
     assertEquals("2004-01-01 00:00:00:000", isoFormat(d));
     d = DateTools.stringToDate("20040705");
     assertEquals("2004-07-05 00:00:00:000", isoFormat(d));
@@ -40,49 +44,52 @@
     assertEquals("2004-07-05 09:10:00:000", isoFormat(d));
     d = DateTools.stringToDate("20040705091055990");
     assertEquals("2004-07-05 09:10:55:990", isoFormat(d));
+  }
 
-    try {
-      d = DateTools.stringToDate("97");    // no date
-      fail();
-    } catch(ParseException e) { /* expected exception */ }
-    try {
-      d = DateTools.stringToDate("200401011235009999");    // no date
-      fail();
-    } catch(ParseException e) { /* expected exception */ }
-    try {
-      d = DateTools.stringToDate("aaaa");    // no date
-      fail();
-    } catch(ParseException e) { /* expected exception */ }
+  @Test(expected = ParseException.class)
+  public void testBadDate1() throws ParseException {
+    DateTools.stringToDate("97");    // no date
+  }
 
+  @Test(expected = ParseException.class)
+  public void testBadDate2() throws Exception {
+    DateTools.stringToDate("200401011235009999");    // no date
   }
-  
+
+  @Test(expected = ParseException.class)
+  public void testBadDate3() throws ParseException {
+    DateTools.stringToDate("aaaa");    // no date
+  }
+
+  @Test
   public void testStringtoTime() throws ParseException {
     long time = DateTools.stringToTime("197001010000");
     Calendar cal = new GregorianCalendar();
     cal.set(1970, 0, 1,    // year=1970, month=january, day=1
-        0, 0, 0);          // hour, minute, second
+            0, 0, 0);          // hour, minute, second
     cal.set(Calendar.MILLISECOND, 0);
     cal.setTimeZone(TimeZone.getTimeZone("GMT"));
     assertEquals(cal.getTime().getTime(), time);
     cal.set(1980, 1, 2,    // year=1980, month=february, day=2
-        11, 5, 0);          // hour, minute, second
+            11, 5, 0);          // hour, minute, second
     cal.set(Calendar.MILLISECOND, 0);
     time = DateTools.stringToTime("198002021105");
     assertEquals(cal.getTime().getTime(), time);
   }
-  
+
+  @Test
   public void testDateAndTimetoString() throws ParseException {
     Calendar cal = new GregorianCalendar();
     cal.setTimeZone(TimeZone.getTimeZone("GMT"));
     cal.set(2004, 1, 3,   // year=2004, month=february(!), day=3
-        22, 8, 56);       // hour, minute, second
+            22, 8, 56);       // hour, minute, second
     cal.set(Calendar.MILLISECOND, 333);
-    
+
     String dateString;
     dateString = DateTools.dateToString(cal.getTime(), DateTools.Resolution.YEAR);
     assertEquals("2004", dateString);
     assertEquals("2004-01-01 00:00:00:000", isoFormat(DateTools.stringToDate(dateString)));
-    
+
     dateString = DateTools.dateToString(cal.getTime(), DateTools.Resolution.MONTH);
     assertEquals("200402", dateString);
     assertEquals("2004-02-01 00:00:00:000", isoFormat(DateTools.stringToDate(dateString)));
@@ -90,26 +97,26 @@
     dateString = DateTools.dateToString(cal.getTime(), DateTools.Resolution.DAY);
     assertEquals("20040203", dateString);
     assertEquals("2004-02-03 00:00:00:000", isoFormat(DateTools.stringToDate(dateString)));
-    
+
     dateString = DateTools.dateToString(cal.getTime(), DateTools.Resolution.HOUR);
     assertEquals("2004020322", dateString);
     assertEquals("2004-02-03 22:00:00:000", isoFormat(DateTools.stringToDate(dateString)));
-    
+
     dateString = DateTools.dateToString(cal.getTime(), DateTools.Resolution.MINUTE);
     assertEquals("200402032208", dateString);
     assertEquals("2004-02-03 22:08:00:000", isoFormat(DateTools.stringToDate(dateString)));
-    
+
     dateString = DateTools.dateToString(cal.getTime(), DateTools.Resolution.SECOND);
     assertEquals("20040203220856", dateString);
     assertEquals("2004-02-03 22:08:56:000", isoFormat(DateTools.stringToDate(dateString)));
-    
+
     dateString = DateTools.dateToString(cal.getTime(), DateTools.Resolution.MILLISECOND);
     assertEquals("20040203220856333", dateString);
     assertEquals("2004-02-03 22:08:56:333", isoFormat(DateTools.stringToDate(dateString)));
 
     // date before 1970:
     cal.set(1961, 2, 5,   // year=1961, month=march(!), day=5
-        23, 9, 51);       // hour, minute, second
+            23, 9, 51);       // hour, minute, second
     cal.set(Calendar.MILLISECOND, 444);
     dateString = DateTools.dateToString(cal.getTime(), DateTools.Resolution.MILLISECOND);
     assertEquals("19610305230951444", dateString);
@@ -121,25 +128,26 @@
 
     // timeToString:
     cal.set(1970, 0, 1, // year=1970, month=january, day=1
-        0, 0, 0); // hour, minute, second
+            0, 0, 0); // hour, minute, second
     cal.set(Calendar.MILLISECOND, 0);
     dateString = DateTools.timeToString(cal.getTime().getTime(),
-        DateTools.Resolution.MILLISECOND);
+            DateTools.Resolution.MILLISECOND);
     assertEquals("19700101000000000", dateString);
-        
+
     cal.set(1970, 0, 1, // year=1970, month=january, day=1
-        1, 2, 3); // hour, minute, second
+            1, 2, 3); // hour, minute, second
     cal.set(Calendar.MILLISECOND, 0);
     dateString = DateTools.timeToString(cal.getTime().getTime(),
-        DateTools.Resolution.MILLISECOND);
+            DateTools.Resolution.MILLISECOND);
     assertEquals("19700101010203000", dateString);
   }
-  
+
+  @Test
   public void testRound() {
     Calendar cal = new GregorianCalendar();
     cal.setTimeZone(TimeZone.getTimeZone("GMT"));
     cal.set(2004, 1, 3,   // year=2004, month=february(!), day=3
-        22, 8, 56);       // hour, minute, second
+            22, 8, 56);       // hour, minute, second
     cal.set(Calendar.MILLISECOND, 333);
     Date date = cal.getTime();
     assertEquals("2004-02-03 22:08:56:333", isoFormat(date));
@@ -174,24 +182,24 @@
   }
 
   private String isoFormat(Date date) {
-    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS", Locale.US);
+    DateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SSS", Locale.US);
     sdf.setTimeZone(TimeZone.getTimeZone("GMT"));
     return sdf.format(date);
   }
 
+  @Test
   public void testDateToolsUTC() throws Exception {
     // Sun, 30 Oct 2005 00:00:00 +0000 -- the last second of 2005's DST in Europe/London
     long time = 1130630400;
     try {
-        TimeZone.setDefault(TimeZone.getTimeZone(/* "GMT" */ "Europe/London"));
+      TimeZone.setDefault(TimeZone.getTimeZone(/* "GMT" */ "Europe/London"));
-        String d1 = DateTools.dateToString(new Date(time*1000), DateTools.Resolution.MINUTE);
+      String d1 = DateTools.dateToString(new Date(time * 1000), DateTools.Resolution.MINUTE);
-        String d2 = DateTools.dateToString(new Date((time+3600)*1000), DateTools.Resolution.MINUTE);
+      String d2 = DateTools.dateToString(new Date((time + 3600) * 1000), DateTools.Resolution.MINUTE);
-        assertFalse("different times", d1.equals(d2));
+      assertFalse("different times", d1.equals(d2));
-        assertEquals("midnight", DateTools.stringToTime(d1), time*1000);
+      assertEquals("midnight", DateTools.stringToTime(d1), time * 1000);
-        assertEquals("later", DateTools.stringToTime(d2), (time+3600)*1000);
+      assertEquals("later", DateTools.stringToTime(d2), (time + 3600) * 1000);
     } finally {
-        TimeZone.setDefault(null);
+      TimeZone.setDefault(null);
     }
   }
-
 }
Index: src/test/org/apache/lucene/util/LocalizedTestCase.java
===================================================================
--- src/test/org/apache/lucene/util/LocalizedTestCase.java	(revision 887181)
+++ src/test/org/apache/lucene/util/LocalizedTestCase.java	Wed Dec 09 18:49:07 EST 2009
@@ -17,8 +17,16 @@
  * limitations under the License.
  */
 
+import org.junit.After;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.AfterClass;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Arrays;
+import java.util.Collection;
 import java.util.Locale;
-import java.util.Set;
 
 /**
  * Base test class for Lucene test classes that test Locale-sensitive behavior.
@@ -28,81 +36,51 @@
  * not fail under a different environment.
  * </p>
  */
-public abstract class LocalizedTestCase extends LuceneTestCase {
-  /**
-   * Before changing the default Locale, save the default Locale here so that it
-   * can be restored.
-   */
-  private final Locale defaultLocale = Locale.getDefault();
+@RunWith(Parameterized.class)
+public abstract class LocalizedTestCase extends LuceneTestCaseJ4 {
-
+  
-  /**
-   * The locale being used as the system default Locale
-   */
-  private Locale locale;
-
-  /**
-   * An optional limited set of testcases that will run under different Locales.
-   */
-  private final Set<String> testWithDifferentLocales;
-
-  public LocalizedTestCase() {
-    super();
-    testWithDifferentLocales = null;
+  @Parameterized.Parameters
+  public static Collection<Locale[]> data() {
+    // There must be a better way to do this....
+    Locale[] locs = Locale.getAvailableLocales();
+    Locale[][] ret = new Locale[locs.length][1];
+    for (int idx = 0; idx < locs.length; ++idx) {
+      ret[idx][0] = locs[idx];
-  }
+    }
-
-  public LocalizedTestCase(String name) {
-    super(name);
-    testWithDifferentLocales = null;
+    return Arrays.asList(ret);
   }
 
-  public LocalizedTestCase(Set<String> testWithDifferentLocales) {
-    super();
-    this.testWithDifferentLocales = testWithDifferentLocales;
-  }
 
-  public LocalizedTestCase(String name, Set<String> testWithDifferentLocales) {
-    super(name);
-    this.testWithDifferentLocales = testWithDifferentLocales;
+  protected LocalizedTestCase(Locale locale) {
+    _currentLocale = locale;
   }
 
+  @Before
   @Override
-  protected void setUp() throws Exception {
+  public void setUp() throws Exception {
     super.setUp();
-    Locale.setDefault(locale);
+    Locale.setDefault(_currentLocale);
   }
 
+  @After
   @Override
-  protected void tearDown() throws Exception {
-    Locale.setDefault(defaultLocale);
+  public void tearDown() throws Exception {
     super.tearDown();
   }
-  
+
-  @Override
-  public void runBare() throws Throwable {
-    // Do the test with the default Locale (default)
-    try {
-      locale = defaultLocale;
-      super.runBare();
-    } catch (Throwable e) {
-      System.out.println("Test failure of '" + getName()
-          + "' occurred with the default Locale " + locale);
-      throw e;
+
+  @BeforeClass
+  public static void stashDefault() {
+    _origDefault = Locale.getDefault();
-    }
+  }
 
-    if (testWithDifferentLocales == null
-        || testWithDifferentLocales.contains(getName())) {
-      // Do the test again under different Locales
-      Locale systemLocales[] = Locale.getAvailableLocales();
-      for (int i = 0; i < systemLocales.length; i++) {
-        try {
-          locale = systemLocales[i];
-          super.runBare();
-        } catch (Throwable e) {
-          System.out.println("Test failure of '" + getName()
-              + "' occurred under a different Locale " + locale);
-          throw e;
+  @AfterClass
+  public static void restoreDefault() {
+    Locale.setDefault(_origDefault);
-        }
+  }
+
+  protected Locale _currentLocale;
+
+  private static Locale _origDefault;
+
-      }
+}
-    }
-  }
-}
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java	(revision 887524)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java	Wed Dec 09 18:47:57 EST 2009
@@ -17,41 +17,17 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.io.Reader;
-import java.text.Collator;
-import java.text.DateFormat;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Collections;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.KeywordAnalyzer;
-import org.apache.lucene.analysis.LowerCaseTokenizer;
-import org.apache.lucene.analysis.SimpleAnalyzer;
-import org.apache.lucene.analysis.StopAnalyzer;
-import org.apache.lucene.analysis.StopFilter;
-import org.apache.lucene.analysis.Token;
-import org.apache.lucene.analysis.TokenFilter;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.WhitespaceAnalyzer;
+import org.apache.lucene.analysis.*;
 import org.apache.lucene.analysis.standard.StandardAnalyzer;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
-import org.apache.lucene.analysis.tokenattributes.TermAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
+import org.apache.lucene.analysis.tokenattributes.TermAttribute;
 import org.apache.lucene.document.DateField;
 import org.apache.lucene.document.DateTools;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.messages.MessageImpl;
 import org.apache.lucene.queryParser.core.QueryNodeException;
@@ -62,38 +38,33 @@
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorPipeline;
 import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
 import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.FuzzyQuery;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.MultiPhraseQuery;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.PhraseQuery;
-import org.apache.lucene.search.PrefixQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.ScoreDoc;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TermRangeQuery;
-import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.search.*;
 import org.apache.lucene.store.MockRAMDirectory;
+import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.LocalizedTestCase;
 import org.apache.lucene.util.Version;
+import org.junit.After;
+import static org.junit.Assert.*;
+import org.junit.Before;
+import org.junit.Test;
 
+import java.io.IOException;
+import java.io.Reader;
+import java.text.Collator;
+import java.text.DateFormat;
+import java.util.*;
+
 /**
  * This test case is a copy of the core Lucene query parser test, it was adapted
  * to use new QueryParserHelper instead of the old query parser.
- * 
+ * <p/>
  * Tests QueryParser.
  */
+@SuppressWarnings({"MagicNumber"})
 public class TestQPHelper extends LocalizedTestCase {
 
-  public TestQPHelper(String name) {
-    super(name, new HashSet<String>(Arrays.asList(new String[]{
-      "testLegacyDateRange", "testDateRange",
-      "testCJK", "testNumber", "testFarsiRangeCollating",
-      "testLocalDateFormat"
-    })));
+  public TestQPHelper(Locale locale) {
+    super(locale);
   }
 
   public static Analyzer qpAnalyzer = new QPTestAnalyzer();
@@ -140,7 +111,9 @@
 
   public static class QPTestAnalyzer extends Analyzer {
 
-    /** Filters LowerCaseTokenizer with StopFilter. */
+    /**
+     * Filters LowerCaseTokenizer with StopFilter.
+     */
     @Override
     public final TokenStream tokenStream(String fieldName, Reader reader) {
       return new QPTestFilter(new LowerCaseTokenizer(reader));
@@ -149,18 +122,18 @@
 
   public static class QPTestParser extends StandardQueryParser {
     public QPTestParser(Analyzer a) {
-      ((QueryNodeProcessorPipeline)getQueryNodeProcessor())
+      ((QueryNodeProcessorPipeline) getQueryNodeProcessor())
-          .addProcessor(new QPTestParserQueryNodeProcessor());
+              .addProcessor(new QPTestParserQueryNodeProcessor());
       this.setAnalyzer(a);
 
     }
 
     private static class QPTestParserQueryNodeProcessor extends
-        QueryNodeProcessorImpl {
+            QueryNodeProcessorImpl {
 
       @Override
       protected QueryNode postProcessNode(QueryNode node)
-          throws QueryNodeException {
+              throws QueryNodeException {
 
         return node;
 
@@ -168,12 +141,12 @@
 
       @Override
       protected QueryNode preProcessNode(QueryNode node)
-          throws QueryNodeException {
+              throws QueryNodeException {
 
         if (node instanceof WildcardQueryNode || node instanceof FuzzyQueryNode) {
 
           throw new QueryNodeException(new MessageImpl(
-              QueryParserMessages.EMPTY_MESSAGE));
+                  QueryParserMessages.EMPTY_MESSAGE));
 
         }
 
@@ -183,7 +156,7 @@
 
       @Override
       protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
-          throws QueryNodeException {
+              throws QueryNodeException {
 
         return children;
 
@@ -193,9 +166,10 @@
 
   }
 
-  private int originalMaxClauses;
+  private int originalMaxClauses = 1024;
 
   @Override
+  @Before
   public void setUp() throws Exception {
     super.setUp();
     originalMaxClauses = BooleanQuery.getMaxClauseCount();
@@ -224,46 +198,46 @@
   }
 
   public void assertQueryEquals(String query, Analyzer a, String result)
-      throws Exception {
+          throws Exception {
     Query q = getQuery(query, a);
     String s = q.toString("field");
     if (!s.equals(result)) {
       fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
-          + "/");
+              + "/");
     }
   }
 
   public void assertQueryEqualsAllowLeadingWildcard(String query, Analyzer a, String result)
-      throws Exception {
+          throws Exception {
     Query q = getQueryAllowLeadingWildcard(query, a);
     String s = q.toString("field");
     if (!s.equals(result)) {
       fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
-          + "/");
+              + "/");
     }
   }
 
   public void assertQueryEquals(StandardQueryParser qp, String field,
-      String query, String result) throws Exception {
+                                String query, String result) throws Exception {
     Query q = qp.parse(query, field);
     String s = q.toString(field);
     if (!s.equals(result)) {
       fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
-          + "/");
+              + "/");
     }
   }
 
   public void assertEscapedQueryEquals(String query, Analyzer a, String result)
-      throws Exception {
+          throws Exception {
     String escapedQuery = QueryParserUtil.escape(query);
     if (!escapedQuery.equals(result)) {
       fail("Query /" + query + "/ yielded /" + escapedQuery + "/, expecting /"
-          + result + "/");
+              + result + "/");
     }
   }
 
   public void assertWildcardQueryEquals(String query, boolean lowercase,
-      String result, boolean allowLeadingWildcard) throws Exception {
+                                        String result, boolean allowLeadingWildcard) throws Exception {
     StandardQueryParser qp = getParser(null);
     qp.setLowercaseExpandedTerms(lowercase);
     qp.setAllowLeadingWildcard(allowLeadingWildcard);
@@ -271,23 +245,23 @@
     String s = q.toString("field");
     if (!s.equals(result)) {
       fail("WildcardQuery /" + query + "/ yielded /" + s + "/, expecting /"
-          + result + "/");
+              + result + "/");
     }
   }
 
   public void assertWildcardQueryEquals(String query, boolean lowercase,
-      String result) throws Exception {
+                                        String result) throws Exception {
     assertWildcardQueryEquals(query, lowercase, result, false);
   }
 
   public void assertWildcardQueryEquals(String query, String result)
-      throws Exception {
+          throws Exception {
     StandardQueryParser qp = getParser(null);
     Query q = qp.parse(query, "field");
     String s = q.toString("field");
     if (!s.equals(result)) {
       fail("WildcardQuery /" + query + "/ yielded /" + s + "/, expecting /"
-          + result + "/");
+              + result + "/");
     }
   }
 
@@ -303,15 +277,16 @@
   }
 
   public void assertQueryEqualsDOA(String query, Analyzer a, String result)
-      throws Exception {
+          throws Exception {
     Query q = getQueryDOA(query, a);
     String s = q.toString("field");
     if (!s.equals(result)) {
       fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
-          + "/");
+              + "/");
     }
   }
 
+  @Test
   public void testConstantScoreAutoRewrite() throws Exception {
     StandardQueryParser qp = new StandardQueryParser(new WhitespaceAnalyzer());
     Query q = qp.parse("foo*bar", "field");
@@ -327,19 +302,21 @@
     assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((MultiTermQuery) q).getRewriteMethod());
   }
 
+  @Test
   public void testCJK() throws Exception {
     // Test Ideographic Space - As wide as a CJK character cell (fullwidth)
     // used google to translate the word "term" to japanese -> ??
     assertQueryEquals("term\u3000term\u3000term", null,
-        "term\u0020term\u0020term");
+            "term\u0020term\u0020term");
     assertQueryEqualsAllowLeadingWildcard("??\u3000??\u3000??", null, "??\u0020??\u0020??");
   }
 
+  @Test
   public void testSimple() throws Exception {
     assertQueryEquals("\"term germ\"~2", null, "\"term germ\"~2");
     assertQueryEquals("term term term", null, "term term term");
     assertQueryEquals("t?rm term term", new WhitespaceAnalyzer(),
-        "t?rm term term");
+            "t?rm term term");
     assertQueryEquals("?mlaut", new WhitespaceAnalyzer(), "?mlaut");
 
     assertQueryEquals("\"\"", new KeywordAnalyzer(), "");
@@ -370,9 +347,9 @@
 
     assertQueryEquals("+term -term term", null, "+term -term term");
     assertQueryEquals("foo:term AND field:anotherTerm", null,
-        "+foo:term +anotherterm");
+            "+foo:term +anotherterm");
     assertQueryEquals("term AND \"phrase phrase\"", null,
-        "+term +\"phrase phrase\"");
+            "+term +\"phrase phrase\"");
     assertQueryEquals("\"hello there\"", null, "\"hello there\"");
     assertTrue(getQuery("a AND b", null) instanceof BooleanQuery);
     assertTrue(getQuery("hello", null) instanceof TermQuery);
@@ -387,15 +364,16 @@
     assertQueryEquals("\"term germ\"^2", null, "\"term germ\"^2.0");
 
     assertQueryEquals("(foo OR bar) AND (baz OR boo)", null,
-        "+(foo bar) +(baz boo)");
+            "+(foo bar) +(baz boo)");
     assertQueryEquals("((a OR b) AND NOT c) OR d", null, "(+(a b) -c) d");
     assertQueryEquals("+(apple \"steve jobs\") -(foo bar baz)", null,
-        "+(apple \"steve jobs\") -(foo bar baz)");
+            "+(apple \"steve jobs\") -(foo bar baz)");
     assertQueryEquals("+title:(dog OR cat) -author:\"bob dole\"", null,
-        "+(title:dog title:cat) -author:\"bob dole\"");
+            "+(title:dog title:cat) -author:\"bob dole\"");
 
   }
 
+  @Test
   public void testPunct() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
     assertQueryEquals("a&b", a, "a&b");
@@ -403,6 +381,7 @@
     assertQueryEquals(".NET", a, ".NET");
   }
 
+  @Test
   public void testSlop() throws Exception {
 
     assertQueryEquals("\"term germ\"~2", null, "\"term germ\"~2");
@@ -412,6 +391,7 @@
     assertQueryEquals("\"term germ\"~2^2", null, "\"term germ\"~2^2.0");
   }
 
+  @Test
   public void testNumber() throws Exception {
     // The numbers go away because SimpleAnalzyer ignores them
     assertQueryEquals("3", null, "");
@@ -424,6 +404,7 @@
     assertQueryEquals("term term1 term2", a, "term term1 term2");
   }
 
+  @Test
   public void testWildcard() throws Exception {
     assertQueryEquals("term*", null, "term*");
     assertQueryEquals("term*^2", null, "term*^2.0");
@@ -510,6 +491,7 @@
     assertWildcardQueryEquals("?Term", true, "?term", true);
   }
 
+  @Test
   public void testLeadingWildcardType() throws Exception {
     StandardQueryParser qp = getParser(null);
     qp.setAllowLeadingWildcard(true);
@@ -518,6 +500,7 @@
     assertEquals(WildcardQuery.class, qp.parse("*term*", "field").getClass());
   }
 
+  @Test
   public void testQPA() throws Exception {
     assertQueryEquals("term term^3.0 term", qpAnalyzer, "term term^3.0 term");
     assertQueryEquals("term stop^3.0 term", qpAnalyzer, "term term");
@@ -532,10 +515,10 @@
 
     assertQueryEquals("drop AND stop AND roll", qpAnalyzer, "+drop +roll");
     assertQueryEquals("term phrase term", qpAnalyzer,
-        "term \"phrase1 phrase2\" term");
+            "term \"phrase1 phrase2\" term");
 
     assertQueryEquals("term AND NOT phrase term", qpAnalyzer,
-        "+term -\"phrase1 phrase2\" term");
+            "+term -\"phrase1 phrase2\" term");
 
     assertQueryEquals("stop^3", qpAnalyzer, "");
     assertQueryEquals("stop", qpAnalyzer, "");
@@ -549,14 +532,15 @@
     assertTrue(getQuery("term +stop", qpAnalyzer) instanceof TermQuery);
   }
 
+  @Test
   public void testRange() throws Exception {
     assertQueryEquals("[ a TO z]", null, "[a TO z]");
-    assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((TermRangeQuery)getQuery("[ a TO z]", null)).getRewriteMethod());
+    assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((TermRangeQuery) getQuery("[ a TO z]", null)).getRewriteMethod());
 
     StandardQueryParser qp = new StandardQueryParser();
-    
+
     qp.setMultiTermRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
-    assertEquals(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE,((TermRangeQuery)qp.parse("[ a TO z]", "field")).getRewriteMethod());
+    assertEquals(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE, ((TermRangeQuery) qp.parse("[ a TO z]", "field")).getRewriteMethod());
 
     assertQueryEquals("[ a TO z ]", null, "[a TO z]");
     assertQueryEquals("{ a TO z}", null, "{a TO z}");
@@ -566,17 +550,18 @@
     assertQueryEquals("[ a TO z] AND bar", null, "+[a TO z] +bar");
     assertQueryEquals("( bar blar { a TO z}) ", null, "bar blar {a TO z}");
     assertQueryEquals("gack ( bar blar { a TO z}) ", null,
-        "gack (bar blar {a TO z})");
+            "gack (bar blar {a TO z})");
   }
 
+  @Test
   public void testFarsiRangeCollating() throws Exception {
 
     RAMDirectory ramDir = new RAMDirectory();
     IndexWriter iw = new IndexWriter(ramDir, new WhitespaceAnalyzer(), true,
-        IndexWriter.MaxFieldLength.LIMITED);
+            IndexWriter.MaxFieldLength.LIMITED);
     Document doc = new Document();
     doc.add(new Field("content", "\u0633\u0627\u0628", Field.Store.YES,
-        Field.Index.NOT_ANALYZED));
+            Field.Index.NOT_ANALYZED));
     iw.addDocument(doc);
     iw.close();
     IndexSearcher is = new IndexSearcher(ramDir, true);
@@ -602,7 +587,7 @@
     // Test ConstantScoreRangeQuery
     qp.setMultiTermRewriteMethod(MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE);
     ScoreDoc[] result = is.search(qp.parse("[ \u062F TO \u0698 ]", "content"),
-        null, 1000).scoreDocs;
+            null, 1000).scoreDocs;
     assertEquals("The index Term should not be included.", 0, result.length);
 
     result = is.search(qp.parse("[ \u0633 TO \u0638 ]", "content"), null, 1000).scoreDocs;
@@ -619,29 +604,35 @@
     is.close();
   }
 
-  /** for testing legacy DateField support */
+  /**
+   * for testing legacy DateField support
+   */
   private String getLegacyDate(String s) throws Exception {
     DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
     return DateField.dateToString(df.parse(s));
   }
 
-  /** for testing DateTools support */
+  /**
+   * for testing DateTools support
+   */
   private String getDate(String s, DateTools.Resolution resolution)
-      throws Exception {
+          throws Exception {
     DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
     return getDate(df.parse(s), resolution);
   }
 
-  /** for testing DateTools support */
+  /**
+   * for testing DateTools support
+   */
   private String getDate(Date d, DateTools.Resolution resolution)
-      throws Exception {
+          throws Exception {
     if (resolution == null) {
       return DateField.dateToString(d);
     } else {
       return DateTools.dateToString(d, resolution);
     }
   }
-  
+
   private String escapeDateString(String s) {
     if (s.contains(" ")) {
       return "\"" + s + "\"";
@@ -651,7 +642,7 @@
   }
 
   private String getLocalizedDate(int year, int month, int day,
-      boolean extendLastDate) {
+                                  boolean extendLastDate) {
     DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
     Calendar calendar = new GregorianCalendar();
     calendar.set(year, month, day);
@@ -664,7 +655,10 @@
     return df.format(calendar.getTime());
   }
 
-  /** for testing legacy DateField support */
+  /**
+   * for testing legacy DateField support
+   */
+  @Test
   public void testLegacyDateRange() throws Exception {
     String startDate = getLocalizedDate(2002, 1, 1, false);
     String endDate = getLocalizedDate(2002, 1, 4, false);
@@ -672,12 +666,13 @@
     endDateExpected.set(2002, 1, 4, 23, 59, 59);
     endDateExpected.set(Calendar.MILLISECOND, 999);
     assertQueryEquals("[ " + escapeDateString(startDate) + " TO " + escapeDateString(endDate) + "]", null, "["
-        + getLegacyDate(startDate) + " TO "
-        + DateField.dateToString(endDateExpected.getTime()) + "]");
+            + getLegacyDate(startDate) + " TO "
+            + DateField.dateToString(endDateExpected.getTime()) + "]");
     assertQueryEquals("{  " + escapeDateString(startDate) + "    " + escapeDateString(endDate) + "   }", null, "{"
-        + getLegacyDate(startDate) + " TO " + getLegacyDate(endDate) + "}");
+            + getLegacyDate(startDate) + " TO " + getLegacyDate(endDate) + "}");
   }
 
+  @Test
   public void testDateRange() throws Exception {
     String startDate = getLocalizedDate(2002, 1, 1, false);
     String endDate = getLocalizedDate(2002, 1, 4, false);
@@ -691,17 +686,17 @@
 
     // Don't set any date resolution and verify if DateField is used
     assertDateRangeQueryEquals(qp, defaultField, startDate, endDate,
-        endDateExpected.getTime(), null);
+            endDateExpected.getTime(), null);
 
-    Map<CharSequence, DateTools.Resolution> dateRes =  new HashMap<CharSequence, DateTools.Resolution>();
+    Map<CharSequence, DateTools.Resolution> dateRes = new HashMap<CharSequence, DateTools.Resolution>();
-    
+
     // set a field specific date resolution    
     dateRes.put(monthField, DateTools.Resolution.MONTH);
     qp.setDateResolution(dateRes);
 
     // DateField should still be used for defaultField
     assertDateRangeQueryEquals(qp, defaultField, startDate, endDate,
-        endDateExpected.getTime(), null);
+            endDateExpected.getTime(), null);
 
     // set default date resolution to MILLISECOND
     qp.setDateResolution(DateTools.Resolution.MILLISECOND);
@@ -713,28 +708,29 @@
     // for this field no field specific date resolution has been set,
     // so verify if the default resolution is used
     assertDateRangeQueryEquals(qp, defaultField, startDate, endDate,
-        endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);
+            endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);
 
     // verify if field specific date resolutions are used for these two
     // fields
     assertDateRangeQueryEquals(qp, monthField, startDate, endDate,
-        endDateExpected.getTime(), DateTools.Resolution.MONTH);
+            endDateExpected.getTime(), DateTools.Resolution.MONTH);
 
     assertDateRangeQueryEquals(qp, hourField, startDate, endDate,
-        endDateExpected.getTime(), DateTools.Resolution.HOUR);
+            endDateExpected.getTime(), DateTools.Resolution.HOUR);
   }
 
   public void assertDateRangeQueryEquals(StandardQueryParser qp,
-      String field, String startDate, String endDate, Date endDateInclusive,
-      DateTools.Resolution resolution) throws Exception {
+                                         String field, String startDate, String endDate, Date endDateInclusive,
+                                         DateTools.Resolution resolution) throws Exception {
     assertQueryEquals(qp, field, field + ":[" + escapeDateString(startDate) + " TO " + escapeDateString(endDate)
-        + "]", "[" + getDate(startDate, resolution) + " TO "
-        + getDate(endDateInclusive, resolution) + "]");
+            + "]", "[" + getDate(startDate, resolution) + " TO "
+            + getDate(endDateInclusive, resolution) + "]");
     assertQueryEquals(qp, field, field + ":{" + escapeDateString(startDate) + " TO " + escapeDateString(endDate)
-        + "}", "{" + getDate(startDate, resolution) + " TO "
-        + getDate(endDate, resolution) + "}");
+            + "}", "{" + getDate(startDate, resolution) + " TO "
+            + getDate(endDate, resolution) + "}");
   }
 
+  @Test
   public void testEscaped() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
 
@@ -760,7 +756,7 @@
      */
 
     assertQueryEquals("\\*", a, "*");
-    
+
     assertQueryEquals("\\a", a, "a");
 
     assertQueryEquals("a\\-b:c", a, "a-b:c");
@@ -796,8 +792,8 @@
     assertQueryEquals("[ a\\\\ TO a\\* ]", null, "[a\\ TO a*]");
 
     assertQueryEquals(
-        "[\"c\\:\\\\temp\\\\\\~foo0.txt\" TO \"c\\:\\\\temp\\\\\\~foo9.txt\"]",
-        a, "[c:\\temp\\~foo0.txt TO c:\\temp\\~foo9.txt]");
+            "[\"c\\:\\\\temp\\\\\\~foo0.txt\" TO \"c\\:\\\\temp\\\\\\~foo9.txt\"]",
+            a, "[c:\\temp\\~foo0.txt TO c:\\temp\\~foo9.txt]");
 
     assertQueryEquals("a\\\\\\+b", a, "a\\+b");
 
@@ -834,6 +830,7 @@
     assertQueryEquals("(\"a\\\\\") or (\"b\")", a, "a\\ or b");
   }
 
+  @Test
   public void testQueryStringEscaping() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
 
@@ -873,6 +870,7 @@
     assertEscapedQueryEquals("&& abc &&", a, "\\&\\& abc \\&\\&");
   }
 
+  @Test
   public void testTabNewlineCarriageReturn() throws Exception {
     assertQueryEqualsDOA("+weltbank +worlbank", null, "+weltbank +worlbank");
 
@@ -888,13 +886,14 @@
     assertQueryEqualsDOA("weltbank \r\n+worlbank", null, "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \r\n +worlbank", null, "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \r \n +worlbank", null,
-        "+weltbank +worlbank");
+            "+weltbank +worlbank");
 
     assertQueryEqualsDOA("+weltbank\t+worlbank", null, "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \t+worlbank", null, "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \t +worlbank", null, "+weltbank +worlbank");
   }
 
+  @Test
   public void testSimpleDAO() throws Exception {
     assertQueryEqualsDOA("term term term", null, "+term +term +term");
     assertQueryEqualsDOA("term +term term", null, "+term +term +term");
@@ -903,6 +902,7 @@
     assertQueryEqualsDOA("-term term term", null, "-term +term +term");
   }
 
+  @Test
   public void testBoost() throws Exception {
     StandardAnalyzer oneStopAnalyzer = new StandardAnalyzer(Version.LUCENE_CURRENT, Collections.singleton("on"));
     StandardQueryParser qp = new StandardQueryParser();
@@ -938,6 +938,7 @@
     fail("ParseException expected, not thrown");
   }
 
+  @Test
   public void testException() throws Exception {
     assertQueryNodeException("*leadingWildcard"); // disallowed by default
     assertQueryNodeException("\"some phrase");
@@ -945,9 +946,10 @@
     assertQueryNodeException("foo bar))");
     assertQueryNodeException("field:term:with:colon some more terms");
     assertQueryNodeException("(sub query)^5.0^2.0 plus more");
-    assertQueryNodeException("secret AND illegal) AND access:confidential");    
+    assertQueryNodeException("secret AND illegal) AND access:confidential");
   }
 
+  @Test
   public void testCustomQueryParserWildcard() {
     try {
       new QPTestParser(new WhitespaceAnalyzer()).parse("a?t", "contents");
@@ -957,31 +959,24 @@
     }
   }
 
+  @Test(expected = QueryNodeException.class)
   public void testCustomQueryParserFuzzy() throws Exception {
-    try {
-      new QPTestParser(new WhitespaceAnalyzer()).parse("xunit~", "contents");
+    new QPTestParser(new WhitespaceAnalyzer()).parse("xunit~", "contents");
-      fail("Fuzzy queries should not be allowed");
-    } catch (QueryNodeException expected) {
-      // expected exception
-    }
+  }
-  }
 
+  @Test(expected = QueryNodeException.class)
   public void testBooleanQuery() throws Exception {
     BooleanQuery.setMaxClauseCount(2);
-    try {
-      StandardQueryParser qp = new StandardQueryParser();
-      qp.setAnalyzer(new WhitespaceAnalyzer());
+    StandardQueryParser qp = new StandardQueryParser();
+    qp.setAnalyzer(new WhitespaceAnalyzer());
 
-      qp.parse("one two three", "field");
+    qp.parse("one two three", "field");
-      fail("ParseException expected due to too many boolean clauses");
-    } catch (QueryNodeException expected) {
-      // too many boolean clauses, so ParseException is expected
-    }
+  }
-  }
 
   /**
    * This test differs from TestPrecedenceQueryParser
    */
+  @Test
   public void testPrecedence() throws Exception {
     StandardQueryParser qp = new StandardQueryParser();
     qp.setAnalyzer(new WhitespaceAnalyzer());
@@ -992,11 +987,12 @@
     assertEquals(query1, query2);
   }
 
+  @Test
   public void testLocalDateFormat() throws IOException, QueryNodeException {
 
     RAMDirectory ramDir = new RAMDirectory();
     IndexWriter iw = new IndexWriter(ramDir, new WhitespaceAnalyzer(), true,
-        IndexWriter.MaxFieldLength.LIMITED);
+            IndexWriter.MaxFieldLength.LIMITED);
     addDateDoc("a", 2005, 12, 2, 10, 15, 33, iw);
     addDateDoc("b", 2005, 12, 4, 22, 15, 00, iw);
     iw.close();
@@ -1010,6 +1006,7 @@
     is.close();
   }
 
+  @Test
   public void testStarParsing() throws Exception {
     // final int[] type = new int[1];
     // StandardQueryParser qp = new StandardQueryParser("field", new
@@ -1073,39 +1070,41 @@
 
   }
 
+  @Test
   public void testStopwords() throws Exception {
     StandardQueryParser qp = new StandardQueryParser();
     qp.setAnalyzer(
-        new StopAnalyzer(Version.LUCENE_CURRENT, StopFilter.makeStopSet(Version.LUCENE_CURRENT, "the", "foo" )));
+            new StopAnalyzer(Version.LUCENE_CURRENT, StopFilter.makeStopSet(Version.LUCENE_CURRENT, "the", "foo")));
 
     Query result = qp.parse("a:the OR a:foo", "a");
     assertNotNull("result is null and it shouldn't be", result);
     assertTrue("result is not a BooleanQuery", result instanceof BooleanQuery);
     assertTrue(((BooleanQuery) result).clauses().size() + " does not equal: "
-        + 0, ((BooleanQuery) result).clauses().size() == 0);
+            + 0, ((BooleanQuery) result).clauses().size() == 0);
     result = qp.parse("a:woo OR a:the", "a");
     assertNotNull("result is null and it shouldn't be", result);
     assertTrue("result is not a TermQuery", result instanceof TermQuery);
     result = qp.parse(
-        "(fieldX:xxxxx OR fieldy:xxxxxxxx)^2 AND (fieldx:the OR fieldy:foo)",
-        "a");
+            "(fieldX:xxxxx OR fieldy:xxxxxxxx)^2 AND (fieldx:the OR fieldy:foo)",
+            "a");
     assertNotNull("result is null and it shouldn't be", result);
     assertTrue("result is not a BooleanQuery", result instanceof BooleanQuery);
-    System.out.println("Result: " + result);
+    //System.out.println("Result: " + result);
     assertTrue(((BooleanQuery) result).clauses().size() + " does not equal: "
-        + 2, ((BooleanQuery) result).clauses().size() == 2);
+            + 2, ((BooleanQuery) result).clauses().size() == 2);
   }
 
+  @Test
   public void testPositionIncrement() throws Exception {
     StandardQueryParser qp = new StandardQueryParser();
     qp.setAnalyzer(
-        new StopAnalyzer(Version.LUCENE_CURRENT, StopFilter.makeStopSet(Version.LUCENE_CURRENT, "the", "in", "are", "this" )));
+            new StopAnalyzer(Version.LUCENE_CURRENT, StopFilter.makeStopSet(Version.LUCENE_CURRENT, "the", "in", "are", "this")));
 
     qp.setEnablePositionIncrements(true);
 
     String qtxt = "\"the words in poisitions pos02578 are stopped in this phrasequery\"";
     // 0 2 5 7 8
-    int expectedPositions[] = { 1, 3, 4, 6, 9 };
+    int expectedPositions[] = {1, 3, 4, 6, 9};
     PhraseQuery pq = (PhraseQuery) qp.parse(qtxt, "a");
     // System.out.println("Query text: "+qtxt);
     // System.out.println("Result: "+pq);
@@ -1114,10 +1113,11 @@
     for (int i = 0; i < t.length; i++) {
       // System.out.println(i+". "+t[i]+"  pos: "+pos[i]);
       assertEquals("term " + i + " = " + t[i] + " has wrong term-position!",
-          expectedPositions[i], pos[i]);
+              expectedPositions[i], pos[i]);
     }
   }
 
+  @Test
   public void testMatchAllDocs() throws Exception {
     StandardQueryParser qp = new StandardQueryParser();
     qp.setAnalyzer(new WhitespaceAnalyzer());
@@ -1130,7 +1130,7 @@
   }
 
   private void assertHits(int expected, String query, IndexSearcher is)
-      throws IOException, QueryNodeException {
+          throws IOException, QueryNodeException {
     StandardQueryParser qp = new StandardQueryParser();
     qp.setAnalyzer(new WhitespaceAnalyzer());
     qp.setLocale(Locale.ENGLISH);
@@ -1141,17 +1141,18 @@
   }
 
   private static void addDateDoc(String content, int year, int month, int day,
-      int hour, int minute, int second, IndexWriter iw) throws IOException {
+                                 int hour, int minute, int second, IndexWriter iw) throws IOException {
     Document d = new Document();
     d.add(new Field("f", content, Field.Store.YES, Field.Index.ANALYZED));
     Calendar cal = Calendar.getInstance(Locale.ENGLISH);
     cal.set(year, month - 1, day, hour, minute, second);
     d.add(new Field("date", DateField.dateToString(cal.getTime()),
-        Field.Store.YES, Field.Index.NOT_ANALYZED));
+            Field.Store.YES, Field.Index.NOT_ANALYZED));
     iw.addDocument(d);
   }
 
   @Override
+  @After
   public void tearDown() throws Exception {
     super.tearDown();
     BooleanQuery.setMaxClauseCount(originalMaxClauses);
@@ -1161,6 +1162,7 @@
     private int upto = 0;
     final PositionIncrementAttribute posIncr = addAttribute(PositionIncrementAttribute.class);
     final TermAttribute term = addAttribute(TermAttribute.class);
+
     @Override
     public boolean incrementToken() {
       if (upto == 4) {
@@ -1191,6 +1193,7 @@
     }
   }
 
+  @Test
   public void testMultiPhraseQuery() throws Exception {
     MockRAMDirectory dir = new MockRAMDirectory();
     IndexWriter w = new IndexWriter(dir, new CannedAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);
@@ -1199,7 +1202,7 @@
     w.addDocument(doc);
     IndexReader r = w.getReader();
     IndexSearcher s = new IndexSearcher(r);
-    
+
     Query q = new StandardQueryParser(new CannedAnalyzer()).parse("\"a\"", "field");
     assertTrue(q instanceof MultiPhraseQuery);
     assertEquals(1, s.search(q, 10).totalHits);
Index: src/test/org/apache/lucene/queryParser/TestQueryParser.java
===================================================================
--- src/test/org/apache/lucene/queryParser/TestQueryParser.java	(revision 887181)
+++ src/test/org/apache/lucene/queryParser/TestQueryParser.java	Wed Dec 09 18:54:09 EST 2009
@@ -17,27 +17,7 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.io.Reader;
-import java.text.Collator;
-import java.text.DateFormat;
-import java.util.Arrays;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.HashSet;
-import java.util.Locale;
-import java.util.Set;
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.KeywordAnalyzer;
-import org.apache.lucene.analysis.LowerCaseTokenizer;
-import org.apache.lucene.analysis.SimpleAnalyzer;
-import org.apache.lucene.analysis.StopAnalyzer;
-import org.apache.lucene.analysis.StopFilter;
-import org.apache.lucene.analysis.TokenFilter;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.WhitespaceAnalyzer;
+import org.apache.lucene.analysis.*;
 import org.apache.lucene.analysis.standard.StandardAnalyzer;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.TermAttribute;
@@ -45,46 +25,43 @@
 import org.apache.lucene.document.DateTools;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.FuzzyQuery;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.PhraseQuery;
-import org.apache.lucene.search.PrefixQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermRangeQuery;
-import org.apache.lucene.search.ScoreDoc;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.search.*;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.MockRAMDirectory;
+import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.LocalizedTestCase;
 import org.apache.lucene.util.Version;
+import org.junit.After;
+import static org.junit.Assert.*;
+import org.junit.Before;
+import org.junit.Test;
 
+import java.io.IOException;
+import java.io.Reader;
+import java.text.Collator;
+import java.text.DateFormat;
+import java.util.*;
+
 /**
  * Tests QueryParser.
  */
+@SuppressWarnings({"MagicNumber"})
 public class TestQueryParser extends LocalizedTestCase {
 
-  public TestQueryParser(String name) {
-    super(name, new HashSet<String>(Arrays.asList(
-      "testLegacyDateRange", "testDateRange",
-      "testCJK", "testNumber", "testFarsiRangeCollating",
-      "testLocalDateFormat"
-    )));
-  }
-  
+
   public static Analyzer qpAnalyzer = new QPTestAnalyzer();
 
+  public TestQueryParser(Locale locale) {
+    super(locale);
+  }
+
   public static class QPTestFilter extends TokenFilter {
     TermAttribute termAtt;
     OffsetAttribute offsetAtt;
-        
+
     /**
      * Filter which discards the token 'stop' and which expands the
      * token 'phrase' into 'phrase1 phrase2'
@@ -121,10 +98,12 @@
     }
   }
 
-  
+
   public static class QPTestAnalyzer extends Analyzer {
 
-    /** Filters LowerCaseTokenizer with StopFilter. */
+    /**
+     * Filters LowerCaseTokenizer with StopFilter.
+     */
     @Override
     public final TokenStream tokenStream(String fieldName, Reader reader) {
       return new QPTestFilter(new LowerCaseTokenizer(reader));
@@ -147,9 +126,10 @@
     }
   }
 
-  private int originalMaxClauses;
+  private int originalMaxClauses = 1024;
 
   @Override
+  @Before
   public void setUp() throws Exception {
     super.setUp();
     originalMaxClauses = BooleanQuery.getMaxClauseCount();
@@ -168,36 +148,36 @@
   }
 
   public void assertQueryEquals(String query, Analyzer a, String result)
-    throws Exception {
+          throws Exception {
     Query q = getQuery(query, a);
     String s = q.toString("field");
     if (!s.equals(result)) {
       fail("Query /" + query + "/ yielded /" + s
-           + "/, expecting /" + result + "/");
+              + "/, expecting /" + result + "/");
     }
   }
 
-  public void assertQueryEquals(QueryParser qp, String field, String query, String result) 
-    throws Exception {
+  public void assertQueryEquals(QueryParser qp, String field, String query, String result)
+          throws Exception {
     Query q = qp.parse(query);
     String s = q.toString(field);
     if (!s.equals(result)) {
       fail("Query /" + query + "/ yielded /" + s
-           + "/, expecting /" + result + "/");
+              + "/, expecting /" + result + "/");
     }
   }
-  
+
   public void assertEscapedQueryEquals(String query, Analyzer a, String result)
-    throws Exception {
+          throws Exception {
     String escapedQuery = QueryParser.escape(query);
     if (!escapedQuery.equals(result)) {
       fail("Query /" + query + "/ yielded /" + escapedQuery
-          + "/, expecting /" + result + "/");
+              + "/, expecting /" + result + "/");
     }
   }
 
   public void assertWildcardQueryEquals(String query, boolean lowercase, String result, boolean allowLeadingWildcard)
-    throws Exception {
+          throws Exception {
     QueryParser qp = getParser(null);
     qp.setLowercaseExpandedTerms(lowercase);
     qp.setAllowLeadingWildcard(allowLeadingWildcard);
@@ -205,12 +185,12 @@
     String s = q.toString("field");
     if (!s.equals(result)) {
       fail("WildcardQuery /" + query + "/ yielded /" + s
-           + "/, expecting /" + result + "/");
+              + "/, expecting /" + result + "/");
     }
   }
 
   public void assertWildcardQueryEquals(String query, boolean lowercase, String result)
-    throws Exception {
+          throws Exception {
     assertWildcardQueryEquals(query, lowercase, result, false);
   }
 
@@ -220,12 +200,12 @@
     String s = q.toString("field");
     if (!s.equals(result)) {
       fail("WildcardQuery /" + query + "/ yielded /" + s + "/, expecting /"
-          + result + "/");
+              + result + "/");
     }
   }
 
   public Query getQueryDOA(String query, Analyzer a)
-    throws Exception {
+          throws Exception {
     if (a == null)
       a = new SimpleAnalyzer();
     QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, "field", a);
@@ -234,22 +214,24 @@
   }
 
   public void assertQueryEqualsDOA(String query, Analyzer a, String result)
-    throws Exception {
+          throws Exception {
     Query q = getQueryDOA(query, a);
     String s = q.toString("field");
     if (!s.equals(result)) {
       fail("Query /" + query + "/ yielded /" + s
-           + "/, expecting /" + result + "/");
+              + "/, expecting /" + result + "/");
     }
   }
 
+  @Test
   public void testCJK() throws Exception {
-	 // Test Ideographic Space - As wide as a CJK character cell (fullwidth)
-	 // used google to translate the word "term" to japanese -> ??
-	 assertQueryEquals("term\u3000term\u3000term", null, "term\u0020term\u0020term");
-	 assertQueryEquals("??\u3000??\u3000??", null, "??\u0020??\u0020??");
+    // Test Ideographic Space - As wide as a CJK character cell (fullwidth)
+    // used google to translate the word "term" to japanese -> ??
+    assertQueryEquals("term\u3000term\u3000term", null, "term\u0020term\u0020term");
+    assertQueryEquals("??\u3000??\u3000??", null, "??\u0020??\u0020??");
   }
-  
+
+  @Test
   public void testSimple() throws Exception {
     assertQueryEquals("term term term", null, "term term term");
     assertQueryEquals("trm term term", new WhitespaceAnalyzer(), "trm term term");
@@ -275,9 +257,9 @@
 
     assertQueryEquals("+term -term term", null, "+term -term term");
     assertQueryEquals("foo:term AND field:anotherTerm", null,
-                      "+foo:term +anotherterm");
+            "+foo:term +anotherterm");
     assertQueryEquals("term AND \"phrase phrase\"", null,
-                      "+term +\"phrase phrase\"");
+            "+term +\"phrase phrase\"");
     assertQueryEquals("\"hello there\"", null, "\"hello there\"");
     assertTrue(getQuery("a AND b", null) instanceof BooleanQuery);
     assertTrue(getQuery("hello", null) instanceof TermQuery);
@@ -292,14 +274,14 @@
     assertQueryEquals("\"term germ\"^2", null, "\"term germ\"^2.0");
 
     assertQueryEquals("(foo OR bar) AND (baz OR boo)", null,
-                      "+(foo bar) +(baz boo)");
+            "+(foo bar) +(baz boo)");
     assertQueryEquals("((a OR b) AND NOT c) OR d", null,
-                      "(+(a b) -c) d");
+            "(+(a b) -c) d");
     assertQueryEquals("+(apple \"steve jobs\") -(foo bar baz)", null,
-                      "+(apple \"steve jobs\") -(foo bar baz)");
+            "+(apple \"steve jobs\") -(foo bar baz)");
     assertQueryEquals("+title:(dog OR cat) -author:\"bob dole\"", null,
-                      "+(title:dog title:cat) -author:\"bob dole\"");
-    
+            "+(title:dog title:cat) -author:\"bob dole\"");
+
     QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, "field", new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT));
     // make sure OR is the default:
     assertEquals(QueryParser.OR_OPERATOR, qp.getDefaultOperator());
@@ -309,6 +291,7 @@
     assertEquals(QueryParser.OR_OPERATOR, qp.getDefaultOperator());
   }
 
+  @Test
   public void testPunct() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
     assertQueryEquals("a&b", a, "a&b");
@@ -316,6 +299,7 @@
     assertQueryEquals(".NET", a, ".NET");
   }
 
+  @Test
   public void testSlop() throws Exception {
     assertQueryEquals("\"term germ\"~2", null, "\"term germ\"~2");
     assertQueryEquals("\"term germ\"~2 flork", null, "\"term germ\"~2 flork");
@@ -324,6 +308,7 @@
     assertQueryEquals("\"term germ\"~2^2", null, "\"term germ\"~2^2.0");
   }
 
+  @Test
   public void testNumber() throws Exception {
 // The numbers go away because SimpleAnalzyer ignores them
     assertQueryEquals("3", null, "");
@@ -336,6 +321,7 @@
     assertQueryEquals("term term1 term2", a, "term term1 term2");
   }
 
+  @Test
   public void testWildcard() throws Exception {
     assertQueryEquals("term*", null, "term*");
     assertQueryEquals("term*^2", null, "term*^2.0");
@@ -350,13 +336,13 @@
     assertTrue(getQuery("term*^2", null) instanceof PrefixQuery);
     assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
     assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
-    FuzzyQuery fq = (FuzzyQuery)getQuery("term~0.7", null);
+    FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
     assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
     assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-    fq = (FuzzyQuery)getQuery("term~", null);
+    fq = (FuzzyQuery) getQuery("term~", null);
     assertEquals(0.5f, fq.getMinSimilarity(), 0.1f);
     assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-    
+
     assertParseException("term~1.1"); // value > 1, throws exception
 
     assertTrue(getQuery("term*germ", null) instanceof WildcardQuery);
@@ -400,20 +386,21 @@
     try {
       assertWildcardQueryEquals("*Term", true, "*term");
       fail();
-    } catch(ParseException pe) {
+    } catch (ParseException pe) {
       // expected exception
     }
     try {
       assertWildcardQueryEquals("?Term", true, "?term");
       fail();
-    } catch(ParseException pe) {
+    } catch (ParseException pe) {
       // expected exception
     }
     // Test suffix queries: then allow
     assertWildcardQueryEquals("*Term", true, "*term", true);
     assertWildcardQueryEquals("?Term", true, "?term", true);
   }
-  
+
+  @Test
   public void testLeadingWildcardType() throws Exception {
     QueryParser qp = getParser(null);
     qp.setAllowLeadingWildcard(true);
@@ -422,10 +409,11 @@
     assertEquals(WildcardQuery.class, qp.parse("*term*").getClass());
   }
 
+  @Test
   public void testQPA() throws Exception {
     assertQueryEquals("term term^3.0 term", qpAnalyzer, "term term^3.0 term");
     assertQueryEquals("term stop^3.0 term", qpAnalyzer, "term term");
-    
+
     assertQueryEquals("term term term", qpAnalyzer, "term term term");
     assertQueryEquals("term +stop term", qpAnalyzer, "term term");
     assertQueryEquals("term -stop term", qpAnalyzer, "term term");
@@ -433,12 +421,12 @@
     assertQueryEquals("drop AND (stop) AND roll", qpAnalyzer, "+drop +roll");
     assertQueryEquals("term +(stop) term", qpAnalyzer, "term term");
     assertQueryEquals("term -(stop) term", qpAnalyzer, "term term");
-    
+
     assertQueryEquals("drop AND stop AND roll", qpAnalyzer, "+drop +roll");
     assertQueryEquals("term phrase term", qpAnalyzer,
-                      "term \"phrase1 phrase2\" term");
+            "term \"phrase1 phrase2\" term");
     assertQueryEquals("term AND NOT phrase term", qpAnalyzer,
-                      "+term -\"phrase1 phrase2\" term");
+            "+term -\"phrase1 phrase2\" term");
     assertQueryEquals("stop^3", qpAnalyzer, "");
     assertQueryEquals("stop", qpAnalyzer, "");
     assertQueryEquals("(stop)^3", qpAnalyzer, "");
@@ -451,14 +439,15 @@
     assertTrue(getQuery("term +stop", qpAnalyzer) instanceof TermQuery);
   }
 
+  @Test
   public void testRange() throws Exception {
     assertQueryEquals("[ a TO z]", null, "[a TO z]");
-    assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((TermRangeQuery)getQuery("[ a TO z]", null)).getRewriteMethod());
+    assertEquals(MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT, ((TermRangeQuery) getQuery("[ a TO z]", null)).getRewriteMethod());
 
     QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, "field", new SimpleAnalyzer());
     qp.setMultiTermRewriteMethod(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE);
-    assertEquals(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE,((TermRangeQuery)qp.parse("[ a TO z]")).getRewriteMethod());
+    assertEquals(MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE, ((TermRangeQuery) qp.parse("[ a TO z]")).getRewriteMethod());
-    
+
     assertQueryEquals("[ a TO z ]", null, "[a TO z]");
     assertQueryEquals("{ a TO z}", null, "{a TO z}");
     assertQueryEquals("{ a TO z }", null, "{a TO z}");
@@ -468,15 +457,16 @@
     assertQueryEquals("( bar blar { a TO z}) ", null, "bar blar {a TO z}");
     assertQueryEquals("gack ( bar blar { a TO z}) ", null, "gack (bar blar {a TO z})");
   }
-    
+
+  @Test
   public void testFarsiRangeCollating() throws Exception {
-    
+
     RAMDirectory ramDir = new RAMDirectory();
-    IndexWriter iw = new IndexWriter(ramDir, new WhitespaceAnalyzer(), true, 
-                                     IndexWriter.MaxFieldLength.LIMITED);
+    IndexWriter iw = new IndexWriter(ramDir, new WhitespaceAnalyzer(), true,
+            IndexWriter.MaxFieldLength.LIMITED);
     Document doc = new Document();
-    doc.add(new Field("content","\u0633\u0627\u0628", 
+    doc.add(new Field("content", "\u0633\u0627\u0628",
-                      Field.Store.YES, Field.Index.NOT_ANALYZED));
+            Field.Store.YES, Field.Index.NOT_ANALYZED));
     iw.addDocument(doc);
     iw.close();
     IndexSearcher is = new IndexSearcher(ramDir, true);
@@ -494,7 +484,7 @@
     // index Term below should NOT be returned by a ConstantScoreRangeQuery
     // with a Farsi Collator (or an Arabic one for the case when Farsi is not
     // supported).
-      
+
     // Test ConstantScoreRangeQuery
     qp.setMultiTermRewriteMethod(MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE);
     ScoreDoc[] result = is.search(qp.parse("[ \u062F TO \u0698 ]"), null, 1000).scoreDocs;
@@ -513,7 +503,7 @@
 
     is.close();
   }
-  
+
   private String escapeDateString(String s) {
     if (s.indexOf(" ") > -1) {
       return "\"" + s + "\"";
@@ -521,28 +511,34 @@
       return s;
     }
   }
-  
+
-  /** for testing legacy DateField support */
+  /**
+   * for testing legacy DateField support
+   */
   private String getLegacyDate(String s) throws Exception {
     DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
     return DateField.dateToString(df.parse(s));
   }
 
-  /** for testing DateTools support */
+  /**
+   * for testing DateTools support
+   */
   private String getDate(String s, DateTools.Resolution resolution) throws Exception {
     DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
-    return getDate(df.parse(s), resolution);      
+    return getDate(df.parse(s), resolution);
   }
-  
+
-  /** for testing DateTools support */
+  /**
+   * for testing DateTools support
+   */
   private String getDate(Date d, DateTools.Resolution resolution) throws Exception {
-      if (resolution == null) {
-        return DateField.dateToString(d);      
-      } else {
-        return DateTools.dateToString(d, resolution);
-      }
-    }
-  
+    if (resolution == null) {
+      return DateField.dateToString(d);
+    } else {
+      return DateTools.dateToString(d, resolution);
+    }
+  }
+
   private String getLocalizedDate(int year, int month, int day, boolean extendLastDate) {
     DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
     Calendar calendar = new GregorianCalendar();
@@ -556,6 +552,7 @@
     return df.format(calendar.getTime());
   }
 
+  @Test
   /** for testing legacy DateField support */
   public void testLegacyDateRange() throws Exception {
     String startDate = getLocalizedDate(2002, 1, 1, false);
@@ -564,11 +561,12 @@
     endDateExpected.set(2002, 1, 4, 23, 59, 59);
     endDateExpected.set(Calendar.MILLISECOND, 999);
     assertQueryEquals("[ " + escapeDateString(startDate) + " TO " + escapeDateString(endDate) + "]", null,
-                      "[" + getLegacyDate(startDate) + " TO " + DateField.dateToString(endDateExpected.getTime()) + "]");
+            "[" + getLegacyDate(startDate) + " TO " + DateField.dateToString(endDateExpected.getTime()) + "]");
     assertQueryEquals("{  " + escapeDateString(startDate) + "    " + escapeDateString(endDate) + "   }", null,
-                      "{" + getLegacyDate(startDate) + " TO " + getLegacyDate(endDate) + "}");
+            "{" + getLegacyDate(startDate) + " TO " + getLegacyDate(endDate) + "}");
   }
-  
+
+  @Test
   public void testDateRange() throws Exception {
     String startDate = getLocalizedDate(2002, 1, 1, false);
     String endDate = getLocalizedDate(2002, 1, 4, false);
@@ -579,74 +577,75 @@
     final String monthField = "month";
     final String hourField = "hour";
     QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, "field", new SimpleAnalyzer());
-    
+
     // Don't set any date resolution and verify if DateField is used
-    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, 
-                               endDateExpected.getTime(), null);
-    
+    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate,
+            endDateExpected.getTime(), null);
+
     // set a field specific date resolution
     qp.setDateResolution(monthField, DateTools.Resolution.MONTH);
-    
+
     // DateField should still be used for defaultField
-    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, 
-                               endDateExpected.getTime(), null);
-    
+    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate,
+            endDateExpected.getTime(), null);
+
     // set default date resolution to MILLISECOND 
     qp.setDateResolution(DateTools.Resolution.MILLISECOND);
-    
+
     // set second field specific date resolution    
     qp.setDateResolution(hourField, DateTools.Resolution.HOUR);
 
     // for this field no field specific date resolution has been set,
     // so verify if the default resolution is used
-    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate, 
+    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate,
             endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);
 
     // verify if field specific date resolutions are used for these two fields
-    assertDateRangeQueryEquals(qp, monthField, startDate, endDate, 
+    assertDateRangeQueryEquals(qp, monthField, startDate, endDate,
             endDateExpected.getTime(), DateTools.Resolution.MONTH);
 
-    assertDateRangeQueryEquals(qp, hourField, startDate, endDate, 
-            endDateExpected.getTime(), DateTools.Resolution.HOUR);  
+    assertDateRangeQueryEquals(qp, hourField, startDate, endDate,
+            endDateExpected.getTime(), DateTools.Resolution.HOUR);
   }
-  
-  public void assertDateRangeQueryEquals(QueryParser qp, String field, String startDate, String endDate, 
+
+  public void assertDateRangeQueryEquals(QueryParser qp, String field, String startDate, String endDate,
                                          Date endDateInclusive, DateTools.Resolution resolution) throws Exception {
     assertQueryEquals(qp, field, field + ":[" + escapeDateString(startDate) + " TO " + escapeDateString(endDate) + "]",
-               "[" + getDate(startDate, resolution) + " TO " + getDate(endDateInclusive, resolution) + "]");
+            "[" + getDate(startDate, resolution) + " TO " + getDate(endDateInclusive, resolution) + "]");
     assertQueryEquals(qp, field, field + ":{" + escapeDateString(startDate) + " TO " + escapeDateString(endDate) + "}",
-               "{" + getDate(startDate, resolution) + " TO " + getDate(endDate, resolution) + "}");
+            "{" + getDate(startDate, resolution) + " TO " + getDate(endDate, resolution) + "}");
   }
 
+  @Test
   public void testEscaped() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
-    
+
     /*assertQueryEquals("\\[brackets", a, "\\[brackets");
-    assertQueryEquals("\\[brackets", null, "brackets");
-    assertQueryEquals("\\\\", a, "\\\\");
-    assertQueryEquals("\\+blah", a, "\\+blah");
-    assertQueryEquals("\\(blah", a, "\\(blah");
+assertQueryEquals("\\[brackets", null, "brackets");
+assertQueryEquals("\\\\", a, "\\\\");
+assertQueryEquals("\\+blah", a, "\\+blah");
+assertQueryEquals("\\(blah", a, "\\(blah");
 
-    assertQueryEquals("\\-blah", a, "\\-blah");
-    assertQueryEquals("\\!blah", a, "\\!blah");
-    assertQueryEquals("\\{blah", a, "\\{blah");
-    assertQueryEquals("\\}blah", a, "\\}blah");
-    assertQueryEquals("\\:blah", a, "\\:blah");
-    assertQueryEquals("\\^blah", a, "\\^blah");
-    assertQueryEquals("\\[blah", a, "\\[blah");
-    assertQueryEquals("\\]blah", a, "\\]blah");
-    assertQueryEquals("\\\"blah", a, "\\\"blah");
-    assertQueryEquals("\\(blah", a, "\\(blah");
-    assertQueryEquals("\\)blah", a, "\\)blah");
-    assertQueryEquals("\\~blah", a, "\\~blah");
-    assertQueryEquals("\\*blah", a, "\\*blah");
-    assertQueryEquals("\\?blah", a, "\\?blah");
-    //assertQueryEquals("foo \\&\\& bar", a, "foo \\&\\& bar");
-    //assertQueryEquals("foo \\|| bar", a, "foo \\|| bar");
-    //assertQueryEquals("foo \\AND bar", a, "foo \\AND bar");*/
+assertQueryEquals("\\-blah", a, "\\-blah");
+assertQueryEquals("\\!blah", a, "\\!blah");
+assertQueryEquals("\\{blah", a, "\\{blah");
+assertQueryEquals("\\}blah", a, "\\}blah");
+assertQueryEquals("\\:blah", a, "\\:blah");
+assertQueryEquals("\\^blah", a, "\\^blah");
+assertQueryEquals("\\[blah", a, "\\[blah");
+assertQueryEquals("\\]blah", a, "\\]blah");
+assertQueryEquals("\\\"blah", a, "\\\"blah");
+assertQueryEquals("\\(blah", a, "\\(blah");
+assertQueryEquals("\\)blah", a, "\\)blah");
+assertQueryEquals("\\~blah", a, "\\~blah");
+assertQueryEquals("\\*blah", a, "\\*blah");
+assertQueryEquals("\\?blah", a, "\\?blah");
+//assertQueryEquals("foo \\&\\& bar", a, "foo \\&\\& bar");
+//assertQueryEquals("foo \\|| bar", a, "foo \\|| bar");
+//assertQueryEquals("foo \\AND bar", a, "foo \\AND bar");*/
 
     assertQueryEquals("\\a", a, "a");
-    
+
     assertQueryEquals("a\\-b:c", a, "a-b:c");
     assertQueryEquals("a\\+b:c", a, "a+b:c");
     assertQueryEquals("a\\:b:c", a, "a:b:c");
@@ -678,40 +677,41 @@
     assertQueryEquals("[ a\\: TO a\\~ ]", null, "[a: TO a~]");
     assertQueryEquals("[ a\\\\ TO a\\* ]", null, "[a\\ TO a*]");
 
-    assertQueryEquals("[\"c\\:\\\\temp\\\\\\~foo0.txt\" TO \"c\\:\\\\temp\\\\\\~foo9.txt\"]", a, 
-                      "[c:\\temp\\~foo0.txt TO c:\\temp\\~foo9.txt]");
-    
+    assertQueryEquals("[\"c\\:\\\\temp\\\\\\~foo0.txt\" TO \"c\\:\\\\temp\\\\\\~foo9.txt\"]", a,
+            "[c:\\temp\\~foo0.txt TO c:\\temp\\~foo9.txt]");
+
     assertQueryEquals("a\\\\\\+b", a, "a\\+b");
-    
+
     assertQueryEquals("a \\\"b c\\\" d", a, "a \"b c\" d");
     assertQueryEquals("\"a \\\"b c\\\" d\"", a, "\"a \"b c\" d\"");
     assertQueryEquals("\"a \\+b c d\"", a, "\"a +b c d\"");
-    
+
     assertQueryEquals("c\\:\\\\temp\\\\\\~foo.txt", a, "c:\\temp\\~foo.txt");
-    
+
     assertParseException("XY\\"); // there must be a character after the escape char
-    
+
     // test unicode escaping
     assertQueryEquals("a\\u0062c", a, "abc");
     assertQueryEquals("XY\\u005a", a, "XYZ");
     assertQueryEquals("XY\\u005A", a, "XYZ");
     assertQueryEquals("\"a \\\\\\u0028\\u0062\\\" c\"", a, "\"a \\(b\" c\"");
-    
+
     assertParseException("XY\\u005G");  // test non-hex character in escaped unicode sequence
     assertParseException("XY\\u005");   // test incomplete escaped unicode sequence
-    
+
     // Tests bug LUCENE-800
     assertQueryEquals("(item:\\\\ item:ABCD\\\\)", a, "item:\\ item:ABCD\\");
     assertParseException("(item:\\\\ item:ABCD\\\\))"); // unmatched closing paranthesis 
     assertQueryEquals("\\*", a, "*");
     assertQueryEquals("\\\\", a, "\\");  // escaped backslash
-    
+
     assertParseException("\\"); // a backslash must always be escaped
-    
+
     // LUCENE-1189
-    assertQueryEquals("(\"a\\\\\") or (\"b\")", a ,"a\\ or b");
+    assertQueryEquals("(\"a\\\\\") or (\"b\")", a, "a\\ or b");
   }
 
+  @Test
   public void testQueryStringEscaping() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
 
@@ -745,50 +745,52 @@
     assertEscapedQueryEquals("[ a - TO a+ ]", null, "\\[ a \\- TO a\\+ \\]");
     assertEscapedQueryEquals("[ a : TO a~ ]", null, "\\[ a \\: TO a\\~ \\]");
     assertEscapedQueryEquals("[ a\\ TO a* ]", null, "\\[ a\\\\ TO a\\* \\]");
-    
+
     // LUCENE-881
     assertEscapedQueryEquals("|| abc ||", a, "\\|\\| abc \\|\\|");
     assertEscapedQueryEquals("&& abc &&", a, "\\&\\& abc \\&\\&");
   }
-  
+
+  @Test
   public void testTabNewlineCarriageReturn()
-    throws Exception {
+          throws Exception {
     assertQueryEqualsDOA("+weltbank +worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
 
     assertQueryEqualsDOA("+weltbank\n+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \n+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \n +worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
 
     assertQueryEqualsDOA("+weltbank\r+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \r+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \r +worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
 
     assertQueryEqualsDOA("+weltbank\r\n+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \r\n+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \r\n +worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \r \n +worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
 
     assertQueryEqualsDOA("+weltbank\t+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \t+worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
     assertQueryEqualsDOA("weltbank \t +worlbank", null,
-      "+weltbank +worlbank");
+            "+weltbank +worlbank");
   }
 
+  @Test
   public void testSimpleDAO()
-    throws Exception {
+          throws Exception {
     assertQueryEqualsDOA("term term term", null, "+term +term +term");
     assertQueryEqualsDOA("term +term term", null, "+term +term +term");
     assertQueryEqualsDOA("term term +term", null, "+term +term +term");
@@ -796,8 +798,9 @@
     assertQueryEqualsDOA("-term term term", null, "-term +term +term");
   }
 
+  @Test
   public void testBoost()
-    throws Exception {
+          throws Exception {
     Set<Object> stopWords = new HashSet<Object>(1);
     stopWords.add("on");
     StandardAnalyzer oneStopAnalyzer = new StandardAnalyzer(org.apache.lucene.util.Version.LUCENE_CURRENT, stopWords);
@@ -829,7 +832,8 @@
     }
     fail("ParseException expected, not thrown");
   }
-       
+
+  @Test
   public void testException() throws Exception {
     assertParseException("\"some phrase");
     assertParseException("(foo bar");
@@ -838,8 +842,9 @@
     assertParseException("(sub query)^5.0^2.0 plus more");
     assertParseException("secret AND illegal) AND access:confidential");
   }
-  
+
 
+  @Test
   public void testCustomQueryParserWildcard() {
     try {
       new QPTestParser("contents", new WhitespaceAnalyzer()).parse("a?t");
@@ -849,6 +854,7 @@
     }
   }
 
+  @Test
   public void testCustomQueryParserFuzzy() throws Exception {
     try {
       new QPTestParser("contents", new WhitespaceAnalyzer()).parse("xunit~");
@@ -858,6 +864,7 @@
     }
   }
 
+  @Test
   public void testBooleanQuery() throws Exception {
     BooleanQuery.setMaxClauseCount(2);
     try {
@@ -872,6 +879,7 @@
   /**
    * This test differs from TestPrecedenceQueryParser
    */
+  @Test
   public void testPrecedence() throws Exception {
     QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, "field", new WhitespaceAnalyzer());
     Query query1 = qp.parse("A AND B OR C AND D");
@@ -879,6 +887,7 @@
     assertEquals(query1, query2);
   }
 
+  @Test
   public void testLocalDateFormat() throws IOException, ParseException {
     RAMDirectory ramDir = new RAMDirectory();
     IndexWriter iw = new IndexWriter(ramDir, new WhitespaceAnalyzer(), true, IndexWriter.MaxFieldLength.LIMITED);
@@ -895,66 +904,69 @@
     is.close();
   }
 
+  @Test
   public void testStarParsing() throws Exception {
     final int[] type = new int[1];
     QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, "field", new WhitespaceAnalyzer()) {
       @Override
       protected Query getWildcardQuery(String field, String termStr) throws ParseException {
         // override error checking of superclass
-        type[0]=1;
+        type[0] = 1;
-        return new TermQuery(new Term(field,termStr));
+        return new TermQuery(new Term(field, termStr));
       }
+
       @Override
       protected Query getPrefixQuery(String field, String termStr) throws ParseException {
         // override error checking of superclass
-        type[0]=2;        
+        type[0] = 2;
-        return new TermQuery(new Term(field,termStr));
+        return new TermQuery(new Term(field, termStr));
       }
 
       @Override
       protected Query getFieldQuery(String field, String queryText) throws ParseException {
-        type[0]=3;
+        type[0] = 3;
         return super.getFieldQuery(field, queryText);
       }
     };
 
     TermQuery tq;
 
-    tq = (TermQuery)qp.parse("foo:zoo*");
+    tq = (TermQuery) qp.parse("foo:zoo*");
-    assertEquals("zoo",tq.getTerm().text());
+    assertEquals("zoo", tq.getTerm().text());
-    assertEquals(2,type[0]);
+    assertEquals(2, type[0]);
 
-    tq = (TermQuery)qp.parse("foo:zoo*^2");
+    tq = (TermQuery) qp.parse("foo:zoo*^2");
-    assertEquals("zoo",tq.getTerm().text());
+    assertEquals("zoo", tq.getTerm().text());
-    assertEquals(2,type[0]);
+    assertEquals(2, type[0]);
-    assertEquals(tq.getBoost(),2,0);
+    assertEquals(tq.getBoost(), 2, 0);
 
-    tq = (TermQuery)qp.parse("foo:*");
+    tq = (TermQuery) qp.parse("foo:*");
-    assertEquals("*",tq.getTerm().text());
+    assertEquals("*", tq.getTerm().text());
-    assertEquals(1,type[0]);  // could be a valid prefix query in the future too
+    assertEquals(1, type[0]);  // could be a valid prefix query in the future too
 
-    tq = (TermQuery)qp.parse("foo:*^2");
+    tq = (TermQuery) qp.parse("foo:*^2");
-    assertEquals("*",tq.getTerm().text());
+    assertEquals("*", tq.getTerm().text());
-    assertEquals(1,type[0]);
+    assertEquals(1, type[0]);
-    assertEquals(tq.getBoost(),2,0);    
+    assertEquals(tq.getBoost(), 2, 0);
 
-    tq = (TermQuery)qp.parse("*:foo");
+    tq = (TermQuery) qp.parse("*:foo");
-    assertEquals("*",tq.getTerm().field());
+    assertEquals("*", tq.getTerm().field());
-    assertEquals("foo",tq.getTerm().text());
+    assertEquals("foo", tq.getTerm().text());
-    assertEquals(3,type[0]);
+    assertEquals(3, type[0]);
 
-    tq = (TermQuery)qp.parse("*:*");
+    tq = (TermQuery) qp.parse("*:*");
-    assertEquals("*",tq.getTerm().field());
+    assertEquals("*", tq.getTerm().field());
-    assertEquals("*",tq.getTerm().text());
+    assertEquals("*", tq.getTerm().text());
-    assertEquals(1,type[0]);  // could be handled as a prefix query in the future
+    assertEquals(1, type[0]);  // could be handled as a prefix query in the future
 
-     tq = (TermQuery)qp.parse("(*:*)");
+    tq = (TermQuery) qp.parse("(*:*)");
-    assertEquals("*",tq.getTerm().field());
+    assertEquals("*", tq.getTerm().field());
-    assertEquals("*",tq.getTerm().text());
+    assertEquals("*", tq.getTerm().text());
-    assertEquals(1,type[0]);
+    assertEquals(1, type[0]);
 
   }
 
+  @Test
   public void testStopwords() throws Exception {
     QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, "a", new StopAnalyzer(Version.LUCENE_CURRENT, StopFilter.makeStopSet(Version.LUCENE_CURRENT, "the", "foo")));
     Query result = qp.parse("a:the OR a:foo");
@@ -967,16 +979,17 @@
     result = qp.parse("(fieldX:xxxxx OR fieldy:xxxxxxxx)^2 AND (fieldx:the OR fieldy:foo)");
     assertNotNull("result is null and it shouldn't be", result);
     assertTrue("result is not a BooleanQuery", result instanceof BooleanQuery);
-    System.out.println("Result: " + result);
+    //System.out.println("Result: " + result);
     assertTrue(((BooleanQuery) result).clauses().size() + " does not equal: " + 2, ((BooleanQuery) result).clauses().size() == 2);
   }
 
+  @Test
   public void testPositionIncrement() throws Exception {
     QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, "a", new StopAnalyzer(Version.LUCENE_CURRENT, StopFilter.makeStopSet(Version.LUCENE_CURRENT, "the", "in", "are", "this")));
     qp.setEnablePositionIncrements(true);
     String qtxt = "\"the words in poisitions pos02578 are stopped in this phrasequery\"";
     //               0         2                      5           7  8
-    int expectedPositions[] = {1,3,4,6,9};
+    int expectedPositions[] = {1, 3, 4, 6, 9};
     PhraseQuery pq = (PhraseQuery) qp.parse(qtxt);
     //System.out.println("Query text: "+qtxt);
     //System.out.println("Result: "+pq);
@@ -984,19 +997,20 @@
     int pos[] = pq.getPositions();
     for (int i = 0; i < t.length; i++) {
       //System.out.println(i+". "+t[i]+"  pos: "+pos[i]);
-      assertEquals("term "+i+" = "+t[i]+" has wrong term-position!",expectedPositions[i],pos[i]);
+      assertEquals("term " + i + " = " + t[i] + " has wrong term-position!", expectedPositions[i], pos[i]);
     }
   }
 
+  @Test
   public void testMatchAllDocs() throws Exception {
     QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, "field", new WhitespaceAnalyzer());
     assertEquals(new MatchAllDocsQuery(), qp.parse("*:*"));
     assertEquals(new MatchAllDocsQuery(), qp.parse("(*:*)"));
-    BooleanQuery bq = (BooleanQuery)qp.parse("+*:* -*:*");
+    BooleanQuery bq = (BooleanQuery) qp.parse("+*:* -*:*");
     assertTrue(bq.getClauses()[0].getQuery() instanceof MatchAllDocsQuery);
     assertTrue(bq.getClauses()[1].getQuery() instanceof MatchAllDocsQuery);
   }
-  
+
   private void assertHits(int expected, String query, IndexSearcher is) throws ParseException, IOException {
     QueryParser qp = new QueryParser(Version.LUCENE_CURRENT, "date", new WhitespaceAnalyzer());
     qp.setLocale(Locale.ENGLISH);
@@ -1006,16 +1020,17 @@
   }
 
   private static void addDateDoc(String content, int year, int month,
-      int day, int hour, int minute, int second, IndexWriter iw) throws IOException {
+                                 int day, int hour, int minute, int second, IndexWriter iw) throws IOException {
     Document d = new Document();
     d.add(new Field("f", content, Field.Store.YES, Field.Index.ANALYZED));
     Calendar cal = Calendar.getInstance(Locale.ENGLISH);
-    cal.set(year, month-1, day, hour, minute, second);
+    cal.set(year, month - 1, day, hour, minute, second);
     d.add(new Field("date", DateField.dateToString(cal.getTime()), Field.Store.YES, Field.Index.NOT_ANALYZED));
     iw.addDocument(d);
   }
 
   @Override
+  @After
   public void tearDown() throws Exception {
     super.tearDown();
     BooleanQuery.setMaxClauseCount(originalMaxClauses);
@@ -1024,6 +1039,7 @@
   // LUCENE-2002: make sure defaults for StandardAnalyzer's
   // enableStopPositionIncr & QueryParser's enablePosIncr
   // "match"
+  @Test
   public void testPositionIncrements() throws Exception {
     Directory dir = new MockRAMDirectory();
     Analyzer a = new StandardAnalyzer(Version.LUCENE_CURRENT);
@@ -1051,15 +1067,16 @@
   //
   // This test is here as a safety, in case that ant step
   // doesn't work for some reason.
+  @Test
   public void testProtectedCtors() throws Exception {
     try {
-      QueryParser.class.getConstructor(new Class[] {CharStream.class});
+      QueryParser.class.getConstructor(new Class[]{CharStream.class});
       fail("please switch public QueryParser(CharStream) to be protected");
     } catch (NoSuchMethodException nsme) {
       // expected
     }
     try {
-      QueryParser.class.getConstructor(new Class[] {QueryParserTokenManager.class});
+      QueryParser.class.getConstructor(new Class[]{QueryParserTokenManager.class});
       fail("please switch public QueryParser(QueryParserTokenManager) to be protected");
     } catch (NoSuchMethodException nsme) {
       // expected
