Index: lucene/core/src/java/org/apache/lucene/search/spans/NearSpans.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/NearSpans.java	(revision 1670679)
+++ lucene/core/src/java/org/apache/lucene/search/spans/NearSpans.java	(working copy)
@@ -29,11 +29,11 @@
  * Common super class for un/ordered Spans
  */
 abstract class NearSpans extends Spans {
-  SpanNearQuery query;
-  int allowedSlop;
+  final SpanNearQuery query;
+  final int allowedSlop;
 
-  List<Spans> subSpans; // in query order
-  DocIdSetIterator conjunction; // use to move to next doc with all clauses
+  final Spans[] subSpans; // in query order
+  final DocIdSetIterator conjunction; // use to move to next doc with all clauses
   boolean atFirstInCurrentDoc;
   boolean oneExhaustedInCurrentDoc; // no more results possbile in current doc
 
@@ -44,7 +44,7 @@
     if (subSpans.size() < 2) {
       throw new IllegalArgumentException("Less than 2 subSpans: " + query);
     }
-    this.subSpans = Objects.requireNonNull(subSpans); // in query order
+    this.subSpans = subSpans.toArray(new Spans[subSpans.size()]); // in query order
     this.conjunction = ConjunctionDISI.intersect(subSpans);
   }
 
@@ -91,13 +91,8 @@
     return res;
   }
 
-  private Spans[] subSpansArray = null; // init only when needed.
-
   public Spans[] getSubSpans() {
-    if (subSpansArray == null) {
-      subSpansArray = subSpans.toArray(new Spans[subSpans.size()]);
-    }
-    return subSpansArray;
+    return subSpans;
   }
 
 }
Index: lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java	(revision 1670679)
+++ lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java	(working copy)
@@ -18,12 +18,8 @@
  */
 
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Collection;
-import java.util.Set;
 
 /** A Spans that is formed from the ordered subspans of a SpanNearQuery
  * where the subspans do not overlap and have a maximum slop between them,
@@ -146,11 +142,11 @@
    * otherwise at least one is exhausted in the current doc.
    */
   private boolean stretchToOrder() throws IOException {
-    Spans prevSpans = subSpans.get(0);
+    Spans prevSpans = subSpans[0];
     assert prevSpans.startPosition() != NO_MORE_POSITIONS : "prevSpans no start position "+prevSpans;
     assert prevSpans.endPosition() != NO_MORE_POSITIONS;
-    for (int i = 1; i < subSpans.size(); i++) {
-      Spans spans = subSpans.get(i);
+    for (int i = 1; i < subSpans.length; i++) {
+      Spans spans = subSpans[i];
       assert spans.startPosition() != NO_MORE_POSITIONS;
       assert spans.endPosition() != NO_MORE_POSITIONS;
 
@@ -169,15 +165,14 @@
    * on all subSpans, except the last one, in reverse order.
    */
   protected boolean shrinkToAfterShortestMatch() throws IOException {
-    Spans lastSubSpans = subSpans.get(subSpans.size() - 1);
+    Spans lastSubSpans = subSpans[subSpans.length - 1];
     matchStart = lastSubSpans.startPosition();
     matchEnd = lastSubSpans.endPosition();
 
     int matchSlop = 0;
     int lastStart = matchStart;
-    int lastEnd = matchEnd;
-    for (int i = subSpans.size() - 2; i >= 0; i--) {
-      Spans prevSpans = subSpans.get(i);
+    for (int i = subSpans.length - 2; i >= 0; i--) {
+      Spans prevSpans = subSpans[i];
 
       int prevStart = prevSpans.startPosition();
       int prevEnd = prevSpans.endPosition();
@@ -206,7 +201,6 @@
        */
       matchStart = prevStart;
       lastStart = prevStart;
-      lastEnd = prevEnd;
     }
 
     boolean match = matchSlop <= allowedSlop;
@@ -224,16 +218,14 @@
     return atFirstInCurrentDoc ? -1 : matchEnd;
   }
 
-  /** Throws an UnsupportedOperationException */
   @Override
   public Collection<byte[]> getPayload() throws IOException {
-    throw new UnsupportedOperationException("Use NearSpansPayloadOrdered instead");
+    return null;
   }
 
-  /** Throws an UnsupportedOperationException */
   @Override
   public boolean isPayloadAvailable() {
-    throw new UnsupportedOperationException("Use NearSpansPayloadOrdered instead");
+    return false;
   }
 
   @Override
Index: lucene/core/src/java/org/apache/lucene/search/spans/NearSpansPayloadOrdered.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/NearSpansPayloadOrdered.java	(revision 1670679)
+++ lucene/core/src/java/org/apache/lucene/search/spans/NearSpansPayloadOrdered.java	(working copy)
@@ -47,7 +47,7 @@
    * Also collect the payloads.
    */
   protected boolean shrinkToAfterShortestMatch() throws IOException {
-    Spans lastSubSpans = subSpans.get(subSpans.size() - 1);
+    Spans lastSubSpans = subSpans[subSpans.length - 1];
     matchStart = lastSubSpans.startPosition();
     matchEnd = lastSubSpans.endPosition();
 
@@ -62,9 +62,8 @@
 
     int matchSlop = 0;
     int lastStart = matchStart;
-    int lastEnd = matchEnd;
-    for (int i = subSpans.size() - 2; i >= 0; i--) {
-      Spans prevSpans = subSpans.get(i);
+    for (int i = subSpans.length - 2; i >= 0; i--) {
+      Spans prevSpans = subSpans[i];
 
       if (prevSpans.isPayloadAvailable()) {
         Collection<byte[]> payload = prevSpans.getPayload();
@@ -112,7 +111,6 @@
        */
       matchStart = prevStart;
       lastStart = prevStart;
-      lastEnd = prevEnd;
     }
 
     boolean match = matchSlop <= allowedSlop;
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(revision 1670679)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(working copy)
@@ -18,8 +18,6 @@
  */
 
 import java.io.IOException;
-
-
 import java.util.List;
 import java.util.ArrayList;
 import java.util.Iterator;
@@ -26,7 +24,7 @@
 import java.util.Map;
 import java.util.Set;
 
-
+import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
@@ -131,10 +129,13 @@
         return null; // all required
       }
     }
-    
+    FieldInfo info = context.reader().getFieldInfos().fieldInfo(field);
+    if (info == null) {
+      return null; // field does not exist
+    }
     // all NearSpans require at least two subSpans
     return (! inOrder) ? new NearSpansUnordered(this, subSpans)
-          : collectPayloads ? new NearSpansPayloadOrdered(this, subSpans)
+          : collectPayloads && info.hasPayloads() ? new NearSpansPayloadOrdered(this, subSpans)
           : new NearSpansOrdered(this, subSpans);
   }
 
