Index: lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java	(revision 1303387)
+++ lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java	(working copy)
@@ -45,6 +45,7 @@
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.MockDirectoryWrapper;
 import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
@@ -157,7 +158,9 @@
       }
       File oldIndxeDir = _TestUtil.getTempDir(unsupportedNames[i]);
       _TestUtil.unzip(getDataFile("unsupported." + unsupportedNames[i] + ".zip"), oldIndxeDir);
-      Directory dir = newFSDirectory(oldIndxeDir);
+      MockDirectoryWrapper dir = newFSDirectory(oldIndxeDir);
+      // don't checkindex, these are intentionally not supported
+      dir.setCheckIndexOnClose(false);
 
       IndexReader reader = null;
       IndexWriter writer = null;
Index: lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper.java	(revision 1303387)
+++ lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper.java	(working copy)
@@ -559,7 +559,7 @@
     }
     open = false;
     if (checkIndexOnClose) {
-      if (DirectoryReader.indexExists(this)) {
+      if (indexPossiblyExists(this)) {
         if (LuceneTestCase.VERBOSE) {
           System.out.println("\nNOTE: MockDirectoryWrapper: now crash");
         }
@@ -595,6 +595,26 @@
     }
     delegate.close();
   }
+  
+  /** don't rely upon DirectoryReader.fileExists to determine if we should
+   *  checkIndex() or not. It might mask real problems, where we silently
+   *  don't checkindex at all. instead we look for a segments file.
+   */
+  private boolean indexPossiblyExists(Directory d) throws IOException {
+    String files[];
+    try {
+      files = d.listAll();
+    } catch (IOException ex) {
+      // this means directory doesn't exist, which is ok. return false
+      return false;
+    }
+    for (String f : files) {
+      if (f.startsWith("segments_")) {
+        return true;
+      }
+    }
+    return false;
+  }
 
   synchronized void removeOpenFile(Closeable c, String name) {
     Integer v = openFiles.get(name);
