Index: lucene/core/src/java/org/apache/lucene/analysis/NumericTokenStream.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/analysis/NumericTokenStream.java	(revision 1588643)
+++ lucene/core/src/java/org/apache/lucene/analysis/NumericTokenStream.java	(working copy)
@@ -214,7 +214,7 @@
   
   /**
    * Creates a token stream for numeric values using the default <code>precisionStep</code>
-   * {@link NumericUtils#PRECISION_STEP_DEFAULT} (4). The stream is not yet initialized,
+   * {@link NumericUtils#PRECISION_STEP_DEFAULT} (16). The stream is not yet initialized,
    * before using set a value using the various set<em>???</em>Value() methods.
    */
   public NumericTokenStream() {
Index: lucene/core/src/java/org/apache/lucene/document/DoubleField.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/document/DoubleField.java	(revision 1588643)
+++ lucene/core/src/java/org/apache/lucene/document/DoubleField.java	(working copy)
@@ -145,7 +145,7 @@
 
   /** Creates a stored or un-stored DoubleField with the provided value
    *  and default <code>precisionStep</code> {@link
-   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). 
+   *  NumericUtils#PRECISION_STEP_DEFAULT} (16). 
    *  @param name field name
    *  @param value 64-bit double value
    *  @param stored Store.YES if the content should also be stored
Index: lucene/core/src/java/org/apache/lucene/document/FloatField.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/document/FloatField.java	(revision 1588643)
+++ lucene/core/src/java/org/apache/lucene/document/FloatField.java	(working copy)
@@ -125,6 +125,7 @@
     TYPE_NOT_STORED.setOmitNorms(true);
     TYPE_NOT_STORED.setIndexOptions(IndexOptions.DOCS_ONLY);
     TYPE_NOT_STORED.setNumericType(FieldType.NumericType.FLOAT);
+    TYPE_NOT_STORED.setNumericPrecisionStep(NumericUtils.PRECISION_STEP_DEFAULT_32);
     TYPE_NOT_STORED.freeze();
   }
 
@@ -139,13 +140,14 @@
     TYPE_STORED.setOmitNorms(true);
     TYPE_STORED.setIndexOptions(IndexOptions.DOCS_ONLY);
     TYPE_STORED.setNumericType(FieldType.NumericType.FLOAT);
+    TYPE_STORED.setNumericPrecisionStep(NumericUtils.PRECISION_STEP_DEFAULT_32);
     TYPE_STORED.setStored(true);
     TYPE_STORED.freeze();
   }
 
   /** Creates a stored or un-stored FloatField with the provided value
    *  and default <code>precisionStep</code> {@link
-   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). 
+   *  NumericUtils#PRECISION_STEP_DEFAULT_32} (8). 
    *  @param name field name
    *  @param value 32-bit double value
    *  @param stored Store.YES if the content should also be stored
Index: lucene/core/src/java/org/apache/lucene/document/IntField.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/document/IntField.java	(revision 1588643)
+++ lucene/core/src/java/org/apache/lucene/document/IntField.java	(working copy)
@@ -125,6 +125,7 @@
     TYPE_NOT_STORED.setOmitNorms(true);
     TYPE_NOT_STORED.setIndexOptions(IndexOptions.DOCS_ONLY);
     TYPE_NOT_STORED.setNumericType(FieldType.NumericType.INT);
+    TYPE_NOT_STORED.setNumericPrecisionStep(NumericUtils.PRECISION_STEP_DEFAULT_32);
     TYPE_NOT_STORED.freeze();
   }
 
@@ -139,13 +140,14 @@
     TYPE_STORED.setOmitNorms(true);
     TYPE_STORED.setIndexOptions(IndexOptions.DOCS_ONLY);
     TYPE_STORED.setNumericType(FieldType.NumericType.INT);
+    TYPE_STORED.setNumericPrecisionStep(NumericUtils.PRECISION_STEP_DEFAULT_32);
     TYPE_STORED.setStored(true);
     TYPE_STORED.freeze();
   }
 
   /** Creates a stored or un-stored IntField with the provided value
    *  and default <code>precisionStep</code> {@link
-   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). 
+   *  NumericUtils#PRECISION_STEP_DEFAULT_32} (8). 
    *  @param name field name
    *  @param value 32-bit integer value
    *  @param stored Store.YES if the content should also be stored
Index: lucene/core/src/java/org/apache/lucene/document/LongField.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/document/LongField.java	(revision 1588643)
+++ lucene/core/src/java/org/apache/lucene/document/LongField.java	(working copy)
@@ -155,7 +155,7 @@
 
   /** Creates a stored or un-stored LongField with the provided value
    *  and default <code>precisionStep</code> {@link
-   *  NumericUtils#PRECISION_STEP_DEFAULT} (4). 
+   *  NumericUtils#PRECISION_STEP_DEFAULT} (16). 
    *  @param name field name
    *  @param value 64-bit long value
    *  @param stored Store.YES if the content should also be stored
Index: lucene/core/src/java/org/apache/lucene/search/NumericRangeFilter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/NumericRangeFilter.java	(revision 1588643)
+++ lucene/core/src/java/org/apache/lucene/search/NumericRangeFilter.java	(working copy)
@@ -68,7 +68,7 @@
   
   /**
    * Factory that creates a <code>NumericRangeFilter</code>, that queries a <code>long</code>
-   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT} (4).
+   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT} (16).
    * You can have half-open ranges (which are in fact &lt;/&le; or &gt;/&ge; queries)
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
@@ -98,7 +98,7 @@
   
   /**
    * Factory that creates a <code>NumericRangeFilter</code>, that queries a <code>int</code>
-   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT} (4).
+   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT_32} (8).
    * You can have half-open ranges (which are in fact &lt;/&le; or &gt;/&ge; queries)
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
@@ -130,7 +130,7 @@
   
   /**
    * Factory that creates a <code>NumericRangeFilter</code>, that queries a <code>double</code>
-   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT} (4).
+   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT} (16).
    * You can have half-open ranges (which are in fact &lt;/&le; or &gt;/&ge; queries)
    * by setting the min or max value to <code>null</code>.
    * {@link Double#NaN} will never match a half-open range, to hit {@code NaN} use a query
@@ -164,7 +164,7 @@
 
   /**
    * Factory that creates a <code>NumericRangeFilter</code>, that queries a <code>float</code>
-   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT} (4).
+   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT_32} (8).
    * You can have half-open ranges (which are in fact &lt;/&le; or &gt;/&ge; queries)
    * by setting the min or max value to <code>null</code>.
    * {@link Float#NaN} will never match a half-open range, to hit {@code NaN} use a query
Index: lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java	(revision 1588643)
+++ lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java	(working copy)
@@ -196,7 +196,7 @@
   
   /**
    * Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>long</code>
-   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT} (4).
+   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT} (16).
    * You can have half-open ranges (which are in fact &lt;/&le; or &gt;/&ge; queries)
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
@@ -222,7 +222,7 @@
   
   /**
    * Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>int</code>
-   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT} (4).
+   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT_32} (8).
    * You can have half-open ranges (which are in fact &lt;/&le; or &gt;/&ge; queries)
    * by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
    * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
@@ -230,7 +230,7 @@
   public static NumericRangeQuery<Integer> newIntRange(final String field,
     Integer min, Integer max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery<>(field, NumericUtils.PRECISION_STEP_DEFAULT, NumericType.INT, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<>(field, NumericUtils.PRECISION_STEP_DEFAULT_32, NumericType.INT, min, max, minInclusive, maxInclusive);
   }
   
   /**
@@ -250,7 +250,7 @@
   
   /**
    * Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>double</code>
-   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT} (4).
+   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT} (16).
    * You can have half-open ranges (which are in fact &lt;/&le; or &gt;/&ge; queries)
    * by setting the min or max value to <code>null</code>.
    * {@link Double#NaN} will never match a half-open range, to hit {@code NaN} use a query
@@ -280,7 +280,7 @@
   
   /**
    * Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>float</code>
-   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT} (4).
+   * range using the default <code>precisionStep</code> {@link NumericUtils#PRECISION_STEP_DEFAULT_32} (8).
    * You can have half-open ranges (which are in fact &lt;/&le; or &gt;/&ge; queries)
    * by setting the min or max value to <code>null</code>.
    * {@link Float#NaN} will never match a half-open range, to hit {@code NaN} use a query
@@ -290,7 +290,7 @@
   public static NumericRangeQuery<Float> newFloatRange(final String field,
     Float min, Float max, final boolean minInclusive, final boolean maxInclusive
   ) {
-    return new NumericRangeQuery<>(field, NumericUtils.PRECISION_STEP_DEFAULT, NumericType.FLOAT, min, max, minInclusive, maxInclusive);
+    return new NumericRangeQuery<>(field, NumericUtils.PRECISION_STEP_DEFAULT_32, NumericType.FLOAT, min, max, minInclusive, maxInclusive);
   }
 
   @Override @SuppressWarnings("unchecked")
Index: lucene/core/src/java/org/apache/lucene/util/NumericUtils.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/NumericUtils.java	(revision 1588643)
+++ lucene/core/src/java/org/apache/lucene/util/NumericUtils.java	(working copy)
@@ -68,14 +68,19 @@
   private NumericUtils() {} // no instance!
   
   /**
-   * The default precision step used by {@link IntField},
-   * {@link FloatField}, {@link LongField}, {@link
-   * DoubleField}, {@link NumericTokenStream}, {@link
+   * The default precision step used by {@link LongField},
+   * {@link DoubleField}, {@link NumericTokenStream}, {@link
    * NumericRangeQuery}, and {@link NumericRangeFilter}.
    */
-  public static final int PRECISION_STEP_DEFAULT = 4;
+  public static final int PRECISION_STEP_DEFAULT = 16;
   
   /**
+   * The default precision step used by {@link IntField} and
+   * {@link FloatField}.
+   */
+  public static final int PRECISION_STEP_DEFAULT_32 = 8;
+  
+  /**
    * Longs are stored at lower precision by shifting off lower bits. The shift count is
    * stored as <code>SHIFT_START_LONG+shift</code> in the first byte
    */
