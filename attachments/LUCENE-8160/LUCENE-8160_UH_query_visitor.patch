Index: lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/MultiTermHighlighting.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/MultiTermHighlighting.java	(revision ce5932fc373ebfa6718af8f317b36bf33896a59e)
+++ lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/MultiTermHighlighting.java	(date 1517717780000)
@@ -17,27 +17,15 @@
 package org.apache.lucene.search.uhighlight;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 import java.util.function.Function;
 import java.util.function.Predicate;
 
-import org.apache.lucene.queries.function.FunctionScoreQuery;
 import org.apache.lucene.search.AutomatonQuery;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.BoostQuery;
-import org.apache.lucene.search.ConstantScoreQuery;
-import org.apache.lucene.search.DisjunctionMaxQuery;
 import org.apache.lucene.search.FuzzyQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanBoostQuery;
-import org.apache.lucene.search.spans.SpanMultiTermQueryWrapper;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanNotQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanPositionCheckQuery;
+import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.util.UnicodeUtil;
 import org.apache.lucene.util.automaton.Automata;
 import org.apache.lucene.util.automaton.Automaton;
@@ -63,91 +51,78 @@
                                                         Predicate<String> fieldMatcher,
                                                         boolean lookInSpan,
                                                         Function<Query, Collection<Query>> preRewriteFunc) {
-    // TODO Lucene needs a Query visitor API!  LUCENE-3041
-
     List<CharacterRunAutomaton> list = new ArrayList<>();
-    Collection<Query> customSubQueries = preRewriteFunc.apply(query);
-    if (customSubQueries != null) {
-      for (Query sub : customSubQueries) {
-        list.addAll(Arrays.asList(extractAutomata(sub, fieldMatcher, lookInSpan, preRewriteFunc)));
-      }
-    } else if (query instanceof BooleanQuery) {
-      for (BooleanClause clause : (BooleanQuery) query) {
-        if (!clause.isProhibited()) {
-          list.addAll(Arrays.asList(extractAutomata(clause.getQuery(), fieldMatcher, lookInSpan, preRewriteFunc)));
+
+    new QueryVisitor() {
+      @Override
+      public void visit(Query query) {
+        Collection<Query> customSubQueries = preRewriteFunc.apply(query);
+        if (customSubQueries != null) {
+          for (Query sub : customSubQueries) {
+            visit(sub);
+          }
+        } else {
+          super.visit(query);
         }
       }
-    } else if (query instanceof ConstantScoreQuery) {
-      list.addAll(Arrays.asList(extractAutomata(((ConstantScoreQuery) query).getQuery(), fieldMatcher, lookInSpan,
-          preRewriteFunc)));
-    } else if (query instanceof BoostQuery) {
-      list.addAll(Arrays.asList(extractAutomata(((BoostQuery) query).getQuery(), fieldMatcher, lookInSpan,
-          preRewriteFunc)));
-    } else if (query instanceof FunctionScoreQuery) {
-      list.addAll(Arrays.asList(extractAutomata(((FunctionScoreQuery) query).getWrappedQuery(), fieldMatcher,
-          lookInSpan, preRewriteFunc)));
-    } else if (query instanceof DisjunctionMaxQuery) {
-      for (Query sub : ((DisjunctionMaxQuery) query).getDisjuncts()) {
-        list.addAll(Arrays.asList(extractAutomata(sub, fieldMatcher, lookInSpan, preRewriteFunc)));
-      }
-    } else if (lookInSpan && query instanceof SpanOrQuery) {
-      for (Query sub : ((SpanOrQuery) query).getClauses()) {
-        list.addAll(Arrays.asList(extractAutomata(sub, fieldMatcher, lookInSpan, preRewriteFunc)));
+
+      @Override
+      public void visit(SpanQuery query) {
+        if (lookInSpan) {
+          super.visit(query);
+        }
       }
-    } else if (lookInSpan && query instanceof SpanNearQuery) {
-      for (Query sub : ((SpanNearQuery) query).getClauses()) {
-        list.addAll(Arrays.asList(extractAutomata(sub, fieldMatcher, lookInSpan, preRewriteFunc)));
+
+      @Override
+      public void visitTerminalOrUnknown(Query query) {
+        if (query instanceof FuzzyQuery) {
+          visit((FuzzyQuery) query);
+        } else if (query instanceof AutomatonQuery) {
+          visit((AutomatonQuery) query);
+        } // else not a MTQ or is some MTQ we don't know what to do with
       }
-    } else if (lookInSpan && query instanceof SpanNotQuery) {
-      list.addAll(Arrays.asList(extractAutomata(((SpanNotQuery) query).getInclude(), fieldMatcher, lookInSpan,
-          preRewriteFunc)));
-    } else if (lookInSpan && query instanceof SpanPositionCheckQuery) {
-      list.addAll(Arrays.asList(extractAutomata(((SpanPositionCheckQuery) query).getMatch(), fieldMatcher, lookInSpan,
-          preRewriteFunc)));
-    } else if (lookInSpan && query instanceof SpanBoostQuery) {
-      list.addAll(Arrays.asList(extractAutomata(((SpanBoostQuery) query).getQuery(), fieldMatcher, lookInSpan,
-          preRewriteFunc)));
-    } else if (lookInSpan && query instanceof SpanMultiTermQueryWrapper) {
-      list.addAll(Arrays.asList(extractAutomata(((SpanMultiTermQueryWrapper<?>) query).getWrappedQuery(),
-          fieldMatcher, lookInSpan, preRewriteFunc)));
-    } else if (query instanceof FuzzyQuery) {
-      final FuzzyQuery fq = (FuzzyQuery) query;
-      if (fieldMatcher.test(fq.getField())) {
-        String utf16 = fq.getTerm().text();
+
+      private void visit(FuzzyQuery query) {
+        if (!fieldMatcher.test(query.getField())) {
+          return;
+        }
+        String utf16 = query.getTerm().text();
         int termText[] = new int[utf16.codePointCount(0, utf16.length())];
         for (int cp, i = 0, j = 0; i < utf16.length(); i += Character.charCount(cp)) {
           termText[j++] = cp = utf16.codePointAt(i);
         }
         int termLength = termText.length;
-        int prefixLength = Math.min(fq.getPrefixLength(), termLength);
+        int prefixLength = Math.min(query.getPrefixLength(), termLength);
         String suffix = UnicodeUtil.newString(termText, prefixLength, termText.length - prefixLength);
-        LevenshteinAutomata builder = new LevenshteinAutomata(suffix, fq.getTranspositions());
+        LevenshteinAutomata builder = new LevenshteinAutomata(suffix, query.getTranspositions());
         String prefix = UnicodeUtil.newString(termText, 0, prefixLength);
-        Automaton automaton = builder.toAutomaton(fq.getMaxEdits(), prefix);
+        Automaton automaton = builder.toAutomaton(query.getMaxEdits(), prefix);
         list.add(new CharacterRunAutomaton(automaton) {
           @Override
           public String toString() {
-            return fq.toString();
+            return query.toString();
           }
         });
       }
-    } else if (query instanceof AutomatonQuery) {
-      final AutomatonQuery aq = (AutomatonQuery) query;
-      if (fieldMatcher.test(aq.getField())) {
+
+      private void visit(AutomatonQuery query) {
+        if (!fieldMatcher.test(query.getField())) {
+          return;
+        }
 
-        if (aq.isAutomatonBinary() == false) { // note: is the case for WildcardQuery, RegexpQuery
-          list.add(new CharacterRunAutomaton(aq.getAutomaton()) {
+        if (query.isAutomatonBinary() == false) { // note: is the case for WildcardQuery, RegexpQuery
+          list.add(new CharacterRunAutomaton(query.getAutomaton()) {
             @Override
             public String toString() {
-              return aq.toString();
+              return query.toString();
             }
           });
         } else { // note: is the case for PrefixQuery, TermRangeQuery
           // byte oriented automaton:
           list.add(new CharacterRunAutomaton(Automata.makeEmpty()) { // empty here is bogus just to satisfy API
-            //   TODO can we get access to the aq.compiledAutomaton.runAutomaton ?
+            //   TODO can we get access to the query.compiledAutomaton.runAutomaton ?
             ByteRunAutomaton byteRunAutomaton =
-                new ByteRunAutomaton(aq.getAutomaton(), true, Operations.DEFAULT_MAX_DETERMINIZED_STATES);
+                new ByteRunAutomaton(query.getAutomaton(), true, Operations.DEFAULT_MAX_DETERMINIZED_STATES);
 
             @Override
             public boolean run(char[] chars, int offset, int length) {
@@ -183,13 +158,15 @@
 
             @Override
             public String toString() {
-              return aq.toString();
+              return query.toString();
             }
           });
         }
 
       }
-    }
+
+    }.visit(query);
+
     return list.toArray(new CharacterRunAutomaton[list.size()]);
   }
 
Index: lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/PhraseHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/PhraseHelper.java	(revision ce5932fc373ebfa6718af8f317b36bf33896a59e)
+++ lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/PhraseHelper.java	(date 1517864027000)
@@ -36,15 +36,19 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.queries.CommonTermsQuery;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.MultiPhraseQuery;
 import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.ScoreMode;
 import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.SynonymQuery;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TwoPhaseIterator;
 import org.apache.lucene.search.Weight;
-import org.apache.lucene.search.highlight.WeightedSpanTerm;
 import org.apache.lucene.search.highlight.WeightedSpanTermExtractor;
 import org.apache.lucene.search.spans.SpanCollector;
 import org.apache.lucene.search.spans.SpanMultiTermQueryWrapper;
@@ -75,14 +79,14 @@
 
   /**
    * Constructor.
-   * {@code rewriteQueryPred} is an extension hook to override the default choice of
-   * {@link WeightedSpanTermExtractor#mustRewriteQuery(SpanQuery)}. By default unknown query types are rewritten,
-   * so use this to return {@link Boolean#FALSE} if you know the query doesn't need to be rewritten.
-   * Similarly, {@code preExtractRewriteFunction} is also an extension hook for extract to allow different queries
-   * to be set before the {@link WeightedSpanTermExtractor}'s extraction is invoked.
-   * {@code ignoreQueriesNeedingRewrite} effectively ignores any query clause that needs to be "rewritten", which is
-   * usually limited to just a {@link SpanMultiTermQueryWrapper} but could be other custom ones.
-   * {@code fieldMatcher} The field name predicate to use for extracting the query part that must be highlighted.
+   * @param fieldMatcher the field name predicate to use for extracting the query part that must be highlighted
+   * @param rewriteQueryPred an extension hook to override the default choice of
+   *        {@link WeightedSpanTermExtractor#mustRewriteQuery(SpanQuery)}. By default unknown query types are rewritten,
+   *        so use this to return {@link Boolean#FALSE} if you know the query doesn't need to be rewritten.
+   * @param preExtractRewriteFunction an extension hook for extract to allow different queries
+   *        to be set before the {@link WeightedSpanTermExtractor}'s extraction is invoked
+   * @param ignoreQueriesNeedingRewrite effectively ignores any query clause that needs to be "rewritten", which is
+   *        usually limited to just a {@link SpanMultiTermQueryWrapper} but could be other custom ones.
    */
   public PhraseHelper(Query query, String field, Predicate<String> fieldMatcher, Function<SpanQuery, Boolean> rewriteQueryPred,
                       Function<Query, Collection<Query>> preExtractRewriteFunction,
@@ -93,77 +97,82 @@
     positionInsensitiveTerms = new HashSet<>();
     spanQueries = new HashSet<>();
 
-    // TODO Have toSpanQuery(query) Function as an extension point for those with custom Query impls
+    // Collect information about the query:
+    // (1) position insensitive terms
+    // (2) position sensitive queries, converting to a SpanQuery
+    // (3) whether we need to rewrite the span queries (MTQ)
 
     boolean[] mustRewriteHolder = {false}; // boolean wrapped in 1-ary array so it's mutable from inner class
 
-    // When we call Weight.extractTerms, we do it on clauses that are NOT position sensitive.
-    // We only want the to track a Set of bytes for the Term, not Term class with field part.
-    Set<Term> extractPosInsensitiveTermsTarget = new TreeSet<Term>() {
-      @Override
-      public boolean add(Term term) {
-        // don't call super.add; we don't actually use the superclass
-        if (fieldMatcher.test(term.field())) {
-          return positionInsensitiveTerms.add(term.bytes());
-        } else {
-          return false;
-        }
-      }
-    };
+    new QueryVisitor() {
+      @Override
+      public void visit(Query query) {
+        Collection<Query> newQueriesToExtract = preExtractRewriteFunction.apply(query);
+        if (newQueriesToExtract != null) {
+          for (Query newQuery : newQueriesToExtract) {
+            visit(newQuery);
+          }
+        } else {
+          super.visit(query);
+        }
+      }
+
+      @Override
+      public void visitTerminalOrUnknown(Query query) {
+        if (query instanceof TermQuery || query instanceof SynonymQuery
+            || query instanceof CommonTermsQuery) { // skip TermInSetQuery
+          // one or more position insensitive terms -- collect them
+          // note: CommonTermsQuery is index sensitive; but for highlighting we don't treat as such
+          try {
+           query.createWeight(UnifiedHighlighter.EMPTY_INDEXSEARCHER, ScoreMode.COMPLETE_NO_SCORES, 1f)
+               .extractTerms(extractPosInsensitiveTermsTarget); // will check the field match too
+          } catch (IOException e) {
+            //ignore; not supported.  Should we "assert false"?
+          }
+
+          // position sensitive:
+        } else if (query instanceof PhraseQuery) {
+          visit(SpanQueryConverter.DEFAULT.convert((PhraseQuery) query));
+        } else if (query instanceof MultiPhraseQuery) {
+          visit(SpanQueryConverter.DEFAULT.convert((MultiPhraseQuery) query));
+
+          // check some unsupported queries:
+        } else if (query instanceof MultiTermQuery) {
+          // these are handled by MultiTermHighlighting; avoid calling rewrite below
+        } else if (query.getClass().getName().startsWith("org.apache.lucene.spatial")) {
+          // not highlightable; avoid calling rewrite below
+        } else {
+          // Almost giving up but one more attempt.  Rewrite it to see if changes, then try again.
+          Query rewritten = query;
+          try {
+            rewritten = query.rewrite(UnifiedHighlighter.EMPTY_INDEXSEARCHER.getIndexReader());
+          } catch (IOException e) {
+            //ignore; not supported.  Should we "assert false"?
+          }
+          if (rewritten != query) {
+            visit(query);
+          } // otherwise give up
+        }
+      }
+
+      // used above for Weight.extractTerms on position insensitive queries
+      // We only want to track a Set of bytes for the Term, not Term class with field part.
+      Set<Term> extractPosInsensitiveTermsTarget = new TreeSet<Term>() {
+        @Override
+        public boolean add(Term term) {
+          // don't call super.add; we don't actually use the superclass
+          if (fieldMatcher.test(term.field())) {
+            return positionInsensitiveTerms.add(term.bytes());
+          } else {
+            return false;
+          }
+        }
+      };
 
-    // For TermQueries or other position insensitive queries, collect the Terms.
-    // For other Query types, WSTE will convert to an equivalent SpanQuery.  NOT extracting position spans here.
-    new WeightedSpanTermExtractor(field) {
-      //anonymous constructor
-      {
-        setExpandMultiTermQuery(true); //necessary for mustRewriteQuery(spanQuery) to work.
-
-        try {
-          extract(query, 1f, null); // null because we won't actually extract right now; we're not collecting
-        } catch (Exception e) {
-          throw new RuntimeException(e);
-        }
-      }
-
-      @Override
-      protected void extract(Query query, float boost, Map<String, WeightedSpanTerm> terms) throws IOException {
-        Collection<Query> newQueriesToExtract = preExtractRewriteFunction.apply(query);
-        if (newQueriesToExtract != null) {
-          for (Query newQuery : newQueriesToExtract) {
-            extract(newQuery, boost, terms);
-          }
-        } else {
-          super.extract(query, boost, terms);
-        }
-      }
-
-      @Override
-      protected boolean isQueryUnsupported(Class<? extends Query> clazz) {
-        if (clazz.isAssignableFrom(MultiTermQuery.class)) {
-          return true; //We do MTQ processing separately in MultiTermHighlighting.java
-        }
-        return true; //TODO set to false and provide a hook to customize certain queries.
-      }
-
-      // called on Query types that are NOT position sensitive, e.g. TermQuery
       @Override
-      protected void extractWeightedTerms(Map<String, WeightedSpanTerm> terms, Query query, float boost)
-          throws IOException {
-        query.createWeight(UnifiedHighlighter.EMPTY_INDEXSEARCHER, ScoreMode.COMPLETE_NO_SCORES, boost)
-            .extractTerms(extractPosInsensitiveTermsTarget);
-      }
-
-      // called on SpanQueries. Some other position-sensitive queries like PhraseQuery are converted beforehand
-      @Override
-      protected void extractWeightedSpanTerms(Map<String, WeightedSpanTerm> terms, SpanQuery spanQuery,
-                                              float boost) throws IOException {
-        // if this span query isn't for this field, skip it.
-        Set<String> fieldNameSet = new HashSet<>();//TODO reuse.  note: almost always size 1
-        collectSpanQueryFields(spanQuery, fieldNameSet);
-        for (String spanField : fieldNameSet) {
-          if (!fieldMatcher.test(spanField)) {
-            return;
-          }
+      public void visit(SpanQuery spanQuery) {
+        if (!fieldMatcher.test(spanQuery.getField())) {
+          return;
         }
 
         boolean mustRewriteQuery = mustRewriteQuery(spanQuery);
@@ -175,12 +184,29 @@
         spanQueries.add(spanQuery);
       }
 
-      @Override
-      protected boolean mustRewriteQuery(SpanQuery spanQuery) {
-        Boolean rewriteQ = rewriteQueryPred.apply(spanQuery);// allow to override
-        return rewriteQ != null ? rewriteQ : super.mustRewriteQuery(spanQuery);
+      private boolean mustRewriteQuery(SpanQuery spanQuery) {
+        Boolean rewriteQ = rewriteQueryPred.apply(spanQuery);// allow to override
+        if (rewriteQ != null) {
+          return rewriteQ;
+        }
+        boolean[] result = new boolean[]{false};
+        new QueryVisitor() {//TODO re-use on outer class?
+          {
+            skipNegative = false; // better than a boolean no-name arg to QueryVisitor?
+          }
+          @Override
+          public void visit(SpanQuery query) {
+            if (query instanceof SpanMultiTermQueryWrapper) {
+              result[0] = true; //TODO should QueryVisitor have an Object stopResult?
+              stopSignal = true;
+            } else {
+              super.visit(query);
+            }
+          }
+        }.visit(spanQuery);
+        return result[0];
       }
-    }; // calling the constructor triggered the extraction/visiting we want.  Hacky; yes.
+    }.visit(query);
 
     willRewrite = mustRewriteHolder[0];
   }
@@ -201,7 +227,7 @@
    * custom things.  When true, the resulting term list will probably be different than what it was known
    * to be initially.
    */
-  public boolean willRewrite() {
+  public boolean willRewrite() { // TODO rename rewriteNeedsIndexReader
     return willRewrite;
   }
 
@@ -296,6 +322,8 @@
         @Override
         public TermsEnum iterator() throws IOException {
           return new FilterTermsEnum(in.iterator()) {
+            //TODO override next & seekCeil to throw an exception if willRewrite == false (should not be called)
+            //   Purpose is to prevent perf bug with PostingsOffsetStrategy and not detecting willRewrite up front
             @Override
             public PostingsEnum postings(PostingsEnum reuse, int flags) throws IOException {
               return super.postings(reuse, flags | PostingsEnum.OFFSETS);
Index: lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/QueryVisitor.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/QueryVisitor.java	(date 1517864027000)
+++ lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/QueryVisitor.java	(date 1517864027000)
@@ -0,0 +1,204 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.search.uhighlight;
+
+import org.apache.lucene.queries.function.FunctionScoreQuery;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.BoostQuery;
+import org.apache.lucene.search.ConstantScoreQuery;
+import org.apache.lucene.search.DisjunctionMaxQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.join.ToChildBlockJoinQuery;
+import org.apache.lucene.search.join.ToParentBlockJoinQuery;
+import org.apache.lucene.search.spans.FieldMaskingSpanQuery;
+import org.apache.lucene.search.spans.SpanBoostQuery;
+import org.apache.lucene.search.spans.SpanMultiTermQueryWrapper;
+import org.apache.lucene.search.spans.SpanNearQuery;
+import org.apache.lucene.search.spans.SpanNotQuery;
+import org.apache.lucene.search.spans.SpanOrQuery;
+import org.apache.lucene.search.spans.SpanPositionCheckQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+
+//LUCENE-3041
+
+public abstract class QueryVisitor {
+
+  protected boolean skipNegative = true;//TODO add constructor param?  Or let anonymous class set it which is clearer
+
+  protected boolean stopSignal = false;
+
+  //TODO perhaps also track the current boost?  Ehh; but easy enough for subclass
+
+  /**
+   * Typical entry point.
+   * Can be overridden, especially to replace a query.
+   * Avoid overriding to replace some SpanQueries but not others; instead prefer overriding {@link #visit(SpanQuery)}
+   * because various SpanQuery visitors will call that one and not this one.  TODO so change that?
+   */
+  public void visit(Query query) {
+    if (stopSignal) {
+      //return
+    }
+
+    // Aggregate queries (more than one) plus Spans:
+    else if (query instanceof BooleanQuery) {
+      visit((BooleanQuery) query);
+    } else if (query instanceof DisjunctionMaxQuery) {
+      visit((DisjunctionMaxQuery)query);
+    } else if (query instanceof SpanQuery) {
+      visit((SpanQuery) query);
+    }
+
+    // Wrapper queries (one child)
+    else if (query instanceof BoostQuery) {
+      visit((BoostQuery) query);
+    } else if (query instanceof FunctionScoreQuery) {
+      visit((FunctionScoreQuery) query);
+    } else if (query instanceof ConstantScoreQuery) {
+      visit((ConstantScoreQuery) query);
+    } else if (query instanceof ToParentBlockJoinQuery) {
+      visit((ToParentBlockJoinQuery) query);
+    } else if (query instanceof ToChildBlockJoinQuery) {
+      visit((ToChildBlockJoinQuery) query);
+    }
+
+    else {
+      visitTerminalOrUnknown(query);
+    }
+
+  }
+  /**
+   * A terminal/leaf query (not a query that aggregates over another) or something custom that Lucene doesn't know
+   * about.
+      Position insensitive, term oriented:
+        TermQuery, SynonymQuery, CommonTermsQuery, TermInSetQuery.  Plus MultiTermQuery (with derivatives)
+      Position sensitive, term oriented:
+        PhraseQuery, MultiPhraseQuery, SpanTermQuery
+      Misc:
+        MatchAllDocsQuery, MatchNoDocsQuery
+        And exotic (e.g. spatial)
+   */
+  public void visitTerminalOrUnknown(Query query) {
+  }
+
+//TODO discuss if we need these extracted methods that can be overridden. Otherwise we inline and subclassers
+//  override visit()
+
+  // Aggregate queries:
+
+  public void visit(BooleanQuery query) {
+    for (BooleanClause clause : query) {
+      if (!skipNegative || !clause.isProhibited()) {
+        // check stopSignal?
+        visit(clause.getQuery());
+      }
+    }
+  }
+
+  public void visit(DisjunctionMaxQuery query) {
+    for (Query clause : query) {
+      // check stopSignal?
+      visit(clause);
+    }
+  }
+
+  // Span queries:
+
+  public void visit(SpanQuery query) {
+    if (stopSignal) {
+      //return;
+    } else if (query instanceof SpanNearQuery) {
+      visit((SpanNearQuery) query);
+    } else if (query instanceof SpanOrQuery) {
+      visit((SpanOrQuery) query);
+    } else if (query instanceof SpanNotQuery) {
+      visit((SpanNotQuery) query);
+    } else if (query instanceof SpanPositionCheckQuery) {
+      visit((SpanPositionCheckQuery) query);
+    } else if (query instanceof SpanBoostQuery) {
+      visit((SpanBoostQuery) query);
+    } else if (query instanceof FieldMaskingSpanQuery) {
+      visit((FieldMaskingSpanQuery) query);
+    } else if (query instanceof SpanMultiTermQueryWrapper) {
+      visit((SpanMultiTermQueryWrapper) query);
+    } else {
+      visitTerminalOrUnknown(query); //ex: SpanTermQuery
+    }
+  }
+
+  public void visit(SpanNearQuery query) {
+    for (SpanQuery clause : query.getClauses()) {
+      // check stopSignal?
+      visit(clause);
+    }
+  }
+
+  public void visit(SpanOrQuery query) {
+    for (SpanQuery clause : query.getClauses()) {
+      // check stopSignal?
+      visit(clause);
+    }
+  }
+
+  public void visit(SpanNotQuery query) {
+    visit(query.getInclude());
+    if (!skipNegative) {
+      visit(query.getExclude());
+    }
+  }
+
+  public void visit(SpanPositionCheckQuery query) {
+    visit(query.getMatch());
+  }
+
+  public void visit(SpanBoostQuery query) {
+    visit(query.getQuery());
+  }
+
+  public void visit(FieldMaskingSpanQuery query) {
+    visit(query.getMaskedQuery());
+  }
+
+  public void visit(SpanMultiTermQueryWrapper query) {
+    visit(query.getWrappedQuery());
+  }
+
+
+  // Wrapper queries:
+
+  public void visit(BoostQuery query) {
+    visit(query.getQuery());
+  }
+
+  public void visit(FunctionScoreQuery query) {
+    visit(query.getWrappedQuery());
+  }
+
+  public void visit(ConstantScoreQuery query) {
+    visit(query.getQuery());
+  }
+
+  public void visit(ToParentBlockJoinQuery query) {
+    visit(query.getChildQuery());
+  }
+
+  public void visit(ToChildBlockJoinQuery query) {
+    visit(query.getParentQuery());
+  }
+}
Index: lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/SpanQueryConverter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/SpanQueryConverter.java	(date 1517864027000)
+++ lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/SpanQueryConverter.java	(date 1517864027000)
@@ -0,0 +1,128 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.search.uhighlight;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.spans.SpanNearQuery;
+import org.apache.lucene.search.spans.SpanOrQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanTermQuery;
+
+/**
+ * Converts some queries into a {@link SpanQuery}.
+ * Can be subclasses to customize {@link #convert(Term)}, e.g. to change the field name or wrap it.
+ *
+ * @lucene.experimental
+ */
+public class SpanQueryConverter {
+
+  public static SpanQueryConverter DEFAULT = new SpanQueryConverter();
+
+  protected SpanQueryConverter() {
+  }
+
+  public SpanTermQuery convert(Term term) {
+    return new SpanTermQuery(term);
+  }
+
+  public SpanQuery convert(PhraseQuery phraseQuery) {
+    //TODO call SpanNearQuery.Builder.addGap for precise gap handling
+    Term[] phraseQueryTerms = phraseQuery.getTerms();
+    if (phraseQueryTerms.length == 1) {
+      return convert(phraseQueryTerms[0]);
+    } else {
+      SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];
+      for (int i = 0; i < phraseQueryTerms.length; i++) {
+        clauses[i] = convert(phraseQueryTerms[i]);
+      }
+
+      // sum position increments beyond 1
+      int positionGaps = 0;
+      int[] positions = phraseQuery.getPositions();
+      if (positions.length >= 2) {
+        // positions are in increasing order.   max(0,...) is just a safeguard.
+        positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1);
+      }
+
+      //if original slop is 0 then require inOrder
+      boolean inorder = (phraseQuery.getSlop() == 0);
+
+      return new SpanNearQuery(clauses, phraseQuery.getSlop() + positionGaps, inorder);
+    }
+  }
+
+  public SpanQuery convert(MultiPhraseQuery mpq) {
+    //TODO call SpanNearQuery.Builder.addGap for precise gap handling
+    final Term[][] termArrays = mpq.getTermArrays();
+    final int[] positions = mpq.getPositions();
+    if (positions.length <= 0) {
+      // TODO why is this even possible?  What other Span type could we return?
+      return new SpanNearQuery(new SpanQuery[0], 0, true);
+    }
+
+    int maxPosition = positions[positions.length - 1];
+    for (int i = 0; i < positions.length - 1; ++i) {
+      if (positions[i] > maxPosition) {
+        maxPosition = positions[i];
+      }
+    }
+
+    @SuppressWarnings({"unchecked","rawtypes"})
+    final List<SpanQuery>[] disjunctLists = new List[maxPosition + 1];
+    int distinctPositions = 0;
+
+    for (int i = 0; i < termArrays.length; ++i) {
+      final Term[] termArray = termArrays[i];
+      List<SpanQuery> disjuncts = disjunctLists[positions[i]];
+      if (disjuncts == null) {
+        disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(termArray.length));
+        ++distinctPositions;
+      }
+      for (Term aTermArray : termArray) {
+        disjuncts.add(convert(aTermArray));
+      }
+    }
+
+    int positionGaps = 0;
+    int position = 0;
+    final SpanQuery[] clauses = new SpanQuery[distinctPositions];
+    for (List<SpanQuery> disjuncts : disjunctLists) {
+      if (disjuncts != null) {
+        clauses[position++] = new SpanOrQuery(disjuncts
+            .toArray(new SpanQuery[disjuncts.size()]));
+      } else {
+        ++positionGaps;
+      }
+    }
+
+    if (clauses.length == 1) {
+      return clauses[0];
+    } else {
+      final int slop = mpq.getSlop();
+      final boolean inorder = (slop == 0);
+
+      return new SpanNearQuery(clauses, slop + positionGaps, inorder);
+    }
+  }
+
+}
Index: lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/TokenStreamOffsetStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/TokenStreamOffsetStrategy.java	(revision ce5932fc373ebfa6718af8f317b36bf33896a59e)
+++ lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/TokenStreamOffsetStrategy.java	(date 1517604722000)
@@ -42,6 +42,8 @@
   }
 
   private static CharacterRunAutomaton[] convertTermsToAutomata(BytesRef[] terms, CharacterRunAutomaton[] automata) {
+    //TODO union the Automata (as is done in MemoryIndexOffsetStrategy). But we need to ensure
+    //  that getTerm below returns the matching term; so perhaps add a special case and remember to clone
     CharacterRunAutomaton[] newAutomata = new CharacterRunAutomaton[terms.length + automata.length];
     for (int i = 0; i < terms.length; i++) {
       String termString = terms[i].utf8ToString();
