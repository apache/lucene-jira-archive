diff --git a/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java b/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
new file mode 100644
index 00000000000..46c70127938
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
@@ -0,0 +1,352 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import org.apache.lucene.document.LongPoint;
+import org.apache.lucene.document.SortedNumericDocValuesField;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.PointValues;
+import org.apache.lucene.index.SortedNumericDocValues;
+import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.NumericDocValues;
+import org.apache.lucene.util.ArrayUtil;
+
+import java.io.IOException;
+import java.util.Objects;
+
+public abstract class NumericRangeQuery extends Query{
+
+    final String field;
+    final long lowerValue;
+    final long upperValue;
+    final Query indexOrDvQuery;
+
+    protected NumericRangeQuery(String field, long lowerValue, long upperValue) {
+        this.field = Objects.requireNonNull(field);
+        this.lowerValue = lowerValue;
+        this.upperValue = upperValue;
+        this.indexOrDvQuery = new IndexOrDocValuesQuery(LongPoint.newRangeQuery(field, lowerValue, upperValue),
+                SortedNumericDocValuesField.newSlowRangeQuery(field, lowerValue, upperValue));
+    }
+
+    @Override
+    public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {
+        final Weight indexOrDvWeight = indexOrDvQuery.createWeight(searcher, scoreMode, boost);
+        return new ConstantScoreWeight(this, boost) {
+
+            @Override
+            public Matches matches(LeafReaderContext context, int doc) throws IOException {
+                return indexOrDvWeight.matches(context, doc);
+            }
+
+            @Override
+            public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+                return indexOrDvWeight.explain(context, doc);
+            }
+
+            public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {
+                return super.bulkScorer(context);
+            }
+
+            @Override
+            public int count(LeafReaderContext context) throws IOException {
+                return indexOrDvWeight.count(context);
+            }
+
+            private final ArrayUtil.ByteArrayComparator comparator = ArrayUtil.getUnsignedComparator(Long.BYTES);
+
+            @Override
+            public Scorer scorer(LeafReaderContext context) throws IOException {
+                ScorerSupplier scorerSupplier = scorerSupplier(context);
+                if (scorerSupplier == null) {
+                    return null;
+                }
+                return scorerSupplier.get(Long.MAX_VALUE);
+            }
+
+            @Override
+            public boolean isCacheable(LeafReaderContext ctx) {
+                return indexOrDvWeight.isCacheable(ctx);
+            }
+
+            @Override
+            public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {
+                LeafReader reader = context.reader();
+
+                // try to get ScorerSupplier by point index
+                PointValues values = reader.getPointValues(field);
+                if (checkValidPointValues(values) == false) {
+                    return null;
+                }
+                boolean allDocsMatch = false;
+                if (values.getDocCount() == reader.maxDoc()) {
+                    final byte[] fieldPackedLower = values.getMinPackedValue();
+                    final byte[] fieldPackedUpper = values.getMaxPackedValue();
+                    if (comparator.compare(LongPoint.pack(lowerValue).bytes, 0, fieldPackedLower, 0) <= 0
+                            && comparator.compare(LongPoint.pack(upperValue).bytes, 0, fieldPackedUpper, 0) >= 0) {
+                        allDocsMatch = true;
+                    }
+                }
+                final Weight weight = this;
+                if (allDocsMatch) {
+                    // all docs have a value and all points are within bounds, so everything matches
+                    return new ScorerSupplier() {
+                        @Override
+                        public Scorer get(long leadCost) {
+                            return new ConstantScoreScorer(
+                                    weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));
+                        }
+
+                        @Override
+                        public long cost() {
+                            return reader.maxDoc();
+                        }
+                    };
+                }
+
+                // try to get ScorerSupplier base on index sort
+                DocIdSetIterator disi = getDocIdSetIteratorOrNull(context);
+                if (disi != null) {
+                    return new ScorerSupplier() {
+                        @Override
+                        public Scorer get(long leadCost) throws IOException {
+                            return new ConstantScoreScorer(
+                                    weight, score(), scoreMode, disi);
+                        }
+
+                        @Override
+                        public long cost() {
+                            return disi.cost();
+                        }
+                    };
+                }
+
+                // otherwise get ScorerSupplier by IndexOrDocValuesQuery
+                return indexOrDvWeight.scorerSupplier(context);
+            }
+        };
+    }
+
+    @Override
+    public Query rewrite(IndexReader reader) throws IOException {
+        Query indexOrDvRewrite = indexOrDvQuery.rewrite(reader);
+        if(indexOrDvRewrite.getClass() == MatchAllDocsQuery.class){
+            return new MatchAllDocsQuery();
+        }
+        return this;
+    }
+
+    @Override
+    public String toString(String field) {
+        // temp implementation
+        return "numericQuery";
+    }
+
+    @Override
+    public void visit(QueryVisitor visitor) {
+        // temp implementation
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (sameClassAs(obj) == false) {
+            return false;
+        }
+        NumericRangeQuery that = (NumericRangeQuery) obj;
+        return indexOrDvQuery.equals(that.indexOrDvQuery);
+    }
+
+    @Override
+    public int hashCode() {
+        // temp implementation
+        int h = classHash();
+        h = 31 * h + indexOrDvQuery.hashCode();
+        return h;
+    }
+
+    private boolean checkValidPointValues(PointValues values) throws IOException {
+        if (values == null) {
+            // No docs in this segment/field indexed any points
+            return false;
+        }
+
+        if (values.getNumIndexDimensions() != 1) {
+            throw new IllegalArgumentException(
+                    "field=\""
+                            + field
+                            + "\" was indexed with numIndexDimensions="
+                            + values.getNumIndexDimensions()
+                            + " but this query has numDims="
+                            + 1);
+        }
+        if (Long.BYTES != values.getBytesPerDimension()) {
+            throw new IllegalArgumentException(
+                    "field=\""
+                            + field
+                            + "\" was indexed with bytesPerDim="
+                            + values.getBytesPerDimension()
+                            + " but this query has bytesPerDim="
+                            + Long.BYTES);
+        }
+        return true;
+    }
+
+    private BoundedDocSetIdIterator getDocIdSetIteratorOrNull(LeafReaderContext context)
+            throws IOException {
+        SortedNumericDocValues sortedNumericValues =
+                DocValues.getSortedNumeric(context.reader(), field);
+        NumericDocValues numericValues = DocValues.unwrapSingleton(sortedNumericValues);
+        if (numericValues != null) {
+            Sort indexSort = context.reader().getMetaData().getSort();
+            if (indexSort != null
+                    && indexSort.getSort().length > 0
+                    && indexSort.getSort()[0].getField().equals(field)) {
+
+                SortField sortField = indexSort.getSort()[0];
+                return getDocIdSetIterator(sortField, context, numericValues);
+            }
+        }
+        return null;
+    }
+
+    /**
+     * A doc ID set iterator that wraps a delegate iterator and only returns doc IDs in the range
+     * [firstDocInclusive, lastDoc).
+     */
+    private static class BoundedDocSetIdIterator extends DocIdSetIterator {
+        private final int firstDoc;
+        private final int lastDoc;
+        private final DocIdSetIterator delegate;
+
+        private int docID = -1;
+
+        BoundedDocSetIdIterator(int firstDoc, int lastDoc, DocIdSetIterator delegate) {
+            this.firstDoc = firstDoc;
+            this.lastDoc = lastDoc;
+            this.delegate = delegate;
+        }
+
+        @Override
+        public int docID() {
+            return docID;
+        }
+
+        @Override
+        public int nextDoc() throws IOException {
+            return advance(docID + 1);
+        }
+
+        @Override
+        public int advance(int target) throws IOException {
+            if (target < firstDoc) {
+                target = firstDoc;
+            }
+
+            int result = delegate.advance(target);
+            if (result < lastDoc) {
+                docID = result;
+            } else {
+                docID = NO_MORE_DOCS;
+            }
+            return docID;
+        }
+
+        @Override
+        public long cost() {
+            return lastDoc - firstDoc;
+        }
+    }
+
+    /**
+     * Computes the document IDs that lie within the range [lowerValue, upperValue] by performing
+     * binary search on the field's doc values.
+     *
+     * <p>Because doc values only allow forward iteration, we need to reload the field comparator
+     * every time the binary search accesses an earlier element.
+     *
+     * <p>We must also account for missing values when performing the binary search. For this reason,
+     * we load the {@link FieldComparator} instead of checking the docvalues directly. The returned
+     * {@link DocIdSetIterator} makes sure to wrap the original docvalues to skip over documents with
+     * no value.
+     */
+    private BoundedDocSetIdIterator getDocIdSetIterator(
+            SortField sortField, LeafReaderContext context, DocIdSetIterator delegate)
+            throws IOException {
+        long lower = sortField.getReverse() ? upperValue : lowerValue;
+        long upper = sortField.getReverse() ? lowerValue : upperValue;
+        int maxDoc = context.reader().maxDoc();
+
+        // Perform a binary search to find the first document with value >= lower.
+        ValueComparator comparator = loadComparator(sortField, lower, context);
+        int low = 0;
+        int high = maxDoc - 1;
+
+        while (low <= high) {
+            int mid = (low + high) >>> 1;
+            if (comparator.compare(mid) <= 0) {
+                high = mid - 1;
+                comparator = loadComparator(sortField, lower, context);
+            } else {
+                low = mid + 1;
+            }
+        }
+        int firstDocIdInclusive = high + 1;
+
+        // Perform a binary search to find the first document with value > upper.
+        // Since we know that upper >= lower, we can initialize the lower bound
+        // of the binary search to the result of the previous search.
+        comparator = loadComparator(sortField, upper, context);
+        low = firstDocIdInclusive;
+        high = maxDoc - 1;
+
+        while (low <= high) {
+            int mid = (low + high) >>> 1;
+            if (comparator.compare(mid) < 0) {
+                high = mid - 1;
+                comparator = loadComparator(sortField, upper, context);
+            } else {
+                low = mid + 1;
+            }
+        }
+
+        int lastDocIdExclusive = high + 1;
+        return new BoundedDocSetIdIterator(firstDocIdInclusive, lastDocIdExclusive, delegate);
+    }
+
+    private static ValueComparator loadComparator(
+            SortField sortField, long topValue, LeafReaderContext context) throws IOException {
+        @SuppressWarnings("unchecked")
+        FieldComparator<Long> fieldComparator =
+                (FieldComparator<Long>) sortField.getComparator(1, false);
+        fieldComparator.setTopValue(topValue);
+
+        LeafFieldComparator leafFieldComparator = fieldComparator.getLeafComparator(context);
+        int direction = sortField.getReverse() ? -1 : 1;
+
+        return doc -> {
+            int value = leafFieldComparator.compareTop(doc);
+            return direction * value;
+        };
+    }
+
+    /** Compares the given document's value with a stored reference value. */
+    private interface ValueComparator {
+        int compare(int docID) throws IOException;
+    }
+}
