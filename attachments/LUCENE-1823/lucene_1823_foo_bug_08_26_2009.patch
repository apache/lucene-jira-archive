Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java	(revision 808150)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java	(working copy)
@@ -17,6 +17,33 @@
  * limitations under the License.
  */
 
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Vector;
+import org.apache.lucene.messages.Message;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryParser.core.QueryNodeError;
+import org.apache.lucene.queryParser.core.QueryNodeException;
+import org.apache.lucene.queryParser.core.QueryNodeParseException;
+import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
+import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
+import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
+import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
+import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
+import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ProximityQueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
+import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
+import org.apache.lucene.queryParser.core.parser.SyntaxParser;
 
 /** Token Manager. */
 public class StandardSyntaxParserTokenManager implements StandardSyntaxParserConstants
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java	(revision 808150)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java	(working copy)
@@ -1,99 +1,96 @@
 /* Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 */
 /* JavaCCOptions:KEEP_LINE_COL=null */
 package org.apache.lucene.queryParser.standard.parser;
+    
+    import org.apache.lucene.messages.Message;
+    import org.apache.lucene.messages.MessageImpl;
+    import org.apache.lucene.queryParser.core.*;
+    import org.apache.lucene.queryParser.core.messages.*;
 
 /**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * This exception is thrown when parse errors are encountered.
+ * You can explicitly create objects of this exception type by
+ * calling the method generateParseException in the generated
+ * parser.
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * You can modify this class to customize your error reporting
+ * mechanisms so long as you retain the public fields.
  */
-import org.apache.lucene.messages.Message;
-import org.apache.lucene.messages.MessageImpl;
-import org.apache.lucene.queryParser.core.QueryNodeParseException;
-import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
-
-/**
- * This exception is thrown when parse errors are encountered. You can
- * explicitly create objects of this exception type by calling the method
- * generateParseException in the generated parser.
- * 
- * You can modify this class to customize your error reporting mechanisms so
- * long as you retain the public fields.
- */
 public class ParseException extends QueryNodeParseException {
 
   /**
-   * The version identifier for this Serializable class. Increment only if the
-   * <i>serialized</i> form of the class changes.
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
    */
   private static final long serialVersionUID = 1L;
 
   /**
-   * This constructor is used by the method "generateParseException" in the
-   * generated parser. Calling this constructor generates a new object of this
-   * type with the fields "currentToken", "expectedTokenSequences", and
-   * "tokenImage" set.
+   * This constructor is used by the method "generateParseException"
+   * in the generated parser.  Calling this constructor generates
+   * a new object of this type with the fields "currentToken",
+   * "expectedTokenSequences", and "tokenImage" set.
    */
   public ParseException(Token currentTokenVal,
-      int[][] expectedTokenSequencesVal, String[] tokenImageVal) {
-    super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, initialise(
-        currentTokenVal, expectedTokenSequencesVal, tokenImageVal)));
-    this.currentToken = currentTokenVal;
-    this.expectedTokenSequences = expectedTokenSequencesVal;
-    this.tokenImage = tokenImageVal;
-  }
+            int[][] expectedTokenSequencesVal, String[] tokenImageVal) {
+        super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, initialise(
+          currentTokenVal, expectedTokenSequencesVal, tokenImageVal)));
+        this.currentToken = currentTokenVal;
+        this.expectedTokenSequences = expectedTokenSequencesVal;
+        this.tokenImage = tokenImageVal;
+      }
 
-  public ParseException(Message message) {
-    super(message);
-  }
+  /**
+   * The following constructors are for use by you for whatever
+   * purpose you can think of.  Constructing the exception in this
+   * manner makes the exception behave in the normal way - i.e., as
+   * documented in the class "Throwable".  The fields "errorToken",
+   * "expectedTokenSequences", and "tokenImage" do not contain
+   * relevant information.  The JavaCC generated code does not use
+   * these constructors.
+   */
 
   public ParseException() {
-    super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, "Error"));
-  }
+        super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, "Error"));
+      }
 
+  /** Constructor with message. */
+  public ParseException(Message message) {
+        super(message);
+                            }
+
+
   /**
-   * This is the last token that has been consumed successfully. If this object
-   * has been created due to a parse error, the token followng this token will
-   * (therefore) be the first error token.
+   * This is the last token that has been consumed successfully.  If
+   * this object has been created due to a parse error, the token
+   * followng this token will (therefore) be the first error token.
    */
-  @SuppressWarnings("unused")
-  private Token currentToken;
+  public Token currentToken;
 
   /**
-   * Each entry in this array is an array of integers. Each array of integers
-   * represents a sequence of tokens (by their ordinal values) that is expected
-   * at this point of the parse.
+   * Each entry in this array is an array of integers.  Each array
+   * of integers represents a sequence of tokens (by their ordinal
+   * values) that is expected at this point of the parse.
    */
-  @SuppressWarnings("unused")
-  private int[][] expectedTokenSequences;
+  public int[][] expectedTokenSequences;
 
   /**
-   * This is a reference to the "tokenImage" array of the generated parser
-   * within which the parse error occurred. This array is defined in the
-   * generated ...Constants interface.
+   * This is a reference to the "tokenImage" array of the generated
+   * parser within which the parse error occurred.  This array is
+   * defined in the generated ...Constants interface.
    */
-  @SuppressWarnings("unused")
-  private String[] tokenImage;
+  public String[] tokenImage;
 
   /**
    * It uses "currentToken" and "expectedTokenSequences" to generate a parse
-   * error message and returns it. If this object has been created due to a
-   * parse error, and you do not catch it (it gets thrown from the parser) the
-   * correct error message gets displayed.
+   * error message and returns it.  If this object has been created
+   * due to a parse error, and you do not catch it (it gets thrown
+   * from the parser) the correct error message
+   * gets displayed.
    */
   private static String initialise(Token currentToken,
-      int[][] expectedTokenSequences, String[] tokenImage) {
+                           int[][] expectedTokenSequences,
+                           String[] tokenImage) {
     String eol = System.getProperty("line.separator", "\n");
     StringBuffer expected = new StringBuffer();
     int maxSize = 0;
@@ -112,8 +109,7 @@
     String retval = "Encountered \"";
     Token tok = currentToken.next;
     for (int i = 0; i < maxSize; i++) {
-      if (i != 0)
-        retval += " ";
+      if (i != 0) retval += " ";
       if (tok.kind == 0) {
         retval += tokenImage[0];
         break;
@@ -124,8 +120,7 @@
       retval += " \"";
       tok = tok.next;
     }
-    retval += "\" at line " + currentToken.next.beginLine + ", column "
-        + currentToken.next.beginColumn;
+    retval += "\" at line " + currentToken.next.beginLine + ", column " + currentToken.next.beginColumn;
     retval += "." + eol;
     if (expectedTokenSequences.length == 1) {
       retval += "Was expecting:" + eol + "    ";
@@ -139,59 +134,57 @@
   /**
    * The end of line string for this machine.
    */
-  @SuppressWarnings("unused")
-  private String eol = System.getProperty("line.separator", "\n");
+  protected String eol = System.getProperty("line.separator", "\n");
 
   /**
-   * Used to convert raw characters to their escaped version when these raw
-   * version cannot be used as part of an ASCII string literal.
+   * Used to convert raw characters to their escaped version
+   * when these raw version cannot be used as part of an ASCII
+   * string literal.
    */
-  static private String add_escapes(String str) {
-    StringBuffer retval = new StringBuffer();
-    char ch;
-    for (int i = 0; i < str.length(); i++) {
-      switch (str.charAt(i)) {
-      case 0:
-        continue;
-      case '\b':
-        retval.append("\\b");
-        continue;
-      case '\t':
-        retval.append("\\t");
-        continue;
-      case '\n':
-        retval.append("\\n");
-        continue;
-      case '\f':
-        retval.append("\\f");
-        continue;
-      case '\r':
-        retval.append("\\r");
-        continue;
-      case '\"':
-        retval.append("\\\"");
-        continue;
-      case '\'':
-        retval.append("\\\'");
-        continue;
-      case '\\':
-        retval.append("\\\\");
-        continue;
-      default:
-        if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
-          String s = "0000" + Integer.toString(ch, 16);
-          retval.append("\\u" + s.substring(s.length() - 4, s.length()));
-        } else {
-          retval.append(ch);
+  static String add_escapes(String str) {
+      StringBuffer retval = new StringBuffer();
+      char ch;
+      for (int i = 0; i < str.length(); i++) {
+        switch (str.charAt(i))
+        {
+           case 0 :
+              continue;
+           case '\b':
+              retval.append("\\b");
+              continue;
+           case '\t':
+              retval.append("\\t");
+              continue;
+           case '\n':
+              retval.append("\\n");
+              continue;
+           case '\f':
+              retval.append("\\f");
+              continue;
+           case '\r':
+              retval.append("\\r");
+              continue;
+           case '\"':
+              retval.append("\\\"");
+              continue;
+           case '\'':
+              retval.append("\\\'");
+              continue;
+           case '\\':
+              retval.append("\\\\");
+              continue;
+           default:
+              if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+                 String s = "0000" + Integer.toString(ch, 16);
+                 retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+              } else {
+                 retval.append(ch);
+              }
+              continue;
         }
-        continue;
       }
-    }
-    return retval.toString();
-  }
+      return retval.toString();
+   }
 
 }
-/*
- * JavaCC - StandardChecksum=c04ac45b94787832e67e6d1b49d8774c (do not edit this
- * line)
- */
+/* JavaCC - OriginalChecksum=7e503f917ca24b733f5420d53a6a3d5e (do not edit this line) */
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java	(revision 808150)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java	(working copy)
@@ -414,6 +414,34 @@
         "+(title:dog title:cat) -author:\"bob dole\"");
 
   }
+  
+  public void testFuzzy() throws Exception {
+    
+    assertQueryEquals("foo~0.5", null, "foo~0.5");
+	  assertQueryEquals("foo~0.4453", null, "foo~0.4453");
+	  assertQueryEquals("foo~0", null, "foo~0.0");
+	  assertQueryEquals("foo~0.0", null, "foo~0.0");
+	  
+	  // tests min similarity
+	  FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
+    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+    fq = (FuzzyQuery) getQuery("term~", null);
+    assertEquals(0.5f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+	  
+	  // should ignore the fuzzy value when it's equals or greater than 1
+	  assertQueryEquals("foo~1.0", null, "foo");
+	  assertQueryEquals("foo~1.1", null, "foo");
+	  
+	  // should return TermQuery if fuzzy value is greater or equals 1
+	  assertTrue(getQuery("foo~1", null) instanceof TermQuery);
+	  assertTrue(getQuery("foo~1.1", null) instanceof TermQuery);
+	  assertTrue(getQuery("foo~0.5", null) instanceof FuzzyQuery);
+	  assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
+    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
+	  	  
+  }
 
   public void testPunct() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
@@ -457,17 +485,6 @@
 
     assertTrue(getQuery("term*", null) instanceof PrefixQuery);
     assertTrue(getQuery("term*^2", null) instanceof PrefixQuery);
-    assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
-    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
-    FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
-    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
-    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-    fq = (FuzzyQuery) getQuery("term~", null);
-    assertEquals(0.5f, fq.getMinSimilarity(), 0.1f);
-    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-
-    assertQueryNodeException("term~1.1"); // value > 1, throws exception
-
     assertTrue(getQuery("term*germ", null) instanceof WildcardQuery);
 
     /*
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java	(revision 808150)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java	(working copy)
@@ -19,10 +19,14 @@
  */
 
 import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Vector;
 
 import org.apache.lucene.messages.Message;
 import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryParser.core.QueryNodeError;
+import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.QueryNodeParseException;
 import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
 import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
@@ -30,14 +34,17 @@
 import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
 import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
 import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
 import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
-import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
 import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
+import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ProximityQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
 import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
 import org.apache.lucene.queryParser.core.parser.SyntaxParser;
 
 @SuppressWarnings("all")
@@ -417,10 +424,16 @@
           try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
           } catch (Exception ignored) { }
-         if(fms < 0.0f || fms > 1.0f){
+         if(fms < 0.0f){
            {if (true) throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));}
+
+         } else if (fms >= 1.0f) {
+                q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
+
+         } else {
+                q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
          }
-         q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
+
        }
       break;
     case RANGEIN_START:
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj	(revision 808150)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj	(working copy)
@@ -392,10 +392,16 @@
        	  try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
        	  } catch (Exception ignored) { }
-       	 if(fms < 0.0f || fms > 1.0f){
+       	 if(fms < 0.0f){
        	   throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));
+       	   
+       	 } else if (fms >= 1.0f) {
+       	 	q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
+       	 
+       	 } else {
+       	 	q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
        	 }
-       	 q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
+       	 
        }
      }
      | ( <RANGEIN_START> ( goop1=<RANGEIN_GOOP>|goop1=<RANGEIN_QUOTED> )
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java	(revision 808150)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java	(working copy)
@@ -410,6 +410,34 @@
     qp.setDefaultOperator(QueryParserWrapper.OR_OPERATOR);
     assertEquals(QueryParserWrapper.OR_OPERATOR, qp.getDefaultOperator());
   }
+  
+public void testFuzzy() throws Exception {
+    
+    assertQueryEquals("foo~0.5", null, "foo~0.5");
+    assertQueryEquals("foo~0.4453", null, "foo~0.4453");
+    assertQueryEquals("foo~0", null, "foo~0.0");
+    assertQueryEquals("foo~0.0", null, "foo~0.0");
+    
+    // tests min similarity
+    FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
+    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+    fq = (FuzzyQuery) getQuery("term~", null);
+    assertEquals(0.5f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+    
+    // should ignore the fuzzy value when it's equals or greater than 1
+    assertQueryEquals("foo~1.0", null, "foo");
+    assertQueryEquals("foo~1.1", null, "foo");
+    
+    // should return TermQuery if fuzzy value is greater or equals 1
+    assertTrue(getQuery("foo~1", null) instanceof TermQuery);
+    assertTrue(getQuery("foo~1.1", null) instanceof TermQuery);
+    assertTrue(getQuery("foo~0.5", null) instanceof FuzzyQuery);
+    assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
+    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
+        
+  }
 
   public void testPunct() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
@@ -453,17 +481,6 @@
 
     assertTrue(getQuery("term*", null) instanceof PrefixQuery);
     assertTrue(getQuery("term*^2", null) instanceof PrefixQuery);
-    assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
-    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
-    FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
-    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
-    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-    fq = (FuzzyQuery) getQuery("term~", null);
-    assertEquals(0.5f, fq.getMinSimilarity(), 0.1f);
-    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-
-    assertParseException("term~1.1"); // value > 1, throws exception
-
     assertTrue(getQuery("term*germ", null) instanceof WildcardQuery);
 
     /*
