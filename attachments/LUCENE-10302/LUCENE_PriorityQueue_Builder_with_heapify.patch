Index: lucene/core/src/java/org/apache/lucene/util/PriorityQueue.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lucene/core/src/java/org/apache/lucene/util/PriorityQueue.java b/lucene/core/src/java/org/apache/lucene/util/PriorityQueue.java
--- a/lucene/core/src/java/org/apache/lucene/util/PriorityQueue.java	
+++ b/lucene/core/src/java/org/apache/lucene/util/PriorityQueue.java	
@@ -16,7 +16,10 @@
  */
 package org.apache.lucene.util;
 
+import java.util.Arrays;
+import java.util.Comparator;
 import java.util.Iterator;
+import java.util.List;
 import java.util.NoSuchElementException;
 import java.util.function.Supplier;
 
@@ -33,6 +36,93 @@
  * @lucene.internal
  */
 public abstract class PriorityQueue<T> implements Iterable<T> {
+
+  public static class Builder<T> {
+
+    private final Comparator<T> comparator;
+    private final int maxSize;
+
+    private T[] arr; // null at element 0
+    private int arrSize;
+    private PriorityQueue<T> queue;
+
+    public Builder(int maxSize, Comparator<T> comparator) {
+      this.maxSize = maxSize;
+      this.comparator = comparator;
+
+      final int heapSize;
+
+      if (0 == maxSize) {
+        // We allocate 1 extra to avoid if statement in top()
+        heapSize = 2;
+      } else {
+        if ((maxSize < 0) || (maxSize >= ArrayUtil.MAX_ARRAY_LENGTH)) {
+          // Throw exception to prevent confusing OOME:
+          throw new IllegalArgumentException(
+              "maxSize must be >= 0 and < " + (ArrayUtil.MAX_ARRAY_LENGTH) + "; got: " + maxSize);
+        }
+
+        // NOTE: we add +1 because all access to heap is
+        // 1-based not 0-based.  heap[0] is unused.
+        heapSize = maxSize + 1;
+      }
+
+      // T is an unbounded type, so this unchecked cast works always.
+      @SuppressWarnings("unchecked")
+      final T[] h = (T[]) new Object[heapSize];
+      this.arr = h;
+    }
+
+    public T insertWithOverflow(T obj) { // or rename add() because the other add may go away?
+      if (queue != null) {
+        return queue.insertWithOverflow(obj);
+      } else if (arrSize < maxSize) {
+        arr[++arrSize] = obj; // increment arrSize first because arr is 1-based.
+        return null;
+      } else {
+        queue = newQueue();
+        arr = null; // signify consumed
+        return queue.insertWithOverflow(obj);
+      }
+    }
+
+    private PriorityQueue<T> newQueue() {
+      // TODO heapify
+      // https://www.geeksforgeeks.org/building-heap-from-array/
+      return new PriorityQueue<T>(this) { // nocommit todo
+        @Override
+        protected boolean lessThan(T a, T b) {
+          return comparator.compare(a, b) < 0;
+        }
+      };
+    }
+
+    public PriorityQueue<T> buildQueue() {
+      return queue != null ? queue : newQueue();
+    }
+
+    @SuppressWarnings("unchecked")
+    public List<T> buildList() { // or buildCollection() since order is undefined?
+      if (queue != null) {
+        return Arrays.asList((T[]) queue.getHeapArray()).subList(1, queue.size + 1);
+      } else {
+        return Arrays.asList(arr).subList(1, arrSize + 1);
+      }
+    }
+
+    public List<T> buildSortedList() {
+      var list = buildList();
+      list.sort(comparator); // TODO it'd be faster to sort the underlying array before
+      return list;
+    }
+
+    // I assume we don't need a buildIterator and sorted variant because it'd be just as fast
+    // to get the List first
+
+  }
+
+  //
+
   private int size = 0;
   private final int maxSize;
   private final T[] heap;
