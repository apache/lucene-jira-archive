Index: lucene/join/src/java/org/apache/lucene/search/join/GlobalOrdinalsWithScoreCollector.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/GlobalOrdinalsWithScoreCollector.java	(revision 1677347)
+++ lucene/join/src/java/org/apache/lucene/search/join/GlobalOrdinalsWithScoreCollector.java	(revision )
@@ -33,24 +33,49 @@
 abstract class GlobalOrdinalsWithScoreCollector implements Collector {
 
   final String field;
+  final boolean doMinMax;
+  final int min;
+  final int max;
   final MultiDocValues.OrdinalMap ordinalMap;
   final LongBitSet collectedOrds;
+
   protected final Scores scores;
+  protected final Occurrences occurrences;
 
-  GlobalOrdinalsWithScoreCollector(String field, MultiDocValues.OrdinalMap ordinalMap, long valueCount) {
+  GlobalOrdinalsWithScoreCollector(String field, MultiDocValues.OrdinalMap ordinalMap, long valueCount, ScoreMode scoreMode, Integer min, Integer max) {
     if (valueCount > Integer.MAX_VALUE) {
       // We simply don't support more than
       throw new IllegalStateException("Can't collect more than [" + Integer.MAX_VALUE + "] ids");
     }
     this.field = field;
+    this.doMinMax = min != null || max != null;
+    this.min = min == null ? 0 : min;
+    this.max = max == null ? Integer.MAX_VALUE : max;;
     this.ordinalMap = ordinalMap;
     this.collectedOrds = new LongBitSet(valueCount);
+    if (scoreMode != ScoreMode.None) {
-    this.scores = new Scores(valueCount, unset());
+      this.scores = new Scores(valueCount, unset());
+    } else {
+      this.scores = null;
-  }
+    }
+    if (scoreMode == ScoreMode.Avg || doMinMax) {
+      this.occurrences = new Occurrences(valueCount);
+    } else {
+      this.occurrences = null;
+    }
+  }
 
-  public LongBitSet getCollectorOrdinals() {
-    return collectedOrds;
+  public boolean match(int globalOrd) {
+    if (collectedOrds.get(globalOrd)) {
+      if (doMinMax) {
+        final int occurrence = occurrences.getOccurrence(globalOrd);
+        return occurrence >= min && occurrence <= max;
+      } else {
+        return true;
-  }
+      }
+    }
+    return false;
+  }
 
   public float score(int globalOrdinal) {
     return scores.getScore(globalOrdinal);
@@ -96,8 +121,11 @@
         float existingScore = scores.getScore(globalOrd);
         float newScore = scorer.score();
         doScore(globalOrd, existingScore, newScore);
+        if (occurrences != null) {
+          occurrences.increment(globalOrd);
-      }
-    }
+        }
+      }
+    }
 
     @Override
     public void setScorer(Scorer scorer) throws IOException {
@@ -122,8 +150,11 @@
         float existingScore = scores.getScore(segmentOrd);
         float newScore = scorer.score();
         doScore(segmentOrd, existingScore, newScore);
+        if (occurrences != null) {
+          occurrences.increment(segmentOrd);
-      }
-    }
+        }
+      }
+    }
 
     @Override
     public void setScorer(Scorer scorer) throws IOException {
@@ -133,8 +164,8 @@
 
   static final class Min extends GlobalOrdinalsWithScoreCollector {
 
-    public Min(String field, MultiDocValues.OrdinalMap ordinalMap, long valueCount) {
-      super(field, ordinalMap, valueCount);
+    public Min(String field, MultiDocValues.OrdinalMap ordinalMap, long valueCount, Integer min, Integer max) {
+      super(field, ordinalMap, valueCount, ScoreMode.Min, min, max);
     }
 
     @Override
@@ -150,8 +181,8 @@
 
   static final class Max extends GlobalOrdinalsWithScoreCollector {
 
-    public Max(String field, MultiDocValues.OrdinalMap ordinalMap, long valueCount) {
-      super(field, ordinalMap, valueCount);
+    public Max(String field, MultiDocValues.OrdinalMap ordinalMap, long valueCount, Integer min, Integer max) {
+      super(field, ordinalMap, valueCount, ScoreMode.Max, min, max);
     }
 
     @Override
@@ -167,8 +198,8 @@
 
   static final class Sum extends GlobalOrdinalsWithScoreCollector {
 
-    public Sum(String field, MultiDocValues.OrdinalMap ordinalMap, long valueCount) {
-      super(field, ordinalMap, valueCount);
+    public Sum(String field, MultiDocValues.OrdinalMap ordinalMap, long valueCount, Integer min, Integer max) {
+      super(field, ordinalMap, valueCount, ScoreMode.Total, min, max);
     }
 
     @Override
@@ -184,16 +215,12 @@
 
   static final class Avg extends GlobalOrdinalsWithScoreCollector {
 
-    private final Occurrences occurrences;
-
-    public Avg(String field, MultiDocValues.OrdinalMap ordinalMap, long valueCount) {
-      super(field, ordinalMap, valueCount);
-      this.occurrences = new Occurrences(valueCount);
+    public Avg(String field, MultiDocValues.OrdinalMap ordinalMap, long valueCount, Integer min, Integer max) {
+      super(field, ordinalMap, valueCount, ScoreMode.Avg, min, max);
     }
 
     @Override
     protected void doScore(int globalOrd, float existingScore, float newScore) {
-      occurrences.increment(globalOrd);
       scores.setScore(globalOrd, existingScore + newScore);
     }
 
@@ -205,6 +232,71 @@
     @Override
     protected float unset() {
       return 0f;
+    }
+  }
+
+  static final class NoScore extends GlobalOrdinalsWithScoreCollector {
+
+    public NoScore(String field, MultiDocValues.OrdinalMap ordinalMap, long valueCount, Integer min, Integer max) {
+      super(field, ordinalMap, valueCount, ScoreMode.None, min, max);
+    }
+
+    @Override
+    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {
+      SortedDocValues docTermOrds = DocValues.getSorted(context.reader(), field);
+      if (ordinalMap != null) {
+        LongValues segmentOrdToGlobalOrdLookup = ordinalMap.getGlobalOrds(context.ord);
+        return new LeafCollector() {
+
+          @Override
+          public void setScorer(Scorer scorer) throws IOException {
+          }
+
+          @Override
+          public void collect(int doc) throws IOException {
+            final long segmentOrd = docTermOrds.getOrd(doc);
+            if (segmentOrd != -1) {
+              final int globalOrd = (int) segmentOrdToGlobalOrdLookup.get(segmentOrd);
+              collectedOrds.set(globalOrd);
+              occurrences.increment(globalOrd);
+            }
+          }
+        };
+      } else {
+        return new LeafCollector() {
+          @Override
+          public void setScorer(Scorer scorer) throws IOException {
+          }
+
+          @Override
+          public void collect(int doc) throws IOException {
+            final int segmentOrd = docTermOrds.getOrd(doc);
+            if (segmentOrd != -1) {
+              collectedOrds.set(segmentOrd);
+              occurrences.increment(segmentOrd);
+            }
+          }
+        };
+      }
+    }
+
+    @Override
+    protected void doScore(int globalOrd, float existingScore, float newScore) {
+    }
+
+    @Override
+    public float score(int globalOrdinal) {
+      return 1f;
+    }
+
+    @Override
+    protected float unset() {
+      return 0f;
+    }
+
+    @Override
+    public boolean needsScores() {
+      return false;
     }
   }
 
Index: lucene/join/src/java/org/apache/lucene/search/join/BaseGlobalOrdinalScorer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/BaseGlobalOrdinalScorer.java	(revision 1677347)
+++ lucene/join/src/java/org/apache/lucene/search/join/BaseGlobalOrdinalScorer.java	(revision )
@@ -28,15 +28,13 @@
 
 abstract class BaseGlobalOrdinalScorer extends Scorer {
 
-  final LongBitSet foundOrds;
   final SortedDocValues values;
   final Scorer approximationScorer;
 
   float score;
 
-  public BaseGlobalOrdinalScorer(Weight weight, LongBitSet foundOrds, SortedDocValues values, Scorer approximationScorer) {
+  public BaseGlobalOrdinalScorer(Weight weight, SortedDocValues values, Scorer approximationScorer) {
     super(weight);
-    this.foundOrds = foundOrds;
     this.values = values;
     this.approximationScorer = approximationScorer;
   }
\ No newline at end of file
Index: lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java	(revision 1677347)
+++ lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java	(revision )
@@ -61,6 +61,7 @@
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.TopScoreDocCollector;
+import org.apache.lucene.search.TotalHitCountCollector;
 import org.apache.lucene.search.Weight;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BitSet;
@@ -261,14 +262,14 @@
     Query toQuery = new TermQuery(new Term(typeField, "price"));
     Query fromQuery = new TermQuery(new Term("name", "name2"));
     // Search for product and return prices
-    Query joinQuery = JoinUtil.createJoinQuery(joinField, fromQuery, toQuery, indexSearcher, ScoreMode.None, ordinalMap);
+    Query joinQuery = JoinUtil.createJoinQuery(joinField, fromQuery, toQuery, indexSearcher, ScoreMode.None, ordinalMap, null, null);
     TopDocs result = indexSearcher.search(joinQuery, 10);
     assertEquals(2, result.totalHits);
     assertEquals(4, result.scoreDocs[0].doc);
     assertEquals(5, result.scoreDocs[1].doc);
 
     fromQuery = new TermQuery(new Term("name", "name1"));
-    joinQuery = JoinUtil.createJoinQuery(joinField, fromQuery, toQuery, indexSearcher, ScoreMode.None, ordinalMap);
+    joinQuery = JoinUtil.createJoinQuery(joinField, fromQuery, toQuery, indexSearcher, ScoreMode.None, ordinalMap, null, null);
     result = indexSearcher.search(joinQuery, 10);
     assertEquals(2, result.totalHits);
     assertEquals(1, result.scoreDocs[0].doc);
@@ -277,7 +278,7 @@
     // Search for prices and return products
     fromQuery = new TermQuery(new Term("price", "20.0"));
     toQuery = new TermQuery(new Term(typeField, "product"));
-    joinQuery = JoinUtil.createJoinQuery(joinField, fromQuery, toQuery, indexSearcher, ScoreMode.None, ordinalMap);
+    joinQuery = JoinUtil.createJoinQuery(joinField, fromQuery, toQuery, indexSearcher, ScoreMode.None, ordinalMap, null, null);
     result = indexSearcher.search(joinQuery, 10);
     assertEquals(2, result.totalHits);
     assertEquals(0, result.scoreDocs[0].doc);
@@ -315,13 +316,13 @@
         fromQuery.add(new TermQuery(new Term("type", "from")), BooleanClause.Occur.FILTER);
         fromQuery.add(actualQuery, BooleanClause.Occur.MUST);
         Query toQuery = new TermQuery(new Term("type", "to"));
-        joinQuery = JoinUtil.createJoinQuery("join_field", fromQuery, toQuery, indexSearcher, scoreMode, context.ordinalMap);
+        joinQuery = JoinUtil.createJoinQuery("join_field", fromQuery, toQuery, indexSearcher, scoreMode, context.ordinalMap, null, null);
       } else {
         BooleanQuery fromQuery = new BooleanQuery();
         fromQuery.add(new TermQuery(new Term("type", "to")), BooleanClause.Occur.FILTER);
         fromQuery.add(actualQuery, BooleanClause.Occur.MUST);
         Query toQuery = new TermQuery(new Term("type", "from"));
-        joinQuery = JoinUtil.createJoinQuery("join_field", fromQuery, toQuery, indexSearcher, scoreMode, context.ordinalMap);
+        joinQuery = JoinUtil.createJoinQuery("join_field", fromQuery, toQuery, indexSearcher, scoreMode, context.ordinalMap, null, null);
       }
       if (VERBOSE) {
         System.out.println("joinQuery=" + joinQuery);
@@ -412,7 +413,7 @@
         String childId = Integer.toString(p + c);
         Document childDoc = new Document();
         childDoc.add(new StringField("id", childId, Field.Store.YES));
-        parentDoc.add(new StringField("type", "from", Field.Store.NO));
+        childDoc.add(new StringField("type", "from", Field.Store.NO));
         childDoc.add(new SortedDocValuesField("join_field", new BytesRef(parentId)));
         int price = random().nextInt(1000);
         childDoc.add(new NumericDocValuesField(priceField, price));
@@ -437,7 +438,7 @@
     BooleanQuery fromQuery = new BooleanQuery();
     fromQuery.add(priceQuery, BooleanClause.Occur.MUST);
     Query toQuery = new TermQuery(new Term("type", "to"));
-    Query joinQuery = JoinUtil.createJoinQuery("join_field", fromQuery, toQuery, searcher, ScoreMode.Min, ordinalMap);
+    Query joinQuery = JoinUtil.createJoinQuery("join_field", fromQuery, toQuery, searcher, ScoreMode.Min, ordinalMap, null, null);
     TopDocs topDocs = searcher.search(joinQuery, numParents);
     assertEquals(numParents, topDocs.totalHits);
     for (int i = 0; i < topDocs.scoreDocs.length; i++) {
@@ -446,13 +447,83 @@
       assertEquals(lowestScoresPerParent.get(id), scoreDoc.score, 0f);
     }
 
-    joinQuery = JoinUtil.createJoinQuery("join_field", fromQuery, toQuery, searcher, ScoreMode.Max, ordinalMap);
+    joinQuery = JoinUtil.createJoinQuery("join_field", fromQuery, toQuery, searcher, ScoreMode.Max, ordinalMap, null, null);
     topDocs = searcher.search(joinQuery, numParents);
     assertEquals(numParents, topDocs.totalHits);
     for (int i = 0; i < topDocs.scoreDocs.length; i++) {
       ScoreDoc scoreDoc = topDocs.scoreDocs[i];
       String id = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader()).document(scoreDoc.doc).get("id");
       assertEquals(highestScoresPerParent.get(id), scoreDoc.score, 0f);
+    }
+
+    searcher.getIndexReader().close();
+    dir.close();
+  }
+
+  public void testMinMaxDocs() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter iw = new RandomIndexWriter(
+        random(),
+        dir,
+        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.KEYWORD, false))
+    );
+
+    int minChildDocsPerParent = 2;
+    int maxChildDocsPerParent = 16;
+    int numParents = RandomInts.randomIntBetween(random(), 16, 64);
+    int[] childDocsPerParent = new int[numParents];
+    for (int p = 0; p < numParents; p++) {
+      String parentId = Integer.toString(p);
+      Document parentDoc = new Document();
+      parentDoc.add(new StringField("id", parentId, Field.Store.YES));
+      parentDoc.add(new StringField("type", "to", Field.Store.NO));
+      parentDoc.add(new SortedDocValuesField("join_field", new BytesRef(parentId)));
+      iw.addDocument(parentDoc);
+      int numChildren = RandomInts.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent);
+      childDocsPerParent[p] = numChildren;
+      for (int c = 0; c < numChildren; c++) {
+        String childId = Integer.toString(p + c);
+        Document childDoc = new Document();
+        childDoc.add(new StringField("id", childId, Field.Store.YES));
+        childDoc.add(new StringField("type", "from", Field.Store.NO));
+        childDoc.add(new SortedDocValuesField("join_field", new BytesRef(parentId)));
+        iw.addDocument(childDoc);
+      }
+    }
+    iw.close();
+
+    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(dir));
+    SortedDocValues[] values = new SortedDocValues[searcher.getIndexReader().leaves().size()];
+    for (LeafReaderContext leadContext : searcher.getIndexReader().leaves()) {
+      values[leadContext.ord] = DocValues.getSorted(leadContext.reader(), "join_field");
+    }
+    MultiDocValues.OrdinalMap ordinalMap = MultiDocValues.OrdinalMap.build(
+        searcher.getIndexReader().getCoreCacheKey(), values, PackedInts.DEFAULT
+    );
+    Query fromQuery = new TermQuery(new Term("type", "from"));
+    Query toQuery = new TermQuery(new Term("type", "to"));
+
+    int iters = RandomInts.randomIntBetween(random(), 3, 9);
+    for (int i = 1; i <= iters; i++) {
+      final ScoreMode scoreMode = ScoreMode.values()[random().nextInt(ScoreMode.values().length)];
+      int min = RandomInts.randomIntBetween(random(), minChildDocsPerParent, maxChildDocsPerParent - 1);
+      int max = RandomInts.randomIntBetween(random(), min, maxChildDocsPerParent);
+      if (VERBOSE) {
+        System.out.println("iter=" + i);
+        System.out.println("scoreMode=" + scoreMode);
+        System.out.println("min=" + min);
+        System.out.println("max=" + max);
+      }
+      Query joinQuery = JoinUtil.createJoinQuery("join_field", fromQuery, toQuery, searcher, scoreMode, ordinalMap, min, max);
+      TotalHitCountCollector collector = new TotalHitCountCollector();
+      searcher.search(joinQuery, collector);
+      int expectedCount = 0;
+      for (int numChildDocs : childDocsPerParent) {
+        if (numChildDocs >= min && numChildDocs <= max) {
+          expectedCount++;
+        }
+      }
+      assertEquals(expectedCount, collector.getTotalHits());
     }
 
     searcher.getIndexReader().close();
Index: lucene/join/src/java/org/apache/lucene/search/join/GlobalOrdinalsQuery.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/GlobalOrdinalsQuery.java	(revision 1677347)
+++ lucene/join/src/java/org/apache/lucene/search/join/GlobalOrdinalsQuery.java	(revision )
@@ -160,11 +160,13 @@
 
   final static class OrdinalMapScorer extends BaseGlobalOrdinalScorer {
 
+    final LongBitSet foundOrds;
     final LongValues segmentOrdToGlobalOrdLookup;
 
     public OrdinalMapScorer(Weight weight, float score, LongBitSet foundOrds, SortedDocValues values, Scorer approximationScorer, LongValues segmentOrdToGlobalOrdLookup) {
-      super(weight, foundOrds, values, approximationScorer);
+      super(weight, values, approximationScorer);
       this.score = score;
+      this.foundOrds = foundOrds;
       this.segmentOrdToGlobalOrdLookup = segmentOrdToGlobalOrdLookup;
     }
 
@@ -203,9 +205,12 @@
 
   final static class SegmentOrdinalScorer extends BaseGlobalOrdinalScorer {
 
+    final LongBitSet foundOrds;
+
     public SegmentOrdinalScorer(Weight weight, float score, LongBitSet foundOrds, SortedDocValues values, Scorer approximationScorer) {
-      super(weight, foundOrds, values, approximationScorer);
+      super(weight, values, approximationScorer);
       this.score = score;
+      this.foundOrds = foundOrds;
     }
 
     @Override
Index: lucene/join/src/java/org/apache/lucene/search/join/GlobalOrdinalsWithScoreQuery.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/GlobalOrdinalsWithScoreQuery.java	(revision 1677347)
+++ lucene/join/src/java/org/apache/lucene/search/join/GlobalOrdinalsWithScoreQuery.java	(revision )
@@ -17,9 +17,6 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.Set;
-
 import org.apache.lucene.index.DocValues;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
@@ -37,6 +34,9 @@
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LongValues;
 
+import java.io.IOException;
+import java.util.Set;
+
 final class GlobalOrdinalsWithScoreQuery extends Query {
 
   private final GlobalOrdinalsWithScoreCollector collector;
@@ -47,14 +47,18 @@
 
   // just for hashcode and equals:
   private final Query fromQuery;
+  private final Integer min;
+  private final Integer max;
   private final IndexReader indexReader;
 
-  GlobalOrdinalsWithScoreQuery(GlobalOrdinalsWithScoreCollector collector, String joinField, MultiDocValues.OrdinalMap globalOrds, Query toQuery, Query fromQuery, IndexReader indexReader) {
+  GlobalOrdinalsWithScoreQuery(GlobalOrdinalsWithScoreCollector collector, String joinField, MultiDocValues.OrdinalMap globalOrds, Query toQuery, Query fromQuery, Integer min, Integer max, IndexReader indexReader) {
     this.collector = collector;
     this.joinField = joinField;
     this.globalOrds = globalOrds;
     this.toQuery = toQuery;
     this.fromQuery = fromQuery;
+    this.min = min;
+    this.max = max;
     this.indexReader = indexReader;
   }
 
@@ -71,12 +75,13 @@
 
     GlobalOrdinalsWithScoreQuery that = (GlobalOrdinalsWithScoreQuery) o;
 
-    if (!fromQuery.equals(that.fromQuery)) return false;
     if (!joinField.equals(that.joinField)) return false;
     if (!toQuery.equals(that.toQuery)) return false;
-    if (!indexReader.equals(that.indexReader)) return false;
+    if (!fromQuery.equals(that.fromQuery)) return false;
+    if (min != null ? !min.equals(that.min) : that.min != null) return false;
+    if (max != null ? !max.equals(that.max) : that.max != null) return false;
+    return indexReader.equals(that.indexReader);
 
-    return true;
   }
 
   @Override
@@ -85,6 +90,8 @@
     result = 31 * result + joinField.hashCode();
     result = 31 * result + toQuery.hashCode();
     result = 31 * result + fromQuery.hashCode();
+    result = 31 * result + (min != null ? min.hashCode() : 0);
+    result = 31 * result + (max != null ? max.hashCode() : 0);
     result = 31 * result + indexReader.hashCode();
     return result;
   }
@@ -168,7 +175,7 @@
     final GlobalOrdinalsWithScoreCollector collector;
 
     public OrdinalMapScorer(Weight weight, GlobalOrdinalsWithScoreCollector collector, SortedDocValues values, Scorer approximationScorer, LongValues segmentOrdToGlobalOrdLookup) {
-      super(weight, collector.getCollectorOrdinals(), values, approximationScorer);
+      super(weight, values, approximationScorer);
       this.segmentOrdToGlobalOrdLookup = segmentOrdToGlobalOrdLookup;
       this.collector = collector;
     }
@@ -178,9 +185,9 @@
       for (int docID = approximationScorer.advance(target); docID < NO_MORE_DOCS; docID = approximationScorer.nextDoc()) {
         final long segmentOrd = values.getOrd(docID);
         if (segmentOrd != -1) {
-          final long globalOrd = segmentOrdToGlobalOrdLookup.get(segmentOrd);
-          if (foundOrds.get(globalOrd)) {
-            score = collector.score((int) globalOrd);
+          final int globalOrd = (int) segmentOrdToGlobalOrdLookup.get(segmentOrd);
+          if (collector.match(globalOrd)) {
+            score = collector.score(globalOrd);
             return docID;
           }
         }
@@ -196,9 +203,9 @@
         public boolean matches() throws IOException {
           final long segmentOrd = values.getOrd(approximationScorer.docID());
           if (segmentOrd != -1) {
-            final long globalOrd = segmentOrdToGlobalOrdLookup.get(segmentOrd);
-            if (foundOrds.get(globalOrd)) {
-              score = collector.score((int) globalOrd);
+            final int globalOrd = (int) segmentOrdToGlobalOrdLookup.get(segmentOrd);
+            if (collector.match(globalOrd)) {
+              score = collector.score(globalOrd);
               return true;
             }
           }
@@ -214,7 +221,7 @@
     final GlobalOrdinalsWithScoreCollector collector;
 
     public SegmentOrdinalScorer(Weight weight, GlobalOrdinalsWithScoreCollector collector, SortedDocValues values, Scorer approximationScorer) {
-      super(weight, collector.getCollectorOrdinals(), values, approximationScorer);
+      super(weight, values, approximationScorer);
       this.collector = collector;
     }
 
@@ -223,7 +230,7 @@
       for (int docID = approximationScorer.advance(target); docID < NO_MORE_DOCS; docID = approximationScorer.nextDoc()) {
         final int segmentOrd = values.getOrd(docID);
         if (segmentOrd != -1) {
-          if (foundOrds.get(segmentOrd)) {
+          if (collector.match(segmentOrd)) {
             score = collector.score(segmentOrd);
             return docID;
           }
@@ -240,7 +247,7 @@
         public boolean matches() throws IOException {
           final int segmentOrd = values.getOrd(approximationScorer.docID());
           if (segmentOrd != -1) {
-            if (foundOrds.get(segmentOrd)) {
+            if (collector.match(segmentOrd)) {
               score = collector.score(segmentOrd);
               return true;
             }
Index: lucene/join/src/java/org/apache/lucene/search/join/JoinUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/JoinUtil.java	(revision 1677347)
+++ lucene/join/src/java/org/apache/lucene/search/join/JoinUtil.java	(revision )
@@ -107,13 +107,17 @@
    *    should store the join values as UTF-8 strings.
    * 4) An ordinal map must be provided that is created on top of the join field.
    *
-   * @param joinField   The {@link org.apache.lucene.index.SortedDocValues} field containing the join values
+   * @param joinField   The {@link SortedDocValues} field containing the join values
    * @param fromQuery   The query containing the actual user query. Also the fromQuery can only match "from" documents.
    * @param toQuery     The query identifying all documents on the "to" side.
    * @param searcher    The index searcher used to execute the from query
    * @param scoreMode   Instructs how scores from the fromQuery are mapped to the returned query
    * @param ordinalMap  The ordinal map constructed over the joinField. In case of a single segment index, no ordinal map
    *                    needs to be provided.
+   * @param min         Optionally the minimum number of "from" documents that are required to match for a "to" document
+   *                    to be a match or <code>null</code> can be specified.
+   * @param max         Optionally the maximum number of "from" documents that are allowed to match for a "to" document
+   *                    to be a match or <code>null</code> can be specified.
    * @return a {@link Query} instance that can be used to join documents based on the join field
    * @throws IOException If I/O related errors occur
    */
@@ -122,7 +126,9 @@
                                       Query toQuery,
                                       IndexSearcher searcher,
                                       ScoreMode scoreMode,
-                                      MultiDocValues.OrdinalMap ordinalMap) throws IOException {
+                                      MultiDocValues.OrdinalMap ordinalMap,
+                                      Integer min,
+                                      Integer max) throws IOException {
     IndexReader indexReader = searcher.getIndexReader();
     int numSegments = indexReader.leaves().size();
     final long valueCount;
@@ -146,7 +152,7 @@
     }
 
     final Query rewrittenFromQuery = searcher.rewrite(fromQuery);
-    if (scoreMode == ScoreMode.None) {
+    if (scoreMode == ScoreMode.None && min == null && max == null) {
       GlobalOrdinalsCollector globalOrdinalsCollector = new GlobalOrdinalsCollector(joinField, ordinalMap, valueCount);
       searcher.search(rewrittenFromQuery, globalOrdinalsCollector);
       return new GlobalOrdinalsQuery(globalOrdinalsCollector.getCollectorOrdinals(), joinField, ordinalMap, toQuery, rewrittenFromQuery, indexReader);
@@ -155,22 +161,26 @@
     GlobalOrdinalsWithScoreCollector globalOrdinalsWithScoreCollector;
     switch (scoreMode) {
       case Total:
-        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount);
+        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Sum(joinField, ordinalMap, valueCount, min, max);
         break;
       case Min:
-        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount);
+        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Min(joinField, ordinalMap, valueCount, min, max);
         break;
       case Max:
-        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount);
+        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Max(joinField, ordinalMap, valueCount, min, max);
         break;
       case Avg:
-        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount);
+        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.Avg(joinField, ordinalMap, valueCount, min, max);
         break;
+      case None:
+        // only used if min / max has been defined:
+        globalOrdinalsWithScoreCollector = new GlobalOrdinalsWithScoreCollector.NoScore(joinField, ordinalMap, valueCount, min, max);
+        break;
       default:
         throw new IllegalArgumentException(String.format(Locale.ROOT, "Score mode %s isn't supported.", scoreMode));
     }
     searcher.search(rewrittenFromQuery, globalOrdinalsWithScoreCollector);
-    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, toQuery, rewrittenFromQuery, indexReader);
+    return new GlobalOrdinalsWithScoreQuery(globalOrdinalsWithScoreCollector, joinField, ordinalMap, toQuery, rewrittenFromQuery, min, max, indexReader);
   }
 
 }
