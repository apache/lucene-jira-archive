Index: lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java	(working copy)
@@ -19,8 +19,6 @@
 
 import java.io.IOException;
 
-import org.apache.lucene.search.spans.Spans;
-
 /**
  * This abstract class defines methods to iterate over a set of non-decreasing
  * doc ids. Note that this class assumes it iterates on doc Ids, and therefore
Index: lucene/core/src/java/org/apache/lucene/search/TwoPhaseIterator.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/TwoPhaseIterator.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/TwoPhaseIterator.java	(working copy)
@@ -20,11 +20,8 @@
 import java.io.IOException;
 import java.util.Objects;
 
-import org.apache.lucene.search.spans.Spans;
-
 /**
  * Returned by {@link Scorer#asTwoPhaseIterator()}
- * and  {@link Spans#asTwoPhaseIterator()}
  * to expose an approximation of a {@link DocIdSetIterator}.
  * When the {@link #approximation()}'s
  * {@link DocIdSetIterator#nextDoc()} or {@link DocIdSetIterator#advance(int)}
@@ -100,8 +97,6 @@
   public static TwoPhaseIterator asTwoPhaseIterator(DocIdSetIterator iter) {
     return (iter instanceof Scorer)
             ? ((Scorer) iter).asTwoPhaseIterator()
-            : (iter instanceof Spans)
-            ? ((Spans) iter).asTwoPhaseIterator()
             : null;
   }
 
Index: lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java	(working copy)
@@ -23,21 +23,23 @@
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.ConjunctionDISI;
 import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.similarities.Similarity;
 
 /**
  * Common super class for multiple sub spans required in a document.
  */
-abstract class ConjunctionSpans extends Spans {
-  final Spans[] subSpans; // in query order
+abstract class ConjunctionSpans extends SpanScorer {
+  final SpanScorer[] subSpans; // in query order
   final DocIdSetIterator conjunction; // use to move to next doc with all clauses
   boolean atFirstInCurrentDoc; // a first start position is available in current doc for nextStartPosition
   boolean oneExhaustedInCurrentDoc; // one subspans exhausted in current doc
 
-  ConjunctionSpans(List<Spans> subSpans) {
+  ConjunctionSpans(List<SpanScorer> subSpans, SpanWeight weight, Similarity.SimScorer docScorer) {
+    super(weight, docScorer);
     if (subSpans.size() < 2) {
       throw new IllegalArgumentException("Less than 2 subSpans.size():" + subSpans.size());
     }
-    this.subSpans = subSpans.toArray(new Spans[subSpans.size()]);
+    this.subSpans = subSpans.toArray(new SpanScorer[subSpans.size()]);
     this.conjunction = ConjunctionDISI.intersect(subSpans);
     this.atFirstInCurrentDoc = true; // ensure for doc -1 that start/end positions are -1
   }
@@ -96,7 +98,7 @@
     return res;
   }
 
-  public Spans[] getSubSpans() {
+  public SpanScorer[] getSubSpans() {
     return subSpans;
   }
 }
Index: lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java	(working copy)
@@ -21,13 +21,15 @@
 import java.util.Arrays;
 import java.util.Objects;
 
+import org.apache.lucene.search.similarities.Similarity;
+
 abstract class ContainSpans extends ConjunctionSpans {
-  Spans sourceSpans;
-  Spans bigSpans;
-  Spans littleSpans;
+  SpanScorer sourceSpans;
+  SpanScorer bigSpans;
+  SpanScorer littleSpans;
 
-  ContainSpans(Spans bigSpans, Spans littleSpans, Spans sourceSpans) {
-    super(Arrays.asList(bigSpans, littleSpans));
+  ContainSpans(SpanWeight weight, Similarity.SimScorer simScorer, SpanScorer bigSpans, SpanScorer littleSpans, SpanScorer sourceSpans) {
+    super(Arrays.asList(bigSpans, littleSpans), weight, simScorer);
     this.bigSpans = Objects.requireNonNull(bigSpans);
     this.littleSpans = Objects.requireNonNull(littleSpans);
     this.sourceSpans = Objects.requireNonNull(sourceSpans);
Index: lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java	(working copy)
@@ -21,21 +21,23 @@
 import java.util.Objects;
 
 import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.similarities.Similarity;
 
 /**
- * A {@link Spans} implementation wrapping another spans instance,
+ * A {@link SpanScorer} implementation wrapping another spans instance,
  * allowing to filter spans matches easily by implementing {@link #accept}
  */
-public abstract class FilterSpans extends Spans {
+public abstract class FilterSpans extends SpanScorer {
  
   /** The wrapped spans instance. */
-  protected final Spans in;
+  protected final SpanScorer in;
   
   private boolean atFirstInCurrentDoc = false;
   private int startPos = -1;
   
-  /** Wrap the given {@link Spans}. */
-  protected FilterSpans(Spans in) {
+  /** Wrap the given {@link SpanScorer}. */
+  protected FilterSpans(SpanScorer in, Similarity.SimScorer docScorer) {
+    super((SpanWeight)in.getWeight(), docScorer);
     this.in = Objects.requireNonNull(in);
   }
   
@@ -44,7 +46,7 @@
    * NO if it should not, and NO_MORE_IN_CURRENT_DOC if iteration
    * should move on to the next document.
    */
-  protected abstract AcceptStatus accept(Spans candidate) throws IOException;
+  protected abstract AcceptStatus accept(SpanScorer candidate) throws IOException;
   
   @Override
   public final int nextDoc() throws IOException {
@@ -181,9 +183,9 @@
       }
     }
   }
-  
+
   /**
-   * Status returned from {@link FilterSpans#accept(Spans)} that indicates
+   * Status returned from {@link FilterSpans#accept(SpanScorer)} that indicates
    * whether a candidate match should be accepted, rejected, or rejected
    * and move on to the next document.
    */
Index: lucene/core/src/java/org/apache/lucene/search/spans/NearSpans.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/NearSpans.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/NearSpans.java	(working copy)
@@ -1,34 +0,0 @@
-package org.apache.lucene.search.spans;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.List;
-
-/**
- * Common super class for un/ordered Spans with a maximum slop between them.
- */
-abstract class NearSpans extends ConjunctionSpans {
-  final SpanNearQuery query;
-  final int allowedSlop;
-
-  NearSpans(SpanNearQuery query, List<Spans> subSpans) {
-    super(subSpans);
-    this.query = query;
-    this.allowedSlop = query.getSlop();
-  }
-}
Index: lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java	(working copy)
@@ -20,14 +20,16 @@
 import java.io.IOException;
 import java.util.List;
 
+import org.apache.lucene.search.similarities.Similarity;
+
 /**
- * A Spans that is formed from the ordered subspans of a SpanNearQuery
+ * A SpanScorer that is formed from the ordered subspans of a SpanNearQuery
  * where the subspans do not overlap and have a maximum slop between them.
  * <p>
  * The formed spans only contains minimum slop matches.<br>
  * The matching slop is computed from the distance(s) between
- * the non overlapping matching Spans.<br>
- * Successive matches are always formed from the successive Spans
+ * the non overlapping matching SpanScorer.<br>
+ * Successive matches are always formed from the successive SpanScorer
  * of the SpanNearQuery.
  * <p>
  * The formed spans may contain overlaps when the slop is at least 1.
@@ -42,15 +44,18 @@
  * Expert:
  * Only public for subclassing.  Most implementations should not need this class
  */
-public class NearSpansOrdered extends NearSpans {
+public class NearSpansOrdered extends ConjunctionSpans {
 
   protected int matchStart = -1;
   protected int matchEnd = -1;
   protected int matchWidth = -1;
 
-  public NearSpansOrdered(SpanNearQuery query, List<Spans> subSpans) throws IOException {
-    super(query, subSpans);
+  private final int allowedSlop;
+
+  public NearSpansOrdered(SpanWeight weight, int allowedSlop, List<SpanScorer> subSpans, Similarity.SimScorer simScorer) throws IOException {
+    super(subSpans, weight, simScorer);
     this.atFirstInCurrentDoc = true; // -1 startPosition/endPosition also at doc -1
+    this.allowedSlop = allowedSlop;
   }
 
   @Override
@@ -66,7 +71,7 @@
   }
 
   private boolean unpositioned() {
-    for (Spans span : subSpans) {
+    for (SpanScorer span : subSpans) {
       if (span.startPosition() != -1)
         return false;
     }
@@ -95,13 +100,13 @@
    * otherwise at least one is exhausted in the current doc.
    */
   private boolean stretchToOrder() throws IOException {
-    Spans prevSpans = subSpans[0];
+    SpanScorer prevSpans = subSpans[0];
     matchStart = prevSpans.startPosition();
     assert prevSpans.startPosition() != NO_MORE_POSITIONS : "prevSpans no start position "+prevSpans;
     assert prevSpans.endPosition() != NO_MORE_POSITIONS;
     matchWidth = 0;
     for (int i = 1; i < subSpans.length; i++) {
-      Spans spans = subSpans[i];
+      SpanScorer spans = subSpans[i];
       assert spans.startPosition() != NO_MORE_POSITIONS;
       assert spans.endPosition() != NO_MORE_POSITIONS;
       if (advancePosition(spans, prevSpans.endPosition()) == NO_MORE_POSITIONS) {
@@ -115,9 +120,9 @@
     return true; // all subSpans ordered and non overlapping
   }
 
-  private static int advancePosition(Spans spans, int position) throws IOException {
-    if (spans instanceof SpanNearQuery.GapSpans) {
-      return ((SpanNearQuery.GapSpans)spans).skipToPosition(position);
+  private static int advancePosition(SpanScorer spans, int position) throws IOException {
+    if (spans instanceof SpanNearQuery.GapSpanScorer) {
+      return ((SpanNearQuery.GapSpanScorer)spans).skipToPosition(position);
     }
     while (spans.startPosition() < position) {
       spans.nextStartPosition();
@@ -142,7 +147,7 @@
 
   @Override
   public void collect(SpanCollector collector) throws IOException {
-    for (Spans span : subSpans) {
+    for (SpanScorer span : subSpans) {
       span.collect(collector);
     }
   }
@@ -149,7 +154,7 @@
 
   @Override
   public String toString() {
-    return "NearSpansOrdered("+query.toString()+")@"+docID()+": "+startPosition()+" - "+endPosition();
+    return "NearSpansOrdered("+weight.getQuery().toString()+")@"+docID()+": "+startPosition()+" - "+endPosition();
   }
 
 }
Index: lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(working copy)
@@ -17,13 +17,14 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.search.TwoPhaseIterator;
-import org.apache.lucene.util.PriorityQueue;
-
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.List;
 
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.util.PriorityQueue;
+
 /**
  * Similar to {@link NearSpansOrdered}, but for the unordered case.
  *
@@ -30,22 +31,24 @@
  * Expert:
  * Only public for subclassing.  Most implementations should not need this class
  */
-public class NearSpansUnordered extends NearSpans {
+public class NearSpansUnordered extends ConjunctionSpans {
 
-  private List<SpansCell> subSpanCells; // in query order
+  private List<SpanScorerCell> subSpanCells; // in query order
+  private final int allowedSlop;
 
   private SpanPositionQueue spanPositionQueue;
 
-  public NearSpansUnordered(SpanNearQuery query, List<Spans> subSpans)
+  public NearSpansUnordered(SpanWeight weight, int allowedSlop, List<SpanScorer> subSpans, Similarity.SimScorer simScorer)
   throws IOException {
-    super(query, subSpans);
+    super(subSpans, weight, simScorer);
 
     this.subSpanCells = new ArrayList<>(subSpans.size());
-    for (Spans subSpan : subSpans) { // sub spans in query order
-      this.subSpanCells.add(new SpansCell(subSpan));
+    for (SpanScorer subSpan : subSpans) { // sub spans in query order
+      this.subSpanCells.add(new SpanScorerCell(subSpan));
     }
     spanPositionQueue = new SpanPositionQueue(subSpans.size());
     singleCellToPositionQueue(); // -1 startPosition/endPosition also at doc -1
+    this.allowedSlop = allowedSlop;
   }
 
   private void singleCellToPositionQueue() {
@@ -57,7 +60,7 @@
 
   private void subSpanCellsToPositionQueue() throws IOException { // used when all subSpanCells arrived at the same doc.
     spanPositionQueue.clear();
-    for (SpansCell cell : subSpanCells) {
+    for (SpanScorerCell cell : subSpanCells) {
       assert cell.startPosition() == -1;
       cell.nextStartPosition();
       assert cell.startPosition() != NO_MORE_POSITIONS;
@@ -65,15 +68,16 @@
     }
   }
 
-  /** SpansCell wraps a sub Spans to maintain totalSpanLength and maxEndPositionCell */
+  /** SpanScorerCell wraps a sub SpanScorer to maintain totalSpanLength and maxEndPositionCell */
   private int totalSpanLength;
-  private SpansCell maxEndPositionCell;
+  private SpanScorerCell maxEndPositionCell;
 
-  private class SpansCell extends Spans {
+  private class SpanScorerCell extends SpanScorer {
     private int spanLength = -1;
-    final Spans in;
+    final SpanScorer in;
 
-    public SpansCell(Spans spans) {
+    public SpanScorerCell(SpanScorer spans) {
+      super((SpanWeight) NearSpansUnordered.this.weight, NearSpansUnordered.this.docScorer);
       this.in = spans;
     }
 
@@ -151,28 +155,28 @@
 
     @Override
     public String toString() {
-      return "NearSpansUnordered.SpansCell(" + in.toString() + ")";
+      return "NearSpansUnordered.SpanScorerCell(" + in.toString() + ")";
     }
   }
 
 
-  private static class SpanPositionQueue extends PriorityQueue<SpansCell> {
+  private static class SpanPositionQueue extends PriorityQueue<SpanScorerCell> {
     public SpanPositionQueue(int size) {
       super(size);
     }
 
     @Override
-    protected final boolean lessThan(SpansCell spans1, SpansCell spans2) {
+    protected final boolean lessThan(SpanScorerCell spans1, SpanScorerCell spans2) {
       return positionsOrdered(spans1, spans2);
     }
   }
 
-  /** Check whether two Spans in the same document are ordered with possible overlap.
+  /** Check whether two SpanScorer in the same document are ordered with possible overlap.
    * @return true iff spans1 starts before spans2
    *              or the spans start at the same position,
    *              and spans1 ends before spans2.
    */
-  static final boolean positionsOrdered(Spans spans1, Spans spans2) {
+  static final boolean positionsOrdered(SpanScorer spans1, SpanScorer spans2) {
     assert spans1.docID() == spans2.docID() : "doc1 " + spans1.docID() + " != doc2 " + spans2.docID();
     int start1 = spans1.startPosition();
     int start2 = spans2.startPosition();
@@ -179,7 +183,7 @@
     return (start1 == start2) ? (spans1.endPosition() < spans2.endPosition()) : (start1 < start2);
   }
 
-  private SpansCell minPositionCell() {
+  private SpanScorerCell minPositionCell() {
     return spanPositionQueue.top();
   }
 
@@ -253,7 +257,7 @@
 
   @Override
   public void collect(SpanCollector collector) throws IOException {
-    for (SpansCell cell : subSpanCells) {
+    for (SpanScorerCell cell : subSpanCells) {
       cell.collect(collector);
     }
   }
@@ -261,10 +265,10 @@
   @Override
   public String toString() {
     if (minPositionCell() != null) {
-      return getClass().getName() + "("+query.toString()+")@"+
+      return getClass().getName() + "("+weight.getQuery().toString()+")@"+
         (docID()+":"+startPosition()+"-"+endPosition());
     } else {
-      return getClass().getName() + "("+query.toString()+")@ ?START?";
+      return getClass().getName() + "("+weight.getQuery().toString()+")@ ?START?";
     }
   }
 }
Index: lucene/core/src/java/org/apache/lucene/search/spans/ScoringWrapperSpans.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/ScoringWrapperSpans.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/search/spans/ScoringWrapperSpans.java	(working copy)
@@ -0,0 +1,85 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.search.similarities.Similarity;
+
+/**
+ * A SpanScorer that wraps another SpanScorer with a different SimScorer
+ */
+public class ScoringWrapperSpans extends SpanScorer {
+
+  private final SpanScorer in;
+
+  /**
+   * Creates a new ScoringWrapperSpans
+   * @param spanScorer the scorer to wrap
+   * @param simScorer  the SimScorer to use for scoring
+   */
+  public ScoringWrapperSpans(SpanScorer spanScorer, Similarity.SimScorer simScorer) {
+    super((SpanWeight) spanScorer.getWeight(), simScorer);
+    this.in = spanScorer;
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    return in.nextStartPosition();
+  }
+
+  @Override
+  public int startPosition() {
+    return in.startPosition();
+  }
+
+  @Override
+  public int endPosition() {
+    return in.endPosition();
+  }
+
+  @Override
+  public int width() {
+    return in.width();
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    in.collect(collector);
+  }
+
+  @Override
+  public int docID() {
+    return in.docID();
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    return in.nextDoc();
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    return in.advance(target);
+  }
+
+  @Override
+  public long cost() {
+    return in.cost();
+  }
+}

Property changes on: lucene/core/src/java/org/apache/lucene/search/spans/ScoringWrapperSpans.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanBoostQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanBoostQuery.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanBoostQuery.java	(working copy)
@@ -146,8 +146,8 @@
       }
       
       @Override
-      public Spans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
-        return weight.getSpans(ctx, requiredPostings);
+      public SpanScorer spanScorer(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
+        return weight.spanScorer(ctx, requiredPostings);
       }
 
       @Override
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanCollector.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanCollector.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanCollector.java	(working copy)
@@ -24,7 +24,7 @@
 
 /**
  * An interface defining the collection of postings information from the leaves
- * of a {@link org.apache.lucene.search.spans.Spans}
+ * of a {@link SpanScorer}
  *
  * @lucene.experimental
  */
@@ -40,7 +40,7 @@
   public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException;
 
   /**
-   * Call to indicate that the driving Spans has moved to a new position
+   * Call to indicate that the driving SpanScorer has moved to a new position
    */
   public void reset();
 
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java	(working copy)
@@ -69,16 +69,16 @@
       littleWeight.extractTerms(terms);
     }
 
-    ArrayList<Spans> prepareConjunction(final LeafReaderContext context, Postings postings) throws IOException {
-      Spans bigSpans = bigWeight.getSpans(context, postings);
+    ArrayList<SpanScorer> prepareConjunction(final LeafReaderContext context, Postings postings) throws IOException {
+      SpanScorer bigSpans = bigWeight.spanScorer(context, postings);
       if (bigSpans == null) {
         return null;
       }
-      Spans littleSpans = littleWeight.getSpans(context, postings);
+      SpanScorer littleSpans = littleWeight.spanScorer(context, postings);
       if (littleSpans == null) {
         return null;
       }
-      ArrayList<Spans> bigAndLittle = new ArrayList<>();
+      ArrayList<SpanScorer> bigAndLittle = new ArrayList<>();
       bigAndLittle.add(bigSpans);
       bigAndLittle.add(littleSpans);
       return bigAndLittle;
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java	(working copy)
@@ -17,16 +17,16 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Map;
+
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.IndexSearcher;
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Map;
-
-/** Keep matches that contain another Spans. */
+/** Keep matches that contain another SpanScorer. */
 public final class SpanContainingQuery extends SpanContainQuery {
   /** Construct a SpanContainingQuery matching spans from <code>big</code>
    * that contain at least one spans from <code>little</code>.
@@ -62,16 +62,16 @@
      * The payload is from the spans of <code>big</code>.
      */
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
-      ArrayList<Spans> containerContained = prepareConjunction(context, requiredPostings);
+    public SpanScorer spanScorer(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+      ArrayList<SpanScorer> containerContained = prepareConjunction(context, requiredPostings);
       if (containerContained == null) {
         return null;
       }
 
-      Spans big = containerContained.get(0);
-      Spans little = containerContained.get(1);
+      SpanScorer big = containerContained.get(0);
+      SpanScorer little = containerContained.get(1);
 
-      return new ContainSpans(big, little, big) {
+      return new ContainSpans(this, getSimScorer(context), big, little, big) {
 
         @Override
         boolean twoPhaseCurrentDocMatches() throws IOException {
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java	(working copy)
@@ -35,7 +35,7 @@
     super(match, 0, end);
   }
 
-  protected AcceptStatus acceptPosition(Spans spans) throws IOException {
+  protected AcceptStatus acceptPosition(SpanScorer spans) throws IOException {
     assert spans.startPosition() != spans.endPosition() : "start equals end: " + spans.startPosition();
     if (spans.startPosition() >= end)
       return AcceptStatus.NO_MORE_IN_CURRENT_DOC;
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(working copy)
@@ -33,7 +33,6 @@
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.util.ToStringUtils;
 
 /** Matches spans which are near one another.  One can specify <i>slop</i>, the
  * maximum number of intervening unmatched positions, as well as whether
@@ -202,7 +201,7 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+    public SpanScorer spanScorer(final LeafReaderContext context, Postings requiredPostings) throws IOException {
 
       Terms terms = context.reader().terms(field);
       if (terms == null) {
@@ -209,9 +208,9 @@
         return null; // field does not exist
       }
 
-      ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());
+      ArrayList<SpanScorer> subSpans = new ArrayList<>(clauses.size());
       for (SpanWeight w : subWeights) {
-        Spans subSpan = w.getSpans(context, requiredPostings);
+        SpanScorer subSpan = w.spanScorer(context, requiredPostings);
         if (subSpan != null) {
           subSpans.add(subSpan);
         } else {
@@ -220,8 +219,8 @@
       }
 
       // all NearSpans require at least two subSpans
-      return (!inOrder) ? new NearSpansUnordered(SpanNearQuery.this, subSpans)
-          : new NearSpansOrdered(SpanNearQuery.this, subSpans);
+      return (!inOrder) ? new NearSpansUnordered(this, slop, subSpans, getSimScorer(context))
+          : new NearSpansOrdered(this, slop, subSpans, getSimScorer(context));
     }
 
     @Override
@@ -313,8 +312,8 @@
       }
 
       @Override
-      public Spans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
-        return new GapSpans(width);
+      public SpanScorer spanScorer(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
+        return new GapSpanScorer(width);
       }
 
       @Override
@@ -324,13 +323,14 @@
     }
   }
 
-  static class GapSpans extends Spans {
+  static class GapSpanScorer extends SpanScorer {
 
     int doc = -1;
     int pos = -1;
     final int width;
 
-    GapSpans(int width) {
+    GapSpanScorer(int width) {
+      super(null, null);
       this.width = width;
     }
 
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java	(working copy)
@@ -17,6 +17,11 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
@@ -25,13 +30,7 @@
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TwoPhaseIterator;
-import org.apache.lucene.util.ToStringUtils;
 
-import java.io.IOException;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-
 /** Removes matches which overlap with another SpanQuery or which are
  * within x tokens before or y tokens after another SpanQuery.
  */
@@ -119,21 +118,21 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
-      Spans includeSpans = includeWeight.getSpans(context, requiredPostings);
+    public SpanScorer spanScorer(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+      SpanScorer includeSpans = includeWeight.spanScorer(context, requiredPostings);
       if (includeSpans == null) {
         return null;
       }
 
-      Spans excludeSpans = excludeWeight.getSpans(context, requiredPostings);
+      SpanScorer excludeSpans = excludeWeight.spanScorer(context, requiredPostings);
       if (excludeSpans == null) {
-        return includeSpans;
+        return new ScoringWrapperSpans(includeSpans, getSimScorer(context));
       }
 
       TwoPhaseIterator excludeTwoPhase = excludeSpans.asTwoPhaseIterator();
       DocIdSetIterator excludeApproximation = excludeTwoPhase == null ? null : excludeTwoPhase.approximation();
 
-      return new FilterSpans(includeSpans) {
+      return new FilterSpans(includeSpans, getSimScorer(context)) {
         // last document we have checked matches() against for the exclusion, and failed
         // when using approximations, so we don't call it again, and pass thru all inclusions.
         int lastApproxDoc = -1;
@@ -140,7 +139,7 @@
         boolean lastApproxResult = false;
 
         @Override
-        protected AcceptStatus accept(Spans candidate) throws IOException {
+        protected AcceptStatus accept(SpanScorer candidate) throws IOException {
           // TODO: this logic is ugly and sneaky, can we clean it up?
           int doc = candidate.docID();
           if (doc > excludeSpans.docID()) {
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(working copy)
@@ -17,6 +17,13 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
@@ -28,14 +35,7 @@
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TwoPhaseIterator;
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
 
-
 /** Matches the union of its clauses.
  */
 public final class SpanOrQuery extends SpanQuery {
@@ -151,13 +151,13 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings)
+    public SpanScorer spanScorer(final LeafReaderContext context, Postings requiredPostings)
         throws IOException {
 
-      ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());
+      ArrayList<SpanScorer> subSpans = new ArrayList<>(clauses.size());
 
       for (SpanWeight w : subWeights) {
-        Spans spans = w.getSpans(context, requiredPostings);
+        SpanScorer spans = w.spanScorer(context, requiredPostings);
         if (spans != null) {
           subSpans.add(spans);
         }
@@ -166,23 +166,23 @@
       if (subSpans.size() == 0) {
         return null;
       } else if (subSpans.size() == 1) {
-        return subSpans.get(0);
+        return new ScoringWrapperSpans(subSpans.get(0), getSimScorer(context));
       }
 
-      DisiPriorityQueue<Spans> byDocQueue = new DisiPriorityQueue<>(subSpans.size());
-      for (Spans spans : subSpans) {
+      DisiPriorityQueue<SpanScorer> byDocQueue = new DisiPriorityQueue<>(subSpans.size());
+      for (SpanScorer spans : subSpans) {
         byDocQueue.add(new DisiWrapper<>(spans));
       }
 
       SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1
 
-      return new Spans() {
-        Spans topPositionSpans = null;
+      return new SpanScorer(this, getSimScorer(context)) {
+        SpanScorer topPositionSpans = null;
 
         @Override
         public int nextDoc() throws IOException {
           topPositionSpans = null;
-          DisiWrapper<Spans> topDocSpans = byDocQueue.top();
+          DisiWrapper<SpanScorer> topDocSpans = byDocQueue.top();
           int currentDoc = topDocSpans.doc;
           do {
             topDocSpans.doc = topDocSpans.iterator.nextDoc();
@@ -194,7 +194,7 @@
         @Override
         public int advance(int target) throws IOException {
           topPositionSpans = null;
-          DisiWrapper<Spans> topDocSpans = byDocQueue.top();
+          DisiWrapper<SpanScorer> topDocSpans = byDocQueue.top();
           do {
             topDocSpans.doc = topDocSpans.iterator.advance(target);
             topDocSpans = byDocQueue.updateTop();
@@ -204,7 +204,7 @@
 
         @Override
         public int docID() {
-          DisiWrapper<Spans> topDocSpans = byDocQueue.top();
+          DisiWrapper<SpanScorer> topDocSpans = byDocQueue.top();
           return topDocSpans.doc;
         }
 
@@ -211,7 +211,7 @@
         @Override
         public TwoPhaseIterator asTwoPhaseIterator() {
           boolean hasApproximation = false;
-          for (DisiWrapper<Spans> w : byDocQueue) {
+          for (DisiWrapper<SpanScorer> w : byDocQueue) {
             if (w.twoPhaseView != null) {
               hasApproximation = true;
               break;
@@ -222,7 +222,7 @@
             return null;
           }
 
-          return new TwoPhaseIterator(new DisjunctionDISIApproximation<Spans>(byDocQueue)) {
+          return new TwoPhaseIterator(new DisjunctionDISIApproximation<SpanScorer>(byDocQueue)) {
             @Override
             public boolean matches() throws IOException {
               return twoPhaseCurrentDocMatches();
@@ -233,7 +233,7 @@
         int lastDocTwoPhaseMatched = -1;
 
         boolean twoPhaseCurrentDocMatches() throws IOException {
-          DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();
+          DisiWrapper<SpanScorer> listAtCurrentDoc = byDocQueue.topList();
           // remove the head of the list as long as it does not match
           final int currentDoc = listAtCurrentDoc.doc;
           while (listAtCurrentDoc.twoPhaseView != null) {
@@ -256,10 +256,10 @@
 
         void fillPositionQueue() throws IOException { // called at first nextStartPosition
           assert byPositionQueue.size() == 0;
-          // add all matching Spans at current doc to byPositionQueue
-          DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();
+          // add all matching SpanScorer at current doc to byPositionQueue
+          DisiWrapper<SpanScorer> listAtCurrentDoc = byDocQueue.topList();
           while (listAtCurrentDoc != null) {
-            Spans spansAtDoc = listAtCurrentDoc.iterator;
+            SpanScorer spansAtDoc = listAtCurrentDoc.iterator;
             if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation
               if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation
                 if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false
@@ -331,7 +331,7 @@
         public long cost() {
           if (cost == -1) {
             cost = 0;
-            for (Spans spans : subSpans) {
+            for (SpanScorer spans : subSpans) {
               cost += spans.cost();
             }
           }
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java	(working copy)
@@ -17,6 +17,11 @@
  */
 
 
+import java.io.IOException;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
@@ -25,12 +30,7 @@
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
 
-import java.io.IOException;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
 
-
 /**
  * Base class for filtering a SpanQuery based on the position of a match.
  **/
@@ -54,17 +54,17 @@
    * Implementing classes are required to return whether the current position is a match for the passed in
    * "match" {@link SpanQuery}.
    *
-   * This is only called if the underlying last {@link Spans#nextStartPosition()} for the
+   * This is only called if the underlying last {@link SpanScorer#nextStartPosition()} for the
    * match indicated a valid start position.
    *
-   * @param spans The {@link Spans} instance, positioned at the spot to check
+   * @param spans The {@link SpanScorer} instance, positioned at the spot to check
    *
    * @return whether the match is accepted, rejected, or rejected and should move to the next doc.
    *
-   * @see Spans#nextDoc()
+   * @see SpanScorer#nextDoc()
    *
    */
-  protected abstract AcceptStatus acceptPosition(Spans spans) throws IOException;
+  protected abstract AcceptStatus acceptPosition(SpanScorer spans) throws IOException;
 
   @Override
   public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
@@ -92,11 +92,11 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
-      Spans matchSpans = matchWeight.getSpans(context, requiredPostings);
-      return (matchSpans == null) ? null : new FilterSpans(matchSpans) {
+    public SpanScorer spanScorer(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+      SpanScorer matchSpans = matchWeight.spanScorer(context, requiredPostings);
+      return (matchSpans == null) ? null : new FilterSpans(matchSpans, getSimScorer(context)) {
         @Override
-        protected AcceptStatus accept(Spans candidate) throws IOException {
+        protected AcceptStatus accept(SpanScorer candidate) throws IOException {
           return acceptPosition(candidate);
         }
       };
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionQueue.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionQueue.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionQueue.java	(working copy)
@@ -19,12 +19,12 @@
 
 import org.apache.lucene.util.PriorityQueue;
 
-class SpanPositionQueue extends PriorityQueue<Spans> {
+class SpanPositionQueue extends PriorityQueue<SpanScorer> {
   SpanPositionQueue(int maxSize) {
     super(maxSize, false); // do not prepopulate
   }
 
-  protected boolean lessThan(Spans s1, Spans s2) {
+  protected boolean lessThan(SpanScorer s1, SpanScorer s2) {
     int start1 = s1.startPosition();
     int start2 = s2.startPosition();
     return (start1 < start2) ? true
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java	(working copy)
@@ -38,7 +38,7 @@
   }
 
   @Override
-  protected AcceptStatus acceptPosition(Spans spans) throws IOException {
+  protected AcceptStatus acceptPosition(SpanScorer spans) throws IOException {
     assert spans.startPosition() != spans.endPosition();
     AcceptStatus res = (spans.startPosition() >= end)
         ? AcceptStatus.NO_MORE_IN_CURRENT_DOC
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java	(working copy)
@@ -18,53 +18,91 @@
  */
 
 import java.io.IOException;
-import java.util.Objects;
 
 import org.apache.lucene.search.Scorer;
-import org.apache.lucene.search.TwoPhaseIterator;
 import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.search.similarities.Similarity.SimScorer;
 
-/**
- * Public for extension only.
+/** Iterates through combinations of start/end positions per-doc.
+ *  Each start/end position represents a range of term positions within the current document.
+ *  These are enumerated in order, by increasing document number, within that by
+ *  increasing start position and finally by increasing end position.
  */
-public class SpanScorer extends Scorer {
-  /** underlying spans we are scoring from */
-  protected final Spans spans;
-  /** similarity used in default score impl */
+public abstract class SpanScorer extends Scorer {
+
+  public static final int NO_MORE_POSITIONS = Integer.MAX_VALUE;
+
   protected final Similarity.SimScorer docScorer;
 
+  protected SpanScorer(SpanWeight weight, SimScorer docScorer) {
+    super(weight);
+    this.docScorer = docScorer;
+  }
+
   /** accumulated sloppy freq (computed in setFreqCurrentDoc) */
   protected float freq;
   /** number of matches (computed in setFreqCurrentDoc) */
   protected int numMatches;
-  
+
   private int lastScoredDoc = -1; // last doc we called setFreqCurrentDoc() for
 
   /**
-   * Creates a new SpanScorer
-   * @lucene.internal
+   * Returns the next start position for the current doc.
+   * There is always at least one start/end position per doc.
+   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
    */
-  public SpanScorer(Spans spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
-    super(weight);
-    this.docScorer = docScorer;
-    this.spans = Objects.requireNonNull(spans);
-  }
+  public abstract int nextStartPosition() throws IOException;
 
+  /**
+   * Returns the start position in the current doc, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
+   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
+   */
+  public abstract int startPosition();
+
+  /**
+   * Returns the end position for the current start position, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
+   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
+   */
+  public abstract int endPosition();
+
+  /**
+   * Return the width of the match, which is typically used to compute
+   * the {@link SimScorer#computeSlopFactor(int) slop factor}. It is only legal
+   * to call this method when the iterator is on a valid doc ID and positioned.
+   * The return value must be positive, and lower values means that the match is
+   * better.
+   */
+  public abstract int width();
+
+  /**
+   * Collect postings data from the leaves of the current SpanScorer.
+   *
+   * This method should only be called after {@link #nextStartPosition()}, and before
+   * {@link #NO_MORE_POSITIONS} has been reached.
+   *
+   * @param collector a SpanCollector
+   *
+   * @lucene.experimental
+   */
+  public abstract void collect(SpanCollector collector) throws IOException;
+
   @Override
-  public final int nextDoc() throws IOException {
-    return spans.nextDoc();
+  public String toString() {
+    StringBuilder sb = new StringBuilder();
+    Class<? extends SpanScorer> clazz = getClass();
+    sb.append(clazz.isAnonymousClass() ? clazz.getName() : clazz.getSimpleName());
+    sb.append("(doc=").append(docID());
+    sb.append(",start=").append(startPosition());
+    sb.append(",end=").append(endPosition());
+    sb.append(")");
+    return sb.toString();
   }
 
-  @Override
-  public final int advance(int target) throws IOException {
-    return spans.advance(target);
-  }
-  
-  /** 
+  /**
    * Ensure setFreqCurrentDoc is called, if not already called for the current doc.
    */
-  private final void ensureFreq() throws IOException {
-    int currentDoc = spans.docID();
+  private void ensureFreq() throws IOException {
+    int currentDoc = docID();
     if (lastScoredDoc != currentDoc) {
       setFreqCurrentDoc();
       lastScoredDoc = currentDoc;
@@ -82,17 +120,17 @@
 
     doStartCurrentDoc();
 
-    assert spans.startPosition() == -1 : "incorrect initial start position, spans="+spans;
-    assert spans.endPosition() == -1 : "incorrect initial end position, spans="+spans;
+    assert startPosition() == -1 : "incorrect initial start position, " + this.toString();
+    assert endPosition() == -1 : "incorrect initial end position, " + this.toString();
     int prevStartPos = -1;
     int prevEndPos = -1;
 
-    int startPos = spans.nextStartPosition();
-    assert startPos != Spans.NO_MORE_POSITIONS : "initial startPos NO_MORE_POSITIONS, spans="+spans;
+    int startPos = nextStartPosition();
+    assert startPos != SpanScorer.NO_MORE_POSITIONS : "initial startPos NO_MORE_POSITIONS, " + this.toString();
     do {
       assert startPos >= prevStartPos;
-      int endPos = spans.endPosition();
-      assert endPos != Spans.NO_MORE_POSITIONS;
+      int endPos = endPosition();
+      assert endPos != SpanScorer.NO_MORE_POSITIONS;
       // This assertion can fail for Or spans on the same term:
       // assert (startPos != prevStartPos) || (endPos > prevEndPos) : "non increased endPos="+endPos;
       assert (startPos != prevStartPos) || (endPos >= prevEndPos) : "decreased endPos="+endPos;
@@ -101,15 +139,15 @@
         freq = 1;
         return;
       }
-      freq += docScorer.computeSlopFactor(spans.width());
+      freq += docScorer.computeSlopFactor(width());
       doCurrentSpans();
       prevStartPos = startPos;
       prevEndPos = endPos;
-      startPos = spans.nextStartPosition();
-    } while (startPos != Spans.NO_MORE_POSITIONS);
+      startPos = nextStartPosition();
+    } while (startPos != SpanScorer.NO_MORE_POSITIONS);
 
-    assert spans.startPosition() == Spans.NO_MORE_POSITIONS : "incorrect final start position, spans="+spans;
-    assert spans.endPosition() == Spans.NO_MORE_POSITIONS : "incorrect final end position, spans="+spans;
+    assert startPosition() == SpanScorer.NO_MORE_POSITIONS : "incorrect final start position, " + this.toString();
+    assert endPosition() == SpanScorer.NO_MORE_POSITIONS : "incorrect final end position, " + this.toString();
   }
 
   /**
@@ -118,22 +156,20 @@
   protected void doStartCurrentDoc() throws IOException {}
 
   /**
-   * Called each time the scorer's Spans is advanced during frequency calculation
+   * Called each time the scorer's SpanScorer is advanced during frequency calculation
    */
   protected void doCurrentSpans() throws IOException {}
-  
+
   /**
-   * Score the current doc. The default implementation scores the doc 
+   * Score the current doc. The default implementation scores the doc
    * with the similarity using the slop-adjusted {@link #freq}.
    */
   protected float scoreCurrentDoc() throws IOException {
-    return docScorer.score(spans.docID(), freq);
+    assert docScorer != null : getClass() + " has a null docScorer!";
+    return docScorer.score(docID(), freq);
   }
 
   @Override
-  public final int docID() { return spans.docID(); }
-
-  @Override
   public final float score() throws IOException {
     ensureFreq();
     return scoreCurrentDoc();
@@ -147,19 +183,9 @@
 
   /** Returns the intermediate "sloppy freq" adjusted for edit distance
    *  @lucene.internal */
-  // only public so .payloads can see it.
-  public final float sloppyFreq() throws IOException {
+  final float sloppyFreq() throws IOException {
     ensureFreq();
     return freq;
   }
 
-  @Override
-  public final long cost() {
-    return spans.cost();
-  }
-
-  @Override
-  public final TwoPhaseIterator asTwoPhaseIterator() {
-    return spans.asTwoPhaseIterator();
-  }
 }
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(working copy)
@@ -17,6 +17,12 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.Collections;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.PostingsEnum;
@@ -27,14 +33,7 @@
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.util.ToStringUtils;
 
-import java.io.IOException;
-import java.util.Collections;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-
 /** Matches spans containing a term.
  * This should not be used for terms that are indexed at position Integer.MAX_VALUE.
  */
@@ -98,7 +97,7 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+    public SpanScorer spanScorer(final LeafReaderContext context, Postings requiredPostings) throws IOException {
 
       assert termContext.topReaderContext == ReaderUtil.getTopLevelContext(context) : "The top-reader used to create Weight (" + termContext.topReaderContext + ") is not the same as the current reader's top-reader (" + ReaderUtil.getTopLevelContext(context);
 
@@ -118,7 +117,7 @@
       termsEnum.seekExact(term.bytes(), state);
 
       final PostingsEnum postings = termsEnum.postings(null, requiredPostings.getRequiredPostings());
-      return new TermSpans(postings, term);
+      return new TermSpans(this, getSimScorer(context), postings, term);
     }
   }
 
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java	(working copy)
@@ -24,7 +24,6 @@
 import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
-import org.apache.lucene.index.Terms;
 import org.apache.lucene.search.CollectionStatistics;
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.IndexSearcher;
@@ -41,7 +40,7 @@
 
   /**
    * Enumeration defining what postings information should be retrieved from the
-   * index for a given Spans
+   * index for a given SpanScorer
    */
   public enum Postings {
     POSITIONS {
@@ -111,12 +110,12 @@
   public abstract void extractTermContexts(Map<Term, TermContext> contexts);
 
   /**
-   * Expert: Return a Spans object iterating over matches from this Weight
-   * @param ctx a LeafReaderContext for this Spans
-   * @return a Spans
+   * Expert: Return a SpanScorer object iterating over matches from this Weight
+   * @param ctx a LeafReaderContext for this SpanScorer
+   * @return a SpanScorer
    * @throws IOException on error
    */
-  public abstract Spans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException;
+  public abstract SpanScorer spanScorer(LeafReaderContext ctx, Postings requiredPostings) throws IOException;
 
   @Override
   public float getValueForNormalization() throws IOException {
@@ -132,18 +131,15 @@
 
   @Override
   public Scorer scorer(LeafReaderContext context) throws IOException {
-    if (field == null) {
-      return null;
-    }
-    Terms terms = context.reader().terms(field);
-    if (terms != null && terms.hasPositions() == false) {
-      throw new IllegalStateException("field \"" + field + "\" was indexed without position data; cannot run SpanQuery (query=" + parentQuery + ")");
-    }
-    Spans spans = getSpans(context, Postings.POSITIONS);
-    Similarity.SimScorer simScorer = getSimScorer(context);
-    return (spans == null) ? null : new SpanScorer(spans, this, simScorer);
+    return spanScorer(context, Postings.POSITIONS);
   }
 
+  /**
+   * Return a SimScorer for this context
+   * @param context the LeafReaderContext
+   * @return a SimWeight
+   * @throws IOException on error
+   */
   public Similarity.SimScorer getSimScorer(LeafReaderContext context) throws IOException {
     return simWeight == null ? null : similarity.simScorer(simWeight, context);
   }
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java	(working copy)
@@ -17,16 +17,16 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Map;
+
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.IndexSearcher;
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Map;
-
-/** Keep matches that are contained within another Spans. */
+/** Keep matches that are contained within another SpanScorer. */
 public final class SpanWithinQuery extends SpanContainQuery {
 
   /** Construct a SpanWithinQuery matching spans from <code>little</code>
@@ -63,16 +63,16 @@
      * The payload is from the spans of <code>little</code>.
      */
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
-      ArrayList<Spans> containerContained = prepareConjunction(context, requiredPostings);
+    public SpanScorer spanScorer(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+      ArrayList<SpanScorer> containerContained = prepareConjunction(context, requiredPostings);
       if (containerContained == null) {
         return null;
       }
 
-      Spans big = containerContained.get(0);
-      Spans little = containerContained.get(1);
+      SpanScorer big = containerContained.get(0);
+      SpanScorer little = containerContained.get(1);
 
-      return new ContainSpans(big, little, little) {
+      return new ContainSpans(this, getSimScorer(context), big, little, little) {
 
         @Override
         boolean twoPhaseCurrentDocMatches() throws IOException {
Index: lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/Spans.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/Spans.java	(working copy)
@@ -1,106 +0,0 @@
-package org.apache.lucene.search.spans;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.search.TwoPhaseIterator;
-import org.apache.lucene.search.similarities.Similarity.SimScorer;
-
-/** Iterates through combinations of start/end positions per-doc.
- *  Each start/end position represents a range of term positions within the current document.
- *  These are enumerated in order, by increasing document number, within that by
- *  increasing start position and finally by increasing end position.
- */
-public abstract class Spans extends DocIdSetIterator {
-  public static final int NO_MORE_POSITIONS = Integer.MAX_VALUE;
-
-  /**
-   * Returns the next start position for the current doc.
-   * There is always at least one start/end position per doc.
-   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
-   */
-  public abstract int nextStartPosition() throws IOException;
-
-  /**
-   * Returns the start position in the current doc, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
-   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
-   */
-  public abstract int startPosition();
-
-  /**
-   * Returns the end position for the current start position, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
-   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
-   */
-  public abstract int endPosition();
-
-  /**
-   * Return the width of the match, which is typically used to compute
-   * the {@link SimScorer#computeSlopFactor(int) slop factor}. It is only legal
-   * to call this method when the iterator is on a valid doc ID and positioned.
-   * The return value must be positive, and lower values means that the match is
-   * better.
-   */
-  public abstract int width();
-
-  /**
-   * Collect postings data from the leaves of the current Spans.
-   *
-   * This method should only be called after {@link #nextStartPosition()}, and before
-   * {@link #NO_MORE_POSITIONS} has been reached.
-   *
-   * @param collector a SpanCollector
-   *
-   * @lucene.experimental
-   */
-  public abstract void collect(SpanCollector collector) throws IOException;
-
-  /**
-   * Optional method: Return a {@link TwoPhaseIterator} view of this
-   * {@link Spans}. A return value of {@code null} indicates that
-   * two-phase iteration is not supported.
-   *
-   * Note that the returned {@link TwoPhaseIterator}'s
-   * {@link TwoPhaseIterator#approximation() approximation} must
-   * advance documents synchronously with this iterator:
-   * advancing the approximation must
-   * advance this iterator and vice-versa.
-   *
-   * Implementing this method is typically useful on a {@link Spans}
-   * that has a high per-document overhead for confirming matches.
-   *
-   * The default implementation returns {@code null}.
-   */
-  public TwoPhaseIterator asTwoPhaseIterator() {
-    return null;
-  }
-
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder();
-    Class<? extends Spans> clazz = getClass();
-    sb.append(clazz.isAnonymousClass() ? clazz.getName() : clazz.getSimpleName());
-    sb.append("(doc=").append(docID());
-    sb.append(",start=").append(startPosition());
-    sb.append(",end=").append(endPosition());
-    sb.append(")");
-    return sb.toString();
-  }
-
-}
Index: lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java	(working copy)
@@ -16,19 +16,20 @@
  */
 
 
+import java.io.IOException;
+import java.util.Objects;
+
 import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.similarities.Similarity;
 
-import java.io.IOException;
-import java.util.Objects;
-
 /**
  * Expert:
  * Public for extension only.
  * This does not work correctly for terms that indexed at position Integer.MAX_VALUE.
  */
-public class TermSpans extends Spans {
+public class TermSpans extends SpanScorer {
   protected final PostingsEnum postings;
   protected final Term term;
   protected int doc;
@@ -37,7 +38,8 @@
   protected int position;
   protected boolean readPayload;
 
-  public TermSpans(PostingsEnum postings, Term term) {
+  public TermSpans(SpanWeight weight, Similarity.SimScorer scorer, PostingsEnum postings, Term term) {
+    super(weight, scorer);
     this.postings = Objects.requireNonNull(postings);
     this.term = Objects.requireNonNull(term);
     this.doc = -1;
Index: lucene/core/src/java/org/apache/lucene/search/spans/package-info.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/package-info.java	(revision 1709810)
+++ lucene/core/src/java/org/apache/lucene/search/spans/package-info.java	(working copy)
@@ -19,7 +19,7 @@
  * The calculus of spans.
  * 
  * <p>A span is a <code>&lt;doc,startPosition,endPosition&gt;</code> tuple  that is enumerated by
- *    class {@link org.apache.lucene.search.spans.Spans Spans}.
+ *    class {@link org.apache.lucene.search.spans.SpanScorer SpanScorer}.
  *  </p>
  * 
  * <p>The following span query operators are implemented:
Index: lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java	(revision 1709810)
+++ lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java	(working copy)
@@ -42,9 +42,9 @@
 import org.apache.lucene.search.spans.SpanCollector;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
@@ -254,9 +254,9 @@
       System.out.println("\ngetPayloadSpans test");
     }
     PayloadSpanCollector collector = new PayloadSpanCollector();
-    Spans pspans = MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
-    while (pspans.nextDoc() != Spans.NO_MORE_DOCS) {
-      while (pspans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+    SpanScorer pspans = MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
+    while (pspans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+      while (pspans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
         if (VERBOSE) {
           System.out.println("doc " + pspans.docID() + ": span " + pspans.startPosition()
               + " to " + pspans.endPosition());
@@ -276,11 +276,11 @@
     assertEquals(8, count);
 
     // System.out.println("\ngetSpans test");
-    Spans spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq);
+    SpanScorer spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq);
     count = 0;
     sawZero = false;
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-      while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+    while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
         count++;
         sawZero |= spans.startPosition() == 0;
         // System.out.println(spans.doc() + " - " + spans.start() + " - " +
Index: lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java	(revision 1709810)
+++ lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java	(working copy)
@@ -20,7 +20,6 @@
 import java.io.IOException;
 
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.similarities.Similarity;
 
 /**
  * Holds all implementations of classes in the o.a.l.s.spans package as a
@@ -33,8 +32,12 @@
 
   private static final String UNSUPPORTED_MSG = "unsupported: used for back-compat testing only !";
 
-  static final class JustCompileSpans extends Spans {
+  static final class JustCompileSpanScorer extends SpanScorer {
 
+    JustCompileSpanScorer() {
+      super(null, null);
+    }
+
     @Override
     public int docID() {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
@@ -100,65 +103,4 @@
     
   }
 
-  static final class JustCompilePayloadSpans extends Spans {
-
-    @Override
-    public int docID() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public int advance(int target) throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public int startPosition() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public int endPosition() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public int width() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public void collect(SpanCollector collector) throws IOException {
-
-    }
-
-    @Override
-    public int nextStartPosition() throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public long cost() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-    
-  }
-  
-  static final class JustCompileSpanScorer extends SpanScorer {
-
-    protected JustCompileSpanScorer(Spans spans, SpanWeight weight,
-        Similarity.SimScorer docScorer) throws IOException {
-      super(spans, weight, docScorer);
-    }
-
-    @Override
-    protected float scoreCurrentDoc() throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-  }
 }
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java	(revision 1709810)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java	(working copy)
@@ -251,7 +251,7 @@
     SpanQuery q  = new SpanOrQuery(q1, new FieldMaskingSpanQuery(q2, "gender"));
     check(q, new int[] { 0, 1, 2, 3, 4 });
 
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
     assertNext(span, 0,0,1);
     assertNext(span, 1,0,1);
     assertNext(span, 1,1,2);
@@ -273,18 +273,18 @@
     check(qA, new int[] { 0, 1, 2, 4 });
     check(qB, new int[] { 0, 1, 2, 4 });
   
-    Spans spanA = MultiSpansWrapper.wrap(searcher.getIndexReader(), qA);
-    Spans spanB = MultiSpansWrapper.wrap(searcher.getIndexReader(), qB);
+    SpanScorer spanA = MultiSpansWrapper.wrap(searcher.getIndexReader(), qA);
+    SpanScorer spanB = MultiSpansWrapper.wrap(searcher.getIndexReader(), qB);
     
-    while (spanA.nextDoc() != Spans.NO_MORE_DOCS) {
-      assertNotSame("spanB not still going", Spans.NO_MORE_DOCS, spanB.nextDoc());
-      while (spanA.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+    while (spanA.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+      assertNotSame("spanB not still going", SpanScorer.NO_MORE_DOCS, spanB.nextDoc());
+      while (spanA.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
         assertEquals("spanB start position", spanA.startPosition(), spanB.nextStartPosition());
         assertEquals("spanB end position", spanA.endPosition(), spanB.endPosition());
       }
-      assertEquals("spanB start position", Spans.NO_MORE_POSITIONS, spanB.nextStartPosition());
+      assertEquals("spanB start position", SpanScorer.NO_MORE_POSITIONS, spanB.nextStartPosition());
     }
-    assertEquals("spanB end doc", Spans.NO_MORE_DOCS, spanB.nextDoc());
+    assertEquals("spanB end doc", SpanScorer.NO_MORE_DOCS, spanB.nextDoc());
   }
   
   public void testSpans2() throws Exception {
@@ -299,7 +299,7 @@
         new FieldMaskingSpanQuery(qB, "id") }, -1, false );
     check(q, new int[] { 0, 1, 2, 3 });
 
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
     assertNext(span, 0,0,1);
     assertNext(span, 1,1,2);
     assertNext(span, 2,0,1);
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestFilterSpans.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestFilterSpans.java	(revision 1709810)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestFilterSpans.java	(working copy)
@@ -28,11 +28,13 @@
 
   @Test
   public void testOverrides() throws Exception {
-    // verify that all methods of Spans are overridden by FilterSpans,
+    // verify that all methods of SpanScorer are overridden by FilterSpans,
     // except those under the 'exclude' list
     Set<Method> exclude = new HashSet<>();
+    exclude.add(FilterSpans.class.getMethod("freq"));
+    exclude.add(FilterSpans.class.getMethod("score"));
     for (Method m : FilterSpans.class.getMethods()) {
-      if (m.getDeclaringClass() == Spans.class) {
+      if (m.getDeclaringClass() == SpanScorer.class) {
         assertTrue("method " + m.getName() + " not overridden!", exclude.contains(m));
       }
     }
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java	(revision 1709810)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java	(working copy)
@@ -109,7 +109,7 @@
     CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {0,1});
   }
 
-  public String s(Spans span) {
+  public String s(SpanScorer span) {
     return s(span.docID(), span.startPosition(), span.endPosition());
   }
   public String s(int doc, int start, int end) {
@@ -118,7 +118,7 @@
   
   public void testNearSpansNext() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
     assertNext(span,0,0,3);
     assertNext(span,1,0,4);
     assertFinished(span);
@@ -131,7 +131,7 @@
    */
   public void testNearSpansAdvanceLikeNext() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
     assertEquals(0, span.advance(0));
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(0,0,3), s(span));
@@ -138,39 +138,39 @@
     assertEquals(1, span.advance(1));
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(1,0,4), s(span));
-    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
+    assertEquals(SpanScorer.NO_MORE_DOCS, span.advance(2));
   }
   
   public void testNearSpansNextThenAdvance() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
-    assertNotSame(Spans.NO_MORE_DOCS, span.nextDoc());
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    assertNotSame(SpanScorer.NO_MORE_DOCS, span.nextDoc());
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(0,0,3), s(span));
-    assertNotSame(Spans.NO_MORE_DOCS, span.advance(1));
+    assertNotSame(SpanScorer.NO_MORE_DOCS, span.advance(1));
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(1,0,4), s(span));
-    assertEquals(Spans.NO_MORE_DOCS, span.nextDoc());
+    assertEquals(SpanScorer.NO_MORE_DOCS, span.nextDoc());
   }
   
   public void testNearSpansNextThenAdvancePast() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
-    assertNotSame(Spans.NO_MORE_DOCS, span.nextDoc());
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    assertNotSame(SpanScorer.NO_MORE_DOCS, span.nextDoc());
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(0,0,3), s(span));
-    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
+    assertEquals(SpanScorer.NO_MORE_DOCS, span.advance(2));
   }
   
   public void testNearSpansAdvancePast() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
-    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    assertEquals(SpanScorer.NO_MORE_DOCS, span.advance(2));
   }
   
   public void testNearSpansAdvanceTo0() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
     assertEquals(0, span.advance(0));
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(0,0,3), s(span));
@@ -178,7 +178,7 @@
 
   public void testNearSpansAdvanceTo1() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
     assertEquals(1, span.advance(1));
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(1,0,4), s(span));
@@ -217,7 +217,7 @@
         new SpanOrQuery(new SpanTermQuery(new Term(FIELD, "w1")), new SpanTermQuery(new Term(FIELD, "w2"))),
         new SpanTermQuery(new Term(FIELD, "w4"))
     }, 10, true);
-    Spans spans = MultiSpansWrapper.wrap(reader, q);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, q);
     assertNext(spans,0,0,4);
     assertNext(spans,0,1,4);
     assertFinished(spans);
@@ -227,7 +227,7 @@
     SpanNearQuery q = new SpanNearQuery(new SpanQuery[]{
         new SpanTermQuery(new Term(FIELD, "t1")), new SpanTermQuery(new Term(FIELD, "t2"))
     }, 1, true);
-    Spans spans = MultiSpansWrapper.wrap(reader, q);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, q);
     assertNext(spans,4,0,2);
     assertFinished(spans);
   }
@@ -236,7 +236,7 @@
     SpanNearQuery q = new SpanNearQuery(new SpanQuery[]{
         new SpanTermQuery(new Term(FIELD, "t2")), new SpanTermQuery(new Term(FIELD, "t1"))
     }, 1, true);
-    Spans spans = MultiSpansWrapper.wrap(reader, q);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, q);
     assertNext(spans,4,1,4);
     assertNext(spans,4,2,4);
     assertFinished(spans);
@@ -260,7 +260,7 @@
         .addGap(1)
         .addClause(new SpanTermQuery(new Term(FIELD, "w2")))
         .build();
-    Spans spans = MultiSpansWrapper.wrap(reader, q);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, q);
     assertNext(spans, 1, 0, 3);
     assertNext(spans, 2, 0, 3);
     assertFinished(spans);
@@ -285,7 +285,7 @@
         .addGap(2)
         .addClause(new SpanTermQuery(new Term(FIELD, "g")))
         .build();
-    Spans spans = MultiSpansWrapper.wrap(reader, q);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, q);
     assertNext(spans, 5, 0, 4);
     assertNext(spans, 5, 9, 13);
     assertFinished(spans);
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java	(revision 1709810)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java	(working copy)
@@ -95,7 +95,7 @@
       "w1 w2 w1 w4 w2 w3"
   };
 
-  private void checkCollectedTerms(Spans spans, TermCollector collector, Term... expectedTerms) throws IOException {
+  private void checkCollectedTerms(SpanScorer spans, TermCollector collector, Term... expectedTerms) throws IOException {
     collector.reset();
     spans.collect(collector);
     for (Term t : expectedTerms) {
@@ -119,7 +119,7 @@
     SpanNearQuery q7 = new SpanNearQuery(new SpanQuery[]{q1, q6}, 1, true);
 
     TermCollector collector = new TermCollector();
-    Spans spans = MultiSpansWrapper.wrap(reader, q7, SpanWeight.Postings.POSITIONS);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, q7, SpanWeight.Postings.POSITIONS);
     assertEquals(0, spans.advance(0));
     spans.nextStartPosition();
     checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"));
@@ -139,7 +139,7 @@
     SpanOrQuery orQuery = new SpanOrQuery(q2, q3);
 
     TermCollector collector = new TermCollector();
-    Spans spans = MultiSpansWrapper.wrap(reader, orQuery, SpanWeight.Postings.POSITIONS);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, orQuery, SpanWeight.Postings.POSITIONS);
 
     assertEquals(1, spans.advance(1));
     spans.nextStartPosition();
@@ -169,7 +169,7 @@
     SpanNotQuery notq = new SpanNotQuery(nq, q3);
 
     TermCollector collector = new TermCollector();
-    Spans spans = MultiSpansWrapper.wrap(reader, notq, SpanWeight.Postings.POSITIONS);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, notq, SpanWeight.Postings.POSITIONS);
 
     assertEquals(2, spans.advance(2));
     spans.nextStartPosition();
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestSpanContainQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestSpanContainQuery.java	(revision 1709810)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestSpanContainQuery.java	(working copy)
@@ -70,21 +70,21 @@
     CheckHits.checkHits(random(), query, field, searcher, results);
   }
 
-  Spans makeSpans(SpanQuery sq) throws Exception {
+  SpanScorer makeSpans(SpanQuery sq) throws Exception {
     return MultiSpansWrapper.wrap(searcher.getIndexReader(), sq);
   }
 
   void tstEqualSpans(String mes, SpanQuery expectedQ, SpanQuery actualQ) throws Exception {
-    Spans expected = makeSpans(expectedQ);
-    Spans actual = makeSpans(actualQ);
+    SpanScorer expected = makeSpans(expectedQ);
+    SpanScorer actual = makeSpans(actualQ);
     tstEqualSpans(mes, expected, actual);
   }
 
-  void tstEqualSpans(String mes, Spans expected, Spans actual) throws Exception {
-    while (expected.nextDoc() != Spans.NO_MORE_DOCS) {
+  void tstEqualSpans(String mes, SpanScorer expected, SpanScorer actual) throws Exception {
+    while (expected.nextDoc() != SpanScorer.NO_MORE_DOCS) {
       assertEquals(expected.docID(), actual.nextDoc());
       assertEquals(expected.docID(), actual.docID());
-      while (expected.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+      while (expected.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
         assertEquals(expected.startPosition(), actual.nextStartPosition());
         assertEquals("start", expected.startPosition(), actual.startPosition());
         assertEquals("end", expected.endPosition(), actual.endPosition());
@@ -108,7 +108,7 @@
     SpanQuery containingPhraseOr = spanContainingQuery(phraseQ, w23);
     SpanQuery containedPhraseOr = spanWithinQuery(phraseQ, w23);
     tstEqualSpans("containing phrase or", phraseQ, containingPhraseOr);
-    Spans spans = makeSpans(containedPhraseOr);
+    SpanScorer spans = makeSpans(containedPhraseOr);
     assertNext(spans,0,1,2);
     assertNext(spans,0,2,3);
     assertNext(spans,1,2,3);
@@ -124,7 +124,7 @@
     SpanQuery containingPhraseW2 = spanContainingQuery(phraseQ, stqw2);
     SpanQuery containedPhraseW2 = spanWithinQuery(phraseQ, stqw2);
     tstEqualSpans("containing phrase w2", phraseQ, containingPhraseW2);
-    Spans spans = makeSpans(containedPhraseW2);
+    SpanScorer spans = makeSpans(containedPhraseW2);
     assertNext(spans,0,1,2);
     assertNext(spans,1,2,3);
     assertFinished(spans);
@@ -138,7 +138,7 @@
     SpanQuery containingPhraseW3 = spanContainingQuery(phraseQ, stqw3);
     SpanQuery containedPhraseW3 = spanWithinQuery(phraseQ, stqw3);
     tstEqualSpans("containing phrase w3", phraseQ, containingPhraseW3);
-    Spans spans = makeSpans(containedPhraseW3);
+    SpanScorer spans = makeSpans(containedPhraseW3);
     assertNext(spans,0,2,3);
     assertNext(spans,1,3,4);
     assertFinished(spans);
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java	(revision 1709810)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java	(working copy)
@@ -190,7 +190,7 @@
   public void testSpanNearOrderedOverlap() throws Exception {
     final SpanQuery query = spanNearOrderedQuery(field, 1, "t1", "t2", "t3");
     
-    Spans spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), query);
+    SpanScorer spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), query);
 
     assertEquals("first doc", 11, spans.nextDoc());
     assertEquals("first start", 0, spans.nextStartPosition());
@@ -205,7 +205,7 @@
   public void testSpanNearUnOrdered() throws Exception {
     //See http://www.gossamer-threads.com/lists/lucene/java-dev/52270 for discussion about this test
     SpanQuery senq = spanNearUnorderedQuery(field, 0, "u1", "u2");
-    Spans spans = MultiSpansWrapper.wrap(reader, senq);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, senq);
     assertNext(spans, 4, 1, 3);
     assertNext(spans, 5, 2, 4);
     assertNext(spans, 8, 2, 4);
@@ -227,23 +227,23 @@
     assertFinished(spans);
   }
 
-  private Spans orSpans(String[] terms) throws Exception {
+  private SpanScorer orSpans(String[] terms) throws Exception {
     return MultiSpansWrapper.wrap(searcher.getIndexReader(), spanOrQuery(field, terms));
   }
 
   public void testSpanOrEmpty() throws Exception {
-    Spans spans = orSpans(new String[0]);
+    SpanScorer spans = orSpans(new String[0]);
     assertFinished(spans);
   }
 
   public void testSpanOrSingle() throws Exception {
-    Spans spans = orSpans(new String[] {"w5"});
+    SpanScorer spans = orSpans(new String[] {"w5"});
     assertNext(spans, 0, 4, 5);
     assertFinished(spans);
   }
   
   public void testSpanOrDouble() throws Exception {
-    Spans spans = orSpans(new String[] {"w5", "yy"});
+    SpanScorer spans = orSpans(new String[] {"w5", "yy"});
     assertNext(spans, 0, 4, 5);
     assertNext(spans, 2, 3, 4);
     assertNext(spans, 3, 4, 5);
@@ -252,7 +252,7 @@
   }
 
   public void testSpanOrDoubleAdvance() throws Exception {
-    Spans spans = orSpans(new String[] {"w5", "yy"});
+    SpanScorer spans = orSpans(new String[] {"w5", "yy"});
     assertEquals("initial advance", 3, spans.advance(3));
     assertNext(spans, 3, 4, 5);
     assertNext(spans, 7, 3, 4);
@@ -260,7 +260,7 @@
   }
 
   public void testSpanOrUnused() throws Exception {
-    Spans spans = orSpans(new String[] {"w5", "unusedTerm", "yy"});
+    SpanScorer spans = orSpans(new String[] {"w5", "unusedTerm", "yy"});
     assertNext(spans, 0, 4, 5);
     assertNext(spans, 2, 3, 4);
     assertNext(spans, 3, 4, 5);
@@ -269,7 +269,7 @@
   }
 
   public void testSpanOrTripleSameDoc() throws Exception {
-    Spans spans = orSpans(new String[] {"t1", "t2", "t3"});
+    SpanScorer spans = orSpans(new String[] {"t1", "t2", "t3"});
     assertNext(spans, 11, 0, 1);
     assertNext(spans, 11, 1, 2);
     assertNext(spans, 11, 2, 3);
@@ -414,12 +414,12 @@
      SpanQuery iq = spanTermQuery(field, include);
      SpanQuery eq = spanTermQuery(field, exclude);
      SpanQuery snq = spanNotQuery(iq, eq, pre, post);
-     Spans spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), snq);
+     SpanScorer spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), snq);
 
      int i = 0;
      if (spans != null) {
-       while (spans.nextDoc() != Spans.NO_MORE_DOCS){
-         while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+       while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS){
+         while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
            i++;
          }
        }
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java	(revision 1709810)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java	(working copy)
@@ -37,7 +37,7 @@
 import static org.apache.lucene.search.spans.SpanTestUtil.*;
 
 /**
- * Tests Spans (v2)
+ * Tests SpanScorer (v2)
  *
  */
 public class TestSpansEnum extends LuceneTestCase {
Index: lucene/highlighter/src/java/org/apache/lucene/search/highlight/PositionSpan.java
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/highlight/PositionSpan.java	(revision 1709810)
+++ lucene/highlighter/src/java/org/apache/lucene/search/highlight/PositionSpan.java	(working copy)
@@ -17,7 +17,7 @@
  */
 
 /**
- * Utility class to record Positions Spans
+ * Utility class to record Positions SpanScorer
  * @lucene.internal
  */
 public class PositionSpan {
Index: lucene/highlighter/src/java/org/apache/lucene/search/highlight/SimpleSpanFragmenter.java
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/highlight/SimpleSpanFragmenter.java	(revision 1709810)
+++ lucene/highlighter/src/java/org/apache/lucene/search/highlight/SimpleSpanFragmenter.java	(working copy)
@@ -23,12 +23,12 @@
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.search.spans.SpanScorer;
 
 
 /**
  * {@link Fragmenter} implementation which breaks text up into same-size
- * fragments but does not split up {@link Spans}. This is a simple sample class.
+ * fragments but does not split up {@link SpanScorer}. This is a simple sample class.
  */
 public class SimpleSpanFragmenter implements Fragmenter {
   private static final int DEFAULT_FRAGMENT_SIZE = 100;
Index: lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java	(revision 1709810)
+++ lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java	(working copy)
@@ -63,9 +63,9 @@
 import org.apache.lucene.search.spans.SpanNotQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.IOUtils;
 
@@ -286,17 +286,17 @@
       LeafReaderContext context = getLeafContext();
       SpanWeight w = (SpanWeight) searcher.createNormalizedWeight(q, false);
       Bits acceptDocs = context.reader().getLiveDocs();
-      final Spans spans = w.getSpans(context, SpanWeight.Postings.POSITIONS);
+      final SpanScorer spans = w.spanScorer(context, SpanWeight.Postings.POSITIONS);
       if (spans == null) {
         return;
       }
 
       // collect span positions
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+      while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
         if (acceptDocs != null && acceptDocs.get(spans.docID()) == false) {
           continue;
         }
-        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+        while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
           spanPositions.add(new PositionSpan(spans.startPosition(), spans.endPosition() - 1));
         }
       }
Index: lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadFunction.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadFunction.java	(revision 1709810)
+++ lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadFunction.java	(working copy)
@@ -17,6 +17,7 @@
  */
 
 import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.spans.SpanScorer;
 
 /**
  * An abstract class that defines a way for PayloadScoreQuery instances to transform
@@ -41,7 +42,7 @@
    * @param currentPayloadScore The score for the current payload
    * @return The new current Score
    *
-   * @see org.apache.lucene.search.spans.Spans
+   * @see SpanScorer
    */
   public abstract float currentScore(int docId, String field, int start, int end, int numPayloadsSeen, float currentScore, float currentPayloadScore);
 
Index: lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadScoreQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadScoreQuery.java	(revision 1709810)
+++ lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadScoreQuery.java	(working copy)
@@ -32,9 +32,8 @@
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.spans.SpanCollector;
 import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanWeight;
 import org.apache.lucene.search.spans.SpanScorer;
-import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.util.BytesRef;
 
 /**
@@ -128,13 +127,13 @@
     }
 
     @Override
-    public Spans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
-      return innerWeight.getSpans(ctx, requiredPostings.atLeast(Postings.PAYLOADS));
+    public SpanScorer spanScorer(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
+      return innerWeight.spanScorer(ctx, requiredPostings.atLeast(Postings.PAYLOADS));
     }
 
     @Override
     public Scorer scorer(LeafReaderContext context) throws IOException {
-      Spans spans = getSpans(context, Postings.PAYLOADS);
+      SpanScorer spans = spanScorer(context, Postings.PAYLOADS);
       if (spans == null)
         return null;
       return new PayloadSpanScorer(spans, this, innerWeight.getSimScorer(context));
@@ -178,12 +177,39 @@
 
     private int payloadsSeen;
     private float payloadScore;
+    private final SpanScorer in;
 
-    private PayloadSpanScorer(Spans spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
-      super(spans, weight, docScorer);
+    private PayloadSpanScorer(SpanScorer spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
+      super(weight, docScorer);
+      this.in = spans;
     }
 
     @Override
+    public int nextStartPosition() throws IOException {
+      return in.nextStartPosition();
+    }
+
+    @Override
+    public int startPosition() {
+      return in.startPosition();
+    }
+
+    @Override
+    public int endPosition() {
+      return in.endPosition();
+    }
+
+    @Override
+    public int width() {
+      return in.width();
+    }
+
+    @Override
+    public void collect(SpanCollector collector) throws IOException {
+      in.collect(collector);
+    }
+
+    @Override
     protected void doStartCurrentDoc() {
       payloadScore = 0;
       payloadsSeen = 0;
@@ -191,7 +217,7 @@
 
     @Override
     protected void doCurrentSpans() throws IOException {
-      spans.collect(this);
+      in.collect(this);
     }
 
     @Override
@@ -199,8 +225,8 @@
       BytesRef payload = postings.getPayload();
       if (payload == null)
         return;
-      float payloadFactor = docScorer.computePayloadFactor(docID(), spans.startPosition(), spans.endPosition(), payload);
-      payloadScore = function.currentScore(docID(), getField(), spans.startPosition(), spans.endPosition(),
+      float payloadFactor = docScorer.computePayloadFactor(docID(), in.startPosition(), in.endPosition(), payload);
+      payloadScore = function.currentScore(docID(), getField(), in.startPosition(), in.endPosition(),
                                             payloadsSeen, payloadScore, payloadFactor);
       payloadsSeen++;
     }
@@ -228,6 +254,26 @@
     public void reset() {
 
     }
+
+    @Override
+    public int docID() {
+      return in.docID();
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      return in.nextDoc();
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      return in.advance(target);
+    }
+
+    @Override
+    public long cost() {
+      return in.cost();
+    }
   }
 
 }
Index: lucene/queries/src/java/org/apache/lucene/queries/payloads/SpanPayloadCheckQuery.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/payloads/SpanPayloadCheckQuery.java	(revision 1709810)
+++ lucene/queries/src/java/org/apache/lucene/queries/payloads/SpanPayloadCheckQuery.java	(working copy)
@@ -28,14 +28,12 @@
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Scorer;
-import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.spans.FilterSpans;
 import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
 import org.apache.lucene.search.spans.SpanCollector;
 import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanWeight;
 import org.apache.lucene.search.spans.SpanScorer;
-import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.util.BytesRef;
 
 /**
@@ -67,7 +65,7 @@
   }
 
   /**
-   * Weight that pulls its Spans using a PayloadSpanCollector
+   * Weight that pulls its SpanScorer using a PayloadSpanCollector
    */
   public class SpanPayloadCheckWeight extends SpanWeight {
 
@@ -89,12 +87,12 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+    public SpanScorer spanScorer(final LeafReaderContext context, Postings requiredPostings) throws IOException {
       final PayloadChecker collector = new PayloadChecker();
-      Spans matchSpans = matchWeight.getSpans(context, requiredPostings.atLeast(Postings.PAYLOADS));
-      return (matchSpans == null) ? null : new FilterSpans(matchSpans) {
+      SpanScorer matchSpans = matchWeight.spanScorer(context, requiredPostings.atLeast(Postings.PAYLOADS));
+      return (matchSpans == null) ? null : new FilterSpans(matchSpans, getSimScorer(context)) {
         @Override
-        protected AcceptStatus accept(Spans candidate) throws IOException {
+        protected AcceptStatus accept(SpanScorer candidate) throws IOException {
           collector.reset();
           candidate.collect(collector);
           return collector.match();
@@ -112,9 +110,7 @@
         throw new IllegalStateException("field \"" + field + "\" was indexed without position data; cannot run SpanQuery (query=" + parentQuery + ")");
       }
 
-      Spans spans = getSpans(context, Postings.PAYLOADS);
-      Similarity.SimScorer simScorer = simWeight == null ? null : similarity.simScorer(simWeight, context);
-      return (spans == null) ? null : new SpanScorer(spans, this, simScorer);
+      return spanScorer(context, Postings.PAYLOADS);
     }
   }
 
Index: lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadSpans.java
===================================================================
--- lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadSpans.java	(revision 1709810)
+++ lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadSpans.java	(working copy)
@@ -48,9 +48,9 @@
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanNotQuery;
 import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
@@ -72,7 +72,7 @@
 
   public void testSpanTermQuery() throws Exception {
     SpanTermQuery stq;
-    Spans spans;
+    SpanScorer spans;
     stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "seventy"));
 
     spans = MultiSpansWrapper.wrap(indexReader, stq, SpanWeight.Postings.PAYLOADS);
@@ -91,7 +91,7 @@
     SpanFirstQuery sfq;
     match = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
     sfq = new SpanFirstQuery(match, 2);
-    Spans spans = MultiSpansWrapper.wrap(indexReader, sfq, SpanWeight.Postings.PAYLOADS);
+    SpanScorer spans = MultiSpansWrapper.wrap(indexReader, sfq, SpanWeight.Postings.PAYLOADS);
     checkSpans(spans, 109, 1, 1, 1);
     //Test more complicated subclause
     SpanQuery[] clauses = new SpanQuery[2];
@@ -133,7 +133,7 @@
   
   public void testNestedSpans() throws Exception {
     SpanTermQuery stq;
-    Spans spans;
+    SpanScorer spans;
     IndexSearcher searcher = getSearcher();
 
     stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "mark"));
@@ -187,7 +187,7 @@
   }
   
   public void testFirstClauseWithoutPayload() throws Exception {
-    Spans spans;
+    SpanScorer spans;
     IndexSearcher searcher = getSearcher();
 
     SpanQuery[] clauses = new SpanQuery[3];
@@ -219,7 +219,7 @@
   }
   
   public void testHeavilyNestedSpanQuery() throws Exception {
-    Spans spans;
+    SpanScorer spans;
     IndexSearcher searcher = getSearcher();
 
     SpanQuery[] clauses = new SpanQuery[3];
@@ -273,13 +273,13 @@
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 1, true);
     VerifyingCollector collector = new VerifyingCollector();
-    Spans spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
+    SpanScorer spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
     for (int i = 0; i < topDocs.scoreDocs.length; i++) {
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+      while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+        while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
           collector.reset();
           spans.collect(collector);
           for (final BytesRef payload : collector.payloads) {
@@ -312,13 +312,13 @@
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
     VerifyingCollector collector = new VerifyingCollector();
-    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
+    SpanScorer spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
     for (int i = 0; i < topDocs.scoreDocs.length; i++) {
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+      while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+        while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
           collector.reset();
           spans.collect(collector);
           for (final BytesRef payload: collector.payloads) {
@@ -350,14 +350,14 @@
     SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
-    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
+    SpanScorer spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
     VerifyingCollector collector = new VerifyingCollector();
     for (int i = 0; i < topDocs.scoreDocs.length; i++) {
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+      while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+        while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
           collector.reset();
           spans.collect(collector);
           for (final BytesRef payload : collector.payloads) {
@@ -402,7 +402,7 @@
     }
   }
 
-  private void checkSpans(Spans spans, int expectedNumSpans, int expectedNumPayloads,
+  private void checkSpans(SpanScorer spans, int expectedNumSpans, int expectedNumPayloads,
                           int expectedPayloadLength, int expectedFirstByte) throws IOException {
     assertTrue("spans is null and it shouldn't be", spans != null);
     //each position match should have a span associated with it, since there is just one underlying term query, there should
@@ -409,8 +409,8 @@
     //only be one entry in the span
     VerifyingCollector collector = new VerifyingCollector();
     int seen = 0;
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-      while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+    while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
         collector.reset();
         spans.collect(collector);
         collector.verify(expectedPayloadLength, expectedFirstByte);
@@ -443,13 +443,13 @@
     return searcher;
   }
   
-  private void checkSpans(Spans spans, int numSpans, int[] numPayloads) throws IOException {
+  private void checkSpans(SpanScorer spans, int numSpans, int[] numPayloads) throws IOException {
     int cnt = 0;
     VerifyingCollector collector = new VerifyingCollector();
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-      while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+    while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
         if(VERBOSE)
-          System.out.println("\nSpans Dump --");
+          System.out.println("\nSpanScorer Dump --");
         collector.reset();
         spans.collect(collector);
         assertEquals("payload size", numPayloads[cnt], collector.payloads.size());
Index: lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java
===================================================================
--- lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java	(revision 1709810)
+++ lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java	(working copy)
@@ -41,8 +41,8 @@
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.spans.MultiSpansWrapper;
 import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.English;
@@ -164,7 +164,7 @@
       assertTrue(doc.score + " does not equal: " + 1, doc.score == 1);
     }
     CheckHits.checkExplanations(query, PayloadHelper.FIELD, searcher, true);
-    Spans spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), query);
+    SpanScorer spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), query);
     assertTrue("spans is null and it shouldn't be", spans != null);
     /*float score = hits.score(0);
     for (int i =1; i < hits.length(); i++)
@@ -215,13 +215,13 @@
     }
     assertTrue(numTens + " does not equal: " + 10, numTens == 10);
     CheckHits.checkExplanations(query, "field", searcher, true);
-    Spans spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), query);
+    SpanScorer spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), query);
     assertTrue("spans is null and it shouldn't be", spans != null);
     //should be two matches per document
     int count = 0;
     //100 hits times 2 matches per hit, we should have 200 in count
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-      while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+    while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
         count++;
       }
     }
Index: lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanUtil.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanUtil.java	(revision 1709810)
+++ lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanUtil.java	(working copy)
@@ -38,9 +38,9 @@
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
 
 /**
  * Experimental class to get set of payloads for most standard Lucene queries.
@@ -176,10 +176,10 @@
 
     PayloadSpanCollector collector = new PayloadSpanCollector();
     for (LeafReaderContext leafReaderContext : context.leaves()) {
-      final Spans spans = w.getSpans(leafReaderContext, SpanWeight.Postings.PAYLOADS);
+      final SpanScorer spans = w.spanScorer(leafReaderContext, SpanWeight.Postings.PAYLOADS);
       if (spans != null) {
-        while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-          while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+        while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+          while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
             collector.reset();
             spans.collect(collector);
             payloads.addAll(collector.getPayloads());
Index: lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java	(revision 1709810)
+++ lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java	(working copy)
@@ -17,6 +17,10 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.Map;
+import java.util.Set;
+
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
@@ -23,11 +27,8 @@
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.similarities.Similarity;
 
-import java.io.IOException;
-import java.util.Map;
-import java.util.Set;
-
 /**
  * Wraps a SpanWeight with additional asserts
  */
@@ -51,14 +52,19 @@
   }
 
   @Override
-  public Spans getSpans(LeafReaderContext context, Postings requiredPostings) throws IOException {
-    Spans spans = in.getSpans(context, requiredPostings);
+  public SpanScorer spanScorer(LeafReaderContext context, Postings requiredPostings) throws IOException {
+    SpanScorer spans = in.spanScorer(context, requiredPostings);
     if (spans == null)
       return null;
-    return new AssertingSpans(spans);
+    return new AssertingSpans(spans, in.getSimScorer(context));
   }
 
   @Override
+  public Similarity.SimScorer getSimScorer(LeafReaderContext context) throws IOException {
+    return in.getSimScorer(context);
+  }
+
+  @Override
   public void extractTerms(Set<Term> terms) {
     in.extractTerms(terms);
   }
Index: lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java	(revision 1709810)
+++ lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java	(working copy)
@@ -17,16 +17,17 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.similarities.Similarity;
 
-import java.io.IOException;
-
 /** 
- * Wraps a Spans with additional asserts 
+ * Wraps a SpanScorer with additional asserts
  */
-class AssertingSpans extends Spans {
-  final Spans in;
+class AssertingSpans extends SpanScorer {
+  final SpanScorer in;
   int doc = -1;
   
   /** 
@@ -67,7 +68,8 @@
   
   State state = State.DOC_START;
   
-  AssertingSpans(Spans in) {
+  AssertingSpans(SpanScorer in, Similarity.SimScorer docScorer) {
+    super((SpanWeight)in.getWeight(), docScorer);
     this.in = in;
   }
   
@@ -187,8 +189,14 @@
   public long cost() {
     return in.cost();
   }
-  
+
   @Override
+  protected float scoreCurrentDoc() throws IOException {
+    assert in.docScorer != null : in.getClass() + " has no docScorer!";
+    return in.scoreCurrentDoc();
+  }
+
+  @Override
   public TwoPhaseIterator asTwoPhaseIterator() {
     final TwoPhaseIterator iterator = in.asTwoPhaseIterator();
     if (iterator == null) {
@@ -196,7 +204,7 @@
     }
     return new AssertingTwoPhaseView(iterator);
   }
-  
+
   class AssertingTwoPhaseView extends TwoPhaseIterator {
     final TwoPhaseIterator in;
     int lastDoc = -1;
Index: lucene/test-framework/src/java/org/apache/lucene/search/spans/MultiSpansWrapper.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/spans/MultiSpansWrapper.java	(revision 1709810)
+++ lucene/test-framework/src/java/org/apache/lucene/search/spans/MultiSpansWrapper.java	(working copy)
@@ -34,11 +34,11 @@
  */
 public class MultiSpansWrapper {
 
-  public static Spans wrap(IndexReader reader, SpanQuery spanQuery) throws IOException {
+  public static SpanScorer wrap(IndexReader reader, SpanQuery spanQuery) throws IOException {
     return wrap(reader, spanQuery, SpanWeight.Postings.POSITIONS);
   }
 
-  public static Spans wrap(IndexReader reader, SpanQuery spanQuery, SpanWeight.Postings requiredPostings) throws IOException {
+  public static SpanScorer wrap(IndexReader reader, SpanQuery spanQuery, SpanWeight.Postings requiredPostings) throws IOException {
 
     LeafReader lr = SlowCompositeReaderWrapper.wrap(reader); // slow, but ok for testing
     LeafReaderContext lrContext = lr.getContext();
@@ -47,6 +47,6 @@
 
     SpanWeight w = spanQuery.createWeight(searcher, false);
 
-    return w.getSpans(lrContext, requiredPostings);
+    return w.spanScorer(lrContext, requiredPostings);
   }
 }
Index: lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java	(revision 1709810)
+++ lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java	(working copy)
@@ -144,21 +144,21 @@
    * Assert the next iteration from {@code spans} is a match
    * from {@code start} to {@code end} in {@code doc}.
    */
-  public static void assertNext(Spans spans, int doc, int start, int end) throws IOException {
+  public static void assertNext(SpanScorer spans, int doc, int start, int end) throws IOException {
     if (spans.docID() >= doc) {
       assertEquals("docId", doc, spans.docID());
     } else { // nextDoc needed before testing start/end
       if (spans.docID() >= 0) {
-        assertEquals("nextStartPosition of previous doc", Spans.NO_MORE_POSITIONS, spans.nextStartPosition());
-        assertEquals("endPosition of previous doc", Spans.NO_MORE_POSITIONS, spans.endPosition());
+        assertEquals("nextStartPosition of previous doc", SpanScorer.NO_MORE_POSITIONS, spans.nextStartPosition());
+        assertEquals("endPosition of previous doc", SpanScorer.NO_MORE_POSITIONS, spans.endPosition());
       }
       assertEquals("nextDoc", doc, spans.nextDoc());
-      if (doc != Spans.NO_MORE_DOCS) {
+      if (doc != SpanScorer.NO_MORE_DOCS) {
         assertEquals("first startPosition", -1, spans.startPosition());
         assertEquals("first endPosition", -1, spans.endPosition());
       }
     }
-    if (doc != Spans.NO_MORE_DOCS) {
+    if (doc != SpanScorer.NO_MORE_DOCS) {
       assertEquals("nextStartPosition", start, spans.nextStartPosition());
       assertEquals("startPosition", start, spans.startPosition());
       assertEquals("endPosition", end, spans.endPosition());
@@ -168,9 +168,9 @@
   /** 
    * Assert that {@code spans} is exhausted.
    */
-  public static void assertFinished(Spans spans) throws Exception {
-    if (spans != null) { // null Spans is empty
-      assertNext(spans, Spans.NO_MORE_DOCS, -2, -2); // start and end positions will be ignored
+  public static void assertFinished(SpanScorer spans) throws Exception {
+    if (spans != null) { // null SpanScorer is empty
+      assertNext(spans, SpanScorer.NO_MORE_DOCS, -2, -2); // start and end positions will be ignored
     }
   }
 }
