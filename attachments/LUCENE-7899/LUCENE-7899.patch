diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index 3d875c3..83bdef8 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -107,6 +107,9 @@ API Changes
   name contains "slow" in order to cleary indicate that they would usually be a
   bad choice. (Adrien Grand)
 
+* LUCENE-7899: FieldValueQuery is renamed to DocValuesFieldExistsQuery
+  (Adrien Grand, Mike McCandless)
+
 Bug Fixes
 
 * LUCENE-7626: IndexWriter will no longer accept broken token offsets
diff --git a/lucene/MIGRATE.txt b/lucene/MIGRATE.txt
index e7edcc5..e5e2822 100644
--- a/lucene/MIGRATE.txt
+++ b/lucene/MIGRATE.txt
@@ -144,3 +144,5 @@ can safely be casted to an int in that case.
 
 Instead use ConcatentingTokenStream, which will allow for the use of custom
 attributes.
+
+## FieldValueQuery is renamed to DocValuesFieldExistsQuery (LUCENE-7899)
diff --git a/lucene/core/src/java/org/apache/lucene/document/SortedNumericDocValuesRangeQuery.java b/lucene/core/src/java/org/apache/lucene/document/SortedNumericDocValuesRangeQuery.java
index 18805b2..5da0733 100644
--- a/lucene/core/src/java/org/apache/lucene/document/SortedNumericDocValuesRangeQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/document/SortedNumericDocValuesRangeQuery.java
@@ -27,7 +27,7 @@ import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.SortedNumericDocValues;
 import org.apache.lucene.search.ConstantScoreScorer;
 import org.apache.lucene.search.ConstantScoreWeight;
-import org.apache.lucene.search.FieldValueQuery;
+import org.apache.lucene.search.DocValuesFieldExistsQuery;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
@@ -84,7 +84,7 @@ abstract class SortedNumericDocValuesRangeQuery extends Query {
   @Override
   public Query rewrite(IndexReader reader) throws IOException {
     if (lowerValue == Long.MIN_VALUE && upperValue == Long.MAX_VALUE) {
-      return new FieldValueQuery(field);
+      return new DocValuesFieldExistsQuery(field);
     }
     return super.rewrite(reader);
   }
diff --git a/lucene/core/src/java/org/apache/lucene/document/SortedSetDocValuesRangeQuery.java b/lucene/core/src/java/org/apache/lucene/document/SortedSetDocValuesRangeQuery.java
index 30af45f..860679a 100644
--- a/lucene/core/src/java/org/apache/lucene/document/SortedSetDocValuesRangeQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/document/SortedSetDocValuesRangeQuery.java
@@ -27,7 +27,7 @@ import org.apache.lucene.index.SortedDocValues;
 import org.apache.lucene.index.SortedSetDocValues;
 import org.apache.lucene.search.ConstantScoreScorer;
 import org.apache.lucene.search.ConstantScoreWeight;
-import org.apache.lucene.search.FieldValueQuery;
+import org.apache.lucene.search.DocValuesFieldExistsQuery;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
@@ -95,7 +95,7 @@ abstract class SortedSetDocValuesRangeQuery extends Query {
   @Override
   public Query rewrite(IndexReader reader) throws IOException {
     if (lowerValue == null && upperValue == null) {
-      return new FieldValueQuery(field);
+      return new DocValuesFieldExistsQuery(field);
     }
     return super.rewrite(reader);
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/DocValuesFieldExistsQuery.java b/lucene/core/src/java/org/apache/lucene/search/DocValuesFieldExistsQuery.java
new file mode 100644
index 0000000..cbb5e04
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/DocValuesFieldExistsQuery.java
@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.Objects;
+
+import org.apache.lucene.index.DocValuesType;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.index.LeafReaderContext;
+
+/**
+ * A {@link Query} that matches documents that have a value for a given field
+ * as reported by doc values iterators.
+ */
+public final class DocValuesFieldExistsQuery extends Query {
+
+  private final String field;
+
+  /** Create a query that will match that have a value for the given
+   *  {@code field}. */
+  public DocValuesFieldExistsQuery(String field) {
+    this.field = Objects.requireNonNull(field);
+  }
+
+  public String getField() {
+    return field;
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    return sameClassAs(other) &&
+           field.equals(((DocValuesFieldExistsQuery) other).field);
+  }
+
+  @Override
+  public int hashCode() {
+    return 31 * classHash() + field.hashCode();
+  }
+
+  @Override
+  public String toString(String field) {
+    return "DocValuesFieldExistsQuery [field=" + this.field + "]";
+  }
+
+  @Override
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {
+    return new ConstantScoreWeight(this, boost) {
+      @Override
+      public Scorer scorer(LeafReaderContext context) throws IOException {
+        FieldInfos fieldInfos = context.reader().getFieldInfos();
+        FieldInfo fieldInfo = fieldInfos.fieldInfo(field);
+        if (fieldInfo == null) {
+          return null;
+        }
+        DocValuesType dvType = fieldInfo.getDocValuesType();
+        LeafReader reader = context.reader();
+        DocIdSetIterator iterator;
+        switch(dvType) {
+        case NONE:
+          return null;
+        case NUMERIC:
+          iterator = reader.getNumericDocValues(field);
+          break;
+        case BINARY:
+          iterator = reader.getBinaryDocValues(field);
+          break;
+        case SORTED:
+          iterator = reader.getSortedDocValues(field);
+          break;
+        case SORTED_NUMERIC:
+          iterator = reader.getSortedNumericDocValues(field);
+          break;
+        case SORTED_SET:
+          iterator = reader.getSortedSetDocValues(field);
+          break;
+        default:
+          throw new AssertionError();
+        }
+
+        return new ConstantScoreScorer(this, score(), iterator);
+      }
+    };
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/FieldValueQuery.java b/lucene/core/src/java/org/apache/lucene/search/FieldValueQuery.java
deleted file mode 100644
index 8a47eea..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/FieldValueQuery.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search;
-
-
-import java.io.IOException;
-import java.util.Objects;
-
-import org.apache.lucene.index.DocValuesType;
-import org.apache.lucene.index.FieldInfo;
-import org.apache.lucene.index.FieldInfos;
-import org.apache.lucene.index.LeafReader;
-import org.apache.lucene.index.LeafReaderContext;
-
-/**
- * A {@link Query} that matches documents that have a value for a given field
- * as reported by doc values iterators.
- */
-public final class FieldValueQuery extends Query {
-
-  private final String field;
-
-  /** Create a query that will match that have a value for the given
-   *  {@code field}. */
-  public FieldValueQuery(String field) {
-    this.field = Objects.requireNonNull(field);
-  }
-
-  public String getField() {
-    return field;
-  }
-
-  @Override
-  public boolean equals(Object other) {
-    return sameClassAs(other) &&
-           field.equals(((FieldValueQuery) other).field);
-  }
-
-  @Override
-  public int hashCode() {
-    return 31 * classHash() + field.hashCode();
-  }
-
-  @Override
-  public String toString(String field) {
-    return "FieldValueQuery [field=" + this.field + "]";
-  }
-
-  @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {
-    return new ConstantScoreWeight(this, boost) {
-      @Override
-      public Scorer scorer(LeafReaderContext context) throws IOException {
-        FieldInfos fieldInfos = context.reader().getFieldInfos();
-        FieldInfo fieldInfo = fieldInfos.fieldInfo(field);
-        if (fieldInfo == null) {
-          return null;
-        }
-        DocValuesType dvType = fieldInfo.getDocValuesType();
-        LeafReader reader = context.reader();
-        DocIdSetIterator iterator;
-        switch(dvType) {
-        case NONE:
-          return null;
-        case NUMERIC:
-          iterator = reader.getNumericDocValues(field);
-          break;
-        case BINARY:
-          iterator = reader.getBinaryDocValues(field);
-          break;
-        case SORTED:
-          iterator = reader.getSortedDocValues(field);
-          break;
-        case SORTED_NUMERIC:
-          iterator = reader.getSortedNumericDocValues(field);
-          break;
-        case SORTED_SET:
-          iterator = reader.getSortedSetDocValues(field);
-          break;
-        default:
-          throw new AssertionError();
-        }
-
-        return new ConstantScoreScorer(this, score(), iterator);
-      }
-    };
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestFieldValueQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestFieldValueQuery.java
index b3478f5..99452f8 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestFieldValueQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestFieldValueQuery.java
@@ -59,8 +59,8 @@ public class TestFieldValueQuery extends LuceneTestCase {
       final IndexSearcher searcher = newSearcher(reader);
       iw.close();
 
-      assertSameMatches(searcher, new TermQuery(new Term("has_value", "yes")), new FieldValueQuery("dv1"), false);
-      assertSameMatches(searcher, new TermQuery(new Term("has_value", "yes")), new FieldValueQuery("dv2"), false);
+      assertSameMatches(searcher, new TermQuery(new Term("has_value", "yes")), new DocValuesFieldExistsQuery("dv1"), false);
+      assertSameMatches(searcher, new TermQuery(new Term("has_value", "yes")), new DocValuesFieldExistsQuery("dv2"), false);
 
       reader.close();
       dir.close();
@@ -99,12 +99,12 @@ public class TestFieldValueQuery extends LuceneTestCase {
 
       BooleanQuery.Builder bq1 = new BooleanQuery.Builder();
       bq1.add(new TermQuery(new Term("f", "yes")), Occur.MUST);
-      bq1.add(new FieldValueQuery("dv1"), Occur.FILTER);
+      bq1.add(new DocValuesFieldExistsQuery("dv1"), Occur.FILTER);
       assertSameMatches(searcher, ref.build(), bq1.build(), true);
 
       BooleanQuery.Builder bq2 = new BooleanQuery.Builder();
       bq2.add(new TermQuery(new Term("f", "yes")), Occur.MUST);
-      bq2.add(new FieldValueQuery("dv2"), Occur.FILTER);
+      bq2.add(new DocValuesFieldExistsQuery("dv2"), Occur.FILTER);
       assertSameMatches(searcher, ref.build(), bq2.build(), true);
 
       reader.close();
@@ -141,10 +141,10 @@ public class TestFieldValueQuery extends LuceneTestCase {
       final float boost = random().nextFloat() * 10;
       final Query ref = new BoostQuery(new ConstantScoreQuery(new TermQuery(new Term("has_value", "yes"))), boost);
 
-      final Query q1 = new BoostQuery(new FieldValueQuery("dv1"), boost);
+      final Query q1 = new BoostQuery(new DocValuesFieldExistsQuery("dv1"), boost);
       assertSameMatches(searcher, ref, q1, true);
 
-      final Query q2 = new BoostQuery(new FieldValueQuery("dv2"), boost);
+      final Query q2 = new BoostQuery(new DocValuesFieldExistsQuery("dv2"), boost);
       assertSameMatches(searcher, ref, q2, true);
 
       reader.close();
@@ -160,7 +160,7 @@ public class TestFieldValueQuery extends LuceneTestCase {
     final IndexReader reader = iw.getReader();
     final IndexSearcher searcher = newSearcher(reader);
     iw.close();
-    assertEquals(0, searcher.search(new FieldValueQuery("f"), 1).totalHits);
+    assertEquals(0, searcher.search(new DocValuesFieldExistsQuery("f"), 1).totalHits);
     reader.close();
     dir.close();
   }
@@ -175,7 +175,7 @@ public class TestFieldValueQuery extends LuceneTestCase {
     final IndexReader reader = iw.getReader();
     final IndexSearcher searcher = newSearcher(reader);
     iw.close();
-    assertEquals(1, searcher.search(new FieldValueQuery("f"), 1).totalHits);
+    assertEquals(1, searcher.search(new DocValuesFieldExistsQuery("f"), 1).totalHits);
     reader.close();
     dir.close();
   }
@@ -193,7 +193,7 @@ public class TestFieldValueQuery extends LuceneTestCase {
     final IndexReader reader = iw.getReader();
     final IndexSearcher searcher = newSearcher(reader);
     iw.close();
-    assertEquals(1, searcher.search(new FieldValueQuery("f"), 1).totalHits);
+    assertEquals(1, searcher.search(new DocValuesFieldExistsQuery("f"), 1).totalHits);
     reader.close();
     dir.close();
   }
diff --git a/lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java b/lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java
index 0bd4784..b1a4a02 100644
--- a/lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java
+++ b/lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java
@@ -70,8 +70,8 @@ import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.DocValuesFieldExistsQuery;
 import org.apache.lucene.search.Explanation;
-import org.apache.lucene.search.FieldValueQuery;
 import org.apache.lucene.search.FilterScorer;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
@@ -532,7 +532,7 @@ public class TestJoinUtil extends LuceneTestCase {
   static Query numericDocValuesScoreQuery(final String field) {
     return new Query() {
 
-        private final Query fieldQuery = new FieldValueQuery(field);
+        private final Query fieldQuery = new DocValuesFieldExistsQuery(field);
 
         @Override
         public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {
diff --git a/solr/core/src/java/org/apache/solr/schema/CurrencyFieldType.java b/solr/core/src/java/org/apache/solr/schema/CurrencyFieldType.java
index 0ace37e..a6ba164 100644
--- a/solr/core/src/java/org/apache/solr/schema/CurrencyFieldType.java
+++ b/solr/core/src/java/org/apache/solr/schema/CurrencyFieldType.java
@@ -27,24 +27,24 @@ import java.util.Map;
 import org.apache.lucene.analysis.util.ResourceLoader;
 import org.apache.lucene.analysis.util.ResourceLoaderAware;
 import org.apache.lucene.document.StoredField;
-import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.IndexableField;
+import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.FieldValueQuery;
+import org.apache.lucene.search.DocValuesFieldExistsQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SortField;
-import org.apache.solr.uninverting.UninvertingReader.Type;
-import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
+import org.apache.solr.common.SolrException;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.Filter;
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.QueryWrapperFilter;
 import org.apache.solr.search.SolrConstantScoreQuery;
 import org.apache.solr.search.function.ValueSourceRangeFilter;
+import org.apache.solr.uninverting.UninvertingReader.Type;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -331,7 +331,7 @@ public class CurrencyFieldType extends FieldType implements SchemaAware, Resourc
         (p2 != null) ? p2.getCurrencyCode() : defaultCurrency;
 
     // ValueSourceRangeFilter doesn't check exists(), so we have to
-    final Filter docsWithValues = new QueryWrapperFilter(new FieldValueQuery(getAmountField(field).getName()));
+    final Filter docsWithValues = new QueryWrapperFilter(new DocValuesFieldExistsQuery(getAmountField(field).getName()));
     final Filter vsRangeFilter = new ValueSourceRangeFilter
         (new RawCurrencyValueSource(field, currencyCode, parser),
             p1 == null ? null : p1.getAmount() + "",
