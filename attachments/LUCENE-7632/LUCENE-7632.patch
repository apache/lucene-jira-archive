diff --git a/lucene/core/src/java/org/apache/lucene/search/TermQuery.java b/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
index 73170b9..66055ea 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
@@ -33,6 +33,7 @@ import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
+import org.apache.lucene.util.BytesRef;
 
 /**
  * A Query that matches documents containing a term. This may be combined with
@@ -43,6 +44,64 @@ public class TermQuery extends Query {
   private final Term term;
   private final TermContext perReaderTermState;
 
+  /** Constructs a query for the term <code>t</code>. */
+  public TermQuery(Term t) {
+    term = Objects.requireNonNull(t);
+    perReaderTermState = null;
+  }
+
+  /**
+   * Constructs a query for the given field and term
+   */
+  public TermQuery(String field, String term) {
+    this(new Term(field, term));
+  }
+
+  /**
+   * Constructs a query for the given field and term
+   */
+  public TermQuery(String field, BytesRef term) {
+    this(new Term(field, term));
+  }
+
+  /**
+   * Expert: constructs a TermQuery that will use the provided docFreq instead
+   * of looking up the docFreq against the searcher.
+   */
+  public TermQuery(Term t, TermContext states) {
+    assert states != null;
+    term = Objects.requireNonNull(t);
+    perReaderTermState = Objects.requireNonNull(states);
+  }
+
+  /** Returns the term of this query. */
+  public Term getTerm() {
+    return term;
+  }
+
+  @Override
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {
+    final IndexReaderContext context = searcher.getTopReaderContext();
+    final TermContext termState;
+    if (perReaderTermState == null
+        || perReaderTermState.topReaderContext != context) {
+      if (needsScores) {
+        // make TermQuery single-pass if we don't have a PRTS or if the context
+        // differs!
+        termState = TermContext.build(context, term);
+      } else {
+        // do not compute the term state, this will help save seeks in the terms
+        // dict on segments that have a cache entry for this query
+        termState = null;
+      }
+    } else {
+      // PRTS was pre-build for this IS
+      termState = this.perReaderTermState;
+    }
+
+    return new TermWeight(searcher, needsScores, boost, termState);
+  }
+
   final class TermWeight extends Weight {
     private final Similarity similarity;
     private final Similarity.SimWeight stats;
@@ -50,7 +109,7 @@ public class TermQuery extends Query {
     private final boolean needsScores;
 
     public TermWeight(IndexSearcher searcher, boolean needsScores,
-        float boost, TermContext termStates) throws IOException {
+                      float boost, TermContext termStates) throws IOException {
       super(TermQuery.this);
       if (needsScores && termStates == null) {
         throw new IllegalStateException("termStates are required when scores are needed");
@@ -70,7 +129,7 @@ public class TermQuery extends Query {
         collectionStats = new CollectionStatistics(term.field(), maxDoc, -1, -1, -1);
         termStats = new TermStatistics(term.bytes(), maxDoc, -1);
       }
-     
+
       this.stats = similarity.computeWeight(boost, collectionStats, termStats);
     }
 
@@ -155,50 +214,6 @@ public class TermQuery extends Query {
     }
   }
 
-  /** Constructs a query for the term <code>t</code>. */
-  public TermQuery(Term t) {
-    term = Objects.requireNonNull(t);
-    perReaderTermState = null;
-  }
-
-  /**
-   * Expert: constructs a TermQuery that will use the provided docFreq instead
-   * of looking up the docFreq against the searcher.
-   */
-  public TermQuery(Term t, TermContext states) {
-    assert states != null;
-    term = Objects.requireNonNull(t);
-    perReaderTermState = Objects.requireNonNull(states);
-  }
-
-  /** Returns the term of this query. */
-  public Term getTerm() {
-    return term;
-  }
-
-  @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {
-    final IndexReaderContext context = searcher.getTopReaderContext();
-    final TermContext termState;
-    if (perReaderTermState == null
-        || perReaderTermState.topReaderContext != context) {
-      if (needsScores) {
-        // make TermQuery single-pass if we don't have a PRTS or if the context
-        // differs!
-        termState = TermContext.build(context, term);
-      } else {
-        // do not compute the term state, this will help save seeks in the terms
-        // dict on segments that have a cache entry for this query
-        termState = null;
-      }
-    } else {
-      // PRTS was pre-build for this IS
-      termState = this.perReaderTermState;
-    }
-
-    return new TermWeight(searcher, needsScores, boost, termState);
-  }
-
   /** Prints a user-readable version of this query. */
   @Override
   public String toString(String field) {
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
index 2746a0c..b12b8a5 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
@@ -33,6 +33,7 @@ import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.util.BytesRef;
 
 /** Matches spans containing a term.
  * This should not be used for terms that are indexed at position Integer.MAX_VALUE.
@@ -48,6 +49,16 @@ public class SpanTermQuery extends SpanQuery {
     this.termContext = null;
   }
 
+  /** Construct a SpanTermQuery for the given field and term */
+  public SpanTermQuery(String field, String term) {
+    this(new Term(field, term));
+  }
+
+  /** Construct a SpanTermQuery for the given field and term */
+  public SpanTermQuery(String field, BytesRef term) {
+    this(new Term(field, term));
+  }
+
   /**
    * Expert: Construct a SpanTermQuery matching the named term's spans, using
    * the provided TermContext
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestTermQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestTermQuery.java
index a994118..23ff490 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestTermQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestTermQuery.java
@@ -51,6 +51,9 @@ public class TestTermQuery extends LuceneTestCase {
     QueryUtils.checkEqual(
         new TermQuery(new Term("foo", "bar")),
         new TermQuery(new Term("foo", "bar"), TermContext.build(new MultiReader().getContext(), new Term("foo", "bar"))));
+    QueryUtils.checkEqual(
+        new TermQuery(new Term("foo", "bar")),
+        new TermQuery("foo", "bar"));
   }
 
   public void testCreateWeightDoesNotSeekIfScoresAreNotNeeded() throws IOException {
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanTermQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanTermQuery.java
index a1498ce..8e68c51 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanTermQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanTermQuery.java
@@ -39,6 +39,8 @@ public class TestSpanTermQuery extends LuceneTestCase {
     QueryUtils.check(q1);
     QueryUtils.check(q2);
     QueryUtils.checkUnequal(q1, q2);
+
+    QueryUtils.checkEqual(q1, new SpanTermQuery("field", "foo"));
   }
   
   public void testNoPositions() throws IOException {
