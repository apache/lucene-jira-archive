Index: java/org/apache/lucene/index/IndexWriter.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/index/IndexWriter.java,v
retrieving revision 1.35
diff -u -r1.35 IndexWriter.java
--- java/org/apache/lucene/index/IndexWriter.java	8 Aug 2004 13:03:59 -0000	1.35
+++ java/org/apache/lucene/index/IndexWriter.java	11 Aug 2004 10:12:14 -0000
@@ -153,6 +153,28 @@
   public Similarity getSimilarity() {
     return this.similarity;
   }
+ 
+  private int termIndexInterval = TermInfosWriter.DEFAULT_INDEX_INTERVAL;
+  
+  /**
+   * EXPERT : returns the term index interval used for this index.
+   **/
+  public int getTermIndexInterval() {
+  	return termIndexInterval;
+  }
+  
+  /**
+   * EXPERT : sets the term index interval used in this index. This value must be modified with caution.
+   * TermIndexInterval defines the number of Terms stored in the tii file of the index. This file is entirely 
+   * stored into memory, so using a low value may yield an OutOfMemoryException and a longer startup time
+   * for IndexReader. At the opposite modifying this value can be useful if the queries are large and the IndexReader
+   * is not opened too often.
+   * Default value is 128 - which offers a good trade off between speed and memory usage.
+   * TODO : provide figures
+   **/
+  public void setTermIndexInterval(int interval) {
+	termIndexInterval=interval;
+  }
 
   /**
    * Constructs an IndexWriter for the index in <code>path</code>.
@@ -261,6 +283,10 @@
       return analyzer;
   }
 
+  /** Returns the directory used by this index. */
+  public Directory getDirectory() {
+	return directory;
+  }
 
   /** Returns the number of documents currently in this index. */
   public synchronized int docCount() {
@@ -400,8 +426,7 @@
     optimize();					  // start with zero or 1 seg
 
     String mergedName = newSegmentName();
-    final SegmentMerger merger = new SegmentMerger(directory, mergedName);
-
+    final SegmentMerger merger = new SegmentMerger(this, mergedName);  
     final Vector segmentsToDelete = new Vector();
     IndexReader sReader = null;
     if (segmentInfos.size() == 1){ // add existing index, if any
@@ -481,9 +506,7 @@
       throws IOException {
     String mergedName = newSegmentName();
     if (infoStream != null) infoStream.print("merging segments");
-    final SegmentMerger merger =
-        new SegmentMerger(directory, mergedName);
-
+    final SegmentMerger merger =  new SegmentMerger(this, mergedName);
     final Vector segmentsToDelete = new Vector();
     for (int i = minSegment; i < segmentInfos.size(); i++) {
       SegmentInfo si = segmentInfos.info(i);
Index: java/org/apache/lucene/index/SegmentMerger.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/index/SegmentMerger.java,v
retrieving revision 1.12
diff -u -r1.12 SegmentMerger.java
--- java/org/apache/lucene/index/SegmentMerger.java	8 Aug 2004 13:03:59 -0000	1.12
+++ java/org/apache/lucene/index/SegmentMerger.java	11 Aug 2004 10:12:15 -0000
@@ -51,6 +51,8 @@
     "tvx", "tvd", "tvf"
   };
 
+  private int termIndexInterval = TermInfosWriter.DEFAULT_INDEX_INTERVAL;
+
   /**
    * 
    * @param dir The Directory to merge the other segments into
@@ -62,6 +64,17 @@
   }
 
   /**
+   * @param writer The IndexWriter that generated this SegmentMerger
+   * @param dir The Directory to merge the other segments into
+   * @param name The name of the new segment
+   */
+  SegmentMerger(IndexWriter writer, String name) {
+	directory = writer.getDirectory();
+	segment = name;
+	termIndexInterval = writer.getTermIndexInterval();
+  }
+
+  /**
    * Add an IndexReader to the collection of readers that are to be merged
    * @param reader
    */
@@ -241,7 +254,7 @@
       freqOutput = directory.createFile(segment + ".frq");
       proxOutput = directory.createFile(segment + ".prx");
       termInfosWriter =
-              new TermInfosWriter(directory, segment, fieldInfos);
+          new TermInfosWriter(directory, segment, fieldInfos,this.termIndexInterval);
       skipInterval = termInfosWriter.skipInterval;
       queue = new SegmentMergeQueue(readers.size());
 
Index: java/org/apache/lucene/index/TermInfosWriter.java
===================================================================
RCS file: /home/cvspublic/jakarta-lucene/src/java/org/apache/lucene/index/TermInfosWriter.java,v
retrieving revision 1.6
diff -u -r1.6 TermInfosWriter.java
--- java/org/apache/lucene/index/TermInfosWriter.java	20 Apr 2004 13:47:58 -0000	1.6
+++ java/org/apache/lucene/index/TermInfosWriter.java	11 Aug 2004 10:12:19 -0000
@@ -29,6 +29,10 @@
   /** The file format version, a negative number. */
   public static final int FORMAT = -2;
 
+  /** Expert: Default value for the Term Index Interval
+   **/
+  public static final int DEFAULT_INDEX_INTERVAL=128;
+
   private FieldInfos fieldInfos;
   private OutputStream output;
   private Term lastTerm = new Term("", "");
@@ -67,11 +71,25 @@
     other = new TermInfosWriter(directory, segment, fis, true);
     other.other = this;
   }
-
+  
+  TermInfosWriter(Directory directory, String segment, FieldInfos fis,int tii)
+         throws IOException {
+      this.indexInterval = tii;
+  	  initialize(directory, segment, fis, false);
+  	  other = new TermInfosWriter(directory, segment, fis, true, tii);
+  	  other.other = this;
+  	}
+  
   private TermInfosWriter(Directory directory, String segment, FieldInfos fis,
         boolean isIndex) throws IOException {
     initialize(directory, segment, fis, isIndex);
   }
+    
+  private TermInfosWriter(Directory directory, String segment, FieldInfos fis,
+  	  boolean isIndex, int tii) throws IOException {
+      this.indexInterval = tii;
+  	  initialize(directory, segment, fis, isIndex);
+     }
 
   private void initialize(Directory directory, String segment, FieldInfos fis,
          boolean isi) throws IOException {
