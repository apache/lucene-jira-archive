diff --git lucene/common-build.xml lucene/common-build.xml
index 71ff92b..84be224 100644
--- lucene/common-build.xml
+++ lucene/common-build.xml
@@ -974,9 +974,9 @@
             <!-- TODO: create propertyset for test properties, so each project can have its own set -->
             <sysproperty key="tests.multiplier" value="@{tests.multiplier}"/>
             
-            <!-- Temporary directory in the cwd. -->
-            <sysproperty key="tempDir" value="." />
-            <sysproperty key="java.io.tmpdir" value="." />
+            <!-- Temporary directory a subdir of the cwd. -->
+            <sysproperty key="tempDir" value="./temp" />
+            <sysproperty key="java.io.tmpdir" value="./temp" />
 
             <!-- Restrict access to certain Java features and install security manager: -->
             <sysproperty key="junit4.tempDir" file="@{workDir}/temp" />
diff --git lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java
index b454128..89e6b78 100644
--- lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java
+++ lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java
@@ -240,7 +240,7 @@ public class AnalyzingInfixSuggester extends Lookup implements Closeable {
       searcherMgr = new SearcherManager(writer, true, null);
       success = true;
     } finally {
-      if (success == false) {
+      if (success == false && writer != null) {
         writer.rollback();
         writer = null;
       }
diff --git lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
index c87b922..ff3375a 100644
--- lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
+++ lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
@@ -47,7 +47,6 @@ import java.util.Random;
 import java.util.Set;
 import java.util.TimeZone;
 import java.util.TreeSet;
-import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -162,7 +161,6 @@ import com.carrotsearch.randomizedtesting.rules.NoClassHooksShadowingRule;
 import com.carrotsearch.randomizedtesting.rules.NoInstanceHooksOverridesRule;
 import com.carrotsearch.randomizedtesting.rules.StaticFieldsInvariantRule;
 import com.carrotsearch.randomizedtesting.rules.SystemPropertiesInvariantRule;
-import com.carrotsearch.randomizedtesting.rules.TestRuleAdapter;
 
 import static com.carrotsearch.randomizedtesting.RandomizedTest.systemPropertyAsBoolean;
 import static com.carrotsearch.randomizedtesting.RandomizedTest.systemPropertyAsInt;
@@ -501,6 +499,11 @@ public abstract class LuceneTestCase extends Assert {
    * Suite failure marker (any error in the test or suite scope).
    */
   private static TestRuleMarkFailure suiteFailureMarker;
+  
+  /**
+   * Temporary files cleanup rule.
+   */
+  private static TestRuleTemporaryFilesCleanup tempFilesCleanupRule;
 
   /**
    * Ignore tests after hitting a designated number of initial failures. This
@@ -577,7 +580,7 @@ public abstract class LuceneTestCase extends Assert {
     .around(suiteFailureMarker = new TestRuleMarkFailure())
     .around(new TestRuleAssertionsRequired())
     .around(new TestRuleLimitSysouts(suiteFailureMarker))
-    .around(new TemporaryFilesCleanupRule())
+    .around(tempFilesCleanupRule = new TestRuleTemporaryFilesCleanup(suiteFailureMarker))
     .around(new StaticFieldsInvariantRule(STATIC_LEAK_THRESHOLD, true) {
       @Override
       protected boolean accept(java.lang.reflect.Field field) {
@@ -2390,52 +2393,12 @@ public abstract class LuceneTestCase extends Assert {
   }
 
   /**
-   * A base location for temporary files of a given test. Helps in figuring out
-   * which tests left which files and where.
-   */
-  private static File tempDirBase;
-  
-  /**
-   * Retry to create temporary file name this many times.
-   */
-  private static final int TEMP_NAME_RETRY_THRESHOLD = 9999;
-
-  /**
    * This method is deprecated for a reason. Do not use it. Call {@link #createTempDir()}
    * or {@link #createTempDir(String)} or {@link #createTempFile(String, String)}.
    */
   @Deprecated
   public static File getBaseTempDirForTestClass() {
-    synchronized (LuceneTestCase.class) {
-      if (tempDirBase == null) {
-        File directory = new File(System.getProperty("tempDir", System.getProperty("java.io.tmpdir")));
-        assert directory.exists() && 
-               directory.isDirectory() && 
-               directory.canWrite();
-
-        RandomizedContext ctx = RandomizedContext.current();
-        Class<?> clazz = ctx.getTargetClass();
-        String prefix = clazz.getName();
-        prefix = prefix.replaceFirst("^org.apache.lucene.", "lucene.");
-        prefix = prefix.replaceFirst("^org.apache.solr.", "solr.");
-
-        int attempt = 0;
-        File f;
-        do {
-          if (attempt++ >= TEMP_NAME_RETRY_THRESHOLD) {
-            throw new RuntimeException(
-                "Failed to get a temporary name too many times, check your temp directory and consider manually cleaning it: "
-                  + directory.getAbsolutePath());            
-          }
-          f = new File(directory, prefix + "-" + ctx.getRunnerSeedAsString() 
-                + "-" + String.format(Locale.ENGLISH, "%03d", attempt));
-        } while (!f.mkdirs());
-
-        tempDirBase = f;
-        registerToRemoveAfterSuite(tempDirBase);
-      }
-    }
-    return tempDirBase;
+    return tempFilesCleanupRule.getPerTestClassTempDir();
   }
 
 
@@ -2457,21 +2420,7 @@ public abstract class LuceneTestCase extends Assert {
    * the folder from being removed. 
    */
   public static File createTempDir(String prefix) {
-    File base = getBaseTempDirForTestClass();
-
-    int attempt = 0;
-    File f;
-    do {
-      if (attempt++ >= TEMP_NAME_RETRY_THRESHOLD) {
-        throw new RuntimeException(
-            "Failed to get a temporary name too many times, check your temp directory and consider manually cleaning it: "
-              + base.getAbsolutePath());            
-      }
-      f = new File(base, prefix + "-" + String.format(Locale.ENGLISH, "%03d", attempt));
-    } while (!f.mkdirs());
-
-    registerToRemoveAfterSuite(f);
-    return f;
+    return tempFilesCleanupRule.createTempDir(prefix);
   }
   
   /**
@@ -2483,21 +2432,7 @@ public abstract class LuceneTestCase extends Assert {
    * the folder from being removed. 
    */
   public static File createTempFile(String prefix, String suffix) throws IOException {
-    File base = getBaseTempDirForTestClass();
-
-    int attempt = 0;
-    File f;
-    do {
-      if (attempt++ >= TEMP_NAME_RETRY_THRESHOLD) {
-        throw new RuntimeException(
-            "Failed to get a temporary name too many times, check your temp directory and consider manually cleaning it: "
-              + base.getAbsolutePath());            
-      }
-      f = new File(base, prefix + "-" + String.format(Locale.ENGLISH, "%03d", attempt) + suffix);
-    } while (!f.createNewFile());
-
-    registerToRemoveAfterSuite(f);
-    return f;
+    return tempFilesCleanupRule.createTempFile(prefix, suffix);
   }
 
   /**
@@ -2508,79 +2443,4 @@ public abstract class LuceneTestCase extends Assert {
   public static File createTempFile() throws IOException {
     return createTempFile("tempFile", ".tmp");
   }
-
-  /**
-   * A queue of temporary resources to be removed after the
-   * suite completes.
-   * @see #registerToRemoveAfterSuite(File)
-   */
-  private final static List<File> cleanupQueue = new ArrayList<File>();
-
-  /**
-   * Register temporary folder for removal after the suite completes.
-   */
-  private static void registerToRemoveAfterSuite(File f) {
-    assert f != null;
-
-    if (LuceneTestCase.LEAVE_TEMPORARY) {
-      System.err.println("INFO: Will leave temporary file: " + f.getAbsolutePath());
-      return;
-    }
-
-    synchronized (cleanupQueue) {
-      cleanupQueue.add(f);
-    }
-  }
-
-  /**
-   * Checks and cleans up temporary files.
-   * 
-   * @see LuceneTestCase#createTempDir()
-   * @see LuceneTestCase#createTempFile()
-   */
-  private static class TemporaryFilesCleanupRule extends TestRuleAdapter {
-    @Override
-    protected void before() throws Throwable {
-      super.before();
-      assert tempDirBase == null;
-    }
-
-    @Override
-    protected void afterAlways(List<Throwable> errors) throws Throwable {
-      // Drain cleanup queue and clear it.
-      final File [] everything;
-      final String tempDirBasePath;
-      synchronized (cleanupQueue) {
-        tempDirBasePath = (tempDirBase != null ? tempDirBase.getAbsolutePath() : null);
-        tempDirBase = null;
-
-        Collections.reverse(cleanupQueue);
-        everything = new File [cleanupQueue.size()];
-        cleanupQueue.toArray(everything);
-        cleanupQueue.clear();
-      }
-
-      // Only check and throw an IOException on un-removable files if the test
-      // was successful. Otherwise just report the path of temporary files
-      // and leave them there.
-      if (LuceneTestCase.suiteFailureMarker.wasSuccessful()) {
-        try {
-          TestUtil.rm(everything);
-        } catch (IOException e) {
-          Class<?> suiteClass = RandomizedContext.current().getTargetClass();
-          if (suiteClass.isAnnotationPresent(SuppressTempFileChecks.class)) {
-            System.err.println("WARNING: Leftover undeleted temporary files (bugUrl: "
-                + suiteClass.getAnnotation(SuppressTempFileChecks.class).bugUrl() + "): "
-                + e.getMessage());
-            return;
-          }
-          throw e;
-        }
-      } else {
-        if (tempDirBasePath != null) {
-          System.err.println("NOTE: leaving temporary files on disk at: " + tempDirBasePath);
-        }
-      }
-    }
-  }
 }
diff --git lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup.java lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup.java
index 10b7e85..52433e2 100644
--- lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup.java
+++ lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup.java
@@ -99,7 +99,7 @@ final class TestRuleTemporaryFilesCleanup extends TestRuleAdapter {
     assert javaTempDir.isDirectory() &&
            javaTempDir.canWrite();
 
-    return javaTempDir;
+    return javaTempDir.getAbsoluteFile();
   }
 
   @Override
diff --git lucene/tools/junit4/tests.policy lucene/tools/junit4/tests.policy
index b1c4311..98e3f2b 100644
--- lucene/tools/junit4/tests.policy
+++ lucene/tools/junit4/tests.policy
@@ -26,8 +26,9 @@
 grant {
   // permissions for file access, write access only to sandbox:
   permission java.io.FilePermission "<<ALL FILES>>", "read,execute";
-  permission java.io.FilePermission "${junit4.childvm.cwd}", "read,execute,write";
-  permission java.io.FilePermission "${junit4.childvm.cwd}${/}-", "read,execute,write,delete";
+  permission java.io.FilePermission "${junit4.childvm.cwd}", "read,execute";
+  permission java.io.FilePermission "${junit4.childvm.cwd}${/}temp", "read,execute,write,delete";
+  permission java.io.FilePermission "${junit4.childvm.cwd}${/}temp${/}-", "read,execute,write,delete";
   permission java.io.FilePermission "${junit4.tempDir}${/}*", "read,execute,write,delete";
   permission java.io.FilePermission "${clover.db.dir}${/}-", "read,execute,write,delete";
   
diff --git solr/core/src/java/org/apache/solr/core/SolrCore.java solr/core/src/java/org/apache/solr/core/SolrCore.java
index 567fc30..50be6ce 100644
--- solr/core/src/java/org/apache/solr/core/SolrCore.java
+++ solr/core/src/java/org/apache/solr/core/SolrCore.java
@@ -161,6 +161,7 @@ public final class SolrCore implements SolrInfoMBean, Closeable {
   private final SolrResourceLoader resourceLoader;
   private volatile IndexSchema schema;
   private final String dataDir;
+  private final String ulogDir;
   private final UpdateHandler updateHandler;
   private final SolrCoreState solrCoreState;
   
@@ -242,6 +243,10 @@ public final class SolrCore implements SolrInfoMBean, Closeable {
     return dataDir;
   }
 
+  public String getUlogDir() {
+    return ulogDir;
+  }
+
   public String getIndexDir() {
     synchronized (searcherLock) {
       if (_searcher == null) return getNewIndexDir();
@@ -654,6 +659,7 @@ public final class SolrCore implements SolrInfoMBean, Closeable {
     this.setName(name);
     this.schema = null;
     this.dataDir = null;
+    this.ulogDir = null;
     this.solrConfig = null;
     this.startTime = System.currentTimeMillis();
     this.maxWarmingSearchers = 2;  // we don't have a config yet, just pick a number.
@@ -687,12 +693,14 @@ public final class SolrCore implements SolrInfoMBean, Closeable {
     if (updateHandler == null) {
       initDirectoryFactory();
     }
-    
+
     if (dataDir == null) {
       if (cd.usingDefaultDataDir()) dataDir = config.getDataDir();
       if (dataDir == null) {
         try {
           dataDir = cd.getDataDir();
+          // nocommit: this check needs to be fixed, see SOLR-6055
+          //if (!new File(dataDir).isAbsolute()) {
           if (!directoryFactory.isAbsolute(dataDir)) {
             dataDir = directoryFactory.getDataHome(cd);
           }
@@ -701,8 +709,18 @@ public final class SolrCore implements SolrInfoMBean, Closeable {
         }
       }
     }
-
     dataDir = SolrResourceLoader.normalizeDir(dataDir);
+
+    String updateLogDir = cd.getUlogDir();
+    if (updateLogDir == null) {
+      updateLogDir = dataDir;
+    }
+    if (new File(updateLogDir).isAbsolute() == false) {
+      updateLogDir = SolrResourceLoader.normalizeDir(cd.getInstanceDir()) + updateLogDir;
+    }
+    ulogDir = updateLogDir;
+
+
     log.info(logid+"Opening new SolrCore at " + resourceLoader.getInstanceDir() + ", dataDir="+dataDir);
 
     if (null != cd && null != cd.getCloudDescriptor()) {
diff --git solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java
index 070fb83..1e31716 100644
--- solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java
+++ solr/core/src/java/org/apache/solr/spelling/suggest/fst/AnalyzingInfixLookupFactory.java
@@ -83,6 +83,9 @@ public class AnalyzingInfixLookupFactory extends LookupFactory {
     String indexPath = params.get(INDEX_PATH) != null
     ? params.get(INDEX_PATH).toString()
     : DEFAULT_INDEX_PATH;
+    if (new File(indexPath).isAbsolute() == false) {
+      indexPath = core.getDataDir() + File.separator + indexPath;
+    }
     
     int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null
     ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())
diff --git solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java
index b895ff0..129a8e2 100644
--- solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java
+++ solr/core/src/java/org/apache/solr/spelling/suggest/fst/BlendedInfixLookupFactory.java
@@ -82,6 +82,9 @@ public class BlendedInfixLookupFactory extends AnalyzingInfixLookupFactory {
     String indexPath = params.get(INDEX_PATH) != null
     ? params.get(INDEX_PATH).toString()
     : DEFAULT_INDEX_PATH;
+    if (new File(indexPath).isAbsolute() == false) {
+      indexPath = core.getDataDir() + File.separator + indexPath;
+    }
     
     int minPrefixChars = params.get(MIN_PREFIX_CHARS) != null
     ? Integer.parseInt(params.get(MIN_PREFIX_CHARS).toString())
diff --git solr/core/src/java/org/apache/solr/update/UpdateLog.java solr/core/src/java/org/apache/solr/update/UpdateLog.java
index a65012c..3f5ed03 100644
--- solr/core/src/java/org/apache/solr/update/UpdateLog.java
+++ solr/core/src/java/org/apache/solr/update/UpdateLog.java
@@ -222,15 +222,7 @@ public class UpdateLog implements PluginInfoInitialized {
    * for an existing log whenever the core or update handler changes.
    */
   public void init(UpdateHandler uhandler, SolrCore core) {
-    // ulogDir from CoreDescriptor overrides
-    String ulogDir = core.getCoreDescriptor().getUlogDir();
-    if (ulogDir != null) {
-      dataDir = ulogDir;
-    }
-
-    if (dataDir == null || dataDir.length()==0) {
-      dataDir = core.getDataDir();
-    }
+    dataDir = core.getUlogDir();
 
     this.uhandler = uhandler;
 
diff --git solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster.java solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster.java
index f3be147..f5009f3 100644
--- solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster.java
+++ solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster.java
@@ -79,9 +79,8 @@ public class TestMiniSolrCloudCluster extends LuceneTestCase {
 
   @BeforeClass
   public static void startup() throws Exception {
-    String testHome = SolrTestCaseJ4.TEST_HOME();
-    miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, null, new File(testHome, "solr-no-core.xml"),
-      null, null);
+    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), "solr-no-core.xml");
+    miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, null, createTempDir(), solrXml, null, null);
   }
 
   @AfterClass
diff --git solr/core/src/test/org/apache/solr/handler/TestReplicationHandler.java solr/core/src/test/org/apache/solr/handler/TestReplicationHandler.java
index 23eecc2..198dd9f 100644
--- solr/core/src/test/org/apache/solr/handler/TestReplicationHandler.java
+++ solr/core/src/test/org/apache/solr/handler/TestReplicationHandler.java
@@ -114,12 +114,12 @@ public class TestReplicationHandler extends SolrTestCaseJ4 {
 //    System.setProperty("solr.directoryFactory", "solr.StandardDirectoryFactory");
     // For manual testing only
     // useFactory(null); // force an FS factory.
-    master = new SolrInstance("master", null);
+    master = new SolrInstance(createTempDir("solr-instance"), "master", null);
     master.setUp();
     masterJetty = createJetty(master);
     masterClient = createNewSolrServer(masterJetty.getLocalPort());
 
-    slave = new SolrInstance("slave", masterJetty.getLocalPort());
+    slave = new SolrInstance(createTempDir("solr-instance"), "slave", masterJetty.getLocalPort());
     slave.setUp();
     slaveJetty = createJetty(slave);
     slaveClient = createNewSolrServer(slaveJetty.getLocalPort());
@@ -323,7 +323,7 @@ public class TestReplicationHandler extends SolrTestCaseJ4 {
     JettySolrRunner repeaterJetty = null;
     SolrServer repeaterClient = null;
     try {
-      repeater = new SolrInstance("repeater", masterJetty.getLocalPort());
+      repeater = new SolrInstance(createTempDir("solr-instance"), "repeater", masterJetty.getLocalPort());
       repeater.setUp();
       repeaterJetty = createJetty(repeater);
       repeaterClient = createNewSolrServer(repeaterJetty.getLocalPort());
@@ -911,7 +911,7 @@ public class TestReplicationHandler extends SolrTestCaseJ4 {
     slaveClient = createNewSolrServer(slaveJetty.getLocalPort());
 
     try {
-      repeater = new SolrInstance("repeater", null);
+      repeater = new SolrInstance(createTempDir("solr-instance"), "repeater", null);
       repeater.setUp();
       repeater.copyConfigFile(CONF_DIR + "solrconfig-repeater.xml",
           "solrconfig.xml");
@@ -1647,13 +1647,15 @@ public class TestReplicationHandler extends SolrTestCaseJ4 {
     private File dataDir;
 
     /**
-     * @param name used to pick new solr home dir, as well as which 
+     * @param homeDir Base directory to build solr configuration and index in
+     * @param name used to pick which
      *        "solrconfig-${name}.xml" file gets copied
      *        to solrconfig.xml in new conf dir.
      * @param testPort if not null, used as a replacement for
      *        TEST_PORT in the cloned config files.
      */
-    public SolrInstance(String name, Integer testPort) {
+    public SolrInstance(File homeDir, String name, Integer testPort) {
+      this.homeDir = homeDir;
       this.name = name;
       this.testPort = testPort;
     }
@@ -1687,11 +1689,6 @@ public class TestReplicationHandler extends SolrTestCaseJ4 {
       System.setProperty("solr.test.sys.prop1", "propone");
       System.setProperty("solr.test.sys.prop2", "proptwo");
 
-      File home = new File(dataDir, 
-                           getClass().getName() + "-" + 
-                           System.currentTimeMillis());
-
-      homeDir = new File(home, name);
       dataDir = new File(homeDir + "/collection1", "data");
       confDir = new File(homeDir + "/collection1", "conf");
 
diff --git solr/core/src/test/org/apache/solr/rest/TestManagedResourceStorage.java solr/core/src/test/org/apache/solr/rest/TestManagedResourceStorage.java
index 373bda7..d973046 100644
--- solr/core/src/test/org/apache/solr/rest/TestManagedResourceStorage.java
+++ solr/core/src/test/org/apache/solr/rest/TestManagedResourceStorage.java
@@ -16,6 +16,7 @@ package org.apache.solr.rest;
  * limitations under the License.
  */
 
+import java.io.File;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
@@ -66,12 +67,12 @@ public class TestManagedResourceStorage extends AbstractZkTestCase {
    * Runs persisted managed resource creation and update tests on JSON storage.
    */
   @Test
-  public void testFileBasedJsonStorage() throws Exception {    
-    SolrResourceLoader loader = new SolrResourceLoader("./");    
-    // Solr unit tests can only write to their working directory due to
-    // a custom Java Security Manager installed in the test environment
+  public void testFileBasedJsonStorage() throws Exception {
+    File instanceDir = createTempDir("json-storage");
+    SolrResourceLoader loader = new SolrResourceLoader(instanceDir.getAbsolutePath());
     NamedList<String> initArgs = new NamedList<>();
-    initArgs.add(ManagedResourceStorage.STORAGE_DIR_INIT_ARG, "./managed");    
+    String managedDir = instanceDir.getAbsolutePath() + File.separator + "managed";
+    initArgs.add(ManagedResourceStorage.STORAGE_DIR_INIT_ARG, managedDir);
     FileStorageIO fileStorageIO = new FileStorageIO();
     fileStorageIO.configure(loader, initArgs);
     doStorageTests(loader, fileStorageIO);
diff --git solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster.java solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster.java
index b98e219..7ff5f36 100644
--- solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster.java
+++ solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster.java
@@ -48,14 +48,15 @@ public class MiniSolrCloudCluster {
    * "Mini" SolrCloud cluster to be used for testing
    * @param numServers number of Solr servers to start
    * @param hostContext context path of Solr servers used by Jetty
+   * @param baseDir base directory that the mini cluster should be run from
    * @param solrXml solr.xml file to be uploaded to ZooKeeper
    * @param extraServlets Extra servlets to be started by Jetty
    * @param extraRequestFilters extra filters to be started by Jetty
    */
-  public MiniSolrCloudCluster(int numServers, String hostContext, File solrXml,
+  public MiniSolrCloudCluster(int numServers, String hostContext, File baseDir, File solrXml,
       SortedMap<ServletHolder, String> extraServlets,
       SortedMap<Class, String> extraRequestFilters) throws Exception {
-    testDir = Files.createTempDir();
+    testDir = baseDir;
 
     String zkDir = testDir.getAbsolutePath() + File.separator
       + "zookeeper/server1/data";
