Index: lucene/core/src/java/org/apache/lucene/store/BufferedIndexInput.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/BufferedIndexInput.java	(revision 1610944)
+++ lucene/core/src/java/org/apache/lucene/store/BufferedIndexInput.java	(working copy)
@@ -389,7 +389,8 @@
   
   @Override
   public IndexInput slice(String sliceDescription, long offset, long length) throws IOException {
-    return wrap(sliceDescription, this, offset, length);
+    // nocommit: remove this default implementation? IndexInput itsself also does not have it, why BufferedIndexInput?
+    return SlicedIndexInput.wrap(sliceDescription, this, offset, length);
   }
 
   /**
@@ -425,62 +426,4 @@
     }
   }
   
-  /** 
-   * Wraps a portion of another IndexInput with buffering.
-   * <p><b>Please note:</b> This is in most cases ineffective, because it may double buffer!
-   */
-  public static BufferedIndexInput wrap(String sliceDescription, IndexInput other, long offset, long length) {
-    return new SlicedIndexInput(sliceDescription, other, offset, length);
-  }
-  
-  /** 
-   * Implementation of an IndexInput that reads from a portion of a file.
-   */
-  private static final class SlicedIndexInput extends BufferedIndexInput {
-    IndexInput base;
-    long fileOffset;
-    long length;
-    
-    SlicedIndexInput(String sliceDescription, IndexInput base, long offset, long length) {
-      super((sliceDescription == null) ? base.toString() : (base.toString() + " [slice=" + sliceDescription + "]"), BufferedIndexInput.BUFFER_SIZE);
-      if (offset < 0 || length < 0 || offset + length > base.length()) {
-        throw new IllegalArgumentException("slice() " + sliceDescription + " out of bounds: "  + base);
-      }
-      this.base = base.clone();
-      this.fileOffset = offset;
-      this.length = length;
-    }
-    
-    @Override
-    public SlicedIndexInput clone() {
-      SlicedIndexInput clone = (SlicedIndexInput)super.clone();
-      clone.base = base.clone();
-      clone.fileOffset = fileOffset;
-      clone.length = length;
-      return clone;
-    }
-    
-    @Override
-    protected void readInternal(byte[] b, int offset, int len) throws IOException {
-      long start = getFilePointer();
-      if (start + len > length) {
-        throw new EOFException("read past EOF: " + this);
-      }
-      base.seek(fileOffset + start);
-      base.readBytes(b, offset, len, false);
-    }
-    
-    @Override
-    protected void seekInternal(long pos) {}
-    
-    @Override
-    public void close() throws IOException {
-      base.close();
-    }
-    
-    @Override
-    public long length() {
-      return length;
-    }
-  }
 }
Index: lucene/core/src/java/org/apache/lucene/store/RAMInputStream.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/RAMInputStream.java	(revision 1610944)
+++ lucene/core/src/java/org/apache/lucene/store/RAMInputStream.java	(working copy)
@@ -125,37 +125,6 @@
 
   @Override
   public IndexInput slice(String sliceDescription, final long offset, final long length) throws IOException {
-    if (offset < 0 || length < 0 || offset + length > this.length) {
-      throw new IllegalArgumentException("slice() " + sliceDescription + " out of bounds: "  + this);
-    }
-    final String newResourceDescription = (sliceDescription == null) ? toString() : (toString() + " [slice=" + sliceDescription + "]");
-    return new RAMInputStream(newResourceDescription, file, offset + length) {
-      {
-        seek(0L);
-      }
-      
-      @Override
-      public void seek(long pos) throws IOException {
-        if (pos < 0L) {
-          throw new IllegalArgumentException("Seeking to negative position: " + this);
-        }
-        super.seek(pos + offset);
-      }
-      
-      @Override
-      public long getFilePointer() {
-        return super.getFilePointer() - offset;
-      }
-
-      @Override
-      public long length() {
-        return super.length() - offset;
-      }
-
-      @Override
-      public IndexInput slice(String sliceDescription, long ofs, long len) throws IOException {
-        return super.slice(sliceDescription, offset + ofs, len);
-      }
-    };
+    return SlicedIndexInput.wrap(sliceDescription, this, offset, length);
   }
 }
Index: lucene/core/src/java/org/apache/lucene/store/SlicedIndexInput.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/SlicedIndexInput.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/store/SlicedIndexInput.java	(working copy)
@@ -0,0 +1,149 @@
+package org.apache.lucene.store;
+
+import java.io.EOFException;
+import java.io.IOException;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** 
+ * Implementation of an IndexInput that reads from a portion of a file.
+ * <p><b>This implementation is not optimized for speed!</b>
+ * Consider implementing your own slicing when implementing a directory.
+ */
+public class SlicedIndexInput extends IndexInput {
+  private final String sliceDescription;
+  
+  IndexInput base;
+  final long offset;
+  final long length;
+  
+  /** 
+   * Wraps a slice of another {@link IndexInput}. The other {@code IndexInput} gets cloned to provide the slice.
+   * If and only if the other input implements {@link RandomAccessInput}, the wrapped one will implement {@code RandomAccessInput}.
+   */
+  @SuppressWarnings("resource")
+  public static final SlicedIndexInput wrap(String sliceDescription, IndexInput other, long offset, long length) throws IOException {
+    if (offset < 0 || length < 0 || offset + length > other.length()) {
+      throw new IllegalArgumentException("slice() " + sliceDescription + " out of bounds: "  + other);
+    }
+    return (other instanceof RandomAccessInput) ?
+        new WithRandomAccess(sliceDescription, other, offset, length) :
+        new SlicedIndexInput(sliceDescription, other, offset, length);
+  }  
+  
+  private SlicedIndexInput(String sliceDescription, IndexInput base, long offset, long length) throws IOException {
+    super(base.toString());
+    this.sliceDescription = sliceDescription;
+    this.base = base.clone();
+    this.offset = offset;
+    this.length =  length;
+    seek(0L);
+  }
+  
+  @Override
+  public final SlicedIndexInput clone() {
+    SlicedIndexInput clone = (SlicedIndexInput) super.clone();
+    clone.base = base.clone();
+    return clone;
+  }
+  
+  @Override
+  public final void close() throws IOException {
+    base.close();
+  }
+  
+  @Override
+  public final long length() {
+    return length;
+  }
+
+  @Override
+  public final long getFilePointer() {
+    return base.getFilePointer() - offset;
+  }
+
+  @Override
+  public final void seek(long pos) throws IOException {
+    if (pos < 0) {
+      throw new IllegalArgumentException("Seeking to negative position: " + this);
+    }
+    base.seek(offset + pos);
+  }
+
+  @Override
+  public final IndexInput slice(String sliceDescription, long offset, long length) throws IOException {
+    if (offset < 0 || length < 0 || offset + length > length()) {
+      throw new IllegalArgumentException("slice() " + sliceDescription + " out of bounds: "  + base);
+    }
+    final String newSliceDescription = (sliceDescription == null) ?
+        this.sliceDescription : (this.sliceDescription + "," + sliceDescription);
+    return SlicedIndexInput.wrap(newSliceDescription, base, this.offset + offset, length);
+  }
+
+  @Override
+  public final byte readByte() throws IOException {
+    if (getFilePointer() >= length) {
+      throw new EOFException("Read past end of file.");
+    }
+    return base.readByte();
+  }
+
+  @Override
+  public final void readBytes(byte[] b, int offset, int len) throws IOException {
+    if (getFilePointer() > length - len) {
+      throw new EOFException("Read past end of file.");
+    }
+    base.readBytes(b, offset, len);
+  }
+  
+  @Override
+  public final String toString() {
+    return (sliceDescription == null) ? super.toString() : (super.toString() + " [slice=" + sliceDescription + "]");
+  }
+
+  /** Custom implementation that is used by {@link #wrap} if the underlying IndexInput implements {@link RandomAccessInput}.
+   * nocommit: Is this an issue? This implementation does not do any bounds checks! Others don't do anyway. Maybe just add an assert!
+   */
+  private static final class WithRandomAccess extends SlicedIndexInput implements RandomAccessInput {
+
+    WithRandomAccess(String sliceDescription, IndexInput base, long offset, long length) throws IOException {
+      super(sliceDescription, base, offset, length);
+    }
+
+    @Override
+    public byte readByte(long pos) throws IOException {
+      return ((RandomAccessInput) base).readByte(offset + pos);
+    }
+
+    @Override
+    public short readShort(long pos) throws IOException {
+      return ((RandomAccessInput) base).readShort(offset + pos);
+    }
+
+    @Override
+    public int readInt(long pos) throws IOException {
+      return ((RandomAccessInput) base).readInt(offset + pos);
+    }
+
+    @Override
+    public long readLong(long pos) throws IOException {
+      return ((RandomAccessInput) base).readLong(offset + pos);
+    }
+    
+  }
+}
\ No newline at end of file
Index: lucene/core/src/java/org/apache/lucene/store/SlicedIndexInput.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/SlicedIndexInput.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/store/SlicedIndexInput.java	(working copy)

Property changes on: lucene/core/src/java/org/apache/lucene/store/SlicedIndexInput.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Added: svn:keywords
## -0,0 +1 ##
+Date Author Id Revision HeadURL
\ No newline at end of property
Index: lucene/misc/src/java/org/apache/lucene/store/NativeUnixDirectory.java
===================================================================
--- lucene/misc/src/java/org/apache/lucene/store/NativeUnixDirectory.java	(revision 1610944)
+++ lucene/misc/src/java/org/apache/lucene/store/NativeUnixDirectory.java	(working copy)
@@ -409,8 +409,7 @@
 
     @Override
     public IndexInput slice(String sliceDescription, long offset, long length) throws IOException {
-      // TODO: is this the right thing to do?
-      return BufferedIndexInput.wrap(sliceDescription, this, offset, length);
+      return SlicedIndexInput.wrap(sliceDescription, this, offset, length);
     }
   }
 }
Index: solr/core/src/java/org/apache/solr/store/blockcache/CustomBufferedIndexInput.java
===================================================================
--- solr/core/src/java/org/apache/solr/store/blockcache/CustomBufferedIndexInput.java	(revision 1610944)
+++ solr/core/src/java/org/apache/solr/store/blockcache/CustomBufferedIndexInput.java	(working copy)
@@ -20,9 +20,9 @@
 import java.io.EOFException;
 import java.io.IOException;
 
-import org.apache.lucene.store.BufferedIndexInput;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.store.SlicedIndexInput;
 
 /**
  * @lucene.experimental
@@ -258,7 +258,7 @@
   
   @Override
   public IndexInput slice(String sliceDescription, long offset, long length) throws IOException {
-    return BufferedIndexInput.wrap(sliceDescription, this, offset, length);
+    return SlicedIndexInput.wrap(sliceDescription, this, offset, length);
   }
 
   /**
