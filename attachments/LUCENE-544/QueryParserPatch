Index: /Users/matt/code/lucene/src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java
===================================================================
--- /Users/matt/code/lucene/src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java	(revision 464950)
+++ /Users/matt/code/lucene/src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java	(working copy)
@@ -24,6 +24,7 @@
 import org.apache.lucene.search.Query;
 
 import java.util.Vector;
+import java.util.Map;
 
 /**
  * A QueryParser which constructs queries to search multiple fields.
@@ -35,8 +36,42 @@
 {
   
   private String[] fields;
+  private Map      boosts;
 
   /**
+   * Creates a MultiFieldQueryParser. 
+   * 
+   * This will allow you pass a map of term to Boost and bost each term differently
+   *
+   * <p>It will, when parse(String query)
+   * is called, construct a query like this (assuming the query consists of
+   * two terms and you specify the two fields <code>title</code> and <code>body</code>):</p>
+   * 
+   * <code>
+   * (title:term1 body:term1) (title:term2 body:term2)
+   * </code>
+   *
+   * <p>When setDefaultOperator(AND_OPERATOR) is set, the result will be:</p>
+   *  
+   * <code>
+   * +(title:term1 body:term1) +(title:term2 body:term2)
+   * </code>
+   * 
+   * <p>When you pass a boost (title=> 5 body=>10) you can get </p>
+   * 
+   * <code>
+   * +(title:term1^5.0 body:term1^10.0) +(title:term2^5.0 body:term2^10.0)
+   * </code>
+   *
+   * <p>In other words, all the query's terms must appear, but it doesn't matter in
+   * what fields they appear.</p>
+   */
+  public MultiFieldQueryParser(String[] fields, Analyzer analyzer, Map boosts) {
+      this (fields,analyzer);
+      this.boosts = boosts;
+  }
+  
+  /**
    * Creates a MultiFieldQueryParser.
    *
    * <p>It will, when parse(String query)
@@ -62,24 +97,33 @@
   }
   
   protected Query getFieldQuery(String field, String queryText, int slop) throws ParseException {
-    if (field == null) {
-      Vector clauses = new Vector();
-      for (int i = 0; i < fields.length; i++) {
-        Query q = super.getFieldQuery(fields[i], queryText);
-        if (q != null) {
-          if (q instanceof PhraseQuery) {
-            ((PhraseQuery) q).setSlop(slop);
-          }
-          if (q instanceof MultiPhraseQuery) {
-            ((MultiPhraseQuery) q).setSlop(slop);
+
+      if (field == null) {
+          Vector clauses = new Vector();
+          for (int i = 0; i < fields.length; i++) {
+              Query q = super.getFieldQuery(fields[i], queryText);
+              if (q != null) {
+                  //If the user passes a map of boosts
+                  if (boosts != null) {
+                      //Get the boost from the map and apply them
+                      Float boost = (Float)boosts.get(fields[i]);
+                      if (boost != null) {
+                          q.setBoost(boost.floatValue());
+                      }
+                  }
+                  if (q instanceof PhraseQuery) {
+                      ((PhraseQuery) q).setSlop(slop);
+                  }
+                  if (q instanceof MultiPhraseQuery) {
+                      ((MultiPhraseQuery) q).setSlop(slop);
+                  }
+                  clauses.add(new BooleanClause(q, BooleanClause.Occur.SHOULD));
+              }
           }
-          clauses.add(new BooleanClause(q, BooleanClause.Occur.SHOULD));
-        }
+          if (clauses.size() == 0)  // happens for stopwords
+              return null;
+          return getBooleanQuery(clauses, true);
       }
-      if (clauses.size() == 0)  // happens for stopwords
-        return null;
-      return getBooleanQuery(clauses, true);
-    }
     return super.getFieldQuery(field, queryText);
   }
   
Index: /Users/matt/code/lucene/src/test/org/apache/lucene/queryParser/TestMultiFieldQueryParser.java
===================================================================
--- /Users/matt/code/lucene/src/test/org/apache/lucene/queryParser/TestMultiFieldQueryParser.java	(revision 464950)
+++ /Users/matt/code/lucene/src/test/org/apache/lucene/queryParser/TestMultiFieldQueryParser.java	(working copy)
@@ -32,6 +32,8 @@
 import org.apache.lucene.store.RAMDirectory;
 
 import java.io.Reader;
+import java.util.HashMap;
+import java.util.Map;
 
 /**
  * Tests QueryParser.
@@ -95,6 +97,33 @@
 
   }
   
+  public void testBoostsSimple() throws Exception {
+      Map boosts = new HashMap();
+      boosts.put("b", new Float(5));
+      boosts.put("t", new Float(10));
+      String[] fields = {"b", "t"};
+      MultiFieldQueryParser mfqp = new MultiFieldQueryParser(fields, new StandardAnalyzer(), boosts);
+      
+      
+      //Check for simple
+      Query q = mfqp.parse("one");
+      assertEquals("b:one^5.0 t:one^10.0", q.toString());
+      
+      //Check for AND
+      q = mfqp.parse("one AND two");
+      assertEquals("+(b:one^5.0 t:one^10.0) +(b:two^5.0 t:two^10.0)", q.toString());
+      
+      //Check for OR
+      q = mfqp.parse("one OR two");
+      assertEquals("(b:one^5.0 t:one^10.0) (b:two^5.0 t:two^10.0)", q.toString());
+      
+      //Check for AND and a field
+      q = mfqp.parse("one AND two AND foo:test");
+      assertEquals("+(b:one^5.0 t:one^10.0) +(b:two^5.0 t:two^10.0) +foo:test", q.toString());
+      
+      q = mfqp.parse("one^3 AND two^4");
+      assertEquals("+((b:one^5.0 t:one^10.0)^3.0) +((b:two^5.0 t:two^10.0)^4.0)", q.toString());
+  }
 
   public void testStaticMethod1() throws ParseException {
     String[] fields = {"b", "t"};
