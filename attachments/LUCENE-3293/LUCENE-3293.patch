Index: lucene/src/java/org/apache/lucene/index/SegmentReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/SegmentReader.java	(revision 1145504)
+++ lucene/src/java/org/apache/lucene/index/SegmentReader.java	(working copy)
@@ -89,7 +89,6 @@
    * @throws IOException if there is a low-level IO error
    */
   public static SegmentReader get(boolean readOnly, SegmentInfo si, int termInfosIndexDivisor, IOContext context) throws CorruptIndexException, IOException {
-    // TODO should we check if readOnly and context combination makes sense like asserting that if read only we don't get a default?
     return get(readOnly, si.dir, si, true, termInfosIndexDivisor, context);
   }
 
@@ -115,7 +114,7 @@
       if (doOpenStores) {
         instance.core.openDocStores(si);
       }
-      instance.loadLiveDocs();
+      instance.loadLiveDocs(context);
       instance.openNorms(instance.core.cfsDir, context);
       success = true;
     } finally {
@@ -157,10 +156,10 @@
     return true;
   }
 
-  private void loadLiveDocs() throws IOException {
+  private void loadLiveDocs(IOContext context) throws IOException {
     // NOTE: the bitvector is stored using the regular directory, not cfs
     if (hasDeletions(si)) {
-      liveDocs = new BitVector(directory(), si.getDelFileName(), IOContext.DEFAULT);
+      liveDocs = new BitVector(directory(), si.getDelFileName(), new IOContext(context, true));
       if (liveDocs.getVersion() < BitVector.VERSION_DGAPS_CLEARED) {
         liveDocs.invertAll();
       }
@@ -273,7 +272,7 @@
         if (!deletionsUpToDate) {
           // load deleted docs
           assert clone.liveDocs == null;
-          clone.loadLiveDocs();
+          clone.loadLiveDocs(IOContext.READ);
         } else if (liveDocs != null) {
           liveDocsRef.incrementAndGet();
           clone.liveDocs = liveDocs;
Index: lucene/src/java/org/apache/lucene/index/codecs/VariableGapTermsIndexReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/VariableGapTermsIndexReader.java	(revision 1145504)
+++ lucene/src/java/org/apache/lucene/index/codecs/VariableGapTermsIndexReader.java	(working copy)
@@ -62,7 +62,7 @@
   public VariableGapTermsIndexReader(Directory dir, FieldInfos fieldInfos, String segment, int indexDivisor, int codecId, IOContext context)
     throws IOException {
 
-    in = dir.openInput(IndexFileNames.segmentFileName(segment, codecId, VariableGapTermsIndexWriter.TERMS_INDEX_EXTENSION), context);
+    in = dir.openInput(IndexFileNames.segmentFileName(segment, codecId, VariableGapTermsIndexWriter.TERMS_INDEX_EXTENSION), new IOContext(context,true));
     this.segment = segment;
     boolean success = false;
 
Index: lucene/src/java/org/apache/lucene/store/IOContext.java
===================================================================
--- lucene/src/java/org/apache/lucene/store/IOContext.java	(revision 1145504)
+++ lucene/src/java/org/apache/lucene/store/IOContext.java	(working copy)
@@ -76,7 +76,7 @@
   public IOContext(MergeInfo mergeInfo) {
     this(Context.MERGE, mergeInfo);
   }
-
+  
   private IOContext(Context context, MergeInfo mergeInfo) {
     assert context != Context.MERGE || mergeInfo != null : "MergeInfo must not be null if context is MERGE";
     assert context != Context.FLUSH : "Use IOContext(FlushInfo) to create a FLUSH IOContext";
@@ -85,6 +85,18 @@
     this.mergeInfo = mergeInfo;
     this.flushInfo = null;
   }
+  
+  /**
+   * This constructor is used to initialize a {@link IOContext} instance with a new value for the readOnce variable. 
+   * @param ctxt {@link IOContext} object whose information is used to create the new instance except the readOnce variable.
+   * @param readOnce The new {@link IOContext} object will use this value for readOnce. 
+   */
+  public IOContext(IOContext ctxt, boolean readOnce) {
+    this.context = ctxt.context;
+    this.mergeInfo = ctxt.mergeInfo;
+    this.flushInfo = ctxt.flushInfo;
+    this.readOnce = readOnce;
+  }
 
   @Override
   public int hashCode() {
