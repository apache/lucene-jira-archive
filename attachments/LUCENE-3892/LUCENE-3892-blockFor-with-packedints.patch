Index: build.xml
===================================================================
--- build.xml	(revision 1363263)
+++ build.xml	(working copy)
@@ -74,13 +74,19 @@
 
   <target name="compile" description="Compile Lucene and Solr">
     <sequential>
-
       <subant target="compile" inheritall="false" failonerror="true">
         <fileset dir="lucene" includes="build.xml" />
         <fileset dir="solr" includes="build.xml" />
       </subant>
     </sequential>
   </target>
+  <target name="compile-core" description="Compile">
+    <sequential>
+      <subant target="compile-core" inheritall="false" failonerror="true">
+        <fileset dir="lucene" includes="build.xml" />
+      </subant>
+    </sequential>
+  </target>
 
   <property name="version" value="5.0-SNAPSHOT"/>
   <property name="maven-build-dir" value="maven-build"/>
Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java	(revision 1363612)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java	(working copy)
@@ -26,7 +26,7 @@
 import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.PostingsWriterBase;
 import org.apache.lucene.codecs.TermStats;
-import org.apache.lucene.codecs.pfor.ForUtil;  // nocommit move here?
+import org.apache.lucene.codecs.block.ForUtil;  // nocommit move here?
 import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.index.FieldInfo;
@@ -78,14 +78,14 @@
   private long posTermStartFP;
   private long payTermStartFP;
 
-  final int[] docDeltaBuffer;
-  final int[] freqBuffer;
+  final long[] docDeltaBuffer;
+  final long[] freqBuffer;
   private int docBufferUpto;
 
-  final int[] posDeltaBuffer;
-  final int[] payloadLengthBuffer;
-  final int[] offsetStartDeltaBuffer;
-  final int[] offsetLengthBuffer;
+  final long[] posDeltaBuffer;
+  final long[] payloadLengthBuffer;
+  final long[] offsetStartDeltaBuffer;
+  final long[] offsetLengthBuffer;
   private int posBufferUpto;
 
   private byte[] payloadBytes;
@@ -120,22 +120,22 @@
     try {
       CodecUtil.writeHeader(docOut, DOC_CODEC, VERSION_CURRENT);
       if (state.fieldInfos.hasProx()) {
-        posDeltaBuffer = new int[blockSize];
+        posDeltaBuffer = new long[blockSize];
         posOut = state.directory.createOutput(IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockPostingsFormat.POS_EXTENSION),
                                               state.context);
         CodecUtil.writeHeader(posOut, POS_CODEC, VERSION_CURRENT);
 
         if (state.fieldInfos.hasPayloads()) {
           payloadBytes = new byte[128];
-          payloadLengthBuffer = new int[blockSize];
+          payloadLengthBuffer = new long[blockSize];
         } else {
           payloadBytes = null;
           payloadLengthBuffer = null;
         }
 
         if (state.fieldInfos.hasOffsets()) {
-          offsetStartDeltaBuffer = new int[blockSize];
-          offsetLengthBuffer = new int[blockSize];
+          offsetStartDeltaBuffer = new long[blockSize];
+          offsetLengthBuffer = new long[blockSize];
         } else {
           offsetStartDeltaBuffer = null;
           offsetLengthBuffer = null;
@@ -162,8 +162,8 @@
       }
     }
 
-    docDeltaBuffer = new int[blockSize];
-    freqBuffer = new int[blockSize];
+    docDeltaBuffer = new long[blockSize];
+    freqBuffer = new long[blockSize];
 
     skipWriter = new BlockSkipWriter(blockSize,
                                      maxSkipLevels, 
@@ -210,11 +210,8 @@
     skipWriter.resetSkip();
   }
 
-  private void writeBlock(int[] buffer, IndexOutput out) throws IOException {
-    final int header = ForUtil.compress(buffer, encodedBuffer);
-    //System.out.println("    block has " + numBytes + " bytes");
-    out.writeVInt(header);
-    out.writeBytes(encoded, ForUtil.getEncodedSize(header));
+  private void writeBlock(long[] buffer, IndexOutput out) throws IOException {
+    ForUtil.compress(buffer, out);
   }
 
   @Override
@@ -400,8 +397,8 @@
 
     // vInt encode the remaining doc deltas and freqs:
     for(int i=0;i<docBufferUpto;i++) {
-      final int docDelta = docDeltaBuffer[i];
-      final int freq = freqBuffer[i];
+      final int docDelta = (int)docDeltaBuffer[i];
+      final int freq = (int)freqBuffer[i];
       if (!fieldHasFreqs) {
         docOut.writeVInt(docDelta);
       } else if (freqBuffer[i] == 1) {
@@ -439,9 +436,9 @@
         int lastPayloadLength = -1;
         int payloadBytesReadUpto = 0;
         for(int i=0;i<posBufferUpto;i++) {
-          final int posDelta = posDeltaBuffer[i];
+          final int posDelta = (int)posDeltaBuffer[i];
           if (fieldHasPayloads) {
-            final int payloadLength = payloadLengthBuffer[i];
+            final int payloadLength = (int)payloadLengthBuffer[i];
             if (payloadLength != lastPayloadLength) {
               lastPayloadLength = payloadLength;
               posOut.writeVInt((posDelta<<1)|1);
@@ -469,8 +466,8 @@
             if (DEBUG) {
               System.out.println("          write offset @ pos.fp=" + posOut.getFilePointer());
             }
-            posOut.writeVInt(offsetStartDeltaBuffer[i]);
-            posOut.writeVInt(offsetLengthBuffer[i]);
+            posOut.writeVInt((int)offsetStartDeltaBuffer[i]);
+            posOut.writeVInt((int)offsetLengthBuffer[i]);
           }
         }
 
Index: lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java	(working copy)
@@ -0,0 +1,128 @@
+package org.apache.lucene.codecs.block;
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.nio.IntBuffer;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.util.packed.PackedInts;
+import org.apache.lucene.util.packed.PackedInts.Reader;
+import org.apache.lucene.util.packed.PackedInts.Writer;
+import org.apache.lucene.util.packed.PackedInts.Mutable;
+
+/**
+ * Encode all values in normal area with fixed bit width, 
+ * which is determined by the max value in this block.
+ */
+public class ForUtil {
+  protected static final int[] MASK = {   0x00000000,
+    0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f,
+    0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff,
+    0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff, 0x0001ffff, 0x0003ffff,
+    0x0007ffff, 0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
+    0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff, 0x1fffffff, 0x3fffffff,
+    0x7fffffff, 0xffffffff};
+
+  /** Compress given int[] into output stream, with For format
+   */
+  public static void compress(final long[] data, IndexOutput out) throws IOException {
+    /*
+    for (int i=0; i<128; i++) {
+      out.writeInt((int)data[i]);
+    }
+    */
+    int numBits=getNumBits(data);
+
+    if (numBits == 0) { // when block is equal, save the value once
+      out.writeInt(getHeader(1,numBits));
+      out.writeInt((int)data[0]);
+      return;
+    }
+    int encodedSize = PackedInts.Format.PACKED.nblocks(numBits,128)*8;
+    out.writeInt(getHeader(encodedSize/4,numBits));
+    //System.out.println(out.getFilePointer()+" "+numBits+" "+encodedSize);
+
+    PackedInts.Writer writer = PackedInts.getWriterNoHeader(out, PackedInts.Format.PACKED, 128, numBits, 256);
+    for (int i=0; i<128; i++) {
+      assert (data[i] & 0xffffffff00000000L) == 0;
+      writer.add(data[i]);
+    }
+    writer.finish();
+    //System.out.println(out.getFilePointer());
+  }
+
+  /** Decompress given ouput stream into int array.
+   */
+  public static void decompress(IndexInput in, long[] data) throws IOException {
+    /*
+    for (int i=0; i<128; i++) {
+      data[i]=in.readInt();
+      assert (data[i] & 0xffffffff00000000L) == 0;
+    }
+    */
+    // nocommit assert header isn't "malformed", ie besides
+    // numBytes / bit-width there is nothing else!
+    int header = in.readInt();
+    int numBits = ((header >> 8) & MASK[6]);
+
+    if (numBits == 0) {
+      Arrays.fill(data, in.readInt());
+      return;
+    }
+    PackedInts.Reader reader = PackedInts.getReaderNoHeader(in, PackedInts.Format.PACKED, 0, 128, numBits);
+    reader.get(0, data, 0, 128);
+  }
+
+  static int getNumBits(final long[] data) {
+    if (isAllEqual(data)) {
+      return 0;
+    }
+    int size=data.length;
+    int optBits=1;
+    for (int i=0; i<size; ++i) {
+      while ((data[i] & ~MASK[optBits]) != 0) {
+        optBits++;
+      }
+    }
+    return optBits;
+  }
+
+  protected static boolean isAllEqual(final long[] data) {
+    int len = data.length;
+    long v = data[0];
+    for (int i=1; i<len; i++) {
+      if (data[i] != v) {
+        return false;
+      }
+    }
+    return true;
+  }
+  static int getHeader(int encodedSize, int numBits) {
+    return  (encodedSize)
+          | ((numBits) << 8);
+  }
+  public static int getEncodedSize(int header) {
+    return ((header & MASK[8]))*4;
+  }
+  public static int getNumBits(int header) {
+    return ((header >> 8) & MASK[6]);
+  }
+}
Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java	(revision 1363612)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java	(working copy)
@@ -24,7 +24,7 @@
 import org.apache.lucene.codecs.BlockTermState;
 import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.PostingsReaderBase;
-import org.apache.lucene.codecs.pfor.ForUtil;
+import org.apache.lucene.codecs.block.ForUtil;
 import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
@@ -292,8 +292,8 @@
     private final byte[] encoded;
     private final IntBuffer encodedBuffer;
     
-    private final int[] docDeltaBuffer = new int[blockSize];
-    private final int[] freqBuffer = new int[blockSize];
+    private final long[] docDeltaBuffer = new long[blockSize];
+    private final long[] freqBuffer = new long[blockSize];
 
     private int docBufferUpto;
 
@@ -370,10 +370,8 @@
       return doc;
     }
     
-    private void readBlock(IndexInput in, int[] buffer) throws IOException {
-      int header = in.readVInt();
-      in.readBytes(encoded, 0, ForUtil.getEncodedSize(header));
-      ForUtil.decompress(encodedBuffer, buffer, header);
+    private void readBlock(IndexInput in, long[] buffer) throws IOException {
+      ForUtil.decompress(in, buffer);
     }
 
     private void refillDocs() throws IOException {
@@ -445,7 +443,7 @@
 
         if (liveDocs == null || liveDocs.get(accum)) {
           doc = accum;
-          freq = freqBuffer[docBufferUpto];
+          freq = (int)freqBuffer[docBufferUpto];
           docBufferUpto++;
           if (DEBUG) {
             System.out.println("  return doc=" + doc + " freq=" + freq);
@@ -536,9 +534,9 @@
     private final byte[] encoded;
     private final IntBuffer encodedBuffer;
 
-    private final int[] docDeltaBuffer = new int[blockSize];
-    private final int[] freqBuffer = new int[blockSize];
-    private final int[] posDeltaBuffer = new int[blockSize];
+    private final long[] docDeltaBuffer = new long[blockSize];
+    private final long[] freqBuffer = new long[blockSize];
+    private final long[] posDeltaBuffer = new long[blockSize];
 
     private int docBufferUpto;
     private int posBufferUpto;
@@ -646,15 +644,14 @@
       return doc;
     }
 
-    private void readBlock(IndexInput in, int[] buffer) throws IOException {
-      int header = in.readVInt();
-      in.readBytes(encoded, 0, ForUtil.getEncodedSize(header));
-      ForUtil.decompress(encodedBuffer, buffer, header);
+    private void readBlock(IndexInput in, long[] buffer) throws IOException {
+      ForUtil.decompress(in, buffer);
     }
 
     private void skipBlock(IndexInput in) throws IOException {
-      int header = in.readVInt();
+      int header = in.readInt();
       in.seek(in.getFilePointer() + ForUtil.getEncodedSize(header));
+      //in.seek(in.getFilePointer() + 128*4);
     }
 
     private void refillDocs() throws IOException {
@@ -751,8 +748,8 @@
         if (DEBUG) {
           System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
         }
-        accum += docDeltaBuffer[docBufferUpto];
-        freq = freqBuffer[docBufferUpto];
+        accum += (int)docDeltaBuffer[docBufferUpto];
+        freq = (int)freqBuffer[docBufferUpto];
         posPendingCount += freq;
         docBufferUpto++;
         docUpto++;
@@ -948,13 +945,13 @@
     private final byte[] encoded;
     private final IntBuffer encodedBuffer;
 
-    private final int[] docDeltaBuffer = new int[blockSize];
-    private final int[] freqBuffer = new int[blockSize];
-    private final int[] posDeltaBuffer = new int[blockSize];
+    private final long[] docDeltaBuffer = new long[blockSize];
+    private final long[] freqBuffer = new long[blockSize];
+    private final long[] posDeltaBuffer = new long[blockSize];
 
-    private final int[] payloadLengthBuffer;
-    private final int[] offsetStartDeltaBuffer;
-    private final int[] offsetLengthBuffer;
+    private final long[] payloadLengthBuffer;
+    private final long[] offsetStartDeltaBuffer;
+    private final long[] offsetLengthBuffer;
 
     private byte[] payloadBytes;
     private int payloadByteUpto;
@@ -1030,8 +1027,8 @@
       encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
       indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
       if (indexHasOffsets) {
-        offsetStartDeltaBuffer = new int[blockSize];
-        offsetLengthBuffer = new int[blockSize];
+        offsetStartDeltaBuffer = new long[blockSize];
+        offsetLengthBuffer = new long[blockSize];
       } else {
         offsetStartDeltaBuffer = null;
         offsetLengthBuffer = null;
@@ -1041,7 +1038,7 @@
 
       indexHasPayloads = fieldInfo.hasPayloads();
       if (indexHasPayloads) {
-        payloadLengthBuffer = new int[blockSize];
+        payloadLengthBuffer = new long[blockSize];
         payloadBytes = new byte[128];
         payload = new BytesRef();
       } else {
@@ -1097,15 +1094,14 @@
       return doc;
     }
 
-    private void readBlock(IndexInput in, int[] buffer) throws IOException {
-      int header = in.readVInt();
-      in.readBytes(encoded, 0, ForUtil.getEncodedSize(header));
-      ForUtil.decompress(encodedBuffer, buffer, header);
+    private void readBlock(IndexInput in, long[] buffer) throws IOException {
+      ForUtil.decompress(in, buffer);
     }
 
     private void skipBlock(IndexInput in) throws IOException {
-      int header = in.readVInt();
+      int header = in.readInt();
       in.seek(in.getFilePointer() + ForUtil.getEncodedSize(header));
+      //in.seek(in.getFilePointer() + 128*4);
     }
 
     private void refillDocs() throws IOException {
@@ -1248,8 +1244,8 @@
         if (DEBUG) {
           System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
         }
-        accum += docDeltaBuffer[docBufferUpto];
-        freq = freqBuffer[docBufferUpto];
+        accum += (int)docDeltaBuffer[docBufferUpto];
+        freq = (int)freqBuffer[docBufferUpto];
         posPendingCount += freq;
         docBufferUpto++;
         docUpto++;
@@ -1476,12 +1472,12 @@
       position += posDeltaBuffer[posBufferUpto];
 
       if (indexHasPayloads) {
-        payloadLength = payloadLengthBuffer[posBufferUpto];
+        payloadLength = (int)payloadLengthBuffer[posBufferUpto];
       }
 
       if (indexHasOffsets) {
-        startOffset = lastEndOffset + offsetStartDeltaBuffer[posBufferUpto];
-        endOffset = startOffset + offsetLengthBuffer[posBufferUpto];
+        startOffset = lastEndOffset + (int)offsetStartDeltaBuffer[posBufferUpto];
+        endOffset = startOffset + (int)offsetLengthBuffer[posBufferUpto];
         lastEndOffset = endOffset;
       }
 
