Index: lucene/misc/src/test/org/apache/lucene/index/sorter/TestEarlyTermination.java
===================================================================
--- lucene/misc/src/test/org/apache/lucene/index/sorter/TestEarlyTermination.java	(revision 1588875)
+++ lucene/misc/src/test/org/apache/lucene/index/sorter/TestEarlyTermination.java	(working copy)
@@ -33,9 +33,12 @@
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.SerialMergeScheduler;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.LeafCollector;
 import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.Query;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.Sort;
 import org.apache.lucene.search.SortField;
@@ -70,7 +73,7 @@
     return doc;
   }
 
-  private void createRandomIndexes(int maxSegments) throws IOException {
+  private void createRandomIndex() throws IOException {
     dir = newDirectory();
     numDocs = atLeast(150);
     final int numTerms = TestUtil.nextInt(random(), 1, numDocs / 5);
@@ -80,7 +83,7 @@
     }
     terms = new ArrayList<>(randomTerms);
     final long seed = random().nextLong();
-    final IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(new Random(seed)));
+    final IndexWriterConfig iwc = getIndexWriterConfig(new Random(seed));
     iwc.setMergePolicy(TestSortingMergePolicy.newSortingMergePolicy(sort));
     iw = new RandomIndexWriter(new Random(seed), dir, iwc);
     for (int i = 0; i < numDocs; ++i) {
@@ -94,69 +97,92 @@
         iw.deleteDocuments(new Term("s", term));
       }
     }
+    if (random().nextBoolean()) {
+      iw.forceMerge(5);
+    }
     reader = iw.getReader();
   }
-
-  @Override
-  public void tearDown() throws Exception {
+  
+  private void closeIndex() throws IOException {
     reader.close();
     iw.shutdown();
     dir.close();
-    super.tearDown();
   }
+  
+  protected IndexWriterConfig getIndexWriterConfig(Random random) {
+    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));
+    iwc.setMergeScheduler(new SerialMergeScheduler());
+    return iwc;
+  }
 
   public void testEarlyTermination() throws IOException {
-    createRandomIndexes(5);
-    final int numHits = TestUtil.nextInt(random(), 1, numDocs / 10);
-    final Sort sort = new Sort(new SortField("ndv1", SortField.Type.LONG, false));
-    final boolean fillFields = random().nextBoolean();
-    final boolean trackDocScores = random().nextBoolean();
-    final boolean trackMaxScore = random().nextBoolean();
-    final boolean inOrder = random().nextBoolean();
-    final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore, inOrder);
-    final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore, inOrder);
+    final int iters = atLeast(8);
+    for (int i = 0; i < iters; ++i) {
+      createRandomIndex();
+      for (int j = 0; j < iters; ++j) {
+        final IndexSearcher searcher = newSearcher(reader);
+        final int numHits = TestUtil.nextInt(random(), 1, numDocs / 10);
+        final Sort sort = new Sort(new SortField("ndv1", SortField.Type.LONG, false));
+        final boolean fillFields = random().nextBoolean();
+        final boolean trackDocScores = random().nextBoolean();
+        final boolean trackMaxScore = random().nextBoolean();
+        final boolean inOrder = random().nextBoolean();
+        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore, inOrder);
+        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore, inOrder);
 
-    final IndexSearcher searcher = newSearcher(reader);
-    final int iters = atLeast(5);
-    for (int i = 0; i < iters; ++i) {
-      final TermQuery query = new TermQuery(new Term("s", RandomPicks.randomFrom(random(), terms)));
-      searcher.search(query, collector1);
-      searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits));
+        final Query query;
+        if (random().nextBoolean()) {
+          query = new TermQuery(new Term("s", RandomPicks.randomFrom(random(), terms)));
+        } else {
+          query = new MatchAllDocsQuery();
+        }
+        searcher.search(query, collector1);
+        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, sort, numHits));
+        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());
+        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);
+      }
+      closeIndex();
     }
-    assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());
-    assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);
   }
   
   public void testEarlyTerminationDifferentSorter() throws IOException {
-    // test that the collector works correctly when the index was sorted by a
-    // different sorter than the one specified in the ctor.
-    createRandomIndexes(5);
-    final int numHits = TestUtil.nextInt(random(), 1, numDocs / 10);
-    final Sort sort = new Sort(new SortField("ndv2", SortField.Type.LONG, false));
-    final boolean fillFields = random().nextBoolean();
-    final boolean trackDocScores = random().nextBoolean();
-    final boolean trackMaxScore = random().nextBoolean();
-    final boolean inOrder = random().nextBoolean();
-    final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore, inOrder);
-    final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore, inOrder);
+    final int iters = atLeast(8);
+    for (int i = 0; i < iters; ++i) {
+      createRandomIndex();
+      for (int j = 0; j < iters; ++j) {
+        final IndexSearcher searcher = newSearcher(reader);
+        // test that the collector works correctly when the index was sorted by a
+        // different sorter than the one specified in the ctor.
+        final int numHits = TestUtil.nextInt(random(), 1, numDocs / 10);
+        final Sort sort = new Sort(new SortField("ndv2", SortField.Type.LONG, false));
+        final boolean fillFields = random().nextBoolean();
+        final boolean trackDocScores = random().nextBoolean();
+        final boolean trackMaxScore = random().nextBoolean();
+        final boolean inOrder = random().nextBoolean();
+        final TopFieldCollector collector1 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore, inOrder);
+        final TopFieldCollector collector2 = TopFieldCollector.create(sort, numHits, fillFields, trackDocScores, trackMaxScore, inOrder);
     
-    final IndexSearcher searcher = newSearcher(reader);
-    final int iters = atLeast(5);
-    for (int i = 0; i < iters; ++i) {
-      final TermQuery query = new TermQuery(new Term("s", RandomPicks.randomFrom(random(), terms)));
-      searcher.search(query, collector1);
-      Sort different = new Sort(new SortField("ndv2", SortField.Type.LONG));
-      searcher.search(query, new EarlyTerminatingSortingCollector(collector2, different, numHits) {
-        @Override
-        public LeafCollector getLeafCollector(AtomicReaderContext context) throws IOException {
-          final LeafCollector ret = super.getLeafCollector(context);
-          assertTrue("segment should not be recognized as sorted as different sorter was used", ret.getClass() == in.getLeafCollector(context).getClass());
-          return ret;
+        final Query query;
+        if (random().nextBoolean()) {
+          query = new TermQuery(new Term("s", RandomPicks.randomFrom(random(), terms)));
+        } else {
+          query = new MatchAllDocsQuery();
         }
-      });
+        searcher.search(query, collector1);
+        Sort different = new Sort(new SortField("ndv2", SortField.Type.LONG));
+        searcher.search(query, new EarlyTerminatingSortingCollector(collector2, different, numHits) {
+          @Override
+          public LeafCollector getLeafCollector(AtomicReaderContext context) throws IOException {
+            final LeafCollector ret = super.getLeafCollector(context);
+            assertTrue("segment should not be recognized as sorted as different sorter was used", ret.getClass() == in.getLeafCollector(context).getClass());
+            return ret;
+          }
+        });
+        assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());
+        assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);
+      }
+      closeIndex();
     }
-    assertTrue(collector1.getTotalHits() >= collector2.getTotalHits());
-    assertTopDocsEquals(collector1.topDocs().scoreDocs, collector2.topDocs().scoreDocs);
   }
 
   private static void assertTopDocsEquals(ScoreDoc[] scoreDocs1, ScoreDoc[] scoreDocs2) {
Index: lucene/misc/src/test/org/apache/lucene/index/sorter/TestEarlyTerminationCMS.java
===================================================================
--- lucene/misc/src/test/org/apache/lucene/index/sorter/TestEarlyTerminationCMS.java	(revision 0)
+++ lucene/misc/src/test/org/apache/lucene/index/sorter/TestEarlyTerminationCMS.java	(working copy)
@@ -0,0 +1,40 @@
+package org.apache.lucene.index.sorter;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Random;
+
+import org.apache.lucene.index.ConcurrentMergeScheduler;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.util.TestUtil;
+
+public class TestEarlyTerminationCMS extends TestEarlyTermination {
+
+  @Override
+  protected IndexWriterConfig getIndexWriterConfig(Random random) {
+    IndexWriterConfig iwc = super.getIndexWriterConfig(random);
+    int maxThreadCount = TestUtil.nextInt(random, 3, 8);
+    int maxMergeCount = TestUtil.nextInt(random, maxThreadCount, maxThreadCount + 4);
+    ConcurrentMergeScheduler cms = new ConcurrentMergeScheduler();
+    cms.setMaxMergesAndThreads(maxMergeCount, maxThreadCount);
+    iwc.setMergeScheduler(cms);
+    // nocommit
+    System.out.println(iwc);
+    return iwc;
+  }
+}
Index: lucene/misc/src/test/org/apache/lucene/index/sorter/TestSortingMergePolicy.java
===================================================================
--- lucene/misc/src/test/org/apache/lucene/index/sorter/TestSortingMergePolicy.java	(revision 1588875)
+++ lucene/misc/src/test/org/apache/lucene/index/sorter/TestSortingMergePolicy.java	(working copy)
@@ -73,16 +73,19 @@
   static MergePolicy newSortingMergePolicy(Sort sort) {
     // create a MP with a low merge factor so that many merges happen
     MergePolicy mp;
-    if (random().nextBoolean()) {
+    int thingToDo = random().nextInt(3);
+    if (thingToDo == 0) {
       TieredMergePolicy tmp = newTieredMergePolicy(random());
       final int numSegs = TestUtil.nextInt(random(), 3, 5);
       tmp.setSegmentsPerTier(numSegs);
       tmp.setMaxMergeAtOnce(TestUtil.nextInt(random(), 2, numSegs));
       mp = tmp;
-    } else {
+    } else if (thingToDo == 1) {
       LogMergePolicy lmp = newLogMergePolicy(random());
       lmp.setMergeFactor(TestUtil.nextInt(random(), 3, 5));
       mp = lmp;
+    } else {
+      mp = newMergePolicy();
     }
     // wrap it with a sorting mp
     return new SortingMergePolicy(mp, sort);
