Index: lucene/spatial/src/test-files/simple-Queries-BBox.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/test-files/simple-Queries-BBox.txt	(revision 1603308)
+++ lucene/spatial/src/test-files/simple-Queries-BBox.txt	(revision )
@@ -3,6 +3,7 @@
 C10 @ Contains(ENVELOPE(-6, 6, 6, -6))
 C10 @ IsEqualTo(ENVELOPE(-10, 10, 10, -10))
 C5 C10 @ Intersects(ENVELOPE(-2, 2, 2, -2))
-C5 C10 @ Overlaps(ENVELOPE(-2, 2, 2, -2))
+ @ Overlaps(ENVELOPE(-2, 2, 2, -2))
+C5 @ Overlaps(ENVELOPE(-2, 2, 8, -2))
 C5 C10 @ BBoxIntersects(ENVELOPE(-2, 2, 2, -2))
 NW15 @ IsDisjointTo(ENVELOPE(-10, 10, 10, -10))
\ No newline at end of file
Index: lucene/spatial/src/java/org/apache/lucene/spatial/query/SpatialOperation.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/query/SpatialOperation.java	(revision 1603308)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/query/SpatialOperation.java	(revision )
@@ -63,7 +63,7 @@
   public static final SpatialOperation Contains       = new SpatialOperation("Contains", true, true, false) {
     @Override
     public boolean evaluate(Shape indexedShape, Shape queryShape) {
-      return indexedShape.hasArea() && indexedShape.relate(queryShape) == SpatialRelation.CONTAINS || indexedShape.equals(queryShape);
+      return indexedShape.relate(queryShape) == SpatialRelation.CONTAINS || indexedShape.equals(queryShape);
     }
   };
   public static final SpatialOperation Intersects     = new SpatialOperation("Intersects", true, false, false) {
@@ -87,13 +87,13 @@
   public static final SpatialOperation IsWithin       = new SpatialOperation("IsWithin", true, false, true) {
     @Override
     public boolean evaluate(Shape indexedShape, Shape queryShape) {
-      return queryShape.hasArea() && (indexedShape.relate(queryShape) == SpatialRelation.WITHIN || indexedShape.equals(queryShape));
+      return indexedShape.relate(queryShape) == SpatialRelation.WITHIN || indexedShape.equals(queryShape);
     }
   };
   public static final SpatialOperation Overlaps       = new SpatialOperation("Overlaps", true, false, true) {
     @Override
     public boolean evaluate(Shape indexedShape, Shape queryShape) {
-      return queryShape.hasArea() && indexedShape.relate(queryShape).intersects();
+      return indexedShape.relate(queryShape) == SpatialRelation.INTERSECTS;//not Contains or Within or Disjoint
     }
   };
 
Index: lucene/spatial/src/java/org/apache/lucene/spatial/bbox/AreaSimilarity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/bbox/AreaSimilarity.java	(revision 1603308)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/bbox/AreaSimilarity.java	(revision )
@@ -16,202 +16,201 @@
  */
 package org.apache.lucene.spatial.bbox;
 
+import com.spatial4j.core.shape.Rectangle;
 import org.apache.lucene.search.Explanation;
 
-import com.spatial4j.core.shape.Rectangle;
-
 /**
  * The algorithm is implemented as envelope on envelope overlays rather than
  * complex polygon on complex polygon overlays.
  * <p/>
  * <p/>
  * Spatial relevance scoring algorithm:
+ * <DL>
+ *   <DT>queryArea</DT> <DD>the area of the input query envelope</DD>
+ *   <DT>targetArea</DT> <DD>the area of the target envelope (per Lucene document)</DD>
+ *   <DT>intersectionArea</DT> <DD>the area of the intersection between the query and target envelopes</DD>
+ *   <DT>queryTargetProportion</DT> <DD>A 0-1 factor that divides the score proportion between query and target.
+ *   0.5 is evenly.</DD>
+ *
+ *   <DT>queryRatio</DT> <DD>intersectionArea / queryArea; (see note)</DD>
+ *   <DT>targetRatio</DT> <DD>intersectionArea / targetArea; (see note)</DD>
+ *   <DT>queryFactor</DT> <DD>queryRatio * queryTargetProportion;</DD>
+ *   <DT>targetFactor</DT> <DD>targetRatio * (1 - queryTargetProportion);</DD>
+ *   <DT>score</DT> <DD>queryFactor + targetFactor;</DD>
+ * </DL>
+ * Note: The actual computation of queryRatio and targetRatio is more complicated so that it considers
+ * points and lines. Lines have the ratio of overlap, and points are either 1.0 or 0.0 depending on wether
+ * it intersects or not.
- * <p/>
+ * <p />
- * <br/>  queryArea = the area of the input query envelope
- * <br/>  targetArea = the area of the target envelope (per Lucene document)
- * <br/>  intersectionArea = the area of the intersection for the query/target envelopes
- * <br/>  queryPower = the weighting power associated with the query envelope (default = 1.0)
- * <br/>  targetPower =  the weighting power associated with the target envelope (default = 1.0)
- * <p/>
- * <br/>  queryRatio  = intersectionArea / queryArea;
- * <br/>  targetRatio = intersectionArea / targetArea;
- * <br/>  queryFactor  = Math.pow(queryRatio,queryPower);
- * <br/>  targetFactor = Math.pow(targetRatio,targetPower);
- * <br/>  score = queryFactor * targetFactor;
- * <p/>
  * Based on Geoportal's
  * <a href="http://geoportal.svn.sourceforge.net/svnroot/geoportal/Geoportal/trunk/src/com/esri/gpt/catalog/lucene/SpatialRankingValueSource.java">
- *   SpatialRankingValueSource</a>.
+ *   SpatialRankingValueSource</a> but modified. GeoPortal's algorithm will yield a score of 0
+ * if either a line or point is compared, and it's doesn't output a 0-1 normalized score (it multiplies the factors).
  *
  * @lucene.experimental
  */
 public class AreaSimilarity implements BBoxSimilarity {
-  /**
-   * Properties associated with the query envelope
-   */
+
+  private final boolean isGeo;//-180/+180 degrees  (not part of identity; attached to parent strategy/field)
   private final Rectangle queryExtent;
-  private final double queryArea;
+  private final double queryArea;//not part of identity
 
-  private final double targetPower;
-  private final double queryPower;
+  private final double queryTargetProportion;
 
-  public AreaSimilarity(Rectangle queryExtent, double queryPower, double targetPower) {
+  //TODO option to compute geodetic area
+
+  public AreaSimilarity(boolean isGeo, Rectangle queryExtent, double queryTargetProportion) {
+    this.isGeo = isGeo;
     this.queryExtent = queryExtent;
     this.queryArea = queryExtent.getArea(null);
-
-    this.queryPower = queryPower;
-    this.targetPower = targetPower;
-
-//  if (this.qryMinX > queryExtent.getMaxX()) {
-//    this.qryCrossedDateline = true;
-//    this.qryArea = Math.abs(qryMaxX + 360.0 - qryMinX) * Math.abs(qryMaxY - qryMinY);
-//  } else {
-//    this.qryArea = Math.abs(qryMaxX - qryMinX) * Math.abs(qryMaxY - qryMinY);
-//  }
+    assert queryArea >= 0;
+    this.queryTargetProportion = queryTargetProportion;
+    if (queryTargetProportion < 0 || queryTargetProportion > 1.0)
+      throw new IllegalArgumentException("queryTargetProportion must be >= 0 and <= 1");
   }
 
+  /** Construct with 75% weighting towards target (roughly GeoPortal's default), geo degrees assumed. */
   public AreaSimilarity(Rectangle queryExtent) {
-    this(queryExtent, 2.0, 0.5);
+    this(true, queryExtent, 0.25);
   }
 
-
-  public String getDelimiterQueryParameters() {
-    return queryExtent.toString() + ";" + queryPower + ";" + targetPower;
+  @Override
+  public String toString() {
+    return queryExtent.toString() + ";" + queryTargetProportion;
   }
 
   @Override
   public double score(Rectangle target, Explanation exp) {
-    if (target == null || queryArea <= 0) {
+    if (target == null) {
       return 0;
     }
-    double targetArea = target.getArea(null);
-    if (targetArea <= 0) {
-      return 0;
-    }
-    double score = 0;
 
+    // calculate "height": the intersection height between two boxes.
     double top = Math.min(queryExtent.getMaxY(), target.getMaxY());
     double bottom = Math.max(queryExtent.getMinY(), target.getMinY());
     double height = top - bottom;
-    double width = 0;
+    if (height < 0)
+      return 0;//no intersection
 
-    // queries that cross the date line
-    if (queryExtent.getCrossesDateLine()) {
-      // documents that cross the date line
-      if (target.getCrossesDateLine()) {
-        double left = Math.max(queryExtent.getMinX(), target.getMinX());
-        double right = Math.min(queryExtent.getMaxX(), target.getMaxX());
-        width = right + 360.0 - left;
+    // calculate "width": the intersection width between two boxes.
+    double width = 0;
+    {
+      Rectangle a = queryExtent;
+      Rectangle b = target;
+      if (a.getCrossesDateLine() == b.getCrossesDateLine()) {
+        //both either cross or don't
+        double left = Math.max(a.getMinX(), b.getMinX());
+        double right = Math.min(a.getMaxX(), b.getMaxX());
+        if (!a.getCrossesDateLine()) {//both don't
+          if (left <= right) {
+            width = right - left;
+          } else if (isGeo && (Math.abs(a.getMinX()) == 180 || Math.abs(a.getMaxX()) == 180)
+              && (Math.abs(b.getMinX()) == 180 || Math.abs(b.getMaxX()) == 180)) {
+            width = 0;//both adjacent to dateline
-      } else {
+          } else {
-        double qryWestLeft = Math.max(queryExtent.getMinX(), target.getMaxX());
-        double qryWestRight = Math.min(target.getMaxX(), 180.0);
-        double qryWestWidth = qryWestRight - qryWestLeft;
-        if (qryWestWidth > 0) {
-          width = qryWestWidth;
+            return 0;//no intersection
+          }
+        } else {//both cross
+          width = right - left + 360;
+        }
-        } else {
+      } else {
-          double qryEastLeft = Math.max(target.getMaxX(), -180.0);
-          double qryEastRight = Math.min(queryExtent.getMaxX(), target.getMaxX());
-          double qryEastWidth = qryEastRight - qryEastLeft;
-          if (qryEastWidth > 0) {
-            width = qryEastWidth;
+        if (!a.getCrossesDateLine()) {//then flip
+          a = target;
+          b = queryExtent;
-          }
+        }
+        //a crosses, b doesn't
+        double qryWestLeft = Math.max(a.getMinX(), b.getMinX());
+        double qryWestRight = b.getMaxX();
+        if (qryWestLeft < qryWestRight)
+          width += qryWestRight - qryWestLeft;
+
+        double qryEastLeft = b.getMinX();
+        double qryEastRight = Math.min(a.getMaxX(), b.getMaxX());
+        if (qryEastLeft < qryEastRight)
+          width += qryEastRight - qryEastLeft;
+
+        if (qryWestLeft > qryWestRight && qryEastLeft > qryEastRight)
+          return 0;//no intersection
-        }
-      }
+      }
+    }
-    } else { // queries that do not cross the date line
 
-      if (target.getCrossesDateLine()) {
-        double tgtWestLeft = Math.max(queryExtent.getMinX(), target.getMinX());
-        double tgtWestRight = Math.min(queryExtent.getMaxX(), 180.0);
-        double tgtWestWidth = tgtWestRight - tgtWestLeft;
-        if (tgtWestWidth > 0) {
-          width = tgtWestWidth;
+    // calculate queryRatio and targetRatio
+    double intersectionArea = width * height;
+    double queryRatio;
+    if (queryArea > 0) {
+      queryRatio = intersectionArea / queryArea;
+    } else if (queryExtent.getHeight() > 0) {//vert line
+      queryRatio = height / queryExtent.getHeight();
+    } else if (queryExtent.getWidth() > 0) {//horiz line
+      queryRatio = width / queryExtent.getWidth();
-        } else {
+    } else {
-          double tgtEastLeft = Math.max(queryExtent.getMinX(), -180.0);
-          double tgtEastRight = Math.min(queryExtent.getMaxX(), target.getMaxX());
-          double tgtEastWidth = tgtEastRight - tgtEastLeft;
-          if (tgtEastWidth > 0) {
-            width = tgtEastWidth;
+      queryRatio = queryExtent.relate(target).intersects() ? 1 : 0;//could be optimized
-          }
+    }
-        }
+
+    double targetArea = target.getArea(null);
+    assert targetArea >= 0;
+    double targetRatio;
+    if (targetArea > 0) {
+      targetRatio = intersectionArea / targetArea;
+    } else if (target.getHeight() > 0) {//vert line
+      targetRatio = height / target.getHeight();
+    } else if (target.getWidth() > 0) {//horiz line
+      targetRatio = width / target.getWidth();
-      } else {
+    } else {
-        double left = Math.max(queryExtent.getMinX(), target.getMinX());
-        double right = Math.min(queryExtent.getMaxX(), target.getMaxX());
-        width = right - left;
+      targetRatio = target.relate(queryExtent).intersects() ? 1 : 0;//could be optimized
-      }
+    }
-    }
+    assert queryRatio >= 0 && queryRatio <= 1 : queryRatio;
+    assert targetRatio >= 0 && targetRatio <= 1 : targetRatio;
 
+    // combine ratios into a score
 
-    // calculate the score
-    if ((width > 0) && (height > 0)) {
-      double intersectionArea = width * height;
-      double queryRatio = intersectionArea / queryArea;
-      double targetRatio = intersectionArea / targetArea;
-      double queryFactor = Math.pow(queryRatio, queryPower);
-      double targetFactor = Math.pow(targetRatio, targetPower);
-      score = queryFactor * targetFactor * 10000.0;
+    double queryFactor = queryRatio * queryTargetProportion;
+    double targetFactor = targetRatio * (1.0 - queryTargetProportion);
+    double score = queryFactor + targetFactor;
 
-      if (exp!=null) {
+    if (exp!=null) {
-//        StringBuilder sb = new StringBuilder();
-//        sb.append("\nscore=").append(score);
-//        sb.append("\n  query=").append();
-//        sb.append("\n  target=").append(target.toString());
-//        sb.append("\n  intersectionArea=").append(intersectionArea);
-//        
-//        sb.append(" queryArea=").append(queryArea).append(" targetArea=").append(targetArea);
-//        sb.append("\n  queryRatio=").append(queryRatio).append(" targetRatio=").append(targetRatio);
-//        sb.append("\n  queryFactor=").append(queryFactor).append(" targetFactor=").append(targetFactor);
-//        sb.append(" (queryPower=").append(queryPower).append(" targetPower=").append(targetPower).append(")");
-        
-        exp.setValue((float)score);
+      exp.setValue((float)score);
-        exp.setDescription(this.getClass().getSimpleName());
+      exp.setDescription(this.getClass().getSimpleName()+": queryFactor + targetFactor");
-        
+
-        Explanation e = null;
+      Explanation e;//tmp
-        
-        exp.addDetail( e = new Explanation((float)intersectionArea, "IntersectionArea") );
+
+      exp.addDetail( e = new Explanation((float)intersectionArea, "IntersectionArea") );
-        e.addDetail(new Explanation((float)width,  "width; Query: "+queryExtent.toString()));
-        e.addDetail(new Explanation((float)height, "height; Target: "+target.toString()));
+      e.addDetail(new Explanation((float)width,  "width"));
+      e.addDetail(new Explanation((float)height, "height"));
+      e.addDetail(new Explanation((float)queryTargetProportion, "queryTargetProportion"));
 
-        exp.addDetail( e = new Explanation((float)queryFactor, "Query") );
-        e.addDetail(new Explanation((float)queryArea, "area"));
+      exp.addDetail( e = new Explanation((float)queryFactor, "queryFactor") );
-        e.addDetail(new Explanation((float)queryRatio, "ratio"));
+      e.addDetail(new Explanation((float)queryRatio, "ratio"));
-        e.addDetail(new Explanation((float)queryPower, "power"));
+      e.addDetail(new Explanation((float)queryArea,  "area of " + queryExtent));
 
-        exp.addDetail( e = new Explanation((float)targetFactor, "Target") );
-        e.addDetail(new Explanation((float)targetArea, "area"));
+      exp.addDetail( e = new Explanation((float)targetFactor, "targetFactor") );
-        e.addDetail(new Explanation((float)targetRatio, "ratio"));
+      e.addDetail(new Explanation((float)targetRatio, "ratio"));
-        e.addDetail(new Explanation((float)targetPower, "power"));
+      e.addDetail(new Explanation((float)targetArea,  "area of " + target));
-      }
+    }
-    }
-    else if(exp !=null) {
-      exp.setValue(0);
-      exp.setDescription("Shape does not intersect");
-    }
+
     return score;
   }
 
-
-  /**
-   * Determines if this ValueSource is equal to another.
-   *
-   * @param o the ValueSource to compare
-   * @return <code>true</code> if the two objects are based upon the same query envelope
-   */
   @Override
   public boolean equals(Object o) {
-    if (o.getClass() != AreaSimilarity.class)
-      return false;
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
 
-    AreaSimilarity other = (AreaSimilarity) o;
-    return getDelimiterQueryParameters().equals(other.getDelimiterQueryParameters());
+    AreaSimilarity that = (AreaSimilarity) o;
+
+    if (Double.compare(that.queryTargetProportion, queryTargetProportion) != 0) return false;
+    if (!queryExtent.equals(that.queryExtent)) return false;
+
+    return true;
   }
 
-  /**
-   * Returns the ValueSource hash code.
-   *
-   * @return the hash code
-   */
   @Override
   public int hashCode() {
-    return getDelimiterQueryParameters().hashCode();
+    int result;
+    long temp;
+    result = queryExtent.hashCode();
+    temp = Double.doubleToLongBits(queryTargetProportion);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    return result;
   }
 }
Index: lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource.java	(revision 1603308)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarityValueSource.java	(revision )
@@ -18,119 +18,79 @@
  */
 
 import com.spatial4j.core.shape.Rectangle;
-import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.AtomicReaderContext;
-import org.apache.lucene.index.DocValues;
-import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.queries.function.FunctionValues;
 import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.queries.function.docvalues.DoubleDocValues;
 import org.apache.lucene.search.Explanation;
-import org.apache.lucene.util.Bits;
+import org.apache.lucene.search.IndexSearcher;
 
 import java.io.IOException;
 import java.util.Map;
 
 /**
- * An implementation of the Lucene ValueSource model to support spatial relevance ranking.
+ * Support spatial relevance ranking via a {@link org.apache.lucene.spatial.bbox.BBoxSimilarity}.
  *
  * @lucene.experimental
  */
 public class BBoxSimilarityValueSource extends ValueSource {
 
-  private final BBoxStrategy strategy;
+  private final ValueSource bboxValueSource;
   private final BBoxSimilarity similarity;
 
-  public BBoxSimilarityValueSource(BBoxStrategy strategy, BBoxSimilarity similarity) {
-    this.strategy = strategy;
+  public BBoxSimilarityValueSource(ValueSource bboxValueSource, BBoxSimilarity similarity) {
+    this.bboxValueSource = bboxValueSource;
     this.similarity = similarity;
   }
 
-  /**
-   * Returns the ValueSource description.
-   *
-   * @return the description
-   */
   @Override
+  public void createWeight(Map context, IndexSearcher searcher) throws IOException {
+    bboxValueSource.createWeight(context, searcher);
+  }
+
+  @Override
   public String description() {
-    return "BBoxSimilarityValueSource(" + similarity + ")";
+    return getClass().getSimpleName()+"(" + bboxValueSource.description() + "," + similarity + ")";
   }
 
-
-  /**
-   * Returns the DocValues used by the function query.
-   *
-   * @param readerContext the AtomicReaderContext which holds an AtomicReader
-   * @return the values
-   */
   @Override
   public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
-    AtomicReader reader = readerContext.reader();
-    final NumericDocValues minX = DocValues.getNumeric(reader, strategy.field_minX);
-    final NumericDocValues minY = DocValues.getNumeric(reader, strategy.field_minY);
-    final NumericDocValues maxX = DocValues.getNumeric(reader, strategy.field_maxX);
-    final NumericDocValues maxY = DocValues.getNumeric(reader, strategy.field_maxY);
 
-    final Bits validMinX = DocValues.getDocsWithField(reader, strategy.field_minX);
-    final Bits validMaxX = DocValues.getDocsWithField(reader, strategy.field_maxX);
+    final FunctionValues shapeValues = bboxValueSource.getValues(context, readerContext);
 
-    return new FunctionValues() {
-      //reused
-      Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);
-
+    return new DoubleDocValues(this) {
       @Override
-      public float floatVal(int doc) {
-        double minXVal = Double.longBitsToDouble(minX.get(doc));
-        double maxXVal = Double.longBitsToDouble(maxX.get(doc));
-        // make sure it has minX and area
-        if ((minXVal != 0 || validMinX.get(doc)) && (maxXVal != 0 || validMaxX.get(doc))) {
-          rect.reset(
-              minXVal, maxXVal,
-              Double.longBitsToDouble(minY.get(doc)), Double.longBitsToDouble(maxY.get(doc)));
-          return (float) similarity.score(rect, null);
-        } else {
-          return (float) similarity.score(null, null);
+      public double doubleVal(int doc) {
+        return similarity.score((Rectangle) shapeValues.objectVal(doc), null);
-        }
+      }
-      }
 
       @Override
       public Explanation explain(int doc) {
-        // make sure it has minX and area
-        if (validMinX.get(doc) && validMaxX.get(doc)) {
-          rect.reset(
-              Double.longBitsToDouble(minX.get(doc)), Double.longBitsToDouble(maxX.get(doc)),
-              Double.longBitsToDouble(minY.get(doc)), Double.longBitsToDouble(maxY.get(doc)));
+        final Rectangle rect = (Rectangle) shapeValues.objectVal(doc);
-          Explanation exp = new Explanation();
-          similarity.score(rect, exp);
-          return exp;
-        }
+        Explanation exp = new Explanation();
+        similarity.score(rect, exp);
+        return exp;
+      }
-        return new Explanation(0, "No BBox");
-      }
-
-      @Override
-      public String toString(int doc) {
-        return description() + "=" + floatVal(doc);
-      }
     };
   }
 
-  /**
-   * Determines if this ValueSource is equal to another.
-   *
-   * @param o the ValueSource to compare
-   * @return <code>true</code> if the two objects are based upon the same query envelope
-   */
   @Override
   public boolean equals(Object o) {
-    if (o.getClass() != BBoxSimilarityValueSource.class) {
-      return false;
-    }
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
 
-    BBoxSimilarityValueSource other = (BBoxSimilarityValueSource) o;
-    return similarity.equals(other.similarity);
+    BBoxSimilarityValueSource that = (BBoxSimilarityValueSource) o;
+
+    if (!bboxValueSource.equals(that.bboxValueSource)) return false;
+    if (!similarity.equals(that.similarity)) return false;
+
+    return true;
   }
 
   @Override
   public int hashCode() {
-    return BBoxSimilarityValueSource.class.hashCode() + similarity.hashCode();
+    int result = bboxValueSource.hashCode();
+    result = 31 * result + similarity.hashCode();
+    return result;
   }
 }
Index: lucene/spatial/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java	(revision 1603308)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java	(revision )
@@ -17,51 +17,202 @@
  * limitations under the License.
  */
 
+import com.carrotsearch.randomizedtesting.annotations.Repeat;
 import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.context.SpatialContextFactory;
+import com.spatial4j.core.distance.DistanceUtils;
+import com.spatial4j.core.shape.Rectangle;
 import com.spatial4j.core.shape.Shape;
+import com.spatial4j.core.shape.impl.RectangleImpl;
 import org.apache.lucene.spatial.SpatialMatchConcern;
-import org.apache.lucene.spatial.StrategyTestCase;
-import org.junit.Before;
+import org.apache.lucene.spatial.prefix.RandomSpatialOpStrategyTestCase;
+import org.apache.lucene.spatial.query.SpatialOperation;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import java.io.IOException;
 
-public class TestBBoxStrategy extends StrategyTestCase {
+public class TestBBoxStrategy extends RandomSpatialOpStrategyTestCase {
 
-  @Before
   @Override
-  public void setUp() throws Exception {
-    super.setUp();
+  protected Shape randomIndexedShape() {
+    Rectangle world = ctx.getWorldBounds();
+    if (random().nextInt(10) == 0) // increased chance of getting one of these
+      return world;
+
+    int worldWidth = (int) Math.round(world.getWidth());
+    int deltaLeft = nextIntInclusive(worldWidth);
+    int deltaRight = nextIntInclusive(worldWidth - deltaLeft);
+    int worldHeight = (int) Math.round(world.getHeight());
+    int deltaTop = nextIntInclusive(worldHeight);
+    int deltaBottom = nextIntInclusive(worldHeight - deltaTop);
+    if (ctx.isGeo() && (deltaLeft != 0 || deltaRight != 0)) {
+      //if geo & doesn't world-wrap, we shift randomly to potentially cross dateline
+      int shift = nextIntInclusive(360);
+      return ctx.makeRectangle(
+          DistanceUtils.normLonDEG(world.getMinX() + deltaLeft + shift),
+          DistanceUtils.normLonDEG(world.getMaxX() - deltaRight + shift),
+          world.getMinY() + deltaBottom, world.getMaxY() - deltaTop);
+    } else {
+      return ctx.makeRectangle(
+          world.getMinX() + deltaLeft, world.getMaxX() - deltaRight,
+          world.getMinY() + deltaBottom, world.getMaxY() - deltaTop);
+    }
+
+  }
+
+  /** next int, inclusive, rounds to multiple of 10 if given evenly divisible. */
+  private int nextIntInclusive(int toInc) {
+    final int DIVIS = 10;
+    if (toInc % DIVIS == 0) {
+      return random().nextInt(toInc/DIVIS + 1) * DIVIS;
+    } else {
+      return random().nextInt(toInc + 1);
+    }
+  }
+
+  @Override
+  protected Shape randomQueryShape() {
+    return randomIndexedShape();
+  }
+
+  @Test
+  @Repeat(iterations = 20)
+  public void testOperations() throws IOException {
+    //setup
+    if (random().nextInt(4) > 0) {//75% of the time choose geo (more interesting to test)
-    this.ctx = SpatialContext.GEO;
+      this.ctx = SpatialContext.GEO;
+    } else {
+      SpatialContextFactory factory = new SpatialContextFactory();
+      factory.geo = false;
+      factory.worldBounds = new RectangleImpl(-300, 300, -100, 100, null);
+      this.ctx = factory.newSpatialContext();
+    }
     this.strategy = new BBoxStrategy(ctx, "bbox");
+
+    for (SpatialOperation operation : SpatialOperation.values()) {
+      if (operation == SpatialOperation.Overlaps)
+        continue;//unsupported
+      testOperationRandomShapes(operation);
+
+      deleteAll();
+      commit();
-  }
+    }
+  }
 
-  /* Convert DATA_WORLD_CITIES_POINTS to bbox */
-  @Override
-  protected Shape convertShapeFromGetDocuments(Shape shape) {
-    return shape.getBoundingBox();
+  @Test
+  public void testIntersectsBugDatelineEdge() throws IOException {
+    setupGeo();
+    testOperation(
+        ctx.makeRectangle(160, 180, -10, 10),
+        SpatialOperation.Intersects,
+        ctx.makeRectangle(-180, -160, -10, 10), true);
   }
 
   @Test
+  public void testWithinBugDatelineEdge() throws IOException {
+    setupGeo();
+    testOperation(
+        ctx.makeRectangle(180, 180, -10, 10),
+        SpatialOperation.IsWithin,
+        ctx.makeRectangle(-180, -100, -10, 10), true);
+  }
+
+  @Test
+  public void testContainsBugDatelineEdge() throws IOException {
+    setupGeo();
+    testOperation(
+        ctx.makeRectangle(-180, -150, -10, 10),
+        SpatialOperation.Contains,
+        ctx.makeRectangle(180, 180, -10, 10), true);
+  }
+
+  @Test
+  public void testWorldContainsXDL() throws IOException {
+    setupGeo();
+    testOperation(
+        ctx.makeRectangle(-180, 180, -10, 10),
+        SpatialOperation.Contains,
+        ctx.makeRectangle(170, -170, -10, 10), true);
+  }
+
+  private void setupGeo() {
+    this.ctx = SpatialContext.GEO;
+    this.strategy = new BBoxStrategy(ctx, "bbox");
+  }
+
+  // OLD STATIC TESTS (worthless?)
+
+  @Test @Ignore("Overlaps not supported")
   public void testBasicOperaions() throws IOException {
+    setupGeo();
     getAddAndVerifyIndexedDocuments(DATA_SIMPLE_BBOX);
-    
+
     executeQueries(SpatialMatchConcern.EXACT, QTEST_Simple_Queries_BBox);
   }
-  
+
   @Test
   public void testStatesBBox() throws IOException {
+    setupGeo();
     getAddAndVerifyIndexedDocuments(DATA_STATES_BBOX);
-    
+
     executeQueries(SpatialMatchConcern.FILTER, QTEST_States_IsWithin_BBox);
     executeQueries(SpatialMatchConcern.FILTER, QTEST_States_Intersects_BBox);
   }
 
   @Test
   public void testCitiesIntersectsBBox() throws IOException {
+    setupGeo();
     getAddAndVerifyIndexedDocuments(DATA_WORLD_CITIES_POINTS);
-    
+
     executeQueries(SpatialMatchConcern.FILTER, QTEST_Cities_Intersects_BBox);
   }
-  
+
+  /* Convert DATA_WORLD_CITIES_POINTS to bbox */
+  @Override
+  protected Shape convertShapeFromGetDocuments(Shape shape) {
+    return shape.getBoundingBox();
+  }
+
+  public void testAreaOverlap() throws IOException {
+    setupGeo();
+    for (int SHIFT = 0; SHIFT < 360; SHIFT += 10) {
+      Rectangle queryBox = shiftedRect(0, 40, -20, 20, SHIFT);//40x40, 1600 area
+      AreaSimilarity sim = new AreaSimilarity(true, queryBox, 0.5);//even distribution
+      int nudge = SHIFT == 0 ? 0 : random().nextInt(3) * 10 - 10;//-10, 0, or 10.  Keep 0 on first round.
+
+      assertEquals("within", (200d/1600d * 0.5) + (0.5), sim.score(shiftedRect(10, 30, 0, 10, SHIFT + nudge), null), 0.0001);
+
+      assertEquals("in25%", 0.25, sim.score(shiftedRect(30, 70, -20, 20, SHIFT), null), 0.0001);
+
+      assertEquals("wrap", 0.2794117, sim.score(shiftedRect(30, 10, -20, 20, SHIFT + nudge), null), 0.0001);
+
+      assertEquals("no intersection H", 0.0, sim.score(shiftedRect(-10, -10, -20, 20, SHIFT), null), 0.0001);
+      assertEquals("no intersection V", 0.0, sim.score(shiftedRect(0, 20, -30, -30, SHIFT), null), 0.0001);
+
+      assertEquals("point", 0.5, sim.score(shiftedRect(0, 0, 0, 0, SHIFT), null), 0.0001);
+
+      assertEquals("line 25% intersection", 0.25/2, sim.score(shiftedRect(-30, 10, 0, 0, SHIFT), null), 0.0001);
+
+      assertEquals("null", 0.0, sim.score(null, null), 0.0001);
+
+      //test with point query
+      sim = new AreaSimilarity(true, shiftedRect(0, 0, 0, 0, SHIFT), 0.5);
+      assertEquals("same", 1.0, sim.score(shiftedRect(0, 0, 0, 0, SHIFT), null), 0.0001);
+      assertEquals("contains", 0.5, sim.score(shiftedRect(0, 30, 0, 10, SHIFT), null), 0.0001);
+
+      //test with line query (vertical this time)
+      sim = new AreaSimilarity(true, shiftedRect(0, 0, 20, 40, SHIFT), 0.5);
+      assertEquals("line 50%", 0.5, sim.score(shiftedRect(0, 0, 10, 30, SHIFT), null), 0.0001);
+      assertEquals("point", 0.5, sim.score(shiftedRect(0, 0, 30, 30, SHIFT), null), 0.0001);
+    }
+
+  }
+
+  private Rectangle shiftedRect(double minX, double maxX, double minY, double maxY, int xShift) {
+    return ctx.makeRectangle(
+        DistanceUtils.normLonDEG(minX + xShift),
+        DistanceUtils.normLonDEG(maxX + xShift),
+        minY, maxY);
+  }
 }
Index: lucene/spatial/src/java/org/apache/lucene/spatial/bbox/DistanceSimilarity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/bbox/DistanceSimilarity.java	(revision 1603308)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/bbox/DistanceSimilarity.java	(revision )
@@ -32,7 +32,7 @@
   private final Point queryPoint;
   private final double multiplier;
   private final DistanceCalculator distCalc;
-  private final double nullValue;
+  private final double nullValue;//not part of identity
 
   public DistanceSimilarity(SpatialContext ctx, Point queryPoint, double multiplier) {
     this.queryPoint = queryPoint;
@@ -67,7 +67,6 @@
     DistanceSimilarity that = (DistanceSimilarity) o;
 
     if (Double.compare(that.multiplier, multiplier) != 0) return false;
-    if (Double.compare(that.nullValue, nullValue) != 0) return false;
     if (!distCalc.equals(that.distCalc)) return false;
     if (!queryPoint.equals(that.queryPoint)) return false;
 
@@ -82,8 +81,6 @@
     temp = Double.doubleToLongBits(multiplier);
     result = 31 * result + (int) (temp ^ (temp >>> 32));
     result = 31 * result + distCalc.hashCode();
-    temp = Double.doubleToLongBits(nullValue);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
     return result;
   }
 }
Index: lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxValueSource.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxValueSource.java	(revision )
+++ lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxValueSource.java	(revision )
@@ -0,0 +1,116 @@
+package org.apache.lucene.spatial.bbox;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import com.spatial4j.core.shape.Rectangle;
+import org.apache.lucene.index.AtomicReader;
+import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.NumericDocValues;
+import org.apache.lucene.queries.function.FunctionValues;
+import org.apache.lucene.queries.function.ValueSource;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.util.Bits;
+
+import java.io.IOException;
+import java.util.Map;
+
+/**
+ * A ValueSource in which the indexed Rectangle is returned from
+ * {@link org.apache.lucene.queries.function.FunctionValues#objectVal(int)}.
+ *
+ * @lucene.internal
+ */
+class BBoxValueSource extends ValueSource {
+
+  private final BBoxStrategy strategy;
+
+  public BBoxValueSource(BBoxStrategy strategy) {
+    this.strategy = strategy;
+  }
+
+  @Override
+  public String description() {
+    return "bboxShape(" + strategy.getFieldName() + ")";
+  }
+
+  @Override
+  public FunctionValues getValues(Map context, AtomicReaderContext readerContext) throws IOException {
+    AtomicReader reader = readerContext.reader();
+    final NumericDocValues minX = DocValues.getNumeric(reader, strategy.field_minX);
+    final NumericDocValues minY = DocValues.getNumeric(reader, strategy.field_minY);
+    final NumericDocValues maxX = DocValues.getNumeric(reader, strategy.field_maxX);
+    final NumericDocValues maxY = DocValues.getNumeric(reader, strategy.field_maxY);
+
+    final Bits validBits = DocValues.getDocsWithField(reader, strategy.field_minX);//could have chosen any field
+    //reused
+    final Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);
+
+    return new FunctionValues() {
+      @Override
+      public Object objectVal(int doc) {
+        if (!validBits.get(doc)) {
+          return null;
+        } else {
+          rect.reset(
+              Double.longBitsToDouble(minX.get(doc)), Double.longBitsToDouble(maxX.get(doc)),
+              Double.longBitsToDouble(minY.get(doc)), Double.longBitsToDouble(maxY.get(doc)));
+          return rect;
+        }
+      }
+
+      @Override
+      public String strVal(int doc) {//TODO support WKT output once Spatial4j does
+        Object v = objectVal(doc);
+        return v == null ? null : v.toString();
+      }
+
+      @Override
+      public boolean exists(int doc) {
+        return validBits.get(doc);
+      }
+
+      @Override
+      public Explanation explain(int doc) {
+        return new Explanation(Float.NaN, toString(doc));
+      }
+
+      @Override
+      public String toString(int doc) {
+        return description() + '=' + strVal(doc);
+      }
+    };
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+
+    BBoxValueSource that = (BBoxValueSource) o;
+
+    if (!strategy.equals(that.strategy)) return false;
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    return strategy.hashCode();
+  }
+}
Index: lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarity.java	(revision 1603308)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxSimilarity.java	(revision )
@@ -16,16 +16,24 @@
  */
 package org.apache.lucene.spatial.bbox;
 
+import com.spatial4j.core.shape.Rectangle;
 import org.apache.lucene.search.Explanation;
 
-import com.spatial4j.core.shape.Rectangle;
-
 /**
- * Abstraction of the calculation used to determine how similar two Bounding Boxes are.
+ * Abstraction of the calculation used to determine how similar two bounding boxes (rectangles) are.
  *
+ * <p>Implementers: Remember equals & hashCode!</p>
+ *
  * @lucene.experimental
  */
 public interface BBoxSimilarity {
 
-  public double score(Rectangle extent, Explanation exp);
+  /**
+   * Return a relevancy score. If {@code exp} is provided then diagnostic information is added.
+   * @param indexedBbox The indexed rectangle or null if none.
+   * @param exp Optional diagnostic holder.
+   * @return a score. Generally use 0 when indexedBBox is null.
+   */
+  public double score(Rectangle indexedBbox, Explanation exp);
+
 }
Index: lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxStrategy.java	(revision 1603308)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxStrategy.java	(revision )
@@ -27,7 +27,6 @@
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
@@ -41,6 +40,9 @@
 import org.apache.lucene.spatial.query.SpatialArgs;
 import org.apache.lucene.spatial.query.SpatialOperation;
 import org.apache.lucene.spatial.query.UnsupportedSpatialOperation;
+import org.apache.lucene.spatial.util.DistanceToShapeValueSource;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.NumericUtils;
 
 
 /**
@@ -53,7 +55,7 @@
  * <ul>
  * <li>Only indexes Rectangles; just one per field value.</li>
  * <li>Can query only by a Rectangle.</li>
- * <li>Supports all {@link SpatialOperation}s.</li>
+ * <li>Supports most {@link SpatialOperation}s -- not Overlaps.</li>
  * <li>Uses the DocValues API for any sorting / relevancy.</li>
  * </ul>
  *
@@ -62,7 +64,7 @@
  * and a boolean to mark a dateline cross. Depending on the particular {@link
  * SpatialOperation}s, there is a variety of {@link NumericRangeQuery}s to be
  * done.
- * The {@link #makeBBoxAreaSimilarityValueSource(com.spatial4j.core.shape.Rectangle)}
+ * The {@link #makeBBoxAreaSimilarityValueSource(com.spatial4j.core.shape.Rectangle, double)}
  * works by calculating the query bbox overlap percentage against the indexed
  * shape overlap percentage. The indexed shape's coordinates are retrieved from
  * {@link AtomicReader#getNumericDocValues}
@@ -81,16 +83,14 @@
    * The Bounding Box gets stored as four fields for x/y min/max and a flag
    * that says if the box crosses the dateline (xdl).
    */
-  public final String field_bbox;
-  public final String field_minX;
-  public final String field_minY;
-  public final String field_maxX;
-  public final String field_maxY;
-  public final String field_xdl; // crosses dateline
+  protected final String field_bbox;
+  protected final String field_minX;
+  protected final String field_minY;
+  protected final String field_maxX;
+  protected final String field_maxY;
+  protected final String field_xdl; // crosses dateline
 
-  public double queryPower = 1.0;
-  public double targetPower = 1.0f;
-  public int precisionStep = 8; // same as solr default
+  protected int precisionStep = 8; // same as solr default
 
   public BBoxStrategy(SpatialContext ctx, String fieldNamePrefix) {
     super(ctx, fieldNamePrefix);
@@ -132,20 +132,34 @@
   }
 
   //---------------------------------
-  // Query Builder
+  // Value Source / Relevancy
   //---------------------------------
 
+  /**
+   * Provides access to each rectangle per document as a ValueSource in which
+   * {@link org.apache.lucene.queries.function.FunctionValues#objectVal(int)} returns a {@link
+   * Shape}.
+   */ //TODO raise to SpatialStrategy
+  public ValueSource makeShapeValueSource() {
+    return new BBoxValueSource(this);
+  }
+
   @Override
   public ValueSource makeDistanceValueSource(Point queryPoint, double multiplier) {
-    return new BBoxSimilarityValueSource(
-        this, new DistanceSimilarity(this.getSpatialContext(), queryPoint, multiplier));
+    //TODO if makeShapeValueSource gets lifted to the top; this could become a generic impl.
+    return new DistanceToShapeValueSource(makeShapeValueSource(), queryPoint, multiplier, ctx);
   }
 
-  public ValueSource makeBBoxAreaSimilarityValueSource(Rectangle queryBox) {
+  /** Returns a similarity based on {@link org.apache.lucene.spatial.bbox.AreaSimilarity}. */
+  public ValueSource makeBBoxAreaSimilarityValueSource(Rectangle queryBox, double queryTargetProportion) {
     return new BBoxSimilarityValueSource(
-        this, new AreaSimilarity(queryBox, queryPower, targetPower));
+        makeShapeValueSource(), new AreaSimilarity(ctx.isGeo(), queryBox, queryTargetProportion));
   }
 
+  //---------------------------------
+  // Query / Filter Building
+  //---------------------------------
+
   @Override
   public Filter makeFilter(SpatialArgs args) {
     return new QueryWrapperFilter(makeSpatialQuery(args));
@@ -156,18 +170,11 @@
     return new ConstantScoreQuery(makeSpatialQuery(args));
   }
 
-  public Query makeQueryWithValueSource(SpatialArgs args, ValueSource valueSource) {
-    BooleanQuery bq = new BooleanQuery();
-    Query spatial = makeSpatialQuery(args);
-    bq.add(new ConstantScoreQuery(spatial), BooleanClause.Occur.MUST);
+//  Utility on SpatialStrategy?
+//  public Query makeQueryWithValueSource(SpatialArgs args, ValueSource valueSource) {
+//    return new FilteredQuery(new FunctionQuery(valueSource), makeFilter(args));
+//  }
 
-    // This part does the scoring
-    Query spatialRankingQuery = new FunctionQuery(valueSource);
-    bq.add(spatialRankingQuery, BooleanClause.Occur.MUST);
-    return bq;
-  }
-
-
   private Query makeSpatialQuery(SpatialArgs args) {
     Shape shape = args.getShape();
     if (!(shape instanceof Rectangle))
@@ -186,18 +193,12 @@
     else if( op == SpatialOperation.IsEqualTo      ) spatial = makeEquals(bbox);
     else if( op == SpatialOperation.IsDisjointTo   ) spatial = makeDisjoint(bbox);
     else if( op == SpatialOperation.IsWithin       ) spatial = makeWithin(bbox);
-    else if( op == SpatialOperation.Overlaps       ) spatial = makeIntersects(bbox);
-    else {
+    else { //no Overlaps support yet
         throw new UnsupportedSpatialOperation(op);
     }
     return spatial;
   }
 
-
-  //-------------------------------------------------------------------------------
-  //
-  //-------------------------------------------------------------------------------
-
   /**
    * Constructs a query to retrieve documents that fully contain the input envelope.
    *
@@ -228,20 +229,30 @@
       Query qMinMax = this.makeQuery(BooleanClause.Occur.MUST, qMinX, qMaxX);
       Query qNonXDL = this.makeXDL(false, qMinMax);
 
+      if (!ctx.isGeo()) {
+        xConditions = qNonXDL;
+      } else {
-      // X Conditions for documents that cross the date line,
-      // the left portion of the document contains the min X of the query
-      // OR the right portion of the document contains the max X of the query,
-      // docMinXLeft <= queryExtent.getMinX() OR docMaxXRight >= queryExtent.getMaxX()
-      Query qXDLLeft = NumericRangeQuery.newDoubleRange(field_minX, precisionStep, null, bbox.getMinX(), false, true);
-      Query qXDLRight = NumericRangeQuery.newDoubleRange(field_maxX, precisionStep, bbox.getMaxX(), null, true, false);
-      Query qXDLLeftRight = this.makeQuery(BooleanClause.Occur.SHOULD, qXDLLeft, qXDLRight);
-      Query qXDL = this.makeXDL(true, qXDLLeftRight);
+        // X Conditions for documents that cross the date line,
+        // the left portion of the document contains the min X of the query
+        // OR the right portion of the document contains the max X of the query,
+        // docMinXLeft <= queryExtent.getMinX() OR docMaxXRight >= queryExtent.getMaxX()
+        Query qXDLLeft = NumericRangeQuery.newDoubleRange(field_minX, precisionStep, null, bbox.getMinX(), false, true);
+        Query qXDLRight = NumericRangeQuery.newDoubleRange(field_maxX, precisionStep, bbox.getMaxX(), null, true, false);
+        Query qXDLLeftRight = this.makeQuery(BooleanClause.Occur.SHOULD, qXDLLeft, qXDLRight);
+        Query qXDL = this.makeXDL(true, qXDLLeftRight);
 
-      // apply the non-XDL and XDL conditions
-      xConditions = this.makeQuery(BooleanClause.Occur.SHOULD, qNonXDL, qXDL);
+        Query qEdgeDL = null;
+        if (bbox.getMinX() == bbox.getMaxX() && Math.abs(bbox.getMinX()) == 180) {
+          double edge = bbox.getMinX() * -1;//opposite dateline edge
+          qEdgeDL = makeQuery(BooleanClause.Occur.SHOULD,
+              makeNumberTermQuery(field_minX, edge), makeNumberTermQuery(field_maxX, edge));
+        }
 
-      // queries that cross the date line
+        // apply the non-XDL and XDL conditions
+        xConditions = this.makeQuery(BooleanClause.Occur.SHOULD, qNonXDL, qXDL, qEdgeDL);
+      }
     } else {
+      // queries that cross the date line
 
       // No need to search for documents that do not cross the date line
 
@@ -251,9 +262,12 @@
       // docMinXLeft <= queryExtent.getMinX() AND docMaxXRight >= queryExtent.getMaxX()
       Query qXDLLeft = NumericRangeQuery.newDoubleRange(field_minX, precisionStep, null, bbox.getMinX(), false, true);
       Query qXDLRight = NumericRangeQuery.newDoubleRange(field_maxX, precisionStep, bbox.getMaxX(), null, true, false);
-      Query qXDLLeftRight = this.makeQuery(BooleanClause.Occur.MUST, qXDLLeft, qXDLRight);
+      Query qXDLLeftRight = this.makeXDL(true, this.makeQuery(BooleanClause.Occur.MUST, qXDLLeft, qXDLRight));
 
-      xConditions = this.makeXDL(true, qXDLLeftRight);
+      Query qWorld = makeQuery(BooleanClause.Occur.MUST,
+          makeNumberTermQuery(field_minX, -180), makeNumberTermQuery(field_maxX, 180));
+
+      xConditions = makeQuery(BooleanClause.Occur.SHOULD, qXDLLeftRight, qWorld);
     }
 
     // both X and Y conditions must occur
@@ -285,25 +299,41 @@
       // X Conditions for documents that do not cross the date line,
       // docMinX > queryExtent.getMaxX() OR docMaxX < queryExtent.getMinX()
       Query qMinX = NumericRangeQuery.newDoubleRange(field_minX, precisionStep, bbox.getMaxX(), null, false, false);
+      if (bbox.getMinX() == -180.0 && ctx.isGeo()) {//touches dateline; -180 == 180
+        BooleanQuery bq = new BooleanQuery();
+        bq.add(qMinX, BooleanClause.Occur.MUST);
+        bq.add(makeNumberTermQuery(field_maxX, 180.0), BooleanClause.Occur.MUST_NOT);
+        qMinX = bq;
+      }
       Query qMaxX = NumericRangeQuery.newDoubleRange(field_maxX, precisionStep, null, bbox.getMinX(), false, false);
+      if (bbox.getMaxX() == 180.0 && ctx.isGeo()) {//touches dateline; -180 == 180
+        BooleanQuery bq = new BooleanQuery();
+        bq.add(qMaxX, BooleanClause.Occur.MUST);
+        bq.add(makeNumberTermQuery(field_minX, -180.0), BooleanClause.Occur.MUST_NOT);
+        qMaxX = bq;
+      }
       Query qMinMax = this.makeQuery(BooleanClause.Occur.SHOULD, qMinX, qMaxX);
       Query qNonXDL = this.makeXDL(false, qMinMax);
 
+      if (!ctx.isGeo()) {
+        xConditions = qNonXDL;
+      } else {
-      // X Conditions for documents that cross the date line,
+        // X Conditions for documents that cross the date line,
+
-      // both the left and right portions of the document must be disjoint to the query
-      // (docMinXLeft > queryExtent.getMaxX() OR docMaxXLeft < queryExtent.getMinX()) AND
-      // (docMinXRight > queryExtent.getMaxX() OR docMaxXRight < queryExtent.getMinX())
-      // where: docMaxXLeft = 180.0, docMinXRight = -180.0
-      // (docMaxXLeft  < queryExtent.getMinX()) equates to (180.0  < queryExtent.getMinX()) and is ignored
-      // (docMinXRight > queryExtent.getMaxX()) equates to (-180.0 > queryExtent.getMaxX()) and is ignored
-      Query qMinXLeft = NumericRangeQuery.newDoubleRange(field_minX, precisionStep, bbox.getMaxX(), null, false, false);
-      Query qMaxXRight = NumericRangeQuery.newDoubleRange(field_maxX, precisionStep, null, bbox.getMinX(), false, false);
-      Query qLeftRight = this.makeQuery(BooleanClause.Occur.MUST, qMinXLeft, qMaxXRight);
-      Query qXDL = this.makeXDL(true, qLeftRight);
+        // both the left and right portions of the document must be disjoint to the query
+        // (docMinXLeft > queryExtent.getMaxX() OR docMaxXLeft < queryExtent.getMinX()) AND
+        // (docMinXRight > queryExtent.getMaxX() OR docMaxXRight < queryExtent.getMinX())
+        // where: docMaxXLeft = 180.0, docMinXRight = -180.0
+        // (docMaxXLeft  < queryExtent.getMinX()) equates to (180.0  < queryExtent.getMinX()) and is ignored
+        // (docMinXRight > queryExtent.getMaxX()) equates to (-180.0 > queryExtent.getMaxX()) and is ignored
+        Query qMinXLeft = NumericRangeQuery.newDoubleRange(field_minX, precisionStep, bbox.getMaxX(), null, false, false);
+        Query qMaxXRight = NumericRangeQuery.newDoubleRange(field_maxX, precisionStep, null, bbox.getMinX(), false, false);
+        Query qLeftRight = this.makeQuery(BooleanClause.Occur.MUST, qMinXLeft, qMaxXRight);
+        Query qXDL = this.makeXDL(true, qLeftRight);
 
-      // apply the non-XDL and XDL conditions
-      xConditions = this.makeQuery(BooleanClause.Occur.SHOULD, qNonXDL, qXDL);
+        // apply the non-XDL and XDL conditions
+        xConditions = this.makeQuery(BooleanClause.Occur.SHOULD, qNonXDL, qXDL);
-
+      }
       // queries that cross the date line
     } else {
 
@@ -336,16 +366,11 @@
   Query makeEquals(Rectangle bbox) {
 
     // docMinX = queryExtent.getMinX() AND docMinY = queryExtent.getMinY() AND docMaxX = queryExtent.getMaxX() AND docMaxY = queryExtent.getMaxY()
-    Query qMinX = NumericRangeQuery.newDoubleRange(field_minX, precisionStep, bbox.getMinX(), bbox.getMinX(), true, true);
-    Query qMinY = NumericRangeQuery.newDoubleRange(field_minY, precisionStep, bbox.getMinY(), bbox.getMinY(), true, true);
-    Query qMaxX = NumericRangeQuery.newDoubleRange(field_maxX, precisionStep, bbox.getMaxX(), bbox.getMaxX(), true, true);
-    Query qMaxY = NumericRangeQuery.newDoubleRange(field_maxY, precisionStep, bbox.getMaxY(), bbox.getMaxY(), true, true);
-    BooleanQuery bq = new BooleanQuery();
-    bq.add(qMinX, BooleanClause.Occur.MUST);
-    bq.add(qMinY, BooleanClause.Occur.MUST);
-    bq.add(qMaxX, BooleanClause.Occur.MUST);
-    bq.add(qMaxY, BooleanClause.Occur.MUST);
-    return bq;
+    Query qMinX = makeNumberTermQuery(field_minX, bbox.getMinX());
+    Query qMinY = makeNumberTermQuery(field_minY, bbox.getMinY());
+    Query qMaxX = makeNumberTermQuery(field_maxX, bbox.getMaxX());
+    Query qMaxY = makeNumberTermQuery(field_maxY, bbox.getMaxY());
+    return makeQuery(BooleanClause.Occur.MUST, qMinX, qMinY, qMaxX, qMaxY);
   }
 
   /**
@@ -362,12 +387,18 @@
     // to get around it we add all documents as a SHOULD
 
     // there must be an envelope, it must not be disjoint
-    Query qDisjoint = makeDisjoint(bbox);
+    Query qHasEnv;
+    if (ctx.isGeo()) {
-    Query qIsNonXDL = this.makeXDL(false);
+      Query qIsNonXDL = this.makeXDL(false);
-    Query qIsXDL = this.makeXDL(true);
-    Query qHasEnv = this.makeQuery(BooleanClause.Occur.SHOULD, qIsNonXDL, qIsXDL);
+      Query qIsXDL = ctx.isGeo() ? this.makeXDL(true) : null;
+      qHasEnv = this.makeQuery(BooleanClause.Occur.SHOULD, qIsNonXDL, qIsXDL);
+    } else {
+      qHasEnv = this.makeXDL(false);
+    }
+
     BooleanQuery qNotDisjoint = new BooleanQuery();
     qNotDisjoint.add(qHasEnv, BooleanClause.Occur.MUST);
+    Query qDisjoint = makeDisjoint(bbox);
     qNotDisjoint.add(qDisjoint, BooleanClause.Occur.MUST_NOT);
 
     //Query qDisjoint = makeDisjoint();
@@ -387,7 +418,8 @@
   BooleanQuery makeQuery(BooleanClause.Occur occur, Query... queries) {
     BooleanQuery bq = new BooleanQuery();
     for (Query query : queries) {
+      if (query != null)
-      bq.add(query, occur);
+        bq.add(query, occur);
     }
     return bq;
   }
@@ -411,33 +443,31 @@
     // X conditions
     Query xConditions;
 
-    // X Conditions for documents that cross the date line,
-    // the left portion of the document must be within the left portion of the query,
-    // AND the right portion of the document must be within the right portion of the query
-    // docMinXLeft >= queryExtent.getMinX() AND docMaxXLeft <= 180.0
-    // AND docMinXRight >= -180.0 AND docMaxXRight <= queryExtent.getMaxX()
-    Query qXDLLeft = NumericRangeQuery.newDoubleRange(field_minX, precisionStep, bbox.getMinX(), null, true, false);
-    Query qXDLRight = NumericRangeQuery.newDoubleRange(field_maxX, precisionStep, null, bbox.getMaxX(), false, true);
-    Query qXDLLeftRight = this.makeQuery(BooleanClause.Occur.MUST, qXDLLeft, qXDLRight);
-    Query qXDL = this.makeXDL(true, qXDLLeftRight);
+    if (ctx.isGeo() && bbox.getMinX() == -180.0 && bbox.getMaxX() == 180.0) {
+      //if query world-wraps, only the y condition matters
+      return yConditions;
 
+    } else if (!bbox.getCrossesDateLine()) {
-    // queries that do not cross the date line
+      // queries that do not cross the date line
-    if (!bbox.getCrossesDateLine()) {
 
-      // X Conditions for documents that do not cross the date line,
       // docMinX >= queryExtent.getMinX() AND docMaxX <= queryExtent.getMaxX()
       Query qMinX = NumericRangeQuery.newDoubleRange(field_minX, precisionStep, bbox.getMinX(), null, true, false);
       Query qMaxX = NumericRangeQuery.newDoubleRange(field_maxX, precisionStep, null, bbox.getMaxX(), false, true);
       Query qMinMax = this.makeQuery(BooleanClause.Occur.MUST, qMinX, qMaxX);
-      Query qNonXDL = this.makeXDL(false, qMinMax);
 
-      // apply the non-XDL or XDL X conditions
-      if ((bbox.getMinX() <= -180.0) && bbox.getMaxX() >= 180.0) {
-        xConditions = this.makeQuery(BooleanClause.Occur.SHOULD, qNonXDL, qXDL);
-      } else {
-        xConditions = qNonXDL;
+      double edge = 0;//none, otherwise opposite dateline of query
+      if (bbox.getMinX() == -180.0)
+        edge = 180;
+      else if (bbox.getMaxX() == 180.0)
+        edge = -180;
+      if (edge != 0 && ctx.isGeo()) {
+        Query edgeQ = makeQuery(BooleanClause.Occur.MUST,
+            makeNumberTermQuery(field_minX, edge), makeNumberTermQuery(field_maxX, edge));
+        qMinMax = makeQuery(BooleanClause.Occur.SHOULD, qMinMax, edgeQ);
       }
 
+      xConditions = this.makeXDL(false, qMinMax);
+
       // queries that cross the date line
     } else {
 
@@ -460,6 +490,16 @@
       Query qLeftRight = this.makeQuery(BooleanClause.Occur.SHOULD, qLeft, qRight);
       Query qNonXDL = this.makeXDL(false, qLeftRight);
 
+      // X Conditions for documents that cross the date line,
+      // the left portion of the document must be within the left portion of the query,
+      // AND the right portion of the document must be within the right portion of the query
+      // docMinXLeft >= queryExtent.getMinX() AND docMaxXLeft <= 180.0
+      // AND docMinXRight >= -180.0 AND docMaxXRight <= queryExtent.getMaxX()
+      Query qXDLLeft = NumericRangeQuery.newDoubleRange(field_minX, precisionStep, bbox.getMinX(), null, true, false);
+      Query qXDLRight = NumericRangeQuery.newDoubleRange(field_maxX, precisionStep, null, bbox.getMaxX(), false, true);
+      Query qXDLLeftRight = this.makeQuery(BooleanClause.Occur.MUST, qXDLLeft, qXDLRight);
+      Query qXDL = this.makeXDL(true, qXDLLeftRight);
+
       // apply the non-XDL and XDL conditions
       xConditions = this.makeQuery(BooleanClause.Occur.SHOULD, qNonXDL, qXDL);
     }
@@ -471,11 +511,10 @@
   /**
    * Constructs a query to retrieve documents that do or do not cross the date line.
    *
-   *
    * @param crossedDateLine <code>true</true> for documents that cross the date line
    * @return the query
    */
-  Query makeXDL(boolean crossedDateLine) {
+  private Query makeXDL(boolean crossedDateLine) {
     // The 'T' and 'F' values match solr fields
     return new TermQuery(new Term(field_xdl, crossedDateLine ? "T" : "F"));
   }
@@ -488,11 +527,21 @@
    * @param query the spatial query
    * @return the query
    */
-  Query makeXDL(boolean crossedDateLine, Query query) {
+  private Query makeXDL(boolean crossedDateLine, Query query) {
+    if (!ctx.isGeo()) {
+      assert !crossedDateLine;
+      return query;
+    }
     BooleanQuery bq = new BooleanQuery();
     bq.add(this.makeXDL(crossedDateLine), BooleanClause.Occur.MUST);
     bq.add(query, BooleanClause.Occur.MUST);
     return bq;
+  }
+
+  private Query makeNumberTermQuery(String field, double number) {
+    BytesRef bytes = new BytesRef();
+    NumericUtils.longToPrefixCodedBytes(NumericUtils.doubleToSortableLong(number), 0, bytes);
+    return new TermQuery(new Term(field, bytes));
   }
 }
 
