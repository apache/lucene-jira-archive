Index: contrib/analyzers/common/src/test/org/apache/lucene/analysis/reverse/TestReverseStringFilter.java
===================================================================
--- contrib/analyzers/common/src/test/org/apache/lucene/analysis/reverse/TestReverseStringFilter.java	(revision 804461)
+++ contrib/analyzers/common/src/test/org/apache/lucene/analysis/reverse/TestReverseStringFilter.java	(working copy)
@@ -42,6 +42,24 @@
     assertEquals("yad", text.term());
     assertFalse(filter.incrementToken());
   }
+  
+  public void testFilterWithMark() throws Exception {
+    TokenStream stream = new WhitespaceTokenizer(
+            new StringReader("Do have a nice day"));     // 1-4 length string
+        ReverseStringFilter filter = new ReverseStringFilter(stream, true);
+        TermAttribute text = (TermAttribute) filter.getAttribute(TermAttribute.class);
+        assertTrue(filter.incrementToken());
+        assertEquals("\u0001oD", text.term());
+        assertTrue(filter.incrementToken());
+        assertEquals("\u0001evah", text.term());
+        assertTrue(filter.incrementToken());
+        assertEquals("\u0001a", text.term());
+        assertTrue(filter.incrementToken());
+        assertEquals("\u0001ecin", text.term());
+        assertTrue(filter.incrementToken());
+        assertEquals("\u0001yad", text.term());
+        assertFalse(filter.incrementToken());
+  }
 
   public void testReverseString() throws Exception {
     assertEquals( "A", ReverseStringFilter.reverse( "A" ) );
@@ -51,7 +69,13 @@
   
   public void testReverseChar() throws Exception {
     char[] buffer = { 'A', 'B', 'C', 'D', 'E', 'F' };
-    ReverseStringFilter.reverse( buffer, 2, 3 );
+    ReverseStringFilter.reverse( buffer, 2, 3, false );
     assertEquals( "ABEDCF", new String( buffer ) );
   }
+  
+  public void testReverseCharWithMark() throws Exception {
+    char[] buffer = { 'A', 'B', 'C', 'D', 'E', 'F' };
+    ReverseStringFilter.reverse( buffer, 2, 3, true );
+    assertEquals( "AB\u0001EDC", new String( buffer ) );
+  }
 }
Index: contrib/analyzers/common/src/java/org/apache/lucene/analysis/reverse/ReverseStringFilter.java
===================================================================
--- contrib/analyzers/common/src/java/org/apache/lucene/analysis/reverse/ReverseStringFilter.java	(revision 804461)
+++ contrib/analyzers/common/src/java/org/apache/lucene/analysis/reverse/ReverseStringFilter.java	(working copy)
@@ -24,44 +24,65 @@
 import java.io.IOException;
 
 /**
- * Reverse token string e.g. "country" => "yrtnuoc".
+ * Reverse token string e.g. "country" => "yrtnuoc". If
+ * <code>withMark</code> is true, then tokens will be
+ * also prepended by a special marker (Unicode char. 0001),
+ * e.g. "country" => "\u0001yrtnuoc". This is useful when
+ * implementing efficient leading wildcards search.
  *
  * @version $Id$
  */
 public final class ReverseStringFilter extends TokenFilter {
 
   private TermAttribute termAtt;
+  private boolean withMark = false;
+  
+  public ReverseStringFilter(TokenStream in) {
+    this(in, false);
+  }
 
-  public ReverseStringFilter(TokenStream in) {
+  public ReverseStringFilter(TokenStream in, boolean withMark) {
     super(in);
+    this.withMark = withMark;
     termAtt = (TermAttribute) addAttribute(TermAttribute.class);
   }
 
   public boolean incrementToken() throws IOException {
     if (input.incrementToken()) {
-      reverse( termAtt.termBuffer(), termAtt.termLength() );
+      if (withMark) {
+        termAtt.resizeTermBuffer(termAtt.termLength() + 1);
+      }
+      reverse( termAtt.termBuffer(), termAtt.termLength(), withMark);
+      if (withMark) {
+        termAtt.setTermLength(termAtt.termLength() + 1);
+      }
       return true;
     } else {
       return false;
     }
   }
 
-  public static String reverse( final String input ){
+  public static String reverse( final String input ) {
     char[] charInput = input.toCharArray();
-    reverse( charInput );
+    reverse( charInput, false );
     return new String( charInput );
   }
   
-  public static void reverse( char[] buffer ){
-    reverse( buffer, buffer.length );
+  public static void reverse( char[] buffer, boolean withMark ){
+    reverse( buffer, buffer.length, withMark);
   }
   
-  public static void reverse( char[] buffer, int len ){
-    reverse( buffer, 0, len );
+  public static void reverse( char[] buffer, int len, boolean withMark ){
+    reverse( buffer, 0, len, withMark);
   }
   
-  public static void reverse( char[] buffer, int start, int len ){
-    if( len <= 1 ) return;
+  public static void reverse( char[] buffer, int start, int len,
+          boolean withMark ) {
+    if( len <= 1 && !withMark) return;
+    if (withMark) {
+      buffer[start + len] = '\u0001';
+      len++;
+    }
     int num = len>>1;
     for( int i = start; i < ( start + num ); i++ ){
       char c = buffer[i];
