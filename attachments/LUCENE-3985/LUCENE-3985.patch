diff --git a/dev-tools/eclipse/dot.classpath b/dev-tools/eclipse/dot.classpath
index 751c238..2b4b057 100644
--- a/dev-tools/eclipse/dot.classpath
+++ b/dev-tools/eclipse/dot.classpath
@@ -174,6 +174,6 @@
   <classpathentry kind="lib" path="solr/contrib/velocity/lib/commons-beanutils-1.7.0.jar"/>
   <classpathentry kind="lib" path="solr/contrib/velocity/lib/commons-collections-3.2.1.jar"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="lib" path="lucene/test-framework/lib/randomizedtesting-runner-1.6.0.jar"/>
+	<classpathentry kind="lib" path="lucene/test-framework/lib/randomizedtesting-runner-2.0.0.rc2.jar"/>
 	<classpathentry kind="output" path="bin/other"/>
 </classpath>
diff --git a/dev-tools/idea/.idea/libraries/JUnit.xml b/dev-tools/idea/.idea/libraries/JUnit.xml
index b3a42f8..538415e 100644
--- a/dev-tools/idea/.idea/libraries/JUnit.xml
+++ b/dev-tools/idea/.idea/libraries/JUnit.xml
@@ -2,7 +2,7 @@
   <library name="JUnit">
     <CLASSES>
       <root url="jar://$PROJECT_DIR$/lucene/test-framework/lib/junit-4.10.jar!/" />
-      <root url="jar://$PROJECT_DIR$/lucene/test-framework/lib/randomizedtesting-runner-1.6.0.jar!/" />
+      <root url="jar://$PROJECT_DIR$/lucene/test-framework/lib/randomizedtesting-runner-2.0.0.rc2.jar!/" />
     </CLASSES>
     <JAVADOC />
     <SOURCES />
diff --git a/dev-tools/maven/pom.xml.template b/dev-tools/maven/pom.xml.template
index 4d4f233..852289a 100644
--- a/dev-tools/maven/pom.xml.template
+++ b/dev-tools/maven/pom.xml.template
@@ -388,7 +388,7 @@
       <dependency>
         <groupId>com.carrotsearch.randomizedtesting</groupId>
         <artifactId>randomizedtesting-runner</artifactId>
-        <version>1.6.0</version>
+        <version>2.0.0.rc2</version>
       </dependency>
     </dependencies>
   </dependencyManagement>
diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index 663fffd..2959ab3 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -6,7 +6,6 @@ http://s.apache.org/luceneversions
 
 ======================= Lucene 5.0.0 =======================
 
-
 ======================= Lucene 4.0.0-BETA =======================
 
 New features
@@ -148,6 +147,10 @@ Changes in Runtime Behavior
 
 Build
 
+* LUCENE-3985: Upgrade to randomizedtesting 2.0.0.rc2. Added support for 
+  thread leak detection (enabled by default!). Added support for suite
+  timeouts (10 minutes per entire class by default). (Dawid Weiss)
+
 * LUCENE-4094: Support overriding file.encoding on forked test JVMs
   (force via -Drandomized.file.encoding=XXX). (Dawid Weiss)
 
diff --git a/lucene/build.xml b/lucene/build.xml
index 81e6bde..568b416 100644
--- a/lucene/build.xml
+++ b/lucene/build.xml
@@ -177,6 +177,7 @@
       <apiFileSet dir="${custom-tasks.dir}/forbiddenApis">
         <include name="jdk.txt" />
         <include name="jdk-deprecated.txt" />
+        <include name="executors.txt" />
       </apiFileSet>
       <fileset dir="${basedir}/build" includes="**/*.class" />
     </forbidden-apis>
diff --git a/lucene/common-build.xml b/lucene/common-build.xml
index 4493b7f..0e71656 100644
--- a/lucene/common-build.xml
+++ b/lucene/common-build.xml
@@ -88,7 +88,7 @@
   <property name="tests.timezone" value="random" />
   <property name="tests.directory" value="random" />
   <property name="tests.linedocsfile" value="europarl.lines.txt.gz" />
-  <property name="tests.loggingfile" value="/dev/null"/>
+  <property name="tests.loggingfile" value="${common.dir}/tools/junit4/logging.properties"/>
   <property name="tests.nightly" value="false" />
   <property name="tests.weekly" value="false" />
   <property name="tests.slow" value="true" />
@@ -854,6 +854,7 @@
             <syspropertyset>
                 <propertyref prefix="tests.maxfailures" />
                 <propertyref prefix="tests.failfast" />
+                <propertyref prefix="tests.badapples" />
             </syspropertyset>
 
             <!-- Pass randomized settings to the forked JVM. -->
diff --git a/lucene/core/src/test/org/apache/lucene/TestWorstCaseTestBehavior.java b/lucene/core/src/test/org/apache/lucene/TestWorstCaseTestBehavior.java
new file mode 100644
index 0000000..c86f813
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/TestWorstCaseTestBehavior.java
@@ -0,0 +1,74 @@
+package org.apache.lucene;
+
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Ignore;
+
+import com.carrotsearch.randomizedtesting.annotations.Timeout;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class TestWorstCaseTestBehavior extends LuceneTestCase {
+  @Ignore
+  public void testThreadLeak() {
+    Thread t = new Thread() {
+      @Override
+      public void run() {
+        try {
+          Thread.sleep(10000);
+        } catch (InterruptedException e) {
+          // Ignore.
+        }
+      }
+    };
+    t.start();
+
+    while (!t.isAlive()) {
+      Thread.yield();
+    }
+
+    // once alive, leave it to run outside of the test scope.
+  }
+
+  @Ignore
+  public void testUncaughtException() throws Exception {
+    Thread t = new Thread() {
+      @Override
+      public void run() {
+        throw new RuntimeException("foobar");
+      }
+    };
+    t.start();
+    t.join();
+  }
+  
+  @Ignore
+  @Timeout(millis = 500)
+  public void testTimeout() throws Exception {
+    Thread.sleep(5000);
+  }
+  
+  @Ignore
+  @Timeout(millis = 1000)
+  public void testZombie() throws Exception {
+    while (true) {
+      try {
+        Thread.sleep(1000);
+      } catch (InterruptedException e) {}
+    }
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.java b/lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.java
index e24ba4b..135fea4 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestDocumentsWriterStallControl.java
@@ -27,12 +27,9 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.ThreadInterruptedException;
 
-import com.carrotsearch.randomizedtesting.annotations.ThreadLeaks;
-
 /**
  * Tests for {@link DocumentsWriterStallControl}
  */
-@ThreadLeaks(failTestIfLeaking = true)
 public class TestDocumentsWriterStallControl extends LuceneTestCase {
   
   public void testSimpleStall() throws InterruptedException {
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSort.java b/lucene/core/src/test/org/apache/lucene/search/TestSort.java
index cd4d901..45cb670 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSort.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSort.java
@@ -59,6 +59,7 @@ import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.DocIdBitSet;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.NamedThreadFactory;
 import org.apache.lucene.util._TestUtil;
 import org.junit.BeforeClass;
 
@@ -810,7 +811,7 @@ public class TestSort extends LuceneTestCase {
     assertMatches (full, queryG, sort, "ZYXW");
 
     // Do the same for a ParallelMultiSearcher
-    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8));
+    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8), new NamedThreadFactory("testEmptyFieldSort"));
     IndexSearcher parallelSearcher=new IndexSearcher (full.getIndexReader(), exec);
 
     sort.setSort (new SortField ("int", SortField.Type.INT),
@@ -852,7 +853,7 @@ public class TestSort extends LuceneTestCase {
 
   // test a variety of sorts using a parallel multisearcher
   public void testParallelMultiSort() throws Exception {
-    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8));
+    ExecutorService exec = Executors.newFixedThreadPool(_TestUtil.nextInt(random(), 2, 8), new NamedThreadFactory("testParallelMultiSort"));
     IndexSearcher searcher = new IndexSearcher(
                                   new MultiReader(searchX.getIndexReader(),
                                                   searchY.getIndexReader()), exec);
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap.java b/lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap.java
index 37cc86c..b5e36e9 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestWeakIdentityMap.java
@@ -159,7 +159,7 @@ public class TestWeakIdentityMap extends LuceneTestCase {
   public void testConcurrentHashMap() throws Exception {
     // don't make threadCount and keyCount random, otherwise easily OOMs or fails otherwise:
     final int threadCount = 8, keyCount = 1024;
-    final ExecutorService exec = Executors.newFixedThreadPool(threadCount);
+    final ExecutorService exec = Executors.newFixedThreadPool(threadCount, new NamedThreadFactory("testConcurrentHashMap"));
     final WeakIdentityMap<Object,Integer> map =
       WeakIdentityMap.newConcurrentHashMap();
     // we keep strong references to the keys,
diff --git a/lucene/ivy-settings.xml b/lucene/ivy-settings.xml
index 97376ff..c09a0f0 100644
--- a/lucene/ivy-settings.xml
+++ b/lucene/ivy-settings.xml
@@ -19,6 +19,8 @@
 <ivysettings>
   <settings defaultResolver="default"/>
 
+  <property name="local-maven2-dir" value="${user.home}/.m2/repository/" />
+  
   <include url="${ivy.default.settings.dir}/ivysettings-public.xml"/>
   <include url="${ivy.default.settings.dir}/ivysettings-shared.xml"/>
   <include url="${ivy.default.settings.dir}/ivysettings-local.xml"/>
@@ -26,11 +28,22 @@
 
   <resolvers>
     <ibiblio name="sonatype-releases" root="http://oss.sonatype.org/content/repositories/releases" m2compatible="true" />
+
     <!-- you might need to tweak this from china so it works -->
     <ibiblio name="working-chinese-mirror" root="http://mirror.netcologne.de/maven2" m2compatible="true" />
 
+    <!--
+    <filesystem name="local-maven-2" m2compatible="true" local="true">
+      <artifact
+          pattern="${local-maven2-dir}/[organisation]/[module]/[revision]/[module]-[revision].[ext]" />
+      <ivy
+          pattern="${local-maven2-dir}/[organisation]/[module]/[revision]/[module]-[revision].pom" />
+    </filesystem>
+    -->
+
     <chain name="default" returnFirst="true" checkmodified="true" changingPattern=".*SNAPSHOT">
       <resolver ref="local"/>
+      <!-- <resolver ref="local-maven-2" /> -->
       <resolver ref="main"/>
       <resolver ref="sonatype-releases" />
       <resolver ref="working-chinese-mirror" />
diff --git a/lucene/licenses/junit4-ant-1.6.0.jar.sha1 b/lucene/licenses/junit4-ant-1.6.0.jar.sha1
deleted file mode 100644
index 9a2ca80..0000000
--- a/lucene/licenses/junit4-ant-1.6.0.jar.sha1
+++ /dev/null
@@ -1 +0,0 @@
-c7a65e96a2c62ba83ca404065305aec5dc7fc8f1
diff --git a/lucene/licenses/junit4-ant-2.0.0.rc2.jar.sha1 b/lucene/licenses/junit4-ant-2.0.0.rc2.jar.sha1
new file mode 100644
index 0000000..633578f
--- /dev/null
+++ b/lucene/licenses/junit4-ant-2.0.0.rc2.jar.sha1
@@ -0,0 +1 @@
+0a5c2f97ad8a5dc45d29166763c9cd625fafc82a
\ No newline at end of file
diff --git a/lucene/licenses/randomizedtesting-runner-1.6.0.jar.sha1 b/lucene/licenses/randomizedtesting-runner-1.6.0.jar.sha1
deleted file mode 100644
index be7ad32..0000000
--- a/lucene/licenses/randomizedtesting-runner-1.6.0.jar.sha1
+++ /dev/null
@@ -1 +0,0 @@
-709f9549a0b0c2e2ecdd5af012d9531325d6551b
diff --git a/lucene/licenses/randomizedtesting-runner-2.0.0.rc2.jar.sha1 b/lucene/licenses/randomizedtesting-runner-2.0.0.rc2.jar.sha1
new file mode 100644
index 0000000..8175fac
--- /dev/null
+++ b/lucene/licenses/randomizedtesting-runner-2.0.0.rc2.jar.sha1
@@ -0,0 +1 @@
+5a538d45ced928566385e8297d0a815f20771b97
\ No newline at end of file
diff --git a/lucene/module-build.xml b/lucene/module-build.xml
index 771016a..87baa3d 100644
--- a/lucene/module-build.xml
+++ b/lucene/module-build.xml
@@ -49,8 +49,8 @@
   <path id="test.classpath" refid="test.base.classpath"/>
 
   <path id="junit.classpath">
-    <path refid="test.classpath"/>
     <pathelement location="${build.dir}/classes/test"/>
+    <path refid="test.classpath"/>
     <pathelement path="${java.class.path}"/>
   </path>
 
diff --git a/lucene/suggest/src/test/org/apache/lucene/search/spell/TestSpellChecker.java b/lucene/suggest/src/test/org/apache/lucene/search/spell/TestSpellChecker.java
index ab7e455..8504b99 100755
--- a/lucene/suggest/src/test/org/apache/lucene/search/spell/TestSpellChecker.java
+++ b/lucene/suggest/src/test/org/apache/lucene/search/spell/TestSpellChecker.java
@@ -39,6 +39,7 @@ import org.apache.lucene.store.AlreadyClosedException;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.English;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.NamedThreadFactory;
 
 /**
  * Spell checker test case
@@ -413,7 +414,7 @@ public class TestSpellChecker extends LuceneTestCase {
     int num_field2 = this.numdoc();
     assertEquals(num_field2, num_field1 + 1);
     int numThreads = 5 + random().nextInt(5);
-    ExecutorService executor = Executors.newFixedThreadPool(numThreads);
+    ExecutorService executor = Executors.newFixedThreadPool(numThreads, new NamedThreadFactory("testConcurrentAccess"));
     SpellCheckWorker[] workers = new SpellCheckWorker[numThreads];
     for (int i = 0; i < numThreads; i++) {
       SpellCheckWorker spellCheckWorker = new SpellCheckWorker(r);
diff --git a/lucene/test-framework/ivy.xml b/lucene/test-framework/ivy.xml
index 4e39a2b..4619a39 100644
--- a/lucene/test-framework/ivy.xml
+++ b/lucene/test-framework/ivy.xml
@@ -33,8 +33,8 @@
       <dependency org="org.apache.ant" name="ant-junit" rev="1.8.2" transitive="false" />
 
       <dependency org="junit" name="junit" rev="4.10" transitive="false" conf="default->*;junit4-stdalone->*" />
-            <dependency org="com.carrotsearch.randomizedtesting" name="junit4-ant" rev="1.6.0" transitive="false" conf="default->*;junit4-stdalone->*" />
-      <dependency org="com.carrotsearch.randomizedtesting" name="randomizedtesting-runner" rev="1.6.0" transitive="false" conf="default->*;junit4-stdalone->*" />
+      <dependency org="com.carrotsearch.randomizedtesting" name="junit4-ant" rev="2.0.0.rc2" transitive="false" conf="default->*;junit4-stdalone->*" />
+      <dependency org="com.carrotsearch.randomizedtesting" name="randomizedtesting-runner" rev="2.0.0.rc2" transitive="false" conf="default->*;junit4-stdalone->*" />
 
       <exclude org="*" ext="*" matcher="regexp" type="${ivy.exclude.types}"/> 
     </dependencies>
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
index 11c7bd6..ba07753 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
@@ -45,6 +45,10 @@ import org.junit.rules.TestRule;
 import org.junit.runner.RunWith;
 import com.carrotsearch.randomizedtesting.*;
 import com.carrotsearch.randomizedtesting.annotations.*;
+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakAction.Action;
+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakGroup.Group;
+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakScope.Scope;
+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakZombies.Consequence;
 import com.carrotsearch.randomizedtesting.generators.RandomPicks;
 import com.carrotsearch.randomizedtesting.rules.SystemPropertiesInvariantRule;
 
@@ -113,7 +117,12 @@ import static com.carrotsearch.randomizedtesting.RandomizedTest.systemPropertyAs
   RunListenerPrintReproduceInfo.class
 })
 @SeedDecorators({MixWithSuiteName.class}) // See LUCENE-3995 for rationale.
-@ThreadLeaks(failTestIfLeaking = false)
+@ThreadLeakScope(Scope.SUITE)
+@ThreadLeakGroup(Group.MAIN)
+@ThreadLeakAction({Action.WARN, Action.INTERRUPT})
+@ThreadLeakLingering(linger = 20000) // Wait long for leaked threads to complete before failure. zk needs this.
+@ThreadLeakZombies(Consequence.IGNORE_REMAINING_TESTS)
+@TimeoutSuite(millis = 10 * (/* minutes */ 1000 * 60)) // max suite execution time.
 public abstract class LuceneTestCase extends Assert {
 
   // --------------------------------------------------------------------
@@ -124,6 +133,7 @@ public abstract class LuceneTestCase extends Assert {
   public static final String SYSPROP_WEEKLY = "tests.weekly";
   public static final String SYSPROP_AWAITSFIX = "tests.awaitsfix";
   public static final String SYSPROP_SLOW = "tests.slow";
+  public static final String SYSPROP_BADAPPLES = "tests.badapples";
 
   /** @see #ignoreAfterMaxFailures*/
   private static final String SYSPROP_MAXFAILURES = "tests.maxfailures";
@@ -170,7 +180,21 @@ public abstract class LuceneTestCase extends Assert {
   @Retention(RetentionPolicy.RUNTIME)
   @TestGroup(enabled = true, sysProperty = SYSPROP_SLOW)
   public @interface Slow {}
-  
+
+  /**
+   * Annotation for tests that fail frequently. You can disable them
+   * if you want to run a long build and not stop on something that
+   * is a known problem.
+   * <pre>
+   * -Dtests.badapples=false
+   * </pre>
+   */
+  @Documented
+  @Inherited
+  @Retention(RetentionPolicy.RUNTIME)
+  @TestGroup(enabled = true, sysProperty = SYSPROP_BADAPPLES)
+  public @interface BadApple {}
+
   /**
    * Annotation for test classes that should avoid certain codec types
    * (because they are expensive, for example).
@@ -353,7 +377,6 @@ public abstract class LuceneTestCase extends Assert {
     .around(new TestRuleNoInstanceHooksOverrides())
     .around(new SystemPropertiesInvariantRule(IGNORED_INVARIANT_PROPERTIES))
     .around(classNameRule = new TestRuleStoreClassName())
-    .around(new TestRuleReportUncaughtExceptions())
     .around(classEnvRule = new TestRuleSetupAndRestoreClassEnv());
 
 
@@ -380,7 +403,6 @@ public abstract class LuceneTestCase extends Assert {
     .outerRule(testFailureMarker)
     .around(ignoreAfterMaxFailures)
     .around(threadAndTestNameRule)
-    .around(new TestRuleReportUncaughtExceptions())
     .around(new SystemPropertiesInvariantRule(IGNORED_INVARIANT_PROPERTIES))
     .around(new TestRuleSetupAndRestoreInstanceEnv())
     .around(new TestRuleFieldCacheSanity())
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleReportUncaughtExceptions.java b/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleReportUncaughtExceptions.java
deleted file mode 100644
index fa75b7c..0000000
--- a/lucene/test-framework/src/java/org/apache/lucene/util/TestRuleReportUncaughtExceptions.java
+++ /dev/null
@@ -1,132 +0,0 @@
-package org.apache.lucene.util;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.lang.Thread.UncaughtExceptionHandler;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.junit.rules.TestRule;
-import org.junit.runner.Description;
-import org.junit.runners.model.MultipleFailureException;
-import org.junit.runners.model.Statement;
-
-/**
- * Subscribes to
- * {@link Thread#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)}
- * and causes test/ suite failures if uncaught exceptions are detected.
- */
-public class TestRuleReportUncaughtExceptions implements TestRule {
-  // This was originally volatile, but I don't think it needs to be. It's the same
-  // thread accessing it, always.
-  private UncaughtExceptionHandler savedUncaughtExceptionHandler;
-  
-  public static class UncaughtExceptionEntry {
-    public final Thread thread;
-    public final Throwable exception;
-
-    public UncaughtExceptionEntry(Thread thread, Throwable exception) {
-      this.thread = thread;
-      this.exception = exception;
-    }
-  }
-
-  @SuppressWarnings("serial")
-  private static class UncaughtExceptionsInBackgroundThread extends RuntimeException {
-    public UncaughtExceptionsInBackgroundThread(UncaughtExceptionEntry e) {
-      super("Uncaught exception by thread: " + e.thread, e.exception);
-    }
-  }
-
-  // Lock on uncaughtExceptions to access.
-  private final List<UncaughtExceptionEntry> uncaughtExceptions = new ArrayList<UncaughtExceptionEntry>();
-
-  @Override
-  public Statement apply(final Statement s, final Description d) {
-    return new Statement() {
-      public void evaluate() throws Throwable {
-        final ArrayList<Throwable> errors = new ArrayList<Throwable>();
-        try {
-          setupHandler();
-          s.evaluate();
-        } catch (Throwable t) {
-          errors.add(t);
-        } finally {
-          restoreHandler();
-        }
-
-        synchronized (uncaughtExceptions) {
-          for (UncaughtExceptionEntry e : uncaughtExceptions) {
-            errors.add(new UncaughtExceptionsInBackgroundThread(e));
-          }
-          uncaughtExceptions.clear();
-        }
-
-        MultipleFailureException.assertEmpty(errors);
-      }
-    };
-  }
-
-  /**
-   * Just a check if anything's been caught.
-   */
-  public boolean hasUncaughtExceptions() {
-    synchronized (uncaughtExceptions) {
-      return !uncaughtExceptions.isEmpty();
-    }
-  }
-  
-  private void restoreHandler() {
-    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);    
-  }
-
-  private void setupHandler() {
-    savedUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
-    Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
-      public void uncaughtException(Thread t, Throwable e) {
-        // org.junit.internal.AssumptionViolatedException in older releases
-        // org.junit.Assume.AssumptionViolatedException in recent ones
-        if (e.getClass().getName().endsWith("AssumptionViolatedException")) {
-          String where = "<unknown>";
-          for (StackTraceElement elem : e.getStackTrace()) {
-            if (!elem.getClassName().startsWith("org.junit")) {
-              where = elem.toString();
-              break;
-            }
-          }
-          System.err.print("NOTE: Uncaught exception handler caught a failed assumption at " 
-              + where + " (ignored):");
-        } else {
-          synchronized (uncaughtExceptions) {
-            uncaughtExceptions.add(new UncaughtExceptionEntry(t, e));
-          }
-
-          StringWriter sw = new StringWriter();
-          sw.write("\n===>\nUncaught exception by thread: " + t + "\n");
-          PrintWriter pw = new PrintWriter(sw);
-          e.printStackTrace(pw);
-          pw.flush();
-          sw.write("<===\n");
-          System.err.println(sw.toString());
-        }
-      }
-    });
-  }  
-}
diff --git a/lucene/tools/custom-tasks.xml b/lucene/tools/custom-tasks.xml
index 959c952..1b409e8 100644
--- a/lucene/tools/custom-tasks.xml
+++ b/lucene/tools/custom-tasks.xml
@@ -51,8 +51,9 @@
             <additional-filters />
 
             <!-- Typical version patterns. -->
+            <replaceregex pattern="\.rc[0-9]+" replace="" flags="gi" />
             <replaceregex pattern="\-(r)?([0-9\-\_\.])+(b(eta)?([0-9\-\.])*)?$" replace="" flags="gi" />
-    
+
             <!-- git hashcode pattern: its always 40 chars right? -->
             <replaceregex pattern="\-[a-z0-9]{40,40}$" replace="" flags="gi" />
           </filtermapper>
diff --git a/lucene/tools/forbiddenApis/executors.txt b/lucene/tools/forbiddenApis/executors.txt
new file mode 100644
index 0000000..dfb9df5
--- /dev/null
+++ b/lucene/tools/forbiddenApis/executors.txt
@@ -0,0 +1,12 @@
+# These methods spawn threads with vague names. Use a custom thread factory and name
+# threads so that you can tell (by its name) which executor it is associated with.
+# see Solr's DefaultSolrThreadFactory
+# see Lucene's NamedThreadFactory
+
+java.util.concurrent.Executors#newFixedThreadPool(int)
+java.util.concurrent.Executors#newSingleThreadExecutor()
+java.util.concurrent.Executors#newCachedThreadPool()
+java.util.concurrent.Executors#newSingleThreadScheduledExecutor()
+java.util.concurrent.Executors#newScheduledThreadPool(int)
+java.util.concurrent.Executors#defaultThreadFactory()
+java.util.concurrent.Executors#privilegedThreadFactory()
diff --git a/lucene/tools/junit4/logging.properties b/lucene/tools/junit4/logging.properties
new file mode 100644
index 0000000..f54ee74
--- /dev/null
+++ b/lucene/tools/junit4/logging.properties
@@ -0,0 +1,10 @@
+
+# root handler
+handlers=java.util.logging.ConsoleHandler
+
+# root logger's cutoff threshold.
+.level=INFO
+
+# configure console handler to emit everything in the default format.
+java.util.logging.ConsoleHandler.level=FINEST
+java.util.logging.ConsoleHandler.formatter=java.util.logging.SimpleFormatter
diff --git a/solr/build.xml b/solr/build.xml
index 127af81..0cbf1fc 100644
--- a/solr/build.xml
+++ b/solr/build.xml
@@ -200,6 +200,7 @@
         <include name="jdk.txt" />
         <include name="jdk-deprecated.txt" />
         <include name="commons-io.txt" />
+        <include name="executors.txt" />
       </apiFileSet>
       <fileset dir="${basedir}/build">
         <include name="**/*.class" />
diff --git a/solr/core/src/java/org/apache/solr/cloud/Overseer.java b/solr/core/src/java/org/apache/solr/cloud/Overseer.java
index 7218b67..0b5953f 100644
--- a/solr/core/src/java/org/apache/solr/cloud/Overseer.java
+++ b/solr/core/src/java/org/apache/solr/cloud/Overseer.java
@@ -410,9 +410,10 @@ public class Overseer {
     Thread updaterThread = new Thread(tg, new CloudStateUpdater(reader, id));
     updaterThread.setDaemon(true);
     updaterThread.start();
-    
+
     ThreadGroup ccTg = new ThreadGroup("Overseer collection creation process.");
-    Thread ccThread = new Thread(ccTg, new OverseerCollectionProcessor(reader, id, shardHandler, adminPath));
+    Thread ccThread = new Thread(ccTg, new OverseerCollectionProcessor(reader, id, shardHandler, adminPath), 
+        "Overseer-" + id);
     ccThread.setDaemon(true);
     ccThread.start();
   }
diff --git a/solr/core/src/java/org/apache/solr/core/SolrCore.java b/solr/core/src/java/org/apache/solr/core/SolrCore.java
index f7888ff..b58546f 100644
--- a/solr/core/src/java/org/apache/solr/core/SolrCore.java
+++ b/solr/core/src/java/org/apache/solr/core/SolrCore.java
@@ -70,6 +70,7 @@ import org.apache.solr.update.processor.LogUpdateProcessorFactory;
 import org.apache.solr.update.processor.RunUpdateProcessorFactory;
 import org.apache.solr.update.processor.UpdateRequestProcessorChain;
 import org.apache.solr.update.processor.UpdateRequestProcessorFactory;
+import org.apache.solr.util.DefaultSolrThreadFactory;
 import org.apache.solr.util.RefCounted;
 import org.apache.solr.util.plugin.NamedListInitializedPlugin;
 import org.apache.solr.util.plugin.PluginInfoInitialized;
@@ -1070,7 +1071,8 @@ public final class SolrCore implements SolrInfoMBean {
   private final LinkedList<RefCounted<SolrIndexSearcher>> _searchers = new LinkedList<RefCounted<SolrIndexSearcher>>();
   private final LinkedList<RefCounted<SolrIndexSearcher>> _realtimeSearchers = new LinkedList<RefCounted<SolrIndexSearcher>>();
 
-  final ExecutorService searcherExecutor = Executors.newSingleThreadExecutor();
+  final ExecutorService searcherExecutor = Executors.newSingleThreadExecutor(
+      new DefaultSolrThreadFactory("searcherExecutor"));
   private int onDeckSearchers;  // number of searchers preparing
   // Lock ordering: one can acquire the openSearcherLock and then the searcherLock, but not vice-versa.
   private Object searcherLock = new Object();  // the sync object for the searcher
diff --git a/solr/core/src/java/org/apache/solr/handler/SnapPuller.java b/solr/core/src/java/org/apache/solr/handler/SnapPuller.java
index ce3c0f4..f616096 100644
--- a/solr/core/src/java/org/apache/solr/handler/SnapPuller.java
+++ b/solr/core/src/java/org/apache/solr/handler/SnapPuller.java
@@ -31,6 +31,7 @@ import org.apache.solr.common.params.CommonParams;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.FastInputStream;
+import org.apache.solr.util.DefaultSolrThreadFactory;
 import org.apache.solr.util.FileUtils;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.core.CachingDirectoryFactory.CloseListener;
@@ -178,7 +179,8 @@ public class SnapPuller {
         }
       }
     };
-    executorService = Executors.newSingleThreadScheduledExecutor();
+    executorService = Executors.newSingleThreadScheduledExecutor(
+        new DefaultSolrThreadFactory("snapPuller"));
     long initialDelay = pollInterval - (System.currentTimeMillis() % pollInterval);
     executorService.scheduleAtFixedRate(task, initialDelay, pollInterval, TimeUnit.MILLISECONDS);
     LOG.info("Poll Scheduled at an interval of " + pollInterval + "ms");
@@ -311,7 +313,7 @@ public class SnapPuller {
       LOG.info("Number of files in latest index in master: " + filesToDownload.size());
 
       // Create the sync service
-      fsyncService = Executors.newSingleThreadExecutor();
+      fsyncService = Executors.newSingleThreadExecutor(new DefaultSolrThreadFactory("fsyncService"));
       // use a synchronized list because the list is read by other threads (to show details)
       filesDownloaded = Collections.synchronizedList(new ArrayList<Map<String, Object>>());
       // if the generateion of master is older than that of the slave , it means they are not compatible to be copied
diff --git a/solr/core/src/java/org/apache/solr/request/SimpleFacets.java b/solr/core/src/java/org/apache/solr/request/SimpleFacets.java
index 800c720..c2b1307 100644
--- a/solr/core/src/java/org/apache/solr/request/SimpleFacets.java
+++ b/solr/core/src/java/org/apache/solr/request/SimpleFacets.java
@@ -397,7 +397,7 @@ public class SimpleFacets {
           Integer.MAX_VALUE,
           10, TimeUnit.SECONDS, // terminate idle threads after 10 sec
           new SynchronousQueue<Runnable>()  // directly hand off tasks
-          , new DefaultSolrThreadFactory("facetExectutor")
+          , new DefaultSolrThreadFactory("facetExecutor")
   );
   
   /**
diff --git a/solr/core/src/java/org/apache/solr/update/CommitTracker.java b/solr/core/src/java/org/apache/solr/update/CommitTracker.java
index 375d2e5..915636e 100644
--- a/solr/core/src/java/org/apache/solr/update/CommitTracker.java
+++ b/solr/core/src/java/org/apache/solr/update/CommitTracker.java
@@ -29,6 +29,7 @@ import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.LocalSolrQueryRequest;
 import org.apache.solr.request.SolrQueryRequest;
+import org.apache.solr.util.DefaultSolrThreadFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -52,8 +53,8 @@ public final class CommitTracker implements Runnable {
   private int docsUpperBound;
   private long timeUpperBound;
   
-  private final ScheduledExecutorService scheduler = Executors
-      .newScheduledThreadPool(1);
+  private final ScheduledExecutorService scheduler = 
+      Executors.newScheduledThreadPool(1, new DefaultSolrThreadFactory("commitScheduler"));
   private ScheduledFuture pending;
   
   // state
diff --git a/solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest.java b/solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest.java
index 23b82b1..8104e1b 100644
--- a/solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/FullSolrCloudTest.java
@@ -31,6 +31,7 @@ import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.http.params.CoreConnectionPNames;
+import org.apache.lucene.util.LuceneTestCase.BadApple;
 import org.apache.lucene.util.LuceneTestCase.Slow;
 import org.apache.solr.client.solrj.SolrQuery;
 import org.apache.solr.client.solrj.SolrServer;
@@ -60,12 +61,11 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * 
  * TODO: we should still test this works as a custom update chain as well as
  * what we test now - the default update chain
- * 
  */
 @Slow
+@BadApple
 public class FullSolrCloudTest extends AbstractDistributedZkTestCase {
   static Logger log = LoggerFactory.getLogger(FullSolrCloudTest.class);
   
diff --git a/solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest.java b/solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest.java
index 246a0f2..3858115 100644
--- a/solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest.java
@@ -35,10 +35,12 @@ import org.apache.solr.common.cloud.SolrZkClient;
 import org.apache.solr.common.cloud.ZkCoreNodeProps;
 import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
+import org.apache.solr.util.DefaultSolrThreadFactory;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.KeeperException.NoNodeException;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
+import org.junit.Ignore;
 import org.junit.Test;
 
 @Slow
@@ -315,7 +317,7 @@ public class LeaderElectionTest extends SolrTestCaseJ4 {
   @Test
   public void testStressElection() throws Exception {
     final ScheduledExecutorService scheduler = Executors
-        .newScheduledThreadPool(15);
+        .newScheduledThreadPool(15, new DefaultSolrThreadFactory("stressElection"));
     final List<ClientThread> threads = Collections
         .synchronizedList(new ArrayList<ClientThread>());
     
@@ -369,9 +371,7 @@ public class LeaderElectionTest extends SolrTestCaseJ4 {
             }
 
             Thread.sleep(10);
-            
           } catch (Exception e) {
-
           }
         }
       }
@@ -382,7 +382,6 @@ public class LeaderElectionTest extends SolrTestCaseJ4 {
       public void run() {
         
         while (!stopStress) {
-
           try {
             Thread.sleep(50);
             int j;
@@ -426,6 +425,7 @@ public class LeaderElectionTest extends SolrTestCaseJ4 {
     
     // cleanup any threads still running
     for (ClientThread thread : threads) {
+      thread.zkClient.getSolrZooKeeper().close();
       thread.close();
     }
     
diff --git a/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java b/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java
index 2b460f7..cf0eb13 100644
--- a/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/OverseerTest.java
@@ -43,6 +43,7 @@ import org.apache.solr.common.cloud.ZkNodeProps;
 import org.apache.solr.common.cloud.ZkStateReader;
 import org.apache.solr.core.CoreDescriptor;
 import org.apache.solr.handler.component.HttpShardHandlerFactory;
+import org.apache.solr.util.DefaultSolrThreadFactory;
 import org.apache.zookeeper.CreateMode;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.KeeperException.NodeExistsException;
@@ -298,7 +299,7 @@ public class OverseerTest extends SolrTestCaseJ4 {
 
       
       for (int i = 0; i < nodeCount; i++) {
-        nodeExecutors[i] = Executors.newFixedThreadPool(1);
+        nodeExecutors[i] = Executors.newFixedThreadPool(1, new DefaultSolrThreadFactory("testShardAssignment"));
       }
       
       final String[] ids = new String[coreCount];
diff --git a/solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest.java b/solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest.java
index dcb90ed..1c46b8f 100644
--- a/solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest.java
+++ b/solr/core/src/test/org/apache/solr/cloud/RecoveryZkTest.java
@@ -19,34 +19,25 @@ package org.apache.solr.cloud;
 
 import java.io.IOException;
 
+import org.apache.lucene.util.LuceneTestCase.BadApple;
 import org.apache.lucene.util.LuceneTestCase.Slow;
 import org.apache.solr.client.solrj.SolrQuery;
 import org.apache.solr.client.solrj.SolrServerException;
 import org.apache.solr.client.solrj.embedded.JettySolrRunner;
 import org.apache.solr.common.SolrInputDocument;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
 import org.junit.Ignore;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 @Slow
+@BadApple
 public class RecoveryZkTest extends FullSolrCloudTest {
 
   //private static final String DISTRIB_UPDATE_CHAIN = "distrib-update-chain";
   private static Logger log = LoggerFactory.getLogger(RecoveryZkTest.class);
   private StopableIndexingThread indexThread;
   private StopableIndexingThread indexThread2;
-  @BeforeClass
-  public static void beforeSuperClass() {
 
-  }
-  
-  @AfterClass
-  public static void afterSuperClass() {
-
-  }
-  
   public RecoveryZkTest() {
     super();
     sliceCount = 1;
diff --git a/solr/core/src/test/org/apache/solr/cloud/TestMultiCoreConfBootstrap.java b/solr/core/src/test/org/apache/solr/cloud/TestMultiCoreConfBootstrap.java
index 56292ff..8effb26 100644
--- a/solr/core/src/test/org/apache/solr/cloud/TestMultiCoreConfBootstrap.java
+++ b/solr/core/src/test/org/apache/solr/cloud/TestMultiCoreConfBootstrap.java
@@ -37,7 +37,6 @@ public class TestMultiCoreConfBootstrap extends SolrTestCaseJ4 {
   protected CoreContainer cores = null;
   private String home;
 
-
   protected static ZkTestServer zkServer;
   protected static String zkDir;
   
@@ -101,7 +100,6 @@ public class TestMultiCoreConfBootstrap extends SolrTestCaseJ4 {
     super.tearDown();
   }
 
-
   @Test
   public void testMultiCoreConfBootstrap() throws Exception {
     System.setProperty("bootstrap_conf", "true");
@@ -113,6 +111,7 @@ public class TestMultiCoreConfBootstrap extends SolrTestCaseJ4 {
     assertTrue(zkclient.exists("/configs/core1/schema.xml", true));
     assertTrue(zkclient.exists("/configs/core0/solrconfig.xml", true));
     assertTrue(zkclient.exists("/configs/core1/schema.xml", true));
+    
+    zkclient.close();
   }
-
 }
diff --git a/solr/core/src/test/org/apache/solr/core/SolrCoreTest.java b/solr/core/src/test/org/apache/solr/core/SolrCoreTest.java
index 43bc6ec..8930fd0 100755
--- a/solr/core/src/test/org/apache/solr/core/SolrCoreTest.java
+++ b/solr/core/src/test/org/apache/solr/core/SolrCoreTest.java
@@ -25,6 +25,7 @@ import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrRequestHandler;
 import org.apache.solr.response.SolrQueryResponse;
 import org.apache.solr.schema.IndexSchema;
+import org.apache.solr.util.DefaultSolrThreadFactory;
 import org.apache.solr.util.plugin.SolrCoreAware;
 import org.junit.Test;
 
@@ -163,7 +164,7 @@ public class SolrCoreTest extends SolrTestCaseJ4 {
 
     final int LOOP = 100;
     final int MT = 16;
-    ExecutorService service = Executors.newFixedThreadPool(MT);
+    ExecutorService service = Executors.newFixedThreadPool(MT, new DefaultSolrThreadFactory("refCountMT"));
     List<Callable<Integer>> callees = new ArrayList<Callable<Integer>>(MT);
     final CoreContainer cores = h.getCoreContainer();
     for (int i = 0; i < MT; ++i) {
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.java b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.java
index 53f851f..33a729d 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/ConcurrentUpdateSolrServer.java
@@ -49,6 +49,7 @@ import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.params.UpdateParams;
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SolrjNamedThreadFactory;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -71,7 +72,8 @@ public class ConcurrentUpdateSolrServer extends SolrServer {
       .getLogger(ConcurrentUpdateSolrServer.class);
   private HttpSolrServer server;
   final BlockingQueue<UpdateRequest> queue;
-  final ExecutorService scheduler = Executors.newCachedThreadPool();
+  final ExecutorService scheduler = Executors.newCachedThreadPool(
+      new SolrjNamedThreadFactory("concurrentUpdateScheduler"));
   final Queue<Runner> runners;
   volatile CountDownLatch lock = null; // used to block everything
   final int threadCount;
diff --git a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttpSolrServer.java b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttpSolrServer.java
index c4c5467..bc124d9 100644
--- a/solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttpSolrServer.java
+++ b/solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttpSolrServer.java
@@ -21,6 +21,7 @@ import org.apache.solr.client.solrj.*;
 import org.apache.solr.client.solrj.response.QueryResponse;
 import org.apache.solr.common.params.ModifiableSolrParams;
 import org.apache.solr.common.util.NamedList;
+import org.apache.solr.common.util.SolrjNamedThreadFactory;
 import org.apache.solr.common.SolrException;
 
 import java.io.IOException;
@@ -397,7 +398,7 @@ public class LBHttpSolrServer extends SolrServer {
   public void setSoTimeout(int timeout) {
     HttpClientUtil.setSoTimeout(httpClient, timeout);
   }
-  
+
   @Override
   public void shutdown() {
     if (aliveCheckExecutor != null) {
@@ -555,7 +556,8 @@ public class LBHttpSolrServer extends SolrServer {
     if (aliveCheckExecutor == null) {
       synchronized (this) {
         if (aliveCheckExecutor == null) {
-          aliveCheckExecutor = Executors.newSingleThreadScheduledExecutor();
+          aliveCheckExecutor = Executors.newSingleThreadScheduledExecutor(
+              new SolrjNamedThreadFactory("aliveCheckExecutor"));
           aliveCheckExecutor.scheduleAtFixedRate(
                   getAliveCheckRunner(new WeakReference<LBHttpSolrServer>(this)),
                   this.interval, this.interval, TimeUnit.MILLISECONDS);
diff --git a/solr/solrj/src/java/org/apache/solr/common/util/SolrjNamedThreadFactory.java b/solr/solrj/src/java/org/apache/solr/common/util/SolrjNamedThreadFactory.java
new file mode 100644
index 0000000..de9042f
--- /dev/null
+++ b/solr/solrj/src/java/org/apache/solr/common/util/SolrjNamedThreadFactory.java
@@ -0,0 +1,49 @@
+package org.apache.solr.common.util;
+
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class SolrjNamedThreadFactory implements ThreadFactory {
+  private static final AtomicInteger poolNumber = new AtomicInteger(1);
+  private final ThreadGroup group;
+  private final AtomicInteger threadNumber = new AtomicInteger(1);
+  private final String prefix;
+
+  public SolrjNamedThreadFactory(String namePrefix) {
+      SecurityManager s = System.getSecurityManager();
+      group = (s != null)? s.getThreadGroup() :
+                           Thread.currentThread().getThreadGroup();
+      prefix = namePrefix + "-" +
+                    poolNumber.getAndIncrement() +
+                   "-thread-";
+  }
+
+  public Thread newThread(Runnable r) {
+      Thread t = new Thread(group, r,
+                            prefix + threadNumber.getAndIncrement(),
+                            0);
+
+      t.setDaemon(false);
+      
+      if (t.getPriority() != Thread.NORM_PRIORITY)
+          t.setPriority(Thread.NORM_PRIORITY);
+      return t;
+  }
+}
\ No newline at end of file
diff --git a/solr/solrj/src/java/org/apache/zookeeper/SolrZooKeeper.java b/solr/solrj/src/java/org/apache/zookeeper/SolrZooKeeper.java
index 3025ae5..5e77cf5 100644
--- a/solr/solrj/src/java/org/apache/zookeeper/SolrZooKeeper.java
+++ b/solr/solrj/src/java/org/apache/zookeeper/SolrZooKeeper.java
@@ -19,9 +19,12 @@ package org.apache.zookeeper;
 
 import java.io.IOException;
 import java.nio.channels.SocketChannel;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 // we use this class to expose nasty stuff for tests
 public class SolrZooKeeper extends ZooKeeper {
+  List<Thread> spawnedThreads = new CopyOnWriteArrayList<Thread>();
 
   public SolrZooKeeper(String connectString, int sessionTimeout,
       Watcher watcher) throws IOException {
@@ -38,21 +41,32 @@ public class SolrZooKeeper extends ZooKeeper {
    * @param ms the number of milliseconds to pause.
    */
   public void pauseCnxn(final long ms) {
-    new Thread() {
+    Thread t = new Thread() {
       public void run() {
-        synchronized (cnxn) {
-          try {
+        try {
+          synchronized (cnxn) {
             try {
               ((SocketChannel) cnxn.sendThread.sockKey.channel()).socket()
                   .close();
             } catch (Exception e) {
-
             }
             Thread.sleep(ms);
-          } catch (InterruptedException e) {}
-        }
+          }
+
+          // Wait a long while to make sure we properly clean up these threads.
+          Thread.sleep(500000);
+        } catch (InterruptedException e) {}
       }
-    }.start();
+    };
+    t.start();
+    spawnedThreads.add(t);
   }
 
+  @Override
+  public synchronized void close() throws InterruptedException {
+    for (Thread t : spawnedThreads) {
+      t.interrupt();
+    }
+    super.close();
+  }
 }
diff --git a/solr/solrj/src/test/org/apache/solr/client/solrj/TestLBHttpSolrServer.java b/solr/solrj/src/test/org/apache/solr/client/solrj/TestLBHttpSolrServer.java
index d155b78..3957d1b 100644
--- a/solr/solrj/src/test/org/apache/solr/client/solrj/TestLBHttpSolrServer.java
+++ b/solr/solrj/src/test/org/apache/solr/client/solrj/TestLBHttpSolrServer.java
@@ -22,6 +22,7 @@ import org.apache.commons.io.FileUtils;
 import org.apache.http.client.HttpClient;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.LuceneTestCase.Slow;
+import org.apache.solr.SolrIgnoredThreadsFilter;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.client.solrj.embedded.JettySolrRunner;
 import org.apache.solr.client.solrj.impl.HttpClientUtil;
@@ -35,6 +36,8 @@ import org.apache.solr.util.AbstractSolrTestCase;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakFilters;
+
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -48,6 +51,9 @@ import java.util.Set;
  * @since solr 1.4
  */
 @Slow
+@ThreadLeakFilters(defaultFilters = true, filters = {
+    SolrIgnoredThreadsFilter.class
+})
 public class TestLBHttpSolrServer extends LuceneTestCase {
   SolrInstance[] solr = new SolrInstance[3];
   HttpClient httpClient;
diff --git a/solr/test-framework/src/java/org/apache/solr/SolrIgnoredThreadsFilter.java b/solr/test-framework/src/java/org/apache/solr/SolrIgnoredThreadsFilter.java
new file mode 100644
index 0000000..85b9e05
--- /dev/null
+++ b/solr/test-framework/src/java/org/apache/solr/SolrIgnoredThreadsFilter.java
@@ -0,0 +1,60 @@
+package org.apache.solr;
+
+import org.apache.lucene.search.TimeLimitingCollector.TimerThread;
+
+import com.carrotsearch.randomizedtesting.ThreadFilter;
+
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This ignores those threads in Solr for which there is no way to
+ * clean up after a suite.
+ */
+public class SolrIgnoredThreadsFilter implements ThreadFilter {
+  @Override
+  public boolean reject(Thread t) {
+    /*
+     * IMPORTANT! IMPORTANT!
+     * 
+     * Any threads added here should have ABSOLUTELY NO SIDE EFFECTS
+     * (should be stateless). This includes no references to cores or other
+     * test-dependent information.
+     */
+
+    String threadName = t.getName();
+    if (threadName.equals(TimerThread.THREAD_NAME)) {
+      return true;
+    }
+
+    if (threadName.startsWith("facetExecutor-") || 
+        threadName.startsWith("cmdDistribExecutor-") ||
+        threadName.startsWith("httpShardExecutor-")) {
+      return true;
+    }
+
+    // THESE ARE LIKELY BUGS - these threads should be closed!
+    if (threadName.startsWith("Overseer-") ||
+        threadName.startsWith("aliveCheckExecutor-") ||
+        threadName.startsWith("concurrentUpdateScheduler-")) {
+      return true;
+    }
+
+    return false;
+  }
+}
diff --git a/solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java b/solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java
index 69a1c3f..08a44d1 100755
--- a/solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java
+++ b/solr/test-framework/src/java/org/apache/solr/SolrTestCaseJ4.java
@@ -38,6 +38,7 @@ import org.apache.solr.schema.SchemaField;
 import org.apache.solr.search.SolrIndexSearcher;
 import org.apache.solr.servlet.DirectSolrConnection;
 import org.apache.solr.util.AbstractSolrTestCase;
+import org.apache.solr.util.RevertDefaultThreadHandlerRule;
 import org.apache.solr.util.TestHarness;
 import org.junit.*;
 import org.junit.rules.RuleChain;
@@ -46,20 +47,24 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.xml.sax.SAXException;
 
-import com.carrotsearch.randomizedtesting.annotations.ThreadLeaks;
+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakFilters;
 import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;
 
 /**
  * A junit4 Solr test harness that extends LuceneTestCaseJ4.
  * Unlike {@link AbstractSolrTestCase}, a new core is not created for each test method.
  */
+@ThreadLeakFilters(defaultFilters = true, filters = {
+    SolrIgnoredThreadsFilter.class
+})
 public abstract class SolrTestCaseJ4 extends LuceneTestCase {
   public static int DEFAULT_CONNECTION_TIMEOUT = 1000;  // default socket connection timeout in ms
 
 
   @ClassRule
   public static TestRule solrClassRules = 
-    RuleChain.outerRule(new SystemPropertiesRestoreRule());
+    RuleChain.outerRule(new SystemPropertiesRestoreRule())
+             .around(new RevertDefaultThreadHandlerRule());
 
   @Rule
   public TestRule solrTestRules = 
diff --git a/solr/test-framework/src/java/org/apache/solr/util/AbstractSolrTestCase.java b/solr/test-framework/src/java/org/apache/solr/util/AbstractSolrTestCase.java
index 6d31774..a05145a 100644
--- a/solr/test-framework/src/java/org/apache/solr/util/AbstractSolrTestCase.java
+++ b/solr/test-framework/src/java/org/apache/solr/util/AbstractSolrTestCase.java
@@ -25,6 +25,7 @@ import java.util.*;
 import javax.xml.xpath.XPathExpressionException;
 
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.solr.SolrIgnoredThreadsFilter;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.*;
 import org.apache.solr.common.params.CommonParams;
@@ -38,7 +39,7 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.xml.sax.SAXException;
 
-import com.carrotsearch.randomizedtesting.annotations.ThreadLeaks;
+import com.carrotsearch.randomizedtesting.annotations.ThreadLeakFilters;
 import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;
 
 /**
@@ -54,6 +55,9 @@ import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;
  * @see #setUp
  * @see #tearDown
  */
+@ThreadLeakFilters(defaultFilters = true, filters = {
+    SolrIgnoredThreadsFilter.class
+})
 public abstract class AbstractSolrTestCase extends LuceneTestCase {
   protected SolrConfig solrConfig;
 
@@ -98,7 +102,8 @@ public abstract class AbstractSolrTestCase extends LuceneTestCase {
   
   @ClassRule
   public static TestRule solrClassRules = 
-    RuleChain.outerRule(new SystemPropertiesRestoreRule());
+    RuleChain.outerRule(new SystemPropertiesRestoreRule())
+             .around(new RevertDefaultThreadHandlerRule());
 
   @Rule
   public TestRule solrTestRules = 
diff --git a/solr/test-framework/src/java/org/apache/solr/util/RevertDefaultThreadHandlerRule.java b/solr/test-framework/src/java/org/apache/solr/util/RevertDefaultThreadHandlerRule.java
new file mode 100644
index 0000000..f805a1a
--- /dev/null
+++ b/solr/test-framework/src/java/org/apache/solr/util/RevertDefaultThreadHandlerRule.java
@@ -0,0 +1,54 @@
+package org.apache.solr.util;
+
+import java.lang.Thread.UncaughtExceptionHandler;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import com.carrotsearch.randomizedtesting.rules.StatementAdapter;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public final class RevertDefaultThreadHandlerRule implements TestRule {
+  private final static AtomicBoolean applied = new AtomicBoolean();
+  
+  @Override
+  public Statement apply(Statement s, Description d) {
+    return new StatementAdapter(s) {
+      @Override
+      protected void before() throws Throwable {
+        if (!applied.getAndSet(true)) {
+          UncaughtExceptionHandler p = Thread.getDefaultUncaughtExceptionHandler();
+          try {
+            // Try to initialize a zookeeper class that reinitializes default exception handler.
+            Class<?> cl = org.apache.zookeeper.server.NIOServerCnxn.Factory.class;
+            // Make sure static initializers have been called.
+            Class.forName(cl.getName(), true, cl.getClassLoader());
+          } finally {
+            if (p == Thread.getDefaultUncaughtExceptionHandler()) {
+              throw new RuntimeException("Zookeeper no longer resets default thread handler.");
+            }
+            Thread.setDefaultUncaughtExceptionHandler(p);
+          }
+        }
+      }
+    };
+  }
+}
