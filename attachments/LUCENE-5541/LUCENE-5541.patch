Index: lucene/core/src/java/org/apache/lucene/store/FileExistsCachingDirectory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/FileExistsCachingDirectory.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/store/FileExistsCachingDirectory.java	(working copy)
@@ -0,0 +1,139 @@
+package org.apache.lucene.store;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
+
+/** Simple delegating Directory to work around filesystems
+ *  where File.exists may sometimes return false when it
+ *  should return true.  E.g., this can happen if there is a
+ *  low level error, since File.exists cannot throw
+ *  IOException.  This class just keeps a private map of
+ *  all created but not deleted files, and then if the file
+ *  is in this map, it returns true from fileExists.  Else,
+ *  it falls back to the delegate. */
+
+public final class FileExistsCachingDirectory extends Directory {
+
+  private final Directory delegate;
+
+  private final Set<String> createdFiles = new HashSet<String>();
+
+  public FileExistsCachingDirectory(Directory delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override
+  public String[] listAll() throws IOException {
+    return delegate.listAll();
+  }
+
+  @Override
+  public boolean fileExists(String name) throws IOException {
+    synchronized(createdFiles) {
+      if (createdFiles.contains(name)) {
+        return true;
+      }
+    }
+
+    return delegate.fileExists(name);
+  }
+
+  @Override
+  public long fileModified(String name) throws IOException {
+    return delegate.fileModified(name);
+  }
+
+  @Override
+  public void touchFile(String name) throws IOException {
+    delegate.touchFile(name);
+  }
+
+  @Override
+  public void deleteFile(String name) throws IOException {
+    synchronized(createdFiles) {
+      createdFiles.remove(name);
+    }
+    delegate.deleteFile(name);
+  }
+
+  @Override
+  public long fileLength(String name) throws IOException {
+    return delegate.fileLength(name);
+  }
+
+  @Override
+  public IndexOutput createOutput(String name) throws IOException {
+    synchronized(createdFiles) {
+      createdFiles.add(name);
+    }
+    return delegate.createOutput(name);
+  }
+
+  @Override
+  public void sync(String name) throws IOException {
+    delegate.sync(name);
+  }
+
+  @Override
+  public IndexInput openInput(String name) throws IOException {
+    return delegate.openInput(name);
+  }
+
+  @Override
+  public IndexInput openInput(String name, int bufferSize) throws IOException {
+    return delegate.openInput(name, bufferSize);
+  }
+
+  @Override
+  public Lock makeLock(String name) {
+    return delegate.makeLock(name);
+  }
+
+  @Override
+  public void clearLock(String name) throws IOException {
+    delegate.clearLock(name);
+  }
+
+  @Override
+  public void close() throws IOException {
+    delegate.close();
+  }
+
+  @Override
+  public void setLockFactory(LockFactory lockFactory) throws IOException {
+    delegate.setLockFactory(lockFactory);
+  }
+
+  @Override
+  public LockFactory getLockFactory() {
+    return delegate.getLockFactory();
+  }
+
+  @Override
+  public String getLockID() {
+    return delegate.getLockID();
+  }
+
+  @Override
+  public String toString() {
+    return "FileExistsCachingDirectory(" + delegate.toString() + ")";
+  }
+}

Property changes on: lucene/core/src/java/org/apache/lucene/store/FileExistsCachingDirectory.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/java/org/apache/lucene/index/FixCFS.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/FixCFS.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/index/FixCFS.java	(working copy)
@@ -0,0 +1,126 @@
+package org.apache.lucene.index;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.File;
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.FSDirectory;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+
+// Put under directory org/apache/lucene/index and then e.g.:
+
+// javac -cp ../build/core/lucene-core-3.6-SNAPSHOT.jar org/apache/lucene/index/FixCFS.java
+
+// java -cp .:../build/core/lucene-core-3.6-SNAPSHOT.jar org.apache.lucene.index.FixCFS /x/tmp/corrupt/FOSSIL_Document_20140206002511_45D206965199486F837748CAD2CE82DC/data/text _k
+
+// jar cf lucene-3.6.0-FixCFS.jar org
+
+public class FixCFS {
+  public static void main(String[] args) throws IOException {
+
+    if (args.length != 2) {
+      System.out.println("Usage: java -cp ... FixCFS /path/to/index _segName");
+      System.exit(1);
+    }
+
+    String indexPath = args[0];
+    String segName = args[1];
+    String segNameDot = segName + ".";
+
+    Directory dir = FSDirectory.open(new File(indexPath));
+    String extraFileName = null;
+    boolean sawCFS = false;
+    for(String fileName : dir.listAll()) {
+      if (fileName.startsWith(segNameDot)) {
+        if (IndexFileNames.matchesExtension(fileName, IndexFileNames.COMPOUND_FILE_EXTENSION)) {
+          sawCFS = true;
+        } else if (extraFileName != null) {
+          throw new IllegalStateException("don't know how to fix segment " + segName + ": it has more than one extra file");
+        } else {
+          extraFileName = fileName;
+        }
+      }
+    }
+
+    // Make sure we only have one file missing from the CFS:
+    if (sawCFS == false) {
+      throw new IllegalStateException("don't know how to fix segment " + segName + ": " + segName + ".cfs was not found");
+    }
+
+    System.out.println("Extra file=" + extraFileName);
+
+    String cfsFileName = IndexFileNames.segmentFileName(segName, IndexFileNames.COMPOUND_FILE_EXTENSION);
+    Directory cfr = new CompoundFileReader(dir, cfsFileName);
+    if (cfr.fileExists(extraFileName)) {
+      throw new IllegalStateException("don't know how to fix segment " + segName + ": " + extraFileName + " also exists inside the CFS file");
+    }
+
+    Set<String> cfsFiles = new HashSet<String>();
+
+    for(String fileName : cfr.listAll()) {
+      if (dir.fileExists(fileName)) {
+        throw new IllegalStateException("CFS file " + fileName + " already exists");
+      }
+      cfsFiles.add(fileName);
+    }
+
+    System.out.println("Expand " + cfsFileName);
+
+    // Extract all files from the CFS:
+    for(String fileName : cfsFiles) {
+      IndexOutput out = dir.createOutput(fileName);
+      IndexInput in = cfr.openInput(fileName);
+      out.copyBytes(in, in.length());
+      in.close();
+      out.close();
+    }
+
+    cfr.close();
+
+    // Remove old CFS:
+    dir.deleteFile(cfsFileName);
+
+    System.out.println("Write new " + cfsFileName);
+
+    // Write new CFS:
+    CompoundFileWriter cfw = new CompoundFileWriter(dir, cfsFileName);
+    for(String fileName : cfsFiles) {
+      cfw.addFile(fileName);
+    }
+
+    // Also add the missing file:
+    cfw.addFile(extraFileName);
+    cfw.close();
+
+    // Delete the files:
+    for(String fileName : cfsFiles) {
+      dir.deleteFile(fileName);
+    }
+
+    // Delete the extra file:
+    dir.deleteFile(extraFileName);
+
+    cfr.close();
+    dir.close();
+  }
+}

Property changes on: lucene/core/src/java/org/apache/lucene/index/FixCFS.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(revision 1545217)
+++ lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(working copy)
@@ -33,8 +33,8 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map.Entry;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.Random;
 import java.util.Set;
 import java.util.TimeZone;
@@ -43,10 +43,10 @@
 import java.util.concurrent.TimeUnit;
 
 import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.document.Field;
 import org.apache.lucene.document.Field.Index;
 import org.apache.lucene.document.Field.Store;
 import org.apache.lucene.document.Field.TermVector;
+import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.LogByteSizeMergePolicy;
@@ -59,11 +59,12 @@
 import org.apache.lucene.index.TieredMergePolicy;
 import org.apache.lucene.search.AssertingIndexSearcher;
 import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.FieldCache.CacheEntry;
 import org.apache.lucene.search.FieldCache;
-import org.apache.lucene.search.FieldCache.CacheEntry;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.FSDirectory;
+import org.apache.lucene.store.FileExistsCachingDirectory;
 import org.apache.lucene.store.LockFactory;
 import org.apache.lucene.store.MockDirectoryWrapper;
 import org.apache.lucene.store.NRTCachingDirectory;
@@ -1271,7 +1272,8 @@
     } catch (Exception e) {
       d = FSDirectory.open(file);
     }
-    return d;
+    // nocommit
+    return new FileExistsCachingDirectory(d);
   }
 
   /**
@@ -1299,7 +1301,8 @@
       }
 
       // try empty ctor
-      return clazz.newInstance();
+      // nocommit
+      return new FileExistsCachingDirectory(clazz.newInstance());
     } catch (Exception e) {
       throw new RuntimeException(e);
     } 
