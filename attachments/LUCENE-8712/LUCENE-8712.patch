Index: lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java	(revision 5f91670a496275167d7699c24ee7df61d7e2f7e6)
+++ lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java	(date 1551878313000)
@@ -194,27 +194,18 @@
     }
   }
 
-  /**
-   * uses orient method to compute relation between two line segments
-   * note the following return values:
-   * CELL_CROSSES_QUERY - if the two line segments fully cross
-   * CELL_INSIDE_QUERY - if the one line segment terminates on the other
-   * CELL_OUTSIDE_QUERY - if the two segments do not cross
-   **/
-  public static Relation lineRelateLine(double a1x, double a1y, double b1x, double b1y, double a2x, double a2y, double b2x, double b2y) {
+  /** uses orient method to compute whether two line segments cross */
+  public static boolean lineCrossesLine(double a1x, double a1y, double b1x, double b1y, double a2x, double a2y, double b2x, double b2y) {
     // shortcut: either "line" is actually a point
     if ((a1x == b1x && a1y == b1y) || (a2x == b2x && a2y == b2y)) {
-      return Relation.CELL_OUTSIDE_QUERY;
+      return false;
     }
 
-    int a = orient(a2x, a2y, b2x, b2y, a1x, a1y) * orient(a2x, a2y, b2x, b2y, b1x, b1y);
-    int b = orient(a1x, a1y, b1x, b1y, a2x, a2y) * orient(a1x, a1y, b1x, b1y, b2x, b2y);
-
-    if (a <= 0 && b <= 0) {
-      return a == 0 || b == 0 ? Relation.CELL_INSIDE_QUERY : Relation.CELL_CROSSES_QUERY;
+    if (orient(a2x, a2y, b2x, b2y, a1x, a1y) * orient(a2x, a2y, b2x, b2y, b1x, b1y) <= 0 &&
+        orient(a1x, a1y, b1x, b1y, a2x, a2y) * orient(a1x, a1y, b1x, b1y, b2x, b2y) <= 0) {
+      return true;
     }
-
-    return Relation.CELL_OUTSIDE_QUERY;
+    return false;
   }
 
   /**
Index: lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonShape.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonShape.java	(revision 5f91670a496275167d7699c24ee7df61d7e2f7e6)
+++ lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonShape.java	(date 1551878882000)
@@ -327,7 +327,7 @@
         GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(alon)),
         GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(alat)));
 
-    assertEquals(PointValues.Relation.CELL_OUTSIDE_QUERY, rel);
+    assertEquals(PointValues.Relation.CELL_CROSSES_QUERY, rel);
 
     rel = polygon2D.relateTriangle(GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(alon)),
         GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(blat)),
@@ -336,7 +336,19 @@
         GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(blon)),
         GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(blat)));
 
-    assertEquals(PointValues.Relation.CELL_OUTSIDE_QUERY, rel);
+    assertEquals(PointValues.Relation.CELL_CROSSES_QUERY, rel);
+  }
+
+  public void testLineCrossingPolygonPoints() {
+    Polygon p = new Polygon(new double[] {0, -1, 0, 1, 0}, new double[] {-1, 0, 1, 0, -1});
+    Polygon2D polygon2D = Polygon2D.create(p);
+    PointValues.Relation rel = polygon2D.relateTriangle(GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(-1.5)),
+        GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(0)),
+        GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(1.5)),
+        GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(0)),
+        GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(-1.5)),
+        GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(0)));
+    assertEquals(PointValues.Relation.CELL_CROSSES_QUERY, rel);
   }
 
   public void testTriangleTouchingEdges() {
@@ -349,7 +361,7 @@
         GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(0.5)),
         GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(0.5)),
         GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(1)));
-    assertEquals(PointValues.Relation.CELL_INSIDE_QUERY, rel);
+    assertEquals(PointValues.Relation.CELL_CROSSES_QUERY, rel);
     //2 shared points
     rel = polygon2D.relateTriangle(GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(0.5)),
         GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(0)),
@@ -357,7 +369,7 @@
         GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(0.5)),
         GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(0.5)),
         GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(0.75)));
-    assertEquals(PointValues.Relation.CELL_INSIDE_QUERY, rel);
+    assertEquals(PointValues.Relation.CELL_CROSSES_QUERY, rel);
     //1 shared point
     rel = polygon2D.relateTriangle(
         GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(0.5)),
@@ -366,7 +378,7 @@
         GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(0)),
         GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(0.75)),
         GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(0.75)));
-    assertEquals(PointValues.Relation.CELL_INSIDE_QUERY, rel);
+    assertEquals(PointValues.Relation.CELL_CROSSES_QUERY, rel);
     // 1 shared point but out
     rel = polygon2D.relateTriangle(GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(1)),
         GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(0.5)),
@@ -390,7 +402,7 @@
         GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(1)),
         GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(0.5)),
         GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(0.5)));
-    assertEquals(PointValues.Relation.CELL_INSIDE_QUERY, rel);
+    assertEquals(PointValues.Relation.CELL_CROSSES_QUERY, rel);
     //share one edge outside
     rel = polygon2D.relateTriangle(GeoEncodingUtils.decodeLongitude(GeoEncodingUtils.encodeLongitude(0)),
         GeoEncodingUtils.decodeLatitude(GeoEncodingUtils.encodeLatitude(1)),
Index: lucene/core/src/java/org/apache/lucene/geo/EdgeTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/core/src/java/org/apache/lucene/geo/EdgeTree.java	(revision 5f91670a496275167d7699c24ee7df61d7e2f7e6)
+++ lucene/core/src/java/org/apache/lucene/geo/EdgeTree.java	(date 1551878753000)
@@ -22,7 +22,7 @@
 import org.apache.lucene.index.PointValues.Relation;
 import org.apache.lucene.util.ArrayUtil;
 
-import static org.apache.lucene.geo.GeoUtils.lineRelateLine;
+import static org.apache.lucene.geo.GeoUtils.lineCrossesLine;
 import static org.apache.lucene.geo.GeoUtils.orient;
 
 /**
@@ -211,6 +211,8 @@
     // lat-lon pair (in original order) of the two vertices
     final double lat1, lat2;
     final double lon1, lon2;
+    //edge belongs to the dateline
+    final boolean dateline;
     /** min of this edge */
     final double low;
     /** max latitude of this edge or any children */
@@ -228,17 +230,18 @@
       this.lon2 = lon2;
       this.low = low;
       this.max = max;
+      dateline = (lon1 == GeoUtils.MIN_LON_INCL && lon2 == GeoUtils.MIN_LON_INCL)
+          || (lon1 == GeoUtils.MAX_LON_INCL && lon2 == GeoUtils.MAX_LON_INCL);
     }
 
     /** Returns true if the triangle crosses any edge in this edge subtree */
-    Relation relateTriangle(double ax, double ay, double bx, double by, double cx, double cy) {
+    boolean crossesTriangle(double ax, double ay, double bx, double by, double cx, double cy) {
       // compute bounding box of triangle
       double minLat = StrictMath.min(StrictMath.min(ay, by), cy);
       double minLon = StrictMath.min(StrictMath.min(ax, bx), cx);
       double maxLat = StrictMath.max(StrictMath.max(ay, by), cy);
       double maxLon = StrictMath.max(StrictMath.max(ax, bx), cx);
 
-      Relation r = Relation.CELL_OUTSIDE_QUERY;
       if (minLat <= max) {
         double dy = lat1;
         double ey = lat2;
@@ -252,53 +255,39 @@
             (dx < minLon && ex < minLon) ||
             (dx > maxLon && ex > maxLon);
 
-        if (outside == false) {
-          int insideEdges = 0;
+        if (dateline == false && outside == false) {
           // does triangle's first edge intersect polyline?
           // ax, ay -> bx, by
-          if ((r = lineRelateLine(ax, ay, bx, by, dx, dy, ex, ey)) == Relation.CELL_CROSSES_QUERY) {
-            return r;
-          } else if (r == Relation.CELL_INSIDE_QUERY) {
-            ++insideEdges;
+          if (lineCrossesLine(ax, ay, bx, by, dx, dy, ex, ey)) {
+            return true;
           }
 
           // does triangle's second edge intersect polyline?
           // bx, by -> cx, cy
-          if ((r = lineRelateLine(bx, by, cx, cy, dx, dy, ex, ey)) == Relation.CELL_CROSSES_QUERY) {
-            return r;
-          } else if (r == Relation.CELL_INSIDE_QUERY) {
-            ++insideEdges;
+          if (lineCrossesLine(bx, by, cx, cy, dx, dy, ex, ey)) {
+            return true;
           }
 
           // does triangle's third edge intersect polyline?
           // cx, cy -> ax, ay
-          if ((r = lineRelateLine(cx, cy, ax, ay, dx, dy, ex, ey)) == Relation.CELL_CROSSES_QUERY) {
-            return r;
-          } else if (r == Relation.CELL_INSIDE_QUERY) {
-            ++insideEdges;
-          }
-          if (insideEdges == 3) {
-            // fully inside, we can return
-            return Relation.CELL_INSIDE_QUERY;
-          } else {
-            //reset relation to not crossing
-            r =  Relation.CELL_OUTSIDE_QUERY;
+          if (lineCrossesLine(cx, cy, ax, ay, dx, dy, ex, ey)) {
+            return true;
           }
         }
 
         if (left != null) {
-          if ((r = left.relateTriangle(ax, ay, bx, by, cx, cy)) != Relation.CELL_OUTSIDE_QUERY) {
-            return r;
+          if (left.crossesTriangle(ax, ay, bx, by, cx, cy)) {
+            return true;
           }
         }
 
         if (right != null && maxLat >= low) {
-          if ((r = right.relateTriangle(ax, ay, bx, by, cx, cy)) != Relation.CELL_OUTSIDE_QUERY) {
-            return r;
+          if (right.crossesTriangle(ax, ay, bx, by, cx, cy)) {
+            return true;
           }
         }
       }
-      return r;
+      return false;
     }
 
     /** Returns true if the box crosses any edge in this edge subtree */
Index: lucene/core/src/java/org/apache/lucene/geo/Polygon2D.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/core/src/java/org/apache/lucene/geo/Polygon2D.java	(revision 5f91670a496275167d7699c24ee7df61d7e2f7e6)
+++ lucene/core/src/java/org/apache/lucene/geo/Polygon2D.java	(date 1551878334000)
@@ -122,7 +122,7 @@
     // check each corner: if < 3 && > 0 are present, its cheaper than crossesSlowly
     int numCorners = numberOfTriangleCorners(ax, ay, bx, by, cx, cy);
     if (numCorners == 3) {
-      if (tree.relateTriangle(ax, ay, bx, by, cx, cy) == Relation.CELL_CROSSES_QUERY) {
+      if (tree.crossesTriangle(ax, ay, bx, by, cx, cy)) {
         return Relation.CELL_CROSSES_QUERY;
       }
       return Relation.CELL_INSIDE_QUERY;
@@ -130,7 +130,7 @@
       if (pointInTriangle(tree.lon1, tree.lat1, ax, ay, bx, by, cx, cy) == true) {
         return Relation.CELL_CROSSES_QUERY;
       }
-      if (tree.relateTriangle(ax, ay, bx, by, cx, cy) == Relation.CELL_CROSSES_QUERY) {
+      if (tree.crossesTriangle(ax, ay, bx, by, cx, cy)) {
         return Relation.CELL_CROSSES_QUERY;
       }
       return Relation.CELL_OUTSIDE_QUERY;
Index: lucene/sandbox/src/java/org/apache/lucene/geo/Line2D.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/geo/Line2D.java	(revision 5f91670a496275167d7699c24ee7df61d7e2f7e6)
+++ lucene/sandbox/src/java/org/apache/lucene/geo/Line2D.java	(date 1551878394000)
@@ -50,6 +50,9 @@
 
   @Override
   protected PointValues.Relation componentRelateTriangle(double ax, double ay, double bx, double by, double cx, double cy) {
-    return tree.relateTriangle(ax, ay, bx, by, cx, cy);
+    if (tree.crossesTriangle(ax, ay, bx, by, cx, cy)) {
+      return PointValues.Relation.CELL_CROSSES_QUERY;
+    }
+    return PointValues.Relation.CELL_OUTSIDE_QUERY;
   }
 }
\ No newline at end of file
