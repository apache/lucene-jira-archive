--- StandardTokenizerImpl.java.sav	2009-12-02 12:38:25.984375000 +0100
+++ StandardTokenizerImpl.java	2009-12-02 12:53:07.687500000 +0100
@@ -1,4 +1,4 @@
-/* The following code was generated by JFlex 1.4.1 on 16.11.09 23:52 */
+/* The following code was generated by JFlex 1.5.0-SNAPSHOT on 02.12.09 12:53 */
 
 package org.apache.lucene.analysis.standard;
 
@@ -35,8 +35,8 @@
 
 /**
  * This class is a scanner generated by 
- * <a href="http://www.jflex.de/">JFlex</a> 1.4.1
- * on 16.11.09 23:52 from the specification file
+ * <a href="http://www.jflex.de/">JFlex</a> 1.5.0-SNAPSHOT
+ * on 02.12.09 12:53 from the specification file
  * <tt>C:/Projects/lucene/trunk-full1/src/java/org/apache/lucene/analysis/standard/StandardTokenizerImpl.jflex</tt>
  */
 class StandardTokenizerImpl implements StandardTokenizerInterface {
@@ -50,6 +50,16 @@
   /** lexical states */
   public static final int YYINITIAL = 0;
 
+  /**
+   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
+   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
+   *                  at the beginning of a line
+   * l is of the form l = 2*k, k a non negative integer
+   */
+  private static final int ZZ_LEXSTATE[] = { 
+     0, 0
+  };
+
   /** 
    * Translates characters to character classes
    */
@@ -309,9 +319,6 @@
   /** the textposition at the last accepting state */
   private int zzMarkedPos;
 
-  /** the textposition at the last state to be included in yytext */
-  private int zzPushbackPos;
-
   /** the current text position in the buffer */
   private int zzCurrentPos;
 
@@ -342,6 +349,9 @@
   /** zzAtEOF == true <=> the scanner is at the EOF */
   private boolean zzAtEOF;
 
+  /** denotes if the user-EOF-code has already been executed */
+  private boolean zzEOFDone;
+
   /* user code: */
 
 public static final int ALPHANUM          = StandardTokenizer.ALPHANUM;
@@ -432,7 +442,6 @@
       zzEndRead-= zzStartRead;
       zzCurrentPos-= zzStartRead;
       zzMarkedPos-= zzStartRead;
-      zzPushbackPos-= zzStartRead;
       zzStartRead = 0;
     }
 
@@ -448,13 +457,23 @@
     int numRead = zzReader.read(zzBuffer, zzEndRead,
                                             zzBuffer.length-zzEndRead);
 
-    if (numRead < 0) {
-      return true;
-    }
-    else {
+    if (numRead > 0) {
       zzEndRead+= numRead;
       return false;
     }
+    // unlikely but not impossible: read 0 characters, but not at end of stream    
+    if (numRead == 0) {
+      int c = zzReader.read();
+      if (c == -1) {
+        return true;
+      } else {
+        zzBuffer[zzEndRead++] = (char) c;
+        return false;
+      }     
+    }
+
+	// numRead < 0
+    return true;
   }
 
     
@@ -484,8 +503,9 @@
     zzReader = reader;
     zzAtBOL  = true;
     zzAtEOF  = false;
+    zzEOFDone = false;
     zzEndRead = zzStartRead = 0;
-    zzCurrentPos = zzMarkedPos = zzPushbackPos = 0;
+    zzCurrentPos = zzMarkedPos = 0;
     yyline = yychar = yycolumn = 0;
     zzLexicalState = YYINITIAL;
   }
@@ -615,7 +635,7 @@
 
       zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
   
-      zzState = zzLexicalState;
+      zzState = ZZ_LEXSTATE[zzLexicalState];
 
 
       zzForAction: {
@@ -663,44 +683,44 @@
       zzMarkedPos = zzMarkedPosL;
 
       switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
-        case 4: 
-          { return HOST;
+        case 5: 
+          { return NUM;
           }
         case 11: break;
         case 9: 
           { return ACRONYM;
           }
         case 12: break;
-        case 8: 
-          { return ACRONYM_DEP;
+        case 7: 
+          { return COMPANY;
           }
         case 13: break;
-        case 1: 
-          { /* ignore */
+        case 10: 
+          { return EMAIL;
           }
         case 14: break;
-        case 5: 
-          { return NUM;
+        case 1: 
+          { /* ignore */
           }
         case 15: break;
-        case 3: 
-          { return CJ;
+        case 6: 
+          { return APOSTROPHE;
           }
         case 16: break;
-        case 2: 
-          { return ALPHANUM;
+        case 3: 
+          { return CJ;
           }
         case 17: break;
-        case 7: 
-          { return COMPANY;
+        case 8: 
+          { return ACRONYM_DEP;
           }
         case 18: break;
-        case 6: 
-          { return APOSTROPHE;
+        case 2: 
+          { return ALPHANUM;
           }
         case 19: break;
-        case 10: 
-          { return EMAIL;
+        case 4: 
+          { return HOST;
           }
         case 20: break;
         default: 
