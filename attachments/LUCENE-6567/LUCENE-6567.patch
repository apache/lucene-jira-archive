Index: lucene/core/src/java/org/apache/lucene/search/payloads/SpanPayloadCheckQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/payloads/SpanPayloadCheckQuery.java	(revision 1685577)
+++ lucene/core/src/java/org/apache/lucene/search/payloads/SpanPayloadCheckQuery.java	(working copy)
@@ -16,6 +16,13 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
@@ -25,7 +32,6 @@
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.spans.FilterSpans;
 import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
-import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanWeight;
@@ -33,14 +39,7 @@
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.ToStringUtils;
 
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Set;
 
-
 /**
  * Only return those matches that have a specific payload at the given position.
  */
@@ -98,17 +97,9 @@
       return (matchSpans == null) ? null : new FilterSpans(matchSpans) {
         @Override
         protected AcceptStatus accept(Spans candidate) throws IOException {
-
           collector.reset();
           candidate.collect(collector);
-          Collection<byte[]> collected = collector.getPayloads();
-
-          if (match instanceof SpanNearQuery) {
-            return checkCompositePayloads(collected);
-          }
-          else {
-            return checkOrderedPayloads(collected);
-          }
+          return checkPayloads(collector.getPayloads());
         }
       };
     }
@@ -132,19 +123,14 @@
   /**
    * Check to see if the collected payloads match the required set.
    *
-   * This is called for Near span queries which collect their sub spans
-   * out-of-order, meaning that we can't rely on the order of payloads
-   * in the collection
-   *
    * @param candidate a collection of payloads from the current Spans
    * @return whether or not the payloads match
    */
-  protected AcceptStatus checkOrderedPayloads(Collection<byte[]> candidate) {
+  protected AcceptStatus checkPayloads(Collection<byte[]> candidate) {
     if (candidate.size() == payloadToMatch.size()){
       //TODO: check the byte arrays are the same
       Iterator<byte[]> toMatchIter = payloadToMatch.iterator();
       //check each of the byte arrays, in order
-      //hmm, can't rely on order here
       for (byte[] candBytes : candidate) {
         //if one is a mismatch, then return false
         if (Arrays.equals(candBytes, toMatchIter.next()) == false){
@@ -158,36 +144,6 @@
     }
   }
 
-  /**
-   * Check to see if the collected payloads match the required set.
-   * @param candidate a collection of payloads from the current Spans
-   * @return whether or not the payloads match
-   */
-  protected AcceptStatus checkCompositePayloads(Collection<byte[]> candidate) {
-    if (candidate.size() == payloadToMatch.size()) {
-      //TODO: check the byte arrays are the same
-      //hmm, can't rely on order here
-      int matches = 0;
-      for (byte[] candBytes : candidate) {
-        //Unfortunately, we can't rely on order, so we need to compare all
-        for (byte[] payBytes : payloadToMatch) {
-          if (Arrays.equals(candBytes, payBytes) == true) {
-            matches++;
-            break;
-          }
-        }
-      }
-      if (matches == payloadToMatch.size()){
-        //we've verified all the bytes
-        return AcceptStatus.YES;
-      } else {
-        return AcceptStatus.NO;
-      }
-    } else {
-      return AcceptStatus.NO;
-    }
-  }
-
   @Override
   public String toString(String field) {
     StringBuilder buffer = new StringBuilder();
Index: lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadBasics.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadBasics.java	(revision 1685577)
+++ lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadBasics.java	(working copy)
@@ -17,6 +17,13 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.analysis.SimplePayloadFilter;
@@ -41,13 +48,6 @@
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-
 /** basic test of payload-spans */
 public class TestPayloadBasics extends LuceneTestCase {
   private static IndexSearcher searcher;
@@ -134,6 +134,23 @@
       {505});
   }
 
+  public void testUnorderedPayloadChecks() throws Exception {
+
+    SpanTermQuery term5 = new SpanTermQuery(new Term("field", "five"));
+    SpanTermQuery term100 = new SpanTermQuery(new Term("field", "hundred"));
+    SpanTermQuery term4 = new SpanTermQuery(new Term("field", "four"));
+    SpanNearQuery nearQuery = new SpanNearQuery(new SpanQuery[]{term5, term100, term4}, 0, false);
+
+    List<byte[]> payloads = new ArrayList<>();
+    payloads.add(("pos: " + 2).getBytes(StandardCharsets.UTF_8));
+    payloads.add(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
+    payloads.add(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
+
+    SpanPayloadCheckQuery payloadQuery = new SpanPayloadCheckQuery(nearQuery, payloads);
+    checkHits(payloadQuery, new int[]{ 405 });
+
+  }
+
   public void testComplexSpanChecks() throws Exception {
     SpanTermQuery one = new SpanTermQuery(new Term("field", "one"));
     SpanTermQuery thous = new SpanTermQuery(new Term("field", "thousand"));
