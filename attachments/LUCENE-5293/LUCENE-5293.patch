Index: core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder.java
===================================================================
--- core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder.java	(revision 1534073)
+++ core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder.java	(working copy)
@@ -27,11 +27,11 @@
  * that was introduced in the 1970's by Peter Elias and Robert Fano.
  * <p>
  * The Elias-Fano encoding is a high bits / low bits representation of
- * a monotonically increasing sequence of <code>numValues > 0</code> natural numbers <code>x[i]</code>
+ * a monotonically increasing sequence of <code>maxNumValues > 0</code> natural numbers <code>x[i]</code>
  * <p>
- * <code>0 <= x[0] <= x[1] <= ... <= x[numValues-2] <= x[numValues-1] <= upperBound</code>
+ * <code>0 <= x[0] <= x[1] <= ... <= x[n-2] <= x[n-1] <= upperBound</code>
  * <p>
- * where <code>upperBound > 0</code> is an upper bound on the last value.
+ * where <code>n = maxNumValues</code> and <code>upperBound > 0</code> is an upper bound on the last value.
  * <br>
  * The Elias-Fano encoding uses less than half a bit per encoded number more
  * than the smallest representation
@@ -40,30 +40,31 @@
  * The lower <code>L</code> bits of each <code>x[i]</code> are stored explicitly and contiguously
  * in the lower-bits array, with <code>L</code> chosen as (<code>log()</code> base 2):
  * <p>
- * <code>L = max(0, floor(log(upperBound/numValues)))</code>
+ * <code>L = max(0, floor(log(upperBound/maxNumValues)))</code>
  * <p>
- * The upper bits are stored in the upper-bits array as a sequence of unary-coded gaps (<code>x[-1] = 0</code>):
+ * The upper bits are stored in the upper-bits array as a sequence of unary-coded gaps
+ * (<code>x[-1] = 0</code> and <code>**</code> is the power operator):
  * <p>
- * <code>(x[i]/2**L) - (x[i-1]/2**L)</code>
+ * <code>x[i]/2**L - x[i-1]/2**L</code>
  * <p>
  * The unary code encodes a natural number <code>n</code> by <code>n</code> 0 bits followed by a 1 bit:
  * <code>0...01</code>. <br>
- * In the upper bits the total the number of 1 bits is <code>numValues</code>
+ * In the upper bits the total the number of 1 bits is <code>maxNumValues = n</code>
  * and the total number of 0 bits is:<p>
- * <code>floor(x[numValues-1]/2**L) <= upperBound/(2**max(0, floor(log(upperBound/numValues)))) <= 2*numValues</code>
+ * <code>floor(x[n-1]/2**L) <= upperBound/(2**max(0, floor(log(upperBound/n)))) <= 2*n</code>
  * <p>
  * The Elias-Fano encoding uses at most
  * <p>
- * <code>2 + ceil(log(upperBound/numValues))</code>
+ * <code>2 + ceil(log(upperBound/maxNumValues))</code>
  * <p>
  * bits per encoded number. With <code>upperBound</code> in these bounds (<code>p</code> is an integer):
  * <p>
- * <code>2**p < x[numValues-1] <= upperBound <= 2**(p+1)</code>
+ * <code>2**p < x[maxNumValues-1] <= upperBound <= 2**(p+1)</code>
  * <p>
  * the number of bits per encoded number is minimized.
  * <p>
  * In this implementation the values in the sequence can be given as <code>long</code>,
- * <code>numValues = 0</code> and <code>upperBound = 0</code> are allowed,
+ * <code>maxNumValues = 0</code> and <code>upperBound = 0</code> are allowed,
  * and each of the upper and lower bit arrays should fit in a <code>long[]</code>.
  * <br>
  * An index of positions of zero's in the upper bits is also built.
@@ -83,69 +84,69 @@
  */
 
 public class EliasFanoEncoder {
-  final long numValues;
-  private final long upperBound;
+  final long maxNumValues;
+  final long upperBound;
   final int numLowBits;
   final long lowerBitsMask;
-  final long[] upperLongs;
-  final long[] lowerLongs;
-  private static final int LOG2_LONG_SIZE = Long.numberOfTrailingZeros(Long.SIZE);
+  long[] upperLongs;
+  long[] lowerLongs;
+  static final int LOG2_LONG_SIZE = Long.numberOfTrailingZeros(Long.SIZE);
 
   long numEncoded = 0L;
-  long lastEncoded = 0L;
+  long lastEncoded = 0L; // x[-1]
 
   /** The default index interval for zero upper bits. */
   public static final long DEFAULT_INDEX_INTERVAL = 256;
   final long numIndexEntries;
   final long indexInterval;
-  final int nIndexEntryBits;
+  final int numIndexEntryBits;
   /** upperZeroBitPositionIndex[i] (filled using packValue) will contain the bit position
    *  just after the zero bit ((i+1) * indexInterval) in the upper bits.
    */
-  final long[] upperZeroBitPositionIndex;
+  long[] upperZeroBitPositionIndex;
   long currentEntryIndex; // also indicates how many entries in the index are valid.
 
 
 
   /**
    * Construct an Elias-Fano encoder.
-   * After construction, call {@link #encodeNext} <code>numValues</code> times to encode
+   * After construction, call {@link #encodeNext} <code>maxNumValues</code> times to encode
    * a non decreasing sequence of non negative numbers.
-   * @param numValues The number of values that is to be encoded.
+   * @param maxNumValues The number of values that is to be encoded.
    * @param upperBound  At least the highest value that will be encoded.
    *                For space efficiency this should not exceed the power of two that equals
    *                or is the first higher than the actual maximum.
-   *                <br>When <code>numValues >= (upperBound/3)</code>
+   *                <br>When <code>maxNumValues >= (upperBound/3)</code>
    *                a {@link FixedBitSet} will take less space.
    * @param indexInterval The number of high zero bits for which a single index entry is built.
-   *                The index will have at most <code>2 * numValues / indexInterval</code> entries
-   *                and each index entry will use at most <code>ceil(log2(3 * numValues))</code> bits,
+   *                The index will have at most <code>2 * maxNumValues / indexInterval</code> entries
+   *                and each index entry will use at most <code>ceil(log2(3 * maxNumValues))</code> bits,
    *                see {@link EliasFanoEncoder}.
    * @throws IllegalArgumentException when:
    *         <ul>
-   *         <li><code>numValues</code> is negative, or
-   *         <li><code>numValues</code> is non negative and <code>upperBound</code> is negative, or
+   *         <li><code>maxNumValues</code> is negative, or
+   *         <li><code>maxNumValues</code> is non negative and <code>upperBound</code> is negative, or
    *         <li>the low bits do not fit in a <code>long[]</code>:
-   *             <code>(L * numValues / 64) > Integer.MAX_VALUE</code>, or
+   *             <code>(L * maxNumValues / 64) > Integer.MAX_VALUE</code>, or
    *         <li>the high bits do not fit in a <code>long[]</code>:
-   *             <code>(2 * numValues / 64) > Integer.MAX_VALUE</code>, or
+   *             <code>(2 * maxNumValues / 64) > Integer.MAX_VALUE</code>, or
    *         <li><code>indexInterval < 2</code>,
    *         <li>the index bits do not fit in a <code>long[]</code>:
-   *             <code>(numValues / indexInterval * ceil(2log(3 * numValues)) / 64) > Integer.MAX_VALUE</code>.
+   *             <code>(maxNumValues / indexInterval * ceil(2log(3 * maxNumValues)) / 64) > Integer.MAX_VALUE</code>.
    *         </ul>
    */
-  public EliasFanoEncoder(long numValues, long upperBound, long indexInterval) {
-    if (numValues < 0L) {
-      throw new IllegalArgumentException("numValues should not be negative: " + numValues);
+  public EliasFanoEncoder(long maxNumValues, long upperBound, long indexInterval) {
+    if (maxNumValues < 0L) {
+      throw new IllegalArgumentException("maxNumValues should not be negative: " + maxNumValues);
     }
-    this.numValues = numValues;
-    if ((numValues > 0L) && (upperBound < 0L)) {
-      throw new IllegalArgumentException("upperBound should not be negative: " + upperBound + " when numValues > 0");
+    this.maxNumValues = maxNumValues;
+    if ((maxNumValues > 0L) && (upperBound < 0L)) {
+      throw new IllegalArgumentException("upperBound should not be negative: " + upperBound + " when maxNumValues > 0");
     }
-    this.upperBound = numValues > 0 ? upperBound : -1L; // if there is no value, -1 is the best upper bound
+    this.upperBound = maxNumValues > 0 ? upperBound : -1L; // if there is no value, -1 is the best upper bound
     int nLowBits = 0;
-    if (this.numValues > 0) { // nLowBits = max(0; floor(2log(upperBound/numValues)))
-      long lowBitsFac = this.upperBound / this.numValues;
+    if (this.maxNumValues > 0) { // nLowBits = max(0; floor(2log(upperBound/maxNumValues)))
+      long lowBitsFac = this.upperBound / this.maxNumValues;
       if (lowBitsFac > 0) {
         nLowBits = 63 - Long.numberOfLeadingZeros(lowBitsFac); // see Long.numberOfLeadingZeros javadocs
       }
@@ -153,15 +154,15 @@
     this.numLowBits = nLowBits;
     this.lowerBitsMask = Long.MAX_VALUE >>> (Long.SIZE - 1 - this.numLowBits);
 
-    long numLongsForLowBits = numLongsForBits(numValues * numLowBits);
+    long numLongsForLowBits = numLongsForBits(maxNumValues * numLowBits);
     if (numLongsForLowBits > Integer.MAX_VALUE) {
       throw new IllegalArgumentException("numLongsForLowBits too large to index a long array: " + numLongsForLowBits);
     }
     this.lowerLongs = new long[(int) numLongsForLowBits];
 
     long numHighBitsClear = ((this.upperBound > 0) ? this.upperBound : 0) >>> this.numLowBits;
-    assert numHighBitsClear <= (2 * this.numValues);
-    long numHighBitsSet = this.numValues;
+    assert numHighBitsClear <= (2 * this.maxNumValues);
+    long numHighBitsSet = this.maxNumValues;
 
     long numLongsForHighBits = numLongsForBits(numHighBitsClear + numHighBitsSet);
     if (numLongsForHighBits > Integer.MAX_VALUE) {
@@ -175,10 +176,10 @@
     long maxHighValue = upperBound >>> this.numLowBits;
     long nIndexEntries = maxHighValue / indexInterval; // no zero value index entry
     this.numIndexEntries = (nIndexEntries >= 0) ? nIndexEntries : 0;
-    long maxIndexEntry = maxHighValue + numValues - 1; // clear upper bits, set upper bits, start at zero
-    this.nIndexEntryBits = (maxIndexEntry <= 0) ? 0
+    long maxIndexEntry = maxHighValue + maxNumValues - 1; // clear upper bits, set upper bits, start at zero
+    this.numIndexEntryBits = (maxIndexEntry <= 0) ? 0
                           : (64 - Long.numberOfLeadingZeros(maxIndexEntry - 1));
-    long numLongsForIndexBits = numLongsForBits(numIndexEntries * nIndexEntryBits);
+    long numLongsForIndexBits = numLongsForBits(numIndexEntries * numIndexEntryBits);
     if (numLongsForIndexBits > Integer.MAX_VALUE) {
       throw new IllegalArgumentException("numLongsForIndexBits too large to index a long array: " + numLongsForIndexBits);
     }
@@ -190,8 +191,8 @@
   /**
   * Construct an Elias-Fano encoder using {@link #DEFAULT_INDEX_INTERVAL}.
   */
-  public EliasFanoEncoder(long numValues, long upperBound) {
-    this(numValues, upperBound, DEFAULT_INDEX_INTERVAL);
+  public EliasFanoEncoder(long maxNumValues, long upperBound) {
+    this(maxNumValues, upperBound, DEFAULT_INDEX_INTERVAL);
   }
 
   private static long numLongsForBits(long numBits) { // Note: int version in FixedBitSet.bits2words()
@@ -199,9 +200,9 @@
     return (numBits + (Long.SIZE-1)) >>> LOG2_LONG_SIZE;
   }
 
-  /** Call at most <code>numValues</code> times to encode a non decreasing sequence of non negative numbers.
+  /** Call at most <code>maxNumValues</code> times to encode a non decreasing sequence of non negative numbers.
    * @param x The next number to be encoded.
-   * @throws IllegalStateException when called more than <code>numValues</code> times.
+   * @throws IllegalStateException when called more than <code>maxNumValues</code> times.
    * @throws IllegalArgumentException when:
    *         <ul>
    *         <li><code>x</code> is smaller than an earlier encoded value, or
@@ -209,8 +210,8 @@
    *         </ul>
    */
   public void encodeNext(long x) {
-    if (numEncoded >= numValues) {
-      throw new IllegalStateException("encodeNext called more than " + numValues + " times.");
+    if (numEncoded >= maxNumValues) {
+      throw new IllegalStateException("encodeNext called more than " + maxNumValues + " times.");
     }
     if (lastEncoded > x) {
       throw new IllegalArgumentException(x + " smaller than previous " + lastEncoded);
@@ -226,7 +227,7 @@
     long indexValue = (currentEntryIndex + 1) * indexInterval;
     while (indexValue <= highValue) { 
       long afterZeroBitPosition = indexValue + numEncoded;
-      packValue(afterZeroBitPosition, upperZeroBitPositionIndex, nIndexEntryBits, currentEntryIndex);
+      packValue(afterZeroBitPosition, upperZeroBitPositionIndex, numIndexEntryBits, currentEntryIndex);
       currentEntryIndex += 1;
       indexValue += indexInterval;
     }
@@ -253,37 +254,66 @@
       }
     }
   }
+  
+  private long[] reallocSmaller(long[] ar, int newLength) {
+    assert newLength <= ar.length : "newLength " + newLength + " should be at most " + ar.length;
+    return (newLength < ar.length) 
+            ? Arrays.copyOf(ar, newLength) 
+            : ar;
+  }
 
-  /** Provide an indication that it is better to use an {@link EliasFanoEncoder} than a {@link FixedBitSet}
-   *  to encode document identifiers.
+  /**
+   * Reduce the allocated size to the minimal size needed for the currently encoded values.
+   * <br>Call this method at most once. Do not call {@link #encodeNext} after this.
+   */
+  public void freeze() {
+    if (numEncoded < maxNumValues) {
+      upperLongs = reallocSmaller(upperLongs,
+                            (int) numLongsForBits(numEncoded + (lastEncoded >> numLowBits)));
+
+      lowerLongs = reallocSmaller(lowerLongs,
+                            (int) numLongsForBits(numEncoded * numLowBits));
+  
+      upperZeroBitPositionIndex = reallocSmaller(upperZeroBitPositionIndex,
+                            (int) numLongsForBits(currentEntryIndex * numIndexEntryBits));
+    }
+  }
+
+  /** Provide a maximum number of values above which it is better to use a {@link FixedBitSet}
+   *  than a {@link EliasFanoEncoder} to encode and decode a sequence with a given upperBound.
    *  This indication is not precise and may change in the future.
-   *  <br>An EliasFanoEncoder is favoured when the size of the encoding by the EliasFanoEncoder
-   *  (including some space for its index) is at most about 5/6 of the size of the FixedBitSet,
-   *  this is the same as comparing estimates of the number of bits accessed by a pair of FixedBitSets and
-   *  by a pair of non indexed EliasFanoDocIdSets when determining the intersections of the pairs.
-   *  <br>A bit set is preferred when <code>upperbound <= 256</code>.
-   *  <br>It is assumed that {@link #DEFAULT_INDEX_INTERVAL} is used.
-   *  @param numValues The number of document identifiers that is to be encoded. Should be non negative.
-   *  @param upperBound The maximum possible value for a document identifier. Should be at least <code>numValues</code>.
+   *  <br>It is assumed the index uses {@link #DEFAULT_INDEX_INTERVAL}.
+   *  <br>A bit set is always preferred when <code>upperbound < 256</code>.
+   *  @param upperBound The maximum possible value for a document identifier.
    */
-  public static boolean sufficientlySmallerThanBitSet(long numValues, long upperBound) {
-    /* When (upperBound / 6) == numValues,
-     * the number of bits per entry for the EliasFanoEncoder is 2 + ceil(2log(upperBound/numValues)) == 5.
-     *
+  public static long preferredMaxNumValues(long upperBound) {
+    /* When (upperBound / 6) == maxNumValues,
+     * the number of bits per entry for the EliasFanoEncoder is 2 + ceil(2log(upperBound/maxNumValues)) == 5.
      * For intersecting two bit sets upperBound bits are accessed, roughly half of one, half of the other.
      * For intersecting two EliasFano sequences without index on the upper bits,
-     * all (2 * 3 * numValues) upper bits are accessed.
+     * all (2 * 3 * maxNumValues) upper bits are accessed.
      */
-    return (upperBound > (4 * Long.SIZE)) // prefer a bit set when it takes no more than 4 longs.
-            && (upperBound / 7) > numValues; // 6 + 1 to allow some room for the index.
+    return (upperBound < (4 * Long.SIZE))
+          ? 0 // prefer a bit set when it takes no more than 4 longs.
+          : (upperBound / 7); // 6 for intersection as above, + 1 to allow room for the index.
   }
+  
+  /**
+   * Returns the number of encoded values.
+   */
+  public long numEncoded() {
+    return numEncoded;
+  }
 
   /**
    * Returns an {@link EliasFanoDecoder} to access the encoded values.
-   * Perform all calls to {@link #encodeNext} before calling {@link #getDecoder}.
+   * Perform all calls to {@link #encodeNext} and {@link #freeze} before calling {@link #getDecoder}.
+   * <p>
+   * When the actual last encoded value divided by the actual number of encoded values
+   * differs from the given <code>upperBound</code> divided by the given <code>maxNumValues</code>
+   * by at least a factor of 2, a better compression would have been possible and the decoding speed may be reduced.
    */
   public EliasFanoDecoder getDecoder() {
-    // decode as far as currently encoded as determined by numEncoded.
     return new EliasFanoDecoder(this);
   }
 
@@ -305,7 +335,7 @@
   @Override
   public String toString() {
     StringBuilder s = new StringBuilder("EliasFanoSequence");
-    s.append(" numValues " + numValues);
+    s.append(" maxNumValues " + maxNumValues);
     s.append(" numEncoded " + numEncoded);
     s.append(" upperBound " + upperBound);
     s.append(" lastEncoded " + lastEncoded);
@@ -318,7 +348,7 @@
     for (int i = 0; i < lowerLongs.length; i++) {
       s.append(" " + ToStringUtils.longHex(lowerLongs[i]));
     }
-    s.append("\nindexInterval: " + indexInterval + ", nIndexEntryBits: " + nIndexEntryBits);
+    s.append("\nindexInterval: " + indexInterval + ", numIndexEntryBits: " + numIndexEntryBits);
     s.append("\nupperZeroBitPositionIndex[" + upperZeroBitPositionIndex.length + "]");
     for (int i = 0; i < upperZeroBitPositionIndex.length; i++) { 
       s.append(" " + ToStringUtils.longHex(upperZeroBitPositionIndex[i]));
@@ -333,7 +363,7 @@
     }
     EliasFanoEncoder oefs = (EliasFanoEncoder) other;
     // no equality needed for upperBound
-    return (this.numValues == oefs.numValues)
+    return (this.maxNumValues == oefs.maxNumValues)
         && (this.numEncoded == oefs.numEncoded)
         && (this.numLowBits == oefs.numLowBits)
         && (this.numIndexEntries == oefs.numIndexEntries)
@@ -344,7 +374,7 @@
 
   @Override
   public int hashCode() {
-    int h = ((int) (31*(numValues + 7*(numEncoded + 5*(numLowBits + 3*(numIndexEntries + 11*indexInterval))))))
+    int h = ((int) (31*(maxNumValues + 7*(numEncoded + 5*(numLowBits + 3*(numIndexEntries + 11*indexInterval))))))
             ^ Arrays.hashCode(upperLongs)
             ^ Arrays.hashCode(lowerLongs);
     return h;
Index: core/src/java/org/apache/lucene/util/packed/EliasFanoDecoder.java
===================================================================
--- core/src/java/org/apache/lucene/util/packed/EliasFanoDecoder.java	(revision 1534073)
+++ core/src/java/org/apache/lucene/util/packed/EliasFanoDecoder.java	(working copy)
@@ -35,15 +35,23 @@
 
   private final long numIndexEntries;
   private final long indexMask;
+  
+  private final long[] upperLongs;
+  private final long[] lowerLongs;
+  private final long[] upperZeroBitPositionIndex;
 
   /** Construct a decoder for a given {@link EliasFanoEncoder}.
    * The decoding index is set to just before the first encoded value.
    */
   public EliasFanoDecoder(EliasFanoEncoder efEncoder) {
     this.efEncoder = efEncoder;
-    this.numEncoded = efEncoder.numEncoded; // not final in EliasFanoEncoder
-    this.numIndexEntries = efEncoder.currentEntryIndex;  // not final in EliasFanoEncoder
-    this.indexMask = (1L << efEncoder.nIndexEntryBits) - 1;
+    this.indexMask = (1L << efEncoder.numIndexEntryBits) - 1;
+    // not final in EliasFanoEncoder:
+    this.numEncoded = efEncoder.numEncoded;
+    this.numIndexEntries = efEncoder.currentEntryIndex;
+    this.upperLongs = efEncoder.upperLongs;
+    this.lowerLongs = efEncoder.lowerLongs;
+    this.upperZeroBitPositionIndex = efEncoder.upperZeroBitPositionIndex;
   }
 
   /** @return The Elias-Fano encoder that is decoded. */
@@ -111,7 +119,7 @@
   /**  @return The low value for the current decoding index. */
   private long currentLowValue() {
     assert ((efIndex >= 0) && (efIndex < numEncoded)) : "efIndex " + efIndex;
-    return unPackValue(efEncoder.lowerLongs, efEncoder.numLowBits, efIndex, efEncoder.lowerBitsMask);
+    return unPackValue(lowerLongs, efEncoder.numLowBits, efIndex, efEncoder.lowerBitsMask);
   }
 
   /**  @return The given highValue shifted left by the number of low bits from by the EliasFanoSequence,
@@ -163,7 +171,7 @@
     }
     setBitForIndex += 1;
     int highIndex = (int)(setBitForIndex >>> LOG2_LONG_SIZE);
-    curHighLong = efEncoder.upperLongs[highIndex] >>> getCurrentRightShift();
+    curHighLong = upperLongs[highIndex] >>> getCurrentRightShift();
     return true;
   }
 
@@ -174,7 +182,7 @@
     setBitForIndex += Long.SIZE - (setBitForIndex & (Long.SIZE-1));
     //assert getCurrentRightShift() == 0;
     int highIndex = (int)(setBitForIndex >>> LOG2_LONG_SIZE);
-    curHighLong = efEncoder.upperLongs[highIndex];
+    curHighLong = upperLongs[highIndex];
   }
 
   /** setBitForIndex and efIndex have just been incremented, scan to the next high set bit
@@ -256,7 +264,7 @@
     setBitForIndex += 1; // the high bit at setBitForIndex belongs to the unary code for efIndex
 
     int highIndex = (int)(setBitForIndex >>> LOG2_LONG_SIZE);
-    long upperLong = efEncoder.upperLongs[highIndex];
+    long upperLong = upperLongs[highIndex];
     curHighLong = upperLong >>> ((int) (setBitForIndex & (Long.SIZE-1))); // may contain the unary 1 bit for efIndex
 
     // determine index entry to advance to
@@ -270,10 +278,10 @@
       long indexHighValue = (indexEntryIndex + 1) * efEncoder.indexInterval;
       assert indexHighValue <= highTarget;
       if (indexHighValue > (setBitForIndex - efIndex)) { // advance to just after zero bit position of index entry.
-        setBitForIndex = unPackValue(efEncoder.upperZeroBitPositionIndex, efEncoder.nIndexEntryBits, indexEntryIndex, indexMask);
+        setBitForIndex = unPackValue(upperZeroBitPositionIndex, efEncoder.numIndexEntryBits, indexEntryIndex, indexMask);
         efIndex = setBitForIndex - indexHighValue; // the high bit at setBitForIndex belongs to the unary code for efIndex
         highIndex = (int)(setBitForIndex >>> LOG2_LONG_SIZE);
-        upperLong = efEncoder.upperLongs[highIndex];
+        upperLong = upperLongs[highIndex];
         curHighLong = upperLong >>> ((int) (setBitForIndex & (Long.SIZE-1))); // may contain the unary 1 bit for efIndex
       }
       assert efIndex < numEncoded; // there is a high value to be found.
@@ -292,7 +300,7 @@
       // highIndex = (int)(setBitForIndex >>> LOG2_LONG_SIZE);
       assert (highIndex + 1) == (int)(setBitForIndex >>> LOG2_LONG_SIZE);
       highIndex += 1;
-      upperLong = efEncoder.upperLongs[highIndex];
+      upperLong = upperLongs[highIndex];
       curHighLong = upperLong;
       curSetBits = Long.bitCount(curHighLong);
       curClearBits = Long.SIZE - curSetBits;
@@ -302,7 +310,7 @@
       setBitForIndex += Long.SIZE - (setBitForIndex & (Long.SIZE-1));
       assert (highIndex + 1) == (int)(setBitForIndex >>> LOG2_LONG_SIZE);
       highIndex += 1;
-      upperLong = efEncoder.upperLongs[highIndex];
+      upperLong = upperLongs[highIndex];
       curHighLong = upperLong;
     }
 
@@ -325,7 +333,7 @@
       if ((setBitForIndex & (Long.SIZE - 1)) == 0L) { // exhausted curHighLong
         assert (highIndex + 1) == (int)(setBitForIndex >>> LOG2_LONG_SIZE);
         highIndex += 1;
-        upperLong = efEncoder.upperLongs[highIndex];
+        upperLong = upperLongs[highIndex];
         curHighLong = upperLong;
       }
       else {
@@ -338,7 +346,7 @@
         setBitForIndex += Long.SIZE - (setBitForIndex & (Long.SIZE-1));
         assert (highIndex + 1) == (int)(setBitForIndex >>> LOG2_LONG_SIZE);
         highIndex += 1;
-        upperLong = efEncoder.upperLongs[highIndex];
+        upperLong = upperLongs[highIndex];
         curHighLong = upperLong;
       }
     }
@@ -383,7 +391,7 @@
     }
     setBitForIndex -= 1;
     int highIndex = (int)(setBitForIndex >>> LOG2_LONG_SIZE);
-    curHighLong = efEncoder.upperLongs[highIndex] << getCurrentLeftShift();
+    curHighLong = upperLongs[highIndex] << getCurrentLeftShift();
     return true;
   }
 
@@ -394,7 +402,7 @@
     setBitForIndex -= (setBitForIndex & (Long.SIZE-1)) + 1;
     //assert getCurrentLeftShift() == 0;
     int highIndex = (int)(setBitForIndex >>> LOG2_LONG_SIZE);
-    curHighLong = efEncoder.upperLongs[highIndex];
+    curHighLong = upperLongs[highIndex];
   }
 
   /** setBitForIndex and efIndex have just been decremented, scan to the previous high set bit
Index: core/src/java/org/apache/lucene/util/packed/EliasFanoEncoderUpperBound.java
===================================================================
--- core/src/java/org/apache/lucene/util/packed/EliasFanoEncoderUpperBound.java	(revision 0)
+++ core/src/java/org/apache/lucene/util/packed/EliasFanoEncoderUpperBound.java	(revision 0)
@@ -0,0 +1,128 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.util.packed;
+
+
+/** An EliasFanoEncoder that only needs a given upperbound for the values to be encoded.
+ *  <br>The current implementation delegates to {@link EliasFanoEncoder} by choosing
+ *  maximum numbers of encoded values appropriately.
+ *  When compared to {@link EliasFanoEncoder} this uses at most twice the memory 
+ *  and has a slightly reduced performance for {@link EliasFanoDecoder#nextValue} 
+ *  and {@link EliasFanoDecoder#advanceToValue}. 
+ * @lucene.internal
+ */
+public class EliasFanoEncoderUpperBound {
+  static final long MAX_UPPER_INITIAL_SIZE = 1L << 8; // 256, power of 2, see also oversize comment at end of constructor.
+  EliasFanoEncoder efEncoder;
+  long currentNumValues;
+  final long upperBound;
+
+  /**
+   * Construct an Elias-Fano encoder that only needs an upperbound.
+   * After construction, call {@link #encodeNext} to encode
+   * a non decreasing sequence of non negative numbers.
+   * @param upperBound  At least the highest value that will be encoded.
+   */
+  public EliasFanoEncoderUpperBound(long upperBound) {
+    if (upperBound <= 0) {
+      upperBound = 0;
+    }
+    this.upperBound = upperBound;
+    // Choose initial currentNumValues so that when repeatedly multiplied by 2
+    // it will be just bigger than the max preferred size for Elias-Fano.
+    // This minimizes the reEncoding memory allocation before a bit set is preferable.
+    if (this.upperBound <= MAX_UPPER_INITIAL_SIZE) { // Small upperBound, may prefer a bit set, but anyway
+      this.currentNumValues = this.upperBound;
+    }
+    else { // this.upperBound > MAX_UPPER_INITIAL_SIZE
+      long workNumValues = EliasFanoEncoder.preferredMaxNumValues(this.upperBound);
+      if (workNumValues <= 1) { // not likely
+        workNumValues = 1;
+      }
+      int rightShift = Long.numberOfLeadingZeros(MAX_UPPER_INITIAL_SIZE) - Long.numberOfLeadingZeros(workNumValues) + 1;
+      if (rightShift > 0) {
+        workNumValues >>>= rightShift; // divide by 2 until smaller than MAX_UPPER_INITIAL_SIZE (power of 2)
+      }
+      assert workNumValues < MAX_UPPER_INITIAL_SIZE;
+      assert workNumValues >= 1;
+      this.currentNumValues = workNumValues + 1;
+      // Add 1 so repeated multiplication by 2 will oversize this to just bigger than the preferred maximum,
+      // but normally by no more than a factor 2/MAX_UPPER_INITIAL_SIZE, i.e. at most 1/128 bigger for 256.
+      // The normal case is when the preferred maximum value is at least MAX_UPPER_INITIAL_SIZE.
+      assert this.currentNumValues < this.upperBound; // because this.upperBound > MAX_UPPER_INITIAL_SIZE
+    }
+    efEncoder = new EliasFanoEncoder(this.currentNumValues, this.upperBound);
+  }
+
+  private void reEncode() {
+    EliasFanoEncoder nextEfEncoder = new EliasFanoEncoder(currentNumValues, upperBound);
+    EliasFanoDecoder efDecoder = getDecoder();
+    long value = efDecoder.nextValue();
+    while (value != EliasFanoDecoder.NO_MORE_VALUES) {
+      nextEfEncoder.encodeNext(value);
+      value = efDecoder.nextValue();
+    }
+    efEncoder = nextEfEncoder;      
+  }
+
+  /** Call to encode a non decreasing sequence of non negative numbers.
+   * @param x The next number to be encoded, this should not exceed <code>upperBound</code>.
+   */
+  public void encodeNext(long x) {
+    if (efEncoder.numEncoded() == currentNumValues) {
+      currentNumValues *= 2;
+      reEncode();
+    }
+    efEncoder.encodeNext(x);
+  }
+
+  /**
+   * Returns the number of encoded values.
+   */
+  public long numEncoded() {
+    return efEncoder.numEncoded();
+  }
+
+  /** Expert. The current encoder */
+  public EliasFanoEncoder getEncoder() {
+    return efEncoder;
+  }
+
+
+  /**
+   * Returns an {@link EliasFanoDecoder} to access the encoded values.
+   * Perform all calls to {@link #encodeNext} before calling {@link #getDecoder}.
+   */
+  public EliasFanoDecoder getDecoder() {
+    return efEncoder.getDecoder();
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (! (other instanceof EliasFanoEncoderUpperBound)) {
+      return false;
+    }
+    return efEncoder.equals(((EliasFanoEncoderUpperBound)other).efEncoder);
+  }
+
+  @Override
+  public int hashCode() {
+    return getClass().hashCode() ^ efEncoder.hashCode();
+  }
+}
+
Index: core/src/java/org/apache/lucene/util/packed/EliasFanoDocIdSet.java
===================================================================
--- core/src/java/org/apache/lucene/util/packed/EliasFanoDocIdSet.java	(revision 1534073)
+++ core/src/java/org/apache/lucene/util/packed/EliasFanoDocIdSet.java	(working copy)
@@ -22,62 +22,127 @@
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.DocIdSetIterator;
 
-import org.apache.lucene.util.FixedBitSet; // for javadocs
+import org.apache.lucene.util.FixedBitSet;
 
 
-/** A DocIdSet in Elias-Fano encoding.
+/** A DocIdSet that uses Elias-Fano encoding or bit set encoding when that is more memory efficient.
+ * <br> CHECKME: name ok?
  * @lucene.internal
  */
 public class EliasFanoDocIdSet extends DocIdSet {
-  final EliasFanoEncoder efEncoder;
+  EliasFanoEncoder efEncoder = null;
+  EliasFanoEncoderUpperBound efEncoderUb = null;
+  FixedBitSet fbs = null;
+  final int numDocIds;
+  final int upperBound;
 
   /**
-   * Construct an EliasFanoDocIdSet. For efficient encoding, the parameters should be chosen as low as possible.
-   * @param numValues At least the number of document ids that will be encoded.
+   * Construct an EliasFanoDocIdSet. 
+   * @param numDocIds When non negative, at least the number of document ids that will be encoded.
+   *                  When negative, the number of doc ids is assumed to be not known in advance.
+   *                  For efficient encoding this should be chosen non negative,
+   *                  and as little as possible bigger than the number of docs.
    * @param upperBound  At least the highest document id that will be encoded.
+   *                    Should be chosen as low as possible for efficient encoding.
    */
-  public EliasFanoDocIdSet(int numValues, int upperBound) {
-    efEncoder = new EliasFanoEncoder(numValues, upperBound);
+  public EliasFanoDocIdSet(int numDocIds, int upperBound) {
+    this.upperBound = (upperBound < 0) ? 0 : upperBound;
+    this.numDocIds = numDocIds;
+    if (numDocIds >= 0) {
+      if (numDocIds <= EliasFanoEncoder.preferredMaxNumValues(upperBound)) {
+        this.efEncoder = new EliasFanoEncoder(numDocIds, upperBound);
+      }
+      else {
+        this.fbs = newFixedBitSet();
+      }
+    }
+    else { // numDocIds not known in advance
+      this.efEncoderUb = new EliasFanoEncoderUpperBound(upperBound);
+    }
   }
-
-  /** Provide an indication that is better to use an {@link EliasFanoDocIdSet} than a {@link FixedBitSet}
-   *  to encode document identifiers.
-   *  @param numValues The number of document identifiers that is to be encoded. Should be non negative.
-   *  @param upperBound The maximum possible value for a document identifier. Should be at least <code>numValues</code>.
-   *  @return See {@link EliasFanoEncoder#sufficientlySmallerThanBitSet(long, long)}
-   */
-  public static boolean sufficientlySmallerThanBitSet(long numValues, long upperBound) {
-    return EliasFanoEncoder.sufficientlySmallerThanBitSet(numValues, upperBound);
+  
+  private FixedBitSet newFixedBitSet() {
+    return new FixedBitSet(upperBound + 1);
   }
 
   /** Encode the document ids from a DocIdSetIterator.
    *  @param disi This DocIdSetIterator should provide document ids that are consistent
-   *              with <code>numValues</code> and <code>upperBound</code> as provided to the constructor.  
+   *              with <code>numValues</code> (if any) and <code>upperBound</code> as provided to the constructor.  
    */
   public void encodeFromDisi(DocIdSetIterator disi) throws IOException {
-    while (efEncoder.numEncoded < efEncoder.numValues) {
-      int x = disi.nextDoc();
-      if (x == DocIdSetIterator.NO_MORE_DOCS) {
-        throw new IllegalArgumentException("disi: " + disi.toString()
-            + "\nhas " + efEncoder.numEncoded
-            + " docs, but at least " + efEncoder.numValues + " are required.");
+    if (fbs != null) {
+      encodeFromDisi(fbs, disi);
+    }
+    else if (efEncoder != null) {
+      encodeFromDisi(efEncoder, disi);
+      efEncoder.freeze();
+    }
+    else if (efEncoderUb != null) {
+      long maxNumDocIdsEF = EliasFanoEncoder.preferredMaxNumValues(upperBound);
+      int docId = disi.nextDoc();
+      while ((docId != DocIdSetIterator.NO_MORE_DOCS) && (efEncoderUb.numEncoded() < maxNumDocIdsEF)) {
+        efEncoderUb.encodeNext(docId);
+        docId = disi.nextDoc();
       }
-      efEncoder.encodeNext(x);
+      if (docId != DocIdSetIterator.NO_MORE_DOCS) { // more than preferred number of values, change to FixedBitSet
+        fbs = newFixedBitSet();
+        encodeFromEfDecoder(fbs, docId, efEncoderUb.getDecoder());
+        efEncoderUb = null;
+        encodeFromDisi(fbs, disi);
+      } else {
+        efEncoderUb.getEncoder().freeze();
+      }
     }
+    else throw new IllegalStateException("no encoder for encoding");
   }
+  
+  private void encodeFromDisi(EliasFanoEncoder efEncoder, DocIdSetIterator disi) throws IOException {
+    int docId = disi.nextDoc();
+    while (docId != DocIdSetIterator.NO_MORE_DOCS) {
+      efEncoder.encodeNext(docId);
+      docId = disi.nextDoc();
+    }
+  }
 
+  private void encodeFromDisi(FixedBitSet fbs, DocIdSetIterator disi) throws IOException {
+    int docId = disi.nextDoc();
+    while (docId != DocIdSetIterator.NO_MORE_DOCS) {
+      if (docId > upperBound) {
+        throw new IllegalArgumentException("docId " + docId + " higher than upperBound " + upperBound);
+      }
+      fbs.set(docId);
+      docId = disi.nextDoc();
+    }
+  }
+
+  private void encodeFromEfDecoder(FixedBitSet fbs, long docId, EliasFanoDecoder efDecoder) {
+    while (docId != EliasFanoDecoder.NO_MORE_VALUES) {
+      assert docId <= upperBound;
+      fbs.set((int) docId);
+      docId = efDecoder.nextValue();
+    }
+  }
+
   /**
    * Provides a {@link DocIdSetIterator} to access encoded document ids.
    */
   @Override
   public DocIdSetIterator iterator() {
-    if (efEncoder.lastEncoded >= DocIdSetIterator.NO_MORE_DOCS) {
-      throw new UnsupportedOperationException(
-          "Highest encoded value too high for DocIdSetIterator.NO_MORE_DOCS: " + efEncoder.lastEncoded);
+    if (fbs != null) {
+      return fbs.iterator();
     }
+
+    final EliasFanoDecoder efDecoder;
+    if (efEncoder != null) {
+      efDecoder = efEncoder.getDecoder();
+    }
+    else if (efEncoderUb != null) {
+      efDecoder = efEncoderUb.getDecoder();
+    }
+    else throw new IllegalStateException("no encoder for iterator");
+
     return new DocIdSetIterator() {
       private int curDocId = -1;
-      private final EliasFanoDecoder efDecoder = efEncoder.getDecoder();
 
       @Override
       public int docID() {
@@ -86,8 +151,8 @@
 
       private int setCurDocID(long value) {
         curDocId = (value == EliasFanoDecoder.NO_MORE_VALUES)
-            ?  NO_MORE_DOCS
-                : (int) value;
+                  ?  NO_MORE_DOCS
+                  : (int) value;
         return curDocId;
       }
 
@@ -116,15 +181,51 @@
     return true;
   }
 
+  /** The number of document ids in the set.
+   * This should only be called after {@link #encodeFromDisi} was called.
+   * @return <code>true</code>
+   */
   @Override
+  public int numDocIds() {
+    if (efEncoder != null) {
+      return (int) efEncoder.numEncoded();
+    }
+    else if (fbs != null) {
+      return fbs.numDocIds();
+    }
+    else if (efEncoderUb != null) {
+      return (int) efEncoderUb.numEncoded();
+    }
+    else throw new IllegalStateException("no encoder for numDocIds");
+  }
+
+  @Override
   public boolean equals(Object other) {
-    return ((other instanceof EliasFanoDocIdSet))
-        && efEncoder.equals(((EliasFanoDocIdSet) other).efEncoder);
+    return (other instanceof EliasFanoDocIdSet)
+        && (
+                ((efEncoder != null) && efEncoder.equals(((EliasFanoDocIdSet) other).efEncoder))
+            || ((efEncoderUb != null) && efEncoderUb.equals(((EliasFanoDocIdSet) other).efEncoder))
+            || ((fbs != null) && fbs.equals(((EliasFanoDocIdSet) other).fbs))
+           );
   }
 
   @Override
   public int hashCode() {
-    return efEncoder.hashCode() ^ getClass().hashCode();
+    return getClass().hashCode()
+            ^ ((efEncoder != null) ? efEncoder.hashCode()
+             : (efEncoderUb != null) ? efEncoderUb.hashCode()
+             : (fbs != null) ? fbs.hashCode()
+             : 0 );
   }
+  
+  public String toString() {
+    StringBuilder sb = new StringBuilder("EliasFanoDocIdSet(");
+    sb.append(" efEncoder = " + ((efEncoder != null) ? efEncoder.getClass() : efEncoder));
+    sb.append(", efEncoderUb = " + ((efEncoderUb != null) ? efEncoderUb.getClass() : efEncoderUb) );
+    sb.append(", fbs = " + ((fbs != null) ? fbs.getClass() : fbs) );
+    sb.append(", upperBound = " + upperBound);
+    sb.append(")");
+    return sb.toString();
+  }
 }
 
Index: core/src/test/org/apache/lucene/util/packed/TestEliasFanoDocIdSet.java
===================================================================
--- core/src/test/org/apache/lucene/util/packed/TestEliasFanoDocIdSet.java	(revision 1534073)
+++ core/src/test/org/apache/lucene/util/packed/TestEliasFanoDocIdSet.java	(working copy)
@@ -27,7 +27,10 @@
 
   @Override
   public EliasFanoDocIdSet copyOf(final BitSet bs, final int numBits) throws IOException {
-    final EliasFanoDocIdSet set = new EliasFanoDocIdSet(bs.cardinality(), numBits - 1);
+    final EliasFanoDocIdSet set =  new EliasFanoDocIdSet(
+                                          ((random().nextBoolean()) ? bs.cardinality() : -1),
+                                          (numBits - 1) );
+
     set.encodeFromDisi(new DocIdSetIterator() {
       int doc = -1;
 
@@ -37,7 +40,9 @@
         if (doc == -1) {
           doc = NO_MORE_DOCS;
         }
-        assert doc < numBits;
+        else {
+          assert doc < numBits;
+        }
         return doc;
       }
       
Index: core/src/java/org/apache/lucene/search/DocIdSet.java
===================================================================
--- core/src/java/org/apache/lucene/search/DocIdSet.java	(revision 1534073)
+++ core/src/java/org/apache/lucene/search/DocIdSet.java	(working copy)
@@ -42,20 +42,32 @@
    * external disk access (as {@link Bits} interface cannot throw
    * {@link IOException}). This is generally true for bit sets
    * like {@link org.apache.lucene.util.FixedBitSet}, which return
-   * itself if they are used as {@code DocIdSet}.
+   * themselves if they are used as {@code DocIdSet}.
    */
   public Bits bits() throws IOException {
     return null;
   }
 
   /**
-   * This method is a hint for {@link CachingWrapperFilter}, if this <code>DocIdSet</code>
-   * should be cached without copying it. The default is to return
-   * <code>false</code>. If you have an own <code>DocIdSet</code> implementation
+   * This method is a hint for {@link CachingWrapperFilter} that this <code>DocIdSet</code>
+   * can be cached. The default is to return <code>false</code>.
+   * <br>If you have an own <code>DocIdSet</code> implementation
    * that does its iteration very effective and fast without doing disk I/O,
    * override this method and return <code>true</code>.
    */
   public boolean isCacheable() {
     return false;
   }
+
+  /**
+   * This method is a hint for {@link CachingWrapperFilter} to choose a <code>DocIdSet</code>
+   * to be cached.
+   * When this method returns a non negative number, that number should be the number of document ids in the set.
+   * The default is to return <code>-1</code>.
+   * <br>If you have an own <code>DocIdSet</code> implementation that can provide this number fast, 
+   * override this method and return the number of document ids in the set.
+   */
+  public int numDocIds() throws IOException {
+    return -1;
+  }
 }
Index: core/src/java/org/apache/lucene/search/CachingWrapperFilter.java
===================================================================
--- core/src/java/org/apache/lucene/search/CachingWrapperFilter.java	(revision 1534073)
+++ core/src/java/org/apache/lucene/search/CachingWrapperFilter.java	(working copy)
@@ -29,6 +29,9 @@
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.RamUsageEstimator;
 import org.apache.lucene.util.WAH8DocIdSet;
+import org.apache.lucene.util.packed.EliasFanoDocIdSet;
+import org.apache.lucene.util.FixedBitSet;
+import org.apache.lucene.util.OpenBitSet;
 
 /**
  * Wraps another {@link Filter}'s result and caches it.  The purpose is to allow
@@ -58,7 +61,7 @@
    *  Provide the DocIdSet to be cached, using the DocIdSet provided
    *  by the wrapped Filter. <p>This implementation returns the given {@link DocIdSet},
    *  if {@link DocIdSet#isCacheable} returns <code>true</code>, else it calls
-   *  {@link #cacheImpl(DocIdSetIterator,AtomicReader)}
+   *  {@link #cacheImpl}.
    *  <p>Note: This method returns {@linkplain #EMPTY_DOCIDSET} if the given docIdSet
    *  is <code>null</code> or if {@link DocIdSet#iterator()} return <code>null</code>. The empty
    *  instance is use as a placeholder in the cache instead of the <code>null</code> value.
@@ -77,18 +80,31 @@
       if (it == null) {
         return EMPTY_DOCIDSET;
       } else {
-        return cacheImpl(it, reader);
+        return cacheImpl(docIdSet, it, reader);
       }
     }
   }
   
   /**
-   * Default cache implementation: uses {@link WAH8DocIdSet}.
+   * Default cache implementation.
+   * <br> NOCOMMIT: LUCENE-5293 added DocIdSet argument.
    */
-  protected DocIdSet cacheImpl(DocIdSetIterator iterator, AtomicReader reader) throws IOException {
-    WAH8DocIdSet.Builder builder = new WAH8DocIdSet.Builder();
-    builder.add(iterator);
-    return builder.build();
+  protected DocIdSet cacheImpl(DocIdSet docIdSet, DocIdSetIterator iterator, AtomicReader reader) throws IOException {
+    if (docIdSet instanceof EliasFanoDocIdSet) {
+      return docIdSet;
+    }
+    int upperBound;
+    if (docIdSet instanceof FixedBitSet) {
+      FixedBitSet fbs = (FixedBitSet) docIdSet;
+      upperBound = fbs.prevSetBit(fbs.length() - 1);
+    }
+    else {
+      upperBound = reader.maxDoc() - 1;
+    }
+    int numDocIds = docIdSet.numDocIds();
+    EliasFanoDocIdSet efDis = new EliasFanoDocIdSet(numDocIds, upperBound);
+    efDis.encodeFromDisi(iterator);
+    return efDis;
   }
 
   // for testing
Index: core/src/java/org/apache/lucene/search/QueryWrapperFilter.java
===================================================================
--- core/src/java/org/apache/lucene/search/QueryWrapperFilter.java	(revision 1534073)
+++ core/src/java/org/apache/lucene/search/QueryWrapperFilter.java	(working copy)
@@ -20,6 +20,7 @@
 import java.io.IOException;
 
 import org.apache.lucene.index.AtomicReaderContext;
+import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.util.Bits;
 
 /** 
@@ -51,7 +52,8 @@
   @Override
   public DocIdSet getDocIdSet(final AtomicReaderContext context, final Bits acceptDocs) throws IOException {
     // get a private context that is used to rewrite, createWeight and score eventually
-    final AtomicReaderContext privateContext = context.reader().getContext();
+    final AtomicReader reader = context.reader();
+    final AtomicReaderContext privateContext = reader.getContext();
     final Weight weight = new IndexSearcher(privateContext).createNormalizedWeight(query);
     return new DocIdSet() {
       @Override
@@ -60,6 +62,16 @@
       }
       @Override
       public boolean isCacheable() { return false; }
+
+      /** When a TermQuery is wrapped its document frequency is returned, otherwise -1. */
+      @Override
+      public int numDocIds() throws IOException {
+        if (query instanceof TermQuery) {
+          return reader.docFreq(((TermQuery) query).getTerm());
+        } else {
+          return -1;
+        }
+      }
     };
   }
 
@@ -79,4 +91,5 @@
   public int hashCode() {
     return query.hashCode() ^ 0x923F64B9;
   }
+
 }
Index: core/src/java/org/apache/lucene/util/WAH8DocIdSet.java
===================================================================
--- core/src/java/org/apache/lucene/util/WAH8DocIdSet.java	(revision 1534073)
+++ core/src/java/org/apache/lucene/util/WAH8DocIdSet.java	(working copy)
@@ -490,6 +490,11 @@
   }
 
   @Override
+  public int numDocIds() {
+    return cardinality;
+  }
+
+  @Override
   public Iterator iterator() {
     return new Iterator(data, cardinality, indexInterval, positions, wordNums);
   }
Index: core/src/java/org/apache/lucene/util/FixedBitSet.java
===================================================================
--- core/src/java/org/apache/lucene/util/FixedBitSet.java	(revision 1534073)
+++ core/src/java/org/apache/lucene/util/FixedBitSet.java	(working copy)
@@ -97,6 +97,15 @@
     return true;
   }
 
+  /** The number of document ids in the set.
+   * @return <code>The value returned by {@link #cardinality}.</code>
+   */
+  @Override
+  public int numDocIds() {
+    return cardinality();
+  }
+
+
   /** Expert. */
   public long[] getBits() {
     return bits;
Index: core/src/java/org/apache/lucene/util/OpenBitSet.java
===================================================================
--- core/src/java/org/apache/lucene/util/OpenBitSet.java	(revision 1534073)
+++ core/src/java/org/apache/lucene/util/OpenBitSet.java	(working copy)
@@ -131,6 +131,19 @@
     return true;
   }
 
+  /** The number of document ids in the set.
+   * @return <code>The value returned by {@link #cardinality}.</code>
+   */
+  @Override
+  public int numDocIds() {
+    long card = cardinality();
+    if (card < Integer.MAX_VALUE) { // DocIdSet.NO_MORE_DOCS == Integer.MAX_VALUE
+      return (int) card;
+    }
+    throw new IllegalStateException("cardinality >= Integer.MAX_VALUE: " + card);
+  }
+
+
   /** Returns the current capacity in bits (1 greater than the index of the last bit) */
   public long capacity() { return bits.length << 6; }
 
Index: queries/src/java/org/apache/lucene/queries/TermFilter.java
===================================================================
--- queries/src/java/org/apache/lucene/queries/TermFilter.java	(revision 1534073)
+++ queries/src/java/org/apache/lucene/queries/TermFilter.java	(working copy)
@@ -56,7 +56,7 @@
   }
 
   @Override
-  public DocIdSet getDocIdSet(AtomicReaderContext context, final Bits acceptDocs) throws IOException {
+  public DocIdSet getDocIdSet(final AtomicReaderContext context, final Bits acceptDocs) throws IOException {
     Terms terms = context.reader().terms(term.field());
     if (terms == null) {
       return null;
@@ -66,12 +66,18 @@
     if (!termsEnum.seekExact(term.bytes())) {
       return null;
     }
+
     return new DocIdSet() {
       @Override
       public DocIdSetIterator iterator() throws IOException {
         return termsEnum.docs(acceptDocs, null, DocsEnum.FLAG_NONE);
       }
 
+      @Override
+      public int numDocIds() throws IOException {
+        return context.reader().docFreq(term);
+      }
+
     };
   }
 
