Index: lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java b/lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java
--- a/lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java	(revision f9be01d5cc2aa713a706cc9502d386863f49675a)
+++ b/lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.java	(date 1635860026000)
@@ -42,6 +42,7 @@
 import org.apache.lucene.util.Accountable;
 import org.apache.lucene.util.Accountables;
 import org.apache.lucene.util.BitDocIdSet;
+import org.apache.lucene.util.BitSetIterator;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.RamUsageEstimator;
 import org.apache.lucene.util.RoaringDocIdSet;
@@ -510,7 +511,7 @@
   }
 
   private static CacheAndCount cacheIntoBitSet(BulkScorer scorer, int maxDoc) throws IOException {
-    final FixedBitSet bitSet = new FixedBitSet(maxDoc);
+    final DenseDocIdSet docIdSet = new DenseDocIdSet(maxDoc);
     int[] count = new int[1];
     scorer.score(
         new LeafCollector() {
@@ -521,11 +522,11 @@
           @Override
           public void collect(int doc) throws IOException {
             count[0]++;
-            bitSet.set(doc);
+            docIdSet.add(doc);
           }
         },
         null);
-    return new CacheAndCount(new BitDocIdSet(bitSet, count[0]), count[0]);
+    return new CacheAndCount(docIdSet, count[0]);
   }
 
   private static CacheAndCount cacheIntoRoaringDocIdSet(BulkScorer scorer, int maxDoc)
@@ -973,4 +974,67 @@
       return BASE_RAM_BYTES_USED + cache.ramBytesUsed();
     }
   }
+
+  // nocommit: possibly useful outside of this class? should it be put somewhere more general?
+  private static class DenseDocIdSet extends DocIdSet {
+    private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(DenseDocIdSet.class);
+
+    private final int maxDoc;
+
+    private FixedBitSet set;
+    private int minDoc = -1;
+    private int previous = -1;
+    private int counter = -1;
+
+    DenseDocIdSet(int maxDoc) {
+      this.maxDoc = maxDoc;
+    }
+
+    void add(int doc) {
+      if (doc <= previous) {
+        throw new IllegalArgumentException("Out of order doc ids: previous=" + previous + ", next=" + doc);
+      }
+
+      if (minDoc == -1) {
+        // First doc; establish a min:
+        assert counter == -1;
+        minDoc = counter = doc;
+      }
+
+      if (set != null) {
+        // Once we move to using a BitSet, just keep using it:
+        set.set(doc);
+      } else if (doc != counter) {
+        // Transition to using a BitSet if we see a gap in the doc IDs:
+        set = new FixedBitSet(maxDoc);
+        set.set(minDoc, counter);
+        set.set(doc);
+      }
+
+      previous = doc;
+      counter++;
+    }
+
+    private int size() {
+      return counter - minDoc;
+    }
+
+    @Override
+    public DocIdSetIterator iterator() throws IOException {
+      if (minDoc == -1) {
+        assert counter == -1;
+        return DocIdSetIterator.empty();
+      } else if (set == null) {
+        assert minDoc != -1 && counter > minDoc;
+        return DocIdSetIterator.range(minDoc, counter);
+      } else {
+        return new BitSetIterator(set, size());
+      }
+    }
+
+    @Override
+    public long ramBytesUsed() {
+      return BASE_RAM_BYTES_USED + (set == null ? 0 : set.ramBytesUsed());
+    }
+  }
 }
