Index: lucene/core/src/java/org/apache/lucene/search/TopDocsCollector.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/TopDocsCollector.java	(revision 1554291)
+++ lucene/core/src/java/org/apache/lucene/search/TopDocsCollector.java	(working copy)
@@ -76,6 +76,11 @@
   public int getTotalHits() {
     return totalHits;
   }
+
+  /** The number of documents in previous pages, when using search after */
+  public int getPreviousPageHits() {
+    return 0;
+  }
   
   /** The number of valid PQ entries */
   protected int topDocsSize() {
Index: lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java	(revision 1554291)
+++ lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java	(working copy)
@@ -848,6 +848,7 @@
 
     Scorer scorer;
     int collectedHits;
+    int previousPageHits;
     final FieldComparator<?>[] comparators;
     final int[] reverseMul;
     final FieldValueHitQueue<Entry> queue;
@@ -894,6 +895,7 @@
         if (cmp < 0) {
           // Already collected on a previous page
           //System.out.println("    skip: before");
+          ++previousPageHits;
           return;
         } else if (cmp > 0) {
           // Not yet collected
@@ -907,6 +909,7 @@
       if (sameValues && doc <= afterDoc) {
         // Already collected on a previous page
         //System.out.println("    skip: tie-break");
+        ++previousPageHits;
         return;
       }
 
@@ -998,6 +1001,11 @@
         queue.setComparator(i, comparators[i].setNextReader(context));
       }
     }
+
+    @Override
+    public int getPreviousPageHits() {
+      return previousPageHits;
+    }
   }
 
   private static final ScoreDoc[] EMPTY_SCOREDOCS = new ScoreDoc[0];
