diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
index 07a3cae..710889b 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
@@ -35,7 +35,7 @@ public class NearSpansUnordered extends ConjunctionSpans {
   private List<SpansCell> subSpanCells; // in query order
   private final int allowedSlop;
 
-  private SpanPositionQueue spanPositionQueue;
+  private SpanPositionQueue<SpansCell> spanPositionQueue;
 
   public NearSpansUnordered(int allowedSlop, List<Spans> subSpans)
   throws IOException {
@@ -45,7 +45,7 @@ public class NearSpansUnordered extends ConjunctionSpans {
     for (Spans subSpan : subSpans) { // sub spans in query order
       this.subSpanCells.add(new SpansCell(subSpan));
     }
-    spanPositionQueue = new SpanPositionQueue(subSpans.size());
+    spanPositionQueue = new SpanPositionQueue<SpansCell>(subSpans.size());
     singleCellToPositionQueue(); // -1 startPosition/endPosition also at doc -1
     this.allowedSlop = allowedSlop;
   }
@@ -163,29 +163,6 @@ public class NearSpansUnordered extends ConjunctionSpans {
   }
 
 
-  private static class SpanPositionQueue extends PriorityQueue<SpansCell> {
-    public SpanPositionQueue(int size) {
-      super(size);
-    }
-
-    @Override
-    protected final boolean lessThan(SpansCell spans1, SpansCell spans2) {
-      return positionsOrdered(spans1, spans2);
-    }
-  }
-
-  /** Check whether two Spans in the same document are ordered with possible overlap.
-   * @return true iff spans1 starts before spans2
-   *              or the spans start at the same position,
-   *              and spans1 ends before spans2.
-   */
-  static boolean positionsOrdered(Spans spans1, Spans spans2) {
-    assert spans1.docID() == spans2.docID() : "doc1 " + spans1.docID() + " != doc2 " + spans2.docID();
-    int start1 = spans1.startPosition();
-    int start2 = spans2.startPosition();
-    return (start1 == start2) ? (spans1.endPosition() < spans2.endPosition()) : (start1 < start2);
-  }
-
   private SpansCell minPositionCell() {
     return spanPositionQueue.top();
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
index c148979..c193614 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
@@ -174,7 +174,7 @@ public final class SpanOrQuery extends SpanQuery {
         byDocQueue.add(new DisiWrapper(spans));
       }
 
-      SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1
+      SpanPositionQueue<Spans> byPositionQueue = new SpanPositionQueue<Spans>(subSpans.size());
 
       return new Spans() {
         Spans topPositionSpans = null;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionQueue.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionQueue.java
index cf83d13..4c0bb34 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionQueue.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionQueue.java
@@ -17,19 +17,174 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
-import org.apache.lucene.util.PriorityQueue;
+import org.apache.lucene.util.ArrayUtil;
 
-class SpanPositionQueue extends PriorityQueue<Spans> {
-  SpanPositionQueue(int maxSize) {
-    super(maxSize, false); // do not prepopulate
+/** A priority queue for Spans comparing positions and ignoring the document numbers. */
+class SpanPositionQueue<SpansT extends Spans> {
+
+/* Started from o.a.l.util.PriorityQueue, April 2015, with unused code removed,
+ * and with the following lessThan inlined and simplified below:
+ *
+ * protected boolean lessThan(Spans s1, Spans s2) {
+ *   int start1 = s1.startPosition();
+ *   int start2 = s2.startPosition();
+ *   return (start1 < start2) ? true
+ *         : (start1 == start2) ? s1.endPosition() < s2.endPosition()
+ *         : false;
+ * }
+ */
+
+  private int size = 0;
+  private final int maxSize;
+  private final SpansT[] heap;
+
+  @SuppressWarnings({"unchecked"})
+  public SpanPositionQueue(int maxSize) {
+    final int heapSize;
+    if (maxSize < 2) {;
+      throw new IllegalArgumentException("maxSize must be >= 2; got: " + maxSize);
+    }
+    // NOTE: we add +1 because all access to heap is
+    // 1-based not 0-based.  heap[0] is unused.
+    heapSize = maxSize + 1;
+
+    if (heapSize > ArrayUtil.MAX_ARRAY_LENGTH) {
+      // Throw exception to prevent confusing OOME:
+      throw new IllegalArgumentException("maxSize must be <= " + (ArrayUtil.MAX_ARRAY_LENGTH-1) + "; got: " + maxSize);
+    }
+
+    this.heap = (SpansT[]) new Spans[heapSize];
+    this.maxSize = maxSize;
   }
 
-  protected boolean lessThan(Spans s1, Spans s2) {
-    int start1 = s1.startPosition();
-    int start2 = s2.startPosition();
-    return (start1 < start2) ? true
-          : (start1 == start2) ? s1.endPosition() < s2.endPosition()
-          : false;
+
+  /**
+   * Adds an Object to a PriorityQueue in log(size) time. If one tries to add
+   * more objects than maxSize from initialize an
+   * {@link ArrayIndexOutOfBoundsException} is thrown.
+   *
+   * @return the new 'top' element in the queue.
+   */
+  public final SpansT add(SpansT element) {
+    size++;
+    heap[size] = element;
+    upHeap(size);
+    return heap[1];
+  }
+
+  /** Returns the least element of the PriorityQueue in constant time. */
+  public final SpansT top() {
+    // We don't need to check size here: if maxSize is 0,
+    // then heap is length 2 array with both entries null.
+    // If size is 0 then heap[1] is already null.
+    return heap[1];
+  }
+
+  /**
+   * Should be called when the Object at top changes values. Still log(n) worst
+   * case, but it's at least twice as fast to
+   *
+   * <pre class="prettyprint">
+   * pq.top().change();
+   * pq.updateTop();
+   * </pre>
+   *
+   * instead of
+   *
+   * <pre class="prettyprint">
+   * o = pq.pop();
+   * o.change();
+   * pq.push(o);
+   * </pre>
+   *
+   * @return the new 'top' element.
+   */
+  public final SpansT updateTop() {
+    downHeap(1);
+    return heap[1];
+  }
+
+  /** Returns the number of elements currently stored in the PriorityQueue. */
+  public final int size() {
+    return size;
+  }
+
+  /** Removes all entries from the PriorityQueue. */
+  public final void clear() {
+    for (int i = 0; i <= size; i++) {
+      heap[i] = null;
+    }
+    size = 0;
+  }
+
+  private final void upHeap(int i) {
+    SpansT node = heap[i];          // save bottom node
+    int j = i >>> 1;
+    if (j > 0) {
+      int startNode = node.startPosition();
+      do {
+        SpansT other = heap[j];
+        int startOther = other.startPosition();
+        if ((startNode > startOther)
+            || ((startNode == startOther)
+                && (node.endPosition() >= other.endPosition())))
+        {
+          break;
+        }
+        heap[i] = other;       // shift parents down
+        i = j;
+        j = j >>> 1;
+      } while (j > 0);
+    }
+    heap[i] = node;            // install saved node
+  }
+
+  private final void downHeap(int i) {
+    SpansT nodeTop = heap[i];          // save top node
+    int j = i << 1;            // find smaller child
+    int k = j + 1;
+    if (k <= size) {
+      Spans nodeK = heap[k];
+      Spans nodeJ = heap[j];
+      int startK = nodeK.startPosition();
+      int startJ = nodeJ.startPosition();
+      if ((startK < startJ)
+          || ((startK == startJ)
+              && (nodeK.endPosition() < nodeJ.endPosition()))) {
+        j = k;
+      }
+    }
+    if (j <= size) {
+      final int startTop = nodeTop.startPosition(); // Saving nodeTop.endPosition() is not worthwhile
+      do {
+        SpansT nodeJ = heap[j];
+        int startJ = nodeJ.startPosition();
+        if ((startJ > startTop)
+            || ((startJ == startTop)
+                && (nodeJ.endPosition() >= nodeTop.endPosition())))
+        {
+          break;
+        }
+
+        heap[i] = nodeJ;       // shift up child
+        i = j;
+        j = i << 1;
+        k = j + 1;
+        if (k <= size) {
+          SpansT nodeK = heap[k];
+          nodeJ = heap[j];
+          int startK = nodeK.startPosition();
+          startJ = nodeJ.startPosition();
+          if ((startK < startJ)
+              || ((startK == startJ)
+                  && (nodeK.endPosition() < nodeJ.endPosition())))
+          {
+            j = k;
+          }
+        }
+      } while (j <= size);
+    }
+    heap[i] = nodeTop;            // install saved node
   }
 }
 
