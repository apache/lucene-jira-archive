Index: lucene/src/java/org/apache/lucene/index/MultiDocValues.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/MultiDocValues.java	(revision 1214158)
+++ lucene/src/java/org/apache/lucene/index/MultiDocValues.java	(working copy)
@@ -97,19 +97,26 @@
           slices.add(new DocValuesSlice(d, base, r.maxDoc()));
         }
       }.run();
-      
+       
       // return null if no docvalues encountered anywhere
       if (promotedType[0] == TypePromoter.getIdentityPromoter()) {
         return null;
       }
-           
+      
       // populate starts and fill gaps with empty docvalues 
       int starts[] = new int[slices.size()];
       for (int i = 0; i < slices.size(); i++) {
         DocValuesSlice slice = slices.get(i);
         starts[i] = slice.start;
         if (slice.docValues == null) {
-          slice.docValues = new EmptyDocValues(slice.length, promotedType[0].type());
+          Type promoted = promotedType[0].type();
+          switch(promoted) {
+            case BYTES_FIXED_DEREF:
+            case BYTES_FIXED_STRAIGHT:
+              slice.docValues = new EmptyFixedDocValues(slice.length, promoted, promotedType[0].getValueSize());
+            default:
+              slice.docValues = new EmptyDocValues(slice.length, promoted);
+          }
         }
       }
       
@@ -147,7 +154,39 @@
       return emptySource;
     }
   }
+  
+  public static class EmptyFixedDocValues extends DocValues {
+    final int maxDoc;
+    final Source emptyFixedSource;
+    final int valueSize;
 
+    public EmptyFixedDocValues(int maxDoc, Type type, int valueSize) {
+      this.maxDoc = maxDoc;
+      this.emptyFixedSource = new EmptyFixedSource(type, valueSize);
+      this.valueSize = valueSize;
+    }
+
+    @Override
+    public Source load() throws IOException {
+      return emptyFixedSource;
+    }
+
+    @Override
+    public Type type() {
+      return emptyFixedSource.type();
+    }
+
+    @Override
+    public int getValueSize() {
+      return valueSize;
+    }
+
+    @Override
+    public Source getDirectSource() throws IOException {
+      return emptyFixedSource;
+    }
+  }
+
   private static class MultiSource extends Source {
     private int numDocs = 0;
     private int start = 0;
@@ -216,10 +255,36 @@
     public BytesRef getBytes(int docID, BytesRef ref) {
       ref.length = 0;
       return ref;
+    }
 
+    @Override
+    public double getFloat(int docID) {
+      return 0d;
     }
 
     @Override
+    public long getInt(int docID) {
+      return 0;
+    }
+  }
+  
+  private static class EmptyFixedSource extends Source {
+    private final int valueSize;
+    
+    public EmptyFixedSource(Type type, int valueSize) {
+      super(type);
+      this.valueSize = valueSize;
+    }
+
+    @Override
+    public BytesRef getBytes(int docID, BytesRef ref) {
+      ref.grow(valueSize);
+      ref.length = valueSize;
+      Arrays.fill(ref.bytes, ref.offset, ref.offset+valueSize, (byte)0);
+      return ref;
+    }
+
+    @Override
     public double getFloat(int docID) {
       return 0d;
     }
