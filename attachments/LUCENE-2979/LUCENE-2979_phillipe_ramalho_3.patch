Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/AbstractQueryConfig.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/AbstractQueryConfig.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/AbstractQueryConfig.java	(revision 0)
@@ -0,0 +1,118 @@
+package org.apache.lucene.queryParser.core.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.HashMap;
+
+/**
+ * <p>
+ * This class is the base of {@link QueryConfigHandler} and {@link FieldConfig}.
+ * It has operations to set, unset and get configuration values.
+ * </p>
+ * <p>
+ * Each configuration is is a key->value pair. The key should be an unique
+ * {@link ConfigurationKey} instance and it also holds the value's type.
+ * </p>
+ * 
+ * @see ConfigurationKey
+ */
+public abstract class AbstractQueryConfig {
+  
+  final private HashMap<ConfigurationKey<?>, Object> configMap = new HashMap<ConfigurationKey<?>, Object>();
+  
+  AbstractQueryConfig() {
+    // although this class is public, it can only be constructed from package
+  }
+  
+  /**
+   * Returns the value held by the given key.
+   * 
+   * @param <T> the value's type
+   * 
+   * @param key the key, cannot be <code>null</code>
+   * 
+   * @return the value held by the given key
+   */
+  @SuppressWarnings("unchecked")
+  public <T> T get(ConfigurationKey<T> key) {
+    
+    if (key == null) {
+      throw new IllegalArgumentException("key cannot be null!");
+    }
+    
+    return (T) this.configMap.get(key);
+    
+  }
+
+  /**
+   * Returns true if there is a value set with the given key, otherwise false.
+   * 
+   * @param <T> @param <T> the value's type
+   * @param key the key, cannot be <code>null</code>
+   * @return true if there is a value set with the given key, otherwise false
+   */
+  public <T> boolean has(ConfigurationKey<T> key) {
+    
+    if (key == null) {
+      throw new IllegalArgumentException("key cannot be null!");
+    }
+    
+    return this.configMap.containsKey(key);
+    
+  }
+  
+  /**
+   * Sets a key and its value.
+   * 
+   * @param <T> the value's type
+   * @param key the key, cannot be <code>null</code>
+   * @param value
+   */
+  public <T> void set(ConfigurationKey<T> key, T value) {
+    
+    if (key == null) {
+      throw new IllegalArgumentException("key cannot be null!");
+    }
+    
+    if (value == null) {
+      unset(key);
+      
+    } else {
+      this.configMap.put(key, value);
+    }
+    
+  }
+
+  /**
+   * Unsets the given key and its value.
+   * 
+   * @param <T> the value's type
+   * @param key the key
+   * @return true if the key and value was set and removed, otherwise false
+   */
+  public <T> boolean unset(ConfigurationKey<T> key) {
+    
+    if (key == null) {
+      throw new IllegalArgumentException("key cannot be null!");
+    }
+    
+    return this.configMap.remove(key) != null;
+    
+  }
+
+}

Property changes on: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/AbstractQueryConfig.java
___________________________________________________________________
Added: svn:keywords
   + Rev Date
Added: svn:eol-style
   + native

Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigurationKey.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigurationKey.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigurationKey.java	(revision 0)
@@ -0,0 +1,42 @@
+package org.apache.lucene.queryParser.core.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * An instance of this class represents a key that is used to retrieve a value
+ * from {@link AbstractQueryConfig}. It also holds the value's type, which is
+ * defined in the generic argument.
+ * 
+ * @see AbstractQueryConfig
+ */
+final public class ConfigurationKey<T> {
+  
+  private ConfigurationKey() {}
+  
+  /**
+   * Creates a new instance.
+   * 
+   * @param <T> the value's type
+   * 
+   * @return a new instance
+   */
+  public static <T> ConfigurationKey<T> newInstance() {
+    return new ConfigurationKey<T>();
+  }
+  
+}

Property changes on: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/ConfigurationKey.java
___________________________________________________________________
Added: svn:keywords
   + Rev Date
Added: svn:eol-style
   + native

Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfig.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfig.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfig.java	(working copy)
@@ -17,16 +17,10 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.util.AttributeSource;
-
 /**
- * This class represents a field configuration. Every configuration should be
- * set using the methods inherited from {@link AttributeSource}.
- * 
- * @see QueryConfigHandler
- * @see org.apache.lucene.util.Attribute
+ * This class represents a field configuration.
  */
-public class FieldConfig extends AttributeSource {
+public class FieldConfig extends AbstractQueryConfig {
 
   private String fieldName;
   
@@ -57,7 +51,7 @@
 
   @Override
   public String toString() {
-    return "<fieldconfig name=\"" + this.fieldName + "\" attributes=\""
+    return "<fieldconfig name=\"" + this.fieldName + "\" configurations=\""
         + super.toString() + "\"/>";
   }
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfigListener.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfigListener.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/FieldConfigListener.java	(working copy)
@@ -20,7 +20,7 @@
 /**
  * This interface should be implemented by classes that wants to listen for
  * field configuration requests. The implementation receives a
- * {@link FieldConfig} object and may add/change its attributes.
+ * {@link FieldConfig} object and may add/change its configuration.
  * 
  * @see FieldConfig
  * @see QueryConfigHandler
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/QueryConfigHandler.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/QueryConfigHandler.java	(revision 1096393)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/QueryConfigHandler.java	(working copy)
@@ -1,85 +0,0 @@
-package org.apache.lucene.queryParser.core.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.LinkedList;
-
-import org.apache.lucene.queryParser.core.processors.QueryNodeProcessor;
-import org.apache.lucene.util.Attribute;
-import org.apache.lucene.util.AttributeSource;
-
-/**
- * This class can be used to hold any query configuration and no field
- * configuration. For field configuration, it creates a empty
- * {@link FieldConfig} object and delegate it to field config listeners, 
- * these are responsible for setting up all the field configuration.
- * 
- * {@link QueryConfigHandler} should be extended by classes that intends to
- * provide configuration to {@link QueryNodeProcessor} objects.
- * 
- * This class extends {@link AttributeSource}, so {@link Attribute}s can be
- * attached to it.
- * 
- * The class that extends {@link QueryConfigHandler} should also provide
- * {@link FieldConfig} objects for each collection field.
- * 
- * @see Attribute
- * @see FieldConfig
- * @see FieldConfigListener
- * @see QueryConfigHandler
- */
-public abstract class QueryConfigHandler extends AttributeSource {
-
-  private LinkedList<FieldConfigListener> listeners = new LinkedList<FieldConfigListener>();
-
-  /**
-   * Returns an implementation of
-   * {@link FieldConfig} for a specific field name. If the implemented
-   * {@link QueryConfigHandler} does not know a specific field name, it may
-   * return <code>null</code>, indicating there is no configuration for that
-   * field.
-   * 
-   * @param fieldName
-   *          the field name
-   * @return a {@link FieldConfig} object containing the field name
-   *         configuration or <code>null</code>, if the implemented
-   *         {@link QueryConfigHandler} has no configuration for that field
-   */
-  public FieldConfig getFieldConfig(CharSequence fieldName) {
-    FieldConfig fieldConfig = new FieldConfig(fieldName);
-
-    for (FieldConfigListener listener : this.listeners) {
-      listener.buildFieldConfig(fieldConfig);
-    }
-
-    return fieldConfig;
-
-  }
-
-  /**
-   * Adds a listener. The added listeners are called in the order they are
-   * added.
-   * 
-   * @param listener
-   *          the listener to be added
-   */
-  public void addFieldConfigListener(FieldConfigListener listener) {
-    this.listeners.add(listener);
-  }
-  
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/QueryConfigHandler.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/QueryConfigHandler.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/QueryConfigHandler.java	(revision 1096393)
@@ -0,0 +1,80 @@
+package org.apache.lucene.queryParser.core.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.LinkedList;
+
+import org.apache.lucene.queryParser.core.processors.QueryNodeProcessor;
+import org.apache.lucene.queryParser.core.util.StringUtils;
+
+/**
+ * This class can be used to hold any query configuration and no field
+ * configuration. For field configuration, it creates an empty
+ * {@link FieldConfig} object and delegate it to field config listeners, 
+ * these are responsible for setting up all the field configuration.
+ * 
+ * {@link QueryConfigHandler} should be extended by classes that intends to
+ * provide configuration to {@link QueryNodeProcessor} objects.
+ * 
+ * The class that extends {@link QueryConfigHandler} should also provide
+ * {@link FieldConfig} objects for each collection field.
+ * 
+ * @see FieldConfig
+ * @see FieldConfigListener
+ * @see QueryConfigHandler
+ */
+public abstract class QueryConfigHandler extends AbstractQueryConfig {
+  
+  final private LinkedList<FieldConfigListener> listeners = new LinkedList<FieldConfigListener>();
+
+  /**
+   * Returns an implementation of
+   * {@link FieldConfig} for a specific field name. If the implemented
+   * {@link QueryConfigHandler} does not know a specific field name, it may
+   * return <code>null</code>, indicating there is no configuration for that
+   * field.
+   * 
+   * @param fieldName
+   *          the field name
+   * @return a {@link FieldConfig} object containing the field name
+   *         configuration or <code>null</code>, if the implemented
+   *         {@link QueryConfigHandler} has no configuration for that field
+   */
+  public FieldConfig getFieldConfig(String fieldName) {
+    FieldConfig fieldConfig = new FieldConfig(StringUtils.toString(fieldName));
+
+    for (FieldConfigListener listener : this.listeners) {
+      listener.buildFieldConfig(fieldConfig);
+    }
+
+    return fieldConfig;
+
+  }
+
+  /**
+   * Adds a listener. The added listeners are called in the order they are
+   * added.
+   * 
+   * @param listener
+   *          the listener to be added
+   */
+  public void addFieldConfigListener(FieldConfigListener listener) {
+    this.listeners.add(listener);
+  }
+  
+}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/package.html
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/package.html	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/config/package.html	(working copy)
@@ -33,14 +33,7 @@
 implementation.
 </p>
 <p>
-{@link org.apache.lucene.queryParser.core.config.FieldConfig} and {@link org.apache.lucene.queryParser.core.config.QueryConfigHandler}
- should use {@link org.apache.lucene.util.Attribute} to store all attributes
-required by the config implementation. See <tt>org.apache.lucene.queryParser.standard.config.*Attribute</tt>
-for reference implementation.
-</p>
-<p>
-The {@link org.apache.lucene.queryParser.core.config.QueryConfigHandler}, {@link org.apache.lucene.queryParser.core.config.FieldConfig},
- and {@link org.apache.lucene.util.Attribute}s are used in the processors to access config
+The {@link org.apache.lucene.queryParser.core.config.QueryConfigHandler} and {@link org.apache.lucene.queryParser.core.config.FieldConfig} are used in the processors to access config
 information in a flexible and independent way.
 See {@link org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor} for a 
 reference implementation.
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/BooleanModifiersQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/BooleanModifiersQueryNodeProcessor.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/processors/BooleanModifiersQueryNodeProcessor.java	(working copy)
@@ -29,8 +29,9 @@
 import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode.Modifier;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.precedence.PrecedenceQueryParser;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator;
 
 /**
  * <p>
@@ -44,7 +45,7 @@
  * if it is, the same operation when an {@link AndQueryNode} is found is applied to it.
  * </p>
  * 
- * @see DefaultOperatorAttribute
+ * @see ConfigurationKeys#DEFAULT_OPERATOR
  * @see PrecedenceQueryParser#setDefaultOperator
  */
 public class BooleanModifiersQueryNodeProcessor extends QueryNodeProcessorImpl {
@@ -59,14 +60,14 @@
 
   @Override
   public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-
-    if (!getQueryConfigHandler().hasAttribute(DefaultOperatorAttribute.class)) {
+    Operator op = getQueryConfigHandler().get(ConfigurationKeys.DEFAULT_OPERATOR);
+    
+    if (op == null) {
       throw new IllegalArgumentException(
-          "DefaultOperatorAttribute should be set on the QueryConfigHandler");
+          "StandardQueryConfigHandler.ConfigurationKeys.DEFAULT_OPERATOR should be set on the QueryConfigHandler");
     }
 
-    this.usingAnd = Operator.AND == getQueryConfigHandler().getAttribute(
-        DefaultOperatorAttribute.class).getOperator();
+    this.usingAnd = StandardQueryConfigHandler.Operator.AND == op;
 
     return super.process(queryTree);
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/StandardQueryParser.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/StandardQueryParser.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/StandardQueryParser.java	(working copy)
@@ -23,25 +23,15 @@
 
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.document.DateTools;
+import org.apache.lucene.document.DateTools.Resolution;
 import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.QueryParserHelper;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
 import org.apache.lucene.queryParser.standard.builders.StandardQueryTreeBuilder;
-import org.apache.lucene.queryParser.standard.config.AllowLeadingWildcardAttribute;
-import org.apache.lucene.queryParser.standard.config.AnalyzerAttribute;
-import org.apache.lucene.queryParser.standard.config.DateResolutionAttribute;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute;
-import org.apache.lucene.queryParser.standard.config.DefaultPhraseSlopAttribute;
-import org.apache.lucene.queryParser.standard.config.FieldBoostMapAttribute;
-import org.apache.lucene.queryParser.standard.config.FieldDateResolutionMapAttribute;
-import org.apache.lucene.queryParser.standard.config.FuzzyAttribute;
-import org.apache.lucene.queryParser.standard.config.LocaleAttribute;
-import org.apache.lucene.queryParser.standard.config.LowercaseExpandedTermsAttribute;
-import org.apache.lucene.queryParser.standard.config.MultiFieldAttribute;
-import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
-import org.apache.lucene.queryParser.standard.config.PositionIncrementsAttribute;
+import org.apache.lucene.queryParser.standard.config.FuzzyConfig;
 import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator;
 import org.apache.lucene.queryParser.standard.parser.StandardSyntaxParser;
 import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
 import org.apache.lucene.search.FuzzyQuery;
@@ -179,9 +169,8 @@
    * Gets implicit operator setting, which will be either {@link Operator#AND}
    * or {@link Operator#OR}.
    */
-  public Operator getDefaultOperator() {
-    DefaultOperatorAttribute attr = getQueryConfigHandler().getAttribute(DefaultOperatorAttribute.class);
-    return attr.getOperator();
+  public StandardQueryConfigHandler.Operator getDefaultOperator() {
+    return getQueryConfigHandler().get(ConfigurationKeys.DEFAULT_OPERATOR);
   }
 
   /**
@@ -192,9 +181,8 @@
    * In {@link Operator#AND} mode terms are considered to be in conjunction: the
    * above mentioned query is parsed as <code>capital AND of AND Hungary</code>
    */
-  public void setDefaultOperator(Operator operator) {
-    DefaultOperatorAttribute attr = getQueryConfigHandler().getAttribute(DefaultOperatorAttribute.class);
-    attr.setOperator(operator);
+  public void setDefaultOperator(StandardQueryConfigHandler.Operator operator) {
+    getQueryConfigHandler().set(ConfigurationKeys.DEFAULT_OPERATOR, operator);
   }
 
   /**
@@ -207,16 +195,22 @@
    * Default: false.
    */
   public void setLowercaseExpandedTerms(boolean lowercaseExpandedTerms) {
-    LowercaseExpandedTermsAttribute attr = getQueryConfigHandler().getAttribute(LowercaseExpandedTermsAttribute.class);
-    attr.setLowercaseExpandedTerms(lowercaseExpandedTerms);
+    getQueryConfigHandler().set(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS, lowercaseExpandedTerms);
   }
 
   /**
    * @see #setLowercaseExpandedTerms(boolean)
    */
   public boolean getLowercaseExpandedTerms() {
-    LowercaseExpandedTermsAttribute attr = getQueryConfigHandler().getAttribute(LowercaseExpandedTermsAttribute.class);
-    return attr.isLowercaseExpandedTerms();
+    Boolean lowercaseExpandedTerms = getQueryConfigHandler().get(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS);
+    
+    if (lowercaseExpandedTerms == null) {
+      return true;
+      
+    } else {
+      return lowercaseExpandedTerms;
+    }
+    
   }
 
   /**
@@ -229,8 +223,7 @@
    * Default: false.
    */
   public void setAllowLeadingWildcard(boolean allowLeadingWildcard) {
-    AllowLeadingWildcardAttribute attr = getQueryConfigHandler().getAttribute(AllowLeadingWildcardAttribute.class);
-    attr.setAllowLeadingWildcard(allowLeadingWildcard);
+    getQueryConfigHandler().set(ConfigurationKeys.ALLOW_LEADING_WILDCARD, allowLeadingWildcard);
   }
 
   /**
@@ -243,16 +236,22 @@
    * Default: false.
    */
   public void setEnablePositionIncrements(boolean enabled) {
-    PositionIncrementsAttribute attr = getQueryConfigHandler().getAttribute(PositionIncrementsAttribute.class);
-    attr.setPositionIncrementsEnabled(enabled);
+    getQueryConfigHandler().set(ConfigurationKeys.ENABLE_POSITION_INCREMENTS, enabled);
   }
 
   /**
    * @see #setEnablePositionIncrements(boolean)
    */
   public boolean getEnablePositionIncrements() {
-    PositionIncrementsAttribute attr = getQueryConfigHandler().getAttribute(PositionIncrementsAttribute.class);
-    return attr.isPositionIncrementsEnabled();
+    Boolean enablePositionsIncrements = getQueryConfigHandler().get(ConfigurationKeys.ENABLE_POSITION_INCREMENTS);
+    
+    if (enablePositionsIncrements == null) {
+       return false;
+       
+    } else {
+      return enablePositionsIncrements;
+    }
+    
   }
 
   /**
@@ -266,95 +265,127 @@
    * not relevant then use this change the rewrite method.
    */
   public void setMultiTermRewriteMethod(MultiTermQuery.RewriteMethod method) {
-    MultiTermRewriteMethodAttribute attr = getQueryConfigHandler().getAttribute(MultiTermRewriteMethodAttribute.class);
-    attr.setMultiTermRewriteMethod(method);
+    getQueryConfigHandler().set(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD, method);
   }
 
   /**
    * @see #setMultiTermRewriteMethod(org.apache.lucene.search.MultiTermQuery.RewriteMethod)
    */
   public MultiTermQuery.RewriteMethod getMultiTermRewriteMethod() {
-    MultiTermRewriteMethodAttribute attr = getQueryConfigHandler().getAttribute(MultiTermRewriteMethodAttribute.class);    
-    return attr.getMultiTermRewriteMethod();
+    return getQueryConfigHandler().get(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD);
   }
 
+  /**
+   * Set the fields a query should be expanded to when the field is
+   * <code>null</code>
+   * 
+   * @param fields the fields used to expand the query
+   */
   public void setMultiFields(CharSequence[] fields) {
 
     if (fields == null) {
       fields = new CharSequence[0];
     }
 
-    MultiFieldAttribute attr = getQueryConfigHandler().addAttribute(MultiFieldAttribute.class);
-    attr.setFields(fields);
+    getQueryConfigHandler().set(ConfigurationKeys.MULTI_FIELDS, fields);
 
   }
 
   /**
+   * Returns the fields used to expand the query when the field for a
+   * certain query is <code>null</code>
+   * 
+   * @param fields the fields used to expand the query
+   */
+  public void getMultiFields(CharSequence[] fields) {
+    getQueryConfigHandler().get(ConfigurationKeys.MULTI_FIELDS);
+  }
+
+  /**
    * Set the prefix length for fuzzy queries. Default is 0.
    * 
    * @param fuzzyPrefixLength
    *          The fuzzyPrefixLength to set.
    */
   public void setFuzzyPrefixLength(int fuzzyPrefixLength) {
-    FuzzyAttribute attr = getQueryConfigHandler().addAttribute(FuzzyAttribute.class);
-    attr.setPrefixLength(fuzzyPrefixLength);
+    QueryConfigHandler config = getQueryConfigHandler();
+    FuzzyConfig fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG);
+    
+    if (fuzzyConfig == null) {
+      fuzzyConfig = new FuzzyConfig();
+      config.set(ConfigurationKeys.FUZZY_CONFIG, fuzzyConfig);
+    }
+
+    fuzzyConfig.setPrefixLength(fuzzyPrefixLength);
+    
   }
 
   /**
    * Set locale used by date range parsing.
    */
   public void setLocale(Locale locale) {
-    LocaleAttribute attr = getQueryConfigHandler().addAttribute(LocaleAttribute.class);
-    attr.setLocale(locale);
+    getQueryConfigHandler().set(ConfigurationKeys.LOCALE, locale);
   }
 
   /**
    * Returns current locale, allowing access by subclasses.
    */
   public Locale getLocale() {
-    LocaleAttribute attr = getQueryConfigHandler().addAttribute(LocaleAttribute.class);
-    return attr.getLocale();
+    return getQueryConfigHandler().get(ConfigurationKeys.LOCALE);
   }
 
   /**
    * Sets the default slop for phrases. If zero, then exact phrase matches are
    * required. Default value is zero.
+   * 
+   * @deprecated renamed to {@link #setPhraseSlop(int)}
    */
+  @Deprecated
   public void setDefaultPhraseSlop(int defaultPhraseSlop) {
-    DefaultPhraseSlopAttribute attr = getQueryConfigHandler().addAttribute(DefaultPhraseSlopAttribute.class);
-    attr.setDefaultPhraseSlop(defaultPhraseSlop);
+    getQueryConfigHandler().set(ConfigurationKeys.PHRASE_SLOP, defaultPhraseSlop);
   }
+  
+  /**
+   * Sets the default slop for phrases. If zero, then exact phrase matches are
+   * required. Default value is zero.
+   */
+  public void setPhraseSlop(int defaultPhraseSlop) {
+    getQueryConfigHandler().set(ConfigurationKeys.PHRASE_SLOP, defaultPhraseSlop);
+  }
 
   public void setAnalyzer(Analyzer analyzer) {
-    AnalyzerAttribute attr = getQueryConfigHandler().getAttribute(AnalyzerAttribute.class);
-    attr.setAnalyzer(analyzer);
+    getQueryConfigHandler().set(ConfigurationKeys.ANALYZER, analyzer);
   }
   
   public Analyzer getAnalyzer() {    
-    QueryConfigHandler config = this.getQueryConfigHandler();
-
-    if ( config.hasAttribute(AnalyzerAttribute.class)) {
-      AnalyzerAttribute attr = config.getAttribute(AnalyzerAttribute.class);
-      return attr.getAnalyzer();
-    }
-
-    return null;       
+    return getQueryConfigHandler().get(ConfigurationKeys.ANALYZER);       
   }
 
   /**
    * @see #setAllowLeadingWildcard(boolean)
    */
   public boolean getAllowLeadingWildcard() {
-    AllowLeadingWildcardAttribute attr = getQueryConfigHandler().addAttribute(AllowLeadingWildcardAttribute.class);
-    return attr.isAllowLeadingWildcard();
+    Boolean allowLeadingWildcard = getQueryConfigHandler().get(ConfigurationKeys.ALLOW_LEADING_WILDCARD);
+    
+    if (allowLeadingWildcard == null) {
+      return false;
+      
+    } else {
+      return allowLeadingWildcard;
+    }
   }
 
   /**
    * Get the minimal similarity for fuzzy queries.
    */
   public float getFuzzyMinSim() {
-    FuzzyAttribute attr = getQueryConfigHandler().addAttribute(FuzzyAttribute.class);
-    return attr.getFuzzyMinSimilarity();
+    FuzzyConfig fuzzyConfig = getQueryConfigHandler().get(ConfigurationKeys.FUZZY_CONFIG);
+    
+    if (fuzzyConfig == null) {
+      return FuzzyQuery.defaultMinSimilarity;
+    } else {
+      return fuzzyConfig.getMinSimilarity();
+    }
   }
 
   /**
@@ -363,16 +394,27 @@
    * @return Returns the fuzzyPrefixLength.
    */
   public int getFuzzyPrefixLength() {
-    FuzzyAttribute attr = getQueryConfigHandler().addAttribute(FuzzyAttribute.class);
-    return attr.getPrefixLength();
+    FuzzyConfig fuzzyConfig = getQueryConfigHandler().get(ConfigurationKeys.FUZZY_CONFIG);
+    
+    if (fuzzyConfig == null) {
+      return FuzzyQuery.defaultPrefixLength;
+    } else {
+      return fuzzyConfig.getPrefixLength();
+    }
   }
 
   /**
    * Gets the default slop for phrases.
    */
   public int getPhraseSlop() {
-    DefaultPhraseSlopAttribute attr = getQueryConfigHandler().addAttribute(DefaultPhraseSlopAttribute.class);
-    return attr.getDefaultPhraseSlop();
+    Integer phraseSlop = getQueryConfigHandler().get(ConfigurationKeys.PHRASE_SLOP);
+    
+    if (phraseSlop == null) {
+      return 0;
+      
+    } else {
+      return phraseSlop;
+    }
   }
 
   /**
@@ -380,23 +422,83 @@
    * {@link FuzzyQuery#defaultMinSimilarity}.
    */
   public void setFuzzyMinSim(float fuzzyMinSim) {
-    FuzzyAttribute attr = getQueryConfigHandler().addAttribute(FuzzyAttribute.class);
-    attr.setFuzzyMinSimilarity(fuzzyMinSim);
+    QueryConfigHandler config = getQueryConfigHandler();
+    FuzzyConfig fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG);
+    
+    if (fuzzyConfig == null) {
+      fuzzyConfig = new FuzzyConfig();
+      config.set(ConfigurationKeys.FUZZY_CONFIG, fuzzyConfig);
+    }
+
+    fuzzyConfig.setMinSimilarity(fuzzyMinSim);
   }
   
+  /**
+   * Sets the boost used for each field.
+   * 
+   * @param boosts a collection that maps a field to its boost 
+   */
   public void setFieldsBoost(Map<String, Float> boosts) {
-    FieldBoostMapAttribute attr = getQueryConfigHandler().addAttribute(FieldBoostMapAttribute.class);
-    attr.setFieldBoostMap(boosts);
+    getQueryConfigHandler().set(ConfigurationKeys.FIELD_BOOST_MAP, boosts);
   }
+  
+  /**
+   * Returns the field to boost map used to set boost for each field.
+   * 
+   * @return the field to boost map 
+   */
+  public Map<String, Float> getFieldsBoost() {
+    return getQueryConfigHandler().get(ConfigurationKeys.FIELD_BOOST_MAP);
+  }
 
+  /**
+   * Sets the default {@link Resolution} used for certain field when
+   * no {@link Resolution} is defined for this field.
+   * 
+   * @param dateResolution the default {@link Resolution}
+   */
   public void setDateResolution(DateTools.Resolution dateResolution) {
-    DateResolutionAttribute attr = getQueryConfigHandler().addAttribute(DateResolutionAttribute.class);
-    attr.setDateResolution(dateResolution);
+    getQueryConfigHandler().set(ConfigurationKeys.DATE_RESOLUTION, dateResolution);
   }
+  
+  /**
+   * Returns the default {@link Resolution} used for certain field when
+   * no {@link Resolution} is defined for this field.
+   * 
+   * @return the default {@link Resolution}
+   */
+  public DateTools.Resolution getDateResolution() {
+    return getQueryConfigHandler().get(ConfigurationKeys.DATE_RESOLUTION);
+  }
 
+  /**
+   * Sets the {@link Resolution} used for each field
+   * 
+   * @param dateRes a collection that maps a field to its {@link Resolution}
+   * 
+   * @deprecated this method was renamed to {@link #setDateResolutionMap(Map)} 
+   */
+  @Deprecated
   public void setDateResolution(Map<CharSequence, DateTools.Resolution> dateRes) {
-    FieldDateResolutionMapAttribute attr = getQueryConfigHandler().addAttribute(FieldDateResolutionMapAttribute.class);
-    attr.setFieldDateResolutionMap(dateRes);
+    setDateResolutionMap(dateRes);
   }
   
+  /**
+   * Returns the field to {@link Resolution} map used to normalize each date field.
+   * 
+   * @return the field to {@link Resolution} map
+   */
+  public Map<CharSequence, DateTools.Resolution> getDateResolutionMap() {
+    return getQueryConfigHandler().get(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP);
+  }
+  
+  /**
+   * Sets the {@link Resolution} used for each field
+   * 
+   * @param dateRes a collection that maps a field to its {@link Resolution}
+   */
+  public void setDateResolutionMap(Map<CharSequence, DateTools.Resolution> dateRes) {
+    getQueryConfigHandler().set(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP, dateRes);
+  }
+  
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/PrefixWildcardQueryNodeBuilder.java	(working copy)
@@ -20,8 +20,8 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
 import org.apache.lucene.queryParser.standard.nodes.PrefixWildcardQueryNode;
+import org.apache.lucene.queryParser.standard.processors.MultiTermRewriteMethodProcessor;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.PrefixQuery;
 
@@ -42,7 +42,7 @@
     String text = wildcardNode.getText().subSequence(0, wildcardNode.getText().length() - 1).toString();
     PrefixQuery q = new PrefixQuery(new Term(wildcardNode.getFieldAsString(), text));
     
-    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodAttribute.TAG_ID);
+    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodProcessor.TAG_ID);
     if (method != null) {
       q.setRewriteMethod(method);
     }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RangeQueryNodeBuilder.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RangeQueryNodeBuilder.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RangeQueryNodeBuilder.java	(working copy)
@@ -21,8 +21,8 @@
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode.CompareOperator;
-import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
 import org.apache.lucene.queryParser.standard.nodes.RangeQueryNode;
+import org.apache.lucene.queryParser.standard.processors.MultiTermRewriteMethodProcessor;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.TermRangeQuery;
 
@@ -55,7 +55,7 @@
 
     TermRangeQuery rangeQuery = TermRangeQuery.newStringRange(field, lower.getTextAsString(), upper.getTextAsString(), lowerInclusive, upperInclusive);
     
-    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodAttribute.TAG_ID);
+    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodProcessor.TAG_ID);
     if (method != null) {
       rangeQuery.setRewriteMethod(method);
     }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RegexpQueryNodeBuilder.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RegexpQueryNodeBuilder.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/RegexpQueryNodeBuilder.java	(working copy)
@@ -20,8 +20,8 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
 import org.apache.lucene.queryParser.standard.nodes.RegexpQueryNode;
+import org.apache.lucene.queryParser.standard.processors.MultiTermRewriteMethodProcessor;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.RegexpQuery;
 
@@ -41,7 +41,7 @@
         regexpNode.textToBytesRef()));
 
     MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod) queryNode
-        .getTag(MultiTermRewriteMethodAttribute.TAG_ID);
+        .getTag(MultiTermRewriteMethodProcessor.TAG_ID);
     if (method != null) {
       q.setRewriteMethod(method);
     }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/builders/WildcardQueryNodeBuilder.java	(working copy)
@@ -20,8 +20,8 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
-import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
 import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
+import org.apache.lucene.queryParser.standard.processors.MultiTermRewriteMethodProcessor;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.WildcardQuery;
 
@@ -41,7 +41,7 @@
     WildcardQuery q = new WildcardQuery(new Term(wildcardNode.getFieldAsString(),
                                                  wildcardNode.getTextAsString()));
     
-    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodAttribute.TAG_ID);
+    MultiTermQuery.RewriteMethod method = (MultiTermQuery.RewriteMethod)queryNode.getTag(MultiTermRewriteMethodProcessor.TAG_ID);
     if (method != null) {
       q.setRewriteMethod(method);
     }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AllowLeadingWildcardAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AllowLeadingWildcardAttribute.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AllowLeadingWildcardAttribute.java	(working copy)
@@ -1,33 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.AllowLeadingWildcardProcessor;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute is used by {@link AllowLeadingWildcardProcessor} processor and
- * must be defined in the {@link QueryConfigHandler}. It basically tells the
- * processor if it should allow leading wildcard. <br/>
- * 
- */
-public interface AllowLeadingWildcardAttribute extends Attribute {
-  public void setAllowLeadingWildcard(boolean allowLeadingWildcard);
-  public boolean isAllowLeadingWildcard();
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AllowLeadingWildcardAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AllowLeadingWildcardAttributeImpl.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AllowLeadingWildcardAttributeImpl.java	(working copy)
@@ -1,79 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.AllowLeadingWildcardProcessor;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute is used by {@link AllowLeadingWildcardProcessor} processor and
- * must be defined in the {@link QueryConfigHandler}. It basically tells the
- * processor if it should allow leading wildcard. <br/>
- * 
- * @see org.apache.lucene.queryParser.standard.config.AllowLeadingWildcardAttribute
- */
-public class AllowLeadingWildcardAttributeImpl extends AttributeImpl 
-				implements AllowLeadingWildcardAttribute {
-
-  private boolean allowLeadingWildcard = false;  // default in 2.9
-
-  public void setAllowLeadingWildcard(boolean allowLeadingWildcard) {
-    this.allowLeadingWildcard = allowLeadingWildcard;
-  }
-
-  public boolean isAllowLeadingWildcard() {
-    return this.allowLeadingWildcard;
-  }
-
-  @Override
-  public void clear() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof AllowLeadingWildcardAttributeImpl
-        && ((AllowLeadingWildcardAttributeImpl) other).allowLeadingWildcard == this.allowLeadingWildcard) {
-
-      return true;
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    return this.allowLeadingWildcard ? -1 : Integer.MAX_VALUE;
-  }
-
-  @Override
-  public String toString() {
-    return "<allowLeadingWildcard allowLeadingWildcard="
-        + this.allowLeadingWildcard + "/>";
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AnalyzerAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AnalyzerAttribute.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AnalyzerAttribute.java	(working copy)
@@ -1,35 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.AnalyzerQueryNodeProcessor;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute is used by {@link AnalyzerQueryNodeProcessor} processor and
- * must be defined in the {@link QueryConfigHandler}. It provides to this
- * processor the {@link Analyzer}, if there is one, which will be used to
- * analyze the query terms. <br/>
- * 
- */
-public interface AnalyzerAttribute extends Attribute {
-  public void setAnalyzer(Analyzer analyzer);
-  public Analyzer getAnalyzer();
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AnalyzerAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AnalyzerAttributeImpl.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/AnalyzerAttributeImpl.java	(working copy)
@@ -1,90 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.AnalyzerQueryNodeProcessor;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute is used by {@link AnalyzerQueryNodeProcessor} processor and
- * must be defined in the {@link QueryConfigHandler}. It provides to this
- * processor the {@link Analyzer}, if there is one, which will be used to
- * analyze the query terms. <br/>
- * 
- * @see org.apache.lucene.queryParser.standard.config.AnalyzerAttribute
- */
-public class AnalyzerAttributeImpl extends AttributeImpl 
-				implements AnalyzerAttribute {
-
-  private Analyzer analyzer;
-
-  public AnalyzerAttributeImpl() {
-    analyzer = null; //default value 2.4
-  }
-
-  public void setAnalyzer(Analyzer analyzer) {
-    this.analyzer = analyzer;
-  }
-
-  public Analyzer getAnalyzer() {
-    return this.analyzer;
-  }
-
-  @Override
-  public void clear() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof AnalyzerAttributeImpl) {
-    	AnalyzerAttributeImpl analyzerAttr = (AnalyzerAttributeImpl) other;
-
-      if (analyzerAttr.analyzer == this.analyzer
-          || (this.analyzer != null && analyzerAttr.analyzer != null && this.analyzer
-              .equals(analyzerAttr.analyzer))) {
-
-        return true;
-
-      }
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    return (this.analyzer == null) ? 0 : this.analyzer.hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return "<analyzerAttribute analyzer='" + this.analyzer + "'/>";
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/BoostAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/BoostAttribute.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/BoostAttribute.java	(working copy)
@@ -1,35 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.FieldConfig;
-import org.apache.lucene.queryParser.standard.processors.MultiFieldQueryNodeProcessor;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute is used by {@link MultiFieldQueryNodeProcessor} processor and
- * it should be defined in a {@link FieldConfig}. This processor uses this
- * attribute to define which boost a specific field should have when none is
- * defined to it. <br/>
- * <br/>
- * 
- */
-public interface BoostAttribute extends Attribute {
-  public void setBoost(float boost);
-  public float getBoost();
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/BoostAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/BoostAttributeImpl.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/BoostAttributeImpl.java	(working copy)
@@ -1,84 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.FieldConfig;
-import org.apache.lucene.queryParser.standard.processors.MultiFieldQueryNodeProcessor;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute is used by {@link MultiFieldQueryNodeProcessor} processor and
- * it should be defined in a {@link FieldConfig}. This processor uses this
- * attribute to define which boost a specific field should have when none is
- * defined to it. <br/>
- * <br/>
- * 
- * @see org.apache.lucene.queryParser.standard.config.BoostAttribute
- */
-public class BoostAttributeImpl extends AttributeImpl 
-				implements BoostAttribute {
-
-  private float boost = 1.0f;
-
-  public BoostAttributeImpl() {
-    // empty constructor
-  }
-
-  public void setBoost(float boost) {
-    this.boost = boost;
-  }
-
-  public float getBoost() {
-    return this.boost;
-  }
-
-  @Override
-  public void clear() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof BoostAttributeImpl
-        && ((BoostAttributeImpl) other).boost == this.boost) {
-
-      return true;
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    return Float.valueOf(this.boost).hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return "<boostAttribute boost=" + this.boost + "/>";
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DateResolutionAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DateResolutionAttribute.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DateResolutionAttribute.java	(working copy)
@@ -1,43 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.document.DateTools;
-import org.apache.lucene.document.DateTools.Resolution;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.nodes.RangeQueryNode;
-import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute is used by {@link ParametricRangeQueryNodeProcessor} processor
- * and must be defined in the {@link QueryConfigHandler}. This attribute tells
- * the processor which {@link Resolution} to use when parsing the date. <br/>
- * 
- */
-public interface DateResolutionAttribute extends Attribute {
-  /**
-   * Sets the default date resolution used by {@link RangeQueryNode}s for
-   * fields for which no specific date resolutions has been set. Field
-   * specific resolutions can be set with
-   * 
-   * @param dateResolution the default date resolution to set
-   */
-  public void setDateResolution(DateTools.Resolution dateResolution);
-  public DateTools.Resolution getDateResolution();
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DateResolutionAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DateResolutionAttributeImpl.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DateResolutionAttributeImpl.java	(working copy)
@@ -1,90 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.document.DateTools;
-import org.apache.lucene.document.DateTools.Resolution;
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute is used by {@link ParametricRangeQueryNodeProcessor} processor
- * and must be defined in the {@link QueryConfigHandler}. This attribute tells
- * the processor which {@link Resolution} to use when parsing the date. <br/>
- * 
- * @see org.apache.lucene.queryParser.standard.config.DateResolutionAttribute
- */
-public class DateResolutionAttributeImpl extends AttributeImpl 
-				implements DateResolutionAttribute {
-
-  private DateTools.Resolution dateResolution = null;
-
-  public DateResolutionAttributeImpl() {
-	  dateResolution = null; //default in 2.4
-  }
-
-  public void setDateResolution(DateTools.Resolution dateResolution) {
-    this.dateResolution = dateResolution;
-  }
-
-  public DateTools.Resolution getDateResolution() {
-    return this.dateResolution;
-  }
-
-  @Override
-  public void clear() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof DateResolutionAttributeImpl) {
-    	DateResolutionAttributeImpl dateResAttr = (DateResolutionAttributeImpl) other;
-
-      if (dateResAttr.getDateResolution() == getDateResolution()
-          || dateResAttr.getDateResolution().equals(getDateResolution())) {
-
-        return true;
-
-      }
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    return (this.dateResolution == null) ? 0 : this.dateResolution.hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return "<dateResolutionAttribute dateResolution='" + this.dateResolution
-        + "'/>";
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultOperatorAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultOperatorAttribute.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultOperatorAttribute.java	(working copy)
@@ -1,39 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.GroupQueryNodeProcessor;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute is used by {@link GroupQueryNodeProcessor} processor and must
- * be defined in the {@link QueryConfigHandler}. This attribute tells the
- * processor which is the default boolean operator when no operator is defined
- * between terms. <br/>
- *
- */
-public interface DefaultOperatorAttribute extends Attribute {	
-  public static enum Operator {
-	    AND, OR;
-	  }
-
-  public void setOperator(Operator operator);
-  public Operator getOperator();
-}
-
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultOperatorAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultOperatorAttributeImpl.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultOperatorAttributeImpl.java	(working copy)
@@ -1,92 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.GroupQueryNodeProcessor;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute is used by {@link GroupQueryNodeProcessor} processor and must
- * be defined in the {@link QueryConfigHandler}. This attribute tells the
- * processor which is the default boolean operator when no operator is defined
- * between terms. <br/>
- * 
- * @see org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute
- */
-public class DefaultOperatorAttributeImpl extends AttributeImpl
-				implements DefaultOperatorAttribute {
-
-  private Operator operator = Operator.OR;
-
-  public DefaultOperatorAttributeImpl() {
-    // empty constructor
-  }
-
-  public void setOperator(Operator operator) {
-
-    if (operator == null) {
-      throw new IllegalArgumentException("default operator cannot be null!");
-    }
-
-    this.operator = operator;
-
-  }
-
-  public Operator getOperator() {
-    return this.operator;
-  }
-
-  @Override
-  public void clear() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof DefaultOperatorAttributeImpl) {
-    	DefaultOperatorAttributeImpl defaultOperatorAttr = (DefaultOperatorAttributeImpl) other;
-
-      if (defaultOperatorAttr.getOperator() == this.getOperator()) {
-        return true;
-
-      }
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    return getOperator().hashCode() * 31;
-  }
-
-  @Override
-  public String toString() {
-    return "<defaultOperatorAttribute operator=" + this.operator.name() + "/>";
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultPhraseSlopAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultPhraseSlopAttribute.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultPhraseSlopAttribute.java	(working copy)
@@ -1,34 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.PhraseSlopQueryNodeProcessor;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute is used by {@link PhraseSlopQueryNodeProcessor} processor and
- * must be defined in the {@link QueryConfigHandler}. This attribute tells the
- * processor what is the default phrase slop when no slop is defined in a
- * phrase. <br/>
- * 
- */
-public interface DefaultPhraseSlopAttribute extends Attribute {
-  public void setDefaultPhraseSlop(int defaultPhraseSlop);
-  public int getDefaultPhraseSlop();
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultPhraseSlopAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultPhraseSlopAttributeImpl.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/DefaultPhraseSlopAttributeImpl.java	(working copy)
@@ -1,84 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.PhraseSlopQueryNodeProcessor;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute is used by {@link PhraseSlopQueryNodeProcessor} processor and
- * must be defined in the {@link QueryConfigHandler}. This attribute tells the
- * processor what is the default phrase slop when no slop is defined in a
- * phrase. <br/>
- * 
- * @see org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute
- */
-public class DefaultPhraseSlopAttributeImpl extends AttributeImpl 
-				implements DefaultPhraseSlopAttribute {
-
-  private int defaultPhraseSlop = 0;
-
-  public DefaultPhraseSlopAttributeImpl() {
-	  defaultPhraseSlop = 0; //default value in 2.4
-  }
-
-  public void setDefaultPhraseSlop(int defaultPhraseSlop) {
-    this.defaultPhraseSlop = defaultPhraseSlop;
-  }
-
-  public int getDefaultPhraseSlop() {
-    return this.defaultPhraseSlop;
-  }
-
-  @Override
-  public void clear() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof DefaultPhraseSlopAttributeImpl
-        && ((DefaultPhraseSlopAttributeImpl) other).defaultPhraseSlop == this.defaultPhraseSlop) {
-
-      return true;
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    return Integer.valueOf(this.defaultPhraseSlop).hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return "<defaultPhraseSlop defaultPhraseSlop=" + this.defaultPhraseSlop
-        + "/>";
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapAttribute.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapAttribute.java	(working copy)
@@ -1,35 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Map;
-
-import org.apache.lucene.queryParser.core.config.FieldConfig;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute enables the user to define a default boost per field.
- * it's used by {@link FieldBoostMapFCListener#buildFieldConfig(FieldConfig)}
- */
-public interface FieldBoostMapAttribute extends Attribute {
-  /**
-   * @param boosts a mapping from field name to its default boost
-   */
-  public void setFieldBoostMap(Map<String, Float> boosts);
-  public Map<String, Float> getFieldBoostMap();
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapAttributeImpl.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapAttributeImpl.java	(working copy)
@@ -1,92 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import org.apache.lucene.queryParser.core.config.FieldConfig;
-import org.apache.lucene.queryParser.standard.processors.MultiFieldQueryNodeProcessor;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute is used by {@link MultiFieldQueryNodeProcessor} processor and
- * it should be defined in a {@link FieldConfig}. This processor uses this
- * attribute to define which boost a specific field should have when none is
- * defined to it. <br/>
- * <br/>
- * 
- * @see org.apache.lucene.queryParser.standard.config.BoostAttribute
- */
-public class FieldBoostMapAttributeImpl extends AttributeImpl 
-				implements FieldBoostMapAttribute {
-
-  private Map<String, Float> boosts = new LinkedHashMap<String, Float>();
-  
-
-  public FieldBoostMapAttributeImpl() {
-    // empty constructor
-  }
-
-  public void setFieldBoostMap(Map<String, Float> boosts) {
-    this.boosts = boosts;
-  }
-  
-  public Map<String, Float> getFieldBoostMap() {
-    return this.boosts;
-  }
-
-  @Override
-  public void clear() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof FieldBoostMapAttributeImpl
-        && ((FieldBoostMapAttributeImpl) other).boosts.equals(this.boosts) ) {
-
-      return true;
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 97;
-    if (this.boosts != null) 
-      return this.boosts.hashCode() * prime;
-    else 
-      return Float.valueOf(prime).hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return "<fieldBoostMapAttribute map=" + this.boosts + "/>";
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapFCListener.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapFCListener.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldBoostMapFCListener.java	(working copy)
@@ -17,18 +17,21 @@
  * limitations under the License.
  */
 
+import java.util.Map;
+
 import org.apache.lucene.queryParser.core.config.FieldConfig;
 import org.apache.lucene.queryParser.core.config.FieldConfigListener;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 
 /**
  * This listener listens for every field configuration request and assign a
- * {@link BoostAttribute} to the equivalent {@link FieldConfig} based on a
- * defined map: fieldName -> boostValue store in {@link FieldBoostMapAttribute}
- * in the {@link FieldBoostMapAttribute}.
+ * {@link ConfigurationKeys#BOOST} to the
+ * equivalent {@link FieldConfig} based on a defined map: fieldName -> boostValue stored in
+ * {@link ConfigurationKeys#FIELD_BOOST_MAP}.
  * 
- * @see BoostAttribute
- * @see FieldBoostMapAttribute
+ * @see ConfigurationKeys#FIELD_BOOST_MAP
+ * @see ConfigurationKeys#BOOST
  * @see FieldConfig
  * @see FieldConfigListener
  */
@@ -40,15 +43,14 @@
     this.config = config;
   }
 
-  public void buildFieldConfig(FieldConfig fieldConfig) {    
-    if (this.config.hasAttribute(FieldBoostMapAttribute.class)) {
-      FieldBoostMapAttribute fieldBoostMapAttr = this.config.getAttribute(FieldBoostMapAttribute.class);
-      BoostAttribute boostAttr = fieldConfig.addAttribute(BoostAttribute.class);
-      
-      Float boost = fieldBoostMapAttr.getFieldBoostMap().get(fieldConfig.getField());
+  public void buildFieldConfig(FieldConfig fieldConfig) {
+    Map<String, Float> fieldBoostMap = this.config.get(ConfigurationKeys.FIELD_BOOST_MAP);
+    
+    if (fieldBoostMap != null) {
+      Float boost = fieldBoostMap.get(fieldConfig.getField());
 
       if (boost != null) {
-        boostAttr.setBoost(boost.floatValue());
+        fieldConfig.set(ConfigurationKeys.BOOST, boost);
       }
 
     }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionFCListener.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionFCListener.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionFCListener.java	(working copy)
@@ -17,20 +17,23 @@
  * limitations under the License.
  */
 
+import java.util.Map;
+
 import org.apache.lucene.document.DateTools;
+import org.apache.lucene.document.DateTools.Resolution;
 import org.apache.lucene.queryParser.core.config.FieldConfig;
 import org.apache.lucene.queryParser.core.config.FieldConfigListener;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 
 /**
  * This listener listens for every field configuration request and assign a
- * {@link DateResolutionAttribute} to the equivalent {@link FieldConfig} based
- * on a defined map: fieldName -> DateTools.Resolution stored in
- * {@link FieldDateResolutionMapAttribute} in the
- * {@link DateResolutionAttribute}.
+ * {@link ConfigurationKeys#DATE_RESOLUTION} to the equivalent {@link FieldConfig} based
+ * on a defined map: fieldName -> {@link Resolution} stored in
+ * {@link ConfigurationKeys#FIELD_DATE_RESOLUTION_MAP}.
  * 
- * @see DateResolutionAttribute
- * @see FieldDateResolutionMapAttribute
+ * @see ConfigurationKeys#DATE_RESOLUTION
+ * @see ConfigurationKeys#FIELD_DATE_RESOLUTION_MAP
  * @see FieldConfig
  * @see FieldConfigListener
  */
@@ -43,30 +46,22 @@
   }
 
   public void buildFieldConfig(FieldConfig fieldConfig) {
-    DateResolutionAttribute fieldDateResAttr = fieldConfig
-        .addAttribute(DateResolutionAttribute.class);
     DateTools.Resolution dateRes = null;
+    Map<CharSequence, DateTools.Resolution> dateResMap = this.config.get(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP);
 
-    if (this.config.hasAttribute(FieldDateResolutionMapAttribute.class)) {
-      FieldDateResolutionMapAttribute dateResMapAttr = this.config
-          .addAttribute(FieldDateResolutionMapAttribute.class);
-      dateRes = dateResMapAttr.getFieldDateResolutionMap().get(
+    if (dateResMap != null) {
+      dateRes = dateResMap.get(
           fieldConfig.getField());
     }
 
     if (dateRes == null) {
+      dateRes = this.config.get(ConfigurationKeys.DATE_RESOLUTION);
+    }
 
-      if (this.config.hasAttribute(DateResolutionAttribute.class)) {
-        DateResolutionAttribute dateResAttr = this.config
-            .addAttribute(DateResolutionAttribute.class);
-        dateRes = dateResAttr.getDateResolution();
-
-      }
-
+    if (dateRes != null) {
+      fieldConfig.set(ConfigurationKeys.DATE_RESOLUTION, dateRes);
     }
 
-    fieldDateResAttr.setDateResolution(dateRes);
-
   }
 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionMapAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionMapAttribute.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionMapAttribute.java	(working copy)
@@ -1,35 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Map;
-
-import org.apache.lucene.document.DateTools;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute enables the user to define a default DateResolution per field.
- * it's used by {@link FieldDateResolutionFCListener#buildFieldConfig(org.apache.lucene.queryParser.core.config.FieldConfig)}
- */
-public interface FieldDateResolutionMapAttribute extends Attribute {
-  /**
-   * @param dateRes a mapping from field name to its default boost
-   */
-  public void setFieldDateResolutionMap(Map<CharSequence, DateTools.Resolution> dateRes);
-  public Map<CharSequence, DateTools.Resolution> getFieldDateResolutionMap();
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionMapAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionMapAttributeImpl.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FieldDateResolutionMapAttributeImpl.java	(working copy)
@@ -1,89 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.lucene.document.DateTools;
-import org.apache.lucene.document.DateTools.Resolution;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute enables the user to define a default DateResolution per field.
- * it's used by {@link FieldDateResolutionFCListener#buildFieldConfig(org.apache.lucene.queryParser.core.config.FieldConfig)}
- *
- * @see FieldDateResolutionMapAttribute
- */
-public class FieldDateResolutionMapAttributeImpl extends AttributeImpl 
-				implements FieldDateResolutionMapAttribute {
-
-  private Map<CharSequence, DateTools.Resolution> dateRes = new HashMap<CharSequence, DateTools.Resolution>();
-  
-
-  public FieldDateResolutionMapAttributeImpl() {
-    // empty constructor
-  }
-
-  public void setFieldDateResolutionMap(Map<CharSequence, DateTools.Resolution> dateRes) {
-    this.dateRes = dateRes;
-  }
-  
-  public Map<CharSequence, Resolution> getFieldDateResolutionMap() {
-    return this.dateRes;
-  }
-
-  @Override
-  public void clear() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof FieldDateResolutionMapAttributeImpl
-        && ((FieldDateResolutionMapAttributeImpl) other).dateRes.equals(this.dateRes) ) {
-
-      return true;
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 97;
-    if (this.dateRes != null) 
-      return this.dateRes.hashCode() * prime;
-    else 
-      return Float.valueOf(prime).hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return "<fieldDateResolutionMapAttribute map=" + this.dateRes + "/>";
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyAttribute.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyAttribute.java	(working copy)
@@ -1,36 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.PhraseSlopQueryNodeProcessor;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute is used by {@link PhraseSlopQueryNodeProcessor} processor and
- * must be defined in the {@link QueryConfigHandler}. This attribute tells the
- * processor what is the default phrase slop when no slop is defined in a
- * phrase. <br/>
- * 
- */
-public interface FuzzyAttribute extends Attribute {
-  public void setPrefixLength(int prefixLength);
-  public int getPrefixLength();
-  public void setFuzzyMinSimilarity(float minSimilarity);
-  public float getFuzzyMinSimilarity();
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyAttributeImpl.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyAttributeImpl.java	(working copy)
@@ -1,94 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.PhraseSlopQueryNodeProcessor;
-import org.apache.lucene.search.FuzzyQuery;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute is used by {@link PhraseSlopQueryNodeProcessor} processor and
- * must be defined in the {@link QueryConfigHandler}. This attribute tells the
- * processor what is the default phrase slop when no slop is defined in a
- * phrase. <br/>
- * 
- * @see org.apache.lucene.queryParser.standard.config.FuzzyAttribute
- */
-public class FuzzyAttributeImpl extends AttributeImpl 
-				implements FuzzyAttribute {
-
-  private int prefixLength = FuzzyQuery.defaultPrefixLength;
-
-  private float minSimilarity = FuzzyQuery.defaultMinSimilarity;
-
-  public FuzzyAttributeImpl() {
-    // empty constructor
-  }
-
-  public void setPrefixLength(int prefixLength) {
-    this.prefixLength = prefixLength;
-  }
-
-  public int getPrefixLength() {
-    return this.prefixLength;
-  }
-
-  public void setFuzzyMinSimilarity(float minSimilarity) {
-    this.minSimilarity = minSimilarity;
-  }
-
-  public float getFuzzyMinSimilarity() {
-    return this.minSimilarity;
-  }
-
-  @Override
-  public void clear() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof FuzzyAttributeImpl
-        && ((FuzzyAttributeImpl) other).prefixLength == this.prefixLength) {
-
-      return true;
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    return Integer.valueOf(this.prefixLength).hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return "<fuzzyAttribute prefixLength=" + this.prefixLength + "/>";
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyConfig.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyConfig.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyConfig.java	(revision 0)
@@ -0,0 +1,46 @@
+package org.apache.lucene.queryParser.standard.config;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.search.FuzzyQuery;
+
+public class FuzzyConfig {
+  
+  private int prefixLength = FuzzyQuery.defaultPrefixLength;
+
+  private float minSimilarity = FuzzyQuery.defaultMinSimilarity;
+  
+  public FuzzyConfig() {}
+
+  public int getPrefixLength() {
+    return prefixLength;
+  }
+
+  public void setPrefixLength(int prefixLength) {
+    this.prefixLength = prefixLength;
+  }
+
+  public float getMinSimilarity() {
+    return minSimilarity;
+  }
+
+  public void setMinSimilarity(float minSimilarity) {
+    this.minSimilarity = minSimilarity;
+  }
+  
+}

Property changes on: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/FuzzyConfig.java
___________________________________________________________________
Added: svn:keywords
   + Rev Date
Added: svn:eol-style
   + native

Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LocaleAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LocaleAttribute.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LocaleAttribute.java	(working copy)
@@ -1,35 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Locale;
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute is used by processor {@link ParametricRangeQueryNodeProcessor}
- * and must be defined in the {@link QueryConfigHandler}. This attribute tells
- * the processor what is the default {@link Locale} used to parse a date. <br/>
- * 
- */
-public interface LocaleAttribute extends Attribute {
-  public void setLocale(Locale locale);
-  public Locale getLocale();
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LocaleAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LocaleAttributeImpl.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LocaleAttributeImpl.java	(working copy)
@@ -1,90 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Locale;
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute is used by processor {@link ParametricRangeQueryNodeProcessor}
- * and must be defined in the {@link QueryConfigHandler}. This attribute tells
- * the processor what is the default {@link Locale} used to parse a date. <br/>
- * 
- * @see org.apache.lucene.queryParser.standard.config.LocaleAttribute
- */
-public class LocaleAttributeImpl extends AttributeImpl
-				implements LocaleAttribute {
-
-  private Locale locale = Locale.getDefault();
-
-  public LocaleAttributeImpl() {
-	  locale = Locale.getDefault(); //default in 2.4
-  }
-
-  public void setLocale(Locale locale) {
-    this.locale = locale;
-  }
-
-  public Locale getLocale() {
-    return this.locale;
-  }
-
-  @Override
-  public void clear() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof LocaleAttributeImpl) {
-    	LocaleAttributeImpl localeAttr = (LocaleAttributeImpl) other;
-
-      if (localeAttr.locale == this.locale
-          || (this.locale != null && localeAttr.locale != null && this.locale
-              .equals(localeAttr.locale))) {
-
-        return true;
-
-      }
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    return (this.locale == null) ? 0 : this.locale.hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return "<localeAttribute locale=" + this.locale + "/>";
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LowercaseExpandedTermsAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LowercaseExpandedTermsAttribute.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LowercaseExpandedTermsAttribute.java	(working copy)
@@ -1,35 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Locale;
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute is used by processor {@link ParametricRangeQueryNodeProcessor}
- * and must be defined in the {@link QueryConfigHandler}. This attribute tells
- * the processor what is the default {@link Locale} used to parse a date. <br/>
- * 
- */
-public interface LowercaseExpandedTermsAttribute extends Attribute {
-  public void setLowercaseExpandedTerms(boolean lowercaseExpandedTerms);
-  public boolean isLowercaseExpandedTerms();
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LowercaseExpandedTermsAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LowercaseExpandedTermsAttributeImpl.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/LowercaseExpandedTermsAttributeImpl.java	(working copy)
@@ -1,85 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Locale;
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute is used by processor {@link ParametricRangeQueryNodeProcessor}
- * and must be defined in the {@link QueryConfigHandler}. This attribute tells
- * the processor what is the default {@link Locale} used to parse a date. <br/>
- * 
- * @see org.apache.lucene.queryParser.standard.config.LowercaseExpandedTermsAttribute
- */
-public class LowercaseExpandedTermsAttributeImpl extends AttributeImpl
-				implements LowercaseExpandedTermsAttribute {
-
-  private boolean lowercaseExpandedTerms = true;
-
-  public LowercaseExpandedTermsAttributeImpl() {
-    lowercaseExpandedTerms = true; // default in 2.4
-  }
-
-  public void setLowercaseExpandedTerms(boolean lowercaseExpandedTerms) {
-	  this.lowercaseExpandedTerms = lowercaseExpandedTerms; 
-  }
-
-  public boolean isLowercaseExpandedTerms() {
-    return this.lowercaseExpandedTerms;
-  }
-
-  @Override
-  public void clear() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof LowercaseExpandedTermsAttributeImpl
-        && ((LowercaseExpandedTermsAttributeImpl) other).lowercaseExpandedTerms == this.lowercaseExpandedTerms) {
-
-      return true;
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    return this.lowercaseExpandedTerms ? -1 : Integer.MAX_VALUE;
-  }
-
-  @Override
-  public String toString() {
-    return "<lowercaseExpandedTerms lowercaseExpandedTerms="
-        + this.lowercaseExpandedTerms + "/>";
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiFieldAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiFieldAttribute.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiFieldAttribute.java	(working copy)
@@ -1,33 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.MultiFieldQueryNodeProcessor;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute is used by {@link MultiFieldQueryNodeProcessor} processor and
- * must be defined in the {@link QueryConfigHandler}. This attribute tells the
- * processor to which fields the terms in the query should be expanded. <br/>
- * 
- */
-public interface MultiFieldAttribute extends Attribute {
-  public void setFields(CharSequence[] fields);
-  public CharSequence[] getFields();
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiFieldAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiFieldAttributeImpl.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiFieldAttributeImpl.java	(working copy)
@@ -1,84 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Arrays;
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.MultiFieldQueryNodeProcessor;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute is used by {@link MultiFieldQueryNodeProcessor} processor and
- * must be defined in the {@link QueryConfigHandler}. This attribute tells the
- * processor to which fields the terms in the query should be expanded. <br/>
- * 
- * @see org.apache.lucene.queryParser.standard.config.MultiFieldAttribute
- */
-public class MultiFieldAttributeImpl extends AttributeImpl
-				implements MultiFieldAttribute {
-
-  private CharSequence[] fields;
-
-  public MultiFieldAttributeImpl() {
-    // empty constructor
-  }
-
-  public void setFields(CharSequence[] fields) {
-    this.fields = fields;
-  }
-
-  public CharSequence[] getFields() {
-    return this.fields;
-  }
-
-  @Override
-  public void clear() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof MultiFieldAttributeImpl) {
-    	MultiFieldAttributeImpl fieldsAttr = (MultiFieldAttributeImpl) other;
-
-      return Arrays.equals(this.fields, fieldsAttr.fields);
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    return Arrays.hashCode(this.fields);
-  }
-
-  @Override
-  public String toString() {
-    return "<fieldsAttribute fields=" + Arrays.toString(this.fields) + "/>";
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttribute.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttribute.java	(working copy)
@@ -1,40 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.MultiTermQuery.RewriteMethod;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute is used by {@link ParametricRangeQueryNodeProcessor} processor
- * and should be defined in the {@link QueryConfigHandler} used by this
- * processor. It basically tells the processor which {@link RewriteMethod} to
- * use. <br/>
- * 
- */
-public interface MultiTermRewriteMethodAttribute extends Attribute {
-  
-  public static final String TAG_ID = "MultiTermRewriteMethodAttribute";
-  
-  public void setMultiTermRewriteMethod(MultiTermQuery.RewriteMethod method);
-
-  public MultiTermQuery.RewriteMethod getMultiTermRewriteMethod();
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttributeImpl.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/MultiTermRewriteMethodAttributeImpl.java	(working copy)
@@ -1,86 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.ParametricRangeQueryNodeProcessor;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.MultiTermQuery.RewriteMethod;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute is used by {@link ParametricRangeQueryNodeProcessor} processor
- * and should be defined in the {@link QueryConfigHandler} used by this
- * processor. It basically tells the processor which {@link RewriteMethod} to
- * use. <br/>
- * 
- * @see MultiTermRewriteMethodAttribute
- */
-public class MultiTermRewriteMethodAttributeImpl extends AttributeImpl
-    implements MultiTermRewriteMethodAttribute {
-  
-  private MultiTermQuery.RewriteMethod multiTermRewriteMethod = MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT;
-
-  public MultiTermRewriteMethodAttributeImpl() {
-    // empty constructor
-  }
-
-  public void setMultiTermRewriteMethod(MultiTermQuery.RewriteMethod method) {
-    multiTermRewriteMethod = method;
-  }
-
-  public MultiTermQuery.RewriteMethod getMultiTermRewriteMethod() {
-    return multiTermRewriteMethod;
-  }
-
-  @Override
-  public void clear() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof MultiTermRewriteMethodAttributeImpl
-        && ((MultiTermRewriteMethodAttributeImpl) other).multiTermRewriteMethod == this.multiTermRewriteMethod) {
-
-      return true;
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    return multiTermRewriteMethod.hashCode();
-  }
-
-  @Override
-  public String toString() {
-    return "<multiTermRewriteMethod multiTermRewriteMethod="
-        + this.multiTermRewriteMethod + "/>";
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/PositionIncrementsAttribute.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/PositionIncrementsAttribute.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/PositionIncrementsAttribute.java	(working copy)
@@ -1,33 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.AnalyzerQueryNodeProcessor;
-import org.apache.lucene.util.Attribute;
-
-/**
- * This attribute is used by {@link AnalyzerQueryNodeProcessor} processor and
- * must be defined in the {@link QueryConfigHandler}. This attribute tells the
- * processor if the position increment is enabled. <br/>
- *
- */
-public interface PositionIncrementsAttribute extends Attribute {
-  public void setPositionIncrementsEnabled(boolean positionIncrementsEnabled);
-  public boolean isPositionIncrementsEnabled();
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/PositionIncrementsAttributeImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/PositionIncrementsAttributeImpl.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/PositionIncrementsAttributeImpl.java	(working copy)
@@ -1,83 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
-import org.apache.lucene.queryParser.standard.processors.AnalyzerQueryNodeProcessor;
-import org.apache.lucene.util.AttributeImpl;
-
-/**
- * This attribute is used by {@link AnalyzerQueryNodeProcessor} processor and
- * must be defined in the {@link QueryConfigHandler}. This attribute tells the
- * processor if the position increment is enabled. <br/>
- * 
- * @see org.apache.lucene.queryParser.standard.config.PositionIncrementsAttribute
- */
-public class PositionIncrementsAttributeImpl extends AttributeImpl
-				implements PositionIncrementsAttribute {
-
-  private boolean positionIncrementsEnabled = false;
-
-  public PositionIncrementsAttributeImpl() {
-	  positionIncrementsEnabled = false; //default in 2.4
-  }
-
-  public void setPositionIncrementsEnabled(boolean positionIncrementsEnabled) {
-    this.positionIncrementsEnabled = positionIncrementsEnabled;
-  }
-
-  public boolean isPositionIncrementsEnabled() {
-    return this.positionIncrementsEnabled;
-  }
-
-  @Override
-  public void clear() {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public void copyTo(AttributeImpl target) {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override
-  public boolean equals(Object other) {
-
-    if (other instanceof PositionIncrementsAttributeImpl
-        && ((PositionIncrementsAttributeImpl) other).positionIncrementsEnabled == this.positionIncrementsEnabled) {
-
-      return true;
-
-    }
-
-    return false;
-
-  }
-
-  @Override
-  public int hashCode() {
-    return this.positionIncrementsEnabled ? -1 : Integer.MAX_VALUE;
-  }
-
-  @Override
-  public String toString() {
-    return "<positionIncrements positionIncrementsEnabled="
-        + this.positionIncrementsEnabled + "/>";
-  }
-
-}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/StandardQueryConfigHandler.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/StandardQueryConfigHandler.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/StandardQueryConfigHandler.java	(working copy)
@@ -17,37 +17,173 @@
  * limitations under the License.
  */
 
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.Locale;
+import java.util.Map;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.document.DateTools;
+import org.apache.lucene.document.DateTools.Resolution;
+import org.apache.lucene.queryParser.core.config.ConfigurationKey;
+import org.apache.lucene.queryParser.core.config.FieldConfig;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.StandardQueryParser;
 import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.MultiTermQuery.RewriteMethod;
 
 /**
  * This query configuration handler is used for almost every processor defined
  * in the {@link StandardQueryNodeProcessorPipeline} processor pipeline. It holds
- * attributes that reproduces the configuration that could be set on the old
+ * configuration methods that reproduce the configuration methods that could be set on the old
  * lucene 2.4 QueryParser class. <br/>
  * 
  * @see StandardQueryNodeProcessorPipeline
  */
 public class StandardQueryConfigHandler extends QueryConfigHandler {
 
+  final public static class ConfigurationKeys  {
+    
+    /**
+     * Key used to set whether position increments is enabled
+     * 
+     * @see StandardQueryParser#setEnablePositionIncrements(boolean)
+     * @see StandardQueryParser#getEnablePositionIncrements()
+     */
+    final public static ConfigurationKey<Boolean> ENABLE_POSITION_INCREMENTS = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set whether expanded terms should be expanded
+     * 
+     * @see StandardQueryParser#setLowercaseExpandedTerms(boolean)
+     * @see StandardQueryParser#getLowercaseExpandedTerms()
+     */
+    final public static ConfigurationKey<Boolean> LOWERCASE_EXPANDED_TERMS = ConfigurationKey.newInstance();
 
+    /**
+     * Key used to set whether leading wildcards are supported
+     * 
+     * @see StandardQueryParser#setAllowLeadingWildcard(boolean)
+     * @see StandardQueryParser#getAllowLeadingWildcard()
+     */
+    final public static ConfigurationKey<Boolean> ALLOW_LEADING_WILDCARD = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the {@link Analyzer} used for terms found in the query
+     * 
+     * @see StandardQueryParser#setAnalyzer(Analyzer)
+     * @see StandardQueryParser#getAnalyzer()
+     */
+    final public static ConfigurationKey<Analyzer> ANALYZER = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the default boolean operator
+     * 
+     * @see StandardQueryParser#setDefaultOperator(org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator)
+     * @see StandardQueryParser#getDefaultOperator()
+     */
+    final public static ConfigurationKey<Operator> DEFAULT_OPERATOR = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the default phrase slop
+     * 
+     * @see StandardQueryParser#setPhraseSlop(int)
+     * @see StandardQueryParser#getPhraseSlop()
+     */
+    final public static ConfigurationKey<Integer> PHRASE_SLOP = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the {@link Locale} used when parsing the query
+     * 
+     * @see StandardQueryParser#setLocale(Locale)
+     * @see StandardQueryParser#getLocale()
+     */
+    final public static ConfigurationKey<Locale> LOCALE = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the {@link RewriteMethod} used when creating queries
+     * 
+     * @see StandardQueryParser#setMultiTermRewriteMethod(org.apache.lucene.search.MultiTermQuery.RewriteMethod)
+     * @see StandardQueryParser#getMultiTermRewriteMethod()
+     */
+    final public static ConfigurationKey<MultiTermQuery.RewriteMethod> MULTI_TERM_REWRITE_METHOD = ConfigurationKey.newInstance();
 
+    /**
+     * Key used to set the fields a query should be expanded to when the field
+     * is <code>null</code>
+     * 
+     * @see StandardQueryParser#setMultiFields(CharSequence[])
+     * @see StandardQueryParser#getMultiFields(CharSequence[])
+     */
+    final public static ConfigurationKey<CharSequence[]> MULTI_FIELDS = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set a field to boost map that is used to set the boost for each field
+     * 
+     * @see StandardQueryParser#setFieldsBoost(Map)
+     * @see StandardQueryParser#getFieldsBoost()
+     */
+    final public static ConfigurationKey<Map<String,Float>> FIELD_BOOST_MAP = ConfigurationKey.newInstance();
+
+    /**
+     * Key used to set a field to {@link Resolution} map that is used
+     * to normalize each date field value.
+     * 
+     * @see StandardQueryParser#setDateResolutionMap(Map)
+     * @see StandardQueryParser#getDateResolutionMap()
+     */
+    final public static ConfigurationKey<Map<CharSequence, DateTools.Resolution>> FIELD_DATE_RESOLUTION_MAP = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the {@link FuzzyConfig} used to create fuzzy queries.
+     * 
+     * @see StandardQueryParser#setFuzzyMinSim(float)
+     * @see StandardQueryParser#setFuzzyPrefixLength(int)
+     * @see StandardQueryParser#getFuzzyMinSim()
+     * @see StandardQueryParser#getFuzzyPrefixLength()
+     */
+    final public static ConfigurationKey<FuzzyConfig> FUZZY_CONFIG = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set default {@link Resolution}.
+     * 
+     * @see StandardQueryParser#setDateResolution(org.apache.lucene.document.DateTools.Resolution)
+     * @see StandardQueryParser#getDateResolution()
+     */
+    final public static ConfigurationKey<DateTools.Resolution> DATE_RESOLUTION = ConfigurationKey.newInstance();
+    
+    /**
+     * Key used to set the boost value in {@link FieldConfig} objects.
+     * 
+     * @see StandardQueryParser#setFieldsBoost(Map)
+     * @see StandardQueryParser#getFieldsBoost()
+     */
+    final public static ConfigurationKey<Float> BOOST = ConfigurationKey.newInstance();
+    
+  }
+  
+  public static enum Operator {
+    AND, OR;
+  }
+
   public StandardQueryConfigHandler() {
-    // Add listener that will build the FieldConfig attributes.
+    // Add listener that will build the FieldConfig.
     addFieldConfigListener(new FieldBoostMapFCListener(this));
     addFieldConfigListener(new FieldDateResolutionFCListener(this));
-
+    
     // Default Values
-    addAttribute(DefaultOperatorAttribute.class);
-    addAttribute(AnalyzerAttribute.class);
-    addAttribute(FuzzyAttribute.class);
-    addAttribute(LowercaseExpandedTermsAttribute.class);
-    addAttribute(MultiTermRewriteMethodAttribute.class);
-    addAttribute(AllowLeadingWildcardAttribute.class);
-    addAttribute(PositionIncrementsAttribute.class);
-    addAttribute(LocaleAttribute.class);
-    addAttribute(DefaultPhraseSlopAttribute.class);
-    addAttribute(MultiTermRewriteMethodAttribute.class);   
+    set(ConfigurationKeys.ALLOW_LEADING_WILDCARD, false); // default in 2.9
+    set(ConfigurationKeys.ANALYZER, null); //default value 2.4
+    set(ConfigurationKeys.DEFAULT_OPERATOR, Operator.OR);
+    set(ConfigurationKeys.PHRASE_SLOP, 0); //default value 2.4
+    set(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS, true); //default value 2.4
+    set(ConfigurationKeys.ENABLE_POSITION_INCREMENTS, false); //default value 2.4
+    set(ConfigurationKeys.FIELD_BOOST_MAP, new LinkedHashMap<String, Float>());
+    set(ConfigurationKeys.FUZZY_CONFIG, new FuzzyConfig());
+    set(ConfigurationKeys.LOCALE, Locale.getDefault());
+    set(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD, MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT);
+    set(ConfigurationKeys.FIELD_DATE_RESOLUTION_MAP, new HashMap<CharSequence, DateTools.Resolution>());
     
   }
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/package.html
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/package.html	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/config/package.html	(working copy)
@@ -24,7 +24,7 @@
 <h2>Standard Lucene Query Configuration</h2>
 <p>
 The package org.apache.lucene.queryParser.standard.config contains the Lucene
-query configuration handler and all the attributes used by it. This configuration
+query configuration handler (StandardQueryConfigHandler). This configuration
 handler reproduces almost everything that could be set on the old query parser.
 </p>
 <p>
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AllowLeadingWildcardProcessor.java	(working copy)
@@ -26,18 +26,18 @@
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.core.util.UnescapedCharSequence;
-import org.apache.lucene.queryParser.standard.config.AllowLeadingWildcardAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.queryParser.standard.parser.EscapeQuerySyntaxImpl;
 
 /**
- * This processor verifies if the attribute
- * {@link AllowLeadingWildcardAttribute} is defined in the
+ * This processor verifies if
+ * {@link ConfigurationKeys#ALLOW_LEADING_WILDCARD} is defined in the
  * {@link QueryConfigHandler}. If it is and leading wildcard is not allowed, it
  * looks for every {@link WildcardQueryNode} contained in the query node tree
  * and throws an exception if any of them has a leading wildcard ('*' or '?'). <br/>
  * 
- * @see AllowLeadingWildcardAttribute
+ * @see ConfigurationKeys#ALLOW_LEADING_WILDCARD
  */
 public class AllowLeadingWildcardProcessor extends QueryNodeProcessorImpl {
 
@@ -47,11 +47,11 @@
 
   @Override
   public QueryNode process(QueryNode queryTree) throws QueryNodeException {
+    Boolean allowsLeadingWildcard = getQueryConfigHandler().get(ConfigurationKeys.ALLOW_LEADING_WILDCARD);
 
-    if (getQueryConfigHandler().hasAttribute(AllowLeadingWildcardAttribute.class)) {
+    if (allowsLeadingWildcard != null) {
 
-      AllowLeadingWildcardAttribute alwAttr= getQueryConfigHandler().getAttribute(AllowLeadingWildcardAttribute.class);
-      if (!alwAttr.isAllowLeadingWildcard()) {
+      if (!allowsLeadingWildcard) {
         return super.process(queryTree);
       }
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/AnalyzerQueryNodeProcessor.java	(working copy)
@@ -40,14 +40,14 @@
 import org.apache.lucene.queryParser.core.nodes.TextableQueryNode;
 import org.apache.lucene.queryParser.core.nodes.TokenizedPhraseQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.AnalyzerAttribute;
-import org.apache.lucene.queryParser.standard.config.PositionIncrementsAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.nodes.MultiPhraseQueryNode;
 import org.apache.lucene.queryParser.standard.nodes.StandardBooleanQueryNode;
 import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 
 /**
- * This processor verifies if the attribute {@link AnalyzerQueryNodeProcessor}
+ * This processor verifies if {@link ConfigurationKeys#ANALYZER}
  * is defined in the {@link QueryConfigHandler}. If it is and the analyzer is
  * not <code>null</code>, it looks for every {@link FieldQueryNode} that is not
  * {@link WildcardQueryNode}, {@link FuzzyQueryNode} or
@@ -64,6 +64,7 @@
  * If no term is returned by the analyzer a {@link NoTokenFoundQueryNode} object
  * is returned. <br/>
  * 
+ * @see ConfigurationKeys#ANALYZER
  * @see Analyzer
  * @see TokenStream
  */
@@ -79,24 +80,15 @@
 
   @Override
   public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-
-    if (getQueryConfigHandler().hasAttribute(AnalyzerAttribute.class)) {
-
-      this.analyzer = getQueryConfigHandler().getAttribute(
-          AnalyzerAttribute.class).getAnalyzer();
-
+    Analyzer analyzer = getQueryConfigHandler().get(ConfigurationKeys.ANALYZER);
+    
+    if (analyzer != null) {
+      this.analyzer = analyzer;
       this.positionIncrementsEnabled = false;
+      Boolean positionIncrementsEnabled = getQueryConfigHandler().get(ConfigurationKeys.ENABLE_POSITION_INCREMENTS);
 
-      if (getQueryConfigHandler().hasAttribute(
-          PositionIncrementsAttribute.class)) {
-
-        if (getQueryConfigHandler().getAttribute(
-            PositionIncrementsAttribute.class).isPositionIncrementsEnabled()) {
-
-          this.positionIncrementsEnabled = true;
-
-        }
-
+      if (positionIncrementsEnabled != null) {
+          this.positionIncrementsEnabled = positionIncrementsEnabled;
       }
 
       if (this.analyzer != null) {
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/BoostQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/BoostQueryNodeProcessor.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/BoostQueryNodeProcessor.java	(working copy)
@@ -27,14 +27,14 @@
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.core.util.StringUtils;
-import org.apache.lucene.queryParser.standard.config.BoostAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 
 /**
  * This processor iterates the query node tree looking for every
- * {@link FieldableNode} that has the attribute {@link BoostAttribute} in its
+ * {@link FieldableNode} that has {@link ConfigurationKeys#BOOST} in its
  * config. If there is, the boost is applied to that {@link FieldableNode}. <br/>
  * 
- * @see BoostAttribute
+ * @see ConfigurationKeys#BOOST
  * @see QueryConfigHandler
  * @see FieldableNode
  */
@@ -53,10 +53,12 @@
         CharSequence field = fieldNode.getField();
         FieldConfig fieldConfig = config.getFieldConfig(StringUtils.toString(field));
 
-        if (fieldConfig != null && fieldConfig.hasAttribute(BoostAttribute.class)) {
-          BoostAttribute boostAttr = fieldConfig.getAttribute(BoostAttribute.class);
+        if (fieldConfig != null) {
+          Float boost = fieldConfig.get(ConfigurationKeys.BOOST);
 
-          return new BoostQueryNode(node, boostAttr.getBoost());
+          if (boost != null) {
+            return new BoostQueryNode(node, boost);
+          }
 
         }
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/DefaultPhraseSlopQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/DefaultPhraseSlopQueryNodeProcessor.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/DefaultPhraseSlopQueryNodeProcessor.java	(working copy)
@@ -25,19 +25,20 @@
 import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
 import org.apache.lucene.queryParser.core.nodes.TokenizedPhraseQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.DefaultPhraseSlopAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.nodes.MultiPhraseQueryNode;
 
 /**
- * This processor verifies if the attribute {@link DefaultPhraseSlopAttribute}
+ * This processor verifies if {@link ConfigurationKeys#PHRASE_SLOP}
  * is defined in the {@link QueryConfigHandler}. If it is, it looks for every
  * {@link TokenizedPhraseQueryNode} and {@link MultiPhraseQueryNode} that does
  * not have any {@link SlopQueryNode} applied to it and creates an
  * {@link SlopQueryNode} and apply to it. The new {@link SlopQueryNode} has the
- * same slop value defined in the attribute. <br/>
+ * same slop value defined in the configuration. <br/>
  * 
  * @see SlopQueryNode
- * @see DefaultPhraseSlopAttribute
+ * @see ConfigurationKeys#PHRASE_SLOP
  */
 public class DefaultPhraseSlopQueryNodeProcessor extends QueryNodeProcessorImpl {
 
@@ -54,11 +55,11 @@
     QueryConfigHandler queryConfig = getQueryConfigHandler();
 
     if (queryConfig != null) {
+      Integer defaultPhraseSlop = queryConfig.get(ConfigurationKeys.PHRASE_SLOP); 
+      
+      if (defaultPhraseSlop != null) {
+        this.defaultPhraseSlop = defaultPhraseSlop;
 
-      if (queryConfig.hasAttribute(DefaultPhraseSlopAttribute.class)) {
-        this.defaultPhraseSlop = queryConfig.getAttribute(
-            DefaultPhraseSlopAttribute.class).getDefaultPhraseSlop();
-
         return super.process(queryTree);
 
       }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/FuzzyQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/FuzzyQueryNodeProcessor.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/FuzzyQueryNodeProcessor.java	(working copy)
@@ -24,17 +24,20 @@
 import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.FuzzyAttribute;
+import org.apache.lucene.queryParser.standard.config.FuzzyConfig;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.search.FuzzyQuery;
 
 /**
  * This processor iterates the query node tree looking for every
  * {@link FuzzyQueryNode}, when this kind of node is found, it checks on the
- * query configuration for {@link FuzzyAttribute}, gets the fuzzy prefix length
- * and default similarity from it and set to the fuzzy node. For more
- * information about fuzzy prefix length check: {@link FuzzyQuery}. <br/>
+ * query configuration for
+ * {@link ConfigurationKeys#FUZZY_CONFIG}, gets the
+ * fuzzy prefix length and default similarity from it and set to the fuzzy node.
+ * For more information about fuzzy prefix length check: {@link FuzzyQuery}. <br/>
  * 
- * @see FuzzyAttribute
+ * @see ConfigurationKeys#FUZZY_CONFIG
  * @see FuzzyQuery
  * @see FuzzyQueryNode
  */
@@ -54,18 +57,17 @@
       FuzzyQueryNode fuzzyNode = (FuzzyQueryNode) node;
       QueryConfigHandler config = getQueryConfigHandler();
 
-      if (config != null && config.hasAttribute(FuzzyAttribute.class)) {
-        FuzzyAttribute fuzzyAttr = config.getAttribute(FuzzyAttribute.class);
-        fuzzyNode.setPrefixLength(fuzzyAttr.getPrefixLength());
+      FuzzyConfig fuzzyConfig = null;
+      
+      if (config != null && (fuzzyConfig = config.get(ConfigurationKeys.FUZZY_CONFIG)) != null) {
+        fuzzyNode.setPrefixLength(fuzzyConfig.getPrefixLength());
 
         if (fuzzyNode.getSimilarity() < 0) {
-          fuzzyNode.setSimilarity(fuzzyAttr.getFuzzyMinSimilarity());
-
+          fuzzyNode.setSimilarity(fuzzyConfig.getMinSimilarity());
         }
-
+        
       } else if (fuzzyNode.getSimilarity() < 0) {
-        throw new IllegalArgumentException("No "
-            + FuzzyAttribute.class.getName() + " set in the config");
+        throw new IllegalArgumentException("No FUZZY_CONFIG set in the config");
       }
 
     }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/GroupQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/GroupQueryNodeProcessor.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/GroupQueryNodeProcessor.java	(working copy)
@@ -31,8 +31,9 @@
 import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode.Modifier;
 import org.apache.lucene.queryParser.core.parser.SyntaxParser;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessor;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator;
 import org.apache.lucene.queryParser.standard.nodes.BooleanModifierNode;
 
 /**
@@ -64,14 +65,14 @@
   }
 
   public QueryNode process(QueryNode queryTree) throws QueryNodeException {
-
-    if (!getQueryConfigHandler().hasAttribute(DefaultOperatorAttribute.class)) {
+    Operator defaultOperator = getQueryConfigHandler().get(ConfigurationKeys.DEFAULT_OPERATOR);
+    
+    if (defaultOperator == null) {
       throw new IllegalArgumentException(
-          "DefaultOperatorAttribute should be set on the QueryConfigHandler");
+          "DEFAULT_OPERATOR should be set on the QueryConfigHandler");
     }
 
-    this.usingAnd = Operator.AND == getQueryConfigHandler()
-        .getAttribute(DefaultOperatorAttribute.class).getOperator();
+    this.usingAnd = StandardQueryConfigHandler.Operator.AND == defaultOperator;
 
     if (queryTree instanceof GroupQueryNode) {
       queryTree = ((GroupQueryNode) queryTree).getChild();
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/LowercaseExpandedTermsQueryNodeProcessor.java	(working copy)
@@ -27,19 +27,20 @@
 import org.apache.lucene.queryParser.core.nodes.TextableQueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.core.util.UnescapedCharSequence;
-import org.apache.lucene.queryParser.standard.config.LowercaseExpandedTermsAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.nodes.RegexpQueryNode;
 import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 
 /**
- * This processor verifies if the attribute
- * {@link LowercaseExpandedTermsAttribute} is defined in the
+ * This processor verifies if 
+ * {@link ConfigurationKeys#LOWERCASE_EXPANDED_TERMS} is defined in the
  * {@link QueryConfigHandler}. If it is and the expanded terms should be
  * lower-cased, it looks for every {@link WildcardQueryNode},
  * {@link FuzzyQueryNode} and {@link ParametricQueryNode} and lower-case its
  * term. <br/>
  * 
- * @see LowercaseExpandedTermsAttribute
+ * @see ConfigurationKeys#LOWERCASE_EXPANDED_TERMS
  */
 public class LowercaseExpandedTermsQueryNodeProcessor extends
     QueryNodeProcessorImpl {
@@ -50,17 +51,10 @@
 
   @Override
   public QueryNode process(QueryNode queryTree) throws QueryNodeException {
+    Boolean lowercaseExpandedTerms = getQueryConfigHandler().get(ConfigurationKeys.LOWERCASE_EXPANDED_TERMS);
 
-    if (getQueryConfigHandler().hasAttribute(
-        LowercaseExpandedTermsAttribute.class)) {
-
-      if (getQueryConfigHandler().getAttribute(
-          LowercaseExpandedTermsAttribute.class).isLowercaseExpandedTerms()) {
-        
-        return super.process(queryTree);
-        
-      }
-
+    if (lowercaseExpandedTerms != null && lowercaseExpandedTerms) {
+      return super.process(queryTree);
     }
 
     return queryTree;
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiFieldQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiFieldQueryNodeProcessor.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiFieldQueryNodeProcessor.java	(working copy)
@@ -27,7 +27,8 @@
 import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.MultiFieldAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 
 /**
  * This processor is used to expand terms so the query looks for the same term
@@ -35,13 +36,13 @@
  * <br/>
  * This processor looks for every {@link FieldableNode} contained in the query
  * node tree. If a {@link FieldableNode} is found, it checks if there is a
- * {@link MultiFieldAttribute} defined in the {@link QueryConfigHandler}. If
+ * {@link ConfigurationKeys#MULTI_FIELDS} defined in the {@link QueryConfigHandler}. If
  * there is, the {@link FieldableNode} is cloned N times and the clones are
  * added to a {@link BooleanQueryNode} together with the original node. N is
  * defined by the number of fields that it will be expanded to. The
  * {@link BooleanQueryNode} is returned. <br/>
  * 
- * @see MultiFieldAttribute
+ * @see ConfigurationKeys#MULTI_FIELDS
  */
 public class MultiFieldQueryNodeProcessor extends QueryNodeProcessorImpl {
 
@@ -78,15 +79,13 @@
       FieldableNode fieldNode = (FieldableNode) node;
 
       if (fieldNode.getField() == null) {
+        CharSequence[] fields = getQueryConfigHandler().get(ConfigurationKeys.MULTI_FIELDS);
 
-        if (!getQueryConfigHandler().hasAttribute(MultiFieldAttribute.class)) {
+        if (fields == null) {
           throw new IllegalArgumentException(
-              "MultiFieldAttribute should be set on the QueryConfigHandler");
+              "StandardQueryConfigHandler.ConfigurationKeys.MULTI_FIELDS should be set on the QueryConfigHandler");
         }
 
-        CharSequence[] fields = getQueryConfigHandler().getAttribute(
-            MultiFieldAttribute.class).getFields();
-
         if (fields != null && fields.length > 0) {
           fieldNode.setField(fields[0]);
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteMethodProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteMethodProcessor.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/MultiTermRewriteMethodProcessor.java	(working copy)
@@ -22,7 +22,7 @@
 import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.MultiTermRewriteMethodAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.nodes.RegexpQueryNode;
 import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.search.MultiTermQuery;
@@ -35,6 +35,8 @@
  */
 public class MultiTermRewriteMethodProcessor extends QueryNodeProcessorImpl {
 
+  public static final String TAG_ID = "MultiTermRewriteMethodConfiguration";
+
   @Override
   protected QueryNode postProcessNode(QueryNode node) {
 
@@ -42,22 +44,19 @@
     // PrefixWildcardQueryNode
     if (node instanceof WildcardQueryNode
         || node instanceof ParametricRangeQueryNode || node instanceof RegexpQueryNode) {
+      
+      MultiTermQuery.RewriteMethod rewriteMethod = getQueryConfigHandler().get(ConfigurationKeys.MULTI_TERM_REWRITE_METHOD);
 
-      if (!getQueryConfigHandler().hasAttribute(
-          MultiTermRewriteMethodAttribute.class)) {
-        // This should not happen, this attribute is created in the
+      if (rewriteMethod == null) {
+        // This should not happen, this configuration is set in the
         // StandardQueryConfigHandler
         throw new IllegalArgumentException(
-            "MultiTermRewriteMethodAttribute should be set on the QueryConfigHandler");
+            "StandardQueryConfigHandler.ConfigurationKeys.MULTI_TERM_REWRITE_METHOD should be set on the QueryConfigHandler");
       }
 
-      // read the attribute value and use a TAG to take the value to the Builder
-      MultiTermQuery.RewriteMethod rewriteMethod = getQueryConfigHandler()
-          .getAttribute(MultiTermRewriteMethodAttribute.class)
-          .getMultiTermRewriteMethod();
+      // use a TAG to take the value to the Builder
+      node.setTag(MultiTermRewriteMethodProcessor.TAG_ID, rewriteMethod);
 
-      node.setTag(MultiTermRewriteMethodAttribute.TAG_ID, rewriteMethod);
-
     }
 
     return node;
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java	(revision 1142535)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/processors/ParametricRangeQueryNodeProcessor.java	(working copy)
@@ -33,8 +33,8 @@
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode.CompareOperator;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
-import org.apache.lucene.queryParser.standard.config.DateResolutionAttribute;
-import org.apache.lucene.queryParser.standard.config.LocaleAttribute;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.ConfigurationKeys;
 import org.apache.lucene.queryParser.standard.nodes.RangeQueryNode;
 
 /**
@@ -45,16 +45,16 @@
  * value, it will only create the {@link RangeQueryNode} using the non-parsed
  * values. <br/>
  * <br/>
- * If a {@link LocaleAttribute} is defined in the {@link QueryConfigHandler} it
+ * If a {@link ConfigurationKeys#LOCALE} is defined in the {@link QueryConfigHandler} it
  * will be used to parse the date, otherwise {@link Locale#getDefault()} will be
  * used. <br/>
  * <br/>
- * If a {@link DateResolutionAttribute} is defined and the {@link Resolution} is
+ * If a {@link ConfigurationKeys#DATE_RESOLUTION} is defined and the {@link Resolution} is
  * not <code>null</code> it will also be used to parse the date value. <br/>
  * <br/>
  * 
- * @see DateResolutionAttribute
- * @see LocaleAttribute
+ * @see ConfigurationKeys#DATE_RESOLUTION
+ * @see ConfigurationKeys#LOCALE
  * @see RangeQueryNode
  * @see ParametricRangeQueryNode
  */
@@ -71,15 +71,13 @@
       ParametricRangeQueryNode parametricRangeNode = (ParametricRangeQueryNode) node;
       ParametricQueryNode upper = parametricRangeNode.getUpperBound();
       ParametricQueryNode lower = parametricRangeNode.getLowerBound();
-      Locale locale = Locale.getDefault();
+      
       DateTools.Resolution dateRes = null;
       boolean inclusive = false;
+      Locale locale = getQueryConfigHandler().get(ConfigurationKeys.LOCALE);
 
-      if (getQueryConfigHandler().hasAttribute(LocaleAttribute.class)) {
-
-        locale = getQueryConfigHandler().getAttribute(LocaleAttribute.class)
-            .getLocale();
-
+      if (locale == null) {
+        locale = Locale.getDefault();
       }
 
       CharSequence field = parametricRangeNode.getField();
@@ -93,14 +91,7 @@
           .getFieldConfig(fieldStr);
 
       if (fieldConfig != null) {
-
-        if (fieldConfig.hasAttribute(DateResolutionAttribute.class)) {
-
-          dateRes = fieldConfig.getAttribute(DateResolutionAttribute.class)
-              .getDateResolution();
-
-        }
-
+        dateRes = fieldConfig.get(ConfigurationKeys.DATE_RESOLUTION);
       }
 
       if (upper.getOperator() == CompareOperator.LE) {
Index: contrib/queryparser/src/java/overview.html
===================================================================
--- contrib/queryparser/src/java/overview.html	(revision 1142535)
+++ contrib/queryparser/src/java/overview.html	(working copy)
@@ -108,8 +108,7 @@
 </dl>
 
 <p>
-Furthermore, the query parser uses flexible configuration objects, which
-are based on AttributeSource/Attribute. It also uses message classes that
+Furthermore, the query parser uses flexible configuration objects. It also uses message classes that
 allow to attach resource bundles. This makes it possible to translate
 messages, which is an important feature of a query parser.
 </p>
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java	(revision 1142535)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java	(working copy)
@@ -38,7 +38,7 @@
 import org.apache.lucene.queryParser.TestQueryParser;
 import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.QueryNodeParseException;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
 import org.apache.lucene.queryParser.standard.parser.ParseException;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.FuzzyQuery;
@@ -128,7 +128,7 @@
       a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
     PrecedenceQueryParser qp = new PrecedenceQueryParser();
     qp.setAnalyzer(a);
-    qp.setDefaultOperator(Operator.OR);
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.OR);
     return qp;
   }
 
@@ -174,7 +174,7 @@
       a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
     PrecedenceQueryParser qp = new PrecedenceQueryParser();
     qp.setAnalyzer(a);
-    qp.setDefaultOperator(Operator.AND);
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
     return qp.parse(query, "field");
   }
 
@@ -234,11 +234,11 @@
     PrecedenceQueryParser qp = new PrecedenceQueryParser();
     qp.setAnalyzer(new MockAnalyzer(random));
     // make sure OR is the default:
-    assertEquals(Operator.OR, qp.getDefaultOperator());
-    qp.setDefaultOperator(Operator.AND);
-    assertEquals(Operator.AND, qp.getDefaultOperator());
-    qp.setDefaultOperator(Operator.OR);
-    assertEquals(Operator.OR, qp.getDefaultOperator());
+    assertEquals(StandardQueryConfigHandler.Operator.OR, qp.getDefaultOperator());
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
+    assertEquals(StandardQueryConfigHandler.Operator.AND, qp.getDefaultOperator());
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.OR);
+    assertEquals(StandardQueryConfigHandler.Operator.OR, qp.getDefaultOperator());
 
     assertQueryEquals("a OR !b", null, "a -b");
     assertQueryEquals("a OR ! b", null, "a -b");
@@ -607,7 +607,7 @@
     query2 = parser.parse("A (-B +C)", "field");
     assertEquals(query1, query2);
     
-    parser.setDefaultOperator(Operator.AND);
+    parser.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
     query1 = parser.parse("A AND B OR C AND D", "field");
     query2 = parser.parse("(A AND B) OR (C AND D)", "field");
     assertEquals(query1, query2);
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansQueryConfigHandler.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansQueryConfigHandler.java	(revision 1142535)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/SpansQueryConfigHandler.java	(working copy)
@@ -17,6 +17,7 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.queryParser.core.config.ConfigurationKey;
 import org.apache.lucene.queryParser.core.config.FieldConfig;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
 
@@ -27,9 +28,11 @@
  * It does not return any configuration for a field in specific.
  */
 public class SpansQueryConfigHandler extends QueryConfigHandler {
-
+  
+  final public static ConfigurationKey<String> UNIQUE_FIELD = ConfigurationKey.newInstance();
+  
   public SpansQueryConfigHandler() {
-    addAttribute(UniqueFieldAttribute.class);
+    // empty constructor
   }
 
   @Override
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java	(revision 1142535)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java	(working copy)
@@ -127,11 +127,10 @@
     return getSpanQuery("", query);
   }
 
-  public SpanQuery getSpanQuery(CharSequence uniqueField, CharSequence query)
+  public SpanQuery getSpanQuery(String uniqueField, CharSequence query)
       throws QueryNodeException {
-    UniqueFieldAttribute uniqueFieldAtt = this.spanQueryConfigHandler
-        .getAttribute(UniqueFieldAttribute.class);
-    uniqueFieldAtt.setUniqueField(uniqueField);
+    
+    this.spanQueryConfigHandler.set(SpansQueryConfigHandler.UNIQUE_FIELD, uniqueField);
 
     QueryNode queryTree = this.queryParser.parse(query, "defaultField");
     queryTree = this.spanProcessorPipeline.process(queryTree);
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParserSimpleSample.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParserSimpleSample.java	(revision 1142535)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParserSimpleSample.java	(working copy)
@@ -104,9 +104,7 @@
     // create a config handler with a attribute used in
     // UniqueFieldQueryNodeProcessor
     QueryConfigHandler spanQueryConfigHandler = new SpansQueryConfigHandler();
-    UniqueFieldAttribute uniqueFieldAtt = spanQueryConfigHandler
-        .getAttribute(UniqueFieldAttribute.class);
-    uniqueFieldAtt.setUniqueField("index");
+    spanQueryConfigHandler.set(SpansQueryConfigHandler.UNIQUE_FIELD, "index");
 
     // set up the processor pipeline with the ConfigHandler
     // and create the pipeline for this simple demo
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldQueryNodeProcessor.java	(revision 1142535)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/UniqueFieldQueryNodeProcessor.java	(working copy)
@@ -57,14 +57,12 @@
             "A config handler is expected by the processor UniqueFieldQueryNodeProcessor!");
       }
 
-      if (!queryConfig.hasAttribute(UniqueFieldAttribute.class)) {
+      if (!queryConfig.has(SpansQueryConfigHandler.UNIQUE_FIELD)) {
         throw new IllegalArgumentException(
             "UniqueFieldAttribute should be defined in the config handler!");
       }
 
-      CharSequence uniqueField = queryConfig.getAttribute(
-          UniqueFieldAttribute.class).getUniqueField();
-
+      String uniqueField = queryConfig.get(SpansQueryConfigHandler.UNIQUE_FIELD);
       fieldNode.setField(uniqueField);
 
     }
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiAnalyzerQPHelper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiAnalyzerQPHelper.java	(revision 1142535)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiAnalyzerQPHelper.java	(working copy)
@@ -28,7 +28,8 @@
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.analysis.tokenattributes.TypeAttribute;
 import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator;
 import org.apache.lucene.util.LuceneTestCase;
 
 /**
@@ -102,7 +103,7 @@
     qp.setDefaultPhraseSlop(0);
 
     // non-default operator:
-    qp.setDefaultOperator(Operator.AND);
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
     assertEquals("+(multi multi2) +foo", qp.parse("multi foo", "").toString());
 
   }
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQPHelper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQPHelper.java	(revision 1142535)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestMultiFieldQPHelper.java	(working copy)
@@ -28,7 +28,8 @@
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.queryParser.core.QueryNodeException;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler.Operator;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
@@ -133,7 +134,7 @@
     assertEquals("(b:one t:one) f:two", q.toString());
 
     // AND mode:
-    mfqp.setDefaultOperator(Operator.AND);
+    mfqp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
     q = mfqp.parse("one two", null);
     assertEquals("+(b:one t:one) +(b:two t:two)", q.toString());
     q = mfqp.parse("\"aa bb cc\" \"dd ee\"", null);
@@ -329,7 +330,7 @@
 
     mfqp.setMultiFields(new String[] { "body" });
     mfqp.setAnalyzer(analyzer);
-    mfqp.setDefaultOperator(Operator.AND);
+    mfqp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
     Query q = mfqp.parse("the footest", null);
     IndexSearcher is = new IndexSearcher(ramDir, true);
     ScoreDoc[] hits = is.search(q, null, 1000).scoreDocs;
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java	(revision 1142535)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java	(working copy)
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 import java.io.Reader;
-import java.text.Collator;
 import java.text.DateFormat;
 import java.util.Calendar;
 import java.util.Date;
@@ -52,7 +51,7 @@
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
 import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorPipeline;
-import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
 import org.apache.lucene.queryParser.standard.nodes.WildcardQueryNode;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
@@ -195,7 +194,7 @@
     StandardQueryParser qp = new StandardQueryParser();
     qp.setAnalyzer(a);
 
-    qp.setDefaultOperator(Operator.OR);
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.OR);
 
     return qp;
 
@@ -284,7 +283,7 @@
       a = new MockAnalyzer(random, MockTokenizer.SIMPLE, true);
     StandardQueryParser qp = new StandardQueryParser();
     qp.setAnalyzer(a);
-    qp.setDefaultOperator(Operator.AND);
+    qp.setDefaultOperator(StandardQueryConfigHandler.Operator.AND);
 
     return qp.parse(query, "field");
 
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/config/TestAttributes.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/config/TestAttributes.java	(revision 1142535)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/config/TestAttributes.java	(working copy)
@@ -1,65 +0,0 @@
-package org.apache.lucene.queryParser.standard.config;
-
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.util._TestUtil;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.search.FuzzyQuery;
-import org.apache.lucene.search.MultiTermQuery;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Locale;
-
-public class TestAttributes extends LuceneTestCase {
-
-  // this checks using reflection API if the defaults are correct
-  public void testAttributes() {
-    _TestUtil.assertAttributeReflection(new AllowLeadingWildcardAttributeImpl(),
-      Collections.singletonMap(AllowLeadingWildcardAttribute.class.getName()+"#allowLeadingWildcard", false));
-    _TestUtil.assertAttributeReflection(new AnalyzerAttributeImpl(),
-      Collections.singletonMap(AnalyzerAttribute.class.getName()+"#analyzer", null));
-    _TestUtil.assertAttributeReflection(new BoostAttributeImpl(),
-      Collections.singletonMap(BoostAttribute.class.getName()+"#boost", 1.0f));
-    _TestUtil.assertAttributeReflection(new DateResolutionAttributeImpl(),
-      Collections.singletonMap(DateResolutionAttribute.class.getName()+"#dateResolution", null));
-    _TestUtil.assertAttributeReflection(new DefaultOperatorAttributeImpl(),
-      Collections.singletonMap(DefaultOperatorAttribute.class.getName()+"#operator", DefaultOperatorAttribute.Operator.OR));
-    _TestUtil.assertAttributeReflection(new DefaultPhraseSlopAttributeImpl(),
-      Collections.singletonMap(DefaultPhraseSlopAttribute.class.getName()+"#defaultPhraseSlop", 0));
-    _TestUtil.assertAttributeReflection(new FieldBoostMapAttributeImpl(),
-      Collections.singletonMap(FieldBoostMapAttribute.class.getName()+"#boosts", Collections.emptyMap()));
-    _TestUtil.assertAttributeReflection(new FieldDateResolutionMapAttributeImpl(),
-      Collections.singletonMap(FieldDateResolutionMapAttribute.class.getName()+"#dateRes", Collections.emptyMap()));
-    _TestUtil.assertAttributeReflection(new FuzzyAttributeImpl(), new HashMap<String,Object>() {{
-      put(FuzzyAttribute.class.getName()+"#prefixLength", FuzzyQuery.defaultPrefixLength);
-      put(FuzzyAttribute.class.getName()+"#minSimilarity", FuzzyQuery.defaultMinSimilarity);
-    }});
-    _TestUtil.assertAttributeReflection(new LocaleAttributeImpl(),
-      Collections.singletonMap(LocaleAttribute.class.getName()+"#locale", Locale.getDefault()));
-    _TestUtil.assertAttributeReflection(new LowercaseExpandedTermsAttributeImpl(),
-      Collections.singletonMap(LowercaseExpandedTermsAttribute.class.getName()+"#lowercaseExpandedTerms", true));
-    _TestUtil.assertAttributeReflection(new MultiFieldAttributeImpl(),
-      Collections.singletonMap(MultiFieldAttribute.class.getName()+"#fields", null));
-    _TestUtil.assertAttributeReflection(new MultiTermRewriteMethodAttributeImpl(),
-      Collections.singletonMap(MultiTermRewriteMethodAttribute.class.getName()+"#multiTermRewriteMethod", MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT));
-    _TestUtil.assertAttributeReflection(new PositionIncrementsAttributeImpl(),
-      Collections.singletonMap(PositionIncrementsAttribute.class.getName()+"#positionIncrementsEnabled", false));
-  }
-
-}
