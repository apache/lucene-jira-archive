Index: lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
===================================================================
--- lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java	(revision 1688672)
+++ lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java	(working copy)
@@ -81,8 +81,8 @@
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.search.highlight.SynonymTokenizer.TestHighlightRunner;
-import org.apache.lucene.search.join.BitDocIdSetCachingWrapperFilter;
-import org.apache.lucene.search.join.BitDocIdSetFilter;
+import org.apache.lucene.search.join.QueryBitSetProducer;
+import org.apache.lucene.search.join.BitSetProducer;
 import org.apache.lucene.search.join.ScoreMode;
 import org.apache.lucene.search.join.ToChildBlockJoinQuery;
 import org.apache.lucene.search.join.ToParentBlockJoinQuery;
@@ -587,7 +587,7 @@
   }
   
   public void testToParentBlockJoinQuery() throws Exception {
-    BitDocIdSetFilter parentFilter = new BitDocIdSetCachingWrapperFilter(
+    BitSetProducer parentFilter = new QueryBitSetProducer(
         new QueryWrapperFilter(
           new TermQuery(new Term(FIELD_NAME, "parent"))));
     
@@ -613,7 +613,7 @@
   }
   
   public void testToChildBlockJoinQuery() throws Exception {
-    BitDocIdSetFilter parentFilter = new BitDocIdSetCachingWrapperFilter(
+    BitSetProducer parentFilter = new QueryBitSetProducer(
         new QueryWrapperFilter(
           new TermQuery(new Term(FIELD_NAME, "parent"))));
     
Index: lucene/join/src/java/org/apache/lucene/search/join/BitDocIdSetCachingWrapperFilter.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/BitDocIdSetCachingWrapperFilter.java	(revision 1688672)
+++ lucene/join/src/java/org/apache/lucene/search/join/BitDocIdSetCachingWrapperFilter.java	(working copy)
@@ -1,101 +0,0 @@
-package org.apache.lucene.search.join;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Collections;
-import java.util.Map;
-import java.util.WeakHashMap;
-
-import org.apache.lucene.index.LeafReader;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.search.DocIdSet;
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.util.BitDocIdSet;
-
-/**
- * {@link Filter} wrapper that implements {@link BitDocIdSetFilter}.
- */
-public class BitDocIdSetCachingWrapperFilter extends BitDocIdSetFilter {
-  private final Filter filter;
-  private final Map<Object,DocIdSet> cache = Collections.synchronizedMap(new WeakHashMap<>());
-
-  /** Wraps another filter's result and caches it into bitsets.
-   * @param filter Filter to cache results of
-   */
-  public BitDocIdSetCachingWrapperFilter(Filter filter) {
-    this.filter = filter;
-  }
-
-  /**
-   * Gets the contained filter.
-   * @return the contained filter.
-   */
-  public Filter getFilter() {
-    return filter;
-  }
-
-  private BitDocIdSet docIdSetToCache(DocIdSet docIdSet, LeafReader reader) throws IOException {
-    final DocIdSetIterator it = docIdSet.iterator();
-    if (it == null) {
-      return null;
-    } else {
-      BitDocIdSet.Builder builder = new BitDocIdSet.Builder(reader.maxDoc());
-      builder.or(it);
-      return builder.build();
-    }
-  }
-  
-  @Override
-  public BitDocIdSet getDocIdSet(LeafReaderContext context) throws IOException {
-    final LeafReader reader = context.reader();
-    final Object key = reader.getCoreCacheKey();
-
-    DocIdSet docIdSet = cache.get(key);
-    if (docIdSet == null) {
-      docIdSet = filter.getDocIdSet(context, null);
-      docIdSet = docIdSetToCache(docIdSet, reader);
-      if (docIdSet == null) {
-        // We use EMPTY as a sentinel for the empty set, which is cacheable
-        docIdSet = DocIdSet.EMPTY;
-      }
-      cache.put(key, docIdSet);
-    }
-    return docIdSet == DocIdSet.EMPTY ? null : (BitDocIdSet) docIdSet;
-  }
-  
-  @Override
-  public String toString(String field) {
-    return getClass().getSimpleName() + "("+filter.toString(field)+")";
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (super.equals(o) == false) {
-      return false;
-    }
-    final BitDocIdSetCachingWrapperFilter other = (BitDocIdSetCachingWrapperFilter) o;
-    return this.filter.equals(other.filter);
-  }
-
-  @Override
-  public int hashCode() {
-    return 31 * super.hashCode() + filter.hashCode();
-  }
-}
Index: lucene/join/src/java/org/apache/lucene/search/join/BitDocIdSetFilter.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/BitDocIdSetFilter.java	(revision 1688672)
+++ lucene/join/src/java/org/apache/lucene/search/join/BitDocIdSetFilter.java	(working copy)
@@ -1,48 +0,0 @@
-package org.apache.lucene.search.join;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.search.BitsFilteredDocIdSet;
-import org.apache.lucene.search.DocIdSet;
-import org.apache.lucene.search.Filter;
-import org.apache.lucene.util.BitDocIdSet;
-import org.apache.lucene.util.Bits;
-
-/**
- * A {@link Filter} that produces {@link BitDocIdSet}s.
- */
-public abstract class BitDocIdSetFilter extends Filter {
-
-  /** Sole constructor, typically called from sub-classes. */
-  protected BitDocIdSetFilter() {}
-
-  /**
-   * Same as {@link #getDocIdSet(LeafReaderContext, Bits)} but does not take
-   * acceptDocs into account and guarantees to return a {@link BitDocIdSet}.
-   */
-  public abstract BitDocIdSet getDocIdSet(LeafReaderContext context) throws IOException;
-
-  @Override
-  public final DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
-    return BitsFilteredDocIdSet.wrap(getDocIdSet(context), acceptDocs);
-  }
-
-}
Index: lucene/join/src/java/org/apache/lucene/search/join/BitSetProducer.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/BitSetProducer.java	(revision 0)
+++ lucene/join/src/java/org/apache/lucene/search/join/BitSetProducer.java	(working copy)
@@ -0,0 +1,39 @@
+package org.apache.lucene.search.join;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.util.BitSet;
+
+/**
+ * A producer of {@link BitSet}s per segment.
+ */
+public abstract class BitSetProducer {
+
+  /** Sole constructor, typically called from sub-classes. */
+  protected BitSetProducer() {}
+
+  /**
+   * Produce a {@link BitSet} matching the expected documents on the given
+   * segment. This may return {@code null} if no documents match.
+   */
+  public abstract BitSet getBitSet(LeafReaderContext context) throws IOException;
+
+}

Property changes on: lucene/join/src/java/org/apache/lucene/search/join/BitSetProducer.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/join/src/java/org/apache/lucene/search/join/QueryBitSetProducer.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/QueryBitSetProducer.java	(revision 0)
+++ lucene/join/src/java/org/apache/lucene/search/join/QueryBitSetProducer.java	(working copy)
@@ -0,0 +1,105 @@
+package org.apache.lucene.search.join;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Collections;
+import java.util.Map;
+import java.util.WeakHashMap;
+
+import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.ReaderUtil;
+import org.apache.lucene.search.DocIdSet;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Weight;
+import org.apache.lucene.util.BitDocIdSet;
+import org.apache.lucene.util.BitSet;
+
+/**
+ * A {@link BitSetProducer} that wraps a query and caches matching
+ * {@link BitSet}s per segment.
+ */
+public class QueryBitSetProducer extends BitSetProducer {
+  private final Query query;
+  private final Map<Object,DocIdSet> cache = Collections.synchronizedMap(new WeakHashMap<>());
+
+  /** Wraps another query's result and caches it into bitsets.
+   * @param query Query to cache results of
+   */
+  public QueryBitSetProducer(Query query) {
+    this.query = query;
+  }
+
+  /**
+   * Gets the contained query.
+   * @return the contained query.
+   */
+  public Query getQuery() {
+    return query;
+  }
+  
+  @Override
+  public BitSet getBitSet(LeafReaderContext context) throws IOException {
+    final LeafReader reader = context.reader();
+    final Object key = reader.getCoreCacheKey();
+
+    DocIdSet docIdSet = cache.get(key);
+    if (docIdSet == null) {
+      final IndexReaderContext topLevelContext = ReaderUtil.getTopLevelContext(context);
+      final IndexSearcher searcher = new IndexSearcher(topLevelContext);
+      searcher.setQueryCache(null);
+      final Weight weight = searcher.createNormalizedWeight(query, false);
+      final DocIdSetIterator it = weight.scorer(context);
+
+      BitDocIdSet.Builder builder = new BitDocIdSet.Builder(context.reader().maxDoc());
+      if (it != null) {
+        builder.or(it);
+      }
+      docIdSet = builder.build();
+      if (docIdSet == null) {
+        // We use EMPTY as a sentinel for the empty set, which is cacheable
+        docIdSet = DocIdSet.EMPTY;
+      }
+      cache.put(key, docIdSet);
+    }
+    return docIdSet == DocIdSet.EMPTY ? null : ((BitDocIdSet) docIdSet).bits();
+  }
+  
+  @Override
+  public String toString() {
+    return getClass().getSimpleName() + "("+query.toString()+")";
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+    final QueryBitSetProducer other = (QueryBitSetProducer) o;
+    return this.query.equals(other.query);
+  }
+
+  @Override
+  public int hashCode() {
+    return 31 * getClass().hashCode() + query.hashCode();
+  }
+}

Property changes on: lucene/join/src/java/org/apache/lucene/search/join/QueryBitSetProducer.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java	(revision 1688672)
+++ lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java	(working copy)
@@ -31,7 +31,6 @@
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.Weight;
-import org.apache.lucene.util.BitDocIdSet;
 import org.apache.lucene.util.BitSet;
 
 /**
@@ -51,7 +50,7 @@
   static final String INVALID_QUERY_MESSAGE = "Parent query yields document which is not matched by parents filter, docID=";
   static final String ILLEGAL_ADVANCE_ON_PARENT = "Expect to be advanced on child docs only. got docID=";
 
-  private final BitDocIdSetFilter parentsFilter;
+  private final BitSetProducer parentsFilter;
   private final Query parentQuery;
 
   // If we are rewritten, this is the original parentQuery we
@@ -67,7 +66,7 @@
    * @param parentQuery Query that matches parent documents
    * @param parentsFilter Filter identifying the parent documents.
    */
-  public ToChildBlockJoinQuery(Query parentQuery, BitDocIdSetFilter parentsFilter) {
+  public ToChildBlockJoinQuery(Query parentQuery, BitSetProducer parentsFilter) {
     super();
     this.origParentQuery = parentQuery;
     this.parentQuery = parentQuery;
@@ -74,7 +73,7 @@
     this.parentsFilter = parentsFilter;
   }
 
-  private ToChildBlockJoinQuery(Query origParentQuery, Query parentQuery, BitDocIdSetFilter parentsFilter) {
+  private ToChildBlockJoinQuery(Query origParentQuery, Query parentQuery, BitSetProducer parentsFilter) {
     super();
     this.origParentQuery = origParentQuery;
     this.parentQuery = parentQuery;
@@ -94,10 +93,10 @@
   private static class ToChildBlockJoinWeight extends Weight {
     private final Query joinQuery;
     private final Weight parentWeight;
-    private final BitDocIdSetFilter parentsFilter;
+    private final BitSetProducer parentsFilter;
     private final boolean doScores;
 
-    public ToChildBlockJoinWeight(Query joinQuery, Weight parentWeight, BitDocIdSetFilter parentsFilter, boolean doScores) {
+    public ToChildBlockJoinWeight(Query joinQuery, Weight parentWeight, BitSetProducer parentsFilter, boolean doScores) {
       super(joinQuery);
       this.joinQuery = joinQuery;
       this.parentWeight = parentWeight;
@@ -132,13 +131,13 @@
 
       // NOTE: this doesn't take acceptDocs into account, the responsibility
       // to not match deleted docs is on the scorer
-      final BitDocIdSet parents = parentsFilter.getDocIdSet(readerContext);
+      final BitSet parents = parentsFilter.getBitSet(readerContext);
       if (parents == null) {
         // No parents
         return null;
       }
 
-      return new ToChildBlockJoinScorer(this, parentScorer, parents.bits(), doScores);
+      return new ToChildBlockJoinScorer(this, parentScorer, parents, doScores);
     }
 
     @Override
Index: lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java	(revision 1688672)
+++ lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java	(working copy)
@@ -35,9 +35,7 @@
 import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.grouping.TopGroups;
 import org.apache.lucene.util.ArrayUtil;
-import org.apache.lucene.util.BitDocIdSet;
 import org.apache.lucene.util.BitSet;
-import org.apache.lucene.util.Bits;
 
 /**
  * This query requires that you index
@@ -83,7 +81,7 @@
  */
 public class ToParentBlockJoinQuery extends Query {
 
-  private final BitDocIdSetFilter parentsFilter;
+  private final BitSetProducer parentsFilter;
   private final Query childQuery;
 
   // If we are rewritten, this is the original childQuery we
@@ -101,7 +99,7 @@
    * @param scoreMode How to aggregate multiple child scores
    * into a single parent score.
    **/
-  public ToParentBlockJoinQuery(Query childQuery, BitDocIdSetFilter parentsFilter, ScoreMode scoreMode) {
+  public ToParentBlockJoinQuery(Query childQuery, BitSetProducer parentsFilter, ScoreMode scoreMode) {
     super();
     this.origChildQuery = childQuery;
     this.childQuery = childQuery;
@@ -109,7 +107,7 @@
     this.scoreMode = scoreMode;
   }
 
-  private ToParentBlockJoinQuery(Query origChildQuery, Query childQuery, BitDocIdSetFilter parentsFilter, ScoreMode scoreMode) {
+  private ToParentBlockJoinQuery(Query origChildQuery, Query childQuery, BitSetProducer parentsFilter, ScoreMode scoreMode) {
     super();
     this.origChildQuery = origChildQuery;
     this.childQuery = childQuery;
@@ -130,10 +128,10 @@
   private static class BlockJoinWeight extends Weight {
     private final Query joinQuery;
     private final Weight childWeight;
-    private final BitDocIdSetFilter parentsFilter;
+    private final BitSetProducer parentsFilter;
     private final ScoreMode scoreMode;
 
-    public BlockJoinWeight(Query joinQuery, Weight childWeight, BitDocIdSetFilter parentsFilter, ScoreMode scoreMode) {
+    public BlockJoinWeight(Query joinQuery, Weight childWeight, BitSetProducer parentsFilter, ScoreMode scoreMode) {
       super(joinQuery);
       this.joinQuery = joinQuery;
       this.childWeight = childWeight;
@@ -173,7 +171,7 @@
 
       // NOTE: this does not take accept docs into account, the responsibility
       // to not match deleted docs is on the scorer
-      final BitDocIdSet parents = parentsFilter.getDocIdSet(readerContext);
+      final BitSet parents = parentsFilter.getBitSet(readerContext);
 
       if (parents == null) {
         // No matches
@@ -180,7 +178,7 @@
         return null;
       }
 
-      return new BlockJoinScorer(this, childScorer, parents.bits(), firstChildDoc, scoreMode);
+      return new BlockJoinScorer(this, childScorer, parents, firstChildDoc, scoreMode);
     }
 
     @Override
Index: lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinSortField.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinSortField.java	(revision 1688672)
+++ lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinSortField.java	(working copy)
@@ -25,7 +25,7 @@
 import org.apache.lucene.index.SortedSetDocValues;
 import org.apache.lucene.search.FieldComparator;
 import org.apache.lucene.search.SortField;
-import org.apache.lucene.util.BitDocIdSet;
+import org.apache.lucene.util.BitSet;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.NumericUtils;
 
@@ -40,8 +40,8 @@
 public class ToParentBlockJoinSortField extends SortField {
 
   private final boolean order;
-  private final BitDocIdSetFilter parentFilter;
-  private final BitDocIdSetFilter childFilter;
+  private final BitSetProducer parentFilter;
+  private final BitSetProducer childFilter;
 
   /**
    * Create ToParentBlockJoinSortField. The parent document ordering is based on child document ordering (reverse).
@@ -52,7 +52,7 @@
    * @param parentFilter Filter that identifies the parent documents.
    * @param childFilter Filter that defines which child documents participates in sorting.
    */
-  public ToParentBlockJoinSortField(String field, Type type, boolean reverse, BitDocIdSetFilter parentFilter, BitDocIdSetFilter childFilter) {
+  public ToParentBlockJoinSortField(String field, Type type, boolean reverse, BitSetProducer parentFilter, BitSetProducer childFilter) {
     super(field, type, reverse);
     switch (getType()) {
       case STRING:
@@ -80,7 +80,7 @@
    * @param parentFilter Filter that identifies the parent documents.
    * @param childFilter Filter that defines which child documents participates in sorting.
    */
-  public ToParentBlockJoinSortField(String field, Type type, boolean reverse, boolean order, BitDocIdSetFilter parentFilter, BitDocIdSetFilter childFilter) {
+  public ToParentBlockJoinSortField(String field, Type type, boolean reverse, boolean order, BitSetProducer parentFilter, BitSetProducer childFilter) {
     super(field, type, reverse);
     this.order = order;
     this.parentFilter = parentFilter;
@@ -114,12 +114,12 @@
         final BlockJoinSelector.Type type = order
             ? BlockJoinSelector.Type.MAX
             : BlockJoinSelector.Type.MIN;
-        final BitDocIdSet parents = parentFilter.getDocIdSet(context);
-        final BitDocIdSet children = childFilter.getDocIdSet(context);
+        final BitSet parents = parentFilter.getBitSet(context);
+        final BitSet children = childFilter.getBitSet(context);
         if (children == null) {
           return DocValues.emptySorted();
         }
-        return BlockJoinSelector.wrap(sortedSet, type, parents.bits(), children.bits());
+        return BlockJoinSelector.wrap(sortedSet, type, parents, children);
       }
 
     };
@@ -133,22 +133,22 @@
         final BlockJoinSelector.Type type = order
             ? BlockJoinSelector.Type.MAX
             : BlockJoinSelector.Type.MIN;
-        final BitDocIdSet parents = parentFilter.getDocIdSet(context);
-        final BitDocIdSet children = childFilter.getDocIdSet(context);
+        final BitSet parents = parentFilter.getBitSet(context);
+        final BitSet children = childFilter.getBitSet(context);
         if (children == null) {
           return DocValues.emptyNumeric();
         }
-        return BlockJoinSelector.wrap(sortedNumeric, type, parents.bits(), children.bits());
+        return BlockJoinSelector.wrap(sortedNumeric, type, parents, children);
       }
       @Override
       protected Bits getDocsWithValue(LeafReaderContext context, String field) throws IOException {
         final Bits docsWithValue = DocValues.getDocsWithField(context.reader(), field);
-        final BitDocIdSet parents = parentFilter.getDocIdSet(context);
-        final BitDocIdSet children = childFilter.getDocIdSet(context);
+        final BitSet parents = parentFilter.getBitSet(context);
+        final BitSet children = childFilter.getBitSet(context);
         if (children == null) {
           return new Bits.MatchNoBits(context.reader().maxDoc());
         }
-        return BlockJoinSelector.wrap(docsWithValue, parents.bits(), children.bits());
+        return BlockJoinSelector.wrap(docsWithValue, parents, children);
       }
     };
   }
@@ -161,22 +161,22 @@
         final BlockJoinSelector.Type type = order
             ? BlockJoinSelector.Type.MAX
             : BlockJoinSelector.Type.MIN;
-        final BitDocIdSet parents = parentFilter.getDocIdSet(context);
-        final BitDocIdSet children = childFilter.getDocIdSet(context);
+        final BitSet parents = parentFilter.getBitSet(context);
+        final BitSet children = childFilter.getBitSet(context);
         if (children == null) {
           return DocValues.emptyNumeric();
         }
-        return BlockJoinSelector.wrap(sortedNumeric, type, parents.bits(), children.bits());
+        return BlockJoinSelector.wrap(sortedNumeric, type, parents, children);
       }
       @Override
       protected Bits getDocsWithValue(LeafReaderContext context, String field) throws IOException {
         final Bits docsWithValue = DocValues.getDocsWithField(context.reader(), field);
-        final BitDocIdSet parents = parentFilter.getDocIdSet(context);
-        final BitDocIdSet children = childFilter.getDocIdSet(context);
+        final BitSet parents = parentFilter.getBitSet(context);
+        final BitSet children = childFilter.getBitSet(context);
         if (children == null) {
           return new Bits.MatchNoBits(context.reader().maxDoc());
         }
-        return BlockJoinSelector.wrap(docsWithValue, parents.bits(), children.bits());
+        return BlockJoinSelector.wrap(docsWithValue, parents, children);
       }
     };
   }
@@ -189,12 +189,12 @@
         final BlockJoinSelector.Type type = order
             ? BlockJoinSelector.Type.MAX
             : BlockJoinSelector.Type.MIN;
-        final BitDocIdSet parents = parentFilter.getDocIdSet(context);
-        final BitDocIdSet children = childFilter.getDocIdSet(context);
+        final BitSet parents = parentFilter.getBitSet(context);
+        final BitSet children = childFilter.getBitSet(context);
         if (children == null) {
           return DocValues.emptyNumeric();
         }
-        final NumericDocValues view = BlockJoinSelector.wrap(sortedNumeric, type, parents.bits(), children.bits());
+        final NumericDocValues view = BlockJoinSelector.wrap(sortedNumeric, type, parents, children);
         // undo the numericutils sortability
         return new NumericDocValues() {
           @Override
@@ -214,12 +214,12 @@
         final BlockJoinSelector.Type type = order
             ? BlockJoinSelector.Type.MAX
             : BlockJoinSelector.Type.MIN;
-        final BitDocIdSet parents = parentFilter.getDocIdSet(context);
-        final BitDocIdSet children = childFilter.getDocIdSet(context);
+        final BitSet parents = parentFilter.getBitSet(context);
+        final BitSet children = childFilter.getBitSet(context);
         if (children == null) {
           return DocValues.emptyNumeric();
         }
-        final NumericDocValues view = BlockJoinSelector.wrap(sortedNumeric, type, parents.bits(), children.bits());
+        final NumericDocValues view = BlockJoinSelector.wrap(sortedNumeric, type, parents, children);
         // undo the numericutils sortability
         return new NumericDocValues() {
           @Override
@@ -231,12 +231,12 @@
       @Override
       protected Bits getDocsWithValue(LeafReaderContext context, String field) throws IOException {
         final Bits docsWithValue = DocValues.getDocsWithField(context.reader(), field);
-        final BitDocIdSet parents = parentFilter.getDocIdSet(context);
-        final BitDocIdSet children = childFilter.getDocIdSet(context);
+        final BitSet parents = parentFilter.getBitSet(context);
+        final BitSet children = childFilter.getBitSet(context);
         if (children == null) {
           return new Bits.MatchNoBits(context.reader().maxDoc());
         }
-        return BlockJoinSelector.wrap(docsWithValue, parents.bits(), children.bits());
+        return BlockJoinSelector.wrap(docsWithValue, parents, children);
       }
     };
   }
Index: lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java
===================================================================
--- lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java	(revision 1688672)
+++ lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin.java	(working copy)
@@ -52,7 +52,6 @@
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.FieldDoc;
-import org.apache.lucene.search.Filter;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.MatchNoDocsQuery;
@@ -61,7 +60,6 @@
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.QueryUtils;
-import org.apache.lucene.search.QueryWrapperFilter;
 import org.apache.lucene.search.RandomApproximationQuery;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.Sort;
@@ -139,7 +137,7 @@
     w.close();
     assertTrue(r.leaves().size() > 1);
     IndexSearcher s = new IndexSearcher(r);
-    BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("docType", "resume"))));
+    BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("docType", "resume")));
 
     BooleanQuery.Builder childQuery = new BooleanQuery.Builder();
     childQuery.add(new BooleanClause(new TermQuery(new Term("skill", "java")), Occur.MUST));
@@ -191,7 +189,7 @@
     IndexSearcher s = newSearcher(r);
 
     // Create a filter that defines "parent" documents in the index - in this case resumes
-    BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("docType", "resume"))));
+    BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("docType", "resume")));
 
     // Define child document criteria (finds an example of relevant work experience)
     BooleanQuery.Builder childQuery = new BooleanQuery.Builder();
@@ -281,7 +279,7 @@
     // iterations: 
     qc.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_BOOLEAN_REWRITE);
 
-    BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("docType", "resume"))));
+    BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("docType", "resume")));
 
     int h1 = qc.hashCode();
     Query qw1 = qc.rewrite(r);
@@ -306,8 +304,8 @@
     dir.close();
   }
 
-  protected QueryWrapperFilter skill(String skill) {
-    return new QueryWrapperFilter(new TermQuery(new Term("skill", skill)));
+  protected Query skill(String skill) {
+    return new TermQuery(new Term("skill", skill));
   }
 
   public void testSimpleFilter() throws Exception {
@@ -342,7 +340,7 @@
     IndexSearcher s = newSearcher(r);
 
     // Create a filter that defines "parent" documents in the index - in this case resumes
-    BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("docType", "resume"))));
+    BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("docType", "resume")));
 
     // Define child document criteria (finds an example of relevant work experience)
     BooleanQuery.Builder childQuery = new BooleanQuery.Builder();
@@ -360,7 +358,7 @@
 
     Query query = new BooleanQuery.Builder()
         .add(childJoinQuery, Occur.MUST)
-        .add(parentsFilter, Occur.FILTER)
+        .add(new TermQuery(new Term("docType", "resume")), Occur.FILTER)
         .build();
     assertEquals("dummy filter passes everyone ", 2, s.search(query, 10).totalHits);
     query = new BooleanQuery.Builder()
@@ -372,19 +370,14 @@
     // not found test
     query = new BooleanQuery.Builder()
         .add(childJoinQuery, Occur.MUST)
-        .add(new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("country", "Oz")))), Occur.FILTER)
+        .add(new TermQuery(new Term("country", "Oz")), Occur.FILTER)
         .build();
     assertEquals("noone live there", 0, s.search(query, 1).totalHits);
-    query = new BooleanQuery.Builder()
-        .add(childJoinQuery, Occur.MUST)
-        .add(new QueryWrapperFilter(new TermQuery(new Term("country", "Oz"))), Occur.FILTER)
-        .build();
-    assertEquals("noone live there", 0, s.search(query, 1).totalHits);
       
     // apply the UK filter by the searcher
     query = new BooleanQuery.Builder()
         .add(childJoinQuery, Occur.MUST)
-        .add(new QueryWrapperFilter(parentQuery), Occur.FILTER)
+        .add(parentQuery, Occur.FILTER)
         .build();
     TopDocs ukOnly = s.search(query, 1);
     assertEquals("has filter - single passed", 1, ukOnly.totalHits);
@@ -392,7 +385,7 @@
 
     query = new BooleanQuery.Builder()
         .add(childJoinQuery, Occur.MUST)
-        .add(new QueryWrapperFilter(new TermQuery(new Term("country", "United States"))), Occur.FILTER)
+        .add(new TermQuery(new Term("country", "United States")), Occur.FILTER)
         .build();
     // looking for US candidates
     TopDocs usThen = s.search(query, 1);
@@ -430,11 +423,11 @@
     }
   }
   
-  private StoredDocument getParentDoc(IndexReader reader, BitDocIdSetFilter parents, int childDocID) throws IOException {
+  private StoredDocument getParentDoc(IndexReader reader, BitSetProducer parents, int childDocID) throws IOException {
     final List<LeafReaderContext> leaves = reader.leaves();
     final int subIndex = ReaderUtil.subIndex(childDocID, leaves);
     final LeafReaderContext leaf = leaves.get(subIndex);
-    final BitSet bits = parents.getDocIdSet(leaf).bits();
+    final BitSet bits = parents.getBitSet(leaf);
     return leaf.reader().document(bits.nextSetBit(childDocID - leaf.docBase));
   }
   
@@ -445,7 +438,7 @@
     w.close();
     IndexSearcher s = newSearcher(r);
     
-    ToParentBlockJoinQuery q = new ToParentBlockJoinQuery(new MatchNoDocsQuery(), new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new MatchAllDocsQuery())), ScoreMode.Avg);
+    ToParentBlockJoinQuery q = new ToParentBlockJoinQuery(new MatchNoDocsQuery(), new QueryBitSetProducer(new MatchAllDocsQuery()), ScoreMode.Avg);
     QueryUtils.check(random(), q, s);
     s.search(q, 10);
     BooleanQuery.Builder bqB = new BooleanQuery.Builder();
@@ -656,7 +649,7 @@
 
     final IndexSearcher joinS = new IndexSearcher(joinR);
 
-    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("isParent", "x"))));
+    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("isParent", "x")));
 
     final int iters = 200*RANDOM_MULTIPLIER;
 
@@ -906,10 +899,9 @@
         final Term childTerm = randomChildTerm(childFields[0]);
         if (random().nextBoolean()) { // filtered case
           childJoinQuery2 = parentJoinQuery2;
-          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));
           childJoinQuery2 = new BooleanQuery.Builder()
               .add(childJoinQuery2, Occur.MUST)
-              .add(random().nextBoolean() ? new BitDocIdSetCachingWrapperFilter(f): f, Occur.FILTER)
+              .add(new TermQuery(childTerm), Occur.FILTER)
               .build();
         } else {
           // AND child field w/ parent query:
@@ -928,10 +920,9 @@
         
         if (random().nextBoolean()) { // filtered case
           childQuery2 = parentQuery2;
-          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));
           childQuery2 = new BooleanQuery.Builder()
               .add(childQuery2, Occur.MUST)
-              .add(random().nextBoolean() ? new BitDocIdSetCachingWrapperFilter(f): f, Occur.FILTER)
+              .add(new TermQuery(childTerm), Occur.FILTER)
               .build();
         } else {
           final BooleanQuery.Builder bq2 = new BooleanQuery.Builder();
@@ -1067,7 +1058,7 @@
     IndexSearcher s = newSearcher(r);
 
     // Create a filter that defines "parent" documents in the index - in this case resumes
-    BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("docType", "resume"))));
+    BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("docType", "resume")));
 
     // Define child document criteria (finds an example of relevant work experience)
     BooleanQuery.Builder childJobQuery = new BooleanQuery.Builder();
@@ -1147,9 +1138,8 @@
     w.close();
     IndexSearcher s = newSearcher(r);
     Query tq = new TermQuery(new Term("child", "1"));
-    BitDocIdSetFilter parentFilter = new BitDocIdSetCachingWrapperFilter(
-                            new QueryWrapperFilter(
-                              new TermQuery(new Term("parent", "1"))));
+    BitSetProducer parentFilter = new QueryBitSetProducer(
+                              new TermQuery(new Term("parent", "1")));
 
     ToParentBlockJoinQuery q = new ToParentBlockJoinQuery(tq, parentFilter, ScoreMode.Avg);
     Weight weight = s.createNormalizedWeight(q, true);
@@ -1181,9 +1171,8 @@
     w.close();
     IndexSearcher s = newSearcher(r);
     Query tq = new TermQuery(new Term("child", "2"));
-    BitDocIdSetFilter parentFilter = new BitDocIdSetCachingWrapperFilter(
-                            new QueryWrapperFilter(
-                              new TermQuery(new Term("isparent", "yes"))));
+    BitSetProducer parentFilter = new QueryBitSetProducer(
+                              new TermQuery(new Term("isparent", "yes")));
 
     ToParentBlockJoinQuery q = new ToParentBlockJoinQuery(tq, parentFilter, ScoreMode.Avg);
     Weight weight = s.createNormalizedWeight(q, true);
@@ -1215,7 +1204,7 @@
     IndexSearcher s = new IndexSearcher(r);
 
     // Create a filter that defines "parent" documents in the index - in this case resumes
-    BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("docType", "resume"))));
+    BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("docType", "resume")));
 
     // Define child document criteria (finds an example of relevant work experience)
     BooleanQuery.Builder childQuery = new BooleanQuery.Builder();
@@ -1321,7 +1310,7 @@
 
     IndexSearcher searcher = new ToParentBlockJoinIndexSearcher(r);
     Query childQuery = new TermQuery(new Term("childText", "text"));
-    BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("isParent", "yes"))));
+    BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("isParent", "yes")));
     ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, ScoreMode.Avg);
     BooleanQuery.Builder parentQuery = new BooleanQuery.Builder();
     parentQuery.add(childJoinQuery, Occur.SHOULD);
@@ -1391,7 +1380,7 @@
     
     // never matches:
     Query childQuery = new TermQuery(new Term("childText", "bogus"));
-    BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("isParent", "yes"))));
+    BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("isParent", "yes")));
     ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, ScoreMode.Avg);
     BooleanQuery.Builder parentQuery = new BooleanQuery.Builder();
     parentQuery.add(childJoinQuery, Occur.SHOULD);
@@ -1456,7 +1445,7 @@
 
     // illegally matches parent:
     Query childQuery = new TermQuery(new Term("parentText", "text"));
-    BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("isParent", "yes"))));
+    BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("isParent", "yes")));
     ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, ScoreMode.Avg);
     BooleanQuery.Builder parentQuery = new BooleanQuery.Builder();
     parentQuery.add(childJoinQuery, Occur.SHOULD);
@@ -1508,7 +1497,7 @@
     IndexSearcher s = newSearcher(r);
 
     // Create a filter that defines "parent" documents in the index - in this case resumes
-    BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("isparent", "yes"))));
+    BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("isparent", "yes")));
 
     Query parentQuery = new TermQuery(new Term("parent", "2"));
 
@@ -1543,7 +1532,7 @@
     final IndexSearcher searcher = newSearcher(reader);
     searcher.setQueryCache(null); // to have real advance() calls
 
-    final BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("parent", "true"))));
+    final BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("parent", "true")));
     final Query toChild = new ToChildBlockJoinQuery(new TermQuery(new Term("foo_parent", "bar")), parentsFilter);
     final Query childQuery = new TermQuery(new Term("foo_child", "baz"));
 
@@ -1587,7 +1576,7 @@
     IndexSearcher s = newSearcher(r);
 
     // Create a filter that defines "parent" documents in the index - in this case resumes
-    BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("docType", "resume"))));
+    BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("docType", "resume")));
     Query parentQuery = new PrefixQuery(new Term("country", "United"));
     
     ToChildBlockJoinQuery toChildQuery = new ToChildBlockJoinQuery(parentQuery, parentsFilter);
@@ -1625,7 +1614,7 @@
     IndexSearcher s = newSearcher(r);
 
     // Create a filter that defines "parent" documents in the index - in this case resumes
-    BitDocIdSetFilter parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("docType", "resume"))));
+    BitSetProducer parentsFilter = new QueryBitSetProducer(new TermQuery(new Term("docType", "resume")));
     Query parentQuery = new PrefixQuery(new Term("country", "United"));
     
     ToChildBlockJoinQuery toChildQuery = new ToChildBlockJoinQuery(parentQuery, parentsFilter);
Index: lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinSorting.java
===================================================================
--- lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinSorting.java	(revision 1688672)
+++ lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinSorting.java	(working copy)
@@ -29,7 +29,6 @@
 import org.apache.lucene.search.FieldDoc;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.PrefixQuery;
-import org.apache.lucene.search.QueryWrapperFilter;
 import org.apache.lucene.search.Sort;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TermQuery;
@@ -228,11 +227,11 @@
 
     IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(w.w, false));
     w.close();
-    BitDocIdSetFilter parentFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("__type", "parent"))));
-    BitDocIdSetFilter childFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new PrefixQuery(new Term("field2"))));
+    BitSetProducer parentFilter = new QueryBitSetProducer(new TermQuery(new Term("__type", "parent")));
+    BitSetProducer childFilter = new QueryBitSetProducer(new PrefixQuery(new Term("field2")));
     ToParentBlockJoinQuery query = new ToParentBlockJoinQuery(
-        childFilter,
-        new BitDocIdSetCachingWrapperFilter(parentFilter),
+        new PrefixQuery(new Term("field2")),
+        parentFilter,
         ScoreMode.None
     );
 
@@ -294,10 +293,10 @@
     assertEquals("g", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[4]).fields[0]).utf8ToString());
 
     // Sort by field descending, order last, sort filter (filter_1:T)
-    childFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new TermQuery((new Term("filter_1", "T")))));
+    childFilter = new QueryBitSetProducer(new TermQuery((new Term("filter_1", "T"))));
     query = new ToParentBlockJoinQuery(
-        childFilter,
-        new BitDocIdSetCachingWrapperFilter(parentFilter),
+        new TermQuery((new Term("filter_1", "T"))),
+        parentFilter,
         ScoreMode.None
     );
     sortField = new ToParentBlockJoinSortField(
Index: lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinValidation.java
===================================================================
--- lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinValidation.java	(revision 1688672)
+++ lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinValidation.java	(working copy)
@@ -54,7 +54,7 @@
   private Directory directory;
   private IndexReader indexReader;
   private IndexSearcher indexSearcher;
-  private BitDocIdSetFilter parentsFilter;
+  private BitSetProducer parentsFilter;
 
   @Override
   public void setUp() throws Exception {
@@ -70,7 +70,7 @@
     indexReader = DirectoryReader.open(indexWriter, random().nextBoolean());
     indexWriter.close();
     indexSearcher = new IndexSearcher(indexReader);
-    parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(new WildcardQuery(new Term("parent", "*"))));
+    parentsFilter = new QueryBitSetProducer(new QueryWrapperFilter(new WildcardQuery(new Term("parent", "*"))));
   }
 
   @Override
@@ -132,7 +132,7 @@
     final LeafReaderContext context = indexSearcher.getIndexReader().leaves().get(0);
     Weight weight = indexSearcher.createNormalizedWeight(blockJoinQuery, true);
     Scorer scorer = weight.scorer(context);
-    final Bits parentDocs = parentsFilter.getDocIdSet(context).bits();
+    final Bits parentDocs = parentsFilter.getBitSet(context);
 
     int target;
     do {
Index: solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestHierarchicalDocBuilder.java
===================================================================
--- solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestHierarchicalDocBuilder.java	(revision 1688672)
+++ solr/contrib/dataimporthandler/src/test/org/apache/solr/handler/dataimport/TestHierarchicalDocBuilder.java	(working copy)
@@ -34,8 +34,8 @@
 import org.apache.lucene.search.QueryWrapperFilter;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.join.BitDocIdSetCachingWrapperFilter;
-import org.apache.lucene.search.join.BitDocIdSetFilter;
+import org.apache.lucene.search.join.QueryBitSetProducer;
+import org.apache.lucene.search.join.BitSetProducer;
 import org.apache.lucene.search.join.ScoreMode;
 import org.apache.lucene.search.join.ToParentBlockJoinQuery;
 import org.apache.solr.common.util.StrUtils;
@@ -457,10 +457,10 @@
    **/
   private final String childEntityTemplate = "<entity " + ConfigNameConstants.CHILD + "=\"true\" name=\"{0}\" query=\"{1}\">\n {2} {3} </entity>\n";
   
-  private BitDocIdSetFilter createParentFilter(String type) {
+  private BitSetProducer createParentFilter(String type) {
     BooleanQuery.Builder parentQuery = new BooleanQuery.Builder();
     parentQuery.add(new TermQuery(new Term("type_s", type)), Occur.MUST);
-    return new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(parentQuery.build()));
+    return new QueryBitSetProducer(new QueryWrapperFilter(parentQuery.build()));
   }
   
   private String nextId() {
Index: solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformerFactory.java
===================================================================
--- solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformerFactory.java	(revision 1688672)
+++ solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformerFactory.java	(working copy)
@@ -23,8 +23,8 @@
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.QueryWrapperFilter;
 import org.apache.lucene.search.Sort;
-import org.apache.lucene.search.join.BitDocIdSetCachingWrapperFilter;
-import org.apache.lucene.search.join.BitDocIdSetFilter;
+import org.apache.lucene.search.join.QueryBitSetProducer;
+import org.apache.lucene.search.join.BitSetProducer;
 import org.apache.lucene.search.join.ToChildBlockJoinQuery;
 import org.apache.solr.common.SolrDocument;
 import org.apache.solr.common.SolrException;
@@ -75,10 +75,10 @@
     String childFilter = params.get( "childFilter" );
     int limit = params.getInt( "limit", 10 );
 
-    BitDocIdSetFilter parentsFilter = null;
+    BitSetProducer parentsFilter = null;
     try {
       Query parentFilterQuery = QParser.getParser( parentFilter, null, req).getQuery();
-      parentsFilter = new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(parentFilterQuery));
+      parentsFilter = new QueryBitSetProducer(new QueryWrapperFilter(parentFilterQuery));
     } catch (SyntaxError syntaxError) {
       throw new SolrException( ErrorCode.BAD_REQUEST, "Failed to create correct parent filter query" );
     }
@@ -100,11 +100,11 @@
   private final String name;
   private final SchemaField idField;
   private final IndexSchema schema;
-  private BitDocIdSetFilter parentsFilter;
+  private BitSetProducer parentsFilter;
   private Query childFilterQuery;
   private int limit;
 
-  public ChildDocTransformer( String name, final BitDocIdSetFilter parentsFilter, 
+  public ChildDocTransformer( String name, final BitSetProducer parentsFilter, 
                               final SchemaField idField, IndexSchema schema,
                               final Query childFilterQuery, int limit) {
     this.name = name;
Index: solr/core/src/java/org/apache/solr/search/join/BlockJoinChildQParser.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/join/BlockJoinChildQParser.java	(revision 1688672)
+++ solr/core/src/java/org/apache/solr/search/join/BlockJoinChildQParser.java	(working copy)
@@ -29,7 +29,7 @@
   }
 
   protected Query createQuery(Query parentListQuery, Query query) {
-    return new ToChildBlockJoinQuery(query, getFilter(parentListQuery));
+    return new ToChildBlockJoinQuery(query, getFilter(parentListQuery).filter);
   }
 
   @Override
Index: solr/core/src/java/org/apache/solr/search/join/BlockJoinParentQParser.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/join/BlockJoinParentQParser.java	(revision 1688672)
+++ solr/core/src/java/org/apache/solr/search/join/BlockJoinParentQParser.java	(working copy)
@@ -17,13 +17,21 @@
 
 package org.apache.solr.search.join;
 
+import java.io.IOException;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.search.BitsFilteredDocIdSet;
+import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.Filter;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.QueryWrapperFilter;
-import org.apache.lucene.search.join.BitDocIdSetCachingWrapperFilter;
-import org.apache.lucene.search.join.BitDocIdSetFilter;
+import org.apache.lucene.search.join.QueryBitSetProducer;
+import org.apache.lucene.search.join.BitSetProducer;
 import org.apache.lucene.search.join.ScoreMode;
 import org.apache.lucene.search.join.ToParentBlockJoinQuery;
+import org.apache.lucene.util.BitDocIdSet;
+import org.apache.lucene.util.BitSet;
+import org.apache.lucene.util.Bits;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.search.QParser;
@@ -63,10 +71,10 @@
   }
 
   protected Query createQuery(Query parentList, Query query) {
-    return new ToParentBlockJoinQuery(query, getFilter(parentList), ScoreMode.None);
+    return new ToParentBlockJoinQuery(query, getFilter(parentList).filter, ScoreMode.None);
   }
 
-  BitDocIdSetFilter getFilter(Query parentList) {
+  BitDocIdSetFilterWrapper getFilter(Query parentList) {
     SolrCache parentCache = req.getSearcher().getCache(CACHE_NAME);
     // lazily retrieve from solr cache
     Filter filter = null;
@@ -73,11 +81,11 @@
     if (parentCache != null) {
       filter = (Filter) parentCache.get(parentList);
     }
-    BitDocIdSetFilter result;
-    if (filter instanceof BitDocIdSetFilter) {
-      result = (BitDocIdSetFilter) filter;
+    BitDocIdSetFilterWrapper result;
+    if (filter instanceof BitDocIdSetFilterWrapper) {
+      result = (BitDocIdSetFilterWrapper) filter;
     } else {
-      result = createParentFilter(parentList);
+      result = new BitDocIdSetFilterWrapper(createParentFilter(parentList));
       if (parentCache != null) {
         parentCache.put(parentList, result);
       }
@@ -85,9 +93,48 @@
     return result;
   }
 
-  private BitDocIdSetFilter createParentFilter(Query parentQ) {
-    return new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(parentQ));
+  private BitSetProducer createParentFilter(Query parentQ) {
+    return new QueryBitSetProducer(new QueryWrapperFilter(parentQ));
   }
+
+  // We need this wrapper since BitDocIdSetFilter does not extend Filter
+  static class BitDocIdSetFilterWrapper extends Filter {
+
+    final BitSetProducer filter;
+
+    BitDocIdSetFilterWrapper(BitSetProducer filter) {
+      this.filter = filter;
+    }
+
+    @Override
+    public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
+      BitSet set = filter.getBitSet(context);
+      if (set == null) {
+        return null;
+      }
+      return BitsFilteredDocIdSet.wrap(new BitDocIdSet(set), acceptDocs);
+    }
+
+    @Override
+    public String toString(String field) {
+      return getClass().getSimpleName() + "(" + filter + ")";
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (super.equals(obj) == false) {
+        return false;
+      }
+      return filter.equals(((BitDocIdSetFilterWrapper) obj).filter);
+    }
+
+    @Override
+    public int hashCode() {
+      return 31 * super.hashCode() + filter.hashCode();
+    }
+
+  }
+
 }
 
 
Index: solr/core/src/test/org/apache/solr/update/AddBlockUpdateTest.java
===================================================================
--- solr/core/src/test/org/apache/solr/update/AddBlockUpdateTest.java	(revision 1688672)
+++ solr/core/src/test/org/apache/solr/update/AddBlockUpdateTest.java	(working copy)
@@ -26,7 +26,7 @@
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.join.BitDocIdSetCachingWrapperFilter;
+import org.apache.lucene.search.join.QueryBitSetProducer;
 import org.apache.lucene.search.join.ScoreMode;
 import org.apache.lucene.search.join.ToParentBlockJoinQuery;
 import org.apache.solr.SolrTestCaseJ4;
@@ -562,7 +562,7 @@
   
   protected ToParentBlockJoinQuery join(final String childTerm) {
     return new ToParentBlockJoinQuery(
-        new TermQuery(new Term(child, childTerm)), new BitDocIdSetCachingWrapperFilter(new QueryWrapperFilter(
+        new TermQuery(new Term(child, childTerm)), new QueryBitSetProducer(new QueryWrapperFilter(
             new TermRangeQuery(parent, null, null, false, false))), ScoreMode.None);
   }
   
