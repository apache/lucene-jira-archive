Index: lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/CheckIndex.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/index/CheckIndex.java	(working copy)
@@ -20,6 +20,8 @@
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintStream;
+import java.nio.file.FileSystems;
+import java.nio.file.Path;
 import java.text.NumberFormat;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -2046,11 +2048,12 @@
 
     System.out.println("\nOpening index @ " + indexPath + "\n");
     Directory dir = null;
+    Path path = FileSystems.getDefault().getPath(indexPath);
     try {
       if (dirImpl == null) {
-        dir = FSDirectory.open(new File(indexPath));
+        dir = FSDirectory.open(path);
       } else {
-        dir = CommandLineUtil.newFSDirectory(dirImpl, new File(indexPath));
+        dir = CommandLineUtil.newFSDirectory(dirImpl, path);
       }
     } catch (Throwable t) {
       System.out.println("ERROR: could not open directory \"" + indexPath + "\"; exiting");
Index: lucene/core/src/java/org/apache/lucene/index/DirectoryReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/DirectoryReader.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/index/DirectoryReader.java	(working copy)
@@ -26,7 +26,6 @@
 
 import org.apache.lucene.search.SearcherManager; // javadocs
 import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.NoSuchDirectoryException;
 
 /** DirectoryReader is an implementation of {@link CompositeReader}
  that can read indexes in a {@link Directory}. 
@@ -288,22 +287,12 @@
     // corrupt indices.  This means that IndexWriter will
     // throw an exception on such indices and the app must
     // resolve the situation manually:
-    String[] files;
-    try {
-      files = directory.listAll();
-    } catch (NoSuchDirectoryException nsde) {
-      // Directory does not exist --> no index exists
-      return false;
-    }
+    String[] files = directory.listAll();
 
-    // Defensive: maybe a Directory impl returns null
-    // instead of throwing NoSuchDirectoryException:
-    if (files != null) {
-      String prefix = IndexFileNames.SEGMENTS + "_";
-      for(String file : files) {
-        if (file.startsWith(prefix)) {
-          return true;
-        }
+    String prefix = IndexFileNames.SEGMENTS + "_";
+    for(String file : files) {
+      if (file.startsWith(prefix)) {
+        return true;
       }
     }
     return false;
Index: lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter.java	(working copy)
@@ -31,7 +31,6 @@
 
 import org.apache.lucene.store.AlreadyClosedException;
 import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.NoSuchDirectoryException;
 import org.apache.lucene.util.CollectionUtil;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.InfoStream;
@@ -144,13 +143,7 @@
     long currentGen = segmentInfos.getGeneration();
 
     CommitPoint currentCommitPoint = null;
-    String[] files = null;
-    try {
-      files = directory.listAll();
-    } catch (NoSuchDirectoryException e) {
-      // it means the directory is empty, so ignore it.
-      files = new String[0];
-    }
+    String[] files = directory.listAll();
 
     if (currentSegmentsFile != null) {
       Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher("");
Index: lucene/core/src/java/org/apache/lucene/index/IndexUpgrader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/IndexUpgrader.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/index/IndexUpgrader.java	(working copy)
@@ -26,6 +26,8 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.nio.file.FileSystems;
+import java.nio.file.Path;
 import java.util.Collection;
 
 /**
@@ -102,11 +104,12 @@
       printUsage();
     }
     
+    Path p = FileSystems.getDefault().getPath(path);
     Directory dir = null;
     if (dirImpl == null) {
-      dir = FSDirectory.open(new File(path));
+      dir = FSDirectory.open(p);
     } else {
-      dir = CommandLineUtil.newFSDirectory(dirImpl, new File(path));
+      dir = CommandLineUtil.newFSDirectory(dirImpl, p);
     }
     return new IndexUpgrader(dir, out, deletePriorCommits);
   }
Index: lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java	(working copy)
@@ -19,6 +19,7 @@
 
 import java.io.IOException;
 import java.io.PrintStream;
+import java.nio.file.NoSuchFileException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -41,7 +42,6 @@
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.store.NoSuchDirectoryException;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.StringHelper;
 
@@ -176,9 +176,6 @@
    * @param files -- array of file names to check
    */
   public static long getLastCommitGeneration(String[] files) {
-    if (files == null) {
-      return -1;
-    }
     long max = -1;
     for (String file : files) {
       if (file.startsWith(IndexFileNames.SEGMENTS) && !file.equals(IndexFileNames.OLD_SEGMENTS_GEN)) {
@@ -198,11 +195,7 @@
    * @param directory -- directory to search for the latest segments_N file
    */
   public static long getLastCommitGeneration(Directory directory) throws IOException {
-    try {
-      return getLastCommitGeneration(directory.listAll());
-    } catch (NoSuchDirectoryException nsde) {
-      return -1;
-    }
+    return getLastCommitGeneration(directory.listAll());
   }
 
   /**
Index: lucene/core/src/java/org/apache/lucene/store/Directory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/Directory.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/store/Directory.java	(working copy)
@@ -46,9 +46,7 @@
   /**
    * Returns an array of strings, one for each file in the directory.
    * 
-   * @throws NoSuchDirectoryException if the directory is not prepared for any
-   *         write operations (such as {@link #createOutput(String, IOContext)}).
-   * @throws IOException in case of other IO errors
+   * @throws IOException in case of IO error
    */
   public abstract String[] listAll() throws IOException;
 
Index: lucene/core/src/java/org/apache/lucene/store/FSDirectory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/FSDirectory.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/store/FSDirectory.java	(working copy)
@@ -20,16 +20,17 @@
 import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.IOUtils;
 
-import java.io.File;
-import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
-import java.io.FilenameFilter;
 import java.io.FilterOutputStream;
 import java.io.IOException;
+import java.nio.file.DirectoryStream;
 import java.nio.file.Files;
+import java.nio.file.Path;
 import java.nio.file.StandardCopyOption;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Set;
 import java.util.concurrent.Future;
 
@@ -114,14 +115,9 @@
  */
 public abstract class FSDirectory extends BaseDirectory {
 
-  protected final File directory; // The underlying filesystem directory
+  protected final Path directory; // The underlying filesystem directory
   protected final Set<String> staleFiles = synchronizedSet(new HashSet<String>()); // Files written, but not yet sync'ed
 
-  // returns the canonical version of the directory, creating it if it doesn't exist.
-  private static File getCanonicalPath(File file) throws IOException {
-    return new File(file.getCanonicalPath());
-  }
-
   /** Create a new FSDirectory for the named location (ctor for subclasses).
    * @param path the path of the directory
    * @param lockFactory the lock factory to use, or null for the default
@@ -128,18 +124,16 @@
    * ({@link NativeFSLockFactory});
    * @throws IOException if there is a low-level I/O error
    */
-  protected FSDirectory(File path, LockFactory lockFactory) throws IOException {
+  protected FSDirectory(Path path, LockFactory lockFactory) throws IOException {
     // new ctors use always NativeFSLockFactory as default:
     if (lockFactory == null) {
       lockFactory = new NativeFSLockFactory();
     }
-    directory = getCanonicalPath(path);
+    
+    Files.createDirectories(path);  // create directory, if it doesnt exist
+    directory = path.toRealPath();
 
-    if (directory.exists() && !directory.isDirectory())
-      throw new NoSuchDirectoryException("file '" + directory + "' exists but is not a directory");
-
     setLockFactory(lockFactory);
-
   }
 
   /** Creates an FSDirectory instance, trying to pick the
@@ -162,13 +156,13 @@
    * {@link MMapDirectory} on 64 bit JVMs.
    *
    * <p>See <a href="#subclasses">above</a> */
-  public static FSDirectory open(File path) throws IOException {
+  public static FSDirectory open(Path path) throws IOException {
     return open(path, null);
   }
 
-  /** Just like {@link #open(File)}, but allows you to
+  /** Just like {@link #open(Path)}, but allows you to
    *  also specify a custom {@link LockFactory}. */
-  public static FSDirectory open(File path, LockFactory lockFactory) throws IOException {
+  public static FSDirectory open(Path path, LockFactory lockFactory) throws IOException {
     if (Constants.JRE_IS_64BIT && MMapDirectory.UNMAP_SUPPORTED) {
       return new MMapDirectory(path, lockFactory);
     } else if (Constants.WINDOWS) {
@@ -186,12 +180,12 @@
     // in index dir. If no index dir is given, set ourselves
     if (lockFactory instanceof FSLockFactory) {
       final FSLockFactory lf = (FSLockFactory) lockFactory;
-      final File dir = lf.getLockDir();
+      final Path dir = lf.getLockDir();
       // if the lock factory has no lockDir set, use the this directory as lockDir
       if (dir == null) {
         lf.setLockDir(directory);
         lf.setLockPrefix(null);
-      } else if (dir.getCanonicalPath().equals(directory.getCanonicalPath())) {
+      } else if (dir.toRealPath().equals(directory)) {
         lf.setLockPrefix(null);
       }
     }
@@ -199,36 +193,29 @@
   }
   
   /** Lists all files (not subdirectories) in the
-   *  directory.  This method never returns null (throws
-   *  {@link IOException} instead).
+   *  directory.
    *
-   *  @throws NoSuchDirectoryException if the directory
-   *   does not exist, or does exist but is not a
-   *   directory.
-   *  @throws IOException if list() returns null */
-  public static String[] listAll(File dir) throws IOException {
-    if (!dir.exists())
-      throw new NoSuchDirectoryException("directory '" + dir + "' does not exist");
-    else if (!dir.isDirectory())
-      throw new NoSuchDirectoryException("file '" + dir + "' exists but is not a directory");
-
-    // Exclude subdirs
-    String[] result = dir.list(new FilenameFilter() {
-        @Override
-        public boolean accept(File dir, String file) {
-          return !new File(dir, file).isDirectory();
-        }
-      });
-
-    if (result == null)
-      throw new IOException("directory '" + dir + "' exists and is a directory, but cannot be listed: list() returned null");
-
-    return result;
+   *  @throws IOException if there was an I/O error during listing */
+  public static String[] listAll(Path dir) throws IOException {
+    List<String> entries = new ArrayList<>();
+    
+    try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, new DirectoryStream.Filter<Path>() {
+      @Override
+      public boolean accept(Path entry) throws IOException {
+        return !Files.isDirectory(entry); // filter out entries that are definitely directories.
+      }
+    })) {
+      for (Path path : stream) {
+        entries.add(path.getFileName().toString());
+      }
+    }
+    
+    return entries.toArray(new String[entries.size()]);
   }
 
   /** Lists all files (not subdirectories) in the
    * directory.
-   * @see #listAll(File) */
+   * @see #listAll(Path) */
   @Override
   public String[] listAll() throws IOException {
     ensureOpen();
@@ -239,13 +226,7 @@
   @Override
   public long fileLength(String name) throws IOException {
     ensureOpen();
-    File file = new File(directory, name);
-    final long len = file.length();
-    if (len == 0 && !file.exists()) {
-      throw new FileNotFoundException(name);
-    } else {
-      return len;
-    }
+    return Files.size(directory.resolve(name));
   }
 
   /** Removes an existing file in the directory. */
@@ -252,8 +233,7 @@
   @Override
   public void deleteFile(String name) throws IOException {
     ensureOpen();
-    File file = new File(directory, name);
-    Files.delete(file.toPath());
+    Files.delete(directory.resolve(name));
     staleFiles.remove(name);
   }
 
@@ -267,12 +247,7 @@
   }
 
   protected void ensureCanWrite(String name) throws IOException {
-    if (!directory.exists())
-      if (!directory.mkdirs())
-        throw new IOException("Cannot create directory: " + directory);
-
-    File file = new File(directory, name);
-    Files.deleteIfExists(file.toPath()); // delete existing, if any
+    Files.deleteIfExists(directory.resolve(name)); // delete existing, if any
   }
 
   /**
@@ -299,7 +274,7 @@
   @Override
   public void renameFile(String source, String dest) throws IOException {
     ensureOpen();
-    Files.move(new File(directory, source).toPath(), new File(directory, dest).toPath(), StandardCopyOption.ATOMIC_MOVE);
+    Files.move(directory.resolve(source), directory.resolve(dest), StandardCopyOption.ATOMIC_MOVE);
     // TODO: should we move directory fsync to a separate 'syncMetadata' method?
     // for example, to improve listCommits(), IndexFileDeleter could also call that after deleting segments_Ns
     IOUtils.fsync(directory, true);
@@ -308,12 +283,7 @@
   @Override
   public String getLockID() {
     ensureOpen();
-    String dirName;                               // name to be hashed
-    try {
-      dirName = directory.getCanonicalPath();
-    } catch (IOException e) {
-      throw new RuntimeException(e.toString(), e);
-    }
+    String dirName = directory.toString();  // name to be hashed
 
     int digest = 0;
     for(int charIDX=0;charIDX<dirName.length();charIDX++) {
@@ -330,7 +300,7 @@
   }
 
   /** @return the underlying filesystem directory */
-  public File getDirectory() {
+  public Path getDirectory() {
     ensureOpen();
     return directory;
   }
@@ -351,7 +321,7 @@
     private final String name;
 
     public FSIndexOutput(String name) throws IOException {
-      super(new FilterOutputStream(new FileOutputStream(new File(directory, name))) {
+      super(new FilterOutputStream(Files.newOutputStream(directory.resolve(name))) {
         // This implementation ensures, that we never write more than CHUNK_SIZE bytes:
         @Override
         public void write(byte[] b, int offset, int length) throws IOException {
@@ -377,6 +347,6 @@
   }
 
   protected void fsync(String name) throws IOException {
-    IOUtils.fsync(new File(directory, name), false);
+    IOUtils.fsync(directory.resolve(name), false);
   }
 }
Index: lucene/core/src/java/org/apache/lucene/store/FSLockFactory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/FSLockFactory.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/store/FSLockFactory.java	(working copy)
@@ -17,7 +17,7 @@
  * limitations under the License.
  */
 
-import java.io.File;
+import java.nio.file.Path;
 
 /**
  * Base class for file system based locking implementation.
@@ -28,7 +28,7 @@
   /**
    * Directory for the lock files.
    */
-  protected File lockDir = null;
+  protected Path lockDir = null;
 
   /**
    * Set the lock directory. This method can be only called
@@ -37,7 +37,7 @@
    * Subclasses can also use this method to set the directory
    * in the constructor.
    */
-  protected final void setLockDir(File lockDir) {
+  protected final void setLockDir(Path lockDir) {
     if (this.lockDir != null)
       throw new IllegalStateException("You can set the lock directory for this factory only once.");
     this.lockDir = lockDir;
@@ -46,7 +46,7 @@
   /**
    * Retrieve the lock directory.
    */
-  public File getLockDir() {
+  public Path getLockDir() {
     return lockDir;
   }
 
Index: lucene/core/src/java/org/apache/lucene/store/FileSwitchDirectory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/FileSwitchDirectory.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/store/FileSwitchDirectory.java	(working copy)
@@ -19,6 +19,7 @@
 
 import java.io.IOException;
 import java.nio.file.AtomicMoveNotSupportedException;
+import java.nio.file.NoSuchFileException;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -82,13 +83,13 @@
     // LUCENE-3380: either or both of our dirs could be FSDirs,
     // but if one underlying delegate is an FSDir and mkdirs() has not
     // yet been called, because so far everything is written to the other,
-    // in this case, we don't want to throw a NoSuchDirectoryException
-    NoSuchDirectoryException exc = null;
+    // in this case, we don't want to throw a NoSuchFileException
+    NoSuchFileException exc = null;
     try {
       for(String f : primaryDir.listAll()) {
         files.add(f);
       }
-    } catch (NoSuchDirectoryException e) {
+    } catch (NoSuchFileException e) {
       exc = e;
     }
     try {
@@ -95,19 +96,19 @@
       for(String f : secondaryDir.listAll()) {
         files.add(f);
       }
-    } catch (NoSuchDirectoryException e) {
-      // we got NoSuchDirectoryException from both dirs
+    } catch (NoSuchFileException e) {
+      // we got NoSuchFileException from both dirs
       // rethrow the first.
       if (exc != null) {
         throw exc;
       }
-      // we got NoSuchDirectoryException from the secondary,
+      // we got NoSuchFileException from the secondary,
       // and the primary is empty.
       if (files.isEmpty()) {
         throw e;
       }
     }
-    // we got NoSuchDirectoryException from the primary,
+    // we got NoSuchFileException from the primary,
     // and the secondary is empty.
     if (exc != null && files.isEmpty()) {
       throw exc;
Index: lucene/core/src/java/org/apache/lucene/store/LockStressTest.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/LockStressTest.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/store/LockStressTest.java	(working copy)
@@ -136,7 +136,7 @@
     File lockDir = new File(lockDirName);
 
     if (lockFactory instanceof FSLockFactory) {
-      ((FSLockFactory) lockFactory).setLockDir(lockDir);
+      ((FSLockFactory) lockFactory).setLockDir(lockDir.toPath());
     }
     lockFactory.setLockPrefix("test");
     return lockFactory;
Index: lucene/core/src/java/org/apache/lucene/store/MMapDirectory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/MMapDirectory.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/store/MMapDirectory.java	(working copy)
@@ -18,11 +18,11 @@
  */
  
 import java.io.IOException;
-import java.io.File;
 import java.nio.ByteBuffer;
 import java.nio.channels.ClosedChannelException; // javadoc @link
 import java.nio.channels.FileChannel;
 import java.nio.channels.FileChannel.MapMode;
+import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
 
 import java.security.AccessController;
@@ -44,7 +44,7 @@
  * be sure your have plenty of virtual address space, e.g. by
  * using a 64 bit JRE, or a 32 bit JRE with indexes that are
  * guaranteed to fit within the address space.
- * On 32 bit platforms also consult {@link #MMapDirectory(File, LockFactory, int)}
+ * On 32 bit platforms also consult {@link #MMapDirectory(Path, LockFactory, int)}
  * if you have problems with mmap failing because of fragmented
  * address space. If you get an OutOfMemoryException, it is recommended
  * to reduce the chunk size, until it works.
@@ -83,7 +83,7 @@
   private boolean useUnmapHack = UNMAP_SUPPORTED;
   /** 
    * Default max chunk size.
-   * @see #MMapDirectory(File, LockFactory, int)
+   * @see #MMapDirectory(Path, LockFactory, int)
    */
   public static final int DEFAULT_MAX_BUFF = Constants.JRE_IS_64BIT ? (1 << 30) : (1 << 28);
   final int chunkSizePower;
@@ -95,7 +95,7 @@
    * ({@link NativeFSLockFactory});
    * @throws IOException if there is a low-level I/O error
    */
-  public MMapDirectory(File path, LockFactory lockFactory) throws IOException {
+  public MMapDirectory(Path path, LockFactory lockFactory) throws IOException {
     this(path, lockFactory, DEFAULT_MAX_BUFF);
   }
 
@@ -104,7 +104,7 @@
    * @param path the path of the directory
    * @throws IOException if there is a low-level I/O error
    */
-  public MMapDirectory(File path) throws IOException {
+  public MMapDirectory(Path path) throws IOException {
     this(path, null);
   }
   
@@ -128,7 +128,7 @@
    * <b>Please note:</b> The chunk size is always rounded down to a power of 2.
    * @throws IOException if there is a low-level I/O error
    */
-  public MMapDirectory(File path, LockFactory lockFactory, int maxChunkSize) throws IOException {
+  public MMapDirectory(Path path, LockFactory lockFactory, int maxChunkSize) throws IOException {
     super(path, lockFactory);
     if (maxChunkSize <= 0) {
       throw new IllegalArgumentException("Maximum chunk size for mmap must be >0");
@@ -182,7 +182,7 @@
   
   /**
    * Returns the current mmap chunk size.
-   * @see #MMapDirectory(File, LockFactory, int)
+   * @see #MMapDirectory(Path, LockFactory, int)
    */
   public final int getMaxChunkSize() {
     return 1 << chunkSizePower;
@@ -192,9 +192,9 @@
   @Override
   public IndexInput openInput(String name, IOContext context) throws IOException {
     ensureOpen();
-    File file = new File(getDirectory(), name);
-    try (FileChannel c = FileChannel.open(file.toPath(), StandardOpenOption.READ)) {
-      final String resourceDescription = "MMapIndexInput(path=\"" + file.toString() + "\")";
+    Path path = directory.resolve(name);
+    try (FileChannel c = FileChannel.open(path, StandardOpenOption.READ)) {
+      final String resourceDescription = "MMapIndexInput(path=\"" + path.toString() + "\")";
       final boolean useUnmap = getUseUnmap();
       return ByteBufferIndexInput.newInstance(resourceDescription,
           map(resourceDescription, c, 0, c.size()), 
Index: lucene/core/src/java/org/apache/lucene/store/NIOFSDirectory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/NIOFSDirectory.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/store/NIOFSDirectory.java	(working copy)
@@ -17,12 +17,12 @@
  * the License.
  */
 
-import java.io.File;
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.channels.ClosedChannelException; // javadoc @link
 import java.nio.channels.FileChannel;
+import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
 import java.util.concurrent.Future; // javadoc
 
@@ -60,7 +60,7 @@
    * ({@link NativeFSLockFactory});
    * @throws IOException if there is a low-level I/O error
    */
-  public NIOFSDirectory(File path, LockFactory lockFactory) throws IOException {
+  public NIOFSDirectory(Path path, LockFactory lockFactory) throws IOException {
     super(path, lockFactory);
   }
 
@@ -69,7 +69,7 @@
    * @param path the path of the directory
    * @throws IOException if there is a low-level I/O error
    */
-  public NIOFSDirectory(File path) throws IOException {
+  public NIOFSDirectory(Path path) throws IOException {
     super(path, null);
   }
 
@@ -77,8 +77,8 @@
   @Override
   public IndexInput openInput(String name, IOContext context) throws IOException {
     ensureOpen();
-    File path = new File(getDirectory(), name);
-    FileChannel fc = FileChannel.open(path.toPath(), StandardOpenOption.READ);
+    Path path = getDirectory().resolve(name);
+    FileChannel fc = FileChannel.open(path, StandardOpenOption.READ);
     return new NIOFSIndexInput("NIOFSIndexInput(path=\"" + path + "\")", fc, context);
   }
   
Index: lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory.java	(working copy)
@@ -18,11 +18,11 @@
  */
 
 import java.io.IOException;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Set;
 
-import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.store.RAMDirectory;      // javadocs
 import org.apache.lucene.util.Accountable;
 import org.apache.lucene.util.IOUtils;
@@ -49,7 +49,7 @@
  * <p>Here's a simple example usage:
  *
  * <pre class="prettyprint">
- *   Directory fsDir = FSDirectory.open(new File("/path/to/index"));
+ *   Directory fsDir = FSDirectory.open(new File("/path/to/index").toPath());
  *   NRTCachingDirectory cachedFSDir = new NRTCachingDirectory(fsDir, 5.0, 60.0);
  *   IndexWriterConfig conf = new IndexWriterConfig(analyzer);
  *   IndexWriter writer = new IndexWriter(cachedFSDir, conf);
@@ -96,23 +96,11 @@
     for(String f : cache.listAll()) {
       files.add(f);
     }
-    // LUCENE-1468: our NRTCachingDirectory will actually exist (RAMDir!),
-    // but if the underlying delegate is an FSDir and mkdirs() has not
-    // yet been called, because so far everything is a cached write,
-    // in this case, we don't want to throw a NoSuchDirectoryException
-    try {
-      for(String f : in.listAll()) {
-        // Cannot do this -- if lucene calls createOutput but
-        // file already exists then this falsely trips:
-        //assert !files.contains(f): "file \"" + f + "\" is in both dirs";
-        files.add(f);
+    for(String f : in.listAll()) {
+      if (!files.add(f)) {
+        throw new IllegalStateException("file: " + in + " appears both in delegate and in cache: " +
+                                        "cache=" + Arrays.toString(cache.listAll()) + ",delegate=" + Arrays.toString(in.listAll()));
       }
-    } catch (NoSuchDirectoryException ex) {
-      // however, if there are no cached files, then the directory truly
-      // does not "exist"
-      if (files.isEmpty()) {
-        throw ex;
-      }
     }
     return files.toArray(new String[files.size()]);
   }
Index: lucene/core/src/java/org/apache/lucene/store/NativeFSLockFactory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/NativeFSLockFactory.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/store/NativeFSLockFactory.java	(working copy)
@@ -20,6 +20,8 @@
 import java.nio.channels.FileChannel;
 import java.nio.channels.FileLock;
 import java.nio.channels.OverlappingFileLockException;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
 import java.io.File;
 import java.io.IOException;
@@ -78,26 +80,16 @@
    * your create!
    */
   public NativeFSLockFactory() {
-    this((File) null);
+    this((Path) null);
   }
 
   /**
    * Create a NativeFSLockFactory instance, storing lock
-   * files into the specified lockDirName:
-   *
-   * @param lockDirName where lock files are created.
-   */
-  public NativeFSLockFactory(String lockDirName) {
-    this(new File(lockDirName));
-  }
-
-  /**
-   * Create a NativeFSLockFactory instance, storing lock
    * files into the specified lockDir:
    * 
    * @param lockDir where lock files are created.
    */
-  public NativeFSLockFactory(File lockDir) {
+  public NativeFSLockFactory(Path lockDir) {
     setLockDir(lockDir);
   }
 
@@ -118,14 +110,14 @@
 
   private FileChannel channel;
   private FileLock lock;
-  private File path;
-  private File lockDir;
+  private Path path;
+  private Path lockDir;
   private static final Set<String> LOCK_HELD = Collections.synchronizedSet(new HashSet<String>());
 
 
-  public NativeFSLock(File lockDir, String lockFileName) {
+  public NativeFSLock(Path lockDir, String lockFileName) {
     this.lockDir = lockDir;
-    path = new File(lockDir, lockFileName);
+    path = lockDir.resolve(lockFileName);
   }
 
 
@@ -138,16 +130,14 @@
     }
 
     // Ensure that lockDir exists and is a directory.
-    if (!lockDir.exists()) {
-      if (!lockDir.mkdirs())
-        throw new IOException("Cannot create directory: " +
-            lockDir.getAbsolutePath());
-    } else if (!lockDir.isDirectory()) {
-      // TODO: NoSuchDirectoryException instead?
-      throw new IOException("Found regular file where directory expected: " + 
-          lockDir.getAbsolutePath());
+    Files.createDirectories(lockDir);
+    try {
+      Files.createFile(path);
+    } catch (IOException ignore) {
+      // we must create the file to have a truly canonical path.
+      // if its already created, we don't care. if it cant be created, it will fail below.
     }
-    final String canonicalPath = path.getCanonicalPath();
+    final Path canonicalPath = path.toRealPath();
     // Make sure nobody else in-process has this lock held
     // already, and, mark it held if not:
     // This is a pretty crazy workaround for some documented
@@ -162,9 +152,9 @@
     // is that we can't re-obtain the lock in the same JVM but from a different process if that happens. Nevertheless
     // this is super trappy. See LUCENE-5738
     boolean obtained = false;
-    if (LOCK_HELD.add(canonicalPath)) {
+    if (LOCK_HELD.add(canonicalPath.toString())) {
       try {
-        channel = FileChannel.open(path.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE);
+        channel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE);
         try {
           lock = channel.tryLock();
           obtained = lock != null;
@@ -209,8 +199,9 @@
     }
   }
 
-  private static final void clearLockHeld(File path) throws IOException {
-    boolean remove = LOCK_HELD.remove(path.getCanonicalPath());
+  private static final void clearLockHeld(Path path) throws IOException {
+    path = path.toRealPath();
+    boolean remove = LOCK_HELD.remove(path.toString());
     assert remove : "Lock was cleared but never marked as held";
   }
 
@@ -221,8 +212,8 @@
     // First a shortcut, if a lock reference in this instance is available
     if (lock != null) return true;
     
-    // Look if lock file is present; if not, there can definitely be no lock!
-    if (!path.exists()) return false;
+    // Look if lock file is definitely not present; if not, there can definitely be no lock!
+    if (Files.notExists(path)) return false;
     
     // Try to obtain and release (if was locked) the lock
     try {
Index: lucene/core/src/java/org/apache/lucene/store/NoSuchDirectoryException.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/NoSuchDirectoryException.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/store/NoSuchDirectoryException.java	(working copy)
@@ -1,31 +0,0 @@
-package org.apache.lucene.store;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.FileNotFoundException;
-
-/**
- * This exception is thrown when you try to list a
- * non-existent directory.
- */
-
-public class NoSuchDirectoryException extends FileNotFoundException {
-  public NoSuchDirectoryException(String message) {
-    super(message);
-  }
-}
Index: lucene/core/src/java/org/apache/lucene/store/SimpleFSDirectory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/SimpleFSDirectory.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/store/SimpleFSDirectory.java	(working copy)
@@ -21,6 +21,7 @@
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
+import java.nio.file.Path;
 
 /** A straightforward implementation of {@link FSDirectory}
  *  using java.io.RandomAccessFile.  However, this class has
@@ -28,6 +29,8 @@
  *  bottleneck) as it synchronizes when multiple threads
  *  read from the same file.  It's usually better to use
  *  {@link NIOFSDirectory} or {@link MMapDirectory} instead. */
+// TODO: we currently mandate .toFile to still use RandomAccessFile, to avoid ClosedByInterruptException.
+// should we change to SeekableByteChannel instead?
 public class SimpleFSDirectory extends FSDirectory {
     
   /** Create a new SimpleFSDirectory for the named location.
@@ -37,8 +40,9 @@
    * ({@link NativeFSLockFactory});
    * @throws IOException if there is a low-level I/O error
    */
-  public SimpleFSDirectory(File path, LockFactory lockFactory) throws IOException {
+  public SimpleFSDirectory(Path path, LockFactory lockFactory) throws IOException {
     super(path, lockFactory);
+    path.toFile(); // throw exception if we can't get a File for now
   }
   
   /** Create a new SimpleFSDirectory for the named location and {@link NativeFSLockFactory}.
@@ -46,8 +50,9 @@
    * @param path the path of the directory
    * @throws IOException if there is a low-level I/O error
    */
-  public SimpleFSDirectory(File path) throws IOException {
+  public SimpleFSDirectory(Path path) throws IOException {
     super(path, null);
+    path.toFile(); // throw exception if we can't get a File for now
   }
 
   /** Creates an IndexInput for the file with the given name. */
@@ -54,7 +59,7 @@
   @Override
   public IndexInput openInput(String name, IOContext context) throws IOException {
     ensureOpen();
-    final File path = new File(directory, name);
+    final File path = directory.resolve(name).toFile();
     RandomAccessFile raf = new RandomAccessFile(path, "r");
     return new SimpleFSIndexInput("SimpleFSIndexInput(path=\"" + path.getPath() + "\")", raf, context);
   }
Index: lucene/core/src/java/org/apache/lucene/store/SimpleFSLockFactory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/SimpleFSLockFactory.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/store/SimpleFSLockFactory.java	(working copy)
@@ -20,10 +20,11 @@
 import java.io.File;
 import java.io.IOException;
 import java.nio.file.Files;
+import java.nio.file.Path;
 
 /**
  * <p>Implements {@link LockFactory} using {@link
- * File#createNewFile()}.</p>
+ * Files#createFile}.</p>
  *
  * <p><b>NOTE:</b> the {@linkplain File#createNewFile() javadocs
  * for <code>File.createNewFile()</code>} contain a vague
@@ -69,25 +70,17 @@
    * your create!
    */
   public SimpleFSLockFactory() {
-    this((File) null);
+    this((Path) null);
   }
 
   /**
-   * Instantiate using the provided directory (as a File instance).
+   * Instantiate using the provided directory (as a Path instance).
    * @param lockDir where lock files should be created.
    */
-  public SimpleFSLockFactory(File lockDir) {
+  public SimpleFSLockFactory(Path lockDir) {
     setLockDir(lockDir);
   }
 
-  /**
-   * Instantiate using the provided directory name (String).
-   * @param lockDirName where lock files should be created.
-   */
-  public SimpleFSLockFactory(String lockDirName) {
-    setLockDir(new File(lockDirName));
-  }
-
   @Override
   public Lock makeLock(String lockName) {
     if (lockPrefix != null) {
@@ -98,42 +91,29 @@
 
   @Override
   public void clearLock(String lockName) throws IOException {
-    if (lockDir.exists()) {
-      if (lockPrefix != null) {
-        lockName = lockPrefix + "-" + lockName;
-      }
-      File lockFile = new File(lockDir, lockName);
-      Files.deleteIfExists(lockFile.toPath());
+    if (lockPrefix != null) {
+      lockName = lockPrefix + "-" + lockName;
     }
+    Files.deleteIfExists(lockDir.resolve(lockName));
   }
 }
 
 class SimpleFSLock extends Lock {
 
-  File lockFile;
-  File lockDir;
+  Path lockFile;
+  Path lockDir;
 
-  public SimpleFSLock(File lockDir, String lockFileName) {
+  public SimpleFSLock(Path lockDir, String lockFileName) {
     this.lockDir = lockDir;
-    lockFile = new File(lockDir, lockFileName);
+    lockFile = lockDir.resolve(lockFileName);
   }
 
   @Override
   public boolean obtain() throws IOException {
-
-    // Ensure that lockDir exists and is a directory:
-    if (!lockDir.exists()) {
-      if (!lockDir.mkdirs())
-        throw new IOException("Cannot create directory: " +
-                              lockDir.getAbsolutePath());
-    } else if (!lockDir.isDirectory()) {
-      // TODO: NoSuchDirectoryException instead?
-      throw new IOException("Found regular file where directory expected: " + 
-                            lockDir.getAbsolutePath());
-    }
-    
     try {
-      return lockFile.createNewFile();
+      Files.createDirectories(lockDir);
+      Files.createFile(lockFile);
+      return true;
     } catch (IOException ioe) {
       // On Windows, on concurrent createNewFile, the 2nd process gets "access denied".
       // In that case, the lock was not aquired successfully, so return false.
@@ -148,7 +128,7 @@
   public void close() throws LockReleaseFailedException {
     // TODO: wierd that clearLock() throws the raw IOException...
     try {
-      Files.deleteIfExists(lockFile.toPath());
+      Files.deleteIfExists(lockFile);
     } catch (Throwable cause) {
       throw new LockReleaseFailedException("failed to delete " + lockFile, cause);
     }
@@ -156,7 +136,7 @@
 
   @Override
   public boolean isLocked() {
-    return lockFile.exists();
+    return Files.exists(lockFile);
   }
 
   @Override
Index: lucene/core/src/java/org/apache/lucene/util/CommandLineUtil.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/CommandLineUtil.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/util/CommandLineUtil.java	(working copy)
@@ -17,9 +17,9 @@
  * limitations under the License.
  */
 
-import java.io.File;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
+import java.nio.file.Path;
 
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.FSDirectory;
@@ -37,13 +37,13 @@
   /**
    * Creates a specific FSDirectory instance starting from its class name
    * @param clazzName The name of the FSDirectory class to load
-   * @param file The file to be used as parameter constructor
+   * @param path The path to be used as parameter constructor
    * @return the new FSDirectory instance
    */
-  public static FSDirectory newFSDirectory(String clazzName, File file) {
+  public static FSDirectory newFSDirectory(String clazzName, Path path) {
     try {
       final Class<? extends FSDirectory> clazz = loadFSDirectoryClass(clazzName);
-      return newFSDirectory(clazz, file);
+      return newFSDirectory(clazz, path);
     } catch (ClassNotFoundException e) {
       throw new IllegalArgumentException(FSDirectory.class.getSimpleName()
           + " implementation not found: " + clazzName, e);
@@ -52,7 +52,7 @@
           + " implementation", e);
     } catch (NoSuchMethodException e) {
       throw new IllegalArgumentException(clazzName + " constructor with "
-          + File.class.getSimpleName() + " as parameter not found", e);
+          + Path.class.getSimpleName() + " as parameter not found", e);
     } catch (Exception e) {
       throw new IllegalArgumentException("Error creating " + clazzName + " instance", e);
     }
@@ -95,18 +95,18 @@
   /**
    * Creates a new specific FSDirectory instance
    * @param clazz The class of the object to be created
-   * @param file The file to be used as parameter constructor
+   * @param path The file to be used as parameter constructor
    * @return The new FSDirectory instance
-   * @throws NoSuchMethodException If the Directory does not have a constructor that takes <code>File</code>.
+   * @throws NoSuchMethodException If the Directory does not have a constructor that takes <code>Path</code>.
    * @throws InstantiationException If the class is abstract or an interface.
    * @throws IllegalAccessException If the constructor does not have public visibility.
    * @throws InvocationTargetException If the constructor throws an exception
    */
-  public static FSDirectory newFSDirectory(Class<? extends FSDirectory> clazz, File file) 
+  public static FSDirectory newFSDirectory(Class<? extends FSDirectory> clazz, Path path) 
       throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
-    // Assuming every FSDirectory has a ctor(File):
-    Constructor<? extends FSDirectory> ctor = clazz.getConstructor(File.class);
-    return ctor.newInstance(file);
+    // Assuming every FSDirectory has a ctor(Path):
+    Constructor<? extends FSDirectory> ctor = clazz.getConstructor(Path.class);
+    return ctor.newInstance(path);
   }
   
 }
Index: lucene/core/src/java/org/apache/lucene/util/IOUtils.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/IOUtils.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/util/IOUtils.java	(working copy)
@@ -33,8 +33,12 @@
 import java.nio.charset.CharsetDecoder;
 import java.nio.charset.CodingErrorAction;
 import java.nio.charset.StandardCharsets;
+import java.nio.file.FileVisitResult;
+import java.nio.file.FileVisitor;
 import java.nio.file.Files;
+import java.nio.file.Path;
 import java.nio.file.StandardOpenOption;
+import java.nio.file.attribute.BasicFileAttributes;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -233,7 +237,7 @@
    * <p>
    * Some of the files may be null, if so they are ignored.
    */
-  public static void deleteFilesIgnoringExceptions(File... files) {
+  public static void deleteFilesIgnoringExceptions(Path... files) {
     deleteFilesIgnoringExceptions(Arrays.asList(files));
   }
   
@@ -242,11 +246,11 @@
    * <p>
    * Some of the files may be null, if so they are ignored.
    */
-  public static void deleteFilesIgnoringExceptions(Iterable<? extends File> files) {
-    for (File name : files) {
+  public static void deleteFilesIgnoringExceptions(Iterable<? extends Path> files) {
+    for (Path name : files) {
       if (name != null) {
         try {
-          Files.delete(name.toPath());
+          Files.delete(name);
         } catch (Throwable ignored) {
           // ignore
         }
@@ -255,7 +259,7 @@
   }
   
   /**
-   * Deletes all given <tt>File</tt>s, if they exist.  Some of the
+   * Deletes all given <tt>Path</tt>s, if they exist.  Some of the
    * <tt>File</tt>s may be null; they are
    * ignored.  After everything is deleted, the method either
    * throws the first exception it hit while deleting, or
@@ -263,12 +267,12 @@
    * 
    * @param files files to delete
    */
-  public static void deleteFilesIfExist(File... files) throws IOException {
+  public static void deleteFilesIfExist(Path... files) throws IOException {
     deleteFilesIfExist(Arrays.asList(files));
   }
   
   /**
-   * Deletes all given <tt>File</tt>s, if they exist.  Some of the
+   * Deletes all given <tt>Path</tt>s, if they exist.  Some of the
    * <tt>File</tt>s may be null; they are
    * ignored.  After everything is deleted, the method either
    * throws the first exception it hit while deleting, or
@@ -276,13 +280,13 @@
    * 
    * @param files files to delete
    */
-  public static void deleteFilesIfExist(Iterable<? extends File> files) throws IOException {
+  public static void deleteFilesIfExist(Iterable<? extends Path> files) throws IOException {
     Throwable th = null;
 
-    for (File file : files) {
+    for (Path file : files) {
       try {
         if (file != null) {
-          Files.deleteIfExists(file.toPath());
+          Files.deleteIfExists(file);
         }
       } catch (Throwable t) {
         addSuppressed(th, t);
@@ -301,13 +305,13 @@
    * @throws IOException if any of the given files (or their subhierarchy files in case
    * of directories) cannot be removed.
    */
-  public static void rm(File... locations) throws IOException {
-    LinkedHashMap<File,Throwable> unremoved = rm(new LinkedHashMap<File,Throwable>(), locations);
+  public static void rm(Path... locations) throws IOException {
+    LinkedHashMap<Path,Throwable> unremoved = rm(new LinkedHashMap<Path,Throwable>(), locations);
     if (!unremoved.isEmpty()) {
       StringBuilder b = new StringBuilder("Could not remove the following files (in the order of attempts):\n");
-      for (Map.Entry<File,Throwable> kv : unremoved.entrySet()) {
+      for (Map.Entry<Path,Throwable> kv : unremoved.entrySet()) {
         b.append("   ")
-         .append(kv.getKey().getAbsolutePath())
+         .append(kv.getKey().toAbsolutePath())
          .append(": ")
          .append(kv.getValue())
          .append("\n");
@@ -316,18 +320,50 @@
     }
   }
 
-  private static LinkedHashMap<File,Throwable> rm(LinkedHashMap<File,Throwable> unremoved, File... locations) {
+  private static LinkedHashMap<Path,Throwable> rm(final LinkedHashMap<Path,Throwable> unremoved, Path... locations) {
     if (locations != null) {
-      for (File location : locations) {
-        if (location != null && location.exists()) {
-          if (location.isDirectory()) {
-            rm(unremoved, location.listFiles());
-          }
-  
+      for (Path location : locations) {
+        // TODO: remove this leniency!
+        if (location != null && Files.exists(location)) {
           try {
-            Files.delete(location.toPath());
-          } catch (Throwable cause) {
-            unremoved.put(location, cause);
+            Files.walkFileTree(location, new FileVisitor<Path>() {            
+              @Override
+              public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
+                return FileVisitResult.CONTINUE;
+              }
+              
+              @Override
+              public FileVisitResult postVisitDirectory(Path dir, IOException impossible) throws IOException {
+                assert impossible == null;
+                
+                try {
+                  Files.delete(dir);
+                } catch (IOException e) {
+                  unremoved.put(dir, e);
+                }
+                return FileVisitResult.CONTINUE;
+              }
+              
+              @Override
+              public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
+                try {
+                  Files.delete(file);
+                } catch (IOException exc) {
+                  unremoved.put(file, exc);
+                }
+                return FileVisitResult.CONTINUE;
+              }
+              
+              @Override
+              public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
+                if (exc != null) {
+                  unremoved.put(file, exc);
+                }
+                return FileVisitResult.CONTINUE;
+              }
+            });
+          } catch (IOException impossible) {
+            throw new AssertionError("visitor threw exception", impossible);
           }
         }
       }
@@ -394,12 +430,12 @@
    * @param isDir if true, the given file is a directory (we open for read and ignore IOExceptions,
    *  because not all file systems and operating systems allow to fsync on a directory)
    */
-  public static void fsync(File fileToSync, boolean isDir) throws IOException {
+  public static void fsync(Path fileToSync, boolean isDir) throws IOException {
     IOException exc = null;
     
     // If the file is a directory we have to open read-only, for regular files we must open r/w for the fsync to have an effect.
     // See http://blog.httrack.com/blog/2013/11/15/everything-you-always-wanted-to-know-about-fsync/
-    try (final FileChannel file = FileChannel.open(fileToSync.toPath(), isDir ? StandardOpenOption.READ : StandardOpenOption.WRITE)) {
+    try (final FileChannel file = FileChannel.open(fileToSync, isDir ? StandardOpenOption.READ : StandardOpenOption.WRITE)) {
       for (int retry = 0; retry < 5; retry++) {
         try {
           file.force(true);
Index: lucene/core/src/java/org/apache/lucene/util/OfflineSorter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/OfflineSorter.java	(revision 1624571)
+++ lucene/core/src/java/org/apache/lucene/util/OfflineSorter.java	(working copy)
@@ -26,12 +26,12 @@
 import java.io.DataOutputStream;
 import java.io.EOFException;
 import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.StandardCopyOption;
 import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.List;
@@ -45,7 +45,7 @@
  *   <li>exactly the above count of bytes for the sequence to be sorted.
  * </ul>
  * 
- * @see #sort(File, File)
+ * @see #sort(Path, Path)
  * @lucene.experimental
  * @lucene.internal
  */
@@ -167,7 +167,7 @@
   }
 
   private final BufferSize ramBufferSize;
-  private final File tempDirectory;
+  private final Path tempDirectory;
   
   private final Counter bufferBytesUsed = Counter.newCounter();
   private final BytesRefArray buffer = new BytesRefArray(bufferBytesUsed);
@@ -201,7 +201,7 @@
   /**
    * All-details constructor.
    */
-  public OfflineSorter(Comparator<BytesRef> comparator, BufferSize ramBufferSize, File tempDirectory, int maxTempfiles) {
+  public OfflineSorter(Comparator<BytesRef> comparator, BufferSize ramBufferSize, Path tempDirectory, int maxTempfiles) {
     if (ramBufferSize.bytes < ABSOLUTE_MIN_SORT_BUFFER_SIZE) {
       throw new IllegalArgumentException(MIN_BUFFER_SIZE_MSG + ": " + ramBufferSize.bytes);
     }
@@ -220,13 +220,13 @@
    * Sort input to output, explicit hint for the buffer size. The amount of allocated
    * memory may deviate from the hint (may be smaller or larger).  
    */
-  public SortInfo sort(File input, File output) throws IOException {
+  public SortInfo sort(Path input, Path output) throws IOException {
     sortInfo = new SortInfo();
     sortInfo.totalTime = System.currentTimeMillis();
 
-    Files.deleteIfExists(output.toPath());
+    Files.deleteIfExists(output);
 
-    ArrayList<File> merges = new ArrayList<>();
+    ArrayList<Path> merges = new ArrayList<>();
     boolean success3 = false;
     try {
       ByteSequencesReader is = new ByteSequencesReader(input);
@@ -240,7 +240,7 @@
 
           // Handle intermediate merges.
           if (merges.size() == maxTempFiles) {
-            File intermediate = File.createTempFile("sort", "intermediate", tempDirectory);
+            Path intermediate = Files.createTempFile(tempDirectory, "sort", "intermediate");
             boolean success2 = false;
             try {
               mergePartitions(merges, intermediate);
@@ -267,10 +267,12 @@
 
       // One partition, try to rename or copy if unsuccessful.
       if (merges.size() == 1) {     
-        File single = merges.get(0);
+        Path single = merges.get(0);
         // If simple rename doesn't work this means the output is
         // on a different volume or something. Copy the input then.
-        if (!single.renameTo(output)) {
+        try {
+          Files.move(single, output, StandardCopyOption.ATOMIC_MOVE);
+        } catch (IOException | UnsupportedOperationException e) {
           copy(single, output);
         }
       } else { 
@@ -295,7 +297,7 @@
    * Returns the default temporary directory. By default, java.io.tmpdir. If not accessible
    * or not available, an IOException is thrown
    */
-  public static File defaultTempDir() throws IOException {
+  public static Path defaultTempDir() throws IOException {
     String tempDirPath = System.getProperty("java.io.tmpdir");
     if (tempDirPath == null) 
       throw new IOException("Java has no temporary folder property (java.io.tmpdir)?");
@@ -305,20 +307,21 @@
       throw new IOException("Java's temporary folder not present or writeable?: " 
           + tempDirectory.getAbsolutePath());
     }
-    return tempDirectory;
+    return tempDirectory.toPath();
   }
 
   /**
    * Copies one file to another.
    */
-  private static void copy(File file, File output) throws IOException {
+  private static void copy(Path path, Path output) throws IOException {
+    // TODO: just use Files.copy?
     // 64kb copy buffer (empirical pick).
     byte [] buffer = new byte [16 * 1024];
     InputStream is = null;
     OutputStream os = null;
     try {
-      is = new FileInputStream(file);
-      os = new FileOutputStream(output);
+      is = Files.newInputStream(path);
+      os = Files.newOutputStream(output);
       int length;
       while ((length = is.read(buffer)) > 0) {
         os.write(buffer, 0, length);
@@ -329,9 +332,9 @@
   }
 
   /** Sort a single partition in-memory. */
-  protected File sortPartition(int len) throws IOException {
+  protected Path sortPartition(int len) throws IOException {
     BytesRefArray data = this.buffer;
-    File tempFile = File.createTempFile("sort", "partition", tempDirectory);
+    Path tempFile = Files.createTempFile(tempDirectory, "sort", "partition");
 
     long start = System.currentTimeMillis();
     sortInfo.sortTime += (System.currentTimeMillis() - start);
@@ -356,7 +359,7 @@
   }
 
   /** Merge a list of sorted temporary files (partitions) into an output file */
-  void mergePartitions(List<File> merges, File outputFile) throws IOException {
+  void mergePartitions(List<Path> merges, Path outputFile) throws IOException {
     long start = System.currentTimeMillis();
 
     ByteSequencesWriter out = new ByteSequencesWriter(outputFile);
@@ -441,11 +444,11 @@
   public static class ByteSequencesWriter implements Closeable {
     private final DataOutput os;
 
-    /** Constructs a ByteSequencesWriter to the provided File */
-    public ByteSequencesWriter(File file) throws IOException {
+    /** Constructs a ByteSequencesWriter to the provided Path */
+    public ByteSequencesWriter(Path path) throws IOException {
       this(new DataOutputStream(
           new BufferedOutputStream(
-              new FileOutputStream(file))));
+              Files.newOutputStream(path))));
     }
 
     /** Constructs a ByteSequencesWriter to the provided DataOutput */
@@ -505,11 +508,11 @@
   public static class ByteSequencesReader implements Closeable {
     private final DataInput is;
 
-    /** Constructs a ByteSequencesReader from the provided File */
-    public ByteSequencesReader(File file) throws IOException {
+    /** Constructs a ByteSequencesReader from the provided Path */
+    public ByteSequencesReader(Path path) throws IOException {
       this(new DataInputStream(
           new BufferedInputStream(
-              new FileInputStream(file))));
+              Files.newInputStream(path))));
     }
 
     /** Constructs a ByteSequencesReader from the provided DataInput */
Index: lucene/core/src/test/org/apache/lucene/index/TestAtomicUpdate.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestAtomicUpdate.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/index/TestAtomicUpdate.java	(working copy)
@@ -17,6 +17,7 @@
  */
 
 import java.io.File;
+import java.nio.file.Path;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.*;
@@ -174,7 +175,7 @@
     directory.close();
 
     // Second in an FSDirectory:
-    File dirPath = createTempDir("lucene.test.atomic");
+    Path dirPath = createTempDir("lucene.test.atomic");
     directory = newFSDirectory(dirPath);
     runTest(directory);
     directory.close();
Index: lucene/core/src/test/org/apache/lucene/index/TestCompoundFile.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestCompoundFile.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/index/TestCompoundFile.java	(working copy)
@@ -30,8 +30,8 @@
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
 
-import java.io.File;
 import java.io.IOException;
+import java.nio.file.Path;
 
 import static org.apache.lucene.store.TestHelper.isSimpleFSIndexInput;
 import static org.apache.lucene.store.TestHelper.isSimpleFSIndexInputOpen;
@@ -43,7 +43,7 @@
     @Override
     public void setUp() throws Exception {
        super.setUp();
-       File file = createTempDir("testIndex");
+       Path file = createTempDir("testIndex");
        // use a simple FSDir here, to be sure to have SimpleFSInputs
        dir = new SimpleFSDirectory(file,null);
     }
Index: lucene/core/src/test/org/apache/lucene/index/TestCrashCausesCorruptIndex.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestCrashCausesCorruptIndex.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/index/TestCrashCausesCorruptIndex.java	(working copy)
@@ -17,8 +17,8 @@
  * limitations under the License.
  */
 
-import java.io.File;
 import java.io.IOException;
+import java.nio.file.Path;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
@@ -35,7 +35,7 @@
 
 public class TestCrashCausesCorruptIndex extends LuceneTestCase  {
 
-  File path;
+  Path path;
     
   /**
    * LUCENE-3627: This test fails.
Index: lucene/core/src/test/org/apache/lucene/index/TestDirectoryReader.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestDirectoryReader.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/index/TestDirectoryReader.java	(working copy)
@@ -22,6 +22,7 @@
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.NoSuchFileException;
+import java.nio.file.Path;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -38,8 +39,8 @@
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.store.BaseDirectoryWrapper;
 import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.NoSuchDirectoryException;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IOUtils;
@@ -440,7 +441,7 @@
   
 public void testFilesOpenClose() throws IOException {
       // Create initial data set
-      File dirFile = createTempDir("TestIndexReader.testFilesOpenClose");
+      Path dirFile = createTempDir("TestIndexReader.testFilesOpenClose");
       Directory dir = newFSDirectory(dirFile);
       IndexWriter writer  = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())));
       addDoc(writer, "test");
@@ -470,8 +471,11 @@
   }
 
   public void testOpenReaderAfterDelete() throws IOException {
-    File dirFile = createTempDir("deletetest");
+    Path dirFile = createTempDir("deletetest");
     Directory dir = newFSDirectory(dirFile);
+    if (dir instanceof BaseDirectoryWrapper) {
+      ((BaseDirectoryWrapper)dir).setCheckIndexOnClose(false); // we will hit NoSuchFileException in MDW since we nuked it!
+    }
     try {
       DirectoryReader.open(dir);
       fail("expected FileNotFoundException/NoSuchFileException");
@@ -479,7 +483,7 @@
       // expected
     }
 
-    Files.delete(dirFile.toPath());
+    Files.delete(dirFile);
 
     // Make sure we still get a CorruptIndexException (not NPE):
     try {
@@ -717,13 +721,13 @@
   // DirectoryReader on a non-existent directory, you get a
   // good exception
   public void testNoDir() throws Throwable {
-    File tempDir = createTempDir("doesnotexist");
+    Path tempDir = createTempDir("doesnotexist");
     IOUtils.rm(tempDir);
     Directory dir = newFSDirectory(tempDir);
     try {
       DirectoryReader.open(dir);
       fail("did not hit expected exception");
-    } catch (NoSuchDirectoryException nsde) {
+    } catch (IndexNotFoundException nsde) {
       // expected
     }
     dir.close();
@@ -1053,8 +1057,8 @@
   }
 
   public void testIndexExistsOnNonExistentDirectory() throws Exception {
-    File tempDir = createTempDir("testIndexExistsOnNonExistentDirectory");
-    Files.delete(tempDir.toPath());
+    Path tempDir = createTempDir("testIndexExistsOnNonExistentDirectory");
+    Files.delete(tempDir);
     Directory dir = newFSDirectory(tempDir);
     assertFalse(DirectoryReader.indexExists(dir));
     dir.close();
Index: lucene/core/src/test/org/apache/lucene/index/TestDoc.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestDoc.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/index/TestDoc.java	(working copy)
@@ -16,9 +16,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
+
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.OutputStreamWriter;
@@ -27,6 +25,7 @@
 import java.io.Writer;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashSet;
@@ -50,9 +49,9 @@
 /** JUnit adaptation of an older test case DocTest. */
 public class TestDoc extends LuceneTestCase {
 
-    private File workDir;
-    private File indexDir;
-    private LinkedList<File> files;
+    private Path workDir;
+    private Path indexDir;
+    private LinkedList<Path> files;
 
     /** Set the test case. This test case needs
      *  a few text files created in the current working directory.
@@ -64,10 +63,7 @@
           System.out.println("TEST: setUp");
         }
         workDir = createTempDir("TestDoc");
-        workDir.mkdirs();
-
         indexDir = createTempDir("testIndex");
-        indexDir.mkdirs();
 
         Directory directory = newFSDirectory(indexDir);
         directory.close();
@@ -82,18 +78,18 @@
         ));
     }
 
-    private File createOutput(String name, String text) throws IOException {
+    private Path createOutput(String name, String text) throws IOException {
         Writer fw = null;
         PrintWriter pw = null;
 
         try {
-            File f = new File(workDir, name);
-            Files.deleteIfExists(f.toPath());
+            Path path = workDir.resolve(name);
+            Files.deleteIfExists(path);
 
-            fw = new OutputStreamWriter(new FileOutputStream(f), StandardCharsets.UTF_8);
+            fw = new OutputStreamWriter(Files.newOutputStream(path), StandardCharsets.UTF_8);
             pw = new PrintWriter(fw);
             pw.println(text);
-            return f;
+            return path;
 
         } finally {
             if (pw != null) pw.close();
@@ -203,9 +199,9 @@
    private SegmentCommitInfo indexDoc(IndexWriter writer, String fileName)
    throws Exception
    {
-      File file = new File(workDir, fileName);
+      Path path = workDir.resolve(fileName);
       Document doc = new Document();
-      InputStreamReader is = new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8);
+      InputStreamReader is = new InputStreamReader(Files.newInputStream(path), StandardCharsets.UTF_8);
       doc.add(new TextField("contents", is));
       writer.addDocument(doc);
       writer.commit();
Index: lucene/core/src/test/org/apache/lucene/index/TestFieldsReader.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestFieldsReader.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/index/TestFieldsReader.java	(working copy)
@@ -19,6 +19,7 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.nio.file.Path;
 import java.util.*;
 import java.util.concurrent.atomic.AtomicBoolean;
 
@@ -110,7 +111,7 @@
     Directory fsDir;
     AtomicBoolean doFail = new AtomicBoolean();
 
-    public FaultyFSDirectory(File dir) {
+    public FaultyFSDirectory(Path dir) {
       fsDir = newFSDirectory(dir);
       lockFactory = fsDir.getLockFactory();
     }
@@ -220,7 +221,7 @@
 
   // LUCENE-1262
   public void testExceptions() throws Throwable {
-    File indexDir = createTempDir("testfieldswriterexceptions");
+    Path indexDir = createTempDir("testfieldswriterexceptions");
 
     try {
       FaultyFSDirectory dir = new FaultyFSDirectory(indexDir);
Index: lucene/core/src/test/org/apache/lucene/index/TestIndexWriterOnJRECrash.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestIndexWriterOnJRECrash.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/index/TestIndexWriterOnJRECrash.java	(working copy)
@@ -18,7 +18,6 @@
  *
  */
 
-import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -25,8 +24,13 @@
 import java.io.PrintStream;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.SimpleFileVisitor;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.lucene.store.BaseDirectoryWrapper;
 import org.apache.lucene.util.Constants;
@@ -38,7 +42,7 @@
  * of execution, then runs checkindex to make sure its not corrupt.
  */
 public class TestIndexWriterOnJRECrash extends TestNRTThreads {
-  private File tempDir;
+  private Path tempDir;
   
   @Override
   public void setUp() throws Exception {
@@ -96,7 +100,7 @@
     cmd.add("-Dtests.crashmode=true");
     // passing NIGHTLY to this test makes it run for much longer, easier to catch it in the act...
     cmd.add("-Dtests.nightly=true");
-    cmd.add("-DtempDir=" + tempDir.getPath());
+    cmd.add("-DtempDir=" + tempDir);
     cmd.add("-Dtests.seed=" + SeedUtils.formatSeed(random().nextLong()));
     cmd.add("-ea");
     cmd.add("-cp");
@@ -104,7 +108,7 @@
     cmd.add("org.junit.runner.JUnitCore");
     cmd.add(getClass().getName());
     ProcessBuilder pb = new ProcessBuilder(cmd);
-    pb.directory(tempDir);
+    pb.directory(tempDir.toFile());
     pb.redirectErrorStream(true);
     Process p = pb.start();
 
@@ -147,30 +151,35 @@
    * Recursively looks for indexes underneath <code>file</code>,
    * and runs checkindex on them. returns true if it found any indexes.
    */
-  public boolean checkIndexes(File file) throws IOException {
-    if (file.isDirectory()) {
-      BaseDirectoryWrapper dir = newFSDirectory(file);
-      dir.setCheckIndexOnClose(false); // don't double-checkindex
-      if (DirectoryReader.indexExists(dir)) {
-        if (VERBOSE) {
-          System.err.println("Checking index: " + file);
+  public boolean checkIndexes(Path path) throws IOException {
+    final AtomicBoolean found = new AtomicBoolean();
+    Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
+      @Override
+      public FileVisitResult postVisitDirectory(Path dirPath, IOException exc) throws IOException {
+        if (exc != null) {
+          throw exc;
+        } else {
+          BaseDirectoryWrapper dir = newFSDirectory(dirPath);
+          dir.setCheckIndexOnClose(false); // don't double-checkindex
+          if (DirectoryReader.indexExists(dir)) {
+            if (VERBOSE) {
+              System.err.println("Checking index: " + dirPath);
+            }
+            // LUCENE-4738: if we crashed while writing first
+            // commit it's possible index will be corrupt (by
+            // design we don't try to be smart about this case
+            // since that too risky):
+            if (SegmentInfos.getLastCommitGeneration(dir) > 1) {
+              TestUtil.checkIndex(dir);
+            }
+            dir.close();
+            found.set(true);
+          }
+          return FileVisitResult.CONTINUE;
         }
-        // LUCENE-4738: if we crashed while writing first
-        // commit it's possible index will be corrupt (by
-        // design we don't try to be smart about this case
-        // since that too risky):
-        if (SegmentInfos.getLastCommitGeneration(dir) > 1) {
-          TestUtil.checkIndex(dir);
-        }
-        dir.close();
-        return true;
       }
-      dir.close();
-      for (File f : file.listFiles())
-        if (checkIndexes(f))
-          return true;
-    }
-    return false;
+    });
+    return found.get();
   }
 
   /**
Index: lucene/core/src/test/org/apache/lucene/index/TestNeverDelete.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestNeverDelete.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/index/TestNeverDelete.java	(working copy)
@@ -17,7 +17,7 @@
  * limitations under the License.
  */
 
-import java.io.File;
+import java.nio.file.Path;
 import java.util.HashSet;
 import java.util.Set;
 
@@ -36,7 +36,7 @@
 public class TestNeverDelete extends LuceneTestCase {
 
   public void testIndexing() throws Exception {
-    final File tmpDir = createTempDir("TestNeverDelete");
+    final Path tmpDir = createTempDir("TestNeverDelete");
     final BaseDirectoryWrapper d = newFSDirectory(tmpDir);
 
     // We want to "see" files removed if Lucene removed
Index: lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/store/TestBufferedIndexInput.java	(working copy)
@@ -17,10 +17,8 @@
  * limitations under the License.
  */
 
-import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.io.OutputStream;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
@@ -45,21 +43,6 @@
 
 public class TestBufferedIndexInput extends LuceneTestCase {
   
-  private static void writeBytes(File aFile, long size) throws IOException{
-    OutputStream stream = null;
-    try {
-      stream = new FileOutputStream(aFile);
-      for (int i = 0; i < size; i++) {
-        stream.write(byten(i));  
-      }
-      stream.flush();
-    } finally {
-      if (stream != null) {
-        stream.close();
-      }
-    }
-  }
-
   private static final long TEST_FILE_LENGTH = 100*1024;
  
   // Call readByte() repeatedly, past the buffer boundary, and see that it
@@ -228,7 +211,7 @@
     }
 
     public void testSetBufferSize() throws IOException {
-      File indexDir = createTempDir("testSetBufferSize");
+      Path indexDir = createTempDir("testSetBufferSize");
       MockFSDirectory dir = new MockFSDirectory(indexDir, random());
       try {
         IndexWriter writer = new IndexWriter(
@@ -292,7 +275,7 @@
 
       private Directory dir;
 
-      public MockFSDirectory(File path, Random rand) throws IOException {
+      public MockFSDirectory(Path path, Random rand) throws IOException {
         this.rand = rand;
         lockFactory = NoLockFactory.getNoLockFactory();
         dir = new SimpleFSDirectory(path, null);
Index: lucene/core/src/test/org/apache/lucene/store/TestDirectory.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/store/TestDirectory.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/store/TestDirectory.java	(working copy)
@@ -20,7 +20,9 @@
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.nio.file.Files;
 import java.nio.file.NoSuchFileException;
+import java.nio.file.Path;
 import java.util.Arrays;
 import java.util.Collections;
 
@@ -30,7 +32,7 @@
 public class TestDirectory extends BaseDirectoryTestCase {
 
   @Override
-  protected Directory getDirectory(File path) throws IOException {
+  protected Directory getDirectory(Path path) throws IOException {
     final Directory dir;
     if (random().nextBoolean()) {
       dir = newDirectory();
@@ -53,7 +55,7 @@
   // Test that different instances of FSDirectory can coexist on the same
   // path, can read, write, and lock files.
   public void testDirectInstantiation() throws Exception {
-    final File path = createTempDir("testDirectInstantiation");
+    final Path path = createTempDir("testDirectInstantiation");
     
     final byte[] largeBuffer = new byte[random().nextInt(256*1024)], largeReadBuffer = new byte[largeBuffer.length];
     for (int i = 0; i < largeBuffer.length; i++) {
@@ -141,10 +143,9 @@
 
   // LUCENE-1468
   public void testCopySubdir() throws Throwable {
-    File path = createTempDir("testsubdir");
+    Path path = createTempDir("testsubdir");
     try {
-      path.mkdirs();
-      new File(path, "subdir").mkdirs();
+      Files.createDirectory(path.resolve("subdir"));
       Directory fsDir = new SimpleFSDirectory(path, null);
       assertEquals(0, new RAMDirectory(fsDir, newIOContext(random())).listAll().length);
     } finally {
@@ -154,7 +155,7 @@
 
   // LUCENE-1468
   public void testNotDirectory() throws Throwable {
-    File path = createTempDir("testnotdir");
+    Path path = createTempDir("testnotdir");
     Directory fsDir = new SimpleFSDirectory(path, null);
     try {
       IndexOutput out = fsDir.createOutput("afile", newIOContext(random()));
@@ -161,9 +162,9 @@
       out.close();
       assertTrue(slowFileExists(fsDir, "afile"));
       try {
-        new SimpleFSDirectory(new File(path, "afile"), null);
+        new SimpleFSDirectory(path.resolve("afile"), null);
         fail("did not hit expected exception");
-      } catch (NoSuchDirectoryException nsde) {
+      } catch (IOException nsde) {
         // Expected
       }
     } finally {
Index: lucene/core/src/test/org/apache/lucene/store/TestFileSwitchDirectory.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/store/TestFileSwitchDirectory.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/store/TestFileSwitchDirectory.java	(working copy)
@@ -17,8 +17,9 @@
  * limitations under the License.
  */
 
-import java.io.File;
 import java.io.IOException;
+import java.nio.file.NoSuchFileException;
+import java.nio.file.Path;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
@@ -27,12 +28,12 @@
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.codecs.compressing.CompressingStoredFieldsWriter;
 import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexNotFoundException;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.TestIndexWriterReader;
 import org.apache.lucene.util.IOUtils;
-import org.apache.lucene.util.TestUtil;
 
 public class TestFileSwitchDirectory extends BaseDirectoryTestCase {
 
@@ -85,12 +86,12 @@
   }
   
   private Directory newFSSwitchDirectory(Set<String> primaryExtensions) throws IOException {
-    File primDir = createTempDir("foo");
-    File secondDir = createTempDir("bar");
+    Path primDir = createTempDir("foo");
+    Path secondDir = createTempDir("bar");
     return newFSSwitchDirectory(primDir, secondDir, primaryExtensions);
   }
 
-  private Directory newFSSwitchDirectory(File aDir, File bDir, Set<String> primaryExtensions) throws IOException {
+  private Directory newFSSwitchDirectory(Path aDir, Path bDir, Set<String> primaryExtensions) throws IOException {
     Directory a = new SimpleFSDirectory(aDir);
     Directory b = new SimpleFSDirectory(bDir);
     return new FileSwitchDirectory(primaryExtensions, a, b, true);
@@ -98,14 +99,14 @@
   
   // LUCENE-3380 -- make sure we get exception if the directory really does not exist.
   public void testNoDir() throws Throwable {
-    File primDir = createTempDir("foo");
-    File secondDir = createTempDir("bar");
+    Path primDir = createTempDir("foo");
+    Path secondDir = createTempDir("bar");
     IOUtils.rm(primDir, secondDir);
     Directory dir = newFSSwitchDirectory(primDir, secondDir, Collections.<String>emptySet());
     try {
       DirectoryReader.open(dir);
       fail("did not hit expected exception");
-    } catch (NoSuchDirectoryException nsde) {
+    } catch (IndexNotFoundException nsde) {
       // expected
     }
     dir.close();
@@ -112,7 +113,7 @@
   }
 
   @Override
-  protected Directory getDirectory(File path) throws IOException {
+  protected Directory getDirectory(Path path) throws IOException {
     Set<String> extensions = new HashSet<String>();
     if (random().nextBoolean()) {
       extensions.add("cfs");
Index: lucene/core/src/test/org/apache/lucene/store/TestLockFactory.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/store/TestLockFactory.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/store/TestLockFactory.java	(working copy)
@@ -17,9 +17,9 @@
  * limitations under the License.
  */
 
-import java.io.File;
 import java.io.IOException;
 import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
@@ -38,7 +38,6 @@
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.TestUtil;
 
 public class TestLockFactory extends LuceneTestCase {
 
@@ -126,11 +125,6 @@
             writer2.close();
         }
     }
-    
-    public void testSimpleFSLockFactory() throws IOException {
-      // test string file instantiation
-      new SimpleFSLockFactory("test");
-    }
 
     // Verify: do stress test, by opening IndexReaders and
     // IndexWriters over & over in 2 threads and making sure
@@ -146,11 +140,11 @@
     // NativeFSLockFactory:
     @Nightly
     public void testStressLocksNativeFSLockFactory() throws Exception {
-      File dir = createTempDir("index.TestLockFactory7");
+      Path dir = createTempDir("index.TestLockFactory7");
       _testStressLocks(new NativeFSLockFactory(dir), dir);
     }
 
-    public void _testStressLocks(LockFactory lockFactory, File indexDir) throws Exception {
+    public void _testStressLocks(LockFactory lockFactory, Path indexDir) throws Exception {
         Directory dir = newFSDirectory(indexDir, lockFactory);
 
         // First create a 1 doc index:
@@ -202,22 +196,22 @@
     
     // Verify: NativeFSLockFactory works correctly if the lock file exists
     public void testNativeFSLockFactoryLockExists() throws IOException {
-      File tempDir = createTempDir(LuceneTestCase.getTestClass().getSimpleName());
-      File lockFile = new File(tempDir, "test.lock");
-      lockFile.createNewFile();
+      Path tempDir = createTempDir(LuceneTestCase.getTestClass().getSimpleName());
+      Path lockFile = tempDir.resolve("test.lock");
+      Files.createFile(lockFile);
       
       Lock l = new NativeFSLockFactory(tempDir).makeLock("test.lock");
       assertTrue("failed to obtain lock", l.obtain());
       l.close();
       assertFalse("failed to release lock", l.isLocked());
-      Files.deleteIfExists(lockFile.toPath());
+      Files.deleteIfExists(lockFile);
     }
 
     // Verify: NativeFSLockFactory assigns null as lockPrefix if the lockDir is inside directory
     public void testNativeFSLockFactoryPrefix() throws IOException {
 
-      File fdir1 = createTempDir("TestLockFactory.8");
-      File fdir2 = createTempDir("TestLockFactory.8.Lockdir");
+      Path fdir1 = createTempDir("TestLockFactory.8");
+      Path fdir2 = createTempDir("TestLockFactory.8.Lockdir");
       Directory dir1 = newFSDirectory(fdir1, new NativeFSLockFactory(fdir1));
       // same directory, but locks are stored somewhere else. The prefix of the lock factory should != null
       Directory dir2 = newFSDirectory(fdir1, new NativeFSLockFactory(fdir2));
@@ -238,7 +232,7 @@
     public void testDefaultFSLockFactoryPrefix() throws IOException {
 
       // Make sure we get null prefix, which wont happen if setLockFactory is ever called.
-      File dirName = createTempDir("TestLockFactory.10");
+      Path dirName = createTempDir("TestLockFactory.10");
 
       Directory dir = new SimpleFSDirectory(dirName);
       assertNull("Default lock prefix should be null", dir.getLockFactory().getLockPrefix());
Index: lucene/core/src/test/org/apache/lucene/store/TestMmapDirectory.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/store/TestMmapDirectory.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/store/TestMmapDirectory.java	(working copy)
@@ -17,8 +17,8 @@
  * limitations under the License.
  */
 
-import java.io.File;
 import java.io.IOException;
+import java.nio.file.Path;
 
 /**
  * Tests MMapDirectory
@@ -26,7 +26,7 @@
 public class TestMmapDirectory extends BaseDirectoryTestCase {
 
   @Override
-  protected Directory getDirectory(File path) throws IOException {
+  protected Directory getDirectory(Path path) throws IOException {
     return new MMapDirectory(path);
   }
 }
Index: lucene/core/src/test/org/apache/lucene/store/TestMultiMMap.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/store/TestMultiMMap.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/store/TestMultiMMap.java	(working copy)
@@ -17,8 +17,8 @@
  * limitations under the License.
  */
 
-import java.io.File;
 import java.io.IOException;
+import java.nio.file.Path;
 import java.util.Random;
 
 import org.apache.lucene.analysis.MockAnalyzer;
@@ -37,10 +37,9 @@
  * Integer.MAX_VALUE in size using multiple byte buffers.
  */
 public class TestMultiMMap extends BaseDirectoryTestCase {
-  File workDir;
 
   @Override
-  protected Directory getDirectory(File path) throws IOException {
+  protected Directory getDirectory(Path path) throws IOException {
     return new MMapDirectory(path, null, 1<<TestUtil.nextInt(random(), 10, 28));
   }
   
@@ -335,7 +334,7 @@
   }
   
   private void assertChunking(Random random, int chunkSize) throws Exception {
-    File path = createTempDir("mmap" + chunkSize);
+    Path path = createTempDir("mmap" + chunkSize);
     MMapDirectory mmapDir = new MMapDirectory(path, null, chunkSize);
     // we will map a lot, try to turn on the unmap hack
     if (MMapDirectory.UNMAP_SUPPORTED)
Index: lucene/core/src/test/org/apache/lucene/store/TestNIOFSDirectory.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/store/TestNIOFSDirectory.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/store/TestNIOFSDirectory.java	(working copy)
@@ -17,8 +17,8 @@
  * limitations under the License.
  */
 
-import java.io.File;
 import java.io.IOException;
+import java.nio.file.Path;
 
 /**
  * Tests NIOFSDirectory
@@ -26,7 +26,7 @@
 public class TestNIOFSDirectory extends BaseDirectoryTestCase {
 
   @Override
-  protected Directory getDirectory(File path) throws IOException {
+  protected Directory getDirectory(Path path) throws IOException {
     return new NIOFSDirectory(path);
   }
 }
Index: lucene/core/src/test/org/apache/lucene/store/TestNRTCachingDirectory.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/store/TestNRTCachingDirectory.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/store/TestNRTCachingDirectory.java	(working copy)
@@ -17,8 +17,8 @@
  * limitations under the License.
  */
 
-import java.io.File;
 import java.io.IOException;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -43,7 +43,7 @@
   // for the threads tests... maybe because of the synchronization in listAll?
   // would be good to investigate further...
   @Override
-  protected Directory getDirectory(File path) throws IOException {
+  protected Directory getDirectory(Path path) throws IOException {
     return new NRTCachingDirectory(new RAMDirectory(),
                                    .1 + 2.0*random().nextDouble(),
                                    .1 + 5.0*random().nextDouble());
@@ -115,7 +115,7 @@
   public void verifyCompiles() throws Exception {
     Analyzer analyzer = null;
 
-    Directory fsDir = FSDirectory.open(new File("/path/to/index"));
+    Directory fsDir = FSDirectory.open(createTempDir("verify"));
     NRTCachingDirectory cachedFSDir = new NRTCachingDirectory(fsDir, 2.0, 25.0);
     IndexWriterConfig conf = new IndexWriterConfig(analyzer);
     IndexWriter writer = new IndexWriter(cachedFSDir, conf);
Index: lucene/core/src/test/org/apache/lucene/store/TestRAMDirectory.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/store/TestRAMDirectory.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/store/TestRAMDirectory.java	(working copy)
@@ -17,8 +17,9 @@
  * limitations under the License.
  */
 
-import java.io.File;
 import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
@@ -32,7 +33,6 @@
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.util.English;
 import org.apache.lucene.util.IOUtils;
-import org.apache.lucene.util.TestUtil;
 
 /**
  * JUnit testcase to test RAMDirectory. RAMDirectory itself is used in many testcases,
@@ -41,7 +41,7 @@
 public class TestRAMDirectory extends BaseDirectoryTestCase {
   
   @Override
-  protected Directory getDirectory(File path) {
+  protected Directory getDirectory(Path path) {
     return new RAMDirectory();
   }
   
@@ -48,8 +48,8 @@
   // add enough document so that the index will be larger than RAMDirectory.READ_BUFFER_SIZE
   private final int docsToAdd = 500;
 
-  private File buildIndex() throws IOException {
-    File path = createTempDir("buildIndex");
+  private Path buildIndex() throws IOException {
+    Path path = createTempDir("buildIndex");
     
     Directory dir = newFSDirectory(path);
     IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(
@@ -70,11 +70,10 @@
   
   // LUCENE-1468
   public void testCopySubdir() throws Throwable {
-    File path = createTempDir("testsubdir");
+    Path path = createTempDir("testsubdir");
     Directory fsDir = null;
     try {
-      path.mkdirs();
-      new File(path, "subdir").mkdirs();
+      Files.createDirectory(path.resolve("subdir"));
       fsDir = newFSDirectory(path);
       assertEquals(0, new RAMDirectory(fsDir, newIOContext(random())).listAll().length);
     } finally {
@@ -84,7 +83,7 @@
   }
 
   public void testRAMDirectory () throws IOException {
-    File indexDir = buildIndex();
+    Path indexDir = buildIndex();
     
     Directory dir = newFSDirectory(indexDir);
     MockDirectoryWrapper ramDir = new MockDirectoryWrapper(random(), new RAMDirectory(dir, newIOContext(random())));
@@ -117,7 +116,7 @@
   
   public void testRAMDirectorySize() throws IOException, InterruptedException {
 
-    File indexDir = buildIndex();
+    Path indexDir = buildIndex();
       
     Directory dir = newFSDirectory(indexDir);
     final MockDirectoryWrapper ramDir = new MockDirectoryWrapper(random(), new RAMDirectory(dir, newIOContext(random())));
Index: lucene/core/src/test/org/apache/lucene/store/TestRateLimitedDirectoryWrapper.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/store/TestRateLimitedDirectoryWrapper.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/store/TestRateLimitedDirectoryWrapper.java	(working copy)
@@ -17,12 +17,12 @@
  * limitations under the License.
  */
 
-import java.io.File;
+import java.nio.file.Path;
 
 public class TestRateLimitedDirectoryWrapper extends BaseDirectoryTestCase {
 
   @Override
-  protected Directory getDirectory(File path) {
+  protected Directory getDirectory(Path path) {
     Directory in = newFSDirectory(path);
     if (in instanceof MockDirectoryWrapper) {
       // test manipulates directory directly
Index: lucene/core/src/test/org/apache/lucene/store/TestSimpleFSDirectory.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/store/TestSimpleFSDirectory.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/store/TestSimpleFSDirectory.java	(working copy)
@@ -17,8 +17,8 @@
  * limitations under the License.
  */
 
-import java.io.File;
 import java.io.IOException;
+import java.nio.file.Path;
 
 /**
  * Tests SimpleFSDirectory
@@ -26,7 +26,7 @@
 public class TestSimpleFSDirectory extends BaseDirectoryTestCase {
 
   @Override
-  protected Directory getDirectory(File path) throws IOException {
+  protected Directory getDirectory(Path path) throws IOException {
     return new SimpleFSDirectory(path);
   }
 }
Index: lucene/core/src/test/org/apache/lucene/store/TestWindowsMMap.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/store/TestWindowsMMap.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/store/TestWindowsMMap.java	(working copy)
@@ -17,7 +17,7 @@
  * limitations under the License.
  */
 
-import java.io.File;
+import java.nio.file.Path;
 
 import org.apache.lucene.document.Field;
 import org.apache.lucene.util.LuceneTestCase;
@@ -64,7 +64,7 @@
     // sometimes the directory is not cleaned by rmDir, because on Windows it
     // may take some time until the files are finally dereferenced. So clean the
     // directory up front, or otherwise new IndexWriter will fail.
-    File dirPath = createTempDir("testLuceneMmap");
+    Path dirPath = createTempDir("testLuceneMmap");
     MMapDirectory dir = new MMapDirectory(dirPath, null);
     
     // plan to add a set of useful stopwords, consider changing some of the
Index: lucene/core/src/test/org/apache/lucene/util/TestOfflineSorter.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/util/TestOfflineSorter.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/util/TestOfflineSorter.java	(working copy)
@@ -18,10 +18,10 @@
  */
 
 import java.io.DataInputStream;
-import java.io.File;
-import java.io.FileInputStream;
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Comparator;
@@ -32,13 +32,12 @@
 import org.apache.lucene.util.OfflineSorter.BufferSize;
 import org.apache.lucene.util.OfflineSorter.ByteSequencesWriter;
 import org.apache.lucene.util.OfflineSorter.SortInfo;
-import org.apache.lucene.util.TestUtil;
 
 /**
  * Tests for on-disk merge sorting.
  */
 public class TestOfflineSorter extends LuceneTestCase {
-  private File tempDir;
+  private Path tempDir;
 
   @Override
   public void setUp() throws Exception {
@@ -112,12 +111,12 @@
    * Check sorting data on an instance of {@link OfflineSorter}.
    */
   private SortInfo checkSort(OfflineSorter sort, byte[][] data) throws IOException {
-    File unsorted = writeAll("unsorted", data);
+    Path unsorted = writeAll("unsorted", data);
 
     Arrays.sort(data, unsignedByteOrderComparator);
-    File golden = writeAll("golden", data);
+    Path golden = writeAll("golden", data);
 
-    File sorted = new File(tempDir, "sorted");
+    Path sorted = tempDir.resolve("sorted");
     SortInfo sortInfo = sort.sort(unsorted, sorted);
     //System.out.println("Input size [MB]: " + unsorted.length() / (1024 * 1024));
     //System.out.println(sortInfo);
@@ -129,14 +128,14 @@
   /**
    * Make sure two files are byte-byte identical.
    */
-  private void assertFilesIdentical(File golden, File sorted) throws IOException {
-    assertEquals(golden.length(), sorted.length());
+  private void assertFilesIdentical(Path golden, Path sorted) throws IOException {
+    assertEquals(Files.size(golden), Files.size(sorted));
 
     byte [] buf1 = new byte [64 * 1024];
     byte [] buf2 = new byte [64 * 1024];
     int len;
-    DataInputStream is1 = new DataInputStream(new FileInputStream(golden));
-    DataInputStream is2 = new DataInputStream(new FileInputStream(sorted));
+    DataInputStream is1 = new DataInputStream(Files.newInputStream(golden));
+    DataInputStream is2 = new DataInputStream(Files.newInputStream(sorted));
     while ((len = is1.read(buf1)) > 0) {
       is2.readFully(buf2, 0, len);
       for (int i = 0; i < len; i++) {
@@ -146,8 +145,8 @@
     IOUtils.close(is1, is2);
   }
 
-  private File writeAll(String name, byte[][] data) throws IOException {
-    File file = new File(tempDir, name);
+  private Path writeAll(String name, byte[][] data) throws IOException {
+    Path file = tempDir.resolve(name);
     ByteSequencesWriter w = new OfflineSorter.ByteSequencesWriter(file);
     for (byte [] datum : data) {
       w.write(datum);
Index: lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/util/fst/TestFSTs.java	(working copy)
@@ -18,15 +18,13 @@
  */
 
 import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
 import java.io.StringWriter;
 import java.io.Writer;
 import java.nio.charset.StandardCharsets;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -313,7 +311,7 @@
     analyzer.setMaxTokenLength(TestUtil.nextInt(random(), 1, IndexWriter.MAX_TERM_LENGTH));
 
     final IndexWriterConfig conf = newIndexWriterConfig(analyzer).setMaxBufferedDocs(-1).setRAMBufferSizeMB(64);
-    final File tempDir = createTempDir("fstlines");
+    final Path tempDir = createTempDir("fstlines");
     final Directory dir = newFSDirectory(tempDir);
     final IndexWriter writer = new IndexWriter(dir, conf);
     final long stopTime = System.currentTimeMillis() + RUN_TIME_MSEC;
@@ -458,14 +456,14 @@
   }
 
   private static abstract class VisitTerms<T> {
-    private final String dirOut;
-    private final String wordsFileIn;
+    private final Path dirOut;
+    private final Path wordsFileIn;
     private int inputMode;
     private final Outputs<T> outputs;
     private final Builder<T> builder;
     private final boolean doPack;
 
-    public VisitTerms(String dirOut, String wordsFileIn, int inputMode, int prune, Outputs<T> outputs, boolean doPack, boolean noArcArrays) {
+    public VisitTerms(Path dirOut, Path wordsFileIn, int inputMode, int prune, Outputs<T> outputs, boolean doPack, boolean noArcArrays) {
       this.dirOut = dirOut;
       this.wordsFileIn = wordsFileIn;
       this.inputMode = inputMode;
@@ -478,7 +476,8 @@
     protected abstract T getOutput(IntsRef input, int ord) throws IOException;
 
     public void run(int limit, boolean verify, boolean verifyByOutput) throws IOException {
-      BufferedReader is = new BufferedReader(new InputStreamReader(new FileInputStream(wordsFileIn), StandardCharsets.UTF_8), 65536);
+      
+      BufferedReader is = Files.newBufferedReader(wordsFileIn, StandardCharsets.UTF_8);
       try {
         final IntsRefBuilder intsRef = new IntsRefBuilder();
         long tStart = System.currentTimeMillis();
@@ -521,13 +520,13 @@
 
         System.out.println(ord + " terms; " + fst.getNodeCount() + " nodes; " + fst.getArcCount() + " arcs; " + fst.getArcWithOutputCount() + " arcs w/ output; tot size " + fst.ramBytesUsed());
         if (fst.getNodeCount() < 100) {
-          Writer w = new OutputStreamWriter(new FileOutputStream("out.dot"), StandardCharsets.UTF_8);
+          Writer w = Files.newBufferedWriter(FileSystems.getDefault().getPath("out.dot"), StandardCharsets.UTF_8);
           Util.toDot(fst, w, false, false);
           w.close();
           System.out.println("Wrote FST to out.dot");
         }
 
-        Directory dir = FSDirectory.open(new File(dirOut));
+        Directory dir = FSDirectory.open(dirOut);
         IndexOutput out = dir.createOutput("fst.bin", IOContext.DEFAULT);
         fst.save(out);
         out.close();
@@ -548,7 +547,7 @@
         while(true) {
           for(int iter=0;iter<2;iter++) {
             is.close();
-            is = new BufferedReader(new InputStreamReader(new FileInputStream(wordsFileIn), StandardCharsets.UTF_8), 65536);
+            is = Files.newBufferedReader(wordsFileIn, StandardCharsets.UTF_8);
 
             ord = 0;
             tStart = System.currentTimeMillis();
@@ -622,8 +621,8 @@
     boolean verify = true;
     boolean doPack = false;
     boolean noArcArrays = false;
-    String wordsFileIn = null;
-    String dirOut = null;
+    Path wordsFileIn = null;
+    Path dirOut = null;
 
     int idx = 0;
     while (idx < args.length) {
@@ -652,9 +651,9 @@
         System.exit(-1);
       } else {
         if (wordsFileIn == null) {
-          wordsFileIn = args[idx];
+          wordsFileIn = FileSystems.getDefault().getPath(args[idx]);
         } else if (dirOut == null) {
-          dirOut = args[idx];
+          dirOut = FileSystems.getDefault().getPath(args[idx]);
         } else {
           System.err.println("Too many arguments, expected: input [output]");
           System.exit(-1);
Index: lucene/core/src/test/org/apache/lucene/util/junitcompat/TestLeaveFilesIfTestFails.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/util/junitcompat/TestLeaveFilesIfTestFails.java	(revision 1624571)
+++ lucene/core/src/test/org/apache/lucene/util/junitcompat/TestLeaveFilesIfTestFails.java	(working copy)
@@ -17,15 +17,15 @@
  * limitations under the License.
  */
 
-import java.io.File;
 import java.io.IOException;
-import java.io.RandomAccessFile;
+import java.nio.channels.SeekableByteChannel;
 import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.StandardOpenOption;
 
 import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.TestUtil;
 import org.junit.Assert;
 import org.junit.Test;
 import org.junit.runner.JUnitCore;
@@ -39,7 +39,7 @@
   }
   
   public static class Nested1 extends WithNestedTests.AbstractNestedTest {
-    static File file;
+    static Path file;
     public void testDummy() {
       file = createTempDir("leftover");
       fail();
@@ -50,19 +50,19 @@
   public void testLeaveFilesIfTestFails() throws IOException {
     Result r = JUnitCore.runClasses(Nested1.class);
     Assert.assertEquals(1, r.getFailureCount());
-    Assert.assertTrue(Nested1.file != null && Nested1.file.exists());
-    Files.delete(Nested1.file.toPath());
+    Assert.assertTrue(Nested1.file != null && Files.exists(Nested1.file));
+    Files.delete(Nested1.file);
   }
   
   public static class Nested2 extends WithNestedTests.AbstractNestedTest {
-    static File file;
-    static File parent;
-    static RandomAccessFile openFile;
+    static Path file;
+    static Path parent;
+    static SeekableByteChannel openFile;
 
     @SuppressWarnings("deprecation")
     public void testDummy() throws Exception {
-      file = new File(createTempDir("leftover"), "child.locked");
-      openFile = new RandomAccessFile(file, "rw");
+      file = createTempDir("leftover").resolve("child.locked");
+      openFile = Files.newByteChannel(file, StandardOpenOption.READ, StandardOpenOption.WRITE, StandardOpenOption.CREATE);
 
       parent = LuceneTestCase.getBaseTempDirForTestClass();
     }
Index: lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java
===================================================================
--- lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java	(revision 1624571)
+++ lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java	(working copy)
@@ -18,9 +18,9 @@
  */
 
 import java.io.Closeable;
-import java.io.File;
 import java.io.IOException;
 import java.io.StringReader;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
@@ -222,7 +222,7 @@
 
   /** Subclass can override to choose a specific {@link
    *  Directory} implementation. */
-  protected Directory getDirectory(File path) throws IOException {
+  protected Directory getDirectory(Path path) throws IOException {
     return FSDirectory.open(path);
   }
 
Index: lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FreeTextSuggester.java
===================================================================
--- lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FreeTextSuggester.java	(revision 1624571)
+++ lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FreeTextSuggester.java	(working copy)
@@ -68,6 +68,7 @@
 import java.io.File;
 import java.io.IOException;
 import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -292,7 +293,7 @@
     }
 
     String prefix = getClass().getSimpleName();
-    File tempIndexPath = Files.createTempDirectory(prefix + ".index.").toFile();
+    Path tempIndexPath = Files.createTempDirectory(prefix + ".index.");
 
     Directory dir = FSDirectory.open(tempIndexPath);
 
Index: lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java	(revision 1624571)
+++ lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java	(working copy)
@@ -19,6 +19,7 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -1335,7 +1336,7 @@
   /** Indexes all fields/terms at the specified
    *  IndexOptions, and fully tests at that IndexOptions. */
   private void testFull(IndexOptions options, boolean withPayloads) throws Exception {
-    File path = createTempDir("testPostingsFormat.testExact");
+    Path path = createTempDir("testPostingsFormat.testExact");
     Directory dir = newFSDirectory(path);
 
     // TODO test thread safety of buildIndex too
@@ -1388,7 +1389,7 @@
     int iters = 5;
 
     for(int iter=0;iter<iters;iter++) {
-      File path = createTempDir("testPostingsFormat");
+      Path path = createTempDir("testPostingsFormat");
       Directory dir = newFSDirectory(path);
 
       boolean indexPayloads = random().nextBoolean();
Index: lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java	(revision 1624571)
+++ lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase.java	(working copy)
@@ -19,6 +19,7 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.nio.file.Path;
 import java.util.*;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
@@ -436,7 +437,7 @@
 
     Random random = new Random(random().nextLong());
     final LineFileDocs docs = new LineFileDocs(random, true);
-    final File tempDir = createTempDir(testName);
+    final Path tempDir = createTempDir(testName);
     dir = getDirectory(newMockFSDirectory(tempDir)); // some subclasses rely on this being MDW
     if (dir instanceof BaseDirectoryWrapper) {
       ((BaseDirectoryWrapper) dir).setCheckIndexOnClose(false); // don't double-checkIndex, we do it ourselves.
Index: lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase.java	(revision 1624571)
+++ lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase.java	(working copy)
@@ -23,6 +23,7 @@
 import java.io.IOException;
 import java.nio.file.Files;
 import java.nio.file.NoSuchFileException;
+import java.nio.file.Path;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
@@ -42,7 +43,7 @@
   /** Subclass returns the Directory to be tested; if it's
    *  an FS-based directory it should point to the specified
    *  path, else it can ignore it. */
-  protected abstract Directory getDirectory(File path) throws IOException;
+  protected abstract Directory getDirectory(Path path) throws IOException;
   
   // first some basic tests for the directory api
   
@@ -473,17 +474,6 @@
     dir.close();
   }
 
-  /** LUCENE-1464: just creating a Directory should not
-   *  mkdir the underling directory in the filesystem. */
-  public void testDontCreate() throws Throwable {
-    File path = createTempDir("doesnotexist");
-    IOUtils.rm(path);
-    assertTrue(!path.exists());
-    Directory dir = getDirectory(path);
-    assertTrue(!path.exists());
-    dir.close();
-  }
-
   /** LUCENE-1468: once we create an output, we should see
    *  it in the dir listing and be able to open it with
    *  openInput. */
@@ -582,13 +572,13 @@
   
   // LUCENE-3382 -- make sure we get exception if the directory really does not exist.
   public void testNoDir() throws Throwable {
-    File tempDir = createTempDir("doesnotexist");
+    Path tempDir = createTempDir("doesnotexist");
     IOUtils.rm(tempDir);
     Directory dir = getDirectory(tempDir);
     try {
       DirectoryReader.open(dir);
       fail("did not hit expected exception");
-    } catch (NoSuchDirectoryException | IndexNotFoundException nsde) {
+    } catch (NoSuchFileException | IndexNotFoundException nsde) {
       // expected
     }
     dir.close();
@@ -774,7 +764,7 @@
   // this test backdoors the directory via the filesystem. so it must actually use the filesystem
   // TODO: somehow change this test to 
   public void testFsyncDoesntCreateNewFiles() throws Exception {
-    File path = createTempDir("nocreate");
+    Path path = createTempDir("nocreate");
     Directory fsdir = getDirectory(path);
     
     // this test backdoors the directory via the filesystem. so it must be an FSDir (for now)
@@ -791,7 +781,7 @@
     out.close();
     
     // delete it
-    Files.delete(new File(path, "afile").toPath());
+    Files.delete(path.resolve("afile"));
     
     // directory is empty
     assertEquals(0, fsdir.listAll().length);
Index: lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(revision 1624571)
+++ lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(working copy)
@@ -31,7 +31,9 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.nio.file.FileSystems;
 import java.nio.file.NoSuchFileException;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -1170,7 +1172,7 @@
     return (MockDirectoryWrapper) wrapDirectory(r, newDirectoryImpl(r, TEST_DIRECTORY), false);
   }
 
-  public static MockDirectoryWrapper newMockFSDirectory(File f) {
+  public static MockDirectoryWrapper newMockFSDirectory(Path f) {
     return (MockDirectoryWrapper) newFSDirectory(f, null, false);
   }
 
@@ -1184,16 +1186,16 @@
   }
 
   /** Returns a new FSDirectory instance over the given file, which must be a folder. */
-  public static BaseDirectoryWrapper newFSDirectory(File f) {
+  public static BaseDirectoryWrapper newFSDirectory(Path f) {
     return newFSDirectory(f, null);
   }
 
   /** Returns a new FSDirectory instance over the given file, which must be a folder. */
-  public static BaseDirectoryWrapper newFSDirectory(File f, LockFactory lf) {
+  public static BaseDirectoryWrapper newFSDirectory(Path f, LockFactory lf) {
     return newFSDirectory(f, lf, rarely());
   }
 
-  private static BaseDirectoryWrapper newFSDirectory(File f, LockFactory lf, boolean bare) {
+  private static BaseDirectoryWrapper newFSDirectory(Path f, LockFactory lf, boolean bare) {
     String fsdirClass = TEST_DIRECTORY;
     if (fsdirClass.equals("random")) {
       fsdirClass = RandomPicks.randomFrom(random(), FS_DIRECTORIES); 
@@ -1408,12 +1410,10 @@
     }
   }
 
-  private static Directory newFSDirectoryImpl(
-      Class<? extends FSDirectory> clazz, File file)
-      throws IOException {
+  private static Directory newFSDirectoryImpl(Class<? extends FSDirectory> clazz, Path path) throws IOException {
     FSDirectory d = null;
     try {
-      d = CommandLineUtil.newFSDirectory(clazz, file);
+      d = CommandLineUtil.newFSDirectory(clazz, path);
     } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {
       Rethrow.rethrow(e);
     }
@@ -1433,21 +1433,21 @@
       final Class<? extends Directory> clazz = CommandLineUtil.loadDirectoryClass(clazzName);
       // If it is a FSDirectory type, try its ctor(File)
       if (FSDirectory.class.isAssignableFrom(clazz)) {
-        final File dir = createTempDir("index-" + clazzName);
+        final Path dir = createTempDir("index-" + clazzName);
         return newFSDirectoryImpl(clazz.asSubclass(FSDirectory.class), dir);
       }
 
-      // See if it has a File ctor even though it's not an
+      // See if it has a Path ctor even though it's not an
       // FSDir subclass:
       Constructor<? extends Directory> fileCtor = null;
       try {
-        fileCtor = clazz.getConstructor(File.class);
+        fileCtor = clazz.getConstructor(Path.class);
       } catch (NoSuchMethodException nsme) {
         // Ignore
       }
 
       if (fileCtor != null) {
-        final File dir = createTempDir("index");
+        final Path dir = createTempDir("index");
         return fileCtor.newInstance(dir);
       }
 
@@ -1662,13 +1662,13 @@
   }
 
   /**
-   * Gets a resource from the classpath as {@link File}. This method should only
+   * Gets a resource from the classpath as {@link Path}. This method should only
    * be used, if a real file is needed. To get a stream, code should prefer
    * {@link Class#getResourceAsStream} using {@code this.getClass()}.
    */
-  protected File getDataFile(String name) throws IOException {
+  protected Path getDataPath(String name) throws IOException {
     try {
-      return new File(this.getClass().getResource(name).toURI());
+      return new File(this.getClass().getResource(name).toURI()).toPath();
     } catch (Exception e) {
       throw new IOException("Cannot find resource: " + name);
     }
@@ -2364,8 +2364,8 @@
    * or {@link #createTempDir(String)} or {@link #createTempFile(String, String)}.
    */
   @Deprecated
-  public static File getBaseTempDirForTestClass() {
-    return tempFilesCleanupRule.getPerTestClassTempDir();
+  public static Path getBaseTempDirForTestClass() {
+    return tempFilesCleanupRule.getPerTestClassTempDir().toPath();
   }
 
 
@@ -2374,7 +2374,7 @@
    * 
    * @see #createTempDir(String)
    */
-  public static File createTempDir() {
+  public static Path createTempDir() {
     return createTempDir("tempDir");
   }
 
@@ -2386,7 +2386,7 @@
    * test class completes successfully. The test should close any file handles that would prevent
    * the folder from being removed. 
    */
-  public static File createTempDir(String prefix) {
+  public static Path createTempDir(String prefix) {
     return tempFilesCleanupRule.createTempDir(prefix);
   }
   
@@ -2398,7 +2398,7 @@
    * test class completes successfully. The test should close any file handles that would prevent
    * the folder from being removed. 
    */
-  public static File createTempFile(String prefix, String suffix) throws IOException {
+  public static Path createTempFile(String prefix, String suffix) throws IOException {
     return tempFilesCleanupRule.createTempFile(prefix, suffix);
   }
 
@@ -2407,7 +2407,7 @@
    * 
    * @see #createTempFile(String, String) 
    */
-  public static File createTempFile() throws IOException {
+  public static Path createTempFile() throws IOException {
     return createTempFile("tempFile", ".tmp");
   }
 }
Index: lucene/test-framework/src/java/org/apache/lucene/util/RemoveUponClose.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/RemoveUponClose.java	(revision 1624571)
+++ lucene/test-framework/src/java/org/apache/lucene/util/RemoveUponClose.java	(working copy)
@@ -1,8 +1,9 @@
 package org.apache.lucene.util;
 
 import java.io.Closeable;
-import java.io.File;
 import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -25,12 +26,12 @@
  * A {@link Closeable} that attempts to remove a given file/folder.
  */
 final class RemoveUponClose implements Closeable {
-  private final File file;
+  private final Path path;
   private final TestRuleMarkFailure failureMarker;
   private final String creationStack;
 
-  public RemoveUponClose(File file, TestRuleMarkFailure failureMarker) {
-    this.file = file;
+  public RemoveUponClose(Path path, TestRuleMarkFailure failureMarker) {
+    this.path = path;
     this.failureMarker = failureMarker;
 
     StringBuilder b = new StringBuilder();
@@ -44,13 +45,13 @@
   public void close() throws IOException {
     // only if there were no other test failures.
     if (failureMarker.wasSuccessful()) {
-      if (file.exists()) {
+      if (Files.exists(path)) {
         try {
-          IOUtils.rm(file);
+          IOUtils.rm(path);
         } catch (IOException e) {
           throw new IOException(
               "Could not remove temporary location '" 
-                  + file.getAbsolutePath() + "', created at stack trace:\n" + creationStack, e);
+                  + path.toAbsolutePath() + "', created at stack trace:\n" + creationStack, e);
         }
       }
     }
Index: lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup.java	(revision 1624571)
+++ lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup.java	(working copy)
@@ -2,6 +2,7 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.nio.file.Path;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -61,7 +62,7 @@
    * suite completes.
    * @see #registerToRemoveAfterSuite(File)
    */
-  private final static List<File> cleanupQueue = new ArrayList<File>();
+  private final static List<Path> cleanupQueue = new ArrayList<Path>();
 
   public TestRuleTemporaryFilesCleanup(TestRuleMarkFailure failureMarker) {
     this.failureMarker = failureMarker;
@@ -79,7 +80,7 @@
     }
 
     synchronized (cleanupQueue) {
-      cleanupQueue.add(f);
+      cleanupQueue.add(f.toPath());
     }
   }
 
@@ -105,7 +106,7 @@
   @Override
   protected void afterAlways(List<Throwable> errors) throws Throwable {
     // Drain cleanup queue and clear it.
-    final File [] everything;
+    final Path [] everything;
     final String tempDirBasePath;
     synchronized (cleanupQueue) {
       tempDirBasePath = (tempDirBase != null ? tempDirBase.getAbsolutePath() : null);
@@ -112,7 +113,7 @@
       tempDirBase = null;
 
       Collections.reverse(cleanupQueue);
-      everything = new File [cleanupQueue.size()];
+      everything = new Path [cleanupQueue.size()];
       cleanupQueue.toArray(everything);
       cleanupQueue.clear();
     }
@@ -169,7 +170,7 @@
   /**
    * @see LuceneTestCase#createTempDir()
    */
-  public File createTempDir(String prefix) {
+  public Path createTempDir(String prefix) {
     File base = getPerTestClassTempDir();
 
     int attempt = 0;
@@ -184,13 +185,13 @@
     } while (!f.mkdirs());
 
     registerToRemoveAfterSuite(f);
-    return f;
+    return f.toPath();
   }
 
   /**
    * @see LuceneTestCase#createTempFile()
    */
-  public File createTempFile(String prefix, String suffix) throws IOException {
+  public Path createTempFile(String prefix, String suffix) throws IOException {
     File base = getPerTestClassTempDir();
 
     int attempt = 0;
@@ -205,6 +206,6 @@
     } while (!f.createNewFile());
 
     registerToRemoveAfterSuite(f);
-    return f;
+    return f.toPath();
   }
 }
Index: lucene/test-framework/src/java/org/apache/lucene/util/TestUtil.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/TestUtil.java	(revision 1624571)
+++ lucene/test-framework/src/java/org/apache/lucene/util/TestUtil.java	(working copy)
@@ -17,10 +17,7 @@
  * limitations under the License.
  */
 
-import java.io.BufferedOutputStream;
 import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -29,10 +26,10 @@
 import java.math.BigInteger;
 import java.nio.CharBuffer;
 import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.Arrays;
 import java.util.Enumeration;
 import java.util.HashMap;
-import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
@@ -104,11 +101,11 @@
    * Convenience method unzipping zipName into destDir, cleaning up 
    * destDir first. 
    */
-  public static void unzip(File zipName, File destDir) throws IOException {
+  public static void unzip(Path zipName, Path destDir) throws IOException {
     IOUtils.rm(destDir);
-    destDir.mkdir();
+    Files.createDirectory(destDir);
 
-    ZipFile zipFile = new ZipFile(zipName);
+    ZipFile zipFile = new ZipFile(zipName.toFile());
     Enumeration<? extends ZipEntry> entries = zipFile.entries();
 
     while (entries.hasMoreElements()) {
@@ -115,17 +112,13 @@
       ZipEntry entry = entries.nextElement();
       
       InputStream in = zipFile.getInputStream(entry);
-      File targetFile = new File(destDir, entry.getName());
-      if (entry.isDirectory()) {
-        // allow unzipping with directory structure
-        targetFile.mkdirs();
-      } else {
-        if (targetFile.getParentFile()!=null) {
-          // be on the safe side: do not rely on that directories are always extracted
-          // before their children (although this makes sense, but is it guaranteed?)
-          targetFile.getParentFile().mkdirs();   
-        }
-        OutputStream out = new BufferedOutputStream(new FileOutputStream(targetFile));
+      Path targetFile = destDir.resolve(entry.getName());
+      
+      // be on the safe side: do not rely on that directories are always extracted
+      // before their children (although this makes sense, but is it guaranteed?)
+      Files.createDirectories(targetFile.getParent());
+      if (!entry.isDirectory()) {
+        OutputStream out = Files.newOutputStream(targetFile);
         
         byte[] buffer = new byte[8192];
         int len;
