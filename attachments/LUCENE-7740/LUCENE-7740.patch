diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/DoubleRangeField.java b/lucene/core/src/java/org/apache/lucene/document/DoubleRange.java
similarity index 88%
rename from lucene/sandbox/src/java/org/apache/lucene/document/DoubleRangeField.java
rename to lucene/core/src/java/org/apache/lucene/document/DoubleRange.java
index c5ae0e7..90a8eb9 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/DoubleRangeField.java
+++ b/lucene/core/src/java/org/apache/lucene/document/DoubleRange.java
@@ -39,18 +39,18 @@ import org.apache.lucene.util.NumericUtils;
  *   <li>{@link #newContainsQuery newContainsQuery()} matches ranges that contain the defined search range.
  * </ul>
  */
-public class DoubleRangeField extends Field {
+public class DoubleRange extends Field {
   /** stores double values so number of bytes is 8 */
   public static final int BYTES = Double.BYTES;
 
   /**
-   * Create a new DoubleRangeField type, from min/max parallel arrays
+   * Create a new DoubleRange type, from min/max parallel arrays
    *
    * @param name field name. must not be null.
    * @param min range min values; each entry is the min value for the dimension
    * @param max range max values; each entry is the max value for the dimension
    */
-  public DoubleRangeField(String name, final double[] min, final double[] max) {
+  public DoubleRange(String name, final double[] min, final double[] max) {
     super(name, getType(min.length));
     setRangeValues(min, max);
   }
@@ -58,7 +58,7 @@ public class DoubleRangeField extends Field {
   /** set the field type */
   private static FieldType getType(int dimensions) {
     if (dimensions > 4) {
-      throw new IllegalArgumentException("DoubleRangeField does not support greater than 4 dimensions");
+      throw new IllegalArgumentException("DoubleRange does not support greater than 4 dimensions");
     }
 
     FieldType ft = new FieldType();
@@ -100,7 +100,7 @@ public class DoubleRangeField extends Field {
       throw new IllegalArgumentException("min/max ranges must agree");
     }
     if (min.length > 4) {
-      throw new IllegalArgumentException("DoubleRangeField does not support greater than 4 dimensions");
+      throw new IllegalArgumentException("DoubleRange does not support greater than 4 dimensions");
     }
   }
 
@@ -123,10 +123,10 @@ public class DoubleRangeField extends Field {
   static void verifyAndEncode(double[] min, double[] max, byte[] bytes) {
     for (int d=0,i=0,j=min.length*BYTES; d<min.length; ++d, i+=BYTES, j+=BYTES) {
       if (Double.isNaN(min[d])) {
-        throw new IllegalArgumentException("invalid min value (" + Double.NaN + ")" + " in DoubleRangeField");
+        throw new IllegalArgumentException("invalid min value (" + Double.NaN + ")" + " in DoubleRange");
       }
       if (Double.isNaN(max[d])) {
-        throw new IllegalArgumentException("invalid max value (" + Double.NaN + ")" + " in DoubleRangeField");
+        throw new IllegalArgumentException("invalid max value (" + Double.NaN + ")" + " in DoubleRange");
       }
       if (min[d] > max[d]) {
         throw new IllegalArgumentException("min value (" + min[d] + ") is greater than max value (" + max[d] + ")");
@@ -188,12 +188,7 @@ public class DoubleRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newIntersectsQuery(String field, final double[] min, final double[] max) {
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.INTERSECTS) {
-      @Override
-      protected String toString(byte[] ranges, int dimension) {
-        return DoubleRangeField.toString(ranges, dimension);
-      }
-    };
+    return newRelationQuery(field, min, max, QueryType.INTERSECTS);
   }
 
   /**
@@ -205,12 +200,7 @@ public class DoubleRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newContainsQuery(String field, final double[] min, final double[] max) {
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.CONTAINS) {
-      @Override
-      protected String toString(byte[] ranges, int dimension) {
-        return DoubleRangeField.toString(ranges, dimension);
-      }
-    };
+    return newRelationQuery(field, min, max, QueryType.CONTAINS);
   }
 
   /**
@@ -222,13 +212,7 @@ public class DoubleRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newWithinQuery(String field, final double[] min, final double[] max) {
-    checkArgs(min, max);
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.WITHIN) {
-      @Override
-      protected String toString(byte[] ranges, int dimension) {
-        return DoubleRangeField.toString(ranges, dimension);
-      }
-    };
+    return newRelationQuery(field, min, max, QueryType.WITHIN);
   }
 
   /**
@@ -242,11 +226,16 @@ public class DoubleRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newCrossesQuery(String field, final double[] min, final double[] max) {
+    return newRelationQuery(field, min, max, QueryType.CROSSES);
+  }
+
+  /** helper method for creating the desired relational query */
+  private static Query newRelationQuery(String field, final double[] min, final double[] max, QueryType relation) {
     checkArgs(min, max);
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.CROSSES) {
+    return new RangeFieldQuery(field, encode(min, max), min.length, relation) {
       @Override
       protected String toString(byte[] ranges, int dimension) {
-        return DoubleRangeField.toString(ranges, dimension);
+        return DoubleRange.toString(ranges, dimension);
       }
     };
   }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/FloatRangeField.java b/lucene/core/src/java/org/apache/lucene/document/FloatRange.java
similarity index 88%
rename from lucene/sandbox/src/java/org/apache/lucene/document/FloatRangeField.java
rename to lucene/core/src/java/org/apache/lucene/document/FloatRange.java
index 60e0acf..8b40538 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/FloatRangeField.java
+++ b/lucene/core/src/java/org/apache/lucene/document/FloatRange.java
@@ -39,18 +39,18 @@ import org.apache.lucene.util.NumericUtils;
  *   <li>{@link #newContainsQuery newContainsQuery()} matches ranges that contain the defined search range.
  * </ul>
  */
-public class FloatRangeField extends Field {
+public class FloatRange extends Field {
   /** stores float values so number of bytes is 4 */
   public static final int BYTES = Float.BYTES;
 
   /**
-   * Create a new FloatRangeField type, from min/max parallel arrays
+   * Create a new FloatRange type, from min/max parallel arrays
    *
    * @param name field name. must not be null.
    * @param min range min values; each entry is the min value for the dimension
    * @param max range max values; each entry is the max value for the dimension
    */
-  public FloatRangeField(String name, final float[] min, final float[] max) {
+  public FloatRange(String name, final float[] min, final float[] max) {
     super(name, getType(min.length));
     setRangeValues(min, max);
   }
@@ -58,7 +58,7 @@ public class FloatRangeField extends Field {
   /** set the field type */
   private static FieldType getType(int dimensions) {
     if (dimensions > 4) {
-      throw new IllegalArgumentException("FloatRangeField does not support greater than 4 dimensions");
+      throw new IllegalArgumentException("FloatRange does not support greater than 4 dimensions");
     }
 
     FieldType ft = new FieldType();
@@ -100,7 +100,7 @@ public class FloatRangeField extends Field {
       throw new IllegalArgumentException("min/max ranges must agree");
     }
     if (min.length > 4) {
-      throw new IllegalArgumentException("FloatRangeField does not support greater than 4 dimensions");
+      throw new IllegalArgumentException("FloatRange does not support greater than 4 dimensions");
     }
   }
 
@@ -123,10 +123,10 @@ public class FloatRangeField extends Field {
   static void verifyAndEncode(float[] min, float[] max, byte[] bytes) {
     for (int d=0,i=0,j=min.length*BYTES; d<min.length; ++d, i+=BYTES, j+=BYTES) {
       if (Double.isNaN(min[d])) {
-        throw new IllegalArgumentException("invalid min value (" + Float.NaN + ")" + " in FloatRangeField");
+        throw new IllegalArgumentException("invalid min value (" + Float.NaN + ")" + " in FloatRange");
       }
       if (Double.isNaN(max[d])) {
-        throw new IllegalArgumentException("invalid max value (" + Float.NaN + ")" + " in FloatRangeField");
+        throw new IllegalArgumentException("invalid max value (" + Float.NaN + ")" + " in FloatRange");
       }
       if (min[d] > max[d]) {
         throw new IllegalArgumentException("min value (" + min[d] + ") is greater than max value (" + max[d] + ")");
@@ -188,12 +188,7 @@ public class FloatRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newIntersectsQuery(String field, final float[] min, final float[] max) {
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.INTERSECTS) {
-      @Override
-      protected String toString(byte[] ranges, int dimension) {
-        return FloatRangeField.toString(ranges, dimension);
-      }
-    };
+    return newRelationQuery(field, min, max, QueryType.INTERSECTS);
   }
 
   /**
@@ -205,12 +200,7 @@ public class FloatRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newContainsQuery(String field, final float[] min, final float[] max) {
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.CONTAINS) {
-      @Override
-      protected String toString(byte[] ranges, int dimension) {
-        return FloatRangeField.toString(ranges, dimension);
-      }
-    };
+    return newRelationQuery(field, min, max, QueryType.CONTAINS);
   }
 
   /**
@@ -222,13 +212,7 @@ public class FloatRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newWithinQuery(String field, final float[] min, final float[] max) {
-    checkArgs(min, max);
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.WITHIN) {
-      @Override
-      protected String toString(byte[] ranges, int dimension) {
-        return FloatRangeField.toString(ranges, dimension);
-      }
-    };
+    return newRelationQuery(field, min, max, QueryType.WITHIN);
   }
 
   /**
@@ -242,11 +226,16 @@ public class FloatRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newCrossesQuery(String field, final float[] min, final float[] max) {
+    return newRelationQuery(field, min, max, QueryType.CROSSES);
+  }
+
+  /** helper method for creating the desired relational query */
+  private static Query newRelationQuery(String field, final float[] min, final float[] max, QueryType relation) {
     checkArgs(min, max);
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.CROSSES) {
+    return new RangeFieldQuery(field, encode(min, max), min.length, relation) {
       @Override
       protected String toString(byte[] ranges, int dimension) {
-        return FloatRangeField.toString(ranges, dimension);
+        return FloatRange.toString(ranges, dimension);
       }
     };
   }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/IntRangeField.java b/lucene/core/src/java/org/apache/lucene/document/IntRange.java
similarity index 90%
rename from lucene/sandbox/src/java/org/apache/lucene/document/IntRangeField.java
rename to lucene/core/src/java/org/apache/lucene/document/IntRange.java
index 53a3311..2618f14 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/IntRangeField.java
+++ b/lucene/core/src/java/org/apache/lucene/document/IntRange.java
@@ -39,18 +39,18 @@ import org.apache.lucene.util.NumericUtils;
  *   <li>{@link #newContainsQuery newContainsQuery()} matches ranges that contain the defined search range.
  * </ul>
  */
-public class IntRangeField extends Field {
+public class IntRange extends Field {
   /** stores integer values so number of bytes is 4 */
   public static final int BYTES = Integer.BYTES;
 
   /**
-   * Create a new IntRangeField type, from min/max parallel arrays
+   * Create a new IntRange type, from min/max parallel arrays
    *
    * @param name field name. must not be null.
    * @param min range min values; each entry is the min value for the dimension
    * @param max range max values; each entry is the max value for the dimension
    */
-  public IntRangeField(String name, final int[] min, final int[] max) {
+  public IntRange(String name, final int[] min, final int[] max) {
     super(name, getType(min.length));
     setRangeValues(min, max);
   }
@@ -58,7 +58,7 @@ public class IntRangeField extends Field {
   /** set the field type */
   private static FieldType getType(int dimensions) {
     if (dimensions > 4) {
-      throw new IllegalArgumentException("IntRangeField does not support greater than 4 dimensions");
+      throw new IllegalArgumentException("IntRange does not support greater than 4 dimensions");
     }
 
     FieldType ft = new FieldType();
@@ -100,7 +100,7 @@ public class IntRangeField extends Field {
       throw new IllegalArgumentException("min/max ranges must agree");
     }
     if (min.length > 4) {
-      throw new IllegalArgumentException("IntRangeField does not support greater than 4 dimensions");
+      throw new IllegalArgumentException("IntRange does not support greater than 4 dimensions");
     }
   }
 
@@ -123,10 +123,10 @@ public class IntRangeField extends Field {
   static void verifyAndEncode(int[] min, int[] max, byte[] bytes) {
     for (int d=0,i=0,j=min.length*BYTES; d<min.length; ++d, i+=BYTES, j+=BYTES) {
       if (Double.isNaN(min[d])) {
-        throw new IllegalArgumentException("invalid min value (" + Double.NaN + ")" + " in IntRangeField");
+        throw new IllegalArgumentException("invalid min value (" + Double.NaN + ")" + " in IntRange");
       }
       if (Double.isNaN(max[d])) {
-        throw new IllegalArgumentException("invalid max value (" + Double.NaN + ")" + " in IntRangeField");
+        throw new IllegalArgumentException("invalid max value (" + Double.NaN + ")" + " in IntRange");
       }
       if (min[d] > max[d]) {
         throw new IllegalArgumentException("min value (" + min[d] + ") is greater than max value (" + max[d] + ")");
@@ -191,7 +191,7 @@ public class IntRangeField extends Field {
     return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.INTERSECTS) {
       @Override
       protected String toString(byte[] ranges, int dimension) {
-        return IntRangeField.toString(ranges, dimension);
+        return IntRange.toString(ranges, dimension);
       }
     };
   }
@@ -205,12 +205,7 @@ public class IntRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newContainsQuery(String field, final int[] min, final int[] max) {
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.CONTAINS) {
-      @Override
-      protected String toString(byte[] ranges, int dimension) {
-        return IntRangeField.toString(ranges, dimension);
-      }
-    };
+    return newRelationQuery(field, min, max, QueryType.CONTAINS);
   }
 
   /**
@@ -222,13 +217,7 @@ public class IntRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newWithinQuery(String field, final int[] min, final int[] max) {
-    checkArgs(min, max);
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.WITHIN) {
-      @Override
-      protected String toString(byte[] ranges, int dimension) {
-        return IntRangeField.toString(ranges, dimension);
-      }
-    };
+    return newRelationQuery(field, min, max, QueryType.WITHIN);
   }
 
   /**
@@ -242,11 +231,16 @@ public class IntRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newCrossesQuery(String field, final int[] min, final int[] max) {
+    return newRelationQuery(field, min, max, QueryType.CROSSES);
+  }
+
+  /** helper method for creating the desired relational query */
+  private static Query newRelationQuery(String field, final int[] min, final int[] max, QueryType relation) {
     checkArgs(min, max);
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.CROSSES) {
+    return new RangeFieldQuery(field, encode(min, max), min.length, relation) {
       @Override
       protected String toString(byte[] ranges, int dimension) {
-        return IntRangeField.toString(ranges, dimension);
+        return IntRange.toString(ranges, dimension);
       }
     };
   }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LongRangeField.java b/lucene/core/src/java/org/apache/lucene/document/LongRange.java
similarity index 88%
rename from lucene/sandbox/src/java/org/apache/lucene/document/LongRangeField.java
rename to lucene/core/src/java/org/apache/lucene/document/LongRange.java
index 7addaf5..009f4a1 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LongRangeField.java
+++ b/lucene/core/src/java/org/apache/lucene/document/LongRange.java
@@ -39,18 +39,18 @@ import org.apache.lucene.util.NumericUtils;
  *   <li>{@link #newContainsQuery newContainsQuery()} matches ranges that contain the defined search range.
  * </ul>
  */
-public class LongRangeField extends Field {
+public class LongRange extends Field {
   /** stores long values so number of bytes is 8 */
   public static final int BYTES = Long.BYTES;
 
   /**
-   * Create a new LongRangeField type, from min/max parallel arrays
+   * Create a new LongRange type, from min/max parallel arrays
    *
    * @param name field name. must not be null.
    * @param min range min values; each entry is the min value for the dimension
    * @param max range max values; each entry is the max value for the dimension
    */
-  public LongRangeField(String name, final long[] min, final long[] max) {
+  public LongRange(String name, final long[] min, final long[] max) {
     super(name, getType(min.length));
     setRangeValues(min, max);
   }
@@ -58,7 +58,7 @@ public class LongRangeField extends Field {
   /** set the field type */
   private static FieldType getType(int dimensions) {
     if (dimensions > 4) {
-      throw new IllegalArgumentException("LongRangeField does not support greater than 4 dimensions");
+      throw new IllegalArgumentException("LongRange does not support greater than 4 dimensions");
     }
 
     FieldType ft = new FieldType();
@@ -100,7 +100,7 @@ public class LongRangeField extends Field {
       throw new IllegalArgumentException("min/max ranges must agree");
     }
     if (min.length > 4) {
-      throw new IllegalArgumentException("LongRangeField does not support greater than 4 dimensions");
+      throw new IllegalArgumentException("LongRange does not support greater than 4 dimensions");
     }
   }
 
@@ -121,10 +121,10 @@ public class LongRangeField extends Field {
   static void verifyAndEncode(long[] min, long[] max, byte[] bytes) {
     for (int d=0,i=0,j=min.length*BYTES; d<min.length; ++d, i+=BYTES, j+=BYTES) {
       if (Double.isNaN(min[d])) {
-        throw new IllegalArgumentException("invalid min value (" + Double.NaN + ")" + " in IntRangeField");
+        throw new IllegalArgumentException("invalid min value (" + Double.NaN + ")" + " in LongRange");
       }
       if (Double.isNaN(max[d])) {
-        throw new IllegalArgumentException("invalid max value (" + Double.NaN + ")" + " in IntRangeField");
+        throw new IllegalArgumentException("invalid max value (" + Double.NaN + ")" + " in LongRange");
       }
       if (min[d] > max[d]) {
         throw new IllegalArgumentException("min value (" + min[d] + ") is greater than max value (" + max[d] + ")");
@@ -186,12 +186,7 @@ public class LongRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newIntersectsQuery(String field, final long[] min, final long[] max) {
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.INTERSECTS) {
-      @Override
-      protected String toString(byte[] ranges, int dimension) {
-        return LongRangeField.toString(ranges, dimension);
-      }
-    };
+    return newRelationQuery(field, min, max, QueryType.INTERSECTS);
   }
 
   /**
@@ -203,12 +198,7 @@ public class LongRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newContainsQuery(String field, final long[] min, final long[] max) {
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.CONTAINS) {
-      @Override
-      protected String toString(byte[] ranges, int dimension) {
-        return LongRangeField.toString(ranges, dimension);
-      }
-    };
+    return newRelationQuery(field, min, max, QueryType.CONTAINS);
   }
 
   /**
@@ -220,13 +210,7 @@ public class LongRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newWithinQuery(String field, final long[] min, final long[] max) {
-    checkArgs(min, max);
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.WITHIN) {
-      @Override
-      protected String toString(byte[] ranges, int dimension) {
-        return LongRangeField.toString(ranges, dimension);
-      }
-    };
+    return newRelationQuery(field, min, max, QueryType.WITHIN);
   }
 
   /**
@@ -240,11 +224,16 @@ public class LongRangeField extends Field {
    * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid
    */
   public static Query newCrossesQuery(String field, final long[] min, final long[] max) {
+    return newRelationQuery(field, min, max, QueryType.CROSSES);
+  }
+
+  /** helper method for creating the desired relational query */
+  private static Query newRelationQuery(String field, final long[] min, final long[] max, QueryType relation) {
     checkArgs(min, max);
-    return new RangeFieldQuery(field, encode(min, max), min.length, QueryType.CROSSES) {
+    return new RangeFieldQuery(field, encode(min, max), min.length, relation) {
       @Override
       protected String toString(byte[] ranges, int dimension) {
-        return LongRangeField.toString(ranges, dimension);
+        return LongRange.toString(ranges, dimension);
       }
     };
   }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery.java b/lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery.java
similarity index 100%
rename from lucene/sandbox/src/java/org/apache/lucene/document/RangeFieldQuery.java
rename to lucene/core/src/java/org/apache/lucene/document/RangeFieldQuery.java
diff --git a/lucene/core/src/java/org/apache/lucene/index/PointValues.java b/lucene/core/src/java/org/apache/lucene/index/PointValues.java
index dab9140..186dbd5 100644
--- a/lucene/core/src/java/org/apache/lucene/index/PointValues.java
+++ b/lucene/core/src/java/org/apache/lucene/index/PointValues.java
@@ -46,7 +46,7 @@ import org.apache.lucene.util.bkd.BKDWriter;
  *   <tr><td>{@code double}</td><td>{@link DoublePoint}</td></tr>
  *   <tr><td>{@code byte[]}</td><td>{@link BinaryPoint}</td></tr>
  *   <tr><td>{@link BigInteger}</td><td><a href="{@docRoot}/../sandbox/org/apache/lucene/document/BigIntegerPoint.html">BigIntegerPoint</a>*</td></tr>
- *   <tr><td>{@link InetAddress}</td><td><a href="{@docRoot}/../sandbox/org/apache/lucene/document/InetAddressPoint.html">InetAddressPoint</a>*</td></tr>
+ *   <tr><td>{@link InetAddress}</td><td><a href="{@docRoot}/../misc/org/apache/lucene/document/InetAddressPoint.html">InetAddressPoint</a>*</td></tr>
  * </table>
  * * in the <i>lucene-sandbox</i> jar<br>
  * <p>
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/TestDoubleRangeFieldQueries.java b/lucene/core/src/test/org/apache/lucene/search/TestDoubleRangeFieldQueries.java
similarity index 72%
rename from lucene/sandbox/src/test/org/apache/lucene/search/TestDoubleRangeFieldQueries.java
rename to lucene/core/src/test/org/apache/lucene/search/TestDoubleRangeFieldQueries.java
index 43630e3..49ca710 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/search/TestDoubleRangeFieldQueries.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestDoubleRangeFieldQueries.java
@@ -19,7 +19,7 @@ package org.apache.lucene.search;
 import java.util.Arrays;
 
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.DoubleRangeField;
+import org.apache.lucene.document.DoubleRange;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.store.Directory;
@@ -39,7 +39,7 @@ public class TestDoubleRangeFieldQueries extends BaseRangeFieldQueryTestCase {
   }
 
   @Override
-  protected Range nextRange(int dimensions) {
+  protected Range nextRange(int dimensions) throws Exception {
     double[] min = new double[dimensions];
     double[] max = new double[dimensions];
 
@@ -50,32 +50,32 @@ public class TestDoubleRangeFieldQueries extends BaseRangeFieldQueryTestCase {
       min[d] = Math.min(minV, maxV);
       max[d] = Math.max(minV, maxV);
     }
-    return new DoubleRange(min, max);
+    return new DoubleTestRange(min, max);
   }
 
   @Override
-  protected DoubleRangeField newRangeField(Range r) {
-    return new DoubleRangeField(FIELD_NAME, ((DoubleRange)r).min, ((DoubleRange)r).max);
+  protected DoubleRange newRangeField(Range r) {
+    return new DoubleRange(FIELD_NAME, ((DoubleTestRange)r).min, ((DoubleTestRange)r).max);
   }
 
   @Override
   protected Query newIntersectsQuery(Range r) {
-    return DoubleRangeField.newIntersectsQuery(FIELD_NAME, ((DoubleRange)r).min, ((DoubleRange)r).max);
+    return DoubleRange.newIntersectsQuery(FIELD_NAME, ((DoubleTestRange)r).min, ((DoubleTestRange)r).max);
   }
 
   @Override
   protected Query newContainsQuery(Range r) {
-    return DoubleRangeField.newContainsQuery(FIELD_NAME, ((DoubleRange)r).min, ((DoubleRange)r).max);
+    return DoubleRange.newContainsQuery(FIELD_NAME, ((DoubleTestRange)r).min, ((DoubleTestRange)r).max);
   }
 
   @Override
   protected Query newWithinQuery(Range r) {
-    return DoubleRangeField.newWithinQuery(FIELD_NAME, ((DoubleRange)r).min, ((DoubleRange)r).max);
+    return DoubleRange.newWithinQuery(FIELD_NAME, ((DoubleTestRange)r).min, ((DoubleTestRange)r).max);
   }
 
   @Override
   protected Query newCrossesQuery(Range r) {
-    return DoubleRangeField.newCrossesQuery(FIELD_NAME, ((DoubleRange)r).min, ((DoubleRange)r).max);
+    return DoubleRange.newCrossesQuery(FIELD_NAME, ((DoubleTestRange)r).min, ((DoubleTestRange)r).max);
   }
 
   /** Basic test */
@@ -85,54 +85,54 @@ public class TestDoubleRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     // intersects (within)
     Document document = new Document();
-    document.add(new DoubleRangeField(FIELD_NAME, new double[] {-10.0, -10.0}, new double[] {9.1, 10.1}));
+    document.add(new DoubleRange(FIELD_NAME, new double[] {-10.0, -10.0}, new double[] {9.1, 10.1}));
     writer.addDocument(document);
 
     // intersects (crosses)
     document = new Document();
-    document.add(new DoubleRangeField(FIELD_NAME, new double[] {10.0, -10.0}, new double[] {20.0, 10.0}));
+    document.add(new DoubleRange(FIELD_NAME, new double[] {10.0, -10.0}, new double[] {20.0, 10.0}));
     writer.addDocument(document);
 
     // intersects (contains, crosses)
     document = new Document();
-    document.add(new DoubleRangeField(FIELD_NAME, new double[] {-20.0, -20.0}, new double[] {30.0, 30.1}));
+    document.add(new DoubleRange(FIELD_NAME, new double[] {-20.0, -20.0}, new double[] {30.0, 30.1}));
     writer.addDocument(document);
 
     // intersects (crosses)
     document = new Document();
-    document.add(new DoubleRangeField(FIELD_NAME, new double[] {-11.1, -11.2}, new double[] {1.23, 11.5}));
+    document.add(new DoubleRange(FIELD_NAME, new double[] {-11.1, -11.2}, new double[] {1.23, 11.5}));
     writer.addDocument(document);
 
     // intersects (crosses)
     document = new Document();
-    document.add(new DoubleRangeField(FIELD_NAME, new double[] {12.33, 1.2}, new double[] {15.1, 29.9}));
+    document.add(new DoubleRange(FIELD_NAME, new double[] {12.33, 1.2}, new double[] {15.1, 29.9}));
     writer.addDocument(document);
 
     // disjoint
     document = new Document();
-    document.add(new DoubleRangeField(FIELD_NAME, new double[] {-122.33, 1.2}, new double[] {-115.1, 29.9}));
+    document.add(new DoubleRange(FIELD_NAME, new double[] {-122.33, 1.2}, new double[] {-115.1, 29.9}));
     writer.addDocument(document);
 
     // intersects (crosses)
     document = new Document();
-    document.add(new DoubleRangeField(FIELD_NAME, new double[] {Double.NEGATIVE_INFINITY, 1.2}, new double[] {-11.0, 29.9}));
+    document.add(new DoubleRange(FIELD_NAME, new double[] {Double.NEGATIVE_INFINITY, 1.2}, new double[] {-11.0, 29.9}));
     writer.addDocument(document);
 
     // equal (within, contains, intersects)
     document = new Document();
-    document.add(new DoubleRangeField(FIELD_NAME, new double[] {-11, -15}, new double[] {15, 20}));
+    document.add(new DoubleRange(FIELD_NAME, new double[] {-11, -15}, new double[] {15, 20}));
     writer.addDocument(document);
 
     // search
     IndexReader reader = writer.getReader();
     IndexSearcher searcher = newSearcher(reader);
-    assertEquals(7, searcher.count(DoubleRangeField.newIntersectsQuery(FIELD_NAME,
+    assertEquals(7, searcher.count(DoubleRange.newIntersectsQuery(FIELD_NAME,
         new double[] {-11.0, -15.0}, new double[] {15.0, 20.0})));
-    assertEquals(2, searcher.count(DoubleRangeField.newWithinQuery(FIELD_NAME,
+    assertEquals(2, searcher.count(DoubleRange.newWithinQuery(FIELD_NAME,
         new double[] {-11.0, -15.0}, new double[] {15.0, 20.0})));
-    assertEquals(2, searcher.count(DoubleRangeField.newContainsQuery(FIELD_NAME,
+    assertEquals(2, searcher.count(DoubleRange.newContainsQuery(FIELD_NAME,
         new double[] {-11.0, -15.0}, new double[] {15.0, 20.0})));
-    assertEquals(5, searcher.count(DoubleRangeField.newCrossesQuery(FIELD_NAME,
+    assertEquals(5, searcher.count(DoubleRange.newCrossesQuery(FIELD_NAME,
         new double[] {-11.0, -15.0}, new double[] {15.0, 20.0})));
 
     reader.close();
@@ -140,12 +140,12 @@ public class TestDoubleRangeFieldQueries extends BaseRangeFieldQueryTestCase {
     dir.close();
   }
 
-  /** DoubleRange test class implementation - use to validate DoubleRangeField */
-  private class DoubleRange extends Range {
+  /** DoubleRange test class implementation - use to validate DoubleRange */
+  private class DoubleTestRange extends Range {
     double[] min;
     double[] max;
 
-    DoubleRange(double[] min, double[] max) {
+    DoubleTestRange(double[] min, double[] max) {
       assert min != null && max != null && min.length > 0 && max.length > 0
           : "test box: min/max cannot be null or empty";
       assert min.length == max.length : "test box: min/max length do not agree";
@@ -190,13 +190,13 @@ public class TestDoubleRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     @Override
     protected boolean isEqual(Range other) {
-      DoubleRange o = (DoubleRange)other;
+      DoubleTestRange o = (DoubleTestRange)other;
       return Arrays.equals(min, o.min) && Arrays.equals(max, o.max);
     }
 
     @Override
     protected boolean isDisjoint(Range o) {
-      DoubleRange other = (DoubleRange)o;
+      DoubleTestRange other = (DoubleTestRange)o;
       for (int d=0; d<this.min.length; ++d) {
         if (this.min[d] > other.max[d] || this.max[d] < other.min[d]) {
           // disjoint:
@@ -208,7 +208,7 @@ public class TestDoubleRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     @Override
     protected boolean isWithin(Range o) {
-      DoubleRange other = (DoubleRange)o;
+      DoubleTestRange other = (DoubleTestRange)o;
       for (int d=0; d<this.min.length; ++d) {
         if ((this.min[d] >= other.min[d] && this.max[d] <= other.max[d]) == false) {
           // not within:
@@ -220,7 +220,7 @@ public class TestDoubleRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     @Override
     protected boolean contains(Range o) {
-      DoubleRange other = (DoubleRange) o;
+      DoubleTestRange other = (DoubleTestRange) o;
       for (int d=0; d<this.min.length; ++d) {
         if ((this.min[d] <= other.min[d] && this.max[d] >= other.max[d]) == false) {
           // not contains:
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/TestFloatRangeFieldQueries.java b/lucene/core/src/test/org/apache/lucene/search/TestFloatRangeFieldQueries.java
similarity index 72%
rename from lucene/sandbox/src/test/org/apache/lucene/search/TestFloatRangeFieldQueries.java
rename to lucene/core/src/test/org/apache/lucene/search/TestFloatRangeFieldQueries.java
index 3509e35..6dc5907 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/search/TestFloatRangeFieldQueries.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestFloatRangeFieldQueries.java
@@ -19,13 +19,13 @@ package org.apache.lucene.search;
 import java.util.Arrays;
 
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.FloatRangeField;
+import org.apache.lucene.document.FloatRange;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.store.Directory;
 
 /**
- * Random testing for FloatRangeField Queries.
+ * Random testing for FloatRange Queries.
  */
 public class TestFloatRangeFieldQueries extends BaseRangeFieldQueryTestCase {
   private static final String FIELD_NAME = "floatRangeField";
@@ -39,7 +39,7 @@ public class TestFloatRangeFieldQueries extends BaseRangeFieldQueryTestCase {
   }
 
   @Override
-  protected Range nextRange(int dimensions) {
+  protected Range nextRange(int dimensions) throws Exception {
     float[] min = new float[dimensions];
     float[] max = new float[dimensions];
 
@@ -50,32 +50,32 @@ public class TestFloatRangeFieldQueries extends BaseRangeFieldQueryTestCase {
       min[d] = Math.min(minV, maxV);
       max[d] = Math.max(minV, maxV);
     }
-    return new FloatRange(min, max);
+    return new FloatTestRange(min, max);
   }
 
   @Override
-  protected FloatRangeField newRangeField(Range r) {
-    return new FloatRangeField(FIELD_NAME, ((FloatRange)r).min, ((FloatRange)r).max);
+  protected FloatRange newRangeField(Range r) {
+    return new FloatRange(FIELD_NAME, ((FloatTestRange)r).min, ((FloatTestRange)r).max);
   }
 
   @Override
   protected Query newIntersectsQuery(Range r) {
-    return FloatRangeField.newIntersectsQuery(FIELD_NAME, ((FloatRange)r).min, ((FloatRange)r).max);
+    return FloatRange.newIntersectsQuery(FIELD_NAME, ((FloatTestRange)r).min, ((FloatTestRange)r).max);
   }
 
   @Override
   protected Query newContainsQuery(Range r) {
-    return FloatRangeField.newContainsQuery(FIELD_NAME, ((FloatRange)r).min, ((FloatRange)r).max);
+    return FloatRange.newContainsQuery(FIELD_NAME, ((FloatTestRange)r).min, ((FloatTestRange)r).max);
   }
 
   @Override
   protected Query newWithinQuery(Range r) {
-    return FloatRangeField.newWithinQuery(FIELD_NAME, ((FloatRange)r).min, ((FloatRange)r).max);
+    return FloatRange.newWithinQuery(FIELD_NAME, ((FloatTestRange)r).min, ((FloatTestRange)r).max);
   }
 
   @Override
   protected Query newCrossesQuery(Range r) {
-    return FloatRangeField.newCrossesQuery(FIELD_NAME, ((FloatRange)r).min, ((FloatRange)r).max);
+    return FloatRange.newCrossesQuery(FIELD_NAME, ((FloatTestRange)r).min, ((FloatTestRange)r).max);
   }
 
   /** Basic test */
@@ -85,54 +85,54 @@ public class TestFloatRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     // intersects (within)
     Document document = new Document();
-    document.add(new FloatRangeField(FIELD_NAME, new float[] {-10.0f, -10.0f}, new float[] {9.1f, 10.1f}));
+    document.add(new FloatRange(FIELD_NAME, new float[] {-10.0f, -10.0f}, new float[] {9.1f, 10.1f}));
     writer.addDocument(document);
 
     // intersects (crosses)
     document = new Document();
-    document.add(new FloatRangeField(FIELD_NAME, new float[] {10.0f, -10.0f}, new float[] {20.0f, 10.0f}));
+    document.add(new FloatRange(FIELD_NAME, new float[] {10.0f, -10.0f}, new float[] {20.0f, 10.0f}));
     writer.addDocument(document);
 
     // intersects (contains, crosses)
     document = new Document();
-    document.add(new FloatRangeField(FIELD_NAME, new float[] {-20.0f, -20.0f}, new float[] {30.0f, 30.1f}));
+    document.add(new FloatRange(FIELD_NAME, new float[] {-20.0f, -20.0f}, new float[] {30.0f, 30.1f}));
     writer.addDocument(document);
 
     // intersects (crosses)
     document = new Document();
-    document.add(new FloatRangeField(FIELD_NAME, new float[] {-11.1f, -11.2f}, new float[] {1.23f, 11.5f}));
+    document.add(new FloatRange(FIELD_NAME, new float[] {-11.1f, -11.2f}, new float[] {1.23f, 11.5f}));
     writer.addDocument(document);
 
     // intersects (crosses)
     document = new Document();
-    document.add(new FloatRangeField(FIELD_NAME, new float[] {12.33f, 1.2f}, new float[] {15.1f, 29.9f}));
+    document.add(new FloatRange(FIELD_NAME, new float[] {12.33f, 1.2f}, new float[] {15.1f, 29.9f}));
     writer.addDocument(document);
 
     // disjoint
     document = new Document();
-    document.add(new FloatRangeField(FIELD_NAME, new float[] {-122.33f, 1.2f}, new float[] {-115.1f, 29.9f}));
+    document.add(new FloatRange(FIELD_NAME, new float[] {-122.33f, 1.2f}, new float[] {-115.1f, 29.9f}));
     writer.addDocument(document);
 
     // intersects (crosses)
     document = new Document();
-    document.add(new FloatRangeField(FIELD_NAME, new float[] {Float.NEGATIVE_INFINITY, 1.2f}, new float[] {-11.0f, 29.9f}));
+    document.add(new FloatRange(FIELD_NAME, new float[] {Float.NEGATIVE_INFINITY, 1.2f}, new float[] {-11.0f, 29.9f}));
     writer.addDocument(document);
 
     // equal (within, contains, intersects)
     document = new Document();
-    document.add(new FloatRangeField(FIELD_NAME, new float[] {-11f, -15f}, new float[] {15f, 20f}));
+    document.add(new FloatRange(FIELD_NAME, new float[] {-11f, -15f}, new float[] {15f, 20f}));
     writer.addDocument(document);
 
     // search
     IndexReader reader = writer.getReader();
     IndexSearcher searcher = newSearcher(reader);
-    assertEquals(7, searcher.count(FloatRangeField.newIntersectsQuery(FIELD_NAME,
+    assertEquals(7, searcher.count(FloatRange.newIntersectsQuery(FIELD_NAME,
         new float[] {-11.0f, -15.0f}, new float[] {15.0f, 20.0f})));
-    assertEquals(2, searcher.count(FloatRangeField.newWithinQuery(FIELD_NAME,
+    assertEquals(2, searcher.count(FloatRange.newWithinQuery(FIELD_NAME,
         new float[] {-11.0f, -15.0f}, new float[] {15.0f, 20.0f})));
-    assertEquals(2, searcher.count(FloatRangeField.newContainsQuery(FIELD_NAME,
+    assertEquals(2, searcher.count(FloatRange.newContainsQuery(FIELD_NAME,
         new float[] {-11.0f, -15.0f}, new float[] {15.0f, 20.0f})));
-    assertEquals(5, searcher.count(FloatRangeField.newCrossesQuery(FIELD_NAME,
+    assertEquals(5, searcher.count(FloatRange.newCrossesQuery(FIELD_NAME,
         new float[] {-11.0f, -15.0f}, new float[] {15.0f, 20.0f})));
 
     reader.close();
@@ -140,12 +140,12 @@ public class TestFloatRangeFieldQueries extends BaseRangeFieldQueryTestCase {
     dir.close();
   }
 
-  /** FloatRange test class implementation - use to validate FloatRangeField */
-  private class FloatRange extends Range {
+  /** FloatRange test class implementation - use to validate FloatRange */
+  private class FloatTestRange extends Range {
     float[] min;
     float[] max;
 
-    FloatRange(float[] min, float[] max) {
+    FloatTestRange(float[] min, float[] max) {
       assert min != null && max != null && min.length > 0 && max.length > 0
           : "test box: min/max cannot be null or empty";
       assert min.length == max.length : "test box: min/max length do not agree";
@@ -190,13 +190,13 @@ public class TestFloatRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     @Override
     protected boolean isEqual(Range other) {
-      FloatRange o = (FloatRange)other;
+      FloatTestRange o = (FloatTestRange)other;
       return Arrays.equals(min, o.min) && Arrays.equals(max, o.max);
     }
 
     @Override
     protected boolean isDisjoint(Range o) {
-      FloatRange other = (FloatRange)o;
+      FloatTestRange other = (FloatTestRange)o;
       for (int d=0; d<this.min.length; ++d) {
         if (this.min[d] > other.max[d] || this.max[d] < other.min[d]) {
           // disjoint:
@@ -208,7 +208,7 @@ public class TestFloatRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     @Override
     protected boolean isWithin(Range o) {
-      FloatRange other = (FloatRange)o;
+      FloatTestRange other = (FloatTestRange)o;
       for (int d=0; d<this.min.length; ++d) {
         if ((this.min[d] >= other.min[d] && this.max[d] <= other.max[d]) == false) {
           // not within:
@@ -220,7 +220,7 @@ public class TestFloatRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     @Override
     protected boolean contains(Range o) {
-      FloatRange other = (FloatRange) o;
+      FloatTestRange other = (FloatTestRange) o;
       for (int d=0; d<this.min.length; ++d) {
         if ((this.min[d] <= other.min[d] && this.max[d] >= other.max[d]) == false) {
           // not contains:
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/TestIntRangeFieldQueries.java b/lucene/core/src/test/org/apache/lucene/search/TestIntRangeFieldQueries.java
similarity index 74%
rename from lucene/sandbox/src/test/org/apache/lucene/search/TestIntRangeFieldQueries.java
rename to lucene/core/src/test/org/apache/lucene/search/TestIntRangeFieldQueries.java
index 0bb782e..14771c9 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/search/TestIntRangeFieldQueries.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestIntRangeFieldQueries.java
@@ -19,13 +19,13 @@ package org.apache.lucene.search;
 import java.util.Arrays;
 
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.IntRangeField;
+import org.apache.lucene.document.IntRange;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.store.Directory;
 
 /**
- * Random testing for IntRangeField Queries.
+ * Random testing for IntRange Queries.
  */
 public class TestIntRangeFieldQueries extends BaseRangeFieldQueryTestCase {
   private static final String FIELD_NAME = "intRangeField";
@@ -39,7 +39,7 @@ public class TestIntRangeFieldQueries extends BaseRangeFieldQueryTestCase {
   }
 
   @Override
-  protected Range nextRange(int dimensions) {
+  protected Range nextRange(int dimensions) throws Exception {
     int[] min = new int[dimensions];
     int[] max = new int[dimensions];
 
@@ -50,32 +50,32 @@ public class TestIntRangeFieldQueries extends BaseRangeFieldQueryTestCase {
       min[d] = Math.min(minV, maxV);
       max[d] = Math.max(minV, maxV);
     }
-    return new IntRange(min, max);
+    return new IntTestRange(min, max);
   }
 
   @Override
-  protected IntRangeField newRangeField(Range r) {
-    return new IntRangeField(FIELD_NAME, ((IntRange)r).min, ((IntRange)r).max);
+  protected org.apache.lucene.document.IntRange newRangeField(Range r) {
+    return new IntRange(FIELD_NAME, ((IntTestRange)r).min, ((IntTestRange)r).max);
   }
 
   @Override
   protected Query newIntersectsQuery(Range r) {
-    return IntRangeField.newIntersectsQuery(FIELD_NAME, ((IntRange)r).min, ((IntRange)r).max);
+    return IntRange.newIntersectsQuery(FIELD_NAME, ((IntTestRange)r).min, ((IntTestRange)r).max);
   }
 
   @Override
   protected Query newContainsQuery(Range r) {
-    return IntRangeField.newContainsQuery(FIELD_NAME, ((IntRange)r).min, ((IntRange)r).max);
+    return IntRange.newContainsQuery(FIELD_NAME, ((IntTestRange)r).min, ((IntTestRange)r).max);
   }
 
   @Override
   protected Query newWithinQuery(Range r) {
-    return IntRangeField.newWithinQuery(FIELD_NAME, ((IntRange)r).min, ((IntRange)r).max);
+    return IntRange.newWithinQuery(FIELD_NAME, ((IntTestRange)r).min, ((IntTestRange)r).max);
   }
 
   @Override
   protected Query newCrossesQuery(Range r) {
-    return IntRangeField.newCrossesQuery(FIELD_NAME, ((IntRange)r).min, ((IntRange)r).max);
+    return IntRange.newCrossesQuery(FIELD_NAME, ((IntTestRange)r).min, ((IntTestRange)r).max);
   }
 
   /** Basic test */
@@ -85,54 +85,54 @@ public class TestIntRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     // intersects (within)
     Document document = new Document();
-    document.add(new IntRangeField(FIELD_NAME, new int[] {-10, -10}, new int[] {9, 10}));
+    document.add(new IntRange(FIELD_NAME, new int[] {-10, -10}, new int[] {9, 10}));
     writer.addDocument(document);
 
     // intersects (crosses)
     document = new Document();
-    document.add(new IntRangeField(FIELD_NAME, new int[] {10, -10}, new int[] {20, 10}));
+    document.add(new IntRange(FIELD_NAME, new int[] {10, -10}, new int[] {20, 10}));
     writer.addDocument(document);
 
     // intersects (contains / crosses)
     document = new Document();
-    document.add(new IntRangeField(FIELD_NAME, new int[] {-20, -20}, new int[] {30, 30}));
+    document.add(new IntRange(FIELD_NAME, new int[] {-20, -20}, new int[] {30, 30}));
     writer.addDocument(document);
 
     // intersects (within)
     document = new Document();
-    document.add(new IntRangeField(FIELD_NAME, new int[] {-11, -11}, new int[] {1, 11}));
+    document.add(new IntRange(FIELD_NAME, new int[] {-11, -11}, new int[] {1, 11}));
     writer.addDocument(document);
 
     // intersects (crosses)
     document = new Document();
-    document.add(new IntRangeField(FIELD_NAME, new int[] {12, 1}, new int[] {15, 29}));
+    document.add(new IntRange(FIELD_NAME, new int[] {12, 1}, new int[] {15, 29}));
     writer.addDocument(document);
 
     // disjoint
     document = new Document();
-    document.add(new IntRangeField(FIELD_NAME, new int[] {-122, 1}, new int[] {-115, 29}));
+    document.add(new IntRange(FIELD_NAME, new int[] {-122, 1}, new int[] {-115, 29}));
     writer.addDocument(document);
 
     // intersects (crosses)
     document = new Document();
-    document.add(new IntRangeField(FIELD_NAME, new int[] {Integer.MIN_VALUE, 1}, new int[] {-11, 29}));
+    document.add(new IntRange(FIELD_NAME, new int[] {Integer.MIN_VALUE, 1}, new int[] {-11, 29}));
     writer.addDocument(document);
 
     // equal (within, contains, intersects)
     document = new Document();
-    document.add(new IntRangeField(FIELD_NAME, new int[] {-11, -15}, new int[] {15, 20}));
+    document.add(new IntRange(FIELD_NAME, new int[] {-11, -15}, new int[] {15, 20}));
     writer.addDocument(document);
 
     // search
     IndexReader reader = writer.getReader();
     IndexSearcher searcher = newSearcher(reader);
-    assertEquals(7, searcher.count(IntRangeField.newIntersectsQuery(FIELD_NAME,
+    assertEquals(7, searcher.count(IntRange.newIntersectsQuery(FIELD_NAME,
         new int[] {-11, -15}, new int[] {15, 20})));
-    assertEquals(3, searcher.count(IntRangeField.newWithinQuery(FIELD_NAME,
+    assertEquals(3, searcher.count(IntRange.newWithinQuery(FIELD_NAME,
         new int[] {-11, -15}, new int[] {15, 20})));
-    assertEquals(2, searcher.count(IntRangeField.newContainsQuery(FIELD_NAME,
+    assertEquals(2, searcher.count(IntRange.newContainsQuery(FIELD_NAME,
         new int[] {-11, -15}, new int[] {15, 20})));
-    assertEquals(4, searcher.count(IntRangeField.newCrossesQuery(FIELD_NAME,
+    assertEquals(4, searcher.count(IntRange.newCrossesQuery(FIELD_NAME,
         new int[] {-11, -15}, new int[] {15, 20})));
 
     reader.close();
@@ -140,12 +140,12 @@ public class TestIntRangeFieldQueries extends BaseRangeFieldQueryTestCase {
     dir.close();
   }
 
-  /** IntRange test class implementation - use to validate IntRangeField */
-  private class IntRange extends Range {
+  /** IntRange test class implementation - use to validate IntRange */
+  private class IntTestRange extends Range {
     int[] min;
     int[] max;
 
-    IntRange(int[] min, int[] max) {
+    IntTestRange(int[] min, int[] max) {
       assert min != null && max != null && min.length > 0 && max.length > 0
           : "test box: min/max cannot be null or empty";
       assert min.length == max.length : "test box: min/max length do not agree";
@@ -190,13 +190,13 @@ public class TestIntRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     @Override
     protected boolean isEqual(Range other) {
-      IntRange o = (IntRange)other;
+      IntTestRange o = (IntTestRange)other;
       return Arrays.equals(min, o.min) && Arrays.equals(max, o.max);
     }
 
     @Override
     protected boolean isDisjoint(Range o) {
-      IntRange other = (IntRange)o;
+      IntTestRange other = (IntTestRange)o;
       for (int d=0; d<this.min.length; ++d) {
         if (this.min[d] > other.max[d] || this.max[d] < other.min[d]) {
           // disjoint:
@@ -208,7 +208,7 @@ public class TestIntRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     @Override
     protected boolean isWithin(Range o) {
-      IntRange other = (IntRange)o;
+      IntTestRange other = (IntTestRange)o;
       for (int d=0; d<this.min.length; ++d) {
         if ((this.min[d] >= other.min[d] && this.max[d] <= other.max[d]) == false) {
           // not within:
@@ -220,7 +220,7 @@ public class TestIntRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     @Override
     protected boolean contains(Range o) {
-      IntRange other = (IntRange) o;
+      IntTestRange other = (IntTestRange) o;
       for (int d=0; d<this.min.length; ++d) {
         if ((this.min[d] <= other.min[d] && this.max[d] >= other.max[d]) == false) {
           // not contains:
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/TestLongRangeFieldQueries.java b/lucene/core/src/test/org/apache/lucene/search/TestLongRangeFieldQueries.java
similarity index 73%
rename from lucene/sandbox/src/test/org/apache/lucene/search/TestLongRangeFieldQueries.java
rename to lucene/core/src/test/org/apache/lucene/search/TestLongRangeFieldQueries.java
index fc21a64..60d7ea3 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/search/TestLongRangeFieldQueries.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestLongRangeFieldQueries.java
@@ -19,13 +19,13 @@ package org.apache.lucene.search;
 import java.util.Arrays;
 
 import org.apache.lucene.document.Document;
-import org.apache.lucene.document.LongRangeField;
+import org.apache.lucene.document.LongRange;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.store.Directory;
 
 /**
- * Random testing for LongRangeField Queries.
+ * Random testing for LongRange Queries.
  */
 public class TestLongRangeFieldQueries extends BaseRangeFieldQueryTestCase {
   private static final String FIELD_NAME = "longRangeField";
@@ -39,7 +39,7 @@ public class TestLongRangeFieldQueries extends BaseRangeFieldQueryTestCase {
   }
 
   @Override
-  protected Range nextRange(int dimensions) {
+  protected Range nextRange(int dimensions) throws Exception {
     long[] min = new long[dimensions];
     long[] max = new long[dimensions];
 
@@ -50,32 +50,32 @@ public class TestLongRangeFieldQueries extends BaseRangeFieldQueryTestCase {
       min[d] = Math.min(minV, maxV);
       max[d] = Math.max(minV, maxV);
     }
-    return new LongRange(min, max);
+    return new LongTestRange(min, max);
   }
 
   @Override
-  protected LongRangeField newRangeField(Range r) {
-    return new LongRangeField(FIELD_NAME, ((LongRange)r).min, ((LongRange)r).max);
+  protected LongRange newRangeField(Range r) {
+    return new LongRange(FIELD_NAME, ((LongTestRange)r).min, ((LongTestRange)r).max);
   }
 
   @Override
   protected Query newIntersectsQuery(Range r) {
-    return LongRangeField.newIntersectsQuery(FIELD_NAME, ((LongRange)r).min, ((LongRange)r).max);
+    return LongRange.newIntersectsQuery(FIELD_NAME, ((LongTestRange)r).min, ((LongTestRange)r).max);
   }
 
   @Override
   protected Query newContainsQuery(Range r) {
-    return LongRangeField.newContainsQuery(FIELD_NAME, ((LongRange)r).min, ((LongRange)r).max);
+    return LongRange.newContainsQuery(FIELD_NAME, ((LongTestRange)r).min, ((LongTestRange)r).max);
   }
 
   @Override
   protected Query newWithinQuery(Range r) {
-    return LongRangeField.newWithinQuery(FIELD_NAME, ((LongRange)r).min, ((LongRange)r).max);
+    return LongRange.newWithinQuery(FIELD_NAME, ((LongTestRange)r).min, ((LongTestRange)r).max);
   }
 
   @Override
   protected Query newCrossesQuery(Range r) {
-    return LongRangeField.newCrossesQuery(FIELD_NAME, ((LongRange)r).min, ((LongRange)r).max);
+    return LongRange.newCrossesQuery(FIELD_NAME, ((LongTestRange)r).min, ((LongTestRange)r).max);
   }
 
   /** Basic test */
@@ -85,54 +85,54 @@ public class TestLongRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     // intersects (within)
     Document document = new Document();
-    document.add(new LongRangeField(FIELD_NAME, new long[] {-10, -10}, new long[] {9, 10}));
+    document.add(new LongRange(FIELD_NAME, new long[] {-10, -10}, new long[] {9, 10}));
     writer.addDocument(document);
 
     // intersects (crosses)
     document = new Document();
-    document.add(new LongRangeField(FIELD_NAME, new long[] {10, -10}, new long[] {20, 10}));
+    document.add(new LongRange(FIELD_NAME, new long[] {10, -10}, new long[] {20, 10}));
     writer.addDocument(document);
 
     // intersects (contains, crosses)
     document = new Document();
-    document.add(new LongRangeField(FIELD_NAME, new long[] {-20, -20}, new long[] {30, 30}));
+    document.add(new LongRange(FIELD_NAME, new long[] {-20, -20}, new long[] {30, 30}));
     writer.addDocument(document);
 
     // intersects (within)
     document = new Document();
-    document.add(new LongRangeField(FIELD_NAME, new long[] {-11, -11}, new long[] {1, 11}));
+    document.add(new LongRange(FIELD_NAME, new long[] {-11, -11}, new long[] {1, 11}));
     writer.addDocument(document);
 
     // intersects (crosses)
     document = new Document();
-    document.add(new LongRangeField(FIELD_NAME, new long[] {12, 1}, new long[] {15, 29}));
+    document.add(new LongRange(FIELD_NAME, new long[] {12, 1}, new long[] {15, 29}));
     writer.addDocument(document);
 
     // disjoint
     document = new Document();
-    document.add(new LongRangeField(FIELD_NAME, new long[] {-122, 1}, new long[] {-115, 29}));
+    document.add(new LongRange(FIELD_NAME, new long[] {-122, 1}, new long[] {-115, 29}));
     writer.addDocument(document);
 
     // intersects (crosses)
     document = new Document();
-    document.add(new LongRangeField(FIELD_NAME, new long[] {Long.MIN_VALUE, 1}, new long[] {-11, 29}));
+    document.add(new LongRange(FIELD_NAME, new long[] {Long.MIN_VALUE, 1}, new long[] {-11, 29}));
     writer.addDocument(document);
 
     // equal (within, contains, intersects)
     document = new Document();
-    document.add(new LongRangeField(FIELD_NAME, new long[] {-11, -15}, new long[] {15, 20}));
+    document.add(new LongRange(FIELD_NAME, new long[] {-11, -15}, new long[] {15, 20}));
     writer.addDocument(document);
 
     // search
     IndexReader reader = writer.getReader();
     IndexSearcher searcher = newSearcher(reader);
-    assertEquals(7, searcher.count(LongRangeField.newIntersectsQuery(FIELD_NAME,
+    assertEquals(7, searcher.count(LongRange.newIntersectsQuery(FIELD_NAME,
         new long[] {-11, -15}, new long[] {15, 20})));
-    assertEquals(3, searcher.count(LongRangeField.newWithinQuery(FIELD_NAME,
+    assertEquals(3, searcher.count(LongRange.newWithinQuery(FIELD_NAME,
         new long[] {-11, -15}, new long[] {15, 20})));
-    assertEquals(2, searcher.count(LongRangeField.newContainsQuery(FIELD_NAME,
+    assertEquals(2, searcher.count(LongRange.newContainsQuery(FIELD_NAME,
         new long[] {-11, -15}, new long[] {15, 20})));
-    assertEquals(4, searcher.count(LongRangeField.newCrossesQuery(FIELD_NAME,
+    assertEquals(4, searcher.count(LongRange.newCrossesQuery(FIELD_NAME,
         new long[] {-11, -15}, new long[] {15, 20})));
 
     reader.close();
@@ -140,12 +140,12 @@ public class TestLongRangeFieldQueries extends BaseRangeFieldQueryTestCase {
     dir.close();
   }
 
-  /** LongRange test class implementation - use to validate LongRangeField */
-  private class LongRange extends Range {
+  /** LongRange test class implementation - use to validate LongRange */
+  private class LongTestRange extends Range {
     long[] min;
     long[] max;
 
-    LongRange(long[] min, long[] max) {
+    LongTestRange(long[] min, long[] max) {
       assert min != null && max != null && min.length > 0 && max.length > 0
           : "test box: min/max cannot be null or empty";
       assert min.length == max.length : "test box: min/max length do not agree";
@@ -190,13 +190,13 @@ public class TestLongRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     @Override
     protected boolean isEqual(Range other) {
-      LongRange o = (LongRange)other;
+      LongTestRange o = (LongTestRange)other;
       return Arrays.equals(min, o.min) && Arrays.equals(max, o.max);
     }
 
     @Override
     protected boolean isDisjoint(Range o) {
-      LongRange other = (LongRange)o;
+      LongTestRange other = (LongTestRange)o;
       for (int d=0; d<this.min.length; ++d) {
         if (this.min[d] > other.max[d] || this.max[d] < other.min[d]) {
           // disjoint:
@@ -208,7 +208,7 @@ public class TestLongRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     @Override
     protected boolean isWithin(Range o) {
-      LongRange other = (LongRange)o;
+      LongTestRange other = (LongTestRange)o;
       for (int d=0; d<this.min.length; ++d) {
         if ((this.min[d] >= other.min[d] && this.max[d] <= other.max[d]) == false) {
           // not within:
@@ -220,7 +220,7 @@ public class TestLongRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
     @Override
     protected boolean contains(Range o) {
-      LongRange other = (LongRange) o;
+      LongTestRange other = (LongTestRange) o;
       for (int d=0; d<this.min.length; ++d) {
         if ((this.min[d] <= other.min[d] && this.max[d] >= other.max[d]) == false) {
           // not contains:
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/InetAddressPoint.java b/lucene/misc/src/java/org/apache/lucene/document/InetAddressPoint.java
similarity index 100%
rename from lucene/sandbox/src/java/org/apache/lucene/document/InetAddressPoint.java
rename to lucene/misc/src/java/org/apache/lucene/document/InetAddressPoint.java
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/InetAddressRangeField.java b/lucene/misc/src/java/org/apache/lucene/document/InetAddressRange.java
similarity index 96%
rename from lucene/sandbox/src/java/org/apache/lucene/document/InetAddressRangeField.java
rename to lucene/misc/src/java/org/apache/lucene/document/InetAddressRange.java
index c6ebc83..5fa1fb9 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/InetAddressRangeField.java
+++ b/lucene/misc/src/java/org/apache/lucene/document/InetAddressRange.java
@@ -40,7 +40,7 @@ import org.apache.lucene.util.StringHelper;
  *   <li>{@link #newCrossesQuery newCrossesQuery()} matches ip ranges that cross the defined search range
  * </ul>
  */
-public class InetAddressRangeField extends Field {
+public class InetAddressRange extends Field {
   /** The number of bytes per dimension : sync w/ {@code InetAddressPoint} */
   public static final int BYTES = InetAddressPoint.BYTES;
 
@@ -52,12 +52,12 @@ public class InetAddressRangeField extends Field {
   }
 
   /**
-   * Create a new InetAddressRangeField from min/max value
+   * Create a new InetAddressRange from min/max value
    * @param name field name. must not be null.
    * @param min range min value; defined as an {@code InetAddress}
    * @param max range max value; defined as an {@code InetAddress}
    */
-  public InetAddressRangeField(String name, final InetAddress min, final InetAddress max) {
+  public InetAddressRange(String name, final InetAddress min, final InetAddress max) {
     super(name, TYPE);
     setRangeValues(min, max);
   }
@@ -147,7 +147,7 @@ public class InetAddressRangeField extends Field {
     return new RangeFieldQuery(field, encode(min, max), 1, relation) {
       @Override
       protected String toString(byte[] ranges, int dimension) {
-        return InetAddressRangeField.toString(ranges, dimension);
+        return InetAddressRange.toString(ranges, dimension);
       }
     };
   }
diff --git a/lucene/sandbox/src/test/org/apache/lucene/document/TestInetAddressPoint.java b/lucene/misc/src/test/org/apache/lucene/document/TestInetAddressPoint.java
similarity index 100%
rename from lucene/sandbox/src/test/org/apache/lucene/document/TestInetAddressPoint.java
rename to lucene/misc/src/test/org/apache/lucene/document/TestInetAddressPoint.java
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/TestIpRangeFieldQueries.java b/lucene/misc/src/test/org/apache/lucene/search/TestInetAddressRangeQueries.java
similarity index 81%
rename from lucene/sandbox/src/test/org/apache/lucene/search/TestIpRangeFieldQueries.java
rename to lucene/misc/src/test/org/apache/lucene/search/TestInetAddressRangeQueries.java
index 1563584..e22cf9b 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/search/TestIpRangeFieldQueries.java
+++ b/lucene/misc/src/test/org/apache/lucene/search/TestInetAddressRangeQueries.java
@@ -19,13 +19,13 @@ package org.apache.lucene.search;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
 
-import org.apache.lucene.document.InetAddressRangeField;
+import org.apache.lucene.document.InetAddressRange;
 import org.apache.lucene.util.StringHelper;
 
 /**
- * Random testing for {@link InetAddressRangeField}
+ * Random testing for {@link InetAddressRange}
  */
-public class TestIpRangeFieldQueries extends BaseRangeFieldQueryTestCase {
+public class TestInetAddressRangeQueries extends BaseRangeFieldQueryTestCase {
   private static final String FIELD_NAME = "ipRangeField";
 
   private IPVersion ipVersion;
@@ -33,20 +33,15 @@ public class TestIpRangeFieldQueries extends BaseRangeFieldQueryTestCase {
   private enum IPVersion {IPv4, IPv6}
 
   @Override
-  protected Range nextRange(int dimensions) {
-    try {
-      InetAddress min = nextInetaddress();
-      byte[] bMin = min.getAddress();
-      InetAddress max = nextInetaddress();
-      byte[] bMax = max.getAddress();
-      if (StringHelper.compare(bMin.length, bMin, 0, bMax, 0) > 0) {
-        return new IpRange(max, min);
-      }
-      return new IpRange(min, max);
-    } catch (UnknownHostException e) {
-      e.printStackTrace();
+  protected Range nextRange(int dimensions) throws Exception {
+    InetAddress min = nextInetaddress();
+    byte[] bMin = min.getAddress();
+    InetAddress max = nextInetaddress();
+    byte[] bMax = max.getAddress();
+    if (StringHelper.compare(bMin.length, bMin, 0, bMax, 0) > 0) {
+      return new IpRange(max, min);
     }
-    return null;
+    return new IpRange(min, max);
   }
 
   /** return random IPv4 or IPv6 address */
@@ -98,32 +93,32 @@ public class TestIpRangeFieldQueries extends BaseRangeFieldQueryTestCase {
 
   /** return random range */
   @Override
-  protected InetAddressRangeField newRangeField(Range r) {
-    return new InetAddressRangeField(FIELD_NAME, ((IpRange)r).min, ((IpRange)r).max);
+  protected InetAddressRange newRangeField(Range r) {
+    return new InetAddressRange(FIELD_NAME, ((IpRange)r).min, ((IpRange)r).max);
   }
 
   /** return random intersects query */
   @Override
   protected Query newIntersectsQuery(Range r) {
-    return InetAddressRangeField.newIntersectsQuery(FIELD_NAME, ((IpRange)r).min, ((IpRange)r).max);
+    return InetAddressRange.newIntersectsQuery(FIELD_NAME, ((IpRange)r).min, ((IpRange)r).max);
   }
 
   /** return random contains query */
   @Override
   protected Query newContainsQuery(Range r) {
-    return InetAddressRangeField.newContainsQuery(FIELD_NAME, ((IpRange)r).min, ((IpRange)r).max);
+    return InetAddressRange.newContainsQuery(FIELD_NAME, ((IpRange)r).min, ((IpRange)r).max);
   }
 
   /** return random within query */
   @Override
   protected Query newWithinQuery(Range r) {
-    return InetAddressRangeField.newWithinQuery(FIELD_NAME, ((IpRange)r).min, ((IpRange)r).max);
+    return InetAddressRange.newWithinQuery(FIELD_NAME, ((IpRange)r).min, ((IpRange)r).max);
   }
 
   /** return random crosses query */
   @Override
   protected Query newCrossesQuery(Range r) {
-    return InetAddressRangeField.newCrossesQuery(FIELD_NAME, ((IpRange)r).min, ((IpRange)r).max);
+    return InetAddressRange.newCrossesQuery(FIELD_NAME, ((IpRange)r).min, ((IpRange)r).max);
   }
 
   /** encapsulated IpRange for test validation */
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/package.html b/lucene/sandbox/src/java/org/apache/lucene/document/package.html
index b6a077e..4783b5e 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/package.html
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/package.html
@@ -26,8 +26,7 @@
 This package contains several point types:
 <ul>
    <li>{@link org.apache.lucene.document.BigIntegerPoint BigIntegerPoint} for 128-bit integers</li>
-   <li>{@link org.apache.lucene.document.InetAddressPoint InetAddressPoint} for IPv4 and IPv6 network addresses</li>
-   <li>{@link org.apache.lucene.document.LatLonPoint LatLonPoint} for latitude/longitude geospatial points</li> 
+   <li>{@link org.apache.lucene.document.LatLonPoint LatLonPoint} for latitude/longitude geospatial points</li>
 </ul>
 </body>
 </html>
diff --git a/lucene/sandbox/src/test/org/apache/lucene/document/TestDoubleRangeField.java b/lucene/sandbox/src/test/org/apache/lucene/document/TestDoubleRangeField.java
index 188aab6..8a8130b 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/document/TestDoubleRangeField.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/document/TestDoubleRangeField.java
@@ -30,11 +30,11 @@ public class TestDoubleRangeField extends LuceneTestCase {
     IllegalArgumentException expected;
 
     expected = expectThrows(IllegalArgumentException.class, () ->
-        doc.add(new DoubleRangeField(FIELD_NAME, new double[] {Double.NaN}, new double[] {5})));
+        doc.add(new DoubleRange(FIELD_NAME, new double[] {Double.NaN}, new double[] {5})));
     assertTrue(expected.getMessage().contains("invalid min value"));
 
     expected = expectThrows(IllegalArgumentException.class, () ->
-        doc.add(new DoubleRangeField(FIELD_NAME, new double[] {5}, new double[] {Double.NaN})));
+        doc.add(new DoubleRange(FIELD_NAME, new double[] {5}, new double[] {Double.NaN})));
     assertTrue(expected.getMessage().contains("invalid max value"));
   }
 
@@ -43,7 +43,7 @@ public class TestDoubleRangeField extends LuceneTestCase {
     Document doc = new Document();
     IllegalArgumentException expected;
     expected = expectThrows(IllegalArgumentException.class, () ->
-        doc.add(new DoubleRangeField(FIELD_NAME, new double[] {5, 6}, new double[] {5})));
+        doc.add(new DoubleRange(FIELD_NAME, new double[] {5, 6}, new double[] {5})));
     assertTrue(expected.getMessage().contains("min/max ranges must agree"));
   }
 
@@ -52,7 +52,7 @@ public class TestDoubleRangeField extends LuceneTestCase {
     Document doc = new Document();
     IllegalArgumentException expected;
     expected = expectThrows(IllegalArgumentException.class, () ->
-        doc.add(new DoubleRangeField(FIELD_NAME, new double[] {1, 2, 3, 4, 5}, new double[] {5})));
+        doc.add(new DoubleRange(FIELD_NAME, new double[] {1, 2, 3, 4, 5}, new double[] {5})));
     assertTrue(expected.getMessage().contains("does not support greater than 4 dimensions"));
   }
 
@@ -61,7 +61,7 @@ public class TestDoubleRangeField extends LuceneTestCase {
     Document doc = new Document();
     IllegalArgumentException expected;
     expected = expectThrows(IllegalArgumentException.class, () ->
-      doc.add(new DoubleRangeField(FIELD_NAME, new double[] {3, 4}, new double[] {1, 2})));
+      doc.add(new DoubleRange(FIELD_NAME, new double[] {3, 4}, new double[] {1, 2})));
     assertTrue(expected.getMessage().contains("is greater than max value"));
   }
 }
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/BaseRangeFieldQueryTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/search/BaseRangeFieldQueryTestCase.java
similarity index 98%
rename from lucene/sandbox/src/test/org/apache/lucene/search/BaseRangeFieldQueryTestCase.java
rename to lucene/test-framework/src/java/org/apache/lucene/search/BaseRangeFieldQueryTestCase.java
index 53f3b82..ba2efd7 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/search/BaseRangeFieldQueryTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/BaseRangeFieldQueryTestCase.java
@@ -53,7 +53,7 @@ public abstract class BaseRangeFieldQueryTestCase extends LuceneTestCase {
 
   protected abstract Query newCrossesQuery(Range box);
 
-  protected abstract Range nextRange(int dimensions);
+  protected abstract Range nextRange(int dimensions) throws Exception;
 
   protected int dimension() {
     return random().nextInt(4) + 1;
@@ -314,10 +314,11 @@ public abstract class BaseRangeFieldQueryTestCase extends LuceneTestCase {
     return relation == queryType;
   }
 
-  abstract static class Range {
+  /** base class for range verification */
+  protected abstract static class Range {
     protected boolean isMissing = false;
 
-    enum QueryType { INTERSECTS, WITHIN, CONTAINS, CROSSES }
+    protected enum QueryType { INTERSECTS, WITHIN, CONTAINS, CROSSES }
 
     protected abstract int numDimensions();
     protected abstract Object getMin(int dim);
