diff --git a/lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java b/lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java
index 344f921f649..1c5f4664d8e 100644
--- a/lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/FuzzyQuery.java
@@ -98,7 +98,7 @@ public class FuzzyQuery extends MultiTermQuery {
     this.prefixLength = prefixLength;
     this.transpositions = transpositions;
     this.maxExpansions = maxExpansions;
-    setRewriteMethod(new MultiTermQuery.TopTermsBlendedFreqScoringRewrite(maxExpansions));
+    setRewriteMethod(new MultiTermQuery.TopTermsBlendedFreqScoringRewrite(term.field(), maxExpansions));
   }
   
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java
index 636a7d6757a..228a8066d1b 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java
@@ -173,9 +173,8 @@ public abstract class MultiTermQuery extends Query {
   }
   
   /**
-   * A rewrite method that first translates each term into
-   * {@link BooleanClause.Occur#SHOULD} clause in a BooleanQuery, but adjusts
-   * the frequencies used for scoring to be blended across the terms, otherwise
+   * A rewrite method that uses the {@link SynonymQuery} to blend
+   * the frequencies used for scoring across the terms, otherwise
    * the rarest term typically ranks highest (often not useful eg in the set of
    * expanded terms in a FuzzyQuery).
    * 
@@ -186,17 +185,20 @@ public abstract class MultiTermQuery extends Query {
    * @see #setRewriteMethod
    */
   public static final class TopTermsBlendedFreqScoringRewrite extends
-      TopTermsRewrite<BlendedTermQuery.Builder> {
+      TopTermsRewrite<SynonymQuery.Builder> {
+
+    private final String field;
 
     /**
      * Create a TopTermsBlendedScoringBooleanQueryRewrite for at most
-     * <code>size</code> terms.
+     * <code>size</code> terms on the provided <code>field</code>.
      * <p>
      * NOTE: if {@link BooleanQuery#getMaxClauseCount} is smaller than
      * <code>size</code>, then it will be used instead.
      */
-    public TopTermsBlendedFreqScoringRewrite(int size) {
+    public TopTermsBlendedFreqScoringRewrite(String field, int size) {
       super(size);
+      this.field = field;
     }
 
     @Override
@@ -205,21 +207,20 @@ public abstract class MultiTermQuery extends Query {
     }
 
     @Override
-    protected BlendedTermQuery.Builder getTopLevelBuilder() {
-      BlendedTermQuery.Builder builder = new BlendedTermQuery.Builder();
-      builder.setRewriteMethod(BlendedTermQuery.BOOLEAN_REWRITE);
+    protected SynonymQuery.Builder getTopLevelBuilder() {
+      SynonymQuery.Builder builder = new SynonymQuery.Builder(field);
       return builder;
     }
 
     @Override
-    protected Query build(BlendedTermQuery.Builder builder) {
+    protected Query build(SynonymQuery.Builder builder) {
       return builder.build();
     }
 
     @Override
-    protected void addClause(BlendedTermQuery.Builder topLevel, Term term, int docCount,
+    protected void addClause(SynonymQuery.Builder topLevel, Term term, int docCount,
         float boost, TermStates states) {
-      topLevel.add(term, boost, states);
+      topLevel.addTerm(term, boost);
     }
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java b/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
index 2d053b6d669..4b1dbd32295 100644
--- a/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
@@ -88,8 +88,8 @@ public final class SynonymQuery extends Query {
       if (field.equals(term.field()) == false) {
         throw new IllegalArgumentException("Synonyms must be across the same field");
       }
-      if (Float.isNaN(boost) || Float.compare(boost, 0f) <= 0 || Float.compare(boost, 1f) > 0) {
-        throw new IllegalArgumentException("boost must be a positive float between 0 (exclusive) and 1 (inclusive)");
+      if (Float.isNaN(boost) || Float.compare(boost, 0f) < 0 || Float.compare(boost, 1f) > 0) {
+        throw new IllegalArgumentException("boost must be a positive float between 0 and 1");
       }
       terms.add(new TermAndBoost(term, boost));
       if (terms.size() > BooleanQuery.getMaxClauseCount()) {
@@ -300,7 +300,12 @@ public final class SynonymQuery extends Query {
           scorer = new TermScorer(this, iterators.get(0), simScorer);
         }
         float boost = termBoosts.get(0);
-        return scoreMode == ScoreMode.COMPLETE_NO_SCORES || boost == 1f ? scorer : new FreqBoostTermScorer(boost, scorer, simScorer);
+        if (boost == 0) {
+          return new ConstantScoreScorer(this, 0f, scoreMode, scorer.iterator());
+        } else {
+          return (scoreMode == ScoreMode.COMPLETE_NO_SCORES || boost == 1f) ? scorer :
+              new FreqBoostTermScorer(boost, scorer, simScorer);
+        }
       }
 
       // we use termscorers + disjunction as an impl detail
@@ -317,8 +322,13 @@ public final class SynonymQuery extends Query {
       DocIdSetIterator iterator = new DisjunctionDISIApproximation(queue);
 
       float[] boosts = new float[impacts.size()];
+      boolean allZeroBoost = false;
       for (int i = 0; i < boosts.length; i++) {
         boosts[i] = termBoosts.get(i);
+        allZeroBoost = (boosts[i] == 0f);
+      }
+      if (allZeroBoost) {
+        return new ConstantScoreScorer(this, 0f, scoreMode, iterator);
       }
       ImpactsSource impactsSource = mergeImpacts(impacts.toArray(new ImpactsEnum[0]), boosts);
       ImpactsDISI impactsDisi = new ImpactsDISI(iterator, impactsSource, simScorer.getSimScorer());
@@ -419,7 +429,10 @@ public final class SynonymQuery extends Query {
                   return Collections.singletonList(new Impact(Integer.MAX_VALUE, 1L));
                 }
                 final List<Impact> impactList;
-                if (boosts[i] != 1f) {
+                if (boosts[i] == 0) {
+                  // ignore clauses that don't impact the score (boost == 0)
+                  continue;
+                } else if (boosts[i] != 1f) {
                   float boost = boosts[i];
                   impactList = impacts[i].getImpacts(impactsLevel)
                       .stream()
@@ -535,6 +548,11 @@ public final class SynonymQuery extends Query {
 
     @Override
     public float score() throws IOException {
+      float freq = freq();
+      if (freq == 0) {
+        // if all matching terms have a boost of 0
+        return 0;
+      }
       return simScorer.score(iterator.docID(), freq());
     }
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSynonymQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestSynonymQuery.java
index 9785254488b..0ac46d89e14 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSynonymQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSynonymQuery.java
@@ -88,10 +88,6 @@ public class TestSynonymQuery extends LuceneTestCase {
       new SynonymQuery.Builder("field1").addTerm(new Term("field1", "a"), -0.3f);
     });
 
-    expectThrows(IllegalArgumentException.class, () -> {
-      new SynonymQuery.Builder("field1").addTerm(new Term("field1", "a"), 0f);
-    });
-
     expectThrows(IllegalArgumentException.class, () -> {
       new SynonymQuery.Builder("field1").addTerm(new Term("field1", "a"), -0f);
     });
@@ -129,8 +125,8 @@ public class TestSynonymQuery extends LuceneTestCase {
     IndexReader reader = w.getReader();
     IndexSearcher searcher = newSearcher(reader);
     SynonymQuery query = new SynonymQuery.Builder("f")
-        .addTerm(new Term("f", "a"), boost == 0 ? 1f : boost)
-        .addTerm(new Term("f", "b"), boost == 0 ? 1f : boost)
+        .addTerm(new Term("f", "a"), boost)
+        .addTerm(new Term("f", "b"), boost)
         .build();
 
     TopScoreDocCollector collector = TopScoreDocCollector.create(Math.min(reader.numDocs(), totalHitsThreshold), null, totalHitsThreshold);
@@ -167,15 +163,15 @@ public class TestSynonymQuery extends LuceneTestCase {
     w.addDocument(doc);
     for (int i = 0; i < 10; ++i) {
       doc.clear();
-      doc.add(new Field("f", "a a a a", ft));
+      doc.add(new Field("f", "a a a a d", ft));
       w.addDocument(doc);
       if (i % 2 == 0) {
         doc.clear();
-        doc.add(new Field("f", "b b", ft));
+        doc.add(new Field("f", "b b d", ft));
         w.addDocument(doc);
       } else {
         doc.clear();
-        doc.add(new Field("f", "a a b", ft));
+        doc.add(new Field("f", "a a b d", ft));
         w.addDocument(doc);
       }
     }
@@ -188,6 +184,7 @@ public class TestSynonymQuery extends LuceneTestCase {
         .addTerm(new Term("f", "a"), 0.25f)
         .addTerm(new Term("f", "b"), 0.5f)
         .addTerm(new Term("f", "c"))
+        .addTerm(new Term("f", "d"), 0f)
         .build();
 
     TopScoreDocCollector collector = TopScoreDocCollector.create(Math.min(reader.numDocs(), totalHitsThreshold), null, totalHitsThreshold);
