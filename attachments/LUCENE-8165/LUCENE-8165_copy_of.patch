diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary.java
index 7885daab8d..32f55f95c9 100644
--- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary.java
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary.java
@@ -62,7 +62,6 @@ import org.apache.lucene.util.IntsRefBuilder;
 import org.apache.lucene.util.OfflineSorter.ByteSequencesReader;
 import org.apache.lucene.util.OfflineSorter.ByteSequencesWriter;
 import org.apache.lucene.util.OfflineSorter;
-import org.apache.lucene.util.RamUsageEstimator;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
 import org.apache.lucene.util.automaton.RegExp;
 import org.apache.lucene.util.fst.Builder;
@@ -927,10 +926,7 @@ public class Dictionary {
         if (hasStemExceptions && end+1 < line.length()) {
           String stemException = parseStemException(line.substring(end+1));
           if (stemException != null) {
-            if (stemExceptionCount == stemExceptions.length) {
-              int newSize = ArrayUtil.oversize(stemExceptionCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);
-              stemExceptions = Arrays.copyOf(stemExceptions, newSize);
-            }
+            stemExceptions = ArrayUtil.grow(stemExceptions, stemExceptionCount+1);
             stemExceptionID = stemExceptionCount+1; // we use '0' to indicate no exception for the form
             stemExceptions[stemExceptionCount++] = stemException;
           }
@@ -1125,9 +1121,12 @@ public class Dictionary {
       }
 
       if (upto < flags.length) {
-        flags = Arrays.copyOf(flags, upto);
+        char[] flagsUpTo = new char[upto];
+        System.arraycopy(flags, 0, flagsUpTo, 0, upto);
+        return flagsUpTo;
+      } else {
+        return flags;
       }
-      return flags;
     }
   }
 
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/WordDelimiterFilter.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/WordDelimiterFilter.java
index 16edb3dbef..55ba1202aa 100644
--- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/WordDelimiterFilter.java
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/WordDelimiterFilter.java
@@ -17,7 +17,6 @@
 package org.apache.lucene.analysis.miscellaneous;
 
 import java.io.IOException;
-import java.util.Arrays;
 
 import org.apache.lucene.analysis.CharArraySet;
 import org.apache.lucene.analysis.TokenFilter;
@@ -425,12 +424,9 @@ public final class WordDelimiterFilter extends TokenFilter {
   final OffsetSorter sorter = new OffsetSorter();
   
   private void buffer() {
-    if (bufferedLen == buffered.length) {
-      int newSize = ArrayUtil.oversize(bufferedLen+1, 8);
-      buffered = Arrays.copyOf(buffered, newSize);
-      startOff = Arrays.copyOf(startOff, newSize);
-      posInc = Arrays.copyOf(posInc, newSize);
-    }
+    buffered = ArrayUtil.grow(buffered, bufferedLen + 1);
+    startOff = ArrayUtil.grow(startOff, bufferedLen + 1);
+    posInc = ArrayUtil.grow(posInc, bufferedLen + 1);
     startOff[bufferedLen] = offsetAttribute.startOffset();
     posInc[bufferedLen] = posIncAttribute.getPositionIncrement();
     buffered[bufferedLen] = captureState();
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter.java
index ec2676f780..a51edb5dba 100644
--- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter.java
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter.java
@@ -17,7 +17,6 @@
 package org.apache.lucene.analysis.synonym;
 
 import java.io.IOException;
-import java.util.Arrays;
 
 import org.apache.lucene.analysis.TokenFilter;
 import org.apache.lucene.analysis.TokenStream;
@@ -33,7 +32,6 @@ import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.CharsRef;
 import org.apache.lucene.util.CharsRefBuilder;
-import org.apache.lucene.util.RamUsageEstimator;
 import org.apache.lucene.util.fst.FST;
 
 /**
@@ -206,7 +204,7 @@ public final class SynonymFilter extends TokenFilter {
 
     public void add(char[] output, int offset, int len, int endOffset, int posLength) {
       if (count == outputs.length) {
-        outputs = Arrays.copyOf(outputs, ArrayUtil.oversize(1+count, RamUsageEstimator.NUM_BYTES_OBJECT_REF));
+        outputs = ArrayUtil.grow(outputs, count+1);
       }
       if (count == endOffsets.length) {
         final int[] next = new int[ArrayUtil.oversize(1+count, Integer.BYTES)];
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/WordnetSynonymParser.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/WordnetSynonymParser.java
index b74e37185d..a4183d711b 100644
--- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/WordnetSynonymParser.java
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/WordnetSynonymParser.java
@@ -21,9 +21,9 @@ import java.io.IOException;
 import java.io.LineNumberReader;
 import java.io.Reader;
 import java.text.ParseException;
-import java.util.Arrays;
 
 import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.CharsRef;
 import org.apache.lucene.util.CharsRefBuilder;
 
@@ -59,10 +59,7 @@ public class WordnetSynonymParser extends SynonymMap.Parser {
           synsetSize = 0;
         }
 
-        if (synset.length <= synsetSize+1) {
-          synset = Arrays.copyOf(synset, synset.length * 2);
-        }
-        
+        synset = ArrayUtil.grow(synset, synsetSize + 1);
         synset[synsetSize] = parseSynonym(line, new CharsRefBuilder());
         synsetSize++;
         lastSynSetID = synSetID;
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/blockterms/BlockTermsWriter.java b/lucene/codecs/src/java/org/apache/lucene/codecs/blockterms/BlockTermsWriter.java
index 9ed87b57a9..9de9d732a2 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/blockterms/BlockTermsWriter.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/blockterms/BlockTermsWriter.java
@@ -20,7 +20,6 @@ package org.apache.lucene.codecs.blockterms;
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 
 import org.apache.lucene.codecs.BlockTermState;
@@ -44,7 +43,6 @@ import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefBuilder;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.IOUtils;
-import org.apache.lucene.util.RamUsageEstimator;
 
 // TODO: currently we encode all terms between two indexed
 // terms as a block; but, we could decouple the two, ie
@@ -260,11 +258,9 @@ public class BlockTermsWriter extends FieldsConsumer implements Closeable {
         //System.out.println("  index term!");
       }
 
-      if (pendingTerms.length == pendingCount) {
-        pendingTerms = Arrays.copyOf(pendingTerms, ArrayUtil.oversize(pendingCount+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF));
-        for(int i=pendingCount;i<pendingTerms.length;i++) {
-          pendingTerms[i] = new TermEntry();
-        }
+      pendingTerms = ArrayUtil.grow(pendingTerms, pendingCount + 1);
+      for (int i = pendingCount; i < pendingTerms.length; i++) {
+        pendingTerms[i] = new TermEntry();
       }
       final TermEntry te = pendingTerms[pendingCount];
       te.term.copyBytes(text);
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.java b/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.java
index 2993727035..27d9dc9ab7 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextBKDWriter.java
@@ -505,7 +505,9 @@ final class SimpleTextBKDWriter implements Closeable {
 
       if (leafBlockFPs.size() > 0) {
         // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:
-        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));
+        final byte[] startValues = new byte[packedBytesLength];
+        System.arraycopy(leafValues, 0, startValues, 0, packedBytesLength);
+        leafBlockStartValues.add(startValues);
       }
       leafBlockFPs.add(out.getFilePointer());
       checkMaxLeafNodeCount(leafBlockFPs.size());
@@ -539,7 +541,8 @@ final class SimpleTextBKDWriter implements Closeable {
           return scratch;
         }
       };
-      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),
+      assert valuesInOrderAndBounds(leafCount, 0,
+          BytesRef.deepCopyOf(new BytesRef(leafValues, 0, packedBytesLength)).bytes,
           BytesRef.deepCopyOf(new BytesRef(leafValues, (leafCount - 1) * packedBytesLength, packedBytesLength)).bytes,
           packedValues, leafDocs, 0);
       writeLeafBlockPackedValues(out, commonPrefixLengths, leafCount, 0, packedValues);
@@ -1206,10 +1209,13 @@ final class SimpleTextBKDWriter implements Closeable {
       reader.getValue(mid, scratchBytesRef1);
       System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);
 
-      byte[] minSplitPackedValue = Arrays.copyOf(minPackedValue, packedBytesLength);
-      byte[] maxSplitPackedValue = Arrays.copyOf(maxPackedValue, packedBytesLength);
+      final byte[] minSplitPackedValue = new byte[packedBytesLength];
+      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);
       System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,
           minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);
+
+      final byte[] maxSplitPackedValue = new byte[packedBytesLength];
+      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);
       System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,
           maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);
 
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsIndexReader.java b/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsIndexReader.java
index 0685d79949..255cecdd32 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsIndexReader.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsIndexReader.java
@@ -21,7 +21,6 @@ import static org.apache.lucene.util.BitUtil.zigZagDecode;
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
@@ -71,15 +70,13 @@ public final class CompressingStoredFieldsIndexReader implements Cloneable, Acco
       if (numChunks == 0) {
         break;
       }
-      if (blockCount == docBases.length) {
-        final int newSize = ArrayUtil.oversize(blockCount + 1, 8);
-        docBases = Arrays.copyOf(docBases, newSize);
-        startPointers = Arrays.copyOf(startPointers, newSize);
-        avgChunkDocs = Arrays.copyOf(avgChunkDocs, newSize);
-        avgChunkSizes = Arrays.copyOf(avgChunkSizes, newSize);
-        docBasesDeltas = Arrays.copyOf(docBasesDeltas, newSize);
-        startPointersDeltas = Arrays.copyOf(startPointersDeltas, newSize);
-      }
+
+      docBases = ArrayUtil.grow(docBases, blockCount + 1);
+      startPointers = ArrayUtil.grow(startPointers, blockCount + 1);
+      avgChunkDocs = ArrayUtil.grow(avgChunkDocs, blockCount + 1);
+      avgChunkSizes = ArrayUtil.grow(avgChunkSizes, blockCount + 1);
+      docBasesDeltas = ArrayUtil.grow(docBasesDeltas, blockCount + 1);
+      startPointersDeltas = ArrayUtil.grow(startPointersDeltas, blockCount + 1);
 
       // doc bases
       docBases[blockCount] = fieldsIndexIn.readVInt();
@@ -102,12 +99,18 @@ public final class CompressingStoredFieldsIndexReader implements Cloneable, Acco
       ++blockCount;
     }
 
-    this.docBases = Arrays.copyOf(docBases, blockCount);
-    this.startPointers = Arrays.copyOf(startPointers, blockCount);
-    this.avgChunkDocs = Arrays.copyOf(avgChunkDocs, blockCount);
-    this.avgChunkSizes = Arrays.copyOf(avgChunkSizes, blockCount);
-    this.docBasesDeltas = Arrays.copyOf(docBasesDeltas, blockCount);
-    this.startPointersDeltas = Arrays.copyOf(startPointersDeltas, blockCount);
+    this.docBases = new int[blockCount];
+    System.arraycopy(docBases, 0, this.docBases, 0, blockCount);
+    this.startPointers = new long[blockCount];
+    System.arraycopy(startPointers, 0, this.startPointers, 0, blockCount);
+    this.avgChunkDocs = new int[blockCount];
+    System.arraycopy(avgChunkDocs, 0, this.avgChunkDocs, 0, blockCount);
+    this.avgChunkSizes = new long[blockCount];
+    System.arraycopy(avgChunkSizes, 0, this.avgChunkSizes, 0, blockCount);
+    this.docBasesDeltas = new PackedInts.Reader[blockCount];
+    System.arraycopy(docBasesDeltas, 0, this.docBasesDeltas, 0, blockCount);
+    this.startPointersDeltas = new PackedInts.Reader[blockCount];
+    System.arraycopy(startPointersDeltas, 0, this.startPointersDeltas, 0, blockCount);
   }
 
   private int block(int docID) {
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter.java
index 8cd8ccbc27..c0e62c1388 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingStoredFieldsWriter.java
@@ -19,7 +19,6 @@ package org.apache.lucene.codecs.compressing;
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 
 import org.apache.lucene.codecs.CodecUtil;
@@ -156,13 +155,10 @@ public final class CompressingStoredFieldsWriter extends StoredFieldsWriter {
 
   @Override
   public void finishDocument() throws IOException {
-    if (numBufferedDocs == this.numStoredFields.length) {
-      final int newLength = ArrayUtil.oversize(numBufferedDocs + 1, 4);
-      this.numStoredFields = Arrays.copyOf(this.numStoredFields, newLength);
-      endOffsets = Arrays.copyOf(endOffsets, newLength);
-    }
-    this.numStoredFields[numBufferedDocs] = numStoredFieldsInDoc;
+    numStoredFields = ArrayUtil.grow(numStoredFields, numBufferedDocs + 1);
+    numStoredFields[numBufferedDocs] = numStoredFieldsInDoc;
     numStoredFieldsInDoc = 0;
+    endOffsets = ArrayUtil.grow(endOffsets, numBufferedDocs + 1);
     endOffsets[numBufferedDocs] = bufferedDocs.getPosition();
     ++numBufferedDocs;
     if (triggerFlush()) {
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingTermVectorsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingTermVectorsWriter.java
index ee948c3e3e..e67569ea57 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingTermVectorsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingTermVectorsWriter.java
@@ -174,13 +174,11 @@ public final class CompressingTermVectorsWriter extends TermVectorsWriter {
         positionsBuf[posStart + totalPositions] = position;
       }
       if (hasOffsets) {
-        if (offStart + totalPositions == startOffsetsBuf.length) {
-          final int newLength = ArrayUtil.oversize(offStart + totalPositions, 4);
-          startOffsetsBuf = Arrays.copyOf(startOffsetsBuf, newLength);
-          lengthsBuf = Arrays.copyOf(lengthsBuf, newLength);
-        }
-        startOffsetsBuf[offStart + totalPositions] = startOffset;
-        lengthsBuf[offStart + totalPositions] = length;
+        int offsetPosition = offStart + totalPositions;
+        startOffsetsBuf = ArrayUtil.grow(startOffsetsBuf, offsetPosition + 1);
+        startOffsetsBuf[offsetPosition] = startOffset;
+        lengthsBuf = ArrayUtil.grow(lengthsBuf, offsetPosition + 1);
+        lengthsBuf[offsetPosition] = length;
       }
       if (hasPayloads) {
         if (payStart + totalPositions == payloadLengthsBuf.length) {
@@ -705,8 +703,12 @@ public final class CompressingTermVectorsWriter extends TermVectorsWriter {
       final int offStart = curField.offStart + curField.totalPositions;
       if (offStart + numProx > startOffsetsBuf.length) {
         final int newLength = ArrayUtil.oversize(offStart + numProx, 4);
-        startOffsetsBuf = Arrays.copyOf(startOffsetsBuf, newLength);
-        lengthsBuf = Arrays.copyOf(lengthsBuf, newLength);
+        int[] nextStartOffsetsBuf = new int[newLength];
+        System.arraycopy(startOffsetsBuf, 0, nextStartOffsetsBuf, 0, startOffsetsBuf.length);
+        startOffsetsBuf = nextStartOffsetsBuf;
+        final int[] nextLengthsBuf = new int[newLength];
+        System.arraycopy(lengthsBuf, 0, nextLengthsBuf, 0, lengthsBuf.length);
+        lengthsBuf = nextLengthsBuf;
       }
       int lastOffset = 0, startOffset, endOffset;
       for (int i = 0; i < numProx; ++i) {
diff --git a/lucene/core/src/java/org/apache/lucene/index/SortingLeafReader.java b/lucene/core/src/java/org/apache/lucene/index/SortingLeafReader.java
index d765b7c4f9..648784034b 100644
--- a/lucene/core/src/java/org/apache/lucene/index/SortingLeafReader.java
+++ b/lucene/core/src/java/org/apache/lucene/index/SortingLeafReader.java
@@ -890,8 +890,12 @@ class SortingLeafReader extends FilterLeafReader {
       while ((doc = in.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
         if (i == docs.length) {
           final int newLength = ArrayUtil.oversize(i + 1, 4);
-          docs = Arrays.copyOf(docs, newLength);
-          offsets = Arrays.copyOf(offsets, newLength);
+          int[] nextDocs = new int[newLength];
+          System.arraycopy(docs, 0, nextDocs, 0, docs.length);
+          docs = nextDocs;
+          long[] nextOffsets = new long[newLength];
+          System.arraycopy(offsets, 0, nextOffsets, 0, offsets.length);
+          offsets = nextOffsets;
         }
         docs[i] = docMap.oldToNew(doc);
         offsets[i] = out.getFilePointer();
diff --git a/lucene/core/src/java/org/apache/lucene/search/BlendedTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/BlendedTermQuery.java
index cca667575a..5c9135d3ac 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BlendedTermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BlendedTermQuery.java
@@ -101,11 +101,13 @@ public final class BlendedTermQuery extends Query {
 
     /** Build the {@link BlendedTermQuery}. */
     public BlendedTermQuery build() {
-      return new BlendedTermQuery(
-          Arrays.copyOf(terms, numTerms),
-          Arrays.copyOf(boosts, numTerms),
-          Arrays.copyOf(contexts, numTerms),
-          rewriteMethod);
+      final Term[] terms = new Term[numTerms];
+      final float[] boosts = new float[numTerms];
+      final TermStates[] contexts = new TermStates[numTerms];
+      System.arraycopy(this.terms, 0, terms, 0, numTerms);
+      System.arraycopy(this.boosts, 0, boosts, 0, numTerms);
+      System.arraycopy(this.contexts, 0, contexts, 0, numTerms);
+      return new BlendedTermQuery(terms, boosts, contexts, rewriteMethod);
     }
 
   }
@@ -263,7 +265,8 @@ public final class BlendedTermQuery extends Query {
 
   @Override
   public final Query rewrite(IndexReader reader) throws IOException {
-    final TermStates[] contexts = Arrays.copyOf(this.contexts, this.contexts.length);
+    final TermStates[] contexts = new TermStates[this.contexts.length];
+    System.arraycopy(this.contexts, 0, contexts, 0, contexts.length);
     for (int i = 0; i < contexts.length; ++i) {
       if (contexts[i] == null || contexts[i].wasBuiltFor(reader.getContext()) == false) {
         contexts[i] = TermStates.build(reader.getContext(), terms[i], true);
diff --git a/lucene/core/src/java/org/apache/lucene/search/CachingCollector.java b/lucene/core/src/java/org/apache/lucene/search/CachingCollector.java
index 3bed88dd99..91e5d48c91 100644
--- a/lucene/core/src/java/org/apache/lucene/search/CachingCollector.java
+++ b/lucene/core/src/java/org/apache/lucene/search/CachingCollector.java
@@ -18,7 +18,6 @@ package org.apache.lucene.search;
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 
 import org.apache.lucene.index.LeafReaderContext;
@@ -213,7 +212,9 @@ public abstract class CachingCollector extends FilterCollector {
     }
 
     protected void grow(int newLen) {
-      docs = Arrays.copyOf(docs, newLen);
+      int[] moreDocs = new int[newLen];
+      System.arraycopy(docs, 0, moreDocs, 0, docs.length);
+      docs = moreDocs;
     }
 
     protected void invalidate() {
@@ -250,7 +251,13 @@ public abstract class CachingCollector extends FilterCollector {
     }
 
     int[] cachedDocs() {
-      return docs == null ? null : Arrays.copyOf(docs, docCount);
+      if (docs == null) {
+        return null;
+      } else {
+        int[] cachedDocs = new int[docCount];
+        System.arraycopy(docs, 0, cachedDocs, 0, docCount);
+        return cachedDocs;
+      }
     }
 
   }
@@ -274,7 +281,9 @@ public abstract class CachingCollector extends FilterCollector {
     @Override
     protected void grow(int newLen) {
       super.grow(newLen);
-      scores = Arrays.copyOf(scores, newLen);
+      float[] moreScores = new float[newLen];
+      System.arraycopy(scores, 0, moreScores, 0, scores.length);
+      scores = moreScores;
     }
 
     @Override
@@ -290,7 +299,12 @@ public abstract class CachingCollector extends FilterCollector {
     }
 
     float[] cachedScores() {
-      return docs == null ? null : Arrays.copyOf(scores, docCount);
+      if (docs == null) {
+        return null;
+      }
+      float[] cachedScores = new float[docCount];
+      System.arraycopy(scores, 0, cachedScores, 0, docCount);
+      return cachedScores;
     }
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/MaxScoreCache.java b/lucene/core/src/java/org/apache/lucene/search/MaxScoreCache.java
index 17e4efc0c1..cd9c4ca599 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MaxScoreCache.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MaxScoreCache.java
@@ -53,7 +53,9 @@ final class MaxScoreCache {
     if (maxScoreCache.length < size) {
       int oldLength = maxScoreCache.length;
       maxScoreCache = ArrayUtil.grow(maxScoreCache, size);
-      maxScoreCacheUpTo = Arrays.copyOf(maxScoreCacheUpTo, maxScoreCache.length);
+      int[] nextScoreCacheUpTo = new int[maxScoreCache.length];
+      System.arraycopy(maxScoreCacheUpTo, 0, nextScoreCacheUpTo, 0, maxScoreCacheUpTo.length);
+      maxScoreCacheUpTo = nextScoreCacheUpTo;
       Arrays.fill(maxScoreCacheUpTo, oldLength, maxScoreCacheUpTo.length, -1);
     }
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
index 16642e51f1..019d8588f8 100644
--- a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
@@ -413,7 +413,9 @@ public class PhraseQuery extends Query {
           }
         }
         if (termUpTo > 0) {
-          return similarity.scorer(boost, searcher.collectionStatistics(field), Arrays.copyOf(termStats, termUpTo));
+          TermStatistics[] scoredStats = new TermStatistics[termUpTo];
+          System.arraycopy(termStats, 0, scoredStats, 0, termUpTo);
+          return similarity.scorer(boost, searcher.collectionStatistics(field), scoredStats);
         } else {
           return null; // no terms at all, we won't use similarity
         }
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
index 35c36d77c7..09701abb9a 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
@@ -18,7 +18,6 @@ package org.apache.lucene.search.spans;
 
 
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.Map;
 
 import org.apache.lucene.index.LeafReaderContext;
@@ -103,7 +102,9 @@ public abstract class SpanWeight extends Weight {
     }
     CollectionStatistics collectionStats = searcher.collectionStatistics(query.getField());
     if (termUpTo > 0) {
-      return similarity.scorer(boost, collectionStats, Arrays.copyOf(termStats, termUpTo));
+      TermStatistics[] scoredStats = new TermStatistics[termUpTo];
+      System.arraycopy(termStats, 0, scoredStats, 0, termUpTo);
+      return similarity.scorer(boost, collectionStats, scoredStats);
     } else {
       return null; // no terms at all exist, we won't use similarity
     }
diff --git a/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java b/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java
index 3c5897f6c8..fd24a18ebe 100644
--- a/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java
+++ b/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java
@@ -16,7 +16,7 @@
  */
 package org.apache.lucene.util;
 
-import java.util.Arrays;
+import java.lang.reflect.Array;
 import java.util.Comparator;
 
 /**
@@ -214,7 +214,14 @@ public final class ArrayUtil {
   public static <T> T[] grow(T[] array, int minSize) {
     assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
     if (array.length < minSize) {
-      return Arrays.copyOf(array, oversize(minSize, RamUsageEstimator.NUM_BYTES_OBJECT_REF));
+      final int newLength = oversize(minSize, RamUsageEstimator.NUM_BYTES_OBJECT_REF);
+      Class<? extends Object[]> type = array.getClass();
+      @SuppressWarnings("unchecked")
+      T[] copy = (type == Object[].class)
+          ? (T[]) new Object[newLength]
+          : (T[]) Array.newInstance(type.getComponentType(), newLength);
+      System.arraycopy(array, 0, copy, 0, array.length);
+      return copy;
     } else
       return array;
   }
@@ -222,7 +229,9 @@ public final class ArrayUtil {
   public static short[] grow(short[] array, int minSize) {
     assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
     if (array.length < minSize) {
-      return Arrays.copyOf(array, oversize(minSize, Short.BYTES));
+      short[] copy = new short[oversize(minSize, Short.BYTES)];
+      System.arraycopy(array, 0, copy, 0, array.length);
+      return copy;
     } else
       return array;
   }
@@ -234,7 +243,9 @@ public final class ArrayUtil {
   public static float[] grow(float[] array, int minSize) {
     assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
     if (array.length < minSize) {
-      return Arrays.copyOf(array, oversize(minSize, Float.BYTES));
+      float[] copy = new float[oversize(minSize, Float.BYTES)];
+      System.arraycopy(array, 0, copy, 0, array.length);
+      return copy;
     } else
       return array;
   }
@@ -246,7 +257,9 @@ public final class ArrayUtil {
   public static double[] grow(double[] array, int minSize) {
     assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
     if (array.length < minSize) {
-      return Arrays.copyOf(array, oversize(minSize, Double.BYTES));
+      double[] copy = new double[oversize(minSize, Double.BYTES)];
+      System.arraycopy(array, 0, copy, 0, array.length);
+      return copy;
     } else
       return array;
   }
@@ -258,7 +271,9 @@ public final class ArrayUtil {
   public static int[] grow(int[] array, int minSize) {
     assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
     if (array.length < minSize) {
-      return Arrays.copyOf(array, oversize(minSize, Integer.BYTES));
+      int[] copy = new int[oversize(minSize, Integer.BYTES)];
+      System.arraycopy(array, 0, copy, 0, array.length);
+      return copy;
     } else
       return array;
   }
@@ -270,7 +285,9 @@ public final class ArrayUtil {
   public static long[] grow(long[] array, int minSize) {
     assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
     if (array.length < minSize) {
-      return Arrays.copyOf(array, oversize(minSize, Long.BYTES));
+      long[] copy = new long[ oversize(minSize, Long.BYTES)];
+      System.arraycopy(array, 0, copy, 0, array.length);
+      return copy;
     } else
       return array;
   }
@@ -282,7 +299,9 @@ public final class ArrayUtil {
   public static byte[] grow(byte[] array, int minSize) {
     assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
     if (array.length < minSize) {
-      return Arrays.copyOf(array, oversize(minSize, Byte.BYTES));
+      byte[] copy = new byte[oversize(minSize, Byte.BYTES)];
+      System.arraycopy(array, 0, copy, 0, array.length);
+      return copy;
     } else
       return array;
   }
@@ -294,7 +313,9 @@ public final class ArrayUtil {
   public static char[] grow(char[] array, int minSize) {
     assert minSize >= 0: "size must be positive (got " + minSize + "): likely integer overflow?";
     if (array.length < minSize) {
-      return Arrays.copyOf(array, oversize(minSize, Character.BYTES));
+      char[] copy = new char[oversize(minSize, Character.BYTES)];
+      System.arraycopy(array, 0, copy, 0, array.length);
+      return copy;
     } else
       return array;
   }
diff --git a/lucene/core/src/java/org/apache/lucene/util/BytesRefBuilder.java b/lucene/core/src/java/org/apache/lucene/util/BytesRefBuilder.java
index 08fda910a5..f287c35808 100644
--- a/lucene/core/src/java/org/apache/lucene/util/BytesRefBuilder.java
+++ b/lucene/core/src/java/org/apache/lucene/util/BytesRefBuilder.java
@@ -17,8 +17,6 @@
 package org.apache.lucene.util;
 
 
-import java.util.Arrays;
-
 /**
  * A builder for {@link BytesRef} instances.
  * @lucene.internal
@@ -170,7 +168,9 @@ public class BytesRefBuilder {
    * Build a new {@link BytesRef} that has the same content as this buffer.
    */
   public BytesRef toBytesRef() {
-    return new BytesRef(Arrays.copyOf(ref.bytes, ref.length));
+    byte[] copy = new byte[ref.length];
+    System.arraycopy(ref.bytes, 0, copy, 0, ref.length);
+    return new BytesRef(copy);
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/util/CharsRefBuilder.java b/lucene/core/src/java/org/apache/lucene/util/CharsRefBuilder.java
index 09830e692c..73f664d19d 100644
--- a/lucene/core/src/java/org/apache/lucene/util/CharsRefBuilder.java
+++ b/lucene/core/src/java/org/apache/lucene/util/CharsRefBuilder.java
@@ -17,8 +17,6 @@
 package org.apache.lucene.util;
 
 
-import java.util.Arrays;
-
 /**
  * A builder for {@link CharsRef} instances.
  * @lucene.internal
@@ -153,7 +151,9 @@ public class CharsRefBuilder implements Appendable {
 
   /** Build a new {@link CharsRef} that has the same content as this builder. */
   public CharsRef toCharsRef() {
-    return new CharsRef(Arrays.copyOf(ref.chars, ref.length), 0, ref.length);
+    final char[] copy = new char[ref.length];
+    System.arraycopy(ref.chars, 0, copy, 0, ref.length);
+    return new CharsRef(copy, 0, ref.length);
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder.java b/lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder.java
index 954614b3ad..d5c2ec2e02 100644
--- a/lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder.java
+++ b/lucene/core/src/java/org/apache/lucene/util/DocIdSetBuilder.java
@@ -18,7 +18,6 @@ package org.apache.lucene.util;
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 
 import org.apache.lucene.index.PointValues;
@@ -226,7 +225,9 @@ public final class DocIdSetBuilder {
   }
 
   private void growBuffer(Buffer buffer, int additionalCapacity) {
-    buffer.array = Arrays.copyOf(buffer.array, buffer.array.length + additionalCapacity);
+    int[] copy = new int[buffer.array.length + additionalCapacity];
+    System.arraycopy(buffer.array, 0, copy, 0, buffer.array.length);
+    buffer.array = copy;
     totalAllocated += additionalCapacity;
   }
 
@@ -295,9 +296,12 @@ public final class DocIdSetBuilder {
     if (largestBuffer == null) {
       return new Buffer(1);
     }
-    int[] docs = largestBuffer.array;
-    if (docs.length < totalLength + 1) {
-      docs = Arrays.copyOf(docs, totalLength + 1);
+    final int[] docs;
+    if (largestBuffer.array.length < totalLength + 1) {
+      docs = new int[totalLength + 1];
+      System.arraycopy(largestBuffer.array, 0, docs, 0, largestBuffer.array.length);
+    } else {
+      docs = largestBuffer.array;
     }
     totalLength = largestBuffer.length;
     for (Buffer buffer : buffers) {
diff --git a/lucene/core/src/java/org/apache/lucene/util/PagedBytes.java b/lucene/core/src/java/org/apache/lucene/util/PagedBytes.java
index ad26f857e4..1c270f4a60 100644
--- a/lucene/core/src/java/org/apache/lucene/util/PagedBytes.java
+++ b/lucene/core/src/java/org/apache/lucene/util/PagedBytes.java
@@ -18,7 +18,6 @@ package org.apache.lucene.util;
 
 
 import java.io.IOException;
-import java.util.Arrays;
 
 import org.apache.lucene.store.DataInput;
 import org.apache.lucene.store.DataOutput;
@@ -62,7 +61,8 @@ public final class PagedBytes implements Accountable {
     private final long bytesUsedPerBlock;
 
     private Reader(PagedBytes pagedBytes) {
-      blocks = Arrays.copyOf(pagedBytes.blocks, pagedBytes.numBlocks);
+      blocks = new byte[pagedBytes.numBlocks][];
+      System.arraycopy(pagedBytes.blocks, 0, blocks, 0, pagedBytes.numBlocks);
       blockBits = pagedBytes.blockBits;
       blockMask = pagedBytes.blockMask;
       blockSize = pagedBytes.blockSize;
@@ -154,9 +154,7 @@ public final class PagedBytes implements Accountable {
   }
 
   private void addBlock(byte[] block) {
-    if (blocks.length == numBlocks) {
-      blocks = Arrays.copyOf(blocks, ArrayUtil.oversize(numBlocks, RamUsageEstimator.NUM_BYTES_OBJECT_REF));
-    }
+    blocks = ArrayUtil.grow(blocks, numBlocks + 1);
     blocks[numBlocks++] = block;
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/util/RoaringDocIdSet.java b/lucene/core/src/java/org/apache/lucene/util/RoaringDocIdSet.java
index 9709c30005..cebc4756e8 100644
--- a/lucene/core/src/java/org/apache/lucene/util/RoaringDocIdSet.java
+++ b/lucene/core/src/java/org/apache/lucene/util/RoaringDocIdSet.java
@@ -18,7 +18,6 @@ package org.apache.lucene.util;
 
 
 import java.io.IOException;
-import java.util.Arrays;
 
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.DocIdSetIterator;
@@ -73,7 +72,9 @@ public class RoaringDocIdSet extends DocIdSet {
         // Use sparse encoding
         assert denseBuffer == null;
         if (currentBlockCardinality > 0) {
-          sets[currentBlock] = new ShortArrayDocIdSet(Arrays.copyOf(buffer, currentBlockCardinality));
+          short[] docIDs = new short[currentBlockCardinality];
+          System.arraycopy(buffer, 0, docIDs, 0, currentBlockCardinality);
+          sets[currentBlock] = new ShortArrayDocIdSet(docIDs);
         }
       } else {
         assert denseBuffer != null;
diff --git a/lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet.java b/lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet.java
index 0324291fc7..016a731a64 100644
--- a/lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet.java
+++ b/lucene/core/src/java/org/apache/lucene/util/SparseFixedBitSet.java
@@ -18,7 +18,6 @@ package org.apache.lucene.util;
 
 
 import java.io.IOException;
-import java.util.Arrays;
 
 import org.apache.lucene.search.DocIdSetIterator;
 
@@ -372,7 +371,8 @@ public class SparseFixedBitSet extends BitSet implements Bits, Accountable {
       // fast path: if we currently have nothing in the block, just copy the data
       // this especially happens all the time if you call OR on an empty set
       indices[i4096] = index;
-      this.bits[i4096] = Arrays.copyOf(bits, nonZeroLongCount);
+      this.bits[i4096] = new long[nonZeroLongCount];
+      System.arraycopy(bits, 0, this.bits[i4096], 0, nonZeroLongCount);
       this.nonZeroLongCount += nonZeroLongCount;
       return;
     }
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java b/lucene/core/src/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java
index 704a6c4124..00dabaa953 100644
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java
@@ -136,9 +136,13 @@ public final class DaciukMihovAutomatonBuilder {
     State newState(int label) {
       assert Arrays.binarySearch(labels, label) < 0 : "State already has transition labeled: "
           + label;
-      
-      labels = Arrays.copyOf(labels, labels.length + 1);
-      states = Arrays.copyOf(states, states.length + 1);
+
+      int[] moreLabels = new int[labels.length + 1];
+      System.arraycopy(labels, 0, moreLabels, 0, labels.length);
+      labels = moreLabels;
+      State[] moreStates = new State[states.length + 1];
+      System.arraycopy(states, 0, moreStates, 0, states.length);
+      states = moreStates;
 
       labels[labels.length - 1] = label;
       return states[states.length - 1] = new State();
diff --git a/lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java b/lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java
index 0eece4223c..98d3fe9e83 100644
--- a/lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter.java
@@ -656,7 +656,9 @@ public class BKDWriter implements Closeable {
 
       if (leafBlockFPs.size() > 0) {
         // Save the first (minimum) value in each leaf block except the first, to build the split value index in the end:
-        leafBlockStartValues.add(Arrays.copyOf(leafValues, packedBytesLength));
+        final byte[] startValues = new byte[packedBytesLength];
+        System.arraycopy(leafValues, 0, startValues, 0, packedBytesLength);
+        leafBlockStartValues.add(startValues);
       }
       leafBlockFPs.add(out.getFilePointer());
       checkMaxLeafNodeCount(leafBlockFPs.size());
@@ -687,7 +689,8 @@ public class BKDWriter implements Closeable {
           return scratchBytesRef1;
         }
       };
-      assert valuesInOrderAndBounds(leafCount, 0, Arrays.copyOf(leafValues, packedBytesLength),
+      assert valuesInOrderAndBounds(leafCount, 0,
+          BytesRef.deepCopyOf(new BytesRef(leafValues, 0, packedBytesLength)).bytes,
           BytesRef.deepCopyOf(new BytesRef(leafValues, (leafCount - 1) * packedBytesLength, packedBytesLength)).bytes,
           packedValues, leafDocs, 0);
       writeLeafBlockPackedValues(scratchOut, commonPrefixLengths, leafCount, 0, packedValues);
@@ -1591,10 +1594,13 @@ public class BKDWriter implements Closeable {
       reader.getValue(mid, scratchBytesRef1);
       System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim, splitPackedValues, address + 1, bytesPerDim);
 
-      byte[] minSplitPackedValue = Arrays.copyOf(minPackedValue, packedBytesLength);
-      byte[] maxSplitPackedValue = Arrays.copyOf(maxPackedValue, packedBytesLength);
+      byte[] minSplitPackedValue = new byte[packedBytesLength];
+      System.arraycopy(minPackedValue, 0, minSplitPackedValue, 0, packedBytesLength);
       System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,
           minSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);
+
+      byte[] maxSplitPackedValue = new byte[packedBytesLength];
+      System.arraycopy(maxPackedValue, 0, maxSplitPackedValue, 0, packedBytesLength);
       System.arraycopy(scratchBytesRef1.bytes, scratchBytesRef1.offset + splitDim * bytesPerDim,
           maxSplitPackedValue, splitDim * bytesPerDim, bytesPerDim);
 
diff --git a/lucene/core/src/java/org/apache/lucene/util/bkd/HeapPointWriter.java b/lucene/core/src/java/org/apache/lucene/util/bkd/HeapPointWriter.java
index e102651ceb..19aee7761e 100644
--- a/lucene/core/src/java/org/apache/lucene/util/bkd/HeapPointWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/util/bkd/HeapPointWriter.java
@@ -18,7 +18,6 @@ package org.apache.lucene.util.bkd;
 
 import java.io.Closeable;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 
 import org.apache.lucene.util.ArrayUtil;
@@ -116,12 +115,18 @@ public final class HeapPointWriter implements PointWriter {
     if (docIDs.length == nextWrite) {
       int nextSize = Math.min(maxSize, ArrayUtil.oversize(nextWrite+1, Integer.BYTES));
       assert nextSize > nextWrite: "nextSize=" + nextSize + " vs nextWrite=" + nextWrite;
-      docIDs = Arrays.copyOf(docIDs, nextSize);
+      int[] nextDocIDs = new int[nextSize];
+      System.arraycopy(docIDs, 0, nextDocIDs, 0, docIDs.length);
+      docIDs = nextDocIDs;
       if (singleValuePerDoc == false) {
         if (ordsLong != null) {
-          ordsLong = Arrays.copyOf(ordsLong, nextSize);
+          long[] nextOrdsLong = new long[nextSize];
+          System.arraycopy(ordsLong, 0, nextOrdsLong, 0, ordsLong.length);
+          ordsLong = nextOrdsLong;
         } else {
-          ords = Arrays.copyOf(ords, nextSize);
+          int[] nextOrds = new int[nextSize];
+          System.arraycopy(ords, 0, nextOrds, 0, ords.length);
+          ords = nextOrds;
         }
       }
     }
diff --git a/lucene/core/src/java/org/apache/lucene/util/packed/DeltaPackedLongValues.java b/lucene/core/src/java/org/apache/lucene/util/packed/DeltaPackedLongValues.java
index 80534da890..58ee9ea039 100644
--- a/lucene/core/src/java/org/apache/lucene/util/packed/DeltaPackedLongValues.java
+++ b/lucene/core/src/java/org/apache/lucene/util/packed/DeltaPackedLongValues.java
@@ -17,8 +17,6 @@
 package org.apache.lucene.util.packed;
 
 
-import java.util.Arrays;
-
 import org.apache.lucene.util.RamUsageEstimator;
 import org.apache.lucene.util.packed.PackedInts.Reader;
 
@@ -70,8 +68,10 @@ class DeltaPackedLongValues extends PackedLongValues {
     public DeltaPackedLongValues build() {
       finish();
       pending = null;
-      final PackedInts.Reader[] values = Arrays.copyOf(this.values, valuesOff);
-      final long[] mins = Arrays.copyOf(this.mins, valuesOff);
+      final PackedInts.Reader[] values = new PackedInts.Reader[valuesOff];
+      System.arraycopy(this.values, 0, values, 0, valuesOff);
+      final long[] mins = new long[valuesOff];
+      System.arraycopy(this.mins, 0, mins, 0, valuesOff);
       final long ramBytesUsed = DeltaPackedLongValues.BASE_RAM_BYTES_USED
           + RamUsageEstimator.sizeOf(values) + RamUsageEstimator.sizeOf(mins);
       return new DeltaPackedLongValues(pageShift, pageMask, values, mins, size, ramBytesUsed);
@@ -94,7 +94,9 @@ class DeltaPackedLongValues extends PackedLongValues {
     void grow(int newBlockCount) {
       super.grow(newBlockCount);
       ramBytesUsed -= RamUsageEstimator.sizeOf(mins);
-      mins = Arrays.copyOf(mins, newBlockCount);
+      long[] moreMins = new long[newBlockCount];
+      System.arraycopy(mins, 0, moreMins, 0, mins.length);
+      mins = moreMins;
       ramBytesUsed += RamUsageEstimator.sizeOf(mins);
     }
 
diff --git a/lucene/core/src/java/org/apache/lucene/util/packed/MonotonicLongValues.java b/lucene/core/src/java/org/apache/lucene/util/packed/MonotonicLongValues.java
index 09b3ecd5cb..9116eeada4 100644
--- a/lucene/core/src/java/org/apache/lucene/util/packed/MonotonicLongValues.java
+++ b/lucene/core/src/java/org/apache/lucene/util/packed/MonotonicLongValues.java
@@ -17,8 +17,6 @@
 package org.apache.lucene.util.packed;
 
 
-import java.util.Arrays;
-
 import static org.apache.lucene.util.packed.MonotonicBlockPackedReader.expected;
 
 import org.apache.lucene.util.RamUsageEstimator;
@@ -72,9 +70,12 @@ class MonotonicLongValues extends DeltaPackedLongValues {
     public MonotonicLongValues build() {
       finish();
       pending = null;
-      final PackedInts.Reader[] values = Arrays.copyOf(this.values, valuesOff);
-      final long[] mins = Arrays.copyOf(this.mins, valuesOff);
-      final float[] averages = Arrays.copyOf(this.averages, valuesOff);
+      final PackedInts.Reader[] values = new PackedInts.Reader[valuesOff];
+      System.arraycopy(this.values, 0, values, 0, valuesOff);
+      final long[] mins = new long[valuesOff];
+      System.arraycopy(this.mins, 0, mins, 0, valuesOff);
+      final float[] averages = new float[valuesOff];
+      System.arraycopy(this.averages, 0, averages, 0, valuesOff);
       final long ramBytesUsed = MonotonicLongValues.BASE_RAM_BYTES_USED
           + RamUsageEstimator.sizeOf(values) + RamUsageEstimator.sizeOf(mins)
           + RamUsageEstimator.sizeOf(averages);
@@ -95,7 +96,9 @@ class MonotonicLongValues extends DeltaPackedLongValues {
     void grow(int newBlockCount) {
       super.grow(newBlockCount);
       ramBytesUsed -= RamUsageEstimator.sizeOf(averages);
-      averages = Arrays.copyOf(averages, newBlockCount);
+      float[] nextAverages = new float[newBlockCount];
+      System.arraycopy(averages, 0, nextAverages, 0, averages.length);
+      averages = nextAverages;
       ramBytesUsed += RamUsageEstimator.sizeOf(averages);
     }
 
diff --git a/lucene/core/src/java/org/apache/lucene/util/packed/PackedLongValues.java b/lucene/core/src/java/org/apache/lucene/util/packed/PackedLongValues.java
index 0daf0623f9..00e79f2488 100644
--- a/lucene/core/src/java/org/apache/lucene/util/packed/PackedLongValues.java
+++ b/lucene/core/src/java/org/apache/lucene/util/packed/PackedLongValues.java
@@ -19,8 +19,6 @@ package org.apache.lucene.util.packed;
 
 import static org.apache.lucene.util.packed.PackedInts.checkBlockSize;
 
-import java.util.Arrays;
-
 import org.apache.lucene.util.Accountable;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.LongValues;
@@ -194,7 +192,8 @@ public class PackedLongValues extends LongValues implements Accountable {
     public PackedLongValues build() {
       finish();
       pending = null;
-      final PackedInts.Reader[] values = Arrays.copyOf(this.values, valuesOff);
+      final PackedInts.Reader[] values = new PackedInts.Reader[valuesOff];
+      System.arraycopy(this.values, 0, values, 0, valuesOff);
       final long ramBytesUsed = PackedLongValues.BASE_RAM_BYTES_USED + RamUsageEstimator.sizeOf(values);
       return new PackedLongValues(pageShift, pageMask, values, size, ramBytesUsed);
     }
@@ -273,7 +272,9 @@ public class PackedLongValues extends LongValues implements Accountable {
 
     void grow(int newBlockCount) {
       ramBytesUsed -= RamUsageEstimator.shallowSizeOf(values);
-      values = Arrays.copyOf(values, newBlockCount);
+      PackedInts.Reader[] moreValues = new PackedInts.Reader[newBlockCount];
+      System.arraycopy(values, 0, moreValues, 0, values.length);
+      values = moreValues;
       ramBytesUsed += RamUsageEstimator.shallowSizeOf(values);
     }
 
diff --git a/lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode.java b/lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode.java
index ddc35492cc..9b5c1806c7 100644
--- a/lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode.java
+++ b/lucene/core/src/test/org/apache/lucene/codecs/compressing/AbstractTestCompressionMode.java
@@ -57,11 +57,13 @@ public abstract class AbstractTestCompressionMode extends LuceneTestCase {
   }
 
   static byte[] compress(Compressor compressor, byte[] decompressed, int off, int len) throws IOException {
-    byte[] compressed = new byte[len * 2 + 16]; // should be enough
-    ByteArrayDataOutput out = new ByteArrayDataOutput(compressed);
+    byte[] outBuffer = new byte[len * 2 + 16]; // should be enough
+    ByteArrayDataOutput out = new ByteArrayDataOutput(outBuffer);
     compressor.compress(decompressed, off, len, out);
     final int compressedLen = out.getPosition();
-    return Arrays.copyOf(compressed, compressedLen);
+    final byte[] compressed = new byte[compressedLen];
+    System.arraycopy(outBuffer, 0, compressed, 0, compressedLen);
+    return compressed;
   }
 
   byte[] decompress(byte[] compressed, int originalLength) throws IOException {
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestPerSegmentDeletes.java b/lucene/core/src/test/org/apache/lucene/index/TestPerSegmentDeletes.java
index 4da5059487..08a2fba5b8 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestPerSegmentDeletes.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestPerSegmentDeletes.java
@@ -18,7 +18,6 @@ package org.apache.lucene.index;
 
 
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.Map;
 import java.util.Random;
 
@@ -238,7 +237,9 @@ public class TestPerSegmentDeletes extends LuceneTestCase {
       docs = ArrayUtil.grow(docs, numDocs + 1);
       docs[numDocs + 1] = docID;
     }
-    return Arrays.copyOf(docs, numDocs);
+    int[] actualDocs = new int[numDocs];
+    System.arraycopy(docs, 0, actualDocs, 0, numDocs);
+    return actualDocs;
   }
 
   public static class RangeMergePolicy extends MergePolicy {
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java b/lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java
index a9e2891140..73e05a3240 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBoolean2.java
@@ -19,7 +19,6 @@ package org.apache.lucene.search;
 
 
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Random;
 
@@ -224,15 +223,15 @@ public class TestBoolean2 extends LuceneTestCase {
   };
 
   public void queriesTest(Query query, int[] expDocNrs) throws Exception {
-
     // adjust the expected doc numbers according to our filler docs
     if (0 < NUM_FILLER_DOCS) {
-      expDocNrs = Arrays.copyOf(expDocNrs, expDocNrs.length);
-      for (int i=0; i < expDocNrs.length; i++) {
-        expDocNrs[i] = PRE_FILLER_DOCS + ((NUM_FILLER_DOCS + 1) * expDocNrs[i]);
+      int[] copy = new int[expDocNrs.length];
+      for (int i = 0; i < expDocNrs.length; i++) {
+        copy[i] = PRE_FILLER_DOCS + ((NUM_FILLER_DOCS + 1) * expDocNrs[i]);
       }
+      expDocNrs = copy;
     }
-    
+
     final int topDocsToCheck = atLeast(1000);
     // The asserting searcher will sometimes return the bulk scorer and
     // sometimes return a default impl around the scorer so that we can
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java
index eb311284bc..0d8e848f99 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestPhraseQuery.java
@@ -731,7 +731,8 @@ public class TestPhraseQuery extends LuceneTestCase {
   public void testTopPhrases() throws IOException {
     Directory dir = newDirectory();
     IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());
-    String[] docs = Arrays.copyOf(DOCS, DOCS.length);
+    String[] docs = new String[DOCS.length];
+    System.arraycopy(DOCS, 0, docs, 0, DOCS.length);
     Collections.shuffle(Arrays.asList(docs), random());
     for (String value : DOCS) {
       Document doc = new Document();
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanationsWithFillerDocs.java b/lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanationsWithFillerDocs.java
index 9f506688c5..cc15d3ccb3 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanationsWithFillerDocs.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSimpleExplanationsWithFillerDocs.java
@@ -101,7 +101,9 @@ public class TestSimpleExplanationsWithFillerDocs extends TestSimpleExplanations
   @Override
   public void qtest(Query q, int[] expDocNrs) throws Exception {
 
-    expDocNrs = Arrays.copyOf(expDocNrs, expDocNrs.length);
+    int[] copy = new int[expDocNrs.length];
+    System.arraycopy(expDocNrs, 0, copy, 0, expDocNrs.length);
+    expDocNrs = copy;
     for (int i=0; i < expDocNrs.length; i++) {
       expDocNrs[i] = PRE_FILLER_DOCS + ((NUM_FILLER_DOCS + 1) * expDocNrs[i]);
     }
diff --git a/lucene/core/src/test/org/apache/lucene/util/BaseSortTestCase.java b/lucene/core/src/test/org/apache/lucene/util/BaseSortTestCase.java
index 96c6db4865..2ca49ce28e 100644
--- a/lucene/core/src/test/org/apache/lucene/util/BaseSortTestCase.java
+++ b/lucene/core/src/test/org/apache/lucene/util/BaseSortTestCase.java
@@ -48,7 +48,8 @@ public abstract class BaseSortTestCase extends LuceneTestCase {
 
   public void assertSorted(Entry[] original, Entry[] sorted) {
     assertEquals(original.length, sorted.length);
-    Entry[] actuallySorted = Arrays.copyOf(original, original.length);
+    Entry[] actuallySorted = new Entry[original.length];
+    System.arraycopy(original, 0, actuallySorted, 0, original.length);
     Arrays.sort(actuallySorted);
     for (int i = 0; i < original.length; ++i) {
       assertEquals(actuallySorted[i].value, sorted[i].value);
diff --git a/lucene/core/src/test/org/apache/lucene/util/StressRamUsageEstimator.java b/lucene/core/src/test/org/apache/lucene/util/StressRamUsageEstimator.java
index 7a2712fcbd..5fd6487ea7 100644
--- a/lucene/core/src/test/org/apache/lucene/util/StressRamUsageEstimator.java
+++ b/lucene/core/src/test/org/apache/lucene/util/StressRamUsageEstimator.java
@@ -17,8 +17,6 @@
 package org.apache.lucene.util;
 
 
-import java.util.Arrays;
-
 /**
  * Estimates how {@link RamUsageEstimator} estimates physical memory consumption
  * of Java objects. 
@@ -85,10 +83,11 @@ public class StressRamUsageEstimator extends LuceneTestCase {
         if (estimated > 50 * RamUsageEstimator.ONE_MB) {
           break;
         }
-
         // Make another batch of objects.
-        Object[] seg =  new Object[10000];
-        all = Arrays.copyOf(all, all.length + 1);
+        Object[] seg = new Object[10000];
+        Object[][] next = new Object[all.length + 1][];
+        System.arraycopy(all, 0, next, 0, all.length);
+        all = next;
         all[all.length - 1] = seg;
         for (int i = 0; i < seg.length; i++) {
           seg[i] = new byte[random().nextInt(7)];
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestLSBRadixSorter.java b/lucene/core/src/test/org/apache/lucene/util/TestLSBRadixSorter.java
index ba8bd021d6..0414b796af 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestLSBRadixSorter.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestLSBRadixSorter.java
@@ -37,7 +37,8 @@ public class TestLSBRadixSorter extends LuceneTestCase {
   }
 
   public void test(LSBRadixSorter sorter, int[] arr, int len) {
-    final int[] expected = Arrays.copyOf(arr, len);
+    final int[] expected = new int[len];
+    System.arraycopy(arr, 0, expected, 0, len);
     Arrays.sort(expected);
 
     int numBits = 0;
@@ -50,7 +51,8 @@ public class TestLSBRadixSorter extends LuceneTestCase {
     }
 
     sorter.sort(numBits, arr, len);
-    final int[] actual = Arrays.copyOf(arr, len);
+    final int[] actual = new int[len];
+    System.arraycopy(arr, 0, actual, 0, len);
     assertArrayEquals(expected, actual);
   }
 
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestMSBRadixSorter.java b/lucene/core/src/test/org/apache/lucene/util/TestMSBRadixSorter.java
index 52eb494711..478b87571f 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestMSBRadixSorter.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestMSBRadixSorter.java
@@ -23,7 +23,8 @@ import java.util.Set;
 public class TestMSBRadixSorter extends LuceneTestCase {
 
   private void test(BytesRef[] refs, int len) {
-    BytesRef[] expected = Arrays.copyOf(refs, len);
+    BytesRef[] expected = new BytesRef[len];
+    System.arraycopy(refs, 0, expected, 0, len);
     Arrays.sort(expected);
 
     int maxLength = 0;
@@ -63,7 +64,8 @@ public class TestMSBRadixSorter extends LuceneTestCase {
         refs[j] = tmp;
       }
     }.sort(0, len);
-    BytesRef[] actual = Arrays.copyOf(refs, len);
+    BytesRef[] actual = new BytesRef[len];
+    System.arraycopy(refs, 0, actual, 0, len);
     assertArrayEquals(expected, actual);
   }
 
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestStringMSBRadixSorter.java b/lucene/core/src/test/org/apache/lucene/util/TestStringMSBRadixSorter.java
index c83ff67640..8f6e37904a 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestStringMSBRadixSorter.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestStringMSBRadixSorter.java
@@ -21,7 +21,8 @@ import java.util.Arrays;
 public class TestStringMSBRadixSorter extends LuceneTestCase {
 
   private void test(BytesRef[] refs, int len) {
-    BytesRef[] expected = Arrays.copyOf(refs, len);
+    BytesRef[] expected = new BytesRef[len];
+    System.arraycopy(refs, 0, expected, 0, len);
     Arrays.sort(expected);
 
     new StringMSBRadixSorter() {
@@ -38,7 +39,8 @@ public class TestStringMSBRadixSorter extends LuceneTestCase {
         refs[j] = tmp;
       }
     }.sort(0, len);
-    BytesRef[] actual = Arrays.copyOf(refs, len);
+    BytesRef[] actual = new BytesRef[len];
+    System.arraycopy(refs, 0, actual, 0, len);
     assertArrayEquals(expected, actual);
   }
 
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalQuery.java b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalQuery.java
index 306c05973c..ffc543a9b0 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/intervals/IntervalQuery.java
@@ -18,7 +18,6 @@
 package org.apache.lucene.search.intervals;
 
 import java.io.IOException;
-import java.util.Arrays;
 import java.util.HashSet;
 import java.util.Objects;
 import java.util.Set;
@@ -89,7 +88,9 @@ public final class IntervalQuery extends Query {
       return null;
     }
     CollectionStatistics collectionStats = searcher.collectionStatistics(field);
-    return searcher.getSimilarity().scorer(boost, collectionStats, Arrays.copyOf(termStats, termUpTo));
+    final TermStatistics[] scoredStats = new TermStatistics[termUpTo];
+    System.arraycopy(termStats, 0, scoredStats, 0, termUpTo);
+    return searcher.getSimilarity().scorer(boost, collectionStats, scoredStats);
   }
 
   @Override
diff --git a/lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint.java b/lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint.java
index 0bcb3f8b84..66f2e523de 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint.java
@@ -78,18 +78,19 @@ public class TestHalfFloatPoint extends LuceneTestCase {
   }
 
   public void testRounding() {
-    float[] values = new float[0];
+    float[] buffer = new float[0];
     int o = 0;
     for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {
       float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);
       if (Float.isFinite(v)) {
-        if (o == values.length) {
-          values = ArrayUtil.grow(values);
+        if (o == buffer.length) {
+          buffer = ArrayUtil.grow(buffer);
         }
-        values[o++] = v;
+        buffer[o++] = v;
       }
     }
-    values = Arrays.copyOf(values, o);
+    float[] values = new float[o];
+    System.arraycopy(buffer, 0, values, 0, o);
 
     int iters = atLeast(1000000);
     for (int iter = 0; iter < iters; ++iter) {
diff --git a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java
index 3e3b2e2abc..3aba3179d1 100644
--- a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java
+++ b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java
@@ -18,7 +18,6 @@ package org.apache.lucene.spatial;
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 
 import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;
@@ -107,7 +106,8 @@ public class DistanceStrategyTest extends StrategyTestCase {
 
   void checkDistValueSource(Point pt, float... distances) throws IOException {
     float multiplier = random().nextFloat() * 100f;
-    float[] dists2 = Arrays.copyOf(distances, distances.length);
+    float[] dists2 = new float[distances.length];
+    System.arraycopy(distances, 0, dists2, 0, distances.length);
     for (int i = 0; i < dists2.length; i++) {
       dists2[i] *= multiplier;
     }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/BlockScoreQueryWrapper.java b/lucene/test-framework/src/java/org/apache/lucene/search/BlockScoreQueryWrapper.java
index 3b9a740a44..c79569a309 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/BlockScoreQueryWrapper.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/BlockScoreQueryWrapper.java
@@ -97,10 +97,8 @@ public final class BlockScoreQueryWrapper extends Query {
         DocIdSetIterator it = inScorer.iterator();
         int i = 1;
         for (int doc = it.nextDoc(); ; doc = it.nextDoc()) {
-          if (i == tmpDocs.length) {
-            tmpDocs = ArrayUtil.grow(tmpDocs);
-            tmpScores = Arrays.copyOf(tmpScores, tmpDocs.length);
-          }
+          tmpDocs = ArrayUtil.grow(tmpDocs, i + 1);
+          tmpScores = ArrayUtil.grow(tmpScores, i + 1);
           tmpDocs[i] = doc;
           if (doc == DocIdSetIterator.NO_MORE_DOCS) {
             i++;
@@ -109,8 +107,10 @@ public final class BlockScoreQueryWrapper extends Query {
           tmpScores[i] = inScorer.score();
           i++;
         }
-        final int[] docs = Arrays.copyOf(tmpDocs, i);
-        final float[] scores = Arrays.copyOf(tmpScores, i);
+        final int[] docs = new int[i];
+        System.arraycopy(tmpDocs, 0, docs, 0, i);
+        final float[] scores = new float[i];
+        System.arraycopy(tmpScores, 0, scores, 0, i);
 
         return new Scorer(inWeight) {
 
diff --git a/lucene/test-framework/src/java/org/apache/lucene/util/automaton/AutomatonTestUtil.java b/lucene/test-framework/src/java/org/apache/lucene/util/automaton/AutomatonTestUtil.java
index 8ef4febea9..d16140faab 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/util/automaton/AutomatonTestUtil.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/util/automaton/AutomatonTestUtil.java
@@ -17,7 +17,6 @@
 package org.apache.lucene.util.automaton;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
@@ -254,7 +253,9 @@ public class AutomatonTestUtil {
         s = t.dest;
       }
 
-      return Arrays.copyOf(codePoints, codepointCount);
+      final int[] result = new int[codepointCount];
+      System.arraycopy(codePoints, 0, result, 0, codepointCount);
+      return result;
     }
   }
 
diff --git a/lucene/tools/forbiddenApis/lucene.txt b/lucene/tools/forbiddenApis/lucene.txt
index a1801c4bfd..59952653a0 100644
--- a/lucene/tools/forbiddenApis/lucene.txt
+++ b/lucene/tools/forbiddenApis/lucene.txt
@@ -38,4 +38,16 @@ java.util.Arrays#copyOfRange(float[],int,int)
 java.util.Arrays#copyOfRange(double[],int,int)
 java.util.Arrays#copyOfRange(boolean[],int,int)
 java.util.Arrays#copyOfRange(java.lang.Object[],int,int)
-java.util.Arrays#copyOfRange(java.lang.Object[],int,int,java.lang.Class)
\ No newline at end of file
+java.util.Arrays#copyOfRange(java.lang.Object[],int,int,java.lang.Class)
+
+@defaultMessage Prefer using System#arraycopy as Arrays#copyOf fills zeros for bad bounds
+java.util.Arrays#copyOf(byte[],int)
+java.util.Arrays#copyOf(char[],int)
+java.util.Arrays#copyOf(short[],int)
+java.util.Arrays#copyOf(int[],int)
+java.util.Arrays#copyOf(long[],int)
+java.util.Arrays#copyOf(float[],int)
+java.util.Arrays#copyOf(double[],int)
+java.util.Arrays#copyOf(boolean[],int)
+java.util.Arrays#copyOf(java.lang.Object[],int)
+java.util.Arrays#copyOf(java.lang.Object[],int,java.lang.Class)
