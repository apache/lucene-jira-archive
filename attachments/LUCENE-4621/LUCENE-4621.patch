Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 1420923)
+++ lucene/CHANGES.txt	(working copy)
@@ -90,6 +90,12 @@
   FacetArrays no longer takes those allocators; if you need to reuse the arrays,
   you should use ReusingFacetArrays. (Shai Erera, Gilad Barkai)
 
+* LUCENE-4621: FacetIndexingParams is now a concrete class (instead of DefaultFIP).
+  Also, the entire IndexingParams chain is now immutable. If you need to override
+  a setting, you should extend the relevant class.
+  Additionally, FacetSearchParams is now immutable, and requires all FacetRequests
+  to speified at initialization time. (Shai Erera)
+  
 New Features
 
 * LUCENE-4226: New experimental StoredFieldsFormat that compresses chunks of
Index: lucene/facet/src/examples/org/apache/lucene/facet/example/adaptive/AdaptiveSearcher.java
===================================================================
--- lucene/facet/src/examples/org/apache/lucene/facet/example/adaptive/AdaptiveSearcher.java	(revision 1420923)
+++ lucene/facet/src/examples/org/apache/lucene/facet/example/adaptive/AdaptiveSearcher.java	(working copy)
@@ -2,16 +2,6 @@
 
 import java.util.List;
 
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TopScoreDocCollector;
-import org.apache.lucene.store.Directory;
-
-import org.apache.lucene.search.MultiCollector;
 import org.apache.lucene.facet.example.ExampleUtils;
 import org.apache.lucene.facet.example.simple.SimpleUtils;
 import org.apache.lucene.facet.search.AdaptiveFacetsAccumulator;
@@ -22,6 +12,15 @@
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MultiCollector;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TopScoreDocCollector;
+import org.apache.lucene.store.Directory;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -78,8 +77,8 @@
     ScoredDocIdCollector docIdsCollecor = ScoredDocIdCollector.create(indexReader.maxDoc(), false);
     
     // Faceted search parameters indicate which facets are we interested in 
-    FacetSearchParams facetSearchParams = new FacetSearchParams();
-    facetSearchParams.addFacetRequest(new CountFacetRequest(new CategoryPath("root","a"), 10));
+    FacetSearchParams facetSearchParams = new FacetSearchParams(
+        new CountFacetRequest(new CategoryPath("root", "a"), 10));
     
     // search, into both collectors. note: in case only facets accumulation 
     // is required, the topDocCollector part can be totally discarded
Index: lucene/facet/src/examples/org/apache/lucene/facet/example/association/AssociationUtils.java
===================================================================
--- lucene/facet/src/examples/org/apache/lucene/facet/example/association/AssociationUtils.java	(revision 1420923)
+++ lucene/facet/src/examples/org/apache/lucene/facet/example/association/AssociationUtils.java	(working copy)
@@ -4,7 +4,7 @@
 import org.apache.lucene.facet.enhancements.association.AssociationFloatProperty;
 import org.apache.lucene.facet.enhancements.association.AssociationIntProperty;
 import org.apache.lucene.facet.enhancements.association.AssociationProperty;
-import org.apache.lucene.facet.enhancements.params.DefaultEnhancementsIndexingParams;
+import org.apache.lucene.facet.enhancements.params.EnhancementsIndexingParams;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 
 /*
@@ -73,7 +73,7 @@
    * Indexing Params: the indexing params to use when dealing with
    * associations.
    */
-  public static final DefaultEnhancementsIndexingParams assocIndexingParams = 
-    new DefaultEnhancementsIndexingParams(new AssociationEnhancement());
+  public static final EnhancementsIndexingParams assocIndexingParams = new EnhancementsIndexingParams(
+      new AssociationEnhancement());
 
 }
Index: lucene/facet/src/examples/org/apache/lucene/facet/example/merge/TaxonomyMergeUtils.java
===================================================================
--- lucene/facet/src/examples/org/apache/lucene/facet/example/merge/TaxonomyMergeUtils.java	(revision 1420923)
+++ lucene/facet/src/examples/org/apache/lucene/facet/example/merge/TaxonomyMergeUtils.java	(working copy)
@@ -3,6 +3,13 @@
 import java.io.IOException;
 import java.util.List;
 
+import org.apache.lucene.facet.example.ExampleUtils;
+import org.apache.lucene.facet.index.OrdinalMappingAtomicReader;
+import org.apache.lucene.facet.index.params.FacetIndexingParams;
+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.DiskOrdinalMap;
+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.MemoryOrdinalMap;
+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.OrdinalMap;
 import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.AtomicReaderContext;
 import org.apache.lucene.index.DirectoryReader;
@@ -11,15 +18,6 @@
 import org.apache.lucene.index.MultiReader;
 import org.apache.lucene.store.Directory;
 
-import org.apache.lucene.facet.example.ExampleUtils;
-import org.apache.lucene.facet.index.OrdinalMappingAtomicReader;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
-import org.apache.lucene.facet.index.params.FacetIndexingParams;
-import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
-import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.DiskOrdinalMap;
-import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.MemoryOrdinalMap;
-import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.OrdinalMap;
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -88,7 +86,7 @@
     destTaxWriter.addTaxonomy(srcTaxDir, map);
 
     int ordinalMap[] = map.getMap();
-    FacetIndexingParams params = new DefaultFacetIndexingParams();
+    FacetIndexingParams params = FacetIndexingParams.ALL_PARENTS;
 
     DirectoryReader reader = DirectoryReader.open(srcIndexDir, -1);
     List<AtomicReaderContext> leaves = reader.leaves();
Index: lucene/facet/src/examples/org/apache/lucene/facet/example/multiCL/MultiCLIndexer.java
===================================================================
--- lucene/facet/src/examples/org/apache/lucene/facet/example/multiCL/MultiCLIndexer.java	(revision 1420923)
+++ lucene/facet/src/examples/org/apache/lucene/facet/example/multiCL/MultiCLIndexer.java	(working copy)
@@ -1,7 +1,9 @@
 package org.apache.lucene.facet.example.multiCL;
 
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
 
 import org.apache.lucene.document.Document;
@@ -74,22 +76,18 @@
       + "reprehenderit qui in ea voluptate velit esse quam nihil molestiae "
       + "consequatur vel illum qui dolorem eum fugiat quo voluptas nulla pariatur";
   // PerDimensionIndexingParams for multiple category lists
-  public static PerDimensionIndexingParams MULTI_IPARAMS = new PerDimensionIndexingParams();
+  public static final PerDimensionIndexingParams MULTI_IPARAMS;
 
   // Initialize PerDimensionIndexingParams
   static {
-    MULTI_IPARAMS.addCategoryListParams(new CategoryPath("0"),
-        new CategoryListParams(new Term("$Digits", "Zero")));
-    MULTI_IPARAMS.addCategoryListParams(new CategoryPath("1"),
-        new CategoryListParams(new Term("$Digits", "One")));
-    MULTI_IPARAMS.addCategoryListParams(new CategoryPath("2"),
-        new CategoryListParams(new Term("$Digits", "Two")));
-    MULTI_IPARAMS.addCategoryListParams(new CategoryPath("3"),
-        new CategoryListParams(new Term("$Digits", "Three")));
-    MULTI_IPARAMS.addCategoryListParams(new CategoryPath("4"),
-        new CategoryListParams(new Term("$Digits", "Four")));
-    MULTI_IPARAMS.addCategoryListParams(new CategoryPath("5"),
-        new CategoryListParams(new Term("$Digits", "Five")));
+    Map<CategoryPath, CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
+    paramsMap.put(new CategoryPath("0"), new CategoryListParams(new Term("$Digits", "Zero")));
+    paramsMap.put(new CategoryPath("1"), new CategoryListParams(new Term("$Digits", "One")));
+    paramsMap.put(new CategoryPath("2"), new CategoryListParams(new Term("$Digits", "Two")));
+    paramsMap.put(new CategoryPath("3"), new CategoryListParams(new Term("$Digits", "Three")));
+    paramsMap.put(new CategoryPath("4"), new CategoryListParams(new Term("$Digits", "Four")));
+    paramsMap.put(new CategoryPath("5"), new CategoryListParams(new Term("$Digits", "Five")));
+    MULTI_IPARAMS = new PerDimensionIndexingParams(paramsMap);
   }
   
   /**
Index: lucene/facet/src/examples/org/apache/lucene/facet/example/multiCL/MultiCLSearcher.java
===================================================================
--- lucene/facet/src/examples/org/apache/lucene/facet/example/multiCL/MultiCLSearcher.java	(revision 1420923)
+++ lucene/facet/src/examples/org/apache/lucene/facet/example/multiCL/MultiCLSearcher.java	(working copy)
@@ -1,5 +1,6 @@
 package org.apache.lucene.facet.example.multiCL;
 
+import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.lucene.index.DirectoryReader;
@@ -17,6 +18,7 @@
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.FacetsCollector;
 import org.apache.lucene.facet.search.params.CountFacetRequest;
+import org.apache.lucene.facet.search.params.FacetRequest;
 import org.apache.lucene.facet.search.params.FacetSearchParams;
 import org.apache.lucene.facet.search.results.FacetResult;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
@@ -91,17 +93,14 @@
     Query q = new TermQuery(new Term(SimpleUtils.TEXT, "Quis"));
     ExampleUtils.log("Query: " + q);
 
-    TopScoreDocCollector topDocsCollector = TopScoreDocCollector.create(10,
-        true);
+    TopScoreDocCollector topDocsCollector = TopScoreDocCollector.create(10, true);
 
     // Faceted search parameters indicate which facets are we interested in
-    FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);
-    facetSearchParams.addFacetRequest(new CountFacetRequest(
-        new CategoryPath("5"), 10));
-    facetSearchParams.addFacetRequest(new CountFacetRequest(
-        new CategoryPath("5", "5"), 10));
-    facetSearchParams.addFacetRequest(new CountFacetRequest(
-        new CategoryPath("6", "2"), 10));
+    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
+    facetRequests.add(new CountFacetRequest(new CategoryPath("5"), 10));
+    facetRequests.add(new CountFacetRequest(new CategoryPath("5", "5"), 10));
+    facetRequests.add(new CountFacetRequest(new CategoryPath("6", "2"), 10));
+    FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);
 
     // Facets collector is the simplest interface for faceted search.
     // It provides faceted search functions that are sufficient to many
Index: lucene/facet/src/examples/org/apache/lucene/facet/example/simple/SimpleSearcher.java
===================================================================
--- lucene/facet/src/examples/org/apache/lucene/facet/example/simple/SimpleSearcher.java	(revision 1420923)
+++ lucene/facet/src/examples/org/apache/lucene/facet/example/simple/SimpleSearcher.java	(working copy)
@@ -1,18 +1,10 @@
 package org.apache.lucene.facet.example.simple;
 
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TopScoreDocCollector;
-
-import org.apache.lucene.search.MultiCollector;
 import org.apache.lucene.facet.example.ExampleUtils;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.DrillDown;
 import org.apache.lucene.facet.search.FacetsCollector;
@@ -23,6 +15,13 @@
 import org.apache.lucene.facet.search.results.FacetResultNode;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MultiCollector;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TopScoreDocCollector;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -101,16 +100,11 @@
     TopScoreDocCollector topDocsCollector = TopScoreDocCollector.create(10, true);
 
     if (indexingParams == null) {
-      indexingParams = new DefaultFacetIndexingParams();
+      indexingParams = FacetIndexingParams.ALL_PARENTS;
     }
     
     // Faceted search parameters indicate which facets are we interested in
-    FacetSearchParams facetSearchParams = new FacetSearchParams(indexingParams);
-    
-    // Add the facet requests of interest to the search params
-    for (FacetRequest frq : facetRequests) {
-      facetSearchParams.addFacetRequest(frq);
-    }
+    FacetSearchParams facetSearchParams = new FacetSearchParams(Arrays.asList(facetRequests), indexingParams);
 
     FacetsCollector facetsCollector = new FacetsCollector(facetSearchParams, indexReader, taxoReader);
 
@@ -138,7 +132,7 @@
   public static List<FacetResult> searchWithDrillDown(IndexReader indexReader,
       TaxonomyReader taxoReader) throws Exception {
 
-    final FacetIndexingParams indexingParams = new DefaultFacetIndexingParams();
+    final FacetIndexingParams indexingParams = FacetIndexingParams.ALL_PARENTS;
     
     // base query the user is interested in
     Query baseQuery = new TermQuery(new Term(SimpleUtils.TEXT, "white"));
Index: lucene/facet/src/java/org/apache/lucene/facet/doc-files/userguide.html
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/doc-files/userguide.html	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/doc-files/userguide.html	(working copy)
@@ -538,7 +538,7 @@
 forms: category-tokens (for drill-down) and category-list-tokens (for
 accumulation). This parameter allows to specify, for each category, the
 Lucene term used for maintaining the category-list-tokens for that category.
-The default implementation in <code>DefaultFacetIndexingParams</code> maintains
+The default implementation in <code>FacetIndexingParams</code> maintains
 this information for all categories under the same special dedicated term.
 One case where it is needed to maintain two categories in separate category
 lists, is when it is known that at search time it would be required to use
@@ -548,7 +548,7 @@
 for example, the partition size is set to 1000, a distinct sub-term is used for
 maintaining each 1000 categories, e.g. term1 for categories 0 to 999, term2
 for categories 1000 to 1999, etc. The default implementation in
-<code>DefaultFacetIndexingParams</code> maintains category lists in a single
+<code>FacetIndexingParams</code> maintains category lists in a single
 partition, hence it defines the partition size as <code>Integer.MAX_VALUE</code>. The
 importance of this parameter is on allowing to handle very large
 taxonomies without exhausting RAM resources. This is because at facet
Index: lucene/facet/src/java/org/apache/lucene/facet/enhancements/CategoryEnhancement.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/enhancements/CategoryEnhancement.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/enhancements/CategoryEnhancement.java	(working copy)
@@ -121,7 +121,7 @@
    *         {@link CategoryParentsStream}, or {@code null} if there is no such
    *         property.
    */
-  Class<? extends CategoryProperty> getRetainableProperty();
+  CategoryProperty getRetainableProperty();
   
   /**
    * Category enhancements must override {@link Object#equals(Object)}, as it is
Index: lucene/facet/src/java/org/apache/lucene/facet/enhancements/EnhancementsDocumentBuilder.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/enhancements/EnhancementsDocumentBuilder.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/enhancements/EnhancementsDocumentBuilder.java	(working copy)
@@ -53,13 +53,12 @@
 
   @Override
   protected TokenStream getParentsStream(CategoryAttributesStream categoryAttributesStream) {
-    List<Class<? extends CategoryProperty>> toRetainList = ((EnhancementsIndexingParams) indexingParams)
-        .getRetainableProperties();
+    List<CategoryProperty> toRetainList = ((EnhancementsIndexingParams) indexingParams).getRetainableProperties();
     if (toRetainList != null) {
       CategoryParentsStream categoryParentsStream = new CategoryParentsStream(
           categoryAttributesStream, taxonomyWriter, indexingParams);
-      for (Class<? extends CategoryProperty> toRetain : toRetainList) {
-        categoryParentsStream.addRetainableProperty(toRetain);
+      for (CategoryProperty toRetain : toRetainList) {
+        categoryParentsStream.addRetainableProperty(toRetain.getClass());
       }
       return categoryParentsStream;
     }
Index: lucene/facet/src/java/org/apache/lucene/facet/enhancements/association/AssociationEnhancement.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/enhancements/association/AssociationEnhancement.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/enhancements/association/AssociationEnhancement.java	(working copy)
@@ -152,7 +152,7 @@
   }
 
   @Override
-  public Class<? extends CategoryProperty> getRetainableProperty() {
+  public CategoryProperty getRetainableProperty() {
     return null;
   }
 
Index: lucene/facet/src/java/org/apache/lucene/facet/enhancements/params/DefaultEnhancementsIndexingParams.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/enhancements/params/DefaultEnhancementsIndexingParams.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/enhancements/params/DefaultEnhancementsIndexingParams.java	(working copy)
@@ -1,101 +0,0 @@
-package org.apache.lucene.facet.enhancements.params;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.facet.enhancements.CategoryEnhancement;
-import org.apache.lucene.facet.index.attributes.CategoryProperty;
-import org.apache.lucene.facet.index.params.CategoryListParams;
-import org.apache.lucene.facet.index.params.PerDimensionIndexingParams;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Default implementation of {@link EnhancementsIndexingParams} 
- * 
- * @lucene.experimental
- */
-public class DefaultEnhancementsIndexingParams extends
-    PerDimensionIndexingParams implements EnhancementsIndexingParams {
-
-  private List<CategoryEnhancement> enhancedCategories;
-
-  /**
-   * Construct with a certain {@link CategoryEnhancement enhancement}
-   * @throws IllegalArgumentException if no enhancements are provided
-   */
-  public DefaultEnhancementsIndexingParams(CategoryEnhancement... enhancements) {
-    super();
-    validateparams(enhancements);
-    addCategoryEnhancements(enhancements);
-  }
-
-  private void validateparams(CategoryEnhancement... enhancements) {
-    if (enhancements==null || enhancements.length<1) {
-      throw new IllegalArgumentException("at least one enhancement is required");
-    }
-  }
-
-  /**
-   * Construct with certain {@link CategoryEnhancement enhancements}
-   * and {@link CategoryListParams}
-   * @throws IllegalArgumentException if no enhancements are provided
-   */
-  public DefaultEnhancementsIndexingParams(
-      CategoryListParams categoryListParams,
-      CategoryEnhancement... enhancements) {
-    super(categoryListParams);
-    validateparams(enhancements);
-    addCategoryEnhancements(enhancements);
-  }
-
-  @Override
-  public void addCategoryEnhancements(CategoryEnhancement... enhancements) {
-    if (enhancedCategories == null) {
-      enhancedCategories = new ArrayList<CategoryEnhancement>();
-    }
-    for (CategoryEnhancement categoryEnhancement : enhancements) {
-      enhancedCategories.add(categoryEnhancement);
-    }
-  }
-
-  @Override
-  public List<CategoryEnhancement> getCategoryEnhancements() {
-    if (enhancedCategories == null || enhancedCategories.isEmpty()) {
-      return null;
-    }
-    return enhancedCategories;
-  }
-
-  @Override
-  public List<Class<? extends CategoryProperty>> getRetainableProperties() {
-    if (enhancedCategories == null) {
-      return null;
-    }
-    List<Class<? extends CategoryProperty>> retainableProperties = new ArrayList<Class<? extends CategoryProperty>>();
-    for (CategoryEnhancement enhancement : enhancedCategories) {
-      if (enhancement.getRetainableProperty() != null) {
-        retainableProperties.add(enhancement.getRetainableProperty());
-      }
-    }
-    if (retainableProperties.isEmpty()) {
-      return null;
-    }
-    return retainableProperties;
-  }
-}
Index: lucene/facet/src/java/org/apache/lucene/facet/enhancements/params/EnhancementsIndexingParams.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/enhancements/params/EnhancementsIndexingParams.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/enhancements/params/EnhancementsIndexingParams.java	(working copy)
@@ -1,12 +1,18 @@
 package org.apache.lucene.facet.enhancements.params;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 
 import org.apache.lucene.facet.enhancements.CategoryEnhancement;
 import org.apache.lucene.facet.enhancements.EnhancementsDocumentBuilder;
 import org.apache.lucene.facet.index.attributes.CategoryProperty;
-import org.apache.lucene.facet.index.params.FacetIndexingParams;
+import org.apache.lucene.facet.index.params.CategoryListParams;
+import org.apache.lucene.facet.index.params.PerDimensionIndexingParams;
 import org.apache.lucene.facet.index.streaming.CategoryParentsStream;
+import org.apache.lucene.facet.taxonomy.CategoryPath;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -26,41 +32,76 @@
  */
 
 /**
- * {@link FacetIndexingParams Facet indexing parameters} for defining
- * {@link CategoryEnhancement category enhancements}. It must contain at least
- * one enhancement, otherwise nothing is "enhanced" about it. When there are
- * more than one, the order matters - see {@link #getCategoryEnhancements()}.
+ * A {@link PerDimensionIndexingParams} for defining {@link CategoryEnhancement
+ * category enhancements}. Must contain at least one enhancement, and when there
+ * are more than one, their order matters.
  * 
+ * @see #getCategoryEnhancements()
  * @see EnhancementsDocumentBuilder
+
  * @lucene.experimental
  */
-public interface EnhancementsIndexingParams extends FacetIndexingParams {
+public class EnhancementsIndexingParams extends PerDimensionIndexingParams {
 
+  private final List<CategoryEnhancement> enhancements;
+
   /**
-   * Add {@link CategoryEnhancement}s to the indexing parameters
-   * @param enhancements enhancements to add
+   * Initializes with the given enhancements
+   * 
+   * @throws IllegalArgumentException
+   *           if no enhancements are provided
    */
-  public void addCategoryEnhancements(CategoryEnhancement... enhancements);
+  public EnhancementsIndexingParams(CategoryEnhancement... enhancements) {
+    this(DEFAULT_CATEGORY_LIST_PARAMS, Collections.<CategoryPath,CategoryListParams> emptyMap(), enhancements);
+  }
 
   /**
-   * Get a list of the active category enhancements. If no enhancements exist
-   * return {@code null}. The order of enhancements in the returned list
-   * dictates the order in which the enhancements data appear in the category
-   * tokens payload.
+   * Initializes with the given enhancements and category list params mappings.
    * 
-   * @return A list of the active category enhancements, or {@code null} if
-   *         there are no enhancements.
+   * @see PerDimensionIndexingParams#PerDimensionIndexingParams(Map, CategoryListParams)
+   * @throws IllegalArgumentException
+   *           if no enhancements are provided
    */
-  public List<CategoryEnhancement> getCategoryEnhancements();
+  public EnhancementsIndexingParams(CategoryListParams categoryListParams, 
+      Map<CategoryPath,CategoryListParams> paramsMap, CategoryEnhancement... enhancements) {
+    super(paramsMap, categoryListParams);
+    validateparams(enhancements);
+    this.enhancements = Arrays.asList(enhancements);
+  }
 
+  private void validateparams(CategoryEnhancement... enhancements) {
+    if (enhancements == null || enhancements.length < 1) {
+      throw new IllegalArgumentException("at least one enhancement is required");
+    }
+  }
+
   /**
-   * Get a list of {@link CategoryProperty} classes to be retained when
-   * creating {@link CategoryParentsStream}.
-   * 
-   * @return the list of {@link CategoryProperty} classes to be retained when
-   *         creating {@link CategoryParentsStream}, or {@code null} if there
-   *         are no such properties.
+   * Returns the list of {@link CategoryEnhancement} as were given at
+   * intialization time. You are not expected to modify the list. The order of
+   * the enhancements dictates the order in which they are written in the
+   * document.
    */
-  public List<Class<? extends CategoryProperty>> getRetainableProperties();
+  public List<CategoryEnhancement> getCategoryEnhancements() {
+    return enhancements;
+  }
 
+  /**
+   * Returns a list of {@link CategoryProperty} which should be retained when
+   * creating {@link CategoryParentsStream}, or {@code null} if there are no
+   * such properties.
+   */
+  public List<CategoryProperty> getRetainableProperties() {
+    List<CategoryProperty> props = new ArrayList<CategoryProperty>();
+    for (CategoryEnhancement enhancement : enhancements) {
+      CategoryProperty prop = enhancement.getRetainableProperty();
+      if (prop != null) {
+        props.add(prop);
+      }
+    }
+    if (props.isEmpty()) {
+      return null;
+    }
+    return props;
+  }
+
 }
Index: lucene/facet/src/java/org/apache/lucene/facet/index/CategoryDocumentBuilder.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/index/CategoryDocumentBuilder.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/index/CategoryDocumentBuilder.java	(working copy)
@@ -12,12 +12,10 @@
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.TextField;
-
 import org.apache.lucene.facet.index.attributes.CategoryAttribute;
 import org.apache.lucene.facet.index.attributes.CategoryAttributesIterable;
 import org.apache.lucene.facet.index.categorypolicy.OrdinalPolicy;
 import org.apache.lucene.facet.index.categorypolicy.PathPolicy;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.index.streaming.CategoryAttributesStream;
 import org.apache.lucene.facet.index.streaming.CategoryListTokenizer;
@@ -48,7 +46,7 @@
  * A utility class which allows attachment of {@link CategoryPath}s or
  * {@link CategoryAttribute}s to a given document using a taxonomy.<br>
  * Construction could be done with either a given {@link FacetIndexingParams} or
- * the default implementation {@link DefaultFacetIndexingParams}.<br>
+ * the default implementation {@link FacetIndexingParams}.<br>
  * A CategoryDocumentBuilder can be reused by repeatedly setting the categories
  * and building the document. Categories are provided either as
  * {@link CategoryAttribute} elements through {@link #setCategories(Iterable)},
@@ -85,18 +83,16 @@
   protected Map<String, List<CategoryAttribute>> categoriesMap;
 
   /**
-   * Creating a facets document builder with default facet indexing
-   * parameters.<br>
-   * See:
-   * {@link #CategoryDocumentBuilder(TaxonomyWriter, FacetIndexingParams)}
+   * Creating a facets document builder with default facet indexing parameters.
    * 
    * @param taxonomyWriter
-   *            to which new categories will be added, as well as translating
-   *            known categories to ordinals
-   *
+   *          to which new categories will be added, as well as translating
+   *          known categories to ordinals
+   * 
+   * @see #CategoryDocumentBuilder(TaxonomyWriter, FacetIndexingParams)
    */
   public CategoryDocumentBuilder(TaxonomyWriter taxonomyWriter) {
-    this(taxonomyWriter, new DefaultFacetIndexingParams());
+    this(taxonomyWriter, FacetIndexingParams.ALL_PARENTS);
   }
 
   /**
Index: lucene/facet/src/java/org/apache/lucene/facet/index/OrdinalMappingAtomicReader.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/index/OrdinalMappingAtomicReader.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/index/OrdinalMappingAtomicReader.java	(working copy)
@@ -25,7 +25,6 @@
 import java.util.Map;
 
 import org.apache.lucene.facet.index.params.CategoryListParams;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter.OrdinalMap;
 import org.apache.lucene.index.AtomicReader;
@@ -71,6 +70,7 @@
  * @lucene.experimental
  */
 public class OrdinalMappingAtomicReader extends FilterAtomicReader {
+  
   private final int[] ordinalMap;
   // a little obtuse: but we dont need to create Term objects this way
   private final Map<String,Map<BytesRef,CategoryListParams>> termMap = 
@@ -82,7 +82,7 @@
    * OrdinalMappingAtomicReader(in, ordinalMap, new DefaultFacetIndexingParams())}
    */
   public OrdinalMappingAtomicReader(AtomicReader in, int[] ordinalMap) {
-    this(in, ordinalMap, new DefaultFacetIndexingParams());
+    this(in, ordinalMap, FacetIndexingParams.ALL_PARENTS);
   }
   
   /**
Index: lucene/facet/src/java/org/apache/lucene/facet/index/categorypolicy/OrdinalPolicy.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/index/categorypolicy/OrdinalPolicy.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/index/categorypolicy/OrdinalPolicy.java	(working copy)
@@ -2,7 +2,6 @@
 
 import java.io.Serializable;
 
-import org.apache.lucene.facet.index.streaming.CategoryParentsStream;
 import org.apache.lucene.facet.search.FacetsAccumulator;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
@@ -25,11 +24,9 @@
  */
 
 /**
- * Filtering category ordinals in {@link CategoryParentsStream}, where a given
- * category ordinal is added to the stream, and than its parents are being added
- * one after the other using {@link TaxonomyWriter#getParent(int)}. <br>
- * That loop should have a stop point - the default approach (excluding the
- * ROOT) is implemented in {@link OrdinalPolicy#ALL_PARENTS}.
+ * A policy for adding category parent ordinals to the list of ordinals that are
+ * encoded for a given document. The default {@link #ALL_PARENTS} policy always
+ * adds all parents, where {@link #NO_PARENTS} never adds any parents.
  * 
  * @lucene.experimental
  */
Index: lucene/facet/src/java/org/apache/lucene/facet/index/params/DefaultFacetIndexingParams.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/index/params/DefaultFacetIndexingParams.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/index/params/DefaultFacetIndexingParams.java	(working copy)
@@ -1,201 +0,0 @@
-package org.apache.lucene.facet.index.params;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.facet.index.categorypolicy.OrdinalPolicy;
-import org.apache.lucene.facet.index.categorypolicy.PathPolicy;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Default implementation for {@link FacetIndexingParams}.
- * <p>
- * Getters for <em>partition-size</em>, {@link OrdinalPolicy} and
- * {@link PathPolicy} are all final, and so the proper way to modify them when
- * extending this class is through {@link #fixedPartitionSize()},
- * {@link #fixedOrdinalPolicy()} or {@link #fixedPathPolicy()} accordingly.
- * 
- * @lucene.experimental
- */
-public class DefaultFacetIndexingParams implements FacetIndexingParams {
-
-  /**
-   * delimiter between a categories in a path, e.g. Products FACET_DELIM
-   * Consumer FACET_DELIM Tv. This should be a character not found in any path
-   * component
-   */
-  public static final char DEFAULT_FACET_DELIM_CHAR = '\uF749';
-
-  private final CategoryListParams clpParams;
-  private final OrdinalPolicy ordinalPolicy;
-  private final PathPolicy pathPolicy;
-  private final int partitionSize;
-
-  public DefaultFacetIndexingParams() {
-    this(new CategoryListParams());
-  }
-
-  public DefaultFacetIndexingParams(CategoryListParams categoryListParams) {
-    clpParams = categoryListParams;
-    ordinalPolicy = fixedOrdinalPolicy();
-    pathPolicy = fixedPathPolicy();
-    partitionSize = fixedPartitionSize();
-  }
-
-  @Override
-  public CategoryListParams getCategoryListParams(CategoryPath category) {
-    return clpParams;
-  }
-
-  @Override
-  public int drillDownTermText(CategoryPath path, char[] buffer) {
-    return path.copyToCharArray(buffer, 0, -1, getFacetDelimChar());
-  }
-
-  /**
-   * "fixed" partition size. 
-   * @see #getPartitionSize()
-   */
-  protected int fixedPartitionSize() {
-    return Integer.MAX_VALUE;
-  }
-  
-  /**
-   * "fixed" ordinal policy. 
-   * @see #getOrdinalPolicy()
-   */
-  protected OrdinalPolicy fixedOrdinalPolicy() {
-    return OrdinalPolicy.ALL_PARENTS;
-  }
-  
-  /**
-   * "fixed" path policy. 
-   * @see #getPathPolicy()
-   */
-  protected PathPolicy fixedPathPolicy() {
-    return PathPolicy.ALL_CATEGORIES;
-  }
-  
-  @Override
-  public final int getPartitionSize() {
-    return partitionSize;
-  }
-
-  /*
-   * (non-Javadoc)
-   * 
-   * @see
-   * org.apache.lucene.facet.index.params.FacetIndexingParams#getAllCategoryListParams
-   * ()
-   */
-  @Override
-  public Iterable<CategoryListParams> getAllCategoryListParams() {
-    List<CategoryListParams> res = new ArrayList<CategoryListParams>();
-    res.add(clpParams);
-    return res;
-  }
-
-  @Override
-  public final OrdinalPolicy getOrdinalPolicy() {
-    return ordinalPolicy;
-  }
-
-  @Override
-  public final PathPolicy getPathPolicy() {
-    return pathPolicy;
-  }
-
-  /* (non-Javadoc)
-   * @see java.lang.Object#hashCode()
-   */
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = 1;
-    result = prime * result
-        + ((clpParams == null) ? 0 : clpParams.hashCode());
-    result = prime * result
-        + ((ordinalPolicy == null) ? 0 : ordinalPolicy.hashCode());
-    result = prime * result + partitionSize;
-    result = prime * result
-        + ((pathPolicy == null) ? 0 : pathPolicy.hashCode());
-    
-    for (CategoryListParams clp: getAllCategoryListParams()) {
-      result ^= clp.hashCode();
-    }
-    
-    return result;
-  }
-
-  /* (non-Javadoc)
-   * @see java.lang.Object#equals(java.lang.Object)
-   */
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj) {
-      return true;
-    }
-    if (obj == null) {
-      return false;
-    }
-    if (!(obj instanceof DefaultFacetIndexingParams)) {
-      return false;
-    }
-    DefaultFacetIndexingParams other = (DefaultFacetIndexingParams) obj;
-    if (clpParams == null) {
-      if (other.clpParams != null) {
-        return false;
-      }
-    } else if (!clpParams.equals(other.clpParams)) {
-      return false;
-    }
-    if (ordinalPolicy == null) {
-      if (other.ordinalPolicy != null) {
-        return false;
-      }
-    } else if (!ordinalPolicy.equals(other.ordinalPolicy)) {
-      return false;
-    }
-    if (partitionSize != other.partitionSize) {
-      return false;
-    }
-    if (pathPolicy == null) {
-      if (other.pathPolicy != null) {
-        return false;
-      }
-    } else if (!pathPolicy.equals(other.pathPolicy)) {
-      return false;
-    }
-    
-    Iterable<CategoryListParams> cLs = getAllCategoryListParams();
-    Iterable<CategoryListParams> otherCLs = other.getAllCategoryListParams();
-    
-    return cLs.equals(otherCLs);
-  }
-
-  /**
-   * Use {@link #DEFAULT_FACET_DELIM_CHAR} as the delimiter.
-   */
-  @Override
-  public char getFacetDelimChar() {
-    return DEFAULT_FACET_DELIM_CHAR;
-  }
-
-}
Index: lucene/facet/src/java/org/apache/lucene/facet/index/params/FacetIndexingParams.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/index/params/FacetIndexingParams.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/index/params/FacetIndexingParams.java	(working copy)
@@ -1,9 +1,11 @@
 package org.apache.lucene.facet.index.params;
 
-import java.io.Serializable;
+import java.util.Collections;
+import java.util.List;
 
 import org.apache.lucene.facet.index.categorypolicy.OrdinalPolicy;
 import org.apache.lucene.facet.index.categorypolicy.PathPolicy;
+import org.apache.lucene.facet.search.FacetArrays;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 
 /*
@@ -24,75 +26,202 @@
  */
 
 /**
- * Parameters on how facets are to be written to the index. 
- * For example, which fields and terms are used to refer to the indexed posting list.
- * <P>
- * If non-default parameters were used during indexing, the same parameters
- * must also be passed during faceted search. This requirement is analogous
- * to the requirement during search to know which fields were indexed, and which
- * Analyzer was used on the text.
+ * Defines parameters that are needed for facets indexing. Note that this class
+ * does not have any setters. That's because overriding the default parameters
+ * is considered expert. If you wish to override them, simply extend this class
+ * and override the relevant getter.
  * 
+ * <p>
+ * <b>NOTE:</b> This class is also used during faceted search in order to e.g.
+ * know which field holds the drill-down terms or the fulltree posting.
+ * Therefore this class should be initialized once and you should refrain from
+ * changing it. Also note that if you make any changes to it (e.g. suddenly
+ * deciding that drill-down terms should be read from a different field) and use
+ * it on an existing index, things may not work as expected.
+ * 
  * @lucene.experimental
  */
-public interface FacetIndexingParams extends Serializable {
+public class FacetIndexingParams {
+  
+  // the default CLP, can be a singleton
+  protected static final CategoryListParams DEFAULT_CATEGORY_LIST_PARAMS = new CategoryListParams();
 
   /**
-   * The name of the category-list to put this category in, or null if this
-   * category should not be aggregatable.
-   * <P>
+   * A {@link FacetIndexingParams} which fixes {@link OrdinalPolicy} to
+   * {@link OrdinalPolicy#NO_PARENTS}. This is a singleton equivalent to new
+   * {@link #FacetIndexingParams()}.
+   */
+  public static final FacetIndexingParams ALL_PARENTS = new FacetIndexingParams();
+  
+  /**
+   * The default delimiter with which {@link CategoryPath#getComponent(int)
+   * components} are concatenated when written to the index, e.g. as drill-down
+   * terms. If you choose to override it by overiding
+   * {@link #getFacetDelimChar()}, you should make sure that you return a
+   * character that's not found in any path component.
+   */
+  public static final char DEFAULT_FACET_DELIM_CHAR = '\uF749';
+  
+  private final OrdinalPolicy ordinalPolicy = OrdinalPolicy.ALL_PARENTS;
+  private final PathPolicy pathPolicy = PathPolicy.ALL_CATEGORIES;
+  private final int partitionSize = Integer.MAX_VALUE;
+
+  protected final CategoryListParams clParams;
+
+  /**
+   * Initializes new default params. You should use this constructor only if you
+   * intend to override any of the getters, otherwise you can use
+   * {@link #ALL_PARENTS} to save unnecessary object allocations.
+   */
+  public FacetIndexingParams() {
+    this(DEFAULT_CATEGORY_LIST_PARAMS);
+  }
+
+  /** Initializes new params with the given {@link CategoryListParams}. */
+  public FacetIndexingParams(CategoryListParams categoryListParams) {
+    clParams = categoryListParams;
+  }
+
+  /**
+   * The name of the category list to put this category in, or {@code null} if
+   * this category should not be aggregatable.
+   * <p>
    * By default, all categories are written to the same category list, but
-   * applications which know in advance that in some situations only parts
-   * of the category hierarchy needs to be counted can divide the categories
-   * into two or more different category lists.
-   * <P>
-   * If null is returned for a category, it means that this category should
-   * not appear in any category list, and thus counts for it cannot be
-   * aggregated. This category can still be used for drill-down, even though
-   * the count for it is not known.
+   * applications which know in advance that in some situations only parts of
+   * the category hierarchy needs to be counted can divide the categories into
+   * two or more different category lists.
+   * <p>
+   * If {@code null} is returned for a category, it means that this category
+   * should not appear in any category list, and thus weights for it cannot be
+   * aggregated. This category can still be used for drill-down, even though the
+   * its weight is unknown.
+   * 
+   * @see PerDimensionIndexingParams
    */
-  public CategoryListParams getCategoryListParams(CategoryPath category);
+  public CategoryListParams getCategoryListParams(CategoryPath category) {
+    return clParams;
+  }
 
   /**
-   * Return info about all category lists in the index.
+   * Copies the text required to execute a drill-down query on the given
+   * category to the given {@code char[]}, and returns the number of characters
+   * that were written.
+   * <p>
+   * <b>NOTE:</b> You should make sure that the {@code char[]} is large enough,
+   * by e.g. calling {@link CategoryPath#charsNeededForFullPath()}.
+   */
+  public int drillDownTermText(CategoryPath path, char[] buffer) {
+    return path.copyToCharArray(buffer, 0, -1, getFacetDelimChar());
+  }
+  
+  /**
+   * Returns the size of a partition. <i>Partitions</i> allow you to divide
+   * (hence, partition) the categories space into small sets to e.g. improve RAM
+   * consumption during faceted search. For instance, {@code partitionSize=100K}
+   * would mean that if your taxonomy index contains 420K categories, they will
+   * be divided into 5 groups and at search time a {@link FacetArrays} will be
+   * allocated at the size of the partition.
    * 
-   * @see #getCategoryListParams(CategoryPath)
+   * <p>
+   * This is real advanced setting and should be changed with care. By default,
+   * all categories are put in one partition. You should modify this setting if
+   * you have really large taxonomies (e.g. 1M+ nodes).
    */
-  public Iterable<CategoryListParams> getAllCategoryListParams();
+  public int getPartitionSize() {
+    return partitionSize;
+  }
 
-  // TODO (Facet): Add special cases of exact/non-exact category term-text
+  /**
+   * Returns a list of all {@link CategoryListParams categoryListParams} that
+   * are used for facets indexing.
+   */
+  public List<CategoryListParams> getAllCategoryListParams() {
+    return Collections.singletonList(clParams);
+  }
 
   /**
-   * Return the drilldown Term-Text which does not need to do any allocations.
-   * The number of chars set is returned.
-   * <p>
-   * Note: Make sure <code>buffer</code> is large enough.
-   * @see CategoryPath#charsNeededForFullPath()
+   * Returns the {@link OrdinalPolicy} that is used during indexing. By default
+   * returns {@link OrdinalPolicy#ALL_PARENTS} which means that the full
+   * hierarchy will be stored for every document.
    */
-  public int drillDownTermText(CategoryPath path, char[] buffer);
+  public OrdinalPolicy getOrdinalPolicy() {
+    return ordinalPolicy;
+  }
 
   /**
-   * Get the partition size.
-   * Same value should be used during the life time of an index.
-   * At search time this value is compared with actual taxonomy size and their minimum is used.
+   * Returns the {@link PathPolicy} that is used during indexing. By default
+   * returns {@link PathPolicy#ALL_CATEGORIES} which means that the full
+   * hierarchy is added as drill-down terms for every document.
    */
-  public int getPartitionSize();
+  public PathPolicy getPathPolicy() {
+    return pathPolicy;
+  }
 
-  /** 
-   * Get the policy for indexing category <b>paths</b>, 
-   * used for deciding how "high" to climb in taxonomy 
-   * from a category when ingesting its category paths. 
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + ((clParams == null) ? 0 : clParams.hashCode());
+    result = prime * result + ((ordinalPolicy == null) ? 0 : ordinalPolicy.hashCode());
+    result = prime * result + partitionSize;
+    result = prime * result + ((pathPolicy == null) ? 0 : pathPolicy.hashCode());
+    
+    for (CategoryListParams clp : getAllCategoryListParams()) {
+      result ^= clp.hashCode();
+    }
+    
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) {
+      return true;
+    }
+    if (obj == null) {
+      return false;
+    }
+    if (!(obj instanceof FacetIndexingParams)) {
+      return false;
+    }
+    FacetIndexingParams other = (FacetIndexingParams) obj;
+    if (clParams == null) {
+      if (other.clParams != null) {
+        return false;
+      }
+    } else if (!clParams.equals(other.clParams)) {
+      return false;
+    }
+    if (ordinalPolicy == null) {
+      if (other.ordinalPolicy != null) {
+        return false;
+      }
+    } else if (!ordinalPolicy.equals(other.ordinalPolicy)) {
+      return false;
+    }
+    if (partitionSize != other.partitionSize) {
+      return false;
+    }
+    if (pathPolicy == null) {
+      if (other.pathPolicy != null) {
+        return false;
+      }
+    } else if (!pathPolicy.equals(other.pathPolicy)) {
+      return false;
+    }
+    
+    Iterable<CategoryListParams> cLs = getAllCategoryListParams();
+    Iterable<CategoryListParams> otherCLs = other.getAllCategoryListParams();
+    
+    return cLs.equals(otherCLs);
+  }
+
+  /**
+   * Returns the delimiter character used internally for concatenating category
+   * path components, e.g. for drill-down terms.
    */
-  public PathPolicy getPathPolicy();
+  public char getFacetDelimChar() {
+    return DEFAULT_FACET_DELIM_CHAR;
+  }
 
-  /** 
-   * Get the policy for indexing category <b>ordinals</b>, 
-   * used for deciding how "high" to climb in taxonomy 
-   * from a category when ingesting its ordinals 
-   */
-  public OrdinalPolicy getOrdinalPolicy();
-  
-  /** 
-   * Get the delimiter character used internally for drill-down terms 
-   */ 
-  public char getFacetDelimChar();
 }
Index: lucene/facet/src/java/org/apache/lucene/facet/index/params/PerDimensionIndexingParams.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/index/params/PerDimensionIndexingParams.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/index/params/PerDimensionIndexingParams.java	(working copy)
@@ -2,7 +2,9 @@
 
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 
@@ -24,62 +26,59 @@
  */
 
 /**
- * A FacetIndexingParams that utilizes different category lists, defined by the
- * dimension specified CategoryPaths (see
- * {@link PerDimensionIndexingParams#addCategoryListParams(CategoryPath, CategoryListParams)}
+ * A {@link FacetIndexingParams} that utilizes different category lists, defined
+ * by the dimension specified by a {@link CategoryPath category} (see
+ * {@link #PerDimensionIndexingParams(Map, CategoryListParams)}.
  * <p>
  * A 'dimension' is defined as the first or "zero-th" component in a
- * CategoryPath. For example, if a CategoryPath is defined as
- * "/Author/American/Mark Twain", then the dimension is "Author".
- * <p>
- * This class also uses the 'default' CategoryListParams (as specified by
- * {@link CategoryListParams#CategoryListParams()} when
- * {@link #getCategoryListParams(CategoryPath)} is called for a CategoryPath
- * whose dimension component has not been specifically defined.
+ * {@link CategoryPath}. For example, if a category is defined as
+ * "Author/American/Mark Twain", then the dimension would be "Author".
  * 
  * @lucene.experimental
  */
-public class PerDimensionIndexingParams extends DefaultFacetIndexingParams {
+public class PerDimensionIndexingParams extends FacetIndexingParams {
 
-  // "Root" or "first component" of a Category Path maps to a
-  // CategoryListParams
-  private final Map<String, CategoryListParams> clParamsMap = new HashMap<String, CategoryListParams>();
+  private final Map<String, CategoryListParams> clParamsMap;
 
   /**
-   * Construct with the default {@link CategoryListParams} as the default
-   * CategoryListParams for unspecified CategoryPaths.
+   * Initializes a new instance with the given dimension-to-params mapping. The
+   * dimension is considered as what's returned by
+   * {@link CategoryPath#getComponent(int) cp.getComponent(0)}.
+   * 
+   * <p>
+   * <b>NOTE:</b> for any dimension whose {@link CategoryListParams} is not
+   * defined in the mapping, a default {@link CategoryListParams} will be used.
+   * 
+   * @see #PerDimensionIndexingParams(Map, CategoryListParams)
    */
-  public PerDimensionIndexingParams() {
-    this(new CategoryListParams());
+  public PerDimensionIndexingParams(Map<CategoryPath, CategoryListParams> paramsMap) {
+    this(paramsMap, DEFAULT_CATEGORY_LIST_PARAMS);
   }
 
   /**
-   * Construct with the included categoryListParams as the default
-   * CategoryListParams for unspecified CategoryPaths.
-   * 
-   * @param categoryListParams
-   *            the default categoryListParams to use
+   * Same as {@link #PerDimensionIndexingParams(Map)}, only the given
+   * {@link CategoryListParams} will be used for any dimension that is not
+   * specified in the given mapping.
    */
-  public PerDimensionIndexingParams(CategoryListParams categoryListParams) {
+  public PerDimensionIndexingParams(Map<CategoryPath, CategoryListParams> paramsMap, 
+      CategoryListParams categoryListParams) {
     super(categoryListParams);
+    clParamsMap = new HashMap<String,CategoryListParams>();
+    for (Entry<CategoryPath, CategoryListParams> e : paramsMap.entrySet()) {
+      clParamsMap.put(e.getKey().getComponent(0), e.getValue());
+    }
   }
 
-  /**
-   * Get all the categoryListParams, including the default.
-   */
   @Override
-  public Iterable<CategoryListParams> getAllCategoryListParams() {
-    ArrayList<CategoryListParams> vals = 
-      new ArrayList<CategoryListParams>(clParamsMap.values());
-    for (CategoryListParams clp : super.getAllCategoryListParams()) {
-      vals.add(clp);
-    }
+  public List<CategoryListParams> getAllCategoryListParams() {
+    ArrayList<CategoryListParams> vals = new ArrayList<CategoryListParams>(clParamsMap.values());
+    vals.add(clParams); // add the default too
     return vals;
   }
 
   /**
-   * Get the CategoryListParams based on the dimension or "zero-th category"
-   * of the specified CategoryPath.
+   * Returns the {@link CategoryListParams} for the corresponding dimension
+   * which is returned by {@code category.getComponent(0)}.
    */
   @Override
   public CategoryListParams getCategoryListParams(CategoryPath category) {
@@ -89,14 +88,7 @@
         return clParams;
       }
     }
-    return super.getCategoryListParams(category);
+    return clParams;
   }
 
-  /**
-   * Add a CategoryListParams for a given CategoryPath's dimension or
-   * "zero-th" category.
-   */
-  public void addCategoryListParams(CategoryPath category, CategoryListParams clParams) {
-    clParamsMap.put(category.getComponent(0), clParams);
-  }
 }
Index: lucene/facet/src/java/org/apache/lucene/facet/index/streaming/CategoryParentsStream.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/index/streaming/CategoryParentsStream.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/index/streaming/CategoryParentsStream.java	(working copy)
@@ -154,20 +154,17 @@
    * using {@link #addRetainableProperty(Class)}.
    */
   protected void clearCategoryProperties() {
-    if (this.retainableProperties == null
-        || this.retainableProperties.isEmpty()) {
-      this.categoryAttribute.clearProperties();
+    if (retainableProperties == null || retainableProperties.isEmpty()) {
+      categoryAttribute.clearProperties();
     } else {
-      List<Class<? extends CategoryProperty>> propertyClassesToRemove = 
-                            new LinkedList<Class<? extends CategoryProperty>>();
-      for (Class<? extends CategoryProperty> propertyClass : this.categoryAttribute
-          .getPropertyClasses()) {
-        if (!this.retainableProperties.contains(propertyClass)) {
-          propertyClassesToRemove.add(propertyClass);
+      List<Class<? extends CategoryProperty>> propsToRemove = new LinkedList<Class<? extends CategoryProperty>>();
+      for (Class<? extends CategoryProperty> propertyClass : categoryAttribute.getPropertyClasses()) {
+        if (!retainableProperties.contains(propertyClass)) {
+          propsToRemove.add(propertyClass);
         }
       }
-      for (Class<? extends CategoryProperty> propertyClass : propertyClassesToRemove) {
-        this.categoryAttribute.remove(propertyClass);
+      for (Class<? extends CategoryProperty> propertyClass : propsToRemove) {
+        categoryAttribute.remove(propertyClass);
       }
     }
   }
Index: lucene/facet/src/java/org/apache/lucene/facet/search/StandardFacetsAccumulator.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/search/StandardFacetsAccumulator.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/search/StandardFacetsAccumulator.java	(working copy)
@@ -83,7 +83,7 @@
     this.facetArrays = facetArrays;
     // can only be computed later when docids size is known
     isUsingComplements = false;
-    partitionSize = PartitionsUtils.partitionSize(searchParams, taxonomyReader);
+    partitionSize = PartitionsUtils.partitionSize(searchParams.getFacetIndexingParams(), taxonomyReader);
     maxPartitions = (int) Math.ceil(this.taxonomyReader.getSize() / (double) partitionSize);
     accumulateGuard = new Object();
   }
@@ -91,7 +91,7 @@
   public StandardFacetsAccumulator(FacetSearchParams searchParams,
       IndexReader indexReader, TaxonomyReader taxonomyReader) {
     this(searchParams, indexReader, taxonomyReader, new FacetArrays(
-        PartitionsUtils.partitionSize(searchParams, taxonomyReader)));
+        PartitionsUtils.partitionSize(searchParams.getFacetIndexingParams(), taxonomyReader)));
   }
 
   @Override
@@ -109,7 +109,7 @@
         try {
           totalFacetCounts = TotalFacetCountsCache.getSingleton()
             .getTotalCounts(indexReader, taxonomyReader,
-                searchParams.getFacetIndexingParams(), searchParams.getClCache());
+                searchParams.getFacetIndexingParams(), searchParams.getCategoryListCache());
           if (totalFacetCounts != null) {
             docids = ScoredDocIdsUtils.getComplementSet(docids, indexReader);
           } else {
@@ -135,11 +135,7 @@
           isUsingComplements = false;
         } catch (Exception e) {
           // give up: this should not happen!
-          IOException ioEx = new IOException(
-              "PANIC: Got unexpected exception while trying to get/calculate total counts: "
-              +e.getMessage());
-          ioEx.initCause(e);
-          throw ioEx;
+          throw new IOException("PANIC: Got unexpected exception while trying to get/calculate total counts", e);
         }
       }
 
Index: lucene/facet/src/java/org/apache/lucene/facet/search/TotalFacetCounts.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/search/TotalFacetCounts.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/search/TotalFacetCounts.java	(working copy)
@@ -8,21 +8,25 @@
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.util.Arrays;
 import java.util.HashMap;
+import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.apache.lucene.index.IndexReader;
-
 import org.apache.lucene.facet.index.params.CategoryListParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.aggregator.Aggregator;
 import org.apache.lucene.facet.search.aggregator.CountingAggregator;
 import org.apache.lucene.facet.search.cache.CategoryListCache;
 import org.apache.lucene.facet.search.cache.CategoryListData;
+import org.apache.lucene.facet.search.params.CountFacetRequest;
+import org.apache.lucene.facet.search.params.FacetRequest;
 import org.apache.lucene.facet.search.params.FacetSearchParams;
+import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.util.PartitionsUtils;
 import org.apache.lucene.facet.util.ScoredDocIdsUtils;
+import org.apache.lucene.index.IndexReader;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -146,13 +150,17 @@
       dos.close();
     }
   }
+  
+  // needed because FacetSearchParams do not allow empty FacetRequests
+  private static final List<FacetRequest> DUMMY_REQ = Arrays.asList(
+      new FacetRequest[] { new CountFacetRequest(new CategoryPath(), 1) });
 
   static TotalFacetCounts compute(final IndexReader indexReader,
       final TaxonomyReader taxonomy, final FacetIndexingParams facetIndexingParams,
       final CategoryListCache clCache) throws IOException {
     int partitionSize = PartitionsUtils.partitionSize(facetIndexingParams, taxonomy);
     final int[][] counts = new int[(int) Math.ceil(taxonomy.getSize()  /(float) partitionSize)][partitionSize];
-    FacetSearchParams newSearchParams = new FacetSearchParams(facetIndexingParams); 
+    FacetSearchParams newSearchParams = new FacetSearchParams(DUMMY_REQ, facetIndexingParams); 
       //createAllListsSearchParams(facetIndexingParams,  this.totalCounts);
     FacetsAccumulator fe = new StandardFacetsAccumulator(newSearchParams, indexReader, taxonomy) {
       @Override
Index: lucene/facet/src/java/org/apache/lucene/facet/search/params/FacetRequest.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/search/params/FacetRequest.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/search/params/FacetRequest.java	(working copy)
@@ -332,7 +332,7 @@
   public CategoryListIterator createCategoryListIterator(IndexReader reader,
       TaxonomyReader taxo, FacetSearchParams sParams, int partition)
       throws IOException {
-    CategoryListCache clCache = sParams.getClCache();
+    CategoryListCache clCache = sParams.getCategoryListCache();
     CategoryListParams clParams = sParams.getFacetIndexingParams().getCategoryListParams(categoryPath);
     if (clCache!=null) {
       CategoryListData clData = clCache.get(clParams);
Index: lucene/facet/src/java/org/apache/lucene/facet/search/params/FacetSearchParams.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/search/params/FacetSearchParams.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/search/params/FacetSearchParams.java	(working copy)
@@ -1,12 +1,10 @@
 package org.apache.lucene.facet.search.params;
 
-import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.cache.CategoryListCache;
-import org.apache.lucene.facet.search.results.FacetResult;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -26,12 +24,13 @@
  */
 
 /**
- * Faceted search parameters indicate for which facets should info be gathered.
+ * Defines parameters that are needed for faceted search. The list of
+ * {@link FacetRequest facet requests} denotes the facets for which aggregated
+ * should be done.
  * <p>
- * The contained facet requests define for which facets should info be gathered.
- * <p>
- * Contained faceted indexing parameters provide required info on how
- * to read and interpret the underlying faceted information in the search index.   
+ * One can pass {@link FacetIndexingParams} in order to tell the search code how
+ * to read the facets information. Note that you must use the same
+ * {@link FacetIndexingParams} that were used for indexing.
  * 
  * @lucene.experimental
  */
@@ -39,64 +38,63 @@
 
   protected final FacetIndexingParams indexingParams;
   protected final List<FacetRequest> facetRequests;
-  private CategoryListCache clCache = null;
+  
+  /**
+   * Initializes with the given {@link FacetRequest requests} and default
+   * {@link FacetIndexingParams#ALL_PARENTS}. If you used a different
+   * {@link FacetIndexingParams}, you should use
+   * {@link #FacetSearchParams(List, FacetIndexingParams)}.
+   */
+  public FacetSearchParams(FacetRequest... facetRequests) {
+    this(Arrays.asList(facetRequests), FacetIndexingParams.ALL_PARENTS);
+  }
+  
+  /**
+   * Initializes with the given {@link FacetRequest requests} and default
+   * {@link FacetIndexingParams#ALL_PARENTS}. If you used a different
+   * {@link FacetIndexingParams}, you should use
+   * {@link #FacetSearchParams(List, FacetIndexingParams)}.
+   */
+  public FacetSearchParams(List<FacetRequest> facetRequests) {
+    this(facetRequests, FacetIndexingParams.ALL_PARENTS);
+  }
 
   /**
-   * Construct with specific faceted indexing parameters.
-   * It is important to know the indexing parameters so as to e.g. 
-   * read facets data correctly from the index.
-   * {@link #addFacetRequest(FacetRequest)} must be called at least once 
-   * for this faceted search to find any faceted result.
-   * @param indexingParams Indexing faceted parameters which were used at indexing time.
-   * @see #addFacetRequest(FacetRequest)
+   * Initilizes with the given {@link FacetRequest requests} and
+   * {@link FacetIndexingParams}.
    */
-  public FacetSearchParams(FacetIndexingParams indexingParams) {
+  public FacetSearchParams(List<FacetRequest> facetRequests, FacetIndexingParams indexingParams) {
+    if (facetRequests == null || facetRequests.size() == 0) {
+      throw new IllegalArgumentException("at least one FacetRequest must be defined");
+    }
     this.indexingParams = indexingParams;
-    facetRequests = new ArrayList<FacetRequest>();
+    this.facetRequests = facetRequests;
   }
 
   /**
-   * Construct with default faceted indexing parameters.
-   * Usage of this constructor is valid only if also during indexing the 
-   * default faceted indexing parameters were used.   
-   * {@link #addFacetRequest(FacetRequest)} must be called at least once 
-   * for this faceted search to find any faceted result.
-   * @see #addFacetRequest(FacetRequest)
+   * Returns the {@link CategoryListCache}. By default returns {@code null}, you
+   * should override if you want to use a cache.
    */
-  public FacetSearchParams() {
-    this(new DefaultFacetIndexingParams());
+  public CategoryListCache getCategoryListCache() {
+    return null;
   }
 
   /**
-   * A list of {@link FacetRequest} objects, determining what to count.
-   * If the returned collection is empty, the faceted search will return no facet results!
+   * Returns the {@link FacetIndexingParams} that were passed to the
+   * constructor.
    */
-  public final FacetIndexingParams getFacetIndexingParams() {
+  public FacetIndexingParams getFacetIndexingParams() {
     return indexingParams;
   }
-
+  
   /**
-   * Parameters which controlled the indexing of facets, and which are also
-   * needed during search.
+   * Returns the list of {@link FacetRequest facet requests} that were passed to
+   * the constructor.
    */
-  public final List<FacetRequest> getFacetRequests() {
+  public List<FacetRequest> getFacetRequests() {
     return facetRequests;
   }
 
-  /**
-   * Add a facet request to apply for this faceted search.
-   * This method must be called at least once for faceted search 
-   * to find any faceted result. <br>
-   * NOTE: The order of addition implies the order of the {@link FacetResult}s
-   * @param facetRequest facet request to be added.
-   */
-  public void addFacetRequest(FacetRequest facetRequest) {
-    if (facetRequest == null) {
-      throw new IllegalArgumentException("Provided facetRequest must not be null");
-    }
-    facetRequests.add(facetRequest);
-  }
-  
   @Override
   public String toString() {
     final char TAB = '\t';
@@ -112,19 +110,4 @@
     
     return sb.toString();
   }
-
-  /**
-   * @return the cldCache in effect
-   */
-  public CategoryListCache getClCache() {
-    return clCache;
-  }
-
-  /**
-   * Set Cached Category Lists data to be used in Faceted search.
-   * @param clCache the cldCache to set
-   */
-  public void setClCache(CategoryListCache clCache) {
-    this.clCache = clCache;
-  }
 }
Index: lucene/facet/src/java/org/apache/lucene/facet/search/sampling/Sampler.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/search/sampling/Sampler.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/search/sampling/Sampler.java	(working copy)
@@ -1,6 +1,8 @@
 package org.apache.lucene.facet.search.sampling;
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 
 import org.apache.lucene.index.IndexReader;
 
@@ -183,11 +185,12 @@
     // So now we can sample -> altering the searchParams to accommodate for the statistical error for the sampling
     double overSampleFactor = getSamplingParams().getOversampleFactor();
     if (overSampleFactor > 1) { // any factoring to do?
-      res = new FacetSearchParams(original.getFacetIndexingParams());
-      for (FacetRequest frq: original.getFacetRequests()) {
+      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
+      for (FacetRequest frq : original.getFacetRequests()) {
         int overSampledNumResults = (int) Math.ceil(frq.getNumResults() * overSampleFactor);
-        res.addFacetRequest(new OverSampledFacetRequest(frq, overSampledNumResults));
+        facetRequests.add(new OverSampledFacetRequest(frq, overSampledNumResults));
       }
+      res = new FacetSearchParams(facetRequests, original.getFacetIndexingParams());
     }
     return res;
   }
Index: lucene/facet/src/java/org/apache/lucene/facet/util/PartitionsUtils.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/util/PartitionsUtils.java	(revision 1420923)
+++ lucene/facet/src/java/org/apache/lucene/facet/util/PartitionsUtils.java	(working copy)
@@ -2,7 +2,6 @@
 
 import org.apache.lucene.facet.index.params.CategoryListParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
-import org.apache.lucene.facet.search.params.FacetSearchParams;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 
 /*
@@ -33,22 +32,12 @@
    * Get the offset for a given partition.  That is, what is the minimum number an
    * ordinal could be for a particular partition. 
    */
-  public final static int partitionOffset (  FacetIndexingParams iParams, 
-                        int partitionNumber, 
-                        final TaxonomyReader taxonomyReader) {
+  public final static int partitionOffset(FacetIndexingParams iParams,
+      int partitionNumber, final TaxonomyReader taxonomyReader) {
     return partitionNumber * partitionSize(iParams, taxonomyReader);
   }
 
   /**
-   * @see #partitionOffset(FacetIndexingParams, int, TaxonomyReader)
-   */
-  public final static int partitionOffset (  FacetSearchParams sParams, 
-                        int partitionNumber, 
-                        final TaxonomyReader taxonomyReader) {
-    return partitionOffset(sParams.getFacetIndexingParams(), partitionNumber, taxonomyReader);
-  }
-
-  /**
    * Get the partition size in this parameter, or return the size of the taxonomy, which
    * is smaller.  (Guarantees usage of as little memory as possible at search time).
    */
@@ -57,13 +46,6 @@
   }
 
   /**
-   * @see #partitionSize(FacetIndexingParams, TaxonomyReader)
-   */
-  public final static int partitionSize(FacetSearchParams sParams, final TaxonomyReader taxonomyReader) {
-    return partitionSize(sParams.getFacetIndexingParams(), taxonomyReader);
-  }
-
-  /**
    * Partition number of an ordinal.
    * <p>
    * This allows to locate the partition containing a certain (facet) ordinal.
@@ -74,19 +56,11 @@
   }
 
   /**
-   * @see #partitionNumber(FacetIndexingParams, int)
-   */
-  public final static int partitionNumber(FacetSearchParams sParams, int ordinal) {
-    return partitionNumber(sParams.getFacetIndexingParams(), ordinal);
-  }
-
-  /**
    * Partition name by category ordinal
    */
-  public final static String partitionNameByOrdinal(  FacetIndexingParams iParams, 
-                            CategoryListParams clParams, 
-                            int ordinal) {
-    int partition = partitionNumber(iParams, ordinal); 
+  public final static String partitionNameByOrdinal(
+      FacetIndexingParams iParams, CategoryListParams clParams, int ordinal) {
+    int partition = partitionNumber(iParams, ordinal);
     return partitionName(clParams, partition);
   }
 
Index: lucene/facet/src/test/org/apache/lucene/facet/FacetTestBase.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/FacetTestBase.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/FacetTestBase.java	(working copy)
@@ -15,6 +15,18 @@
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
+import org.apache.lucene.facet.index.CategoryDocumentBuilder;
+import org.apache.lucene.facet.index.params.CategoryListParams;
+import org.apache.lucene.facet.index.params.FacetIndexingParams;
+import org.apache.lucene.facet.search.params.FacetRequest;
+import org.apache.lucene.facet.search.params.FacetSearchParams;
+import org.apache.lucene.facet.search.results.FacetResult;
+import org.apache.lucene.facet.search.results.FacetResultNode;
+import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.TaxonomyReader;
+import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.IndexReader;
@@ -28,24 +40,10 @@
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.store.Directory;
-
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util._TestUtil;
-import org.apache.lucene.facet.index.CategoryDocumentBuilder;
-import org.apache.lucene.facet.index.params.CategoryListParams;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
-import org.apache.lucene.facet.index.params.FacetIndexingParams;
-import org.apache.lucene.facet.search.params.FacetRequest;
-import org.apache.lucene.facet.search.params.FacetSearchParams;
-import org.apache.lucene.facet.search.results.FacetResult;
-import org.apache.lucene.facet.search.results.FacetResultNode;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
-import org.apache.lucene.facet.taxonomy.TaxonomyReader;
-import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
-import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
-import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
@@ -184,29 +182,28 @@
 
   /** Returns a default facet indexing params */
   protected FacetIndexingParams getFacetIndexingParams(final int partSize) {
-    return new DefaultFacetIndexingParams() {
+    return new FacetIndexingParams() {
       @Override
-      protected int fixedPartitionSize() {
+      public int getPartitionSize() {
         return partSize;
       }
     };
   }
   
   /**
-   * Faceted Search Params for the test.
-   * Sub classes should override in order to test with different faceted search params.
+   * Faceted Search Params for the test. Sub classes should override in order to
+   * test with different faceted search params.
    */
-  protected FacetSearchParams getFacetedSearchParams() {
-    return getFacetedSearchParams(Integer.MAX_VALUE);
+  protected FacetSearchParams getFacetSearchParams(FacetIndexingParams iParams, FacetRequest... facetRequests) {
+    return new FacetSearchParams(Arrays.asList(facetRequests), iParams);
   }
 
   /**
-   * Faceted Search Params with specified partition size.
-   * @see #getFacetedSearchParams()
+   * Faceted Search Params for the test. Sub classes should override in order to
+   * test with different faceted search params.
    */
-  protected FacetSearchParams getFacetedSearchParams(int partitionSize) {
-    FacetSearchParams res = new FacetSearchParams(getFacetIndexingParams(partitionSize));
-    return res; 
+  protected FacetSearchParams getFacetSearchParams(List<FacetRequest> facetRequests, FacetIndexingParams iParams) {
+    return new FacetSearchParams(facetRequests, iParams);
   }
 
   /**
Index: lucene/facet/src/test/org/apache/lucene/facet/FacetTestUtils.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/FacetTestUtils.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/FacetTestUtils.java	(working copy)
@@ -2,26 +2,13 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Collection;
+import java.util.List;
 
 import org.apache.lucene.analysis.standard.StandardAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.IndexWriterConfig;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.search.Collector;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.TopScoreDocCollector;
-import org.apache.lucene.store.Directory;
-
-import org.apache.lucene.search.MultiCollector;
-import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.facet.index.CategoryDocumentBuilder;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.FacetsCollector;
 import org.apache.lucene.facet.search.params.CountFacetRequest;
@@ -32,6 +19,17 @@
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.search.Collector;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.MultiCollector;
+import org.apache.lucene.search.TopScoreDocCollector;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -91,19 +89,18 @@
   }
 
   public static Collector[] search(IndexSearcher searcher,
-      TaxonomyReader taxonomyReader, DefaultFacetIndexingParams iParams,
-      int k, String... facetNames) throws IOException {
+      TaxonomyReader taxonomyReader, FacetIndexingParams iParams, int k,
+      String... facetNames) throws IOException {
     
     Collector[] collectors = new Collector[2];
     
-    FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);
-    Collection<FacetRequest> fRequests = new ArrayList<FacetRequest>();
+    List<FacetRequest> fRequests = new ArrayList<FacetRequest>();
     for (String facetName : facetNames) {
       CategoryPath cp = new CategoryPath(facetName);
       FacetRequest fq = new CountFacetRequest(cp, k);
-      facetSearchParams.addFacetRequest(fq);
       fRequests.add(fq);
     }
+    FacetSearchParams facetSearchParams = new FacetSearchParams(fRequests, iParams);
 
     TopScoreDocCollector topDocsCollector = TopScoreDocCollector.create(
         searcher.getIndexReader().maxDoc(), true);
Index: lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy1.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy1.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy1.java	(working copy)
@@ -56,7 +56,7 @@
   }
 
   @Override
-  public Class<? extends CategoryProperty> getRetainableProperty() {
+  public CategoryProperty getRetainableProperty() {
     return null;
   }
 
Index: lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy2.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy2.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy2.java	(working copy)
@@ -65,8 +65,8 @@
   }
 
   @Override
-  public Class<? extends CategoryProperty> getRetainableProperty() {
-    return DummyProperty.class;
+  public CategoryProperty getRetainableProperty() {
+    return DummyProperty.INSTANCE;
   }
 
   @Override
Index: lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy3.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy3.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/enhancements/CategoryEnhancementDummy3.java	(working copy)
@@ -64,7 +64,7 @@
   }
 
   @Override
-  public Class<? extends CategoryProperty> getRetainableProperty() {
+  public CategoryProperty getRetainableProperty() {
     return null;
   }
 
Index: lucene/facet/src/test/org/apache/lucene/facet/enhancements/TwoEnhancementsTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/enhancements/TwoEnhancementsTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/enhancements/TwoEnhancementsTest.java	(working copy)
@@ -7,22 +7,18 @@
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
+import org.apache.lucene.facet.enhancements.params.EnhancementsIndexingParams;
+import org.apache.lucene.facet.search.DrillDown;
+import org.apache.lucene.facet.taxonomy.CategoryPath;
+import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
 import org.junit.Test;
 
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.facet.enhancements.EnhancementsDocumentBuilder;
-import org.apache.lucene.facet.enhancements.EnhancementsPayloadIterator;
-import org.apache.lucene.facet.enhancements.params.DefaultEnhancementsIndexingParams;
-import org.apache.lucene.facet.enhancements.params.EnhancementsIndexingParams;
-import org.apache.lucene.facet.search.DrillDown;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
-import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
-import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -47,10 +43,8 @@
     Directory indexDir = newDirectory();
     Directory taxoDir = newDirectory();
 
-    EnhancementsIndexingParams indexingParams = 
-      new DefaultEnhancementsIndexingParams(
-          new CategoryEnhancementDummy1(),
-          new CategoryEnhancementDummy3());
+    EnhancementsIndexingParams indexingParams = new EnhancementsIndexingParams(
+        new CategoryEnhancementDummy1(), new CategoryEnhancementDummy3());
 
     // add document with a category containing data for both enhancements
     List<CategoryPath> categoryPaths = new ArrayList<CategoryPath>();
@@ -93,10 +87,8 @@
     Directory indexDir = newDirectory();
     Directory taxoDir = newDirectory();
 
-    EnhancementsIndexingParams indexingParams = 
-      new DefaultEnhancementsIndexingParams(
-          new CategoryEnhancementDummy2(),
-          new CategoryEnhancementDummy3());
+    EnhancementsIndexingParams indexingParams = new EnhancementsIndexingParams(
+        new CategoryEnhancementDummy2(), new CategoryEnhancementDummy3());
 
     List<CategoryPath> categoryPaths = new ArrayList<CategoryPath>();
     categoryPaths.add(new CategoryPath("a", "b"));
Index: lucene/facet/src/test/org/apache/lucene/facet/enhancements/association/CustomAssociationPropertyTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/enhancements/association/CustomAssociationPropertyTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/enhancements/association/CustomAssociationPropertyTest.java	(working copy)
@@ -3,14 +3,7 @@
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.store.Directory;
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.facet.enhancements.EnhancementsDocumentBuilder;
-import org.apache.lucene.facet.enhancements.params.DefaultEnhancementsIndexingParams;
 import org.apache.lucene.facet.enhancements.params.EnhancementsIndexingParams;
 import org.apache.lucene.facet.index.CategoryContainer;
 import org.apache.lucene.facet.index.attributes.CategoryAttributeImpl;
@@ -18,6 +11,11 @@
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -51,8 +49,7 @@
     }
 
     final int NUM_CATEGORIES = 10;
-    EnhancementsIndexingParams iParams = new DefaultEnhancementsIndexingParams(
-        new AssociationEnhancement());
+    EnhancementsIndexingParams iParams = new EnhancementsIndexingParams(new AssociationEnhancement());
 
     Directory iDir = newDirectory();
     Directory tDir = newDirectory();
Index: lucene/facet/src/test/org/apache/lucene/facet/enhancements/params/DefaultEnhancementsIndexingParamsTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/enhancements/params/DefaultEnhancementsIndexingParamsTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/enhancements/params/DefaultEnhancementsIndexingParamsTest.java	(working copy)
@@ -1,67 +0,0 @@
-package org.apache.lucene.facet.enhancements.params;
-
-import java.util.List;
-
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.facet.enhancements.CategoryEnhancement;
-import org.apache.lucene.facet.enhancements.CategoryEnhancementDummy1;
-import org.apache.lucene.facet.enhancements.CategoryEnhancementDummy2;
-import org.apache.lucene.facet.enhancements.params.DefaultEnhancementsIndexingParams;
-import org.apache.lucene.facet.enhancements.params.EnhancementsIndexingParams;
-import org.apache.lucene.facet.index.DummyProperty;
-import org.apache.lucene.facet.index.attributes.CategoryProperty;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public class DefaultEnhancementsIndexingParamsTest extends LuceneTestCase {
-
-  @Test
-  public void testCategoryEnhancements() {
-    EnhancementsIndexingParams params = 
-      new DefaultEnhancementsIndexingParams(
-          new CategoryEnhancementDummy1());
-
-    // check retainable properties 
-    List<Class<? extends CategoryProperty>> retainableProps = params
-        .getRetainableProperties();
-    assertNull("Unexpected content in retainable list", retainableProps);
-
-    params.addCategoryEnhancements(new CategoryEnhancementDummy2());
-
-    List<CategoryEnhancement> enhancements = params
-        .getCategoryEnhancements();
-
-    assertEquals("Wrong number of enhancements", 2, enhancements.size());
-
-    assertTrue("Wrong first enhancement",
-        enhancements.get(0) instanceof CategoryEnhancementDummy1);
-    assertTrue("Wrong second enhancement",
-        enhancements.get(1) instanceof CategoryEnhancementDummy2);
-
-    // re-check retainable properties 
-    retainableProps = params.getRetainableProperties();
-    assertNotNull("Unexpected empty retainable list", retainableProps);
-    assertEquals("Unexpected size of retainable list", 1, retainableProps
-        .size());
-    assertEquals("Wrong property in retainable list", DummyProperty.class,
-        retainableProps.get(0));
-
-  }
-}
Index: lucene/facet/src/test/org/apache/lucene/facet/enhancements/params/EnhancementsIndexingParamsTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/enhancements/params/EnhancementsIndexingParamsTest.java	(working copy)
+++ lucene/facet/src/test/org/apache/lucene/facet/enhancements/params/EnhancementsIndexingParamsTest.java	(working copy)
@@ -2,16 +2,13 @@
 
 import java.util.List;
 
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.facet.enhancements.CategoryEnhancement;
 import org.apache.lucene.facet.enhancements.CategoryEnhancementDummy1;
 import org.apache.lucene.facet.enhancements.CategoryEnhancementDummy2;
-import org.apache.lucene.facet.enhancements.params.DefaultEnhancementsIndexingParams;
-import org.apache.lucene.facet.enhancements.params.EnhancementsIndexingParams;
 import org.apache.lucene.facet.index.DummyProperty;
 import org.apache.lucene.facet.index.attributes.CategoryProperty;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -30,38 +27,25 @@
  * limitations under the License.
  */
 
-public class DefaultEnhancementsIndexingParamsTest extends LuceneTestCase {
+public class EnhancementsIndexingParamsTest extends LuceneTestCase {
 
   @Test
   public void testCategoryEnhancements() {
-    EnhancementsIndexingParams params = 
-      new DefaultEnhancementsIndexingParams(
-          new CategoryEnhancementDummy1());
+    EnhancementsIndexingParams params = new EnhancementsIndexingParams(
+        new CategoryEnhancementDummy1(), new CategoryEnhancementDummy2());
 
-    // check retainable properties 
-    List<Class<? extends CategoryProperty>> retainableProps = params
-        .getRetainableProperties();
-    assertNull("Unexpected content in retainable list", retainableProps);
-
-    params.addCategoryEnhancements(new CategoryEnhancementDummy2());
-
-    List<CategoryEnhancement> enhancements = params
-        .getCategoryEnhancements();
-
+    List<CategoryEnhancement> enhancements = params.getCategoryEnhancements();
     assertEquals("Wrong number of enhancements", 2, enhancements.size());
 
-    assertTrue("Wrong first enhancement",
-        enhancements.get(0) instanceof CategoryEnhancementDummy1);
-    assertTrue("Wrong second enhancement",
-        enhancements.get(1) instanceof CategoryEnhancementDummy2);
+    // check order
+    assertTrue("Wrong first enhancement", enhancements.get(0) instanceof CategoryEnhancementDummy1);
+    assertTrue("Wrong second enhancement", enhancements.get(1) instanceof CategoryEnhancementDummy2);
 
-    // re-check retainable properties 
-    retainableProps = params.getRetainableProperties();
+    // check retainable properties 
+    List<CategoryProperty> retainableProps = params.getRetainableProperties();
     assertNotNull("Unexpected empty retainable list", retainableProps);
-    assertEquals("Unexpected size of retainable list", 1, retainableProps
-        .size());
-    assertEquals("Wrong property in retainable list", DummyProperty.class,
-        retainableProps.get(0));
-
+    assertEquals("Unexpected size of retainable list", 1, retainableProps.size());
+    assertSame("Wrong property in retainable list", DummyProperty.INSTANCE, retainableProps.get(0));
   }
+  
 }
Index: lucene/facet/src/test/org/apache/lucene/facet/index/CategoryContainerTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/index/CategoryContainerTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/index/CategoryContainerTest.java	(working copy)
@@ -62,7 +62,7 @@
   @Test
   public void testExistingNewCategoryWithProperty() throws FacetException {
     categoryContainer.addCategory(new CategoryPath("five", "six"),
-        new DummyProperty());
+        DummyProperty.INSTANCE);
     Iterator<CategoryAttribute> iterator = categoryContainer.iterator();
 
     // count the number of tokens, and check there is one DummyAttribute
@@ -83,12 +83,12 @@
     AssociationProperty associationProperty = new AssociationIntProperty(
         49);
     categoryContainer.addCategory(new CategoryPath("five", "six"),
-        new DummyProperty(), associationProperty);
+        DummyProperty.INSTANCE, associationProperty);
     categoryContainer.addCategory(new CategoryPath("seven", "eight"),
-        new DummyProperty());
+        DummyProperty.INSTANCE);
     associationProperty = new AssociationIntProperty(123);
     categoryContainer.addCategory(new CategoryPath("nine"),
-        associationProperty, new DummyProperty());
+        associationProperty, DummyProperty.INSTANCE);
     Iterator<CategoryAttribute> iterator = categoryContainer.iterator();
 
     // count the number of tokens, and check there is one DummyAttribute
@@ -114,7 +114,7 @@
   @Test
   public void testAddNewCategoryWithProperty() throws FacetException {
     categoryContainer.addCategory(new CategoryPath("seven", "eight"),
-        new DummyProperty());
+        DummyProperty.INSTANCE);
     Iterator<CategoryAttribute> iterator = categoryContainer.iterator();
 
     // count the number of tokens, and check there is one DummyAttribute
@@ -150,7 +150,7 @@
   public void testAddCategoryAttributeWithProperty() throws FacetException {
     CategoryAttribute newCA = new CategoryAttributeImpl(new CategoryPath(
         "seven", "eight"));
-    newCA.addProperty(new DummyProperty());
+    newCA.addProperty(DummyProperty.INSTANCE);
     categoryContainer.addCategory(newCA);
     Iterator<CategoryAttribute> iterator = categoryContainer.iterator();
 
@@ -215,12 +215,12 @@
     AssociationProperty associationProperty = new AssociationIntProperty(
         49);
     categoryContainer.addCategory(new CategoryPath("five", "six"),
-        new DummyProperty(), associationProperty);
+        DummyProperty.INSTANCE, associationProperty);
     categoryContainer.addCategory(new CategoryPath("seven", "eight"),
-        new DummyProperty());
+        DummyProperty.INSTANCE);
     associationProperty = new AssociationIntProperty(123);
     categoryContainer.addCategory(new CategoryPath("nine"),
-        associationProperty, new DummyProperty());
+        associationProperty, DummyProperty.INSTANCE);
     
     ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);
     ObjectOutputStream out = new ObjectOutputStream(baos);
Index: lucene/facet/src/test/org/apache/lucene/facet/index/DummyProperty.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/index/DummyProperty.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/index/DummyProperty.java	(working copy)
@@ -24,6 +24,10 @@
  */
 public class DummyProperty implements CategoryProperty {
 
+  public static final DummyProperty INSTANCE = new DummyProperty();
+  
+  private DummyProperty() {}
+  
   @Override
   public boolean equals(Object o) {
     if (o instanceof DummyProperty) {
Index: lucene/facet/src/test/org/apache/lucene/facet/index/FacetsPayloadProcessorProviderTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/index/FacetsPayloadProcessorProviderTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/index/FacetsPayloadProcessorProviderTest.java	(working copy)
@@ -70,8 +70,7 @@
     DirectoryReader reader1 = DirectoryReader.open(dir);
     DirectoryTaxonomyReader taxReader = new DirectoryTaxonomyReader(taxDir);
     IndexSearcher searcher = newSearcher(reader1);
-    FacetSearchParams fsp = new FacetSearchParams();
-    fsp.addFacetRequest(new CountFacetRequest(new CategoryPath("tag"), NUM_DOCS));
+    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new CategoryPath("tag"), NUM_DOCS));
     FacetsCollector collector = new FacetsCollector(fsp, reader1, taxReader);
     searcher.search(new MatchAllDocsQuery(), collector);
     FacetResult result = collector.getFacetResults().get(0);
Index: lucene/facet/src/test/org/apache/lucene/facet/index/attributes/CategoryAttributeImplTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/index/attributes/CategoryAttributeImplTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/index/attributes/CategoryAttributeImplTest.java	(working copy)
@@ -57,15 +57,15 @@
         .getProperty(DummyProperty.class));
     assertNull("Attribute classes should be null", ca.getPropertyClasses());
 
-    ca.addProperty(new DummyProperty());
+    ca.addProperty(DummyProperty.INSTANCE);
     assertEquals("DummyProperty should be in properties",
-        new DummyProperty(), ca.getProperty(DummyProperty.class));
+        DummyProperty.INSTANCE, ca.getProperty(DummyProperty.class));
     assertEquals("Attribute classes should contain 1 element", 1, ca
         .getPropertyClasses().size());
 
     boolean failed = false;
     try {
-      ca.addProperty(new DummyProperty());
+      ca.addProperty(DummyProperty.INSTANCE);
     } catch (UnsupportedOperationException e) {
       failed = true;
     }
@@ -77,24 +77,24 @@
     ca.clearProperties();
     assertNull("Attribute classes should be null", ca.getPropertyClasses());
 
-    ca.addProperty(new DummyProperty());
+    ca.addProperty(DummyProperty.INSTANCE);
     assertEquals("DummyProperty should be in properties",
-        new DummyProperty(), ca.getProperty(DummyProperty.class));
+        DummyProperty.INSTANCE, ca.getProperty(DummyProperty.class));
     ca.remove(DummyProperty.class);
     assertEquals("DummyProperty should not be in properties", null, ca
         .getProperty(DummyProperty.class));
     assertNull("Attribute classes should be null", ca.getPropertyClasses());
 
-    ca.addProperty(new DummyProperty());
+    ca.addProperty(DummyProperty.INSTANCE);
     List<Class<? extends CategoryProperty>> propertyClasses = new ArrayList<Class<? extends CategoryProperty>>();
     assertEquals("No property expected when no classes given", null, ca
         .getProperty(propertyClasses));
     propertyClasses.add(DummyProperty.class);
     assertEquals("DummyProperty should be in properties",
-        new DummyProperty(), ca.getProperty(propertyClasses));
+        DummyProperty.INSTANCE, ca.getProperty(propertyClasses));
     propertyClasses.add(OrdinalProperty.class);
     assertEquals("DummyProperty should be in properties",
-        new DummyProperty(), ca.getProperty(propertyClasses));
+        DummyProperty.INSTANCE, ca.getProperty(propertyClasses));
     propertyClasses.clear();
     propertyClasses.add(OrdinalProperty.class);
     assertEquals("No ordinal property expected", null, ca
@@ -107,7 +107,7 @@
 
     CategoryPath cp = new CategoryPath("a", "b");
     ca1.setCategoryPath(cp);
-    ca1.addProperty(new DummyProperty());
+    ca1.addProperty(DummyProperty.INSTANCE);
 
     CategoryAttribute ca2 = ca1.clone();
     assertEquals("Error in cloning", ca1, ca2);
Index: lucene/facet/src/test/org/apache/lucene/facet/index/params/DefaultFacetIndexingParamsTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/index/params/DefaultFacetIndexingParamsTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/index/params/DefaultFacetIndexingParamsTest.java	(working copy)
@@ -1,109 +0,0 @@
-package org.apache.lucene.facet.index.params;
-
-import org.apache.lucene.facet.index.categorypolicy.OrdinalPolicy;
-import org.apache.lucene.facet.index.categorypolicy.PathPolicy;
-import org.apache.lucene.facet.search.DrillDown;
-import org.apache.lucene.facet.taxonomy.CategoryPath;
-import org.apache.lucene.facet.taxonomy.TaxonomyReader;
-import org.apache.lucene.facet.util.PartitionsUtils;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.util.LuceneTestCase;
-import org.junit.Test;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public class DefaultFacetIndexingParamsTest extends LuceneTestCase {
-
-  @Test
-  public void testDefaultSettings() {
-    FacetIndexingParams dfip = new DefaultFacetIndexingParams();
-    assertNotNull("Missing default category list", dfip
-        .getAllCategoryListParams());
-    assertEquals(
-        "all categories have the same CategoryListParams by default",
-        dfip.getCategoryListParams(null), dfip
-            .getCategoryListParams(new CategoryPath("a")));
-    assertEquals(
-        "Expected default category list term is $facets:$fulltree$",
-        new Term("$facets", "$fulltree$"), dfip.getCategoryListParams(
-            null).getTerm());
-    String expectedDDText = "a"
-        + dfip.getFacetDelimChar() + "b";
-    CategoryPath cp = new CategoryPath("a", "b");
-    assertEquals("wrong drill-down term", new Term("$facets",
-        expectedDDText), DrillDown.term(dfip,cp));
-    char[] buf = new char[20];
-    int numchars = dfip.drillDownTermText(cp, buf);
-    assertEquals("3 characters should be written", 3, numchars);
-    assertEquals("wrong drill-down term text", expectedDDText, new String(
-        buf, 0, numchars));
-    CategoryListParams clParams = dfip.getCategoryListParams(null);
-    assertEquals("partition for all ordinals is the first", "$fulltree$", 
-        PartitionsUtils.partitionNameByOrdinal(dfip, clParams , 250));
-    assertEquals("for partition 0, the same name should be returned",
-        "$fulltree$", PartitionsUtils.partitionName(clParams, 0));
-    assertEquals(
-        "for any other, it's the concatenation of name + partition",
-        "$fulltree$1", PartitionsUtils.partitionName(clParams, 1));
-    assertEquals("default partition number is always 0", 0, 
-        PartitionsUtils.partitionNumber(dfip,100));
-    assertEquals("default partition size is unbounded", Integer.MAX_VALUE,
-        dfip.getPartitionSize());
-  }
-
-  @Test
-  public void testCategoryListParamsWithDefaultIndexingParams() {
-    CategoryListParams clp = new CategoryListParams(
-        new Term("clp", "value"));
-    FacetIndexingParams dfip = new DefaultFacetIndexingParams(clp);
-    assertEquals("Expected default category list term is " + clp.getTerm(),
-        clp.getTerm(), dfip.getCategoryListParams(null).getTerm());
-  }
-
-  @Test
-  public void testCategoryPolicies() {
-    FacetIndexingParams dfip = new DefaultFacetIndexingParams();
-    // check path policy
-    CategoryPath cp = new CategoryPath();
-    PathPolicy pathPolicy = PathPolicy.ALL_CATEGORIES;
-    assertEquals("path policy does not match default for root", pathPolicy.shouldAdd(cp), dfip.getPathPolicy().shouldAdd(cp));
-    for (int i = 0; i < 30; i++) {
-      int nComponents = random().nextInt(10);
-      String[] components = new String[nComponents];
-      for (int j = 0; j < components.length; j++) {
-        components[j] = (Integer.valueOf(random().nextInt(30))).toString();
-      }
-      cp = new CategoryPath(components);
-      assertEquals("path policy does not match default for " + cp.toString('/'), 
-          pathPolicy.shouldAdd(cp), dfip.getPathPolicy().shouldAdd(cp));
-    }
-
-    // check ordinal policy
-    OrdinalPolicy ordinalPolicy = OrdinalPolicy.ALL_PARENTS;
-    assertEquals("ordinal policy does not match default for root", 
-        ordinalPolicy.shouldAdd(TaxonomyReader.ROOT_ORDINAL), 
-        dfip.getOrdinalPolicy().shouldAdd(TaxonomyReader.ROOT_ORDINAL));
-    for (int i = 0; i < 30; i++) {
-      int ordinal = random().nextInt();
-      assertEquals("ordinal policy does not match default for " + ordinal, 
-          ordinalPolicy.shouldAdd(ordinal),
-          dfip.getOrdinalPolicy().shouldAdd(ordinal));
-    }
-  }
-
-}
\ No newline at end of file
Index: lucene/facet/src/test/org/apache/lucene/facet/index/params/FacetIndexingParamsTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/index/params/FacetIndexingParamsTest.java	(working copy)
+++ lucene/facet/src/test/org/apache/lucene/facet/index/params/FacetIndexingParamsTest.java	(working copy)
@@ -27,21 +27,16 @@
  * limitations under the License.
  */
 
-public class DefaultFacetIndexingParamsTest extends LuceneTestCase {
+public class FacetIndexingParamsTest extends LuceneTestCase {
 
   @Test
   public void testDefaultSettings() {
-    FacetIndexingParams dfip = new DefaultFacetIndexingParams();
-    assertNotNull("Missing default category list", dfip
-        .getAllCategoryListParams());
-    assertEquals(
-        "all categories have the same CategoryListParams by default",
-        dfip.getCategoryListParams(null), dfip
-            .getCategoryListParams(new CategoryPath("a")));
-    assertEquals(
-        "Expected default category list term is $facets:$fulltree$",
-        new Term("$facets", "$fulltree$"), dfip.getCategoryListParams(
-            null).getTerm());
+    FacetIndexingParams dfip = FacetIndexingParams.ALL_PARENTS;
+    assertNotNull("Missing default category list", dfip.getAllCategoryListParams());
+    assertEquals("all categories have the same CategoryListParams by default",
+        dfip.getCategoryListParams(null), dfip.getCategoryListParams(new CategoryPath("a")));
+    assertEquals("Expected default category list term is $facets:$fulltree$",
+        new Term("$facets", "$fulltree$"), dfip.getCategoryListParams(null).getTerm());
     String expectedDDText = "a"
         + dfip.getFacetDelimChar() + "b";
     CategoryPath cp = new CategoryPath("a", "b");
@@ -70,14 +65,14 @@
   public void testCategoryListParamsWithDefaultIndexingParams() {
     CategoryListParams clp = new CategoryListParams(
         new Term("clp", "value"));
-    FacetIndexingParams dfip = new DefaultFacetIndexingParams(clp);
+    FacetIndexingParams dfip = new FacetIndexingParams(clp);
     assertEquals("Expected default category list term is " + clp.getTerm(),
         clp.getTerm(), dfip.getCategoryListParams(null).getTerm());
   }
 
   @Test
   public void testCategoryPolicies() {
-    FacetIndexingParams dfip = new DefaultFacetIndexingParams();
+    FacetIndexingParams dfip = FacetIndexingParams.ALL_PARENTS;
     // check path policy
     CategoryPath cp = new CategoryPath();
     PathPolicy pathPolicy = PathPolicy.ALL_CATEGORIES;
Index: lucene/facet/src/test/org/apache/lucene/facet/index/params/PerDimensionIndexingParamsTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/index/params/PerDimensionIndexingParamsTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/index/params/PerDimensionIndexingParamsTest.java	(working copy)
@@ -1,15 +1,13 @@
 package org.apache.lucene.facet.index.params;
 
-import org.apache.lucene.index.Term;
-import org.junit.Test;
+import java.util.Collections;
 
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.facet.index.params.CategoryListParams;
-import org.apache.lucene.facet.index.params.FacetIndexingParams;
-import org.apache.lucene.facet.index.params.PerDimensionIndexingParams;
 import org.apache.lucene.facet.search.DrillDown;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.util.PartitionsUtils;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -32,9 +30,8 @@
 
   @Test
   public void testTopLevelSettings() {
-    FacetIndexingParams ifip = new PerDimensionIndexingParams();
-    assertNotNull("Missing default category list", ifip
-        .getAllCategoryListParams());
+    FacetIndexingParams ifip = new PerDimensionIndexingParams(Collections.<CategoryPath, CategoryListParams>emptyMap());
+    assertNotNull("Missing default category list", ifip.getAllCategoryListParams());
     assertEquals(
         "Expected default category list term is $facets:$fulltree$",
         new Term("$facets", "$fulltree$"), ifip.getCategoryListParams(
@@ -67,15 +64,12 @@
 
   @Test
   public void testCategoryListParamsAddition() {
-    PerDimensionIndexingParams tlfip = new PerDimensionIndexingParams();
-    CategoryListParams clp = new CategoryListParams(
-        new Term("clp", "value"));
-    tlfip.addCategoryListParams(new CategoryPath("a"), clp);
-    assertEquals("Expected category list term is " + clp.getTerm(), clp
-        .getTerm(), tlfip.getCategoryListParams(new CategoryPath("a"))
-        .getTerm());
-    assertNotSame("Unexpected default category list " + clp.getTerm(), clp,
-        tlfip.getCategoryListParams(null));
+    CategoryListParams clp = new CategoryListParams(new Term("clp", "value"));
+    PerDimensionIndexingParams tlfip = new PerDimensionIndexingParams(
+        Collections.<CategoryPath,CategoryListParams> singletonMap(new CategoryPath("a"), clp));
+    assertEquals("Expected category list term is " + clp.getTerm(), 
+        clp.getTerm(), tlfip.getCategoryListParams(new CategoryPath("a")).getTerm());
+    assertNotSame("Unexpected default category list " + clp.getTerm(), clp, tlfip.getCategoryListParams(null));
   }
 
 }
\ No newline at end of file
Index: lucene/facet/src/test/org/apache/lucene/facet/index/streaming/CategoryParentsStreamTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/index/streaming/CategoryParentsStreamTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/index/streaming/CategoryParentsStreamTest.java	(working copy)
@@ -3,20 +3,17 @@
 import java.io.IOException;
 
 import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.store.Directory;
-import org.junit.Test;
-
-import org.apache.lucene.facet.FacetException;
 import org.apache.lucene.facet.index.CategoryContainerTestBase;
 import org.apache.lucene.facet.index.DummyProperty;
 import org.apache.lucene.facet.index.categorypolicy.NonTopLevelOrdinalPolicy;
 import org.apache.lucene.facet.index.categorypolicy.NonTopLevelPathPolicy;
 import org.apache.lucene.facet.index.categorypolicy.OrdinalPolicy;
 import org.apache.lucene.facet.index.categorypolicy.PathPolicy;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.store.Directory;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -49,7 +46,7 @@
         directory);
     CategoryParentsStream stream = new CategoryParentsStream(
         new CategoryAttributesStream(categoryContainer),
-        taxonomyWriter, new DefaultFacetIndexingParams());
+        taxonomyWriter, FacetIndexingParams.ALL_PARENTS);
 
     // count the number of tokens
     int nTokens;
@@ -72,13 +69,13 @@
     Directory directory = newDirectory();
     final TaxonomyWriter taxonomyWriter = new DirectoryTaxonomyWriter(
         directory);
-    FacetIndexingParams indexingParams = new DefaultFacetIndexingParams() {
+    FacetIndexingParams indexingParams = new FacetIndexingParams() {
       @Override
-      protected OrdinalPolicy fixedOrdinalPolicy() {
+      public OrdinalPolicy getOrdinalPolicy() {
         return new NonTopLevelOrdinalPolicy();
       }
       @Override
-      protected PathPolicy fixedPathPolicy() {
+      public PathPolicy getPathPolicy() {
         return new NonTopLevelPathPolicy();
       }
     };
@@ -110,15 +107,14 @@
     Directory directory = newDirectory();
     TaxonomyWriter taxonomyWriter = new DirectoryTaxonomyWriter(directory);
 
-    new CategoryParentsStream(new CategoryAttributesStream(categoryContainer),
-        taxonomyWriter, new DefaultFacetIndexingParams());
+    assertNotNull(new CategoryParentsStream(new CategoryAttributesStream(categoryContainer),
+        taxonomyWriter, FacetIndexingParams.ALL_PARENTS));
 
     // add DummyAttribute, but do not retain, only one expected
-    categoryContainer.addCategory(initialCatgeories[0], new DummyProperty());
+    categoryContainer.addCategory(initialCatgeories[0], DummyProperty.INSTANCE);
 
     CategoryParentsStream stream = new CategoryParentsStream(new CategoryAttributesStream(
-        categoryContainer), taxonomyWriter,
-        new DefaultFacetIndexingParams());
+        categoryContainer), taxonomyWriter, FacetIndexingParams.ALL_PARENTS);
 
     int nAttributes = 0;
     while (stream.incrementToken()) {
@@ -139,24 +135,21 @@
   @Test
   public void testRetainableAttributes() throws IOException {
     Directory directory = newDirectory();
-    TaxonomyWriter taxonomyWriter = new DirectoryTaxonomyWriter(
-        directory);
+    TaxonomyWriter taxonomyWriter = new DirectoryTaxonomyWriter(directory);
 
-    FacetIndexingParams indexingParams = new DefaultFacetIndexingParams();
-    new CategoryParentsStream(new CategoryAttributesStream(
-        categoryContainer), taxonomyWriter, indexingParams);
+    FacetIndexingParams indexingParams = FacetIndexingParams.ALL_PARENTS;
+    assertNotNull(new CategoryParentsStream(new CategoryAttributesStream(
+        categoryContainer), taxonomyWriter, indexingParams));
 
     // add DummyAttribute and retain it, three expected
     categoryContainer.clear();
-    categoryContainer
-        .addCategory(initialCatgeories[0], new DummyProperty());
+    categoryContainer.addCategory(initialCatgeories[0], DummyProperty.INSTANCE);
     CategoryParentsStream stream = new CategoryParentsStream(
         new CategoryAttributesStream(categoryContainer),
-        taxonomyWriter, new DefaultFacetIndexingParams());
+        taxonomyWriter, FacetIndexingParams.ALL_PARENTS);
     stream.addRetainableProperty(DummyProperty.class);
 
-    MyCategoryListTokenizer tokenizer = new MyCategoryListTokenizer(stream,
-        indexingParams);
+    MyCategoryListTokenizer tokenizer = new MyCategoryListTokenizer(stream, indexingParams);
 
     int nAttributes = 0;
     try {
Index: lucene/facet/src/test/org/apache/lucene/facet/index/streaming/CategoryTokenizerTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/index/streaming/CategoryTokenizerTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/index/streaming/CategoryTokenizerTest.java	(working copy)
@@ -7,17 +7,14 @@
 import java.util.Set;
 
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.store.Directory;
-import org.junit.Test;
-
 import org.apache.lucene.facet.index.CategoryContainerTestBase;
 import org.apache.lucene.facet.index.attributes.CategoryAttributesIterable;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
-import org.apache.lucene.facet.index.streaming.CategoryAttributesStream;
-import org.apache.lucene.facet.index.streaming.CategoryTokenizer;
+import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.store.Directory;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -47,7 +44,7 @@
     Directory directory = newDirectory();
     TaxonomyWriter taxonomyWriter = new DirectoryTaxonomyWriter(
         directory);
-    DefaultFacetIndexingParams indexingParams = new DefaultFacetIndexingParams();
+    FacetIndexingParams indexingParams = FacetIndexingParams.ALL_PARENTS;
     CategoryTokenizer tokenizer = new CategoryTokenizer(
         new CategoryAttributesStream(categoryContainer),
         indexingParams);
@@ -89,7 +86,7 @@
     longCategory.add(new CategoryPath("one", "two", "three", "four",
         "five", "six", "seven"));
 
-    DefaultFacetIndexingParams indexingParams = new DefaultFacetIndexingParams();
+    FacetIndexingParams indexingParams = FacetIndexingParams.ALL_PARENTS;
     CategoryTokenizer tokenizer = new CategoryTokenizer(
         new CategoryAttributesStream(new CategoryAttributesIterable(
             longCategory)), indexingParams);
Index: lucene/facet/src/test/org/apache/lucene/facet/search/BaseTestTopK.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/BaseTestTopK.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/BaseTestTopK.java	(working copy)
@@ -1,6 +1,7 @@
 package org.apache.lucene.facet.search;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
@@ -12,6 +13,7 @@
 import org.apache.lucene.facet.FacetTestBase;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.params.CountFacetRequest;
+import org.apache.lucene.facet.search.params.FacetRequest;
 import org.apache.lucene.facet.search.params.FacetSearchParams;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
@@ -97,12 +99,12 @@
   }
   
   protected FacetSearchParams searchParamsWithRequests(int numResults, int partitionSize) {
-    FacetSearchParams res = getFacetedSearchParams(partitionSize);
-    res.addFacetRequest(new CountFacetRequest(new CategoryPath("a"), numResults));
-    res.addFacetRequest(new CountFacetRequest(new CategoryPath("a", "1"), numResults));
-    res.addFacetRequest(new CountFacetRequest(new CategoryPath("a", "1", "10"), numResults));
-    res.addFacetRequest(new CountFacetRequest(new CategoryPath("a", "2",  "26", "267"), numResults));
-    return res;
+    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
+    facetRequests.add(new CountFacetRequest(new CategoryPath("a"), numResults));
+    facetRequests.add(new CountFacetRequest(new CategoryPath("a", "1"), numResults));
+    facetRequests.add(new CountFacetRequest(new CategoryPath("a", "1", "10"), numResults));
+    facetRequests.add(new CountFacetRequest(new CategoryPath("a", "2",  "26", "267"), numResults));
+    return getFacetSearchParams(facetRequests, getFacetIndexingParams(partitionSize));
   }
 
   @Override
Index: lucene/facet/src/test/org/apache/lucene/facet/search/DrillDownTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/DrillDownTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/DrillDownTest.java	(working copy)
@@ -2,6 +2,8 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Map;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
@@ -10,8 +12,8 @@
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.facet.index.CategoryDocumentBuilder;
 import org.apache.lucene.facet.index.params.CategoryListParams;
+import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.index.params.PerDimensionIndexingParams;
-import org.apache.lucene.facet.search.params.FacetSearchParams;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
@@ -49,22 +51,18 @@
 
 public class DrillDownTest extends LuceneTestCase {
   
-  private FacetSearchParams defaultParams = new FacetSearchParams();
-  private FacetSearchParams nonDefaultParams;
+  private FacetIndexingParams defaultParams = FacetIndexingParams.ALL_PARENTS;
+  private PerDimensionIndexingParams nonDefaultParams;
   private static IndexReader reader;
   private static DirectoryTaxonomyReader taxo;
   private static Directory dir;
   private static Directory taxoDir;
   
   public DrillDownTest() {
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams();
-    CategoryListParams aClParams = new CategoryListParams(new Term("testing_facets_a", "a"));
-    CategoryListParams bClParams = new CategoryListParams(new Term("testing_facets_b", "b"));
-    
-    iParams.addCategoryListParams(new CategoryPath("a"), aClParams);
-    iParams.addCategoryListParams(new CategoryPath("b"), bClParams);
-    
-    nonDefaultParams = new FacetSearchParams(iParams);
+    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
+    paramsMap.put(new CategoryPath("a"), new CategoryListParams(new Term("testing_facets_a", "a")));
+    paramsMap.put(new CategoryPath("b"), new CategoryListParams(new Term("testing_facets_b", "b")));
+    nonDefaultParams = new PerDimensionIndexingParams(paramsMap);
   }
 
   @BeforeClass
Index: lucene/facet/src/test/org/apache/lucene/facet/search/TestCategoryListCache.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/TestCategoryListCache.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/TestCategoryListCache.java	(working copy)
@@ -1,6 +1,7 @@
 package org.apache.lucene.facet.search;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
@@ -16,6 +17,7 @@
 import org.apache.lucene.facet.search.cache.CategoryListCache;
 import org.apache.lucene.facet.search.cache.CategoryListData;
 import org.apache.lucene.facet.search.params.CountFacetRequest;
+import org.apache.lucene.facet.search.params.FacetRequest;
 import org.apache.lucene.facet.search.params.FacetSearchParams;
 import org.apache.lucene.facet.search.results.FacetResult;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
@@ -74,22 +76,29 @@
   
   private void doTest(boolean withCache, boolean plantWrongData) throws Exception {
     Map<CategoryPath,Integer> truth = facetCountsTruth();
-    CategoryPath cp = (CategoryPath) truth.keySet().toArray()[0]; // any category path will do for this test 
-    CountFacetRequest frq = new CountFacetRequest(cp, 10);
-    FacetSearchParams sParams = getFacetedSearchParams();
-    sParams.addFacetRequest(frq);
+    CategoryPath cp = (CategoryPath) truth.keySet().toArray()[0]; // any category path will do for this test
+    FacetIndexingParams iParams = FacetIndexingParams.ALL_PARENTS;
+    final CategoryListCache clCache;
     if (withCache) {
       //let's use a cached cl data
-      FacetIndexingParams iparams = sParams.getFacetIndexingParams();
       CategoryListParams clp = new CategoryListParams(); // default term ok as only single list
-      CategoryListCache clCache = new CategoryListCache();
-      clCache.loadAndRegister(clp, indexReader, taxoReader, iparams);
+      clCache = new CategoryListCache();
+      clCache.loadAndRegister(clp, indexReader, taxoReader, iParams);
       if (plantWrongData) {
         // let's mess up the cached data and then expect a wrong result...
         messCachedData(clCache, clp);
       }
-      sParams.setClCache(clCache);
+    } else {
+      clCache = null;
     }
+    List<FacetRequest> req = new ArrayList<FacetRequest>();
+    req.add(new CountFacetRequest(cp, 10));
+    final FacetSearchParams sParams = new FacetSearchParams(req, iParams) {
+      @Override
+      public CategoryListCache getCategoryListCache() {
+        return clCache;
+      }
+    };
     FacetsCollector fc = new FacetsCollector(sParams, indexReader, taxoReader);
     searcher.search(new MatchAllDocsQuery(), fc);
     List<FacetResult> res = fc.getFacetResults();
Index: lucene/facet/src/test/org/apache/lucene/facet/search/TestDemoFacets.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/TestDemoFacets.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/TestDemoFacets.java	(working copy)
@@ -84,12 +84,10 @@
     TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoWriter);
     taxoWriter.close();
 
-    // Holds all configuration for a facet request:
-    FacetSearchParams fsp = new FacetSearchParams();
-
     // Count both "Publish Date" and "Author" dimensions:
-    fsp.addFacetRequest(new CountFacetRequest(new CategoryPath("Publish Date"), 10));
-    fsp.addFacetRequest(new CountFacetRequest(new CategoryPath("Author"), 10));
+    FacetSearchParams fsp = new FacetSearchParams(
+        new CountFacetRequest(new CategoryPath("Publish Date"), 10), 
+        new CountFacetRequest(new CategoryPath("Author"), 10));
 
     // Aggregatses the facet counts:
     FacetsCollector c = new FacetsCollector(fsp, searcher.getIndexReader(), taxoReader);
@@ -110,9 +108,8 @@
 
     
     // Now user drills down on Publish Date/2010:
-    fsp = new FacetSearchParams();
+    fsp = new FacetSearchParams(new CountFacetRequest(new CategoryPath("Author"), 10));
     Query q2 = DrillDown.query(fsp, new MatchAllDocsQuery(), new CategoryPath("Publish Date/2010", '/'));
-    fsp.addFacetRequest(new CountFacetRequest(new CategoryPath("Author"), 10));
     c = new FacetsCollector(fsp, searcher.getIndexReader(), taxoReader);
     searcher.search(q2, c);
     results = c.getFacetResults();
Index: lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsAccumulatorWithComplement.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsAccumulatorWithComplement.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsAccumulatorWithComplement.java	(working copy)
@@ -123,18 +123,15 @@
     
   }
   
-  @Override
-  protected FacetSearchParams getFacetedSearchParams() {
-    FacetSearchParams res = super.getFacetedSearchParams();
-    res.addFacetRequest(new CountFacetRequest(new CategoryPath("root","a"), 10));
-    return res;
+  private FacetSearchParams getFacetSearchParams() {
+    return new FacetSearchParams(new CountFacetRequest(new CategoryPath("root","a"), 10));
   }
   
   /** compute facets with certain facet requests and docs */
   private List<FacetResult> findFacets(ScoredDocIDs sDocids, boolean withComplement) throws IOException {
     
     FacetsAccumulator fAccumulator = 
-      new StandardFacetsAccumulator(getFacetedSearchParams(), indexReader, taxoReader);
+      new StandardFacetsAccumulator(getFacetSearchParams(), indexReader, taxoReader);
     
     fAccumulator.setComplementThreshold(
         withComplement ? 
Index: lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsCollector.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsCollector.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/TestFacetsCollector.java	(working copy)
@@ -67,8 +67,7 @@
     taxonomyWriter.close();
     iw.close();
     
-    FacetSearchParams sParams = new FacetSearchParams();
-    sParams.addFacetRequest(new ScoreFacetRequest(new CategoryPath("a"), 10));
+    FacetSearchParams sParams = new FacetSearchParams(new ScoreFacetRequest(new CategoryPath("a"), 10));
     
     DirectoryReader r = DirectoryReader.open(indexDir);
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
Index: lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/TestMultipleCategoryLists.java	(working copy)
@@ -1,8 +1,12 @@
 package org.apache.lucene.facet.search;
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
@@ -11,6 +15,7 @@
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.index.params.PerDimensionIndexingParams;
 import org.apache.lucene.facet.search.params.CountFacetRequest;
+import org.apache.lucene.facet.search.params.FacetRequest;
 import org.apache.lucene.facet.search.params.FacetSearchParams;
 import org.apache.lucene.facet.search.params.FacetRequest.ResultMode;
 import org.apache.lucene.facet.search.results.FacetResult;
@@ -70,7 +75,7 @@
     /**
      * Configure with no custom counting lists
      */
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams();
+    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(Collections.<CategoryPath, CategoryListParams>emptyMap());
 
     seedIndex(iw, tw, iParams);
 
@@ -109,9 +114,9 @@
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(dirs[0][1],
         OpenMode.CREATE);
 
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams();
-    iParams.addCategoryListParams(new CategoryPath("Author"),
-        new CategoryListParams(new Term("$author", "Authors")));
+    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(
+        Collections.singletonMap(new CategoryPath("Author"),
+            new CategoryListParams(new Term("$author", "Authors"))));
     seedIndex(iw, tw, iParams);
 
     IndexReader ir = iw.getReader();
@@ -148,11 +153,10 @@
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(dirs[0][1],
         OpenMode.CREATE);
 
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams();
-    iParams.addCategoryListParams(new CategoryPath("Band"),
-        new CategoryListParams(new Term("$music", "Bands")));
-    iParams.addCategoryListParams(new CategoryPath("Composer"),
-        new CategoryListParams(new Term("$music", "Composers")));
+    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
+    paramsMap.put(new CategoryPath("Band"), new CategoryListParams(new Term("$music", "Bands")));
+    paramsMap.put(new CategoryPath("Composer"), new CategoryListParams(new Term("$music", "Composers")));
+    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);
     seedIndex(iw, tw, iParams);
 
     IndexReader ir = iw.getReader();
@@ -195,11 +199,10 @@
     // create and open a taxonomy writer
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(dirs[0][1], OpenMode.CREATE);
 
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams();
-    iParams.addCategoryListParams(new CategoryPath("Band"),
-        new CategoryListParams(new Term("$bands", "Bands")));
-    iParams.addCategoryListParams(new CategoryPath("Composer"),
-        new CategoryListParams(new Term("$composers", "Composers")));
+    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
+    paramsMap.put(new CategoryPath("Band"), new CategoryListParams(new Term("$bands", "Bands")));
+    paramsMap.put(new CategoryPath("Composer"), new CategoryListParams(new Term("$composers", "Composers")));
+    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);
     seedIndex(iw, tw, iParams);
 
     IndexReader ir = iw.getReader();
@@ -236,13 +239,11 @@
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(dirs[0][1],
         OpenMode.CREATE);
 
-    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams();
-    iParams.addCategoryListParams(new CategoryPath("Band"),
-        new CategoryListParams(new Term("$music", "music")));
-    iParams.addCategoryListParams(new CategoryPath("Composer"),
-        new CategoryListParams(new Term("$music", "music")));
-    iParams.addCategoryListParams(new CategoryPath("Author"),
-        new CategoryListParams(new Term("$literature", "Authors")));
+    Map<CategoryPath,CategoryListParams> paramsMap = new HashMap<CategoryPath,CategoryListParams>();
+    paramsMap.put(new CategoryPath("Band"), new CategoryListParams(new Term("$music", "music")));
+    paramsMap.put(new CategoryPath("Composer"), new CategoryListParams(new Term("$music", "music")));
+    paramsMap.put(new CategoryPath("Author"), new CategoryListParams(new Term("$literature", "Authors")));
+    PerDimensionIndexingParams iParams = new PerDimensionIndexingParams(paramsMap);
 
     seedIndex(iw, tw, iParams);
 
@@ -329,21 +330,22 @@
                                         IndexSearcher searcher) throws IOException {
     // step 1: collect matching documents into a collector
     Query q = new MatchAllDocsQuery();
-    TopScoreDocCollector topDocsCollector = TopScoreDocCollector.create(10,
-        true);
+    TopScoreDocCollector topDocsCollector = TopScoreDocCollector.create(10, true);
 
-    // Faceted search parameters indicate which facets are we interested in
-    FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);
-
-    facetSearchParams.addFacetRequest(new CountFacetRequest(new CategoryPath("Band"), 10));
+    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
+    facetRequests.add(new CountFacetRequest(new CategoryPath("Band"), 10));
     CountFacetRequest bandDepth = new CountFacetRequest(new CategoryPath("Band"), 10);
     bandDepth.setDepth(2);
     // makes it easier to check the results in the test.
     bandDepth.setResultMode(ResultMode.GLOBAL_FLAT);
-    facetSearchParams.addFacetRequest(bandDepth);
-    facetSearchParams.addFacetRequest(new CountFacetRequest(new CategoryPath("Author"), 10));
-    facetSearchParams.addFacetRequest(new CountFacetRequest(new CategoryPath("Band", "Rock & Pop"), 10));
+    facetRequests.add(bandDepth);
+    facetRequests.add(new CountFacetRequest(new CategoryPath("Author"), 10));
+    facetRequests.add(new CountFacetRequest(new CategoryPath("Band", "Rock & Pop"), 10));
 
+    // Faceted search parameters indicate which facets are we interested in
+    FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);
+    
+
     // perform documents search and facets accumulation
     FacetsCollector facetsCollector = new FacetsCollector(facetSearchParams, ir, tr);
     searcher.search(q, MultiCollector.wrap(topDocsCollector, facetsCollector));
Index: lucene/facet/src/test/org/apache/lucene/facet/search/TestScoredDocIdCollector.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/TestScoredDocIdCollector.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/TestScoredDocIdCollector.java	(working copy)
@@ -80,7 +80,7 @@
     }
 
     // verify by facet values
-    List<FacetResult> countRes = findFacets(scoredDocIDs, getFacetedSearchParams());
+    List<FacetResult> countRes = findFacets(scoredDocIDs, getFacetSearchParams());
     List<FacetResult> scoreRes = findFacets(scoredDocIDs, sumScoreSearchParams());
 
     assertEquals("Wrong number of facet count results!", 1, countRes.size());
@@ -160,16 +160,11 @@
   /* use a scoring aggregator */
   private FacetSearchParams sumScoreSearchParams() {
     // this will use default faceted indexing params, not altering anything about indexing
-    FacetSearchParams res = super.getFacetedSearchParams();
-    res.addFacetRequest(new ScoreFacetRequest(new CategoryPath("root", "a"), 10));
-    return res;
+    return new FacetSearchParams(new ScoreFacetRequest(new CategoryPath("root", "a"), 10));
   }
 
-  @Override
-  protected FacetSearchParams getFacetedSearchParams() {
-    FacetSearchParams res = super.getFacetedSearchParams();
-    res.addFacetRequest(new CountFacetRequest(new CategoryPath("root","a"), 10));
-    return res;
+  private FacetSearchParams getFacetSearchParams() {
+    return new FacetSearchParams(new CountFacetRequest(new CategoryPath("root","a"), 10));
   }
 
 }
\ No newline at end of file
Index: lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKInEachNodeResultHandler.java	(working copy)
@@ -8,22 +8,12 @@
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexWriterConfig.OpenMode;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.store.Directory;
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.facet.index.CategoryDocumentBuilder;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
+import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.params.CountFacetRequest;
+import org.apache.lucene.facet.search.params.FacetRequest;
+import org.apache.lucene.facet.search.params.FacetRequest.ResultMode;
 import org.apache.lucene.facet.search.params.FacetSearchParams;
-import org.apache.lucene.facet.search.params.FacetRequest.ResultMode;
 import org.apache.lucene.facet.search.results.FacetResult;
 import org.apache.lucene.facet.search.results.FacetResultNode;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
@@ -31,6 +21,16 @@
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.apache.lucene.facet.util.PartitionsUtils;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriterConfig.OpenMode;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -69,9 +69,9 @@
       }
       
       final int pSize = partitionSize;
-      DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {
+      FacetIndexingParams iParams = new FacetIndexingParams() {
         @Override
-        protected int fixedPartitionSize() {
+        public int getPartitionSize() {
           return pSize;
         }
       };
@@ -153,17 +153,18 @@
       cfrb20.setDepth(0);
       cfrb20.setResultMode(ResultMode.PER_NODE_IN_TREE);
 
-      FacetSearchParams facetSearchParams = new FacetSearchParams(iParams);
-      facetSearchParams.addFacetRequest(cfra23);
-      facetSearchParams.addFacetRequest(cfra22);
-      facetSearchParams.addFacetRequest(cfra21);
-      facetSearchParams.addFacetRequest(cfrb23);
-      facetSearchParams.addFacetRequest(cfrb22);
-      facetSearchParams.addFacetRequest(cfrb21);
-      facetSearchParams.addFacetRequest(doctor);
-      facetSearchParams.addFacetRequest(cfrb20);
+      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
+      facetRequests.add(cfra23);
+      facetRequests.add(cfra22);
+      facetRequests.add(cfra21);
+      facetRequests.add(cfrb23);
+      facetRequests.add(cfrb22);
+      facetRequests.add(cfrb21);
+      facetRequests.add(doctor);
+      facetRequests.add(cfrb20);
+      FacetSearchParams facetSearchParams = new FacetSearchParams(facetRequests, iParams);
       
-      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams,tr));
+      FacetArrays facetArrays = new FacetArrays(PartitionsUtils.partitionSize(facetSearchParams.getFacetIndexingParams(), tr));
       FacetsAccumulator fctExtrctr = new StandardFacetsAccumulator(facetSearchParams, is.getIndexReader(), tr, facetArrays);
       fctExtrctr.setComplementThreshold(FacetsAccumulator.DISABLE_COMPLEMENT);
       long start = System.currentTimeMillis();
@@ -318,8 +319,8 @@
 
   }
 
-  private void prvt_add(DefaultFacetIndexingParams iParams, RandomIndexWriter iw,
-                    TaxonomyWriter tw, String... strings) throws IOException {
+  private void prvt_add(FacetIndexingParams iParams, RandomIndexWriter iw,
+      TaxonomyWriter tw, String... strings) throws IOException {
     ArrayList<CategoryPath> cps = new ArrayList<CategoryPath>();
     CategoryPath cp = new CategoryPath(strings);
     cps.add(cp);
Index: lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandler.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandler.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/TestTopKResultsHandler.java	(working copy)
@@ -1,19 +1,20 @@
 package org.apache.lucene.facet.search;
 
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.junit.Test;
-
 import org.apache.lucene.facet.search.params.CountFacetRequest;
+import org.apache.lucene.facet.search.params.FacetRequest;
+import org.apache.lucene.facet.search.params.FacetRequest.ResultMode;
 import org.apache.lucene.facet.search.params.FacetSearchParams;
-import org.apache.lucene.facet.search.params.FacetRequest.ResultMode;
 import org.apache.lucene.facet.search.results.FacetResult;
 import org.apache.lucene.facet.search.results.FacetResultNode;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -74,18 +75,19 @@
     for (int partitionSize : partitionSizes) {
       initIndex(partitionSize);
 
-      // do different facet counts and compare to control
-      FacetSearchParams sParams = getFacetedSearchParams(partitionSize);
-      
-      sParams.addFacetRequest(new CountFacetRequest(new CategoryPath("a"), 100));
+      List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
+      facetRequests.add(new CountFacetRequest(new CategoryPath("a"), 100));
       CountFacetRequest cfra = new CountFacetRequest(new CategoryPath("a"), 100);
       cfra.setDepth(3);
       // makes it easier to check the results in the test.
       cfra.setResultMode(ResultMode.GLOBAL_FLAT);
-      sParams.addFacetRequest(cfra);
-      sParams.addFacetRequest(new CountFacetRequest(new CategoryPath("a", "b"), 100));
-      sParams.addFacetRequest(new CountFacetRequest(new CategoryPath("a", "b", "1"), 100));
-      sParams.addFacetRequest(new CountFacetRequest(new CategoryPath("a", "c"), 100));
+      facetRequests.add(cfra);
+      facetRequests.add(new CountFacetRequest(new CategoryPath("a", "b"), 100));
+      facetRequests.add(new CountFacetRequest(new CategoryPath("a", "b", "1"), 100));
+      facetRequests.add(new CountFacetRequest(new CategoryPath("a", "c"), 100));
+      
+      // do different facet counts and compare to control
+      FacetSearchParams sParams = getFacetSearchParams(facetRequests, getFacetIndexingParams(partitionSize));
 
       FacetsCollector fc = new FacetsCollector(sParams, indexReader, taxoReader) {
         @Override
@@ -157,8 +159,8 @@
 
       // do different facet counts and compare to control
       CategoryPath path = new CategoryPath("a", "b");
-      FacetSearchParams sParams = getFacetedSearchParams(partitionSize);
-      sParams.addFacetRequest(new CountFacetRequest(path, Integer.MAX_VALUE));
+      FacetSearchParams sParams = getFacetSearchParams(
+          getFacetIndexingParams(partitionSize), new CountFacetRequest(path, Integer.MAX_VALUE));
 
       FacetsCollector fc = new FacetsCollector(sParams, indexReader, taxoReader) {
         @Override
@@ -183,8 +185,8 @@
       assertEquals(path + " should only have 4 desendants", 4, res.getNumValidDescendants());
 
       // As a control base results, ask for top-1000 results
-      FacetSearchParams sParams2 = getFacetedSearchParams(partitionSize);
-      sParams2.addFacetRequest(new CountFacetRequest(path, Integer.MAX_VALUE));
+      FacetSearchParams sParams2 = getFacetSearchParams(
+          getFacetIndexingParams(partitionSize), new CountFacetRequest(path, Integer.MAX_VALUE));
 
       FacetsCollector fc2 = new FacetsCollector(sParams2, indexReader, taxoReader) {
         @Override
@@ -220,8 +222,9 @@
       initIndex(partitionSize);
 
       CategoryPath path = new CategoryPath("Miau Hattulla");
-      FacetSearchParams sParams = getFacetedSearchParams(partitionSize);
-      sParams.addFacetRequest(new CountFacetRequest(path, 10));
+      FacetSearchParams sParams = getFacetSearchParams(
+          getFacetIndexingParams(partitionSize),
+          new CountFacetRequest(path, 10));
 
       FacetsCollector fc = new FacetsCollector(sParams, indexReader, taxoReader);
       
Index: lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCounts.java	(working copy)
@@ -4,17 +4,16 @@
 import java.io.IOException;
 import java.util.Arrays;
 
+import org.apache.lucene.facet.FacetTestUtils;
+import org.apache.lucene.facet.FacetTestUtils.IndexTaxonomyReaderPair;
+import org.apache.lucene.facet.FacetTestUtils.IndexTaxonomyWriterPair;
+import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util._TestUtil;
 import org.junit.Test;
 
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.facet.FacetTestUtils;
-import org.apache.lucene.facet.FacetTestUtils.IndexTaxonomyReaderPair;
-import org.apache.lucene.facet.FacetTestUtils.IndexTaxonomyWriterPair;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -56,9 +55,9 @@
     // Create our index/taxonomy writers
     IndexTaxonomyWriterPair[] writers = FacetTestUtils
     .createIndexTaxonomyWriterPair(dirs);
-    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {
+    FacetIndexingParams iParams = new FacetIndexingParams() {
       @Override
-      protected int fixedPartitionSize() {
+      public int getPartitionSize() {
         return partitionSize;
       }
     };
Index: lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/TestTotalFacetCountsCache.java	(working copy)
@@ -8,16 +8,6 @@
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.IndexWriterConfig;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.MockDirectoryWrapper;
-import org.junit.Before;
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.facet.FacetTestUtils;
 import org.apache.lucene.facet.FacetTestUtils.IndexTaxonomyReaderPair;
 import org.apache.lucene.facet.FacetTestUtils.IndexTaxonomyWriterPair;
@@ -26,7 +16,6 @@
 import org.apache.lucene.facet.example.multiCL.MultiCLIndexer;
 import org.apache.lucene.facet.example.multiCL.MultiCLSearcher;
 import org.apache.lucene.facet.index.CategoryDocumentBuilder;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.TotalFacetCounts.CreationType;
 import org.apache.lucene.facet.search.results.FacetResult;
@@ -36,9 +25,18 @@
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.MockDirectoryWrapper;
 import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.SlowRAMDirectory;
 import org.apache.lucene.util._TestUtil;
+import org.junit.Before;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -196,7 +194,7 @@
     // it references a different TFC cache. This will still result
     // in valid results, but will only search one of the category lists
     // instead of all of them.
-    multis[numThreads - 1] = new Multi(slowIndexReader, slowTaxoReader, new DefaultFacetIndexingParams());
+    multis[numThreads - 1] = new Multi(slowIndexReader, slowTaxoReader, FacetIndexingParams.ALL_PARENTS);
 
     // Gentleman, start your engines
     for (Multi m : multis) {
@@ -252,7 +250,7 @@
 
     // Create our index/taxonomy writers
     IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);
-    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams();
+    FacetIndexingParams iParams = FacetIndexingParams.ALL_PARENTS;
 
     // Add a facet to the index
     addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, "a", "b");
@@ -347,11 +345,10 @@
     // Create temporary RAMDirectories
     Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(1);
     // Create our index/taxonomy writers
-    IndexTaxonomyWriterPair[] writers = FacetTestUtils
-    .createIndexTaxonomyWriterPair(dirs);
-    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams() {
+    IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);
+    FacetIndexingParams iParams = new FacetIndexingParams() {
       @Override
-      protected int fixedPartitionSize() {
+      public int getPartitionSize() {
         return 2;
       }
     };
@@ -403,7 +400,7 @@
     IndexWriter w = new IndexWriter(indexDir, new IndexWriterConfig(
         TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)));
     DirectoryTaxonomyWriter tw = new DirectoryTaxonomyWriter(taxoDir);
-    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams();
+    FacetIndexingParams iParams = FacetIndexingParams.ALL_PARENTS;
     // Add documents and facets
     for (int i = 0; i < 1000; i++) {
       addFacets(iParams, w, tw, "facet", Integer.toString(i));
@@ -454,7 +451,7 @@
     Directory[][] dirs = FacetTestUtils.createIndexTaxonomyDirs(2);
     // Create our index/taxonomy writers
     IndexTaxonomyWriterPair[] writers = FacetTestUtils.createIndexTaxonomyWriterPair(dirs);
-    DefaultFacetIndexingParams iParams = new DefaultFacetIndexingParams();
+    FacetIndexingParams iParams = FacetIndexingParams.ALL_PARENTS;
 
     // Add a facet to the index
     addFacets(iParams, writers[0].indexWriter, writers[0].taxWriter, "a", "b");
Index: lucene/facet/src/test/org/apache/lucene/facet/search/association/AssociationsFacetRequestTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/association/AssociationsFacetRequestTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/association/AssociationsFacetRequestTest.java	(working copy)
@@ -2,17 +2,6 @@
 
 import java.util.List;
 
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.store.Directory;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
@@ -20,7 +9,7 @@
 import org.apache.lucene.facet.enhancements.association.AssociationEnhancement;
 import org.apache.lucene.facet.enhancements.association.AssociationFloatProperty;
 import org.apache.lucene.facet.enhancements.association.AssociationIntProperty;
-import org.apache.lucene.facet.enhancements.params.DefaultEnhancementsIndexingParams;
+import org.apache.lucene.facet.enhancements.params.EnhancementsIndexingParams;
 import org.apache.lucene.facet.index.CategoryContainer;
 import org.apache.lucene.facet.search.FacetsCollector;
 import org.apache.lucene.facet.search.params.FacetSearchParams;
@@ -31,6 +20,16 @@
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -72,8 +71,7 @@
     TaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir);
     
     EnhancementsDocumentBuilder builder = new EnhancementsDocumentBuilder(
-        taxoWriter, new DefaultEnhancementsIndexingParams(
-            new AssociationEnhancement()));
+        taxoWriter, new EnhancementsIndexingParams(new AssociationEnhancement()));
     
     // index documents, 50% have only 'b' and all have 'a'
     for (int i = 0; i < 100; i++) {
@@ -109,9 +107,9 @@
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
 
     // facet requests for two facets
-    FacetSearchParams fsp = new FacetSearchParams();
-    fsp.addFacetRequest(new AssociationIntSumFacetRequest(aint, 10));
-    fsp.addFacetRequest(new AssociationIntSumFacetRequest(bint, 10));
+    FacetSearchParams fsp = new FacetSearchParams(
+        new AssociationIntSumFacetRequest(aint, 10),
+        new AssociationIntSumFacetRequest(bint, 10));
     
     Query q = new MatchAllDocsQuery();
 
@@ -134,9 +132,9 @@
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
 
     // facet requests for two facets
-    FacetSearchParams fsp = new FacetSearchParams();
-    fsp.addFacetRequest(new AssociationFloatSumFacetRequest(afloat, 10));
-    fsp.addFacetRequest(new AssociationFloatSumFacetRequest(bfloat, 10));
+    FacetSearchParams fsp = new FacetSearchParams(
+        new AssociationFloatSumFacetRequest(afloat, 10),
+        new AssociationFloatSumFacetRequest(bfloat, 10));
     
     Query q = new MatchAllDocsQuery();
 
@@ -162,11 +160,11 @@
     DirectoryTaxonomyReader taxo = new DirectoryTaxonomyReader(taxoDir);
 
     // facet requests for two facets
-    FacetSearchParams fsp = new FacetSearchParams();
-    fsp.addFacetRequest(new AssociationIntSumFacetRequest(aint, 10));
-    fsp.addFacetRequest(new AssociationIntSumFacetRequest(bint, 10));
-    fsp.addFacetRequest(new AssociationFloatSumFacetRequest(afloat, 10));
-    fsp.addFacetRequest(new AssociationFloatSumFacetRequest(bfloat, 10));
+    FacetSearchParams fsp = new FacetSearchParams(
+        new AssociationIntSumFacetRequest(aint, 10),
+        new AssociationIntSumFacetRequest(bint, 10),
+        new AssociationFloatSumFacetRequest(afloat, 10),
+        new AssociationFloatSumFacetRequest(bfloat, 10));
     
     Query q = new MatchAllDocsQuery();
 
Index: lucene/facet/src/test/org/apache/lucene/facet/search/params/FacetSearchParamsTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/params/FacetSearchParamsTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/params/FacetSearchParamsTest.java	(working copy)
@@ -1,16 +1,15 @@
 package org.apache.lucene.facet.search.params;
 
-import org.apache.lucene.store.Directory;
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
+import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.taxonomy.CategoryPath;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.apache.lucene.facet.util.PartitionsUtils;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -32,47 +31,32 @@
 public class FacetSearchParamsTest extends LuceneTestCase {
 
   @Test
-  public void testDefaultSettings() throws Exception {
-    FacetSearchParams fsp = new FacetSearchParams();
-    assertEquals("unexpected default facet indexing params class", DefaultFacetIndexingParams.class.getName(), fsp.getFacetIndexingParams().getClass().getName());
-    assertEquals("no facet requests should be added by default", 0, fsp.getFacetRequests().size());
-    Directory dir = newDirectory();
-    new DirectoryTaxonomyWriter(dir).close();
-    TaxonomyReader tr = new DirectoryTaxonomyReader(dir);
-    assertEquals("unexpected partition offset for 0 categories", 1, PartitionsUtils.partitionOffset(fsp, 1, tr));
-    assertEquals("unexpected partition size for 0 categories", 1, PartitionsUtils.partitionSize(fsp,tr));
-    tr.close();
-    dir.close();
-  }
-  
-  @Test
   public void testAddFacetRequest() throws Exception {
-    FacetSearchParams fsp = new FacetSearchParams();
-    fsp.addFacetRequest(new CountFacetRequest(new CategoryPath("a", "b"), 1));
+    FacetSearchParams fsp = new FacetSearchParams(new CountFacetRequest(new CategoryPath("a", "b"), 1));
     assertEquals("expected 1 facet request", 1, fsp.getFacetRequests().size());
   }
   
   @Test
   public void testPartitionSizeWithCategories() throws Exception {
-    FacetSearchParams fsp = new FacetSearchParams();
     Directory dir = newDirectory();
     TaxonomyWriter tw = new DirectoryTaxonomyWriter(dir);
     tw.addCategory(new CategoryPath("a"));
     tw.commit();
     tw.close();
     TaxonomyReader tr = new DirectoryTaxonomyReader(dir);
-    assertEquals("unexpected partition offset for 1 categories", 2, PartitionsUtils.partitionOffset(fsp, 1, tr));
-    assertEquals("unexpected partition size for 1 categories", 2, PartitionsUtils.partitionSize(fsp,tr));
+    assertEquals("unexpected partition offset for 1 categories", 2,
+        PartitionsUtils.partitionOffset(FacetIndexingParams.ALL_PARENTS, 1, tr));
+    assertEquals("unexpected partition size for 1 categories", 2,
+        PartitionsUtils.partitionSize(FacetIndexingParams.ALL_PARENTS,tr));
     tr.close();
     dir.close();
   }
   
   @Test
   public void testSearchParamsWithNullRequest() throws Exception {
-    FacetSearchParams fsp = new FacetSearchParams();
     try {
-      fsp.addFacetRequest(null);
-      fail("FacetSearchParams should throw IllegalArgumentException when trying to add a null FacetRequest");
+      assertNull(new FacetSearchParams());
+      fail("FacetSearchParams should throw IllegalArgumentException when not adding requests");
     } catch (IllegalArgumentException e) {
     }
   }
Index: lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiIteratorsPerCLParamsTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiIteratorsPerCLParamsTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/params/MultiIteratorsPerCLParamsTest.java	(working copy)
@@ -1,22 +1,15 @@
 package org.apache.lucene.facet.search.params;
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.store.Directory;
-import org.junit.Test;
-
-import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.facet.index.CategoryDocumentBuilder;
 import org.apache.lucene.facet.index.params.CategoryListParams;
-import org.apache.lucene.facet.index.params.DefaultFacetIndexingParams;
 import org.apache.lucene.facet.index.params.FacetIndexingParams;
 import org.apache.lucene.facet.search.CategoryListIterator;
 import org.apache.lucene.facet.search.FacetArrays;
@@ -35,6 +28,12 @@
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
 import org.apache.lucene.facet.util.ScoredDocIdsUtils;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -87,7 +86,7 @@
     // Create a CLP which generates different CLIs according to the
     // FacetRequest's dimension
     CategoryListParams clp = new CategoryListParams();
-    FacetIndexingParams iParams = new DefaultFacetIndexingParams(clp);
+    FacetIndexingParams iParams = new FacetIndexingParams(clp);
     Directory indexDir = newDirectory();
     Directory taxoDir = newDirectory();
     populateIndex(iParams, indexDir, taxoDir);
@@ -135,16 +134,19 @@
   }
 
   private void validateFacetedSearch(FacetIndexingParams iParams,
-      TaxonomyReader taxo, IndexReader reader,  CategoryListCache clCache, ScoredDocIDs allDocs,
-      String[] dimension, int[] expectedValue,
-      int[] expectedNumDescendants)
-      throws IOException {
-    FacetSearchParams sParams = new FacetSearchParams(iParams);
-    sParams.setClCache(clCache);
+      TaxonomyReader taxo, IndexReader reader, final CategoryListCache clCache,
+      ScoredDocIDs allDocs, String[] dimension, int[] expectedValue,
+      int[] expectedNumDescendants) throws IOException {
+    List<FacetRequest> facetRequests = new ArrayList<FacetRequest>();
     for (String dim : dimension) {
-      sParams.addFacetRequest(new PerDimCountFacetRequest(
-          new CategoryPath(dim), 10));
+      facetRequests.add(new PerDimCountFacetRequest(new CategoryPath(dim), 10));
     }
+    FacetSearchParams sParams = new FacetSearchParams(facetRequests, iParams) {
+      @Override
+      public CategoryListCache getCategoryListCache() {
+        return clCache;
+      }
+    };
     FacetsAccumulator acc = new StandardFacetsAccumulator(sParams, reader, taxo);
     
     // no use to test this with complement since at that mode all facets are taken
Index: lucene/facet/src/test/org/apache/lucene/facet/search/sampling/OversampleWithDepthTest.java
===================================================================
--- lucene/facet/src/test/org/apache/lucene/facet/search/sampling/OversampleWithDepthTest.java	(revision 1420923)
+++ lucene/facet/src/test/org/apache/lucene/facet/search/sampling/OversampleWithDepthTest.java	(working copy)
@@ -63,14 +63,12 @@
     DirectoryReader r = DirectoryReader.open(indexDir);
     TaxonomyReader tr = new DirectoryTaxonomyReader(taxoDir);
     
-    FacetSearchParams fsp = new FacetSearchParams();
-    
     CountFacetRequest facetRequest = new CountFacetRequest(new CategoryPath("root"), 10);
-    
     // Setting the depth to '2', should potentially get all categories
     facetRequest.setDepth(2);
     facetRequest.setResultMode(ResultMode.PER_NODE_IN_TREE);
-    fsp.addFacetRequest(facetRequest);
+
+    FacetSearchParams fsp = new FacetSearchParams(facetRequest);
     
     // Craft sampling params to enforce sampling
     final SamplingParams params = new SamplingParams();
