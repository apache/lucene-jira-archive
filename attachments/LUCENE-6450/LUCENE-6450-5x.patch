diff --git a/lucene/core/src/java/org/apache/lucene/document/GeoPointField.java b/lucene/core/src/java/org/apache/lucene/document/GeoPointField.java
new file mode 100644
index 0000000..caedcd9
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/document/GeoPointField.java
@@ -0,0 +1,101 @@
+package org.apache.lucene.document;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.DocValuesType;
+import org.apache.lucene.index.IndexOptions;
+import org.apache.lucene.util.GeoUtils;
+
+/**
+ * <p>
+ * Field that indexes <code>latitude</code> <code>longitude</code> decimal-degree values
+ * for efficient encoding, sorting, and querying. This Geo capability is intended
+ * to provide a basic and efficient out of the box field type for indexing and
+ * querying 2 dimensional points in WGS-84 decimal degrees. An example usage is as follows:
+ *
+ * <pre class="prettyprint">
+ *  document.add(new GeoPointField(name, -96.33, 32.66, Field.Store.NO));
+ * </pre>
+ *
+ * <p>To perform simple geospatial queries against a <code>GeoPointField</code>,
+ * see {@link org.apache.lucene.search.GeoPointInBBoxQuery} or {@link org.apache.lucene.search.GeoPointInPolygonQuery}
+ */
+public final class GeoPointField extends Field {
+    /**
+     * Type for an GeoPointField that is not stored:
+     * normalization factors, frequencies, and positions are omitted.
+     */
+    public static final FieldType TYPE_NOT_STORED = new FieldType();
+    static {
+        TYPE_NOT_STORED.setTokenized(false);
+        TYPE_NOT_STORED.setOmitNorms(true);
+        TYPE_NOT_STORED.setIndexOptions(IndexOptions.DOCS);
+        TYPE_NOT_STORED.setNumericType(FieldType.NumericType.LONG);
+        TYPE_NOT_STORED.setDocValuesType(DocValuesType.SORTED_NUMERIC);
+        TYPE_NOT_STORED.setNumericPrecisionStep(64);
+        TYPE_NOT_STORED.freeze();
+    }
+
+    /**
+     * Type for a stored GeoPointField:
+     * normalization factors, frequencies, and positions are omitted.
+     */
+    public static final FieldType TYPE_STORED = new FieldType();
+    static {
+        TYPE_STORED.setTokenized(false);
+        TYPE_STORED.setOmitNorms(true);
+        TYPE_STORED.setIndexOptions(IndexOptions.DOCS);
+        TYPE_STORED.setNumericType(FieldType.NumericType.LONG);
+        TYPE_STORED.setDocValuesType(DocValuesType.SORTED_NUMERIC);
+        TYPE_STORED.setNumericPrecisionStep(64);
+        TYPE_STORED.setStored(true);
+        TYPE_STORED.freeze();
+    }
+
+    /** Creates a stored or un-stored GeoPointField with the provided value
+     *  and default <code>precisionStep</code> set to 64 to avoid wasteful
+     *  indexing of lower precision terms.
+     *  @param name field name
+     *  @param lon longitude double value [-180.0 : 180.0]
+     *  @param lat latitude double value [-90.0 : 90.0]
+     *  @param stored Store.YES if the content should also be stored
+     *  @throws IllegalArgumentException if the field name is null.
+     */
+    public GeoPointField(String name, double lon, double lat, Store stored) {
+        super(name, stored == Store.YES ? TYPE_STORED : TYPE_NOT_STORED);
+        fieldsData = GeoUtils.mortonHash(lon, lat);
+    }
+
+    /** Expert: allows you to customize the {@link
+     *  FieldType}.
+     *  @param name field name
+     *  @param lon longitude double value [-180.0 : 180.0]
+     *  @param lat latitude double value [-90.0 : 90.0]
+     *  @param type customized field type: must have {@link FieldType#numericType()}
+     *         of {@link FieldType.NumericType#LONG}.
+     *  @throws IllegalArgumentException if the field name or type is null, or
+     *          if the field type does not have a LONG numericType()
+     */
+    public GeoPointField(String name, double lon, double lat, FieldType type) {
+        super(name, type);
+        if (type.numericType() != FieldType.NumericType.LONG) {
+            throw new IllegalArgumentException("type.numericType() must be LONG but got " + type.numericType());
+        }
+        fieldsData = GeoUtils.mortonHash(lon, lat);
+    }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/GeoPointInBBoxQuery.java b/lucene/core/src/java/org/apache/lucene/search/GeoPointInBBoxQuery.java
new file mode 100644
index 0000000..32b6244
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/GeoPointInBBoxQuery.java
@@ -0,0 +1,113 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.document.FieldType;
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.util.AttributeSource;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.GeoUtils;
+import org.apache.lucene.util.NumericUtils;
+
+/** Implements a simple bounding box query on a GeoPoint field. This is based on
+ * {@link org.apache.lucene.search.NumericRangeQuery} and is implemented using a
+ * two phase approach. First, candidate terms are queried using a numeric
+ * range based on the morton codes of the min and max lat/lon pairs. Terms
+ * passing this initial filter are passed to a final check that verifies whether
+ * the decoded lat/lon falls within (or on the boundary) of the query bounding box.
+ * The value comparisons are subject to a precision tolerance defined in
+ * {@value org.apache.lucene.util.GeoUtils#TOLERANCE}
+ *
+ * NOTES:
+ *    1.  The bounding box coordinates need to be in either clockwise or counter-clockwise order.
+ *    2.  All latitude/longitude values must be in decimal degrees.
+ *    3.  Complex computational geometry (e.g., dateline wrapping) is not supported
+ *    4.  For more advanced GeoSpatial indexing and query operations see spatial module
+ */
+public class GeoPointInBBoxQuery extends NumericRangeQuery<Long> {
+  // max precision to avoid wasteful indexing of low resolution terms
+  protected static final int PRECISION_STEP = 64;
+
+  // simple bounding box optimization - no objects used to avoid dependencies
+  protected double minLon;
+  protected double minLat;
+  protected double maxLon;
+  protected double maxLat;
+
+  /**
+   * Constructs a new GeoBBoxQuery that will match encoded GeoPoint terms that fall within or on the boundary
+   * of the bounding box defined by the input parameters
+   * @param field the field name
+   * @param minLon lower longitude (x) value of the bounding box
+   * @param minLat lower latitude (y) value of the bounding box
+   * @param maxLon upper longitude (x) value of the bounding box
+   * @param maxLat upper latitude (y) value of the bounding box
+   */
+  public GeoPointInBBoxQuery(final String field, final double minLon, final double minLat, final double maxLon, final double maxLat) {
+    super(field, PRECISION_STEP, FieldType.NumericType.LONG, GeoUtils.mortonHash(minLon, minLat), GeoUtils.mortonHash(maxLon, maxLat),
+        true, true);
+    this.minLon = minLon;
+    this.minLat = minLat;
+    this.maxLon = maxLon;
+    this.maxLat = maxLat;
+  }
+
+  @Override @SuppressWarnings("unchecked")
+  protected TermsEnum getTermsEnum(final Terms terms, AttributeSource atts) throws IOException {
+    // very strange: java.lang.Number itself is not Comparable, but all subclasses used here are
+    if (min != null && max != null &&  min.compareTo(max) > 0) {
+      return TermsEnum.EMPTY;
+    }
+    return new GeoBBoxTermsEnum(terms.iterator());
+  }
+
+  private final class GeoBBoxTermsEnum extends NumericRangeTermsEnum {
+    GeoBBoxTermsEnum(final TermsEnum tenum) {
+      super(tenum);
+    }
+
+    /**
+     * The two-phase query approach. The parent
+     * {@link org.apache.lucene.search.NumericRangeQuery.NumericRangeTermsEnum#accept} method is called to match
+     * encoded terms that fall within the numeric range of the bounding box. Those documents that pass the initial
+     * filter are compared against the decoded min/max latitude and longitude values of the bounding box.
+     * @param term term for candidate document
+     * @return match status
+     */
+    @Override
+    protected final AcceptStatus accept(BytesRef term) {
+      AcceptStatus status = super.accept(term);
+      assert status != AcceptStatus.YES_AND_SEEK;
+      if (status != AcceptStatus.YES) {
+        return status;
+      }
+      // final-filter by bounding box
+      final long val = NumericUtils.prefixCodedToLong(term);
+      final double lon = GeoUtils.mortonUnhash(val, true);
+      final double lat = GeoUtils.mortonUnhash(val, false);
+
+      if (!GeoUtils.bboxContains(lon, lat, minLon, minLat, maxLon, maxLat)) {
+        return AcceptStatus.NO;
+      }
+      return AcceptStatus.YES;
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/GeoPointInPolygonQuery.java b/lucene/core/src/java/org/apache/lucene/search/GeoPointInPolygonQuery.java
new file mode 100644
index 0000000..e1a75f7
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/GeoPointInPolygonQuery.java
@@ -0,0 +1,149 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.util.AttributeSource;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.GeoUtils;
+import org.apache.lucene.util.NumericUtils;
+
+import java.io.IOException;
+
+/** Implements a simple point in polygon query on a GeoPoint field. This is based on
+ * {@link GeoPointInBBoxQuery} and is implemented using a
+ * three phase approach. First, like {@link GeoPointInBBoxQuery}
+ * candidate terms are queried using a numeric range based on the morton codes
+ * of the min and max lat/lon pairs. Terms passing this initial filter are passed
+ * to a secondary filter that verifies whether the decoded lat/lon point falls within
+ * (or on the boundary) of the bounding box query. Finally, the remaining candidate
+ * term is passed to the final point in polygon check. All value comparisons are subject
+ * to the same precision tolerance defined in {@value org.apache.lucene.util.GeoUtils#TOLERANCE}
+ *
+ * NOTES:
+ *    1.  The polygon coordinates need to be in either clockwise or counter-clockwise order.
+ *    2.  The polygon must not be self-crossing, otherwise the query may result in unexpected behavior
+ *    3.  All latitude/longitude values must be in decimal degrees.
+ *    4.  Complex computational geometry (e.g., dateline wrapping, polygon with holes) is not supported
+ *    5.  For more advanced GeoSpatial indexing and query operations see spatial module
+ */
+public final class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
+  // polygon position arrays - this avoids the use of any objects or
+  // or geo library dependencies
+  private double[] x;
+  private double[] y;
+
+  /**
+   * Constructs a new GeoPolygonQuery that will match encoded {@link org.apache.lucene.document.GeoPointField} terms
+   * that fall within or on the boundary of the polygon defined by the input parameters. This constructor requires a
+   * precomputed bounding box. As an alternative the {@link GeoPointInPolygonQuery#newPolygonQuery} static factory can
+   * be used to compute the bounding box during construction
+   *
+   * @param field the field name
+   * @param minLon lower longitude (x) value of the bounding box optimizer
+   * @param minLat lower latitude (y) value of the bounding box optimizer
+   * @param maxLon upper longitude (x) value of the bounding box optimizer
+   * @param maxLat upper latitude (y) value of the bounding box optimizer
+   * @param polyLons array containing all longitude values for the polygon
+   * @param polyLats array containing all latitude values for the polygon
+   */
+  public GeoPointInPolygonQuery(final String field, final double minLon, final double minLat, final double maxLon,
+                                final double maxLat, final double[] polyLons, final double[] polyLats) {
+      this(field, minLon, minLat, maxLon, maxLat);
+      this.x = polyLons;
+      this.y = polyLats;
+  }
+
+  /**Constructs a
+   * {@link #GeoPointInPolygonQuery(String, double, double, double, double)
+   * GeoPolygonQuery(field, minLon, minLat, maxLon, maxLat)} by first setting the bbox optimization values
+   */
+  private GeoPointInPolygonQuery(final String field, final double minLon, final double minLat, final double maxLon, final double maxLat) {
+    super(field, minLon, minLat, maxLon, maxLat);
+  }
+
+  /**
+   * Static method call to construct a
+   * {@link #GeoPointInPolygonQuery(String, double, double, double, double, double[], double[])
+   * GeoPolygonQuery(field, minLon, minLat, maxLon, maxLat, polyLons, polyLats)} by first computing the bounding
+   * box lat/lon ranges
+   */
+  public static GeoPointInPolygonQuery newPolygonQuery(final String field, final double[] polyLons, final double[] polyLats) {
+    assert polyLons.length == polyLats.length;
+    double minLon, maxLon, minLat, maxLat;
+    int i=1;
+    for(minLon=maxLon=polyLons[0], minLat=maxLat=polyLats[0]; i<polyLons.length; ++i) {
+        minLon = Math.min(polyLons[i], minLon);
+        maxLon = Math.max(polyLons[i], maxLon);
+        minLat = Math.min(polyLats[i], minLat);
+        maxLat = Math.max(polyLats[i], maxLat);
+    }
+    return new GeoPointInPolygonQuery(field, minLon, minLat, maxLon, maxLat, polyLons, polyLats);
+  }
+
+  @Override @SuppressWarnings("unchecked")
+  protected TermsEnum getTermsEnum(final Terms terms, AttributeSource atts) throws IOException {
+    // very strange: java.lang.Number itself is not Comparable, but all subclasses used here are
+    if (min != null && max != null &&  min.compareTo(max) > 0) {
+      return TermsEnum.EMPTY;
+    }
+    return new GeoPolygonTermsEnum(terms.iterator());
+  }
+
+  private final class GeoPolygonTermsEnum extends NumericRangeTermsEnum {
+    GeoPolygonTermsEnum(final TermsEnum tenum) {
+            super(tenum);
+        }
+
+    /**
+     * The three-phase query approach. The parent
+     * {@link org.apache.lucene.search.NumericRangeQuery.NumericRangeTermsEnum#accept} method is called to match
+     * encoded terms that fall within the numeric range of the bounding box. Those documents that pass the initial
+     * range filter are compared against the decoded min/max latitude and longitude values of the bounding box. The
+     * final gate checks the term against the polygon using the
+     * {@link org.apache.lucene.util.GeoUtils#pointInPolygon} method.
+     *
+     * @param term term for candidate document
+     * @return match status
+     */
+    @Override
+    protected final AcceptStatus accept(BytesRef term) {
+      // first filter by numeric range
+      AcceptStatus status = super.accept(term);
+      assert status != AcceptStatus.YES_AND_SEEK;
+
+      if (status != AcceptStatus.YES) {
+        return status;
+      }
+
+      // second-filter by bounding box
+      final long val = NumericUtils.prefixCodedToLong(term);
+      final double lon = GeoUtils.mortonUnhash(val, true);
+      final double lat = GeoUtils.mortonUnhash(val, false);
+      if (!GeoUtils.bboxContains(lon, lat, minLon, minLat, maxLon, maxLat)) {
+        return AcceptStatus.NO;
+      }
+      // third-filter by point in polygon
+      else if (x!=null && !GeoUtils.pointInPolygon(x, y, lat, lon)) {
+        return AcceptStatus.NO;
+      }
+      return AcceptStatus.YES;
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java b/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
index 45ed87b..7bf5fca 100644
--- a/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
@@ -164,11 +164,10 @@ import org.apache.lucene.index.Term; // for javadocs
  *
  * @since 2.9
  **/
-public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
+public class NumericRangeQuery<T extends Number> extends MultiTermQuery {
 
-  private NumericRangeQuery(final String field, final int precisionStep, final NumericType dataType,
-    T min, T max, final boolean minInclusive, final boolean maxInclusive
-  ) {
+  NumericRangeQuery(final String field, final int precisionStep, final NumericType dataType,
+    T min, T max, final boolean minInclusive, final boolean maxInclusive) {
     super(field);
     if (precisionStep < 1)
       throw new IllegalArgumentException("precisionStep must be >=1");
@@ -385,7 +384,7 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
    * {@link NumericUtils#splitIntRange} generates the sub-ranges. For
    * {@link MultiTermQuery} ordering is not relevant.
    */
-  private final class NumericRangeTermsEnum extends FilteredTermsEnum {
+  class NumericRangeTermsEnum extends FilteredTermsEnum {
 
     private BytesRef currentLowerBound, currentUpperBound;
 
@@ -510,7 +509,7 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
     }
     
     @Override
-    protected final AcceptStatus accept(BytesRef term) {
+    protected AcceptStatus accept(BytesRef term) {
       while (currentUpperBound == null || term.compareTo(currentUpperBound) > 0) {
         if (rangeBounds.isEmpty())
           return AcceptStatus.END;
diff --git a/lucene/core/src/java/org/apache/lucene/util/BitUtil.java b/lucene/core/src/java/org/apache/lucene/util/BitUtil.java
index 3a435fa..dcbd2ef 100644
--- a/lucene/core/src/java/org/apache/lucene/util/BitUtil.java
+++ b/lucene/core/src/java/org/apache/lucene/util/BitUtil.java
@@ -90,6 +90,15 @@ public final class BitUtil {
     0x8765421, 0x876543, 0x8765431, 0x8765432, 0x87654321
   };
 
+  // magic numbers for bit interleaving
+  private static final long MAGIC[] = {
+      0x5555555555555555L, 0x3333333333333333L,
+      0x0F0F0F0F0F0F0F0FL, 0x00FF00FF00FF00FFL,
+      0x0000FFFF0000FFFFL, 0x00000000FFFFFFFFL
+  };
+  // shift values for bit interleaving
+  private static final short SHIFT[] = {1, 2, 4, 8, 16};
+
   private BitUtil() {} // no instance
 
   /** Return the number of bits sets in b. 
@@ -193,6 +202,39 @@ public final class BitUtil {
     return v;
   }
 
+  /**
+   * Interleaves the first 32 bits of each long value
+   *
+   * Adapted from: http://graphics.stanford.edu/~seander/bithacks.html#InterleaveBMN
+   */
+  public static long interleave(long v1, long v2) {
+    v1 = (v1 | (v1 << SHIFT[4])) & MAGIC[4];
+    v1 = (v1 | (v1 << SHIFT[3])) & MAGIC[3];
+    v1 = (v1 | (v1 << SHIFT[2])) & MAGIC[2];
+    v1 = (v1 | (v1 << SHIFT[1])) & MAGIC[1];
+    v1 = (v1 | (v1 << SHIFT[0])) & MAGIC[0];
+    v2 = (v2 | (v2 << SHIFT[4])) & MAGIC[4];
+    v2 = (v2 | (v2 << SHIFT[3])) & MAGIC[3];
+    v2 = (v2 | (v2 << SHIFT[2])) & MAGIC[2];
+    v2 = (v2 | (v2 << SHIFT[1])) & MAGIC[1];
+    v2 = (v2 | (v2 << SHIFT[0])) & MAGIC[0];
+
+    return (v2<<1) | v1;
+  }
+
+  /**
+   * Deinterleaves long value back to two concatenated 32bit values
+   */
+  public static long deinterleave(long b) {
+    b &= MAGIC[0];
+    b = (b ^ (b >>> SHIFT[0])) & MAGIC[1];
+    b = (b ^ (b >>> SHIFT[1])) & MAGIC[2];
+    b = (b ^ (b >>> SHIFT[2])) & MAGIC[3];
+    b = (b ^ (b >>> SHIFT[3])) & MAGIC[4];
+    b = (b ^ (b >>> SHIFT[4])) & MAGIC[5];
+    return b;
+  }
+
    /** Same as {@link #zigZagEncode(long)} but on integers. */
    public static int zigZagEncode(int i) {
      return (i >> 31) ^ (i << 1);
diff --git a/lucene/core/src/java/org/apache/lucene/util/GeoUtils.java b/lucene/core/src/java/org/apache/lucene/util/GeoUtils.java
new file mode 100644
index 0000000..9512480
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/GeoUtils.java
@@ -0,0 +1,84 @@
+package org.apache.lucene.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Basic reusable geo-spatial utility methods
+ */
+public final class GeoUtils {
+    private static final short MIN_LON = -180;
+    private static final short MIN_LAT = -90;
+    private static final short BITS = 31;
+    private static final double LON_SCALE = (0x1L<<BITS)/360.0D;
+    private static final double LAT_SCALE = (0x1L<<BITS)/180.0D;
+    private static final double TOLERANCE = 1E-7;
+
+    // No instance:
+    private GeoUtils() {
+    }
+
+    public static final Long mortonHash(final double lon, final double lat) {
+        return BitUtil.interleave(scale(lon, true), scale(lat, false));
+    }
+
+    public static final double mortonUnhash(final long hash, final boolean isLon) {
+        return unscale(BitUtil.deinterleave((isLon) ? hash : hash >>> 1), isLon);
+    }
+
+    private static long scale(final double val, final boolean lon) {
+        return (long) ((lon == true) ? (val-MIN_LON) * LON_SCALE : (val-MIN_LAT) * LAT_SCALE);
+    }
+
+    public static double unscale(final long val, final boolean lon) {
+        return (lon == true) ? (val / LON_SCALE) + MIN_LON : (val / LAT_SCALE) + MIN_LAT;
+    }
+
+    public static final double compare(final double v1, final double v2) {
+        final double compare = v1-v2;
+        return Math.abs(compare) <= TOLERANCE ? 0 : compare;
+    }
+
+    public static final boolean bboxContains(final double lon, final double lat, final double minLon,
+                                             final double minLat, final double maxLon, final double maxLat) {
+        return (compare(lon, minLon) >= 0 && compare(lon, maxLon) <= 0
+            && compare(lat, minLat) >= 0 && compare(lat, maxLat) <= 0);
+    }
+
+    /**
+     * simple even-odd point in polygon computation
+     *    1.  Determine if point is contained in the longitudinal range
+     *    2.  Determine whether point crosses the edge by computing the latitudinal delta
+     *        between the end-point of a parallel vector (originating at the point) and the
+     *        y-component of the edge sink
+     *
+     * NOTE: Requires polygon point (x,y) order either clockwise or counter-clockwise
+     */
+    public static boolean pointInPolygon(double[] x, double[] y, double lat, double lon) {
+        assert x.length == y.length;
+        boolean inPoly = false;
+
+        for (int i = 1; i < x.length; i++) {
+            if (x[i] < lon && x[i-1] >= lon || x[i-1] < lon && x[i] >= lon) {
+                if (y[i] + (lon - x[i]) / (x[i-1] - x[i]) * (y[i-1] - y[i]) < lat) {
+                    inPoly = !inPoly;
+                }
+            }
+        }
+        return inPoly;
+    }
+}
\ No newline at end of file
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestGeoPointQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestGeoPointQuery.java
new file mode 100644
index 0000000..9e4c2ad
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestGeoPointQuery.java
@@ -0,0 +1,106 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.FieldType;
+import org.apache.lucene.document.GeoPointField;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ * Unit testing for basic GeoPoint query logic
+ */
+public class TestGeoPointQuery extends LuceneTestCase {
+  private static Directory directory = null;
+  private static IndexReader reader = null;
+  private static IndexSearcher searcher = null;
+
+  private static final String FIELD_NAME = "geoField";
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+            newIndexWriterConfig(new MockAnalyzer(random()))
+                    .setMaxBufferedDocs(TestUtil.nextInt(random(), 100, 1000))
+                    .setMergePolicy(newLogMergePolicy()));
+
+    // create some simple geo points
+    final FieldType storedPoint = new FieldType(GeoPointField.TYPE_STORED);
+    // this is a simple systematic test
+    GeoPointField[] pts = new GeoPointField[] {
+         new GeoPointField(FIELD_NAME, -96.4538113027811, 32.94823588839368, storedPoint),
+         new GeoPointField(FIELD_NAME, -96.7759895324707, 32.7559529921407, storedPoint),
+         new GeoPointField(FIELD_NAME, -96.77701950073242, 32.77866942010977, storedPoint),
+         new GeoPointField(FIELD_NAME, -96.7706036567688, 32.7756745755423, storedPoint),
+         new GeoPointField(FIELD_NAME, -139.73458170890808, 27.703618681345585, storedPoint),
+         new GeoPointField(FIELD_NAME, -96.65084838867188, 33.06047141970814, storedPoint),
+         new GeoPointField(FIELD_NAME, -96.7772, 32.778650, storedPoint)};
+
+    for (GeoPointField p : pts) {
+        Document doc = new Document();
+        doc.add(p);
+        writer.addDocument(doc);
+    }
+    reader = writer.getReader();
+    searcher = newSearcher(reader);
+    writer.close();
+  }
+
+  @AfterClass
+  public static void afterClass() throws Exception {
+    searcher = null;
+    reader.close();
+    reader = null;
+    directory.close();
+    directory = null;
+  }
+
+  private TopDocs bboxQuery(double minLon, double minLat, double maxLon, double maxLat, int limit) throws Exception {
+    GeoPointInBBoxQuery q = new GeoPointInBBoxQuery(FIELD_NAME, minLon, minLat, maxLon, maxLat);
+    return searcher.search(q, limit);
+  }
+
+  private TopDocs polygonQuery(double[] lon, double[] lat, int limit) throws Exception {
+    GeoPointInPolygonQuery q = GeoPointInPolygonQuery.newPolygonQuery(FIELD_NAME, lon, lat);
+    return searcher.search(q, limit);
+  }
+
+  @Test
+  public void testBBoxQuery() throws Exception {
+    TopDocs td = bboxQuery(-96.7772, 32.778650, -96.77690000, 32.778950, 5);
+    assertEquals("GeoBoundingBoxQuery failed", td.totalHits, 2);
+  }
+
+  @Test
+  public void testPolyQuery() throws Exception {
+    TopDocs td = polygonQuery( new double[] { -96.7682647, -96.8280029, -96.6288757, -96.4929199,
+        -96.6041564, -96.7449188, -96.76826477}, new double[] { 33.073130, 32.9942669, 32.938386, 33.0374494,
+        33.1369762, 33.1162747, 33.073130}, 5);
+    assertEquals("GeoPolygonQuery failed", td.totalHits, 1);
+  }
+}
