Index: src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java	(date 1521903809000)
+++ src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java	(revision )
@@ -888,10 +888,10 @@
         }
         // Look for a point that is on the wrong side of the check edge.  This means that we can't build the polygon.
         final GeoPoint thePoint;
-        if (checkEdge.startPoint != confirmEdge.startPoint && checkEdge.endPoint != confirmEdge.startPoint && !flippedPlane.isWithin(confirmEdge.startPoint)) {
-          thePoint = confirmEdge.startPoint;
-        } else if (checkEdge.startPoint != confirmEdge.endPoint && checkEdge.endPoint != confirmEdge.endPoint && !flippedPlane.isWithin(confirmEdge.endPoint)) {
-          thePoint = confirmEdge.endPoint;
+        if (checkEdge.startPoint() != confirmEdge.startPoint() && checkEdge.endPoint() != confirmEdge.startPoint() && !flippedPlane.isWithin(confirmEdge.startPoint())) {
+          thePoint = confirmEdge.startPoint();
+        } else if (checkEdge.startPoint() != confirmEdge.endPoint() && checkEdge.endPoint() != confirmEdge.endPoint() && !flippedPlane.isWithin(confirmEdge.endPoint())) {
+          thePoint = confirmEdge.endPoint();
         } else {
           thePoint = null;
         }
@@ -912,9 +912,9 @@
           // to the end point of the edge.  We generate that as a triangle convex polygon, and tile the two remaining pieces.
           final List<GeoPoint> thirdPartPoints = new ArrayList<>(3);
           final BitSet thirdPartInternal = new BitSet();
-          thirdPartPoints.add(checkEdge.startPoint);
-          thirdPartInternal.set(0, checkEdge.isInternal);
-          thirdPartPoints.add(checkEdge.endPoint);
+          thirdPartPoints.add(checkEdge.startPoint());
+          thirdPartInternal.set(0, checkEdge.isInternal());
+          thirdPartPoints.add(checkEdge.endPoint());
           thirdPartInternal.set(1, true);
           thirdPartPoints.add(thePoint);
           assert checkEdge.plane.isWithin(thePoint) : "Point was on wrong side of complementary plane, so must be on the right side of the non-complementary plane!";
@@ -936,11 +936,11 @@
           final BitSet firstPartInternal = new BitSet();
           int i = 0;
           while (true) {
-            firstPartPoints.add(loopEdge.endPoint);
-            if (loopEdge.endPoint == thePoint) {
+            firstPartPoints.add(loopEdge.endPoint());
+            if (loopEdge.endPoint() == thePoint) {
               break;
             }
-            firstPartInternal.set(i++, loopEdge.isInternal);
+            firstPartInternal.set(i++, loopEdge.isInternal());
             loopEdge = edgeBuffer.getPrevious(loopEdge);
           }
           firstPartInternal.set(i, true);
@@ -952,7 +952,7 @@
             firstPartInternal, 
             firstPartPoints.size()-1,
             0,
-            new SidedPlane(checkEdge.endPoint, false, checkEdge.startPoint, thePoint),
+            new SidedPlane(checkEdge.endPoint(), false, checkEdge.startPoint(), thePoint),
             holes,
             testPoint) == false) {
             return false;
@@ -964,11 +964,11 @@
           loopEdge = edgeBuffer.getNext(checkEdge);
           i = 0;
           while (true) {
-            secondPartPoints.add(loopEdge.startPoint);
-            if (loopEdge.startPoint == thePoint) {
+            secondPartPoints.add(loopEdge.startPoint());
+            if (loopEdge.startPoint() == thePoint) {
               break;
             }
-            secondPartInternal.set(i++, loopEdge.isInternal);
+            secondPartInternal.set(i++, loopEdge.isInternal());
             loopEdge = edgeBuffer.getNext(loopEdge);
           }
           secondPartInternal.set(i, true);
@@ -980,7 +980,7 @@
             secondPartInternal, 
             secondPartPoints.size()-1,
             0,
-            new SidedPlane(checkEdge.startPoint, false, checkEdge.endPoint, thePoint),
+            new SidedPlane(checkEdge.startPoint(), false, checkEdge.endPoint(), thePoint),
             holes,
             testPoint) == false) {
             return false;
@@ -1050,11 +1050,11 @@
     boolean isInternal = false;
     for (int i = 0; i < edgeBuffer.size(); i++) {
       //System.out.println(" "+edge.plane+": "+edge.startPoint+"->"+edge.endPoint+"; previous? "+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?"in":"out")+" next? "+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?"in":"out"));
-      points.add(edge.startPoint);
+      points.add(edge.startPoint());
       if (i < edgeBuffer.size() - 1) {
-        internalEdges.set(i, edge.isInternal);
+        internalEdges.set(i, edge.isInternal());
       } else {
-        isInternal = edge.isInternal;
+        isInternal = edge.isInternal();
       }
       edge = edgeBuffer.getNext(edge);
     }
@@ -1116,24 +1116,24 @@
     
     // First, walk towards the end until we need to stop
     while (true) {
-      if (firstEdge.startPoint == lastEdge.endPoint) {
+      if (firstEdge.startPoint() == lastEdge.endPoint()) {
         break;
       }
       final Edge newLastEdge = edgeBuffer.getNext(lastEdge);
-      if (Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newLastEdge.endPoint)) {
+      if (Plane.arePointsCoplanar(lastEdge.startPoint(), lastEdge.endPoint(), newLastEdge.endPoint())) {
         break;
       }
-      if (isWithin(newLastEdge.endPoint, includedEdges)) {
+      if (isWithin(newLastEdge.endPoint(), includedEdges)) {
         //System.out.println(" maybe can extend to next edge");
         // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon
         // here will overlap with other remaining points?
         final SidedPlane returnBoundary;
-        if (firstEdge.startPoint != newLastEdge.endPoint) {
-          if (Plane.arePointsCoplanar(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint) ||
-            Plane.arePointsCoplanar(firstEdge.startPoint, newLastEdge.endPoint, newLastEdge.startPoint)) {
+        if (firstEdge.startPoint() != newLastEdge.endPoint()) {
+          if (Plane.arePointsCoplanar(firstEdge.endPoint(), firstEdge.startPoint(), newLastEdge.endPoint()) ||
+            Plane.arePointsCoplanar(firstEdge.startPoint(), newLastEdge.endPoint(), newLastEdge.startPoint())) {
             break;
           }
-          returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);
+          returnBoundary = new SidedPlane(firstEdge.endPoint(), firstEdge.startPoint(), newLastEdge.endPoint());
         } else {
           returnBoundary = null;
         }
@@ -1145,17 +1145,17 @@
           final Edge edge = edgeIterator.next();
           if (!includedEdges.contains(edge) && edge != newLastEdge) {
             // This edge has a point to check
-            if (edge.startPoint != newLastEdge.endPoint) {
+            if (edge.startPoint() != newLastEdge.endPoint()) {
               // look at edge.startPoint
-              if (isWithin(edge.startPoint, includedEdges, newLastEdge, returnBoundary)) {
+              if (isWithin(edge.startPoint(), includedEdges, newLastEdge, returnBoundary)) {
                 //System.out.println("  nope; point within found: "+edge.startPoint);
                 foundPointInside = true;
                 break;
               }
             }
-            if (edge.endPoint != firstEdge.startPoint) {
+            if (edge.endPoint() != firstEdge.startPoint()) {
               // look at edge.endPoint
-              if (isWithin(edge.endPoint, includedEdges, newLastEdge, returnBoundary)) {
+              if (isWithin(edge.endPoint(), includedEdges, newLastEdge, returnBoundary)) {
                 //System.out.println("  nope; point within found: "+edge.endPoint);
                 foundPointInside = true;
                 break;
@@ -1179,24 +1179,24 @@
     
     // Now, walk towards the beginning until we need to stop
     while (true) {
-      if (firstEdge.startPoint == lastEdge.endPoint) {
+      if (firstEdge.startPoint() == lastEdge.endPoint()) {
         break;
       }
       final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);
-      if (Plane.arePointsCoplanar(newFirstEdge.startPoint, newFirstEdge.endPoint, firstEdge.endPoint)) {
+      if (Plane.arePointsCoplanar(newFirstEdge.startPoint(), newFirstEdge.endPoint(), firstEdge.endPoint())) {
         break;
       }
-      if (isWithin(newFirstEdge.startPoint, includedEdges)) {
+      if (isWithin(newFirstEdge.startPoint(), includedEdges)) {
         //System.out.println(" maybe can extend to previous edge");
         // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon
         // here will overlap with other remaining points?
         final SidedPlane returnBoundary;
-        if (newFirstEdge.startPoint != lastEdge.endPoint) {
-          if(Plane.arePointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint) ||
-            Plane.arePointsCoplanar(lastEdge.endPoint, newFirstEdge.startPoint, newFirstEdge.endPoint)) {
+        if (newFirstEdge.startPoint() != lastEdge.endPoint()) {
+          if(Plane.arePointsCoplanar(lastEdge.startPoint(), lastEdge.endPoint(), newFirstEdge.startPoint()) ||
+            Plane.arePointsCoplanar(lastEdge.endPoint(), newFirstEdge.startPoint(), newFirstEdge.endPoint())) {
             break;
           }
-          returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);
+          returnBoundary = new SidedPlane(lastEdge.startPoint(), lastEdge.endPoint(), newFirstEdge.startPoint());
         } else {
           returnBoundary = null;
         }
@@ -1208,17 +1208,17 @@
           final Edge edge = edgeIterator.next();
           if (!includedEdges.contains(edge) && edge != newFirstEdge) {
             // This edge has a point to check
-            if (edge.startPoint != lastEdge.endPoint) {
+            if (edge.startPoint() != lastEdge.endPoint()) {
               // look at edge.startPoint
-              if (isWithin(edge.startPoint, includedEdges, newFirstEdge, returnBoundary)) {
+              if (isWithin(edge.startPoint(), includedEdges, newFirstEdge, returnBoundary)) {
                 //System.out.println("  nope; point within found: "+edge.startPoint);
                 foundPointInside = true;
                 break;
               }
             }
-            if (edge.endPoint != newFirstEdge.startPoint) {
+            if (edge.endPoint() != newFirstEdge.startPoint()) {
               // look at edge.endPoint
-              if (isWithin(edge.endPoint, includedEdges, newFirstEdge, returnBoundary)) {
+              if (isWithin(edge.endPoint(), includedEdges, newFirstEdge, returnBoundary)) {
                 //System.out.println("  nope; point within found: "+edge.endPoint);
                 foundPointInside = true;
                 break;
@@ -1258,7 +1258,7 @@
     final BitSet internalEdges = new BitSet(includedEdges.size());
     final boolean returnIsInternal;
     
-    if (firstEdge.startPoint == lastEdge.endPoint) {
+    if (firstEdge.startPoint() == lastEdge.endPoint()) {
       // Degenerate case!!  There is no return edge -- or rather, we already have it.
       if (includedEdges.size() < 3) {
         // This means we found a degenerate cycle of edges.  If we emit a polygon at this point it
@@ -1269,22 +1269,22 @@
       // Now look for completely planar points.  This too is a degeneracy condition that we should
       // return "false" for.
       Edge edge = firstEdge;
-      points.add(edge.startPoint);
+      points.add(edge.startPoint());
       int k = 0;
       while (true) {
         if (edge == lastEdge) {
           break;
         }
-        points.add(edge.endPoint);
-        internalEdges.set(k++, edge.isInternal);
+        points.add(edge.endPoint());
+        internalEdges.set(k++, edge.isInternal());
         edge = edgeBuffer.getNext(edge);
       }
-      returnIsInternal = lastEdge.isInternal;
+      returnIsInternal = lastEdge.isInternal();
       edgeBuffer.clear();
     } else {
       // Build the return edge (internal, of course)
-      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint, false, firstEdge.startPoint, lastEdge.endPoint);
-      final Edge returnEdge = new Edge(firstEdge.startPoint, lastEdge.endPoint, returnSidedPlane, true);
+      final SidedPlane returnSidedPlane = new SidedPlane(firstEdge.endPoint(), false, firstEdge.startPoint(), lastEdge.endPoint());
+      final Edge returnEdge = new Edge(firstEdge.startPoint(), lastEdge.endPoint(), returnSidedPlane, true);
 
       // Build point list and edge list
       final List<Edge> edges = new ArrayList<Edge>(includedEdges.size());
@@ -1293,11 +1293,11 @@
       // Now look for completely planar points.  This too is a degeneracy condition that we should
       // return "false" for.
       Edge edge = firstEdge;
-      points.add(edge.startPoint);
+      points.add(edge.startPoint());
       int k = 0;
       while (true) {
-        points.add(edge.endPoint);
-        internalEdges.set(k++, edge.isInternal);
+        points.add(edge.endPoint());
+        internalEdges.set(k++, edge.isInternal());
         edges.add(edge);
         if (edge == lastEdge) {
           break;
@@ -1379,12 +1379,10 @@
   private static class Edge {
     /** Plane */
     public final SidedPlane plane;
-    /** Start point */
-    public final GeoPoint startPoint;
-    /** End point */
-    public final GeoPoint endPoint;
-    /** Internal edge flag */
-    public final boolean isInternal;
+    /** List of points */
+    private final List<GeoPoint> points = new ArrayList<>();
+    /** Internal edge flags */
+    private final BitSet isInternal = new BitSet();
 
     /** Constructor.
       * @param startPoint the edge start point
@@ -1393,10 +1391,55 @@
       * @param isInternal true if internal edge
       */
     public Edge(final GeoPoint startPoint, final GeoPoint endPoint, final SidedPlane plane, final boolean isInternal) {
-      this.startPoint = startPoint;
-      this.endPoint = endPoint;
+      points.add(startPoint);
+      points.add(endPoint);
       this.plane = plane;
-      this.isInternal = isInternal;
+      this.isInternal.set(0, isInternal);
+    }
+
+    /**
+     * first point of this edge.
+     *
+     * @return start point
+     */
+    public GeoPoint startPoint() {
+      return points.get(0);
+    }
+
+    /**
+     * last point of this edge
+     *
+     * @return last point
+     */
+    public GeoPoint endPoint() {
+      return points.get(points.size() - 1);
+    }
+
+    /**
+     * if the edge is internal of part of the shape.
+     *
+     * @return true if all flags are internal, else false
+     */
+    public boolean isInternal() {
+      for (int i = 0; i <points.size() -1; i ++) {
+        if (!isInternal.get(i)) {
+          return false;
+        }
+      }
+      return true;
+    }
+
+    /**
+     * Merge this edge with provided edge at end.
+     *
+     * @param edge to be merged.
+     */
+    public void addEdge(Edge edge) {
+      points.addAll(edge.points);
+      int index = points.size() -1;
+      for(int i= 0; i < edge.points.size() -1; i ++) {
+        isInternal.set(index + i, edge.isInternal.get(i));
+      }
     }
     
     @Override
@@ -1493,7 +1536,7 @@
         */
         
         // Check termination condition
-        if (currentEdge.endPoint == startEdge.startPoint) {
+        if (currentEdge.endPoint() == startEdge.startPoint()) {
           // We finish here.  Link the current edge to the start edge, and exit
           previousEdges.put(startEdge, currentEdge);
           nextEdges.put(currentEdge, startEdge);
@@ -1516,7 +1559,7 @@
         // is not colinear, then we can use the new point's relationship with the current edge as our guide.
         
         final boolean isNewPointWithin = currentEdge.plane.isWithin(newPoint);
-        final GeoPoint pointToPresent = currentEdge.startPoint;
+        final GeoPoint pointToPresent = currentEdge.startPoint();
 
         final SidedPlane newPlane = new SidedPlane(pointToPresent, isNewPointWithin, pointList.get(startIndex), newPoint);
         final Edge newEdge = new Edge(pointList.get(startIndex), pointList.get(endIndex), newPlane, internalEdges.get(startIndex));
@@ -1594,16 +1637,38 @@
       }
       System.out.println("...with: "+newEdge.startPoint+"-->"+newEdge.endPoint);
       */
+      Edge currentEdge = newEdge;
       final Edge previous = previousEdges.get(removeList.get(0));
       final Edge next = nextEdges.get(removeList.get(removeList.size()-1));
-      edges.add(newEdge);
-      previousEdges.put(newEdge, previous);
-      nextEdges.put(previous, newEdge);
-      previousEdges.put(next, newEdge);
-      nextEdges.put(newEdge, next);
+      if (Plane.arePointsCoplanar(newEdge.startPoint(), newEdge.endPoint(), previous.startPoint())) {
+        previous.addEdge(newEdge);
+        nextEdges.put(previous, next);
+        previousEdges.put(next, previous);
+        currentEdge = previous;
+      } else if (Plane.arePointsCoplanar(newEdge.startPoint(), newEdge.endPoint(), next.endPoint())) {
+        newEdge.addEdge(next);
+        edges.add(newEdge);
+        final Edge newNext = nextEdges.get(next);
+        edges.remove(next);
+        previousEdges.remove(next);
+        nextEdges.remove(next);
+        previousEdges.put(newEdge, previous);
+        nextEdges.put(previous, newEdge);
+        previousEdges.put(newNext, newEdge);
+        nextEdges.put(newEdge, newNext);
+        if (next == oneEdge) {
+          oneEdge = newEdge;
+        }
+      } else {
+        edges.add(newEdge);
+        previousEdges.put(newEdge, previous);
+        nextEdges.put(previous, newEdge);
+        previousEdges.put(next, newEdge);
+        nextEdges.put(newEdge, next);
+      }
       for (final Edge edge : removeList) {
         if (edge == oneEdge) {
-          oneEdge = newEdge;
+          oneEdge = currentEdge;
         }
         edges.remove(edge);
         previousEdges.remove(edge);
