Index: modules/join/src/java/org/apache/lucene/search/join/BlockJoinQuery.java
===================================================================
--- modules/join/src/java/org/apache/lucene/search/join/BlockJoinQuery.java	(revision 1148880)
+++ modules/join/src/java/org/apache/lucene/search/join/BlockJoinQuery.java	(working copy)
@@ -18,6 +18,8 @@
  */
 
 import java.io.IOException;
+import java.util.Collection;
+import java.util.Collections;
 import java.util.Set;
 
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
@@ -32,6 +34,7 @@
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.Scorer.ChildScorer;
 import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.grouping.TopGroups;
 import org.apache.lucene.util.ArrayUtil;
@@ -210,11 +213,8 @@
     }
 
     @Override
-    public void visitSubScorers(Query parent, BooleanClause.Occur relationship,
-                                ScorerVisitor<Query, Query, Scorer> visitor) {
-      super.visitSubScorers(parent, relationship, visitor);
-      //childScorer.visitSubScorers(weight.getQuery(), BooleanClause.Occur.MUST, visitor);
-      childScorer.visitScorers(visitor);
+    public Collection<ChildScorer> getChildren() {
+      return Collections.singletonList(new ChildScorer(childScorer, "BLOCK_JOIN"));
     }
 
     int getChildCount() {
Index: modules/join/src/java/org/apache/lucene/search/join/BlockJoinCollector.java
===================================================================
--- modules/join/src/java/org/apache/lucene/search/join/BlockJoinCollector.java	(revision 1148880)
+++ modules/join/src/java/org/apache/lucene/search/join/BlockJoinCollector.java	(working copy)
@@ -18,9 +18,12 @@
  */
 
 import java.io.IOException;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.LinkedList;
 import java.util.Map;
+import java.util.Queue;
 
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.index.IndexReader;
@@ -31,6 +34,7 @@
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.ScoreCachingWrappingScorer;
 import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.Scorer.ChildScorer;
 import org.apache.lucene.search.Sort;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.TopDocsCollector;
@@ -281,6 +285,20 @@
     return false;
   }
 
+  private void enroll(BlockJoinQuery query, BlockJoinQuery.BlockJoinScorer scorer) {
+    final Integer slot = joinQueryID.get(query);
+    if (slot == null) {
+      joinQueryID.put(query, joinScorers.length);
+      //System.out.println("found JQ: " + query + " slot=" + joinScorers.length);
+      final BlockJoinQuery.BlockJoinScorer[] newArray = new BlockJoinQuery.BlockJoinScorer[1+joinScorers.length];
+      System.arraycopy(joinScorers, 0, newArray, 0, joinScorers.length);
+      joinScorers = newArray;
+      joinScorers[joinScorers.length-1] = scorer;
+    } else {
+      joinScorers[slot] = scorer;
+    }
+  }
+  
   @Override
   public void setScorer(Scorer scorer) {
     //System.out.println("C.setScorer scorer=" + scorer);
@@ -293,49 +311,17 @@
     }
     Arrays.fill(joinScorers, null);
 
-    // Find any BlockJoinScorers out there:
-    scorer.visitScorers(new Scorer.ScorerVisitor<Query,Query,Scorer>() {
-        private void enroll(BlockJoinQuery query, BlockJoinQuery.BlockJoinScorer scorer) {
-          final Integer slot = joinQueryID.get(query);
-          if (slot == null) {
-            joinQueryID.put(query, joinScorers.length);
-            //System.out.println("found JQ: " + query + " slot=" + joinScorers.length);
-            final BlockJoinQuery.BlockJoinScorer[] newArray = new BlockJoinQuery.BlockJoinScorer[1+joinScorers.length];
-            System.arraycopy(joinScorers, 0, newArray, 0, joinScorers.length);
-            joinScorers = newArray;
-            joinScorers[joinScorers.length-1] = scorer;
-          } else {
-            joinScorers[slot] = scorer;
-          }
-        }
+    Queue<Scorer> queue = new LinkedList<Scorer>();
+    queue.add(scorer);
+    while ((scorer = queue.poll()) != null) {
+      if (scorer instanceof BlockJoinQuery.BlockJoinScorer) {
+        enroll((BlockJoinQuery) scorer.getWeight().getQuery(), (BlockJoinQuery.BlockJoinScorer)scorer);
+      }
 
-        @Override
-        public void visitOptional(Query parent, Query child, Scorer scorer) {
-          //System.out.println("visitOpt");
-          if (child instanceof BlockJoinQuery) {
-            enroll((BlockJoinQuery) child,
-                   (BlockJoinQuery.BlockJoinScorer) scorer);
-          }
-        }
-
-        @Override
-        public void visitRequired(Query parent, Query child, Scorer scorer) {
-          //System.out.println("visitReq parent=" + parent + " child=" + child + " scorer=" + scorer);
-          if (child instanceof BlockJoinQuery) {
-            enroll((BlockJoinQuery) child,
-                   (BlockJoinQuery.BlockJoinScorer) scorer);
-          }
-        }
-
-        @Override
-        public void visitProhibited(Query parent, Query child, Scorer scorer) {
-          //System.out.println("visitProh");
-          if (child instanceof BlockJoinQuery) {
-            enroll((BlockJoinQuery) child,
-                   (BlockJoinQuery.BlockJoinScorer) scorer);
-          }
-        }
-      });
+      for (ChildScorer sub : scorer.getChildren()) {
+        queue.add(sub.child);
+      }
+    }
   }
 
   private final static class FakeScorer extends Scorer {
Index: lucene/src/test/org/apache/lucene/search/TestSubScorerFreqs.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestSubScorerFreqs.java	(revision 1148880)
+++ lucene/src/test/org/apache/lucene/search/TestSubScorerFreqs.java	(working copy)
@@ -25,7 +25,7 @@
 import org.apache.lucene.index.*;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.search.BooleanClause.Occur;
-import org.apache.lucene.search.Scorer.ScorerVisitor;
+import org.apache.lucene.search.Scorer.ChildScorer;
 import org.apache.lucene.store.*;
 import org.apache.lucene.util.*;
 import org.junit.AfterClass;
@@ -75,45 +75,32 @@
     public final Map<Integer, Map<Query, Float>> docCounts = new HashMap<Integer, Map<Query, Float>>();
 
     private final Map<Query, Scorer> subScorers = new HashMap<Query, Scorer>();
-    private final ScorerVisitor<Query, Query, Scorer> visitor = new MockScorerVisitor();
-    private final EnumSet<Occur> collect;
+    private final Set<String> relationships;
 
-    private class MockScorerVisitor extends ScorerVisitor<Query, Query, Scorer> {
-
-      @Override
-      public void visitOptional(Query parent, Query child, Scorer scorer) {
-        if (collect.contains(Occur.SHOULD))
-          subScorers.put(child, scorer);
-      }
-
-      @Override
-      public void visitProhibited(Query parent, Query child, Scorer scorer) {
-        if (collect.contains(Occur.MUST_NOT))
-          subScorers.put(child, scorer);
-      }
-
-      @Override
-      public void visitRequired(Query parent, Query child, Scorer scorer) {
-        if (collect.contains(Occur.MUST))
-          subScorers.put(child, scorer);
-      }
-
-    }
-
     public CountingCollector(Collector other) {
-      this(other, EnumSet.allOf(Occur.class));
+      this(other, new HashSet<String>(Arrays.asList(Occur.MUST.toString(), Occur.SHOULD.toString(), Occur.MUST_NOT.toString())));
     }
 
-    public CountingCollector(Collector other, EnumSet<Occur> collect) {
+    public CountingCollector(Collector other, Set<String> relationships) {
       this.other = other;
-      this.collect = collect;
+      this.relationships = relationships;
     }
 
     @Override
     public void setScorer(Scorer scorer) throws IOException {
       other.setScorer(scorer);
-      scorer.visitScorers(visitor);
+      subScorers.clear();
+      setSubScorers(scorer, "TOP");
     }
+    
+    public void setSubScorers(Scorer scorer, String relationship) {
+      for (ChildScorer child : scorer.getChildren()) {
+        if (relationships.contains(child.relationship)) {
+          setSubScorers(child.child, child.relationship);
+        }
+      }
+      subScorers.put(scorer.getWeight().getQuery(), scorer);
+    }
 
     @Override
     public void collect(int doc) throws IOException {
@@ -177,14 +164,17 @@
     query.add(inner, Occur.MUST);
     query.add(aQuery, Occur.MUST);
     query.add(dQuery, Occur.MUST);
-    EnumSet<Occur>[] occurList = new EnumSet[] {EnumSet.of(Occur.MUST), EnumSet.of(Occur.MUST, Occur.SHOULD)};
-    for (EnumSet<Occur> occur : occurList) {
+    Set<String>[] occurList = new Set[] {
+        Collections.singleton(Occur.MUST.toString()), 
+        new HashSet<String>(Arrays.asList(Occur.MUST.toString(), Occur.SHOULD.toString()))
+    };
+    for (Set<String> occur : occurList) {
       CountingCollector c = new CountingCollector(TopScoreDocCollector.create(
           10, true), occur);
       s.search(query, null, c);
       final int maxDocs = s.maxDoc();
       assertEquals(maxDocs, c.docCounts.size());
-      boolean includeOptional = occur.contains(Occur.SHOULD);
+      boolean includeOptional = occur.contains(Occur.SHOULD.toString());
       for (int i = 0; i < maxDocs; i++) {
         Map<Query, Float> doc0 = c.docCounts.get(i);
         assertEquals(includeOptional ? 5 : 4, doc0.size());
Index: lucene/src/java/org/apache/lucene/search/BooleanScorer2.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/BooleanScorer2.java	(revision 1148880)
+++ lucene/src/java/org/apache/lucene/search/BooleanScorer2.java	(working copy)
@@ -19,10 +19,12 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery.BooleanWeight;
+import org.apache.lucene.search.Scorer.ChildScorer;
 
 /* See the description in BooleanScorer.java, comparing
  * BooleanScorer & BooleanScorer2 */
@@ -318,17 +320,17 @@
   }
 
   @Override
-  protected void visitSubScorers(Query parent, Occur relationship, ScorerVisitor<Query, Query, Scorer> visitor) {
-    super.visitSubScorers(parent, relationship, visitor);
-    final Query q = weight.getQuery();
+  public Collection<ChildScorer> getChildren() {
+    ArrayList<ChildScorer> children = new ArrayList<ChildScorer>();
     for (Scorer s : optionalScorers) {
-      s.visitSubScorers(q, Occur.SHOULD, visitor);
+      children.add(new ChildScorer(s, Occur.SHOULD.toString()));
     }
     for (Scorer s : prohibitedScorers) {
-      s.visitSubScorers(q, Occur.MUST_NOT, visitor);
+      children.add(new ChildScorer(s, Occur.MUST_NOT.toString()));
     }
     for (Scorer s : requiredScorers) {
-      s.visitSubScorers(q, Occur.MUST, visitor);
+      children.add(new ChildScorer(s, Occur.MUST.toString()));
     }
+    return children;
   }
 }
Index: lucene/src/java/org/apache/lucene/search/BooleanScorer.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/BooleanScorer.java	(revision 1148880)
+++ lucene/src/java/org/apache/lucene/search/BooleanScorer.java	(working copy)
@@ -18,6 +18,8 @@
  */
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
@@ -353,26 +355,11 @@
   }
   
   @Override
-  protected void visitSubScorers(Query parent, Occur relationship, ScorerVisitor<Query, Query, Scorer> visitor) {
-    super.visitSubScorers(parent, relationship, visitor);
-    final Query q = weight.getQuery();
-    SubScorer sub = scorers;
-    while(sub != null) {
-      // TODO: re-enable this if BQ ever sends us required
-      //clauses
-      //if (sub.required) {
-      //relationship = Occur.MUST;
-      if (!sub.prohibited) {
-        relationship = Occur.SHOULD;
-      } else {
-        // TODO: maybe it's pointless to do this, but, it is
-        // possible the doc may still be collected, eg foo
-        // OR (bar -fee)
-        relationship = Occur.MUST_NOT;
-      }
-      sub.scorer.visitSubScorers(q, relationship, visitor);
-      sub = sub.next;
+  public Collection<ChildScorer> getChildren() {
+    List<ChildScorer> children = new ArrayList<ChildScorer>();
+    for (SubScorer sub = scorers; sub != null; sub = sub.next) {
+      children.add(new ChildScorer(sub.scorer, sub.prohibited ? Occur.MUST_NOT.toString() : Occur.SHOULD.toString()));
     }
+    return children;
   }
-
 }
Index: lucene/src/java/org/apache/lucene/search/Scorer.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/Scorer.java	(revision 1148880)
+++ lucene/src/java/org/apache/lucene/search/Scorer.java	(working copy)
@@ -18,9 +18,9 @@
  */
 
 import java.io.IOException;
+import java.util.Collection;
+import java.util.Collections;
 
-import org.apache.lucene.search.BooleanClause.Occur;
-
 /**
  * Expert: Common scoring functionality for different types of queries.
  *
@@ -101,83 +101,30 @@
   public float freq() throws IOException {
     throw new UnsupportedOperationException(this + " does not implement freq()");
   }
-
-  /**
-   * A callback to gather information from a scorer and its sub-scorers. Each
-   * the top-level scorer as well as each of its sub-scorers are passed to
-   * either one of the visit methods depending on their boolean relationship in
-   * the query.
+  
+  /** returns parent Weight
    * @lucene.experimental
    */
-  public static abstract class ScorerVisitor<P extends Query, C extends Query, S extends Scorer> {
-    /**
-     * Invoked for all optional scorer 
-     * 
-     * @param parent the parent query of the child query or <code>null</code> if the child is a top-level query
-     * @param child the query of the currently visited scorer
-     * @param scorer the current scorer
-     */
-    public void visitOptional(P parent, C child, S scorer) {}
-    
-    /**
-     * Invoked for all required scorer 
-     * 
-     * @param parent the parent query of the child query or <code>null</code> if the child is a top-level query
-     * @param child the query of the currently visited scorer
-     * @param scorer the current scorer
-     */
-    public void visitRequired(P parent, C child, S scorer) {}
-    
-    /**
-     * Invoked for all prohibited scorer 
-     * 
-     * @param parent the parent query of the child query or <code>null</code> if the child is a top-level query
-     * @param child the query of the currently visited scorer
-     * @param scorer the current scorer
-     */
-    public void visitProhibited(P parent, C child, S scorer) {}
-  } 
-
-  /**
-   * Expert: call this to gather details for all sub-scorers for this query.
-   * This can be used, in conjunction with a custom {@link Collector} to gather
-   * details about how each sub-query matched the current hit.
-   * 
-   * @param visitor a callback executed for each sub-scorer
-   * @lucene.experimental
-   */
-  public void visitScorers(ScorerVisitor<Query, Query, Scorer> visitor) {
-    visitSubScorers(null, Occur.MUST/*must id default*/, visitor);
+  public Weight getWeight() {
+    return weight;
   }
-
-  /**
-   * {@link Scorer} subclasses should implement this method if the subclass
-   * itself contains multiple scorers to support gathering details for
-   * sub-scorers via {@link ScorerVisitor}
-   * <p>
-   * Note: this method will throw {@link UnsupportedOperationException} if no
-   * associated {@link Weight} instance is provided to
-   * {@link #Scorer(Weight)}
-   * </p>
-   * 
-   * @lucene.experimental
-   */
-  protected void visitSubScorers(Query parent, Occur relationship,
-      ScorerVisitor<Query, Query, Scorer> visitor) {
-    if (weight == null)
-      throw new UnsupportedOperationException();
-
-    final Query q = weight.getQuery();
-    switch (relationship) {
-    case MUST:
-      visitor.visitRequired(parent, q, this);
-      break;
-    case MUST_NOT:
-      visitor.visitProhibited(parent, q, this);
-      break;
-    case SHOULD:
-      visitor.visitOptional(parent, q, this);
-      break;
+  
+  /** Returns child sub-scorers
+   * @lucene.experimental */
+  public Collection<ChildScorer> getChildren() {
+    return Collections.emptyList();
+  }
+  
+  /** a child Scorer and its relationship to its parent.
+   * the meaning of the relationship depends upon the parent query. 
+   * @lucene.experimental */
+  public static class ChildScorer {
+    public final Scorer child;
+    public final String relationship;
+    
+    public ChildScorer(Scorer child, String relationship) {
+      this.child = child;
+      this.relationship = relationship;
     }
   }
 }
