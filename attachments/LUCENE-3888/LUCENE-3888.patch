Index: solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker.java
===================================================================
--- solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker.java	(revision 1305054)
+++ solr/core/src/java/org/apache/solr/spelling/AbstractLuceneSpellChecker.java	(working copy)
@@ -32,6 +32,7 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.Token;
 import org.apache.lucene.analysis.core.WhitespaceAnalyzer;
 import org.apache.lucene.index.IndexReader;
@@ -69,6 +70,7 @@
   public static final String ACCURACY = "accuracy";
   public static final String STRING_DISTANCE = "distanceMeasure";
   public static final String COMPARATOR_CLASS = "comparatorClass";
+  public static final String ANALYZER_FIELD_TYPE = "spellcheckerAnalyzerFieldType";
 
   public static final String SCORE_COMP = "score";
   public static final String FREQ_COMP = "freq";
@@ -121,12 +123,22 @@
     } else {
       sd = new LevensteinDistance();
     }
+    String analyzerFieldType = (String) config.get(ANALYZER_FIELD_TYPE);
+    Analyzer analyzer = null;
+    if (analyzerFieldType != null &&
+        core.getSchema().getFieldTypes().containsKey(analyzerFieldType))  {
+      FieldType fieldType = core.getSchema().getFieldTypes().get(analyzerFieldType);
+      analyzer = fieldType.getQueryAnalyzer();
+    }
     try {
       initIndex();
       spellChecker = new SpellChecker(index, sd, comp);
     } catch (IOException e) {
       throw new RuntimeException(e);
     }
+    if (analyzer != null) {
+      spellChecker.setAnalyzer(analyzer);
+    }
     if (accuracy != null) {
       try {
         this.accuracy = Float.parseFloat(accuracy);
Index: modules/suggest/src/test/org/apache/lucene/search/spell/TestDirectSpellChecker.java
===================================================================
--- modules/suggest/src/test/org/apache/lucene/search/spell/TestDirectSpellChecker.java	(revision 1305054)
+++ modules/suggest/src/test/org/apache/lucene/search/spell/TestDirectSpellChecker.java	(working copy)
@@ -51,8 +51,8 @@
     StringDistance sd = spellchecker.getDistance();
     assertTrue(sd instanceof LuceneLevenshteinDistance);
     for(SuggestWord word : similar) {
-      assertTrue(word.score==sd.getDistance(word.string, misspelled));
-      assertTrue(word.score==sd.getDistance(misspelled, word.string));
+      assertTrue(word.getScore()==sd.getDistance(word.getAnalyzed(), misspelled));
+      assertTrue(word.getScore()==sd.getDistance(misspelled, word.getAnalyzed()));
     }
     
     ir.close();
@@ -77,33 +77,33 @@
     SuggestWord[] similar = spellChecker.suggestSimilar(new Term("numbers",
         "fvie"), 2, ir, SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX);
     assertTrue(similar.length > 0);
-    assertEquals("five", similar[0].string);
+    assertEquals("five", similar[0].getSurface());
 
     similar = spellChecker.suggestSimilar(new Term("numbers", "five"), 2, ir,
         SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX);
     if (similar.length > 0) {
-      assertFalse(similar[0].string.equals("five")); // don't suggest a word for itself
+      assertFalse(similar[0].getSurface().equals("five")); // don't suggest a word for itself
     }
 
     similar = spellChecker.suggestSimilar(new Term("numbers", "fvie"), 2, ir,
         SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX);
     assertTrue(similar.length > 0);
-    assertEquals("five", similar[0].string);
+    assertEquals("five", similar[0].getSurface());
 
     similar = spellChecker.suggestSimilar(new Term("numbers", "fiv"), 2, ir,
         SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX);
     assertTrue(similar.length > 0);
-    assertEquals("five", similar[0].string);
+    assertEquals("five", similar[0].getSurface());
 
     similar = spellChecker.suggestSimilar(new Term("numbers", "fives"), 2, ir,
         SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX);
     assertTrue(similar.length > 0);
-    assertEquals("five", similar[0].string);
+    assertEquals("five", similar[0].getSurface());
 
     assertTrue(similar.length > 0);
     similar = spellChecker.suggestSimilar(new Term("numbers", "fie"), 2, ir,
         SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX);
-    assertEquals("five", similar[0].string);
+    assertEquals("five", similar[0].getSurface());
 
     // add some more documents
     for (int i = 1000; i < 1100; i++) {
@@ -119,7 +119,7 @@
     similar = spellChecker.suggestSimilar(new Term("numbers", "tousand"), 10,
         ir, SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX);
     assertTrue(similar.length > 0); 
-    assertEquals("thousand", similar[0].string);
+    assertEquals("thousand", similar[0].getSurface());
 
     ir.close();
     writer.close();
@@ -234,7 +234,7 @@
         "numbers", "fvie"), 1, ir,
         SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX);
     assertEquals(1, similar.length);
-    assertEquals("five", similar[0].string);
+    assertEquals("five", similar[0].getSurface());
     ir.close();
     writer.close();
     dir.close();
@@ -259,7 +259,7 @@
         "numbers", "seevntene"), 2, ir,
         SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX);
     assertEquals(1, similar.length);
-    assertEquals("seventeen", similar[0].string);
+    assertEquals("seventeen", similar[0].getSurface());
     ir.close();
     writer.close();
     dir.close();
Index: modules/suggest/src/test/org/apache/lucene/search/spell/TestSpellChecker.java
===================================================================
--- modules/suggest/src/test/org/apache/lucene/search/spell/TestSpellChecker.java	(revision 1305054)
+++ modules/suggest/src/test/org/apache/lucene/search/spell/TestSpellChecker.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import java.io.IOException;
+import java.io.Reader;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -26,13 +27,20 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
 
+import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.Analyzer.TokenStreamComponents;
 import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.store.AlreadyClosedException;
 import org.apache.lucene.store.Directory;
@@ -85,6 +93,13 @@
                                                                     // twice
       writer.addDocument(doc);
     }
+    {
+      Document doc = new Document();
+      doc.add(newField("field1", "APPLE", TextField.TYPE_STORED)); // an "APPLE"
+                                                                    // in the
+                                                                    // index
+      writer.addDocument(doc);
+    }
     
     writer.close();
     searchers = Collections.synchronizedList(new ArrayList<IndexSearcher>());
@@ -230,6 +245,40 @@
     }
     r.close();
   }
+  
+  public void testSurfaceAnalyzer() throws Exception {
+    // a keywordAnalyzer: no lowercasing or tokenization
+    Analyzer keywordAnalyzer = new MockAnalyzer(random, MockTokenizer.KEYWORD, false);
+    Directory dir = newDirectory();
+    RandomIndexWriter iw = new RandomIndexWriter(random, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, keywordAnalyzer));
+    Document doc = new Document();
+    Field field = new StringField("field1", "APPLE");
+    doc.add(field);
+    iw.addDocument(doc);
+    iw.close();
+    
+    IndexReader r = IndexReader.open(dir);
+    // lowercasing analyzer
+    Analyzer a = new Analyzer() {
+      @Override
+      protected TokenStreamComponents createComponents(String fieldName, Reader reader) {
+        return new TokenStreamComponents(new MockTokenizer(reader, MockTokenizer.KEYWORD, true));
+      }
+    };
+    spellChecker.setAnalyzer(a);
+    spellChecker.clearIndex();
+    // nocommit: we need to fix SuggestWord to separate surface and analyzed forms.
+    // currently the 're-rank' is based on the surface forms!
+    spellChecker.setAccuracy(0F);
+    addwords(r, spellChecker, "field1");
+    
+    String[] similar = spellChecker.suggestSimilar("appli", 1, r, "field1", SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX);
+    assertEquals(1, similar.length);
+    assertEquals("APPLE", similar[0]);
+    r.close();
+    dir.close();
+  }
+
   private void checkCommonSuggestions(IndexReader r) throws IOException {
     String[] similar = spellChecker.suggestSimilar("fvie", 2);
     assertTrue(similar.length > 0);
Index: modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker.java
===================================================================
--- modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker.java	(revision 1305054)
+++ modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker.java	(working copy)
@@ -362,14 +362,12 @@
     SuggestWord suggestions[] = new SuggestWord[terms.size()];
     int index = suggestions.length - 1;
     for (ScoreTerm s : terms) {
-      SuggestWord suggestion = new SuggestWord();
       if (s.termAsString == null) {
         UnicodeUtil.UTF8toUTF16(s.term, spare);
         s.termAsString = spare.toString();
       }
-      suggestion.string = s.termAsString;
-      suggestion.score = s.score;
-      suggestion.freq = s.docfreq;
+      SuggestWord suggestion = new SuggestWord(s.termAsString, s.termAsString, s.docfreq);
+      suggestion.setScore(s.score);
       suggestions[index--] = suggestion;
     }
     
Index: modules/suggest/src/java/org/apache/lucene/search/spell/SuggestWord.java
===================================================================
--- modules/suggest/src/java/org/apache/lucene/search/spell/SuggestWord.java	(revision 1305054)
+++ modules/suggest/src/java/org/apache/lucene/search/spell/SuggestWord.java	(working copy)
@@ -25,21 +25,50 @@
  * 
  *
  */
-public final class SuggestWord{
+public final class SuggestWord {
+  private final int freq;
+  private final String analyzed;
+  private final String surface;
   
+  public SuggestWord(String analyzed, String surface, int freq) {
+    this.analyzed = analyzed;
+    this.surface = surface;
+    this.freq = freq;
+  }
+
+  private float score;
   /**
-   * the score of the word
+   * returns the score of the word
    */
-  public float score;
+  public float getScore() {
+    return score;
+  }
 
   /**
-   * The freq of the word
+   * sets the score of the word
    */
-  public int freq;
+  public void setScore(float score) {
+    this.score = score;
+  }
 
   /**
-   * the suggested word
+   * returns the freq of the word
    */
-  public String string;
+  public int getFreq() {
+    return freq;
+  }
 
-}
\ No newline at end of file
+  /**
+   * returns the suggested word (analyzed form for comparison)
+   */
+  public String getAnalyzed() {
+    return analyzed;
+  }
+
+  /**
+   * returns the suggested word (surface form for retrieval)
+   */
+  public String getSurface() {
+    return surface;
+  }
+}
Index: modules/suggest/src/java/org/apache/lucene/search/spell/SuggestWordFrequencyComparator.java
===================================================================
--- modules/suggest/src/java/org/apache/lucene/search/spell/SuggestWordFrequencyComparator.java	(revision 1305054)
+++ modules/suggest/src/java/org/apache/lucene/search/spell/SuggestWordFrequencyComparator.java	(working copy)
@@ -27,21 +27,28 @@
 
   public int compare(SuggestWord first, SuggestWord second) {
     // first criteria: the frequency
-    if (first.freq > second.freq) {
+    if (first.getFreq() > second.getFreq()) {
       return 1;
     }
-    if (first.freq < second.freq) {
+    if (first.getFreq() < second.getFreq()) {
       return -1;
     }
 
     // second criteria (if first criteria is equal): the score
-    if (first.score > second.score) {
+    if (first.getScore() > second.getScore()) {
       return 1;
     }
-    if (first.score < second.score) {
+    if (first.getScore() < second.getScore()) {
       return -1;
     }
-    // third criteria: term text
-    return second.string.compareTo(first.string);
+    
+    // third criteria: analyzed form
+    int cmp = second.getAnalyzed().compareTo(first.getAnalyzed());
+    if (cmp != 0) {
+      return cmp;
+    }
+    
+    // fourth criteria: surface text
+    return second.getSurface().compareTo(first.getSurface());
   }
 }
Index: modules/suggest/src/java/org/apache/lucene/search/spell/SuggestWordScoreComparator.java
===================================================================
--- modules/suggest/src/java/org/apache/lucene/search/spell/SuggestWordScoreComparator.java	(revision 1305054)
+++ modules/suggest/src/java/org/apache/lucene/search/spell/SuggestWordScoreComparator.java	(working copy)
@@ -26,22 +26,29 @@
 public class SuggestWordScoreComparator implements Comparator<SuggestWord> {
   public int compare(SuggestWord first, SuggestWord second) {
     // first criteria: the distance
-    if (first.score > second.score) {
+    if (first.getScore() > second.getScore()) {
       return 1;
     }
-    if (first.score < second.score) {
+    if (first.getScore() < second.getScore()) {
       return -1;
     }
 
     // second criteria (if first criteria is equal): the popularity
-    if (first.freq > second.freq) {
+    if (first.getFreq() > second.getFreq()) {
       return 1;
     }
 
-    if (first.freq < second.freq) {
+    if (first.getFreq() < second.getFreq()) {
       return -1;
     }
-    // third criteria: term text
-    return second.string.compareTo(first.string);
+    
+    // third criteria: analyzed form
+    int cmp = second.getAnalyzed().compareTo(first.getAnalyzed());
+    if (cmp != 0) {
+      return cmp;
+    }
+    
+    // fourth criteria: surface text
+    return second.getSurface().compareTo(first.getSurface());
   }
 }
Index: modules/suggest/src/java/org/apache/lucene/search/spell/SpellChecker.java
===================================================================
--- modules/suggest/src/java/org/apache/lucene/search/spell/SpellChecker.java	(revision 1305054)
+++ modules/suggest/src/java/org/apache/lucene/search/spell/SpellChecker.java	(working copy)
@@ -18,15 +18,18 @@
  */
 
 import java.io.IOException;
+import java.io.StringReader;
 import java.util.ArrayList;
 import java.util.Comparator;
-import java.util.Iterator;
 import java.util.List;
 
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.document.StringField;
 import org.apache.lucene.index.AtomicReader;
 import org.apache.lucene.index.DirectoryReader;
@@ -34,9 +37,10 @@
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.IndexSearcher;
@@ -58,7 +62,7 @@
  *
  * <p>Example Usage:
  * 
- * <pre>
+ * <pre class="prettyprint">
  *  SpellChecker spellchecker = new SpellChecker(spellIndexDirectory);
  *  // To index a field of a user index:
  *  spellchecker.indexDictionary(new LuceneDictionary(my_lucene_reader, a_field));
@@ -66,7 +70,7 @@
  *  spellchecker.indexDictionary(new PlainTextDictionary(new File("myfile.txt")));
  *  String[] suggestions = spellchecker.suggestSimilar("misspelt", 5);
  * </pre>
- * 
+ * </p>
  *
  */
 public class SpellChecker implements java.io.Closeable {
@@ -117,6 +121,8 @@
   private StringDistance sd;
   private Comparator<SuggestWord> comparator;
 
+  private Analyzer analyzer = null;
+
   /**
    * Use the given directory as a spell checker index. The directory
    * is created if it doesn't exist yet.
@@ -190,6 +196,14 @@
   public Comparator<SuggestWord> getComparator() {
     return comparator;
   }
+  
+  public Analyzer getAnalyzer() {
+    return analyzer;
+  }
+  
+  public void setAnalyzer(Analyzer analyzer) {
+    this.analyzer = analyzer;
+  }
 
   /**
    * Sets the {@link StringDistance} implementation for this
@@ -228,6 +242,27 @@
   public float getAccuracy() {
     return accuracy;
   }
+  
+  // NOTE: can't do any crazy graphs etc
+  private String analyzeWord(String surface) throws IOException {
+    if (analyzer == null) {
+      return surface;
+    } else {
+      StringBuilder sb = new StringBuilder();
+      TokenStream ts = analyzer.tokenStream("bogus", new StringReader(surface));
+      CharTermAttribute termAtt = ts.addAttribute(CharTermAttribute.class);
+      PositionIncrementAttribute posIncAtt = ts.addAttribute(PositionIncrementAttribute.class);
+      ts.reset();
+      while (ts.incrementToken()) {
+        if (posIncAtt.getPositionIncrement() > 0) {
+          sb.append(termAtt);
+        }
+      }
+      ts.end();
+      ts.close();
+      return sb.toString();
+    }
+  }
 
   /**
    * Suggest similar words.
@@ -240,7 +275,7 @@
    * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.
    * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.
    *
-   * @param word the word you want a spell check done on
+   * @param surface the word you want a spell check done on
    * @param numSug the number of suggested words
    * @throws IOException if the underlying index throws an {@link IOException}
    * @throws AlreadyClosedException if the Spellchecker is already closed
@@ -248,8 +283,8 @@
    *
    * @see #suggestSimilar(String, int, IndexReader, String, SuggestMode, float) 
    */
-  public String[] suggestSimilar(String word, int numSug) throws IOException {
-    return this.suggestSimilar(word, numSug, null, null, SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX);
+  public String[] suggestSimilar(String surface, int numSug) throws IOException {
+    return this.suggestSimilar(surface, numSug, null, null, SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX);
   }
 
   /**
@@ -263,7 +298,7 @@
    * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.
    * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.
    *
-   * @param word the word you want a spell check done on
+   * @param surface the word you want a spell check done on
    * @param numSug the number of suggested words
    * @param accuracy The minimum score a suggestion must have in order to qualify for inclusion in the results
    * @throws IOException if the underlying index throws an {@link IOException}
@@ -272,18 +307,18 @@
    *
    * @see #suggestSimilar(String, int, IndexReader, String, SuggestMode, float)
    */
-  public String[] suggestSimilar(String word, int numSug, float accuracy) throws IOException {
-    return this.suggestSimilar(word, numSug, null, null, SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX, accuracy);
+  public String[] suggestSimilar(String surface, int numSug, float accuracy) throws IOException {
+    return this.suggestSimilar(surface, numSug, null, null, SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX, accuracy);
   }
 
   /**
    * Calls {@link #suggestSimilar(String, int, IndexReader, String, SuggestMode, float) 
-   *       suggestSimilar(word, numSug, ir, suggestMode, field, this.accuracy)}
+   *       suggestSimilar(surface, numSug, ir, suggestMode, field, this.accuracy)}
    * 
    */
-  public String[] suggestSimilar(String word, int numSug, IndexReader ir,
+  public String[] suggestSimilar(String surface, int numSug, IndexReader ir,
       String field, SuggestMode suggestMode) throws IOException {
-  	return suggestSimilar(word, numSug, ir, field, suggestMode, this.accuracy);
+  	return suggestSimilar(surface, numSug, ir, field, suggestMode, this.accuracy);
   }
   
   /**
@@ -297,7 +332,7 @@
    * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.
    * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.
    *
-   * @param word the word you want a spell check done on
+   * @param surface the word you want a spell check done on
    * @param numSug the number of suggested words
    * @param ir the indexReader of the user index (can be null see field param)
    * @param field the field of the user index: if field is not null, the suggested
@@ -312,8 +347,12 @@
    * of the suggest words in the field of the user index
    * 
    */
-  public String[] suggestSimilar(String word, int numSug, IndexReader ir,
+  public String[] suggestSimilar(String surface, int numSug, IndexReader ir,
       String field, SuggestMode suggestMode, float accuracy) throws IOException {
+    
+    // the analyzed form
+    String word = analyzeWord(surface);
+    
     // obtainSearcher calls ensureOpen
     final IndexSearcher indexSearcher = obtainSearcher();
     try {
@@ -327,11 +366,11 @@
 
       final int lengthWord = word.length();
 
-      final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, word)) : 0;
+      final int freq = (ir != null && field != null) ? ir.docFreq(new Term(field, surface)) : 0;
       final int goalFreq = suggestMode==SuggestMode.SUGGEST_MORE_POPULAR ? freq : 0;
       // if the word exists in the real index and we don't care for word frequency, return the word itself
       if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && freq > 0) {
-        return new String[] { word };
+        return new String[] { surface };
       }
 
       BooleanQuery query = new BooleanQuery();
@@ -363,48 +402,53 @@
 
       int maxHits = 10 * numSug;
 
-  //    System.out.println("Q: " + query);
+      // System.out.println("Q: " + query);
       ScoreDoc[] hits = indexSearcher.search(query, null, maxHits).scoreDocs;
-  //    System.out.println("HITS: " + hits.length());
+      // System.out.println("HITS: " + hits.length);
       SuggestWordQueue sugQueue = new SuggestWordQueue(numSug, comparator);
 
       // go thru more than 'maxr' matches in case the distance filter triggers
       int stop = Math.min(hits.length, maxHits);
-      SuggestWord sugWord = new SuggestWord();
       for (int i = 0; i < stop; i++) {
 
-        sugWord.string = indexSearcher.doc(hits[i].doc).get(F_WORD); // get orig word
+        // nocommit!
+        String suggestedSurface = indexSearcher.doc(hits[i].doc).get(F_WORD); // get orig word
 
         // don't suggest a word for itself, that would be silly
-        if (sugWord.string.equals(word)) {
+        if (suggestedSurface.equals(surface)) {
           continue;
         }
 
-        // edit distance
-        sugWord.score = sd.getDistance(word,sugWord.string);
-        if (sugWord.score < accuracy) {
+        // edit distance: nocommit
+        float score = sd.getDistance(surface, suggestedSurface);
+        if (score < accuracy) {
           continue;
         }
 
+        int suggestedFreq = 0;
         if (ir != null && field != null) { // use the user index
-          sugWord.freq = ir.docFreq(new Term(field, sugWord.string)); // freq in the index
+          suggestedFreq = ir.docFreq(new Term(field, suggestedSurface)); // freq in the index
           // don't suggest a word that is not present in the field
-          if ((suggestMode==SuggestMode.SUGGEST_MORE_POPULAR && goalFreq > sugWord.freq) || sugWord.freq < 1) {
+          if ((suggestMode==SuggestMode.SUGGEST_MORE_POPULAR && goalFreq > suggestedFreq) || suggestedFreq < 1) {
             continue;
           }
         }
-        sugQueue.insertWithOverflow(sugWord);
+        // nocommit
+        SuggestWord suggestion = new SuggestWord(suggestedSurface, suggestedSurface, suggestedFreq);
+        suggestion.setScore(score);
+        sugQueue.insertWithOverflow(suggestion);
         if (sugQueue.size() == numSug) {
           // if queue full, maintain the minScore score
-          accuracy = sugQueue.top().score;
+          accuracy = sugQueue.top().getScore();
         }
-        sugWord = new SuggestWord();
       }
 
-      // convert to array string
+      // convert to array string: 
+      // nocommit: why don't we just return SuggestWord[] with all the information?
+      // consumers such as Solr must be recomputing this stuff again?!
       String[] list = new String[sugQueue.size()];
       for (int i = sugQueue.size() - 1; i >= 0; i--) {
-        list[i] = sugQueue.pop().string;
+        list[i] = sugQueue.pop().getSurface();
       }
 
       return list;
@@ -516,7 +560,8 @@
         
         terms: while ((currentTerm = iter.next()) != null) {
   
-          String word = currentTerm.utf8ToString();
+          String surface = currentTerm.utf8ToString();
+          String word = analyzeWord(surface);
           int len = word.length();
           if (len < 3) {
             continue; // too short we bail but "too long" is fine...
@@ -531,7 +576,7 @@
           }
   
           // ok index the word
-          Document doc = createDocument(word, getMin(len), getMax(len));
+          Document doc = createDocument(surface, word, getMin(len), getMax(len));
           writer.addDocument(doc);
         }
       } finally {
@@ -571,13 +616,13 @@
     return 2;
   }
 
-  private static Document createDocument(String text, int ng1, int ng2) {
+  private static Document createDocument(String surface, String analyzed, int ng1, int ng2) {
     Document doc = new Document();
     // the word field is never queried on... its indexed so it can be quickly
     // checked for rebuild (and stored for retrieval). Doesn't need norms or TF/pos
-    Field f = new Field(F_WORD, text, StringField.TYPE_STORED);
+    Field f = new Field(F_WORD, surface, StringField.TYPE_STORED);
     doc.add(f); // orig term
-    addGram(text, doc, ng1, ng2);
+    addGram(analyzed, doc, ng1, ng2);
     return doc;
   }
 
