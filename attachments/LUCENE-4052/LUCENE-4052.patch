Index: lucene/core/src/java/org/apache/lucene/search/HitIterator.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/HitIterator.java	(revision 1337554)
+++ lucene/core/src/java/org/apache/lucene/search/HitIterator.java	(working copy)
@@ -24,10 +24,8 @@
  * An iterator over {@link Hits} that provides lazy fetching of each document.
  * {@link Hits#iterator()} returns an instance of this class.  Calls to {@link #next()}
  * return a {@link Hit} instance.
- *
- * @deprecated Use {@link TopScoreDocCollector} and {@link TopDocs} instead. Hits will be removed in Lucene 3.0.
  */
-public class HitIterator implements Iterator {
+public class HitIterator implements Iterator<Hit> {
   private Hits hits;
   private int hitNumber = 0;
 
@@ -50,11 +48,11 @@
    *
    * @return Next {@link Hit}.
    */
-  public Object next() {
+  public Hit next() {
     if (hitNumber == hits.length())
       throw new NoSuchElementException();
 
-    Object next = new Hit(hits, hitNumber);
+    Hit next = new Hit(hits, hitNumber);
     hitNumber++;
     return next;
   }

Property changes on: lucene/core/src/java/org/apache/lucene/search/HitIterator.java
___________________________________________________________________
Added: svn:mergeinfo
   Merged /lucene/dev/branches/lucene_solr_3_1/lucene/src/java/org/apache/lucene/search/HitIterator.java:r1096127
   Merged /lucene/dev/trunk/lucene/src/java/org/apache/lucene/search/HitIterator.java:r930932,957707,963372,963781,965103,965299,984187,989785,990161,990281,994979,999223,999842,1034017,1039773,1072567
   Merged /lucene/java/branches/lucene_3_0/src/java/org/apache/lucene/search/HitIterator.java:r963788,965105,984217,988638,990293,995063,999228,1028739,1028779,1028789,1028827,1028873,1028915,1028920,1028931,1029013,1029022,1029024,1029039,1029077,1029138,1029374,1034054,1038096,1039775,1039904,1060786,1063506,1096128
   Merged /lucene/java/trunk/src/java/org/apache/lucene/search/HitIterator.java:r825112,900030,903368,916543,919869
   Merged /lucene/dev/branches/branch_3x/lucene/src/java/org/apache/lucene/search/HitIterator.java:r957490,957920,984210,988629,990167,990286,999226,999847,1034036,1039774,1060782

Index: lucene/core/src/java/org/apache/lucene/search/Hits.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/Hits.java	(revision 1337554)
+++ lucene/core/src/java/org/apache/lucene/search/Hits.java	(working copy)
@@ -18,7 +18,6 @@
  */
 
 import java.io.IOException;
-import java.util.ConcurrentModificationException;
 import java.util.Iterator;
 import java.util.Vector;
 
@@ -30,76 +29,43 @@
  * <b>Caution:</b> Iterate only over the hits needed.  Iterating over all
  * hits is generally not desirable and may be the source of
  * performance issues. If you need to iterate over many or all hits, consider
- * using the search method that takes a {@link HitCollector}.
+ * using the search method that takes a {@link Collector}.
  * </p>
  * <p><b>Note:</b> Deleting matching documents concurrently with traversing 
  * the hits, might, when deleting hits that were not yet retrieved, decrease
  * {@link #length()}. In such case, 
  * {@link java.util.ConcurrentModificationException ConcurrentModificationException}
  * is thrown when accessing hit <code>n</code> &ge; current_{@link #length()} 
- * (but <code>n</code> &lt; {@link #length()}_at_start). 
- * 
- * @deprecated
- * see {@link Searcher#search(Query, int)}, {@link Searcher#search(Query, Filter, int)}
- * and {@link Searcher#search(Query, Filter, int, Sort)}:<br>
- * <pre>
- *   TopDocs topDocs = searcher.search(query, numHits);
- *   ScoreDoc[] hits = topDocs.scoreDocs;
- *   for (int i = 0; i < hits.length; i++) {
- *     int docId = hits[i].doc;
- *     Document d = searcher.doc(docId);
- *     // do something with current hit
- *     ...
- * </pre>
+ * (but <code>n</code> &lt; {@link #length()}_at_start).
  */
 public final class Hits {
   private Weight weight;
-  private Searcher searcher;
-  private Filter filter = null;
+  private IndexSearcher searcher;
   private Sort sort = null;
 
   private int length;				  // the total number of hits
-  private Vector hitDocs = new Vector();	  // cache of hits retrieved
+  private Vector<HitDoc> hitDocs = new Vector<HitDoc>();	  // cache of hits retrieved
 
   private HitDoc first;         // head of LRU cache
   private HitDoc last;          // tail of LRU cache
   private int numDocs = 0;      // number cached
   private int maxDocs = 200;    // max to cache
   
-  private int nDeletions;       // # deleted docs in the index.    
-  private int lengthAtStart;    // this is the number apps usually count on (although deletions can bring it down). 
-  private int nDeletedHits = 0; // # of already collected hits that were meanwhile deleted.
-
-  boolean debugCheckedForDeletions = false; // for test purposes.
-
-  Hits(Searcher s, Query q, Filter f) throws IOException {
-    weight = q.weight(s);
+  public Hits(IndexSearcher s, Query q, Filter f) throws IOException {
+    q = s.wrapFilter(q, f);
+    weight = s.createNormalizedWeight(q);
     searcher = s;
-    filter = f;
-    nDeletions = countDeletions(s);
     getMoreDocs(50); // retrieve 100 initially
-    lengthAtStart = length;
   }
 
-  Hits(Searcher s, Query q, Filter f, Sort o) throws IOException {
-    weight = q.weight(s);
+  public Hits(IndexSearcher s, Query q, Filter f, Sort o) throws IOException {
+    q = s.wrapFilter(q, f);
+    weight = s.createNormalizedWeight(q);
     searcher = s;
-    filter = f;
     sort = o;
-    nDeletions = countDeletions(s);
     getMoreDocs(50); // retrieve 100 initially
-    lengthAtStart = length;
   }
 
-  // count # deletions, return -1 if unknown.
-  private int countDeletions(Searcher s) throws IOException {
-    int cnt = -1;
-    if (s instanceof IndexSearcher) {
-      cnt = s.maxDoc() - ((IndexSearcher) s).getIndexReader().numDocs(); 
-    } 
-    return cnt;
-  }
-
   /**
    * Tries to add new documents to hitDocs.
    * Ensures that the hit numbered <code>min</code> has been retrieved.
@@ -110,7 +76,7 @@
     }
 
     int n = min * 2;	// double # retrieved
-    TopDocs topDocs = (sort == null) ? searcher.search(weight, filter, n) : searcher.search(weight, filter, n, sort);
+    TopDocs topDocs = (sort == null) ? searcher.search(weight, null, n) : searcher.search(weight, n, sort);
     
     length = topDocs.totalHits;
     ScoreDoc[] scoreDocs = topDocs.scoreDocs;
@@ -121,36 +87,12 @@
       scoreNorm = 1.0f / topDocs.getMaxScore();
     }
 
-    int start = hitDocs.size() - nDeletedHits;
-
-    // any new deletions?
-    int nDels2 = countDeletions(searcher);
-    debugCheckedForDeletions = false;
-    if (nDeletions < 0 || nDels2 > nDeletions) { 
-      // either we cannot count deletions, or some "previously valid hits" might have been deleted, so find exact start point
-      nDeletedHits = 0;
-      debugCheckedForDeletions = true;
-      int i2 = 0;
-      for (int i1=0; i1<hitDocs.size() && i2<scoreDocs.length; i1++) {
-        int id1 = ((HitDoc)hitDocs.get(i1)).id;
-        int id2 = scoreDocs[i2].doc;
-        if (id1 == id2) {
-          i2++;
-        } else {
-          nDeletedHits ++;
-        }
-      }
-      start = i2;
-    }
-
+    int start = hitDocs.size();
     int end = scoreDocs.length < length ? scoreDocs.length : length;
-    length += nDeletedHits;
     for (int i = start; i < end; i++) {
       hitDocs.addElement(new HitDoc(scoreDocs[i].score * scoreNorm,
                                     scoreDocs[i].doc));
-    }
-    
-    nDeletions = nDels2;
+    }    
   }
 
   /** Returns the total number of hits available in this set. */
@@ -203,27 +145,23 @@
    * <b>Caution:</b> Iterate only over the hits needed.  Iterating over all
    * hits is generally not desirable and may be the source of
    * performance issues. If you need to iterate over many or all hits, consider
-   * using a search method that takes a {@link HitCollector}.
+   * using a search method that takes a {@link Collector}.
    * </p>
    */
-  public Iterator iterator() {
+  public Iterator<Hit> iterator() {
     return new HitIterator(this);
   }
 
   private final HitDoc hitDoc(int n) throws IOException {
-    if (n >= lengthAtStart) {
+    if (n >= length) {
       throw new IndexOutOfBoundsException("Not a valid hit number: " + n);
     }
 
     if (n >= hitDocs.size()) {
       getMoreDocs(n);
     }
-
-    if (n >= length) {
-      throw new ConcurrentModificationException("Not a valid hit number: " + n);
-    }
     
-    return (HitDoc) hitDocs.elementAt(n);
+    return hitDocs.elementAt(n);
   }
 
   private final void addToFront(HitDoc hitDoc) {  // insert at front of cache

Property changes on: lucene/core/src/java/org/apache/lucene/search/Hits.java
___________________________________________________________________
Added: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/java/org/apache/lucene/search/Hits.java:r963788,965105,984217,988638,990293,995063,999228,1028739,1028779,1028789,1028827,1028873,1028915,1028920,1028931,1029013,1029022,1029024,1029039,1029077,1029138,1029374,1034054,1038096,1039775,1039904,1060786,1063506,1096128
   Merged /lucene/java/trunk/src/java/org/apache/lucene/search/Hits.java:r825112,900030,903368,916543,919869
   Merged /lucene/dev/branches/branch_3x/lucene/src/java/org/apache/lucene/search/Hits.java:r957490,957920,984210,988629,990167,990286,999226,999847,1034036,1039774,1060782
   Merged /lucene/dev/branches/lucene_solr_3_1/lucene/src/java/org/apache/lucene/search/Hits.java:r1096127
   Merged /lucene/dev/trunk/lucene/src/java/org/apache/lucene/search/Hits.java:r930932,957707,963372,963781,965103,965299,984187,989785,990161,990281,994979,999223,999842,1034017,1039773,1072567

Index: lucene/core/src/java/org/apache/lucene/search/Hit.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/Hit.java	(revision 1337554)
+++ lucene/core/src/java/org/apache/lucene/search/Hit.java	(working copy)
@@ -25,10 +25,8 @@
 /**
  * Wrapper used by {@link HitIterator} to provide a lazily loaded hit
  * from {@link Hits}.
- *
- * @deprecated Use {@link TopScoreDocCollector} and {@link TopDocs} instead. Hits will be removed in Lucene 3.0.
  */
-public class Hit implements java.io.Serializable {
+public class Hit {
 
   private Document doc = null;
 
@@ -85,17 +83,6 @@
   // provide some of the Document style interface (the simple stuff)
 
   /**
-   * Returns the boost factor for this hit on any field of the underlying document.
-   *
-   * @see Document#getBoost()
-   * @throws CorruptIndexException if the index is corrupt
-   * @throws IOException if there is a low-level IO error
-   */
-  public float getBoost() throws CorruptIndexException, IOException {
-    return getDocument().getBoost();
-  }
-
-  /**
    * Returns the string value of the field with the given name if any exist in
    * this document, or null.  If multiple fields exist with this name, this
    * method returns the first value added. If only binary fields with this name

Property changes on: lucene/core/src/java/org/apache/lucene/search/Hit.java
___________________________________________________________________
Added: svn:mergeinfo
   Merged /lucene/java/branches/lucene_3_0/src/java/org/apache/lucene/search/Hit.java:r963788,965105,984217,988638,990293,995063,999228,1028739,1028779,1028789,1028827,1028873,1028915,1028920,1028931,1029013,1029022,1029024,1029039,1029077,1029138,1029374,1034054,1038096,1039775,1039904,1060786,1063506,1096128
   Merged /lucene/java/trunk/src/java/org/apache/lucene/search/Hit.java:r825112,900030,903368,916543,919869
   Merged /lucene/dev/branches/branch_3x/lucene/src/java/org/apache/lucene/search/Hit.java:r957490,957920,984210,988629,990167,990286,999226,999847,1034036,1039774,1060782
   Merged /lucene/dev/branches/lucene_solr_3_1/lucene/src/java/org/apache/lucene/search/Hit.java:r1096127
   Merged /lucene/dev/trunk/lucene/src/java/org/apache/lucene/search/Hit.java:r930932,957707,963372,963781,965103,965299,984187,989785,990161,990281,994979,999223,999842,1034017,1039773,1072567

