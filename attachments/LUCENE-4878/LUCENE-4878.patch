Index: lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestMultiFieldQueryParser.java
===================================================================
--- lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestMultiFieldQueryParser.java	(revision 1459903)
+++ lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestMultiFieldQueryParser.java	(working copy)
@@ -28,10 +28,13 @@
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.RegexpQuery;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.IOUtils;
@@ -328,5 +331,15 @@
       return stdAnalyzer.createComponents(fieldName, reader);
     }
   }
+  
+  public void testSimpleRegex() throws ParseException {
+    String[] fields = new String[] {"a", "b"};
+    MultiFieldQueryParser mfqp = new MultiFieldQueryParser(TEST_VERSION_CURRENT, fields, new MockAnalyzer(random()));
 
+    BooleanQuery bq = new BooleanQuery(true);
+    bq.add(new RegexpQuery(new Term("a", "[a-z][123]")), Occur.SHOULD);
+    bq.add(new RegexpQuery(new Term("b", "[a-z][123]")), Occur.SHOULD);
+    assertEquals(bq, mfqp.parse("/[a-z][123]/"));
+  }
+
 }
Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/MultiFieldQueryParser.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/MultiFieldQueryParser.java	(revision 1459903)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/MultiFieldQueryParser.java	(working copy)
@@ -213,7 +213,23 @@
     }
     return super.getRangeQuery(field, part1, part2, startInclusive, endInclusive);
   }
+  
+  
 
+  @Override
+  protected Query getRegexpQuery(String field, String termStr)
+      throws ParseException {
+    if (field == null) {
+      List<BooleanClause> clauses = new ArrayList<BooleanClause>();
+      for (int i = 0; i < fields.length; i++) {
+        clauses.add(new BooleanClause(getRegexpQuery(fields[i], termStr),
+            BooleanClause.Occur.SHOULD));
+      }
+      return getBooleanQuery(clauses, true);
+    }
+    return super.getRegexpQuery(field, termStr);
+  }
+
   /**
    * Parses a query which searches on the fields specified.
    * <p>
Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 1459903)
+++ lucene/CHANGES.txt	(working copy)
@@ -196,6 +196,10 @@
   OpenMode.CREATE_OR_APPEND is used. This might also affect application that set
   the open mode manually using DirectoryReader#indexExists. (Simon Willnauer)
 
+* LUCENE-4878: Override getRegexpQuery in MultiFieldQueryParser to prefent
+  NullPointerException when regular expression syntax is used with
+  MultiFieldQueryParser. (Simon Willnauer, Adam Rauch)
+
 Optimizations
 
 * LUCENE-4819: Added Sorted[Set]DocValues.termsEnum(), and optimized the
