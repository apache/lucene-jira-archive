diff --git a/lucene/core/src/java/org/apache/lucene/search/PrefixQuery.java b/lucene/core/src/java/org/apache/lucene/search/PrefixQuery.java
index f4b5e50..84ae8de 100644
--- a/lucene/core/src/java/org/apache/lucene/search/PrefixQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/PrefixQuery.java
@@ -32,50 +32,51 @@ public class PrefixQuery extends AutomatonQuery {
 
   /** Constructs a query for terms starting with <code>prefix</code>. */
   public PrefixQuery(Term prefix) {
     // It's OK to pass unlimited maxDeterminizedStates: the automaton is born small and determinized:
     super(prefix, toAutomaton(prefix.bytes()), Integer.MAX_VALUE, true);
     if (prefix == null) {
       throw new NullPointerException("prefix must not be null");
     }
   }
 
   /** Build an automaton accepting all terms with the specified prefix. */
   public static Automaton toAutomaton(BytesRef prefix) {
-    Automaton automaton = new Automaton();
+    final int numStatesAndTransitions = prefix.length+1;
+    final Automaton automaton = new Automaton(numStatesAndTransitions, numStatesAndTransitions);
     int lastState = automaton.createState();
     for(int i=0;i<prefix.length;i++) {
       int state = automaton.createState();
       automaton.addTransition(lastState, state, prefix.bytes[prefix.offset+i]&0xff);
       lastState = state;
     }
     automaton.setAccept(lastState, true);
     automaton.addTransition(lastState, lastState, 0, 255);
     automaton.finishState();
     assert automaton.isDeterministic();
     return automaton;
   }
 
   /** Returns the prefix of this query. */
   public Term getPrefix() {
     return term;
   }
   
   /** Prints a user-readable version of this query. */
   @Override
   public String toString(String field) {
     StringBuilder buffer = new StringBuilder();
     if (!getField().equals(field)) {
       buffer.append(getField());
-      buffer.append(":");
+      buffer.append(':');
     }
     buffer.append(term.text());
     buffer.append('*');
     return buffer.toString();
   }
 
   @Override
   public int hashCode() {
     final int prime = 31;
     int result = super.hashCode();
     result = prime * result + term.hashCode();
     return result;
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java b/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java
index 42f28ed..0dd449c 100644
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java
@@ -348,31 +348,31 @@ public class Automaton implements Accountable {
   /** How many transitions this state has. */
   public int getNumTransitions(int state) {
     assert state >= 0;
     int count = states[2*state+1];
     if (count == -1) {
       return 0;
     } else {
       return count;
     }
   }
 
   private void growStates() {
-    if (nextState+2 >= states.length) {
+    if (nextState+2 > states.length) {
       states = ArrayUtil.grow(states, nextState+2);
     }
   }
 
   private void growTransitions() {
-    if (nextTransition+3 >= transitions.length) {
+    if (nextTransition+3 > transitions.length) {
       transitions = ArrayUtil.grow(transitions, nextTransition+3);
     }
   }
 
   /** Sorts transitions by dest, ascending, then min label ascending, then max label ascending */
   private final Sorter destMinMaxSorter = new InPlaceMergeSorter() {
 
       private void swapOne(int i, int j) {
         int x = transitions[i];
         transitions[i] = transitions[j];
         transitions[j] = x;
       }
