Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 1685575)
+++ lucene/CHANGES.txt	(working copy)
@@ -70,6 +70,13 @@
 * LUCENE-6466: Moved SpanQuery.getSpans() and .extractTerms() to SpanWeight
   (Alan Woodward, Robert Muir)
 
+* LUCENE-6371, LUCENE-6490: Payload collection from Spans is moved to a more generic
+  SpanCollector framework.  Spans no longer implements .hasPayload() and
+  .getPayload() methods, and instead exposes a collect() method that allows
+  the collection of arbitrary postings information. SpanPayloadCheckQuery and
+  SpanPayloadNearCheckQuery have moved from the .spans package to the .payloads
+  package. (Alan Woodward, David Smiley, Paul Elschot, Robert Muir)
+
 Bug fixes
 
 * LUCENE-6500: ParallelCompositeReader did not always call
Index: lucene/core/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java	(working copy)
@@ -34,8 +34,6 @@
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
-import org.apache.lucene.search.spans.NearSpansOrdered;
-import org.apache.lucene.search.spans.NearSpansUnordered;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanScorer;
@@ -56,10 +54,11 @@
  * which returns 1 by default.
  * <p>
  * Payload scores are aggregated using a pluggable {@link PayloadFunction}.
- * 
+ *
  * @see org.apache.lucene.search.similarities.Similarity.SimScorer#computePayloadFactor(int, int, int, BytesRef)
  */
 public class PayloadNearQuery extends SpanNearQuery {
+
   protected String fieldName;
   protected PayloadFunction function;
 
@@ -68,7 +67,7 @@
   }
 
   public PayloadNearQuery(SpanQuery[] clauses, int slop, boolean inOrder,
-      PayloadFunction function) {
+                          PayloadFunction function) {
     super(clauses, slop, inOrder);
     this.fieldName = Objects.requireNonNull(clauses[0].getField(), "all clauses must have same non null field");
     this.function = Objects.requireNonNull(function);
@@ -134,7 +133,7 @@
     }
     PayloadNearQuery other = (PayloadNearQuery) obj;
     return fieldName.equals(other.fieldName)
-          && function.equals(other.function);
+        && function.equals(other.function);
   }
 
   public class PayloadNearSpanWeight extends SpanNearWeight {
@@ -146,13 +145,11 @@
 
     @Override
     public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
-      Spans spans = super.getSpans(context, acceptDocs);
+      Spans spans = super.getSpans(context, acceptDocs, Postings.PAYLOADS);
       Similarity.SimScorer simScorer = simWeight == null ? null : similarity.simScorer(simWeight, context);
-      return (spans == null)
-              ? null
-              : new PayloadNearSpanScorer(spans, this, simScorer);
+      return (spans == null) ? null : new PayloadNearSpanScorer(spans, this, simScorer);
     }
-    
+
     @Override
     public Explanation explain(LeafReaderContext context, int doc) throws IOException {
       PayloadNearSpanScorer scorer = (PayloadNearSpanScorer) scorer(context, context.reader().getLiveDocs());
@@ -177,7 +174,7 @@
               expl, payloadExpl);
         }
       }
-      
+
       return Explanation.noMatch("no matching term");
     }
   }
@@ -186,6 +183,7 @@
     Spans spans;
     protected float payloadScore;
     private int payloadsSeen;
+    private final PayloadSpanCollector collector = new PayloadSpanCollector();
 
     protected PayloadNearSpanScorer(Spans spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
       super(spans, weight, docScorer);
@@ -192,25 +190,6 @@
       this.spans = spans;
     }
 
-    // Get the payloads associated with all underlying subspans
-    public void getPayloads(Spans[] subSpans) throws IOException {
-      for (int i = 0; i < subSpans.length; i++) {
-        if (subSpans[i] instanceof NearSpansOrdered) {
-          if (((NearSpansOrdered) subSpans[i]).isPayloadAvailable()) {
-            processPayloads(((NearSpansOrdered) subSpans[i]).getPayload(),
-                subSpans[i].startPosition(), subSpans[i].endPosition());
-          }
-          getPayloads(((NearSpansOrdered) subSpans[i]).getSubSpans());
-        } else if (subSpans[i] instanceof NearSpansUnordered) {
-          if (((NearSpansUnordered) subSpans[i]).isPayloadAvailable()) {
-            processPayloads(((NearSpansUnordered) subSpans[i]).getPayload(),
-                subSpans[i].startPosition(), subSpans[i].endPosition());
-          }
-          getPayloads(((NearSpansUnordered) subSpans[i]).getSubSpans());
-        }
-      }
-    }
-
     // TODO change the whole spans api to use bytesRef, or nuke spans
     BytesRef scratch = new BytesRef();
 
@@ -217,11 +196,11 @@
     /**
      * By default, uses the {@link PayloadFunction} to score the payloads, but
      * can be overridden to do other things.
-     * 
+     *
      * @param payLoads The payloads
      * @param start The start position of the span being scored
      * @param end The end position of the span being scored
-     * 
+     *
      * @see Spans
      */
     protected void processPayloads(Collection<byte[]> payLoads, int start, int end) {
@@ -247,9 +226,9 @@
       do {
         int matchLength = spans.endPosition() - startPos;
         freq += docScorer.computeSlopFactor(matchLength);
-        Spans[] spansArr = new Spans[1];
-        spansArr[0] = spans;
-        getPayloads(spansArr);            
+        collector.reset();
+        spans.collect(collector);
+        processPayloads(collector.getPayloads(), startPos, spans.endPosition());
         startPos = spans.nextStartPosition();
       } while (startPos != Spans.NO_MORE_POSITIONS);
     }
Index: lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanCollector.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanCollector.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanCollector.java	(working copy)
@@ -0,0 +1,57 @@
+package org.apache.lucene.search.payloads;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.spans.SpanCollector;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * SpanCollector for collecting payloads
+ */
+public class PayloadSpanCollector implements SpanCollector {
+
+  private final Collection<byte[]> payloads = new ArrayList<>();
+
+  @Override
+  public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException {
+    BytesRef payload = postings.getPayload();
+    if (payload == null)
+      return;
+    final byte[] bytes = new byte[payload.length];
+    System.arraycopy(payload.bytes, payload.offset, bytes, 0, payload.length);
+    payloads.add(bytes);
+  }
+
+  @Override
+  public void reset() {
+    payloads.clear();
+  }
+
+  /**
+   * @return the collected payloads
+   */
+  public Collection<byte[]> getPayloads() {
+    return payloads;
+  }
+}

Property changes on: lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanCollector.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java	(working copy)
@@ -179,21 +179,22 @@
 
     final IndexSearcher searcher = new IndexSearcher(context);
     searcher.setQueryCache(null);
+
     SpanWeight w = (SpanWeight) searcher.createNormalizedWeight(query, false);
+
+    PayloadSpanCollector collector = new PayloadSpanCollector();
     for (LeafReaderContext leafReaderContext : context.leaves()) {
-      final Spans spans = w.getSpans(leafReaderContext, leafReaderContext.reader().getLiveDocs());
+      final Spans spans = w.getSpans(leafReaderContext, leafReaderContext.reader().getLiveDocs(), SpanWeight.Postings.PAYLOADS);
       if (spans != null) {
         while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
           while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-            if (spans.isPayloadAvailable()) {
-              Collection<byte[]> payload = spans.getPayload();
-              for (byte [] bytes : payload) {
-                payloads.add(bytes);
-              }
-            }
+            collector.reset();
+            spans.collect(collector);
+            payloads.addAll(collector.getPayloads());
           }
         }
       }
     }
   }
+
 }
Index: lucene/core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java	(working copy)
@@ -31,12 +31,12 @@
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
+import org.apache.lucene.search.spans.SpanCollector;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.SpanWeight;
 import org.apache.lucene.search.spans.Spans;
-import org.apache.lucene.search.spans.TermSpans;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 
@@ -74,6 +74,22 @@
     return new PayloadTermWeight(context, searcher, needsScores ? Collections.singletonMap(term, context) : null);
   }
 
+  private static class PayloadTermCollector implements SpanCollector {
+
+    BytesRef payload;
+
+    @Override
+    public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException {
+      payload = postings.getPayload();
+    }
+
+    @Override
+    public void reset() {
+      payload = null;
+    }
+
+  }
+
   private class PayloadTermWeight extends SpanTermWeight {
 
     public PayloadTermWeight(TermContext context, IndexSearcher searcher, Map<Term, TermContext> terms)
@@ -83,11 +99,11 @@
 
     @Override
     public PayloadTermSpanScorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
-      Spans spans = super.getSpans(context, acceptDocs);
+      Spans spans = super.getSpans(context, acceptDocs, Postings.PAYLOADS);
       Similarity.SimScorer simScorer = simWeight == null ? null : similarity.simScorer(simWeight, context);
       return (spans == null)
               ? null
-              : new PayloadTermSpanScorer((TermSpans) spans, this, simScorer);
+              : new PayloadTermSpanScorer(spans, this, simScorer);
     }
 
     protected class PayloadTermSpanScorer extends SpanScorer {
@@ -94,11 +110,10 @@
       protected BytesRef payload;
       protected float payloadScore;
       protected int payloadsSeen;
-      private final TermSpans termSpans;
+      private final PayloadTermCollector payloadCollector = new PayloadTermCollector();
 
-      public PayloadTermSpanScorer(TermSpans spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
+      public PayloadTermSpanScorer(Spans spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
         super(spans, weight, docScorer);
-        termSpans = spans; // CHECKME: generics to use SpansScorer.spans as TermSpans.
       }
 
       @Override
@@ -111,32 +126,26 @@
         assert startPos != Spans.NO_MORE_POSITIONS : "initial startPos NO_MORE_POSITIONS, spans="+spans;
         do {
           int matchLength = spans.endPosition() - startPos;
-
+          if (docScorer == null) {
+            freq = 1;
+            return;
+          }
           freq += docScorer.computeSlopFactor(matchLength);
           numMatches++;
-          processPayload(similarity);
+          payloadCollector.reset();
+          spans.collect(payloadCollector);
+          processPayload();
 
           startPos = spans.nextStartPosition();
         } while (startPos != Spans.NO_MORE_POSITIONS);
       }
 
-      protected void processPayload(Similarity similarity) throws IOException {
-        if (spans.isPayloadAvailable()) {
-          final PostingsEnum postings = termSpans.getPostings();
-          payload = postings.getPayload();
-          if (payload != null) {
-            payloadScore = function.currentScore(docID(), term.field(),
-                                                 spans.startPosition(), spans.endPosition(), payloadsSeen, payloadScore,
-                                                 docScorer.computePayloadFactor(docID(), spans.startPosition(), spans.endPosition(), payload));
-          } else {
-            payloadScore = function.currentScore(docID(), term.field(),
-                                                 spans.startPosition(), spans.endPosition(), payloadsSeen, payloadScore, 1F);
-          }
-          payloadsSeen++;
-
-        } else {
-          // zero out the payload?
-        }
+      protected void processPayload() throws IOException {
+        float payloadFactor = payloadCollector.payload == null ? 1F :
+            docScorer.computePayloadFactor(docID(), spans.startPosition(), spans.endPosition(), payloadCollector.payload);
+        payloadScore = function.currentScore(docID(), term.field(), spans.startPosition(), spans.endPosition(),
+            payloadsSeen, payloadScore, payloadFactor);
+        payloadsSeen++;
       }
 
       /**
Index: lucene/core/src/java/org/apache/lucene/search/payloads/SpanNearPayloadCheckQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/payloads/SpanNearPayloadCheckQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/payloads/SpanNearPayloadCheckQuery.java	(working copy)
@@ -1,4 +1,4 @@
-package org.apache.lucene.search.spans;
+package org.apache.lucene.search.payloads;
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -16,63 +16,30 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
+import java.util.Collection;
+
+import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.util.ToStringUtils;
 
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Objects;
 
-
 /**
  * Only return those matches that have a specific payload at
  * the given position.
+ *
+ * @deprecated Use {@link SpanPayloadCheckQuery}
  */
-public class SpanNearPayloadCheckQuery extends SpanPositionCheckQuery {
-  protected final Collection<byte[]> payloadToMatch;
+@Deprecated
+public class SpanNearPayloadCheckQuery extends SpanPayloadCheckQuery {
 
   /**
-   * @param match          The underlying {@link SpanQuery} to check
+   * @param match          The underlying {@link org.apache.lucene.search.spans.SpanQuery} to check
    * @param payloadToMatch The {@link java.util.Collection} of payloads to match
    */
   public SpanNearPayloadCheckQuery(SpanNearQuery match, Collection<byte[]> payloadToMatch) {
-    super(match);
-    this.payloadToMatch = Objects.requireNonNull(payloadToMatch);
+    super(match, payloadToMatch);
   }
 
   @Override
-  protected AcceptStatus acceptPosition(Spans spans) throws IOException {
-    boolean result = spans.isPayloadAvailable();
-    if (result == true) {
-      Collection<byte[]> candidate = spans.getPayload();
-      if (candidate.size() == payloadToMatch.size()) {
-        //TODO: check the byte arrays are the same
-        //hmm, can't rely on order here
-        int matches = 0;
-        for (byte[] candBytes : candidate) {
-          //Unfortunately, we can't rely on order, so we need to compare all
-          for (byte[] payBytes : payloadToMatch) {
-            if (Arrays.equals(candBytes, payBytes) == true) {
-              matches++;
-              break;
-            }
-          }
-        }
-        if (matches == payloadToMatch.size()){
-          //we've verified all the bytes
-          return AcceptStatus.YES;
-        } else {
-          return AcceptStatus.NO;
-        }
-      } else {
-        return AcceptStatus.NO;
-      }
-    }
-    return AcceptStatus.NO;
-  }
-
-  @Override
   public String toString(String field) {
     StringBuilder buffer = new StringBuilder();
     buffer.append("spanPayCheck(");
Index: lucene/core/src/java/org/apache/lucene/search/payloads/SpanPayloadCheckQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/payloads/SpanPayloadCheckQuery.java	(revision 1685537)
+++ lucene/core/src/java/org/apache/lucene/search/payloads/SpanPayloadCheckQuery.java	(working copy)
@@ -1,4 +1,4 @@
-package org.apache.lucene.search.spans;
+package org.apache.lucene.search.payloads;
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -16,25 +16,38 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
-import org.apache.lucene.util.ToStringUtils;
-
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
 
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.search.spans.FilterSpans;
+import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
+import org.apache.lucene.search.spans.SpanNearQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanScorer;
+import org.apache.lucene.search.spans.SpanWeight;
+import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.ToStringUtils;
 
+
 /**
- * Only return those matches that have a specific payload at
- * the given position.
- * <p>
- * Do not use this with a SpanQuery that contains a {@link org.apache.lucene.search.spans.SpanNearQuery}.
- * Instead, use {@link SpanNearPayloadCheckQuery} since it properly handles the fact that payloads
- * aren't ordered by {@link org.apache.lucene.search.spans.SpanNearQuery}.
+ * Only return those matches that have a specific payload at the given position.
  */
-public class SpanPayloadCheckQuery extends SpanPositionCheckQuery {
+public class SpanPayloadCheckQuery extends SpanQuery {
+
   protected final Collection<byte[]> payloadToMatch;
+  protected final SpanQuery match;
 
   /**
    * @param match The underlying {@link org.apache.lucene.search.spans.SpanQuery} to check
@@ -41,36 +54,138 @@
    * @param payloadToMatch The {@link java.util.Collection} of payloads to match
    */
   public SpanPayloadCheckQuery(SpanQuery match, Collection<byte[]> payloadToMatch) {
-    super(match);
-    if (match instanceof SpanNearQuery){
-      throw new IllegalArgumentException("SpanNearQuery not allowed");
-    }
+    this.match = match;
     this.payloadToMatch = payloadToMatch;
   }
 
   @Override
-  protected AcceptStatus acceptPosition(Spans spans) throws IOException {
-    boolean result = spans.isPayloadAvailable();
-    if (result == true){
-      Collection<byte[]> candidate = spans.getPayload();
-      if (candidate.size() == payloadToMatch.size()){
-        //TODO: check the byte arrays are the same
-        Iterator<byte[]> toMatchIter = payloadToMatch.iterator();
-        //check each of the byte arrays, in order
-        //hmm, can't rely on order here
-        for (byte[] candBytes : candidate) {
-          //if one is a mismatch, then return false
-          if (Arrays.equals(candBytes, toMatchIter.next()) == false){
-            return AcceptStatus.NO;
+  public String getField() {
+    return match.getField();
+  }
+
+  @Override
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    SpanWeight matchWeight = match.createWeight(searcher, false);
+    return new SpanPayloadCheckWeight(searcher, needsScores ? getTermContexts(matchWeight) : null, matchWeight);
+  }
+
+  /**
+   * Weight that pulls its Spans using a PayloadSpanCollector
+   */
+  public class SpanPayloadCheckWeight extends SpanWeight {
+
+    final SpanWeight matchWeight;
+
+    public SpanPayloadCheckWeight(IndexSearcher searcher, Map<Term, TermContext> termContexts, SpanWeight matchWeight) throws IOException {
+      super(SpanPayloadCheckQuery.this, searcher, termContexts);
+      this.matchWeight = matchWeight;
+    }
+
+    @Override
+    public void extractTerms(Set<Term> terms) {
+      matchWeight.extractTerms(terms);
+    }
+
+    @Override
+    public void extractTermContexts(Map<Term, TermContext> contexts) {
+      matchWeight.extractTermContexts(contexts);
+    }
+
+    @Override
+    public Spans getSpans(final LeafReaderContext context, Bits acceptDocs, Postings requiredPostings) throws IOException {
+      final PayloadSpanCollector collector = new PayloadSpanCollector();
+      Spans matchSpans = matchWeight.getSpans(context, acceptDocs, requiredPostings.atLeast(Postings.PAYLOADS));
+      return (matchSpans == null) ? null : new FilterSpans(matchSpans) {
+        @Override
+        protected AcceptStatus accept(Spans candidate) throws IOException {
+
+          collector.reset();
+          candidate.collect(collector);
+          Collection<byte[]> collected = collector.getPayloads();
+
+          if (match instanceof SpanNearQuery) {
+            return checkCompositePayloads(collected);
           }
+          else {
+            return checkOrderedPayloads(collected);
+          }
         }
+      };
+    }
+
+    @Override
+    public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
+      if (field == null)
+        return null;
+
+      Terms terms = context.reader().terms(field);
+      if (terms != null && terms.hasPositions() == false) {
+        throw new IllegalStateException("field \"" + field + "\" was indexed without position data; cannot run SpanQuery (query=" + parentQuery + ")");
+      }
+
+      Spans spans = getSpans(context, acceptDocs, Postings.PAYLOADS);
+      Similarity.SimScorer simScorer = simWeight == null ? null : similarity.simScorer(simWeight, context);
+      return (spans == null) ? null : new SpanScorer(spans, this, simScorer);
+    }
+  }
+
+  /**
+   * Check to see if the collected payloads match the required set.
+   *
+   * This is called for Near span queries which collect their sub spans
+   * out-of-order, meaning that we can't rely on the order of payloads
+   * in the collection
+   *
+   * @param candidate a collection of payloads from the current Spans
+   * @return whether or not the payloads match
+   */
+  protected AcceptStatus checkOrderedPayloads(Collection<byte[]> candidate) {
+    if (candidate.size() == payloadToMatch.size()){
+      //TODO: check the byte arrays are the same
+      Iterator<byte[]> toMatchIter = payloadToMatch.iterator();
+      //check each of the byte arrays, in order
+      //hmm, can't rely on order here
+      for (byte[] candBytes : candidate) {
+        //if one is a mismatch, then return false
+        if (Arrays.equals(candBytes, toMatchIter.next()) == false){
+          return AcceptStatus.NO;
+        }
+      }
+      //we've verified all the bytes
+      return AcceptStatus.YES;
+    } else {
+      return AcceptStatus.NO;
+    }
+  }
+
+  /**
+   * Check to see if the collected payloads match the required set.
+   * @param candidate a collection of payloads from the current Spans
+   * @return whether or not the payloads match
+   */
+  protected AcceptStatus checkCompositePayloads(Collection<byte[]> candidate) {
+    if (candidate.size() == payloadToMatch.size()) {
+      //TODO: check the byte arrays are the same
+      //hmm, can't rely on order here
+      int matches = 0;
+      for (byte[] candBytes : candidate) {
+        //Unfortunately, we can't rely on order, so we need to compare all
+        for (byte[] payBytes : payloadToMatch) {
+          if (Arrays.equals(candBytes, payBytes) == true) {
+            matches++;
+            break;
+          }
+        }
+      }
+      if (matches == payloadToMatch.size()){
         //we've verified all the bytes
         return AcceptStatus.YES;
       } else {
         return AcceptStatus.NO;
       }
+    } else {
+      return AcceptStatus.NO;
     }
-    return AcceptStatus.YES;
   }
 
   @Override
Index: lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java	(working copy)
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.Objects;
 
 abstract class ContainSpans extends ConjunctionSpans {
@@ -49,12 +48,8 @@
   }
 
   @Override
-  public boolean isPayloadAvailable() throws IOException {
-    return sourceSpans.isPayloadAvailable();
+  public void collect(SpanCollector collector) throws IOException {
+    sourceSpans.collect(collector);
   }
 
-  @Override
-  public Collection<byte[]> getPayload() throws IOException {
-    return sourceSpans.getPayload();
-  }
 }
Index: lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java	(working copy)
@@ -17,12 +17,11 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.search.TwoPhaseIterator;
+
 import java.io.IOException;
-import java.util.Collection;
 import java.util.Objects;
 
-import org.apache.lucene.search.TwoPhaseIterator;
-
 /**
  * A {@link Spans} implementation wrapping another spans instance,
  * allowing to filter spans matches easily by implementing {@link #accept}
@@ -110,18 +109,13 @@
     return atFirstInCurrentDoc ? -1
           : (startPos != NO_MORE_POSITIONS) ? in.endPosition() : NO_MORE_POSITIONS;
   }
-  
+
   @Override
-  public final Collection<byte[]> getPayload() throws IOException {
-    return in.getPayload();
+  public void collect(SpanCollector collector) throws IOException {
+    in.collect(collector);
   }
 
   @Override
-  public final boolean isPayloadAvailable() throws IOException {
-    return in.isPayloadAvailable();
-  }
-  
-  @Override
   public final long cost() {
     return in.cost();
   }
Index: lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java	(working copy)
@@ -18,9 +18,7 @@
  */
 
 import java.io.IOException;
-import java.util.ArrayList;
 import java.util.List;
-import java.util.Collection;
 
 /**
  * A Spans that is formed from the ordered subspans of a SpanNearQuery
@@ -131,25 +129,13 @@
   }
 
   @Override
-  public Collection<byte[]> getPayload() throws IOException {
-    List<byte[]> payloads = new ArrayList<>();
+  public void collect(SpanCollector collector) throws IOException {
     for (Spans spans : subSpans) {
-      if (spans.isPayloadAvailable())
-        payloads.addAll(spans.getPayload());
+      spans.collect(collector);
     }
-    return payloads;
   }
 
   @Override
-  public boolean isPayloadAvailable() throws IOException {
-    for (Spans spans : subSpans) {
-      if (spans.isPayloadAvailable())
-        return true;
-    }
-    return false;
-  }
-
-  @Override
   public String toString() {
     return "NearSpansOrdered("+query.toString()+")@"+docID()+": "+startPosition()+" - "+endPosition();
   }
Index: lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(working copy)
@@ -22,10 +22,7 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.List;
-import java.util.Set;
-import java.util.HashSet;
 
 /**
  * Similar to {@link NearSpansOrdered}, but for the unordered case.
@@ -118,16 +115,11 @@
     }
 
     @Override
-    public Collection<byte[]> getPayload() throws IOException {
-      return in.getPayload();
+    public void collect(SpanCollector collector) throws IOException {
+      in.collect(collector);
     }
 
     @Override
-    public boolean isPayloadAvailable() throws IOException {
-      return in.isPayloadAvailable();
-    }
-
-    @Override
     public TwoPhaseIterator asTwoPhaseIterator() {
       return in.asTwoPhaseIterator();
     }
@@ -249,34 +241,14 @@
           : maxEndPositionCell.endPosition();
   }
 
-
-  /**
-   * WARNING: The List is not necessarily in order of the positions.
-   * @return Collection of <code>byte[]</code> payloads
-   * @throws IOException if there is a low-level I/O error
-   */
   @Override
-  public Collection<byte[]> getPayload() throws IOException {
-    Set<byte[]> matchPayload = new HashSet<>();
+  public void collect(SpanCollector collector) throws IOException {
     for (SpansCell cell : subSpanCells) {
-      if (cell.isPayloadAvailable()) {
-        matchPayload.addAll(cell.getPayload());
-      }
+      cell.collect(collector);
     }
-    return matchPayload;
   }
 
   @Override
-  public boolean isPayloadAvailable() throws IOException {
-    for (SpansCell cell : subSpanCells) {
-      if (cell.isPayloadAvailable()) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  @Override
   public String toString() {
     if (minPositionCell() != null) {
       return getClass().getName() + "("+query.toString()+")@"+
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanCollector.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanCollector.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanCollector.java	(working copy)
@@ -0,0 +1,47 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.Term;
+
+/**
+ * An interface defining the collection of postings information from the leaves
+ * of a {@link org.apache.lucene.search.spans.Spans}
+ *
+ * @lucene.experimental
+ */
+public interface SpanCollector {
+
+  /**
+   * Collect information from postings
+   * @param postings a {@link PostingsEnum}
+   * @param position the position of the PostingsEnum
+   * @param term     the {@link Term} for this postings list
+   * @throws IOException on error
+   */
+  public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException;
+
+  /**
+   * Call to indicate that the driving Spans has moved to a new position
+   */
+  public void reset();
+
+}

Property changes on: lucene/core/src/java/org/apache/lucene/search/spans/SpanCollector.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java	(working copy)
@@ -71,12 +71,12 @@
       littleWeight.extractTerms(terms);
     }
 
-    ArrayList<Spans> prepareConjunction(final LeafReaderContext context, final Bits acceptDocs) throws IOException {
-      Spans bigSpans = bigWeight.getSpans(context, acceptDocs);
+    ArrayList<Spans> prepareConjunction(final LeafReaderContext context, final Bits acceptDocs, Postings requiredPostings) throws IOException {
+      Spans bigSpans = bigWeight.getSpans(context, acceptDocs, requiredPostings);
       if (bigSpans == null) {
         return null;
       }
-      Spans littleSpans = littleWeight.getSpans(context, acceptDocs);
+      Spans littleSpans = littleWeight.getSpans(context, acceptDocs, requiredPostings);
       if (littleSpans == null) {
         return null;
       }
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java	(working copy)
@@ -70,8 +70,8 @@
      * The payload is from the spans of <code>big</code>.
      */
     @Override
-    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs) throws IOException {
-      ArrayList<Spans> containerContained = prepareConjunction(context, acceptDocs);
+    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, Postings requiredPostings) throws IOException {
+      ArrayList<Spans> containerContained = prepareConjunction(context, acceptDocs, requiredPostings);
       if (containerContained == null) {
         return null;
       }
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java	(working copy)
@@ -36,7 +36,6 @@
     super(match, 0, end);
   }
 
-  @Override
   protected AcceptStatus acceptPosition(Spans spans) throws IOException {
     assert spans.startPosition() != spans.endPosition() : "start equals end: " + spans.startPosition();
     if (spans.startPosition() >= end)
@@ -47,7 +46,6 @@
       return AcceptStatus.NO;
   }
 
-
   @Override
   public String toString(String field) {
     StringBuilder buffer = new StringBuilder();
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanNearPayloadCheckQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanNearPayloadCheckQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanNearPayloadCheckQuery.java	(working copy)
@@ -1,112 +0,0 @@
-package org.apache.lucene.search.spans;
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
-import org.apache.lucene.util.ToStringUtils;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Objects;
-
-
-/**
- * Only return those matches that have a specific payload at
- * the given position.
- */
-public class SpanNearPayloadCheckQuery extends SpanPositionCheckQuery {
-  protected final Collection<byte[]> payloadToMatch;
-
-  /**
-   * @param match          The underlying {@link SpanQuery} to check
-   * @param payloadToMatch The {@link java.util.Collection} of payloads to match
-   */
-  public SpanNearPayloadCheckQuery(SpanNearQuery match, Collection<byte[]> payloadToMatch) {
-    super(match);
-    this.payloadToMatch = Objects.requireNonNull(payloadToMatch);
-  }
-
-  @Override
-  protected AcceptStatus acceptPosition(Spans spans) throws IOException {
-    boolean result = spans.isPayloadAvailable();
-    if (result == true) {
-      Collection<byte[]> candidate = spans.getPayload();
-      if (candidate.size() == payloadToMatch.size()) {
-        //TODO: check the byte arrays are the same
-        //hmm, can't rely on order here
-        int matches = 0;
-        for (byte[] candBytes : candidate) {
-          //Unfortunately, we can't rely on order, so we need to compare all
-          for (byte[] payBytes : payloadToMatch) {
-            if (Arrays.equals(candBytes, payBytes) == true) {
-              matches++;
-              break;
-            }
-          }
-        }
-        if (matches == payloadToMatch.size()){
-          //we've verified all the bytes
-          return AcceptStatus.YES;
-        } else {
-          return AcceptStatus.NO;
-        }
-      } else {
-        return AcceptStatus.NO;
-      }
-    }
-    return AcceptStatus.NO;
-  }
-
-  @Override
-  public String toString(String field) {
-    StringBuilder buffer = new StringBuilder();
-    buffer.append("spanPayCheck(");
-    buffer.append(match.toString(field));
-    buffer.append(", payloadRef: ");
-    for (byte[] bytes : payloadToMatch) {
-      ToStringUtils.byteArray(buffer, bytes);
-      buffer.append(';');
-    }
-    buffer.append(")");
-    buffer.append(ToStringUtils.boost(getBoost()));
-    return buffer.toString();
-  }
-
-  @Override
-  public SpanNearPayloadCheckQuery clone() {
-    SpanNearPayloadCheckQuery result = new SpanNearPayloadCheckQuery((SpanNearQuery) match.clone(), payloadToMatch);
-    result.setBoost(getBoost());
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (! super.equals(o)) {
-      return false;
-    }
-    SpanNearPayloadCheckQuery other = (SpanNearPayloadCheckQuery) o;
-    return this.payloadToMatch.equals(other.payloadToMatch);
-  }
-
-  @Override
-  public int hashCode() {
-    int h = super.hashCode();
-    h = (h * 15) ^ payloadToMatch.hashCode();
-    return h;
-  }
-}
\ No newline at end of file
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(working copy)
@@ -137,7 +137,7 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Bits acceptDocs) throws IOException {
+    public Spans getSpans(final LeafReaderContext context, Bits acceptDocs, Postings requiredPostings) throws IOException {
 
       Terms terms = context.reader().terms(field);
       if (terms == null) {
@@ -146,7 +146,7 @@
 
       ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());
       for (SpanWeight w : subWeights) {
-        Spans subSpan = w.getSpans(context, acceptDocs);
+        Spans subSpan = w.getSpans(context, acceptDocs, requiredPostings);
         if (subSpan != null) {
           subSpans.add(subSpan);
         } else {
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java	(working copy)
@@ -129,13 +129,13 @@
 
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs) throws IOException {
-      Spans includeSpans = includeWeight.getSpans(context, acceptDocs);
+    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, Postings requiredPostings) throws IOException {
+      Spans includeSpans = includeWeight.getSpans(context, acceptDocs, requiredPostings);
       if (includeSpans == null) {
         return null;
       }
 
-      final Spans excludeSpans = excludeWeight.getSpans(context, acceptDocs);
+      final Spans excludeSpans = excludeWeight.getSpans(context, acceptDocs, requiredPostings);
       if (excludeSpans == null) {
         return includeSpans;
       }
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(working copy)
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -170,13 +169,13 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs)
+    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, Postings requiredPostings)
         throws IOException {
 
       final ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());
 
       for (SpanWeight w : subWeights) {
-        Spans spans = w.getSpans(context, acceptDocs);
+        Spans spans = w.getSpans(context, acceptDocs, requiredPostings);
         if (spans != null) {
           subSpans.add(spans);
         }
@@ -329,20 +328,11 @@
         }
 
         @Override
-        public Collection<byte[]> getPayload() throws IOException {
-          return topPositionSpans == null
-              ? null
-              : topPositionSpans.isPayloadAvailable()
-              ? new ArrayList<>(topPositionSpans.getPayload())
-              : null;
+        public void collect(SpanCollector collector) throws IOException {
+          topPositionSpans.collect(collector);
         }
 
         @Override
-        public boolean isPayloadAvailable() throws IOException {
-          return (topPositionSpans != null) && topPositionSpans.isPayloadAvailable();
-        }
-
-        @Override
         public String toString() {
           return "spanOr("+SpanOrQuery.this+")@"+docID()+": "+startPosition()+" - "+endPosition();
         }
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanPayloadCheckQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanPayloadCheckQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanPayloadCheckQuery.java	(working copy)
@@ -1,113 +0,0 @@
-package org.apache.lucene.search.spans;
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
-import org.apache.lucene.util.ToStringUtils;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Iterator;
-
-
-/**
- * Only return those matches that have a specific payload at
- * the given position.
- * <p>
- * Do not use this with a SpanQuery that contains a {@link org.apache.lucene.search.spans.SpanNearQuery}.
- * Instead, use {@link SpanNearPayloadCheckQuery} since it properly handles the fact that payloads
- * aren't ordered by {@link org.apache.lucene.search.spans.SpanNearQuery}.
- */
-public class SpanPayloadCheckQuery extends SpanPositionCheckQuery {
-  protected final Collection<byte[]> payloadToMatch;
-
-  /**
-   * @param match The underlying {@link org.apache.lucene.search.spans.SpanQuery} to check
-   * @param payloadToMatch The {@link java.util.Collection} of payloads to match
-   */
-  public SpanPayloadCheckQuery(SpanQuery match, Collection<byte[]> payloadToMatch) {
-    super(match);
-    if (match instanceof SpanNearQuery){
-      throw new IllegalArgumentException("SpanNearQuery not allowed");
-    }
-    this.payloadToMatch = payloadToMatch;
-  }
-
-  @Override
-  protected AcceptStatus acceptPosition(Spans spans) throws IOException {
-    boolean result = spans.isPayloadAvailable();
-    if (result == true){
-      Collection<byte[]> candidate = spans.getPayload();
-      if (candidate.size() == payloadToMatch.size()){
-        //TODO: check the byte arrays are the same
-        Iterator<byte[]> toMatchIter = payloadToMatch.iterator();
-        //check each of the byte arrays, in order
-        //hmm, can't rely on order here
-        for (byte[] candBytes : candidate) {
-          //if one is a mismatch, then return false
-          if (Arrays.equals(candBytes, toMatchIter.next()) == false){
-            return AcceptStatus.NO;
-          }
-        }
-        //we've verified all the bytes
-        return AcceptStatus.YES;
-      } else {
-        return AcceptStatus.NO;
-      }
-    }
-    return AcceptStatus.YES;
-  }
-
-  @Override
-  public String toString(String field) {
-    StringBuilder buffer = new StringBuilder();
-    buffer.append("spanPayCheck(");
-    buffer.append(match.toString(field));
-    buffer.append(", payloadRef: ");
-    for (byte[] bytes : payloadToMatch) {
-      ToStringUtils.byteArray(buffer, bytes);
-      buffer.append(';');
-    }
-    buffer.append(")");
-    buffer.append(ToStringUtils.boost(getBoost()));
-    return buffer.toString();
-  }
-
-  @Override
-  public SpanPayloadCheckQuery clone() {
-    SpanPayloadCheckQuery result = new SpanPayloadCheckQuery((SpanQuery) match.clone(), payloadToMatch);
-    result.setBoost(getBoost());
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (! super.equals(o)) {
-      return false;
-    }
-    SpanPayloadCheckQuery other = (SpanPayloadCheckQuery)o;
-    return this.payloadToMatch.equals(other.payloadToMatch);
-  }
-
-  @Override
-  public int hashCode() {
-    int h = super.hashCode();
-    h = (h * 63) ^ payloadToMatch.hashCode();
-    return h;
-  }
-}
\ No newline at end of file
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java	(working copy)
@@ -94,8 +94,8 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Bits acceptDocs) throws IOException {
-      Spans matchSpans = matchWeight.getSpans(context, acceptDocs);
+    public Spans getSpans(final LeafReaderContext context, Bits acceptDocs, Postings requiredPostings) throws IOException {
+      Spans matchSpans = matchWeight.getSpans(context, acceptDocs, requiredPostings);
       return (matchSpans == null) ? null : new FilterSpans(matchSpans) {
         @Override
         protected AcceptStatus accept(Spans candidate) throws IOException {
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java	(working copy)
@@ -38,18 +38,16 @@
     this.end = end;
   }
 
-
   @Override
   protected AcceptStatus acceptPosition(Spans spans) throws IOException {
     assert spans.startPosition() != spans.endPosition();
     AcceptStatus res = (spans.startPosition() >= end)
-                      ? AcceptStatus.NO_MORE_IN_CURRENT_DOC
-                      : (spans.startPosition() >= start && spans.endPosition() <= end)
-                      ? AcceptStatus.YES : AcceptStatus.NO;
+        ? AcceptStatus.NO_MORE_IN_CURRENT_DOC
+        : (spans.startPosition() >= start && spans.endPosition() <= end)
+        ? AcceptStatus.YES : AcceptStatus.NO;
     return res;
   }
 
-
   /**
    * @return The minimum position permitted in a match
    */
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java	(working copy)
@@ -40,7 +40,11 @@
   
   private int lastScoredDoc = -1; // last doc we called setFreqCurrentDoc() for
 
-  protected SpanScorer(Spans spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
+  /**
+   * Creates a new SpanScorer
+   * @lucene.internal
+   */
+  public SpanScorer(Spans spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
     super(weight);
     this.docScorer = docScorer;
     this.spans = Objects.requireNonNull(spans);
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(working copy)
@@ -99,7 +99,7 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Bits acceptDocs) throws IOException {
+    public Spans getSpans(final LeafReaderContext context, Bits acceptDocs, Postings requiredPostings) throws IOException {
 
       assert termContext.topReaderContext == ReaderUtil.getTopLevelContext(context) : "The top-reader used to create Weight (" + termContext.topReaderContext + ") is not the same as the current reader's top-reader (" + ReaderUtil.getTopLevelContext(context);
 
@@ -118,7 +118,7 @@
       final TermsEnum termsEnum = terms.iterator();
       termsEnum.seekExact(term.bytes(), state);
 
-      final PostingsEnum postings = termsEnum.postings(acceptDocs, null, PostingsEnum.PAYLOADS);
+      final PostingsEnum postings = termsEnum.postings(acceptDocs, null, requiredPostings.getRequiredPostings());
       return new TermSpans(postings, term);
     }
   }
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java	(working copy)
@@ -21,6 +21,7 @@
 import java.util.Map;
 
 import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.Terms;
@@ -39,6 +40,39 @@
  */
 public abstract class SpanWeight extends Weight {
 
+  /**
+   * Enumeration defining what postings information should be retrieved from the
+   * index for a given Spans
+   */
+  public enum Postings {
+    POSITIONS {
+      @Override
+      public int getRequiredPostings() {
+        return PostingsEnum.POSITIONS;
+      }
+    },
+    PAYLOADS {
+      @Override
+      public int getRequiredPostings() {
+        return PostingsEnum.PAYLOADS;
+      }
+    },
+    OFFSETS {
+      @Override
+      public int getRequiredPostings() {
+        return PostingsEnum.PAYLOADS | PostingsEnum.OFFSETS;
+      }
+    };
+
+    public abstract int getRequiredPostings();
+
+    public Postings atLeast(Postings postings) {
+      if (postings.compareTo(this) > 0)
+        return postings;
+      return this;
+    }
+  }
+
   protected final Similarity similarity;
   protected final Similarity.SimWeight simWeight;
   protected final String field;
@@ -81,10 +115,11 @@
    * Expert: Return a Spans object iterating over matches from this Weight
    * @param ctx a LeafReaderContext for this Spans
    * @param acceptDocs a bitset of documents to check
+   * @param requiredPostings the postings information required
    * @return a Spans
    * @throws IOException on error
    */
-  public abstract Spans getSpans(LeafReaderContext ctx, Bits acceptDocs) throws IOException;
+  public abstract Spans getSpans(LeafReaderContext ctx, Bits acceptDocs, Postings requiredPostings) throws IOException;
 
   @Override
   public float getValueForNormalization() throws IOException {
@@ -108,7 +143,7 @@
       throw new IllegalStateException("field \"" + field + "\" was indexed without position data; cannot run SpanQuery (query=" + parentQuery + ")");
     }
 
-    Spans spans = getSpans(context, acceptDocs);
+    Spans spans = getSpans(context, acceptDocs, Postings.POSITIONS);
     Similarity.SimScorer simScorer = simWeight == null ? null : similarity.simScorer(simWeight, context);
     return (spans == null) ? null : new SpanScorer(spans, this, simScorer);
   }
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java	(working copy)
@@ -71,8 +71,8 @@
      * The payload is from the spans of <code>little</code>.
      */
     @Override
-    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs) throws IOException {
-      ArrayList<Spans> containerContained = prepareConjunction(context, acceptDocs);
+    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, Postings requiredPostings) throws IOException {
+      ArrayList<Spans> containerContained = prepareConjunction(context, acceptDocs, requiredPostings);
       if (containerContained == null) {
         return null;
       }
Index: lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/Spans.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/Spans.java	(working copy)
@@ -18,7 +18,6 @@
  */
 
 import java.io.IOException;
-import java.util.Collection;
 
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.TwoPhaseIterator;
@@ -51,33 +50,16 @@
   public abstract int endPosition();
 
   /**
-   * Returns the payload data for the current start/end position.
-   * This is only valid after {@link #nextStartPosition()}
-   * returned an available start position.
-   * This method must not be called more than once after each call
-   * of {@link #nextStartPosition()}. However, most payloads are loaded lazily,
-   * so if the payload data for the current position is not needed,
-   * this method may not be called at all for performance reasons.
-   * <br>
-   * Note that the return type is a collection, thus the ordering should not be relied upon.
-   * <br>
-   * @lucene.experimental
+   * Collect postings data from the leaves of the current Spans.
    *
-   * @return a List of byte arrays containing the data of this payload, otherwise null if isPayloadAvailable is false
-   * @throws IOException if there is a low-level I/O error
-   */
-  public abstract Collection<byte[]> getPayload() throws IOException;
-
-  /**
-   * Checks if a payload can be loaded at the current start/end position.
-   * <p>
-   * Payloads can only be loaded once per call to
-   * {@link #nextStartPosition()}.
+   * This method should only be called after {@link #nextStartPosition()}, and before
+   * {@link #NO_MORE_POSITIONS} has been reached.
    *
-   * @return true if there is a payload available at this start/end position
-   *              that can be loaded
+   * @param collector a SpanCollector
+   *
+   * @lucene.experimental
    */
-  public abstract boolean isPayloadAvailable() throws IOException;
+  public abstract void collect(SpanCollector collector) throws IOException;
 
   /**
    * Optional method: Return a {@link TwoPhaseIterator} view of this
Index: lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java	(revision 1685575)
+++ lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java	(working copy)
@@ -16,14 +16,11 @@
  */
 
 
+import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.util.BytesRef;
 
 import java.io.IOException;
-import java.util.Collections;
-import java.util.Collection;
 import java.util.Objects;
 
 /**
@@ -110,25 +107,11 @@
   }
 
   @Override
-  public Collection<byte[]> getPayload() throws IOException {
-    final BytesRef payload = postings.getPayload();
-    readPayload = true;
-    final byte[] bytes;
-    if (payload != null) {
-      bytes = new byte[payload.length];
-      System.arraycopy(payload.bytes, payload.offset, bytes, 0, payload.length);
-    } else {
-      bytes = null;
-    }
-    return Collections.singletonList(bytes);
+  public void collect(SpanCollector collector) throws IOException {
+    collector.collectLeaf(postings, position, term);
   }
 
   @Override
-  public boolean isPayloadAvailable() throws IOException {
-    return readPayload == false && postings.getPayload() != null;
-  }
-
-  @Override
   public String toString() {
     return "spans(" + term.toString() + ")@" +
             (doc == -1 ? "START" : (doc == NO_MORE_DOCS) ? "ENDDOC"
Index: lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java	(revision 1685575)
+++ lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java	(working copy)
@@ -22,29 +22,33 @@
 import java.nio.charset.StandardCharsets;
 import java.util.Collection;
 
-import org.apache.lucene.analysis.*;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockPayloadAnalyzer;
+import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.PostingsEnum;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.SlowCompositeReaderWrapper;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.store.Directory;
+import org.apache.lucene.search.payloads.PayloadSpanCollector;
 import org.apache.lucene.search.payloads.PayloadSpanUtil;
 import org.apache.lucene.search.spans.MultiSpansWrapper;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.spans.SpanWeight;
 import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.BytesRef;
 
 /**
  * Term position unit test.
@@ -238,7 +242,8 @@
     if (VERBOSE) {
       System.out.println("\ngetPayloadSpans test");
     }
-    Spans pspans = MultiSpansWrapper.wrap(is.getIndexReader(), snq);
+    PayloadSpanCollector collector = new PayloadSpanCollector();
+    Spans pspans = MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
     while (pspans.nextDoc() != Spans.NO_MORE_DOCS) {
       while (pspans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
         if (VERBOSE) {
@@ -245,7 +250,9 @@
           System.out.println("doc " + pspans.docID() + ": span " + pspans.startPosition()
               + " to " + pspans.endPosition());
         }
-        Collection<byte[]> payloads = pspans.getPayload();
+        collector.reset();
+        pspans.collect(collector);
+        Collection<byte[]> payloads = collector.getPayloads();
         sawZero |= pspans.startPosition() == 0;
         for (byte[] bytes : payloads) {
           count++;
@@ -256,7 +263,7 @@
       }
     }
     assertTrue(sawZero);
-    assertEquals(5, count);
+    assertEquals(8, count);
 
     // System.out.println("\ngetSpans test");
     Spans spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq);
@@ -282,7 +289,7 @@
       //System.out.println(s);
       sawZero |= s.equals("pos: 0");
     }
-    assertEquals(5, count);
+    assertEquals(8, count);
     assertTrue(sawZero);
     writer.close();
     is.getIndexReader().close();
Index: lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadBasics.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadBasics.java	(revision 1685575)
+++ lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadBasics.java	(working copy)
@@ -36,9 +36,7 @@
 import org.apache.lucene.search.CheckHits;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanNearPayloadCheckQuery;
 import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanPayloadCheckQuery;
 import org.apache.lucene.search.spans.SpanPositionRangeQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
Index: lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadNearQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadNearQuery.java	(revision 1685575)
+++ lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadNearQuery.java	(working copy)
@@ -15,9 +15,14 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 import java.io.IOException;
 
-import org.apache.lucene.analysis.*;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
@@ -27,14 +32,14 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.CollectionStatistics;
 import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.QueryUtils;
 import org.apache.lucene.search.ScoreDoc;
-import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.TermStatistics;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
@@ -43,7 +48,6 @@
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
-
 public class TestPayloadNearQuery extends LuceneTestCase {
   private static IndexSearcher searcher;
   private static IndexReader reader;
Index: lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java	(revision 1685575)
+++ lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java	(working copy)
@@ -28,20 +28,18 @@
 import org.apache.lucene.analysis.TokenFilter;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.payloads.PayloadHelper;
-import org.apache.lucene.search.payloads.PayloadSpanUtil;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.spans.MultiSpansWrapper;
@@ -50,6 +48,7 @@
 import org.apache.lucene.search.spans.SpanNotQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.spans.SpanWeight;
 import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
@@ -74,14 +73,15 @@
     SpanTermQuery stq;
     Spans spans;
     stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "seventy"));
-    spans = MultiSpansWrapper.wrap(indexReader, stq);
+    PayloadSpanCollector collector = new PayloadSpanCollector();
+    spans = MultiSpansWrapper.wrap(indexReader, stq, SpanWeight.Postings.PAYLOADS);
     assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 100, 1, 1, 1);
+    checkSpans(spans, collector, 100, 1, 1, 1);
 
     stq = new SpanTermQuery(new Term(PayloadHelper.NO_PAYLOAD_FIELD, "seventy"));  
-    spans = MultiSpansWrapper.wrap(indexReader, stq);
+    spans = MultiSpansWrapper.wrap(indexReader, stq, SpanWeight.Postings.PAYLOADS);
     assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 100, 0, 0, 0);
+    checkSpans(spans, collector, 100, 0, 0, 0);
   }
 
   public void testSpanFirst() throws IOException {
@@ -90,8 +90,9 @@
     SpanFirstQuery sfq;
     match = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
     sfq = new SpanFirstQuery(match, 2);
-    Spans spans = MultiSpansWrapper.wrap(indexReader, sfq);
-    checkSpans(spans, 109, 1, 1, 1);
+    PayloadSpanCollector collector = new PayloadSpanCollector();
+    Spans spans = MultiSpansWrapper.wrap(indexReader, sfq, SpanWeight.Postings.PAYLOADS);
+    checkSpans(spans, collector, 109, 1, 1, 1);
     //Test more complicated subclause
     SpanQuery[] clauses = new SpanQuery[2];
     clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
@@ -98,11 +99,11 @@
     clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "hundred"));
     match = new SpanNearQuery(clauses, 0, true);
     sfq = new SpanFirstQuery(match, 2);
-    checkSpans(MultiSpansWrapper.wrap(indexReader, sfq), 100, 2, 1, 1);
+    checkSpans(MultiSpansWrapper.wrap(indexReader, sfq, SpanWeight.Postings.PAYLOADS), collector, 100, 2, 1, 1);
 
     match = new SpanNearQuery(clauses, 0, false);
     sfq = new SpanFirstQuery(match, 2);
-    checkSpans(MultiSpansWrapper.wrap(indexReader, sfq), 100, 2, 1, 1);
+    checkSpans(MultiSpansWrapper.wrap(indexReader, sfq, SpanWeight.Postings.PAYLOADS), collector, 100, 2, 1, 1);
     
   }
   
@@ -124,9 +125,9 @@
     writer.addDocument(doc);
     IndexReader reader = writer.getReader();
     writer.close();
-    
 
-    checkSpans(MultiSpansWrapper.wrap(reader, snq), 1,new int[]{2});
+    PayloadSpanCollector collector = new PayloadSpanCollector();
+    checkSpans(MultiSpansWrapper.wrap(reader, snq, SpanWeight.Postings.PAYLOADS), collector, 1, new int[]{2});
     reader.close();
     directory.close();
   }
@@ -135,8 +136,10 @@
     SpanTermQuery stq;
     Spans spans;
     IndexSearcher searcher = getSearcher();
+    PayloadSpanCollector collector = new PayloadSpanCollector();
+
     stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "mark"));
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), stq);
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), stq, SpanWeight.Postings.PAYLOADS);
     assertNull(spans);
 
     SpanQuery[] clauses = new SpanQuery[3];
@@ -145,9 +148,9 @@
     clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
     SpanNearQuery spanNearQuery = new SpanNearQuery(clauses, 12, false);
 
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), spanNearQuery);
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), spanNearQuery, SpanWeight.Postings.PAYLOADS);
     assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 2, new int[]{3,3});
+    checkSpans(spans, collector, 2, new int[]{3,3});
 
      
     clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
@@ -156,10 +159,10 @@
 
     spanNearQuery = new SpanNearQuery(clauses, 6, true);
    
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), spanNearQuery);
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), spanNearQuery, SpanWeight.Postings.PAYLOADS);
 
     assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 1, new int[]{3});
+    checkSpans(spans, collector, 1, new int[]{3});
      
     clauses = new SpanQuery[2];
      
@@ -178,10 +181,9 @@
     SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses2, 6, false);
     
     // yy within 6 of xx within 6 of rr
-
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery);
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery, SpanWeight.Postings.PAYLOADS);
     assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 2, new int[]{3,3});
+    checkSpans(spans, collector, 2, new int[]{3,3});
     closeIndexReader.close();
     directory.close();
   }
@@ -208,12 +210,13 @@
      
     clauses3[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "np"));
     clauses3[1] = snq;
-     
+
+    PayloadSpanCollector collector = new PayloadSpanCollector();
     SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses3, 6, false);
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery);
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery, SpanWeight.Postings.PAYLOADS);
 
     assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 1, new int[]{3});
+    checkSpans(spans, collector, 1, new int[]{3});
     closeIndexReader.close();
     directory.close();
   }
@@ -248,9 +251,10 @@
      
     SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses3, 6, false);
 
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery);
+    PayloadSpanCollector collector = new PayloadSpanCollector();
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery, SpanWeight.Postings.PAYLOADS);
     assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 2, new int[]{8, 8});
+    checkSpans(spans, collector, 2, new int[]{8, 8});
     closeIndexReader.close();
     directory.close();
   }
@@ -272,7 +276,8 @@
     SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 1, true);
-    Spans spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq);
+    PayloadSpanCollector collector = new PayloadSpanCollector();
+    Spans spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
@@ -279,8 +284,9 @@
     for (int i = 0; i < topDocs.scoreDocs.length; i++) {
       while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
         while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-          Collection<byte[]> payloads = spans.getPayload();
-  
+          collector.reset();
+          spans.collect(collector);
+          Collection<byte[]> payloads = collector.getPayloads();
           for (final byte [] payload : payloads) {
             payloadSet.add(new String(payload, StandardCharsets.UTF_8));
           }
@@ -310,7 +316,8 @@
     SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
-    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq);
+    PayloadSpanCollector collector = new PayloadSpanCollector();
+    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
@@ -317,7 +324,9 @@
     for (int i = 0; i < topDocs.scoreDocs.length; i++) {
       while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
         while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-          Collection<byte[]> payloads = spans.getPayload();
+          collector.reset();
+          spans.collect(collector);
+          Collection<byte[]> payloads = collector.getPayloads();
   
           for (final byte [] payload : payloads) {
             payloadSet.add(new String(payload, StandardCharsets.UTF_8));
@@ -348,7 +357,8 @@
     SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
-    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq);
+    PayloadSpanCollector collector = new PayloadSpanCollector();
+    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
@@ -355,7 +365,9 @@
     for (int i = 0; i < topDocs.scoreDocs.length; i++) {
       while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
         while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-          Collection<byte[]> payloads = spans.getPayload();
+          collector.reset();
+          spans.collect(collector);
+          Collection<byte[]> payloads = collector.getPayloads();
   
           for (final byte [] payload : payloads) {
             payloadSet.add(new String(payload, StandardCharsets.UTF_8));
@@ -401,7 +413,7 @@
     directory.close();
   }
 
-  private void checkSpans(Spans spans, int expectedNumSpans, int expectedNumPayloads,
+  private void checkSpans(Spans spans, PayloadSpanCollector collector, int expectedNumSpans, int expectedNumPayloads,
                           int expectedPayloadLength, int expectedFirstByte) throws IOException {
     assertTrue("spans is null and it shouldn't be", spans != null);
     //each position match should have a span associated with it, since there is just one underlying term query, there should
@@ -409,16 +421,16 @@
     int seen = 0;
     while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
       while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-        assertEquals("isPayloadAvailable should return true/false as payloads are expected", expectedNumPayloads > 0, spans.isPayloadAvailable());
-        //See payload helper, for the PayloadHelper.FIELD field, there is a single byte payload at every token
-        if (spans.isPayloadAvailable()) {
-          Collection<byte[]> payload = spans.getPayload();
-          assertEquals("payload size", expectedNumPayloads, payload.size());
-          for (final byte [] thePayload : payload) {
-            assertEquals("payload length", expectedPayloadLength, thePayload.length);
-            assertEquals("payload first byte", expectedFirstByte, thePayload[0]);
-          }
+        collector.reset();
+        spans.collect(collector);
+
+        Collection<byte[]> payload = collector.getPayloads();
+        assertEquals("payload size", expectedNumPayloads, payload.size());
+        for (final byte [] thePayload : payload) {
+          assertEquals("payload length", expectedPayloadLength, thePayload.length);
+          assertEquals("payload first byte", expectedFirstByte, thePayload[0]);
         }
+
         seen++;
       }
     }
@@ -446,7 +458,7 @@
     return searcher;
   }
   
-  private void checkSpans(Spans spans, int numSpans, int[] numPayloads) throws IOException {
+  private void checkSpans(Spans spans, PayloadSpanCollector collector, int numSpans, int[] numPayloads) throws IOException {
     int cnt = 0;
 
     while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
@@ -453,19 +465,19 @@
       while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
         if(VERBOSE)
           System.out.println("\nSpans Dump --");
-        if (spans.isPayloadAvailable()) {
-          Collection<byte[]> payload = spans.getPayload();
-          if(VERBOSE) {
-            System.out.println("payloads for span:" + payload.size());
-            for (final byte [] bytes : payload) {
-              System.out.println("doc:" + spans.docID() + " s:" + spans.startPosition() + " e:" + spans.endPosition() + " "
+        collector.reset();
+        spans.collect(collector);
+
+        Collection<byte[]> payload = collector.getPayloads();
+        if(VERBOSE) {
+          System.out.println("payloads for span:" + payload.size());
+          for (final byte [] bytes : payload) {
+            System.out.println("doc:" + spans.docID() + " s:" + spans.startPosition() + " e:" + spans.endPosition() + " "
                 + new String(bytes, StandardCharsets.UTF_8));
-            }
           }
-          assertEquals("payload size", numPayloads[cnt], payload.size());
-        } else { // no payload available
-          assertFalse("Expected spans:" + numPayloads[cnt] + " found: 0", numPayloads.length > 0 && numPayloads[cnt] > 0 );
         }
+        assertEquals("payload size", numPayloads[cnt], payload.size());
+
         cnt++;
       }
     }
Index: lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java	(revision 1685575)
+++ lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java	(working copy)
@@ -18,7 +18,6 @@
  */
 
 import java.io.IOException;
-import java.util.Collection;
 
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.similarities.Similarity;
@@ -60,19 +59,14 @@
     public int endPosition() {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
-    
+
     @Override
-    public int nextStartPosition() throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
+    public void collect(SpanCollector collector) throws IOException {
 
-    @Override
-    public Collection<byte[]> getPayload() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
 
     @Override
-    public boolean isPayloadAvailable() {
+    public int nextStartPosition() throws IOException {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
 
@@ -127,19 +121,14 @@
     public int endPosition() {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
-    
+
     @Override
-    public int nextStartPosition() throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
+    public void collect(SpanCollector collector) throws IOException {
 
-    @Override
-    public Collection<byte[]> getPayload() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
 
     @Override
-    public boolean isPayloadAvailable() {
+    public int nextStartPosition() throws IOException {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
 
Index: lucene/core/src/test/org/apache/lucene/search/spans/MultiSpansWrapper.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/MultiSpansWrapper.java	(revision 1685575)
+++ lucene/core/src/test/org/apache/lucene/search/spans/MultiSpansWrapper.java	(working copy)
@@ -27,7 +27,7 @@
 import org.apache.lucene.util.Bits;
 
 /**
- * 
+ *
  * A wrapper to perform span operations on a non-leaf reader context
  * <p>
  * NOTE: This should be used for testing purposes only
@@ -36,14 +36,18 @@
 public class MultiSpansWrapper {
 
   public static Spans wrap(IndexReader reader, SpanQuery spanQuery) throws IOException {
+    return wrap(reader, spanQuery, SpanWeight.Postings.POSITIONS);
+  }
 
+  public static Spans wrap(IndexReader reader, SpanQuery spanQuery, SpanWeight.Postings requiredPostings) throws IOException {
+
     LeafReader lr = SlowCompositeReaderWrapper.wrap(reader); // slow, but ok for testing
     LeafReaderContext lrContext = lr.getContext();
     IndexSearcher searcher = new IndexSearcher(lr);
     searcher.setQueryCache(null);
 
-    SpanWeight w = (SpanWeight) searcher.createNormalizedWeight(spanQuery, false);
+    SpanWeight w = spanQuery.createWeight(searcher, false);
 
-    return w.getSpans(lrContext, new Bits.MatchAllBits(lr.numDocs()));
+    return w.getSpans(lrContext, new Bits.MatchAllBits(lr.numDocs()), requiredPostings);
   }
 }
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java	(working copy)
@@ -0,0 +1,181 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.FieldType;
+import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.IndexOptions;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.NoMergePolicy;
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
+
+public class TestSpanCollection extends LuceneTestCase {
+
+  protected IndexSearcher searcher;
+  protected Directory directory;
+  protected IndexReader reader;
+
+  public static final String FIELD = "field";
+
+  public static FieldType OFFSETS = new FieldType(TextField.TYPE_STORED);
+  static {
+    OFFSETS.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    reader.close();
+    directory.close();
+    super.tearDown();
+  }
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(NoMergePolicy.INSTANCE));
+    for (int i = 0; i < docFields.length; i++) {
+      Document doc = new Document();
+      doc.add(newField(FIELD, docFields[i], OFFSETS));
+      writer.addDocument(doc);
+    }
+    reader = writer.getReader();
+    writer.close();
+    searcher = newSearcher(reader);
+  }
+
+  private static class TermCollector implements SpanCollector {
+
+    final Set<Term> terms = new HashSet<>();
+
+    @Override
+    public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException {
+      terms.add(term);
+    }
+
+    @Override
+    public void reset() {
+      terms.clear();
+    }
+
+  }
+
+  protected String[] docFields = {
+      "w1 w2 w3 w4 w5",
+      "w1 w3 w2 w3 zz",
+      "w1 xx w2 yy w4",
+      "w1 w2 w1 w4 w2 w3"
+  };
+
+  private void checkCollectedTerms(Spans spans, TermCollector collector, Term... expectedTerms) throws IOException {
+    collector.reset();
+    spans.collect(collector);
+    for (Term t : expectedTerms) {
+      assertTrue("Missing term " + t, collector.terms.contains(t));
+    }
+    assertEquals("Unexpected terms found", expectedTerms.length, collector.terms.size());
+  }
+
+  @Test
+  public void testNestedNearQuery() throws IOException {
+
+    // near(w1, near(w2, or(w3, w4)))
+
+    SpanTermQuery q1 = new SpanTermQuery(new Term(FIELD, "w1"));
+    SpanTermQuery q2 = new SpanTermQuery(new Term(FIELD, "w2"));
+    SpanTermQuery q3 = new SpanTermQuery(new Term(FIELD, "w3"));
+    SpanTermQuery q4 = new SpanTermQuery(new Term(FIELD, "w4"));
+
+    SpanOrQuery q5 = new SpanOrQuery(q4, q3);
+    SpanNearQuery q6 = new SpanNearQuery(new SpanQuery[]{q2, q5}, 1, true);
+    SpanNearQuery q7 = new SpanNearQuery(new SpanQuery[]{q1, q6}, 1, true);
+
+    TermCollector collector = new TermCollector();
+    Spans spans = MultiSpansWrapper.wrap(reader, q7, SpanWeight.Postings.POSITIONS);
+    assertEquals(0, spans.advance(0));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"));
+
+    assertEquals(3, spans.advance(3));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w4"));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"));
+
+  }
+
+  @Test
+  public void testOrQuery() throws IOException {
+    SpanTermQuery q2 = new SpanTermQuery(new Term(FIELD, "w2"));
+    SpanTermQuery q3 = new SpanTermQuery(new Term(FIELD, "w3"));
+    SpanOrQuery orQuery = new SpanOrQuery(q2, q3);
+
+    TermCollector collector = new TermCollector();
+    Spans spans = MultiSpansWrapper.wrap(reader, orQuery, SpanWeight.Postings.POSITIONS);
+
+    assertEquals(1, spans.advance(1));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w3"));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w2"));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w3"));
+
+    assertEquals(3, spans.advance(3));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w2"));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w2"));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w3"));
+  }
+
+  @Test
+  public void testSpanNotQuery() throws IOException {
+
+    SpanTermQuery q1 = new SpanTermQuery(new Term(FIELD, "w1"));
+    SpanTermQuery q2 = new SpanTermQuery(new Term(FIELD, "w2"));
+    SpanTermQuery q3 = new SpanTermQuery(new Term(FIELD, "w3"));
+
+    SpanNearQuery nq = new SpanNearQuery(new SpanQuery[]{q1, q2}, 2, true);
+    SpanNotQuery notq = new SpanNotQuery(nq, q3);
+
+    TermCollector collector = new TermCollector();
+    Spans spans = MultiSpansWrapper.wrap(reader, notq, SpanWeight.Postings.POSITIONS);
+
+    assertEquals(2, spans.advance(2));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"));
+
+  }
+
+}
+

Property changes on: lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java	(revision 1685575)
+++ lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java	(working copy)
@@ -303,7 +303,7 @@
       LeafReaderContext context = getLeafContext();
       SpanWeight w = (SpanWeight) searcher.createNormalizedWeight(q, false);
       Bits acceptDocs = context.reader().getLiveDocs();
-      final Spans spans = w.getSpans(context, acceptDocs);
+      final Spans spans = w.getSpans(context, acceptDocs, SpanWeight.Postings.POSITIONS);
       if (spans == null) {
         return;
       }
Index: lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
===================================================================
--- lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java	(revision 1685575)
+++ lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java	(working copy)
@@ -17,6 +17,20 @@
  * limitations under the License.
  */
 
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.StringTokenizer;
+
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.BaseTokenStreamTestCase;
 import org.apache.lucene.analysis.CachingTokenFilter;
@@ -39,11 +53,10 @@
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
-import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queries.CommonTermsQuery;
-import org.apache.lucene.queries.CustomScoreProvider;
 import org.apache.lucene.queries.CustomScoreQuery;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
@@ -68,11 +81,11 @@
 import org.apache.lucene.search.join.ScoreMode;
 import org.apache.lucene.search.join.ToChildBlockJoinQuery;
 import org.apache.lucene.search.join.ToParentBlockJoinQuery;
+import org.apache.lucene.search.payloads.SpanPayloadCheckQuery;
 import org.apache.lucene.search.spans.SpanMultiTermQueryWrapper;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanNotQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanPayloadCheckQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
@@ -84,20 +97,6 @@
 import org.w3c.dom.Element;
 import org.w3c.dom.NodeList;
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.StringTokenizer;
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-
 /**
  * JUnit Test for Highlighter class.
  *
Index: lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java	(revision 1685575)
+++ lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java	(working copy)
@@ -17,6 +17,10 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.Map;
+import java.util.Set;
+
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
@@ -25,10 +29,6 @@
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.util.Bits;
 
-import java.io.IOException;
-import java.util.Map;
-import java.util.Set;
-
 /**
  * Wraps a SpanWeight with additional asserts
  */
@@ -52,8 +52,8 @@
   }
 
   @Override
-  public Spans getSpans(LeafReaderContext context, Bits liveDocs) throws IOException {
-    Spans spans = in.getSpans(context, liveDocs);
+  public Spans getSpans(LeafReaderContext context, Bits liveDocs, Postings requiredPostings) throws IOException {
+    Spans spans = in.getSpans(context, liveDocs, requiredPostings);
     if (spans == null)
       return null;
     return new AssertingSpans(spans);
Index: lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java	(revision 1685575)
+++ lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java	(working copy)
@@ -17,13 +17,11 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.Collection;
-
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.TwoPhaseIterator;
-import org.apache.lucene.search.spans.Spans;
 
+import java.io.IOException;
+
 /** 
  * Wraps a Spans with additional asserts 
  */
@@ -125,20 +123,14 @@
     checkCurrentPositions();
     return in.endPosition();
   }
-  
+
   @Override
-  public Collection<byte[]> getPayload() throws IOException {
-    assert state == State.ITERATING : "getPayload() called in illegal state: " + state + ": " + in;
-    return in.getPayload();
+  public void collect(SpanCollector collector) throws IOException {
+    assert state == State.ITERATING : "collect() called in illegal state: " + state + ": " + in;
+    in.collect(collector);
   }
-  
+
   @Override
-  public boolean isPayloadAvailable() throws IOException {
-    assert state == State.ITERATING : "isPayloadAvailable() called in illegal state: " + state + ": " + in;
-    return in.isPayloadAvailable();
-  }
-  
-  @Override
   public int docID() {
     int doc = in.docID();
     assert doc == this.doc : "broken docID() impl: docID() = " + doc + ", but next/advance last returned: " + this.doc + ": " + in;
Index: solr/core/src/test/org/apache/solr/highlight/HighlighterTest.java
===================================================================
--- solr/core/src/test/org/apache/solr/highlight/HighlighterTest.java	(revision 1685575)
+++ solr/core/src/test/org/apache/solr/highlight/HighlighterTest.java	(working copy)
@@ -28,7 +28,7 @@
 import org.apache.lucene.analysis.core.WhitespaceAnalyzer;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanPayloadCheckQuery;
+import org.apache.lucene.search.payloads.SpanPayloadCheckQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.params.HighlightParams;
