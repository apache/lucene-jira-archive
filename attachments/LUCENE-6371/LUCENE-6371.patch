Index: core/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java	(working copy)
@@ -26,7 +26,6 @@
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
-import org.apache.lucene.search.spans.SpanCollectorFactory;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanScorer;
@@ -75,10 +74,10 @@
   }
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, SpanCollectorFactory factory) throws IOException {
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     List<SpanWeight> subWeights = new ArrayList<>();
     for (SpanQuery q : clauses) {
-      subWeights.add(q.createWeight(searcher, false, PayloadSpanCollector.FACTORY));
+      subWeights.add(q.createWeight(searcher, false));
     }
     return new PayloadNearSpanWeight(subWeights, searcher, needsScores ? getTermContexts(subWeights) : null);
   }
@@ -141,17 +140,14 @@
 
     public PayloadNearSpanWeight(List<SpanWeight> subWeights, IndexSearcher searcher, Map<Term, TermContext> terms)
         throws IOException {
-      super(subWeights, searcher, terms, PayloadSpanCollector.FACTORY);
+      super(subWeights, searcher, terms);
     }
 
     @Override
     public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
-      PayloadSpanCollector collector = (PayloadSpanCollector) collectorFactory.newCollector();
-      Spans spans = super.getSpans(context, acceptDocs, collector);
+      Spans spans = super.getSpans(context, acceptDocs, Postings.PAYLOADS);
       Similarity.SimScorer simScorer = simWeight == null ? null : similarity.simScorer(simWeight, context);
-      return (spans == null)
-              ? null
-              : new PayloadNearSpanScorer(spans, this, collector, simScorer);
+      return (spans == null) ? null : new PayloadNearSpanScorer(spans, this, simScorer);
     }
     
     @Override
@@ -187,13 +183,11 @@
     Spans spans;
     protected float payloadScore;
     private int payloadsSeen;
-    private final PayloadSpanCollector collector;
+    private final PayloadSpanCollector collector = new PayloadSpanCollector();
 
-    protected PayloadNearSpanScorer(Spans spans, SpanWeight weight, PayloadSpanCollector collector,
-                                    Similarity.SimScorer docScorer) throws IOException {
+    protected PayloadNearSpanScorer(Spans spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
       super(spans, weight, docScorer);
       this.spans = spans;
-      this.collector = collector;
     }
 
     // TODO change the whole spans api to use bytesRef, or nuke spans
Index: core/src/java/org/apache/lucene/search/payloads/PayloadSpanCollector.java
===================================================================
--- core/src/java/org/apache/lucene/search/payloads/PayloadSpanCollector.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/payloads/PayloadSpanCollector.java	(working copy)
@@ -19,10 +19,7 @@
 
 import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.spans.BufferedSpanCollector;
 import org.apache.lucene.search.spans.SpanCollector;
-import org.apache.lucene.search.spans.SpanCollectorFactory;
-import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.util.BytesRef;
 
 import java.io.IOException;
@@ -30,36 +27,14 @@
 import java.util.Collection;
 
 /**
- * SpanCollector implementation that collects payloads from a {@link Spans}
+ * SpanCollector for collecting payloads
  */
 public class PayloadSpanCollector implements SpanCollector {
 
-  public static final SpanCollectorFactory FACTORY = new SpanCollectorFactory() {
-    @Override
-    public PayloadSpanCollector newCollector() {
-      return new PayloadSpanCollector();
-    }
-  };
-
   private final Collection<byte[]> payloads = new ArrayList<>();
-  BufferedPayloadCollector bufferedCollector;
 
-  public Collection<byte[]> getPayloads() {
-    return payloads;
-  }
-
   @Override
-  public void reset() {
-    payloads.clear();
-  }
-
-  @Override
-  public int requiredPostings() {
-    return PostingsEnum.PAYLOADS;
-  }
-
-  @Override
-  public void collectLeaf(PostingsEnum postings, Term term) throws IOException {
+  public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException {
     BytesRef payload = postings.getPayload();
     if (payload == null)
       return;
@@ -69,43 +44,14 @@
   }
 
   @Override
-  public BufferedSpanCollector buffer() {
-    if (bufferedCollector == null)
-      bufferedCollector = new BufferedPayloadCollector();
-    bufferedCollector.reset();
-    return bufferedCollector;
+  public void reset() {
+    payloads.clear();
   }
 
-  @Override
-  public SpanCollector bufferedCollector() {
-    if (bufferedCollector == null)
-      bufferedCollector = new BufferedPayloadCollector();
-    return bufferedCollector.candidateCollector;
+  /**
+   * @return the collected payloads
+   */
+  public Collection<byte[]> getPayloads() {
+    return payloads;
   }
-
-  class BufferedPayloadCollector implements BufferedSpanCollector {
-
-    final Collection<byte[]> buffer = new ArrayList<>();
-    PayloadSpanCollector candidateCollector = new PayloadSpanCollector();
-
-    void reset() {
-      buffer.clear();
-    }
-
-    @Override
-    public void collectCandidate(Spans spans) throws IOException {
-      candidateCollector.reset();
-      spans.collect(candidateCollector);
-    }
-
-    @Override
-    public void accept() {
-      buffer.addAll(candidateCollector.payloads);
-    }
-
-    @Override
-    public void replay() {
-      payloads.addAll(buffer);
-    }
-  }
 }
Index: core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
===================================================================
--- core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java	(working copy)
@@ -184,7 +184,7 @@
 
     PayloadSpanCollector collector = new PayloadSpanCollector();
     for (LeafReaderContext leafReaderContext : context.leaves()) {
-      final Spans spans = w.getSpans(leafReaderContext, leafReaderContext.reader().getLiveDocs(), collector);
+      final Spans spans = w.getSpans(leafReaderContext, leafReaderContext.reader().getLiveDocs(), SpanWeight.Postings.PAYLOADS);
       if (spans != null) {
         while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
           while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
Index: core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java	(working copy)
@@ -26,7 +26,6 @@
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
-import org.apache.lucene.search.spans.BufferedSpanCollector;
 import org.apache.lucene.search.spans.SpanCollector;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanScorer;
@@ -80,29 +79,15 @@
     BytesRef payload;
 
     @Override
-    public void reset() {
-      payload = null;
-    }
-
-    @Override
-    public int requiredPostings() {
-      return PostingsEnum.PAYLOADS;
-    }
-
-    @Override
-    public void collectLeaf(PostingsEnum postings, Term term) throws IOException {
+    public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException {
       payload = postings.getPayload();
     }
 
     @Override
-    public BufferedSpanCollector buffer() {
-      throw new UnsupportedOperationException();
+    public void reset() {
+      payload = null;
     }
 
-    @Override
-    public SpanCollector bufferedCollector() {
-      throw new UnsupportedOperationException();
-    }
   }
 
   private class PayloadTermWeight extends SpanTermWeight {
@@ -109,17 +94,14 @@
 
     public PayloadTermWeight(TermContext context, IndexSearcher searcher, Map<Term, TermContext> terms)
         throws IOException {
-      super(context, searcher, terms, PayloadSpanCollector.FACTORY);
+      super(context, searcher, terms);
     }
 
     @Override
     public PayloadTermSpanScorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
-      PayloadTermCollector collector = new PayloadTermCollector();
-      Spans spans = super.getSpans(context, acceptDocs, collector);
+      Spans spans = super.getSpans(context, acceptDocs, Postings.PAYLOADS);
       Similarity.SimScorer simScorer = simWeight == null ? null : similarity.simScorer(simWeight, context);
-      return (spans == null)
-              ? null
-              : new PayloadTermSpanScorer(spans, this, collector, simScorer);
+      return (spans == null) ? null : new PayloadTermSpanScorer(spans, this, simScorer);
     }
 
     protected class PayloadTermSpanScorer extends SpanScorer {
@@ -126,12 +108,10 @@
       protected BytesRef payload;
       protected float payloadScore;
       protected int payloadsSeen;
-      private final PayloadTermCollector payloadCollector;
+      private final PayloadTermCollector payloadCollector = new PayloadTermCollector();
 
-      public PayloadTermSpanScorer(Spans spans, SpanWeight weight, PayloadTermCollector collector,
-                                   Similarity.SimScorer docScorer) throws IOException {
+      public PayloadTermSpanScorer(Spans spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
         super(spans, weight, docScorer);
-        this.payloadCollector = collector;
       }
 
       @Override
@@ -144,7 +124,10 @@
         assert startPos != Spans.NO_MORE_POSITIONS : "initial startPos NO_MORE_POSITIONS, spans="+spans;
         do {
           int matchLength = spans.endPosition() - startPos;
-
+          if (docScorer == null) {
+            freq = 1;
+            return;
+          }
           freq += docScorer.computeSlopFactor(matchLength);
           numMatches++;
           payloadCollector.reset();
@@ -156,13 +139,11 @@
       }
 
       protected void processPayload() throws IOException {
-
         float payloadFactor = payloadCollector.payload == null ? 1F :
             docScorer.computePayloadFactor(docID(), spans.startPosition(), spans.endPosition(), payloadCollector.payload);
         payloadScore = function.currentScore(docID(), term.field(), spans.startPosition(), spans.endPosition(),
-                                             payloadsSeen, payloadScore, payloadFactor);
+            payloadsSeen, payloadScore, payloadFactor);
         payloadsSeen++;
-
       }
 
       /**
Index: core/src/java/org/apache/lucene/search/payloads/SpanNearPayloadCheckQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/payloads/SpanNearPayloadCheckQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/payloads/SpanNearPayloadCheckQuery.java	(working copy)
@@ -16,78 +16,30 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
-import org.apache.lucene.search.spans.SpanCollector;
 import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanPositionCheckQuery;
-import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.util.ToStringUtils;
 
-import java.io.IOException;
-import java.util.Arrays;
 import java.util.Collection;
-import java.util.Objects;
 
 
 /**
  * Only return those matches that have a specific payload at
  * the given position.
+ *
+ * @deprecated Use {@link SpanPayloadCheckQuery}
  */
-public class SpanNearPayloadCheckQuery extends SpanPositionCheckQuery {
+@Deprecated
+public class SpanNearPayloadCheckQuery extends SpanPayloadCheckQuery {
 
-  protected final Collection<byte[]> payloadToMatch;
-
   /**
    * @param match          The underlying {@link org.apache.lucene.search.spans.SpanQuery} to check
    * @param payloadToMatch The {@link java.util.Collection} of payloads to match
    */
   public SpanNearPayloadCheckQuery(SpanNearQuery match, Collection<byte[]> payloadToMatch) {
-    super(match);
-    this.payloadToMatch = Objects.requireNonNull(payloadToMatch);
+    super(match, payloadToMatch);
   }
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    return createWeight(searcher, needsScores, PayloadSpanCollector.FACTORY);
-  }
-
-  @Override
-  protected AcceptStatus acceptPosition(Spans spans, SpanCollector collector) throws IOException {
-
-    PayloadSpanCollector payloadCollector = (PayloadSpanCollector) collector;
-
-    payloadCollector.reset();
-    spans.collect(payloadCollector);
-
-    Collection<byte[]> candidate = payloadCollector.getPayloads();
-    if (candidate.size() == payloadToMatch.size()) {
-      //TODO: check the byte arrays are the same
-      //hmm, can't rely on order here
-      int matches = 0;
-      for (byte[] candBytes : candidate) {
-        //Unfortunately, we can't rely on order, so we need to compare all
-        for (byte[] payBytes : payloadToMatch) {
-          if (Arrays.equals(candBytes, payBytes) == true) {
-            matches++;
-            break;
-          }
-        }
-      }
-      if (matches == payloadToMatch.size()){
-        //we've verified all the bytes
-        return AcceptStatus.YES;
-      } else {
-        return AcceptStatus.NO;
-      }
-    } else {
-      return AcceptStatus.NO;
-    }
-
-  }
-
-  @Override
   public String toString(String field) {
     StringBuilder buffer = new StringBuilder();
     buffer.append("spanPayCheck(");
Index: core/src/java/org/apache/lucene/search/payloads/SpanPayloadCheckQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/payloads/SpanPayloadCheckQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/payloads/SpanPayloadCheckQuery.java	(working copy)
@@ -16,14 +16,21 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.search.spans.FilterSpans;
 import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
-import org.apache.lucene.search.spans.SpanCollector;
 import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanPositionCheckQuery;
 import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanWeight;
 import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.ToStringUtils;
 
 import java.io.IOException;
@@ -30,19 +37,17 @@
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
 
 
 /**
- * Only return those matches that have a specific payload at
- * the given position.
- * <p>
- * Do not use this with a SpanQuery that contains a {@link org.apache.lucene.search.spans.SpanNearQuery}.
- * Instead, use {@link org.apache.lucene.search.payloads.SpanNearPayloadCheckQuery} since it properly handles the fact that payloads
- * aren't ordered by {@link org.apache.lucene.search.spans.SpanNearQuery}.
+ * Only return those matches that have a specific payload at the given position.
  */
-public class SpanPayloadCheckQuery extends SpanPositionCheckQuery {
+public class SpanPayloadCheckQuery extends SpanQuery {
 
   protected final Collection<byte[]> payloadToMatch;
+  protected final SpanQuery match;
 
   /**
    * @param match The underlying {@link org.apache.lucene.search.spans.SpanQuery} to check
@@ -49,27 +54,92 @@
    * @param payloadToMatch The {@link java.util.Collection} of payloads to match
    */
   public SpanPayloadCheckQuery(SpanQuery match, Collection<byte[]> payloadToMatch) {
-    super(match);
-    if (match instanceof SpanNearQuery){
-      throw new IllegalArgumentException("SpanNearQuery not allowed");
-    }
+    this.match = match;
     this.payloadToMatch = payloadToMatch;
   }
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    return super.createWeight(searcher, needsScores, PayloadSpanCollector.FACTORY);
+  public String getField() {
+    return match.getField();
   }
 
   @Override
-  protected AcceptStatus acceptPosition(Spans spans, SpanCollector collector) throws IOException {
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    SpanWeight matchWeight = match.createWeight(searcher, false);
+    return new SpanPayloadCheckWeight(searcher, needsScores ? getTermContexts(matchWeight) : null, matchWeight);
+  }
 
-    PayloadSpanCollector payloadCollector = (PayloadSpanCollector) collector;
+  /**
+   * Weight that pulls its Spans using a PayloadSpanCollector
+   */
+  public class SpanPayloadCheckWeight extends SpanWeight {
 
-    payloadCollector.reset();
-    spans.collect(payloadCollector);
+    final SpanWeight matchWeight;
 
-    Collection<byte[]> candidate = payloadCollector.getPayloads();
+    public SpanPayloadCheckWeight(IndexSearcher searcher, Map<Term, TermContext> termContexts, SpanWeight matchWeight) throws IOException {
+      super(SpanPayloadCheckQuery.this, searcher, termContexts);
+      this.matchWeight = matchWeight;
+    }
+
+    @Override
+    public void extractTerms(Set<Term> terms) {
+      matchWeight.extractTerms(terms);
+    }
+
+    @Override
+    public void extractTermContexts(Map<Term, TermContext> contexts) {
+      matchWeight.extractTermContexts(contexts);
+    }
+
+    @Override
+    public Spans getSpans(final LeafReaderContext context, Bits acceptDocs, Postings requiredPostings) throws IOException {
+      final PayloadSpanCollector collector = new PayloadSpanCollector();
+      Spans matchSpans = matchWeight.getSpans(context, acceptDocs, requiredPostings.atLeast(Postings.PAYLOADS));
+      return (matchSpans == null) ? null : new FilterSpans(matchSpans) {
+        @Override
+        protected AcceptStatus accept(Spans candidate) throws IOException {
+
+          collector.reset();
+          candidate.collect(collector);
+          Collection<byte[]> collected = collector.getPayloads();
+
+          if (match instanceof SpanNearQuery) {
+            return checkCompositePayloads(collected);
+          }
+          else {
+            return checkOrderedPayloads(collected);
+          }
+        }
+      };
+    }
+
+    @Override
+    public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
+      if (field == null)
+        return null;
+
+      Terms terms = context.reader().terms(field);
+      if (terms != null && terms.hasPositions() == false) {
+        throw new IllegalStateException("field \"" + field + "\" was indexed without position data; cannot run SpanQuery (query=" + parentQuery + ")");
+      }
+
+      Spans spans = getSpans(context, acceptDocs, Postings.PAYLOADS);
+      Similarity.SimScorer simScorer = simWeight == null ? null : similarity.simScorer(simWeight, context);
+      return (spans == null) ? null : new SpanScorer(spans, this, simScorer);
+    }
+  }
+
+  /**
+   * Check to see if the collected payloads match the required set.
+   *
+   * This is called for Near span queries which collect their sub spans
+   * out-of-order, meaning that we can't rely on the order of payloads
+   * in the collection
+   *
+   * @param candidate a collection of payloads from the current Spans
+   * @return whether or not the payloads match
+   */
+  protected AcceptStatus checkOrderedPayloads(Collection<byte[]> candidate) {
     if (candidate.size() == payloadToMatch.size()){
       //TODO: check the byte arrays are the same
       Iterator<byte[]> toMatchIter = payloadToMatch.iterator();
@@ -86,7 +156,36 @@
     } else {
       return AcceptStatus.NO;
     }
+  }
 
+  /**
+   * Check to see if the collected payloads match the required set.
+   * @param candidate a collection of payloads from the current Spans
+   * @return whether or not the payloads match
+   */
+  protected AcceptStatus checkCompositePayloads(Collection<byte[]> candidate) {
+    if (candidate.size() == payloadToMatch.size()) {
+      //TODO: check the byte arrays are the same
+      //hmm, can't rely on order here
+      int matches = 0;
+      for (byte[] candBytes : candidate) {
+        //Unfortunately, we can't rely on order, so we need to compare all
+        for (byte[] payBytes : payloadToMatch) {
+          if (Arrays.equals(candBytes, payBytes) == true) {
+            matches++;
+            break;
+          }
+        }
+      }
+      if (matches == payloadToMatch.size()){
+        //we've verified all the bytes
+        return AcceptStatus.YES;
+      } else {
+        return AcceptStatus.NO;
+      }
+    } else {
+      return AcceptStatus.NO;
+    }
   }
 
   @Override
Index: core/src/java/org/apache/lucene/search/spans/BufferedSpanCollector.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/BufferedSpanCollector.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/BufferedSpanCollector.java	(working copy)
@@ -1,67 +0,0 @@
-package org.apache.lucene.search.spans;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-/**
- * Defines span collection for eager Span implementations, such as
- * {@link org.apache.lucene.search.spans.NearSpansOrdered}
- *
- * @lucene.experimental
- */
-public interface BufferedSpanCollector {
-
-  /**
-   * Collect information from a possible candidate
-   * @param spans the candidate Spans
-   * @throws IOException on error
-   */
-  public void collectCandidate(Spans spans) throws IOException;
-
-  /**
-   * Confirm that the last candidate Spans has been accepted by the parent algorithm
-   */
-  public void accept();
-
-  /**
-   * Replay buffered information back to the parent SpanCollector
-   */
-  public void replay();
-
-  /**
-   * A default No-op BufferedSpanCollector
-   */
-  public static final BufferedSpanCollector NO_OP = new BufferedSpanCollector() {
-    @Override
-    public void collectCandidate(Spans spans) throws IOException {
-
-    }
-
-    @Override
-    public void accept() {
-
-    }
-
-    @Override
-    public void replay() {
-
-    }
-  };
-
-}
Index: core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java	(working copy)
@@ -90,8 +90,8 @@
   // ...this is done to be more consistent with things like SpanFirstQuery
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, SpanCollectorFactory factory) throws IOException {
-    return maskedQuery.createWeight(searcher, needsScores, factory);
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    return maskedQuery.createWeight(searcher, needsScores);
   }
 
   @Override
Index: core/src/java/org/apache/lucene/search/spans/SpanCollector.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanCollector.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanCollector.java	(working copy)
@@ -27,7 +27,7 @@
  * of a {@link org.apache.lucene.search.spans.Spans}
  *
  * Typical use would be as follows:
- * <pre>
+ * <pre class="prettyprint">
  *   while (spans.nextStartPosition() != NO_MORE_POSITIONS) {
  *     spanCollector.reset();
  *     spans.collect(spanCollector);
@@ -40,71 +40,17 @@
 public interface SpanCollector {
 
   /**
-   * Called to indicate that the driving {@link org.apache.lucene.search.spans.Spans} has
-   * been moved to a new position
-   */
-  public void reset();
-
-  /**
-   * Returns an integer indicating what postings information should be retrieved
-   *
-   * See {@link org.apache.lucene.index.TermsEnum#postings(org.apache.lucene.util.Bits, org.apache.lucene.index.PostingsEnum, int)}
-   *
-   * @return the postings flag
-   */
-  public int requiredPostings();
-
-  /**
    * Collect information from postings
    * @param postings a {@link PostingsEnum}
+   * @param position the position of the PostingsEnum
    * @param term     the {@link Term} for this postings list
    * @throws IOException on error
    */
-  public void collectLeaf(PostingsEnum postings, Term term) throws IOException;
+  public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException;
 
   /**
-   * Return a {@link BufferedSpanCollector} for use by eager spans implementations, such
-   * as {@link NearSpansOrdered}.
-   *
-   * @return a BufferedSpanCollector
+   * Indicates that the driving Spans has moved to a new position
    */
-  public BufferedSpanCollector buffer();
+  public void reset();
 
-  /**
-   * @return the SpanCollector used by the {@link org.apache.lucene.search.spans.BufferedSpanCollector}
-   *          returned from {@link #buffer()}.
-   */
-  public SpanCollector bufferedCollector();
-
-  /**
-   * A default No-op implementation of SpanCollector
-   */
-  public static final SpanCollector NO_OP = new SpanCollector() {
-
-    @Override
-    public void reset() {
-
-    }
-
-    @Override
-    public int requiredPostings() {
-      return PostingsEnum.POSITIONS;
-    }
-
-    @Override
-    public void collectLeaf(PostingsEnum postings, Term term) {
-
-    }
-
-    @Override
-    public BufferedSpanCollector buffer() {
-      return BufferedSpanCollector.NO_OP;
-    }
-
-    @Override
-    public SpanCollector bufferedCollector() {
-      return this;
-    }
-  };
-
 }
Index: core/src/java/org/apache/lucene/search/spans/SpanCollectorFactory.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanCollectorFactory.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanCollectorFactory.java	(working copy)
@@ -1,40 +0,0 @@
-package org.apache.lucene.search.spans;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Interface defining a factory for creating new {@link SpanCollector}s
- */
-public interface SpanCollectorFactory {
-
-  /**
-   * @return a new SpanCollector
-   */
-  SpanCollector newCollector();
-
-  /**
-   * Factory for creating NO_OP collectors
-   */
-  public static final SpanCollectorFactory NO_OP_FACTORY = new SpanCollectorFactory() {
-    @Override
-    public SpanCollector newCollector() {
-      return SpanCollector.NO_OP;
-    }
-  };
-
-}
Index: core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java	(working copy)
@@ -55,9 +55,9 @@
     final SpanWeight bigWeight;
     final SpanWeight littleWeight;
 
-    public SpanContainWeight(IndexSearcher searcher, Map<Term, TermContext> terms, SpanCollectorFactory factory,
+    public SpanContainWeight(IndexSearcher searcher, Map<Term, TermContext> terms,
                              SpanWeight bigWeight, SpanWeight littleWeight) throws IOException {
-      super(SpanContainQuery.this, searcher, terms, factory);
+      super(SpanContainQuery.this, searcher, terms);
       this.bigWeight = bigWeight;
       this.littleWeight = littleWeight;
     }
@@ -71,12 +71,12 @@
       littleWeight.extractTerms(terms);
     }
 
-    ArrayList<Spans> prepareConjunction(final LeafReaderContext context, final Bits acceptDocs, SpanCollector collector) throws IOException {
-      Spans bigSpans = bigWeight.getSpans(context, acceptDocs, collector);
+    ArrayList<Spans> prepareConjunction(final LeafReaderContext context, final Bits acceptDocs, Postings postings) throws IOException {
+      Spans bigSpans = bigWeight.getSpans(context, acceptDocs, postings);
       if (bigSpans == null) {
         return null;
       }
-      Spans littleSpans = littleWeight.getSpans(context, acceptDocs, collector);
+      Spans littleSpans = littleWeight.getSpans(context, acceptDocs, postings);
       if (littleSpans == null) {
         return null;
       }
Index: core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java	(working copy)
@@ -51,18 +51,18 @@
   }
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, SpanCollectorFactory factory) throws IOException {
-    SpanWeight bigWeight = big.createWeight(searcher, false, factory);
-    SpanWeight littleWeight = little.createWeight(searcher, false, factory);
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    SpanWeight bigWeight = big.createWeight(searcher, false);
+    SpanWeight littleWeight = little.createWeight(searcher, false);
     return new SpanContainingWeight(searcher, needsScores ? getTermContexts(bigWeight, littleWeight) : null,
-                                      factory, bigWeight, littleWeight);
+                                      bigWeight, littleWeight);
   }
 
   public class SpanContainingWeight extends SpanContainWeight {
 
-    public SpanContainingWeight(IndexSearcher searcher, Map<Term, TermContext> terms, SpanCollectorFactory factory,
+    public SpanContainingWeight(IndexSearcher searcher, Map<Term, TermContext> terms,
                                 SpanWeight bigWeight, SpanWeight littleWeight) throws IOException {
-      super(searcher, terms, factory, bigWeight, littleWeight);
+      super(searcher, terms, bigWeight, littleWeight);
     }
 
     /**
@@ -70,8 +70,8 @@
      * The payload is from the spans of <code>big</code>.
      */
     @Override
-    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, SpanCollector collector) throws IOException {
-      ArrayList<Spans> containerContained = prepareConjunction(context, acceptDocs, collector);
+    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, Postings requiredPostings) throws IOException {
+      ArrayList<Spans> containerContained = prepareConjunction(context, acceptDocs, requiredPostings);
       if (containerContained == null) {
         return null;
       }
Index: core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java	(working copy)
@@ -36,8 +36,7 @@
     super(match, 0, end);
   }
 
-  @Override
-  protected AcceptStatus acceptPosition(Spans spans, SpanCollector collector) throws IOException {
+  protected AcceptStatus acceptPosition(Spans spans) throws IOException {
     assert spans.startPosition() != spans.endPosition() : "start equals end: " + spans.startPosition();
     if (spans.startPosition() >= end)
       return AcceptStatus.NO_MORE_IN_CURRENT_DOC;
@@ -47,7 +46,6 @@
       return AcceptStatus.NO;
   }
 
-
   @Override
   public String toString(String field) {
     StringBuilder buffer = new StringBuilder();
Index: core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java	(working copy)
@@ -96,7 +96,7 @@
   }
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, SpanCollectorFactory factory) throws IOException {
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     throw new IllegalArgumentException("Rewrite first!");
   }
 
Index: core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(revision 1684600)
+++ core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(working copy)
@@ -112,12 +112,12 @@
   }
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, SpanCollectorFactory factory) throws IOException {
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     List<SpanWeight> subWeights = new ArrayList<>();
     for (SpanQuery q : clauses) {
-      subWeights.add(q.createWeight(searcher, false, factory));
+      subWeights.add(q.createWeight(searcher, false));
     }
-    return new SpanNearWeight(subWeights, searcher, needsScores ? getTermContexts(subWeights) : null, factory);
+    return new SpanNearWeight(subWeights, searcher, needsScores ? getTermContexts(subWeights) : null);
   }
 
   public class SpanNearWeight extends SpanWeight {
@@ -124,8 +124,8 @@
 
     final List<SpanWeight> subWeights;
 
-    public SpanNearWeight(List<SpanWeight> subWeights, IndexSearcher searcher, Map<Term, TermContext> terms, SpanCollectorFactory factory) throws IOException {
-      super(SpanNearQuery.this, searcher, terms, factory);
+    public SpanNearWeight(List<SpanWeight> subWeights, IndexSearcher searcher, Map<Term, TermContext> terms) throws IOException {
+      super(SpanNearQuery.this, searcher, terms);
       this.subWeights = subWeights;
     }
 
@@ -137,7 +137,7 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Bits acceptDocs, SpanCollector collector) throws IOException {
+    public Spans getSpans(final LeafReaderContext context, Bits acceptDocs, Postings requiredPostings) throws IOException {
 
       Terms terms = context.reader().terms(field);
       if (terms == null) {
@@ -145,9 +145,8 @@
       }
 
       ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());
-      SpanCollector subSpanCollector = inOrder ? collector.bufferedCollector() : collector;
       for (SpanWeight w : subWeights) {
-        Spans subSpan = w.getSpans(context, acceptDocs, subSpanCollector);
+        Spans subSpan = w.getSpans(context, acceptDocs, requiredPostings);
         if (subSpan != null) {
           subSpans.add(subSpan);
         } else {
Index: core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java	(working copy)
@@ -17,8 +17,8 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.DocIdSetIterator;
@@ -30,8 +30,8 @@
 
 import java.io.IOException;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
-import java.util.Objects;
 
 /** Removes matches which overlap with another SpanQuery or which are
  * within x tokens before or y tokens after another SpanQuery.
@@ -103,11 +103,11 @@
   }
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, SpanCollectorFactory factory) throws IOException {
-    SpanWeight includeWeight = include.createWeight(searcher, false, factory);
-    SpanWeight excludeWeight = exclude.createWeight(searcher, false, factory);
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    SpanWeight includeWeight = include.createWeight(searcher, false);
+    SpanWeight excludeWeight = exclude.createWeight(searcher, false);
     return new SpanNotWeight(searcher, needsScores ? getTermContexts(includeWeight, excludeWeight) : null,
-                                  factory, includeWeight, excludeWeight);
+                                  includeWeight, excludeWeight);
   }
 
   public class SpanNotWeight extends SpanWeight {
@@ -115,9 +115,9 @@
     final SpanWeight includeWeight;
     final SpanWeight excludeWeight;
 
-    public SpanNotWeight(IndexSearcher searcher, Map<Term, TermContext> terms, SpanCollectorFactory factory,
+    public SpanNotWeight(IndexSearcher searcher, Map<Term, TermContext> terms,
                          SpanWeight includeWeight, SpanWeight excludeWeight) throws IOException {
-      super(SpanNotQuery.this, searcher, terms, factory);
+      super(SpanNotQuery.this, searcher, terms);
       this.includeWeight = includeWeight;
       this.excludeWeight = excludeWeight;
     }
@@ -128,13 +128,13 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, SpanCollector collector) throws IOException {
-      Spans includeSpans = includeWeight.getSpans(context, acceptDocs, collector);
+    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, Postings requiredPostings) throws IOException {
+      Spans includeSpans = includeWeight.getSpans(context, acceptDocs, requiredPostings);
       if (includeSpans == null) {
         return null;
       }
 
-      Spans excludeSpans = excludeWeight.getSpans(context, acceptDocs, collector);
+      Spans excludeSpans = excludeWeight.getSpans(context, acceptDocs, requiredPostings);
       if (excludeSpans == null) {
         return includeSpans;
       }
Index: core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(working copy)
@@ -138,12 +138,12 @@
   }
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, SpanCollectorFactory factory) throws IOException {
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     List<SpanWeight> subWeights = new ArrayList<>(clauses.size());
     for (SpanQuery q : clauses) {
-      subWeights.add(q.createWeight(searcher, false, factory));
+      subWeights.add(q.createWeight(searcher, false));
     }
-    return new SpanOrWeight(searcher, needsScores ? getTermContexts(subWeights) : null, factory, subWeights);
+    return new SpanOrWeight(searcher, needsScores ? getTermContexts(subWeights) : null, subWeights);
   }
 
   public class SpanOrWeight extends SpanWeight {
@@ -150,8 +150,8 @@
 
     final List<SpanWeight> subWeights;
 
-    public SpanOrWeight(IndexSearcher searcher, Map<Term, TermContext> terms, SpanCollectorFactory factory, List<SpanWeight> subWeights) throws IOException {
-      super(SpanOrQuery.this, searcher, terms, factory);
+    public SpanOrWeight(IndexSearcher searcher, Map<Term, TermContext> terms, List<SpanWeight> subWeights) throws IOException {
+      super(SpanOrQuery.this, searcher, terms);
       this.subWeights = subWeights;
     }
 
@@ -170,13 +170,13 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, SpanCollector collector)
+    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, Postings requiredPostings)
         throws IOException {
 
       ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());
 
       for (SpanWeight w : subWeights) {
-        Spans spans = w.getSpans(context, acceptDocs, collector);
+        Spans spans = w.getSpans(context, acceptDocs, requiredPostings);
         if (spans != null) {
           subSpans.add(spans);
         }
Index: core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java	(working copy)
@@ -17,8 +17,8 @@
  */
 
 
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.IndexSearcher;
@@ -28,8 +28,8 @@
 
 import java.io.IOException;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
-import java.util.Objects;
 
 
 /**
@@ -59,7 +59,6 @@
    * match indicated a valid start position.
    *
    * @param spans The {@link Spans} instance, positioned at the spot to check
-   * @param collector the {@link SpanCollector} associated with the Spans
    *
    * @return whether the match is accepted, rejected, or rejected and should move to the next doc.
    *
@@ -66,12 +65,12 @@
    * @see Spans#nextDoc()
    *
    */
-  protected abstract AcceptStatus acceptPosition(Spans spans, SpanCollector collector) throws IOException;
+  protected abstract AcceptStatus acceptPosition(Spans spans) throws IOException;
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, SpanCollectorFactory factory) throws IOException {
-    SpanWeight matchWeight = match.createWeight(searcher, false, factory);
-    return new SpanPositionCheckWeight(matchWeight, searcher, needsScores ? getTermContexts(matchWeight) : null, factory);
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    SpanWeight matchWeight = match.createWeight(searcher, false);
+    return new SpanPositionCheckWeight(matchWeight, searcher, needsScores ? getTermContexts(matchWeight) : null);
   }
 
   public class SpanPositionCheckWeight extends SpanWeight {
@@ -78,9 +77,8 @@
 
     final SpanWeight matchWeight;
 
-    public SpanPositionCheckWeight(SpanWeight matchWeight, IndexSearcher searcher, Map<Term, TermContext> terms,
-                                   SpanCollectorFactory collectorFactory) throws IOException {
-      super(SpanPositionCheckQuery.this, searcher, terms, collectorFactory);
+    public SpanPositionCheckWeight(SpanWeight matchWeight, IndexSearcher searcher, Map<Term, TermContext> terms) throws IOException {
+      super(SpanPositionCheckQuery.this, searcher, terms);
       this.matchWeight = matchWeight;
     }
 
@@ -95,12 +93,12 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Bits acceptDocs, SpanCollector collector) throws IOException {
-      Spans matchSpans = matchWeight.getSpans(context, acceptDocs, collector);
+    public Spans getSpans(final LeafReaderContext context, Bits acceptDocs, Postings requiredPostings) throws IOException {
+      Spans matchSpans = matchWeight.getSpans(context, acceptDocs, requiredPostings);
       return (matchSpans == null) ? null : new FilterSpans(matchSpans) {
         @Override
         protected AcceptStatus accept(Spans candidate) throws IOException {
-          return acceptPosition(candidate, collector);
+          return acceptPosition(candidate);
         }
       };
     }
Index: core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java	(working copy)
@@ -38,18 +38,16 @@
     this.end = end;
   }
 
-
   @Override
-  protected AcceptStatus acceptPosition(Spans spans, SpanCollector collector) throws IOException {
+  protected AcceptStatus acceptPosition(Spans spans) throws IOException {
     assert spans.startPosition() != spans.endPosition();
     AcceptStatus res = (spans.startPosition() >= end)
-                      ? AcceptStatus.NO_MORE_IN_CURRENT_DOC
-                      : (spans.startPosition() >= start && spans.endPosition() <= end)
-                      ? AcceptStatus.YES : AcceptStatus.NO;
+        ? AcceptStatus.NO_MORE_IN_CURRENT_DOC
+        : (spans.startPosition() >= start && spans.endPosition() <= end)
+        ? AcceptStatus.YES : AcceptStatus.NO;
     return res;
   }
 
-
   /**
    * @return The minimum position permitted in a match
    */
Index: core/src/java/org/apache/lucene/search/spans/SpanQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanQuery.java	(working copy)
@@ -21,7 +21,6 @@
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.Weight;
 
 import java.io.IOException;
 import java.util.Collection;
@@ -36,21 +35,8 @@
    */
   public abstract String getField();
 
-  /**
-   * Create a SpanWeight for this query
-   * @param searcher the IndexSearcher to be searched across
-   * @param needsScores if the query needs scores
-   * @param collectorFactory a SpanCollectorFactory to use in collecting postings data
-   * @return a SpanWeight
-   * @throws IOException on error
-   */
-  public abstract SpanWeight createWeight(IndexSearcher searcher, boolean needsScores,
-                                          SpanCollectorFactory collectorFactory) throws IOException;
-
   @Override
-  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    return createWeight(searcher, needsScores, SpanCollectorFactory.NO_OP_FACTORY);
-  }
+  public abstract SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException;
 
   /**
    * Build a map of terms to termcontexts, for use in constructing SpanWeights
Index: core/src/java/org/apache/lucene/search/spans/SpanScorer.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanScorer.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanScorer.java	(working copy)
@@ -40,7 +40,11 @@
   
   private int lastScoredDoc = -1; // last doc we called setFreqCurrentDoc() for
 
-  protected SpanScorer(Spans spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
+  /**
+   * Creates a new SpanScorer
+   * @lucene.expert
+   */
+  public SpanScorer(Spans spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
     super(weight);
     this.docScorer = docScorer;
     this.spans = Objects.requireNonNull(spans);
Index: core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(working copy)
@@ -66,7 +66,7 @@
   public String getField() { return term.field(); }
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, SpanCollectorFactory factory) throws IOException {
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     final TermContext context;
     final IndexReaderContext topContext = searcher.getTopReaderContext();
     if (termContext == null || termContext.topReaderContext != topContext) {
@@ -75,7 +75,7 @@
     else {
       context = termContext;
     }
-    return new SpanTermWeight(context, searcher, needsScores ? Collections.singletonMap(term, context) : null, factory);
+    return new SpanTermWeight(context, searcher, needsScores ? Collections.singletonMap(term, context) : null);
   }
 
   public class SpanTermWeight extends SpanWeight {
@@ -82,8 +82,8 @@
 
     final TermContext termContext;
 
-    public SpanTermWeight(TermContext termContext, IndexSearcher searcher, Map<Term, TermContext> terms, SpanCollectorFactory factory) throws IOException {
-      super(SpanTermQuery.this, searcher, terms, factory);
+    public SpanTermWeight(TermContext termContext, IndexSearcher searcher, Map<Term, TermContext> terms) throws IOException {
+      super(SpanTermQuery.this, searcher, terms);
       this.termContext = termContext;
       assert termContext != null : "TermContext must not be null";
     }
@@ -99,7 +99,7 @@
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Bits acceptDocs, SpanCollector collector) throws IOException {
+    public Spans getSpans(final LeafReaderContext context, Bits acceptDocs, Postings requiredPostings) throws IOException {
 
       assert termContext.topReaderContext == ReaderUtil.getTopLevelContext(context) : "The top-reader used to create Weight (" + termContext.topReaderContext + ") is not the same as the current reader's top-reader (" + ReaderUtil.getTopLevelContext(context);
 
@@ -118,7 +118,7 @@
       final TermsEnum termsEnum = terms.iterator();
       termsEnum.seekExact(term.bytes(), state);
 
-      final PostingsEnum postings = termsEnum.postings(acceptDocs, null, collector.requiredPostings());
+      final PostingsEnum postings = termsEnum.postings(acceptDocs, null, requiredPostings.getRequiredPostings());
       return new TermSpans(postings, term);
     }
   }
Index: core/src/java/org/apache/lucene/search/spans/SpanWeight.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanWeight.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanWeight.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.Terms;
@@ -39,9 +40,41 @@
  */
 public abstract class SpanWeight extends Weight {
 
+  /**
+   * Enumeration defining what postings information should be retrieved from the
+   * index for a given Spans
+   */
+  public enum Postings {
+    POSITIONS {
+      @Override
+      public int getRequiredPostings() {
+        return PostingsEnum.POSITIONS;
+      }
+    },
+    PAYLOADS {
+      @Override
+      public int getRequiredPostings() {
+        return PostingsEnum.PAYLOADS;
+      }
+    },
+    OFFSETS {
+      @Override
+      public int getRequiredPostings() {
+        return PostingsEnum.PAYLOADS | PostingsEnum.OFFSETS;
+      }
+    };
+
+    public abstract int getRequiredPostings();
+
+    public Postings atLeast(Postings postings) {
+      if (postings.compareTo(this) > 0)
+        return postings;
+      return this;
+    }
+  }
+
   protected final Similarity similarity;
   protected final Similarity.SimWeight simWeight;
-  protected final SpanCollectorFactory collectorFactory;
   protected final String field;
 
   /**
@@ -50,14 +83,12 @@
    * @param searcher the IndexSearcher to query against
    * @param termContexts a map of terms to termcontexts for use in building the similarity.  May
    *                     be null if scores are not required
-   * @param collectorFactory a SpanCollectorFactory to be used for Span collection
    * @throws IOException on error
    */
-  public SpanWeight(SpanQuery query, IndexSearcher searcher, Map<Term, TermContext> termContexts, SpanCollectorFactory collectorFactory) throws IOException {
+  public SpanWeight(SpanQuery query, IndexSearcher searcher, Map<Term, TermContext> termContexts) throws IOException {
     super(query);
     this.field = query.getField();
     this.similarity = searcher.getSimilarity(termContexts != null);
-    this.collectorFactory = collectorFactory;
     this.simWeight = buildSimWeight(query, searcher, termContexts);
   }
 
@@ -84,24 +115,11 @@
    * Expert: Return a Spans object iterating over matches from this Weight
    * @param ctx a LeafReaderContext for this Spans
    * @param acceptDocs a bitset of documents to check
-   * @param collector a SpanCollector to use for postings data collection
    * @return a Spans
    * @throws IOException on error
    */
-  public abstract Spans getSpans(LeafReaderContext ctx, Bits acceptDocs, SpanCollector collector) throws IOException;
+  public abstract Spans getSpans(LeafReaderContext ctx, Bits acceptDocs, Postings requiredPostings) throws IOException;
 
-  /**
-   * Expert: Return a Spans object iterating over matches from this Weight, without
-   * collecting any postings data.
-   * @param ctx a LeafReaderContext for this Spans
-   * @param acceptDocs a bitset of documents to check
-   * @return a Spans
-   * @throws IOException on error
-   */
-  public final Spans getSpans(LeafReaderContext ctx, Bits acceptDocs) throws IOException {
-    return getSpans(ctx, acceptDocs, collectorFactory.newCollector());
-  }
-
   @Override
   public float getValueForNormalization() throws IOException {
     return simWeight == null ? 1.0f : simWeight.getValueForNormalization();
@@ -123,7 +141,7 @@
     if (terms != null && terms.hasPositions() == false) {
       throw new IllegalStateException("field \"" + field + "\" was indexed without position data; cannot run SpanQuery (query=" + parentQuery + ")");
     }
-    Spans spans = getSpans(context, acceptDocs, collectorFactory.newCollector());
+    Spans spans = getSpans(context, acceptDocs, Postings.POSITIONS);
     Similarity.SimScorer simScorer = simWeight == null ? null : similarity.simScorer(simWeight, context);
     return (spans == null) ? null : new SpanScorer(spans, this, simScorer);
   }
Index: core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java	(working copy)
@@ -52,18 +52,18 @@
   }
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, SpanCollectorFactory factory) throws IOException {
-    SpanWeight bigWeight = big.createWeight(searcher, false, factory);
-    SpanWeight littleWeight = little.createWeight(searcher, false, factory);
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    SpanWeight bigWeight = big.createWeight(searcher, false);
+    SpanWeight littleWeight = little.createWeight(searcher, false);
     return new SpanWithinWeight(searcher, needsScores ? getTermContexts(bigWeight, littleWeight) : null,
-                                      factory, bigWeight, littleWeight);
+                                      bigWeight, littleWeight);
   }
 
   public class SpanWithinWeight extends SpanContainWeight {
 
-    public SpanWithinWeight(IndexSearcher searcher, Map<Term, TermContext> terms, SpanCollectorFactory factory,
+    public SpanWithinWeight(IndexSearcher searcher, Map<Term, TermContext> terms,
                             SpanWeight bigWeight, SpanWeight littleWeight) throws IOException {
-      super(searcher, terms, factory, bigWeight, littleWeight);
+      super(searcher, terms, bigWeight, littleWeight);
     }
 
     /**
@@ -71,8 +71,8 @@
      * The payload is from the spans of <code>little</code>.
      */
     @Override
-    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, SpanCollector collector) throws IOException {
-      ArrayList<Spans> containerContained = prepareConjunction(context, acceptDocs, collector);
+    public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, Postings requiredPostings) throws IOException {
+      ArrayList<Spans> containerContained = prepareConjunction(context, acceptDocs, requiredPostings);
       if (containerContained == null) {
         return null;
       }
Index: core/src/java/org/apache/lucene/search/spans/Spans.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/Spans.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/Spans.java	(working copy)
@@ -50,7 +50,11 @@
   public abstract int endPosition();
 
   /**
-   * Collect data from the current Spans
+   * Collect postings data from the leaves of the current Spans.
+   *
+   * This method should only be called after {@link #nextStartPosition()}, and before
+   * {@link #NO_MORE_POSITIONS} has been reached.
+   *
    * @param collector a SpanCollector
    *
    * @lucene.experimental
Index: core/src/java/org/apache/lucene/search/spans/TermSpans.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/TermSpans.java	(revision 1684590)
+++ core/src/java/org/apache/lucene/search/spans/TermSpans.java	(working copy)
@@ -106,30 +106,9 @@
     return postings.cost();
   }
 
-  /*
   @Override
-  public Collection<byte[]> getPayload() throws IOException {
-    final BytesRef payload = postings.getPayload();
-    readPayload = true;
-    final byte[] bytes;
-    if (payload != null) {
-      bytes = new byte[payload.length];
-      System.arraycopy(payload.bytes, payload.offset, bytes, 0, payload.length);
-    } else {
-      bytes = null;
-    }
-    return Collections.singletonList(bytes);
-  }
-
-  @Override
-  public boolean isPayloadAvailable() throws IOException {
-    return readPayload == false && postings.getPayload() != null;
-  }
-  */
-
-  @Override
   public void collect(SpanCollector collector) throws IOException {
-    collector.collectLeaf(postings, term);
+    collector.collectLeaf(postings, position, term);
   }
 
   @Override
Index: core/src/test/org/apache/lucene/search/TestPositionIncrement.java
===================================================================
--- core/src/test/org/apache/lucene/search/TestPositionIncrement.java	(revision 1684590)
+++ core/src/test/org/apache/lucene/search/TestPositionIncrement.java	(working copy)
@@ -39,6 +39,7 @@
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.spans.SpanWeight;
 import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
@@ -242,7 +243,7 @@
       System.out.println("\ngetPayloadSpans test");
     }
     PayloadSpanCollector collector = new PayloadSpanCollector();
-    Spans pspans = MultiSpansWrapper.wrap(is.getIndexReader(), snq, collector);
+    Spans pspans = MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
     while (pspans.nextDoc() != Spans.NO_MORE_DOCS) {
       while (pspans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
         if (VERBOSE) {
Index: core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java
===================================================================
--- core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java	(revision 1684590)
+++ core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java	(working copy)
@@ -28,6 +28,7 @@
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.IndexSearcher;
@@ -41,6 +42,7 @@
 import org.apache.lucene.search.spans.SpanNotQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.spans.SpanWeight;
 import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
@@ -73,12 +75,12 @@
     Spans spans;
     stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "seventy"));
     PayloadSpanCollector collector = new PayloadSpanCollector();
-    spans = MultiSpansWrapper.wrap(indexReader, stq, collector);
+    spans = MultiSpansWrapper.wrap(indexReader, stq, SpanWeight.Postings.PAYLOADS);
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, collector, 100, 1, 1, 1);
 
     stq = new SpanTermQuery(new Term(PayloadHelper.NO_PAYLOAD_FIELD, "seventy"));  
-    spans = MultiSpansWrapper.wrap(indexReader, stq, collector);
+    spans = MultiSpansWrapper.wrap(indexReader, stq, SpanWeight.Postings.PAYLOADS);
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, collector, 100, 0, 0, 0);
   }
@@ -90,7 +92,7 @@
     match = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
     sfq = new SpanFirstQuery(match, 2);
     PayloadSpanCollector collector = new PayloadSpanCollector();
-    Spans spans = MultiSpansWrapper.wrap(indexReader, sfq, collector);
+    Spans spans = MultiSpansWrapper.wrap(indexReader, sfq, SpanWeight.Postings.PAYLOADS);
     checkSpans(spans, collector, 109, 1, 1, 1);
     //Test more complicated subclause
     SpanQuery[] clauses = new SpanQuery[2];
@@ -98,11 +100,11 @@
     clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "hundred"));
     match = new SpanNearQuery(clauses, 0, true);
     sfq = new SpanFirstQuery(match, 2);
-    checkSpans(MultiSpansWrapper.wrap(indexReader, sfq, collector), collector, 100, 2, 1, 1);
+    checkSpans(MultiSpansWrapper.wrap(indexReader, sfq, SpanWeight.Postings.PAYLOADS), collector, 100, 2, 1, 1);
 
     match = new SpanNearQuery(clauses, 0, false);
     sfq = new SpanFirstQuery(match, 2);
-    checkSpans(MultiSpansWrapper.wrap(indexReader, sfq, collector), collector, 100, 2, 1, 1);
+    checkSpans(MultiSpansWrapper.wrap(indexReader, sfq, SpanWeight.Postings.PAYLOADS), collector, 100, 2, 1, 1);
     
   }
   
@@ -126,7 +128,7 @@
     writer.close();
 
     PayloadSpanCollector collector = new PayloadSpanCollector();
-    checkSpans(MultiSpansWrapper.wrap(reader, snq, collector), collector, 1, new int[]{2});
+    checkSpans(MultiSpansWrapper.wrap(reader, snq, SpanWeight.Postings.PAYLOADS), collector, 1, new int[]{2});
     reader.close();
     directory.close();
   }
@@ -138,7 +140,7 @@
     PayloadSpanCollector collector = new PayloadSpanCollector();
 
     stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "mark"));
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), stq, collector);
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), stq, SpanWeight.Postings.PAYLOADS);
     assertNull(spans);
 
     SpanQuery[] clauses = new SpanQuery[3];
@@ -147,7 +149,7 @@
     clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
     SpanNearQuery spanNearQuery = new SpanNearQuery(clauses, 12, false);
 
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), spanNearQuery, collector);
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), spanNearQuery, SpanWeight.Postings.PAYLOADS);
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, collector, 2, new int[]{3,3});
 
@@ -158,7 +160,7 @@
 
     spanNearQuery = new SpanNearQuery(clauses, 6, true);
    
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), spanNearQuery, collector);
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), spanNearQuery, SpanWeight.Postings.PAYLOADS);
 
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, collector, 1, new int[]{3});
@@ -180,7 +182,7 @@
     SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses2, 6, false);
     
     // yy within 6 of xx within 6 of rr
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery, collector);
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery, SpanWeight.Postings.PAYLOADS);
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, collector, 2, new int[]{3,3});
     closeIndexReader.close();
@@ -212,7 +214,7 @@
 
     PayloadSpanCollector collector = new PayloadSpanCollector();
     SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses3, 6, false);
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery, collector);
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery, SpanWeight.Postings.PAYLOADS);
 
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, collector, 1, new int[]{3});
@@ -251,7 +253,7 @@
     SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses3, 6, false);
 
     PayloadSpanCollector collector = new PayloadSpanCollector();
-    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery, collector);
+    spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery, SpanWeight.Postings.PAYLOADS);
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, collector, 2, new int[]{8, 8});
     closeIndexReader.close();
@@ -276,7 +278,7 @@
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 1, true);
     PayloadSpanCollector collector = new PayloadSpanCollector();
-    Spans spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq, collector);
+    Spans spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
@@ -316,7 +318,7 @@
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
     PayloadSpanCollector collector = new PayloadSpanCollector();
-    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq, collector);
+    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
@@ -357,7 +359,7 @@
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
     PayloadSpanCollector collector = new PayloadSpanCollector();
-    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq, collector);
+    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
Index: core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java
===================================================================
--- core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java	(revision 1684590)
+++ core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java	(working copy)
@@ -84,7 +84,7 @@
     }
 
     @Override
-    public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, SpanCollectorFactory factory) throws IOException {
+    public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
 
Index: core/src/test/org/apache/lucene/search/spans/MultiSpansWrapper.java
===================================================================
--- core/src/test/org/apache/lucene/search/spans/MultiSpansWrapper.java	(revision 1684590)
+++ core/src/test/org/apache/lucene/search/spans/MultiSpansWrapper.java	(working copy)
@@ -36,10 +36,10 @@
 public class MultiSpansWrapper {
 
   public static Spans wrap(IndexReader reader, SpanQuery spanQuery) throws IOException {
-    return wrap(reader, spanQuery, SpanCollector.NO_OP);
+    return wrap(reader, spanQuery, SpanWeight.Postings.POSITIONS);
   }
 
-  public static Spans wrap(IndexReader reader, SpanQuery spanQuery, SpanCollector collector) throws IOException {
+  public static Spans wrap(IndexReader reader, SpanQuery spanQuery, SpanWeight.Postings requiredPostings) throws IOException {
 
     LeafReader lr = SlowCompositeReaderWrapper.wrap(reader); // slow, but ok for testing
     LeafReaderContext lrContext = lr.getContext();
@@ -46,8 +46,8 @@
     IndexSearcher searcher = new IndexSearcher(lr);
     searcher.setQueryCache(null);
 
-    SpanWeight w = (SpanWeight) searcher.createNormalizedWeight(spanQuery, false);
+    SpanWeight w = spanQuery.createWeight(searcher, false);
 
-    return w.getSpans(lrContext, new Bits.MatchAllBits(lr.numDocs()), collector);
+    return w.getSpans(lrContext, new Bits.MatchAllBits(lr.numDocs()), requiredPostings);
   }
 }
Index: highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
===================================================================
--- highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java	(revision 1684590)
+++ highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java	(working copy)
@@ -301,7 +301,7 @@
       LeafReaderContext context = getLeafContext();
       SpanWeight w = (SpanWeight) searcher.createNormalizedWeight(q, false);
       Bits acceptDocs = context.reader().getLiveDocs();
-      final Spans spans = w.getSpans(context, acceptDocs);
+      final Spans spans = w.getSpans(context, acceptDocs, SpanWeight.Postings.POSITIONS);
       if (spans == null) {
         return;
       }
Index: test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanQuery.java
===================================================================
--- test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanQuery.java	(revision 1684590)
+++ test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanQuery.java	(working copy)
@@ -42,8 +42,8 @@
   }
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, SpanCollectorFactory factory) throws IOException {
-    SpanWeight weight = in.createWeight(searcher, needsScores, factory);
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    SpanWeight weight = in.createWeight(searcher, needsScores);
     return new AssertingSpanWeight(searcher, weight);
   }
 
Index: test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java
===================================================================
--- test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java	(revision 1684590)
+++ test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java	(working copy)
@@ -42,7 +42,7 @@
    * @throws IOException on error
    */
   public AssertingSpanWeight(IndexSearcher searcher, SpanWeight in) throws IOException {
-    super((SpanQuery) in.getQuery(), searcher, null, in.collectorFactory);
+    super((SpanQuery) in.getQuery(), searcher, null);
     this.in = in;
   }
 
@@ -52,8 +52,8 @@
   }
 
   @Override
-  public Spans getSpans(LeafReaderContext context, Bits liveDocs, SpanCollector collector) throws IOException {
-    Spans spans = in.getSpans(context, liveDocs, collector);
+  public Spans getSpans(LeafReaderContext context, Bits liveDocs, Postings requiredPostings) throws IOException {
+    Spans spans = in.getSpans(context, liveDocs, requiredPostings);
     if (spans == null)
       return null;
     return new AssertingSpans(spans);
