Index: solr/contrib/extraction/src/test/java/org/apache/solr/handler/ExtractingRequestHandlerTest.java
===================================================================
--- solr/contrib/extraction/src/test/java/org/apache/solr/handler/ExtractingRequestHandlerTest.java	(revision 1023270)
+++ solr/contrib/extraction/src/test/java/org/apache/solr/handler/ExtractingRequestHandlerTest.java	(working copy)
@@ -26,7 +26,7 @@
 import org.apache.solr.handler.extraction.ExtractingParams;
 import org.apache.solr.handler.extraction.ExtractingRequestHandler;
 import org.apache.solr.handler.extraction.ExtractingDocumentLoader;
-import org.junit.Assume;
+
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -60,7 +60,7 @@
   public void testExtraction() throws Exception {
     // broken for turkish: https://issues.apache.org/jira/browse/SOLR-2088
     String defLang = Locale.getDefault().getLanguage();
-    Assume.assumeTrue(!defLang.equals("tr") && !defLang.equals("az"));
+    assumeFalse("Known bugs under Turkish locale: https://issues.apache.org/jira/browse/SOLR-2088", defLang.equals("tr") || defLang.equals("az"));
     ExtractingRequestHandler handler = (ExtractingRequestHandler) h.getCore().getRequestHandler("/update/extract");
     assertTrue("handler is null and it shouldn't be", handler != null);
     loadLocal("solr-word.pdf", "fmap.created", "extractedDate", "fmap.producer", "extractedProducer",
Index: solr/src/test/org/apache/solr/servlet/SolrRequestParserTest.java
===================================================================
--- solr/src/test/org/apache/solr/servlet/SolrRequestParserTest.java	(revision 1023270)
+++ solr/src/test/org/apache/solr/servlet/SolrRequestParserTest.java	(working copy)
@@ -39,7 +39,6 @@
 import org.apache.solr.common.util.ContentStream;
 import org.apache.solr.core.SolrCore;
 import org.junit.AfterClass;
-import org.junit.Assume;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -120,8 +119,7 @@
       txt = IOUtils.toString( connection.getInputStream());
     }
     catch( Exception ex ) {
-      System.out.println( "this test only works if you have a network connection." );
-      Assume.assumeNoException(ex);
+      assumeNoException("Unable to connect to " + url + " to run the test.", ex);
       return;
     }
 
Index: solr/src/test/org/apache/solr/analysis/TestThaiWordFilterFactory.java
===================================================================
--- solr/src/test/org/apache/solr/analysis/TestThaiWordFilterFactory.java	(revision 1023270)
+++ solr/src/test/org/apache/solr/analysis/TestThaiWordFilterFactory.java	(working copy)
@@ -24,7 +24,6 @@
 import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.core.WhitespaceTokenizer;
 import org.apache.lucene.analysis.th.ThaiWordFilter;
-import org.junit.Assume;
 
 /**
  * Simple tests to ensure the Thai word filter factory is working.
@@ -34,7 +33,7 @@
    * Ensure the filter actually decomposes text.
    */
   public void testWordBreak() throws Exception {
-    Assume.assumeTrue(ThaiWordFilter.DBBI_AVAILABLE);
+    assumeTrue("JRE does not support Thai dictionary-based BreakIterator", ThaiWordFilter.DBBI_AVAILABLE);
     Reader reader = new StringReader("การที่ได้ต้องแสดงว่างานดี");
     Tokenizer tokenizer = new WhitespaceTokenizer(DEFAULT_VERSION, reader);
     ThaiWordFilterFactory factory = new ThaiWordFilterFactory();
Index: modules/analysis/common/src/test/org/apache/lucene/analysis/th/TestThaiAnalyzer.java
===================================================================
--- modules/analysis/common/src/test/org/apache/lucene/analysis/th/TestThaiAnalyzer.java	(revision 1023270)
+++ modules/analysis/common/src/test/org/apache/lucene/analysis/th/TestThaiAnalyzer.java	(working copy)
@@ -19,7 +19,6 @@
 
 import org.apache.lucene.analysis.BaseTokenStreamTestCase;
 import org.apache.lucene.util.Version;
-import org.junit.Assume;
 
 /**
  * Test case for ThaiAnalyzer, modified from TestFrenchAnalyzer
@@ -33,7 +32,7 @@
 	 * testcase for offsets
 	 */
 	public void testOffsets() throws Exception {
-	  Assume.assumeTrue(ThaiWordFilter.DBBI_AVAILABLE);
+	  assumeTrue("JRE does not support Thai dictionary-based BreakIterator", ThaiWordFilter.DBBI_AVAILABLE);
 		assertAnalyzesTo(new ThaiAnalyzer(TEST_VERSION_CURRENT), "การที่ได้ต้องแสดงว่างานดี", 
 		    new String[] { "การ", "ที่", "ได้", "ต้อง", "แสดง", "ว่า", "งาน", "ดี" },
 				new int[] { 0, 3, 6, 9, 13, 17, 20, 23 },
@@ -41,6 +40,7 @@
 	}
 	
 	public void testTokenType() throws Exception {
+	    assumeTrue("JRE does not support Thai dictionary-based BreakIterator", ThaiWordFilter.DBBI_AVAILABLE);
       assertAnalyzesTo(new ThaiAnalyzer(TEST_VERSION_CURRENT), "การที่ได้ต้องแสดงว่างานดี ๑๒๓", 
                        new String[] { "การ", "ที่", "ได้", "ต้อง", "แสดง", "ว่า", "งาน", "ดี", "๑๒๓" },
                        new String[] { "<SOUTHEAST_ASIAN>", "<SOUTHEAST_ASIAN>", 
@@ -56,7 +56,7 @@
  	 */
 	@Deprecated
 	public void testBuggyTokenType30() throws Exception {
-	  Assume.assumeTrue(ThaiWordFilter.DBBI_AVAILABLE);
+	  assumeTrue("JRE does not support Thai dictionary-based BreakIterator", ThaiWordFilter.DBBI_AVAILABLE);
 		assertAnalyzesTo(new ThaiAnalyzer(Version.LUCENE_30), "การที่ได้ต้องแสดงว่างานดี ๑๒๓", 
                          new String[] { "การ", "ที่", "ได้", "ต้อง", "แสดง", "ว่า", "งาน", "ดี", "๑๒๓" },
                          new String[] { "<ALPHANUM>", "<ALPHANUM>", "<ALPHANUM>", 
@@ -67,7 +67,7 @@
 	/** @deprecated testing backwards behavior */
 	@Deprecated
     public void testAnalyzer30() throws Exception {
- 	  Assume.assumeTrue(ThaiWordFilter.DBBI_AVAILABLE);
+	  assumeTrue("JRE does not support Thai dictionary-based BreakIterator", ThaiWordFilter.DBBI_AVAILABLE);
         ThaiAnalyzer analyzer = new ThaiAnalyzer(Version.LUCENE_30);
 	
 		assertAnalyzesTo(analyzer, "", new String[] {});
@@ -93,7 +93,7 @@
 	 * Test that position increments are adjusted correctly for stopwords.
 	 */
 	public void testPositionIncrements() throws Exception {
-	  Assume.assumeTrue(ThaiWordFilter.DBBI_AVAILABLE);
+	  assumeTrue("JRE does not support Thai dictionary-based BreakIterator", ThaiWordFilter.DBBI_AVAILABLE);
 	  ThaiAnalyzer analyzer = new ThaiAnalyzer(TEST_VERSION_CURRENT);
 
     assertAnalyzesTo(new ThaiAnalyzer(TEST_VERSION_CURRENT), "การที่ได้ต้อง the แสดงว่างานดี", 
@@ -111,7 +111,7 @@
 	}
 	
 	public void testReusableTokenStream() throws Exception {
-	  Assume.assumeTrue(ThaiWordFilter.DBBI_AVAILABLE);
+	  assumeTrue("JRE does not support Thai dictionary-based BreakIterator", ThaiWordFilter.DBBI_AVAILABLE);
 	  ThaiAnalyzer analyzer = new ThaiAnalyzer(TEST_VERSION_CURRENT);
 	  assertAnalyzesToReuse(analyzer, "", new String[] {});
 
@@ -129,6 +129,7 @@
 	/** @deprecated, for version back compat */
 	@Deprecated
 	public void testReusableTokenStream30() throws Exception {
+	    assumeTrue("JRE does not support Thai dictionary-based BreakIterator", ThaiWordFilter.DBBI_AVAILABLE);
 	    ThaiAnalyzer analyzer = new ThaiAnalyzer(Version.LUCENE_30);
 	    assertAnalyzesToReuse(analyzer, "", new String[] {});
 
Index: lucene/src/test/org/apache/lucene/index/TestLazyProxSkipping.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestLazyProxSkipping.java	(revision 1023270)
+++ lucene/src/test/org/apache/lucene/index/TestLazyProxSkipping.java	(working copy)
@@ -34,7 +34,6 @@
 import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.BytesRef;
-import static org.junit.Assume.*;
 
 /**
  * Tests lazy skipping on the proximity file.
@@ -121,7 +120,7 @@
     }
  
     public void testLazySkipping() throws IOException {
-        assumeTrue(!CodecProvider.getDefaultCodec().equals("SimpleText"));
+        assumeFalse("This test cannot run with SimpleText codec", CodecProvider.getDefaultCodec().equals("SimpleText"));
         // test whether only the minimum amount of seeks()
         // are performed
         performTest(5);
Index: lucene/src/test/org/apache/lucene/util/LuceneTestCase.java
===================================================================
--- lucene/src/test/org/apache/lucene/util/LuceneTestCase.java	(revision 1023270)
+++ lucene/src/test/org/apache/lucene/util/LuceneTestCase.java	(working copy)
@@ -42,6 +42,7 @@
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.MockDirectoryWrapper;
 import org.apache.lucene.util.FieldCacheSanityChecker.Insanity;
+import org.junit.Assume;
 import org.junit.After;
 import org.junit.AfterClass;
 import org.junit.Assert;
@@ -65,6 +66,7 @@
 import java.io.File;
 import java.io.IOException;
 import java.io.PrintStream;
+import java.io.PrintWriter;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
@@ -351,8 +353,16 @@
       // org.junit.internal.AssumptionViolatedException in older releases
       // org.junit.Assume.AssumptionViolatedException in recent ones
       if (e.getClass().getName().endsWith("AssumptionViolatedException")) {
-        System.err.println("NOTE: " + method.getName() + " Assume failed (ignored):");
-        e.printStackTrace();
+        if (e.getCause() instanceof TestIgnoredException)
+          e = e.getCause();
+        System.err.print("NOTE: Assume failed in '" + method.getName() + "' (ignored):");
+        if (VERBOSE) {
+          System.err.println();
+          e.printStackTrace(System.err);
+        } else {
+          System.err.print(" ");
+          System.err.println(e.getMessage());
+        }
       } else {
         testsFailed = true;
         reportAdditionalFailureInfo();
@@ -373,7 +383,7 @@
   public void setUp() throws Exception {
     seed = "random".equals(TEST_SEED) ? seedRand.nextLong() : TwoLongs.fromString(TEST_SEED).l2;
     random.setSeed(seed);
-    Assert.assertFalse("ensure your tearDown() calls super.tearDown()!!!", setup);
+    assertFalse("ensure your tearDown() calls super.tearDown()!!!", setup);
     setup = true;
     savedUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
     Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
@@ -410,7 +420,7 @@
 
   @After
   public void tearDown() throws Exception {
-    Assert.assertTrue("ensure your setUp() calls super.setUp()!!!", setup);
+    assertTrue("ensure your setUp() calls super.setUp()!!!", setup);
     setup = false;
     BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);
     try {
@@ -515,7 +525,64 @@
   static public void assertEquals(String message, float expected, float actual) {
     assertEquals(message, Float.valueOf(expected), Float.valueOf(actual));
   }
+  
+  // Replacement for Assume jUnit class, so we can add a messge with explanation:
+  
+  private static final class TestIgnoredException extends RuntimeException {
+    TestIgnoredException(String msg) {
+      super(msg);
+    }
+    
+    TestIgnoredException(String msg, Throwable t) {
+      super(msg, t);
+    }
+    
+    @Override
+    public String getMessage() {
+      StringBuilder sb = new StringBuilder(super.getMessage());
+      if (getCause() != null)
+        sb.append(" - ").append(getCause());
+      return sb.toString();
+    }
+    
+    @Override
+    public void printStackTrace(PrintStream s) {
+      if (getCause() != null) {
+        s.println(toString() + " - Caused by:");
+        getCause().printStackTrace(s);
+      } else {
+        super.printStackTrace(s);
+      }
+    }
+    
+    @Override
+    public void printStackTrace(PrintWriter s) {
+      if (getCause() != null) {
+        s.println(toString() + " - Caused by:");
+        getCause().printStackTrace(s);
+      } else {
+        super.printStackTrace(s);
+      }
+    }
+    
+    @Override
+    public void printStackTrace() {
+      printStackTrace(System.err);
+    }
+  }
+  
+  public static void assumeTrue(String msg, boolean b) {
+    Assume.assumeNoException(b ? null : new TestIgnoredException(msg));
+  }
  
+  public static void assumeFalse(String msg, boolean b) {
+    assumeTrue(msg, !b);
+  }
+  
+  public static void assumeNoException(String msg, Exception e) {
+    Assume.assumeNoException(e == null ? null : new TestIgnoredException(msg, e));
+  }
+ 
   /**
    * Convinience method for logging an iterator.
    *
@@ -792,16 +859,14 @@
     protected List<FrameworkMethod> computeTestMethods() {
       if (testMethods != null)
         return testMethods;
-      // check if the current test's class has methods annotated with @Ignore
-      final Class<?> clazz = getTestClass().getJavaClass();
-      for (Method m : clazz.getMethods()) {
-        Ignore ignored = m.getAnnotation(Ignore.class);
+      testMethods = getTestClass().getAnnotatedMethods(Test.class);
+      for (Method m : getTestClass().getJavaClass().getMethods()) {
+        // check if the current test's class has methods annotated with @Ignore
+        final Ignore ignored = m.getAnnotation(Ignore.class);
         if (ignored != null) {
-          System.err.println("NOTE: Ignoring test method '" + m.getName() + "' " + ignored.value());
+          System.err.println("NOTE: Ignoring test method '" + m.getName() + "': " + ignored.value());
         }
-      }
-      testMethods = getTestClass().getAnnotatedMethods(Test.class);
-      for (Method m : getTestClass().getJavaClass().getMethods()) {
+        // add methods starting with "test"
         final int mod = m.getModifiers();
         if (m.getName().startsWith("test") &&
             m.getAnnotation(Test.class) == null &&
Index: lucene/contrib/xml-query-parser/src/test/org/apache/lucene/xmlparser/TestQueryTemplateManager.java
===================================================================
--- lucene/contrib/xml-query-parser/src/test/org/apache/lucene/xmlparser/TestQueryTemplateManager.java	(revision 1023270)
+++ lucene/contrib/xml-query-parser/src/test/org/apache/lucene/xmlparser/TestQueryTemplateManager.java	(working copy)
@@ -17,7 +17,7 @@
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.LuceneTestCase;
-import org.junit.Assume;
+
 import org.w3c.dom.Document;
 import org.xml.sax.SAXException;
 
@@ -75,7 +75,7 @@
 	  // Sun 1.5 suffers from http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6240963
 	  if (Constants.JAVA_VENDOR.startsWith("Sun") && Constants.JAVA_VERSION.startsWith("1.5")) {
 	    String defLang = Locale.getDefault().getLanguage();
-	    Assume.assumeTrue(!defLang.equals("tr") && !defLang.equals("az"));
+	    assumeFalse("Sun JRE 1.5 suffers from http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6240963 under Turkish locale", defLang.equals("tr") || defLang.equals("az"));
 	  }
 		//Cache all the query templates we will be referring to.
 		QueryTemplateManager qtm=new QueryTemplateManager();
