diff --git a/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java b/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
index 2a8b6e6..2941c4a 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
@@ -74,7 +74,7 @@ class ConjunctionScorer extends Scorer {
   }
 
   @Override
-  public void setMinCompetitiveScore(float score) {
+  public void setMinCompetitiveScore(float score) throws IOException {
     if (scorers.length == 1) {
       scorers[0].setMinCompetitiveScore(score);
     }
diff --git a/lucene/core/src/java/org/apache/lucene/search/ReqExclScorer.java b/lucene/core/src/java/org/apache/lucene/search/ReqExclScorer.java
index 3714d49..dfa8120 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ReqExclScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ReqExclScorer.java
@@ -82,7 +82,7 @@ class ReqExclScorer extends Scorer {
   }
 
   @Override
-  public void setMinCompetitiveScore(float score) {
+  public void setMinCompetitiveScore(float score) throws IOException {
     // The score of this scorer is the same as the score of 'reqScorer'.
     reqScorer.setMinCompetitiveScore(score);
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/ScoreCachingWrappingScorer.java b/lucene/core/src/java/org/apache/lucene/search/ScoreCachingWrappingScorer.java
index 1384cbe..ce6a0fa 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ScoreCachingWrappingScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ScoreCachingWrappingScorer.java
@@ -59,7 +59,7 @@ public final class ScoreCachingWrappingScorer extends FilterScorer {
   }
 
   @Override
-  public void setMinCompetitiveScore(float minScore) {
+  public void setMinCompetitiveScore(float minScore) throws IOException {
     in.setMinCompetitiveScore(minScore);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/Scorer.java b/lucene/core/src/java/org/apache/lucene/search/Scorer.java
index 2fb0d26..f135dff 100644
--- a/lucene/core/src/java/org/apache/lucene/search/Scorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/Scorer.java
@@ -153,7 +153,7 @@ public abstract class Scorer {
    * {@link ScoreMode#TOP_SCORES}, and successive calls may only set increasing
    * values of {@code minScore}.
    */
-  public void setMinCompetitiveScore(float minScore) {
+  public void setMinCompetitiveScore(float minScore) throws IOException {
     // no-op by default
   }
 
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/DistanceQuery.java b/lucene/sandbox/src/java/org/apache/lucene/search/DistanceQuery.java
new file mode 100644
index 0000000..41c57a3
--- /dev/null
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/DistanceQuery.java
@@ -0,0 +1,253 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.Objects;
+import java.util.Set;
+import java.util.function.DoubleFunction;
+
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.PointValues;
+import org.apache.lucene.index.PointValues.IntersectVisitor;
+import org.apache.lucene.index.PointValues.Relation;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.util.DocIdSetBuilder;
+import org.apache.lucene.util.StringHelper;
+
+final class DistanceQuery extends Query {
+
+  private final String field;
+  private final DoubleValuesSource scores;
+  private final DoubleFunction<byte[][]> scoreToRange;
+  private final String toString;
+
+  // scores must be <= 1
+  DistanceQuery(String field, DoubleValuesSource scores, DoubleFunction<byte[][]> scoreToRange, String toString) {
+    this.field = field;
+    this.scores = scores;
+    this.scoreToRange = scoreToRange;
+    this.toString = toString;
+  }
+
+  @Override
+  public final int hashCode() {
+    int hash = classHash();
+    hash = 31 * hash + Objects.hashCode(field);
+    hash = 31 * hash + Objects.hashCode(scores);
+    hash = 31 * hash + Objects.hashCode(scoreToRange);
+    return hash;
+  }
+
+  @Override
+  public final boolean equals(Object o) {
+    return sameClassAs(o) &&
+        equalsTo(getClass().cast(o));
+  }
+
+  private boolean equalsTo(DistanceQuery other) {
+    return Objects.equals(scores, other.scores) &&
+        Objects.equals(scoreToRange, other.scoreToRange);
+  }
+
+  @Override
+  public final String toString(String field) {
+    return "DistanceQuery(" + toString + ")";
+  }
+
+  @Override
+  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {
+    // TODO: what if scores are not needed
+    return new Weight(this) {
+
+      @Override
+      public boolean isCacheable(LeafReaderContext ctx) {
+        return false; // this query is only relevant with scoring anyway
+      }
+
+      @Override
+      public Scorer scorer(LeafReaderContext context) throws IOException {
+        LeafReader reader = context.reader();
+        PointValues values = reader.getPointValues(field);
+        if (values == null) {
+          return null;
+        }
+        DoubleValues scores = DistanceQuery.this.scores.getValues(context, null);
+        return new DistanceScorer(this, reader.maxDoc(), scores, values, scoreToRange);
+      }
+
+      @Override
+      public void extractTerms(Set<Term> terms) {}
+
+      @Override
+      public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+        Scorer scorer = scorer(context);
+        if (scorer == null) {
+          return Explanation.noMatch("Field does not exist");
+        } else if (scorer.iterator().advance(doc) == doc) {
+          return Explanation.match(scorer.score(), "Match");
+        } else {
+          return Explanation.noMatch("Document does not have a value for this field");
+        }
+      }
+    };
+  }
+
+  private static class DistanceScorer extends Scorer {
+
+    private final int maxDoc;
+    private DocIdSetIterator it;
+    private int doc = -1;
+    private final PointValues values;
+    private final DoubleValues scores;
+    private final DoubleFunction<byte[][]> scoreToRange;
+
+    protected DistanceScorer(Weight weight, int maxDoc,
+        DoubleValues scores, PointValues values, DoubleFunction<byte[][]> scoreToRange) {
+      super(weight);
+      this.maxDoc = maxDoc;
+      this.scores = scores;
+      this.values = values;
+      this.scoreToRange = scoreToRange;
+      this.it = DocIdSetIterator.all(maxDoc);
+    }
+
+    @Override
+    public int docID() {
+      return it.docID();
+    }
+
+    @Override
+    public float score() throws IOException {
+      if (scores.advanceExact(docID())) {
+        return (float) scores.doubleValue();
+      } else {
+        return 0;
+      }
+    }
+
+    @Override
+    public DocIdSetIterator iterator() {
+      // add indirection so that if 'it' is updated then it will
+      // be taken into account
+      return new DocIdSetIterator() {
+
+        @Override
+        public int nextDoc() throws IOException {
+          int next = it.nextDoc();
+          assert next > doc : "next=" + next + " <= doc=" + doc;
+          return doc = next;
+        }
+
+        @Override
+        public int docID() {
+          return doc;
+        }
+
+        @Override
+        public long cost() {
+          return it.cost();
+        }
+
+        @Override
+        public int advance(int target) throws IOException {
+        int next = it.advance(target);
+        assert next > doc : "next=" + next + " <= doc=" + doc;
+        return doc = next;
+        }
+      };
+    }
+
+    @Override
+    public float maxScore() {
+      return 1f;
+    }
+
+    @Override
+    public void setMinCompetitiveScore(float minScore) throws IOException {
+      byte[][] range = scoreToRange.apply(minScore);
+      assert range.length == 2;
+      byte[] lowerPoint = range[0];
+      byte[] upperPoint = range[1];
+      int bytesPerDim = lowerPoint.length;
+      assert upperPoint.length == bytesPerDim;
+      DocIdSetBuilder result = new DocIdSetBuilder(maxDoc);
+      final int doc = docID();
+      IntersectVisitor visitor = new IntersectVisitor() {
+
+        DocIdSetBuilder.BulkAdder adder;
+
+        @Override
+        public void grow(int count) {
+          adder = result.grow(count);
+        }
+
+        @Override
+        public void visit(int docID) {
+          if (docID <= doc) {
+            // Already visited or skipped
+            return;
+          }
+          adder.add(docID);
+        }
+
+        @Override
+        public void visit(int docID, byte[] packedValue) {
+          if (docID <= doc) {
+            // Already visited or skipped
+            return;
+          }
+          if (StringHelper.compare(bytesPerDim, packedValue, 0, lowerPoint, 0) < 0) {
+            // Doc's value is too low, in this dimension
+            return;
+          }
+          if (StringHelper.compare(bytesPerDim, packedValue, 0, upperPoint, 0) > 0) {
+            // Doc's value is too high, in this dimension
+            return;
+          }
+
+          // Doc is in-bounds
+          adder.add(docID);
+        }
+
+        @Override
+        public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {
+          if (StringHelper.compare(bytesPerDim, minPackedValue, 0, upperPoint, 0) > 0 ||
+              StringHelper.compare(bytesPerDim, maxPackedValue, 0, lowerPoint, 0) < 0) {
+            return Relation.CELL_OUTSIDE_QUERY;
+          }
+
+          if (StringHelper.compare(bytesPerDim, minPackedValue, 0, lowerPoint, 0) < 0 ||
+              StringHelper.compare(bytesPerDim, maxPackedValue, 0, upperPoint, 0) > 0) {
+            return Relation.CELL_CROSSES_QUERY;
+          }
+
+          return Relation.CELL_INSIDE_QUERY;
+        }
+      };
+      if (values.estimatePointCount(visitor) >= it.cost() / 32) { // runs in O(log(numPoints))
+        // the new range is not selective enough to be worthwhile
+        return;
+      }
+      values.intersect(visitor);
+      this.it = result.build().iterator();
+    }
+
+  }
+
+}
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/TestDistanceQuery.java b/lucene/sandbox/src/test/org/apache/lucene/search/TestDistanceQuery.java
new file mode 100644
index 0000000..1ff220b
--- /dev/null
+++ b/lucene/sandbox/src/test/org/apache/lucene/search/TestDistanceQuery.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import java.util.function.DoubleFunction;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.LongPoint;
+import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.queries.function.FunctionScoreQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestDistanceQuery extends LuceneTestCase {
+
+  public void testRandom() throws Exception {
+    Directory dir = newDirectory();
+    IndexWriter w = new IndexWriter(dir, new IndexWriterConfig());
+    Document d = new Document();
+    LongPoint p = new LongPoint("foo", 0L);
+    NumericDocValuesField dv = new NumericDocValuesField("foo", 0L);
+    d.add(p);
+    d.add(dv);
+    for (int i = 0; i < 1000000; ++i) {
+      long v = random().nextInt(1000000);
+      p.setLongValue(v);
+      dv.setLongValue(v);
+      w.addDocument(d);
+    }
+    DirectoryReader reader = DirectoryReader.open(w);
+    w.close();
+    IndexSearcher searcher = new IndexSearcher(reader);
+    long origin = 100000;
+    DoubleValuesSource scores = DoubleValuesSource.fromField("foo", l -> 1.0 / (1.0 + Math.abs((double) l - origin)));
+
+    FunctionScoreQuery query1 = new FunctionScoreQuery(new MatchAllDocsQuery(), scores);
+
+    DoubleFunction<byte[][]> scoreToRange = score -> {
+      double distance1p = 1 / score;
+      // round up
+      // TODO: overflow?
+      long distance = 1L + (long) Math.ceil(Math.nextUp(distance1p));
+      long low = origin - distance;
+      long high = origin + distance;
+      byte[] encodedLow = new byte[Long.BYTES];
+      LongPoint.encodeDimension(low, encodedLow, 0);
+      byte[] encodedHigh = new byte[Long.BYTES];
+      LongPoint.encodeDimension(high, encodedHigh, 0);
+      return new byte[][] { encodedLow, encodedHigh };
+    };
+
+    DistanceQuery query2 = new DistanceQuery("foo", scores, scoreToRange, "abcde");
+    QueryUtils.check(random(), query2, searcher);
+
+    ScoreDoc[] sd1 = searcher.search(query1, 10).scoreDocs;
+    TopScoreDocCollector collector = TopScoreDocCollector.create(10, null, false);
+    searcher.search(query2, collector);
+    ScoreDoc[] sd2 = collector.topDocs().scoreDocs;
+    CheckHits.checkEqual(query1, sd1, sd2);
+
+    reader.close();
+    dir.close();
+  }
+
+}
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java b/lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java
index b6062a2..1888d2c 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java
@@ -65,7 +65,7 @@ public class AssertingScorer extends Scorer {
   }
 
   @Override
-  public void setMinCompetitiveScore(float score) {
+  public void setMinCompetitiveScore(float score) throws IOException {
     assert scoreMode == ScoreMode.TOP_SCORES;
     assert Float.isNaN(score) == false;
     assert score >= minCompetitiveScore;
