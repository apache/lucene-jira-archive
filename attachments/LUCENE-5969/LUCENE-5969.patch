diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/BitVector.java branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/BitVector.java
--- trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/BitVector.java	1969-12-31 19:00:00.000000000 -0500
+++ branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/BitVector.java	2014-09-25 22:06:32.001457904 -0400
@@ -0,0 +1,410 @@
+package org.apache.lucene.codecs.lucene40;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.index.IndexFormatTooOldException;
+import org.apache.lucene.store.ChecksumIndexInput;
+import org.apache.lucene.store.CompoundFileDirectory;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.util.BitUtil;
+import org.apache.lucene.util.MutableBits;
+
+/** Optimized implementation of a vector of bits.  This is more-or-less like
+ *  java.util.BitSet, but also includes the following:
+ *  <ul>
+ *  <li>a count() method, which efficiently computes the number of one bits;</li>
+ *  <li>optimized read from and write to disk;</li>
+ *  <li>inlinable get() method;</li>
+ *  <li>store and load, as bit set or d-gaps, depending on sparseness;</li> 
+ *  </ul>
+ *
+ *  @lucene.internal
+ */
+// pkg-private: if this thing is generally useful then it can go back in .util,
+// but the serialization must be here underneath the codec.
+final class BitVector implements Cloneable, MutableBits {
+
+  private byte[] bits;
+  private int size;
+  private int count;
+  private int version;
+
+  /** Constructs a vector capable of holding <code>n</code> bits. */
+  public BitVector(int n) {
+    size = n;
+    bits = new byte[getNumBytes(size)];
+    count = 0;
+  }
+
+  BitVector(byte[] bits, int size) {
+    this.bits = bits;
+    this.size = size;
+    count = -1;
+  }
+  
+  private int getNumBytes(int size) {
+    int bytesLength = size >>> 3;
+    if ((size & 7) != 0) {
+      bytesLength++;
+    }
+    return bytesLength;
+  }
+  
+  @Override
+  public BitVector clone() {
+    byte[] copyBits = new byte[bits.length];
+    System.arraycopy(bits, 0, copyBits, 0, bits.length);
+    BitVector clone = new BitVector(copyBits, size);
+    clone.count = count;
+    return clone;
+  }
+  
+  /** Sets the value of <code>bit</code> to one. */
+  public final void set(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
+    }
+    bits[bit >> 3] |= 1 << (bit & 7);
+    count = -1;
+  }
+
+  /** Sets the value of <code>bit</code> to true, and
+   *  returns true if bit was already set */
+  public final boolean getAndSet(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
+    }
+    final int pos = bit >> 3;
+    final int v = bits[pos];
+    final int flag = 1 << (bit & 7);
+    if ((flag & v) != 0)
+      return true;
+    else {
+      bits[pos] = (byte) (v | flag);
+      if (count != -1) {
+        count++;
+        assert count <= size;
+      }
+      return false;
+    }
+  }
+
+  /** Sets the value of <code>bit</code> to zero. */
+  @Override
+  public final void clear(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    bits[bit >> 3] &= ~(1 << (bit & 7));
+    count = -1;
+  }
+
+  public final boolean getAndClear(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    final int pos = bit >> 3;
+    final int v = bits[pos];
+    final int flag = 1 << (bit & 7);
+    if ((flag & v) == 0) {
+      return false;
+    } else {
+      bits[pos] &= ~flag;
+      if (count != -1) {
+        count--;
+        assert count >= 0;
+      }
+      return true;
+    }
+  }
+
+  /** Returns <code>true</code> if <code>bit</code> is one and
+    <code>false</code> if it is zero. */
+  @Override
+  public final boolean get(int bit) {
+    assert bit >= 0 && bit < size: "bit " + bit + " is out of bounds 0.." + (size-1);
+    return (bits[bit >> 3] & (1 << (bit & 7))) != 0;
+  }
+
+  /** Returns the number of bits in this vector.  This is also one greater than
+    the number of the largest valid bit number. */
+  public final int size() {
+    return size;
+  }
+
+  @Override
+  public int length() {
+    return size;
+  }
+
+  /** Returns the total number of one bits in this vector.  This is efficiently
+    computed and cached, so that, if the vector is not changed, no
+    recomputation is done for repeated calls. */
+  public final int count() {
+    // if the vector has been modified
+    if (count == -1) {
+      int c = 0;
+      int end = bits.length;
+      for (int i = 0; i < end; i++) {
+        c += BitUtil.bitCount(bits[i]);  // sum bits per byte
+      }
+      count = c;
+    }
+    assert count <= size: "count=" + count + " size=" + size;
+    return count;
+  }
+
+  /** For testing */
+  public final int getRecomputedCount() {
+    int c = 0;
+    int end = bits.length;
+    for (int i = 0; i < end; i++) {
+      c += BitUtil.bitCount(bits[i]);  // sum bits per byte
+    }
+    return c;
+  }
+
+
+
+  private static String CODEC = "BitVector";
+
+  // Version before version tracking was added:
+  public final static int VERSION_PRE = -1;
+
+  // First version:
+  public final static int VERSION_START = 0;
+
+  // Changed DGaps to encode gaps between cleared bits, not
+  // set:
+  public final static int VERSION_DGAPS_CLEARED = 1;
+  
+  // added checksum
+  public final static int VERSION_CHECKSUM = 2;
+
+  // Increment version to change it:
+  public final static int VERSION_CURRENT = VERSION_CHECKSUM;
+
+  public int getVersion() {
+    return version;
+  }
+
+  /** Writes this vector to the file <code>name</code> in Directory
+    <code>d</code>, in a format that can be read by the constructor {@link
+    #BitVector(Directory, String, IOContext)}.  */
+  public final void write(Directory d, String name, IOContext context) throws IOException {
+    assert !(d instanceof CompoundFileDirectory);
+    try (IndexOutput output = d.createOutput(name, context)) {
+      output.writeInt(-2);
+      CodecUtil.writeHeader(output, CODEC, VERSION_CURRENT);
+      if (isSparse()) { 
+        // sparse bit-set more efficiently saved as d-gaps.
+        writeClearedDgaps(output);
+      } else {
+        writeBits(output);
+      }
+      CodecUtil.writeFooter(output);
+      assert verifyCount();
+    }
+  }
+
+  /** Invert all bits */
+  public void invertAll() {
+    if (count != -1) {
+      count = size - count;
+    }
+    if (bits.length > 0) {
+      for(int idx=0;idx<bits.length;idx++) {
+        bits[idx] = (byte) (~bits[idx]);
+      }
+      clearUnusedBits();
+    }
+  }
+
+  private void clearUnusedBits() {
+    // Take care not to invert the "unused" bits in the
+    // last byte:
+    if (bits.length > 0) {
+      final int lastNBits = size & 7;
+      if (lastNBits != 0) {
+        final int mask = (1 << lastNBits)-1;
+        bits[bits.length-1] &= mask;
+      }
+    }
+  }
+
+  /** Set all bits */
+  public void setAll() {
+    Arrays.fill(bits, (byte) 0xff);
+    clearUnusedBits();
+    count = size;
+  }
+     
+  /** Write as a bit set */
+  private void writeBits(IndexOutput output) throws IOException {
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    output.writeBytes(bits, bits.length);
+  }
+  
+  /** Write as a d-gaps list */
+  private void writeClearedDgaps(IndexOutput output) throws IOException {
+    output.writeInt(-1);            // mark using d-gaps                         
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    int last=0;
+    int numCleared = size()-count();
+    for (int i=0; i<bits.length && numCleared>0; i++) {
+      if (bits[i] != (byte) 0xff) {
+        output.writeVInt(i-last);
+        output.writeByte(bits[i]);
+        last = i;
+        numCleared -= (8-BitUtil.bitCount(bits[i]));
+        assert numCleared >= 0 || (i == (bits.length-1) && numCleared == -(8-(size&7)));
+      }
+    }
+  }
+
+  /** Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. */
+  private boolean isSparse() {
+
+    final int clearedCount = size() - count();
+    if (clearedCount == 0) {
+      return true;
+    }
+
+    final int avgGapLength = bits.length / clearedCount;
+
+    // expected number of bytes for vInt encoding of each gap
+    final int expectedDGapBytes;
+    if (avgGapLength <= (1<< 7)) {
+      expectedDGapBytes = 1;
+    } else if (avgGapLength <= (1<<14)) {
+      expectedDGapBytes = 2;
+    } else if (avgGapLength <= (1<<21)) {
+      expectedDGapBytes = 3;
+    } else if (avgGapLength <= (1<<28)) {
+      expectedDGapBytes = 4;
+    } else {
+      expectedDGapBytes = 5;
+    }
+
+    // +1 because we write the byte itself that contains the
+    // set bit
+    final int bytesPerSetBit = expectedDGapBytes + 1;
+    
+    // note: adding 32 because we start with ((int) -1) to indicate d-gaps format.
+    final long expectedBits = 32 + 8 * bytesPerSetBit * clearedCount;
+
+    // note: factor is for read/write of byte-arrays being faster than vints.  
+    final long factor = 10;  
+    return factor * expectedBits < size();
+  }
+
+  /** Constructs a bit vector from the file <code>name</code> in Directory
+    <code>d</code>, as written by the {@link #write} method.
+    */
+  public BitVector(Directory d, String name, IOContext context) throws IOException {
+    try (ChecksumIndexInput input = d.openChecksumInput(name, context)) {
+      final int firstInt = input.readInt();
+
+      if (firstInt == -2) {
+        // New format, with full header & version:
+        version = CodecUtil.checkHeader(input, CODEC, VERSION_START, VERSION_CURRENT);
+        size = input.readInt();
+      } else {
+        // we started writing full header well before 4.0
+        throw new IndexFormatTooOldException(input.toString(), Integer.toString(firstInt));
+      }
+      if (size == -1) {
+        if (version >= VERSION_DGAPS_CLEARED) {
+          readClearedDgaps(input);
+        } else {
+          readSetDgaps(input);
+        }
+      } else {
+        readBits(input);
+      }
+
+      if (version < VERSION_DGAPS_CLEARED) {
+        invertAll();
+      }
+
+      if (version >= VERSION_CHECKSUM) {
+        CodecUtil.checkFooter(input);
+      } else {
+        CodecUtil.checkEOF(input);
+      }
+      assert verifyCount();
+    }
+  }
+
+  // asserts only
+  private boolean verifyCount() {
+    assert count != -1;
+    final int countSav = count;
+    count = -1;
+    assert countSav == count(): "saved count was " + countSav + " but recomputed count is " + count;
+    return true;
+  }
+
+  /** Read as a bit set */
+  private void readBits(IndexInput input) throws IOException {
+    count = input.readInt();        // read count
+    bits = new byte[getNumBytes(size)];     // allocate bits
+    input.readBytes(bits, 0, bits.length);
+  }
+
+  /** read as a d-gaps list */ 
+  private void readSetDgaps(IndexInput input) throws IOException {
+    size = input.readInt();       // (re)read size
+    count = input.readInt();        // read count
+    bits = new byte[getNumBytes(size)];     // allocate bits
+    int last=0;
+    int n = count();
+    while (n>0) {
+      last += input.readVInt();
+      bits[last] = input.readByte();
+      n -= BitUtil.bitCount(bits[last]);
+      assert n >= 0;
+    }          
+  }
+
+  /** read as a d-gaps cleared bits list */ 
+  private void readClearedDgaps(IndexInput input) throws IOException {
+    size = input.readInt();       // (re)read size
+    count = input.readInt();        // read count
+    bits = new byte[getNumBytes(size)];     // allocate bits
+    Arrays.fill(bits, (byte) 0xff);
+    clearUnusedBits();
+    int last=0;
+    int numCleared = size()-count();
+    while (numCleared>0) {
+      last += input.readVInt();
+      bits[last] = input.readByte();
+      numCleared -= 8-BitUtil.bitCount(bits[last]);
+      assert numCleared >= 0 || (last == (bits.length-1) && numCleared == -(8-(size&7)));
+    }
+  }
+}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosReader.java branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosReader.java
--- trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosReader.java	2014-09-26 11:20:12.738287193 -0400
+++ branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosReader.java	2014-09-25 09:31:11.436668671 -0400
@@ -29,6 +29,7 @@
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.FieldInfo.DocValuesType;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
@@ -49,8 +50,8 @@
   }
 
   @Override
-  public FieldInfos read(Directory directory, String segmentName, String segmentSuffix, IOContext iocontext) throws IOException {
-    final String fileName = IndexFileNames.segmentFileName(segmentName, "", Lucene40FieldInfosFormat.FIELD_INFOS_EXTENSION);
+  public FieldInfos read(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, IOContext iocontext) throws IOException {
+    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, "", Lucene40FieldInfosFormat.FIELD_INFOS_EXTENSION);
     IndexInput input = directory.openInput(fileName, iocontext);
     
     boolean success = false;
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java
--- trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java	1969-12-31 19:00:00.000000000 -0500
+++ branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java	2014-09-25 22:06:32.009457904 -0400
@@ -0,0 +1,120 @@
+package org.apache.lucene.codecs.lucene40;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Collection;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.codecs.LiveDocsFormat;
+import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentCommitInfo;
+import org.apache.lucene.store.DataOutput; // javadocs
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.MutableBits;
+
+/**
+ * Lucene 4.0 Live Documents Format.
+ * <p>
+ * <p>The .del file is optional, and only exists when a segment contains
+ * deletions.</p>
+ * <p>Although per-segment, this file is maintained exterior to compound segment
+ * files.</p>
+ * <p>Deletions (.del) --&gt; Format,Header,ByteCount,BitCount, Bits | DGaps (depending
+ * on Format)</p>
+ * <ul>
+ *   <li>Format,ByteSize,BitCount --&gt; {@link DataOutput#writeInt Uint32}</li>
+ *   <li>Bits --&gt; &lt;{@link DataOutput#writeByte Byte}&gt; <sup>ByteCount</sup></li>
+ *   <li>DGaps --&gt; &lt;DGap,NonOnesByte&gt; <sup>NonzeroBytesCount</sup></li>
+ *   <li>DGap --&gt; {@link DataOutput#writeVInt VInt}</li>
+ *   <li>NonOnesByte --&gt; {@link DataOutput#writeByte Byte}</li>
+ *   <li>Header --&gt; {@link CodecUtil#writeHeader CodecHeader}</li>
+ * </ul>
+ * <p>Format is 1: indicates cleared DGaps.</p>
+ * <p>ByteCount indicates the number of bytes in Bits. It is typically
+ * (SegSize/8)+1.</p>
+ * <p>BitCount indicates the number of bits that are currently set in Bits.</p>
+ * <p>Bits contains one bit for each document indexed. When the bit corresponding
+ * to a document number is cleared, that document is marked as deleted. Bit ordering
+ * is from least to most significant. Thus, if Bits contains two bytes, 0x00 and
+ * 0x02, then document 9 is marked as alive (not deleted).</p>
+ * <p>DGaps represents sparse bit-vectors more efficiently than Bits. It is made
+ * of DGaps on indexes of nonOnes bytes in Bits, and the nonOnes bytes themselves.
+ * The number of nonOnes bytes in Bits (NonOnesBytesCount) is not stored.</p>
+ * <p>For example, if there are 8000 bits and only bits 10,12,32 are cleared, DGaps
+ * would be used:</p>
+ * <p>(VInt) 1 , (byte) 20 , (VInt) 3 , (Byte) 1</p>
+ */
+public class Lucene40LiveDocsFormat extends LiveDocsFormat {
+
+  /** Extension of deletes */
+  static final String DELETES_EXTENSION = "del";
+
+  /** Sole constructor. */
+  public Lucene40LiveDocsFormat() {
+  }
+  
+  @Override
+  public MutableBits newLiveDocs(int size) throws IOException {
+    BitVector bitVector = new BitVector(size);
+    bitVector.invertAll();
+    return bitVector;
+  }
+
+  @Override
+  public MutableBits newLiveDocs(Bits existing) throws IOException {
+    final BitVector liveDocs = (BitVector) existing;
+    return liveDocs.clone();
+  }
+
+  @Override
+  public Bits readLiveDocs(Directory dir, SegmentCommitInfo info, IOContext context) throws IOException {
+    String filename = IndexFileNames.fileNameFromGeneration(info.info.name, DELETES_EXTENSION, info.getDelGen());
+    final BitVector liveDocs = new BitVector(dir, filename, context);
+    if (liveDocs.length() != info.info.getDocCount()) {
+      throw new CorruptIndexException("liveDocs.length()=" + liveDocs.length() + "info.docCount=" + info.info.getDocCount(), filename);
+    }
+    if (liveDocs.count() != info.info.getDocCount() - info.getDelCount()) {
+      throw new CorruptIndexException("liveDocs.count()=" + liveDocs.count() + " info.docCount=" + info.info.getDocCount() + " info.getDelCount()=" + info.getDelCount(), filename);
+    }
+    return liveDocs;
+  }
+
+  @Override
+  public void writeLiveDocs(MutableBits bits, Directory dir, SegmentCommitInfo info, int newDelCount, IOContext context) throws IOException {
+    String filename = IndexFileNames.fileNameFromGeneration(info.info.name, DELETES_EXTENSION, info.getNextDelGen());
+    final BitVector liveDocs = (BitVector) bits;
+    if (liveDocs.length() != info.info.getDocCount()) {
+      throw new CorruptIndexException("liveDocs.length()=" + liveDocs.length() + "info.docCount=" + info.info.getDocCount(), filename);
+    }
+    if (liveDocs.count() != info.info.getDocCount() - info.getDelCount() - newDelCount) {
+      throw new CorruptIndexException("liveDocs.count()=" + liveDocs.count() + " info.docCount=" + info.info.getDocCount() + " info.getDelCount()=" + info.getDelCount() + " newDelCount=" + newDelCount, filename);
+    }
+    liveDocs.write(dir, filename, context);
+  }
+
+  @Override
+  public void files(SegmentCommitInfo info, Collection<String> files) throws IOException {
+    if (info.hasDeletions()) {
+      files.add(IndexFileNames.fileNameFromGeneration(info.info.name, DELETES_EXTENSION, info.getDelGen()));
+    }
+  }
+}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoFormat.java branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoFormat.java
--- trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoFormat.java	2014-09-26 11:20:12.738287193 -0400
+++ branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoFormat.java	2014-09-25 09:12:13.064648847 -0400
@@ -72,7 +72,6 @@
 @Deprecated
 public class Lucene40SegmentInfoFormat extends SegmentInfoFormat {
   private final SegmentInfoReader reader = new Lucene40SegmentInfoReader();
-  private final SegmentInfoWriter writer = new Lucene40SegmentInfoWriter();
 
   /** Sole constructor. */
   public Lucene40SegmentInfoFormat() {
@@ -83,11 +82,9 @@
     return reader;
   }
 
-  // we must unfortunately support write, to allow addIndexes to write a new .si with rewritten filenames:
-  // see LUCENE-5377
   @Override
   public SegmentInfoWriter getSegmentInfoWriter() {
-    return writer;
+    throw new UnsupportedOperationException("this codec can only be used for reading");
   }
 
   /** File extension used to store {@link SegmentInfo}. */
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java
--- trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java	2014-09-26 11:20:12.738287193 -0400
+++ branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java	2014-09-25 09:40:38.652678549 -0400
@@ -73,7 +73,7 @@
       
       CodecUtil.checkEOF(input);
 
-      final SegmentInfo si = new SegmentInfo(dir, version, segment, docCount, isCompoundFile, null, diagnostics);
+      final SegmentInfo si = new SegmentInfo(dir, version, segment, docCount, isCompoundFile, null, diagnostics, null);
       si.setFiles(files);
 
       success = true;
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java
--- trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java	2014-09-26 11:20:12.738287193 -0400
+++ branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,77 +0,0 @@
-package org.apache.lucene.codecs.lucene40;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Collections;
-
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.codecs.SegmentInfoWriter;
-import org.apache.lucene.index.FieldInfos;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.IOUtils;
-
-/**
- * Lucene 4.0 implementation of {@link SegmentInfoWriter}.
- * 
- * @see Lucene40SegmentInfoFormat
- * @lucene.experimental
- */
-@Deprecated
-public class Lucene40SegmentInfoWriter extends SegmentInfoWriter {
-
-  /** Sole constructor. */
-  public Lucene40SegmentInfoWriter() {
-  }
-
-  /** Save a single segment's info. */
-  @Override
-  public void write(Directory dir, SegmentInfo si, FieldInfos fis, IOContext ioContext) throws IOException {
-    final String fileName = IndexFileNames.segmentFileName(si.name, "", Lucene40SegmentInfoFormat.SI_EXTENSION);
-    si.addFile(fileName);
-
-    final IndexOutput output = dir.createOutput(fileName, ioContext);
-
-    boolean success = false;
-    try {
-      CodecUtil.writeHeader(output, Lucene40SegmentInfoFormat.CODEC_NAME, Lucene40SegmentInfoFormat.VERSION_CURRENT);
-      // Write the Lucene version that created this segment, since 3.1
-      output.writeString(si.getVersion().toString());
-      output.writeInt(si.getDocCount());
-
-      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));
-      output.writeStringStringMap(si.getDiagnostics());
-      output.writeStringStringMap(Collections.<String,String>emptyMap());
-      output.writeStringSet(si.files());
-
-      success = true;
-    } finally {
-      if (!success) {
-        IOUtils.closeWhileHandlingException(output);
-        // TODO: why must we do this? do we not get tracking dir wrapper?
-        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);
-      } else {
-        output.close();
-      }
-    }
-  }
-}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene42/Lucene42FieldInfosReader.java branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene42/Lucene42FieldInfosReader.java
--- trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene42/Lucene42FieldInfosReader.java	2014-09-26 11:20:12.742287193 -0400
+++ branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene42/Lucene42FieldInfosReader.java	2014-09-25 09:30:51.836668330 -0400
@@ -29,6 +29,7 @@
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.FieldInfo.DocValuesType;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
@@ -49,8 +50,8 @@
   }
 
   @Override
-  public FieldInfos read(Directory directory, String segmentName, String segmentSuffix, IOContext iocontext) throws IOException {
-    final String fileName = IndexFileNames.segmentFileName(segmentName, "", Lucene42FieldInfosFormat.EXTENSION);
+  public FieldInfos read(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, IOContext iocontext) throws IOException {
+    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, "", Lucene42FieldInfosFormat.EXTENSION);
     IndexInput input = directory.openInput(fileName, iocontext);
     
     boolean success = false;
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46Codec.java branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46Codec.java
--- trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46Codec.java	2014-09-26 11:20:12.746287193 -0400
+++ branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46Codec.java	2014-09-25 08:42:01.052617292 -0400
@@ -100,7 +100,7 @@
   }
   
   @Override
-  public final SegmentInfoFormat segmentInfoFormat() {
+  public SegmentInfoFormat segmentInfoFormat() {
     return segmentInfosFormat;
   }
   
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosFormat.java branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosFormat.java
--- trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosFormat.java	1969-12-31 19:00:00.000000000 -0500
+++ branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosFormat.java	2014-09-25 08:40:12.492615402 -0400
@@ -0,0 +1,129 @@
+package org.apache.lucene.codecs.lucene46;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.codecs.DocValuesFormat;
+import org.apache.lucene.codecs.FieldInfosFormat;
+import org.apache.lucene.codecs.FieldInfosReader;
+import org.apache.lucene.codecs.FieldInfosWriter;
+import org.apache.lucene.index.FieldInfo.DocValuesType;
+import org.apache.lucene.store.DataOutput;
+
+/**
+ * Lucene 4.6 Field Infos format.
+ * <p>
+ * <p>Field names are stored in the field info file, with suffix <tt>.fnm</tt>.</p>
+ * <p>FieldInfos (.fnm) --&gt; Header,FieldsCount, &lt;FieldName,FieldNumber,
+ * FieldBits,DocValuesBits,DocValuesGen,Attributes&gt; <sup>FieldsCount</sup>,Footer</p>
+ * <p>Data types:
+ * <ul>
+ *   <li>Header --&gt; {@link CodecUtil#checkHeader CodecHeader}</li>
+ *   <li>FieldsCount --&gt; {@link DataOutput#writeVInt VInt}</li>
+ *   <li>FieldName --&gt; {@link DataOutput#writeString String}</li>
+ *   <li>FieldBits, DocValuesBits --&gt; {@link DataOutput#writeByte Byte}</li>
+ *   <li>FieldNumber --&gt; {@link DataOutput#writeInt VInt}</li>
+ *   <li>Attributes --&gt; {@link DataOutput#writeStringStringMap Map&lt;String,String&gt;}</li>
+ *   <li>DocValuesGen --&gt; {@link DataOutput#writeLong(long) Int64}</li>
+ *   <li>Footer --&gt; {@link CodecUtil#writeFooter CodecFooter}</li>
+ * </ul>
+ * </p>
+ * Field Descriptions:
+ * <ul>
+ *   <li>FieldsCount: the number of fields in this file.</li>
+ *   <li>FieldName: name of the field as a UTF-8 String.</li>
+ *   <li>FieldNumber: the field's number. Note that unlike previous versions of
+ *       Lucene, the fields are not numbered implicitly by their order in the
+ *       file, instead explicitly.</li>
+ *   <li>FieldBits: a byte containing field options.
+ *       <ul>
+ *         <li>The low-order bit is one for indexed fields, and zero for non-indexed
+ *             fields.</li>
+ *         <li>The second lowest-order bit is one for fields that have term vectors
+ *             stored, and zero for fields without term vectors.</li>
+ *         <li>If the third lowest order-bit is set (0x4), offsets are stored into
+ *             the postings list in addition to positions.</li>
+ *         <li>Fourth bit is unused.</li>
+ *         <li>If the fifth lowest-order bit is set (0x10), norms are omitted for the
+ *             indexed field.</li>
+ *         <li>If the sixth lowest-order bit is set (0x20), payloads are stored for the
+ *             indexed field.</li>
+ *         <li>If the seventh lowest-order bit is set (0x40), term frequencies and
+ *             positions omitted for the indexed field.</li>
+ *         <li>If the eighth lowest-order bit is set (0x80), positions are omitted for the
+ *             indexed field.</li>
+ *       </ul>
+ *    </li>
+ *    <li>DocValuesBits: a byte containing per-document value types. The type
+ *        recorded as two four-bit integers, with the high-order bits representing
+ *        <code>norms</code> options, and the low-order bits representing 
+ *        {@code DocValues} options. Each four-bit integer can be decoded as such:
+ *        <ul>
+ *          <li>0: no DocValues for this field.</li>
+ *          <li>1: NumericDocValues. ({@link DocValuesType#NUMERIC})</li>
+ *          <li>2: BinaryDocValues. ({@code DocValuesType#BINARY})</li>
+ *          <li>3: SortedDocValues. ({@code DocValuesType#SORTED})</li>
+ *        </ul>
+ *    </li>
+ *    <li>DocValuesGen is the generation count of the field's DocValues. If this is -1,
+ *        there are no DocValues updates to that field. Anything above zero means there 
+ *        are updates stored by {@link DocValuesFormat}.</li>
+ *    <li>Attributes: a key-value map of codec-private attributes.</li>
+ * </ul>
+ *
+ * @lucene.experimental
+ */
+public final class Lucene46FieldInfosFormat extends FieldInfosFormat {
+  private final FieldInfosReader reader = new Lucene46FieldInfosReader();
+  private final FieldInfosWriter writer = new Lucene46FieldInfosWriter();
+  
+  /** Sole constructor. */
+  public Lucene46FieldInfosFormat() {
+  }
+
+  @Override
+  public FieldInfosReader getFieldInfosReader() throws IOException {
+    return reader;
+  }
+
+  @Override
+  public FieldInfosWriter getFieldInfosWriter() throws IOException {
+    return writer;
+  }
+  
+  /** Extension of field infos */
+  static final String EXTENSION = "fnm";
+  
+  // Codec header
+  static final String CODEC_NAME = "Lucene46FieldInfos";
+  static final int FORMAT_START = 0;
+  static final int FORMAT_CHECKSUM = 1;
+  static final int FORMAT_SORTED_NUMERIC = 2;
+  static final int FORMAT_CURRENT = FORMAT_SORTED_NUMERIC;
+  
+  // Field flags
+  static final byte IS_INDEXED = 0x1;
+  static final byte STORE_TERMVECTOR = 0x2;
+  static final byte STORE_OFFSETS_IN_POSTINGS = 0x4;
+  static final byte OMIT_NORMS = 0x10;
+  static final byte STORE_PAYLOADS = 0x20;
+  static final byte OMIT_TERM_FREQ_AND_POSITIONS = 0x40;
+  static final byte OMIT_POSITIONS = -128;
+}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosReader.java branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosReader.java
--- trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosReader.java	1969-12-31 19:00:00.000000000 -0500
+++ branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosReader.java	2014-09-25 09:30:34.472668028 -0400
@@ -0,0 +1,121 @@
+package org.apache.lucene.codecs.lucene46;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Collections;
+import java.util.Map;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.codecs.FieldInfosReader;
+import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.FieldInfo.DocValuesType;
+import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.index.SegmentInfo;
+import org.apache.lucene.store.ChecksumIndexInput;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexInput;
+
+/**
+ * Lucene 4.6 FieldInfos reader.
+ * 
+ * @lucene.experimental
+ * @see Lucene46FieldInfosFormat
+ */
+final class Lucene46FieldInfosReader extends FieldInfosReader {
+
+  /** Sole constructor. */
+  public Lucene46FieldInfosReader() {
+  }
+
+  @Override
+  public FieldInfos read(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, IOContext context) throws IOException {
+    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene46FieldInfosFormat.EXTENSION);
+    try (ChecksumIndexInput input = directory.openChecksumInput(fileName, context)) {
+      int codecVersion = CodecUtil.checkHeader(input, Lucene46FieldInfosFormat.CODEC_NAME, 
+                                                      Lucene46FieldInfosFormat.FORMAT_START, 
+                                                      Lucene46FieldInfosFormat.FORMAT_CURRENT);
+
+      final int size = input.readVInt(); //read in the size
+      FieldInfo infos[] = new FieldInfo[size];
+
+      for (int i = 0; i < size; i++) {
+        String name = input.readString();
+        final int fieldNumber = input.readVInt();
+        if (fieldNumber < 0) {
+          throw new CorruptIndexException("invalid field number for field: " + name + ", fieldNumber=" + fieldNumber, input);
+        }
+        byte bits = input.readByte();
+        boolean isIndexed = (bits & Lucene46FieldInfosFormat.IS_INDEXED) != 0;
+        boolean storeTermVector = (bits & Lucene46FieldInfosFormat.STORE_TERMVECTOR) != 0;
+        boolean omitNorms = (bits & Lucene46FieldInfosFormat.OMIT_NORMS) != 0;
+        boolean storePayloads = (bits & Lucene46FieldInfosFormat.STORE_PAYLOADS) != 0;
+        final IndexOptions indexOptions;
+        if (!isIndexed) {
+          indexOptions = null;
+        } else if ((bits & Lucene46FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS) != 0) {
+          indexOptions = IndexOptions.DOCS_ONLY;
+        } else if ((bits & Lucene46FieldInfosFormat.OMIT_POSITIONS) != 0) {
+          indexOptions = IndexOptions.DOCS_AND_FREQS;
+        } else if ((bits & Lucene46FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS) != 0) {
+          indexOptions = IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS;
+        } else {
+          indexOptions = IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;
+        }
+
+        // DV Types are packed in one byte
+        byte val = input.readByte();
+        final DocValuesType docValuesType = getDocValuesType(input, (byte) (val & 0x0F));
+        final DocValuesType normsType = getDocValuesType(input, (byte) ((val >>> 4) & 0x0F));
+        final long dvGen = input.readLong();
+        final Map<String,String> attributes = input.readStringStringMap();
+        infos[i] = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, 
+          omitNorms, storePayloads, indexOptions, docValuesType, normsType, dvGen, Collections.unmodifiableMap(attributes));
+      }
+      
+      if (codecVersion >= Lucene46FieldInfosFormat.FORMAT_CHECKSUM) {
+        CodecUtil.checkFooter(input);
+      } else {
+        CodecUtil.checkEOF(input);
+      }
+      return new FieldInfos(infos);
+    }
+  }
+  
+  private static DocValuesType getDocValuesType(IndexInput input, byte b) throws IOException {
+    if (b == 0) {
+      return null;
+    } else if (b == 1) {
+      return DocValuesType.NUMERIC;
+    } else if (b == 2) {
+      return DocValuesType.BINARY;
+    } else if (b == 3) {
+      return DocValuesType.SORTED;
+    } else if (b == 4) {
+      return DocValuesType.SORTED_SET;
+    } else if (b == 5) {
+      return DocValuesType.SORTED_NUMERIC;
+    } else {
+      throw new CorruptIndexException("invalid docvalues byte: " + b, input);
+    }
+  }
+}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosWriter.java branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosWriter.java
--- trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosWriter.java	1969-12-31 19:00:00.000000000 -0500
+++ branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosWriter.java	2014-09-25 09:27:45.100665078 -0400
@@ -0,0 +1,103 @@
+package org.apache.lucene.codecs.lucene46;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.codecs.FieldInfosWriter;
+import org.apache.lucene.index.FieldInfo.DocValuesType;
+import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentInfo;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+
+/**
+ * Lucene 4.6 FieldInfos writer.
+ * 
+ * @see Lucene46FieldInfosFormat
+ * @lucene.experimental
+ */
+final class Lucene46FieldInfosWriter extends FieldInfosWriter {
+  
+  /** Sole constructor. */
+  public Lucene46FieldInfosWriter() {
+  }
+  
+  @Override
+  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {
+    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene46FieldInfosFormat.EXTENSION);
+    try (IndexOutput output = directory.createOutput(fileName, context)) {
+      CodecUtil.writeHeader(output, Lucene46FieldInfosFormat.CODEC_NAME, Lucene46FieldInfosFormat.FORMAT_CURRENT);
+      output.writeVInt(infos.size());
+      for (FieldInfo fi : infos) {
+        IndexOptions indexOptions = fi.getIndexOptions();
+        byte bits = 0x0;
+        if (fi.hasVectors()) bits |= Lucene46FieldInfosFormat.STORE_TERMVECTOR;
+        if (fi.omitsNorms()) bits |= Lucene46FieldInfosFormat.OMIT_NORMS;
+        if (fi.hasPayloads()) bits |= Lucene46FieldInfosFormat.STORE_PAYLOADS;
+        if (fi.isIndexed()) {
+          bits |= Lucene46FieldInfosFormat.IS_INDEXED;
+          assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !fi.hasPayloads();
+          if (indexOptions == IndexOptions.DOCS_ONLY) {
+            bits |= Lucene46FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS;
+          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {
+            bits |= Lucene46FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS;
+          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS) {
+            bits |= Lucene46FieldInfosFormat.OMIT_POSITIONS;
+          }
+        }
+        output.writeString(fi.name);
+        output.writeVInt(fi.number);
+        output.writeByte(bits);
+
+        // pack the DV types in one byte
+        final byte dv = docValuesByte(fi.getDocValuesType());
+        final byte nrm = docValuesByte(fi.getNormType());
+        assert (dv & (~0xF)) == 0 && (nrm & (~0x0F)) == 0;
+        byte val = (byte) (0xff & ((nrm << 4) | dv));
+        output.writeByte(val);
+        output.writeLong(fi.getDocValuesGen());
+        output.writeStringStringMap(fi.attributes());
+      }
+      CodecUtil.writeFooter(output);
+    }
+  }
+  
+  private static byte docValuesByte(DocValuesType type) {
+    if (type == null) {
+      return 0;
+    } else if (type == DocValuesType.NUMERIC) {
+      return 1;
+    } else if (type == DocValuesType.BINARY) {
+      return 2;
+    } else if (type == DocValuesType.SORTED) {
+      return 3;
+    } else if (type == DocValuesType.SORTED_SET) {
+      return 4;
+    } else if (type == DocValuesType.SORTED_NUMERIC) {
+      return 5;
+    } else {
+      throw new AssertionError();
+    }
+  }  
+}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoFormat.java branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoFormat.java
--- trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoFormat.java	1969-12-31 19:00:00.000000000 -0500
+++ branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoFormat.java	2014-09-26 01:01:31.465640747 -0400
@@ -0,0 +1,91 @@
+package org.apache.lucene.codecs.lucene46;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.codecs.SegmentInfoFormat;
+import org.apache.lucene.codecs.SegmentInfoReader;
+import org.apache.lucene.codecs.SegmentInfoWriter;
+import org.apache.lucene.index.IndexWriter; // javadocs
+import org.apache.lucene.index.SegmentInfo; // javadocs
+import org.apache.lucene.index.SegmentInfos; // javadocs
+import org.apache.lucene.store.DataOutput; // javadocs
+
+/**
+ * Lucene 4.6 Segment info format.
+ * <p>
+ * Files:
+ * <ul>
+ *   <li><tt>.si</tt>: Header, SegVersion, SegSize, IsCompoundFile, Diagnostics, Files, Footer
+ * </ul>
+ * </p>
+ * Data types:
+ * <p>
+ * <ul>
+ *   <li>Header --&gt; {@link CodecUtil#writeHeader CodecHeader}</li>
+ *   <li>SegSize --&gt; {@link DataOutput#writeInt Int32}</li>
+ *   <li>SegVersion --&gt; {@link DataOutput#writeString String}</li>
+ *   <li>Files --&gt; {@link DataOutput#writeStringSet Set&lt;String&gt;}</li>
+ *   <li>Diagnostics --&gt; {@link DataOutput#writeStringStringMap Map&lt;String,String&gt;}</li>
+ *   <li>IsCompoundFile --&gt; {@link DataOutput#writeByte Int8}</li>
+ *   <li>Footer --&gt; {@link CodecUtil#writeFooter CodecFooter}</li>
+ * </ul>
+ * </p>
+ * Field Descriptions:
+ * <p>
+ * <ul>
+ *   <li>SegVersion is the code version that created the segment.</li>
+ *   <li>SegSize is the number of documents contained in the segment index.</li>
+ *   <li>IsCompoundFile records whether the segment is written as a compound file or
+ *       not. If this is -1, the segment is not a compound file. If it is 1, the segment
+ *       is a compound file.</li>
+ *   <li>The Diagnostics Map is privately written by {@link IndexWriter}, as a debugging aid,
+ *       for each segment it creates. It includes metadata like the current Lucene
+ *       version, OS, Java version, why the segment was created (merge, flush,
+ *       addIndexes), etc.</li>
+ *   <li>Files is a list of files referred to by this segment.</li>
+ * </ul>
+ * </p>
+ * 
+ * @see SegmentInfos
+ * @lucene.experimental
+ */
+public class Lucene46SegmentInfoFormat extends SegmentInfoFormat {
+  private final SegmentInfoReader reader = new Lucene46SegmentInfoReader();
+
+  /** Sole constructor. */
+  public Lucene46SegmentInfoFormat() {
+  }
+  
+  @Override
+  public SegmentInfoReader getSegmentInfoReader() {
+    return reader;
+  }
+
+  @Override
+  public SegmentInfoWriter getSegmentInfoWriter() {
+    throw new UnsupportedOperationException("this codec can only be used for reading");
+  }
+
+  /** File extension used to store {@link SegmentInfo}. */
+  public final static String SI_EXTENSION = "si";
+  static final String CODEC_NAME = "Lucene46SegmentInfo";
+  static final int VERSION_START = 0;
+  static final int VERSION_CHECKSUM = 1;
+  static final int VERSION_CURRENT = VERSION_CHECKSUM;
+}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java
--- trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java	1969-12-31 19:00:00.000000000 -0500
+++ branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java	2014-09-26 01:01:45.825640997 -0400
@@ -0,0 +1,81 @@
+package org.apache.lucene.codecs.lucene46;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.text.ParseException;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.codecs.SegmentInfoReader;
+import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentInfo;
+import org.apache.lucene.store.ChecksumIndexInput;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.util.Version;
+
+/**
+ * Lucene 4.6 implementation of {@link SegmentInfoReader}.
+ * 
+ * @see Lucene46SegmentInfoFormat
+ * @lucene.experimental
+ */
+public class Lucene46SegmentInfoReader extends SegmentInfoReader {
+
+  /** Sole constructor. */
+  public Lucene46SegmentInfoReader() {
+  }
+
+  @Override
+  public SegmentInfo read(Directory dir, String segment, IOContext context) throws IOException {
+    final String fileName = IndexFileNames.segmentFileName(segment, "", Lucene46SegmentInfoFormat.SI_EXTENSION);
+    try (ChecksumIndexInput input = dir.openChecksumInput(fileName, context)) {
+      int codecVersion = CodecUtil.checkHeader(input, Lucene46SegmentInfoFormat.CODEC_NAME,
+                                                      Lucene46SegmentInfoFormat.VERSION_START,
+                                                      Lucene46SegmentInfoFormat.VERSION_CURRENT);
+      final Version version;
+      try {
+        version = Version.parse(input.readString());
+      } catch (ParseException pe) {
+        throw new CorruptIndexException("unable to parse version string: " + pe.getMessage(), input, pe);
+      }
+
+      final int docCount = input.readInt();
+      if (docCount < 0) {
+        throw new CorruptIndexException("invalid docCount: " + docCount, input);
+      }
+      final boolean isCompoundFile = input.readByte() == SegmentInfo.YES;
+      final Map<String,String> diagnostics = input.readStringStringMap();
+      final Set<String> files = input.readStringSet();
+
+      if (codecVersion >= Lucene46SegmentInfoFormat.VERSION_CHECKSUM) {
+        CodecUtil.checkFooter(input);
+      } else {
+        CodecUtil.checkEOF(input);
+      }
+
+      final SegmentInfo si = new SegmentInfo(dir, version, segment, docCount, isCompoundFile, null, diagnostics, null);
+      si.setFiles(files);
+
+      return si;
+    }
+  }
+}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene49/Lucene49Codec.java branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene49/Lucene49Codec.java
--- trunk/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene49/Lucene49Codec.java	2014-09-26 11:20:12.746287193 -0400
+++ branch/lucene/backward-codecs/src/java/org/apache/lucene/codecs/lucene49/Lucene49Codec.java	2014-09-25 08:45:54.416621356 -0400
@@ -99,7 +99,7 @@
   }
   
   @Override
-  public final SegmentInfoFormat segmentInfoFormat() {
+  public SegmentInfoFormat segmentInfoFormat() {
     return segmentInfosFormat;
   }
   
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosWriter.java branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosWriter.java
--- trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosWriter.java	2014-09-26 11:20:12.734287193 -0400
+++ branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40FieldInfosWriter.java	2014-09-25 09:26:32.100663807 -0400
@@ -26,6 +26,7 @@
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexOutput;
@@ -45,11 +46,11 @@
   }
   
   @Override
-  public void write(Directory directory, String segmentName, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {
+  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {
     if (!segmentSuffix.isEmpty()) {
       throw new UnsupportedOperationException("4.0 does not support fieldinfo updates");
     }
-    final String fileName = IndexFileNames.segmentFileName(segmentName, "", Lucene40FieldInfosFormat.FIELD_INFOS_EXTENSION);
+    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, "", Lucene40FieldInfosFormat.FIELD_INFOS_EXTENSION);
     IndexOutput output = directory.createOutput(fileName, context);
     boolean success = false;
     try {
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40RWCodec.java branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40RWCodec.java
--- trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40RWCodec.java	2014-09-26 11:20:12.734287193 -0400
+++ branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40RWCodec.java	2014-09-25 09:14:23.764651123 -0400
@@ -7,9 +7,9 @@
 import org.apache.lucene.codecs.FieldInfosWriter;
 import org.apache.lucene.codecs.NormsFormat;
 import org.apache.lucene.codecs.PostingsFormat;
+import org.apache.lucene.codecs.SegmentInfoFormat;
 import org.apache.lucene.codecs.StoredFieldsFormat;
 import org.apache.lucene.codecs.TermVectorsFormat;
-import org.apache.lucene.util.LuceneTestCase;
 
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -74,4 +74,11 @@
   public PostingsFormat getPostingsFormatForField(String field) {
     return postings;
   }
+  
+  private static final SegmentInfoFormat segmentInfos = new Lucene40RWSegmentInfoFormat();
+
+  @Override
+  public SegmentInfoFormat segmentInfoFormat() {
+    return segmentInfos;
+  }
 }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40RWSegmentInfoFormat.java branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40RWSegmentInfoFormat.java
--- trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40RWSegmentInfoFormat.java	1969-12-31 19:00:00.000000000 -0500
+++ branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40RWSegmentInfoFormat.java	2014-09-25 09:17:54.816654799 -0400
@@ -0,0 +1,29 @@
+package org.apache.lucene.codecs.lucene40;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.codecs.SegmentInfoWriter;
+
+/** read-write version of 4.0 segmentinfos for testing */
+public class Lucene40RWSegmentInfoFormat extends Lucene40SegmentInfoFormat {
+
+  @Override
+  public SegmentInfoWriter getSegmentInfoWriter() {
+    return new Lucene40SegmentInfoWriter();
+  }
+}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java
--- trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java	1969-12-31 19:00:00.000000000 -0500
+++ branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java	2014-09-25 09:11:26.496648036 -0400
@@ -0,0 +1,77 @@
+package org.apache.lucene.codecs.lucene40;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Collections;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.codecs.SegmentInfoWriter;
+import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentInfo;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.util.IOUtils;
+
+/**
+ * Lucene 4.0 implementation of {@link SegmentInfoWriter}.
+ * 
+ * @see Lucene40SegmentInfoFormat
+ * @lucene.experimental
+ */
+@Deprecated
+public class Lucene40SegmentInfoWriter extends SegmentInfoWriter {
+
+  /** Sole constructor. */
+  public Lucene40SegmentInfoWriter() {
+  }
+
+  /** Save a single segment's info. */
+  @Override
+  public void write(Directory dir, SegmentInfo si, FieldInfos fis, IOContext ioContext) throws IOException {
+    final String fileName = IndexFileNames.segmentFileName(si.name, "", Lucene40SegmentInfoFormat.SI_EXTENSION);
+    si.addFile(fileName);
+
+    final IndexOutput output = dir.createOutput(fileName, ioContext);
+
+    boolean success = false;
+    try {
+      CodecUtil.writeHeader(output, Lucene40SegmentInfoFormat.CODEC_NAME, Lucene40SegmentInfoFormat.VERSION_CURRENT);
+      // Write the Lucene version that created this segment, since 3.1
+      output.writeString(si.getVersion().toString());
+      output.writeInt(si.getDocCount());
+
+      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));
+      output.writeStringStringMap(si.getDiagnostics());
+      output.writeStringStringMap(Collections.<String,String>emptyMap());
+      output.writeStringSet(si.files());
+
+      success = true;
+    } finally {
+      if (!success) {
+        IOUtils.closeWhileHandlingException(output);
+        // TODO: why must we do this? do we not get tracking dir wrapper?
+        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);
+      } else {
+        output.close();
+      }
+    }
+  }
+}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene41/Lucene41RWCodec.java branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene41/Lucene41RWCodec.java
--- trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene41/Lucene41RWCodec.java	2014-09-26 11:20:12.714287193 -0400
+++ branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene41/Lucene41RWCodec.java	2014-09-25 09:14:38.044651372 -0400
@@ -6,12 +6,14 @@
 import org.apache.lucene.codecs.FieldInfosFormat;
 import org.apache.lucene.codecs.FieldInfosWriter;
 import org.apache.lucene.codecs.NormsFormat;
+import org.apache.lucene.codecs.SegmentInfoFormat;
 import org.apache.lucene.codecs.StoredFieldsFormat;
 import org.apache.lucene.codecs.TermVectorsFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40FieldInfosFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40FieldInfosWriter;
 import org.apache.lucene.codecs.lucene40.Lucene40RWDocValuesFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40RWNormsFormat;
+import org.apache.lucene.codecs.lucene40.Lucene40RWSegmentInfoFormat;
 import org.apache.lucene.codecs.lucene40.Lucene40RWTermVectorsFormat;
 import org.apache.lucene.util.LuceneTestCase;
 
@@ -73,4 +75,11 @@
   public TermVectorsFormat termVectorsFormat() {
     return vectors;
   }
+  
+  private static final SegmentInfoFormat segmentInfos = new Lucene40RWSegmentInfoFormat();
+
+  @Override
+  public SegmentInfoFormat segmentInfoFormat() {
+    return segmentInfos;
+  }
 }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene42/Lucene42FieldInfosWriter.java branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene42/Lucene42FieldInfosWriter.java
--- trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene42/Lucene42FieldInfosWriter.java	2014-09-26 11:20:12.718287193 -0400
+++ branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene42/Lucene42FieldInfosWriter.java	2014-09-25 09:26:52.024664154 -0400
@@ -26,6 +26,7 @@
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexOutput;
@@ -45,11 +46,11 @@
   }
   
   @Override
-  public void write(Directory directory, String segmentName, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {
+  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {
     if (!segmentSuffix.isEmpty()) {
       throw new UnsupportedOperationException("4.2 does not support fieldinfo updates");
     }
-    final String fileName = IndexFileNames.segmentFileName(segmentName, "", Lucene42FieldInfosFormat.EXTENSION);
+    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, "", Lucene42FieldInfosFormat.EXTENSION);
     IndexOutput output = directory.createOutput(fileName, context);
     boolean success = false;
     try {
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene42/Lucene42RWCodec.java branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene42/Lucene42RWCodec.java
--- trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene42/Lucene42RWCodec.java	2014-09-26 11:20:12.718287193 -0400
+++ branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene42/Lucene42RWCodec.java	2014-09-25 09:14:45.252651498 -0400
@@ -23,6 +23,8 @@
 import org.apache.lucene.codecs.FieldInfosFormat;
 import org.apache.lucene.codecs.FieldInfosWriter;
 import org.apache.lucene.codecs.NormsFormat;
+import org.apache.lucene.codecs.SegmentInfoFormat;
+import org.apache.lucene.codecs.lucene40.Lucene40RWSegmentInfoFormat;
 import org.apache.lucene.util.LuceneTestCase;
 
 /**
@@ -55,4 +57,11 @@
   public FieldInfosFormat fieldInfosFormat() {
     return fieldInfosFormat;
   }  
+  
+  private static final SegmentInfoFormat segmentInfos = new Lucene40RWSegmentInfoFormat();
+
+  @Override
+  public SegmentInfoFormat segmentInfoFormat() {
+    return segmentInfos;
+  }
 }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene45/Lucene45RWCodec.java branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene45/Lucene45RWCodec.java
--- trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene45/Lucene45RWCodec.java	2014-09-26 11:20:12.722287193 -0400
+++ branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene45/Lucene45RWCodec.java	2014-09-25 09:14:52.908651631 -0400
@@ -23,6 +23,8 @@
 import org.apache.lucene.codecs.FieldInfosFormat;
 import org.apache.lucene.codecs.FieldInfosWriter;
 import org.apache.lucene.codecs.NormsFormat;
+import org.apache.lucene.codecs.SegmentInfoFormat;
+import org.apache.lucene.codecs.lucene40.Lucene40RWSegmentInfoFormat;
 import org.apache.lucene.codecs.lucene42.Lucene42FieldInfosFormat;
 import org.apache.lucene.codecs.lucene42.Lucene42FieldInfosWriter;
 import org.apache.lucene.codecs.lucene42.Lucene42RWNormsFormat;
@@ -58,4 +60,11 @@
   public NormsFormat normsFormat() {
     return norms;
   }
+  
+  private static final SegmentInfoFormat segmentInfos = new Lucene40RWSegmentInfoFormat();
+
+  @Override
+  public SegmentInfoFormat segmentInfoFormat() {
+    return segmentInfos;
+  }
 }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene46/Lucene46RWCodec.java branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene46/Lucene46RWCodec.java
--- trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene46/Lucene46RWCodec.java	2014-09-26 11:20:12.726287193 -0400
+++ branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene46/Lucene46RWCodec.java	2014-09-25 08:45:22.252620796 -0400
@@ -19,6 +19,8 @@
 
 import org.apache.lucene.codecs.DocValuesFormat;
 import org.apache.lucene.codecs.NormsFormat;
+import org.apache.lucene.codecs.SegmentInfoFormat;
+import org.apache.lucene.codecs.SegmentInfoWriter;
 import org.apache.lucene.codecs.lucene42.Lucene42RWNormsFormat;
 import org.apache.lucene.codecs.lucene45.Lucene45RWDocValuesFormat;
 
@@ -41,4 +43,11 @@
   public NormsFormat normsFormat() {
     return norms;
   }
+  
+  private static final SegmentInfoFormat segmentInfos = new Lucene46RWSegmentInfoFormat();
+
+  @Override
+  public SegmentInfoFormat segmentInfoFormat() {
+    return segmentInfos;
+  }
 }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene46/Lucene46RWSegmentInfoFormat.java branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene46/Lucene46RWSegmentInfoFormat.java
--- trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene46/Lucene46RWSegmentInfoFormat.java	1969-12-31 19:00:00.000000000 -0500
+++ branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene46/Lucene46RWSegmentInfoFormat.java	2014-09-25 08:45:02.440620451 -0400
@@ -0,0 +1,28 @@
+package org.apache.lucene.codecs.lucene46;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.codecs.SegmentInfoWriter;
+
+/** read-write version of 4.6 segmentinfos for testing */
+public class Lucene46RWSegmentInfoFormat extends Lucene46SegmentInfoFormat {
+  @Override
+  public SegmentInfoWriter getSegmentInfoWriter() {
+    return new Lucene46SegmentInfoWriter();
+  }
+}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java
--- trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java	1969-12-31 19:00:00.000000000 -0500
+++ branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java	2014-09-26 01:01:11.709640403 -0400
@@ -0,0 +1,79 @@
+package org.apache.lucene.codecs.lucene46;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.codecs.SegmentInfoWriter;
+import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentInfo;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.Version;
+
+/**
+ * Lucene 4.0 implementation of {@link SegmentInfoWriter}.
+ * 
+ * @see Lucene46SegmentInfoFormat
+ * @lucene.experimental
+ */
+public class Lucene46SegmentInfoWriter extends SegmentInfoWriter {
+
+  /** Sole constructor. */
+  public Lucene46SegmentInfoWriter() {
+  }
+
+  /** Save a single segment's info. */
+  @Override
+  public void write(Directory dir, SegmentInfo si, FieldInfos fis, IOContext ioContext) throws IOException {
+    final String fileName = IndexFileNames.segmentFileName(si.name, "", Lucene46SegmentInfoFormat.SI_EXTENSION);
+    si.addFile(fileName);
+
+    final IndexOutput output = dir.createOutput(fileName, ioContext);
+
+    boolean success = false;
+    try {
+      CodecUtil.writeHeader(output, Lucene46SegmentInfoFormat.CODEC_NAME, Lucene46SegmentInfoFormat.VERSION_CURRENT);
+      Version version = si.getVersion();
+      if (version.major < 4) {
+        throw new IllegalArgumentException("invalid major version: should be >= 4 but got: " + version.major + " segment=" + si);
+      }
+      // Write the Lucene version that created this segment, since 3.1
+      output.writeString(version.toString());
+      output.writeInt(si.getDocCount());
+
+      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));
+      output.writeStringStringMap(si.getDiagnostics());
+      output.writeStringSet(si.files());
+      CodecUtil.writeFooter(output);
+      success = true;
+    } finally {
+      if (!success) {
+        IOUtils.closeWhileHandlingException(output);
+        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?
+        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);
+      } else {
+        output.close();
+      }
+    }
+  }
+}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene49/Lucene49RWCodec.java branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene49/Lucene49RWCodec.java
--- trunk/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene49/Lucene49RWCodec.java	2014-09-26 11:20:12.730287193 -0400
+++ branch/lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene49/Lucene49RWCodec.java	2014-09-25 08:45:39.740621100 -0400
@@ -19,6 +19,8 @@
 
 import org.apache.lucene.codecs.DocValuesFormat;
 import org.apache.lucene.codecs.NormsFormat;
+import org.apache.lucene.codecs.SegmentInfoFormat;
+import org.apache.lucene.codecs.lucene46.Lucene46RWSegmentInfoFormat;
 
 /**
  * Read-write version of {@link Lucene49Codec} for testing.
@@ -39,4 +41,11 @@
   public NormsFormat normsFormat() {
     return norms;
   }
+  
+  private static final SegmentInfoFormat segmentInfos = new Lucene46RWSegmentInfoFormat();
+
+  @Override
+  public SegmentInfoFormat segmentInfoFormat() {
+    return segmentInfos;
+  }
 }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextFieldInfosReader.java branch/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextFieldInfosReader.java
--- trunk/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextFieldInfosReader.java	2014-09-26 11:20:12.758287193 -0400
+++ branch/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextFieldInfosReader.java	2014-09-25 09:30:09.080667586 -0400
@@ -29,6 +29,7 @@
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.ChecksumIndexInput;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
@@ -47,8 +48,8 @@
 public class SimpleTextFieldInfosReader extends FieldInfosReader {
 
   @Override
-  public FieldInfos read(Directory directory, String segmentName, String segmentSuffix, IOContext iocontext) throws IOException {
-    final String fileName = IndexFileNames.segmentFileName(segmentName, segmentSuffix, FIELD_INFOS_EXTENSION);
+  public FieldInfos read(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, IOContext iocontext) throws IOException {
+    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, FIELD_INFOS_EXTENSION);
     ChecksumIndexInput input = directory.openChecksumInput(fileName, iocontext);
     BytesRefBuilder scratch = new BytesRefBuilder();
     
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextFieldInfosWriter.java branch/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextFieldInfosWriter.java
--- trunk/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextFieldInfosWriter.java	2014-09-26 11:20:12.758287193 -0400
+++ branch/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextFieldInfosWriter.java	2014-09-25 09:27:19.244664628 -0400
@@ -25,6 +25,7 @@
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexOutput;
@@ -61,8 +62,8 @@
   final static BytesRef ATT_VALUE       =  new BytesRef("    value ");
   
   @Override
-  public void write(Directory directory, String segmentName, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {
-    final String fileName = IndexFileNames.segmentFileName(segmentName, segmentSuffix, FIELD_INFOS_EXTENSION);
+  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {
+    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, FIELD_INFOS_EXTENSION);
     IndexOutput out = directory.createOutput(fileName, context);
     BytesRefBuilder scratch = new BytesRefBuilder();
     boolean success = false;
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoReader.java branch/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoReader.java
--- trunk/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoReader.java	2014-09-23 10:04:34.973694345 -0400
+++ branch/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoReader.java	2014-09-26 01:03:25.213642727 -0400
@@ -20,6 +20,7 @@
 import java.io.IOException;
 import java.nio.charset.StandardCharsets;
 import java.text.ParseException;
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
@@ -109,7 +110,7 @@
       
       SimpleTextUtil.readLine(input, scratch);
       assert StringHelper.startsWith(scratch.get(), SI_ID);
-      final String id = readString(SI_ID.length, scratch);
+      final byte[] id = Arrays.copyOfRange(scratch.bytes(), SI_ID.length, scratch.length());
 
       SimpleTextUtil.checkFooter(input);
 
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoWriter.java branch/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoWriter.java
--- trunk/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoWriter.java	2014-08-25 15:29:50.286400547 -0400
+++ branch/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoWriter.java	2014-09-26 01:02:23.589641654 -0400
@@ -107,7 +107,7 @@
       }
 
       SimpleTextUtil.write(output, SI_ID);
-      SimpleTextUtil.write(output, si.getId(), scratch);
+      SimpleTextUtil.write(output, new BytesRef(si.getId()));
       SimpleTextUtil.writeNewline(output);
       
       SimpleTextUtil.writeChecksum(output, scratch);
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/CodecUtil.java branch/lucene/core/src/java/org/apache/lucene/codecs/CodecUtil.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/CodecUtil.java	2014-09-25 17:27:33.201166407 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/CodecUtil.java	2014-09-26 01:18:48.553658807 -0400
@@ -19,6 +19,7 @@
 
 
 import java.io.IOException;
+import java.util.Arrays;
 
 import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.IndexFormatTooNewException;
@@ -31,6 +32,7 @@
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.StringHelper;
 
 /**
  * Utility class for reading and writing versioned headers.
@@ -80,8 +82,7 @@
    * @throws IOException If there is an I/O error writing to the underlying medium.
    * @throws IllegalArgumentException If the codec name is not simple ASCII, or is more than 127 characters in length
    */
-  public static void writeHeader(DataOutput out, String codec, int version)
-    throws IOException {
+  public static void writeHeader(DataOutput out, String codec, int version) throws IOException {
     BytesRef bytes = new BytesRef(codec);
     if (bytes.length != codec.length() || bytes.length >= 128) {
       throw new IllegalArgumentException("codec must be simple ASCII, less than 128 characters in length [got " + codec + "]");
@@ -90,6 +91,40 @@
     out.writeString(codec);
     out.writeInt(version);
   }
+  
+  /**
+   * Writes a codec header for a per-segment, which records both a string to
+   * identify the file, a version number, and the unique ID of the segment. 
+   * This header can be parsed and validated with 
+   * {@link #checkSegmentHeader(DataInput, String, int, int, byte[]) checkSegmentHeader()}.
+   * <p>
+   * CodecSegmentHeader --&gt; CodecHeader,SegmentID
+   * <ul>
+   *    <li>CodecHeader --&gt; {@link #writeHeader}
+   *    <li>SegmentID   --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>.
+   *        Unique identifier for the segment.
+   * </ul>
+   * <p>
+   * Note that the length of a segment header depends only upon the
+   * name of the codec, so this length can be computed at any time
+   * with {@link #headerLength(String)}.
+   * 
+   * @param out Output stream
+   * @param codec String to identify this file. It should be simple ASCII, 
+   *              less than 128 characters in length.
+   * @param segmentID Unique identifier for the segment
+   * @param version Version number
+   * @throws IOException If there is an I/O error writing to the underlying medium.
+   * @throws IllegalArgumentException If the codec name is not simple ASCII, or 
+   *         is more than 127 characters in length, or if segmentID is invalid.
+   */
+  public static void writeSegmentHeader(DataOutput out, String codec, int version, byte[] segmentID) throws IOException {
+    if (segmentID.length != StringHelper.ID_LENGTH) {
+      throw new IllegalArgumentException("Invalid id: " + StringHelper.idToString(segmentID));
+    }
+    writeHeader(out, codec, version);
+    out.writeBytes(segmentID, 0, segmentID.length);
+  }
 
   /**
    * Computes the length of a codec header.
@@ -101,6 +136,17 @@
   public static int headerLength(String codec) {
     return 9+codec.length();
   }
+  
+  /**
+   * Computes the length of a segment header.
+   * 
+   * @param codec Codec name.
+   * @return length of the entire segment header.
+   * @see #writeSegmentHeader(DataOutput, String, int, byte[])
+   */
+  public static int segmentHeaderLength(String codec) {
+    return headerLength(codec) + StringHelper.ID_LENGTH;
+  }
 
   /**
    * Reads and validates a header previously written with 
@@ -129,9 +175,7 @@
    * @throws IOException If there is an I/O error reading from the underlying medium.
    * @see #writeHeader(DataOutput, String, int)
    */
-  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion)
-    throws IOException {
-
+  public static int checkHeader(DataInput in, String codec, int minVersion, int maxVersion) throws IOException {
     // Safety to guard against reading a bogus string:
     final int actualHeader = in.readInt();
     if (actualHeader != CODEC_MAGIC) {
@@ -162,6 +206,48 @@
   }
   
   /**
+   * Reads and validates a header previously written with 
+   * {@link #writeSegmentHeader(DataOutput, String, int, byte[])}.
+   * <p>
+   * When reading a file, supply the expected <code>codec</code>,
+   * expected version range (<code>minVersion to maxVersion</code>),
+   * and segment ID.
+   * 
+   * @param in Input stream, positioned at the point where the
+   *        header was previously written. Typically this is located
+   *        at the beginning of the file.
+   * @param codec The expected codec name.
+   * @param minVersion The minimum supported expected version number.
+   * @param maxVersion The maximum supported expected version number.
+   * @param segmentID The expected segment this file belongs to.
+   * @return The actual version found, when a valid header is found 
+   *         that matches <code>codec</code>, with an actual version 
+   *         where <code>minVersion <= actual <= maxVersion</code>, 
+   *         and matching <code>segmentID</code>
+   *         Otherwise an exception is thrown.
+   * @throws CorruptIndexException If the first four bytes are not
+   *         {@link #CODEC_MAGIC}, or if the actual codec found is
+   *         not <code>codec</code>, or if the <code>segmentID</code>
+   *         does not match.
+   * @throws IndexFormatTooOldException If the actual version is less 
+   *         than <code>minVersion</code>.
+   * @throws IndexFormatTooNewException If the actual version is greater 
+   *         than <code>maxVersion</code>.
+   * @throws IOException If there is an I/O error reading from the underlying medium.
+   * @see #writeSegmentHeader(DataOutput, String, int, byte[])
+   */
+  public static int checkSegmentHeader(DataInput in, String codec, int minVersion, int maxVersion, byte[] segmentID) throws IOException {
+    int version = checkHeader(in, codec, minVersion, maxVersion);
+    byte id[] = new byte[StringHelper.ID_LENGTH];
+    in.readBytes(id, 0, id.length);
+    if (!Arrays.equals(id, segmentID)) {
+      throw new CorruptIndexException("file mismatch, expected segment id=" + StringHelper.idToString(segmentID) 
+                                                                 + ", got=" + StringHelper.idToString(id), in);
+    }
+    return version;
+  }
+  
+  /**
    * Writes a codec footer, which records both a checksum
    * algorithm ID and a checksum. This footer can
    * be parsed and validated with 
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/FieldInfosReader.java branch/lucene/core/src/java/org/apache/lucene/codecs/FieldInfosReader.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/FieldInfosReader.java	2014-09-26 11:20:13.194287201 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/FieldInfosReader.java	2014-09-25 09:28:55.680666307 -0400
@@ -20,6 +20,7 @@
 import java.io.IOException;
 
 import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 
@@ -35,5 +36,5 @@
 
   /** Read the {@link FieldInfos} previously written with {@link
    *  FieldInfosWriter}. */
-  public abstract FieldInfos read(Directory directory, String segmentName, String segmentSuffix, IOContext iocontext) throws IOException;
+  public abstract FieldInfos read(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, IOContext iocontext) throws IOException;
 }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/FieldInfosWriter.java branch/lucene/core/src/java/org/apache/lucene/codecs/FieldInfosWriter.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/FieldInfosWriter.java	2014-09-26 11:20:13.194287201 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/FieldInfosWriter.java	2014-09-25 09:24:23.976661576 -0400
@@ -20,6 +20,7 @@
 import java.io.IOException;
 
 import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 
@@ -35,5 +36,5 @@
 
   /** Writes the provided {@link FieldInfos} to the
    *  directory. */
-  public abstract void write(Directory directory, String segmentName, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException;
+  public abstract void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException;
 }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene40/BitVector.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene40/BitVector.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene40/BitVector.java	2014-09-23 10:04:34.261694333 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene40/BitVector.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,410 +0,0 @@
-package org.apache.lucene.codecs.lucene40;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Arrays;
-
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.index.IndexFormatTooOldException;
-import org.apache.lucene.store.ChecksumIndexInput;
-import org.apache.lucene.store.CompoundFileDirectory;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexInput;
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.BitUtil;
-import org.apache.lucene.util.MutableBits;
-
-/** Optimized implementation of a vector of bits.  This is more-or-less like
- *  java.util.BitSet, but also includes the following:
- *  <ul>
- *  <li>a count() method, which efficiently computes the number of one bits;</li>
- *  <li>optimized read from and write to disk;</li>
- *  <li>inlinable get() method;</li>
- *  <li>store and load, as bit set or d-gaps, depending on sparseness;</li> 
- *  </ul>
- *
- *  @lucene.internal
- */
-// pkg-private: if this thing is generally useful then it can go back in .util,
-// but the serialization must be here underneath the codec.
-final class BitVector implements Cloneable, MutableBits {
-
-  private byte[] bits;
-  private int size;
-  private int count;
-  private int version;
-
-  /** Constructs a vector capable of holding <code>n</code> bits. */
-  public BitVector(int n) {
-    size = n;
-    bits = new byte[getNumBytes(size)];
-    count = 0;
-  }
-
-  BitVector(byte[] bits, int size) {
-    this.bits = bits;
-    this.size = size;
-    count = -1;
-  }
-  
-  private int getNumBytes(int size) {
-    int bytesLength = size >>> 3;
-    if ((size & 7) != 0) {
-      bytesLength++;
-    }
-    return bytesLength;
-  }
-  
-  @Override
-  public BitVector clone() {
-    byte[] copyBits = new byte[bits.length];
-    System.arraycopy(bits, 0, copyBits, 0, bits.length);
-    BitVector clone = new BitVector(copyBits, size);
-    clone.count = count;
-    return clone;
-  }
-  
-  /** Sets the value of <code>bit</code> to one. */
-  public final void set(int bit) {
-    if (bit >= size) {
-      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
-    }
-    bits[bit >> 3] |= 1 << (bit & 7);
-    count = -1;
-  }
-
-  /** Sets the value of <code>bit</code> to true, and
-   *  returns true if bit was already set */
-  public final boolean getAndSet(int bit) {
-    if (bit >= size) {
-      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
-    }
-    final int pos = bit >> 3;
-    final int v = bits[pos];
-    final int flag = 1 << (bit & 7);
-    if ((flag & v) != 0)
-      return true;
-    else {
-      bits[pos] = (byte) (v | flag);
-      if (count != -1) {
-        count++;
-        assert count <= size;
-      }
-      return false;
-    }
-  }
-
-  /** Sets the value of <code>bit</code> to zero. */
-  @Override
-  public final void clear(int bit) {
-    if (bit >= size) {
-      throw new ArrayIndexOutOfBoundsException(bit);
-    }
-    bits[bit >> 3] &= ~(1 << (bit & 7));
-    count = -1;
-  }
-
-  public final boolean getAndClear(int bit) {
-    if (bit >= size) {
-      throw new ArrayIndexOutOfBoundsException(bit);
-    }
-    final int pos = bit >> 3;
-    final int v = bits[pos];
-    final int flag = 1 << (bit & 7);
-    if ((flag & v) == 0) {
-      return false;
-    } else {
-      bits[pos] &= ~flag;
-      if (count != -1) {
-        count--;
-        assert count >= 0;
-      }
-      return true;
-    }
-  }
-
-  /** Returns <code>true</code> if <code>bit</code> is one and
-    <code>false</code> if it is zero. */
-  @Override
-  public final boolean get(int bit) {
-    assert bit >= 0 && bit < size: "bit " + bit + " is out of bounds 0.." + (size-1);
-    return (bits[bit >> 3] & (1 << (bit & 7))) != 0;
-  }
-
-  /** Returns the number of bits in this vector.  This is also one greater than
-    the number of the largest valid bit number. */
-  public final int size() {
-    return size;
-  }
-
-  @Override
-  public int length() {
-    return size;
-  }
-
-  /** Returns the total number of one bits in this vector.  This is efficiently
-    computed and cached, so that, if the vector is not changed, no
-    recomputation is done for repeated calls. */
-  public final int count() {
-    // if the vector has been modified
-    if (count == -1) {
-      int c = 0;
-      int end = bits.length;
-      for (int i = 0; i < end; i++) {
-        c += BitUtil.bitCount(bits[i]);  // sum bits per byte
-      }
-      count = c;
-    }
-    assert count <= size: "count=" + count + " size=" + size;
-    return count;
-  }
-
-  /** For testing */
-  public final int getRecomputedCount() {
-    int c = 0;
-    int end = bits.length;
-    for (int i = 0; i < end; i++) {
-      c += BitUtil.bitCount(bits[i]);  // sum bits per byte
-    }
-    return c;
-  }
-
-
-
-  private static String CODEC = "BitVector";
-
-  // Version before version tracking was added:
-  public final static int VERSION_PRE = -1;
-
-  // First version:
-  public final static int VERSION_START = 0;
-
-  // Changed DGaps to encode gaps between cleared bits, not
-  // set:
-  public final static int VERSION_DGAPS_CLEARED = 1;
-  
-  // added checksum
-  public final static int VERSION_CHECKSUM = 2;
-
-  // Increment version to change it:
-  public final static int VERSION_CURRENT = VERSION_CHECKSUM;
-
-  public int getVersion() {
-    return version;
-  }
-
-  /** Writes this vector to the file <code>name</code> in Directory
-    <code>d</code>, in a format that can be read by the constructor {@link
-    #BitVector(Directory, String, IOContext)}.  */
-  public final void write(Directory d, String name, IOContext context) throws IOException {
-    assert !(d instanceof CompoundFileDirectory);
-    try (IndexOutput output = d.createOutput(name, context)) {
-      output.writeInt(-2);
-      CodecUtil.writeHeader(output, CODEC, VERSION_CURRENT);
-      if (isSparse()) { 
-        // sparse bit-set more efficiently saved as d-gaps.
-        writeClearedDgaps(output);
-      } else {
-        writeBits(output);
-      }
-      CodecUtil.writeFooter(output);
-      assert verifyCount();
-    }
-  }
-
-  /** Invert all bits */
-  public void invertAll() {
-    if (count != -1) {
-      count = size - count;
-    }
-    if (bits.length > 0) {
-      for(int idx=0;idx<bits.length;idx++) {
-        bits[idx] = (byte) (~bits[idx]);
-      }
-      clearUnusedBits();
-    }
-  }
-
-  private void clearUnusedBits() {
-    // Take care not to invert the "unused" bits in the
-    // last byte:
-    if (bits.length > 0) {
-      final int lastNBits = size & 7;
-      if (lastNBits != 0) {
-        final int mask = (1 << lastNBits)-1;
-        bits[bits.length-1] &= mask;
-      }
-    }
-  }
-
-  /** Set all bits */
-  public void setAll() {
-    Arrays.fill(bits, (byte) 0xff);
-    clearUnusedBits();
-    count = size;
-  }
-     
-  /** Write as a bit set */
-  private void writeBits(IndexOutput output) throws IOException {
-    output.writeInt(size());        // write size
-    output.writeInt(count());       // write count
-    output.writeBytes(bits, bits.length);
-  }
-  
-  /** Write as a d-gaps list */
-  private void writeClearedDgaps(IndexOutput output) throws IOException {
-    output.writeInt(-1);            // mark using d-gaps                         
-    output.writeInt(size());        // write size
-    output.writeInt(count());       // write count
-    int last=0;
-    int numCleared = size()-count();
-    for (int i=0; i<bits.length && numCleared>0; i++) {
-      if (bits[i] != (byte) 0xff) {
-        output.writeVInt(i-last);
-        output.writeByte(bits[i]);
-        last = i;
-        numCleared -= (8-BitUtil.bitCount(bits[i]));
-        assert numCleared >= 0 || (i == (bits.length-1) && numCleared == -(8-(size&7)));
-      }
-    }
-  }
-
-  /** Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. */
-  private boolean isSparse() {
-
-    final int clearedCount = size() - count();
-    if (clearedCount == 0) {
-      return true;
-    }
-
-    final int avgGapLength = bits.length / clearedCount;
-
-    // expected number of bytes for vInt encoding of each gap
-    final int expectedDGapBytes;
-    if (avgGapLength <= (1<< 7)) {
-      expectedDGapBytes = 1;
-    } else if (avgGapLength <= (1<<14)) {
-      expectedDGapBytes = 2;
-    } else if (avgGapLength <= (1<<21)) {
-      expectedDGapBytes = 3;
-    } else if (avgGapLength <= (1<<28)) {
-      expectedDGapBytes = 4;
-    } else {
-      expectedDGapBytes = 5;
-    }
-
-    // +1 because we write the byte itself that contains the
-    // set bit
-    final int bytesPerSetBit = expectedDGapBytes + 1;
-    
-    // note: adding 32 because we start with ((int) -1) to indicate d-gaps format.
-    final long expectedBits = 32 + 8 * bytesPerSetBit * clearedCount;
-
-    // note: factor is for read/write of byte-arrays being faster than vints.  
-    final long factor = 10;  
-    return factor * expectedBits < size();
-  }
-
-  /** Constructs a bit vector from the file <code>name</code> in Directory
-    <code>d</code>, as written by the {@link #write} method.
-    */
-  public BitVector(Directory d, String name, IOContext context) throws IOException {
-    try (ChecksumIndexInput input = d.openChecksumInput(name, context)) {
-      final int firstInt = input.readInt();
-
-      if (firstInt == -2) {
-        // New format, with full header & version:
-        version = CodecUtil.checkHeader(input, CODEC, VERSION_START, VERSION_CURRENT);
-        size = input.readInt();
-      } else {
-        // we started writing full header well before 4.0
-        throw new IndexFormatTooOldException(input.toString(), Integer.toString(firstInt));
-      }
-      if (size == -1) {
-        if (version >= VERSION_DGAPS_CLEARED) {
-          readClearedDgaps(input);
-        } else {
-          readSetDgaps(input);
-        }
-      } else {
-        readBits(input);
-      }
-
-      if (version < VERSION_DGAPS_CLEARED) {
-        invertAll();
-      }
-
-      if (version >= VERSION_CHECKSUM) {
-        CodecUtil.checkFooter(input);
-      } else {
-        CodecUtil.checkEOF(input);
-      }
-      assert verifyCount();
-    }
-  }
-
-  // asserts only
-  private boolean verifyCount() {
-    assert count != -1;
-    final int countSav = count;
-    count = -1;
-    assert countSav == count(): "saved count was " + countSav + " but recomputed count is " + count;
-    return true;
-  }
-
-  /** Read as a bit set */
-  private void readBits(IndexInput input) throws IOException {
-    count = input.readInt();        // read count
-    bits = new byte[getNumBytes(size)];     // allocate bits
-    input.readBytes(bits, 0, bits.length);
-  }
-
-  /** read as a d-gaps list */ 
-  private void readSetDgaps(IndexInput input) throws IOException {
-    size = input.readInt();       // (re)read size
-    count = input.readInt();        // read count
-    bits = new byte[getNumBytes(size)];     // allocate bits
-    int last=0;
-    int n = count();
-    while (n>0) {
-      last += input.readVInt();
-      bits[last] = input.readByte();
-      n -= BitUtil.bitCount(bits[last]);
-      assert n >= 0;
-    }          
-  }
-
-  /** read as a d-gaps cleared bits list */ 
-  private void readClearedDgaps(IndexInput input) throws IOException {
-    size = input.readInt();       // (re)read size
-    count = input.readInt();        // read count
-    bits = new byte[getNumBytes(size)];     // allocate bits
-    Arrays.fill(bits, (byte) 0xff);
-    clearUnusedBits();
-    int last=0;
-    int numCleared = size()-count();
-    while (numCleared>0) {
-      last += input.readVInt();
-      bits[last] = input.readByte();
-      numCleared -= 8-BitUtil.bitCount(bits[last]);
-      assert numCleared >= 0 || (last == (bits.length-1) && numCleared == -(8-(size&7)));
-    }
-  }
-}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java	2014-09-26 11:20:12.782287194 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40LiveDocsFormat.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,116 +0,0 @@
-package org.apache.lucene.codecs.lucene40;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Collection;
-
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.codecs.LiveDocsFormat;
-import org.apache.lucene.index.CorruptIndexException;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.SegmentCommitInfo;
-import org.apache.lucene.store.DataOutput; // javadocs
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.MutableBits;
-
-/**
- * Lucene 4.0 Live Documents Format.
- * <p>
- * <p>The .del file is optional, and only exists when a segment contains
- * deletions.</p>
- * <p>Although per-segment, this file is maintained exterior to compound segment
- * files.</p>
- * <p>Deletions (.del) --&gt; Format,Header,ByteCount,BitCount, Bits | DGaps (depending
- * on Format)</p>
- * <ul>
- *   <li>Format,ByteSize,BitCount --&gt; {@link DataOutput#writeInt Uint32}</li>
- *   <li>Bits --&gt; &lt;{@link DataOutput#writeByte Byte}&gt; <sup>ByteCount</sup></li>
- *   <li>DGaps --&gt; &lt;DGap,NonOnesByte&gt; <sup>NonzeroBytesCount</sup></li>
- *   <li>DGap --&gt; {@link DataOutput#writeVInt VInt}</li>
- *   <li>NonOnesByte --&gt; {@link DataOutput#writeByte Byte}</li>
- *   <li>Header --&gt; {@link CodecUtil#writeHeader CodecHeader}</li>
- * </ul>
- * <p>Format is 1: indicates cleared DGaps.</p>
- * <p>ByteCount indicates the number of bytes in Bits. It is typically
- * (SegSize/8)+1.</p>
- * <p>BitCount indicates the number of bits that are currently set in Bits.</p>
- * <p>Bits contains one bit for each document indexed. When the bit corresponding
- * to a document number is cleared, that document is marked as deleted. Bit ordering
- * is from least to most significant. Thus, if Bits contains two bytes, 0x00 and
- * 0x02, then document 9 is marked as alive (not deleted).</p>
- * <p>DGaps represents sparse bit-vectors more efficiently than Bits. It is made
- * of DGaps on indexes of nonOnes bytes in Bits, and the nonOnes bytes themselves.
- * The number of nonOnes bytes in Bits (NonOnesBytesCount) is not stored.</p>
- * <p>For example, if there are 8000 bits and only bits 10,12,32 are cleared, DGaps
- * would be used:</p>
- * <p>(VInt) 1 , (byte) 20 , (VInt) 3 , (Byte) 1</p>
- */
-public class Lucene40LiveDocsFormat extends LiveDocsFormat {
-
-  /** Extension of deletes */
-  static final String DELETES_EXTENSION = "del";
-
-  /** Sole constructor. */
-  public Lucene40LiveDocsFormat() {
-  }
-  
-  @Override
-  public MutableBits newLiveDocs(int size) throws IOException {
-    BitVector bitVector = new BitVector(size);
-    bitVector.invertAll();
-    return bitVector;
-  }
-
-  @Override
-  public MutableBits newLiveDocs(Bits existing) throws IOException {
-    final BitVector liveDocs = (BitVector) existing;
-    return liveDocs.clone();
-  }
-
-  @Override
-  public Bits readLiveDocs(Directory dir, SegmentCommitInfo info, IOContext context) throws IOException {
-    String filename = IndexFileNames.fileNameFromGeneration(info.info.name, DELETES_EXTENSION, info.getDelGen());
-    final BitVector liveDocs = new BitVector(dir, filename, context);
-    if (liveDocs.length() != info.info.getDocCount()) {
-      throw new CorruptIndexException("liveDocs.length()=" + liveDocs.length() + "info.docCount=" + info.info.getDocCount(), filename);
-    }
-    if (liveDocs.count() != info.info.getDocCount() - info.getDelCount()) {
-      throw new CorruptIndexException("liveDocs.count()=" + liveDocs.count() + " info.docCount=" + info.info.getDocCount() + " info.getDelCount()=" + info.getDelCount(), filename);
-    }
-    return liveDocs;
-  }
-
-  @Override
-  public void writeLiveDocs(MutableBits bits, Directory dir, SegmentCommitInfo info, int newDelCount, IOContext context) throws IOException {
-    String filename = IndexFileNames.fileNameFromGeneration(info.info.name, DELETES_EXTENSION, info.getNextDelGen());
-    final BitVector liveDocs = (BitVector) bits;
-    assert liveDocs.count() == info.info.getDocCount() - info.getDelCount() - newDelCount;
-    assert liveDocs.length() == info.info.getDocCount();
-    liveDocs.write(dir, filename, context);
-  }
-
-  @Override
-  public void files(SegmentCommitInfo info, Collection<String> files) throws IOException {
-    if (info.hasDeletions()) {
-      files.add(IndexFileNames.fileNameFromGeneration(info.info.name, DELETES_EXTENSION, info.getDelGen()));
-    }
-  }
-}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene40/package.html branch/lucene/core/src/java/org/apache/lucene/codecs/lucene40/package.html
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene40/package.html	2014-09-04 10:11:43.765114250 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene40/package.html	1969-12-31 19:00:00.000000000 -0500
@@ -1,25 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-Lucene 4.0 file format.
-</body>
-</html>
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosFormat.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosFormat.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosFormat.java	2014-09-26 11:20:12.790287194 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosFormat.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,129 +0,0 @@
-package org.apache.lucene.codecs.lucene46;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.codecs.DocValuesFormat;
-import org.apache.lucene.codecs.FieldInfosFormat;
-import org.apache.lucene.codecs.FieldInfosReader;
-import org.apache.lucene.codecs.FieldInfosWriter;
-import org.apache.lucene.index.FieldInfo.DocValuesType;
-import org.apache.lucene.store.DataOutput;
-
-/**
- * Lucene 4.6 Field Infos format.
- * <p>
- * <p>Field names are stored in the field info file, with suffix <tt>.fnm</tt>.</p>
- * <p>FieldInfos (.fnm) --&gt; Header,FieldsCount, &lt;FieldName,FieldNumber,
- * FieldBits,DocValuesBits,DocValuesGen,Attributes&gt; <sup>FieldsCount</sup>,Footer</p>
- * <p>Data types:
- * <ul>
- *   <li>Header --&gt; {@link CodecUtil#checkHeader CodecHeader}</li>
- *   <li>FieldsCount --&gt; {@link DataOutput#writeVInt VInt}</li>
- *   <li>FieldName --&gt; {@link DataOutput#writeString String}</li>
- *   <li>FieldBits, DocValuesBits --&gt; {@link DataOutput#writeByte Byte}</li>
- *   <li>FieldNumber --&gt; {@link DataOutput#writeInt VInt}</li>
- *   <li>Attributes --&gt; {@link DataOutput#writeStringStringMap Map&lt;String,String&gt;}</li>
- *   <li>DocValuesGen --&gt; {@link DataOutput#writeLong(long) Int64}</li>
- *   <li>Footer --&gt; {@link CodecUtil#writeFooter CodecFooter}</li>
- * </ul>
- * </p>
- * Field Descriptions:
- * <ul>
- *   <li>FieldsCount: the number of fields in this file.</li>
- *   <li>FieldName: name of the field as a UTF-8 String.</li>
- *   <li>FieldNumber: the field's number. Note that unlike previous versions of
- *       Lucene, the fields are not numbered implicitly by their order in the
- *       file, instead explicitly.</li>
- *   <li>FieldBits: a byte containing field options.
- *       <ul>
- *         <li>The low-order bit is one for indexed fields, and zero for non-indexed
- *             fields.</li>
- *         <li>The second lowest-order bit is one for fields that have term vectors
- *             stored, and zero for fields without term vectors.</li>
- *         <li>If the third lowest order-bit is set (0x4), offsets are stored into
- *             the postings list in addition to positions.</li>
- *         <li>Fourth bit is unused.</li>
- *         <li>If the fifth lowest-order bit is set (0x10), norms are omitted for the
- *             indexed field.</li>
- *         <li>If the sixth lowest-order bit is set (0x20), payloads are stored for the
- *             indexed field.</li>
- *         <li>If the seventh lowest-order bit is set (0x40), term frequencies and
- *             positions omitted for the indexed field.</li>
- *         <li>If the eighth lowest-order bit is set (0x80), positions are omitted for the
- *             indexed field.</li>
- *       </ul>
- *    </li>
- *    <li>DocValuesBits: a byte containing per-document value types. The type
- *        recorded as two four-bit integers, with the high-order bits representing
- *        <code>norms</code> options, and the low-order bits representing 
- *        {@code DocValues} options. Each four-bit integer can be decoded as such:
- *        <ul>
- *          <li>0: no DocValues for this field.</li>
- *          <li>1: NumericDocValues. ({@link DocValuesType#NUMERIC})</li>
- *          <li>2: BinaryDocValues. ({@code DocValuesType#BINARY})</li>
- *          <li>3: SortedDocValues. ({@code DocValuesType#SORTED})</li>
- *        </ul>
- *    </li>
- *    <li>DocValuesGen is the generation count of the field's DocValues. If this is -1,
- *        there are no DocValues updates to that field. Anything above zero means there 
- *        are updates stored by {@link DocValuesFormat}.</li>
- *    <li>Attributes: a key-value map of codec-private attributes.</li>
- * </ul>
- *
- * @lucene.experimental
- */
-public final class Lucene46FieldInfosFormat extends FieldInfosFormat {
-  private final FieldInfosReader reader = new Lucene46FieldInfosReader();
-  private final FieldInfosWriter writer = new Lucene46FieldInfosWriter();
-  
-  /** Sole constructor. */
-  public Lucene46FieldInfosFormat() {
-  }
-
-  @Override
-  public FieldInfosReader getFieldInfosReader() throws IOException {
-    return reader;
-  }
-
-  @Override
-  public FieldInfosWriter getFieldInfosWriter() throws IOException {
-    return writer;
-  }
-  
-  /** Extension of field infos */
-  static final String EXTENSION = "fnm";
-  
-  // Codec header
-  static final String CODEC_NAME = "Lucene46FieldInfos";
-  static final int FORMAT_START = 0;
-  static final int FORMAT_CHECKSUM = 1;
-  static final int FORMAT_SORTED_NUMERIC = 2;
-  static final int FORMAT_CURRENT = FORMAT_SORTED_NUMERIC;
-  
-  // Field flags
-  static final byte IS_INDEXED = 0x1;
-  static final byte STORE_TERMVECTOR = 0x2;
-  static final byte STORE_OFFSETS_IN_POSTINGS = 0x4;
-  static final byte OMIT_NORMS = 0x10;
-  static final byte STORE_PAYLOADS = 0x20;
-  static final byte OMIT_TERM_FREQ_AND_POSITIONS = 0x40;
-  static final byte OMIT_POSITIONS = -128;
-}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosReader.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosReader.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosReader.java	2014-09-26 11:20:12.790287194 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosReader.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,120 +0,0 @@
-package org.apache.lucene.codecs.lucene46;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Collections;
-import java.util.Map;
-
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.codecs.FieldInfosReader;
-import org.apache.lucene.index.CorruptIndexException;
-import org.apache.lucene.index.FieldInfo;
-import org.apache.lucene.index.FieldInfos;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.FieldInfo.DocValuesType;
-import org.apache.lucene.index.FieldInfo.IndexOptions;
-import org.apache.lucene.store.ChecksumIndexInput;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexInput;
-
-/**
- * Lucene 4.6 FieldInfos reader.
- * 
- * @lucene.experimental
- * @see Lucene46FieldInfosFormat
- */
-final class Lucene46FieldInfosReader extends FieldInfosReader {
-
-  /** Sole constructor. */
-  public Lucene46FieldInfosReader() {
-  }
-
-  @Override
-  public FieldInfos read(Directory directory, String segmentName, String segmentSuffix, IOContext context) throws IOException {
-    final String fileName = IndexFileNames.segmentFileName(segmentName, segmentSuffix, Lucene46FieldInfosFormat.EXTENSION);
-    try (ChecksumIndexInput input = directory.openChecksumInput(fileName, context)) {
-      int codecVersion = CodecUtil.checkHeader(input, Lucene46FieldInfosFormat.CODEC_NAME, 
-                                                      Lucene46FieldInfosFormat.FORMAT_START, 
-                                                      Lucene46FieldInfosFormat.FORMAT_CURRENT);
-
-      final int size = input.readVInt(); //read in the size
-      FieldInfo infos[] = new FieldInfo[size];
-
-      for (int i = 0; i < size; i++) {
-        String name = input.readString();
-        final int fieldNumber = input.readVInt();
-        if (fieldNumber < 0) {
-          throw new CorruptIndexException("invalid field number for field: " + name + ", fieldNumber=" + fieldNumber, input);
-        }
-        byte bits = input.readByte();
-        boolean isIndexed = (bits & Lucene46FieldInfosFormat.IS_INDEXED) != 0;
-        boolean storeTermVector = (bits & Lucene46FieldInfosFormat.STORE_TERMVECTOR) != 0;
-        boolean omitNorms = (bits & Lucene46FieldInfosFormat.OMIT_NORMS) != 0;
-        boolean storePayloads = (bits & Lucene46FieldInfosFormat.STORE_PAYLOADS) != 0;
-        final IndexOptions indexOptions;
-        if (!isIndexed) {
-          indexOptions = null;
-        } else if ((bits & Lucene46FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS) != 0) {
-          indexOptions = IndexOptions.DOCS_ONLY;
-        } else if ((bits & Lucene46FieldInfosFormat.OMIT_POSITIONS) != 0) {
-          indexOptions = IndexOptions.DOCS_AND_FREQS;
-        } else if ((bits & Lucene46FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS) != 0) {
-          indexOptions = IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS;
-        } else {
-          indexOptions = IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;
-        }
-
-        // DV Types are packed in one byte
-        byte val = input.readByte();
-        final DocValuesType docValuesType = getDocValuesType(input, (byte) (val & 0x0F));
-        final DocValuesType normsType = getDocValuesType(input, (byte) ((val >>> 4) & 0x0F));
-        final long dvGen = input.readLong();
-        final Map<String,String> attributes = input.readStringStringMap();
-        infos[i] = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, 
-          omitNorms, storePayloads, indexOptions, docValuesType, normsType, dvGen, Collections.unmodifiableMap(attributes));
-      }
-      
-      if (codecVersion >= Lucene46FieldInfosFormat.FORMAT_CHECKSUM) {
-        CodecUtil.checkFooter(input);
-      } else {
-        CodecUtil.checkEOF(input);
-      }
-      return new FieldInfos(infos);
-    }
-  }
-  
-  private static DocValuesType getDocValuesType(IndexInput input, byte b) throws IOException {
-    if (b == 0) {
-      return null;
-    } else if (b == 1) {
-      return DocValuesType.NUMERIC;
-    } else if (b == 2) {
-      return DocValuesType.BINARY;
-    } else if (b == 3) {
-      return DocValuesType.SORTED;
-    } else if (b == 4) {
-      return DocValuesType.SORTED_SET;
-    } else if (b == 5) {
-      return DocValuesType.SORTED_NUMERIC;
-    } else {
-      throw new CorruptIndexException("invalid docvalues byte: " + b, input);
-    }
-  }
-}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosWriter.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosWriter.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosWriter.java	2014-09-26 11:20:12.790287194 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46FieldInfosWriter.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,102 +0,0 @@
-package org.apache.lucene.codecs.lucene46;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.codecs.FieldInfosWriter;
-import org.apache.lucene.index.FieldInfo.DocValuesType;
-import org.apache.lucene.index.FieldInfo.IndexOptions;
-import org.apache.lucene.index.FieldInfo;
-import org.apache.lucene.index.FieldInfos;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-
-/**
- * Lucene 4.6 FieldInfos writer.
- * 
- * @see Lucene46FieldInfosFormat
- * @lucene.experimental
- */
-final class Lucene46FieldInfosWriter extends FieldInfosWriter {
-  
-  /** Sole constructor. */
-  public Lucene46FieldInfosWriter() {
-  }
-  
-  @Override
-  public void write(Directory directory, String segmentName, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {
-    final String fileName = IndexFileNames.segmentFileName(segmentName, segmentSuffix, Lucene46FieldInfosFormat.EXTENSION);
-    try (IndexOutput output = directory.createOutput(fileName, context)) {
-      CodecUtil.writeHeader(output, Lucene46FieldInfosFormat.CODEC_NAME, Lucene46FieldInfosFormat.FORMAT_CURRENT);
-      output.writeVInt(infos.size());
-      for (FieldInfo fi : infos) {
-        IndexOptions indexOptions = fi.getIndexOptions();
-        byte bits = 0x0;
-        if (fi.hasVectors()) bits |= Lucene46FieldInfosFormat.STORE_TERMVECTOR;
-        if (fi.omitsNorms()) bits |= Lucene46FieldInfosFormat.OMIT_NORMS;
-        if (fi.hasPayloads()) bits |= Lucene46FieldInfosFormat.STORE_PAYLOADS;
-        if (fi.isIndexed()) {
-          bits |= Lucene46FieldInfosFormat.IS_INDEXED;
-          assert indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0 || !fi.hasPayloads();
-          if (indexOptions == IndexOptions.DOCS_ONLY) {
-            bits |= Lucene46FieldInfosFormat.OMIT_TERM_FREQ_AND_POSITIONS;
-          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) {
-            bits |= Lucene46FieldInfosFormat.STORE_OFFSETS_IN_POSTINGS;
-          } else if (indexOptions == IndexOptions.DOCS_AND_FREQS) {
-            bits |= Lucene46FieldInfosFormat.OMIT_POSITIONS;
-          }
-        }
-        output.writeString(fi.name);
-        output.writeVInt(fi.number);
-        output.writeByte(bits);
-
-        // pack the DV types in one byte
-        final byte dv = docValuesByte(fi.getDocValuesType());
-        final byte nrm = docValuesByte(fi.getNormType());
-        assert (dv & (~0xF)) == 0 && (nrm & (~0x0F)) == 0;
-        byte val = (byte) (0xff & ((nrm << 4) | dv));
-        output.writeByte(val);
-        output.writeLong(fi.getDocValuesGen());
-        output.writeStringStringMap(fi.attributes());
-      }
-      CodecUtil.writeFooter(output);
-    }
-  }
-  
-  private static byte docValuesByte(DocValuesType type) {
-    if (type == null) {
-      return 0;
-    } else if (type == DocValuesType.NUMERIC) {
-      return 1;
-    } else if (type == DocValuesType.BINARY) {
-      return 2;
-    } else if (type == DocValuesType.SORTED) {
-      return 3;
-    } else if (type == DocValuesType.SORTED_SET) {
-      return 4;
-    } else if (type == DocValuesType.SORTED_NUMERIC) {
-      return 5;
-    } else {
-      throw new AssertionError();
-    }
-  }  
-}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoFormat.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoFormat.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoFormat.java	2014-09-26 11:20:12.790287194 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoFormat.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,94 +0,0 @@
-package org.apache.lucene.codecs.lucene46;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.codecs.SegmentInfoFormat;
-import org.apache.lucene.codecs.SegmentInfoReader;
-import org.apache.lucene.codecs.SegmentInfoWriter;
-import org.apache.lucene.index.IndexWriter; // javadocs
-import org.apache.lucene.index.SegmentInfo; // javadocs
-import org.apache.lucene.index.SegmentInfos; // javadocs
-import org.apache.lucene.store.DataOutput; // javadocs
-
-/**
- * Lucene 4.6 Segment info format.
- * <p>
- * Files:
- * <ul>
- *   <li><tt>.si</tt>: Header, SegVersion, SegSize, IsCompoundFile, Diagnostics, Files, Id, Footer
- * </ul>
- * </p>
- * Data types:
- * <p>
- * <ul>
- *   <li>Header --&gt; {@link CodecUtil#writeHeader CodecHeader}</li>
- *   <li>SegSize --&gt; {@link DataOutput#writeInt Int32}</li>
- *   <li>SegVersion --&gt; {@link DataOutput#writeString String}</li>
- *   <li>Files --&gt; {@link DataOutput#writeStringSet Set&lt;String&gt;}</li>
- *   <li>Diagnostics --&gt; {@link DataOutput#writeStringStringMap Map&lt;String,String&gt;}</li>
- *   <li>IsCompoundFile --&gt; {@link DataOutput#writeByte Int8}</li>
- *   <li>Footer --&gt; {@link CodecUtil#writeFooter CodecFooter}</li>
- *   <li>Id --&gt; {@link DataOutput#writeString String}</li>
- * </ul>
- * </p>
- * Field Descriptions:
- * <p>
- * <ul>
- *   <li>SegVersion is the code version that created the segment.</li>
- *   <li>SegSize is the number of documents contained in the segment index.</li>
- *   <li>IsCompoundFile records whether the segment is written as a compound file or
- *       not. If this is -1, the segment is not a compound file. If it is 1, the segment
- *       is a compound file.</li>
- *   <li>The Diagnostics Map is privately written by {@link IndexWriter}, as a debugging aid,
- *       for each segment it creates. It includes metadata like the current Lucene
- *       version, OS, Java version, why the segment was created (merge, flush,
- *       addIndexes), etc.</li>
- *   <li>Files is a list of files referred to by this segment.</li>
- * </ul>
- * </p>
- * 
- * @see SegmentInfos
- * @lucene.experimental
- */
-public class Lucene46SegmentInfoFormat extends SegmentInfoFormat {
-  private final SegmentInfoReader reader = new Lucene46SegmentInfoReader();
-  private final SegmentInfoWriter writer = new Lucene46SegmentInfoWriter();
-
-  /** Sole constructor. */
-  public Lucene46SegmentInfoFormat() {
-  }
-  
-  @Override
-  public SegmentInfoReader getSegmentInfoReader() {
-    return reader;
-  }
-
-  @Override
-  public SegmentInfoWriter getSegmentInfoWriter() {
-    return writer;
-  }
-
-  /** File extension used to store {@link SegmentInfo}. */
-  public final static String SI_EXTENSION = "si";
-  static final String CODEC_NAME = "Lucene46SegmentInfo";
-  static final int VERSION_START = 0;
-  static final int VERSION_CHECKSUM = 1;
-  static final int VERSION_ID = 2;
-  static final int VERSION_CURRENT = VERSION_ID;
-}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java	2014-09-26 11:20:12.790287194 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,88 +0,0 @@
-package org.apache.lucene.codecs.lucene46;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.text.ParseException;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.codecs.SegmentInfoReader;
-import org.apache.lucene.index.CorruptIndexException;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.store.ChecksumIndexInput;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.util.Version;
-
-/**
- * Lucene 4.6 implementation of {@link SegmentInfoReader}.
- * 
- * @see Lucene46SegmentInfoFormat
- * @lucene.experimental
- */
-public class Lucene46SegmentInfoReader extends SegmentInfoReader {
-
-  /** Sole constructor. */
-  public Lucene46SegmentInfoReader() {
-  }
-
-  @Override
-  public SegmentInfo read(Directory dir, String segment, IOContext context) throws IOException {
-    final String fileName = IndexFileNames.segmentFileName(segment, "", Lucene46SegmentInfoFormat.SI_EXTENSION);
-    try (ChecksumIndexInput input = dir.openChecksumInput(fileName, context)) {
-      int codecVersion = CodecUtil.checkHeader(input, Lucene46SegmentInfoFormat.CODEC_NAME,
-                                                      Lucene46SegmentInfoFormat.VERSION_START,
-                                                      Lucene46SegmentInfoFormat.VERSION_CURRENT);
-      final Version version;
-      try {
-        version = Version.parse(input.readString());
-      } catch (ParseException pe) {
-        throw new CorruptIndexException("unable to parse version string: " + pe.getMessage(), input, pe);
-      }
-
-      final int docCount = input.readInt();
-      if (docCount < 0) {
-        throw new CorruptIndexException("invalid docCount: " + docCount, input);
-      }
-      final boolean isCompoundFile = input.readByte() == SegmentInfo.YES;
-      final Map<String,String> diagnostics = input.readStringStringMap();
-      final Set<String> files = input.readStringSet();
-      
-      String id;
-      if (codecVersion >= Lucene46SegmentInfoFormat.VERSION_ID) {
-        id = input.readString();
-      } else {
-        id = null;
-      }
-
-      if (codecVersion >= Lucene46SegmentInfoFormat.VERSION_CHECKSUM) {
-        CodecUtil.checkFooter(input);
-      } else {
-        CodecUtil.checkEOF(input);
-      }
-
-      final SegmentInfo si = new SegmentInfo(dir, version, segment, docCount, isCompoundFile, null, diagnostics, id);
-      si.setFiles(files);
-
-      return si;
-    }
-  }
-}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java	2014-09-26 11:20:12.790287194 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,80 +0,0 @@
-package org.apache.lucene.codecs.lucene46;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.CodecUtil;
-import org.apache.lucene.codecs.SegmentInfoWriter;
-import org.apache.lucene.index.FieldInfos;
-import org.apache.lucene.index.IndexFileNames;
-import org.apache.lucene.index.SegmentInfo;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.IOUtils;
-import org.apache.lucene.util.Version;
-
-/**
- * Lucene 4.0 implementation of {@link SegmentInfoWriter}.
- * 
- * @see Lucene46SegmentInfoFormat
- * @lucene.experimental
- */
-public class Lucene46SegmentInfoWriter extends SegmentInfoWriter {
-
-  /** Sole constructor. */
-  public Lucene46SegmentInfoWriter() {
-  }
-
-  /** Save a single segment's info. */
-  @Override
-  public void write(Directory dir, SegmentInfo si, FieldInfos fis, IOContext ioContext) throws IOException {
-    final String fileName = IndexFileNames.segmentFileName(si.name, "", Lucene46SegmentInfoFormat.SI_EXTENSION);
-    si.addFile(fileName);
-
-    final IndexOutput output = dir.createOutput(fileName, ioContext);
-
-    boolean success = false;
-    try {
-      CodecUtil.writeHeader(output, Lucene46SegmentInfoFormat.CODEC_NAME, Lucene46SegmentInfoFormat.VERSION_CURRENT);
-      Version version = si.getVersion();
-      if (version.major < 4) {
-        throw new IllegalArgumentException("invalid major version: should be >= 4 but got: " + version.major + " segment=" + si);
-      }
-      // Write the Lucene version that created this segment, since 3.1
-      output.writeString(version.toString());
-      output.writeInt(si.getDocCount());
-
-      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));
-      output.writeStringStringMap(si.getDiagnostics());
-      output.writeStringSet(si.files());
-      output.writeString(si.getId());
-      CodecUtil.writeFooter(output);
-      success = true;
-    } finally {
-      if (!success) {
-        IOUtils.closeWhileHandlingException(output);
-        // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?
-        IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);
-      } else {
-        output.close();
-      }
-    }
-  }
-}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene46/package.html branch/lucene/core/src/java/org/apache/lucene/codecs/lucene46/package.html
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene46/package.html	2014-09-26 11:20:12.790287194 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene46/package.html	1969-12-31 19:00:00.000000000 -0500
@@ -1,25 +0,0 @@
-<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
-<!--
- Licensed to the Apache Software Foundation (ASF) under one or more
- contributor license agreements.  See the NOTICE file distributed with
- this work for additional information regarding copyright ownership.
- The ASF licenses this file to You under the Apache License, Version 2.0
- (the "License"); you may not use this file except in compliance with
- the License.  You may obtain a copy of the License at
-
-     http://www.apache.org/licenses/LICENSE-2.0
-
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
--->
-<html>
-<head>
-   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
-</head>
-<body>
-Lucene 4.6 file format.
-</body>
-</html>
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50Codec.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50Codec.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50Codec.java	2014-09-25 17:27:33.205166407 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50Codec.java	2014-09-25 16:50:57.073128163 -0400
@@ -27,7 +27,6 @@
 import org.apache.lucene.codecs.SegmentInfoFormat;
 import org.apache.lucene.codecs.StoredFieldsFormat;
 import org.apache.lucene.codecs.TermVectorsFormat;
-import org.apache.lucene.codecs.lucene40.Lucene40LiveDocsFormat;
 import org.apache.lucene.codecs.lucene41.Lucene41StoredFieldsFormat;
 import org.apache.lucene.codecs.lucene42.Lucene42TermVectorsFormat;
 import org.apache.lucene.codecs.lucene49.Lucene49NormsFormat;
@@ -49,7 +48,7 @@
   private final TermVectorsFormat vectorsFormat = new Lucene42TermVectorsFormat();
   private final FieldInfosFormat fieldInfosFormat = new Lucene50FieldInfosFormat();
   private final SegmentInfoFormat segmentInfosFormat = new Lucene50SegmentInfoFormat();
-  private final LiveDocsFormat liveDocsFormat = new Lucene40LiveDocsFormat();
+  private final LiveDocsFormat liveDocsFormat = new Lucene50LiveDocsFormat();
   
   private final PostingsFormat postingsFormat = new PerFieldPostingsFormat() {
     @Override
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.java	2014-09-26 11:20:13.346287204 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.java	2014-09-25 22:21:12.377473235 -0400
@@ -25,6 +25,7 @@
 import org.apache.lucene.codecs.FieldInfosReader;
 import org.apache.lucene.codecs.FieldInfosWriter;
 import org.apache.lucene.index.FieldInfo.DocValuesType;
+import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.DataOutput;
 
 /**
@@ -35,7 +36,7 @@
  * FieldBits,DocValuesBits,DocValuesGen,Attributes&gt; <sup>FieldsCount</sup>,Footer</p>
  * <p>Data types:
  * <ul>
- *   <li>Header --&gt; {@link CodecUtil#checkHeader CodecHeader}</li>
+ *   <li>Header --&gt; {@link CodecUtil#checkSegmentHeader SegmentHeader}</li>
  *   <li>FieldsCount --&gt; {@link DataOutput#writeVInt VInt}</li>
  *   <li>FieldName --&gt; {@link DataOutput#writeString String}</li>
  *   <li>FieldBits, DocValuesBits --&gt; {@link DataOutput#writeByte Byte}</li>
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosReader.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosReader.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosReader.java	2014-09-26 11:20:13.422287205 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosReader.java	2014-09-25 16:42:12.501119028 -0400
@@ -29,6 +29,7 @@
 import org.apache.lucene.index.IndexFileNames;
 import org.apache.lucene.index.FieldInfo.DocValuesType;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.ChecksumIndexInput;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
@@ -47,15 +48,16 @@
   }
 
   @Override
-  public FieldInfos read(Directory directory, String segmentName, String segmentSuffix, IOContext context) throws IOException {
-    final String fileName = IndexFileNames.segmentFileName(segmentName, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);
+  public FieldInfos read(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, IOContext context) throws IOException {
+    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);
     try (ChecksumIndexInput input = directory.openChecksumInput(fileName, context)) {
       Throwable priorE = null;
       FieldInfo infos[] = null;
       try {
-        CodecUtil.checkHeader(input, Lucene50FieldInfosFormat.CODEC_NAME, 
+        CodecUtil.checkSegmentHeader(input, Lucene50FieldInfosFormat.CODEC_NAME, 
                                      Lucene50FieldInfosFormat.FORMAT_START, 
-                                     Lucene50FieldInfosFormat.FORMAT_CURRENT);
+                                     Lucene50FieldInfosFormat.FORMAT_CURRENT,
+                                     segmentInfo.getId());
         
         final int size = input.readVInt(); //read in the size
         infos = new FieldInfo[size];
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosWriter.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosWriter.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosWriter.java	2014-09-26 11:20:13.422287205 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosWriter.java	2014-09-25 16:42:38.729119484 -0400
@@ -26,6 +26,7 @@
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
@@ -43,10 +44,10 @@
   }
   
   @Override
-  public void write(Directory directory, String segmentName, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {
-    final String fileName = IndexFileNames.segmentFileName(segmentName, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);
+  public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {
+    final String fileName = IndexFileNames.segmentFileName(segmentInfo.name, segmentSuffix, Lucene50FieldInfosFormat.EXTENSION);
     try (IndexOutput output = directory.createOutput(fileName, context)) {
-      CodecUtil.writeHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT);
+      CodecUtil.writeSegmentHeader(output, Lucene50FieldInfosFormat.CODEC_NAME, Lucene50FieldInfosFormat.FORMAT_CURRENT, segmentInfo.getId());
       output.writeVInt(infos.size());
       for (FieldInfo fi : infos) {
         fi.checkConsistency();
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50LiveDocsFormat.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50LiveDocsFormat.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50LiveDocsFormat.java	1969-12-31 19:00:00.000000000 -0500
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50LiveDocsFormat.java	2014-09-26 09:08:45.074149834 -0400
@@ -0,0 +1,124 @@
+package org.apache.lucene.codecs.lucene50;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Collection;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.codecs.LiveDocsFormat;
+import org.apache.lucene.index.CorruptIndexException;
+import org.apache.lucene.index.IndexFileNames;
+import org.apache.lucene.index.SegmentCommitInfo;
+import org.apache.lucene.store.ChecksumIndexInput;
+import org.apache.lucene.store.DataOutput;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.FixedBitSet;
+import org.apache.lucene.util.MutableBits;
+
+/** 
+ * Lucene 5.0 live docs format 
+ * <p>
+ * <p>The .liv file is optional, and only exists when a segment contains
+ * deletions.</p>
+ * <p>Although per-segment, this file is maintained exterior to compound segment
+ * files.</p>
+ * <p>Deletions (.liv) --&gt; SegmentHeader,Generation,Bits</p>
+ * <ul>
+ *   <li>SegmentHeader --&gt; {@link CodecUtil#writeSegmentHeader SegmentHeader}</li>
+ *   <li>Generation --&gt; {@link DataOutput#writeLong Int64}
+ *   <li>Bits --&gt; &lt;{@link DataOutput#writeLong Int64}&gt; <sup>LongCount</sup></li>
+ * </ul>
+ */
+public class Lucene50LiveDocsFormat extends LiveDocsFormat {
+  
+  /** extension of live docs */
+  private static final String EXTENSION = "liv";
+  
+  /** codec of live docs */
+  private static final String CODEC_NAME = "Lucene50LiveDocs";
+  
+  /** supported version range */
+  private static final int VERSION_START = 0;
+  private static final int VERSION_CURRENT = VERSION_START;
+
+  @Override
+  public MutableBits newLiveDocs(int size) throws IOException {
+    FixedBitSet bits = new FixedBitSet(size);
+    bits.set(0, size);
+    return bits;
+  }
+
+  @Override
+  public MutableBits newLiveDocs(Bits existing) throws IOException {
+    FixedBitSet fbs = (FixedBitSet) existing;
+    return fbs.clone();
+  }
+
+  @Override
+  public Bits readLiveDocs(Directory dir, SegmentCommitInfo info, IOContext context) throws IOException {
+    long gen = info.getDelGen();
+    String name = IndexFileNames.fileNameFromGeneration(info.info.name, EXTENSION, gen);
+    final int length = info.info.getDocCount();
+    try (ChecksumIndexInput input = dir.openChecksumInput(name, context)) {
+      Throwable priorE = null;
+      try {
+        CodecUtil.checkSegmentHeader(input, CODEC_NAME, VERSION_START, VERSION_CURRENT, info.info.getId());
+        long filegen = input.readLong();
+        if (gen != filegen) {
+          throw new CorruptIndexException("file mismatch, expected generation=" + gen + ", got=" + filegen, input);
+        }
+        long data[] = new long[FixedBitSet.bits2words(length)];
+        for (int i = 0; i < data.length; i++) {
+          data[i] = input.readLong();
+        }
+        return new FixedBitSet(data, length);
+      } catch (Throwable exception) {
+        priorE = exception;
+      } finally {
+        CodecUtil.checkFooter(input, priorE);
+      }
+    }
+    throw new AssertionError();
+  }
+
+  @Override
+  public void writeLiveDocs(MutableBits bits, Directory dir, SegmentCommitInfo info, int newDelCount, IOContext context) throws IOException {
+    long gen = info.getNextDelGen();
+    String name = IndexFileNames.fileNameFromGeneration(info.info.name, EXTENSION, gen);
+    long data[] = ((FixedBitSet) bits).getBits();
+    try (IndexOutput output = dir.createOutput(name, context)) {
+      CodecUtil.writeSegmentHeader(output, CODEC_NAME, VERSION_CURRENT, info.info.getId());
+      output.writeLong(gen);
+      for (int i = 0; i < data.length; i++) {
+        output.writeLong(data[i]);
+      }
+      CodecUtil.writeFooter(output);
+    }
+  }
+
+  @Override
+  public void files(SegmentCommitInfo info, Collection<String> files) throws IOException {
+    if (info.hasDeletions()) {
+      files.add(IndexFileNames.fileNameFromGeneration(info.info.name, EXTENSION, info.getDelGen()));
+    }
+  }
+}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoReader.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoReader.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoReader.java	2014-09-25 17:27:33.197166407 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoReader.java	2014-09-26 00:57:34.181636614 -0400
@@ -30,6 +30,7 @@
 import org.apache.lucene.store.ChecksumIndexInput;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
+import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.Version;
 
 /**
@@ -69,7 +70,8 @@
         final Map<String,String> diagnostics = input.readStringStringMap();
         final Set<String> files = input.readStringSet();
         
-        String id = input.readString();
+        byte[] id = new byte[StringHelper.ID_LENGTH];
+        input.readBytes(id, 0, id.length);
         
         si = new SegmentInfo(dir, version, segment, docCount, isCompoundFile, null, diagnostics, id);
         si.setFiles(files);
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoWriter.java branch/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoWriter.java
--- trunk/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoWriter.java	2014-09-25 17:27:33.197166407 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoWriter.java	2014-09-26 11:00:08.426266221 -0400
@@ -18,6 +18,7 @@
  */
 
 import java.io.IOException;
+import java.util.Set;
 
 import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.SegmentInfoWriter;
@@ -28,6 +29,7 @@
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.Version;
 
 /**
@@ -48,10 +50,8 @@
     final String fileName = IndexFileNames.segmentFileName(si.name, "", Lucene50SegmentInfoFormat.SI_EXTENSION);
     si.addFile(fileName);
 
-    final IndexOutput output = dir.createOutput(fileName, ioContext);
-
     boolean success = false;
-    try {
+    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {
       CodecUtil.writeHeader(output, Lucene50SegmentInfoFormat.CODEC_NAME, Lucene50SegmentInfoFormat.VERSION_CURRENT);
       Version version = si.getVersion();
       if (version.major < 5) {
@@ -63,17 +63,24 @@
 
       output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));
       output.writeStringStringMap(si.getDiagnostics());
-      output.writeStringSet(si.files());
-      output.writeString(si.getId());
+      Set<String> files = si.files();
+      for (String file : files) {
+        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {
+          throw new IllegalArgumentException("invalid files: expected segment=" + si.name + ", got=" + files);
+        }
+      }
+      output.writeStringSet(files);
+      byte[] id = si.getId();
+      if (id.length != StringHelper.ID_LENGTH) {
+        throw new IllegalArgumentException("invalid id, got=" + StringHelper.idToString(id));
+      }
+      output.writeBytes(id, 0, id.length);
       CodecUtil.writeFooter(output);
       success = true;
     } finally {
       if (!success) {
-        IOUtils.closeWhileHandlingException(output);
         // TODO: are we doing this outside of the tracking wrapper? why must SIWriter cleanup like this?
         IOUtils.deleteFilesIgnoringExceptions(si.dir, fileName);
-      } else {
-        output.close();
       }
     }
   }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java branch/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
--- trunk/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java	2014-09-25 17:27:33.137166406 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java	2014-09-26 01:00:45.781639951 -0400
@@ -47,6 +47,7 @@
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LongBitSet;
+import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.Version;
 
 
@@ -514,7 +515,7 @@
     }
 
     msg(infoStream, "Segments file=" + segmentsFileName + " numSegments=" + numSegments
-        + " " + versionString + " id=" + sis.getId() + " format=" + sFormat + userDataString);
+        + " " + versionString + " id=" + StringHelper.idToString(sis.getId()) + " format=" + sFormat + userDataString);
 
     if (onlySegments != null) {
       result.partial = true;
@@ -565,7 +566,7 @@
 
       try {
         msg(infoStream, "    version=" + (version == null ? "3.0" : version));
-        msg(infoStream, "    id=" + info.info.getId());
+        msg(infoStream, "    id=" + StringHelper.idToString(info.info.getId()));
         final Codec codec = info.info.getCodec();
         msg(infoStream, "    codec=" + codec);
         segInfoStat.codec = codec;
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java branch/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java
--- trunk/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java	2014-09-26 11:20:12.782287194 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java	2014-09-25 09:24:31.576661708 -0400
@@ -119,7 +119,7 @@
     // FreqProxTermsWriter does this with
     // FieldInfo.storePayload.
     FieldInfosWriter infosWriter = docWriter.codec.fieldInfosFormat().getFieldInfosWriter();
-    infosWriter.write(state.directory, state.segmentInfo.name, "", state.fieldInfos, IOContext.DEFAULT);
+    infosWriter.write(state.directory, state.segmentInfo, "", state.fieldInfos, IOContext.DEFAULT);
   }
 
   /** Writes all buffered doc values (called from {@link #flush}). */
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java branch/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
--- trunk/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java	2014-09-26 11:20:13.346287204 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java	2014-09-25 08:26:53.720601491 -0400
@@ -2591,67 +2591,33 @@
   }
 
   /** Copies the segment files as-is into the IndexWriter's directory. */
-  private SegmentCommitInfo copySegmentAsIs(SegmentCommitInfo info, String segName, IOContext context)
-      throws IOException {
-    
-    // note: we don't really need this fis (its copied), but we load it up
-    // so we don't pass a null value to the si writer
-    FieldInfos fis = SegmentReader.readFieldInfos(info);
+  private SegmentCommitInfo copySegmentAsIs(SegmentCommitInfo info, String segName, IOContext context) throws IOException {
     
     //System.out.println("copy seg=" + info.info.name + " version=" + info.info.getVersion());
     // Same SI as before but we change directory and name
     SegmentInfo newInfo = new SegmentInfo(directory, info.info.getVersion(), segName, info.info.getDocCount(),
                                           info.info.getUseCompoundFile(), info.info.getCodec(), 
-                                          info.info.getDiagnostics(), StringHelper.randomId());
-    SegmentCommitInfo newInfoPerCommit = new SegmentCommitInfo(newInfo,
-        info.getDelCount(), info.getDelGen(), info.getFieldInfosGen(),
-        info.getDocValuesGen());
-
-    Set<String> segFiles = new HashSet<>();
-
-    // Build up new segment's file names.  Must do this
-    // before writing SegmentInfo:
-    for (String file: info.files()) {
-      final String newFileName;
-      newFileName = segName + IndexFileNames.stripSegmentName(file);
-      segFiles.add(newFileName);
-    }
-    newInfo.setFiles(segFiles);
-
-    // We must rewrite the SI file because it references segment name in its list of files, etc
-    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);
+                                          info.info.getDiagnostics(), info.info.getId());
+    SegmentCommitInfo newInfoPerCommit = new SegmentCommitInfo(newInfo, info.getDelCount(), info.getDelGen(), 
+                                                               info.getFieldInfosGen(), info.getDocValuesGen());
+    
+    newInfo.setFiles(info.files());
 
     boolean success = false;
 
     try {
-
-      newInfo.getCodec().segmentInfoFormat().getSegmentInfoWriter().write(trackingDir, newInfo, fis, context);
-
-      final Collection<String> siFiles = trackingDir.getCreatedFiles();
-
       // Copy the segment's files
       for (String file: info.files()) {
+        final String newFileName = newInfo.namedForThisSegment(file);
 
-        final String newFileName = segName + IndexFileNames.stripSegmentName(file);
-
-        if (siFiles.contains(newFileName)) {
-          // We already rewrote this above
-          continue;
-        }
-
-        assert !slowFileExists(directory, newFileName): "file \"" + newFileName + "\" already exists; siFiles=" + siFiles;
+        assert !slowFileExists(directory, newFileName): "file \"" + newFileName + "\" already exists; newInfo.files=" + newInfo.files();
 
         info.info.dir.copy(directory, file, newFileName, context);
       }
       success = true;
     } finally {
       if (!success) {
-        for(String file : newInfo.files()) {
-          try {
-            directory.deleteFile(file);
-          } catch (Throwable t) {
-          }
-        }
+        IOUtils.deleteFilesIgnoringExceptions(directory, newInfo.files().toArray(new String[0]));
       }
     }
     
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java branch/lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java
--- trunk/lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java	2014-09-26 11:20:12.782287194 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java	2014-09-25 09:25:17.880662514 -0400
@@ -451,7 +451,7 @@
     final IOContext infosContext = new IOContext(new FlushInfo(info.info.getDocCount(), estInfosSize));
     // separately also track which files were created for this gen
     final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);
-    infosFormat.getFieldInfosWriter().write(trackingDir, info.info.name, segmentSuffix, fieldInfos, infosContext);
+    infosFormat.getFieldInfosWriter().write(trackingDir, info.info, segmentSuffix, fieldInfos, infosContext);
     info.advanceFieldInfosGen();
     return trackingDir.getCreatedFiles();
   }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo.java branch/lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo.java
--- trunk/lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo.java	2014-09-26 11:20:12.782287194 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo.java	2014-09-25 08:26:53.748601492 -0400
@@ -109,7 +109,14 @@
   @Deprecated
   public void setGenUpdatesFiles(Map<Long,Set<String>> genUpdatesFiles) {
     this.genUpdatesFiles.clear();
-    this.genUpdatesFiles.putAll(genUpdatesFiles);
+    for (Map.Entry<Long,Set<String>> kv : genUpdatesFiles.entrySet()) {
+      // rename the set
+      Set<String> set = new HashSet<>();
+      for (String file : kv.getValue()) {
+        set.add(info.namedForThisSegment(file));
+      }
+      this.genUpdatesFiles.put(kv.getKey(), set);
+    }
   }
   
   /** Returns the per-field DocValues updates files. */
@@ -120,7 +127,14 @@
   /** Sets the DocValues updates file names, per field number. Does not deep clone the map. */
   public void setDocValuesUpdatesFiles(Map<Integer,Set<String>> dvUpdatesFiles) {
     this.dvUpdatesFiles.clear();
-    this.dvUpdatesFiles.putAll(dvUpdatesFiles);
+    for (Map.Entry<Integer,Set<String>> kv : dvUpdatesFiles.entrySet()) {
+      // rename the set
+      Set<String> set = new HashSet<>();
+      for (String file : kv.getValue()) {
+        set.add(info.namedForThisSegment(file));
+      }
+      this.dvUpdatesFiles.put(kv.getKey(), set);
+    }
   }
   
   /** Returns the FieldInfos file names. */
@@ -131,7 +145,9 @@
   /** Sets the FieldInfos file names. */
   public void setFieldInfosFiles(Set<String> fieldInfosFiles) {
     this.fieldInfosFiles.clear();
-    this.fieldInfosFiles.addAll(fieldInfosFiles);
+    for (String file : fieldInfosFiles) {
+      this.fieldInfosFiles.add(info.namedForThisSegment(file));
+    }
   }
 
   /** Called when we succeed in writing deletes */
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java branch/lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java
--- trunk/lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java	2014-09-26 11:20:12.782287194 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java	2014-09-26 01:04:28.897643836 -0400
@@ -18,8 +18,10 @@
  */
 
 
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.regex.Matcher;
@@ -58,7 +60,7 @@
   private boolean isCompoundFile;
 
   /** Id that uniquely identifies this segment. */
-  private final String id;
+  private final byte[] id;
 
   private Codec codec;
 
@@ -82,22 +84,13 @@
   }
 
   /**
-   * Construct a new complete SegmentInfo instance from
-   * input, with a newly generated random id.
-   */
-  public SegmentInfo(Directory dir, Version version, String name, int docCount,
-                     boolean isCompoundFile, Codec codec, Map<String,String> diagnostics) {
-    this(dir, version, name, docCount, isCompoundFile, codec, diagnostics, null);
-  }
-
-  /**
    * Construct a new complete SegmentInfo instance from input.
    * <p>Note: this is public only to allow access from
    * the codecs package.</p>
    */
   public SegmentInfo(Directory dir, Version version, String name, int docCount,
                      boolean isCompoundFile, Codec codec, Map<String,String> diagnostics,
-                     String id) {
+                     byte[] id) {
     assert !(dir instanceof TrackingDirectoryWrapper);
     this.dir = dir;
     this.version = version;
@@ -107,6 +100,9 @@
     this.codec = codec;
     this.diagnostics = diagnostics;
     this.id = id;
+    if (id != null && id.length != StringHelper.ID_LENGTH) {
+      throw new IllegalArgumentException("invalid id: " + Arrays.toString(id));
+    }
   }
 
   /**
@@ -226,30 +222,32 @@
   }
 
   /** Return the id that uniquely identifies this segment. */
-  public String getId() {
-    return id;
+  public byte[] getId() {
+    return id == null ? null : id.clone();
   }
 
   private Set<String> setFiles;
 
   /** Sets the files written for this segment. */
-  public void setFiles(Set<String> files) {
-    checkFileNames(files);
-    setFiles = files;
+  public void setFiles(Collection<String> files) {
+    setFiles = new HashSet<>();
+    addFiles(files);
   }
 
   /** Add these files to the set of files written for this
    *  segment. */
   public void addFiles(Collection<String> files) {
     checkFileNames(files);
-    setFiles.addAll(files);
+    for (String f : files) {
+      setFiles.add(namedForThisSegment(f));
+    }
   }
 
   /** Add this file to the set of files written for this
    *  segment. */
   public void addFile(String file) {
     checkFileNames(Collections.singleton(file));
-    setFiles.add(file);
+    setFiles.add(namedForThisSegment(file));
   }
   
   private void checkFileNames(Collection<String> files) {
@@ -261,5 +259,12 @@
       }
     }
   }
-    
+  
+  /** 
+   * strips any segment name from the file, naming it with this segment
+   * this is because "segment names" can change, e.g. by addIndexes(Dir)
+   */
+  String namedForThisSegment(String file) {
+    return name + IndexFileNames.stripSegmentName(file);
+  }
 }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java branch/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
--- trunk/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java	2014-09-23 10:04:34.653694339 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java	2014-09-26 00:58:51.765637965 -0400
@@ -125,8 +125,8 @@
   /** The file format version for the segments_N codec header, since 4.9+ */
   public static final int VERSION_49 = 3;
 
-  /** The file format version for the segments_N codec header, since 4.11+ */
-  public static final int VERSION_411 = 4;
+  /** The file format version for the segments_N codec header, since 5.0+ */
+  public static final int VERSION_50 = 4;
 
   /** Used to name new segments. */
   // TODO: should this be a long ...?
@@ -151,8 +151,8 @@
    */
   private static PrintStream infoStream = null;
 
-  /** Id for this commit; only written starting with Lucene 4.11 */
-  private String id;
+  /** Id for this commit; only written starting with Lucene 5.0 */
+  private byte[] id;
 
   /** Sole constructor. Typically you call this and then
    *  use {@link #read(Directory) or
@@ -262,10 +262,10 @@
                                                  nextGeneration);
   }
 
-  /** Since Lucene 4.11, every commit (segments_N) writes a unique id.  This will
-   *  return that id, or null if this commit was pre-4.11. */
-  public String getId() {
-    return id;
+  /** Since Lucene 5.0, every commit (segments_N) writes a unique id.  This will
+   *  return that id, or null if this commit was 5.0. */
+  public byte[] getId() {
+    return id == null ? null : id.clone();
   }
 
   /**
@@ -296,7 +296,7 @@
         throw new IndexFormatTooOldException(input, magic, CodecUtil.CODEC_MAGIC, CodecUtil.CODEC_MAGIC);
       }
       // 4.0+
-      int format = CodecUtil.checkHeaderNoMagic(input, "segments", VERSION_40, VERSION_411);
+      int format = CodecUtil.checkHeaderNoMagic(input, "segments", VERSION_40, VERSION_50);
       version = input.readLong();
       counter = input.readInt();
       int numSegments = input.readInt();
@@ -361,8 +361,9 @@
         add(siPerCommit);
       }
       userData = input.readStringStringMap();
-      if (format >= VERSION_411) {
-        id = input.readString();
+      if (format >= VERSION_50) {
+        id = new byte[StringHelper.ID_LENGTH];
+        input.readBytes(id, 0, id.length);
       }
 
       if (format >= VERSION_48) {
@@ -425,7 +426,7 @@
 
     try {
       segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);
-      CodecUtil.writeHeader(segnOutput, "segments", VERSION_411);
+      CodecUtil.writeHeader(segnOutput, "segments", VERSION_50);
       segnOutput.writeLong(version); 
       segnOutput.writeInt(counter); // write counter
       segnOutput.writeInt(size()); // write infos
@@ -451,7 +452,8 @@
         assert si.dir == directory;
       }
       segnOutput.writeStringStringMap(userData);
-      segnOutput.writeString(StringHelper.randomId());
+      byte[] id = StringHelper.randomId();
+      segnOutput.writeBytes(id, 0, id.length);
       CodecUtil.writeFooter(segnOutput);
       segnOutput.close();
       directory.sync(Collections.singleton(segmentFileName));
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java branch/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java
--- trunk/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java	2014-09-26 11:20:13.346287204 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/index/SegmentMerger.java	2014-09-25 09:25:25.972662655 -0400
@@ -146,7 +146,7 @@
     
     // write the merged infos
     FieldInfosWriter fieldInfosWriter = codec.fieldInfosFormat().getFieldInfosWriter();
-    fieldInfosWriter.write(directory, mergeState.segmentInfo.name, "", mergeState.fieldInfos, context);
+    fieldInfosWriter.write(directory, mergeState.segmentInfo, "", mergeState.fieldInfos, context);
 
     return mergeState;
   }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/index/SegmentReader.java branch/lucene/core/src/java/org/apache/lucene/index/SegmentReader.java
--- trunk/lucene/core/src/java/org/apache/lucene/index/SegmentReader.java	2014-09-26 11:20:13.346287204 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/index/SegmentReader.java	2014-09-25 09:29:36.304667015 -0400
@@ -217,7 +217,7 @@
       final String segmentSuffix = info.getFieldInfosGen() == -1 ? "" : Long.toString(info.getFieldInfosGen(), Character.MAX_RADIX);
       Codec codec = info.info.getCodec();
       FieldInfosFormat fisFormat = codec.fieldInfosFormat();
-      return fisFormat.getFieldInfosReader().read(dir, info.info.name, segmentSuffix, IOContext.READONCE);
+      return fisFormat.getFieldInfosReader().read(dir, info.info, segmentSuffix, IOContext.READONCE);
     } finally {
       if (closeDir) {
         dir.close();
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java branch/lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java
--- trunk/lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java	2014-08-06 12:26:35.876458861 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java	2014-09-25 21:57:11.649448146 -0400
@@ -31,7 +31,7 @@
  * 
  * @lucene.internal
  */
-public final class FixedBitSet extends DocIdSet implements Bits {
+public final class FixedBitSet extends DocIdSet implements MutableBits {
 
   private static final long BASE_RAM_BYTES_USED = RamUsageEstimator.shallowSizeOfInstance(FixedBitSet.class);
 
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/java/org/apache/lucene/util/StringHelper.java branch/lucene/core/src/java/org/apache/lucene/util/StringHelper.java
--- trunk/lucene/core/src/java/org/apache/lucene/util/StringHelper.java	2014-09-04 10:11:43.769114250 -0400
+++ branch/lucene/core/src/java/org/apache/lucene/util/StringHelper.java	2014-09-26 01:16:40.085656570 -0400
@@ -232,21 +232,21 @@
 
   // Holds 128 bit unsigned value:
   private static BigInteger nextId;
-  private static final BigInteger idMask;
+  private static final BigInteger mask128;
   private static final Object idLock = new Object();
-  private static final String idPad = "00000000000000000000000000000000";
 
   static {
-    byte[] maskBytes = new byte[16];
-    Arrays.fill(maskBytes, (byte) 0xff);
-    idMask = new BigInteger(maskBytes);
+    // 128 bit unsigned mask
+    byte[] maskBytes128 = new byte[16];
+    Arrays.fill(maskBytes128, (byte) 0xff);
+    mask128 = new BigInteger(1, maskBytes128);
+    
     String prop = System.getProperty("tests.seed");
 
     // State for xorshift128:
     long x0;
     long x1;
 
-    long seed;
     if (prop != null) {
       // So if there is a test failure that somehow relied on this id,
       // we remain reproducible based on the test seed:
@@ -280,17 +280,25 @@
       s1 ^= s1 << 23; // a
       x1 = s1 ^ s0 ^ (s1 >>> 17) ^ (s0 >>> 26); // b, c
     }
+    
+    // 64-bit unsigned mask
+    byte[] maskBytes64 = new byte[8];
+    Arrays.fill(maskBytes64, (byte) 0xff);
+    BigInteger mask64 = new BigInteger(1, maskBytes64);
 
     // First make unsigned versions of x0, x1:
-    BigInteger unsignedX0 = new BigInteger(1, BigInteger.valueOf(x0).toByteArray());
-    BigInteger unsignedX1 = new BigInteger(1, BigInteger.valueOf(x1).toByteArray());
+    BigInteger unsignedX0 = BigInteger.valueOf(x0).and(mask64);
+    BigInteger unsignedX1 = BigInteger.valueOf(x1).and(mask64);
 
     // Concatentate bits of x0 and x1, as unsigned 128 bit integer:
     nextId = unsignedX0.shiftLeft(64).or(unsignedX1);
   }
+  
+  /** length in bytes of an ID */
+  public static final int ID_LENGTH = 16;
 
   /** Generates a non-cryptographic globally unique id. */
-  public static String randomId() {
+  public static byte[] randomId() {
 
     // NOTE: we don't use Java's UUID.randomUUID() implementation here because:
     //
@@ -306,15 +314,42 @@
     //     what impact that has on the period, whereas the simple ++ (mod 2^128)
     //     we use here is guaranteed to have the full period.
 
-    String id;
+    byte bits[];
     synchronized(idLock) {
-      id = nextId.toString(16);
-      nextId = nextId.add(BigInteger.ONE).and(idMask);
+      bits = nextId.toByteArray();
+      nextId = nextId.add(BigInteger.ONE).and(mask128);
+    }
+    
+    // toByteArray() always returns a sign bit, so it may require an extra byte (always zero)
+    if (bits.length > ID_LENGTH) {
+      assert bits.length == ID_LENGTH + 1;
+      assert bits[0] == 0;
+      return Arrays.copyOfRange(bits, 1, bits.length);
+    } else {
+      byte[] result = new byte[ID_LENGTH];
+      System.arraycopy(bits, 0, result, result.length - bits.length, bits.length);
+      return result;
+    }
+  }
+  
+  /** 
+   * Helper method to render an ID as a string, for debugging
+   * <p>
+   * Returns the string {@code (null)} if the id is null.
+   * Otherwise, returns a string representation for debugging.
+   * Never throws an exception. The returned string may
+   * indicate if the id is definitely invalid.
+   */
+  public static String idToString(byte id[]) {
+    if (id == null) {
+      return "(null)";
+    } else {
+      StringBuilder sb = new StringBuilder();
+      sb.append(new BigInteger(1, id).toString(Character.MAX_RADIX));
+      if (id.length != ID_LENGTH) {
+        sb.append(" (INVALID FORMAT)");
+      }
+      return sb.toString();
     }
-
-    assert id.length() <= 32: "id=" + id;
-    id = idPad.substring(id.length()) + id;
-
-    return id;
   }
 }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/test/org/apache/lucene/index/TestCodecs.java branch/lucene/core/src/test/org/apache/lucene/index/TestCodecs.java
--- trunk/lucene/core/src/test/org/apache/lucene/index/TestCodecs.java	2014-09-26 11:20:13.198287201 -0400
+++ branch/lucene/core/src/test/org/apache/lucene/index/TestCodecs.java	2014-09-25 09:42:05.468680061 -0400
@@ -42,6 +42,7 @@
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.TestUtil;
 import org.apache.lucene.util.Version;
 import org.junit.BeforeClass;
@@ -248,7 +249,7 @@
     final Directory dir = newDirectory();
     this.write(fieldInfos, dir, fields);
     Codec codec = Codec.getDefault();
-    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, SEGMENT, 10000, false, codec, null);
+    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, SEGMENT, 10000, false, codec, null, StringHelper.randomId());
 
     final FieldsProducer reader = codec.postingsFormat().fieldsProducer(new SegmentReadState(dir, si, fieldInfos, newIOContext(random())));
 
@@ -305,7 +306,7 @@
 
     this.write(fieldInfos, dir, fields);
     Codec codec = Codec.getDefault();
-    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, SEGMENT, 10000, false, codec, null);
+    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, SEGMENT, 10000, false, codec, null, StringHelper.randomId());
 
     if (VERBOSE) {
       System.out.println("TEST: now read postings");
@@ -800,7 +801,7 @@
   private void write(final FieldInfos fieldInfos, final Directory dir, final FieldData[] fields) throws Throwable {
 
     final Codec codec = Codec.getDefault();
-    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, SEGMENT, 10000, false, codec, null);
+    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, SEGMENT, 10000, false, codec, null, StringHelper.randomId());
     final SegmentWriteState state = new SegmentWriteState(InfoStream.getDefault(), dir, si, fieldInfos, null, newIOContext(random()));
 
     Arrays.sort(fields);
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/test/org/apache/lucene/index/TestDoc.java branch/lucene/core/src/test/org/apache/lucene/index/TestDoc.java
--- trunk/lucene/core/src/test/org/apache/lucene/index/TestDoc.java	2014-09-26 11:20:13.198287201 -0400
+++ branch/lucene/core/src/test/org/apache/lucene/index/TestDoc.java	2014-09-25 09:46:01.496684171 -0400
@@ -43,6 +43,7 @@
 import org.apache.lucene.store.TrackingDirectoryWrapper;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.Version;
 
 
@@ -218,7 +219,7 @@
 
       final Codec codec = Codec.getDefault();
       TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(si1.info.dir);
-      final SegmentInfo si = new SegmentInfo(si1.info.dir, Version.LATEST, merged, -1, false, codec, null);
+      final SegmentInfo si = new SegmentInfo(si1.info.dir, Version.LATEST, merged, -1, false, codec, null, StringHelper.randomId());
 
       SegmentMerger merger = new SegmentMerger(Arrays.<LeafReader>asList(r1, r2),
           si, InfoStream.getDefault(), trackingDir,
@@ -226,21 +227,18 @@
 
       MergeState mergeState = merger.merge();
       r1.close();
-      r2.close();
-      final SegmentInfo info = new SegmentInfo(si1.info.dir, Version.LATEST, merged,
-                                               si1.info.getDocCount() + si2.info.getDocCount(),
-                                               false, codec, null);
-      info.setFiles(new HashSet<>(trackingDir.getCreatedFiles()));
+      r2.close();;
+      si.setFiles(new HashSet<>(trackingDir.getCreatedFiles()));
       
       if (useCompoundFile) {
-        Collection<String> filesToDelete = IndexWriter.createCompoundFile(InfoStream.getDefault(), dir, MergeState.CheckAbort.NONE, info, newIOContext(random()));
-        info.setUseCompoundFile(true);
+        Collection<String> filesToDelete = IndexWriter.createCompoundFile(InfoStream.getDefault(), dir, MergeState.CheckAbort.NONE, si, newIOContext(random()));
+        si.setUseCompoundFile(true);
         for (final String fileToDelete : filesToDelete) {
           si1.info.dir.deleteFile(fileToDelete);
         }
       }
 
-      return new SegmentCommitInfo(info, 0, -1L, -1L, -1L);
+      return new SegmentCommitInfo(si, 0, -1L, -1L, -1L);
    }
 
 
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/test/org/apache/lucene/index/TestFieldInfos.java branch/lucene/core/src/test/org/apache/lucene/index/TestFieldInfos.java
--- trunk/lucene/core/src/test/org/apache/lucene/index/TestFieldInfos.java	2014-09-26 11:20:12.782287194 -0400
+++ branch/lucene/core/src/test/org/apache/lucene/index/TestFieldInfos.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,115 +0,0 @@
-package org.apache.lucene.index;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.codecs.Codec;
-import org.apache.lucene.codecs.FieldInfosReader;
-import org.apache.lucene.codecs.FieldInfosWriter;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.IOContext;
-import org.apache.lucene.store.IndexOutput;
-import org.apache.lucene.util.LuceneTestCase;
-
-//import org.cnlp.utils.properties.ResourceBundleHelper;
-
-public class TestFieldInfos extends LuceneTestCase {
-
-  private Document testDoc = new Document();
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    DocHelper.setupDoc(testDoc);
-  }
-
-  public FieldInfos createAndWriteFieldInfos(Directory dir, String filename) throws IOException{
-  //Positive test of FieldInfos
-    assertTrue(testDoc != null);
-    FieldInfos.Builder builder = new FieldInfos.Builder();
-    for (IndexableField field : testDoc.getFields()) {
-      builder.addOrUpdate(field.name(), field.fieldType());
-    }
-    FieldInfos fieldInfos = builder.finish();
-    //Since the complement is stored as well in the fields map
-    assertTrue(fieldInfos.size() == DocHelper.all.size()); //this is all b/c we are using the no-arg constructor
-    
-    
-    IndexOutput output = dir.createOutput(filename, newIOContext(random()));
-    assertTrue(output != null);
-    //Use a RAMOutputStream
-  
-    FieldInfosWriter writer = Codec.getDefault().fieldInfosFormat().getFieldInfosWriter();
-    writer.write(dir, filename, "", fieldInfos, IOContext.DEFAULT);
-    output.close();
-    return fieldInfos;
-  }
-  
-  public FieldInfos readFieldInfos(Directory dir, String filename) throws IOException {
-    FieldInfosReader reader = Codec.getDefault().fieldInfosFormat().getFieldInfosReader();
-    return reader.read(dir, filename, "", IOContext.DEFAULT);
-  }
-  
-  public void test() throws IOException {
-    String name = "testFile";
-    Directory dir = newDirectory();
-    FieldInfos fieldInfos = createAndWriteFieldInfos(dir, name);
-
-    FieldInfos readIn = readFieldInfos(dir, name);
-    assertTrue(fieldInfos.size() == readIn.size());
-    FieldInfo info = readIn.fieldInfo("textField1");
-    assertTrue(info != null);
-    assertTrue(info.hasVectors() == false);
-    assertTrue(info.omitsNorms() == false);
-
-    info = readIn.fieldInfo("textField2");
-    assertTrue(info != null);
-    assertTrue(info.omitsNorms() == false);
-
-    info = readIn.fieldInfo("textField3");
-    assertTrue(info != null);
-    assertTrue(info.hasVectors() == false);
-    assertTrue(info.omitsNorms() == true);
-
-    info = readIn.fieldInfo("omitNorms");
-    assertTrue(info != null);
-    assertTrue(info.hasVectors() == false);
-    assertTrue(info.omitsNorms() == true);
-
-    dir.close();
-  }
-  
-  public void testReadOnly() throws IOException {
-    String name = "testFile";
-    Directory dir = newDirectory();
-    FieldInfos fieldInfos = createAndWriteFieldInfos(dir, name);
-    FieldInfos readOnly = readFieldInfos(dir, name);
-    assertReadOnly(readOnly, fieldInfos);
-    dir.close();
-  }
-  
-  private void assertReadOnly(FieldInfos readOnly, FieldInfos modifiable) {    
-    assertEquals(modifiable.size(), readOnly.size());
-    // assert we can iterate
-    for (FieldInfo fi : readOnly) {
-      assertEquals(fi.name, modifiable.fieldInfo(fi.number).name);
-    }
-  }
-}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter.java branch/lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter.java
--- trunk/lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter.java	2014-09-23 10:04:34.253694332 -0400
+++ branch/lucene/core/src/test/org/apache/lucene/index/TestIndexFileDeleter.java	2014-09-25 17:09:48.637147868 -0400
@@ -96,7 +96,7 @@
     */
 
     // TODO: fix this test better
-    String ext = Codec.getDefault().getName().equals("SimpleText") ? ".liv" : ".del";
+    String ext = ".liv";
     
     // Create a bogus separate del file for a
     // segment that already has a separate del file: 
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java branch/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java
--- trunk/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java	2014-09-25 17:27:33.421166411 -0400
+++ branch/lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java	2014-09-26 01:05:00.213644382 -0400
@@ -2767,11 +2767,13 @@
     
     SegmentInfos sis = new SegmentInfos();
     sis.read(d);
-    String id1 = sis.getId();
+    byte[] id1 = sis.getId();
     assertNotNull(id1);
+    assertEquals(StringHelper.ID_LENGTH, id1.length);
     
-    String id2 = sis.info(0).info.getId();
+    byte[] id2 = sis.info(0).info.getId();
     assertNotNull(id2);
+    assertEquals(StringHelper.ID_LENGTH, id2.length);
 
     // Make sure CheckIndex includes id output:
     ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);
@@ -2784,14 +2786,14 @@
     assertTrue(s, indexStatus != null && indexStatus.clean);
 
     // Commit id is always stored:
-    assertTrue("missing id=" + id1 + " in:\n" + s, s.contains("id=" + id1));
+    assertTrue("missing id=" + StringHelper.idToString(id1) + " in:\n" + s, s.contains("id=" + StringHelper.idToString(id1)));
 
-    assertTrue("missing id=" + id2 + " in:\n" + s, s.contains("id=" + id2));
+    assertTrue("missing id=" + StringHelper.idToString(id1) + " in:\n" + s, s.contains("id=" + StringHelper.idToString(id1)));
     d.close();
 
     Set<String> ids = new HashSet<>();
     for(int i=0;i<100000;i++) {
-      String id = StringHelper.randomId();
+      String id = StringHelper.idToString(StringHelper.randomId());
       assertFalse("id=" + id + " i=" + i, ids.contains(id));
       ids.add(id);
     }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/core/src/test/org/apache/lucene/index/TestSegmentMerger.java branch/lucene/core/src/test/org/apache/lucene/index/TestSegmentMerger.java
--- trunk/lucene/core/src/test/org/apache/lucene/index/TestSegmentMerger.java	2014-09-26 11:20:13.330287203 -0400
+++ branch/lucene/core/src/test/org/apache/lucene/index/TestSegmentMerger.java	2014-09-25 09:47:37.744685847 -0400
@@ -28,6 +28,7 @@
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.TestUtil;
 import org.apache.lucene.util.Version;
 
@@ -78,7 +79,7 @@
 
   public void testMerge() throws IOException {
     final Codec codec = Codec.getDefault();
-    final SegmentInfo si = new SegmentInfo(mergedDir, Version.LATEST, mergedSegment, -1, false, codec, null);
+    final SegmentInfo si = new SegmentInfo(mergedDir, Version.LATEST, mergedSegment, -1, false, codec, null, StringHelper.randomId());
 
     SegmentMerger merger = new SegmentMerger(Arrays.<LeafReader>asList(reader1, reader2),
         si, InfoStream.getDefault(), mergedDir,
@@ -88,8 +89,7 @@
     assertTrue(docsMerged == 2);
     //Should be able to open a new SegmentReader against the new directory
     SegmentReader mergedReader = new SegmentReader(new SegmentCommitInfo(
-                                                         new SegmentInfo(mergedDir, Version.LATEST, mergedSegment, docsMerged,
-                                                                         false, codec, null),
+                                                         mergeState.segmentInfo,
                                                          0, -1L, -1L, -1L),
                                                    newIOContext(random()));
     assertTrue(mergedReader != null);
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/misc/src/java/org/apache/lucene/index/IndexSplitter.java branch/lucene/misc/src/java/org/apache/lucene/index/IndexSplitter.java
--- trunk/lucene/misc/src/java/org/apache/lucene/index/IndexSplitter.java	2014-09-26 11:20:12.750287193 -0400
+++ branch/lucene/misc/src/java/org/apache/lucene/index/IndexSplitter.java	2014-09-25 09:53:18.040691774 -0400
@@ -28,6 +28,7 @@
 import java.util.Locale;
 
 import org.apache.lucene.store.FSDirectory;
+import org.apache.lucene.util.StringHelper;
 
 /**
  * Command-line tool that enables listing segments in an
@@ -137,7 +138,7 @@
       SegmentInfo info = infoPerCommit.info;
       // Same info just changing the dir:
       SegmentInfo newInfo = new SegmentInfo(destFSDir, info.getVersion(), info.name, info.getDocCount(), 
-                                            info.getUseCompoundFile(), info.getCodec(), info.getDiagnostics());
+                                            info.getUseCompoundFile(), info.getCodec(), info.getDiagnostics(), info.getId());
       destInfos.add(new SegmentCommitInfo(newInfo, infoPerCommit.getDelCount(),
           infoPerCommit.getDelGen(), infoPerCommit.getFieldInfosGen(),
           infoPerCommit.getDocValuesGen()));
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/test-framework/src/java/org/apache/lucene/codecs/asserting/AssertingCodec.java branch/lucene/test-framework/src/java/org/apache/lucene/codecs/asserting/AssertingCodec.java
--- trunk/lucene/test-framework/src/java/org/apache/lucene/codecs/asserting/AssertingCodec.java	2014-09-26 11:20:12.762287194 -0400
+++ branch/lucene/test-framework/src/java/org/apache/lucene/codecs/asserting/AssertingCodec.java	2014-09-25 11:46:02.904809580 -0400
@@ -19,6 +19,7 @@
 
 import org.apache.lucene.codecs.DocValuesFormat;
 import org.apache.lucene.codecs.FilterCodec;
+import org.apache.lucene.codecs.LiveDocsFormat;
 import org.apache.lucene.codecs.NormsFormat;
 import org.apache.lucene.codecs.PostingsFormat;
 import org.apache.lucene.codecs.StoredFieldsFormat;
@@ -49,7 +50,7 @@
   private final TermVectorsFormat vectors = new AssertingTermVectorsFormat();
   private final StoredFieldsFormat storedFields = new AssertingStoredFieldsFormat();
   private final NormsFormat norms = new AssertingNormsFormat();
-  
+  private final LiveDocsFormat liveDocs = new AssertingLiveDocsFormat();
   private final PostingsFormat defaultFormat = new AssertingPostingsFormat();
   private final DocValuesFormat defaultDVFormat = new AssertingDocValuesFormat();
 
@@ -83,6 +84,11 @@
   }
 
   @Override
+  public LiveDocsFormat liveDocsFormat() {
+    return liveDocs;
+  }
+
+  @Override
   public String toString() {
     return "Asserting(" + delegate + ")";
   }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/test-framework/src/java/org/apache/lucene/codecs/asserting/AssertingLiveDocsFormat.java branch/lucene/test-framework/src/java/org/apache/lucene/codecs/asserting/AssertingLiveDocsFormat.java
--- trunk/lucene/test-framework/src/java/org/apache/lucene/codecs/asserting/AssertingLiveDocsFormat.java	1969-12-31 19:00:00.000000000 -0500
+++ branch/lucene/test-framework/src/java/org/apache/lucene/codecs/asserting/AssertingLiveDocsFormat.java	2014-09-25 17:05:51.185143733 -0400
@@ -0,0 +1,137 @@
+package org.apache.lucene.codecs.asserting;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Collection;
+
+import org.apache.lucene.codecs.LiveDocsFormat;
+import org.apache.lucene.index.SegmentCommitInfo;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.MutableBits;
+import org.apache.lucene.util.TestUtil;
+
+/**
+ * Just like the default live docs format but with additional asserts.
+ */
+public class AssertingLiveDocsFormat extends LiveDocsFormat {
+  private final LiveDocsFormat in = TestUtil.getDefaultCodec().liveDocsFormat();
+
+  @Override
+  public MutableBits newLiveDocs(int size) throws IOException {
+    assert size >= 0;
+    MutableBits raw = in.newLiveDocs(size);
+    assert raw != null;
+    assert raw.length() == size;
+    for (int i = 0; i < raw.length(); i++) {
+      assert raw.get(i);
+    }
+    return new AssertingMutableBits(raw);
+  }
+
+  @Override
+  public MutableBits newLiveDocs(Bits existing) throws IOException {
+    assert existing instanceof AssertingBits;
+    Bits rawExisting = ((AssertingBits)existing).in;
+    MutableBits raw = in.newLiveDocs(rawExisting);
+    assert raw != null;
+    assert raw.length() == rawExisting.length();
+    for (int i = 0; i < raw.length(); i++) {
+      assert rawExisting.get(i) == raw.get(i);
+    }
+    return new AssertingMutableBits(raw);
+  }
+
+  @Override
+  public Bits readLiveDocs(Directory dir, SegmentCommitInfo info, IOContext context) throws IOException {
+    Bits raw = in.readLiveDocs(dir, info, context);
+    assert raw != null;
+    check(raw, info.info.getDocCount(), info.getDelCount());
+    return new AssertingBits(raw);
+  }
+
+  @Override
+  public void writeLiveDocs(MutableBits bits, Directory dir, SegmentCommitInfo info, int newDelCount, IOContext context) throws IOException {
+    assert bits instanceof AssertingMutableBits;
+    MutableBits raw = (MutableBits) ((AssertingMutableBits)bits).in;
+    check(raw, info.info.getDocCount(), info.getDelCount() + newDelCount);
+    in.writeLiveDocs(raw, dir, info, newDelCount, context);
+  }
+  
+  private void check(Bits bits, int expectedLength, int expectedDeleteCount) {
+    assert bits.length() == expectedLength;
+    int deletedCount = 0;
+    for (int i = 0; i < bits.length(); i++) {
+      if (!bits.get(i)) {
+        deletedCount++;
+      }
+    }
+    assert deletedCount == expectedDeleteCount;
+  }
+
+  @Override
+  public void files(SegmentCommitInfo info, Collection<String> files) throws IOException {
+    in.files(info, files);
+  }
+  
+  @Override
+  public String toString() {
+    return "Asserting(" + in + ")";
+  }
+
+  static class AssertingBits implements Bits {
+    final Bits in;
+    
+    AssertingBits(Bits in) {
+      this.in = in;
+      assert in.length() >= 0;
+    }
+    
+    @Override
+    public boolean get(int index) {
+      assert index >= 0;
+      assert index < in.length();
+      return in.get(index);
+    }
+    
+    @Override
+    public int length() {
+      return in.length();
+    }
+    
+    @Override
+    public String toString() {
+      return "Asserting(" + in + ")";
+    }
+  }
+  
+  static class AssertingMutableBits extends AssertingBits implements MutableBits {   
+    AssertingMutableBits(MutableBits in) {
+      super(in);
+    }
+
+    @Override
+    public void clear(int index) {
+      assert index >= 0;
+      assert index < in.length();
+      ((MutableBits)in).clear(index);
+    }
+  }
+}
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/test-framework/src/java/org/apache/lucene/codecs/cranky/CrankyFieldInfosFormat.java branch/lucene/test-framework/src/java/org/apache/lucene/codecs/cranky/CrankyFieldInfosFormat.java
--- trunk/lucene/test-framework/src/java/org/apache/lucene/codecs/cranky/CrankyFieldInfosFormat.java	2014-09-26 11:20:12.762287194 -0400
+++ branch/lucene/test-framework/src/java/org/apache/lucene/codecs/cranky/CrankyFieldInfosFormat.java	2014-09-25 09:26:07.604663380 -0400
@@ -24,6 +24,7 @@
 import org.apache.lucene.codecs.FieldInfosReader;
 import org.apache.lucene.codecs.FieldInfosWriter;
 import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.SegmentInfo;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 
@@ -59,11 +60,11 @@
     }
 
     @Override
-    public void write(Directory directory, String segmentName, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {
+    public void write(Directory directory, SegmentInfo segmentInfo, String segmentSuffix, FieldInfos infos, IOContext context) throws IOException {
       if (random.nextInt(100) == 0) {
         throw new IOException("Fake IOException from FieldInfosWriter.write()");
       }
-      delegate.write(directory, segmentName, segmentSuffix, infos, context);
+      delegate.write(directory, segmentInfo, segmentSuffix, infos, context);
     }
   }
 }
diff -ruN -x .svn -x .git -x build -x .caches trunk/lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java branch/lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java
--- trunk/lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java	2014-09-26 11:20:13.194287201 -0400
+++ branch/lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java	2014-09-25 09:41:40.980679635 -0400
@@ -57,6 +57,7 @@
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LineFileDocs;
 import org.apache.lucene.util.RamUsageTester;
+import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.TestUtil;
 import org.apache.lucene.util.UnicodeUtil;
 import org.apache.lucene.util.Version;
@@ -675,7 +676,7 @@
   // randomly index at lower IndexOption
   private FieldsProducer buildIndex(Directory dir, IndexOptions maxAllowed, boolean allowPayloads, boolean alwaysTestMax) throws IOException {
     Codec codec = getCodec();
-    SegmentInfo segmentInfo = new SegmentInfo(dir, Version.LATEST, "_0", maxDoc, false, codec, null);
+    SegmentInfo segmentInfo = new SegmentInfo(dir, Version.LATEST, "_0", maxDoc, false, codec, null, StringHelper.randomId());
 
     int maxIndexOption = Arrays.asList(IndexOptions.values()).indexOf(maxAllowed);
     if (VERBOSE) {
