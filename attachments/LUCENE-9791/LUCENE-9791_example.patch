diff --git a/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java b/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java
index 41180b4cffa..b6ce18cf86a 100644
--- a/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java
+++ b/lucene/core/src/java/org/apache/lucene/util/BytesRefHash.java
@@ -173,9 +173,9 @@ public final class BytesRefHash implements Accountable {
     return compact;
   }
 
-  private boolean equals(int id, BytesRef b) {
-    pool.setBytesRef(scratch1, bytesStart[id]);
-    return scratch1.bytesEquals(b);
+  private boolean equals(int id, BytesRef b, BytesRef scratch) {
+    pool.setBytesRef(scratch, bytesStart[id]);
+    return scratch.bytesEquals(b);
   }
 
   private boolean shrink(int targetSize) {
@@ -238,7 +238,7 @@ public final class BytesRefHash implements Accountable {
     assert bytesStart != null : "Bytesstart is null - not initialized";
     final int length = bytes.length;
     // final position
-    final int hashPos = findHash(bytes);
+    final int hashPos = findHash(bytes, scratch1);
     int e = ids[hashPos];
 
     if (e == -1) {
@@ -296,10 +296,15 @@ public final class BytesRefHash implements Accountable {
    * @return the id of the given bytes, or {@code -1} if there is no mapping for the given bytes.
    */
   public int find(BytesRef bytes) {
-    return ids[findHash(bytes)];
+    return ids[findHash(bytes, scratch1)];
   }
 
-  private int findHash(BytesRef bytes) {
+  /** @deprecated do not use */
+  public int find(BytesRef bytes, BytesRef scratch) {
+    return ids[findHash(bytes, scratch)];
+  }
+
+  private int findHash(BytesRef bytes, BytesRef scratch) {
     assert bytesStart != null : "bytesStart is null - not initialized";
 
     int code = doHash(bytes.bytes, bytes.offset, bytes.length);
@@ -307,14 +312,14 @@ public final class BytesRefHash implements Accountable {
     // final position
     int hashPos = code & hashMask;
     int e = ids[hashPos];
-    if (e != -1 && !equals(e, bytes)) {
+    if (e != -1 && !equals(e, bytes, scratch)) {
       // Conflict; use linear probe to find an open slot
       // (see LUCENE-5604):
       do {
         code++;
         hashPos = code & hashMask;
         e = ids[hashPos];
-      } while (e != -1 && !equals(e, bytes));
+      } while (e != -1 && !equals(e, bytes, scratch));
     }
 
     return hashPos;
