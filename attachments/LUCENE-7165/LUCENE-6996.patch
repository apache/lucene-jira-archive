diff --git a/lucene/core/src/java/org/apache/lucene/geo/Polygon.java b/lucene/core/src/java/org/apache/lucene/geo/Polygon.java
index 145b939..187756e 100644
--- a/lucene/core/src/java/org/apache/lucene/geo/Polygon.java
+++ b/lucene/core/src/java/org/apache/lucene/geo/Polygon.java
@@ -49,7 +49,7 @@ public final class Polygon {
   public final double maxLon;
 
   // TODO: refactor to GeoUtils once LUCENE-7165 is complete
-  private static final double ENCODING_TOLERANCE = 1e-6;
+  private static final double ENCODING_TOLERANCE = 1e-7;
 
   // TODO: we could also compute the maximal inner bounding box, to make relations faster to compute?
 
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointTokenStream.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointTokenStream.java
index c374c4e..c4f6346 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointTokenStream.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointTokenStream.java
@@ -116,7 +116,7 @@ final class GeoPointTokenStream extends TokenStream {
 
     final int shift = geoPointTermAtt.incShift();
     posIncrAtt.setPositionIncrement((shift == MAX_SHIFT) ? 1 : 0);
-    return (shift < 63);
+    return (shift < 64);
   }
 
   /**
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java
index f511392..8a7644e 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java
@@ -126,7 +126,7 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
         minLon = mortonUnhashLon(currStart);
         minLat = mortonUnhashLat(currStart);
       }
-    } while(shift < 63);
+    } while(shift <= 63);
   }
 
   private void setNextRange(final boolean boundary) {
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java
index d2141d9..310a5d0 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java
@@ -23,6 +23,8 @@ import org.apache.lucene.util.BytesRefBuilder;
 
 import static org.apache.lucene.geo.GeoUtils.MIN_LON_INCL;
 import static org.apache.lucene.geo.GeoUtils.MIN_LAT_INCL;
+import static org.apache.lucene.geo.GeoUtils.checkLatitude;
+import static org.apache.lucene.geo.GeoUtils.checkLongitude;
 
 /**
  * Basic reusable geopoint encoding methods
@@ -31,10 +33,10 @@ import static org.apache.lucene.geo.GeoUtils.MIN_LAT_INCL;
  */
 public final class GeoEncodingUtils {
   /** number of bits used for quantizing latitude and longitude values */
-  public static final short BITS = 31;
+  public static final short BITS = 32;
 
-  private static final double LAT_SCALE = (0x1L<<BITS)/180.0D;
-  private static final double LON_SCALE = (0x1L<<BITS)/360.0D;
+  private static final double LAT_SCALE = ((0x1L<<BITS)-1)/180.0D;
+  private static final double LON_SCALE = ((0x1L<<BITS)-1)/360.0D;
 
   /**
    * The maximum term length (used for <code>byte[]</code> buffer size)
@@ -44,7 +46,7 @@ public final class GeoEncodingUtils {
   public static final int BUF_SIZE_LONG = 28/8 + 1;
 
   /** rounding error for quantized latitude and longitude values */
-  public static final double TOLERANCE = 1E-6;
+  public static final double TOLERANCE = 1E-7;
 
   // No instance:
   private GeoEncodingUtils() {
@@ -54,7 +56,10 @@ public final class GeoEncodingUtils {
    * encode latitude, longitude geopoint values using morton encoding method
    * https://en.wikipedia.org/wiki/Z-order_curve
    */
-  public static final Long mortonHash(final double lat, final double lon) {
+  public static final Long mortonHash(double lat, double lon) {
+    checkLongitude(lon);
+    checkLatitude(lat);
+
     return BitUtil.interleave(scaleLon(lon), scaleLat(lat));
   }
 
@@ -68,20 +73,20 @@ public final class GeoEncodingUtils {
     return unscaleLat(BitUtil.deinterleave(hash >>> 1));
   }
 
-  private static final long scaleLon(final double val) {
-    return (long) ((val-MIN_LON_INCL) * LON_SCALE);
+  private static final long scaleLon(final double lon) {
+    return (long) ((lon-MIN_LON_INCL) * LON_SCALE);
   }
 
-  private static final long scaleLat(final double val) {
-    return (long) ((val-MIN_LAT_INCL) * LAT_SCALE);
+  private static final long scaleLat(final double lat) {
+    return (long) ((lat-MIN_LAT_INCL) * LAT_SCALE);
   }
 
-  private static final double unscaleLon(final long val) {
-    return (val / LON_SCALE) + MIN_LON_INCL;
+  private static final double unscaleLon(final long lon) {
+    return (lon / LON_SCALE) + MIN_LON_INCL;
   }
 
-  private static final double unscaleLat(final long val) {
-    return (val / LAT_SCALE) + MIN_LAT_INCL;
+  private static final double unscaleLat(final long lat) {
+    return (lat / LAT_SCALE) + MIN_LAT_INCL;
   }
 
   /** Convert a geocoded morton long into a prefix coded geo term */
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoEncodingUtils.java b/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoEncodingUtils.java
index 1a1b2cc..80d9f4b 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoEncodingUtils.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoEncodingUtils.java
@@ -22,6 +22,7 @@ import org.apache.lucene.util.LuceneTestCase;
 
 import static org.apache.lucene.geo.GeoTestUtil.nextLatitude;
 import static org.apache.lucene.geo.GeoTestUtil.nextLongitude;
+import static org.apache.lucene.spatial.util.GeoEncodingUtils.TOLERANCE;
 
 /**
  * Tests methods in {@link GeoEncodingUtils}
@@ -46,9 +47,12 @@ public class TestGeoEncodingUtils extends LuceneTestCase {
   }
 
   public void testMortonEncoding() throws Exception {
-    long hash = GeoEncodingUtils.mortonHash(90, 180);
-    assertEquals(180.0, GeoEncodingUtils.mortonUnhashLon(hash), 0);
-    assertEquals(90.0, GeoEncodingUtils.mortonUnhashLat(hash), 0);
+    long hash = GeoEncodingUtils.mortonHash(90.0D, 180.0D);
+    assertEquals(180.0D, GeoEncodingUtils.mortonUnhashLon(hash), TOLERANCE);
+    assertEquals(90.0D, GeoEncodingUtils.mortonUnhashLat(hash), 1e-7);
+    hash = GeoEncodingUtils.mortonHash(-90.0D, -180.0D);
+    assertEquals(-180.0D, GeoEncodingUtils.mortonUnhashLon(hash), 1e-7);
+    assertEquals(-90.0D, GeoEncodingUtils.mortonUnhashLat(hash), 1e-7);
   }
 
   public void testEncodeDecode() throws Exception {
@@ -94,8 +98,13 @@ public class TestGeoEncodingUtils extends LuceneTestCase {
       long enc2 = GeoEncodingUtils.mortonHash(lat, lon);
       double latEnc2 = GeoEncodingUtils.mortonUnhashLat(enc2);
       double lonEnc2 = GeoEncodingUtils.mortonUnhashLon(enc2);
-      assertEquals(latEnc, latEnc2, 0.0);
-      assertEquals(lonEnc, lonEnc2, 0.0);
+
+      // test multi encoding stability
+      long enc3 = GeoEncodingUtils.mortonHash(latEnc2, lonEnc2);
+      double latEnc3 = GeoEncodingUtils.mortonUnhashLat(enc3);
+      double lonEnc3 = GeoEncodingUtils.mortonUnhashLon(enc3);
+      assertEquals(latEnc2, latEnc3, 0.0);
+      assertEquals(lonEnc2, lonEnc3, 0.0);
     }
   }
 }
