Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 951501)
+++ lucene/CHANGES.txt	(working copy)
@@ -472,6 +472,10 @@
   that warming is free to do whatever it needs to.  (Earwin Burrfoot
   via Mike McCandless)
 
+* LUCENE-2486: Fixed intermittent FileNotFoundException on doc store
+  files when a mergedSegmentWarmer is set on IndexWriter.  (Mike
+  McCandless)
+
 New features
 
 * LUCENE-2128: Parallelized fetching document frequencies during weight
Index: lucene/src/test/org/apache/lucene/index/TestIndexWriterReader.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestIndexWriterReader.java	(revision 951501)
+++ lucene/src/test/org/apache/lucene/index/TestIndexWriterReader.java	(working copy)
@@ -542,7 +542,7 @@
     
     ((LogMergePolicy) writer.getConfig().getMergePolicy()).setMergeFactor(2);
 
-    for (int i = 0; i < 10; i++) {
+    for (int i = 0; i < 100*_TestUtil.getRandomMultiplier(); i++) {
       writer.addDocument(createDocument(i, "test", 4));
     }
     ((ConcurrentMergeScheduler) writer.getConfig().getMergeScheduler()).sync();
Index: lucene/src/java/org/apache/lucene/index/MergePolicy.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/MergePolicy.java	(revision 951501)
+++ lucene/src/java/org/apache/lucene/index/MergePolicy.java	(working copy)
@@ -76,6 +76,7 @@
     int maxNumSegmentsOptimize;     // used by IndexWriter
     SegmentReader[] readers;        // used by IndexWriter
     SegmentReader[] readersClone;   // used by IndexWriter
+    List<String> mergeFiles;            // used by IndexWriter
     final SegmentInfos segments;
     final boolean useCompoundFile;
     boolean aborted;
Index: lucene/src/java/org/apache/lucene/index/IndexWriter.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/IndexWriter.java	(revision 951501)
+++ lucene/src/java/org/apache/lucene/index/IndexWriter.java	(working copy)
@@ -3537,25 +3537,7 @@
     commitMergedDeletes(merge, mergedReader);
     docWriter.remapDeletes(segmentInfos, merger.getDocMaps(), merger.getDelCounts(), merge, mergedDocCount);
       
-    // Simple optimization: if the doc store we are using
-    // has been closed and is in now compound format (but
-    // wasn't when we started), then we will switch to the
-    // compound format as well:
-    final String mergeDocStoreSegment = merge.info.getDocStoreSegment(); 
-    if (mergeDocStoreSegment != null && !merge.info.getDocStoreIsCompoundFile()) {
-      final int size = segmentInfos.size();
-      for(int i=0;i<size;i++) {
-        final SegmentInfo info = segmentInfos.info(i);
-        final String docStoreSegment = info.getDocStoreSegment();
-        if (docStoreSegment != null &&
-            docStoreSegment.equals(mergeDocStoreSegment) && 
-            info.getDocStoreIsCompoundFile()) {
-          merge.info.setDocStoreIsCompoundFile(true);
-          break;
-        }
-      }
-    }
-    
+    setMergeDocStoreIsCompoundFile(merge);
     merge.info.setHasProx(merger.hasProx());
 
     segmentInfos.subList(start, start + merge.segments.size()).clear();
@@ -3903,6 +3885,11 @@
     if (merge.increfDone)
       decrefMergeSegments(merge);
 
+    if (merge.mergeFiles != null) {
+      deleter.decRef(merge.mergeFiles);
+      merge.mergeFiles = null;
+    }
+
     // It's possible we are called twice, eg if there was an
     // exception inside mergeInit
     if (merge.registerDone) {
@@ -3917,6 +3904,23 @@
     runningMerges.remove(merge);
   }
 
+  private synchronized void setMergeDocStoreIsCompoundFile(MergePolicy.OneMerge merge) {
+    final String mergeDocStoreSegment = merge.info.getDocStoreSegment(); 
+    if (mergeDocStoreSegment != null && !merge.info.getDocStoreIsCompoundFile()) {
+      final int size = segmentInfos.size();
+      for(int i=0;i<size;i++) {
+        final SegmentInfo info = segmentInfos.info(i);
+        final String docStoreSegment = info.getDocStoreSegment();
+        if (docStoreSegment != null &&
+            docStoreSegment.equals(mergeDocStoreSegment) && 
+            info.getDocStoreIsCompoundFile()) {
+          merge.info.setDocStoreIsCompoundFile(true);
+          break;
+        }
+      }
+    }
+  }        
+
   /** Does the actual (time-consuming) work of the merge,
    *  but without holding synchronized lock on IndexWriter
    *  instance */
@@ -4037,6 +4041,17 @@
       final int termsIndexDivisor;
       final boolean loadDocStores;
 
+      synchronized(this) {
+        // If the doc store we are using has been closed and
+        // is in now compound format (but wasn't when we
+        // started), then we will switch to the compound
+        // format as well:
+        setMergeDocStoreIsCompoundFile(merge);
+        assert merge.mergeFiles == null;
+        merge.mergeFiles = merge.info.files();
+        deleter.incRef(merge.mergeFiles);
+      }
+
       if (poolReaders && mergedSegmentWarmer != null) {
         // Load terms index & doc stores so the segment
         // warmer can run searches, load documents/term
Index: lucene/src/java/org/apache/lucene/index/IndexFileDeleter.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/IndexFileDeleter.java	(revision 951501)
+++ lucene/src/java/org/apache/lucene/index/IndexFileDeleter.java	(working copy)
@@ -465,7 +465,7 @@
     }
   }
 
-  void incRef(List<String> files) throws IOException {
+  void incRef(Collection<String> files) throws IOException {
     for(final String file : files) {
       incRef(file);
     }
