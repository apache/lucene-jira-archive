diff --git a/lucene/core/src/java/org/apache/lucene/util/packed/Direct16.java b/lucene/core/src/java/org/apache/lucene/util/packed/Direct16.java
deleted file mode 100644
index 82281a9e..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/packed/Direct16.java
+++ /dev/null
@@ -1,106 +0,0 @@
-// This file has been automatically generated, DO NOT EDIT
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.util.packed;
-
-import org.apache.lucene.store.DataInput;
-import org.apache.lucene.util.RamUsageEstimator;
-
-import java.io.IOException;
-import java.util.Arrays;
-
-/**
- * Direct wrapping of 16-bits values to a backing array.
- * @lucene.internal
- */
-final class Direct16 extends PackedInts.MutableImpl {
-  final short[] values;
-
-  Direct16(int valueCount) {
-    super(valueCount, 16);
-    values = new short[valueCount];
-  }
-
-  Direct16(int packedIntsVersion, DataInput in, int valueCount) throws IOException {
-    this(valueCount);
-    for (int i = 0; i < valueCount; ++i) {
-      values[i] = in.readShort();
-    }
-    // because packed ints have not always been byte-aligned
-    final int remaining = (int) (PackedInts.Format.PACKED.byteCount(packedIntsVersion, valueCount, 16) - 2L * valueCount);
-    for (int i = 0; i < remaining; ++i) {
-      in.readByte();
-    }
-  }
-
-  @Override
-  public long get(final int index) {
-    return values[index] & 0xFFFFL;
-  }
-
-  @Override
-  public void set(final int index, final long value) {
-    values[index] = (short) (value);
-  }
-
-  @Override
-  public long ramBytesUsed() {
-    return RamUsageEstimator.alignObjectSize(
-        RamUsageEstimator.NUM_BYTES_OBJECT_HEADER
-        + 2 * RamUsageEstimator.NUM_BYTES_INT     // valueCount,bitsPerValue
-        + RamUsageEstimator.NUM_BYTES_OBJECT_REF) // values ref
-        + RamUsageEstimator.sizeOf(values);
-  }
-
-  @Override
-  public void clear() {
-    Arrays.fill(values, (short) 0L);
-  }
-
-  @Override
-  public int get(int index, long[] arr, int off, int len) {
-    assert len > 0 : "len must be > 0 (got " + len + ")";
-    assert index >= 0 && index < valueCount;
-    assert off + len <= arr.length;
-
-    final int gets = Math.min(valueCount - index, len);
-    for (int i = index, o = off, end = index + gets; i < end; ++i, ++o) {
-      arr[o] = values[i] & 0xFFFFL;
-    }
-    return gets;
-  }
-
-  @Override
-  public int set(int index, long[] arr, int off, int len) {
-    assert len > 0 : "len must be > 0 (got " + len + ")";
-    assert index >= 0 && index < valueCount;
-    assert off + len <= arr.length;
-
-    final int sets = Math.min(valueCount - index, len);
-    for (int i = index, o = off, end = index + sets; i < end; ++i, ++o) {
-      values[i] = (short) arr[o];
-    }
-    return sets;
-  }
-
-  @Override
-  public void fill(int fromIndex, int toIndex, long val) {
-    assert val == (val & 0xFFFFL);
-    Arrays.fill(values, fromIndex, toIndex, (short) val);
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/packed/Direct32.java b/lucene/core/src/java/org/apache/lucene/util/packed/Direct32.java
deleted file mode 100644
index 502aa3f..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/packed/Direct32.java
+++ /dev/null
@@ -1,106 +0,0 @@
-// This file has been automatically generated, DO NOT EDIT
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.util.packed;
-
-import org.apache.lucene.store.DataInput;
-import org.apache.lucene.util.RamUsageEstimator;
-
-import java.io.IOException;
-import java.util.Arrays;
-
-/**
- * Direct wrapping of 32-bits values to a backing array.
- * @lucene.internal
- */
-final class Direct32 extends PackedInts.MutableImpl {
-  final int[] values;
-
-  Direct32(int valueCount) {
-    super(valueCount, 32);
-    values = new int[valueCount];
-  }
-
-  Direct32(int packedIntsVersion, DataInput in, int valueCount) throws IOException {
-    this(valueCount);
-    for (int i = 0; i < valueCount; ++i) {
-      values[i] = in.readInt();
-    }
-    // because packed ints have not always been byte-aligned
-    final int remaining = (int) (PackedInts.Format.PACKED.byteCount(packedIntsVersion, valueCount, 32) - 4L * valueCount);
-    for (int i = 0; i < remaining; ++i) {
-      in.readByte();
-    }
-  }
-
-  @Override
-  public long get(final int index) {
-    return values[index] & 0xFFFFFFFFL;
-  }
-
-  @Override
-  public void set(final int index, final long value) {
-    values[index] = (int) (value);
-  }
-
-  @Override
-  public long ramBytesUsed() {
-    return RamUsageEstimator.alignObjectSize(
-        RamUsageEstimator.NUM_BYTES_OBJECT_HEADER
-        + 2 * RamUsageEstimator.NUM_BYTES_INT     // valueCount,bitsPerValue
-        + RamUsageEstimator.NUM_BYTES_OBJECT_REF) // values ref
-        + RamUsageEstimator.sizeOf(values);
-  }
-
-  @Override
-  public void clear() {
-    Arrays.fill(values, (int) 0L);
-  }
-
-  @Override
-  public int get(int index, long[] arr, int off, int len) {
-    assert len > 0 : "len must be > 0 (got " + len + ")";
-    assert index >= 0 && index < valueCount;
-    assert off + len <= arr.length;
-
-    final int gets = Math.min(valueCount - index, len);
-    for (int i = index, o = off, end = index + gets; i < end; ++i, ++o) {
-      arr[o] = values[i] & 0xFFFFFFFFL;
-    }
-    return gets;
-  }
-
-  @Override
-  public int set(int index, long[] arr, int off, int len) {
-    assert len > 0 : "len must be > 0 (got " + len + ")";
-    assert index >= 0 && index < valueCount;
-    assert off + len <= arr.length;
-
-    final int sets = Math.min(valueCount - index, len);
-    for (int i = index, o = off, end = index + sets; i < end; ++i, ++o) {
-      values[i] = (int) arr[o];
-    }
-    return sets;
-  }
-
-  @Override
-  public void fill(int fromIndex, int toIndex, long val) {
-    assert val == (val & 0xFFFFFFFFL);
-    Arrays.fill(values, fromIndex, toIndex, (int) val);
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/packed/Direct64.java b/lucene/core/src/java/org/apache/lucene/util/packed/Direct64.java
deleted file mode 100644
index 106f641..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/packed/Direct64.java
+++ /dev/null
@@ -1,96 +0,0 @@
-// This file has been automatically generated, DO NOT EDIT
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.util.packed;
-
-import org.apache.lucene.store.DataInput;
-import org.apache.lucene.util.RamUsageEstimator;
-
-import java.io.IOException;
-import java.util.Arrays;
-
-/**
- * Direct wrapping of 64-bits values to a backing array.
- * @lucene.internal
- */
-final class Direct64 extends PackedInts.MutableImpl {
-  final long[] values;
-
-  Direct64(int valueCount) {
-    super(valueCount, 64);
-    values = new long[valueCount];
-  }
-
-  Direct64(int packedIntsVersion, DataInput in, int valueCount) throws IOException {
-    this(valueCount);
-    for (int i = 0; i < valueCount; ++i) {
-      values[i] = in.readLong();
-    }
-  }
-
-  @Override
-  public long get(final int index) {
-    return values[index];
-  }
-
-  @Override
-  public void set(final int index, final long value) {
-    values[index] = (value);
-  }
-
-  @Override
-  public long ramBytesUsed() {
-    return RamUsageEstimator.alignObjectSize(
-        RamUsageEstimator.NUM_BYTES_OBJECT_HEADER
-        + 2 * RamUsageEstimator.NUM_BYTES_INT     // valueCount,bitsPerValue
-        + RamUsageEstimator.NUM_BYTES_OBJECT_REF) // values ref
-        + RamUsageEstimator.sizeOf(values);
-  }
-
-  @Override
-  public void clear() {
-    Arrays.fill(values, 0L);
-  }
-
-  @Override
-  public int get(int index, long[] arr, int off, int len) {
-    assert len > 0 : "len must be > 0 (got " + len + ")";
-    assert index >= 0 && index < valueCount;
-    assert off + len <= arr.length;
-
-    final int gets = Math.min(valueCount - index, len);
-    System.arraycopy(values, index, arr, off, gets);
-    return gets;
-  }
-
-  @Override
-  public int set(int index, long[] arr, int off, int len) {
-    assert len > 0 : "len must be > 0 (got " + len + ")";
-    assert index >= 0 && index < valueCount;
-    assert off + len <= arr.length;
-
-    final int sets = Math.min(valueCount - index, len);
-    System.arraycopy(arr, off, values, index, sets);
-    return sets;
-  }
-
-  @Override
-  public void fill(int fromIndex, int toIndex, long val) {
-    Arrays.fill(values, fromIndex, toIndex, val);
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/packed/Direct8.java b/lucene/core/src/java/org/apache/lucene/util/packed/Direct8.java
deleted file mode 100644
index 27986c0..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/packed/Direct8.java
+++ /dev/null
@@ -1,104 +0,0 @@
-// This file has been automatically generated, DO NOT EDIT
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.util.packed;
-
-import org.apache.lucene.store.DataInput;
-import org.apache.lucene.util.RamUsageEstimator;
-
-import java.io.IOException;
-import java.util.Arrays;
-
-/**
- * Direct wrapping of 8-bits values to a backing array.
- * @lucene.internal
- */
-final class Direct8 extends PackedInts.MutableImpl {
-  final byte[] values;
-
-  Direct8(int valueCount) {
-    super(valueCount, 8);
-    values = new byte[valueCount];
-  }
-
-  Direct8(int packedIntsVersion, DataInput in, int valueCount) throws IOException {
-    this(valueCount);
-    in.readBytes(values, 0, valueCount);
-    // because packed ints have not always been byte-aligned
-    final int remaining = (int) (PackedInts.Format.PACKED.byteCount(packedIntsVersion, valueCount, 8) - 1L * valueCount);
-    for (int i = 0; i < remaining; ++i) {
-      in.readByte();
-    }
-  }
-
-  @Override
-  public long get(final int index) {
-    return values[index] & 0xFFL;
-  }
-
-  @Override
-  public void set(final int index, final long value) {
-    values[index] = (byte) (value);
-  }
-
-  @Override
-  public long ramBytesUsed() {
-    return RamUsageEstimator.alignObjectSize(
-        RamUsageEstimator.NUM_BYTES_OBJECT_HEADER
-        + 2 * RamUsageEstimator.NUM_BYTES_INT     // valueCount,bitsPerValue
-        + RamUsageEstimator.NUM_BYTES_OBJECT_REF) // values ref
-        + RamUsageEstimator.sizeOf(values);
-  }
-
-  @Override
-  public void clear() {
-    Arrays.fill(values, (byte) 0L);
-  }
-
-  @Override
-  public int get(int index, long[] arr, int off, int len) {
-    assert len > 0 : "len must be > 0 (got " + len + ")";
-    assert index >= 0 && index < valueCount;
-    assert off + len <= arr.length;
-
-    final int gets = Math.min(valueCount - index, len);
-    for (int i = index, o = off, end = index + gets; i < end; ++i, ++o) {
-      arr[o] = values[i] & 0xFFL;
-    }
-    return gets;
-  }
-
-  @Override
-  public int set(int index, long[] arr, int off, int len) {
-    assert len > 0 : "len must be > 0 (got " + len + ")";
-    assert index >= 0 && index < valueCount;
-    assert off + len <= arr.length;
-
-    final int sets = Math.min(valueCount - index, len);
-    for (int i = index, o = off, end = index + sets; i < end; ++i, ++o) {
-      values[i] = (byte) arr[o];
-    }
-    return sets;
-  }
-
-  @Override
-  public void fill(int fromIndex, int toIndex, long val) {
-    assert val == (val & 0xFFL);
-    Arrays.fill(values, fromIndex, toIndex, (byte) val);
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/packed/Packed16ThreeBlocks.java b/lucene/core/src/java/org/apache/lucene/util/packed/Packed16ThreeBlocks.java
deleted file mode 100644
index 8e8e94d..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/packed/Packed16ThreeBlocks.java
+++ /dev/null
@@ -1,125 +0,0 @@
-// This file has been automatically generated, DO NOT EDIT
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.util.packed;
-
-import org.apache.lucene.store.DataInput;
-import org.apache.lucene.util.RamUsageEstimator;
-
-import java.io.IOException;
-import java.util.Arrays;
-
-/**
- * Packs integers into 3 shorts (48 bits per value).
- * @lucene.internal
- */
-final class Packed16ThreeBlocks extends PackedInts.MutableImpl {
-  final short[] blocks;
-
-  public static final int MAX_SIZE = Integer.MAX_VALUE / 3;
-
-  Packed16ThreeBlocks(int valueCount) {
-    super(valueCount, 48);
-    if (valueCount > MAX_SIZE) {
-      throw new ArrayIndexOutOfBoundsException("MAX_SIZE exceeded");
-    }
-    blocks = new short[valueCount * 3];
-  }
-
-  Packed16ThreeBlocks(int packedIntsVersion, DataInput in, int valueCount) throws IOException {
-    this(valueCount);
-    for (int i = 0; i < 3 * valueCount; ++i) {
-      blocks[i] = in.readShort();
-    }
-  }
-
-  @Override
-  public long get(int index) {
-    final int o = index * 3;
-    return (blocks[o] & 0xFFFFL) << 32 | (blocks[o+1] & 0xFFFFL) << 16 | (blocks[o+2] & 0xFFFFL);
-  }
-
-  @Override
-  public int get(int index, long[] arr, int off, int len) {
-    assert len > 0 : "len must be > 0 (got " + len + ")";
-    assert index >= 0 && index < valueCount;
-    assert off + len <= arr.length;
-
-    final int gets = Math.min(valueCount - index, len);
-    for (int i = index * 3, end = (index + gets) * 3; i < end; i+=3) {
-      arr[off++] = (blocks[i] & 0xFFFFL) << 32 | (blocks[i+1] & 0xFFFFL) << 16 | (blocks[i+2] & 0xFFFFL);
-    }
-    return gets;
-  }
-
-  @Override
-  public void set(int index, long value) {
-    final int o = index * 3;
-    blocks[o] = (short) (value >>> 32);
-    blocks[o+1] = (short) (value >>> 16);
-    blocks[o+2] = (short) value;
-  }
-
-  @Override
-  public int set(int index, long[] arr, int off, int len) {
-    assert len > 0 : "len must be > 0 (got " + len + ")";
-    assert index >= 0 && index < valueCount;
-    assert off + len <= arr.length;
-
-    final int sets = Math.min(valueCount - index, len);
-    for (int i = off, o = index * 3, end = off + sets; i < end; ++i) {
-      final long value = arr[i];
-      blocks[o++] = (short) (value >>> 32);
-      blocks[o++] = (short) (value >>> 16);
-      blocks[o++] = (short) value;
-    }
-    return sets;
-  }
-
-  @Override
-  public void fill(int fromIndex, int toIndex, long val) {
-    final short block1 = (short) (val >>> 32);
-    final short block2 = (short) (val >>> 16);
-    final short block3 = (short) val;
-    for (int i = fromIndex * 3, end = toIndex * 3; i < end; i += 3) {
-      blocks[i] = block1;
-      blocks[i+1] = block2;
-      blocks[i+2] = block3;
-    }
-  }
-
-  @Override
-  public void clear() {
-    Arrays.fill(blocks, (short) 0);
-  }
-
-  @Override
-  public long ramBytesUsed() {
-    return RamUsageEstimator.alignObjectSize(
-        RamUsageEstimator.NUM_BYTES_OBJECT_HEADER
-        + 2 * RamUsageEstimator.NUM_BYTES_INT     // valueCount,bitsPerValue
-        + RamUsageEstimator.NUM_BYTES_OBJECT_REF) // blocks ref
-        + RamUsageEstimator.sizeOf(blocks);
-  }
-
-  @Override
-  public String toString() {
-    return getClass().getSimpleName() + "(bitsPerValue=" + bitsPerValue
-        + ",size=" + size() + ",blocks=" + blocks.length + ")";
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/packed/Packed8ThreeBlocks.java b/lucene/core/src/java/org/apache/lucene/util/packed/Packed8ThreeBlocks.java
deleted file mode 100644
index 5a85735..0000000
--- a/lucene/core/src/java/org/apache/lucene/util/packed/Packed8ThreeBlocks.java
+++ /dev/null
@@ -1,123 +0,0 @@
-// This file has been automatically generated, DO NOT EDIT
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.util.packed;
-
-import org.apache.lucene.store.DataInput;
-import org.apache.lucene.util.RamUsageEstimator;
-
-import java.io.IOException;
-import java.util.Arrays;
-
-/**
- * Packs integers into 3 bytes (24 bits per value).
- * @lucene.internal
- */
-final class Packed8ThreeBlocks extends PackedInts.MutableImpl {
-  final byte[] blocks;
-
-  public static final int MAX_SIZE = Integer.MAX_VALUE / 3;
-
-  Packed8ThreeBlocks(int valueCount) {
-    super(valueCount, 24);
-    if (valueCount > MAX_SIZE) {
-      throw new ArrayIndexOutOfBoundsException("MAX_SIZE exceeded");
-    }
-    blocks = new byte[valueCount * 3];
-  }
-
-  Packed8ThreeBlocks(int packedIntsVersion, DataInput in, int valueCount) throws IOException {
-    this(valueCount);
-    in.readBytes(blocks, 0, 3 * valueCount);
-  }
-
-  @Override
-  public long get(int index) {
-    final int o = index * 3;
-    return (blocks[o] & 0xFFL) << 16 | (blocks[o+1] & 0xFFL) << 8 | (blocks[o+2] & 0xFFL);
-  }
-
-  @Override
-  public int get(int index, long[] arr, int off, int len) {
-    assert len > 0 : "len must be > 0 (got " + len + ")";
-    assert index >= 0 && index < valueCount;
-    assert off + len <= arr.length;
-
-    final int gets = Math.min(valueCount - index, len);
-    for (int i = index * 3, end = (index + gets) * 3; i < end; i+=3) {
-      arr[off++] = (blocks[i] & 0xFFL) << 16 | (blocks[i+1] & 0xFFL) << 8 | (blocks[i+2] & 0xFFL);
-    }
-    return gets;
-  }
-
-  @Override
-  public void set(int index, long value) {
-    final int o = index * 3;
-    blocks[o] = (byte) (value >>> 16);
-    blocks[o+1] = (byte) (value >>> 8);
-    blocks[o+2] = (byte) value;
-  }
-
-  @Override
-  public int set(int index, long[] arr, int off, int len) {
-    assert len > 0 : "len must be > 0 (got " + len + ")";
-    assert index >= 0 && index < valueCount;
-    assert off + len <= arr.length;
-
-    final int sets = Math.min(valueCount - index, len);
-    for (int i = off, o = index * 3, end = off + sets; i < end; ++i) {
-      final long value = arr[i];
-      blocks[o++] = (byte) (value >>> 16);
-      blocks[o++] = (byte) (value >>> 8);
-      blocks[o++] = (byte) value;
-    }
-    return sets;
-  }
-
-  @Override
-  public void fill(int fromIndex, int toIndex, long val) {
-    final byte block1 = (byte) (val >>> 16);
-    final byte block2 = (byte) (val >>> 8);
-    final byte block3 = (byte) val;
-    for (int i = fromIndex * 3, end = toIndex * 3; i < end; i += 3) {
-      blocks[i] = block1;
-      blocks[i+1] = block2;
-      blocks[i+2] = block3;
-    }
-  }
-
-  @Override
-  public void clear() {
-    Arrays.fill(blocks, (byte) 0);
-  }
-
-  @Override
-  public long ramBytesUsed() {
-    return RamUsageEstimator.alignObjectSize(
-        RamUsageEstimator.NUM_BYTES_OBJECT_HEADER
-        + 2 * RamUsageEstimator.NUM_BYTES_INT     // valueCount,bitsPerValue
-        + RamUsageEstimator.NUM_BYTES_OBJECT_REF) // blocks ref
-        + RamUsageEstimator.sizeOf(blocks);
-  }
-
-  @Override
-  public String toString() {
-    return getClass().getSimpleName() + "(bitsPerValue=" + bitsPerValue
-        + ",size=" + size() + ",blocks=" + blocks.length + ")";
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java b/lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java
index 054f3a3..16b2969 100644
--- a/lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java
+++ b/lucene/core/src/java/org/apache/lucene/util/packed/PackedInts.java
@@ -104,7 +104,9 @@ public class PackedInts {
      * should never use it directly, but rather use
      * {@link PackedInts#fastestFormatAndBits(int, int, float)} to find the
      * format that best suits your needs.
+     * @deprecated Use {@link #PACKED} instead.
      */
+    @Deprecated
     PACKED_SINGLE_BLOCK(1) {
 
       @Override
@@ -245,8 +247,8 @@ public class PackedInts {
     int maxBitsPerValue = bitsPerValue + (int) acceptableOverheadPerValue;
 
     int actualBitsPerValue = -1;
-    Format format = Format.PACKED;
 
+    // rounded number of bits per value are usually the fastest
     if (bitsPerValue <= 8 && maxBitsPerValue >= 8) {
       actualBitsPerValue = 8;
     } else if (bitsPerValue <= 16 && maxBitsPerValue >= 16) {
@@ -255,28 +257,11 @@ public class PackedInts {
       actualBitsPerValue = 32;
     } else if (bitsPerValue <= 64 && maxBitsPerValue >= 64) {
       actualBitsPerValue = 64;
-    } else if (valueCount <= Packed8ThreeBlocks.MAX_SIZE && bitsPerValue <= 24 && maxBitsPerValue >= 24) {
-      actualBitsPerValue = 24;
-    } else if (valueCount <= Packed16ThreeBlocks.MAX_SIZE && bitsPerValue <= 48 && maxBitsPerValue >= 48) {
-      actualBitsPerValue = 48;
     } else {
-      for (int bpv = bitsPerValue; bpv <= maxBitsPerValue; ++bpv) {
-        if (Format.PACKED_SINGLE_BLOCK.isSupported(bpv)) {
-          float overhead = Format.PACKED_SINGLE_BLOCK.overheadPerValue(bpv);
-          float acceptableOverhead = acceptableOverheadPerValue + bitsPerValue - bpv;
-          if (overhead <= acceptableOverhead) {
-            actualBitsPerValue = bpv;
-            format = Format.PACKED_SINGLE_BLOCK;
-            break;
-          }
-        }
-      }
-      if (actualBitsPerValue < 0) {
-        actualBitsPerValue = bitsPerValue;
-      }
+      actualBitsPerValue = bitsPerValue;
     }
 
-    return new FormatAndBits(format, actualBitsPerValue);
+    return new FormatAndBits(Format.PACKED, actualBitsPerValue);
   }
 
   /**
@@ -779,26 +764,6 @@ public class PackedInts {
       case PACKED_SINGLE_BLOCK:
         return Packed64SingleBlock.create(in, valueCount, bitsPerValue);
       case PACKED:
-        switch (bitsPerValue) {
-          case 8:
-            return new Direct8(version, in, valueCount);
-          case 16:
-            return new Direct16(version, in, valueCount);
-          case 32:
-            return new Direct32(version, in, valueCount);
-          case 64:
-            return new Direct64(version, in, valueCount);
-          case 24:
-            if (valueCount <= Packed8ThreeBlocks.MAX_SIZE) {
-              return new Packed8ThreeBlocks(version, in, valueCount);
-            }
-            break;
-          case 48:
-            if (valueCount <= Packed16ThreeBlocks.MAX_SIZE) {
-              return new Packed16ThreeBlocks(version, in, valueCount);
-            }
-            break;
-        }
         return new Packed64(version, in, valueCount, bitsPerValue);
       default:
         throw new AssertionError("Unknown Writer format: " + format);
@@ -949,26 +914,6 @@ public class PackedInts {
       case PACKED_SINGLE_BLOCK:
         return Packed64SingleBlock.create(valueCount, bitsPerValue);
       case PACKED:
-        switch (bitsPerValue) {
-          case 8:
-            return new Direct8(valueCount);
-          case 16:
-            return new Direct16(valueCount);
-          case 32:
-            return new Direct32(valueCount);
-          case 64:
-            return new Direct64(valueCount);
-          case 24:
-            if (valueCount <= Packed8ThreeBlocks.MAX_SIZE) {
-              return new Packed8ThreeBlocks(valueCount);
-            }
-            break;
-          case 48:
-            if (valueCount <= Packed16ThreeBlocks.MAX_SIZE) {
-              return new Packed16ThreeBlocks(valueCount);
-            }
-            break;
-        }
         return new Packed64(valueCount, bitsPerValue);
       default:
         throw new AssertionError();
diff --git a/lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts.java b/lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts.java
index a675e0b..6a5cca4 100644
--- a/lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts.java
+++ b/lucene/core/src/test/org/apache/lucene/util/packed/TestPackedInts.java
@@ -343,7 +343,7 @@ public class TestPackedInts extends LuceneTestCase {
     List<PackedInts.Mutable> packedInts = createPackedInts(valueCount, bitsPerValue);
     for (PackedInts.Mutable packedInt: packedInts) {
       try {
-        fill(packedInt, PackedInts.maxValue(bitsPerValue), randomSeed);
+        fill(packedInt, bitsPerValue, randomSeed);
       } catch (Exception e) {
         e.printStackTrace(System.err);
         fail(String.format(Locale.ROOT,
@@ -358,25 +358,7 @@ public class TestPackedInts extends LuceneTestCase {
   private static List<PackedInts.Mutable> createPackedInts(
           int valueCount, int bitsPerValue) {
     List<PackedInts.Mutable> packedInts = new ArrayList<>();
-    if (bitsPerValue <= 8) {
-      packedInts.add(new Direct8(valueCount));
-    }
-    if (bitsPerValue <= 16) {
-      packedInts.add(new Direct16(valueCount));
-    }
-    if (bitsPerValue <= 24 && valueCount <= Packed8ThreeBlocks.MAX_SIZE) {
-      packedInts.add(new Packed8ThreeBlocks(valueCount));
-    }
-    if (bitsPerValue <= 32) {
-      packedInts.add(new Direct32(valueCount));
-    }
-    if (bitsPerValue <= 48 && valueCount <= Packed16ThreeBlocks.MAX_SIZE) {
-      packedInts.add(new Packed16ThreeBlocks(valueCount));
-    }
-    if (bitsPerValue <= 63) {
-      packedInts.add(new Packed64(valueCount, bitsPerValue));
-    }
-    packedInts.add(new Direct64(valueCount));
+    packedInts.add(new Packed64(valueCount, bitsPerValue));
     for (int bpv = bitsPerValue; bpv <= Packed64SingleBlock.MAX_SUPPORTED_BITS_PER_VALUE; ++bpv) {
       if (Packed64SingleBlock.isSupported(bpv)) {
         packedInts.add(Packed64SingleBlock.create(valueCount, bpv));
@@ -385,10 +367,11 @@ public class TestPackedInts extends LuceneTestCase {
     return packedInts;
   }
 
-  private static void fill(PackedInts.Mutable packedInt, long maxValue, long randomSeed) {
+  private static void fill(PackedInts.Mutable packedInt, int bitsPerValue, long randomSeed) {
     Random rnd2 = new Random(randomSeed);
+    final long maxValue = bitsPerValue == 64 ? Long.MAX_VALUE : (1L << bitsPerValue) - 1;
     for (int i = 0 ; i < packedInt.size() ; i++) {
-      long value = TestUtil.nextLong(rnd2, 0, maxValue);
+      long value = bitsPerValue == 64 ? random().nextLong() : TestUtil.nextLong(rnd2, 0, maxValue);
       packedInt.set(i, value);
       assertEquals(String.format(Locale.ROOT,
               "The set/get of the value at index %d should match for %s",
@@ -495,34 +478,6 @@ public class TestPackedInts extends LuceneTestCase {
           + " should be correct for " + p64sb.getClass().getSimpleName(),
           1, p64sb.get(INDEX-1));
     }
-
-    int index = Integer.MAX_VALUE / 24 + 1;
-    Packed8ThreeBlocks p8 = null;
-    try {
-      p8 = new Packed8ThreeBlocks(index);
-    } catch (OutOfMemoryError oome) {
-      // Ignore: see comment above
-    }
-    if (p8 != null) {
-      p8.set(index - 1, 1);
-      assertEquals("The value at position " + (index-1)
-                   + " should be correct for Packed8ThreeBlocks", 1, p8.get(index-1));
-      p8 = null;
-    }
-
-    index = Integer.MAX_VALUE / 48 + 1;
-    Packed16ThreeBlocks p16 = null;
-    try {
-      p16 = new Packed16ThreeBlocks(index);
-    } catch (OutOfMemoryError oome) {
-      // Ignore: see comment above
-    }
-    if (p16 != null) {
-      p16.set(index - 1, 1);
-      assertEquals("The value at position " + (index-1)
-                   + " should be correct for Packed16ThreeBlocks", 1, p16.get(index-1));
-      p16 = null;
-    }
   }
 
   public void testFill() {
