Index: lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(revision 1674410)
+++ lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(working copy)
@@ -313,6 +313,18 @@
   }
   
   /**
+   * Annotation for test classes that should avoid always omit
+   * actual fsync calls from reaching the filesystem.
+   * <p>
+   * This can be useful, e.g. if they make many lucene commits.
+   */
+  @Documented
+  @Inherited
+  @Retention(RetentionPolicy.RUNTIME)
+  @Target(ElementType.TYPE)
+  public @interface SuppressFsync {}
+  
+  /**
    * Marks any suites which are known not to close all the temporary
    * files. This may prevent temp. files and folders from being cleaned
    * up after the suite is completed.
Index: lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup.java	(revision 1674410)
+++ lucene/test-framework/src/java/org/apache/lucene/util/TestRuleTemporaryFilesCleanup.java	(working copy)
@@ -23,6 +23,7 @@
 import org.apache.lucene.mockfile.VerboseFS;
 import org.apache.lucene.mockfile.WindowsFS;
 import org.apache.lucene.util.LuceneTestCase.SuppressFileSystems;
+import org.apache.lucene.util.LuceneTestCase.SuppressFsync;
 import org.apache.lucene.util.LuceneTestCase.SuppressTempFileChecks;
 
 import com.carrotsearch.randomizedtesting.RandomizedContext;
@@ -138,11 +139,17 @@
     }
     
     Random random = RandomizedContext.current().getRandom();
-    // sometimes just use a bare filesystem
-    if (random.nextInt(10) > 0) {
+    
+    // speed up tests by omitting actual fsync calls to the hardware most of the time.
+    if (targetClass.isAnnotationPresent(SuppressFsync.class) || random.nextInt(100) > 0) {
       if (allowed(avoid, DisableFsyncFS.class)) {
         fs = new DisableFsyncFS(fs).getFileSystem(null);
       }
+    }
+    
+    // otherwise, wrap with mockfilesystems for additional checks. some 
+    // of these have side effects (e.g. concurrency) so it doesn't always happen.
+    if (random.nextInt(10) > 0) {
       if (allowed(avoid, LeakFS.class)) {
         fs = new LeakFS(fs).getFileSystem(null);
       }
