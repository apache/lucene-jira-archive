Index: lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo.java	(revision 1620637)
+++ lucene/core/src/java/org/apache/lucene/index/SegmentCommitInfo.java	(working copy)
@@ -324,7 +324,18 @@
 
   @Override
   public SegmentCommitInfo clone() {
-    SegmentCommitInfo other = new SegmentCommitInfo(info, delCount, delGen, fieldInfosGen, docValuesGen);
+    return clone(false);
+  }
+
+  /** Clones {@code this}, optionally also cloning the {@link SegmentInfo}. */
+  public SegmentCommitInfo clone(boolean cloneSegmentInfo) {
+    SegmentInfo otherInfo;
+    if (cloneSegmentInfo) {
+      otherInfo = info.clone();
+    } else {
+      otherInfo = info;
+    }
+    SegmentCommitInfo other = new SegmentCommitInfo(otherInfo, delCount, delGen, fieldInfosGen, docValuesGen);
     // Not clear that we need to carry over nextWriteDelGen
     // (i.e. do we ever clone after a failed write and
     // before the next successful write?), but just do it to
Index: lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java	(revision 1620637)
+++ lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java	(working copy)
@@ -21,6 +21,7 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 import java.util.regex.Matcher;
@@ -29,7 +30,6 @@
 import org.apache.lucene.codecs.lucene3x.Lucene3xSegmentInfoFormat;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.TrackingDirectoryWrapper;
-import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.Version;
 
 /**
@@ -355,4 +355,21 @@
   public Map<String,String> attributes() {
     return attributes;
   }
+
+  private static Map<String,String> cloneMap(Map<String,String> map) {
+    if (map != null) {
+      return new HashMap<String,String>(map);
+    } else {
+      return null;
+    }
+  }
+
+  @Override
+  public SegmentInfo clone() {
+    SegmentInfo other = new SegmentInfo(dir, version, name, docCount, isCompoundFile, codec, cloneMap(diagnostics), cloneMap(attributes), id);
+    if (setFiles != null) {
+      other.setFiles(new HashSet<>(setFiles));
+    }
+    return other;
+  }
 }
Index: lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java	(revision 1620637)
+++ lucene/core/src/java/org/apache/lucene/index/SegmentInfos.java	(working copy)
@@ -659,6 +659,11 @@
   
   @Override
   public SegmentInfos clone() {
+    return clone(false);
+  }
+
+  /** Deep clone of this {@code SegmentInfos}, optionally also fully cloning the {@link SegmentInfo}. */
+  public SegmentInfos clone(boolean cloneSegmentInfo) {
     try {
       final SegmentInfos sis = (SegmentInfos) super.clone();
       // deep clone, first recreate all collections:
@@ -666,7 +671,7 @@
       for(final SegmentCommitInfo info : this) {
         assert info.info.getCodec() != null;
         // dont directly access segments, use add method!!!
-        sis.add(info.clone());
+        sis.add(info.clone(cloneSegmentInfo));
       }
       sis.userData = new HashMap<>(userData);
       return sis;
Index: lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader.java	(revision 1620637)
+++ lucene/core/src/java/org/apache/lucene/index/StandardDirectoryReader.java	(working copy)
@@ -74,6 +74,9 @@
 
   /** Used by near real-time search */
   static DirectoryReader open(IndexWriter writer, SegmentInfos infos, boolean applyAllDeletes) throws IOException {
+
+    assert Thread.holdsLock(writer);
+
     // IndexWriter synchronizes externally before calling
     // us, which ensures infos will not change; so there's
     // no need to process segments in reverse order
@@ -82,7 +85,10 @@
     List<SegmentReader> readers = new ArrayList<>();
     final Directory dir = writer.getDirectory();
 
-    final SegmentInfos segmentInfos = infos.clone();
+    // LUCENE-5907: must make a deep clone, even of the SegmentInfo, so that if its files changed e.g. due to upgrade from 3.x index, we
+    // don't later corrupt the index when this reader is closed:
+    final SegmentInfos segmentInfos = infos.clone(true);
+
     int infosUpto = 0;
     boolean success = false;
     try {
Index: lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility3x.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility3x.java	(revision 1620637)
+++ lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility3x.java	(working copy)
@@ -23,7 +23,6 @@
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -57,8 +56,6 @@
 import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.Constants;
-import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
@@ -948,4 +945,39 @@
     TestUtil.checkIndex(dir);
     dir.close();
   }
+
+  // LUCENE-5907
+  public void testUpgradeWithNRTReader() throws Exception {
+    for (String name : oldNames) {
+      Directory dir = newDirectory(oldIndexDirs.get(name));
+
+      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))
+                                           .setOpenMode(OpenMode.APPEND));
+      writer.addDocument(new Document());
+      DirectoryReader r = DirectoryReader.open(writer, true);
+      writer.commit();
+      r.close();
+      writer.forceMerge(1);
+      writer.commit();
+      writer.rollback();
+      new SegmentInfos().read(dir);
+      dir.close();
+    }
+  }
+
+  // LUCENE-5907
+  public void testUpgradeThenMultipleCommits() throws Exception {
+    for (String name : oldNames) {
+      Directory dir = newDirectory(oldIndexDirs.get(name));
+
+      IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))
+                                           .setOpenMode(OpenMode.APPEND));
+      writer.addDocument(new Document());
+      writer.commit();
+      writer.addDocument(new Document());
+      writer.commit();
+      writer.close();
+      dir.close();
+    }
+  }
 }
