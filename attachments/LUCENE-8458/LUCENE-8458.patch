diff --git a/lucene/core/src/java/org/apache/lucene/index/PendingDeletes.java b/lucene/core/src/java/org/apache/lucene/index/PendingDeletes.java
index 4ab037c950..b7d83da209 100644
--- a/lucene/core/src/java/org/apache/lucene/index/PendingDeletes.java
+++ b/lucene/core/src/java/org/apache/lucene/index/PendingDeletes.java
@@ -42,7 +42,7 @@ class PendingDeletes {
   private boolean liveDocsInitialized;
 
   PendingDeletes(SegmentReader reader, SegmentCommitInfo info) {
-    this(info, reader.getLiveDocs(), true);
+    this(info, reader.getHardLiveDocs(), true);
     pendingDeleteCount = reader.numDeletedDocs() - info.getDelCount();
   }
 
@@ -53,7 +53,7 @@ class PendingDeletes {
     // For segments that were published we enforce a reader in the BufferedUpdatesStream.SegmentState ctor
   }
 
-  private PendingDeletes(SegmentCommitInfo info, Bits liveDocs, boolean liveDocsInitialized) {
+  PendingDeletes(SegmentCommitInfo info, Bits liveDocs, boolean liveDocsInitialized) {
     this.info = info;
     this.liveDocs = liveDocs;
     pendingDeleteCount = 0;
@@ -125,7 +125,7 @@ class PendingDeletes {
   /**
    * Called once a new reader is opened for this segment ie. when deletes or updates are applied.
    */
-  void onNewReader(CodecReader reader, SegmentCommitInfo info) throws IOException {
+  void onNewReader(SegmentReader reader, SegmentCommitInfo info) throws IOException {
     if (liveDocsInitialized == false) {
       assert writeableLiveDocs == null;
       if (reader.hasDeletions()) {
@@ -133,7 +133,7 @@ class PendingDeletes {
         // if we use the live docs from a reader it has to be in a situation where we don't
         // have any existing live docs
         assert pendingDeleteCount == 0 : "pendingDeleteCount: " + pendingDeleteCount;
-        liveDocs = reader.getLiveDocs();
+        liveDocs = reader.getHardLiveDocs();
         assert liveDocs == null || assertCheckLiveDocs(liveDocs, info.info.maxDoc(), info.getDelCount());
       }
       liveDocsInitialized = true;
@@ -219,7 +219,7 @@ class PendingDeletes {
   /**
    * Returns <code>true</code> iff the segment represented by this {@link PendingDeletes} is fully deleted
    */
-  boolean isFullyDeleted(IOSupplier<CodecReader> readerIOSupplier) throws IOException {
+  boolean isFullyDeleted(IOSupplier<SegmentReader> readerIOSupplier) throws IOException {
     return getDelCount() == info.info.maxDoc();
   }
 
@@ -231,8 +231,8 @@ class PendingDeletes {
   void onDocValuesUpdate(FieldInfo info, DocValuesFieldUpdates.Iterator iterator) throws IOException {
   }
 
-  int numDeletesToMerge(MergePolicy policy, IOSupplier<CodecReader> readerIOSupplier) throws IOException {
-    return policy.numDeletesToMerge(info, getDelCount(), readerIOSupplier);
+  int numDeletesToMerge(MergePolicy policy, IOSupplier<SegmentReader> readerIOSupplier) throws IOException {
+    return policy.numDeletesToMerge(info, getDelCount(), readerIOSupplier::get);
   }
 
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes.java b/lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes.java
index eb6e4ff360..fad669fb47 100644
--- a/lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes.java
+++ b/lucene/core/src/java/org/apache/lucene/index/PendingSoftDeletes.java
@@ -37,7 +37,7 @@ final class PendingSoftDeletes extends PendingDeletes {
   private final PendingDeletes hardDeletes;
 
   PendingSoftDeletes(String field, SegmentCommitInfo info)  {
-    super(info);
+    super(info, null, info.getDelCount(true) == 0);
     this.field = field;
     hardDeletes = new PendingDeletes(info);
   }
@@ -71,7 +71,7 @@ final class PendingSoftDeletes extends PendingDeletes {
   }
 
   @Override
-  void onNewReader(CodecReader reader, SegmentCommitInfo info) throws IOException {
+  void onNewReader(SegmentReader reader, SegmentCommitInfo info) throws IOException {
     super.onNewReader(reader, info);
     hardDeletes.onNewReader(reader, info);
     if (dvGeneration < info.getDocValuesGen()) { // only re-calculate this if we haven't seen this generation
@@ -172,12 +172,12 @@ final class PendingSoftDeletes extends PendingDeletes {
   }
 
   @Override
-  int numDeletesToMerge(MergePolicy policy, IOSupplier<CodecReader> readerIOSupplier) throws IOException {
+  int numDeletesToMerge(MergePolicy policy, IOSupplier<SegmentReader> readerIOSupplier) throws IOException {
     ensureInitialized(readerIOSupplier); // initialize to ensure we have accurate counts
     return super.numDeletesToMerge(policy, readerIOSupplier);
   }
 
-  private void ensureInitialized(IOSupplier<CodecReader> readerIOSupplier) throws IOException {
+  private void ensureInitialized(IOSupplier<SegmentReader> readerIOSupplier) throws IOException {
     if (dvGeneration == -2) {
       FieldInfos fieldInfos = readFieldInfos();
       FieldInfo fieldInfo = fieldInfos.fieldInfo(field);
@@ -196,7 +196,7 @@ final class PendingSoftDeletes extends PendingDeletes {
   }
 
   @Override
-  boolean isFullyDeleted(IOSupplier<CodecReader> readerIOSupplier) throws IOException {
+  boolean isFullyDeleted(IOSupplier<SegmentReader> readerIOSupplier) throws IOException {
     ensureInitialized(readerIOSupplier); // initialize to ensure we have accurate counts - only needed in the soft-delete case
     return super.isFullyDeleted(readerIOSupplier);
   }
diff --git a/lucene/core/src/java/org/apache/lucene/index/ReaderPool.java b/lucene/core/src/java/org/apache/lucene/index/ReaderPool.java
index b792be2687..551bf299fd 100644
--- a/lucene/core/src/java/org/apache/lucene/index/ReaderPool.java
+++ b/lucene/core/src/java/org/apache/lucene/index/ReaderPool.java
@@ -91,7 +91,7 @@ final class ReaderPool implements Closeable {
         SegmentReader newReader = new SegmentReader(segmentInfos.info(i), segReader, segReader.getLiveDocs(),
             segReader.getHardLiveDocs(), segReader.numDocs(), true);
         readerMap.put(newReader.getOriginalSegmentInfo(), new ReadersAndUpdates(segmentInfos.getIndexCreatedVersionMajor(),
-            newReader, newPendingDeletes(newReader, newReader.getOriginalSegmentInfo())));
+            newReader, newPendingDeletes(newReader, newReader.getOriginalSegmentInfo()), softDeletesField));
       }
     }
   }
@@ -372,7 +372,7 @@ final class ReaderPool implements Closeable {
       if (create == false) {
         return null;
       }
-      rld = new ReadersAndUpdates(segmentInfos.getIndexCreatedVersionMajor(), info, newPendingDeletes(info));
+      rld = new ReadersAndUpdates(segmentInfos.getIndexCreatedVersionMajor(), info, newPendingDeletes(info), softDeletesField);
       // Steal initial reference:
       readerMap.put(info, rld);
     } else {
diff --git a/lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java b/lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java
index b09338fc72..1cc11a8275 100644
--- a/lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java
+++ b/lucene/core/src/java/org/apache/lucene/index/ReadersAndUpdates.java
@@ -62,6 +62,7 @@ final class ReadersAndUpdates {
   // How many further deletions we've done against
   // liveDocs vs when we loaded it or last wrote it:
   private final PendingDeletes pendingDeletes;
+  private final String softDeletesFields;
 
   // the major version this index was created with
   private final int indexCreatedVersionMajor;
@@ -89,17 +90,19 @@ final class ReadersAndUpdates {
   final AtomicLong ramBytesUsed = new AtomicLong();
 
   ReadersAndUpdates(int indexCreatedVersionMajor, SegmentCommitInfo info,
-                    PendingDeletes pendingDeletes) {
+                    PendingDeletes pendingDeletes, String softDeletesField) {
     this.info = info;
     this.pendingDeletes = pendingDeletes;
     this.indexCreatedVersionMajor = indexCreatedVersionMajor;
+    this.softDeletesFields = softDeletesField;
   }
 
   /** Init from a previously opened SegmentReader.
    *
    * <p>NOTE: steals incoming ref from reader. */
-  ReadersAndUpdates(int indexCreatedVersionMajor, SegmentReader reader, PendingDeletes pendingDeletes) throws IOException {
-    this(indexCreatedVersionMajor, reader.getOriginalSegmentInfo(), pendingDeletes);
+  ReadersAndUpdates(int indexCreatedVersionMajor, SegmentReader reader,
+                    PendingDeletes pendingDeletes, String softDeletesFields) throws IOException {
+    this(indexCreatedVersionMajor, reader.getOriginalSegmentInfo(), pendingDeletes, softDeletesFields);
     this.reader = reader;
     pendingDeletes.onNewReader(reader, info);
   }
@@ -184,6 +187,11 @@ final class ReadersAndUpdates {
   }
 
   public synchronized boolean delete(int docID) throws IOException {
+    // If soft-deletes is enabled, we need to make sure that PendingDeletes is initialized,
+    // so that soft-deletes can be transferred to hard-deletes accordingly.
+    if (reader == null && softDeletesFields != null) {
+      getLatestReader();
+    }
     return pendingDeletes.delete(docID);
   }
 
@@ -227,7 +235,7 @@ final class ReadersAndUpdates {
     return pendingDeletes.numDeletesToMerge(policy, this::getLatestReader);
   }
 
-  private synchronized CodecReader getLatestReader() throws IOException {
+  private synchronized SegmentReader getLatestReader() throws IOException {
     if (this.reader == null) {
       // get a reader and dec the ref right away we just make sure we have a reader
       getReader(IOContext.READ).decRef();
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java b/lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java
index 70f43a00fe..991e994499 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestPendingSoftDeletes.java
@@ -84,6 +84,44 @@ public class TestPendingSoftDeletes extends TestPendingDeletes {
     IOUtils.close(reader, writer, dir);
   }
 
+  public void testHardSoftLiveDocs() throws Exception {
+    Directory dir = newDirectory();
+    IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()
+        .setSoftDeletesField("_soft_deletes")
+        // make sure all docs will end up in the same segment
+        .setMaxBufferedDocs(10)
+        .setMergePolicy(NoMergePolicy.INSTANCE)
+        .setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH));
+
+    Document d1 = new Document();
+    d1.add(new StringField("id", "1", Field.Store.YES));
+    writer.addDocument(d1);
+    writer.softUpdateDocument(new Term("id", "1"), d1, new NumericDocValuesField("_soft_deletes", 1));
+
+    Document d2 = new Document();
+    d2.add(new StringField("id", "2", Field.Store.YES));
+    writer.addDocument(d2);
+    writer.deleteDocuments(new Term("id", "2"));
+    writer.commit();
+
+    DirectoryReader reader = writer.getReader();
+    assertEquals(1, reader.leaves().size());
+    SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();
+    SegmentCommitInfo segmentInfo = segmentReader.getSegmentInfo();
+    assertEquals(3, segmentInfo.info.maxDoc());
+    assertEquals(1, segmentInfo.getDelCount());
+    assertEquals(1, segmentInfo.getSoftDelCount());
+    PendingSoftDeletes pendingSoftDeletes = newPendingDeletes(segmentInfo);
+    pendingSoftDeletes.onNewReader(segmentReader, segmentInfo);
+    assertFalse(pendingSoftDeletes.getLiveDocs().get(0));
+    assertTrue(pendingSoftDeletes.getLiveDocs().get(1));
+    assertFalse(pendingSoftDeletes.getLiveDocs().get(2));
+    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(0));
+    assertTrue(pendingSoftDeletes.getHardLiveDocs().get(1));
+    assertFalse(pendingSoftDeletes.getHardLiveDocs().get(2));
+    IOUtils.close(reader, writer, dir);
+  }
+
   public void testDeleteSoft() throws IOException {
     Directory dir = newDirectory();
     IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig()
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestSoftDeletesRetentionMergePolicy.java b/lucene/core/src/test/org/apache/lucene/index/TestSoftDeletesRetentionMergePolicy.java
index 909ee9c049..bc50fe52d9 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestSoftDeletesRetentionMergePolicy.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestSoftDeletesRetentionMergePolicy.java
@@ -29,6 +29,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Supplier;
 
+import com.carrotsearch.randomizedtesting.generators.RandomPicks;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.IntPoint;
@@ -594,7 +595,7 @@ public class TestSoftDeletesRetentionMergePolicy extends LuceneTestCase {
     }
     while (true) {
       try (DirectoryReader reader = writer.getReader()) {
-        TopDocs topDocs = new IndexSearcher(new NoDeletesWrapper(reader)).search(new TermQuery(new Term("id", "1")), 1);
+        TopDocs topDocs = new IndexSearcher(new IncludeSoftDeletesWrapper(reader)).search(new TermQuery(new Term("id", "1")), 1);
         assertEquals(1, topDocs.totalHits.value);
         if (writer.tryDeleteDocument(reader, topDocs.scoreDocs[0].doc) > 0) {
           break;
@@ -630,11 +631,58 @@ public class TestSoftDeletesRetentionMergePolicy extends LuceneTestCase {
     IOUtils.close(sm, writer, dir);
   }
 
+  public void testMixedSoftDeletesAndHardDeletes() throws Exception {
+    Directory dir = newDirectory();
+    String softDeletesField = "soft-deletes";
+    IndexWriterConfig config = newIndexWriterConfig()
+        .setMaxBufferedDocs(2 + random().nextInt(50)).setRAMBufferSizeMB(IndexWriterConfig.DISABLE_AUTO_FLUSH)
+        .setSoftDeletesField(softDeletesField)
+        .setMergePolicy(new SoftDeletesRetentionMergePolicy(softDeletesField, MatchAllDocsQuery::new, newMergePolicy()));
+    IndexWriter writer = new IndexWriter(dir, config);
+    int numDocs = 10 + random().nextInt(100);
+    Set<String> liveDocs = new HashSet<>();
+    for (int i = 0; i < numDocs; i++) {
+      String id = Integer.toString(i);
+      Document doc = new Document();
+      doc.add(new StringField("id", id, Field.Store.YES));
+      writer.addDocument(doc);
+      liveDocs.add(id);
+    }
+    for (int i = 0; i < numDocs; i++) {
+      if (random().nextBoolean()) {
+        String id = Integer.toString(i);
+        if (random().nextBoolean() && liveDocs.contains(id)) {
+          doUpdate(new Term("id", id), writer, new NumericDocValuesField(softDeletesField, 1));
+        } else {
+          Document doc = new Document();
+          doc.add(new StringField("id", "v" + id, Field.Store.YES));
+          writer.softUpdateDocument(new Term("id", id), doc, new NumericDocValuesField(softDeletesField, 1));
+          liveDocs.add("v" + id);
+        }
+      }
+      if (random().nextBoolean() && liveDocs.isEmpty() == false) {
+        String delId = RandomPicks.randomFrom(random(), liveDocs);
+        if (random().nextBoolean()) {
+          doDelete(new Term("id", delId), writer);
+        } else {
+          writer.deleteDocuments(new Term("id", delId));
+        }
+        liveDocs.remove(delId);
+      }
+    }
+    try (DirectoryReader unwrapped = writer.getReader()) {
+      DirectoryReader reader = new IncludeSoftDeletesWrapper(unwrapped);
+      assertEquals(liveDocs.size(), reader.numDocs());
+    }
+    writer.commit();
+    IOUtils.close(writer, dir);
+  }
+
   static void doUpdate(Term doc, IndexWriter writer, Field... fields) throws IOException {
     long seqId = -1;
     do { // retry if we just committing a merge
       try (DirectoryReader reader = writer.getReader()) {
-        TopDocs topDocs = new IndexSearcher(new NoDeletesWrapper(reader)).search(new TermQuery(doc), 10);
+        TopDocs topDocs = new IndexSearcher(new IncludeSoftDeletesWrapper(reader)).search(new TermQuery(doc), 10);
         assertEquals(1, topDocs.totalHits.value);
         int theDoc = topDocs.scoreDocs[0].doc;
         seqId = writer.tryUpdateDocValue(reader, theDoc, fields);
@@ -642,20 +690,46 @@ public class TestSoftDeletesRetentionMergePolicy extends LuceneTestCase {
     } while (seqId == -1);
   }
 
-  private static final class NoDeletesSubReaderWrapper extends FilterDirectoryReader.SubReaderWrapper {
+  static void doDelete(Term doc, IndexWriter writer) throws IOException {
+    long seqId;
+    do { // retry if we just committing a merge
+      try (DirectoryReader reader = writer.getReader()) {
+        TopDocs topDocs = new IndexSearcher(new IncludeSoftDeletesWrapper(reader)).search(new TermQuery(doc), 10);
+        assertEquals(1, topDocs.totalHits.value);
+        int theDoc = topDocs.scoreDocs[0].doc;
+        seqId = writer.tryDeleteDocument(reader, theDoc);
+      }
+    } while (seqId == -1);
+  }
 
+  private static final class IncludeSoftDeletesSubReaderWrapper extends FilterDirectoryReader.SubReaderWrapper {
     @Override
     public LeafReader wrap(LeafReader reader) {
+      while (reader instanceof FilterLeafReader) {
+        reader = ((FilterLeafReader) reader).getDelegate();
+      }
+      Bits hardLiveDocs = ((SegmentReader) reader).getHardLiveDocs();
+      final int numDocs;
+      if (hardLiveDocs == null) {
+        numDocs = reader.maxDoc();
+      } else {
+        int bits = 0;
+        for (int i = 0; i < hardLiveDocs.length(); i++) {
+          if (hardLiveDocs.get(i)) {
+            bits++;
+          }
+        }
+        numDocs = bits;
+      }
       return new FilterLeafReader(reader) {
-
         @Override
         public int numDocs() {
-          return maxDoc();
+          return numDocs;
         }
 
         @Override
         public Bits getLiveDocs() {
-          return null;
+          return hardLiveDocs;
         }
 
         @Override
@@ -671,15 +745,15 @@ public class TestSoftDeletesRetentionMergePolicy extends LuceneTestCase {
     }
   }
 
-  private static final class NoDeletesWrapper extends FilterDirectoryReader {
+  private static final class IncludeSoftDeletesWrapper extends FilterDirectoryReader {
 
-    NoDeletesWrapper(DirectoryReader in) throws IOException {
-      super(in, new NoDeletesSubReaderWrapper());
+    IncludeSoftDeletesWrapper(DirectoryReader in) throws IOException {
+      super(in, new IncludeSoftDeletesSubReaderWrapper());
     }
 
     @Override
     protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) throws IOException {
-      return new NoDeletesWrapper(in);
+      return new IncludeSoftDeletesWrapper(in);
     }
 
 
