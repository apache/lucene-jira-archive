commit 3242ee89058ef7db78dbd01400d7d9885689e791
Author: Mikhail Khludnev <mkhl@apache.org>
Date:   Mon Jul 3 14:58:28 2017 +0300

    LUCENE-7835: ToChildBlockJoinSortField

diff --git a/lucene/join/src/java/org/apache/lucene/search/join/BlockJoinSelector.java b/lucene/join/src/java/org/apache/lucene/search/join/BlockJoinSelector.java
index 79c35b8..fa9e7d8 100644
--- a/lucene/join/src/java/org/apache/lucene/search/join/BlockJoinSelector.java
+++ b/lucene/join/src/java/org/apache/lucene/search/join/BlockJoinSelector.java
@@ -43,6 +43,16 @@ public class BlockJoinSelector {
     MAX;
   }
 
+  @FunctionalInterface 
+  interface StringSelector {
+    SortedDocValues select(SortedSetDocValues sortedSet, Type selection, BitSet parents, DocIdSetIterator children);
+  }
+  
+  @FunctionalInterface
+  interface NumericSelector {
+    NumericDocValues select(SortedNumericDocValues sortedSet, Type selection, BitSet parents, DocIdSetIterator children);
+  }
+  
   /** Return a {@link Bits} instance that returns true if, and only if, any of
    *  the children of the given parent document has a value. */
   public static Bits wrap(final Bits docsWithValue, BitSet parents, BitSet children) {
@@ -86,6 +96,16 @@ public class BlockJoinSelector {
    *  one value per parent among its {@code children} using the configured
    *  {@code selection} type. */
   public static SortedDocValues wrap(SortedSetDocValues sortedSet, Type selection, BitSet parents, DocIdSetIterator children) {
+    return stringToParent(sortedSet, selection, parents, children);
+  }
+
+  static SortedDocValues stringToParent(SortedSetDocValues sortedSet, Type selection, BitSet parents,
+      DocIdSetIterator children) throws AssertionError {
+    SortedDocValues values = singleSortedDocValues(sortedSet, selection);
+    return wrap(values, selection, parents, children);
+  }
+
+  static SortedDocValues singleSortedDocValues(SortedSetDocValues sortedSet, Type selection) throws AssertionError {
     SortedDocValues values;
     switch (selection) {
       case MIN:
@@ -97,7 +117,7 @@ public class BlockJoinSelector {
       default:
         throw new AssertionError();
     }
-    return wrap(values, selection, parents, children);
+    return values;
   }
   
   /** Wraps the provided {@link SortedDocValues} in order to only select
@@ -135,6 +155,16 @@ public class BlockJoinSelector {
    *  one value per parent among its {@code children} using the configured
    *  {@code selection} type. */
   public static NumericDocValues wrap(SortedNumericDocValues sortedNumerics, Type selection, BitSet parents, DocIdSetIterator children) {
+    return numericToParent(sortedNumerics, selection, parents, children);
+  }
+  static NumericDocValues numericToParent(SortedNumericDocValues sortedNumerics, Type selection, BitSet parents,
+      DocIdSetIterator children) throws AssertionError {
+    NumericDocValues values = singleNumericDocValues(sortedNumerics, selection);
+    return wrap(values, selection, parents, children);
+  }
+
+  protected static NumericDocValues singleNumericDocValues(SortedNumericDocValues sortedNumerics, Type selection)
+      throws AssertionError {
     NumericDocValues values;
     switch (selection) {
       case MIN:
@@ -146,7 +176,7 @@ public class BlockJoinSelector {
       default:
         throw new AssertionError();
     }
-    return wrap(values, selection, parents, children);
+    return values;
   }
 
   /** Wraps the provided {@link NumericDocValues}, iterating over only
@@ -166,4 +196,18 @@ public class BlockJoinSelector {
     }
     return ToParentDocValues.wrap(values,selection, parents, children);
   }
+
+  public static SortedDocValues stringToChild(SortedSetDocValues sortedSet, BlockJoinSelector.Type type, BitSet parents, DocIdSetIterator children) {
+    if (sortedSet.docID() != -1) {
+      throw new IllegalArgumentException("values iterator was already consumed: values.docID=" + sortedSet.docID());
+    }
+    return ToChildDocValues.wrap(singleSortedDocValues(sortedSet, type), parents, children);
+  }
+  
+  public static NumericDocValues numericToChild(SortedNumericDocValues sortedNumerics ,BlockJoinSelector.Type type, BitSet parents, DocIdSetIterator children) {
+    if (sortedNumerics.docID() != -1) {
+      throw new IllegalArgumentException("values iterator was already consumed: values.docID=" + sortedNumerics.docID());
+    }
+    return ToChildDocValues.wrap(singleNumericDocValues(sortedNumerics, type) , parents, children);
+  }
 }
diff --git a/lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinSortField.java b/lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinSortField.java
new file mode 100644
index 0000000..0531da6
--- /dev/null
+++ b/lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinSortField.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search.join;
+
+/**
+ * A special sort field that allows sorting child docs based on enclosing parents' fields.
+ * Based on the sort order it either takes the document with the lowest or highest field value into account.
+ *
+ * @lucene.experimental
+ */
+public class ToChildBlockJoinSortField extends ToParentBlockJoinSortField {
+
+  public ToChildBlockJoinSortField(String field, Type type, boolean reverse, BitSetProducer parentFilter,
+      BitSetProducer childFilter) {
+    this(field, type, reverse, reverse, parentFilter, childFilter);
+  }
+
+  public ToChildBlockJoinSortField(String field, Type type, boolean reverse, boolean order, BitSetProducer parentFilter,
+      BitSetProducer childFilter) {
+    super(field, type, reverse, order, parentFilter, childFilter,
+        BlockJoinSelector::stringToChild, BlockJoinSelector::numericToChild);
+  }
+
+  
+}
diff --git a/lucene/join/src/java/org/apache/lucene/search/join/ToChildDocValues.java b/lucene/join/src/java/org/apache/lucene/search/join/ToChildDocValues.java
new file mode 100644
index 0000000..c12f263
--- /dev/null
+++ b/lucene/join/src/java/org/apache/lucene/search/join/ToChildDocValues.java
@@ -0,0 +1,230 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search.join;
+
+import java.io.IOException;
+
+import org.apache.lucene.index.NumericDocValues;
+import org.apache.lucene.index.SortedDocValues;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.util.BitSet;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.automaton.CompiledAutomaton;
+
+abstract class ToChildDocValues extends DocIdSetIterator {
+  
+  final private BitSet parents;
+  final private DocIdSetIterator children;
+  final private DocIdSetIterator parentValues;
+  private int docId;
+  
+  public ToChildDocValues(DocIdSetIterator parentValues, BitSet parents, DocIdSetIterator children) {
+    super();
+    this.parentValues = parentValues;
+    this.parents = parents;
+    this.children = children;
+    docId = children.docID();
+  }
+
+  public boolean advanceExact(int target) throws IOException {
+    docId=target;
+    if (children.docID()<target) {
+      int newDocId = children.advance(docId);
+      if (newDocId!=target) {
+        return false;
+      }
+    } 
+    if (children.docID()>target) {//child already leaped beyond the given target 
+      return false; // it means no match.
+    } // children.docID()==target gets further 
+    //docId = children.docID();
+    if (children.docID()!=NO_MORE_DOCS) {
+      if (parentValues.docID() ==-1 || parentValues.docID()<children.docID()) {
+        return advanceParentsExact(
+            parents.nextSetBit(children.docID()));
+      } else {//no need to drag parent. it's already there. 
+        return true;
+      }
+    }
+    // Ohrlly?
+    return false; 
+  }
+  
+  @Override
+  public int docID() {
+    //assert docId==children.docID();
+    return docId;//children.docID();
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    if (children.docID()==NO_MORE_DOCS) {
+      return docId = children.docID();
+    }
+    docId = children.nextDoc();
+    
+    if (docId!=NO_MORE_DOCS) {
+      if (parentValues.docID() ==-1 || parentValues.docID()<docId) {
+        advanceParentsExact(
+            parents.nextSetBit(docId));
+      }
+    }
+    
+    return docId;
+  }
+
+  protected abstract boolean advanceParentsExact(int nextSetBit) throws IOException;
+
+  @Override
+  public int advance(int target) throws IOException {
+    boolean hitParent = true;
+    do{
+      assert target>children.docID();
+    docId = children.advance(target) ;
+    
+    if (docId!=NO_MORE_DOCS) {
+      if (parentValues.docID() ==-1 || parentValues.docID()<docId) {
+        hitParent = advanceParentsExact(
+            parents.nextSetBit(docId));
+      }
+    }
+    }while(!hitParent && docId!=NO_MORE_DOCS);
+    return docId;
+  }
+
+  @Override
+  public long cost() {
+    return children.cost();
+  }
+
+
+  static private class NumDV extends NumericDocValues {
+    private final ToChildDocValues iter;
+    private final NumericDocValues parentValues;
+    public NumDV(NumericDocValues parentValues, BitSet parents, DocIdSetIterator children) {
+      super();
+      this.parentValues = parentValues;
+      this.iter = new ToChildDocValues(parentValues, parents, children) {
+        
+        protected boolean advanceParentsExact(int target) throws IOException{
+          return parentValues.advanceExact(target);
+        }
+      };
+    }
+    @Override
+    public long longValue() throws IOException {
+      return parentValues.longValue();
+    }
+    @Override
+    public boolean advanceExact(int target) throws IOException {
+      return iter.advanceExact(target);
+    }
+    @Override
+    public int docID() {
+      return iter.docID();
+    }
+    @Override
+    public int nextDoc() throws IOException {
+      return iter.nextDoc();
+    }
+    @Override
+    public int advance(int target) throws IOException {
+      return iter.advance(target);
+    }
+    @Override
+    public long cost() {
+      return iter.cost();
+    }
+  }
+  
+  static private class SortedDV extends SortedDocValues {
+    private final ToChildDocValues iter;
+    private final SortedDocValues parentValues;
+    public SortedDV( final SortedDocValues parentValues, BitSet parents, DocIdSetIterator children) {
+      super();
+      this.iter = new ToChildDocValues(parentValues, parents, children) {
+        
+        protected boolean advanceParentsExact(int target) throws IOException{
+          return parentValues.advanceExact(target);
+        }
+      };
+      this.parentValues = parentValues;
+    }
+    
+    @Override 
+    public boolean advanceExact(int target) throws IOException {
+      final boolean advanceExact = iter.advanceExact(target);
+      //final int ordValue = ordValue();
+      //final BytesRef lookupOrd = lookupOrd(ordValue);
+      //System.out.println("advanceExact("+target+"):"+advanceExact+" "+
+      //    "ord:"+ordValue+" term:"+(lookupOrd!=null?lookupOrd.utf8ToString():lookupOrd));
+      return advanceExact;
+    }
+    
+    @Override
+    public int docID() {
+      return iter.docID();
+    }
+    
+    @Override
+    public int nextDoc() throws IOException {
+      return iter.nextDoc();
+    }
+    
+    @Override
+    public int advance(int target) throws IOException {
+      return iter.advance(target);
+    }
+    @Override
+    public long cost() {
+      return iter.cost();
+    }
+    @Override
+    public TermsEnum termsEnum() throws IOException {
+      return parentValues.termsEnum();
+    }
+    @Override
+    public TermsEnum intersect(CompiledAutomaton automaton) throws IOException {
+      return parentValues.intersect(automaton);
+    }
+    @Override
+    public int ordValue() throws IOException {
+      return parentValues.ordValue();
+    }
+    @Override
+    public BytesRef lookupOrd(int ord) throws IOException {
+      return parentValues.lookupOrd(ord);
+    }
+    @Override
+    public int getValueCount() {
+      return parentValues.getValueCount();
+    }
+    
+  }
+
+  public static SortedDocValues wrap (SortedDocValues sortedSet, BitSet parents2,
+      DocIdSetIterator children){
+    
+    return new ToChildDocValues.SortedDV(sortedSet, parents2, children);
+  }
+
+  public static NumericDocValues wrap (NumericDocValues values,BitSet parents2,
+      DocIdSetIterator children){
+    return new ToChildDocValues.NumDV(values, parents2, children);
+  }
+}
diff --git a/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinSortField.java b/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinSortField.java
index fef167e..9bf5388 100644
--- a/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinSortField.java
+++ b/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinSortField.java
@@ -42,6 +42,9 @@ public class ToParentBlockJoinSortField extends SortField {
   private final BitSetProducer parentFilter;
   private final BitSetProducer childFilter;
 
+  private final BlockJoinSelector.StringSelector stringSelector;
+  private final BlockJoinSelector.NumericSelector numericSelector;
+  
   /**
    * Create ToParentBlockJoinSortField. The parent document ordering is based on child document ordering (reverse).
    *
@@ -52,21 +55,7 @@ public class ToParentBlockJoinSortField extends SortField {
    * @param childFilter Filter that defines which child documents participates in sorting.
    */
   public ToParentBlockJoinSortField(String field, Type type, boolean reverse, BitSetProducer parentFilter, BitSetProducer childFilter) {
-    super(field, type, reverse);
-    switch (getType()) {
-      case STRING:
-      case DOUBLE:
-      case FLOAT:
-      case LONG:
-      case INT:
-        // ok
-        break;
-      default:
-        throw new UnsupportedOperationException("Sort type " + type + " is not supported");
-    }
-    this.order = reverse;
-    this.parentFilter = parentFilter;
-    this.childFilter = childFilter;
+    this(field, type, reverse,reverse,parentFilter,childFilter);
   }
 
   /**
@@ -80,12 +69,34 @@ public class ToParentBlockJoinSortField extends SortField {
    * @param childFilter Filter that defines which child documents participates in sorting.
    */
   public ToParentBlockJoinSortField(String field, Type type, boolean reverse, boolean order, BitSetProducer parentFilter, BitSetProducer childFilter) {
+    this(field, type, reverse,order,parentFilter,childFilter,
+        BlockJoinSelector::stringToParent, BlockJoinSelector::numericToParent);
+  }
+
+  protected ToParentBlockJoinSortField(String field, Type type, 
+      boolean reverse, boolean order, 
+      BitSetProducer parentFilter, BitSetProducer childFilter,
+      BlockJoinSelector.StringSelector stringSelector, 
+      BlockJoinSelector.NumericSelector numericSelector) {
     super(field, type, reverse);
+    switch (getType()) {
+      case STRING:
+      case DOUBLE:
+      case FLOAT:
+      case LONG:
+      case INT:
+        // ok
+        break;
+      default:
+        throw new UnsupportedOperationException("Sort type " + type + " is not supported");
+    }
     this.order = order;
     this.parentFilter = parentFilter;
     this.childFilter = childFilter;
+    this.stringSelector = stringSelector;
+    this.numericSelector = numericSelector;
   }
-
+  
   @Override
   public FieldComparator<?> getComparator(int numHits, int sortPos) {
     switch (getType()) {
@@ -110,15 +121,12 @@ public class ToParentBlockJoinSortField extends SortField {
       @Override
       protected SortedDocValues getSortedDocValues(LeafReaderContext context, String field) throws IOException {
         SortedSetDocValues sortedSet = DocValues.getSortedSet(context.reader(), field);
-        final BlockJoinSelector.Type type = order
-            ? BlockJoinSelector.Type.MAX
-            : BlockJoinSelector.Type.MIN;
         final BitSet parents = parentFilter.getBitSet(context);
         final BitSet children = childFilter.getBitSet(context);
         if (children == null) {
           return DocValues.emptySorted();
         }
-        return BlockJoinSelector.wrap(sortedSet, type, parents, children);
+        return stringSelector.select(sortedSet, getTypeByReverse(order), parents, BlockJoinSelector.toIter(children));
       }
 
     };
@@ -129,15 +137,12 @@ public class ToParentBlockJoinSortField extends SortField {
       @Override
       protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {
         SortedNumericDocValues sortedNumeric = DocValues.getSortedNumeric(context.reader(), field);
-        final BlockJoinSelector.Type type = order
-            ? BlockJoinSelector.Type.MAX
-            : BlockJoinSelector.Type.MIN;
         final BitSet parents = parentFilter.getBitSet(context);
         final BitSet children = childFilter.getBitSet(context);
         if (children == null) {
           return DocValues.emptyNumeric();
         }
-        return BlockJoinSelector.wrap(sortedNumeric, type, parents, children);
+        return numericSelector.select(sortedNumeric, getTypeByReverse(order), parents, BlockJoinSelector.toIter(children));
       }
     };
   }
@@ -147,15 +152,12 @@ public class ToParentBlockJoinSortField extends SortField {
       @Override
       protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {
         SortedNumericDocValues sortedNumeric = DocValues.getSortedNumeric(context.reader(), field);
-        final BlockJoinSelector.Type type = order
-            ? BlockJoinSelector.Type.MAX
-            : BlockJoinSelector.Type.MIN;
         final BitSet parents = parentFilter.getBitSet(context);
         final BitSet children = childFilter.getBitSet(context);
         if (children == null) {
           return DocValues.emptyNumeric();
         }
-        return BlockJoinSelector.wrap(sortedNumeric, type, parents, children);
+        return numericSelector.select(sortedNumeric, getTypeByReverse(order), parents, BlockJoinSelector.toIter(children));
       }
     };
   }
@@ -165,15 +167,13 @@ public class ToParentBlockJoinSortField extends SortField {
       @Override
       protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {
         SortedNumericDocValues sortedNumeric = DocValues.getSortedNumeric(context.reader(), field);
-        final BlockJoinSelector.Type type = order
-            ? BlockJoinSelector.Type.MAX
-            : BlockJoinSelector.Type.MIN;
         final BitSet parents = parentFilter.getBitSet(context);
         final BitSet children = childFilter.getBitSet(context);
         if (children == null) {
           return DocValues.emptyNumeric();
         }
-        return new FilterNumericDocValues(BlockJoinSelector.wrap(sortedNumeric, type, parents, children)) {
+        return new FilterNumericDocValues(
+            numericSelector.select(sortedNumeric, getTypeByReverse(order), parents, BlockJoinSelector.toIter(children))) {
           @Override
           public long longValue() throws IOException {
             // undo the numericutils sortability
@@ -189,15 +189,13 @@ public class ToParentBlockJoinSortField extends SortField {
       @Override
       protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {
         SortedNumericDocValues sortedNumeric = DocValues.getSortedNumeric(context.reader(), field);
-        final BlockJoinSelector.Type type = order
-            ? BlockJoinSelector.Type.MAX
-            : BlockJoinSelector.Type.MIN;
         final BitSet parents = parentFilter.getBitSet(context);
         final BitSet children = childFilter.getBitSet(context);
         if (children == null) {
           return DocValues.emptyNumeric();
         }
-        return new FilterNumericDocValues(BlockJoinSelector.wrap(sortedNumeric, type, parents, children)) {
+        return new FilterNumericDocValues(
+            numericSelector.select(sortedNumeric, getTypeByReverse(order), parents, BlockJoinSelector.toIter(children))) {
           @Override
           public long longValue() throws IOException {
             // undo the numericutils sortability
@@ -215,6 +213,8 @@ public class ToParentBlockJoinSortField extends SortField {
     result = prime * result + ((childFilter == null) ? 0 : childFilter.hashCode());
     result = prime * result + (order ? 1231 : 1237);
     result = prime * result + ((parentFilter == null) ? 0 : parentFilter.hashCode());
+    result = prime * result + stringSelector.hashCode();
+    result = prime * result + numericSelector.hashCode();
     return result;
   }
 
@@ -231,6 +231,19 @@ public class ToParentBlockJoinSortField extends SortField {
     if (parentFilter == null) {
       if (other.parentFilter != null) return false;
     } else if (!parentFilter.equals(other.parentFilter)) return false;
+    if (numericSelector!=other.numericSelector) {
+      return false;
+    }
+    if (stringSelector!=other.stringSelector) {
+      return false;
+    }
     return true;
   }
+
+  static BlockJoinSelector.Type getTypeByReverse(final boolean order2) {
+    final BlockJoinSelector.Type type = order2
+        ? BlockJoinSelector.Type.MAX
+        : BlockJoinSelector.Type.MIN;
+    return type;
+  }
 }
diff --git a/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinSelector.java b/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinSelector.java
index 838826f..9966efc 100644
--- a/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinSelector.java
+++ b/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinSelector.java
@@ -32,6 +32,9 @@ import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.LuceneTestCase;
 
+import com.carrotsearch.randomizedtesting.annotations.Repeat;
+
+@Repeat(iterations=200)
 public class TestBlockJoinSelector extends LuceneTestCase {
 
   public void testDocsWithValue() {
@@ -72,7 +75,8 @@ public class TestBlockJoinSelector extends LuceneTestCase {
       assertEquals(NO_MORE_DOCS, sdv.nextDoc());
     } else {
       if (r.nextBoolean()) {
-        assertEquals(NO_MORE_DOCS,  sdv.advance(sdv.docID()+random().nextInt(maxDoc-sdv.docID())));
+        final int target = sdv.docID()+random().nextInt(maxDoc-sdv.docID());
+        assertEquals(NO_MORE_DOCS,  sdv.advance(Math.max(sdv.docID()+1, target)));
       } else {
         final int noMatchDoc = sdv.docID()+random().nextInt(maxDoc-sdv.docID()-1)+1;
         assertFalse(advanceExact(sdv,noMatchDoc));
@@ -89,12 +93,14 @@ public class TestBlockJoinSelector extends LuceneTestCase {
     if(r.nextBoolean()){
       return sdv.nextDoc();
     } else {
+      final int jump = docId-sdv.docID()-1;
+      final int randomJump = (jump==0?0:random().nextInt(jump));
       if (r.nextBoolean()) {
-        return sdv.advance(sdv.docID()+random().nextInt(docId-sdv.docID()-1)+1);
+        return sdv.advance(sdv.docID()+randomJump+1);
       } else {
-        if (r.nextBoolean()){
-          final int noMatchDoc = sdv.docID()+random().nextInt(docId-sdv.docID()-1)+1;
-          assertFalse(advanceExact(sdv,noMatchDoc));
+        final int noMatchDoc = sdv.docID()+randomJump+1;
+        if (r.nextBoolean() && noMatchDoc<docId){
+          assertEquals(false, advanceExact(sdv,noMatchDoc));
           assertEquals(noMatchDoc, sdv.docID());
         }
         assertTrue(advanceExact(sdv,docId));
@@ -147,6 +153,66 @@ public class TestBlockJoinSelector extends LuceneTestCase {
     assertNoMoreDoc( maxs,20);
   }
 
+  public void testToChildSortedSelector() throws IOException {
+    final BitSet parents = new FixedBitSet(20);
+    parents.set(0);
+    parents.set(5);
+    parents.set(6);
+    parents.set(10);
+    parents.set(15);
+    parents.set(19);
+
+    final BitSet children = new FixedBitSet(20);
+    children.set(2);
+    children.set(3);
+    children.set(4);
+    children.set(12);
+    children.set(17);
+
+    final int[] ords = new int[20];
+    Arrays.fill(ords, -1); 
+    ords[5] = 5;           
+    //ords[3] = 7;         
+    //ords[4] = 3;         
+    ords[15] = 10;         
+    ords[19] = 11;            
+
+    final SortedDocValues parentVals = BlockJoinSelector.stringToChild(
+        DocValues.singleton( new CannedSortedDocValues(ords)), 
+        random().nextBoolean()? BlockJoinSelector.Type.MIN:BlockJoinSelector.Type.MAX
+        ,parents, BlockJoinSelector.toIter(children));
+    //234 - > 5
+    {
+      int firstChild = 2;
+      if(random().nextBoolean()) {
+        firstChild=random().nextInt(5)/*0,1,2,3,4*/;
+        assertEquals(Math.max( firstChild,2),parentVals.advance(firstChild));
+      } else {
+        assertEquals(firstChild,parentVals.nextDoc());
+      }
+      
+      assertEquals(Math.max(firstChild,2),parentVals.docID());
+    }
+    assertEquals(5, parentVals.ordValue());
+    
+    {
+      for (int child=parentVals.docID()+1;child<5; child++){
+          assertEquals(child, nextDoc(parentVals,child));
+          assertEquals(child,parentVals.docID());
+          assertEquals(5, parentVals.ordValue());
+      }
+    }
+
+    assertEquals(12, nextDoc(parentVals,12));
+    assertEquals(10, parentVals.ordValue());
+    
+    assertEquals(17, nextDoc(parentVals,17));
+    assertEquals(11, parentVals.ordValue());
+    
+    assertNoMoreDoc(parentVals, 20);
+
+  }
+  
   private static class CannedSortedDocValues extends SortedDocValues {
     private final int[] ords;
     int docID = -1;
@@ -261,6 +327,68 @@ public class TestBlockJoinSelector extends LuceneTestCase {
     assertNoMoreDoc(maxs, 20);
   }
 
+  public void testToChildNumericSelector() throws Exception {
+    final BitSet parents = new FixedBitSet(20);
+    parents.set(0);
+    parents.set(5);
+    parents.set(6);
+    parents.set(10);
+    parents.set(15);
+    parents.set(19);
+
+    final BitSet children = new FixedBitSet(20);
+    children.set(2);
+    children.set(3);
+    children.set(4);
+    children.set(12);
+    children.set(17);
+
+    final long[] longs = new long[20];
+    final BitSet docsWithValue = new FixedBitSet(20);
+    docsWithValue.set(5);
+    longs[5] = 5;
+//    docsWithValue.set(3);
+//    longs[3] = 7;
+//    docsWithValue.set(4);
+//    longs[4] = 3;
+    docsWithValue.set(15);
+    longs[15] = 9;
+    docsWithValue.set(19);
+    longs[19] = 11;
+
+    final NumericDocValues toChildVals = BlockJoinSelector.numericToChild(
+        DocValues.singleton(new CannedNumericDocValues(longs, docsWithValue)),
+        random().nextBoolean()? BlockJoinSelector.Type.MIN:BlockJoinSelector.Type.MAX,
+            parents, BlockJoinSelector.toIter(children));
+  //234 - > 5
+    {
+      int firstChild = 2;
+      if(random().nextBoolean()) {
+        firstChild=random().nextInt(5)/*0,1,2,3,4*/;
+        assertEquals(Math.max(firstChild,2) ,toChildVals.advance(firstChild));
+      } else {
+        assertEquals(firstChild,toChildVals.nextDoc());
+      }
+      
+      assertEquals(Math.max(firstChild,2),toChildVals.docID());
+    }
+    assertEquals(5, toChildVals.longValue());
+    
+    {
+      for (int child=toChildVals.docID()+1;child<5; child++){
+          assertEquals(child, nextDoc(toChildVals,child));
+          assertEquals(child,toChildVals.docID());
+          assertEquals(5, toChildVals.longValue());
+      }
+    }
+    
+    assertEquals(12, nextDoc(toChildVals,12));
+    assertEquals(9, toChildVals.longValue());
+    assertEquals(17, nextDoc(toChildVals,17));
+    assertEquals(11, toChildVals.longValue());
+    assertNoMoreDoc(toChildVals, 20);
+  }
+
   private static class CannedNumericDocValues extends NumericDocValues {
     final Bits docsWithValue;
     final long[] values;
diff --git a/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinSorting.java b/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinSorting.java
index a570044..611d593 100644
--- a/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinSorting.java
+++ b/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinSorting.java
@@ -17,6 +17,8 @@
 package org.apache.lucene.search.join;
 
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Iterator;
 import java.util.List;
 import java.util.function.Supplier;
 
@@ -31,8 +33,10 @@ import org.apache.lucene.index.Term;
 import org.apache.lucene.search.FieldDoc;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.PrefixQuery;
+import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.Sort;
 import org.apache.lucene.search.SortField;
+import org.apache.lucene.search.TermInSetQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopFieldDocs;
 import org.apache.lucene.store.Directory;
@@ -71,7 +75,9 @@ public class TestBlockJoinSorting extends LuceneTestCase {
     document.add(new StringField("field1", "a", Field.Store.NO));
     docs.add(document);
     w.addDocuments(docs);
-    w.commit();
+    if(rarely()){
+      w.commit();
+    }
 
     docs.clear();
     document = new Document();
@@ -138,8 +144,9 @@ public class TestBlockJoinSorting extends LuceneTestCase {
     document.add(new StringField("field1", "d", Field.Store.NO));
     docs.add(document);
     w.addDocuments(docs);
-    w.commit();
-
+    if(rarely()){
+      w.commit();
+    }
     docs.clear();
     document = new Document();
     document.add(new StringField("field2", "i", Field.Store.NO));
@@ -206,7 +213,6 @@ public class TestBlockJoinSorting extends LuceneTestCase {
     docs.add(document);
     w.addDocuments(docs);
     w.commit();
-
     IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(w.w));
     w.close();
     BitSetProducer parentFilter = new QueryBitSetProducer(new TermQuery(new Term("__type", "parent")));
@@ -219,23 +225,16 @@ public class TestBlockJoinSorting extends LuceneTestCase {
     );
 
     // Sort by field ascending, order first
-    ToParentBlockJoinSortField sortField = new ToParentBlockJoinSortField(
+    SortField sortField = new ToParentBlockJoinSortField(
         "field2", SortField.Type.STRING, false, parentFilter, childFilter
     );
     Sort sort = new Sort(sortField);
     TopFieldDocs topDocs = searcher.search(query, 5, sort);
-    assertEquals(7, topDocs.totalHits);
-    assertEquals(5, topDocs.scoreDocs.length);
-    assertEquals(3, topDocs.scoreDocs[0].doc);
-    assertEquals("a", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[0]).fields[0]).utf8ToString());
-    assertEquals(7, topDocs.scoreDocs[1].doc);
-    assertEquals("c", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[1]).fields[0]).utf8ToString());
-    assertEquals(11, topDocs.scoreDocs[2].doc);
-    assertEquals("e", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[2]).fields[0]).utf8ToString());
-    assertEquals(15, topDocs.scoreDocs[3].doc);
-    assertEquals("g", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[3]).fields[0]).utf8ToString());
-    assertEquals(19, topDocs.scoreDocs[4].doc);
-    assertEquals("i", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[4]).fields[0]).utf8ToString());
+    total(7).andThen(3, "a")
+    .andThen(7, "c")
+    .andThen(11, "e")
+    .andThen(15, "g")
+    .andThen(19, "i").assertEq(topDocs);
 
     // Sort by field ascending, order last
     sortField = notEqual(sortField, () -> new ToParentBlockJoinSortField(
@@ -244,18 +243,11 @@ public class TestBlockJoinSorting extends LuceneTestCase {
 
     sort = new Sort(sortField);
     topDocs = searcher.search(query, 5, sort);
-    assertEquals(7, topDocs.totalHits);
-    assertEquals(5, topDocs.scoreDocs.length);
-    assertEquals(3, topDocs.scoreDocs[0].doc);
-    assertEquals("c", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[0]).fields[0]).utf8ToString());
-    assertEquals(7, topDocs.scoreDocs[1].doc);
-    assertEquals("e", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[1]).fields[0]).utf8ToString());
-    assertEquals(11, topDocs.scoreDocs[2].doc);
-    assertEquals("g", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[2]).fields[0]).utf8ToString());
-    assertEquals(15, topDocs.scoreDocs[3].doc);
-    assertEquals("i", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[3]).fields[0]).utf8ToString());
-    assertEquals(19, topDocs.scoreDocs[4].doc);
-    assertEquals("k", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[4]).fields[0]).utf8ToString());
+    total(7).andThen(3, "c")
+            .andThen(7, "e")
+            .andThen(11, "g")
+            .andThen(15, "i")
+            .andThen(19, "k").assertEq(topDocs);
 
     // Sort by field descending, order last
     sortField = notEqual(sortField, () -> new ToParentBlockJoinSortField(
@@ -263,18 +255,12 @@ public class TestBlockJoinSorting extends LuceneTestCase {
     ));
     sort = new Sort(sortField);
     topDocs = searcher.search(query, 5, sort);
-    assertEquals(topDocs.totalHits, 7);
-    assertEquals(5, topDocs.scoreDocs.length);
-    assertEquals(27, topDocs.scoreDocs[0].doc);
-    assertEquals("o", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[0]).fields[0]).utf8ToString());
-    assertEquals(23, topDocs.scoreDocs[1].doc);
-    assertEquals("m", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[1]).fields[0]).utf8ToString());
-    assertEquals(19, topDocs.scoreDocs[2].doc);
-    assertEquals("k", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[2]).fields[0]).utf8ToString());
-    assertEquals(15, topDocs.scoreDocs[3].doc);
-    assertEquals("i", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[3]).fields[0]).utf8ToString());
-    assertEquals(11, topDocs.scoreDocs[4].doc);
-    assertEquals("g", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[4]).fields[0]).utf8ToString());
+    total(7).andThen(27, "o").
+              andThen(23, "m")
+             .andThen(19, "k")
+             .andThen(15, "i")
+             .andThen(11, "g")
+    .assertEq(topDocs);
     
     // Sort by field descending, order last, sort filter (filter_1:T)
     BitSetProducer childFilter1T = new QueryBitSetProducer(new TermQuery((new Term("filter_1", "T"))));
@@ -290,35 +276,346 @@ public class TestBlockJoinSorting extends LuceneTestCase {
     
     sort = new Sort(sortField);
     topDocs = searcher.search(query, 5, sort);
-    assertEquals(6, topDocs.totalHits);
-    assertEquals(5, topDocs.scoreDocs.length);
-    assertEquals(23, topDocs.scoreDocs[0].doc);
-    assertEquals("m", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[0]).fields[0]).utf8ToString());
-    assertEquals(27, topDocs.scoreDocs[1].doc);
-    assertEquals("m", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[1]).fields[0]).utf8ToString());
-    assertEquals(11, topDocs.scoreDocs[2].doc);
-    assertEquals("g", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[2]).fields[0]).utf8ToString());
-    assertEquals(15, topDocs.scoreDocs[3].doc);
-    assertEquals("g", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[3]).fields[0]).utf8ToString());
-    assertEquals(7, topDocs.scoreDocs[4].doc);
-    assertEquals("e", ((BytesRef) ((FieldDoc) topDocs.scoreDocs[4]).fields[0]).utf8ToString());
+    total(6)
+        .andThen(23, "m")
+        .andThen(27, "m")
+        .andThen(11, "g")
+        .andThen(15, "g")
+        .andThen(7, "e").
+        assertEq(topDocs);
 
+    
+    final QueryBitSetProducer parentFilterAnother 
+          = new QueryBitSetProducer(new TermQuery(new Term("__type", "another")));
+    
     sortField = notEqual(sortField, () -> new ToParentBlockJoinSortField(
         "field2", SortField.Type.STRING, true, 
-              new QueryBitSetProducer(new TermQuery(new Term("__type", "another")))
+              parentFilterAnother
         , childFilter1T
     ));
-
+    // Child !=Parent
+    sortField = notEqual(sortField, () -> new ToChildBlockJoinSortField(
+        "field2", SortField.Type.STRING, true, 
+           parentFilterAnother
+        , childFilter1T
+    ));
+    // Parent != Child 
+    sortField = notEqual(sortField, () -> new ToParentBlockJoinSortField(
+        "field2", SortField.Type.STRING, true, 
+              parentFilterAnother
+        , childFilter1T
+    ));
+    
     searcher.getIndexReader().close();
     dir.close();
   }
  
-  private ToParentBlockJoinSortField notEqual(ToParentBlockJoinSortField old, Supplier<ToParentBlockJoinSortField> create) {
-    final ToParentBlockJoinSortField newObj = create.get();
+  
+  @Test
+  public void testToChildSorting() throws Exception {
+    final Directory dir = newDirectory();
+    final RandomIndexWriter w = new RandomIndexWriter(random(), dir, newIndexWriterConfig(new MockAnalyzer(random()))
+                                                      .setMergePolicy(newLogMergePolicy()));
+
+    List<Document> docs = new ArrayList<>();
+    Document document = new Document();
+    document.add(new StringField("field2", "a", Field.Store.NO));
+    document.add(new StringField("filter_1", "T", Field.Store.NO));
+    docs.add(document);
+    document = new Document();
+    document.add(new StringField("field2", "b", Field.Store.NO));
+    document.add(new StringField("filter_1", "T", Field.Store.NO));
+    docs.add(document);
+    document = new Document();
+    document.add(new StringField("field2", "c", Field.Store.NO));
+    document.add(new StringField("filter_1", "T", Field.Store.NO));
+    docs.add(document);
+    document = new Document();//3
+    document.add(new StringField("__type", "parent", Field.Store.NO));
+    document.add(new StringField("field1", "a", Field.Store.NO));
+    document.add(new SortedDocValuesField("field2", new BytesRef("a")));
+    docs.add(document);
+    w.addDocuments(docs);
+    if(rarely()){
+      w.commit();
+    }
+    docs.clear();
+    document = new Document();
+    document.add(new StringField("field2", "c", Field.Store.NO));
+    document.add(new StringField("filter_1", "T", Field.Store.NO));
+    docs.add(document);
+    document = new Document();
+    document.add(new StringField("field2", "d", Field.Store.NO));
+    document.add(new StringField("filter_1", "T", Field.Store.NO));
+    docs.add(document);
+    document = new Document();
+    document.add(new StringField("field2", "e", Field.Store.NO));
+    document.add(new StringField("filter_1", "T", Field.Store.NO));
+    docs.add(document);
+    document = new Document();//7
+    document.add(new StringField("__type", "parent", Field.Store.NO));
+    document.add(new StringField("field1", "b", Field.Store.NO));
+    document.add(new SortedDocValuesField("field2", new BytesRef("e")));
+    docs.add(document);
+    w.addDocuments(docs);
+    if(rarely()){
+      w.commit();
+    }
+    docs.clear();
+    document = new Document();
+    document.add(new StringField("field2", "e", Field.Store.NO));
+    document.add(new StringField("filter_1", "T", Field.Store.NO));
+    docs.add(document);
+    document = new Document();
+    document.add(new StringField("field2", "f", Field.Store.NO));
+    document.add(new StringField("filter_1", "T", Field.Store.NO));
+    docs.add(document);
+    document = new Document();
+    document.add(new StringField("field2", "g", Field.Store.NO));
+    document.add(new StringField("filter_1", "T", Field.Store.NO));
+    docs.add(document);
+    document = new Document();//11
+    document.add(new StringField("__type", "parent", Field.Store.NO));
+    document.add(new StringField("field1", "c", Field.Store.NO));
+    document.add(new SortedDocValuesField("field2", new BytesRef("f")));
+    docs.add(document);
+    w.addDocuments(docs);
+    if(rarely()){
+      w.commit();
+    }
+    docs.clear();
+    document = new Document();
+    document.add(new StringField("field2", "g", Field.Store.NO));
+    document.add(new StringField("filter_1", "T", Field.Store.NO));
+    docs.add(document);
+    document = new Document();
+    document.add(new StringField("field2", "h", Field.Store.NO));
+    document.add(new StringField("filter_1", "F", Field.Store.NO));
+    docs.add(document);
+    document = new Document();
+    document.add(new StringField("field2", "i", Field.Store.NO));
+    document.add(new StringField("filter_1", "F", Field.Store.NO));
+    docs.add(document);
+    document = new Document();//15
+    document.add(new StringField("__type", "parent", Field.Store.NO));
+    document.add(new SortedDocValuesField("field2", new BytesRef("h")));
+    document.add(new StringField("field1", "d", Field.Store.NO));
+    docs.add(document);
+    w.addDocuments(docs);
+    if(rarely()){
+      w.commit();
+    }
+    docs.clear();
+    document = new Document();
+    document.add(new StringField("field2", "i", Field.Store.NO));
+    document.add(new StringField("filter_1", "F", Field.Store.NO));
+    docs.add(document);
+    document = new Document();
+    document.add(new StringField("field2", "j", Field.Store.NO));
+    document.add(new StringField("filter_1", "F", Field.Store.NO));
+    docs.add(document);
+    document = new Document();
+    document.add(new StringField("field2", "k", Field.Store.NO));
+    document.add(new StringField("filter_1", "F", Field.Store.NO));
+    docs.add(document);
+    document = new Document();//19
+    document.add(new StringField("__type", "parent", Field.Store.NO));
+    document.add(new StringField("field1", "f", Field.Store.NO));
+    document.add(new SortedDocValuesField("field2", new BytesRef("i")));
+    docs.add(document);
+    w.addDocuments(docs);
+    if(rarely()){
+      w.commit();
+    }
+    docs.clear();
+    document = new Document();//20
+    document.add(new StringField("field2", "k", Field.Store.NO));
+    document.add(new StringField("filter_1", "T", Field.Store.NO));
+    docs.add(document);
+    document = new Document();//21
+    document.add(new StringField("field2", "l", Field.Store.NO));
+    document.add(new StringField("filter_1", "T", Field.Store.NO));
+    docs.add(document);
+    document = new Document();//22
+    document.add(new StringField("field2", "m", Field.Store.NO));
+    document.add(new StringField("filter_1", "T", Field.Store.NO));
+    docs.add(document);
+    document = new Document();//23
+    document.add(new StringField("__type", "parent", Field.Store.NO));
+    document.add(new StringField("field1", "g", Field.Store.NO));
+    document.add(new SortedDocValuesField("field2", new BytesRef("k")));
+    docs.add(document);
+    w.addDocuments(docs);
+    if(rarely()){
+      w.commit();
+    }
+    docs.clear();
+    document = new Document();
+    document.add(new StringField("field2", "m", Field.Store.NO));
+    document.add(new StringField("filter_1", "T", Field.Store.NO));
+    docs.add(document);
+    document = new Document();
+    document.add(new StringField("field2", "n", Field.Store.NO));
+    document.add(new StringField("filter_1", "F", Field.Store.NO));
+    docs.add(document);
+    document = new Document();
+    document.add(new StringField("field2", "o", Field.Store.NO));
+    document.add(new StringField("filter_1", "F", Field.Store.NO));
+    docs.add(document);
+    document = new Document();//27
+    document.add(new StringField("__type", "parent", Field.Store.NO));
+    document.add(new StringField("field1", "i", Field.Store.NO));
+    document.add(new SortedDocValuesField("field2", new BytesRef("m")));
+    docs.add(document);
+    w.addDocuments(docs);
+    w.commit();
+
+    IndexSearcher searcher = new IndexSearcher(DirectoryReader.open(w.w));
+    //w.close();
+    BitSetProducer parentFilter = new QueryBitSetProducer(new TermQuery(new Term("__type", "parent")));
+    CheckJoinIndex.check(searcher.getIndexReader(), parentFilter);
+    BitSetProducer childFilter = new QueryBitSetProducer(new PrefixQuery(new Term("field2")));
+    ToChildBlockJoinQuery query = new ToChildBlockJoinQuery(
+        new PrefixQuery(new Term("field1")),
+        parentFilter
+    );
+
+    // Sort by field ascending, order first
+    SortField sortField = new ToChildBlockJoinSortField(
+        "field2", SortField.Type.STRING, false, parentFilter, childFilter
+    );
+    final Expect aefh = total(21)
+            .andThen(0, "a").andThen(1, "a").andThen(2, "a")
+            .andThen(4, "e").andThen(5, "e").andThen(6, "e")
+            .andThen(8, "f").andThen(9, "f").andThen(10,"f")
+            .andThen(12, "h");
+    aefh.assertEq(searcher.search(query, 10, new Sort(sortField)));
+
+    // Sort by field ascending, order last
+    sortField = notEqual(sortField, () -> new ToChildBlockJoinSortField(
+        "field2", SortField.Type.STRING, false, true, parentFilter, childFilter
+    ));
+    // it will only impact multivalue parent field
+    aefh.assertEq(searcher.search(query, 10, new Sort(sortField)));
+    
+    // Sort by field descending, order last
+    sortField = notEqual(sortField, () -> new ToChildBlockJoinSortField(
+        "field2", SortField.Type.STRING, true, parentFilter, childFilter
+    ));
+    total(21).andThen(24, "m").andThen(25, "m").andThen(26, "m").
+              andThen(20, "k").andThen(21, "k").andThen(22, "k")
+             .andThen(16, "i").andThen(17, "i").andThen(18, "i")
+             .andThen(12, "h")
+    .assertEq(searcher.search(query, 10, new Sort(sortField)));
+    
+    
+    // Sort by field descending, order last, sort filter 
+    //BitSetProducer childFilter1T = new QueryBitSetProducer(new TermQuery((new Term("filter_1", "T"))));
+    {
+      ToChildBlockJoinQuery mifaParents = new ToChildBlockJoinQuery(
+          new TermInSetQuery("field1",new BytesRef("a") /*a*/,
+              new BytesRef("c")  /*f*/,new BytesRef("f")  /*i*/,
+              new BytesRef("i")  /*m*/),
+          parentFilter
+      );
+   
+      //sortField = notEqual(sortField, () -> new ToChildBlockJoinSortField(
+      //    "field2", SortField.Type.STRING, true, parentFilter, childFilter
+          //childFilter1T
+      //));
+      
+      total(12)
+          .andThen(24, "m").andThen(25, "m").andThen(26, "m")
+          .andThen(16, "i").andThen(17, "i").andThen(18, "i")
+          .andThen(8, "f").andThen(9, "f").andThen(10, "f")
+          .andThen(0, "a").
+          assertEq(searcher.search(mifaParents, 10, new Sort(sortField)));
+    }
+    {
+      QueryBitSetProducer parentFilterAnother = new QueryBitSetProducer(new TermQuery(new Term("__type", "another")));
+      sortField = notEqual(sortField, () -> new ToChildBlockJoinSortField(
+          "field2", SortField.Type.STRING, true, parentFilterAnother
+          , childFilter
+      )
+          //, childFilter1T
+      );
+      
+      sortField = notEqual(sortField, () -> new ToParentBlockJoinSortField(// just for fun if ToParent == ToChild
+          "field2", SortField.Type.STRING, true, 
+          parentFilterAnother, childFilter
+      ));
+    }
+    
+    // let's filter child in ToChildBJsortField
+    final TermQuery filter_1T = new TermQuery(new Term("filter_1", "T"));
+    sortField = notEqual(sortField, () -> {
+      return new ToChildBlockJoinSortField(
+          "field2", SortField.Type.STRING, true, parentFilter, 
+              new QueryBitSetProducer(filter_1T)
+      );
+    });
+    final Expect filteredChildren = total(21).andThen(24, "m").//.andThen(25, "m").andThen(26, "m").
+              andThen(20, "k").andThen(21, "k").andThen(22, "k")
+             //.andThen(16, "i").andThen(17, "i").andThen(18, "i")
+             .andThen(12, "h")
+             .andThen(8, "f").andThen(9, "f").andThen(10, "f")
+             .andThen(4, "e").andThen(5, "e");
+    filteredChildren//.andThen(6, "e")
+    .assertEq(searcher.search(query, 10, new Sort(sortField)));
+    // now remove docs which doesn't match filter_1T
+    searcher.getIndexReader().close();
+    w.close();
+    dir.close();
+  }
+  
+  static Expect total(final int t) {
+    return new Expect(){
+      List<Integer> docNums = new ArrayList<>();
+      List<String> fieldVals = new ArrayList<>();
+      @Override
+      public Expect andThen(int docNum, String val) {
+        docNums.add(docNum);
+        fieldVals.add(val);
+        return this;
+      }
+      @Override
+      public void assertEq(TopFieldDocs topDocs) {
+        assertEquals("total hits:"+Arrays.asList(topDocs.scoreDocs),t,topDocs.totalHits);
+        assertEquals(Arrays.toString(topDocs.scoreDocs)+" "+docNums,
+            topDocs.scoreDocs.length,docNums.size());
+        assertEquals(Arrays.toString(topDocs.scoreDocs)+" "+fieldVals,
+            topDocs.scoreDocs.length,fieldVals.size());
+        int i =0;
+        for (@SuppressWarnings("rawtypes")
+        Iterator nums = docNums.iterator(),
+            vals = fieldVals.iterator(); nums.hasNext()&&vals.hasNext(); i++) {
+          Integer num = (Integer) nums.next();
+          String val = (String) vals.next();
+          final ScoreDoc scoreDoc = topDocs.scoreDocs[i];
+          final Object[] fields = ((FieldDoc) scoreDoc).fields;
+          assertEquals(""+scoreDoc+" "+((BytesRef) fields[0]).utf8ToString(),
+              num, Integer.valueOf(scoreDoc.doc));
+          assertEquals(""+Arrays.asList(fields), val,((BytesRef) fields[0]).utf8ToString());
+          assertEquals( nums.hasNext(),vals.hasNext());
+        }
+        
+      }
+      
+    };
+  }
+  
+  interface Expect {
+    Expect andThen(int docNum, String val);
+    void assertEq(TopFieldDocs topDocs);
+  };
+  
+  
+  private SortField notEqual(SortField old, Supplier<SortField> create) {
+    final SortField newObj = create.get();
     assertFalse(old.equals(newObj));
     assertNotSame( old, newObj);
     
-    final ToParentBlockJoinSortField bro = create.get();
+    final SortField bro = create.get();
     assertEquals(newObj, bro);
     assertEquals(newObj.hashCode(), bro.hashCode());
     assertNotSame( bro, newObj);
