Index: src/test/org/apache/lucene/util/TestOpenBitSet.java
===================================================================
--- src/test/org/apache/lucene/util/TestOpenBitSet.java	(wersja 899922)
+++ src/test/org/apache/lucene/util/TestOpenBitSet.java	(kopia robocza)
@@ -230,7 +230,16 @@
     }
   }
 
-  
+  public void testHashCodeEquals()
+  {
+    OpenBitSet bs1 = new OpenBitSet(200);
+    OpenBitSet bs2 = new OpenBitSet(64);
+    bs1.set(3);
+    bs2.set(3);
+    
+    assertEquals(bs1, bs2);
+    assertEquals(bs1.hashCode(), bs2.hashCode());
+  }
 }
 
 
Index: src/java/org/apache/lucene/util/OpenBitSet.java
===================================================================
--- src/java/org/apache/lucene/util/OpenBitSet.java	(wersja 899922)
+++ src/java/org/apache/lucene/util/OpenBitSet.java	(kopia robocza)
@@ -778,19 +778,20 @@
   public boolean equals(Object o) {
     if (this == o) return true;
     if (!(o instanceof OpenBitSet)) return false;
-    OpenBitSet a;
+    OpenBitSet a = this;
     OpenBitSet b = (OpenBitSet)o;
+    
+    // Make sure wlen is set to max. non-zero element.
+    a.trimTrailingZeros();
+    b.trimTrailingZeros();
+
     // make a the larger set.
     if (b.wlen > this.wlen) {
       a = b; b=this;
-    } else {
-      a=this;
     }
 
-    // check for any set bits out of the range of b
-    for (int i=a.wlen-1; i>=b.wlen; i--) {
-      if (a.bits[i]!=0) return false;
-    }
+    // Must hold true -- if not equal, there is at least one non-empty bit.
+    if (a.wlen != b.wlen) return false;
 
     for (int i=b.wlen-1; i>=0; i--) {
       if (a.bits[i] != b.bits[i]) return false;
@@ -802,8 +803,10 @@
 
   @Override
   public int hashCode() {
+      trimTrailingZeros();
+
       long h = 0x98761234;  // something non-zero for length==0
-      for (int i = bits.length; --i>=0;) {
+      for (int i = wlen - 1; i >= 0; i--) {
       h ^= bits[i];
       h = (h << 1) | (h >>> 63); // rotate left
     }
