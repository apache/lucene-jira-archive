From b899cb4b68e0fb85c2268e92b97620539b673186 Mon Sep 17 00:00:00 2001
From: Michael Gibney <michael@michaelgibney.net>
Date: Wed, 12 Jul 2017 08:31:05 -0400
Subject: [PATCH] patch fixing NearSpans and SpanOrQuery for graphs

---
 .../lucene/search/spans/NearSpansOrdered.java      | 21 ++++++---
 .../apache/lucene/search/spans/SpanOrQuery.java    | 54 ++++++++++++++++++++++
 2 files changed, 69 insertions(+), 6 deletions(-)

diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
index f4054738d2..27846e6db4 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
@@ -103,13 +103,19 @@ public class NearSpansOrdered extends ConjunctionSpans {
     assert prevSpans.startPosition() != NO_MORE_POSITIONS : "prevSpans no start position "+prevSpans;
     assert prevSpans.endPosition() != NO_MORE_POSITIONS;
     matchWidth = 0;
+    boolean repeatSubsequent = false;
     for (int i = 1; i < subSpans.length; i++) {
       Spans spans = subSpans[i];
       assert spans.startPosition() != NO_MORE_POSITIONS;
       assert spans.endPosition() != NO_MORE_POSITIONS;
-      if (advancePosition(spans, prevSpans.endPosition()) == NO_MORE_POSITIONS) {
-        oneExhaustedInCurrentDoc = true;
-        return false;
+      if (!repeatSubsequent) {
+        int advancePosition = advancePosition(spans, prevSpans.endPosition());
+        if (advancePosition < 0) {
+          repeatSubsequent = true;
+        } else if (advancePosition == NO_MORE_POSITIONS) {
+          oneExhaustedInCurrentDoc = true;
+          return false;
+        }
       }
       matchWidth += (spans.startPosition() - prevSpans.endPosition());
       prevSpans = spans;
@@ -122,10 +128,13 @@ public class NearSpansOrdered extends ConjunctionSpans {
     if (spans instanceof SpanNearQuery.GapSpans) {
       return ((SpanNearQuery.GapSpans)spans).skipToPosition(position);
     }
-    while (spans.startPosition() < position) {
-      spans.nextStartPosition();
+    if (spans.startPosition() <= position) {
+      do {
+        spans.nextStartPosition();
+      } while (spans.startPosition() < position);
     }
-    return spans.startPosition();
+    int ret = spans.startPosition();
+    return ret == position ? ~ret : ret;
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
index 15abc7ddb2..8be88c43c3 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
@@ -18,6 +18,7 @@ package org.apache.lucene.search.spans;
 
 
 import java.io.IOException;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -313,13 +314,66 @@ public final class SpanOrQuery extends SpanQuery {
           assert byPositionQueue.size() > 0;
         }
 
+        private ArrayDeque<Spans> preserve = null;
+
+        private Spans popTop(SpanPositionQueue queue) {
+          queue.pop();
+          return queue.top();
+        }
+
+        private boolean restore(Spans nextSpan) throws IOException {
+          byPositionQueue.updateTop(nextSpan);
+          return restore();
+        }
+
+        private boolean restore() throws IOException {
+          int size = preserve.size();
+          Spans restore = null;
+          for (int i = 1; i < size; i++) {
+            restore = preserve.removeLast();
+            byPositionQueue.updateTop(restore);
+          }
+          restore = preserve.removeLast();
+          restore.nextStartPosition();
+          topPositionSpans = byPositionQueue.updateTop(restore);
+          return false;
+        }
+
         @Override
         public int nextStartPosition() throws IOException {
           if (topPositionSpans == null) {
             byPositionQueue.clear();
             fillPositionQueue(); // fills byPositionQueue at first position
             topPositionSpans = byPositionQueue.top();
+          } else if (byPositionQueue.size() > 1) {
+            Spans from = byPositionQueue.pop();
+            Spans nextSpan = byPositionQueue.top();
+            int topStart = topPositionSpans.startPosition();
+            if (nextSpan.startPosition() > topStart) {
+              topPositionSpans.nextStartPosition();
+              topPositionSpans = byPositionQueue.updateTop(topPositionSpans);
+            } else {
+              int topEnd = topPositionSpans.endPosition();
+              if (preserve != null) {
+                preserve.clear();
+              } else {
+                preserve = new ArrayDeque<>(byPositionQueue.size());
+              }
+              preserve.add(topPositionSpans);
+              topPositionSpans = null;
+              do {
+                if (nextSpan.endPosition() > topEnd) {
+                  topPositionSpans = nextSpan;
+                } else {
+                  preserve.add(nextSpan);
+                }
+              } while (topPositionSpans == null && (byPositionQueue.size() <= 1
+                  ? restore() : ((nextSpan = popTop(byPositionQueue)).startPosition() <= topStart) || restore(nextSpan)));
+            }
           } else {
+            if (preserve != null && !preserve.isEmpty()) {
+              restore();
+            }
             topPositionSpans.nextStartPosition();
             topPositionSpans = byPositionQueue.updateTop();
           }
-- 
2.13.0

