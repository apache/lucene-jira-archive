Index: lucene/src/test/org/apache/lucene/store/TestMultiMMap.java
===================================================================
--- lucene/src/test/org/apache/lucene/store/TestMultiMMap.java	(revision 0)
+++ lucene/src/test/org/apache/lucene/store/TestMultiMMap.java	(revision 0)
@@ -0,0 +1,83 @@
+package org.apache.lucene.store;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.File;
+import java.util.Random;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util._TestUtil;
+
+/**
+ * Tests MMapDirectory's MultiMMapIndexInput
+ * <p>
+ * Because Java's ByteBuffer uses an int to address the
+ * values, it's necessary to access a file >
+ * Integer.MAX_VALUE in size using multiple byte buffers.
+ */
+public class TestMultiMMap extends LuceneTestCase {
+  File workDir;
+  
+  @Override
+  protected void setUp() throws Exception {
+      super.setUp();
+      workDir = new File(TEMP_DIR, "TestMultiMMap");
+      workDir.mkdirs();
+  }
+  
+  public void testRandomChunkSizes() throws Exception {
+    Random random = newRandom(); // seed for -Dtests.codec=Standard
+    for (int i = 0; i < 10*RANDOM_MULTIPLIER; i++)
+      assertChunking(random, _TestUtil.nextInt(random, 1, 1000*RANDOM_MULTIPLIER));
+  }
+  
+  private void assertChunking(Random random, int chunkSize) throws Exception {
+    File path = File.createTempFile("mmap" + chunkSize, "tmp", workDir);
+    path.delete();
+    path.mkdirs();
+    MMapDirectory dir = new MMapDirectory(path);
+    dir.setMaxChunkSize(chunkSize);
+    RandomIndexWriter writer = new RandomIndexWriter(random, dir);
+    Document doc = new Document();
+    Field docid = new Field("docid", "0", Field.Store.YES, Field.Index.NOT_ANALYZED);
+    Field junk = new Field("junk", "", Field.Store.YES, Field.Index.NOT_ANALYZED);
+    doc.add(docid);
+    doc.add(junk);
+    
+    int numDocs = 1000*RANDOM_MULTIPLIER;
+    for (int i = 0; i < numDocs; i++) {
+      docid.setValue("" + i);
+      junk.setValue(_TestUtil.randomUnicodeString(random));
+      writer.addDocument(doc);
+    }
+    writer.close();
+    
+    IndexReader reader = IndexReader.open(dir, true);
+    int numAsserts = 100*RANDOM_MULTIPLIER;
+    for (int i = 0; i < numAsserts; i++) {
+      int docID = random.nextInt(numDocs);
+      assertEquals("" + docID, reader.document(docID).get("docid"));
+    }
+    reader.close();
+    dir.close();
+  }
+}

Property changes on: lucene\src\test\org\apache\lucene\store\TestMultiMMap.java
___________________________________________________________________
Added: svn:eol-style
   + native

Index: lucene/src/java/org/apache/lucene/store/MMapDirectory.java
===================================================================
--- lucene/src/java/org/apache/lucene/store/MMapDirectory.java	(revision 990204)
+++ lucene/src/java/org/apache/lucene/store/MMapDirectory.java	(working copy)
@@ -309,7 +309,7 @@
            + raf.toString());
       
       int nrBuffers = (int) (length / maxBufSize);
-      if (((long) nrBuffers * maxBufSize) < length) nrBuffers++;
+      if (((long) nrBuffers * maxBufSize) <= length) nrBuffers++;
       
       this.buffers = new ByteBuffer[nrBuffers];
       this.bufSizes = new int[nrBuffers];
