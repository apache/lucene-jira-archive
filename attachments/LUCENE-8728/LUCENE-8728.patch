diff --git a/lucene/grouping/src/java/org/apache/lucene/search/grouping/CollectedSearchGroup.java b/lucene/grouping/src/java/org/apache/lucene/search/grouping/CollectedSearchGroup.java
index 5e4bf14cecf..ffa1dade9ff 100644
--- a/lucene/grouping/src/java/org/apache/lucene/search/grouping/CollectedSearchGroup.java
+++ b/lucene/grouping/src/java/org/apache/lucene/search/grouping/CollectedSearchGroup.java
@@ -23,6 +23,6 @@ import org.apache.lucene.search.FieldComparator; // javadocs
  * tracking the top doc and {@link FieldComparator} slot.
  * @lucene.internal */
 public class CollectedSearchGroup<T> extends SearchGroup<T> {
-  int topDoc;
-  int comparatorSlot;
+  public int topDoc;
+  public int comparatorSlot;
 }
diff --git a/lucene/grouping/src/java/org/apache/lucene/search/grouping/FirstPassGroupingCollector.java b/lucene/grouping/src/java/org/apache/lucene/search/grouping/FirstPassGroupingCollector.java
index 6a745b8e735..0f0b06f353a 100644
--- a/lucene/grouping/src/java/org/apache/lucene/search/grouping/FirstPassGroupingCollector.java
+++ b/lucene/grouping/src/java/org/apache/lucene/search/grouping/FirstPassGroupingCollector.java
@@ -137,18 +137,30 @@ public class FirstPassGroupingCollector<T> extends SimpleCollector {
         continue;
       }
       // System.out.println("  group=" + (group.groupValue == null ? "null" : group.groupValue.toString()));
-      SearchGroup<T> searchGroup = new SearchGroup<>();
-      searchGroup.groupValue = group.groupValue;
-      searchGroup.sortValues = new Object[sortFieldCount];
-      for(int sortFieldIDX=0;sortFieldIDX<sortFieldCount;sortFieldIDX++) {
-        searchGroup.sortValues[sortFieldIDX] = comparators[sortFieldIDX].value(group.comparatorSlot);
-      }
+      SearchGroup<T> searchGroup = newSearchGroupFromCollectedSearchGroup(group, comparators, sortFieldCount);
       result.add(searchGroup);
     }
     //System.out.println("  return " + result.size() + " groups");
     return result;
   }
 
+  protected SearchGroup<T> newSearchGroup() {
+    return new SearchGroup<>();
+  }
+
+  protected SearchGroup<T> newSearchGroupFromCollectedSearchGroup(
+      CollectedSearchGroup<T> group,
+      FieldComparator<?>[] comparators,
+      int sortFieldCount) {
+    SearchGroup<T> searchGroup = newSearchGroup();
+    searchGroup.groupValue = group.groupValue;
+    searchGroup.sortValues = new Object[sortFieldCount];
+    for(int sortFieldIDX=0;sortFieldIDX<sortFieldCount;sortFieldIDX++) {
+      searchGroup.sortValues[sortFieldIDX] = comparators[sortFieldIDX].value(group.comparatorSlot);
+    }
+    return searchGroup;
+  }
+
   @Override
   public void setScorer(Scorable scorer) throws IOException {
     for (LeafFieldComparator comparator : leafComparators) {
diff --git a/lucene/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.java b/lucene/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.java
index 58e1f74350a..50dcb9fda7b 100644
--- a/lucene/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.java
+++ b/lucene/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.java
@@ -76,7 +76,12 @@ public class SearchGroup<T> {
     return groupValue != null ? groupValue.hashCode() : 0;
   }
 
-  private static class ShardIter<T> {
+  /**
+   * Iterator for all the groups on a shard
+   *
+   * @lucene.experimental
+   */
+  protected static class ShardIter<T> {
     public final Iterator<SearchGroup<T>> iter;
     public final int shardIndex;
 
@@ -101,8 +106,16 @@ public class SearchGroup<T> {
     }
   }
 
-  // Holds all shards currently on the same group
-  private static class MergedGroup<T> {
+  protected MergedGroup<T> newMergedGroup() {
+    return new MergedGroup<>(this.groupValue);
+  }
+
+  /**
+   * Holds all shards currently on the same group
+   *
+   * @lucene.experimental
+   */
+  protected static class MergedGroup<T> {
 
     // groupValue may be null!
     public final T groupValue;
@@ -117,6 +130,25 @@ public class SearchGroup<T> {
       this.groupValue = groupValue;
     }
 
+    private SearchGroup<T> toSearchGroup() {
+      final SearchGroup<T> searchGroup = newSearchGroup();
+      fillSearchGroup(searchGroup);
+      return searchGroup;
+    }
+
+    protected SearchGroup<T> newSearchGroup() {
+      return new SearchGroup<T>();
+    }
+
+    protected void fillSearchGroup(SearchGroup<T> searchGroup) {
+      searchGroup.groupValue = this.groupValue;
+      searchGroup.sortValues = this.topValues;
+    }
+
+    protected void update(SearchGroup<T> group) {
+      this.topValues = group.sortValues;
+    }
+
     // Only for assert
     private boolean neverEquals(Object _other) {
       if (_other instanceof MergedGroup) {
@@ -224,7 +256,7 @@ public class SearchGroup<T> {
         if (isNew) {
           // Start a new group:
           //System.out.println("      new");
-          mergedGroup = new MergedGroup<>(group.groupValue);
+          mergedGroup = group.newMergedGroup();
           mergedGroup.minShardIndex = shard.shardIndex;
           assert group.sortValues != null;
           mergedGroup.topValues = group.sortValues;
@@ -262,7 +294,7 @@ public class SearchGroup<T> {
             if (mergedGroup.inQueue) {
               queue.remove(mergedGroup);
             }
-            mergedGroup.topValues = group.sortValues;
+            mergedGroup.update(group);
             mergedGroup.minShardIndex = shard.shardIndex;
             queue.add(mergedGroup);
             mergedGroup.inQueue = true;
@@ -305,9 +337,7 @@ public class SearchGroup<T> {
         group.processed = true;
         //System.out.println("  pop: shards=" + group.shards + " group=" + (group.groupValue == null ? "null" : (((BytesRef) group.groupValue).utf8ToString())) + " sortValues=" + Arrays.toString(group.topValues));
         if (count++ >= offset) {
-          final SearchGroup<T> newGroup = new SearchGroup<>();
-          newGroup.groupValue = group.groupValue;
-          newGroup.sortValues = group.topValues;
+          final SearchGroup<T> newGroup = group.toSearchGroup();
           newTopGroups.add(newGroup);
           if (newTopGroups.size() == topN) {
             break;
