Index: lucene/core/src/java/org/apache/lucene/codecs/lucene42/Lucene42DocValuesProducer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/lucene42/Lucene42DocValuesProducer.java	(revision 1587910)
+++ lucene/core/src/java/org/apache/lucene/codecs/lucene42/Lucene42DocValuesProducer.java	(working copy)
@@ -148,6 +148,11 @@
   private void readFields(IndexInput meta, FieldInfos infos) throws IOException {
     int fieldNumber = meta.readVInt();
     while (fieldNumber != -1) {
+      if (infos.fieldInfo(fieldNumber) == null) {
+        // trickier to validate more: because we re-use for norms, because we use multiple entries
+        // for "composite" types like sortedset, etc.
+        throw new CorruptIndexException("Invalid field number: " + fieldNumber + ", input=" + meta);
+      }
       int fieldType = meta.readByte();
       if (fieldType == NUMBER) {
         NumericEntry entry = new NumericEntry();
Index: lucene/core/src/java/org/apache/lucene/codecs/lucene45/Lucene45DocValuesProducer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/lucene45/Lucene45DocValuesProducer.java	(revision 1587910)
+++ lucene/core/src/java/org/apache/lucene/codecs/lucene45/Lucene45DocValuesProducer.java	(working copy)
@@ -185,6 +185,11 @@
   private void readFields(IndexInput meta, FieldInfos infos) throws IOException {
     int fieldNumber = meta.readVInt();
     while (fieldNumber != -1) {
+      if (infos.fieldInfo(fieldNumber) == null) {
+        // trickier to validate more: because we re-use for norms, because we use multiple entries
+        // for "composite" types like sortedset, etc.
+        throw new CorruptIndexException("Invalid field number: " + fieldNumber + " (resource=" + meta + ")");
+      }
       byte type = meta.readByte();
       if (type == Lucene45DocValuesFormat.NUMERIC) {
         numerics.put(fieldNumber, readNumericEntry(meta));
Index: lucene/core/src/java/org/apache/lucene/index/FieldInfos.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/FieldInfos.java	(revision 1587910)
+++ lucene/core/src/java/org/apache/lucene/index/FieldInfos.java	(working copy)
@@ -58,6 +58,9 @@
     boolean hasDocValues = false;
     
     for (FieldInfo info : infos) {
+      if (info.number < 0) {
+        throw new IllegalArgumentException("illegal field number: " + info.number + " for field " + info.name);
+      }
       FieldInfo previous = byNumber.put(info.number, info);
       if (previous != null) {
         throw new IllegalArgumentException("duplicate field numbers: " + previous.name + " and " + info.name + " have: " + info.number);
@@ -148,15 +151,16 @@
 
   /**
    * Return the fieldinfo object referenced by the fieldNumber.
-   * @param fieldNumber field's number. if this is negative, this method
-   *        always returns null.
+   * @param fieldNumber field's number.
    * @return the FieldInfo object or null when the given fieldNumber
    * doesn't exist.
-   */  
-  // TODO: fix this negative behavior, this was something related to Lucene3x?
-  // if the field name is empty, i think it writes the fieldNumber as -1
+   * @throws IllegalArgumentException if fieldNumber is negative
+   */
   public FieldInfo fieldInfo(int fieldNumber) {
-    return (fieldNumber >= 0) ? byNumber.get(fieldNumber) : null;
+    if (fieldNumber < 0) {
+      throw new IllegalArgumentException("Illegal field number: " + fieldNumber);
+    }
+    return byNumber.get(fieldNumber);
   }
   
   static final class FieldNumbers {
