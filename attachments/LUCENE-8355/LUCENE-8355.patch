diff --git a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
index 037ff7230b..c4c9e61f4f 100644
--- a/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
@@ -607,6 +607,12 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable,
               // Only acquire IW lock on each write, since this is a time consuming operation.  This way
               // other threads get a chance to run in between our writes.
               synchronized (this) {
+                // It's possible that the segment of a reader returned by readerPool#getReadersByRam
+                // is dropped before being processed here. If it happens, we need to skip that reader.
+                if (readerPool.get(rld.info, false) == null) {
+                  assert segmentInfos.contains(rld.info) == false : "Segment [" + rld.info + "] is not dropped yet";
+                  continue;
+                }
                 if (rld.writeFieldUpdates(directory, globalFieldNumberMap, bufferedUpdatesStream.getCompletedDelGen(), infoStream)) {
                   checkpointNoSIS();
                 }
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads.java b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads.java
index 6e9645b71e..596df101b1 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads.java
@@ -658,10 +658,18 @@ public class TestIndexWriterWithThreads extends LuceneTestCase {
     d.close();
   }
 
-  public void testUpdateSingleDocWithThreads() throws IOException, BrokenBarrierException, InterruptedException {
+  public void testUpdateSingleDocWithThreads() throws Exception {
+    stressUpdateSingleDocWithThreads(false, rarely());
+  }
+
+  public void testSoftUpdateSingleDocWithThreads() throws Exception {
+    stressUpdateSingleDocWithThreads(true, rarely());
+  }
+
+  public void stressUpdateSingleDocWithThreads(boolean useSoftDeletes, boolean forceMerge) throws Exception{
     try (Directory dir = newDirectory();
          RandomIndexWriter writer = new RandomIndexWriter(random(), dir,
-             newIndexWriterConfig().setMaxBufferedDocs(-1).setRAMBufferSizeMB(0.00001))) {
+             newIndexWriterConfig().setMaxBufferedDocs(-1).setRAMBufferSizeMB(0.00001), useSoftDeletes)) {
       Thread[] threads = new Thread[3 + random().nextInt(3)];
       AtomicInteger done = new AtomicInteger(0);
       CyclicBarrier barrier = new CyclicBarrier(threads.length + 1);
@@ -691,6 +699,9 @@ public class TestIndexWriterWithThreads extends LuceneTestCase {
       barrier.await();
       try {
         do {
+          if (forceMerge && random().nextBoolean()) {
+            writer.forceMerge(1);
+          }
           DirectoryReader newReader = DirectoryReader.openIfChanged(open);
           if (newReader != null) {
             open.close();
