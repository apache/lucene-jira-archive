Index: lucene/src/java/org/apache/lucene/document2/Document.java
===================================================================
--- lucene/src/java/org/apache/lucene/document2/Document.java	(revision 1145347)
+++ lucene/src/java/org/apache/lucene/document2/Document.java	(working copy)
@@ -158,7 +158,31 @@
     }
     return null;
   }
+
+  public final IndexableField getField(String name) {
+    for (IndexableField field : fields) {
+      if (field.name().equals(name))
+        return field;
+    }
+    return null;
+  }
+
+  private final static IndexableField[] NO_FIELDS = new IndexableField[0];
   
+  public IndexableField[] getFields(String name) {
+    List<IndexableField> result = new ArrayList<IndexableField>();
+    for (IndexableField field : fields) {
+      if (field.name().equals(name)) {
+        result.add(field);
+      }
+    }
+
+    if (result.size() == 0)
+      return NO_FIELDS;
+
+    return result.toArray(new IndexableField[result.size()]);
+  }
+  
   public Integer size() {
     return fields.size();
   }
Index: lucene/src/java/org/apache/lucene/document2/StringField.java
===================================================================
--- lucene/src/java/org/apache/lucene/document2/StringField.java	(revision 1145347)
+++ lucene/src/java/org/apache/lucene/document2/StringField.java	(working copy)
@@ -42,6 +42,7 @@
     this(name, true, value);
   }
   
+  @Override
   public String stringValue() {
     return (fieldsData == null) ? null : fieldsData.toString();
   }
Index: solr/src/java/org/apache/solr/schema/BCDIntField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/BCDIntField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/BCDIntField.java	(working copy)
@@ -21,6 +21,7 @@
 import org.apache.solr.search.QParser;
 import org.apache.solr.search.function.ValueSource;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.solr.util.BCDUtils;
 import org.apache.solr.response.TextResponseWriter;
 
@@ -51,12 +52,21 @@
   }
 
   @Override
+  public String toExternal(IndexableField f) {
+    return indexedToReadable(f.stringValue());
+  }
+  
+  @Override
   public String toExternal(Fieldable f) {
     return indexedToReadable(f.stringValue());
   }
   
   // Note, this can't return type 'Integer' because BCDStrField and BCDLong extend it
   @Override
+  public Object toObject(IndexableField f) {
+    return Integer.valueOf( toExternal(f) );
+  }
+  @Override
   public Object toObject(Fieldable f) {
     return Integer.valueOf( toExternal(f) );
   }
Index: solr/src/java/org/apache/solr/schema/BCDLongField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/BCDLongField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/BCDLongField.java	(working copy)
@@ -18,11 +18,16 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 /**
  *
  */
 public class BCDLongField extends BCDIntField {
   @Override
+  public Long toObject(IndexableField f) {
+    return Long.valueOf( toExternal(f) );
+  }
+  @Override
   public Long toObject(Fieldable f) {
     return Long.valueOf( toExternal(f) );
   }
Index: solr/src/java/org/apache/solr/schema/BCDStrField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/BCDStrField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/BCDStrField.java	(working copy)
@@ -18,6 +18,7 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 /**
  *
  */
@@ -27,6 +28,10 @@
    * is not an integer, it will not survive the base10k conversion!
    */
   @Override
+  public String toObject(IndexableField f) {
+    return toExternal(f);
+  }
+  @Override
   public String toObject(Fieldable f) {
     return toExternal(f);
   }
Index: solr/src/java/org/apache/solr/schema/BinaryField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/BinaryField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/BinaryField.java	(working copy)
@@ -20,8 +20,9 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 
-import org.apache.lucene.document.Field;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.document2.Field;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.util.BytesRef;
 import org.apache.solr.common.util.Base64;
@@ -46,9 +47,19 @@
 
 
   @Override
+  public String toExternal(IndexableField f) {
+    return toBase64String(toObject(f));
+  }
+  @Override
   public String toExternal(Fieldable f) {
     return toBase64String(toObject(f));
   }
+
+  @Override
+  public ByteBuffer toObject(IndexableField f) {
+    BytesRef bytes = f.binaryValue(null);
+    return  ByteBuffer.wrap(bytes.bytes, bytes.offset, bytes.length);
+  }
   
   @Override
   public ByteBuffer toObject(Fieldable f) {
@@ -57,7 +68,7 @@
   }
 
   @Override
-  public Fieldable createField(SchemaField field, Object val, float boost) {
+  public IndexableField createField(SchemaField field, Object val, float boost) {
     if (val == null) return null;
     if (!field.stored()) {
       log.trace("Ignoring unstored binary field: " + field);
@@ -81,7 +92,7 @@
       len = buf.length;
     }
 
-    Field f = new Field(field.getName(), buf, offset, len);
+    Field f = new org.apache.lucene.document2.BinaryField(field.getName(), buf, offset, len);
     f.setBoost(boost);
     return f;
   }
Index: solr/src/java/org/apache/solr/schema/BoolField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/BoolField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/BoolField.java	(working copy)
@@ -18,6 +18,7 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.FieldCache;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.util.BytesRef;
@@ -114,11 +115,19 @@
   }
 
   @Override
+  public String toExternal(IndexableField f) {
+    return indexedToReadable(f.stringValue());
+  }
+  @Override
   public String toExternal(Fieldable f) {
     return indexedToReadable(f.stringValue());
   }
 
   @Override
+  public Boolean toObject(IndexableField f) {
+    return Boolean.valueOf( toExternal(f) );
+  }
+  @Override
   public Boolean toObject(Fieldable f) {
     return Boolean.valueOf( toExternal(f) );
   }
Index: solr/src/java/org/apache/solr/schema/CollationField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/CollationField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/CollationField.java	(working copy)
@@ -32,6 +32,7 @@
 import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.collation.CollationKeyAnalyzer;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TermRangeQuery;
Index: solr/src/java/org/apache/solr/schema/DateField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/DateField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/DateField.java	(working copy)
@@ -19,6 +19,7 @@
 
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TermRangeQuery;
@@ -182,7 +183,7 @@
     }
   }
 
-  public Fieldable createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value, float boost) {
     // Convert to a string before indexing
     if(value instanceof Date) {
       value = toInternal( (Date)value ) + Z;
@@ -207,6 +208,10 @@
   }
 
   @Override
+  public String toExternal(IndexableField f) {
+    return indexedToReadable(f.stringValue());
+  }
+  @Override
   public String toExternal(Fieldable f) {
     return indexedToReadable(f.stringValue());
   }
@@ -224,6 +229,15 @@
       throw new RuntimeException( ex );
     }
   }
+  @Override
+  public Date toObject(IndexableField f) {
+    try {
+      return parseDate( toExternal(f) );
+    }
+    catch( ParseException ex ) {
+      throw new RuntimeException( ex );
+    }
+  }
 
   @Override
   public SortField getSortField(SchemaField field,boolean reverse) {
Index: solr/src/java/org/apache/solr/schema/DoubleField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/DoubleField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/DoubleField.java	(working copy)
@@ -18,6 +18,7 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.cache.CachedArrayCreator;
 import org.apache.lucene.search.cache.DoubleValuesCreator;
@@ -78,6 +79,10 @@
 
 
   @Override
+  public Double toObject(IndexableField f) {
+    return Double.valueOf(toExternal(f));
+  }
+  @Override
   public Double toObject(Fieldable f) {
     return Double.valueOf(toExternal(f));
   }
Index: solr/src/java/org/apache/solr/schema/ExternalFileField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/ExternalFileField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/ExternalFileField.java	(working copy)
@@ -18,6 +18,7 @@
 
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.solr.search.function.ValueSource;
 import org.apache.solr.search.function.FileFloatSource;
 import org.apache.solr.search.QParser;
Index: solr/src/java/org/apache/solr/schema/FieldType.java
===================================================================
--- solr/src/java/org/apache/solr/schema/FieldType.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/FieldType.java	(working copy)
@@ -21,8 +21,9 @@
 import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
-import org.apache.lucene.document.Field;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.document2.Field;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Similarity;
@@ -90,7 +91,7 @@
   }
 
   /**
-   * A "polyField" is a FieldType that can produce more than one Fieldable instance for a single value, via the {@link #createFields(org.apache.solr.schema.SchemaField, Object, float)} method.  This is useful
+   * A "polyField" is a FieldType that can produce more than one IndexableField instance for a single value, via the {@link #createFields(org.apache.solr.schema.SchemaField, Object, float)} method.  This is useful
    * when hiding the implementation details of a field from the Solr end user.  For instance, a spatial point may be represented by multiple different fields.
    * @return true if the {@link #createFields(org.apache.solr.schema.SchemaField, Object, float)} method may return more than one field
    */
@@ -234,7 +235,7 @@
    *
    *
    */
-  public Fieldable createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value, float boost) {
     if (!field.indexed() && !field.stored()) {
       if (log.isTraceEnabled())
         log.trace("Ignoring unindexed/unstored field: " + field);
@@ -249,6 +250,47 @@
     }
     if (val==null) return null;
 
+    org.apache.lucene.document2.FieldType newType = new org.apache.lucene.document2.FieldType();
+    newType.setIndexed(field.indexed());
+    newType.setTokenized(field.isTokenized());
+    newType.setStored(field.stored());
+    newType.setOmitNorms(field.omitNorms());
+    newType.setOmitTermFreqAndPositions(field.omitTf());
+    newType.setStoreTermVectors(field.storeTermVector());
+    newType.setStoreTermVectorOffsets(field.storeTermOffsets());
+    newType.setStoreTermVectorPositions(field.storeTermPositions());
+    
+    return createField(field.getName(), val, newType, boost);
+  }
+
+  protected Fieldable createField(String name, String val, org.apache.lucene.document.Field.Store storage, org.apache.lucene.document.Field.Index index,
+      org.apache.lucene.document.Field.TermVector vec, boolean omitNorms, boolean omitTFPos, float boost){
+    org.apache.lucene.document.Field f = new org.apache.lucene.document.Field(name,
+                        val,
+                        storage,
+                        index,
+                        vec);
+    f.setOmitNorms(omitNorms);
+    f.setOmitTermFreqAndPositions(omitTFPos);
+    f.setBoost(boost);
+    return f;
+  }
+
+  public Fieldable createField2(SchemaField field, Object value, float boost) {
+    if (!field.indexed() && !field.stored()) {
+      if (log.isTraceEnabled())
+        log.trace("Ignoring unindexed/unstored field: " + field);
+      return null;
+    }
+    
+    String val;
+    try {
+      val = toInternal(value.toString());
+    } catch (RuntimeException e) {
+      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR, "Error while creating field '" + field + "' from value '" + value + "'", e, false);
+    }
+    if (val==null) return null;
+
     return createField(field.getName(), val, getFieldStore(field, val),
             getFieldIndex(field, val), getFieldTermVec(field, val), field.omitNorms(),
             field.omitTf(), boost);
@@ -260,66 +302,55 @@
    * Fields per SchemaField
    * @param name The name of the field
    * @param val The _internal_ value to index
-   * @param storage {@link org.apache.lucene.document.Field.Store}
-   * @param index {@link org.apache.lucene.document.Field.Index}
-   * @param vec {@link org.apache.lucene.document.Field.TermVector}
-   * @param omitNorms true if norms should be omitted
-   * @param omitTFPos true if term freq and position should be omitted.
+   * @param type {@link org.apache.lucene.document2.FieldType}
    * @param boost The boost value
-   * @return the {@link org.apache.lucene.document.Fieldable}.
+   * @return the {@link org.apache.lucene.index.IndexableField}.
    */
-  protected Fieldable createField(String name, String val, Field.Store storage, Field.Index index,
-                                    Field.TermVector vec, boolean omitNorms, boolean omitTFPos, float boost){
-    Field f = new Field(name,
-                        val,
-                        storage,
-                        index,
-                        vec);
-    f.setOmitNorms(omitNorms);
-    f.setOmitTermFreqAndPositions(omitTFPos);
+  protected IndexableField createField(String name, String val, org.apache.lucene.document2.FieldType type, float boost){
+    Field f = new Field(name, type, val);
     f.setBoost(boost);
     return f;
   }
 
   /**
-   * Given a {@link org.apache.solr.schema.SchemaField}, create one or more {@link org.apache.lucene.document.Fieldable} instances
+   * Given a {@link org.apache.solr.schema.SchemaField}, create one or more {@link org.apache.lucene.index.IndexableField} instances
    * @param field the {@link org.apache.solr.schema.SchemaField}
    * @param value The value to add to the field
    * @param boost The boost to apply
-   * @return An array of {@link org.apache.lucene.document.Fieldable}
+   * @return An array of {@link org.apache.lucene.index.IndexableField}
    *
    * @see #createField(SchemaField, Object, float)
    * @see #isPolyField()
    */
-  public Fieldable[] createFields(SchemaField field, Object value, float boost) {
-    Fieldable f = createField( field, value, boost);
-    return f==null ? new Fieldable[]{} : new Fieldable[]{f};
+  public IndexableField[] createFields(SchemaField field, Object value, float boost) {
+    IndexableField f = createField( field, value, boost);
+    return f==null ? new IndexableField[]{} : new IndexableField[]{f};
   }
 
   /* Helpers for field construction */
-  protected Field.TermVector getFieldTermVec(SchemaField field,
+  protected org.apache.lucene.document.Field.TermVector getFieldTermVec(SchemaField field,
                                              String internalVal) {
-    Field.TermVector ftv = Field.TermVector.NO;
+    org.apache.lucene.document.Field.TermVector ftv = org.apache.lucene.document.Field.TermVector.NO;
     if (field.storeTermPositions() && field.storeTermOffsets())
-      ftv = Field.TermVector.WITH_POSITIONS_OFFSETS;
+      ftv = org.apache.lucene.document.Field.TermVector.WITH_POSITIONS_OFFSETS;
     else if (field.storeTermPositions())
-      ftv = Field.TermVector.WITH_POSITIONS;
+      ftv = org.apache.lucene.document.Field.TermVector.WITH_POSITIONS;
     else if (field.storeTermOffsets())
-      ftv = Field.TermVector.WITH_OFFSETS;
+      ftv = org.apache.lucene.document.Field.TermVector.WITH_OFFSETS;
     else if (field.storeTermVector())
-      ftv = Field.TermVector.YES;
+      ftv = org.apache.lucene.document.Field.TermVector.YES;
     return ftv;
   }
-  protected Field.Store getFieldStore(SchemaField field,
+  protected org.apache.lucene.document.Field.Store getFieldStore(SchemaField field,
                                       String internalVal) {
-    return field.stored() ? Field.Store.YES : Field.Store.NO;
+    return field.stored() ? org.apache.lucene.document.Field.Store.YES : org.apache.lucene.document.Field.Store.NO;
   }
-  protected Field.Index getFieldIndex(SchemaField field,
+  protected org.apache.lucene.document.Field.Index getFieldIndex(SchemaField field,
                                       String internalVal) {
-    return field.indexed() ? (isTokenized() ? Field.Index.ANALYZED :
-                              Field.Index.NOT_ANALYZED) : Field.Index.NO;
+    return field.indexed() ? (isTokenized() ? org.apache.lucene.document.Field.Index.ANALYZED :
+      org.apache.lucene.document.Field.Index.NOT_ANALYZED) : org.apache.lucene.document.Field.Index.NO;
   }
-
+  
   /**
    * Convert an external value (from XML update command or from query string)
    * into the internal format for both storing and indexing (which can be modified by any analyzers).
@@ -338,10 +369,13 @@
    */
   public String toExternal(Fieldable f) {
     // currently used in writing XML of the search result (but perhaps
-    // a more efficient toXML(Fieldable f, Writer w) should be used
+    // a more efficient toXML(IndexableField f, Writer w) should be used
     // in the future.
     return f.stringValue();
   }
+  public String toExternal(IndexableField f) {
+    return f.stringValue();
+  }
 
   /**
    * Convert the stored-field format to an external object.
@@ -351,11 +385,14 @@
   public Object toObject(Fieldable f) {
     return toExternal(f); // by default use the string
   }
+  public Object toObject(IndexableField f) {
+    return toExternal(f); // by default use the string
+  }
 
   public Object toObject(SchemaField sf, BytesRef term) {
     final CharsRef ref = new CharsRef(term.length);
     indexedToReadable(term, ref);
-    final Fieldable f = createField(sf, ref.toString(), 1.0f);
+    final IndexableField f = createField(sf, ref.toString(), 1.0f);
     return toObject(f);
   }
 
@@ -374,6 +411,10 @@
   public String storedToReadable(Fieldable f) {
     return toExternal(f);
   }
+  /** Given the stored field, return the human readable representation */
+  public String storedToReadable(IndexableField f) {
+    return toExternal(f);
+  }
 
   /** Given the stored field, return the indexed form */
   public String storedToIndexed(Fieldable f) {
@@ -382,6 +423,10 @@
     // that the indexed form is the same as the stored field form.
     return f.stringValue();
   }
+  /** Given the stored field, return the indexed form */
+  public String storedToIndexed(IndexableField f) {
+    return f.stringValue();
+  }
 
   /** Given the readable value, return the term value that will match it. */
   public String readableToIndexed(String val) {
Index: solr/src/java/org/apache/solr/schema/FloatField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/FloatField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/FloatField.java	(working copy)
@@ -24,6 +24,7 @@
 import org.apache.solr.search.function.ValueSource;
 import org.apache.solr.search.function.FloatFieldSource;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.solr.response.TextResponseWriter;
 
 import java.util.Map;
@@ -75,6 +76,10 @@
   }
 
   @Override
+  public Float toObject(IndexableField f) {
+    return Float.valueOf( toExternal(f) );
+  }
+  @Override
   public Float toObject(Fieldable f) {
     return Float.valueOf( toExternal(f) );
   }
Index: solr/src/java/org/apache/solr/schema/GeoHashField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/GeoHashField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/GeoHashField.java	(working copy)
@@ -18,6 +18,7 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.spatial.geohash.GeoHashUtils;
@@ -75,7 +76,7 @@
 
 
   @Override
-  public String toExternal(Fieldable f) {
+  public String toExternal(IndexableField f) {
     double[] latLon = GeoHashUtils.decode(f.stringValue());
     return latLon[0] + "," + latLon[1];
   }
Index: solr/src/java/org/apache/solr/schema/IndexSchema.java
===================================================================
--- solr/src/java/org/apache/solr/schema/IndexSchema.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/IndexSchema.java	(working copy)
@@ -20,6 +20,7 @@
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.DefaultSimilarity;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Similarity;
@@ -260,8 +261,8 @@
    * @return null if this schema has no unique key field
    * @see #printableUniqueKey
    */
-  public Fieldable getUniqueKeyField(org.apache.lucene.document.Document doc) {
-    return doc.getFieldable(uniqueKeyFieldName);  // this should return null if name is null
+  public IndexableField getUniqueKeyField(org.apache.lucene.document2.Document doc) {
+    return doc.getField(uniqueKeyFieldName);  // this should return null if name is null
   }
 
   /**
@@ -270,9 +271,13 @@
    * @return null if this schema has no unique key field
    */
   public String printableUniqueKey(org.apache.lucene.document.Document doc) {
-     Fieldable f = doc.getFieldable(uniqueKeyFieldName);
-     return f==null ? null : uniqueKeyFieldType.toExternal(f);
-  }
+    Fieldable f = doc.getField(uniqueKeyFieldName);
+    return f==null ? null : uniqueKeyFieldType.toExternal(f);
+ }
+  public String printableUniqueKey(org.apache.lucene.document2.Document doc) {
+    IndexableField f = doc.getField(uniqueKeyFieldName);
+    return f==null ? null : uniqueKeyFieldType.toExternal(f);
+ }
 
   private SchemaField getIndexedField(String fname) {
     SchemaField f = getFields().get(fname);
Index: solr/src/java/org/apache/solr/schema/IntField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/IntField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/IntField.java	(working copy)
@@ -24,6 +24,7 @@
 import org.apache.solr.search.function.ValueSource;
 import org.apache.solr.search.function.IntFieldSource;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.solr.response.TextResponseWriter;
 
 import java.util.Map;
@@ -75,6 +76,10 @@
   }
 
   @Override
+  public Integer toObject(IndexableField f) {
+    return Integer.valueOf( toExternal(f) );
+  }
+  @Override
   public Integer toObject(Fieldable f) {
     return Integer.valueOf( toExternal(f) );
   }
Index: solr/src/java/org/apache/solr/schema/LatLonType.java
===================================================================
--- solr/src/java/org/apache/solr/schema/LatLonType.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/LatLonType.java	(working copy)
@@ -16,8 +16,9 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.document.Field;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.document2.FieldType;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.search.*;
@@ -54,10 +55,10 @@
   }
 
   @Override
-  public Fieldable[] createFields(SchemaField field, Object value, float boost) {
+  public IndexableField[] createFields(SchemaField field, Object value, float boost) {
     String externalVal = value.toString();
     //we could have tileDiff + 3 fields (two for the lat/lon, one for storage)
-    Fieldable[] f = new Fieldable[(field.indexed() ? 2 : 0) + (field.stored() ? 1 : 0)];
+    IndexableField[] f = new IndexableField[(field.indexed() ? 2 : 0) + (field.stored() ? 1 : 0)];
     if (field.indexed()) {
       int i = 0;
       double[] latLon = new double[0];
@@ -75,9 +76,10 @@
     }
 
     if (field.stored()) {
-      f[f.length - 1] = createField(field.getName(), externalVal,
-              getFieldStore(field, externalVal), Field.Index.NO, Field.TermVector.NO,
-              false, false, boost);
+      FieldType customType = new FieldType();
+      customType.setStored(true);
+      
+      f[f.length - 1] = createField(field.getName(), externalVal, customType, boost);
     }
     return f;
   }
@@ -281,7 +283,7 @@
   //It never makes sense to create a single field, so make it impossible to happen
 
   @Override
-  public Fieldable createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value, float boost) {
     throw new UnsupportedOperationException("LatLonType uses multiple fields.  field=" + field.getName());
   }
 
Index: solr/src/java/org/apache/solr/schema/LongField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/LongField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/LongField.java	(working copy)
@@ -18,6 +18,7 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.cache.CachedArrayCreator;
 import org.apache.lucene.search.cache.LongValuesCreator;
@@ -77,6 +78,10 @@
   }
 
   @Override
+  public Long toObject(IndexableField f) {
+    return Long.valueOf( toExternal(f) );
+  }
+  @Override
   public Long toObject(Fieldable f) {
     return Long.valueOf( toExternal(f) );
   }
Index: solr/src/java/org/apache/solr/schema/PointType.java
===================================================================
--- solr/src/java/org/apache/solr/schema/PointType.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/PointType.java	(working copy)
@@ -19,6 +19,7 @@
 
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.Query;
@@ -68,7 +69,7 @@
   }
 
   @Override
-  public Fieldable[] createFields(SchemaField field, Object value, float boost) {
+  public IndexableField[] createFields(SchemaField field, Object value, float boost) {
     String externalVal = value.toString();
     String[] point = new String[0];
     try {
@@ -78,7 +79,7 @@
     }
 
     // TODO: this doesn't currently support polyFields as sub-field types
-    Fieldable[] f = new Fieldable[ (field.indexed() ? dimension : 0) + (field.stored() ? 1 : 0) ];
+    IndexableField[] f = new IndexableField[ (field.indexed() ? dimension : 0) + (field.stored() ? 1 : 0) ];
 
     if (field.indexed()) {
       for (int i=0; i<dimension; i++) {
@@ -88,9 +89,9 @@
 
     if (field.stored()) {
       String storedVal = externalVal;  // normalize or not?
-      f[f.length - 1] = createField(field.getName(), storedVal,
-                getFieldStore(field, storedVal), Field.Index.NO, Field.TermVector.NO,
-                false, false, boost);
+      org.apache.lucene.document2.FieldType customType = new org.apache.lucene.document2.FieldType();
+      customType.setStored(true);
+      f[f.length - 1] = createField(field.getName(), storedVal, customType, boost);
     }
     
     return f;
@@ -113,7 +114,7 @@
    *
    */
   @Override
-  public Fieldable createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value, float boost) {
     throw new UnsupportedOperationException("PointType uses multiple fields.  field=" + field.getName());
   }
 
Index: solr/src/java/org/apache/solr/schema/RandomSortField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/RandomSortField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/RandomSortField.java	(working copy)
@@ -21,6 +21,7 @@
 import java.util.Map;
 
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
 import org.apache.lucene.search.*;
Index: solr/src/java/org/apache/solr/schema/SchemaField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/SchemaField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/SchemaField.java	(working copy)
@@ -20,6 +20,7 @@
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.SortField;
 import org.apache.solr.search.QParser;
 
@@ -92,11 +93,11 @@
   boolean isBinary() { return (properties & BINARY)!=0; }
 
 
-  public Fieldable createField(Object val, float boost) {
+  public IndexableField createField(Object val, float boost) {
     return type.createField(this,val,boost);
   }
   
-  public Fieldable[] createFields(Object val, float boost) {
+  public IndexableField[] createFields(Object val, float boost) {
     return type.createFields(this,val,boost);
   }
 
Index: solr/src/java/org/apache/solr/schema/ShortField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/ShortField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/ShortField.java	(working copy)
@@ -17,6 +17,7 @@
  */
 
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.cache.CachedArrayCreator;
 import org.apache.lucene.search.cache.ShortValuesCreator;
@@ -80,6 +81,10 @@
   }
 
   @Override
+  public Short toObject(IndexableField f) {
+    return Short.valueOf(toExternal(f));
+  }
+  @Override
   public Short toObject(Fieldable f) {
     return Short.valueOf(toExternal(f));
   }
Index: solr/src/java/org/apache/solr/schema/SortableDoubleField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/SortableDoubleField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/SortableDoubleField.java	(working copy)
@@ -29,6 +29,7 @@
 import org.apache.solr.search.function.StringIndexDocValues;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.index.IndexableField;
 import org.apache.solr.util.NumberUtils;
 import org.apache.solr.response.TextResponseWriter;
 
@@ -62,12 +63,16 @@
   }
 
   @Override
+  public String toExternal(IndexableField f) {
+    return indexedToReadable(f.stringValue());
+  }
+  @Override
   public String toExternal(Fieldable f) {
     return indexedToReadable(f.stringValue());
   }
 
   @Override
-  public Double toObject(Fieldable f) {
+  public Double toObject(IndexableField f) {
     return NumberUtils.SortableStr2double(f.stringValue());
   }
   
Index: solr/src/java/org/apache/solr/schema/SortableFloatField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/SortableFloatField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/SortableFloatField.java	(working copy)
@@ -29,6 +29,7 @@
 import org.apache.solr.search.function.StringIndexDocValues;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.index.IndexableField;
 import org.apache.solr.util.NumberUtils;
 import org.apache.solr.response.TextResponseWriter;
 
@@ -62,11 +63,19 @@
   }
 
   @Override
+  public String toExternal(IndexableField f) {
+    return indexedToReadable(f.stringValue());
+  }
+  @Override
   public String toExternal(Fieldable f) {
     return indexedToReadable(f.stringValue());
   }
 
   @Override
+  public Float toObject(IndexableField f) {
+    return NumberUtils.SortableStr2float(f.stringValue());
+  }
+  @Override
   public Float toObject(Fieldable f) {
     return NumberUtils.SortableStr2float(f.stringValue());
   }
Index: solr/src/java/org/apache/solr/schema/SortableIntField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/SortableIntField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/SortableIntField.java	(working copy)
@@ -29,6 +29,7 @@
 import org.apache.solr.search.function.StringIndexDocValues;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.index.IndexableField;
 import org.apache.solr.util.NumberUtils;
 import org.apache.solr.response.TextResponseWriter;
 
@@ -65,6 +66,10 @@
   }
 
   @Override
+  public String toExternal(IndexableField f) {
+    return indexedToReadable(f.stringValue());
+  }
+  @Override
   public String toExternal(Fieldable f) {
     return indexedToReadable(f.stringValue());
   }
@@ -82,6 +87,10 @@
   }
 
   @Override
+  public Integer toObject(IndexableField f) {
+    return NumberUtils.SortableStr2int(f.stringValue(), 0, 3);    
+  }
+  @Override
   public Integer toObject(Fieldable f) {
     return NumberUtils.SortableStr2int(f.stringValue(), 0, 3);    
   }
Index: solr/src/java/org/apache/solr/schema/SortableLongField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/SortableLongField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/SortableLongField.java	(working copy)
@@ -29,6 +29,7 @@
 import org.apache.solr.search.function.StringIndexDocValues;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.index.IndexableField;
 import org.apache.solr.util.NumberUtils;
 import org.apache.solr.response.TextResponseWriter;
 
@@ -72,8 +73,17 @@
     charsRef.copy(indexedToReadable, 0, indexedToReadable.length);
     return charsRef;
   }
-  
+
   @Override
+  public String toExternal(IndexableField f) {
+    return indexedToReadable(f.stringValue());
+  }
+
+  @Override
+  public Long toObject(IndexableField f) {
+    return NumberUtils.SortableStr2long(f.stringValue(),0,5);
+  }
+  @Override
   public String toExternal(Fieldable f) {
     return indexedToReadable(f.stringValue());
   }
Index: solr/src/java/org/apache/solr/schema/StrField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/StrField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/StrField.java	(working copy)
@@ -19,6 +19,7 @@
 
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.util.BytesRef;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.function.ValueSource;
Index: solr/src/java/org/apache/solr/schema/TextField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/TextField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/TextField.java	(working copy)
@@ -24,13 +24,13 @@
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.MultiPhraseQuery;
-import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.CachingTokenFilter;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.util.BytesRef;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.solr.search.QParser;
Index: solr/src/java/org/apache/solr/schema/TrieDateField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/TrieDateField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/TrieDateField.java	(working copy)
@@ -21,6 +21,7 @@
 import org.apache.solr.search.QParser;
 import org.apache.solr.response.TextResponseWriter;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.NumericRangeQuery;
@@ -45,6 +46,10 @@
   }
 
   @Override
+  public Date toObject(IndexableField f) {
+    return (Date) wrappedField.toObject(f);
+  }
+  @Override
   public Date toObject(Fieldable f) {
     return (Date) wrappedField.toObject(f);
   }
@@ -88,6 +93,10 @@
   }
 
   @Override
+  public String storedToReadable(IndexableField f) {
+    return wrappedField.storedToReadable(f);
+  }
+  @Override
   public String storedToReadable(Fieldable f) {
     return wrappedField.storedToReadable(f);
   }
@@ -103,6 +112,10 @@
   }
 
   @Override
+  public String toExternal(IndexableField f) {
+    return wrappedField.toExternal(f);
+  }
+  @Override
   public String toExternal(Fieldable f) {
     return wrappedField.toExternal(f);
   }
@@ -118,12 +131,16 @@
   }
 
   @Override
+  public String storedToIndexed(IndexableField f) {
+    return wrappedField.storedToIndexed(f);
+  }
+  @Override
   public String storedToIndexed(Fieldable f) {
     return wrappedField.storedToIndexed(f);
   }
 
   @Override
-  public Fieldable createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value, float boost) {
     return wrappedField.createField(field, value, boost);
   }
 
Index: solr/src/java/org/apache/solr/schema/TrieField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/TrieField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/TrieField.java	(working copy)
@@ -17,8 +17,8 @@
 package org.apache.solr.schema;
 
 import org.apache.lucene.document.Fieldable;
-import org.apache.lucene.document.Field;
 import org.apache.lucene.document.NumericField;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.*;
 import org.apache.lucene.search.cache.CachedArrayCreator;
 import org.apache.lucene.search.cache.DoubleValuesCreator;
@@ -102,6 +102,32 @@
   }
 
   @Override
+  public Object toObject(IndexableField f) {
+    if (f instanceof org.apache.lucene.document2.NumericField) {
+      final Number val = ((org.apache.lucene.document2.NumericField) f).getNumericValue();
+      if (val==null) return badFieldString(f);
+      return (type == TrieTypes.DATE) ? new Date(val.longValue()) : val;
+    } else {
+      // the following code is "deprecated" and only to support pre-3.2 indexes using the old BinaryField encoding:
+      final BytesRef bytes = f.binaryValue(null);
+      if (bytes==null) return badFieldString(f);
+      switch (type) {
+        case INTEGER:
+          return toInt(bytes.bytes);
+        case FLOAT:
+          return Float.intBitsToFloat(toInt(bytes.bytes));
+        case LONG:
+          return toLong(bytes.bytes);
+        case DOUBLE:
+          return Double.longBitsToDouble(toLong(bytes.bytes));
+        case DATE:
+          return new Date(toLong(bytes.bytes));
+        default:
+          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unknown type for trie field: " + f.name());
+      }
+    }
+  }
+  @Override
   public Object toObject(Fieldable f) {
     if (f instanceof NumericField) {
       final Number val = ((NumericField) f).getNumericValue();
@@ -289,6 +315,10 @@
   }
 
   @Override
+  public String storedToReadable(IndexableField f) {
+    return toExternal(f);
+  }
+  @Override
   public String storedToReadable(Fieldable f) {
     return toExternal(f);
   }
@@ -330,13 +360,22 @@
     return readableToIndexed(val);
   }
 
-
+  static String badFieldString(IndexableField f) {
+    String s = f.stringValue();
+    return "ERROR:SCHEMA-INDEX-MISMATCH,stringValue="+s;
+  }
   static String badFieldString(Fieldable f) {
     String s = f.stringValue();
     return "ERROR:SCHEMA-INDEX-MISMATCH,stringValue="+s;
   }
 
   @Override
+  public String toExternal(IndexableField f) {
+    return (type == TrieTypes.DATE)
+      ? dateField.toExternal((Date) toObject(f)) 
+      : toObject(f).toString();
+  }
+  @Override
   public String toExternal(Fieldable f) {
     return (type == TrieTypes.DATE)
       ? dateField.toExternal((Date) toObject(f)) 
@@ -407,6 +446,67 @@
   }
 
   @Override
+  public String storedToIndexed(IndexableField f) {
+    final BytesRef bytes = new BytesRef(NumericUtils.BUF_SIZE_LONG);
+    if (f instanceof org.apache.lucene.document2.NumericField) {
+      final Number val = ((org.apache.lucene.document2.NumericField) f).getNumericValue();
+      if (val==null)
+        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Invalid field contents: "+f.name());
+      switch (type) {
+        case INTEGER:
+          NumericUtils.intToPrefixCoded(val.intValue(), 0, bytes);
+          break;
+        case FLOAT:
+          NumericUtils.intToPrefixCoded(NumericUtils.floatToSortableInt(val.floatValue()), 0, bytes);
+          break;
+        case LONG: //fallthrough!
+        case DATE:
+          NumericUtils.longToPrefixCoded(val.longValue(), 0, bytes);
+          break;
+        case DOUBLE:
+          NumericUtils.longToPrefixCoded(NumericUtils.doubleToSortableLong(val.doubleValue()), 0, bytes);
+          break;
+        default:
+          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unknown type for trie field: " + f.name());
+      }
+    } else {
+      // the following code is "deprecated" and only to support pre-3.2 indexes using the old BinaryField encoding:
+      final BytesRef bytesRef = f.binaryValue(null);
+      if (bytesRef==null)
+        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Invalid field contents: "+f.name());
+      switch (type) {
+        case INTEGER:
+          NumericUtils.intToPrefixCoded(toInt(bytesRef.bytes), 0, bytes);
+          break;
+        case FLOAT: {
+          // WARNING: Code Duplication! Keep in sync with o.a.l.util.NumericUtils!
+          // copied from NumericUtils to not convert to/from float two times
+          // code in next 2 lines is identical to: int v = NumericUtils.floatToSortableInt(Float.intBitsToFloat(toInt(arr)));
+          int v = toInt(bytesRef.bytes);
+          if (v<0) v ^= 0x7fffffff;
+          NumericUtils.intToPrefixCoded(v, 0, bytes);
+          break;
+        }
+        case LONG: //fallthrough!
+        case DATE:
+          NumericUtils.longToPrefixCoded(toLong(bytesRef.bytes), 0, bytes);
+          break;
+        case DOUBLE: {
+          // WARNING: Code Duplication! Keep in sync with o.a.l.util.NumericUtils!
+          // copied from NumericUtils to not convert to/from double two times
+          // code in next 2 lines is identical to: long v = NumericUtils.doubleToSortableLong(Double.longBitsToDouble(toLong(arr)));
+          long v = toLong(bytesRef.bytes);
+          if (v<0) v ^= 0x7fffffffffffffffL;
+          NumericUtils.longToPrefixCoded(v, 0, bytes);
+          break;
+        }
+        default:
+          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unknown type for trie field: " + f.name());
+      }
+    }
+    return bytes.utf8ToString();
+  }
+  @Override
   public String storedToIndexed(Fieldable f) {
     final BytesRef bytes = new BytesRef(NumericUtils.BUF_SIZE_LONG);
     if (f instanceof NumericField) {
@@ -467,9 +567,9 @@
     }
     return bytes.utf8ToString();
   }
-
+  
   @Override
-  public Fieldable createField(SchemaField field, Object value, float boost) {
+  public IndexableField createField(SchemaField field, Object value, float boost) {
     boolean indexed = field.indexed();
     boolean stored = field.stored();
 
@@ -478,8 +578,14 @@
         log.trace("Ignoring unindexed/unstored field: " + field);
       return null;
     }
-
-    final NumericField f = new NumericField(field.getName(), precisionStep, stored ? Field.Store.YES : Field.Store.NO, indexed);
+    
+    org.apache.lucene.document2.FieldType ft = new org.apache.lucene.document2.FieldType();
+    ft.setStored(stored);
+    ft.setIndexed(indexed);
+    ft.setOmitNorms(field.omitNorms());
+    ft.setOmitTermFreqAndPositions(field.omitTf());
+    
+    final org.apache.lucene.document2.NumericField f = new org.apache.lucene.document2.NumericField(field.getName(), precisionStep, ft);
     switch (type) {
       case INTEGER:
         int i = (value instanceof Number)
@@ -515,8 +621,6 @@
         throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Unknown type for trie field: " + type);
     }
 
-    f.setOmitNorms(field.omitNorms());
-    f.setOmitTermFreqAndPositions(field.omitTf());
     f.setBoost(boost);
     return f;
   }
Index: solr/src/java/org/apache/solr/schema/UUIDField.java
===================================================================
--- solr/src/java/org/apache/solr/schema/UUIDField.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/schema/UUIDField.java	(working copy)
@@ -23,6 +23,7 @@
 import java.util.UUID;
 
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.SortField;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.response.TextResponseWriter;
@@ -88,6 +89,10 @@
   }
 
   @Override
+  public UUID toObject(IndexableField f) {
+    return UUID.fromString(f.stringValue());
+  }
+  @Override
   public UUID toObject(Fieldable f) {
     return UUID.fromString(f.stringValue());
   }
Index: solr/src/java/org/apache/solr/update/AddUpdateCommand.java
===================================================================
--- solr/src/java/org/apache/solr/update/AddUpdateCommand.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/update/AddUpdateCommand.java	(working copy)
@@ -17,8 +17,8 @@
 
 package org.apache.solr.update;
 
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.document2.Document;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.Term;
 import org.apache.solr.common.SolrInputDocument;
 import org.apache.solr.common.SolrInputField;
@@ -74,7 +74,7 @@
        if (sf != null) {
          if (doc != null) {
            schema.getUniqueKeyField();
-           Fieldable storedId = doc.getFieldable(sf.getName());
+           IndexableField storedId = doc.getField(sf.getName());
            indexedId = sf.getType().storedToIndexed(storedId);
          }
          if (solrDoc != null) {
Index: solr/src/java/org/apache/solr/update/DocumentBuilder.java
===================================================================
--- solr/src/java/org/apache/solr/update/DocumentBuilder.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/update/DocumentBuilder.java	(working copy)
@@ -21,8 +21,9 @@
 import java.util.HashMap;
 import java.util.List;
 
-import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.document2.Document;
+import org.apache.lucene.index.IndexableField;
 import org.apache.solr.common.SolrDocument;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrInputDocument;
@@ -56,7 +57,7 @@
     // might actually want to map it to something.  If createField()
     // returns null, then we don't store the field.
     if (sfield.isPolyField()) {
-      Fieldable[] fields = sfield.createFields(val, boost);
+      IndexableField[] fields = sfield.createFields(val, boost);
       if (fields.length > 0) {
         if (!sfield.multiValued()) {
           String oldValue = map.put(sfield.getName(), val);
@@ -66,12 +67,12 @@
           }
         }
         // Add each field
-        for (Fieldable field : fields) {
+        for (IndexableField field : fields) {
           doc.add(field);
         }
       }
     } else {
-      Fieldable field = sfield.createField(val, boost);
+      IndexableField field = sfield.createField(val, boost);
       if (field != null) {
         if (!sfield.multiValued()) {
           String oldValue = map.put(sfield.getName(), val);
@@ -146,7 +147,7 @@
   }
 
   public void setBoost(float boost) {
-    doc.setBoost(boost);
+    //doc.setBoost(boost);
   }
 
   public void endDoc() {
@@ -159,7 +160,7 @@
     // default value are defacto 'required' fields.  
     List<String> missingFields = null;
     for (SchemaField field : schema.getRequiredFields()) {
-      if (doc.getFieldable(field.getName() ) == null) {
+      if (doc.getField(field.getName() ) == null) {
         if (field.getDefaultValue() != null) {
           addField(doc, field, field.getDefaultValue(), 1.0f);
         } else {
@@ -176,7 +177,7 @@
       // add the uniqueKey if possible
       if( schema.getUniqueKeyField() != null ) {
         String n = schema.getUniqueKeyField().getName();
-        String v = doc.get( n );
+        String v = doc.getField( n ).stringValue();
         builder.append( "Document ["+n+"="+v+"] " );
       }
       builder.append("missing required fields: " );
@@ -194,12 +195,12 @@
 
   private static void addField(Document doc, SchemaField field, Object val, float boost) {
     if (field.isPolyField()) {
-      Fieldable[] farr = field.getType().createFields(field, val, boost);
-      for (Fieldable f : farr) {
+      IndexableField[] farr = field.getType().createFields(field, val, boost);
+      for (IndexableField f : farr) {
         if (f != null) doc.add(f); // null fields are not added
       }
     } else {
-      Fieldable f = field.createField(val, boost);
+      IndexableField f = field.createField(val, boost);
       if (f != null) doc.add(f);  // null fields are not added
     }
   }
@@ -231,7 +232,7 @@
   public static Document toDocument( SolrInputDocument doc, IndexSchema schema )
   { 
     Document out = new Document();
-    out.setBoost( doc.getDocumentBoost() );
+    //out.setBoost( doc.getDocumentBoost() );
     
     // Load fields from SolrDocument to Document
     for( SolrInputField field : doc ) {
@@ -267,7 +268,7 @@
           for (CopyField cf : copyFields) {
             SchemaField destinationField = cf.getDestination();
             // check if the copy field is a multivalued or not
-            if (!destinationField.multiValued() && out.getFieldable(destinationField.getName()) != null) {
+            if (!destinationField.multiValued() && out.getField(destinationField.getName()) != null) {
               throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,
                       "ERROR: "+getID(doc, schema)+"multiple values encountered for non multiValued copy field " +
                               destinationField.getName() + ": " + v);
@@ -281,9 +282,9 @@
               val = cf.getLimitedValue((String)val);
             }
             
-            Fieldable [] fields = destinationField.createFields(val, boost);
+            IndexableField [] fields = destinationField.createFields(val, boost);
             if (fields != null) { // null fields are not added
-              for (Fieldable f : fields) {
+              for (IndexableField f : fields) {
                 if(f != null) out.add(f);
               }
             }
@@ -313,7 +314,7 @@
     // Now validate required fields or add default values
     // fields with default values are defacto 'required'
     for (SchemaField field : schema.getRequiredFields()) {
-      if (out.getFieldable(field.getName() ) == null) {
+      if (out.getField(field.getName() ) == null) {
         if (field.getDefaultValue() != null) {
           addField(out, field, field.getDefaultValue(), 1.0f);
         } 
@@ -337,7 +338,7 @@
    * 
    * @since solr 1.3
    */
-  public SolrDocument loadStoredFields( SolrDocument doc, Document luceneDoc  )
+  public SolrDocument loadStoredFields( SolrDocument doc, org.apache.lucene.document.Document luceneDoc  )
   {
     for( Fieldable field : luceneDoc.getFields() ) {
       if( field.isStored() ) {
Index: solr/src/java/org/apache/solr/update/UpdateHandler.java
===================================================================
--- solr/src/java/org/apache/solr/update/UpdateHandler.java	(revision 1145347)
+++ solr/src/java/org/apache/solr/update/UpdateHandler.java	(working copy)
@@ -19,9 +19,9 @@
 
 
 import org.apache.lucene.index.IndexReader.AtomicReaderContext;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.document2.Document;
 import org.apache.lucene.search.Collector;
 import org.apache.lucene.search.Scorer;
 
@@ -113,7 +113,7 @@
 
     // Right now, single valued fields that require value transformation from external to internal (indexed)
     // form have that transformation already performed and stored as the field value.
-    Fieldable[] id = doc.getFieldables( idField.getName() );
+    IndexableField[] id = doc.getFields( idField.getName() );
     if (id == null || id.length < 1)
       throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,"Document is missing mandatory uniqueKey field: " + idField.getName());
     if( id.length > 1 )
@@ -124,7 +124,7 @@
 
   protected final String getIndexedIdOptional(Document doc) {
     if (idField == null) return null;
-    Fieldable f = doc.getFieldable(idField.getName());
+    IndexableField f = doc.getField(idField.getName());
     if (f == null) return null;
     return idFieldType.storedToIndexed(f);
   }
Index: solr/src/test/org/apache/solr/BasicFunctionalityTest.java
===================================================================
--- solr/src/test/org/apache/solr/BasicFunctionalityTest.java	(revision 1145347)
+++ solr/src/test/org/apache/solr/BasicFunctionalityTest.java	(working copy)
@@ -26,8 +26,8 @@
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.document2.Field;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.LogMergePolicy;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrException.ErrorCode;
@@ -358,32 +358,32 @@
     
     IndexSchema ischema = new IndexSchema(solrConfig, getSchemaFile(), null);
     SchemaField f; // Solr field type
-    Fieldable luf; // Lucene field
+    IndexableField luf; // Lucene field
 
     f = ischema.getField("test_basictv");
     luf = f.createField("test", 0f);
     assertTrue(f.storeTermVector());
-    assertTrue(luf.isTermVectorStored());
+    assertTrue(luf.storeTermVectors());
 
     f = ischema.getField("test_notv");
     luf = f.createField("test", 0f);
     assertTrue(!f.storeTermVector());
-    assertTrue(!luf.isTermVectorStored());    
+    assertTrue(!luf.storeTermVectors());    
 
     f = ischema.getField("test_postv");
     luf = f.createField("test", 0f);
     assertTrue(f.storeTermVector() && f.storeTermPositions());
-    assertTrue(luf.isStorePositionWithTermVector());
+    assertTrue(luf.storeTermVectorPositions());
 
     f = ischema.getField("test_offtv");
     luf = f.createField("test", 0f);
     assertTrue(f.storeTermVector() && f.storeTermOffsets());
-    assertTrue(luf.isStoreOffsetWithTermVector());
+    assertTrue(luf.storeTermVectorOffsets());
 
     f = ischema.getField("test_posofftv");
     luf = f.createField("test", 0f);
     assertTrue(f.storeTermVector() && f.storeTermPositions() && f.storeTermOffsets());
-    assertTrue(luf.isStoreOffsetWithTermVector() && luf.isStorePositionWithTermVector());
+    assertTrue(luf.storeTermVectorOffsets() && luf.storeTermVectorPositions());
 
   }
 
Index: solr/src/test/org/apache/solr/schema/DateFieldTest.java
===================================================================
--- solr/src/test/org/apache/solr/schema/DateFieldTest.java	(revision 1145347)
+++ solr/src/test/org/apache/solr/schema/DateFieldTest.java	(working copy)
@@ -17,8 +17,8 @@
 
 package org.apache.solr.schema;
 
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.document2.Field;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.solr.schema.DateField;
 import org.apache.solr.util.DateMathParser;
@@ -119,7 +119,7 @@
   public void testCreateField() {
     int props = FieldProperties.INDEXED ^ FieldProperties.STORED;
     SchemaField sf = new SchemaField( "test", f, props, null );
-    Fieldable out = (Field)f.createField(sf, "1995-12-31T23:59:59Z", 1.0f );
+    IndexableField out = (Field)f.createField(sf, "1995-12-31T23:59:59Z", 1.0f );
     assertEquals(820454399000l, f.toObject( out ).getTime() );
     
     out = (Field)f.createField(sf, new Date(820454399000l), 1.0f );
Index: solr/src/test/org/apache/solr/schema/PolyFieldTest.java
===================================================================
--- solr/src/test/org/apache/solr/schema/PolyFieldTest.java	(revision 1145347)
+++ solr/src/test/org/apache/solr/schema/PolyFieldTest.java	(working copy)
@@ -16,7 +16,7 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.Query;
@@ -83,7 +83,7 @@
     assertEquals(pt.getDimension(), 2);
     double[] xy = new double[]{35.0, -79.34};
     String point = xy[0] + "," + xy[1];
-    Fieldable[] fields = home.createFields(point, 2);
+    IndexableField[] fields = home.createFields(point, 2);
     assertEquals(fields.length, 3);//should be 3, we have a stored field
     //first two fields contain the values, third is just stored and contains the original
     for (int i = 0; i < 3; i++) {
Index: solr/src/test/org/apache/solr/update/DirectUpdateHandlerOptimizeTest.java
===================================================================
--- solr/src/test/org/apache/solr/update/DirectUpdateHandlerOptimizeTest.java	(revision 1145347)
+++ solr/src/test/org/apache/solr/update/DirectUpdateHandlerOptimizeTest.java	(working copy)
@@ -16,8 +16,10 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
+import org.apache.lucene.document2.Document;
+import org.apache.lucene.document2.Field;
+import org.apache.lucene.document2.StringField;
+import org.apache.lucene.document2.TextField;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.util.AbstractSolrTestCase;
@@ -56,8 +58,8 @@
     for (int i = 0; i < 99; i++) {
       // Add a valid document
       cmd.doc = new Document();
-      cmd.doc.add(new Field("id", "id_" + i, Field.Store.YES, Field.Index.NOT_ANALYZED));
-      cmd.doc.add(new Field("subject", "subject_" + i, Field.Store.NO, Field.Index.ANALYZED));
+      cmd.doc.add(new Field("id", StringField.TYPE_STORED, "id_" + i));
+      cmd.doc.add(new TextField("subject", "subject_" + i));
       updater.addDoc(cmd);
     }
 
Index: solr/src/test/org/apache/solr/update/DocumentBuilderTest.java
===================================================================
--- solr/src/test/org/apache/solr/update/DocumentBuilderTest.java	(revision 1145347)
+++ solr/src/test/org/apache/solr/update/DocumentBuilderTest.java	(working copy)
@@ -17,7 +17,7 @@
 
 package org.apache.solr.update;
 
-import org.apache.lucene.document.Document;
+import org.apache.lucene.document2.Document;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.SolrInputDocument;
@@ -109,8 +109,8 @@
     doc.addField( "home", "2.2,3.3", 1.0f );
     Document out = DocumentBuilder.toDocument( doc, core.getSchema() );
     assertNotNull( out.get( "home" ) );//contains the stored value and term vector, if there is one
-    assertNotNull( out.getFieldable( "home_0" + FieldType.POLY_FIELD_SEPARATOR + "double" ) );
-    assertNotNull( out.getFieldable( "home_1" + FieldType.POLY_FIELD_SEPARATOR + "double" ) );
+    assertNotNull( out.getField( "home_0" + FieldType.POLY_FIELD_SEPARATOR + "double" ) );
+    assertNotNull( out.getField( "home_1" + FieldType.POLY_FIELD_SEPARATOR + "double" ) );
   }
 
 }
Index: solr/src/test/org/apache/solr/update/TestIndexingPerformance.java
===================================================================
--- solr/src/test/org/apache/solr/update/TestIndexingPerformance.java	(revision 1145347)
+++ solr/src/test/org/apache/solr/update/TestIndexingPerformance.java	(working copy)
@@ -17,9 +17,10 @@
 
 package org.apache.solr.update;
 
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.document2.Document;
+import org.apache.lucene.document2.Field;
+import org.apache.lucene.document2.StringField;
+import org.apache.lucene.index.IndexableField;
 import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.util.AbstractSolrTestCase;
@@ -97,12 +98,12 @@
     for (int i=0; i<iter; i++) {
       if (includeDoc || add.doc==null) {
         add.doc = new Document();
-        idField = new Field("id","", Field.Store.YES, Field.Index.NOT_ANALYZED);
+        idField = new Field("id",StringField.TYPE_STORED,"");
         add.doc.add(idField);
         for (int j=0; j<fields.length; j+=2) {
           String field = fields[j];
           String val = fields[j+1];
-          Fieldable f = schema.getField(field).createField(val, 1.0f);
+          IndexableField f = schema.getField(field).createField(val, 1.0f);
           add.doc.add(f);
         }
       }
