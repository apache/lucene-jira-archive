diff --git a/lucene/core/src/java/org/apache/lucene/document/FeatureField.java b/lucene/core/src/java/org/apache/lucene/document/FeatureField.java
index 33255638e6..cb9d52c199 100644
--- a/lucene/core/src/java/org/apache/lucene/document/FeatureField.java
+++ b/lucene/core/src/java/org/apache/lucene/document/FeatureField.java
@@ -30,7 +30,11 @@ import org.apache.lucene.index.TermStates;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.BoostQuery;
 import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.Feature;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.ScoreMode;
+import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.similarities.BM25Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
 
@@ -42,10 +46,9 @@ import org.apache.lucene.search.similarities.Similarity.SimScorer;
  * ACM SIGIR conference on Research and development in information retrieval.
  * August 15-19, 2005, Salvador, Brazil.
  * <p>
- * Feature values are internally encoded as term frequencies. Putting
- * feature queries as
- * {@link org.apache.lucene.search.BooleanClause.Occur#SHOULD} clauses of a
- * {@link BooleanQuery} allows to combine query-dependent scores (eg. BM25)
+ * Feature values are internally encoded as term frequencies. Adding
+ * features to a {@link BooleanQuery} by using {@link BooleanQuery.Builder#add(Feature)}
+ * allows to combine query-dependent scores (eg. BM25)
  * with query-independent scores using a linear combination. The fact that
  * feature values are stored as frequencies also allows search logic to
  * efficiently skip documents that can't be competitive when total hit counts
@@ -65,16 +68,16 @@ import org.apache.lucene.search.similarities.Similarity.SimScorer;
  * Given a scoring factor {@code S > 0} and its weight {@code w > 0}, there
  * are three ways that S can be turned into a score:
  * <ul>
- *   <li>{@link #newLogQuery w * log(a + S)}, with a &ge; 1. This function
+ *   <li>{@link #newLogFeature w * log(a + S)}, with a &ge; 1. This function
  *       usually makes sense because the distribution of scoring factors
  *       often follows a power law. This is typically the case for pagerank for
  *       instance. However the paper suggested that the {@code satu} and
  *       {@code sigm} functions give even better results.
- *   <li>{@link #newSaturationQuery satu(S) = w * S / (S + k)}, with k &gt; 0. This
+ *   <li>{@link #newSaturationFeature satu(S) = w * S / (S + k)}, with k &gt; 0. This
  *       function is similar to the one used by {@link BM25Similarity} in order
  *       to incorporate term frequency into the final score and produces values
  *       between 0 and 1. A value of 0.5 is obtained when S and k are equal.
- *   <li>{@link #newSigmoidQuery sigm(S) = w * S<sup>a</sup> / (S<sup>a</sup> + k<sup>a</sup>)},
+ *   <li>{@link #newSigmoidFeature sigm(S) = w * S<sup>a</sup> / (S<sup>a</sup> + k<sup>a</sup>)},
  *       with k &gt; 0, a &gt; 0. This function provided even better results
  *       than the two above but is also harder to tune due to the fact it has
  *       2 parameters. Like with {@code satu}, values are in the 0..1 range and
@@ -83,7 +86,7 @@ import org.apache.lucene.search.similarities.Similarity.SimScorer;
  * <p>
  * The constants in the above formulas typically need training in order to
  * compute optimal values. If you don't know where to start, the
- * {@link #newSaturationQuery(String, String)} method uses
+ * {@link #newSaturationFeature(String, String)} method uses
  * {@code 1f} as a weight and tries to guess a sensible value for the
  * {@code pivot} parameter of the saturation function based on index
  * statistics, which shouldn't perform too bad. Here is an example, assuming
@@ -94,10 +97,10 @@ import org.apache.lucene.search.similarities.Similarity.SimScorer;
  *     .add(new TermQuery(new Term("body", "apache")), Occur.SHOULD)
  *     .add(new TermQuery(new Term("body", "lucene")), Occur.SHOULD)
  *     .build();
- * Query boost = FeatureField.newSaturationQuery("features", "pagerank");
+ * Feature boost = FeatureField.newSaturationFeature("features", "pagerank");
  * Query boostedQuery = new BooleanQuery.Builder()
  *     .add(query, Occur.MUST)
- *     .add(boost, Occur.SHOULD)
+ *     .add(boost)
  *     .build();
  * TopDocs topDocs = searcher.search(boostedQuery, 10);
  * </pre>
@@ -412,22 +415,18 @@ public final class FeatureField extends Field {
    * @param scalingFactor scaling factor applied before taking the logarithm, must be in [1, +Infinity)
    * @throws IllegalArgumentException if weight is not in (0,64] or scalingFactor is not in [1, +Infinity)
    */
-  public static Query newLogQuery(String fieldName, String featureName, float weight, float scalingFactor) {
+  public static Feature newLogFeature(String fieldName, String featureName, float weight, float scalingFactor) {
     if (weight <= 0 || weight > MAX_WEIGHT) {
       throw new IllegalArgumentException("weight must be in (0, " + MAX_WEIGHT + "], got: " + weight);
     }
     if (scalingFactor < 1 || Float.isFinite(scalingFactor) == false) {
       throw new IllegalArgumentException("scalingFactor must be >= 1, got: " + scalingFactor);
     }
-    Query q = new FeatureQuery(fieldName, featureName, new LogFunction(scalingFactor));
-    if (weight != 1f) {
-      q = new BoostQuery(q, weight);
-    }
-    return q;
+    return new FeatureQuery(fieldName, featureName, new LogFunction(scalingFactor), weight);
   }
 
   /**
-   * Return a new {@link Query} that will score documents as
+   * Return a new {@link Feature} that will score documents as
    * {@code weight * S / (S + pivot)} where S is the value of the static feature.
    * @param fieldName   field that stores features
    * @param featureName name of the feature
@@ -435,12 +434,13 @@ public final class FeatureField extends Field {
    * @param pivot       feature value that would give a score contribution equal to weight/2, must be in (0, +Infinity)
    * @throws IllegalArgumentException if weight is not in (0,64] or pivot is not in (0, +Infinity)
    */
-  public static Query newSaturationQuery(String fieldName, String featureName, float weight, float pivot) {
-    return newSaturationQuery(fieldName, featureName, weight, Float.valueOf(pivot));
+  public static Feature newSaturationFeature(String fieldName, String featureName, float weight, float pivot) {
+    return newSaturationFeature(fieldName, featureName, weight, Float.valueOf(pivot));
   }
 
+
   /**
-   * Same as {@link #newSaturationQuery(String, String, float, float)} but
+   * Same as {@link #newSaturationFeature(String, String, float, float)} but
    * {@code 1f} is used as a weight and a reasonably good default pivot value
    * is computed based on index statistics and is approximately equal to the
    * geometric mean of all values that exist in the index.
@@ -448,22 +448,18 @@ public final class FeatureField extends Field {
    * @param featureName name of the feature
    * @throws IllegalArgumentException if weight is not in (0,64] or pivot is not in (0, +Infinity)
    */
-  public static Query newSaturationQuery(String fieldName, String featureName) {
-    return newSaturationQuery(fieldName, featureName, 1f, null);
+  public static Feature newSaturationFeature(String fieldName, String featureName) {
+    return newSaturationFeature(fieldName, featureName, 1f, null);
   }
 
-  private static Query newSaturationQuery(String fieldName, String featureName, float weight, Float pivot) {
+  private static Feature newSaturationFeature(String fieldName, String featureName, float weight, Float pivot) {
     if (weight <= 0 || weight > MAX_WEIGHT) {
       throw new IllegalArgumentException("weight must be in (0, " + MAX_WEIGHT + "], got: " + weight);
     }
     if (pivot != null && (pivot <= 0 || Float.isFinite(pivot) == false)) {
       throw new IllegalArgumentException("pivot must be > 0, got: " + pivot);
     }
-    Query q = new FeatureQuery(fieldName, featureName, new SaturationFunction(fieldName, featureName, pivot));
-    if (weight != 1f) {
-      q = new BoostQuery(q, weight);
-    }
-    return q;
+    return new FeatureQuery(fieldName, featureName, new SaturationFunction(fieldName, featureName, pivot), weight);
   }
 
   /**
@@ -476,7 +472,7 @@ public final class FeatureField extends Field {
    * @param exp         exponent, higher values make the function grow slower before 'pivot' and faster after 'pivot', must be in (0, +Infinity)
    * @throws IllegalArgumentException if w is not in (0,64] or either k or a are not in (0, +Infinity)
    */
-  public static Query newSigmoidQuery(String fieldName, String featureName, float weight, float pivot, float exp) {
+  public static Feature newSigmoidFeature(String fieldName, String featureName, float weight, float pivot, float exp) {
     if (weight <= 0 || weight > MAX_WEIGHT) {
       throw new IllegalArgumentException("weight must be in (0, " + MAX_WEIGHT + "], got: " + weight);
     }
@@ -486,17 +482,13 @@ public final class FeatureField extends Field {
     if (exp <= 0 || Float.isFinite(exp) == false) {
       throw new IllegalArgumentException("exp must be > 0, got: " + exp);
     }
-    Query q = new FeatureQuery(fieldName, featureName, new SigmoidFunction(pivot, exp));
-    if (weight != 1f) {
-      q = new BoostQuery(q, weight);
-    }
-    return q;
+    return new FeatureQuery(fieldName, featureName, new SigmoidFunction(pivot, exp), weight);
   }
 
   /**
    * Compute a feature value that may be used as the {@code pivot} parameter of
-   * the {@link #newSaturationQuery(String, String, float, float)} and
-   * {@link #newSigmoidQuery(String, String, float, float, float)} factory
+   * the {@link #newSaturationFeature(String, String, float, float)} and
+   * {@link #newSigmoidFeature(String, String, float, float, float)} factory
    * methods. The implementation takes the average of the int bits of the float
    * representation in practice before converting it back to a float. Given that
    * floats store the exponent in the higher bits, it means that the result will
@@ -518,4 +510,5 @@ public final class FeatureField extends Field {
     float avgFreq = (float) ((double) states.totalTermFreq() / states.docFreq());
     return decodeFeatureValue(avgFreq);
   }
+
 }
diff --git a/lucene/core/src/java/org/apache/lucene/document/FeatureQuery.java b/lucene/core/src/java/org/apache/lucene/document/FeatureQuery.java
index efc2d00e5c..99e2ad0845 100644
--- a/lucene/core/src/java/org/apache/lucene/document/FeatureQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/document/FeatureQuery.java
@@ -30,6 +30,7 @@ import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.Feature;
 import org.apache.lucene.search.ImpactsDISI;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
@@ -39,25 +40,27 @@ import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
 import org.apache.lucene.util.BytesRef;
 
-final class FeatureQuery extends Query {
+final class FeatureQuery extends Feature {
 
   private final String fieldName;
   private final String featureName;
   private final FeatureFunction function;
+  private final float weight;
 
-  FeatureQuery(String fieldName, String featureName, FeatureFunction function) {
+  FeatureQuery(String fieldName, String featureName, FeatureFunction function, float weight) {
     this.fieldName = Objects.requireNonNull(fieldName);
     this.featureName = Objects.requireNonNull(featureName);
     this.function = Objects.requireNonNull(function);
+    this.weight = weight;
   }
 
   @Override
-  public Query rewrite(IndexReader reader) throws IOException {
+  public Feature rewrite(IndexReader reader) throws IOException {
     FeatureFunction rewritten = function.rewrite(reader);
     if (function != rewritten) {
-      return new FeatureQuery(fieldName, featureName, rewritten);
+      return new FeatureQuery(fieldName, featureName, rewritten, weight);
     }
-    return super.rewrite(reader);
+    return this;
   }
 
   @Override
@@ -81,8 +84,8 @@ final class FeatureQuery extends Query {
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {
-    return new Weight(this) {
+  public Weight createWeight(Query parent, IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {
+    return new Weight(parent) {
 
       @Override
       public boolean isCacheable(LeafReaderContext ctx) {
@@ -119,7 +122,7 @@ final class FeatureQuery extends Query {
           return Explanation.noMatch(desc + ". Feature " + featureName + " isn't set.");
         }
 
-        return function.explain(fieldName, featureName, boost, postings.freq());
+        return function.explain(fieldName, featureName, boost * weight, postings.freq());
       }
 
       @Override
@@ -133,7 +136,7 @@ final class FeatureQuery extends Query {
           return null;
         }
 
-        final SimScorer scorer = function.scorer(boost);
+        final SimScorer scorer = function.scorer(boost * weight);
         final ImpactsEnum impacts = termsEnum.impacts(PostingsEnum.FREQS);
         final ImpactsDISI impactsDisi = new ImpactsDISI(impacts, impacts, scorer);
 
@@ -175,7 +178,7 @@ final class FeatureQuery extends Query {
   }
 
   @Override
-  public String toString(String field) {
+  public String toString() {
     return "FeatureQuery(field=" + fieldName + ", feature=" + featureName + ", function=" + function + ")";
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/document/LongDistanceFeatureQuery.java b/lucene/core/src/java/org/apache/lucene/document/LongDistanceFeature.java
similarity index 91%
rename from lucene/core/src/java/org/apache/lucene/document/LongDistanceFeatureQuery.java
rename to lucene/core/src/java/org/apache/lucene/document/LongDistanceFeature.java
index 480cfce443..8034dc988f 100644
--- a/lucene/core/src/java/org/apache/lucene/document/LongDistanceFeatureQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/document/LongDistanceFeature.java
@@ -21,6 +21,7 @@ import java.util.Objects;
 import java.util.Set;
 
 import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.PointValues;
@@ -30,6 +31,7 @@ import org.apache.lucene.index.SortedNumericDocValues;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.Feature;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.ScoreMode;
@@ -39,50 +41,52 @@ import org.apache.lucene.search.Weight;
 import org.apache.lucene.util.DocIdSetBuilder;
 import org.apache.lucene.util.FutureArrays;
 
-final class LongDistanceFeatureQuery extends Query {
+final class LongDistanceFeature extends Feature {
 
   private final String field;
   private final long origin;
   private final long pivotDistance;
+  private final float weight;
 
-  LongDistanceFeatureQuery(String field, long origin, long pivotDistance) {
+  LongDistanceFeature(String field, long origin, long pivotDistance, float weight) {
     this.field = Objects.requireNonNull(field);
     this.origin = origin;
     if (pivotDistance <= 0) {
       throw new IllegalArgumentException("pivotDistance must be > 0, got " + pivotDistance);
     }
     this.pivotDistance = pivotDistance;
+    this.weight = weight;
   }
 
   @Override
-  public final boolean equals(Object o) {
-    return sameClassAs(o) &&
-        equalsTo(getClass().cast(o));
-  }
-
-  private boolean equalsTo(LongDistanceFeatureQuery other) {
-    return Objects.equals(field, other.field) &&
-        origin == other.origin &&
-        pivotDistance == other.pivotDistance;
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+    LongDistanceFeature that = (LongDistanceFeature) o;
+    return origin == that.origin &&
+        pivotDistance == that.pivotDistance &&
+        weight == that.weight &&
+        Objects.equals(field, that.field);
   }
 
   @Override
   public int hashCode() {
-    int h = classHash();
-    h = 31 * h + field.hashCode();
-    h = 31 * h + Long.hashCode(origin);
-    h = 31 * h + Long.hashCode(pivotDistance);
-    return h;
+    return Objects.hash(field, origin, pivotDistance, weight);
   }
 
   @Override
-  public String toString(String field) {
+  public String toString() {
     return getClass().getSimpleName() + "(field=" + field + ",origin=" + origin + ",pivotDistance=" + pivotDistance + ")";
   }
 
   @Override
-  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {
-    return new Weight(this) {
+  public Feature rewrite(IndexReader reader) throws IOException {
+    return this;
+  }
+
+  @Override
+  public Weight createWeight(Query parent, IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {
+    return new Weight(parent) {
 
       @Override
       public boolean isCacheable(LeafReaderContext ctx) {
@@ -104,9 +108,9 @@ final class LongDistanceFeatureQuery extends Query {
           // underflow, treat as MAX_VALUE
           distance = Long.MAX_VALUE;
         }
-        float score = (float) (boost * (pivotDistance / (pivotDistance + (double) distance)));
+        float score = (float) (boost * weight * (pivotDistance / (pivotDistance + (double) distance)));
         return Explanation.match(score, "Distance score, computed as weight * pivotDistance / (pivotDistance + abs(value - origin)) from:",
-            Explanation.match(boost, "weight"),
+            Explanation.match(boost * weight, "weight"),
             Explanation.match(pivotDistance, "pivotDistance"),
             Explanation.match(origin, "origin"),
             Explanation.match(value, "current value"));
@@ -199,7 +203,7 @@ final class LongDistanceFeatureQuery extends Query {
 
           @Override
           public Scorer get(long leadCost) throws IOException {
-            return new DistanceScorer(weight, context.reader().maxDoc(), leadCost, boost, pointValues, docValues);
+            return new DistanceScorer(weight, context.reader().maxDoc(), leadCost, boost * LongDistanceFeature.this.weight, pointValues, docValues);
           }
 
           @Override
diff --git a/lucene/core/src/java/org/apache/lucene/document/LongPoint.java b/lucene/core/src/java/org/apache/lucene/document/LongPoint.java
index 5311114553..299ea3c511 100644
--- a/lucene/core/src/java/org/apache/lucene/document/LongPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/LongPoint.java
@@ -21,7 +21,7 @@ import java.util.Collection;
 
 import org.apache.lucene.index.PointValues;
 import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.BoostQuery;
+import org.apache.lucene.search.Feature;
 import org.apache.lucene.search.PointInSetQuery;
 import org.apache.lucene.search.PointRangeQuery;
 import org.apache.lucene.search.Query;
@@ -263,7 +263,7 @@ public final class LongPoint extends Field {
   /**
    * Given a field that indexes the same long values into a {@link LongPoint}
    * and doc values (either {@link NumericDocValuesField} or
-   * {@link SortedNumericDocValuesField}), this returns a query that scores
+   * {@link SortedNumericDocValuesField}), this returns a {@link Feature} that scores
    * documents based on their distance to {@code origin}:
    * {@code score = weight * pivotDistance / (pivotDistance + distance)}, ie.
    * score is in the {@code [0, weight]} range, is equal to {@code weight} when
@@ -272,14 +272,10 @@ public final class LongPoint extends Field {
    * {@code pivotDistance} from {@code origin}.
    * In case of multi-valued fields, only the closest point to {@code origin}
    * will be considered.
-   * This query is typically useful to boost results based on recency by adding
-   * this query to a {@link Occur#SHOULD} clause of a {@link BooleanQuery}.
+   * This feature is typically useful to boost results based on recency by adding
+   * it to a boolean query via {@link BooleanQuery.Builder#add(Feature)}.
    */
-  public static Query newDistanceFeatureQuery(String field, float weight, long origin, long pivotDistance) {
-    Query query = new LongDistanceFeatureQuery(field, origin, pivotDistance);
-    if (weight != 1f) {
-      query = new BoostQuery(query, weight);
-    }
-    return query;
+  public static Feature newDistanceFeature(String field, float weight, long origin, long pivotDistance) {
+    return new LongDistanceFeature(field, origin, pivotDistance, weight);
   }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/BooleanClause.java b/lucene/core/src/java/org/apache/lucene/search/BooleanClause.java
index f3931b1f97..1a05473a0d 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BooleanClause.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BooleanClause.java
@@ -17,8 +17,11 @@
 package org.apache.lucene.search;
 
 
+import java.io.IOException;
 import java.util.Objects;
 
+import org.apache.lucene.index.IndexReader;
+
 /** A clause in a BooleanQuery. */
 public final class BooleanClause {
   
@@ -53,13 +56,15 @@ public final class BooleanClause {
 
   private final Occur occur;
 
-
   /** Constructs a BooleanClause.
   */ 
   public BooleanClause(Query query, Occur occur) {
     this.query = Objects.requireNonNull(query, "Query must not be null");
     this.occur = Objects.requireNonNull(occur, "Occur must not be null");
-    
+  }
+
+  public BooleanClause(Feature feature) {
+    this(new FeatureQuery(feature), Occur.SHOULD);
   }
 
   public Occur getOccur() {
@@ -98,9 +103,49 @@ public final class BooleanClause {
     return 31 * query.hashCode() + occur.hashCode();
   }
 
-
   @Override
   public String toString() {
     return occur.toString() + query.toString();
   }
+
+  private static class FeatureQuery extends Query {
+
+    private final Feature feature;
+
+    private FeatureQuery(Feature feature) {
+      this.feature = feature;
+    }
+
+    @Override
+    public String toString(String field) {
+      return feature.toString();
+    }
+
+    @Override
+    public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {
+      return feature.createWeight(this, searcher, scoreMode, boost);
+    }
+
+    @Override
+    public Query rewrite(IndexReader reader) throws IOException {
+      Feature rewritten = feature.rewrite(reader);
+      if (rewritten != feature) {
+        return new FeatureQuery(rewritten);
+      }
+      return this;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
+      FeatureQuery that = (FeatureQuery) o;
+      return Objects.equals(feature, that.feature);
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(feature);
+    }
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java b/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
index f52df9fb9c..0b101b27b5 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
@@ -127,6 +127,16 @@ public class BooleanQuery extends Query implements Iterable<BooleanClause> {
       return add(new BooleanClause(query, occur));
     }
 
+    /**
+     * Add a scoring feature to this {@link Builder}.  Note that the order in which
+     * clauses are added does not have any impact on matching documents or query
+     * performance.
+     * @throws TooManyClauses if the new number of clauses exceeds the maximum clause number
+     */
+    public Builder add(Feature feature) {
+      return add(new BooleanClause(feature));
+    }
+
     /** Create a new {@link BooleanQuery} based on the parameters that have
      *  been set on this builder. */
     public BooleanQuery build() {
diff --git a/lucene/core/src/java/org/apache/lucene/search/Feature.java b/lucene/core/src/java/org/apache/lucene/search/Feature.java
new file mode 100644
index 0000000000..6b8896cee5
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/Feature.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.search;
+
+import java.io.IOException;
+
+import org.apache.lucene.index.IndexReader;
+
+/**
+ * Provides factors that can be linearly combined with a {@link Query} to
+ * affect scoring.
+ *
+ * @see BooleanQuery.Builder#add(Feature)
+ * @see org.apache.lucene.document.FeatureField
+ * @see org.apache.lucene.document.LongPoint#newDistanceFeature(String, float, long, long)
+ */
+public abstract class Feature {
+
+  /**
+   * Rewrite this Feature for a specific index
+   *
+   * Index-independent features may just return {@code this}
+   */
+  public abstract Feature rewrite(IndexReader reader) throws IOException;
+
+  /**
+   * Create a Weight for producing scores against a searcher
+   */
+  public abstract Weight createWeight(Query parent, IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException;
+
+  @Override
+  public abstract String toString();
+
+  @Override
+  public abstract boolean equals(Object other);
+
+  @Override
+  public abstract int hashCode();
+
+}
diff --git a/lucene/core/src/test/org/apache/lucene/document/TestFeatureField.java b/lucene/core/src/test/org/apache/lucene/document/TestFeatureField.java
index 6a0a33591d..701cded519 100644
--- a/lucene/core/src/test/org/apache/lucene/document/TestFeatureField.java
+++ b/lucene/core/src/test/org/apache/lucene/document/TestFeatureField.java
@@ -31,7 +31,9 @@ import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.Feature;
 import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.QueryUtils;
 import org.apache.lucene.search.ScoreMode;
@@ -88,8 +90,8 @@ public class TestFeatureField extends LuceneTestCase {
     IndexSearcher searcher = new IndexSearcher(reader);
     LeafReaderContext context = reader.leaves().get(0);
 
-    Query q = FeatureField.newLogQuery("features", "pagerank", 3f, 4.5f);
-    Weight w = q.createWeight(searcher, ScoreMode.TOP_SCORES, 2);
+    Feature q = FeatureField.newLogFeature("features", "pagerank", 3f, 4.5f);
+    Weight w = q.createWeight(new MatchAllDocsQuery(), searcher, ScoreMode.TOP_SCORES, 2);
     Scorer s = w.scorer(context);
 
     assertEquals(0, s.iterator().nextDoc());
@@ -106,8 +108,8 @@ public class TestFeatureField extends LuceneTestCase {
 
     assertEquals(DocIdSetIterator.NO_MORE_DOCS, s.iterator().nextDoc());
 
-    q = FeatureField.newSaturationQuery("features", "pagerank", 3f, 4.5f);
-    w = q.createWeight(searcher, ScoreMode.TOP_SCORES, 2);
+    q = FeatureField.newSaturationFeature("features", "pagerank", 3f, 4.5f);
+    w = q.createWeight(new MatchAllDocsQuery(), searcher, ScoreMode.TOP_SCORES, 2);
     s = w.scorer(context);
 
     assertEquals(0, s.iterator().nextDoc());
@@ -124,8 +126,8 @@ public class TestFeatureField extends LuceneTestCase {
 
     assertEquals(DocIdSetIterator.NO_MORE_DOCS, s.iterator().nextDoc());
 
-    q = FeatureField.newSigmoidQuery("features", "pagerank", 3f, 4.5f, 0.6f);
-    w = q.createWeight(searcher, ScoreMode.TOP_SCORES, 2);
+    q = FeatureField.newSigmoidFeature("features", "pagerank", 3f, 4.5f, 0.6f);
+    w = q.createWeight(new MatchAllDocsQuery(), searcher, ScoreMode.TOP_SCORES, 2);
     s = w.scorer(context);
     double kPa = Math.pow(4.5f, 0.6f);
 
@@ -143,8 +145,8 @@ public class TestFeatureField extends LuceneTestCase {
 
     assertEquals(DocIdSetIterator.NO_MORE_DOCS, s.iterator().nextDoc());
 
-    q = FeatureField.newSaturationQuery("features", "urlLen", 3f, 1f/24);
-    w = q.createWeight(searcher, ScoreMode.TOP_SCORES, 2);
+    q = FeatureField.newSaturationFeature("features", "urlLen", 3f, 1f/24);
+    w = q.createWeight(new MatchAllDocsQuery(), searcher, ScoreMode.TOP_SCORES, 2);
     s = w.scorer(context);
 
     assertEquals(0, s.iterator().nextDoc());
@@ -165,6 +167,10 @@ public class TestFeatureField extends LuceneTestCase {
     dir.close();
   }
 
+  private static Query wrapFeature(Feature feature) {
+    return new BooleanQuery.Builder().add(feature).build();
+  }
+
   public void testExplanations() throws Exception {
     Directory dir = newDirectory();
     RandomIndexWriter writer = new RandomIndexWriter(random(), dir, newIndexWriterConfig()
@@ -192,19 +198,19 @@ public class TestFeatureField extends LuceneTestCase {
 
     IndexSearcher searcher = new IndexSearcher(reader);
 
-    QueryUtils.check(random(), FeatureField.newLogQuery("features", "pagerank", 1f, 4.5f), searcher);
-    QueryUtils.check(random(), FeatureField.newSaturationQuery("features", "pagerank", 1f, 12f), searcher);
-    QueryUtils.check(random(), FeatureField.newSigmoidQuery("features", "pagerank", 1f, 12f, 0.6f), searcher);
+    QueryUtils.check(random(), wrapFeature(FeatureField.newLogFeature("features", "pagerank", 1f, 4.5f)), searcher);
+    QueryUtils.check(random(), wrapFeature(FeatureField.newSaturationFeature("features", "pagerank", 1f, 12f)), searcher);
+    QueryUtils.check(random(), wrapFeature(FeatureField.newSigmoidFeature("features", "pagerank", 1f, 12f, 0.6f)), searcher);
 
     // Test boosts that are > 1
-    QueryUtils.check(random(), FeatureField.newLogQuery("features", "pagerank", 3f, 4.5f), searcher);
-    QueryUtils.check(random(), FeatureField.newSaturationQuery("features", "pagerank", 3f, 12f), searcher);
-    QueryUtils.check(random(), FeatureField.newSigmoidQuery("features", "pagerank", 3f, 12f, 0.6f), searcher);
+    QueryUtils.check(random(), wrapFeature(FeatureField.newLogFeature("features", "pagerank", 3f, 4.5f)), searcher);
+    QueryUtils.check(random(), wrapFeature(FeatureField.newSaturationFeature("features", "pagerank", 3f, 12f)), searcher);
+    QueryUtils.check(random(), wrapFeature(FeatureField.newSigmoidFeature("features", "pagerank", 3f, 12f, 0.6f)), searcher);
 
     // Test boosts that are < 1
-    QueryUtils.check(random(), FeatureField.newLogQuery("features", "pagerank", .2f, 4.5f), searcher);
-    QueryUtils.check(random(), FeatureField.newSaturationQuery("features", "pagerank", .2f, 12f), searcher);
-    QueryUtils.check(random(), FeatureField.newSigmoidQuery("features", "pagerank", .2f, 12f, 0.6f), searcher);
+    QueryUtils.check(random(), wrapFeature(FeatureField.newLogFeature("features", "pagerank", .2f, 4.5f)), searcher);
+    QueryUtils.check(random(), wrapFeature(FeatureField.newSaturationFeature("features", "pagerank", .2f, 12f)), searcher);
+    QueryUtils.check(random(), wrapFeature(FeatureField.newSigmoidFeature("features", "pagerank", .2f, 12f, 0.6f)), searcher);
 
     reader.close();
     dir.close();
@@ -275,7 +281,7 @@ public class TestFeatureField extends LuceneTestCase {
   public void testExtractTerms() throws IOException {
     IndexReader reader = new MultiReader();
     IndexSearcher searcher = newSearcher(reader);
-    Query query = FeatureField.newLogQuery("field", "term", 2f, 42);
+    Query query = wrapFeature(FeatureField.newLogFeature("field", "term", 2f, 42));
 
     Weight weight = searcher.createWeight(query, ScoreMode.COMPLETE_NO_SCORES, 1f);
     Set<Term> terms = new HashSet<>();
@@ -331,10 +337,9 @@ public class TestFeatureField extends LuceneTestCase {
         .add(new TermQuery(new Term("body", "apache")), Occur.SHOULD)
         .add(new TermQuery(new Term("body", "lucene")), Occur.SHOULD)
         .build();
-    Query boost = FeatureField.newSaturationQuery("features", "pagerank");
     Query boostedQuery = new BooleanQuery.Builder()
         .add(query, Occur.MUST)
-        .add(boost, Occur.SHOULD)
+        .add(FeatureField.newSaturationFeature("features", "pagerank"))
         .build();
     TopDocs topDocs = searcher.search(boostedQuery, 10);
     assertEquals(4, topDocs.scoreDocs.length);
diff --git a/lucene/core/src/test/org/apache/lucene/document/TestLongDistanceFeatureQuery.java b/lucene/core/src/test/org/apache/lucene/document/TestLongDistanceFeature.java
similarity index 88%
rename from lucene/core/src/test/org/apache/lucene/document/TestLongDistanceFeatureQuery.java
rename to lucene/core/src/test/org/apache/lucene/document/TestLongDistanceFeature.java
index d8ae66ac53..8a1619d3c2 100644
--- a/lucene/core/src/test/org/apache/lucene/document/TestLongDistanceFeatureQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/document/TestLongDistanceFeature.java
@@ -23,7 +23,9 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.MultiReader;
 import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.Feature;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.QueryUtils;
@@ -33,23 +35,27 @@ import org.apache.lucene.search.TopScoreDocCollector;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 
-public class TestLongDistanceFeatureQuery extends LuceneTestCase {
+public class TestLongDistanceFeature extends LuceneTestCase {
+
+  private static Query wrapFeature(Feature feature) {
+    return new BooleanQuery.Builder().add(feature).build();
+  }
 
   public void testEqualsAndHashcode() {
-    Query q1 = LongPoint.newDistanceFeatureQuery("foo", 3, 10, 5);
-    Query q2 = LongPoint.newDistanceFeatureQuery("foo", 3, 10, 5);
+    Query q1 = wrapFeature(LongPoint.newDistanceFeature("foo", 3, 10, 5));
+    Query q2 = wrapFeature(LongPoint.newDistanceFeature("foo", 3, 10, 5));
     QueryUtils.checkEqual(q1, q2);
 
-    Query q3 = LongPoint.newDistanceFeatureQuery("bar", 3, 10, 5);
+    Query q3 = wrapFeature(LongPoint.newDistanceFeature("bar", 3, 10, 5));
     QueryUtils.checkUnequal(q1, q3);
 
-    Query q4 = LongPoint.newDistanceFeatureQuery("foo", 4, 10, 5);
+    Query q4 = wrapFeature(LongPoint.newDistanceFeature("foo", 4, 10, 5));
     QueryUtils.checkUnequal(q1, q4);
 
-    Query q5 = LongPoint.newDistanceFeatureQuery("foo", 3, 9, 5);
+    Query q5 = wrapFeature(LongPoint.newDistanceFeature("foo", 3, 9, 5));
     QueryUtils.checkUnequal(q1, q5);
 
-    Query q6 = LongPoint.newDistanceFeatureQuery("foo", 3, 10, 6);
+    Query q6 = wrapFeature(LongPoint.newDistanceFeature("foo", 3, 10, 6));
     QueryUtils.checkUnequal(q1, q6);
   }
 
@@ -86,7 +92,7 @@ public class TestLongDistanceFeatureQuery extends LuceneTestCase {
     DirectoryReader reader = w.getReader();
     IndexSearcher searcher = newSearcher(reader);
     
-    Query q = LongPoint.newDistanceFeatureQuery("foo", 3, 10, 5);
+    Query q = wrapFeature(LongPoint.newDistanceFeature("foo", 3, 10, 5));
     TopScoreDocCollector collector = TopScoreDocCollector.create(2, null, 1);
     searcher.search(q, collector);
     TopDocs topHits = collector.topDocs();
@@ -99,7 +105,7 @@ public class TestLongDistanceFeatureQuery extends LuceneTestCase {
         },
         topHits.scoreDocs);
 
-    q = LongPoint.newDistanceFeatureQuery("foo", 3, 7, 5);
+    q = wrapFeature(LongPoint.newDistanceFeature("foo", 3, 7, 5));
     collector = TopScoreDocCollector.create(2, null, 1);
     searcher.search(q, collector);
     topHits = collector.topDocs();
@@ -151,7 +157,7 @@ public class TestLongDistanceFeatureQuery extends LuceneTestCase {
     DirectoryReader reader = w.getReader();
     IndexSearcher searcher = newSearcher(reader);
     
-    Query q = LongPoint.newDistanceFeatureQuery("foo", 3, Long.MAX_VALUE - 1, 100);
+    Query q = wrapFeature(LongPoint.newDistanceFeature("foo", 3, Long.MAX_VALUE - 1, 100));
     TopScoreDocCollector collector = TopScoreDocCollector.create(2, null, 1);
     searcher.search(q, collector);
     TopDocs topHits = collector.topDocs();
@@ -164,7 +170,7 @@ public class TestLongDistanceFeatureQuery extends LuceneTestCase {
         },
         topHits.scoreDocs);
 
-    q = LongPoint.newDistanceFeatureQuery("foo", 3, Long.MIN_VALUE + 1, 100);
+    q = wrapFeature(LongPoint.newDistanceFeature("foo", 3, Long.MIN_VALUE + 1, 100));
     collector = TopScoreDocCollector.create(2, null, 1);
     searcher.search(q, collector);
     topHits = collector.topDocs();
@@ -187,7 +193,7 @@ public class TestLongDistanceFeatureQuery extends LuceneTestCase {
     IndexReader reader = new MultiReader();
     IndexSearcher searcher = newSearcher(reader);
     
-    Query q = LongPoint.newDistanceFeatureQuery("foo", 3, 10, 5);
+    Query q = wrapFeature(LongPoint.newDistanceFeature("foo", 3, 10, 5));
     TopDocs topHits = searcher.search(q, 2);
     assertEquals(0, topHits.totalHits.value);
   }
@@ -215,7 +221,7 @@ public class TestLongDistanceFeatureQuery extends LuceneTestCase {
     DirectoryReader reader = w.getReader();
     IndexSearcher searcher = newSearcher(reader);
     
-    Query q = LongPoint.newDistanceFeatureQuery("foo", 3, 10, 5);
+    Query q = wrapFeature(LongPoint.newDistanceFeature("foo", 3, 10, 5));
     TopScoreDocCollector collector = TopScoreDocCollector.create(3, null, 1);
     searcher.search(q, collector);
     TopDocs topHits = collector.topDocs();
@@ -278,7 +284,7 @@ public class TestLongDistanceFeatureQuery extends LuceneTestCase {
     DirectoryReader reader = w.getReader();
     IndexSearcher searcher = newSearcher(reader);
     
-    Query q = LongPoint.newDistanceFeatureQuery("foo", 3, 10, 5);
+    Query q = wrapFeature(LongPoint.newDistanceFeature("foo", 3, 10, 5));
     TopScoreDocCollector collector = TopScoreDocCollector.create(2, null, 1);
     searcher.search(q, collector);
     TopDocs topHits = collector.topDocs();
@@ -291,7 +297,7 @@ public class TestLongDistanceFeatureQuery extends LuceneTestCase {
         },
         topHits.scoreDocs);
 
-    q = LongPoint.newDistanceFeatureQuery("foo", 3, 7, 5);
+    q = wrapFeature(LongPoint.newDistanceFeature("foo", 3, 7, 5));
     collector = TopScoreDocCollector.create(2, null, 1);
     searcher.search(q, collector);
     topHits = collector.topDocs();
@@ -338,7 +344,7 @@ public class TestLongDistanceFeatureQuery extends LuceneTestCase {
         pivotDistance = random().nextLong();
       } while (pivotDistance <= 0);
       float boost = (1 + random().nextInt(10)) / 3f;
-      Query q = LongPoint.newDistanceFeatureQuery("foo", boost, origin, pivotDistance);
+      Query q = wrapFeature(LongPoint.newDistanceFeature("foo", boost, origin, pivotDistance));
 
       CheckHits.checkTopScores(random(), q, searcher);
     }
