diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointDistanceQuery.java b/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointDistanceQuery.java
new file mode 100644
index 0000000..725e354
--- /dev/null
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointDistanceQuery.java
@@ -0,0 +1,123 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.util.AttributeSource;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.GeoDistanceUtils;
+import org.apache.lucene.util.GeoUtils;
+import org.apache.lucene.util.NumericUtils;
+import org.apache.lucene.util.SloppyMath;
+
+/** Implements a simple point distance query on a GeoPoint field. This is based on
+ * {@link GeoPointInPolygonQuery} and is implemented using a two phase approach. First,
+ * like {@link GeoPointInBBoxQuery} candidate terms are queried using the numeric ranges based on
+ * the morton codes of the min and max lat/lon pairs that intersect a polygonal representation of the
+ * circle (see {@link org.apache.lucene.util.GeoUtils#circleToPoly}. Terms
+ * passing this initial filter are then passed to a secondary filter that verifies whether the
+ * decoded lat/lon point fall within the specified query distance. All value comparisons are subject
+ * to the same precision tolerance defined in {@value org.apache.lucene.util.GeoUtils#TOLERANCE}
+ *
+ *    @lucene.experimental
+ */
+public class GeoPointDistanceQuery extends GeoPointInBBoxQuery {
+  private final double centerLon;
+  private final double centerLat;
+  private final double radius;
+
+  public GeoPointDistanceQuery(final String field, final double centerLon, final double centerLat, final double radius) {
+    this(field, computeBBox(centerLon, centerLat, radius), centerLon, centerLat, radius);
+  }
+
+  private GeoPointDistanceQuery(final String field, GeoBoundingBox bbox, final double centerLon,
+                                final double centerLat, final double radius) {
+    super(field, bbox.minLon, bbox.minLat, bbox.maxLon, bbox.maxLat);
+    this.centerLon = centerLon;
+    this.centerLat = centerLat;
+    this.radius = radius;
+  }
+
+  @Override @SuppressWarnings("unchecked")
+  protected TermsEnum getTermsEnum(final Terms terms, AttributeSource atts) throws IOException {
+    final Long min = GeoUtils.mortonHash(minLon, minLat);
+    final Long max = Math.abs(GeoUtils.mortonHash(maxLon, maxLat));
+    if (min != null && max != null &&  min.compareTo(max) > 0) {
+      return TermsEnum.EMPTY;
+    }
+    return new GeoPointRadiusTermsEnum(terms.iterator(), atts, minLon, minLat, maxLon, maxLat);
+  }
+
+  private final class GeoPointRadiusTermsEnum extends GeoPointTermsEnum {
+    GeoPointRadiusTermsEnum(final TermsEnum tenum, AttributeSource atts, final double minLon, final double minLat,
+                        final double maxLon, final double maxLat) {
+      super(tenum, atts, minLon, minLat, maxLon, maxLat);
+    }
+
+    @Override
+    protected boolean cellCrosses(final double minLon, final double minLat, final double maxLon, final double maxLat) {
+      return GeoUtils.rectCrossesCircle(minLon, minLat, maxLon, maxLat, centerLon, centerLat, radius);
+    }
+
+    @Override
+    protected boolean cellWithin(final double minLon, final double minLat, final double maxLon, final double maxLat) {
+      return GeoUtils.rectWithinCircle(minLon, minLat, maxLon, maxLat, centerLon, centerLat, radius);
+    }
+
+    /**
+     * The two-phase query approach. The parent
+     * {@link org.apache.lucene.search.GeoPointTermsEnum#accept} method is called to match
+     * encoded terms that fall within the bounding box of the polygon. Those documents that pass the initial
+     * bounding box filter are then compared to the provided polygon using the
+     * {@link org.apache.lucene.util.GeoUtils#pointInPolygon} method.
+     *
+     * @param term term for candidate document
+     * @return match status
+     */
+    @Override
+    protected final AcceptStatus accept(BytesRef term) {
+      // first filter by bounding box
+      AcceptStatus status = super.accept(term);
+      assert status != AcceptStatus.YES_AND_SEEK;
+
+      if (status != AcceptStatus.YES) {
+        return status;
+      }
+
+      final long val = NumericUtils.prefixCodedToLong(term);
+      final double lon = GeoUtils.mortonUnhashLon(val);
+      final double lat = GeoUtils.mortonUnhashLat(val);
+      // post-filter by distance
+      if (!(SloppyMath.haversin(centerLon, centerLat, lon, lat) <= radius)) {
+        return AcceptStatus.NO;
+      }
+
+      return AcceptStatus.YES;
+    }
+  }
+
+  protected static GeoBoundingBox computeBBox(final double centerLon, final double centerLat, final double radius) {
+    final double lonDistDeg = GeoDistanceUtils.distanceToDegreesLon(centerLat, radius);
+    final double latDistDeg = GeoDistanceUtils.distanceToDegreesLat(centerLat, radius);
+
+    return new GeoBoundingBox(centerLon - lonDistDeg, centerLon + lonDistDeg, centerLat - latDistDeg, centerLat + latDistDeg);
+  }
+}
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointInPolygonQuery.java b/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointInPolygonQuery.java
index 327c681..ea58f0e 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointInPolygonQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointInPolygonQuery.java
@@ -47,11 +47,11 @@ import java.util.Arrays;
  *
  *    @lucene.experimental
  */
-public final class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
+public class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
   // polygon position arrays - this avoids the use of any objects or
   // or geo library dependencies
-  private final double[] x;
-  private final double[] y;
+  protected final double[] x;
+  protected final double[] y;
 
   /**
    * Constructs a new GeoPolygonQuery that will match encoded {@link org.apache.lucene.document.GeoPointField} terms
@@ -222,7 +222,7 @@ public final class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
     }
   }
 
-  private static GeoBoundingBox computeBBox(double[] polyLons, double[] polyLats) {
+  protected static GeoBoundingBox computeBBox(double[] polyLons, double[] polyLats) {
     if (polyLons.length != polyLats.length) {
       throw new IllegalArgumentException("polyLons and polyLats must be equal length");
     }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/util/GeoDistanceUtils.java b/lucene/sandbox/src/java/org/apache/lucene/util/GeoDistanceUtils.java
new file mode 100644
index 0000000..110605c
--- /dev/null
+++ b/lucene/sandbox/src/java/org/apache/lucene/util/GeoDistanceUtils.java
@@ -0,0 +1,126 @@
+package org.apache.lucene.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Reusable geo-spatial distance utility methods.
+ *
+ * @lucene.experimental
+ */
+public class GeoDistanceUtils {
+
+  /**
+   * Compute the distance between two geo-points using vincenty distance formula
+   * Vincenty uses the oblate spheroid whereas haversine uses unit sphere, this will give roughly
+   * 22m better accuracy (in worst case) than haversine
+   *
+   * @param lonA longitudinal coordinate of point A (in degrees)
+   * @param latA latitudinal coordinate of point A (in degrees)
+   * @param lonB longitudinal coordinate of point B (in degrees)
+   * @param latB latitudinal coordinate of point B (in degrees)
+   * @return distance (in meters) between point A and point B
+   */
+  public static final double vincentyDistance(final double lonA, final double latA, final double lonB, final double latB) {
+    final double L = StrictMath.toRadians(lonB - lonA);
+    final double oF = 1 - GeoProjectionUtils.FLATTENING;
+    final double U1 = StrictMath.atan(oF * StrictMath.tan(StrictMath.toRadians(latA)));
+    final double U2 = StrictMath.atan(oF * StrictMath.tan(StrictMath.toRadians(latB)));
+    final double sU1 = StrictMath.sin(U1);
+    final double cU1 = StrictMath.cos(U1);
+    final double sU2 = StrictMath.sin(U2);
+    final double cU2 = StrictMath.cos(U2);
+
+    double sigma, sinSigma, cosSigma;
+    double sinAlpha, cos2Alpha, cos2SigmaM;
+    double lambda = L;
+    double lambdaP;
+    double iters = 100;
+    double sinLambda, cosLambda, c;
+
+    do {
+      sinLambda = StrictMath.sin(lambda);
+      cosLambda = Math.cos(lambda);
+      sinSigma = Math.sqrt(	(cU2 * sinLambda) * (cU2 * sinLambda) + (cU1 * sU2 - sU1 * cU2 * cosLambda)
+          * (cU1 * sU2 - sU1 * cU2 * cosLambda));
+      if (sinSigma == 0)
+        return 0;
+
+      cosSigma = sU1 * sU2 + cU1 * cU2 * cosLambda;
+      sigma = Math.atan2(sinSigma, cosSigma);
+      sinAlpha = cU1 * cU2 * sinLambda / sinSigma;
+      cos2Alpha = 1 - sinAlpha * sinAlpha;
+      cos2SigmaM = cosSigma - 2 * sU1 * sU2 / cos2Alpha;
+
+      c = GeoProjectionUtils.FLATTENING/16 * cos2Alpha * (4 + GeoProjectionUtils.FLATTENING * (4 - 3 * cos2Alpha));
+      lambdaP = lambda;
+      lambda = 	L + (1 - c) * GeoProjectionUtils.FLATTENING * sinAlpha * (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma *
+          (-1 + 2 * cos2SigmaM * cos2SigmaM)));
+    } while (StrictMath.abs(lambda - lambdaP) > 1E-12 && --iters > 0);
+
+    if (iters == 0)
+      return 0;
+
+    final double uSq = cos2Alpha * (GeoProjectionUtils.SEMIMAJOR_AXIS2 - GeoProjectionUtils.SEMIMINOR_AXIS2) / (GeoProjectionUtils.SEMIMINOR_AXIS2);
+    final double A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
+    final double B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
+    final double deltaSigma = B * sinSigma * (cos2SigmaM + B/4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B/6 * cos2SigmaM
+        * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
+
+    return GeoProjectionUtils.SEMIMINOR_AXIS * A * (sigma - deltaSigma);
+  }
+
+  /**
+   * Compute the inverse haversine to determine distance in degrees longitude for provided distance in meters
+   * @param lat latitude to compute delta degrees lon
+   * @param distance distance in meters to convert to degrees lon
+   * @return Sloppy distance in degrees longitude for provided distance in kilometers
+   */
+  public static double distanceToDegreesLon(double lat, double distance) {
+    // convert latitude to radians
+    lat = StrictMath.toRadians(lat);
+
+    // get the diameter at the latitude
+    final double diameter = SloppyMath.earthDiameter(StrictMath.toRadians(lat));
+
+    // compute inverse haversine
+    double a = StrictMath.sin(distance/diameter);
+    double h = StrictMath.min(1, a);
+    h *= h;
+    double cLat = StrictMath.cos(lat);
+
+    return StrictMath.toDegrees(StrictMath.acos(1-((2d*h)/(cLat*cLat))));
+  }
+
+  /**
+   * Compute the inverse haversine to determine distance in degrees longitude for provided distance in meters
+   * @param lat latitude to compute delta degrees lon
+   * @param distance distance in meters to convert to degrees lon
+   * @return Sloppy distance in degrees longitude for provided distance in kilometers
+   */
+  public static double distanceToDegreesLat(double lat, double distance) {
+    // get the diameter at the latitude
+    final double diameter = SloppyMath.earthDiameter(StrictMath.toRadians(lat));
+
+    // compute inverse haversine
+    double a = StrictMath.sin(distance/diameter);
+    double h = StrictMath.min(1, a);
+    h *= h;
+
+    return StrictMath.toDegrees(StrictMath.acos(1-(2d*h)));
+  }
+}
diff --git a/lucene/sandbox/src/java/org/apache/lucene/util/GeoProjectionUtils.java b/lucene/sandbox/src/java/org/apache/lucene/util/GeoProjectionUtils.java
new file mode 100644
index 0000000..21e3ec5
--- /dev/null
+++ b/lucene/sandbox/src/java/org/apache/lucene/util/GeoProjectionUtils.java
@@ -0,0 +1,374 @@
+package org.apache.lucene.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Reusable geo-spatial projection utility methods.
+ *
+ * @lucene.experimental
+ */
+public class GeoProjectionUtils {
+  // WGS84 earth-ellipsoid major (a) minor (b) radius, (f) flattening and eccentricity (e)
+  static final double SEMIMAJOR_AXIS = 6_378_137; // [m]
+  static final double FLATTENING = 1.0/298.257223563;
+  static final double SEMIMINOR_AXIS = SEMIMAJOR_AXIS * (1.0 - FLATTENING); //6_356_752.31420; // [m]
+  static final double ECCENTRICITY = StrictMath.sqrt((2.0 - FLATTENING) * FLATTENING);
+  static final double PI_OVER_2 = StrictMath.PI / 2.0D;
+  static final double SEMIMAJOR_AXIS2 = SEMIMAJOR_AXIS * SEMIMAJOR_AXIS;
+  static final double SEMIMINOR_AXIS2 = SEMIMINOR_AXIS * SEMIMINOR_AXIS;
+
+  /**
+   * Converts from geocentric earth-centered earth-fixed to geodesic lat/lon/alt
+   * @param x Cartesian x coordinate
+   * @param y Cartesian y coordinate
+   * @param z Cartesian z coordinate
+   * @param lla 0: longitude 1: latitude: 2: altitude
+   * @return double array as 0: longitude 1: latitude 2: altitude
+   */
+  public static final double[] ecfToLLA(final double x, final double y, final double z, double[] lla) {
+    boolean atPole = false;
+    final double ad_c = 1.0026000D;
+    final double e2 = (SEMIMAJOR_AXIS2 - SEMIMINOR_AXIS2)/(SEMIMAJOR_AXIS2);
+    final double ep2 = (SEMIMAJOR_AXIS2 - SEMIMINOR_AXIS2)/(SEMIMINOR_AXIS2);
+    final double cos67P5 = 0.38268343236508977D;
+
+    if (lla == null)
+      lla = new double[3];
+
+    if (x != 0.0) {
+      lla[0] = StrictMath.atan2(y,x);
+    } else {
+      if (y > 0) {
+        lla[0] = PI_OVER_2;
+      } else if (y < 0) {
+        lla[0] = -PI_OVER_2;
+      } else {
+        atPole = true;
+        lla[0] = 0.0D;
+        if (z > 0.0) {
+          lla[1] = PI_OVER_2;
+        } else if (z < 0.0) {
+          lla[1] = -PI_OVER_2;
+        } else {
+          lla[1] = PI_OVER_2;
+          lla[2] = -SEMIMINOR_AXIS;
+          return lla;
+        }
+      }
+    }
+
+    final double w2 = x*x + y*y;
+    final double w = StrictMath.sqrt(w2);
+    final double t0 = z * ad_c;
+    final double s0 = StrictMath.sqrt(t0 * t0 + w2);
+    final double sinB0 = t0 / s0;
+    final double cosB0 = w / s0;
+    final double sin3B0 = sinB0 * sinB0 * sinB0;
+    final double t1 = z + SEMIMINOR_AXIS * ep2 * sin3B0;
+    final double sum = w - SEMIMAJOR_AXIS * e2 * cosB0 * cosB0 * cosB0;
+    final double s1 = StrictMath.sqrt(t1 * t1 + sum * sum);
+    final double sinP1 = t1 / s1;
+    final double cosP1 = sum / s1;
+    final double rn = SEMIMAJOR_AXIS / StrictMath.sqrt(1.0D - e2 * sinP1 * sinP1);
+
+    if (cosP1 >= cos67P5) {
+      lla[2] = w / cosP1 - rn;
+    } else if (cosP1 <= -cos67P5) {
+      lla[2] = w / -cosP1 - rn;
+    } else {
+      lla[2] = z / sinP1 + rn * (e2 - 1.0);
+    }
+    if (!atPole) {
+      lla[1] = StrictMath.atan(sinP1/cosP1);
+    }
+    lla[0] = StrictMath.toDegrees(lla[0]);
+    lla[1] = StrictMath.toDegrees(lla[1]);
+
+    return lla;
+  }
+
+  /**
+   * Converts from geodesic lon lat alt to geocentric earth-centered earth-fixed
+   * @param lon geodesic longitude
+   * @param lat geodesic latitude
+   * @param alt geodesic altitude
+   * @param ecf reusable earth-centered earth-fixed result
+   * @return either a new ecef array or the reusable ecf parameter
+   */
+  public static final double[] llaToECF(double lon, double lat, double alt, double[] ecf) {
+    lon = StrictMath.toRadians(lon);
+    lat = StrictMath.toRadians(lat);
+
+    final double sl = StrictMath.sin(lat);
+    final double s2 = sl*sl;
+    final double cl = StrictMath.cos(lat);
+    final double ge2 = (SEMIMAJOR_AXIS2 - SEMIMINOR_AXIS2)/(SEMIMAJOR_AXIS2);
+
+    if (ecf == null)
+      ecf = new double[3];
+
+    if (lat < -PI_OVER_2 && lat > -1.001D * PI_OVER_2) {
+      lat = -PI_OVER_2;
+    } else if (lat > PI_OVER_2 && lat < 1.001D * PI_OVER_2) {
+      lat = PI_OVER_2;
+    }
+    assert ((lat >= -PI_OVER_2) || (lat <= PI_OVER_2));
+
+    if (lon > StrictMath.PI) {
+      lon -= (2*StrictMath.PI);
+    }
+
+    final double rn = SEMIMAJOR_AXIS / StrictMath.sqrt(1.0D - ge2 * s2);
+    ecf[0] = (rn+alt) * cl * StrictMath.cos(lon);
+    ecf[1] = (rn+alt) * cl * StrictMath.sin(lon);
+    ecf[2] = ((rn*(1.0-ge2))+alt)*sl;
+
+    return ecf;
+  }
+
+  /**
+   * Converts from lat lon alt (in degrees) to East North Up right-hand coordinate system
+   * @param lon longitude in degrees
+   * @param lat latitude in degrees
+   * @param alt altitude in meters
+   * @param centerLon reference point longitude in degrees
+   * @param centerLat reference point latitude in degrees
+   * @param centerAlt reference point altitude in meters
+   * @param enu result east, north, up coordinate
+   * @return east, north, up coordinate
+   */
+  public static double[] llaToENU(final double lon, final double lat, final double alt, double centerLon,
+                                  double centerLat, final double centerAlt, double[] enu) {
+    if (enu == null)
+      enu = new double[3];
+
+    // convert point to ecf coordinates
+    final double[] ecf = llaToECF(lon, lat, alt, null);
+
+    // convert from ecf to enu
+    return ecfToENU(ecf[0], ecf[1], ecf[2], centerLon, centerLat, centerAlt, enu);
+  }
+
+  /**
+   * Converts from East North Up right-hand rule to lat lon alt in degrees
+   * @param x easting (in meters)
+   * @param y northing (in meters)
+   * @param z up (in meters)
+   * @param centerLon reference point longitude (in degrees)
+   * @param centerLat reference point latitude (in degrees)
+   * @param centerAlt reference point altitude (in meters)
+   * @param lla resulting lat, lon, alt point (in degrees)
+   * @return lat, lon, alt point (in degrees)
+   */
+  public static double[] enuToLLA(final double x, final double y, final double z, final double centerLon,
+                                  final double centerLat, final double centerAlt, double[] lla) {
+    // convert enuToECF
+    if (lla == null)
+      lla = new double[3];
+
+    // convert enuToECF, storing intermediate result in lla
+    lla = enuToECF(x, y, z, centerLon, centerLat, centerAlt, lla);
+
+    // convert ecf to LLA
+    return ecfToLLA(lla[0], lla[1], lla[2], lla);
+  }
+
+  /**
+   * Convert from Earth-Centered-Fixed to Easting, Northing, Up Right Hand System
+   * @param x ECF X coordinate (in meters)
+   * @param y ECF Y coordinate (in meters)
+   * @param z ECF Z coordinate (in meters)
+   * @param centerLon ENU origin longitude (in degrees)
+   * @param centerLat ENU origin latitude (in degrees)
+   * @param centerAlt ENU altitude (in meters)
+   * @param enu reusable enu result
+   * @return Easting, Northing, Up coordinate
+   */
+  public static double[] ecfToENU(double x, double y, double z, final double centerLon,
+                                  final double centerLat, final double centerAlt, double[] enu) {
+    if (enu == null)
+      enu = new double[3];
+
+    // create rotation matrix and rotate to enu orientation
+    final double[][] phi = createPhiTransform(centerLon, centerLat, null);
+
+    // convert origin to ENU
+    final double[] originECF = llaToECF(centerLon, centerLat, centerAlt, null);
+    final double[] originENU = new double[3];
+    originENU[0] = ((phi[0][0] * originECF[0]) + (phi[0][1] * originECF[1]) + (phi[0][2] * originECF[2]));
+    originENU[1] = ((phi[1][0] * originECF[0]) + (phi[1][1] * originECF[1]) + (phi[1][2] * originECF[2]));
+    originENU[2] = ((phi[2][0] * originECF[0]) + (phi[2][1] * originECF[1]) + (phi[2][2] * originECF[2]));
+
+    // rotate then translate
+    enu[0] = ((phi[0][0] * x) + (phi[0][1] * y) + (phi[0][2] * z)) - originENU[0];
+    enu[1] = ((phi[1][0] * x) + (phi[1][1] * y) + (phi[1][2] * z)) - originENU[1];
+    enu[2] = ((phi[2][0] * x) + (phi[2][1] * y) + (phi[2][2] * z)) - originENU[2];
+
+    return enu;
+  }
+
+  /**
+   * Convert from Easting, Northing, Up Right-Handed system to Earth Centered Fixed system
+   * @param x ENU x coordinate (in meters)
+   * @param y ENU y coordinate (in meters)
+   * @param z ENU z coordinate (in meters)
+   * @param centerLon ENU origin longitude (in degrees)
+   * @param centerLat ENU origin latitude (in degrees)
+   * @param centerAlt ENU origin altitude (in meters)
+   * @param ecf reusable ecf result
+   * @return ecf result coordinate
+   */
+  public static double[] enuToECF(final double x, final double y, final double z, double centerLon,
+                                  double centerLat, final double centerAlt, double[] ecf) {
+    if (ecf == null)
+      ecf = new double[3];
+
+    double[][] phi = createTransposedPhiTransform(centerLon, centerLat, null);
+    double[] ecfOrigin = llaToECF(centerLon, centerLat, centerAlt, null);
+
+    // rotate and translate
+    ecf[0] = (phi[0][0]*x + phi[0][1]*y + phi[0][2]*z) + ecfOrigin[0];
+    ecf[1] = (phi[1][0]*x + phi[1][1]*y + phi[1][2]*z) + ecfOrigin[1];
+    ecf[2] = (phi[2][0]*x + phi[2][1]*y + phi[2][2]*z) + ecfOrigin[2];
+
+    return ecf;
+  }
+
+  /**
+   * Create the rotation matrix for converting Earth Centered Fixed to Easting Northing Up
+   * @param originLon ENU origin longitude (in degrees)
+   * @param originLat ENU origin latitude (in degrees)
+   * @param phiMatrix reusable phi matrix result
+   * @return phi rotation matrix
+   */
+  private static double[][] createPhiTransform(double originLon, double originLat, double[][] phiMatrix) {
+    if (phiMatrix == null)
+      phiMatrix = new double[3][3];
+
+    originLon = StrictMath.toRadians(originLon);
+    originLat = StrictMath.toRadians(originLat);
+
+    final double sLon = StrictMath.sin(originLon);
+    final double cLon = StrictMath.cos(originLon);
+    final double sLat = StrictMath.sin(originLat);
+    final double cLat = StrictMath.cos(originLat);
+
+    phiMatrix[0][0] = -sLon;
+    phiMatrix[0][1] = cLon;
+    phiMatrix[0][2] = 0.0D;
+    phiMatrix[1][0] = -sLat * cLon;
+    phiMatrix[1][1] = -sLat * sLon;
+    phiMatrix[1][2] = cLat;
+    phiMatrix[2][0] = cLat * cLon;
+    phiMatrix[2][1] = cLat * sLon;
+    phiMatrix[2][2] = sLat;
+
+    return phiMatrix;
+  }
+
+  /**
+   * Create the transposed rotation matrix for converting Easting Northing Up coordinates to Earth Centered Fixed
+   * @param originLon ENU origin longitude (in degrees)
+   * @param originLat ENU origin latitude (in degrees)
+   * @param phiMatrix reusable phi rotation matrix result
+   * @return transposed phi rotation matrix
+   */
+  private static double[][] createTransposedPhiTransform(double originLon, double originLat, double[][] phiMatrix) {
+    if (phiMatrix == null)
+      phiMatrix = new double[3][3];
+
+    originLon = StrictMath.toRadians(originLon);
+    originLat = StrictMath.toRadians(originLat);
+
+    final double sLat = StrictMath.sin(originLat);
+    final double cLat = StrictMath.cos(originLat);
+    final double sLon = StrictMath.sin(originLon);
+    final double cLon = StrictMath.cos(originLon);
+
+    phiMatrix[0][0] = -sLon;
+    phiMatrix[1][0] = cLon;
+    phiMatrix[2][0] = 0.0D;
+    phiMatrix[0][1] = -sLat * cLon;
+    phiMatrix[1][1] = -sLat * sLon;
+    phiMatrix[2][1] = cLat;
+    phiMatrix[0][2] = cLat * cLon;
+    phiMatrix[1][2] = cLat * sLon;
+    phiMatrix[2][2] = sLat;
+
+    return phiMatrix;
+  }
+
+  /**
+   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula
+   *
+   * @param lon origin longitude in degrees
+   * @param lat origin latitude in degrees
+   * @param bearing azimuthal bearing in degrees
+   * @param dist distance in kilometers
+   * @param pt resulting point
+   * @return the point along a bearing at a given distance in kilometers
+   */
+  public static final double[] pointFromLonLatBearing(double lon, double lat, double bearing, double dist, double[] pt) {
+    if (pt == null)
+      pt = new double[2];
+
+    // convert from kilometers to meters
+    dist *= 1000;
+
+    final double alpha1 = StrictMath.toRadians(bearing);
+    final double cosA1 = StrictMath.cos(alpha1);
+    final double sinA1 = StrictMath.sin(alpha1);
+    final double tanU1 = (1-FLATTENING) * StrictMath.tan(StrictMath.toRadians(lat));
+    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));
+    final double sinU1 = tanU1*cosU1;
+    final double sig1 = StrictMath.atan2(tanU1, cosA1);
+    final double sinAlpha = cosU1 * sinA1;
+    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;
+    final double uSq = cosSqAlpha * (SEMIMAJOR_AXIS2 - SEMIMINOR_AXIS2) / SEMIMINOR_AXIS2;
+    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));
+    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));
+
+    double sigma = dist / (SEMIMINOR_AXIS*A);
+    double sigmaP;
+    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;
+
+    do {
+      cos2SigmaM = StrictMath.cos(2*sig1 + sigma);
+      sinSigma = StrictMath.sin(sigma);
+      cosSigma = StrictMath.cos(sigma);
+
+      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-
+          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));
+      sigmaP = sigma;
+      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;
+    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);
+
+    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;
+    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,
+        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));
+    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);
+    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));
+
+    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *
+        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));
+    pt[0] = lon + StrictMath.toDegrees(lam);
+    pt[1] = StrictMath.toDegrees(lat2);
+
+    return pt;
+  }
+}
diff --git a/lucene/sandbox/src/java/org/apache/lucene/util/GeoUtils.java b/lucene/sandbox/src/java/org/apache/lucene/util/GeoUtils.java
index 2bee100..ec42780 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/util/GeoUtils.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/util/GeoUtils.java
@@ -17,21 +17,14 @@ package org.apache.lucene.util;
  * limitations under the License.
  */
 
+import java.util.ArrayList;
+
 /**
  * Basic reusable geo-spatial utility methods
  *
  * @lucene.experimental
  */
 public final class GeoUtils {
-  // WGS84 earth-ellipsoid major (a) minor (b) radius, (f) flattening and eccentricity (e)
-  private static final double SEMIMAJOR_AXIS = 6_378_137; // [m]
-  private static final double FLATTENING = 1.0/298.257223563;
-  private static final double SEMIMINOR_AXIS = SEMIMAJOR_AXIS * (1.0 - FLATTENING); //6_356_752.31420; // [m]
-  private static final double ECCENTRICITY = StrictMath.sqrt((2.0 - FLATTENING) * FLATTENING);
-  private static final double PI_OVER_2 = StrictMath.PI / 2.0D;
-  private static final double SEMIMAJOR_AXIS2 = SEMIMAJOR_AXIS * SEMIMINOR_AXIS;
-  private static final double SEMIMINOR_AXIS2 = SEMIMINOR_AXIS * SEMIMINOR_AXIS;
-
   private static final short MIN_LON = -180;
   private static final short MIN_LAT = -90;
   public static final short BITS = 31;
@@ -95,115 +88,6 @@ public final class GeoUtils {
   }
 
   /**
-   * Converts from geodesic lon lat alt to geocentric earth-centered earth-fixed
-   * @param lon geodesic longitude
-   * @param lat geodesic latitude
-   * @param alt geodesic altitude
-   * @param ecf reusable earth-centered earth-fixed result
-   * @return either a new ecef array or the reusable ecf parameter
-   */
-  public static final double[] llaToECF(double lon, double lat, double alt, double[] ecf) {
-    lon = StrictMath.toRadians(lon);
-    lat = StrictMath.toRadians(lat);
-
-    final double sl = StrictMath.sin(lat);
-    final double s2 = sl*sl;
-    final double cl = StrictMath.cos(lat);
-    final double ge2 = (SEMIMAJOR_AXIS2 - SEMIMINOR_AXIS2)/(SEMIMAJOR_AXIS2);
-
-    if (ecf == null)
-      ecf = new double[3];
-
-    if (lat < -PI_OVER_2 && lat > -1.001D * PI_OVER_2) {
-      lat = -PI_OVER_2;
-    } else if (lat > PI_OVER_2 && lat < 1.001D * PI_OVER_2) {
-      lat = PI_OVER_2;
-    }
-    assert ((lat >= -PI_OVER_2) || (lat <= PI_OVER_2));
-
-    if (lon > StrictMath.PI) {
-      lon -= (2*StrictMath.PI);
-    }
-
-    final double rn = SEMIMAJOR_AXIS / StrictMath.sqrt(1.0D - ge2 * s2);
-    ecf[0] = (rn+alt) * cl * StrictMath.cos(lon);
-    ecf[1] = (rn+alt) * cl * StrictMath.sin(lon);
-    ecf[2] = ((rn*(1.0-ge2))+alt)*sl;
-
-    return ecf;
-  }
-
-  /**
-   * Converts from geocentric earth-centered earth-fixed to geodesic lat/lon/alt
-   * @param x Cartesian x coordinate
-   * @param y Cartesian y coordinate
-   * @param z Cartesian z coordinate
-   * @param lla 0: longitude 1: latitude: 2: altitude
-   * @return double array as 0: longitude 1: latitude 2: altitude
-   */
-  public static final double[] ecfToLLA(final double x, final double y, final double z, double[] lla) {
-    boolean atPole = false;
-    final double ad_c = 1.0026000D;
-    final double e2 = (SEMIMAJOR_AXIS2 - SEMIMINOR_AXIS2)/(SEMIMAJOR_AXIS2);
-    final double ep2 = (SEMIMAJOR_AXIS2 - SEMIMINOR_AXIS2)/(SEMIMINOR_AXIS2);
-    final double cos67P5 = 0.38268343236508977D;
-
-    if (lla == null)
-      lla = new double[3];
-
-    if (x != 0.0) {
-      lla[0] = StrictMath.atan2(y,x);
-    } else {
-      if (y > 0) {
-        lla[0] = PI_OVER_2;
-      } else if (y < 0) {
-        lla[0] = -PI_OVER_2;
-      } else {
-        atPole = true;
-        lla[0] = 0.0D;
-        if (z > 0.0) {
-          lla[1] = PI_OVER_2;
-        } else if (z < 0.0) {
-          lla[1] = -PI_OVER_2;
-        } else {
-          lla[1] = PI_OVER_2;
-          lla[2] = -SEMIMINOR_AXIS;
-          return lla;
-        }
-      }
-    }
-
-    final double w2 = x*x + y*y;
-    final double w = StrictMath.sqrt(w2);
-    final double t0 = z * ad_c;
-    final double s0 = StrictMath.sqrt(t0 * t0 + w2);
-    final double sinB0 = t0 / s0;
-    final double cosB0 = w / s0;
-    final double sin3B0 = sinB0 * sinB0 * sinB0;
-    final double t1 = z + SEMIMINOR_AXIS * ep2 * sin3B0;
-    final double sum = w - SEMIMAJOR_AXIS * e2 * cosB0 * cosB0 * cosB0;
-    final double s1 = StrictMath.sqrt(t1 * t1 + sum * sum);
-    final double sinP1 = t1 / s1;
-    final double cosP1 = sum / s1;
-    final double rn = SEMIMAJOR_AXIS / StrictMath.sqrt(1.0D - e2 * sinP1 * sinP1);
-
-    if (cosP1 >= cos67P5) {
-      lla[2] = w / cosP1 - rn;
-    } else if (cosP1 <= -cos67P5) {
-      lla[2] = w / -cosP1 - rn;
-    } else {
-      lla[2] = z / sinP1 + rn * (e2 - 1.0);
-    }
-    if (!atPole) {
-      lla[1] = StrictMath.atan(sinP1/cosP1);
-    }
-    lla[0] = StrictMath.toDegrees(lla[0]);
-    lla[1] = StrictMath.toDegrees(lla[1]);
-
-    return lla;
-  }
-
-  /**
    * simple even-odd point in polygon computation
    *    1.  Determine if point is contained in the longitudinal range
    *    2.  Determine whether point crosses the edge by computing the latitudinal delta
@@ -329,6 +213,39 @@ public final class GeoUtils {
   }
 
   /**
+   * Converts a given circle (defined as a point/radius) to an approximated line-segment polygon
+   *
+   * @param lon longitudinal center of circle (in degrees)
+   * @param lat latitudinal center of circle (in degrees)
+   * @param radius distance radius of circle (in kilometers)
+   * @return a list of lon/lat points representing the circle
+   */
+  public static final ArrayList<double[]> circleToPoly(final double lon, final double lat, final double radius) {
+    double angle;
+    // a little under-sampling (to limit the number of polygonal points): using archimedes estimation of pi
+    final int sides = 25;
+    ArrayList<double[]> geometry = new ArrayList();
+    double[] lons = new double[sides];
+    double[] lats = new double[sides];
+
+    double[] pt = new double[2];
+    final int sidesLen = sides-1;
+    for (int i=0; i<sidesLen; ++i) {
+      angle = (i*360/sides);
+      pt = GeoProjectionUtils.pointFromLonLatBearing(lon, lat, angle, radius, pt);
+      lons[i] = pt[0];
+      lats[i] = pt[1];
+    }
+    // close the poly
+    lons[sidesLen] = lons[0];
+    lats[sidesLen] = lats[0];
+    geometry.add(lons);
+    geometry.add(lats);
+
+    return geometry;
+  }
+
+  /**
    * Computes whether a rectangle is within a given polygon (shared boundaries allowed)
    */
   public static boolean rectWithinPoly(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
@@ -341,6 +258,65 @@ public final class GeoUtils {
         !pointInPolygon(shapeX, shapeY, rMaxY, rMaxX) || !pointInPolygon(shapeX, shapeY, rMaxY, rMinX));
   }
 
+  public static boolean rectWithinCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
+                                         final double centerLon, final double centerLat, final double radius) {
+    return !(SloppyMath.haversin(centerLat, centerLon, rMinY, rMinX) > radius
+        || SloppyMath.haversin(centerLat, centerLon, rMaxY, rMinX) > radius
+        || SloppyMath.haversin(centerLat, centerLon, rMaxY, rMaxX) > radius
+        || SloppyMath.haversin(centerLat, centerLon, rMinY, rMaxX) > radius);
+
+  }
+
+  public static boolean rectCrossesCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
+                                          final double centerLon, final double centerLat, final double radius) {
+    return lineCrossesCircle(rMinX, rMinY, rMaxX, rMinY, centerLon, centerLat, radius)
+        || lineCrossesCircle(rMaxX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radius)
+        || lineCrossesCircle(rMaxX, rMaxY, rMinX, rMaxY, centerLon, centerLat, radius)
+        || lineCrossesCircle(rMinX, rMaxY, rMinX, rMinY, centerLon, centerLat, radius);
+
+  }
+
+  /**
+   * Computes whether a line crosses a circle. That is, one point is inside and one is outside, or the line is a secant
+   */
+  private static boolean lineCrossesCircle(final double x1, final double y1, final double x2, final double y2,
+                                           final double centerX, final double centerY, double radius) {
+    if (isSecant(x1, y1, x2, y2, centerX, centerY))
+      return true;
+
+    // distance in km
+    final double d1 = SloppyMath.haversin(centerY, centerX, y1, x1);
+    final double d2 = SloppyMath.haversin(centerY, centerX, y2, x2);
+    return  (d1 < radius && d2 > radius) || (d2 < radius && d1 > radius);
+  }
+
+  private static boolean isSecant(final double x1, final double y1, final double x2, final double y2,
+                                  final double centerX, final double centerY) {
+    final double dX = x2 - x1;
+    final double dY = y2 - y1;
+    final double fX = x1 - centerX;
+    final double fY = y1 - centerY;
+
+    final double a = StrictMath.sqrt(dX*dX + dY*dY);
+    final double b = 2 * StrictMath.sqrt(fX*dX + fY*dY);
+    final double c = StrictMath.sqrt(fX*fX + fY*fY);
+
+    double discrim = b*b-4*a*c;
+    if (discrim < 0)
+      return false;
+
+    discrim = StrictMath.sqrt(discrim);
+    final double a2 = 2*a;
+    final double t1 = (-b - discrim)/a2;
+    final double t2 = (-b + discrim)/a2;
+
+
+    if ( (t1 < 0 || t1 > 1) )
+      return !(t2 < 0 || t2 > 1);
+
+    return true;
+  }
+
   public static boolean isValidLat(double lat) {
     return Double.isNaN(lat) == false && lat >= MIN_LAT_INCL && lat <= MAX_LAT_INCL;
   }
@@ -348,4 +324,93 @@ public final class GeoUtils {
   public static boolean isValidLon(double lon) {
     return Double.isNaN(lon) == false && lon >= MIN_LON_INCL && lon <= MAX_LON_INCL;
   }
+
+  // nocommit for testing only add to util testing
+  public static void main(String[] args) {
+    // pacman
+    double[] px = {0, 10, 10, 0, -8, -10, -8, 0, 10, 10, 0};
+    double[] py = {0, 5, 9, 10, 9, 0, -9, -10, -9, -5, 0};
+
+    // bbox
+    double xMinA = -10;
+    double xMaxA = 10;
+    double yMinA = -10;
+    double yMaxA = 10;
+
+    // candidate cell
+    double xMin = 2;//-5;
+    double xMax = 11;//0.000001;
+    double yMin = -1;//0;
+    double yMax = 1;//5;
+
+    System.out.println("LINE CROSS CIRCLE TEST\n----------------------");
+    System.out.println(GeoUtils.lineCrossesCircle(3, 5, 15, 5, 0, 0, 1000));
+
+    System.out.println("CIRCLE TO POLYGON\n----------------------");
+    final ArrayList<double[]> circle = GeoUtils.circleToPoly(-99.458333333, 31.243333333, 635);
+    System.out.println("\"coordinates\": [[" );
+    final double[] lons = circle.get(0);
+    final double[] lats = circle.get(1);
+    for (int i=0; i<lons.length; ++i) {
+      System.out.println(" [" + lons[i] + ", " + lats[i] + "], ");
+    }
+    System.out.println("]]");
+
+    System.out.println("DISTANCE TO DEGREES LON\n-----------------");
+    double deltaDegLon = GeoDistanceUtils.distanceToDegreesLon(33.2343234, 500);
+    System.out.println(deltaDegLon);
+    double distanceLon = SloppyMath.haversin(33.2343234, -96.723424, 33.2343234, -96.723424 + deltaDegLon);
+    System.out.println(distanceLon);
+
+    System.out.println("DISTANCE TO DEGREES LAT\n-----------------");
+    double deltaDegLat = GeoDistanceUtils.distanceToDegreesLat(33.2343234, 500);
+    System.out.println(deltaDegLat);
+    double distanceLat = SloppyMath.haversin(33.2343234, -96.723424, 33.2343234 + deltaDegLat, -96.723424);
+    System.out.println(distanceLat);
+
+    System.out.println("LLA TO ECF AND BACK\n-----------");
+    double[] ecf = GeoProjectionUtils.llaToECF(-96.723424, 33.2343234, 0, null);
+    double[] lla1 = GeoProjectionUtils.ecfToLLA(ecf[0], ecf[1], ecf[2], null);
+    System.out.println(lla1[0] + ", " + lla1[1] + ", " + lla1[2] + "\n");
+
+    System.out.println("ECF TO ENU AND BACK\n-----------");
+    double[] enu1 = GeoProjectionUtils.ecfToENU(-624908.0691658813, -5300885.398638069, 3485665.2533506844, -96.2343234, 33.454354, 0, null);
+    double[] ecf1 = GeoProjectionUtils.enuToECF(enu1[0], enu1[1], enu1[2], -96.2343234, 33.454354, 0, null);
+    System.out.println(ecf1[0] + ", " + ecf[1] + ", " + ecf1[2] + "\n");
+
+    System.out.println("LLA TO ENU AND BACK\n-----------");
+    double[] enu = GeoProjectionUtils.llaToENU(-96.723424, 33.2343234, 0, -96.2343234, 33.454354, 0, null);
+    double[] lla2 = GeoProjectionUtils.enuToLLA(enu[0], enu[1], enu[2], -96.2343234, 33.454354, 0, null);
+    System.out.println(lla2[0] + ", " + lla2[1] + ", " + lla2[2] + "\n");
+
+    System.out.println("CELL AND POLY\n--------------");
+    // cell crosses poly (touching not allowed)
+    if (rectCrossesPoly(xMin, yMin, xMax, yMax, px, py, -10, -10, 10, 10)) {
+      System.out.println("CROSSES");
+    } else {
+      System.out.println("NO CROSS");
+    }
+
+    // cell within poly (touching allowed)
+    if (rectWithinPoly(xMin, yMin, xMax, yMax, px, py, -10, -10, 10, 10)) {
+      System.out.println("WITHIN");
+    } else {
+      System.out.println("NOT WITHIN");
+    }
+
+    System.out.println("\nCELL AND BBOX\n--------------");
+    // cell crosses poly (touching not allowed)
+    if (rectCrosses(xMin, yMin, xMax, yMax, xMinA, yMinA, xMaxA, yMaxA)) {
+      System.out.println("CROSSES");
+    } else {
+      System.out.println("NO CROSS");
+    }
+
+    // cell within poly (touching allowed)
+    if (rectWithin(xMin, yMin, xMax, yMax, xMinA, yMinA, xMaxA, yMaxA)) {
+      System.out.println("WITHIN");
+    } else {
+      System.out.println("NOT WITHIN");
+    }
+  }
 }
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery.java b/lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery.java
index 59cca0c..8e50c74 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery.java
@@ -41,6 +41,7 @@ import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.FixedBitSet;
+import org.apache.lucene.util.GeoDistanceUtils;
 import org.apache.lucene.util.GeoUtils;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase;
@@ -99,7 +100,8 @@ public class TestGeoPointQuery extends LuceneTestCase {
          new GeoPointField(FIELD_NAME, -83.99724648980559, 58.29438379542874, storedPoint),
          new GeoPointField(FIELD_NAME, -26.779373834241003, 33.541429799076354, storedPoint),
          new GeoPointField(FIELD_NAME, -77.35379276106497, 26.774024500421728, storedPoint),
-         new GeoPointField(FIELD_NAME, -14.796283808944777, -62.455081198245665, storedPoint)};
+         new GeoPointField(FIELD_NAME, -14.796283808944777, -62.455081198245665, storedPoint),
+         new GeoPointField(FIELD_NAME, -179.5, -44.5, storedPoint)};
 
     for (GeoPointField p : pts) {
         Document doc = new Document();
@@ -130,6 +132,11 @@ public class TestGeoPointQuery extends LuceneTestCase {
     return searcher.search(q, limit);
   }
 
+  private TopDocs geoDistanceQuery(double lon, double lat, double radius, int limit) throws Exception {
+    GeoPointDistanceQuery q = new GeoPointDistanceQuery(FIELD_NAME, lon, lat, radius);
+    return searcher.search(q, limit);
+  }
+
   @Test
   public void testBBoxQuery() throws Exception {
     TopDocs td = bboxQuery(-96.7772, 32.778650, -96.77690000, 32.778950, 5);
@@ -142,7 +149,7 @@ public class TestGeoPointQuery extends LuceneTestCase {
                                              -96.6041564, -96.7449188, -96.76826477, -96.7682647},
                                new double[] { 33.073130, 32.9942669, 32.938386, 33.0374494,
                                               33.1369762, 33.1162747, 33.073130, 33.073130}, 5);
-    assertEquals("GeoPolygonQuery failed", td.totalHits, 1);
+    assertEquals("GeoPolygonQuery failed", 1, td.totalHits);
   }
 
   @Test
@@ -169,6 +176,12 @@ public class TestGeoPointQuery extends LuceneTestCase {
     assertTrue(GeoUtils.rectWithinPoly(-5, 0, -2, 5, px, py, xMin, yMin, xMax, yMax));
   }
 
+  @Test
+  public void testGeoDistanceQuery() throws Exception {
+    TopDocs td = geoDistanceQuery(-96.4538113027811, 32.94823588839368, 400, 20);
+    assertEquals("GeoDistanceQuery failed", 6, td.totalHits);
+  }
+
   public void testRandomTiny() throws Exception {
     // Make sure single-leaf-node case is OK:
     doTestRandom(10);
@@ -342,14 +355,24 @@ public class TestGeoPointQuery extends LuceneTestCase {
               Query query;
               boolean tooBigBBox = false;
               boolean polySearch = false;
+              boolean pointRadiusQuery = false;
 
               double bboxLat0 = lat0;
               double bboxLat1 = lat1;
               double bboxLon0 = lon0;
               double bboxLon1 = lon1;
+              double radius = 0;
 
               if (random().nextBoolean()) {
                 query = new GeoPointInBBoxQuery(FIELD_NAME, lon0, lat0, lon1, lat1);
+              } else if (false && random().nextBoolean()) { // nocommit re-enable after point-radius improvements
+                pointRadiusQuery = true;
+                radius = 1.0 + (3_000_000 - 1.0) * random().nextDouble();
+                radius /= 1000;
+                if (VERBOSE) {
+                  System.out.println("\t pt = " + lon0 + ", " + lat0 + " radius = " + radius);
+                }
+                query = new GeoPointDistanceQuery(FIELD_NAME, lon0, lat0, radius);
               } else {
                 polySearch = true;
                 if (random().nextBoolean()) {
@@ -378,6 +401,7 @@ public class TestGeoPointQuery extends LuceneTestCase {
                 query = new GeoPointInPolygonQuery(FIELD_NAME, bboxLon0, bboxLat0, bboxLon1, bboxLat1, pLons, pLats);
               }
 
+
               final FixedBitSet hits = new FixedBitSet(r.maxDoc());
               s.search(query, new SimpleCollector() {
 
@@ -413,8 +437,9 @@ public class TestGeoPointQuery extends LuceneTestCase {
                 final double pointLon = GeoUtils.mortonUnhashLon(pointHash);
                 final double pointLat = GeoUtils.mortonUnhashLat(pointHash);
                 if (!tolerateIgnorance(lat0, lat1, lon0, lon1, pointLat, pointLon)) {
-                  boolean expected = (deleted.contains(id) == false) &&
-                      rectContainsPointEnc(lat0, lat1, lon0, lon1, pointLat, pointLon);
+                  boolean expected = (deleted.contains(id) == false) && (pointRadiusQuery ?
+                      distanceContainsPt(lon0, lat0, pointLon, pointLat, radius) :
+                      rectContainsPointEnc(lat0, lat1, lon0, lon1, pointLat, pointLon));
                   if (hits.get(docID) != expected) {
                     System.out.println(Thread.currentThread().getName() + ": iter=" + iter + " id=" + id + " docID=" + docID + " lat=" + pointLat + " lon=" + pointLon + " (bbox: lat=" + lat0 + " TO " + lat1 + " lon=" + lon0 + " TO " + lon1 + ") expected " + expected + " but got: " + hits.get(docID) + " deleted?=" + deleted.contains(id) + " query=" + query);
                     if (tooBigBBox) {
@@ -440,6 +465,17 @@ public class TestGeoPointQuery extends LuceneTestCase {
     IOUtils.close(r, dir);
   }
 
+  private static boolean distanceContainsPt(double lonA, double latA, double lonB, double latB, final double radius) {
+    final long hashedPtA = GeoUtils.mortonHash(lonA, latA);
+    lonA = GeoUtils.mortonUnhashLon(hashedPtA);
+    latA = GeoUtils.mortonUnhashLat(hashedPtA);
+    final long hashedPtB = GeoUtils.mortonHash(lonB, latB);
+    lonB = GeoUtils.mortonUnhashLon(hashedPtB);
+    latB = GeoUtils.mortonUnhashLat(hashedPtB);
+
+    return (GeoDistanceUtils.vincentyDistance(lonA, latA, lonB, latB) <= radius);
+  }
+
   private static boolean rectContainsPointEnc(double rectLatMin, double rectLatMax,
                                               double rectLonMin, double rectLonMax,
                                               double pointLat, double pointLon) {
