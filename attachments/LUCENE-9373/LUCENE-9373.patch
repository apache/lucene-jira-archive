Index: lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionMatchQuery.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionMatchQuery.java	(revision a6515ca38f9813730d16f1d8eaba953e4cd130ca)
+++ lucene/queries/src/test/org/apache/lucene/queries/function/TestFunctionMatchQuery.java	(date 1597290472940)
@@ -18,20 +18,26 @@
 package org.apache.lucene.queries.function;
 
 import java.io.IOException;
+import java.util.function.DoublePredicate;
 
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.search.DoubleValuesSource;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.search.ScoreMode;
 import org.apache.lucene.search.TopDocs;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
+import static org.apache.lucene.queries.function.FunctionMatchQuery.DEFAULT_MATCH_COST;
+
 public class TestFunctionMatchQuery extends FunctionTestSetup {
 
   static IndexReader reader;
   static IndexSearcher searcher;
+  private static final DoubleValuesSource in = DoubleValuesSource.fromFloatField(FLOAT_FIELD);
 
   @BeforeClass
   public static void beforeClass() throws Exception {
@@ -46,7 +52,6 @@
   }
 
   public void testRangeMatching() throws IOException {
-    DoubleValuesSource in = DoubleValuesSource.fromFloatField(FLOAT_FIELD);
     FunctionMatchQuery fmq = new FunctionMatchQuery(in, d -> d >= 2 && d < 4);
     TopDocs docs = searcher.search(fmq, 10);
 
@@ -58,4 +63,23 @@
 
   }
 
+  public void testTwoPhaseIteratorMatchCost() throws IOException {
+    DoublePredicate predicate = d -> true;
+
+    // should use default match cost
+    FunctionMatchQuery fmq = new FunctionMatchQuery(in, predicate);
+    assertEquals(DEFAULT_MATCH_COST, getMatchCost(fmq), 0.1);
+
+    // should use client defined match cost
+    fmq = new FunctionMatchQuery(in, predicate, 200);
+    assertEquals(200, getMatchCost(fmq), 0.1);
+  }
+
+  private static float getMatchCost(FunctionMatchQuery fmq) throws IOException {
+    LeafReaderContext ctx = reader.leaves().get(0);
+    return fmq.createWeight(searcher, ScoreMode.TOP_DOCS, 1)
+      .scorer(ctx)
+      .twoPhaseIterator()
+      .matchCost();
+  }
 }
Index: lucene/queries/src/java/org/apache/lucene/queries/function/FunctionMatchQuery.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/function/FunctionMatchQuery.java	(revision a6515ca38f9813730d16f1d8eaba953e4cd130ca)
+++ lucene/queries/src/java/org/apache/lucene/queries/function/FunctionMatchQuery.java	(date 1597290113886)
@@ -44,17 +44,32 @@
  */
 public final class FunctionMatchQuery extends Query {
 
+  static final float DEFAULT_MATCH_COST = 100;
+
   private final DoubleValuesSource source;
   private final DoublePredicate filter;
+  private final float matchCost; // not used in equals/hashCode
 
   /**
-   * Create a FunctionMatchQuery
+   * Create a FunctionMatchQuery with default TwoPhaseIterator matchCost -
+   * {@link #DEFAULT_MATCH_COST} = {@value #DEFAULT_MATCH_COST}
    * @param source  a {@link DoubleValuesSource} to use for values
    * @param filter  the predicate to match against
    */
   public FunctionMatchQuery(DoubleValuesSource source, DoublePredicate filter) {
+    this(source, filter, DEFAULT_MATCH_COST);
+  }
+
+  /**
+   * Create a FunctionMatchQuery
+   * @param source     a {@link DoubleValuesSource} to use for values
+   * @param filter     the predicate to match against
+   * @param matchCost  to be returned by {@link TwoPhaseIterator#matchCost()}
+   */
+  public FunctionMatchQuery(DoubleValuesSource source, DoublePredicate filter, float matchCost) {
     this.source = source;
     this.filter = filter;
+    this.matchCost = matchCost;
   }
 
   @Override
@@ -83,7 +98,7 @@
 
           @Override
           public float matchCost() {
-            return 100; // TODO maybe DoubleValuesSource should have a matchCost?
+            return matchCost; // TODO maybe DoubleValuesSource should have a matchCost?
           }
         };
         return new ConstantScoreScorer(this, score(), scoreMode, twoPhase);
