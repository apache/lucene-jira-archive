diff --git a/lucene/core/src/java/org/apache/lucene/search/PointRangeQuery.java b/lucene/core/src/java/org/apache/lucene/search/PointRangeQuery.java
index 4991096..94438ca 100644
--- a/lucene/core/src/java/org/apache/lucene/search/PointRangeQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/PointRangeQuery.java
@@ -27,7 +27,7 @@ import org.apache.lucene.document.IntPoint;    // javadocs
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.util.DocIdSetBuilder;
+import org.apache.lucene.util.MatchingPoints;
 import org.apache.lucene.util.StringHelper;
 
 /** 
@@ -105,18 +105,13 @@ public abstract class PointRangeQuery extends Query {
 
     return new ConstantScoreWeight(this) {
 
-      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {
-        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());
+      private DocIdSetIterator buildMatchingIterator(LeafReader reader, PointValues values) throws IOException {
+        MatchingPoints result = new MatchingPoints(reader, field);
 
         values.intersect(field,
             new IntersectVisitor() {
 
               @Override
-              public void grow(int count) {
-                result.grow(count);
-              }
-
-              @Override
               public void visit(int docID) {
                 result.add(docID);
               }
@@ -163,7 +158,7 @@ public abstract class PointRangeQuery extends Query {
                 }
               }
             });
-        return result.build();
+        return result.iterator();
       }
 
       @Override
@@ -208,7 +203,7 @@ public abstract class PointRangeQuery extends Query {
           // all docs have a value and all points are within bounds, so everything matches
           iterator = DocIdSetIterator.all(reader.maxDoc());
         } else {
-          iterator = buildMatchingDocIdSet(reader, values).iterator();
+          iterator = buildMatchingIterator(reader, values);
         }
 
         return new ConstantScoreScorer(this, score(), iterator);
diff --git a/lucene/core/src/java/org/apache/lucene/util/MatchingPoints.java b/lucene/core/src/java/org/apache/lucene/util/MatchingPoints.java
new file mode 100644
index 0000000..f78a20a
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/MatchingPoints.java
@@ -0,0 +1,86 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.util;
+
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.index.PointValues;
+import org.apache.lucene.search.DocIdSetIterator;
+
+/**
+ * Accumulates matching hits for points.
+ * <p>
+ * Add matches with ({@link #add(int)}) and call {@link #iterator()} for
+ * an iterator over the results. 
+ * <p>
+ * This implementation currently optimizes bitset structure (sparse vs dense)
+ * and {@link DocIdSetIterator#cost()} (cardinality) based on index statistics.
+ * This API may change as point values evolves.
+ * 
+ * @lucene.experimental
+ */
+public final class MatchingPoints {
+  /** bitset we collect into */
+  private final BitSet bits;
+  /** number of documents containing a value for the points field */
+  private final int docCount;
+  /** number of values indexed for the points field */
+  private final long numPoints;
+  /** number of documents in the index segment */
+  private final int maxDoc;
+  /** counter of hits seen */
+  private long counter;
+
+  /**
+   * Creates a new accumulator.
+   * @param reader reader to collect point matches from
+   * @param field field name.
+   */
+  public MatchingPoints(LeafReader reader, String field) {
+    maxDoc = reader.maxDoc();
+    PointValues values = reader.getPointValues();
+    if (values == null) {
+      throw new IllegalStateException("the query is missing null checks");
+    }
+    docCount = values.getDocCount(field);
+    numPoints = values.size(field);
+    // heuristic: if the field is really sparse, use a sparse impl
+    if (docCount >= 0 && docCount * 100L < maxDoc) {
+      bits = new SparseFixedBitSet(maxDoc);
+    } else {
+      bits = new FixedBitSet(maxDoc);
+    }
+  }
+
+  /**
+   * Record a matching docid.
+   * <p>
+   * NOTE: doc IDs do not need to be provided in any order.
+   */
+  public void add(int doc) {
+    bits.set(doc);
+    counter++;
+  }
+  
+  /**
+   * Returns an iterator over the recorded matches.
+   */
+  public DocIdSetIterator iterator() {
+    // if single-valued (docCount == numPoints), then this is exact
+    // otherwise its approximate based on field stats
+    return new BitSetIterator(bits, (long) (counter * (docCount / (double) numPoints)));
+  }
+}
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
index 9bd78fe..2d97b82 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
@@ -28,13 +28,11 @@ import org.apache.lucene.index.PointValues.IntersectVisitor;
 import org.apache.lucene.index.PointValues.Relation;
 import org.apache.lucene.search.ConstantScoreScorer;
 import org.apache.lucene.search.ConstantScoreWeight;
-import org.apache.lucene.search.DocIdSet;
-import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.Weight;
-import org.apache.lucene.util.DocIdSetBuilder;
+import org.apache.lucene.util.MatchingPoints;
 import org.apache.lucene.util.NumericUtils;
 import org.apache.lucene.util.SloppyMath;
 import org.apache.lucene.util.StringHelper;
@@ -120,16 +118,11 @@ final class LatLonPointDistanceQuery extends Query {
         LatLonPoint.checkCompatible(fieldInfo);
         
         // matching docids
-        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());
+        MatchingPoints result = new MatchingPoints(reader, field);
 
         values.intersect(field,
                          new IntersectVisitor() {
                            @Override
-                           public void grow(int count) {
-                             result.grow(count);
-                           }
-
-                           @Override
                            public void visit(int docID) {
                              result.add(docID);
                            }
@@ -209,12 +202,7 @@ final class LatLonPointDistanceQuery extends Query {
                            }
                          });
 
-        DocIdSet set = result.build();
-        final DocIdSetIterator disi = set.iterator();
-        if (disi == null) {
-          return null;
-        }
-        return new ConstantScoreScorer(this, score(), disi);
+        return new ConstantScoreScorer(this, score(), result.iterator());
       }
     };
   }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
index ee7c1e8..c73b7f1 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
@@ -24,8 +24,6 @@ import org.apache.lucene.index.PointValues.IntersectVisitor;
 import org.apache.lucene.index.PointValues.Relation;
 import org.apache.lucene.search.ConstantScoreScorer;
 import org.apache.lucene.search.ConstantScoreWeight;
-import org.apache.lucene.search.DocIdSet;
-import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
@@ -34,7 +32,7 @@ import org.apache.lucene.index.PointValues;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.util.DocIdSetBuilder;
+import org.apache.lucene.util.MatchingPoints;
 import org.apache.lucene.util.NumericUtils;
 import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.geo.Polygon;
@@ -113,16 +111,11 @@ final class LatLonPointInPolygonQuery extends Query {
         LatLonPoint.checkCompatible(fieldInfo);
 
         // matching docids
-        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());
+        MatchingPoints result = new MatchingPoints(reader, field);
 
         values.intersect(field, 
                          new IntersectVisitor() {
                            @Override
-                           public void grow(int count) {
-                             result.grow(count);
-                           }
-
-                           @Override
                            public void visit(int docID) {
                              result.add(docID);
                            }
@@ -154,13 +147,7 @@ final class LatLonPointInPolygonQuery extends Query {
                            }
                          });
 
-        DocIdSet set = result.build();
-        final DocIdSetIterator disi = set.iterator();
-        if (disi == null) {
-          return null;
-        }
-
-        return new ConstantScoreScorer(this, score(), disi);
+        return new ConstantScoreScorer(this, score(), result.iterator());
       }
     };
   }
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInGeo3DShapeQuery.java b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInGeo3DShapeQuery.java
index 24a4224..4d63885 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInGeo3DShapeQuery.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInGeo3DShapeQuery.java
@@ -31,7 +31,7 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.Weight;
-import org.apache.lucene.util.DocIdSetBuilder;
+import org.apache.lucene.util.MatchingPoints;
 
 /** Finds all previously indexed points that fall within the specified polygon.
  *
@@ -97,11 +97,11 @@ final class PointInGeo3DShapeQuery extends Query {
         assert xyzSolid.getRelationship(shape) == GeoArea.WITHIN || xyzSolid.getRelationship(shape) == GeoArea.OVERLAPS: "expected WITHIN (1) or OVERLAPS (2) but got " + xyzSolid.getRelationship(shape) + "; shape="+shape+"; XYZSolid="+xyzSolid;
         */
 
-        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());
+        MatchingPoints result = new MatchingPoints(reader, field);
 
         values.intersect(field, new PointInShapeIntersectVisitor(result, shape, shapeBounds));
 
-        return new ConstantScoreScorer(this, score(), result.build().iterator());
+        return new ConstantScoreScorer(this, score(), result.iterator());
       }
     };
   }
diff --git a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor.java b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor.java
index cf94c35..afe322d 100644
--- a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/PointInShapeIntersectVisitor.java
@@ -24,26 +24,21 @@ import org.apache.lucene.spatial3d.geom.GeoAreaFactory;
 import org.apache.lucene.spatial3d.geom.GeoShape;
 import org.apache.lucene.spatial3d.geom.PlanetModel;
 import org.apache.lucene.spatial3d.geom.XYZBounds;
-import org.apache.lucene.util.DocIdSetBuilder;
+import org.apache.lucene.util.MatchingPoints;
 import org.apache.lucene.util.NumericUtils;
 
 class PointInShapeIntersectVisitor implements IntersectVisitor {
-  private final DocIdSetBuilder hits;
+  private final MatchingPoints hits;
   private final GeoShape shape;
   private final XYZBounds shapeBounds;
   
-  public PointInShapeIntersectVisitor(DocIdSetBuilder hits, GeoShape shape, XYZBounds shapeBounds) {
+  public PointInShapeIntersectVisitor(MatchingPoints hits, GeoShape shape, XYZBounds shapeBounds) {
     this.hits = hits;
     this.shape = shape;
     this.shapeBounds = shapeBounds;
   }
 
   @Override
-  public void grow(int count) {
-    hits.grow(count);
-  }
-
-  @Override
   public void visit(int docID) {
     hits.add(docID);
   }
diff --git a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint.java b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint.java
index 2028c36..d5c862b 100644
--- a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint.java
+++ b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint.java
@@ -76,6 +76,7 @@ import org.apache.lucene.util.DocIdSetBuilder;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.MatchingPoints;
 import org.apache.lucene.util.NumericUtils;
 import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.TestUtil;
@@ -1387,7 +1388,7 @@ public class TestGeo3DPoint extends LuceneTestCase {
     StringBuilder b = new StringBuilder();
     b.append("target is in leaf " + leafReader + " of full reader " + reader + "\n");
 
-    DocIdSetBuilder hits = new DocIdSetBuilder(leafReader.maxDoc());
+    MatchingPoints hits = new MatchingPoints(leafReader, fieldName);
     ExplainingVisitor visitor = new ExplainingVisitor(shape, targetDocPoint, scaledDocPoint, new PointInShapeIntersectVisitor(hits, shape, bounds), docID - reader.leaves().get(subIndex).docBase, 3, Integer.BYTES, b);
 
     // Do first phase, where we just figure out the "path" that leads to the target docID:
