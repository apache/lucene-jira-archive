Index: src/test/org/apache/lucene/store/TestDirectory.java
===================================================================
--- src/test/org/apache/lucene/store/TestDirectory.java	(revision 713425)
+++ src/test/org/apache/lucene/store/TestDirectory.java	(working copy)
@@ -19,6 +19,8 @@
 
 import org.apache.lucene.util.LuceneTestCase;
 
+import java.io.File;
+
 public class TestDirectory extends LuceneTestCase {
 
   public void testDetectClose() throws Throwable {
@@ -38,5 +40,80 @@
     } catch (AlreadyClosedException ace) {
     }
   }
+
+
+  // Test that different instances of FSDirectory can coexist on the same
+  // path, can read, write, and lock files.
+  public void testDirectInstantiation() throws Exception {
+    File path = new File(System.getProperty("tempDir"));
+
+    int sz = 3;
+    Directory[] dirs = new Directory[sz];
+
+    dirs[0] = new FSDirectory(path, null);
+    dirs[1] = new NIOFSDirectory(path, null);
+    dirs[2] = new MMapDirectory(path, null);
+
+    for (int i=0; i<sz; i++) {
+      Directory dir = dirs[i];
+      dir.ensureOpen();
+      String fname = "foo." + i;
+      String lockname = "foo" + i + ".lck";
+      IndexOutput out = dir.createOutput(fname);
+      out.writeByte((byte)i);
+      out.close();
+
+      for (int j=0; j<sz; j++) {
+        Directory d2 = dirs[j];
+        d2.ensureOpen();
+        assertTrue(d2.fileExists(fname));
+        assertEquals(1, d2.fileLength(fname));
+
+        // don't test read on MMapDirectory, since it can't really be
+        // closed and will cause a failure to delete the file.
+        if (d2 instanceof MMapDirectory) continue;
+        
+        IndexInput input = d2.openInput(fname);
+        assertEquals((byte)i, input.readByte());
+        input.close();
+      }
+
+      // delete with a different dir
+      dirs[(i+1)%sz].deleteFile(fname);
+
+      for (int j=0; j<sz; j++) {
+        Directory d2 = dirs[j];
+        assertFalse(d2.fileExists(fname));
+      }
+
+      Lock lock = dir.makeLock(lockname);
+      assertTrue(lock.obtain());
+
+      for (int j=0; j<sz; j++) {
+        Directory d2 = dirs[j];
+        Lock lock2 = d2.makeLock(lockname);
+        try {
+          assertFalse(lock2.obtain(1));
+        } catch (LockObtainFailedException e) {
+          // OK
+        }
+      }
+
+      lock.release();
+      
+      // now lock with different dir
+      lock = dirs[(i+1)%sz].makeLock(lockname);
+      assertTrue(lock.obtain());
+      lock.release();
+    }
+
+    for (int i=0; i<sz; i++) {
+      Directory dir = dirs[i];
+      dir.ensureOpen();
+      dir.close();
+      assertFalse(dir.isOpen);
+    }
+  }
+
 }
 
Index: src/java/org/apache/lucene/store/NIOFSDirectory.java
===================================================================
--- src/java/org/apache/lucene/store/NIOFSDirectory.java	(revision 713425)
+++ src/java/org/apache/lucene/store/NIOFSDirectory.java	(working copy)
@@ -43,6 +43,16 @@
 
 public class NIOFSDirectory extends FSDirectory {
 
+  /** Create a new NIOFSDirectory for the named location.
+   * 
+   * @param path the path of the directory
+   * @param lockFactory the lock factory to use, or null for the default.
+   * @throws IOException
+   */
+  public NIOFSDirectory(File path, LockFactory lockFactory) throws IOException {
+    super(path, lockFactory);
+  }  
+
   // Inherit javadoc
   public IndexInput openInput(String name, int bufferSize) throws IOException {
     ensureOpen();
Index: src/java/org/apache/lucene/store/MMapDirectory.java
===================================================================
--- src/java/org/apache/lucene/store/MMapDirectory.java	(revision 713425)
+++ src/java/org/apache/lucene/store/MMapDirectory.java	(working copy)
@@ -33,6 +33,15 @@
  */
 public class MMapDirectory extends FSDirectory {
 
+  /** Create a new MMapDirectory for the named location.
+   * @param path the path of the directory
+   * @param lockFactory the lock factory to use, or null for the default.
+   * @throws IOException
+   */
+  public MMapDirectory(File path, LockFactory lockFactory) throws IOException {
+    super(path, lockFactory);
+  }
+
   private static class MMapIndexInput extends IndexInput {
 
     private ByteBuffer buffer;
Index: src/java/org/apache/lucene/store/FSDirectory.java
===================================================================
--- src/java/org/apache/lucene/store/FSDirectory.java	(revision 713425)
+++ src/java/org/apache/lucene/store/FSDirectory.java	(working copy)
@@ -131,6 +131,7 @@
   /** A buffer optionally used in renameTo method */
   private byte[] buffer = null;
 
+
   /** Returns the directory instance for the named location.
    * @param path the path to the directory.
    * @return the FSDirectory for the named file.  */
@@ -165,15 +166,8 @@
   public static FSDirectory getDirectory(File file, LockFactory lockFactory)
     throws IOException
   {
-    file = new File(file.getCanonicalPath());
+    file = createCanonicalDir(file);
 
-    if (file.exists() && !file.isDirectory())
-      throw new IOException(file + " not a directory");
-
-    if (!file.exists())
-      if (!file.mkdirs())
-        throw new IOException("Cannot create directory: " + file);
-
     FSDirectory dir;
     synchronized (DIRECTORIES) {
       dir = (FSDirectory)DIRECTORIES.get(file);
@@ -249,11 +243,39 @@
     lockFactory.clearLock(IndexWriter.WRITE_LOCK_NAME);
   }
 
+  // returns the canonical version of the directory, creating it if it doesn't exist.
+  private static File createCanonicalDir(File file) throws IOException {
+    file = new File(file.getCanonicalPath());
+
+    if (file.exists() && !file.isDirectory())
+      throw new IOException(file + " not a directory");
+
+    if (!file.exists())
+      if (!file.mkdirs())
+        throw new IOException("Cannot create directory: " + file);
+
+    return file;
+  }
+
   private File directory = null;
   private int refCount;
 
   protected FSDirectory() {};                     // permit subclassing
 
+  /** Create a new FSDirectory for the named location.
+   *
+   * @param path the path of the directory
+   * @param lockFactory the lock factory to use, or null for the default.
+   * @throws IOException
+   *
+   * Use {@link #getDirectory(String)} if singletons per path are needed.
+   */
+  public FSDirectory(File path, LockFactory lockFactory) throws IOException {
+    path = createCanonicalDir(path);
+    init(path, lockFactory);
+    refCount = 1;
+  }
+
   private void init(File path, LockFactory lockFactory) throws IOException {
 
     // Set up lockFactory with cascaded defaults: if an instance was passed in,
