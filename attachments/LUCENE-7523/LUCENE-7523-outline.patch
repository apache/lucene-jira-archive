diff --git a/lucene/core/src/java/org/apache/lucene/index/UpgradeIndexMergePolicy.java b/lucene/core/src/java/org/apache/lucene/index/UpgradeIndexMergePolicy.java
index 74cbc90..5f5a6f6 100644
--- a/lucene/core/src/java/org/apache/lucene/index/UpgradeIndexMergePolicy.java
+++ b/lucene/core/src/java/org/apache/lucene/index/UpgradeIndexMergePolicy.java
@@ -21,6 +21,7 @@ import org.apache.lucene.util.Version;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.HashMap;
@@ -50,6 +51,9 @@ import java.util.HashMap;
   */
 public class UpgradeIndexMergePolicy extends MergePolicyWrapper {
 
+  private boolean fallbackToInnerAfterUpgrade = false;
+  private boolean upgradeUnmergedSegmentsIndividually = false;
+
   /** Wrap the given {@link MergePolicy} and intercept forceMerge requests to
    * only upgrade segments written with previous Lucene versions. */
   public UpgradeIndexMergePolicy(MergePolicy in) {
@@ -85,8 +89,13 @@ public class UpgradeIndexMergePolicy extends MergePolicyWrapper {
       message("findForcedMerges: segmentsToUpgrade=" + oldSegments, writer);
     }
       
-    if (oldSegments.isEmpty())
-      return null;
+    if (oldSegments.isEmpty()) {
+      if (fallbackToInnerAfterUpgrade) {
+        return in.findForcedMerges(segmentInfos, maxSegmentCount, segmentsToMerge, writer);
+      } else {
+        return null;
+      }
+    }
 
     MergeSpecification spec = in.findForcedMerges(segmentInfos, maxSegmentCount, oldSegments, writer);
     
@@ -100,21 +109,35 @@ public class UpgradeIndexMergePolicy extends MergePolicyWrapper {
     }
 
     if (!oldSegments.isEmpty()) {
-      if (verbose(writer)) {
-        message("findForcedMerges: " +  in.getClass().getSimpleName() +
-        " does not want to merge all old segments, merge remaining ones into new segment: " + oldSegments, writer);
+      if (spec == null) {
+        spec = new MergeSpecification();
       }
-      final List<SegmentCommitInfo> newInfos = new ArrayList<>();
-      for (final SegmentCommitInfo si : segmentInfos) {
-        if (oldSegments.containsKey(si)) {
-          newInfos.add(si);
+
+      if (verbose(writer)) {
+        if (upgradeUnmergedSegmentsIndividually) {
+          message("findForcedMerges: " +  in.getClass().getSimpleName() +
+              " does not want to merge all old segments, upgrading remaining ones individually: " + oldSegments, writer);
+        } else {
+          message("findForcedMerges: " +  in.getClass().getSimpleName() +
+              " does not want to merge all old segments, merge remaining ones into new segment: " + oldSegments, writer);
         }
       }
-      // add the final merge
-      if (spec == null) {
-        spec = new MergeSpecification();
+
+      if (upgradeUnmergedSegmentsIndividually) {
+        for (final SegmentCommitInfo si : segmentInfos) {
+          if (oldSegments.containsKey(si)) {
+            spec.add(new OneMerge(Collections.singletonList(si)));
+          }
+        }
+      } else {
+        final List<SegmentCommitInfo> newInfos = new ArrayList<>();
+        for (final SegmentCommitInfo si : segmentInfos) {
+          if (oldSegments.containsKey(si)) {
+            newInfos.add(si);
+          }
+        }
+        spec.add(new OneMerge(newInfos));
       }
-      spec.add(new OneMerge(newInfos));
     }
 
     return spec;
