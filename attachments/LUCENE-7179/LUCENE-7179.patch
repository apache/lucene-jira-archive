diff --git a/lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java b/lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java
index c11dfe1..f4e5f30 100644
--- a/lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java
+++ b/lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java
@@ -52,6 +52,9 @@ public final class GeoUtils {
   // see http://earth-info.nga.mil/GandG/publications/tr8350.2/wgs84fin.pdf
   public static final double EARTH_MEAN_RADIUS_METERS = 6_371_008.7714;
 
+  /** tolerance for encoding/decoding a {@code GeoPointField} or {@code LatLonPoint} */
+  public static final double ENCODING_TOLERANCE = 1e-7;
+
   // No instance:
   private GeoUtils() {
   }
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestLegacyGeoPointQuery.java b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestLegacyGeoPointQuery.java
index 4c8e3e3..5d1028a 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestLegacyGeoPointQuery.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestLegacyGeoPointQuery.java
@@ -24,6 +24,8 @@ import org.apache.lucene.spatial.geopoint.document.GeoPointField;
 import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
 import org.apache.lucene.spatial.util.BaseGeoPointTestCase;
 
+import static org.apache.lucene.geo.GeoUtils.ENCODING_TOLERANCE;
+
 /**
  * random testing for GeoPoint query logic (with deprecated numeric encoding)
  * @deprecated remove this when TermEncoding.NUMERIC is removed
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java b/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java
index 6ae4d20..9ea82b2 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java
@@ -70,6 +70,8 @@ import org.apache.lucene.util.TestUtil;
 import org.apache.lucene.util.bkd.BKDWriter;
 import org.junit.BeforeClass;
 
+import static org.apache.lucene.geo.GeoUtils.ENCODING_TOLERANCE;
+
 /**
  * Abstract class to do basic tests for a geospatial impl (high level
  * fields and queries)
@@ -513,13 +515,19 @@ public abstract class BaseGeoPointTestCase extends LuceneTestCase {
 
     for (int id=0;id<numPoints;id++) {
       Document doc = new Document();
-      lats[2*id] = quantizeLat(randomLat(small));
-      lons[2*id] = quantizeLon(randomLon(small));
+      lats[2*id] = randomLat(small);
+      lons[2*id] = randomLon(small);
       doc.add(newStringField("id", ""+id, Field.Store.YES));
       addPointToDoc(FIELD_NAME, doc, lats[2*id], lons[2*id]);
-      lats[2*id+1] = quantizeLat(randomLat(small));
-      lons[2*id+1] = quantizeLon(randomLon(small));
+      // quantize for test comparison
+      lats[2*id] = quantizeLat(lats[2*id]);
+      lons[2*id] = quantizeLon(lons[2*id]);
+      lats[2*id+1] = randomLat(small);
+      lons[2*id+1] = randomLon(small);
       addPointToDoc(FIELD_NAME, doc, lats[2*id+1], lons[2*id+1]);
+      // quantize for test comparison
+      lats[2*id+1] = quantizeLat(lats[2*id+1]);
+      lons[2*id+1] = quantizeLon(lons[2*id+1]);
 
       if (VERBOSE) {
         System.out.println("id=" + id);
@@ -748,18 +756,6 @@ public abstract class BaseGeoPointTestCase extends LuceneTestCase {
   }
 
   private void verify(boolean small, double[] lats, double[] lons) throws Exception {
-    // quantize each value the same way the index does
-    // NaN means missing for the doc!!!!!
-    for (int i = 0; i < lats.length; i++) {
-      if (!Double.isNaN(lats[i])) {
-        lats[i] = quantizeLat(lats[i]);
-      }
-    }
-    for (int i = 0; i < lons.length; i++) {
-      if (!Double.isNaN(lons[i])) {
-        lons[i] = quantizeLon(lons[i]);
-      }
-    }
     verifyRandomRectangles(small, lats, lons);
     verifyRandomDistances(small, lats, lons);
     verifyRandomPolygons(small, lats, lons);
@@ -790,6 +786,8 @@ public abstract class BaseGeoPointTestCase extends LuceneTestCase {
       doc.add(new NumericDocValuesField("id", id));
       if (Double.isNaN(lats[id]) == false) {
         addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);
+        lats[id] = quantizeLat(lats[id]);
+        lons[id] = quantizeLon(lons[id]);
       }
       w.addDocument(doc);
       if (id > 0 && random().nextInt(100) == 42) {
@@ -826,6 +824,7 @@ public abstract class BaseGeoPointTestCase extends LuceneTestCase {
       Rectangle rect = randomRect(small);
 
       Query query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);
+      rect = new Rectangle(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));
 
       if (VERBOSE) {
         System.out.println("  query=" + query);
@@ -1184,8 +1183,6 @@ public abstract class BaseGeoPointTestCase extends LuceneTestCase {
         break;
       }
     }
-    // this test works in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!
-    rect = new Rectangle(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));
     Directory dir = newDirectory();
     IndexWriterConfig iwc = newIndexWriterConfig();
     // Else seeds may not reproduce:
@@ -1196,7 +1193,7 @@ public abstract class BaseGeoPointTestCase extends LuceneTestCase {
       if (x == 0) {
         lat = rect.minLat;
       } else if (x == 1) {
-        lat = quantizeLat((rect.minLat+rect.maxLat)/2.0);
+        lat = (rect.minLat+rect.maxLat)/2.0;
       } else {
         lat = rect.maxLat;
       }
@@ -1208,7 +1205,7 @@ public abstract class BaseGeoPointTestCase extends LuceneTestCase {
           if (x == 1) {
             continue;
           }
-          lon = quantizeLon((rect.minLon+rect.maxLon)/2.0);
+          lon = (rect.minLon+rect.maxLon)/2.0;
         } else {
           lon = rect.maxLon;
         }
@@ -1220,6 +1217,9 @@ public abstract class BaseGeoPointTestCase extends LuceneTestCase {
     }
     IndexReader r = w.getReader();
     IndexSearcher s = newSearcher(r, false);
+
+    // queries and indexed points work in quantized space: for testing inclusiveness of exact edges it must be aware of index-time quantization!
+    rect = new Rectangle(quantizeLat(rect.minLat), quantizeLat(rect.maxLat), quantizeLon(rect.minLon), quantizeLon(rect.maxLon));
     // exact edge cases
     assertEquals(8, s.count(newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon)));
     
@@ -1294,7 +1294,8 @@ public abstract class BaseGeoPointTestCase extends LuceneTestCase {
       double lat = quantizeLat(latRaw);
       double lon = quantizeLon(lonRaw);
       Document doc = new Document();
-      addPointToDoc("field", doc, lat, lon);
+      // we don't want to doubly quantize
+      addPointToDoc("field", doc, latRaw, lonRaw);
       doc.add(new StoredField("lat", lat));
       doc.add(new StoredField("lon", lon));
       writer.addDocument(doc);
