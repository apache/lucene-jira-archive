Index: lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java	(working copy)
@@ -0,0 +1,222 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.List;
+
+import org.apache.lucene.util.CollectionUtil;
+
+class ConjunctionDISI extends DocIdSetIterator {
+
+  /**
+   * Recursively add {@code it} to the list of iterators that will give the
+   * approximation and two-phase iterators that will be used for confirmation.
+   */
+  private static void add(DocIdSetIterator it, List<DocIdSetIterator> allIterators, List<TwoPhaseDocIdSetIterator> twoPhaseIterators) {
+    if (it instanceof Scorer) {
+      // if we have a scorer, check if it supports two-phase iteration
+      TwoPhaseDocIdSetIterator twoPhaseIterator = ((Scorer) it).asTwoPhaseIterator();
+      if (twoPhaseIterator != null) {
+        // Note: 
+        add(twoPhaseIterator.approximation(), allIterators, twoPhaseIterators);
+        twoPhaseIterators.add(twoPhaseIterator);
+      } else {
+        allIterators.add(it);
+      }
+    } else if (it.getClass() == ConjunctionDISI.class) {
+      // if we have a conjunction, flatten it into this new instance
+      ConjunctionDISI disi = (ConjunctionDISI) it;
+      allIterators.add(disi.lead);
+      allIterators.addAll(Arrays.asList(disi.others));
+    } else if (it.getClass() == TwoPhase.class) {
+      // same here for two-phase conjunctions
+      TwoPhase disi = (TwoPhase) it;
+      allIterators.add(disi.lead);
+      allIterators.addAll(Arrays.asList(disi.others));
+      twoPhaseIterators.addAll(Arrays.asList(disi.twoPhaseView.twoPhaseIterators));
+    } else {
+      // no approximation support, use the iterator as-is
+      allIterators.add(it);
+    }
+  }
+
+  /** Create a conjunction over the provided iterators, taking advantage of
+   *  {@link TwoPhaseDocIdSetIterator}. */
+  public static ConjunctionDISI intersect(List<? extends DocIdSetIterator> iterators) {
+    final List<DocIdSetIterator> allIterators = new ArrayList<>();
+    final List<TwoPhaseDocIdSetIterator> twoPhaseIterators = new ArrayList<>();
+    for (DocIdSetIterator iterator : iterators) {
+      add(iterator, allIterators, twoPhaseIterators);
+    }
+
+    if (twoPhaseIterators.isEmpty()) {
+      return new ConjunctionDISI(allIterators);
+    } else {
+      return new TwoPhase(allIterators, twoPhaseIterators);
+    }
+  }
+
+  final DocIdSetIterator lead;
+  final DocIdSetIterator[] others;
+
+  private ConjunctionDISI(List<? extends DocIdSetIterator> iterators) {
+    // Sort the array the first time to allow the least frequent DocsEnum to
+    // lead the matching.
+    CollectionUtil.timSort(iterators, new Comparator<DocIdSetIterator>() {
+      @Override
+      public int compare(DocIdSetIterator o1, DocIdSetIterator o2) {
+        return Long.compare(o1.cost(), o2.cost());
+      }
+    });
+    lead = iterators.get(0);
+    others = iterators.subList(1, iterators.size()).toArray(new DocIdSetIterator[0]);
+  }
+
+  protected boolean matches() throws IOException {
+    return true;
+  }
+
+  TwoPhaseDocIdSetIterator asTwoPhaseIterator() {
+    return null;
+  }
+
+  private int doNext(int doc) throws IOException {
+    for(;;) {
+
+      if (doc == NO_MORE_DOCS) {
+        // we need this check because it is only ok to call #matches when positioned
+        return NO_MORE_DOCS;
+      }
+
+      advanceHead: for(;;) {
+        for (DocIdSetIterator other : others) {
+          // invariant: docsAndFreqs[i].doc <= doc at this point.
+
+          // docsAndFreqs[i].doc may already be equal to doc if we "broke advanceHead"
+          // on the previous iteration and the advance on the lead scorer exactly matched.
+          if (other.docID() < doc) {
+            final int next = other.advance(doc);
+
+            if (next > doc) {
+              // DocsEnum beyond the current doc - break and advance lead to the new highest doc.
+              doc = lead.advance(next);
+              break advanceHead;
+            }
+          }
+        }
+
+        if (matches()) {
+          // success - all DocsEnums are on the same doc
+          return doc;
+        } else {
+          doc = lead.nextDoc();
+          break advanceHead;
+        }
+      }
+    }
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    return doNext(lead.advance(target));
+  }
+
+  @Override
+  public int docID() {
+    return lead.docID();
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    return doNext(lead.nextDoc());
+  }
+
+  @Override
+  public long cost() {
+    return lead.cost();
+  }
+
+  /**
+   * {@link TwoPhaseDocIdSetIterator} view of a {@link TwoPhase} conjunction.
+   */
+  private static class TwoPhaseConjunctionDISI extends TwoPhaseDocIdSetIterator {
+
+    private final ConjunctionDISI approximation;
+    private final TwoPhaseDocIdSetIterator[] twoPhaseIterators;
+
+    private TwoPhaseConjunctionDISI(List<? extends DocIdSetIterator> iterators, List<TwoPhaseDocIdSetIterator> twoPhaseIterators) {
+      approximation = new ConjunctionDISI(iterators);
+      assert twoPhaseIterators.size() > 0;
+      this.twoPhaseIterators = twoPhaseIterators.toArray(new TwoPhaseDocIdSetIterator[0]);
+    }
+
+    @Override
+    public DocIdSetIterator approximation() {
+      return approximation;
+    }
+
+    @Override
+    public boolean matches() throws IOException {
+      for (TwoPhaseDocIdSetIterator twoPhaseIterator : twoPhaseIterators) {
+        if (twoPhaseIterator.matches() == false) {
+          return false;
+        }
+      }
+      return true;
+    }
+
+  }
+
+  /**
+   * A conjunction DISI built on top of approximations. This implementation
+   * verifies that documents actually match by consulting the provided
+   * {@link TwoPhaseDocIdSetIterator}s.
+   *
+   * Another important difference with {@link ConjunctionDISI} is that this
+   * implementation supports approximations too: the approximation of this
+   * impl is the conjunction of the approximations of the wrapped iterators.
+   * This allows eg. {@code +"A B" +C} to be approximated as
+   * {@code +(+A +B) +C}.
+   */
+  // NOTE: this is essentially the same as TwoPhaseDocIdSetIterator.asDocIdSetIterator
+  // but is its own impl in order to be able to expose a two-phase view
+  private static class TwoPhase extends ConjunctionDISI {
+
+    final TwoPhaseConjunctionDISI twoPhaseView;
+
+    private TwoPhase(List<? extends DocIdSetIterator> iterators, List<TwoPhaseDocIdSetIterator> twoPhaseIterators) {
+      super(iterators);
+      twoPhaseView = new TwoPhaseConjunctionDISI(iterators, twoPhaseIterators);
+    }
+
+    @Override
+    public TwoPhaseConjunctionDISI asTwoPhaseIterator() {
+      return twoPhaseView;
+    }
+
+    @Override
+    protected boolean matches() throws IOException {
+      return twoPhaseView.matches();
+    }
+  }
+
+}

Property changes on: lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java	(revision 1659465)
+++ lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java	(working copy)
@@ -20,18 +20,14 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Comparator;
 import java.util.List;
 
-import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.BytesRef;
 
 /** Scorer for conjunctions, sets of queries, all of which are required. */
 class ConjunctionScorer extends Scorer {
 
-  protected int lastDoc = -1;
-  protected final DocsAndFreqs[] docsAndFreqs;
-  private final DocsAndFreqs lead;
+  private final ConjunctionDISI disi;
   private final Scorer[] scorers;
   private final float coord;
 
@@ -44,68 +40,28 @@
     super(weight);
     assert required.containsAll(scorers);
     this.coord = coord;
-    this.docsAndFreqs = new DocsAndFreqs[required.size()];
-    for (int i = 0; i < required.size(); ++i) {
-      docsAndFreqs[i] = new DocsAndFreqs(required.get(i));
-    }
-    // Sort the array the first time to allow the least frequent DocsEnum to
-    // lead the matching.
-    ArrayUtil.timSort(docsAndFreqs, new Comparator<DocsAndFreqs>() {
-      @Override
-      public int compare(DocsAndFreqs o1, DocsAndFreqs o2) {
-        return Long.compare(o1.cost, o2.cost);
-      }
-    });
-
-    lead = docsAndFreqs[0]; // least frequent DocsEnum leads the intersection
-
+    this.disi = ConjunctionDISI.intersect(required);
     this.scorers = scorers.toArray(new Scorer[scorers.size()]);
   }
 
-  private int doNext(int doc) throws IOException {
-    for(;;) {
-      // doc may already be NO_MORE_DOCS here, but we don't check explicitly
-      // since all scorers should advance to NO_MORE_DOCS, match, then
-      // return that value.
-      advanceHead: for(;;) {
-        for (int i = 1; i < docsAndFreqs.length; i++) {
-          // invariant: docsAndFreqs[i].doc <= doc at this point.
-
-          // docsAndFreqs[i].doc may already be equal to doc if we "broke advanceHead"
-          // on the previous iteration and the advance on the lead scorer exactly matched.
-          if (docsAndFreqs[i].doc < doc) {
-            docsAndFreqs[i].doc = docsAndFreqs[i].iterator.advance(doc);
-
-            if (docsAndFreqs[i].doc > doc) {
-              // DocsEnum beyond the current doc - break and advance lead to the new highest doc.
-              doc = docsAndFreqs[i].doc;
-              break advanceHead;
-            }
-          }
-        }
-        // success - all DocsEnums are on the same doc
-        return doc;
-      }
-      // advance head for next iteration
-      doc = lead.doc = lead.iterator.advance(doc);
-    }
+  @Override
+  public TwoPhaseDocIdSetIterator asTwoPhaseIterator() {
+    return disi.asTwoPhaseIterator();
   }
 
   @Override
   public int advance(int target) throws IOException {
-    lead.doc = lead.iterator.advance(target);
-    return lastDoc = doNext(lead.doc);
+    return disi.advance(target);
   }
 
   @Override
   public int docID() {
-    return lastDoc;
+    return disi.docID();
   }
 
   @Override
   public int nextDoc() throws IOException {
-    lead.doc = lead.iterator.nextDoc();
-    return lastDoc = doNext(lead.doc);
+    return disi.nextDoc();
   }
 
   @Override
@@ -120,7 +76,7 @@
 
   @Override
   public int freq() {
-    return docsAndFreqs.length;
+    return scorers.length;
   }
 
   @Override
@@ -145,12 +101,12 @@
 
   @Override
   public long cost() {
-    return lead.iterator.cost();
+    return disi.cost();
   }
 
   @Override
   public Collection<ChildScorer> getChildren() {
-    ArrayList<ChildScorer> children = new ArrayList<>(docsAndFreqs.length);
+    ArrayList<ChildScorer> children = new ArrayList<>();
     for (Scorer scorer : scorers) {
       children.add(new ChildScorer(scorer, "MUST"));
     }
Index: lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java	(revision 1659465)
+++ lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java	(working copy)
@@ -143,4 +143,5 @@
    * completely inaccurate.
    */
   public abstract long cost();
+
 }
Index: lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer.java	(revision 1659465)
+++ lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer.java	(working copy)
@@ -18,106 +18,45 @@
  */
 
 import java.io.IOException;
-import java.util.Arrays;
 
-import org.apache.lucene.index.*;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.util.BytesRef;
 
 final class ExactPhraseScorer extends Scorer {
-  private final int endMinus1;
 
-  private final static int CHUNK = 4096;
-
-  private int gen;
-  private final int[] counts = new int[CHUNK];
-  private final int[] gens = new int[CHUNK];
-
-  private final long cost;
-
-  private final static class ChunkState {
-    final PostingsEnum posEnum;
-    final int offset;
-    int posUpto;
-    int posLimit;
-    int pos;
-    int lastPos;
-
-    public ChunkState(PostingsEnum posEnum, int offset) {
-      this.posEnum = posEnum;
-      this.offset = offset;
-    }
-  }
-
-  private final ChunkState[] chunkStates;
-  private final PostingsEnum lead;
-
-  private int docID = -1;
-  private int freq;
-
+  private final TwoPhaseExactPhraseDISI twoPhaseDisi;
+  private final DocIdSetIterator disi;
   private final Similarity.SimScorer docScorer;
-  private final boolean needsScores;
   
   ExactPhraseScorer(Weight weight, PhraseQuery.PostingsAndFreq[] postings,
                     Similarity.SimScorer docScorer, boolean needsScores) throws IOException {
     super(weight);
     this.docScorer = docScorer;
-    this.needsScores = needsScores;
-
-    chunkStates = new ChunkState[postings.length];
-
-    endMinus1 = postings.length-1;
-    
-    lead = postings[0].postings;
-    // min(cost)
-    cost = lead.cost();
-
-    for(int i=0;i<postings.length;i++) {
-      chunkStates[i] = new ChunkState(postings[i].postings, -postings[i].position);
-    }
+    this.twoPhaseDisi = new TwoPhaseExactPhraseDISI(postings, needsScores);
+    this.disi = TwoPhaseDocIdSetIterator.asDocIdSetIterator(twoPhaseDisi);
   }
-  
-  private int doNext(int doc) throws IOException {
-    for(;;) {
-      // TODO: don't dup this logic from conjunctionscorer :)
-      advanceHead: for(;;) {
-        for (int i = 1; i < chunkStates.length; i++) {
-          final PostingsEnum de = chunkStates[i].posEnum;
-          if (de.docID() < doc) {
-            int d = de.advance(doc);
 
-            if (d > doc) {
-              // DocsEnum beyond the current doc - break and advance lead to the new highest doc.
-              doc = d;
-              break advanceHead;
-            }
-          }
-        }
-        // all DocsEnums are on the same doc
-        if (doc == NO_MORE_DOCS) {
-          return doc;
-        } else if (phraseFreq() > 0) {
-          return doc;            // success: matches phrase
-        } else {
-          doc = lead.nextDoc();  // doesn't match phrase
-        }
-      }
-      // advance head for next iteration
-      doc = lead.advance(doc);
-    }
+  @Override
+  public TwoPhaseDocIdSetIterator asTwoPhaseIterator() {
+    return twoPhaseDisi;
   }
 
   @Override
   public int nextDoc() throws IOException {
-    return docID = doNext(lead.nextDoc());
+    return disi.nextDoc();
   }
 
   @Override
   public int advance(int target) throws IOException {
-    return docID = doNext(lead.advance(target));
+    return disi.advance(target);
   }
 
   @Override
+  public long cost() {
+    return disi.cost();
+  }
+
+  @Override
   public String toString() {
     return "ExactPhraseScorer(" + weight + ")";
   }
@@ -124,7 +63,7 @@
 
   @Override
   public int freq() {
-    return freq;
+    return twoPhaseDisi.freq();
   }
 
   @Override
@@ -149,137 +88,12 @@
 
   @Override
   public int docID() {
-    return docID;
+    return disi.docID();
   }
 
   @Override
   public float score() {
-    return docScorer.score(docID, freq);
+    return docScorer.score(docID(), freq());
   }
 
-  private int phraseFreq() throws IOException {
-
-    freq = 0;
-
-    // init chunks
-    for(int i=0;i<chunkStates.length;i++) {
-      final ChunkState cs = chunkStates[i];
-      cs.posLimit = cs.posEnum.freq();
-      cs.pos = cs.offset + cs.posEnum.nextPosition();
-      cs.posUpto = 1;
-      cs.lastPos = -1;
-    }
-
-    int chunkStart = 0;
-    int chunkEnd = CHUNK;
-
-    // process chunk by chunk
-    boolean end = false;
-
-    // TODO: we could fold in chunkStart into offset and
-    // save one subtract per pos incr
-
-    while(!end) {
-
-      gen++;
-
-      if (gen == 0) {
-        // wraparound
-        Arrays.fill(gens, 0);
-        gen++;
-      }
-
-      // first term
-      {
-        final ChunkState cs = chunkStates[0];
-        while(cs.pos < chunkEnd) {
-          if (cs.pos > cs.lastPos) {
-            cs.lastPos = cs.pos;
-            final int posIndex = cs.pos - chunkStart;
-            counts[posIndex] = 1;
-            assert gens[posIndex] != gen;
-            gens[posIndex] = gen;
-          }
-
-          if (cs.posUpto == cs.posLimit) {
-            end = true;
-            break;
-          }
-          cs.posUpto++;
-          cs.pos = cs.offset + cs.posEnum.nextPosition();
-        }
-      }
-
-      // middle terms
-      boolean any = true;
-      for(int t=1;t<endMinus1;t++) {
-        final ChunkState cs = chunkStates[t];
-        any = false;
-        while(cs.pos < chunkEnd) {
-          if (cs.pos > cs.lastPos) {
-            cs.lastPos = cs.pos;
-            final int posIndex = cs.pos - chunkStart;
-            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == t) {
-              // viable
-              counts[posIndex]++;
-              any = true;
-            }
-          }
-
-          if (cs.posUpto == cs.posLimit) {
-            end = true;
-            break;
-          }
-          cs.posUpto++;
-          cs.pos = cs.offset + cs.posEnum.nextPosition();
-        }
-
-        if (!any) {
-          break;
-        }
-      }
-
-      if (!any) {
-        // petered out for this chunk
-        chunkStart += CHUNK;
-        chunkEnd += CHUNK;
-        continue;
-      }
-
-      // last term
-
-      {
-        final ChunkState cs = chunkStates[endMinus1];
-        while(cs.pos < chunkEnd) {
-          if (cs.pos > cs.lastPos) {
-            cs.lastPos = cs.pos;
-            final int posIndex = cs.pos - chunkStart;
-            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == endMinus1) {
-              freq++;
-              if (!needsScores) {
-                return freq; // we determined there was a match.
-              }
-            }
-          }
-
-          if (cs.posUpto == cs.posLimit) {
-            end = true;
-            break;
-          }
-          cs.posUpto++;
-          cs.pos = cs.offset + cs.posEnum.nextPosition();
-        }
-      }
-
-      chunkStart += CHUNK;
-      chunkEnd += CHUNK;
-    }
-
-    return freq;
-  }
-
-  @Override
-  public long cost() {
-    return cost;
-  }
 }
Index: lucene/core/src/java/org/apache/lucene/search/Scorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/Scorer.java	(revision 1659465)
+++ lucene/core/src/java/org/apache/lucene/search/Scorer.java	(working copy)
@@ -60,7 +60,7 @@
    * {@link LeafCollector#collect}.
    */
   public abstract float score() throws IOException;
-  
+
   /** returns parent Weight
    * @lucene.experimental
    */
@@ -99,4 +99,23 @@
       this.relationship = relationship;
     }
   }
+
+  /**
+   * Optional method: Return a {@link TwoPhaseDocIdSetIterator} view of this
+   * {@link Scorer}. A return value of {@code null} indicates that
+   * two-phase iteration is not supported.
+   *
+   * Note that the returned {@link TwoPhaseDocIdSetIterator}'s
+   * {@link TwoPhaseDocIdSetIterator#approximation() approximation} must
+   * advance synchronously with this iterator: advancing the approximation must
+   * advance this iterator and vice-versa.
+   *
+   * Implementing this method is typically useful on {@link Scorer}s
+   * that have a high per-document overhead in order to confirm matches.
+   *
+   * The default implementation returns {@code null}.
+   */
+  public TwoPhaseDocIdSetIterator asTwoPhaseIterator() {
+    return null;
+  }
 }
Index: lucene/core/src/java/org/apache/lucene/search/TwoPhaseDocIdSetIterator.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/TwoPhaseDocIdSetIterator.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/search/TwoPhaseDocIdSetIterator.java	(working copy)
@@ -0,0 +1,81 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+/**
+ * An approximation of a {@link DocIdSetIterator}. When the {@link #approximation()}'s
+ * {@link DocIdSetIterator#nextDoc()} or {@link DocIdSetIterator#advance(int)}
+ * return, {@link #matches()} needs to be checked in order to know whether the
+ * returned doc ID actually matches.
+ * @lucene.experimental
+ */
+public abstract class TwoPhaseDocIdSetIterator {
+
+  /** Return a {@link DocIdSetIterator} view of the provided
+   *  {@link TwoPhaseDocIdSetIterator}. */
+  public static DocIdSetIterator asDocIdSetIterator(TwoPhaseDocIdSetIterator twoPhaseIterator) {
+    final DocIdSetIterator approximation = twoPhaseIterator.approximation();
+    return new DocIdSetIterator() {
+
+      @Override
+      public int docID() {
+        return approximation.docID();
+      }
+
+      @Override
+      public int nextDoc() throws IOException {
+        return doNext(approximation.nextDoc());
+      }
+
+      @Override
+      public int advance(int target) throws IOException {
+        return doNext(approximation.advance(target));
+      }
+
+      private int doNext(int doc) throws IOException {
+        for (;; doc = approximation.nextDoc()) {
+          if (doc == NO_MORE_DOCS) {
+            return NO_MORE_DOCS;
+          } else if (twoPhaseIterator.matches()) {
+            return doc;
+          }
+        }
+      }
+
+      @Override
+      public long cost() {
+        return approximation.cost();
+      }
+
+    };
+  }
+
+  /** Return an approximation. The returned {@link DocIdSetIterator} is a
+   *  superset of the matching documents, and each match needs to be confirmed
+   *  with {@link #matches()} in order to know whether it matches or not. */
+  public abstract DocIdSetIterator approximation();
+
+  /** Return whether the current doc ID that the iterator is on matches. This
+   *  method should only be called when the iterator is positionned, ie. not
+   *  when {@link DocIdSetIterator#docID()} is {@code -1} or
+   *  {@link DocIdSetIterator#NO_MORE_DOCS}. */
+  public abstract boolean matches() throws IOException;
+
+}

Property changes on: lucene/core/src/java/org/apache/lucene/search/TwoPhaseDocIdSetIterator.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/java/org/apache/lucene/search/TwoPhaseExactPhraseDISI.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/TwoPhaseExactPhraseDISI.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/search/TwoPhaseExactPhraseDISI.java	(working copy)
@@ -0,0 +1,214 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.lucene.index.PostingsEnum;
+
+/** An approximation of {@link ExactPhraseScorer}. Iteration returns doc IDs of
+ *  the intersection between terms and confirmation checks positions. */
+final class TwoPhaseExactPhraseDISI extends TwoPhaseDocIdSetIterator {
+
+  final ConjunctionDISI conjunction;
+
+  private final int endMinus1;
+
+  private final static int CHUNK = 4096;
+
+  private int gen;
+  private final int[] counts = new int[CHUNK];
+  private final int[] gens = new int[CHUNK];
+
+  private final static class ChunkState {
+    final PostingsEnum posEnum;
+    final int offset;
+    int posUpto;
+    int posLimit;
+    int pos;
+    int lastPos;
+
+    public ChunkState(PostingsEnum posEnum, int offset) {
+      this.posEnum = posEnum;
+      this.offset = offset;
+    }
+  }
+
+  private final ChunkState[] chunkStates;
+
+  private int freq;
+
+  private final boolean needsFreqs;
+
+  TwoPhaseExactPhraseDISI(PhraseQuery.PostingsAndFreq[] postings, boolean needsFreqs) throws IOException {
+    this.needsFreqs = needsFreqs;
+
+    chunkStates = new ChunkState[postings.length];
+
+    endMinus1 = postings.length-1;
+
+    List<DocIdSetIterator> iterators = new ArrayList<>();
+    for(int i = 0; i < postings.length; i++) {
+      chunkStates[i] = new ChunkState(postings[i].postings, -postings[i].position);
+      iterators.add(postings[i].postings);
+    }
+    conjunction = ConjunctionDISI.intersect(iterators);
+  }
+
+  @Override
+  public DocIdSetIterator approximation() {
+    return conjunction;
+  }
+
+  @Override
+  public boolean matches() throws IOException {
+    // TODO: matches should return as soon as one match is found, and then we
+    // would only continue computing it when freq() is called?
+    return phraseFreq() > 0;
+  }
+
+  /** Return the number of matches. NOTE: it is only legal to call this after
+   *  {@link #matches()} returned. */
+  int freq() {
+    return freq;
+  }
+
+  private int phraseFreq() throws IOException {
+
+    freq = 0;
+
+    // init chunks
+    for(int i=0;i<chunkStates.length;i++) {
+      final ChunkState cs = chunkStates[i];
+      cs.posLimit = cs.posEnum.freq();
+      cs.pos = cs.offset + cs.posEnum.nextPosition();
+      cs.posUpto = 1;
+      cs.lastPos = -1;
+    }
+
+    int chunkStart = 0;
+    int chunkEnd = CHUNK;
+
+    // process chunk by chunk
+    boolean end = false;
+
+    // TODO: we could fold in chunkStart into offset and
+    // save one subtract per pos incr
+
+    while(!end) {
+
+      gen++;
+
+      if (gen == 0) {
+        // wraparound
+        Arrays.fill(gens, 0);
+        gen++;
+      }
+
+      // first term
+      {
+        final ChunkState cs = chunkStates[0];
+        while(cs.pos < chunkEnd) {
+          if (cs.pos > cs.lastPos) {
+            cs.lastPos = cs.pos;
+            final int posIndex = cs.pos - chunkStart;
+            counts[posIndex] = 1;
+            assert gens[posIndex] != gen;
+            gens[posIndex] = gen;
+          }
+
+          if (cs.posUpto == cs.posLimit) {
+            end = true;
+            break;
+          }
+          cs.posUpto++;
+          cs.pos = cs.offset + cs.posEnum.nextPosition();
+        }
+      }
+
+      // middle terms
+      boolean any = true;
+      for(int t=1;t<endMinus1;t++) {
+        final ChunkState cs = chunkStates[t];
+        any = false;
+        while(cs.pos < chunkEnd) {
+          if (cs.pos > cs.lastPos) {
+            cs.lastPos = cs.pos;
+            final int posIndex = cs.pos - chunkStart;
+            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == t) {
+              // viable
+              counts[posIndex]++;
+              any = true;
+            }
+          }
+
+          if (cs.posUpto == cs.posLimit) {
+            end = true;
+            break;
+          }
+          cs.posUpto++;
+          cs.pos = cs.offset + cs.posEnum.nextPosition();
+        }
+
+        if (!any) {
+          break;
+        }
+      }
+
+      if (!any) {
+        // petered out for this chunk
+        chunkStart += CHUNK;
+        chunkEnd += CHUNK;
+        continue;
+      }
+
+      // last term
+
+      {
+        final ChunkState cs = chunkStates[endMinus1];
+        while(cs.pos < chunkEnd) {
+          if (cs.pos > cs.lastPos) {
+            cs.lastPos = cs.pos;
+            final int posIndex = cs.pos - chunkStart;
+            if (posIndex >= 0 && gens[posIndex] == gen && counts[posIndex] == endMinus1) {
+              freq++;
+              if (!needsFreqs) {
+                return freq; // we determined there was a match.
+              }
+            }
+          }
+
+          if (cs.posUpto == cs.posLimit) {
+            end = true;
+            break;
+          }
+          cs.posUpto++;
+          cs.pos = cs.offset + cs.posEnum.nextPosition();
+        }
+      }
+
+      chunkStart += CHUNK;
+      chunkEnd += CHUNK;
+    }
+
+    return freq;
+  }
+}

Property changes on: lucene/core/src/java/org/apache/lucene/search/TwoPhaseExactPhraseDISI.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java	(revision 1659465)
+++ lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java	(working copy)
@@ -590,4 +590,33 @@
     w.close();
     dir.close();
   }
+
+  public void testConjunctionSupportsApproximations() throws IOException {
+    Directory dir = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    Field f = newTextField("field", "a b c", Field.Store.NO);
+    doc.add(f);
+    w.addDocument(doc);
+    w.commit();
+
+    DirectoryReader reader = w.getReader();
+    final IndexSearcher searcher = new IndexSearcher(reader);
+
+    PhraseQuery pq = new PhraseQuery();
+    pq.add(new Term("field", "a"));
+    pq.add(new Term("field", "b"));
+
+    BooleanQuery q = new BooleanQuery();
+    q.add(pq, Occur.MUST);
+    q.add(new TermQuery(new Term("field", "c")), Occur.FILTER);
+
+    final Weight weight = searcher.createNormalizedWeight(q, random().nextBoolean());
+    final Scorer scorer = weight.scorer(reader.leaves().get(0), null);
+    assertNotNull(scorer.asTwoPhaseIterator());
+
+    reader.close();
+    w.close();
+    dir.close();
+  }
 }
Index: lucene/core/src/test/org/apache/lucene/search/TestConjunctionDISI.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestConjunctionDISI.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/search/TestConjunctionDISI.java	(working copy)
@@ -0,0 +1,243 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.apache.lucene.util.BitDocIdSet;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.FixedBitSet;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+
+public class TestConjunctionDISI extends LuceneTestCase {
+
+  private static TwoPhaseDocIdSetIterator approximation(final DocIdSetIterator iterator, final FixedBitSet confirmed) {
+    return new TwoPhaseDocIdSetIterator() {
+
+      @Override
+      public DocIdSetIterator approximation() {
+        return iterator;
+      }
+
+      @Override
+      public boolean matches() throws IOException {
+        return confirmed.get(iterator.docID());
+      }
+    };
+  }
+
+  private static Scorer scorer(final TwoPhaseDocIdSetIterator twoPhaseIterator) {
+    return new Scorer(null) {
+
+      @Override
+      public TwoPhaseDocIdSetIterator asTwoPhaseIterator() {
+        return twoPhaseIterator;
+      }
+
+      @Override
+      public int docID() {
+        throw new UnsupportedOperationException("ConjunctionDISI should call the two-phase iterator");
+      }
+
+      @Override
+      public int nextDoc() throws IOException {
+        throw new UnsupportedOperationException("ConjunctionDISI should call the two-phase iterator");
+      }
+
+      @Override
+      public int advance(int target) throws IOException {
+        throw new UnsupportedOperationException("ConjunctionDISI should call the two-phase iterator");
+      }
+
+      @Override
+      public long cost() {
+        throw new UnsupportedOperationException("ConjunctionDISI should call the two-phase iterator");
+      }
+
+      @Override
+      public float score() throws IOException {
+        return 0;
+      }
+
+      @Override
+      public int freq() throws IOException {
+        return 0;
+      }
+
+      @Override
+      public int nextPosition() throws IOException {
+        return 0;
+      }
+
+      @Override
+      public int startOffset() throws IOException {
+        return 0;
+      }
+
+      @Override
+      public int endOffset() throws IOException {
+        return 0;
+      }
+
+      @Override
+      public BytesRef getPayload() throws IOException {
+        return null;
+      }
+
+    };
+  }
+
+  private static FixedBitSet randomSet(int maxDoc) {
+    final int step = TestUtil.nextInt(random(), 1, 10);
+    FixedBitSet set = new FixedBitSet(maxDoc);
+    for (int doc = random().nextInt(step); doc < maxDoc; doc += TestUtil.nextInt(random(), 1, step)) {
+      set.set(doc);
+    }
+    return set;
+  }
+
+  private static FixedBitSet clearRandomBits(FixedBitSet other) {
+    final FixedBitSet set = new FixedBitSet(other.length());
+    set.or(other);
+    for (int i = 0; i < set.length(); ++i) {
+      if (random().nextBoolean()) {
+        set.clear(i);
+      }
+    }
+    return set;
+  }
+
+  private static FixedBitSet intersect(FixedBitSet[] bitSets) {
+    final FixedBitSet intersection = new FixedBitSet(bitSets[0].length());
+    intersection.or(bitSets[0]);
+    for (int i = 1; i < bitSets.length; ++i) {
+      intersection.and(bitSets[i]);
+    }
+    return intersection;
+  }
+
+  private static FixedBitSet toBitSet(int maxDoc, DocIdSetIterator iterator) throws IOException {
+    final FixedBitSet set = new FixedBitSet(maxDoc);
+    for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {
+      set.set(doc);
+    }
+    return set;
+  }
+
+  public void testConjunction() throws IOException {
+    final int iters = atLeast(100);
+    for (int iter = 0; iter < iters; ++iter) {
+      final int maxDoc = TestUtil.nextInt(random(), 100, 10000);
+      final int numIterators = TestUtil.nextInt(random(), 2, 5);
+      final FixedBitSet[] sets = new FixedBitSet[numIterators];
+      final DocIdSetIterator[] iterators = new DocIdSetIterator[numIterators];
+      for (int i = 0; i < iterators.length; ++i) {
+        final FixedBitSet set = randomSet(maxDoc);
+        if (random().nextBoolean()) {
+          // simple iterator
+          sets[i] = set;
+          iterators[i] = new BitDocIdSet(set).iterator();
+        } else {
+          // scorer with approximation
+          final FixedBitSet confirmed = clearRandomBits(set);
+          sets[i] = confirmed;
+          final TwoPhaseDocIdSetIterator approximation = approximation(new BitDocIdSet(set).iterator(), confirmed);
+          iterators[i] = scorer(approximation);
+        }
+      }
+
+      final ConjunctionDISI conjunction = ConjunctionDISI.intersect(Arrays.asList(iterators));
+      assertEquals(intersect(sets), toBitSet(maxDoc, conjunction));
+    }
+  }
+
+  public void testConjunctionApproximation() throws IOException {
+    final int iters = atLeast(100);
+    for (int iter = 0; iter < iters; ++iter) {
+      final int maxDoc = TestUtil.nextInt(random(), 100, 10000);
+      final int numIterators = TestUtil.nextInt(random(), 2, 5);
+      final FixedBitSet[] sets = new FixedBitSet[numIterators];
+      final DocIdSetIterator[] iterators = new DocIdSetIterator[numIterators];
+      boolean hasApproximation = false;
+      for (int i = 0; i < iterators.length; ++i) {
+        final FixedBitSet set = randomSet(maxDoc);
+        if (random().nextBoolean()) {
+          // simple iterator
+          sets[i] = set;
+          iterators[i] = new BitDocIdSet(set).iterator();
+        } else {
+          // scorer with approximation
+          final FixedBitSet confirmed = clearRandomBits(set);
+          sets[i] = confirmed;
+          final TwoPhaseDocIdSetIterator approximation = approximation(new BitDocIdSet(set).iterator(), confirmed);
+          iterators[i] = scorer(approximation);
+          hasApproximation = true;
+        }
+      }
+
+      final ConjunctionDISI conjunction = ConjunctionDISI.intersect(Arrays.asList(iterators));
+      TwoPhaseDocIdSetIterator twoPhaseIterator = conjunction.asTwoPhaseIterator();
+      assertEquals(hasApproximation, twoPhaseIterator != null);
+      if (hasApproximation) {
+        assertEquals(intersect(sets), toBitSet(maxDoc, conjunction));
+      }
+    }
+  }
+
+  public void testRecursiveConjunctionApproximation() throws IOException {
+    final int iters = atLeast(100);
+    for (int iter = 0; iter < iters; ++iter) {
+      final int maxDoc = TestUtil.nextInt(random(), 100, 10000);
+      final int numIterators = TestUtil.nextInt(random(), 2, 5);
+      final FixedBitSet[] sets = new FixedBitSet[numIterators];
+      DocIdSetIterator conjunction = null;
+      boolean hasApproximation = false;
+      for (int i = 0; i < numIterators; ++i) {
+        final FixedBitSet set = randomSet(maxDoc);
+        final DocIdSetIterator newIterator;
+        if (random().nextBoolean()) {
+          // simple iterator
+          sets[i] = set;
+          newIterator = new BitDocIdSet(set).iterator();
+        } else {
+          // scorer with approximation
+          final FixedBitSet confirmed = clearRandomBits(set);
+          sets[i] = confirmed;
+          final TwoPhaseDocIdSetIterator approximation = approximation(new BitDocIdSet(set).iterator(), confirmed);
+          newIterator = scorer(approximation);
+          hasApproximation = true;
+        }
+
+        if (conjunction == null) {
+          conjunction = newIterator;
+        } else {
+          conjunction = ConjunctionDISI.intersect(Arrays.asList(conjunction, newIterator));
+        }
+      }
+
+      TwoPhaseDocIdSetIterator twoPhaseIterator = ((ConjunctionDISI) conjunction).asTwoPhaseIterator();
+      assertEquals(hasApproximation, twoPhaseIterator != null);
+      if (hasApproximation) {
+        assertEquals(intersect(sets), toBitSet(maxDoc, conjunction));
+      }
+    }
+  }
+
+}

Property changes on: lucene/core/src/test/org/apache/lucene/search/TestConjunctionDISI.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
