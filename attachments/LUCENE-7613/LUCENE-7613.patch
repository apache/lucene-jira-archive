diff --git a/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java b/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
index c718dc9..ecca69a 100644
--- a/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
@@ -29,11 +29,14 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
+import org.apache.lucene.search.MatchNoDocsQuery;
+
 
 /**
  * A query that treats multiple terms as synonyms.
@@ -45,6 +48,7 @@ import org.apache.lucene.search.similarities.Similarity.SimScorer;
  */
 public final class SynonymQuery extends Query {
   private final Term terms[];
+  private final String field;
 
   /**
    * Creates a new SynonymQuery, matching any of the supplied terms.
@@ -62,16 +66,23 @@ public final class SynonymQuery extends Query {
         throw new IllegalArgumentException("Synonyms must be across the same field");
       }
     }
+    this.field = field;
     if (terms.length > BooleanQuery.getMaxClauseCount()) {
       throw new BooleanQuery.TooManyClauses();
     }
     Arrays.sort(this.terms);
   }
 
+  /** The terms to be treated as synonyms. */
   public List<Term> getTerms() {
     return Collections.unmodifiableList(Arrays.asList(terms));
   }
 
+  /** The field of the terms. */
+  public String getField() {
+    return field;
+  }
+
   @Override
   public String toString(String field) {
     StringBuilder builder = new StringBuilder("Synonym(");
@@ -101,7 +112,7 @@ public final class SynonymQuery extends Query {
   public Query rewrite(IndexReader reader) throws IOException {
     // optimize zero and single term cases
     if (terms.length == 0) {
-      return new BooleanQuery.Builder().build();
+      return new MatchNoDocsQuery();
     }
     if (terms.length == 1) {
       return new TermQuery(terms[0]);
@@ -123,7 +134,7 @@ public final class SynonymQuery extends Query {
     }
   }
 
-  class SynonymWeight extends Weight {
+  public class SynonymWeight extends Weight {
     private final TermContext termContexts[];
     private final Similarity similarity;
     private final Similarity.SimWeight simWeight;
@@ -183,20 +194,42 @@ public final class SynonymQuery extends Query {
       return Explanation.noMatch("no matching term");
     }
 
+    /**
+     * Expert: Return a SimScorer for this context.
+     * Public only for use in the spans package.
+     * @param context the LeafReaderContext
+     * @return a SimWeight
+     * @throws IOException on error
+     */
+    public Similarity.SimScorer getSimScorer(LeafReaderContext context) throws IOException {
+      return similarity.simScorer(simWeight, context);
+    }
+
+    /**
+     * Expert: Return a TermContext array in the same order as the terms.
+     * Public only for use in the spans package, do not modify.
+     */
+    public TermContext[] getTermContexts() {
+      return termContexts;
+    }
+
     @Override
     public Scorer scorer(LeafReaderContext context) throws IOException {
-      Similarity.SimScorer simScorer = similarity.simScorer(simWeight, context);
+      Similarity.SimScorer simScorer = getSimScorer(context);
       // we use termscorers + disjunction as an impl detail
       List<Scorer> subScorers = new ArrayList<>();
+      Terms fieldTerms = context.reader().terms(field);
+      if (fieldTerms != null) {
+        TermsEnum termsEnum = fieldTerms.iterator();
         for (int i = 0; i < terms.length; i++) {
           TermState state = termContexts[i].get(context.ord);
           if (state != null) {
-          TermsEnum termsEnum = context.reader().terms(terms[i].field()).iterator();
             termsEnum.seekExact(terms[i].bytes(), state);
             PostingsEnum postings = termsEnum.postings(null, PostingsEnum.FREQS);
             subScorers.add(new TermScorer(this, postings, simScorer));
           }
         }
+      }
       if (subScorers.isEmpty()) {
         return null;
       } else if (subScorers.size() == 1) {
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/DisjunctionSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/DisjunctionSpans.java
new file mode 100644
index 0000000..0396a82
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/DisjunctionSpans.java
@@ -0,0 +1,245 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search.spans;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.lucene.search.DisiPriorityQueue;
+import org.apache.lucene.search.DisiWrapper;
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.DisjunctionDISIApproximation;
+
+
+/**
+ * A spans that merges given spans.
+ *
+ * @lucene.experimental
+ */
+public class DisjunctionSpans extends Spans {
+  protected final SpanQuery spanQuery;
+  protected final List<Spans> subSpans;
+  protected final DisiPriorityQueue byDocQueue;
+  protected final SpanPositionQueue byPositionQueue;
+  protected Spans topPositionSpans;
+
+  /** Construct a DisjunctionSpans.
+   * @param spanQuery   The query that provides the subSpans.
+   * @param subSpans    Over which the disjunction is to be taken.
+   */
+  public DisjunctionSpans(SpanQuery spanQuery, List<Spans> subSpans) {
+    this.spanQuery = spanQuery; // for toString() only
+    this.subSpans = subSpans;
+    byDocQueue = new DisiPriorityQueue(subSpans.size());
+    for (Spans spans : subSpans) {
+      byDocQueue.add(new DisiWrapper(spans));
+    }
+    byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1
+    topPositionSpans = null;
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    topPositionSpans = null;
+    DisiWrapper topDocSpans = byDocQueue.top();
+    int currentDoc = topDocSpans.doc;
+    do {
+      topDocSpans.doc = topDocSpans.iterator.nextDoc();
+      topDocSpans = byDocQueue.updateTop();
+    } while (topDocSpans.doc == currentDoc);
+    return topDocSpans.doc;
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    topPositionSpans = null;
+    DisiWrapper topDocSpans = byDocQueue.top();
+    do {
+      topDocSpans.doc = topDocSpans.iterator.advance(target);
+      topDocSpans = byDocQueue.updateTop();
+    } while (topDocSpans.doc < target);
+    return topDocSpans.doc;
+  }
+
+  @Override
+  public int docID() {
+    DisiWrapper topDocSpans = byDocQueue.top();
+    return topDocSpans.doc;
+  }
+
+  @Override
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    float sumMatchCost = 0; // See also DisjunctionScorer.asTwoPhaseIterator()
+    long sumApproxCost = 0;
+
+    for (DisiWrapper w : byDocQueue) {
+      if (w.twoPhaseView != null) {
+        long costWeight = (w.cost <= 1) ? 1 : w.cost;
+        sumMatchCost += w.twoPhaseView.matchCost() * costWeight;
+        sumApproxCost += costWeight;
+      }
+    }
+
+    if (sumApproxCost == 0) { // no sub spans supports approximations
+      computePositionsCost();
+      return null;
+    }
+
+    final float matchCost = sumMatchCost / sumApproxCost;
+
+    return new TwoPhaseIterator(new DisjunctionDISIApproximation(byDocQueue)) {
+      @Override
+      public boolean matches() throws IOException {
+        return twoPhaseCurrentDocMatches();
+      }
+
+      @Override
+      public float matchCost() {
+        return matchCost;
+      }
+    };
+  }
+
+  float positionsCost = -1;
+
+  void computePositionsCost() {
+    float sumPositionsCost = 0;
+    long sumCost = 0;
+    for (DisiWrapper w : byDocQueue) {
+      long costWeight = (w.cost <= 1) ? 1 : w.cost;
+      sumPositionsCost += w.spans.positionsCost() * costWeight;
+      sumCost += costWeight;
+    }
+    positionsCost = sumPositionsCost / sumCost;
+  }
+
+  @Override
+  public float positionsCost() {
+    // This may be called when asTwoPhaseIterator returned null,
+    // which happens when none of the sub spans supports approximations.
+    assert positionsCost > 0;
+    return positionsCost;
+  }
+
+  int lastDocTwoPhaseMatched = -1;
+
+  boolean twoPhaseCurrentDocMatches() throws IOException {
+    DisiWrapper listAtCurrentDoc = byDocQueue.topList();
+    // remove the head of the list as long as it does not match
+    final int currentDoc = listAtCurrentDoc.doc;
+    while (listAtCurrentDoc.twoPhaseView != null) {
+      if (listAtCurrentDoc.twoPhaseView.matches()) {
+        // use this spans for positions at current doc:
+        listAtCurrentDoc.lastApproxMatchDoc = currentDoc;
+        break;
+      }
+      // do not use this spans for positions at current doc:
+      listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;
+      listAtCurrentDoc = listAtCurrentDoc.next;
+      if (listAtCurrentDoc == null) {
+        return false;
+      }
+    }
+    lastDocTwoPhaseMatched = currentDoc;
+    topPositionSpans = null;
+    return true;
+  }
+
+  void fillPositionQueue() throws IOException { // called at first nextStartPosition
+    assert byPositionQueue.size() == 0;
+    // add all matching Spans at current doc to byPositionQueue
+    DisiWrapper listAtCurrentDoc = byDocQueue.topList();
+    while (listAtCurrentDoc != null) {
+      Spans spansAtDoc = listAtCurrentDoc.spans;
+      if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation
+        if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation
+          if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false
+            spansAtDoc = null;
+          } else {
+            if (listAtCurrentDoc.lastApproxMatchDoc != listAtCurrentDoc.doc) {
+              if (!listAtCurrentDoc.twoPhaseView.matches()) {
+                spansAtDoc = null;
+              }
+            }
+          }
+        }
+      }
+
+      if (spansAtDoc != null) {
+        assert spansAtDoc.docID() == listAtCurrentDoc.doc;
+        assert spansAtDoc.startPosition() == -1;
+        spansAtDoc.nextStartPosition();
+        assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;
+        byPositionQueue.add(spansAtDoc);
+      }
+      listAtCurrentDoc = listAtCurrentDoc.next;
+    }
+    assert byPositionQueue.size() > 0;
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    if (topPositionSpans == null) {
+      byPositionQueue.clear();
+      fillPositionQueue(); // fills byPositionQueue at first position
+      topPositionSpans = byPositionQueue.top();
+    } else {
+      topPositionSpans.nextStartPosition();
+      topPositionSpans = byPositionQueue.updateTop();
+    }
+    return topPositionSpans.startPosition();
+  }
+
+  @Override
+  public int startPosition() {
+    return topPositionSpans == null ? -1 : topPositionSpans.startPosition();
+  }
+
+  @Override
+  public int endPosition() {
+    return topPositionSpans == null ? -1 : topPositionSpans.endPosition();
+  }
+
+  @Override
+  public int width() {
+    return topPositionSpans.width();
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    if (topPositionSpans != null)
+      topPositionSpans.collect(collector);
+  }
+
+  @Override
+  public String toString() {
+    return "DisjunctionSpans(" + spanQuery + ")@" + docID() + ": " + startPosition() + " - " + endPosition();
+  }
+
+  long cost = -1;
+
+  @Override
+  public long cost() {
+    if (cost == -1) {
+      cost = 0;
+      for (Spans spans : subSpans) {
+        cost += spans.cost();
+      }
+    }
+    return cost;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
index 15abc7d..c2996cc 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
@@ -16,7 +16,6 @@
  */
 package org.apache.lucene.search.spans;
 
-
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
@@ -28,13 +27,8 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
-import org.apache.lucene.search.DisiPriorityQueue;
-import org.apache.lucene.search.DisiWrapper;
-import org.apache.lucene.search.DisjunctionDISIApproximation;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TwoPhaseIterator;
-
 
 /** Matches the union of its clauses.
  */
@@ -117,16 +111,25 @@ public final class SpanOrQuery extends SpanQuery {
   public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {
     List<SpanWeight> subWeights = new ArrayList<>(clauses.size());
     for (SpanQuery q : clauses) {
-      subWeights.add(q.createWeight(searcher, false, boost));
+      subWeights.add(q.createWeight(searcher, needsScores, boost));
     }
-    return new SpanOrWeight(searcher, needsScores ? getTermContexts(subWeights) : null, subWeights, boost);
+    return new SpanOrWeight(searcher,
+                            needsScores ? getTermContexts(subWeights) : null,
+                            subWeights,
+                            needsScores,
+                            boost);
   }
 
   public class SpanOrWeight extends SpanWeight {
 
     final List<SpanWeight> subWeights;
 
-    public SpanOrWeight(IndexSearcher searcher, Map<Term, TermContext> terms, List<SpanWeight> subWeights, float boost) throws IOException {
+    public SpanOrWeight(IndexSearcher searcher,
+                        Map<Term, TermContext> terms,
+                        List<SpanWeight> subWeights,
+                        boolean needsScores,
+                        float boost) throws IOException
+    {
       super(SpanOrQuery.this, searcher, terms, boost);
       this.subWeights = subWeights;
     }
@@ -163,210 +166,8 @@ public final class SpanOrQuery extends SpanQuery {
       } else if (subSpans.size() == 1) {
         return subSpans.get(0);
       }
-
-      DisiPriorityQueue byDocQueue = new DisiPriorityQueue(subSpans.size());
-      for (Spans spans : subSpans) {
-        byDocQueue.add(new DisiWrapper(spans));
-      }
-
-      SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1
-
-      return new Spans() {
-        Spans topPositionSpans = null;
-
-        @Override
-        public int nextDoc() throws IOException {
-          topPositionSpans = null;
-          DisiWrapper topDocSpans = byDocQueue.top();
-          int currentDoc = topDocSpans.doc;
-          do {
-            topDocSpans.doc = topDocSpans.iterator.nextDoc();
-            topDocSpans = byDocQueue.updateTop();
-          } while (topDocSpans.doc == currentDoc);
-          return topDocSpans.doc;
-        }
-
-        @Override
-        public int advance(int target) throws IOException {
-          topPositionSpans = null;
-          DisiWrapper topDocSpans = byDocQueue.top();
-          do {
-            topDocSpans.doc = topDocSpans.iterator.advance(target);
-            topDocSpans = byDocQueue.updateTop();
-          } while (topDocSpans.doc < target);
-          return topDocSpans.doc;
-        }
-
-        @Override
-        public int docID() {
-          DisiWrapper topDocSpans = byDocQueue.top();
-          return topDocSpans.doc;
-        }
-
-        @Override
-        public TwoPhaseIterator asTwoPhaseIterator() {
-          float sumMatchCost = 0; // See also DisjunctionScorer.asTwoPhaseIterator()
-          long sumApproxCost = 0;
-
-          for (DisiWrapper w : byDocQueue) {
-            if (w.twoPhaseView != null) {
-              long costWeight = (w.cost <= 1) ? 1 : w.cost;
-              sumMatchCost += w.twoPhaseView.matchCost() * costWeight;
-              sumApproxCost += costWeight;
-            }
-          }
-
-          if (sumApproxCost == 0) { // no sub spans supports approximations
-            computePositionsCost();
-            return null;
-          }
-
-          final float matchCost = sumMatchCost / sumApproxCost;
-
-          return new TwoPhaseIterator(new DisjunctionDISIApproximation(byDocQueue)) {
-            @Override
-            public boolean matches() throws IOException {
-              return twoPhaseCurrentDocMatches();
-            }
-
-            @Override
-            public float matchCost() {
-              return matchCost;
-            }
-          };
-        }
-
-        float positionsCost = -1;
-
-        void computePositionsCost() {
-          float sumPositionsCost = 0;
-          long sumCost = 0;
-          for (DisiWrapper w : byDocQueue) {
-            long costWeight = (w.cost <= 1) ? 1 : w.cost;
-            sumPositionsCost += w.spans.positionsCost() * costWeight;
-            sumCost += costWeight;
-          }
-          positionsCost = sumPositionsCost / sumCost;
-        }
-
-        @Override
-        public float positionsCost() {
-          // This may be called when asTwoPhaseIterator returned null,
-          // which happens when none of the sub spans supports approximations.
-          assert positionsCost > 0;
-          return positionsCost;
-        }
-
-        int lastDocTwoPhaseMatched = -1;
-
-        boolean twoPhaseCurrentDocMatches() throws IOException {
-          DisiWrapper listAtCurrentDoc = byDocQueue.topList();
-          // remove the head of the list as long as it does not match
-          final int currentDoc = listAtCurrentDoc.doc;
-          while (listAtCurrentDoc.twoPhaseView != null) {
-            if (listAtCurrentDoc.twoPhaseView.matches()) {
-              // use this spans for positions at current doc:
-              listAtCurrentDoc.lastApproxMatchDoc = currentDoc;
-              break;
-            }
-            // do not use this spans for positions at current doc:
-            listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;
-            listAtCurrentDoc = listAtCurrentDoc.next;
-            if (listAtCurrentDoc == null) {
-              return false;
-            }
-          }
-          lastDocTwoPhaseMatched = currentDoc;
-          topPositionSpans = null;
-          return true;
-        }
-
-        void fillPositionQueue() throws IOException { // called at first nextStartPosition
-          assert byPositionQueue.size() == 0;
-          // add all matching Spans at current doc to byPositionQueue
-          DisiWrapper listAtCurrentDoc = byDocQueue.topList();
-          while (listAtCurrentDoc != null) {
-            Spans spansAtDoc = listAtCurrentDoc.spans;
-            if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation
-              if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation
-                if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false
-                  spansAtDoc = null;
-                } else {
-                  if (listAtCurrentDoc.lastApproxMatchDoc != listAtCurrentDoc.doc) {
-                    if (!listAtCurrentDoc.twoPhaseView.matches()) {
-                      spansAtDoc = null;
-                    }
-                  }
-                }
-              }
-            }
-
-            if (spansAtDoc != null) {
-              assert spansAtDoc.docID() == listAtCurrentDoc.doc;
-              assert spansAtDoc.startPosition() == -1;
-              spansAtDoc.nextStartPosition();
-              assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;
-              byPositionQueue.add(spansAtDoc);
-            }
-            listAtCurrentDoc = listAtCurrentDoc.next;
-          }
-          assert byPositionQueue.size() > 0;
-        }
-
-        @Override
-        public int nextStartPosition() throws IOException {
-          if (topPositionSpans == null) {
-            byPositionQueue.clear();
-            fillPositionQueue(); // fills byPositionQueue at first position
-            topPositionSpans = byPositionQueue.top();
-          } else {
-            topPositionSpans.nextStartPosition();
-            topPositionSpans = byPositionQueue.updateTop();
-          }
-          return topPositionSpans.startPosition();
-        }
-
-        @Override
-        public int startPosition() {
-          return topPositionSpans == null ? -1 : topPositionSpans.startPosition();
-        }
-
-        @Override
-        public int endPosition() {
-          return topPositionSpans == null ? -1 : topPositionSpans.endPosition();
-        }
-
-        @Override
-        public int width() {
-          return topPositionSpans.width();
-        }
-
-        @Override
-        public void collect(SpanCollector collector) throws IOException {
-          if (topPositionSpans != null)
-            topPositionSpans.collect(collector);
-        }
-
-        @Override
-        public String toString() {
-          return "spanOr(" + SpanOrQuery.this + ")@" + docID() + ": " + startPosition() + " - " + endPosition();
-        }
-
-        long cost = -1;
-
-        @Override
-        public long cost() {
-          if (cost == -1) {
-            cost = 0;
-            for (Spans spans : subSpans) {
-              cost += spans.cost();
-            }
-          }
-          return cost;
+      return new DisjunctionSpans(SpanOrQuery.this, subSpans);
     }
-      };
   }
 }
 
-}
-
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanSynonymQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanSynonymQuery.java
new file mode 100644
index 0000000..fb57ddb
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanSynonymQuery.java
@@ -0,0 +1,187 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search.spans;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+import java.util.Map;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.index.TermState;
+import org.apache.lucene.index.TermsEnum;
+
+import org.apache.lucene.search.similarities.Similarity.SimScorer;
+
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.SynonymQuery;
+import org.apache.lucene.search.SynonymQuery.SynonymWeight;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.MatchNoDocsQuery;
+
+/**
+ * A SpanQuery that treats terms as synonyms.
+ * <p>
+ * For scoring purposes, this query tries to score the terms as if you
+ * had indexed them as one term: it will match any of the terms while
+ * using the same scoring as {@link SynonymQuery}, as far as possible.
+ */
+public final class SpanSynonymQuery extends SpanQuery {
+  final SynonymQuery synonymQuery;
+  final List<Term> terms;
+
+  /**
+   * Creates a new SpanSynonymQuery, matching any of the supplied terms.
+   * <p>
+   * The terms must all have the same field.
+   */
+  public SpanSynonymQuery(Term... terms) {
+    this.synonymQuery = new SynonymQuery(terms);
+    this.terms = synonymQuery.getTerms();
+  }
+
+  @Override
+  public String getField() {
+    return synonymQuery.getField();
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder builder = new StringBuilder("SpanSynonym(");
+    builder.append(synonymQuery.toString(field));
+    builder.append(")");
+    return builder.toString();
+  }
+
+  @Override
+  public int hashCode() {
+    return 31 * classHash() - synonymQuery.hashCode();
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    return sameClassAs(other) &&
+           synonymQuery.equals(((SpanSynonymQuery) other).synonymQuery);
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    // optimize zero and single term cases
+    int numTerms = terms.size();
+    if (numTerms == 0) {
+      return new MatchNoDocsQuery();
+    }
+    if (numTerms == 1) {
+      return new SpanTermQuery(terms.get(0));
+    }
+    return this;
+  }
+
+  /** The returned SpanWeight does not support {@link SpanWeight#explain}. */
+  @Override
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {
+    if (needsScores) {
+      SynonymWeight synonymWeight = (SynonymWeight)
+                      synonymQuery.createWeight(searcher, needsScores, boost);
+      return new SpanSynonymWeight(searcher, boost, synonymWeight);
+    }
+    else { // scores not needed, use SpanOrQuery without scoring.
+      SpanTermQuery[] clauses = new SpanTermQuery[terms.size()];
+      int i = 0;
+      for (Term term : terms) {
+        clauses[i++] = new SpanTermQuery(term);
+      }
+      return new SpanOrQuery(clauses).createWeight(searcher, needsScores, boost);
+    }
+  }
+
+  class SpanSynonymWeight extends SpanWeight {
+    final SynonymWeight synonymWeight;
+
+    SpanSynonymWeight(
+            IndexSearcher searcher,
+            float boost,
+            SynonymWeight synonymWeight)
+    throws IOException {
+      super(SpanSynonymQuery.this, searcher, null, boost); // null: no term context map
+      this.synonymWeight = synonymWeight;
+    }
+
+    @Override
+    public void extractTerms(Set<Term> termSet) {
+      for (Term t : terms) {
+        termSet.add(t);
+      }
+    }
+
+    @Override
+    public void extractTermContexts(Map<Term, TermContext> termContextbyTerm) {
+      TermContext[] termContexts = synonymWeight.getTermContexts();
+      int i = 0;
+      for (Term term : terms) {
+        TermContext termContext = termContexts[i++];
+        termContextbyTerm.put(term, termContext);
+      }
+    }
+
+    @Override
+    public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public SimScorer getSimScorer(LeafReaderContext context) throws IOException {
+      return synonymWeight.getSimScorer(context);
+    }
+
+    @Override
+    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings)
+    throws IOException {
+      SimScorer simScorer = getSimScorer(context);
+      final String field = getField();
+      Terms fieldTerms = context.reader().terms(field);
+      List<Spans> termSpans = new ArrayList<>(terms.size());
+      if (fieldTerms != null) {
+        TermsEnum termsEnum = fieldTerms.iterator();
+        TermContext[] termContexts = synonymWeight.getTermContexts();
+        int i = 0;
+        for (Term term : terms) {
+          TermContext termContext = termContexts[i++]; // in term order
+          TermState termState = termContext.get(context.ord);
+          if (termState != null) {
+            termsEnum.seekExact(term.bytes(), termState);
+            PostingsEnum postings = termsEnum.postings(null, PostingsEnum.POSITIONS);
+            float positionsCost = SpanTermQuery.termPositionsCost(termsEnum)
+                                * SpanTermQuery.PHRASE_TO_SPAN_TERM_POSITIONS_COST;
+            termSpans.add(new TermSpans(simScorer, postings, term, positionsCost));
+          }
+        }
+      }
+
+      return  (termSpans.size() == 0) ? null
+            : (termSpans.size() == 1) ? termSpans.get(0)
+            : new SynonymSpans(SpanSynonymQuery.this, termSpans, simScorer);
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
index 2746a0c..9c28ac9 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
@@ -126,7 +126,7 @@ public class SpanTermQuery extends SpanQuery {
    * the relative cost of dealing with the term positions
    * when using a SpanNearQuery instead of a PhraseQuery.
    */
-  private static final float PHRASE_TO_SPAN_TERM_POSITIONS_COST = 4.0f;
+  static final float PHRASE_TO_SPAN_TERM_POSITIONS_COST = 4.0f;
 
   private static final int TERM_POSNS_SEEK_OPS_PER_DOC = 128;
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SynonymSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/SynonymSpans.java
new file mode 100644
index 0000000..fdbf676
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SynonymSpans.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search.spans;
+
+import java.util.List;
+
+import org.apache.lucene.search.similarities.Similarity.SimScorer;
+
+
+/**
+ * A spans for merging and equal scoring of given spans.
+ * This does not provide score values.
+ *
+ * @lucene.experimental
+ */
+public class SynonymSpans extends DisjunctionSpans {
+  SimScorer simScorer;
+
+  /** Construct a SynonymSpans.
+   * @param spanQuery   The query that provides the subSpans.
+   * @param subSpans    Over which the disjunction is to be taken.
+   * @param simScorer   To be used for scoring.
+   */
+  public SynonymSpans(SpanQuery spanQuery, List<Spans> subSpans, SimScorer simScorer) {
+    super(spanQuery, subSpans);
+    this.simScorer = simScorer;
+  }
+
+  @Override
+  public String toString() {
+    return "SynonymSpans(" + spanQuery + ")@" + docID() + ": " + startPosition() + " - " + endPosition();
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSynonymQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSynonymQuery.java
new file mode 100644
index 0000000..5f4b8eb
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSynonymQuery.java
@@ -0,0 +1,238 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search.spans;
+
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Comparator;
+
+import org.apache.lucene.analysis.*;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.TopScoreDocCollector;
+
+import org.apache.lucene.search.SynonymQuery;
+
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.English;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import junit.framework.Assert;
+
+
+public class TestSpanSynonymQuery extends LuceneTestCase {
+  static IndexSearcher searcher;
+  static IndexReader reader;
+  static Directory directory;
+
+  static final int MAX_TEST_DOC = 32;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.SIMPLE, true))
+            .setMaxBufferedDocs(TestUtil.nextInt(random(), MAX_TEST_DOC, MAX_TEST_DOC + 100))
+            .setMergePolicy(newLogMergePolicy()));
+    for (int i = 0; i < MAX_TEST_DOC; i++) {
+      Document doc = new Document();
+      String text;
+      if (i < (MAX_TEST_DOC-1)) {
+        text = English.intToEnglish(i);
+        if ((i % 5) == 0) { // add some multiple occurrences of the same term(s)
+          text += " " + text;
+        }
+      } else { // last doc, for testing distances > 1, and repeating occurrrences of wb
+        text = "az a b c d e wa wb wb wc az";
+      }
+      doc.add(newTextField("field", text, Field.Store.YES));
+      writer.addDocument(doc);
+    }
+    reader = writer.getReader();
+    searcher = new IndexSearcher(reader);
+    writer.close();
+  }
+
+  @AfterClass
+  public static void afterClass() throws Exception {
+    reader.close();
+    directory.close();
+    searcher = null;
+    directory = null;
+  }
+
+  final String FIELD_NAME = "field";
+
+
+  Term lcnTerm(String term) {
+    return new Term(FIELD_NAME, term);
+  }
+
+  Term[] lcnTerms(String... terms) {
+    Term[] lcnTrms = new Term[terms.length];
+    for (int i = 0; i < terms.length; i++) {
+      lcnTrms[i] = lcnTerm(terms[i]);
+    }
+    return lcnTrms;
+  }
+
+  TermQuery termQuery(String term) {
+    return new TermQuery(lcnTerm(term));
+  }
+
+  SpanTermQuery spanTermQuery(String term) {
+    return new SpanTermQuery(lcnTerm(term));
+  }
+
+  SpanTermQuery[] spanTermQueries(String... terms) {
+    SpanTermQuery[] stqs = new SpanTermQuery[terms.length];
+    for (int i = 0; i < terms.length; i++) {
+      stqs[i] = spanTermQuery(terms[i]);
+    }
+    return stqs;
+  }
+
+  SpanSynonymQuery spanSynonymQuery(String... terms) {
+    return new SpanSynonymQuery(lcnTerms(terms));
+  }
+
+  SynonymQuery synonymQuery(String... terms) {
+    return new SynonymQuery(lcnTerms(terms));
+  }
+
+  void sortByDoc(ScoreDoc[] scoreDocs) {
+    Arrays.sort(scoreDocs, new Comparator<ScoreDoc>() {
+        @Override
+        public int compare(ScoreDoc sd1, ScoreDoc sd2) {
+          return sd1.doc - sd2.doc;
+        }
+    });
+  }
+
+  ScoreDoc[] search(IndexSearcher searcher, Query query) throws IOException {
+    TopScoreDocCollector collector = TopScoreDocCollector.create(MAX_TEST_DOC);
+    searcher.search(query, collector);
+    return collector.topDocs().scoreDocs;
+  }
+
+  int[] docsFromHits(ScoreDoc[] hits) throws Exception {
+    int[] docs = new int[hits.length];
+    for (int i = 0; i < hits.length; i++) {
+      docs[i] = hits[i].doc;
+    }
+    return docs;
+  }
+
+  void showQueryResults(String message, Query q, ScoreDoc[] hits) {
+    System.out.println(message + " results from query " + q);
+    for (ScoreDoc hit : hits) {
+      System.out.println("doc=" + hit.doc + ", score=" + hit.score);
+    }
+  }
+
+  void checkEqualScores(Query qexp, Query qact) throws Exception {
+    ScoreDoc[] expHits = search(searcher, qexp);
+
+    int[] expDocs = docsFromHits(expHits);
+    //showQueryResults("checkEqualScores expected", qexp, expHits);
+
+    ScoreDoc[] actHits = search(searcher, qact);
+    //showQueryResults("checkEqualScores actual", qact, actHits);
+
+    CheckHits.checkHitsQuery(qact, actHits, expHits, expDocs);
+  }
+
+  void checkScoresInRange(Query qexp, Query qact, float maxFac, float minFac) throws Exception {
+    ScoreDoc[] expHits = search(searcher, qexp);
+    //showQueryResults("checkScoresInRange expected", qexp, expHits);
+
+    ScoreDoc[] actHits = search(searcher, qact);
+    //showQueryResults("checkScoresInRange actual", qact, actHits);
+
+    if (expHits.length != actHits.length) {
+      Assert.fail("Unequal lengths: expHits="+expHits.length+",actHits="+actHits.length);
+    }
+
+    sortByDoc(expHits);
+    sortByDoc(actHits);
+    for (int i = 0; i < expHits.length; i++) {
+      if (expHits[i].doc != actHits[i].doc)
+      {
+        Assert.fail("At index " + i
+                      + ": expHits[i].doc=" + expHits[i].doc
+                      + " != actHits[i].doc=" + actHits[i].doc);
+      }
+
+      if ( (expHits[i].score * maxFac < actHits[i].score)
+        || (expHits[i].score * minFac > actHits[i].score))
+      {
+        Assert.fail("At index " + i
+                      + ", expHits[i].doc=" + expHits[i].doc
+                      + ", score not in expected range: " + (expHits[i].score * minFac)
+                      + " <= " + actHits[i].score
+                      + " <= " + (expHits[i].score * maxFac));
+      }
+    }
+  }
+
+  void checkSingleTerm(String term) throws Exception {
+    TermQuery tq = termQuery(term);
+    SpanTermQuery stq = spanTermQuery(term);
+    SpanSynonymQuery ssq = spanSynonymQuery(term);
+
+    checkEqualScores(tq, stq);
+    checkEqualScores(tq, ssq);
+  }
+
+  public void testSingleZero() throws Exception {
+    checkSingleTerm("zero");
+  }
+
+  SpanOrQuery spanOrQuery(String... terms) {
+    return new SpanOrQuery(spanTermQueries(terms));
+  }
+
+  void checkOrTerms(String... terms)  throws Exception {
+    assertTrue(terms.length >= 1);
+    SpanOrQuery soq = spanOrQuery(terms);
+    SpanSynonymQuery ssq = spanSynonymQuery(terms);
+    checkScoresInRange(soq, ssq, 0.7f, 0.3f);
+
+    SynonymQuery sq = synonymQuery(terms);
+    checkEqualScores(sq, ssq);
+  }
+
+  public void testOrTwoTermsNoDocOverlap() throws Exception {
+    checkOrTerms("zero", "one");
+  }
+
+  public void testOrTwoTermsDocOverlap() throws Exception {
+    checkOrTerms("twenty", "one");
+  }
+}
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/AndQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/AndQuery.java
index 2ed8d79..4045f0f 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/AndQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/AndQuery.java
@@ -29,7 +29,7 @@ public class AndQuery extends ComposedQuery {
   
   @Override
   public Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf) {
-    return SrndBooleanQuery.makeBooleanQuery( /* subqueries can be individually boosted */
+    return qf.newBooleanQuery( // subqueries can be individually boosted
       makeLuceneSubQueriesField(fieldName, qf), BooleanClause.Occur.MUST);
   }
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java
index 4f01a2d..a156b42 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java
@@ -15,20 +15,27 @@
  * limitations under the License.
  */
 package org.apache.lucene.queryparser.surround.query;
-/* Create basic queries to be used during rewrite.
- * The basic queries are TermQuery and SpanTermQuery.
- * An exception can be thrown when too many of these are used.
- * SpanTermQuery and TermQuery use IndexReader.termEnum(Term), which causes the buffer usage.
- *
- * Use this class to limit the buffer usage for reading terms from an index.
- * Default is 1024, the same as the max. number of subqueries for a BooleanQuery.
- */
+
+import java.util.List;
 
 import org.apache.lucene.index.Term;
+import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.DisjunctionMaxQuery;
+import org.apache.lucene.search.SynonymQuery;
+import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.spans.SpanNearQuery;
+import org.apache.lucene.search.spans.SpanSynonymQuery;
 
-/** Factory for creating basic term queries */
+/** Factory for creating primitive queries to be used during as result of rewriting.
+ * An exception can be thrown when too many terms are involved.
+ * <br>
+ * Use this class to limit the total number of terms involved in rewriting to primitive queries.
+ * The default maximum is 1024, the same as the max. number of subqueries for a BooleanQuery.
+ */
 public class BasicQueryFactory {
   public BasicQueryFactory(int maxBasicQueries) {
     this.maxBasicQueries = maxBasicQueries;
@@ -47,46 +54,113 @@ public class BasicQueryFactory {
 
   @Override
   public String toString() {
-    return getClass().getName()
+    return getClass().getSimpleName()
     + "(maxBasicQueries: " + maxBasicQueries
     + ", queriesMade: " + queriesMade
     + ")";
   }
 
-  private boolean atMax() {
-    return queriesMade >= maxBasicQueries;
+  private boolean aboveMax() {
+    return queriesMade > maxBasicQueries;
   }
 
-  protected synchronized void checkMax() throws TooManyBasicQueries {
-    if (atMax())
+  protected void checkMax(int numQueries) throws TooManyBasicQueries {
+    queriesMade += numQueries;
+    if (aboveMax()) {
       throw new TooManyBasicQueries(getMaxBasicQueries());
-    queriesMade++;
+    }
   }
 
   public TermQuery newTermQuery(Term term) throws TooManyBasicQueries {
-    checkMax();
+    checkMax(1);
     return new TermQuery(term);
   }
 
   public SpanTermQuery newSpanTermQuery(Term term) throws TooManyBasicQueries {
-    checkMax();
+    checkMax(1);
     return new SpanTermQuery(term);
   }
 
-  @Override
-  public int hashCode() {
-    return getClass().hashCode() ^ (atMax() ? 7 : 31*32);
+  /** Create a BooleanQuery over the given queries.
+   * If necessary this temporarily increases {@link BooleanQuery#setMaxClauseCount}.
+   */
+  public BooleanQuery newBooleanQuery(List<Query> queries, BooleanClause.Occur occur) {
+    if (queries.size() <= 1) {
+      throw new AssertionError("Too few subqueries: " + queries.size());
+    }
+    BooleanQuery.Builder bq = new BooleanQuery.Builder();
+    for (int i = 0; i < queries.size(); i++) {
+      bq.add( queries.get(i), occur);
+    }
+    return bq.build();
+  }
+
+  /** Create a BooleanQuery with the first subquery required and the later subqueries prohibited.
+   * If necessary this temporarily increases {@link BooleanQuery#setMaxClauseCount}.
+   */
+  public BooleanQuery newNotQuery(List<Query> queries) {
+    if (queries.size() <= 1) {
+      throw new AssertionError("Too few subqueries: " + queries.size());
+    }
+    BooleanQuery.Builder bq = new BooleanQuery.Builder();
+    bq.add( queries.get(0), BooleanClause.Occur.MUST); // first subquery required
+    for (Query q : queries.subList(1, queries.size())) {
+      bq.add( q, BooleanClause.Occur.MUST_NOT); // later subqueries prohibited
+    }
+    return bq.build();
+  }
+
+
+  /** Create a DisjunctionMaxQuery over the given queries using <code>tieBreakerMultiplier=0.1</code>
+   *  <br>Override this to use another <code>tieBreakerMultiplier</code>
+   */
+  public DisjunctionMaxQuery newDisjunctionMaxQuery(List<Query> queries) {
+    float tieBreakerMultiplier = 0.1f;
+    return new DisjunctionMaxQuery(queries, tieBreakerMultiplier);
+  }
+
+  /** Create a SpanNearQuery over the given clauses, with the given allowedSlop and ordered.
+   */
+  public SpanNearQuery newSpanNearQuery(SpanQuery[] spanClauses, int allowedSlop, boolean ordered) {
+    assert allowedSlop >= 0;
+    return new SpanNearQuery(spanClauses, allowedSlop, ordered);
   }
 
-  /** Two BasicQueryFactory's are equal when they generate
-   *  the same types of basic queries, or both cannot generate queries anymore.
+  /** Create a SynonymQuery over the given terms.
+   * If necessary this temporarily increases {@link BooleanQuery#setMaxClauseCount}.
+   */
+  public SynonymQuery newSynonymQuery(List<Term> termList) throws TooManyBasicQueries  {
+    assert termList.size() >= 2;
+    checkMax(termList.size());
+    return new SynonymQuery(termList.toArray(new Term[termList.size()]));
+  }
+
+
+  /** Create a SpanSynonymQuery over the given terms.
+   * If necessary this temporarily increases {@link BooleanQuery#setMaxClauseCount}.
    */
+  public SpanSynonymQuery newSpanSynonymQuery(List<Term> termList) throws TooManyBasicQueries {
+    assert termList.size() >= 2;
+    checkMax(termList.size());
+    return new SpanSynonymQuery(termList.toArray(new Term[termList.size()]));
+  }
+
+
   @Override
-  public boolean equals(Object obj) {
-    if (! (obj instanceof BasicQueryFactory))
+  public boolean equals(Object other) {
+    if (! (other instanceof BasicQueryFactory)) {
       return false;
-    BasicQueryFactory other = (BasicQueryFactory) obj;
-    return atMax() == other.atMax();
+    }
+    BasicQueryFactory obqf = (BasicQueryFactory) other;
+    return maxBasicQueries == obqf.maxBasicQueries
+           && queriesMade == obqf.queriesMade;
+  }
+
+  @Override
+  public int hashCode() {
+    return getClass().hashCode()
+           ^ (7 * maxBasicQueries)
+           ^ (31 * queriesMade);
   }
 }
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java
index 74fd3ae..1fbd9f3 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java
@@ -22,7 +22,6 @@ import java.io.IOException;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.MatchNoDocsQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 
 /** Factory for NEAR queries */
@@ -94,12 +93,18 @@ public class DistanceQuery extends ComposedQuery implements DistanceSubQuery {
       qi++;
     }
 
-    return new SpanNearQuery(spanClauses, getOpDistance() - 1, subQueriesOrdered());
+    return qf.newSpanNearQuery(spanClauses, getOpDistance() - 1, subQueriesOrdered());
   }
 
   @Override
   public Query makeLuceneQueryFieldNoBoost(final String fieldName, final BasicQueryFactory qf) {
-    return new DistanceRewriteQuery(this, fieldName, qf);
+    return new RewriteQuery<DistanceQuery>(this, fieldName, qf) {
+
+      @Override
+      public Query rewrite(IndexReader reader) throws IOException {
+        return srndQuery.getSpanNearQuery(reader, fieldName, qf);
+      }
+    };
   }
 }
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceRewriteQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceRewriteQuery.java
deleted file mode 100644
index 1972a8e..0000000
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceRewriteQuery.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.queryparser.surround.query;
-import java.io.IOException;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.Query;
-
-class DistanceRewriteQuery extends RewriteQuery<DistanceQuery> {
-
-  DistanceRewriteQuery(
-      DistanceQuery srndQuery,
-      String fieldName,
-      BasicQueryFactory qf) {
-    super(srndQuery, fieldName, qf);
-  }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    return srndQuery.getSpanNearQuery(reader, fieldName, qf);
-  }
-}
-
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/FieldsQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/FieldsQuery.java
index 23bb095..6bc4b3a 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/FieldsQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/FieldsQuery.java
@@ -22,13 +22,13 @@ import java.util.Iterator;
 import org.apache.lucene.search.Query;
 
 /**
- * Forms an OR query of the provided query across multiple fields.
+ * Forms a {@link org.apache.lucene.search.DisjunctionMaxQuery} for
+ * the provided query across multiple fields.
  */
-public class FieldsQuery extends SrndQuery { /* mostly untested */
+public class FieldsQuery extends SrndQuery {
   private SrndQuery q;
   private List<String> fieldNames;
   private final char fieldOp;
-  private final String OrOperatorName = "OR"; /* for expanded queries, not normally visible */
 
   public FieldsQuery(SrndQuery q, List<String> fieldNames, char fieldOp) {
     this.q = q;
@@ -51,19 +51,12 @@ public class FieldsQuery extends SrndQuery { /* mostly untested */
   public Query makeLuceneQueryNoBoost(BasicQueryFactory qf) {
     if (fieldNames.size() == 1) { /* single field name: no new queries needed */
       return q.makeLuceneQueryFieldNoBoost(fieldNames.get(0), qf);
-    } else { /* OR query over the fields */
-      List<SrndQuery> queries = new ArrayList<>();
-      Iterator<String> fni = getFieldNames().listIterator();
-      SrndQuery qc;
-      while (fni.hasNext()) {
-        qc = q.clone();
-        queries.add( new FieldsQuery( qc, fni.next(), fieldOp));
+    } else { /* DisjunctionMaxQuery query over the fields */
+      List<Query> queries = new ArrayList<>();
+      for (String fieldName : fieldNames) {
+        queries.add(q.makeLuceneQueryFieldNoBoost(fieldName, qf));
       }
-      OrQuery oq = new OrQuery(queries,
-                              true /* infix OR for field names */,
-                              OrOperatorName);
-      // System.out.println(getClass().toString() + ", fields expanded: " + oq.toString()); /* needs testing */
-      return oq.makeLuceneQueryField(null, qf);
+      return qf.newDisjunctionMaxQuery(queries);
     }
   }
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/NotQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/NotQuery.java
index 897d3a8..8d09521 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/NotQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/NotQuery.java
@@ -17,8 +17,6 @@
 package org.apache.lucene.queryparser.surround.query;
 import java.util.List;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.BooleanClause;
 
 /**
  * Factory for prohibited clauses
@@ -28,14 +26,8 @@ public class NotQuery extends ComposedQuery {
   
   @Override
   public Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf) {
-    List<Query> luceneSubQueries = makeLuceneSubQueriesField(fieldName, qf);
-    BooleanQuery.Builder bq = new BooleanQuery.Builder();
-    bq.add( luceneSubQueries.get(0), BooleanClause.Occur.MUST);
-    SrndBooleanQuery.addQueriesToBoolean(bq,
     // FIXME: do not allow weights on prohibited subqueries.
-            luceneSubQueries.subList(1, luceneSubQueries.size()),
-            // later subqueries: not required, prohibited
-            BooleanClause.Occur.MUST_NOT);
-    return bq.build();
+    List<Query> luceneSubQueries = makeLuceneSubQueriesField(fieldName, qf);
+    return qf.newNotQuery(luceneSubQueries);
   }
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/OrQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/OrQuery.java
index 76daa19..1d27fb9 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/OrQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/OrQuery.java
@@ -32,8 +32,7 @@ public class OrQuery extends ComposedQuery implements DistanceSubQuery {
 
   @Override
   public Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf) {
-    return SrndBooleanQuery.makeBooleanQuery(
-      /* subqueries can be individually boosted */
+    return qf.newBooleanQuery( // subqueries can be individually boosted
       makeLuceneSubQueriesField(fieldName, qf), BooleanClause.Occur.SHOULD);
   }
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java
index 438535f..af2381e 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java
@@ -40,11 +40,11 @@ abstract class RewriteQuery<SQ extends SrndQuery> extends Query {
 
   @Override
   public String toString(String field) {
-    return getClass().getName()
+    return "RewriteQuery"
     + (field.isEmpty() ? "" : "(unused: " + field + ")")
     + "(" + fieldName
-    + ", " + srndQuery.toString()
-    + ", " + qf.toString()
+    + ": " + srndQuery.toString()
+    // + ", " + qf.toString()
     + ")";
   }
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTerm.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTerm.java
index f574feb..d0d86db 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTerm.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTerm.java
@@ -15,18 +15,23 @@
  * limitations under the License.
  */
 package org.apache.lucene.queryparser.surround.query;
+
 import java.io.IOException;
+import java.util.List;
+import java.util.ArrayList;
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.MatchNoDocsQuery;
+import org.apache.lucene.util.BytesRef;
 
 /**
  * Base class for queries that expand to sets of simple terms.
  */
 public abstract class SimpleTerm
   extends SrndQuery
-  implements DistanceSubQuery, Comparable<SimpleTerm>
+  implements DistanceSubQuery
 {
   public SimpleTerm(boolean q) {quoted = q;}
 
@@ -38,16 +43,6 @@ public abstract class SimpleTerm
 
   public abstract String toStringUnquoted();
 
-  /** @deprecated (March 2011) Not normally used, to be removed from Lucene 4.0.
-   *   This class implementing Comparable is to be removed at the same time.
-   */
-  @Override
-  @Deprecated
-  public int compareTo(SimpleTerm ost) {
-    /* for ordering terms and prefixes before using an index, not used */
-    return this.toStringUnquoted().compareTo( ost.toStringUnquoted());
-  }
-  
   protected void suffixToString(StringBuilder r) {} /* override for prefix query */
 
   @Override
@@ -72,10 +67,10 @@ public abstract class SimpleTerm
 
   /**
    * Callback to visit each matching term during "rewrite"
-   * in {@link #visitMatchingTerm(Term)}
+   * in {@link #visitMatchingTerm(BytesRef)}
    */
   public interface MatchingTermVisitor {
-    void visitMatchingTerm(Term t)throws IOException;
+    void visitMatchingTerm(BytesRef termRef)throws IOException;
   }
 
   @Override
@@ -83,21 +78,48 @@ public abstract class SimpleTerm
 
   @Override
   public void addSpanQueries(final SpanNearClauseFactory sncf) throws IOException {
-    visitMatchingTerms(
-          sncf.getIndexReader(),
-          sncf.getFieldName(),
+    ArrayList<Term> terms = new ArrayList<>();
+    String fieldName = sncf.getFieldName();
+    visitMatchingTerms( sncf.getIndexReader(), fieldName,
           new MatchingTermVisitor() {
             @Override
-            public void visitMatchingTerm(Term term) throws IOException {
-              sncf.addTermWeighted(term, getWeight());
+            public void visitMatchingTerm(BytesRef termRef) throws IOException {
+              terms.add(new Term(fieldName, termRef)); // termRef is copied.
             }
           });
+    if (terms.size() == 0) {
+      return;
+    }
+    else if (terms.size() == 1) {
+      sncf.addTermWeighted(terms.get(0), getWeight());
+    }
+    else {
+      BasicQueryFactory qf = sncf.getBasicQueryFactory();
+      sncf.addSpanQueryWeighted(qf.newSpanSynonymQuery(terms), getWeight());
+    }
   }
 
   @Override
   public Query makeLuceneQueryFieldNoBoost(final String fieldName, final BasicQueryFactory qf) {
-    return new SimpleTermRewriteQuery(this, fieldName, qf);
+    return new RewriteQuery<SimpleTerm>(this, fieldName, qf) {
+
+      @Override
+      public Query rewrite(IndexReader reader) throws IOException {
+        final List<Term> terms = new ArrayList<>();
+        srndQuery.visitMatchingTerms(reader, fieldName,
+            new MatchingTermVisitor() {
+              @Override
+              public void visitMatchingTerm(BytesRef termRef) throws IOException {
+                terms.add(new Term(fieldName, termRef));
               }
+            });
+        return  (terms.size() == 0) ? new MatchNoDocsQuery()
+              : (terms.size() == 1) ? qf.newTermQuery(terms.get(0))
+                                    : qf.newSynonymQuery(terms);
+      }
+    };
+  }
+
 }
 
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTermRewriteQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTermRewriteQuery.java
deleted file mode 100644
index 3e0e4aa..0000000
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTermRewriteQuery.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.queryparser.surround.query;
-import java.io.IOException;
-import java.util.List;
-import java.util.ArrayList;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.MatchNoDocsQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.index.Term;
-
-class SimpleTermRewriteQuery extends RewriteQuery<SimpleTerm> {
-
-  SimpleTermRewriteQuery(
-      SimpleTerm srndQuery,
-      String fieldName,
-      BasicQueryFactory qf) {
-    super(srndQuery, fieldName, qf);
-  }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    final List<Query> luceneSubQueries = new ArrayList<>();
-    srndQuery.visitMatchingTerms(reader, fieldName,
-    new SimpleTerm.MatchingTermVisitor() {
-      @Override
-      public void visitMatchingTerm(Term term) throws IOException {
-        luceneSubQueries.add(qf.newTermQuery(term));
-      }
-    });
-    return  (luceneSubQueries.size() == 0) ? new MatchNoDocsQuery()
-    : (luceneSubQueries.size() == 1) ? luceneSubQueries.get(0)
-    : SrndBooleanQuery.makeBooleanQuery(
-      /* luceneSubQueries all have default weight */
-      luceneSubQueries, BooleanClause.Occur.SHOULD); /* OR the subquery terms */
-  }
-}
-
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java
index 2db315f..42a4ba5 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java
@@ -66,7 +66,7 @@ import org.apache.lucene.search.spans.SpanTermQuery;
 
 
 /**
- * Factory for {@link SpanOrQuery}
+ * Factory for {@link SpanOrQuery}.
  */
 public class SpanNearClauseFactory { // FIXME: rename to SpanClauseFactory
   public SpanNearClauseFactory(IndexReader reader, String fieldName, BasicQueryFactory qf) {
@@ -75,6 +75,11 @@ public class SpanNearClauseFactory { // FIXME: rename to SpanClauseFactory
     this.weightBySpanQuery = new HashMap<>();
     this.qf = qf;
   }
+
+  public SpanNearClauseFactory(SpanNearClauseFactory sncf) {
+    this(sncf.reader, sncf.fieldName, sncf.qf);
+  }
+
   private IndexReader reader;
   private String fieldName;
   private HashMap<SpanQuery, Float> weightBySpanQuery;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndBooleanQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndBooleanQuery.java
deleted file mode 100644
index 501034e..0000000
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndBooleanQuery.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.queryparser.surround.query;
-import java.util.List;
-
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.BooleanClause;
-
-class SrndBooleanQuery {
-  public static void addQueriesToBoolean(
-          BooleanQuery.Builder bq,
-          List<Query> queries,
-          BooleanClause.Occur occur) {
-    for (int i = 0; i < queries.size(); i++) {
-      bq.add( queries.get(i), occur);
-    }
-  }
-  
-  public static Query makeBooleanQuery(
-          List<Query> queries,
-          BooleanClause.Occur occur) {
-    if (queries.size() <= 1) {
-      throw new AssertionError("Too few subqueries: " + queries.size());
-    }
-    BooleanQuery.Builder bq = new BooleanQuery.Builder();
-    addQueriesToBoolean(bq, queries.subList(0, queries.size()), occur);
-    return bq.build();
-  }
-}
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndPrefixQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndPrefixQuery.java
index 587c4fb..fac2c3d 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndPrefixQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndPrefixQuery.java
@@ -15,7 +15,9 @@
  * limitations under the License.
  */
 package org.apache.lucene.queryparser.surround.query;
-import org.apache.lucene.index.Term;
+
+import java.io.IOException;
+
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.StringHelper;
@@ -23,36 +25,42 @@ import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiFields;
 
-import java.io.IOException;
-
 
 /**
  * Query that matches String prefixes
  */
 public class SrndPrefixQuery extends SimpleTerm {
-  private final BytesRef prefixRef;
+
   public SrndPrefixQuery(String prefix, boolean quoted, char truncator) {
     super(quoted);
     this.prefix = prefix;
-    prefixRef = new BytesRef(prefix);
+    this.prefixRef = new BytesRef(prefix);
     this.truncator = truncator;
   }
 
+  private BytesRef prefixRef;
+
   private final String prefix;
-  public String getPrefix() {return prefix;}
+
+  public String getPrefix() {
+    return prefix;
+  }
 
   private final char truncator;
-  public char getSuffixOperator() {return truncator;}
 
-  public Term getLucenePrefixTerm(String fieldName) {
-    return new Term(fieldName, getPrefix());
+  public char getSuffixOperator() {
+    return truncator;
   }
 
   @Override
-  public String toStringUnquoted() {return getPrefix();}
+  public String toStringUnquoted() {
+    return prefix;
+  }
 
   @Override
-  protected void suffixToString(StringBuilder r) {r.append(getSuffixOperator());}
+  protected void suffixToString(StringBuilder r) {
+    r.append(getSuffixOperator());
+  }
 
   @Override
   public void visitMatchingTerms(
@@ -60,36 +68,35 @@ public class SrndPrefixQuery extends SimpleTerm {
     String fieldName,
     MatchingTermVisitor mtv) throws IOException
   {
-    /* inspired by PrefixQuery.rewrite(): */
+    // See also PrefixQuery.rewrite()
     Terms terms = MultiFields.getTerms(reader, fieldName);
     if (terms != null) {
       TermsEnum termsEnum = terms.iterator();
-
       boolean skip = false;
-      TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(getPrefix()));
+      TermsEnum.SeekStatus status = termsEnum.seekCeil(prefixRef);
+
       if (status == TermsEnum.SeekStatus.FOUND) {
-        mtv.visitMatchingTerm(getLucenePrefixTerm(fieldName));
-      } else if (status == TermsEnum.SeekStatus.NOT_FOUND) {
-        if (StringHelper.startsWith(termsEnum.term(), prefixRef)) {
-          mtv.visitMatchingTerm(new Term(fieldName, termsEnum.term().utf8ToString()));
-        } else {
-          skip = true;
+        mtv.visitMatchingTerm(prefixRef);
       }
-      } else {
-        // EOF
-        skip = true;
+      else if (status == TermsEnum.SeekStatus.NOT_FOUND) {
+        BytesRef termRef = termsEnum.term();
+        if (! StringHelper.startsWith(termRef, prefixRef)) {
+          return;
+        }
+        mtv.visitMatchingTerm(termRef);
+      }
+      else { // TermsEnum.SeekStatus.END
+        return;
       }
 
-      if (!skip) {
       while(true) {
-          BytesRef text = termsEnum.next();
-          if (text != null && StringHelper.startsWith(text, prefixRef)) {
-            mtv.visitMatchingTerm(new Term(fieldName, text.utf8ToString()));
-          } else {
-            break;
-          }
+        BytesRef termRef = termsEnum.next();
+        if ((termRef == null) || (! StringHelper.startsWith(termRef, prefixRef))) {
+          return;
         }
+        mtv.visitMatchingTerm(termRef);
       }
     }
   }
+
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndQuery.java
index 4ecb30f..dafbe15 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndQuery.java
@@ -14,9 +14,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.apache.lucene.queryparser.surround.query;
-import org.apache.lucene.search.BoostQuery;
+
+import java.util.Arrays;
+
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.BoostQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanBoostQuery;
 
 /** Lowest level base class for surround queries */
 public abstract class SrndQuery implements Cloneable {
@@ -42,16 +48,30 @@ public abstract class SrndQuery implements Cloneable {
     }
   }
 
-  public Query makeLuceneQueryField(String fieldName, BasicQueryFactory qf){
+  public Query makeLuceneQueryField(String fieldName, BasicQueryFactory qf) { /* weight may be at any level in a SrndQuery */
     Query q = makeLuceneQueryFieldNoBoost(fieldName, qf);
     if (isWeighted()) {
-      q = new BoostQuery(q, getWeight()); /* weight may be at any level in a SrndQuery */
+      if (q instanceof SpanQuery) {
+        q = new SpanBoostQuery((SpanQuery) q, getWeight());
+      }
+      else {
+        q = new BoostQuery(q, getWeight());
+      }
     }
     return q;
   }
 
+
   public abstract Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf);
 
+  public Query makeLuceneQueryFields(BasicQueryFactory qf, String... fieldNames) {
+    if (fieldNames.length == 0) {
+      throw new IllegalArgumentException("No fieldNames given");
+    }
+    char fieldOp = ':'; // same field operator as in surround QueryParser
+    return (new FieldsQuery(this, Arrays.asList(fieldNames), fieldOp)).makeLuceneQueryField(null, qf);
+  }
+
   /** This method is used by {@link #hashCode()} and {@link #equals(Object)},
    *  see LUCENE-2945.
    */
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTermQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTermQuery.java
index ffa8c78..be67bf0 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTermQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTermQuery.java
@@ -18,7 +18,6 @@ package org.apache.lucene.queryparser.surround.query;
 import java.io.IOException;
 
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.MultiFields;
@@ -29,20 +28,23 @@ import org.apache.lucene.util.BytesRef;
  * Simple single-term clause
  */
 public class SrndTermQuery extends SimpleTerm {
-  public SrndTermQuery(String termText, boolean quoted) {
+  public SrndTermQuery(String term, boolean quoted) {
     super(quoted);
-    this.termText = termText;
+    this.term = term;
+    this.termRef = new BytesRef(term);
   }
 
-  private final String termText;
-  public String getTermText() {return termText;}
+  private final String term;
+  private final BytesRef termRef;
 
-  public Term getLuceneTerm(String fieldName) {
-    return new Term(fieldName, getTermText());
+  private String getTermText() {
+    return term;
   }
 
   @Override
-  public String toStringUnquoted() {return getTermText();}
+  public String toStringUnquoted() {
+    return term;
+  }
 
   @Override
   public void visitMatchingTerms(
@@ -50,14 +52,12 @@ public class SrndTermQuery extends SimpleTerm {
     String fieldName,
     MatchingTermVisitor mtv) throws IOException
   {
-    /* check term presence in index here for symmetry with other SimpleTerm's */
     Terms terms = MultiFields.getTerms(reader, fieldName);
     if (terms != null) {
       TermsEnum termsEnum = terms.iterator();
-
-      TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(getTermText()));
+      TermsEnum.SeekStatus status = termsEnum.seekCeil(termRef);
       if (status == TermsEnum.SeekStatus.FOUND) {
-        mtv.visitMatchingTerm(getLuceneTerm(fieldName));
+        mtv.visitMatchingTerm(termRef);
       }
     }
   }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTruncQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTruncQuery.java
index b987921..abeda1c 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTruncQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTruncQuery.java
@@ -15,7 +15,6 @@
  * limitations under the License.
  */
 package org.apache.lucene.queryparser.surround.query;
-import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.util.BytesRef;
@@ -49,10 +48,14 @@ public class SrndTruncQuery extends SimpleTerm {
   private Pattern pattern;
   
   
-  public String getTruncated() {return truncated;}
+  public String getTruncated() {
+    return truncated;
+  }
   
   @Override
-  public String toStringUnquoted() {return getTruncated();}
+  public String toStringUnquoted() {
+    return truncated;
+  }
 
   
   protected boolean matchingChar(char c) {
@@ -107,15 +110,14 @@ public class SrndTruncQuery extends SimpleTerm {
           text = null;
         }
 
-        while(text != null) {
-          if (text != null && StringHelper.startsWith(text, prefixRef)) {
+        while(true) {
+          if ((text == null) || (! StringHelper.startsWith(text, prefixRef))) {
+            return;
+          }
           String textString = text.utf8ToString();
           matcher.reset(textString.substring(prefixLength));
           if (matcher.matches()) {
-              mtv.visitMatchingTerm(new Term(fieldName, textString));
-            }
-          } else {
-            break;
+            mtv.visitMatchingTerm(text);
           }
           text = termsEnum.next();
         }
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/BooleanQueryTst.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/BooleanQueryTst.java
deleted file mode 100644
index 77ce5d5..0000000
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/BooleanQueryTst.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.queryparser.surround.query;
-
-import java.io.IOException;
-
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Scorer;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.SimpleCollector;
-import org.apache.lucene.queryparser.surround.parser.QueryParser;
-import org.junit.Assert;
-
-public class BooleanQueryTst {
-  String queryText;
-  final int[] expectedDocNrs;
-  SingleFieldTestDb dBase;
-  String fieldName;
-  Assert testCase;
-  BasicQueryFactory qf;
-  boolean verbose = true;
-
-  public BooleanQueryTst(
-      String queryText,
-      int[] expectedDocNrs,
-      SingleFieldTestDb dBase,
-      String fieldName,
-      Assert testCase,
-      BasicQueryFactory qf) {
-    this.queryText = queryText;
-    this.expectedDocNrs = expectedDocNrs;
-    this.dBase = dBase;
-    this.fieldName = fieldName;
-    this.testCase = testCase;
-    this.qf = qf;
-  }
-  
-  public void setVerbose(boolean verbose) {this.verbose = verbose;}
-
-  class TestCollector extends SimpleCollector { // FIXME: use check hits from Lucene tests
-    int totalMatched;
-    boolean[] encountered;
-    private Scorer scorer = null;
-    private int docBase = 0;
-
-    TestCollector() {
-      totalMatched = 0;
-      encountered = new boolean[expectedDocNrs.length];
-    }
-
-    @Override
-    public void setScorer(Scorer scorer) throws IOException {
-      this.scorer = scorer;
-    }
-
-    @Override
-    protected void doSetNextReader(LeafReaderContext context) throws IOException {
-      docBase = context.docBase;
-    }
-    
-    @Override
-    public void collect(int docNr) throws IOException {
-      float score = scorer.score();
-      docNr += docBase;
-      /* System.out.println(docNr + " '" + dBase.getDocs()[docNr] + "': " + score); */
-      Assert.assertTrue(queryText + ": positive score", score > 0.0);
-      Assert.assertTrue(queryText + ": too many hits", totalMatched < expectedDocNrs.length);
-      int i;
-      for (i = 0; i < expectedDocNrs.length; i++) {
-        if ((! encountered[i]) && (expectedDocNrs[i] == docNr)) {
-          encountered[i] = true;
-          break;
-        }
-      }
-      if (i == expectedDocNrs.length) {
-        Assert.assertTrue(queryText + ": doc nr for hit not expected: " + docNr, false);
-      }
-      totalMatched++;
-    }
-    
-    @Override
-    public boolean needsScores() {
-      return true;
-    }
-
-    void checkNrHits() {
-      Assert.assertEquals(queryText + ": nr of hits", expectedDocNrs.length, totalMatched);
-    }
-  }
-
-  public void doTest() throws Exception {
-
-    if (verbose) {    
-        System.out.println("");
-        System.out.println("Query: " + queryText);
-    }
-    
-    SrndQuery lq = QueryParser.parse(queryText);
-    
-    /* if (verbose) System.out.println("Srnd: " + lq.toString()); */
-    
-    Query query = lq.makeLuceneQueryField(fieldName, qf);
-    /* if (verbose) System.out.println("Lucene: " + query.toString()); */
-
-    TestCollector tc = new TestCollector();
-    IndexReader reader = DirectoryReader.open(dBase.getDb());
-    IndexSearcher searcher = new IndexSearcher(reader);
-    try {
-      searcher.search(query, tc);
-    } finally {
-      reader.close();
-    }
-    tc.checkNrHits();
-  }
-}
-
-
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/ExceptionQueryTst.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/ExceptionQueryTst.java
deleted file mode 100644
index b54f68d..0000000
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/ExceptionQueryTst.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.queryparser.surround.query;
-
-import org.apache.lucene.queryparser.surround.parser.ParseException;
-import org.apache.lucene.queryparser.surround.parser.QueryParser;
-
-
-public class ExceptionQueryTst {
-  private String queryText;
-  private boolean verbose;
-  
-  public ExceptionQueryTst(String queryText, boolean verbose) {
-    this.queryText = queryText;
-    this.verbose = verbose;
-  }
-
-  public void doTest(StringBuilder failQueries) {
-    boolean pass = false;
-    SrndQuery lq = null;
-    try {
-      lq = QueryParser.parse(queryText);
-      if (verbose) {
-        System.out.println("Query: " + queryText + "\nParsed as: " + lq.toString());
-      }
-    } catch (ParseException e) {
-      if (verbose) {
-        System.out.println("Parse exception for query:\n"
-                            + queryText + "\n"
-                            + e.getMessage());
-      }
-      pass = true;
-    }
-    if (! pass) {
-      failQueries.append(queryText);
-      failQueries.append("\nParsed as: ");
-      failQueries.append(lq.toString());
-      failQueries.append("\n");
-    }
-  }
-  
-  public static String getFailQueries(String[] exceptionQueries, boolean verbose) {
-    StringBuilder failQueries = new StringBuilder();
-    for (int i = 0; i < exceptionQueries.length; i++ ) {
-      new ExceptionQueryTst( exceptionQueries[i], verbose).doTest(failQueries);
-    }
-    return failQueries.toString();
-  }
-}
-
-
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/MultiFieldTestDb.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/MultiFieldTestDb.java
new file mode 100644
index 0000000..ba45a7f
--- /dev/null
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/MultiFieldTestDb.java
@@ -0,0 +1,118 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.queryparser.surround.query;
+
+import java.io.IOException;
+import java.util.Random;
+
+import org.junit.Assert;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.MockDirectoryWrapper;
+import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig;
+
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.IndexSearcher;
+
+
+public class MultiFieldTestDb {
+  private Directory db;
+  private String[][] docsFields;
+  private String[] fieldNames;
+  private IndexReader reader;
+  private IndexSearcher searcher;
+
+  public MultiFieldTestDb(Random random, String[][] docsFields, String[] fieldNames) {
+    try {
+      db = new MockDirectoryWrapper(random, new RAMDirectory());
+      this.docsFields = docsFields;
+      this.fieldNames = fieldNames;
+
+      IndexWriter writer = new IndexWriter(db, new IndexWriterConfig(new MockAnalyzer(random)));
+      for (int docNr = 0; docNr < docsFields.length; docNr++) {
+        Assert.assertTrue(docsFields[docNr].length == fieldNames.length);
+
+        Document d = new Document();
+        for (int f = 0; f < fieldNames.length; f++) {
+          d.add(new TextField(fieldNames[f], docsFields[docNr][f], Field.Store.NO));
+        }
+        writer.addDocument(d);
+      }
+      writer.close();
+      reader = DirectoryReader.open(getDb());
+      searcher = new IndexSearcher(reader);
+    } catch (IOException ioe) {
+      throw new Error(ioe);
+    }
+  }
+
+  public void close() throws IOException {
+    reader.close();
+    db.close();
+    reader = null;
+    searcher = null;
+  }
+
+  static MultiFieldTestDb create(Random random, String[] docs, String fieldName) { // single field
+    String[][] docsFields = new String[docs.length][1];
+    for (int d = 0; d < docs.length; d++) {
+      docsFields[d][0] = docs[d];
+    }
+    String[] fieldNames = {fieldName};
+    return new MultiFieldTestDb(random, docsFields, fieldNames);
+  }
+
+
+  Directory getDb() {return db;}
+
+  IndexReader getReader() {
+    return reader;
+  }
+
+  IndexSearcher getSearcher() {
+    return searcher;
+  }
+
+  String[][] getDocsFields() {return docsFields;}
+
+  String showDoc(int d) {
+    StringBuilder s = new StringBuilder();
+    s.append("[");
+    for (int f = 0; f < docsFields[d].length; f++) {
+      if (f > 0) {
+        s.append(", ");
+      }
+      s.append(fieldNames[f]);
+      s.append(": \"");
+      s.append(docsFields[d][f]);
+      s.append("\"");
+    }
+    s.append("]");
+    return s.toString();
+  }
+
+  String[] getFieldnames() {return fieldNames;}
+}
+
+
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SingleFieldTestDb.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SingleFieldTestDb.java
deleted file mode 100644
index 30a5f92..0000000
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SingleFieldTestDb.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.queryparser.surround.query;
-
-import java.util.Random;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.MockDirectoryWrapper;
-import org.apache.lucene.store.RAMDirectory;
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.TextField;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.IndexWriterConfig;
-
-public class SingleFieldTestDb {
-  private Directory db;
-  private String[] docs;
-  private String fieldName;
-  
-  public SingleFieldTestDb(Random random, String[] documents, String fName) {
-    try {
-      db = new MockDirectoryWrapper(random, new RAMDirectory());
-      docs = documents;
-      fieldName = fName;
-      IndexWriter writer = new IndexWriter(db, new IndexWriterConfig(new MockAnalyzer(random)));
-      for (int j = 0; j < docs.length; j++) {
-        Document d = new Document();
-        d.add(new TextField(fieldName, docs[j], Field.Store.NO));
-        writer.addDocument(d);
-      }
-      writer.close();
-    } catch (java.io.IOException ioe) {
-      throw new Error(ioe);
-    }
-  }
-  
-  Directory getDb() {return db;}
-  String[] getDocs() {return docs;}
-  String getFieldname() {return fieldName;}
-}
-
-
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SurroundTst.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SurroundTst.java
new file mode 100644
index 0000000..bcb412c
--- /dev/null
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SurroundTst.java
@@ -0,0 +1,80 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.queryparser.surround.query;
+
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TopScoreDocCollector;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.CheckHits;
+
+import org.apache.lucene.queryparser.surround.parser.QueryParser;
+import org.apache.lucene.queryparser.surround.parser.ParseException;
+
+
+public class SurroundTst {
+
+  private static void nonExceptionTst(String queryText, StringBuilder nonExceptionQueries) {
+    boolean pass = false;
+    SrndQuery srndq = null;
+    try {
+      srndq = QueryParser.parse(queryText);
+      // no ParseException, report:
+      nonExceptionQueries.append(queryText);
+      nonExceptionQueries.append("\nParsed as: ");
+      nonExceptionQueries.append(srndq.toString());
+      nonExceptionQueries.append("\n");
+    } catch (ParseException e) {
+      //System.out.println("Parse exception for query:\n"
+      //                    + queryText + "\n"
+      //                    + e.getMessage());
+    }
+  }
+
+  public static String getNonExceptionQueries(String[] exceptionQueries) {
+    StringBuilder nonExceptionQueries = new StringBuilder();
+    for (int i = 0; i < exceptionQueries.length; i++ ) {
+      nonExceptionTst(exceptionQueries[i], nonExceptionQueries);
+    }
+    return nonExceptionQueries.toString();
+  }
+
+  static void showQueryResults(String message, Query q, ScoreDoc[] hits) {
+    System.out.println(message + " results from query " + q);
+    for (ScoreDoc hit : hits) {
+      System.out.println("doc=" + hit.doc + ", score=" + hit.score);
+    }
+  }
+
+  public static void doTest(
+                        String queryText,
+                        String[] fieldNames,
+                        BasicQueryFactory basicQueryFactory,
+                        IndexSearcher searcher,
+                        int[] expectedDocNrs)
+  throws Exception {
+    SrndQuery srndq = QueryParser.parse(queryText);
+    Query query = srndq.makeLuceneQueryFields(basicQueryFactory, fieldNames);
+    TopScoreDocCollector collector = TopScoreDocCollector.create(expectedDocNrs.length + 1);
+    searcher.search(query, collector);
+    ScoreDoc[] scoreDocs = collector.topDocs().scoreDocs;
+    //showQueryResults(queryText, query, scoreDocs);
+    CheckHits.checkDocIds(queryText, expectedDocNrs, scoreDocs);
+  }
+}
+
+
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test01Exceptions.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test01Exceptions.java
index f61ebd2..c4c2ed9 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test01Exceptions.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test01Exceptions.java
@@ -16,18 +16,9 @@
  */
 package org.apache.lucene.queryparser.surround.query;
 
-import junit.framework.TestSuite;
-import junit.textui.TestRunner;
-
 import org.apache.lucene.util.LuceneTestCase;
 
 public class Test01Exceptions extends LuceneTestCase {
-  /** Main for running test case by itself. */
-  public static void main(String args[]) {
-    TestRunner.run(new TestSuite(Test01Exceptions.class));
-  }
-
-  boolean verbose = false; /* to show actual parsing error messages */
   final String fieldName = "bi";
 
   String[] exceptionQueries = {
@@ -58,7 +49,7 @@ public class Test01Exceptions extends LuceneTestCase {
   };
 
   public void test01Exceptions() throws Exception {
-    String m = ExceptionQueryTst.getFailQueries(exceptionQueries, verbose);
+    String m = SurroundTst.getNonExceptionQueries(exceptionQueries);
     if (m.length() > 0) {
       fail("No ParseException for:\n" + m);
     }
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test02Boolean.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test02Boolean.java
index 298dbdc..57c572f 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test02Boolean.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test02Boolean.java
@@ -16,21 +16,19 @@
  */
 package org.apache.lucene.queryparser.surround.query;
 
-import junit.framework.TestSuite;
-import junit.textui.TestRunner;
+import org.junit.BeforeClass;
+import org.junit.AfterClass;
+import org.junit.Assert;
 
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.search.BooleanQuery;
 
 public class Test02Boolean extends LuceneTestCase {
-  public static void main(String args[]) {
-    TestRunner.run(new TestSuite(Test02Boolean.class));
-  }
 
-  final String fieldName = "bi";
-  boolean verbose = false;
+  static final String fieldName = "bi";
   int maxBasicQueries = 16;
 
-  String[] docs1 = {
+  static String[] docs1 = {
     "word1 word2 word3",
     "word4 word5",
     "ord1 ord2 ord3",
@@ -38,19 +36,22 @@ public class Test02Boolean extends LuceneTestCase {
     "a c e a b c"
   };
 
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    db1 = new SingleFieldTestDb(random(), docs1, fieldName);
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    db1 = MultiFieldTestDb.create(random(), docs1, fieldName);
+  }
+
+  @AfterClass
+  public static void afterClass() throws Exception {
+    db1.close();
   }
 
-  SingleFieldTestDb db1;
+  static MultiFieldTestDb db1;
 
   public void normalTest1(String query, int[] expdnrs) throws Exception {
-    BooleanQueryTst bqt = new BooleanQueryTst( query, expdnrs, db1, fieldName, this,
-                                                new BasicQueryFactory(maxBasicQueries));
-    bqt.setVerbose(verbose);
-    bqt.doTest();
+    String[] fieldNames = {fieldName};
+    SurroundTst.doTest( query, fieldNames, new BasicQueryFactory(maxBasicQueries),
+                        db1.getSearcher(), expdnrs);
   }
 
   public void test02Terms01() throws Exception {
@@ -103,11 +104,14 @@ public class Test02Boolean extends LuceneTestCase {
   public void test03And03() throws Exception {
     int[] expdnrs = {0}; normalTest1( "and(word1,word2)", expdnrs);
   }
+  public void test03And04() throws Exception {
+    int[] expdnrs = {}; normalTest1( "and(word1,ord1a)", expdnrs);
+  }
   public void test04Or01() throws Exception {
     int[] expdnrs = {0, 3}; normalTest1( "word1 or word2", expdnrs);
   }
   public void test04Or02() throws Exception {
-    int[] expdnrs = {0, 1, 2, 3}; normalTest1( "word* OR ord*", expdnrs);
+    int[] expdnrs = {3, 2, 0, 1}; normalTest1( "word* OR ord*", expdnrs);
   }
   public void test04Or03() throws Exception {
     int[] expdnrs = {0, 3}; normalTest1( "OR (word1, word2)", expdnrs);
@@ -124,4 +128,32 @@ public class Test02Boolean extends LuceneTestCase {
   public void test07AndOrNot02() throws Exception {
     int[] expdnrs = {0}; normalTest1( "or( word2* not ord*, and(xyz,def))", expdnrs);
   }
+
+  public void testMaxBasicQueries1() throws Exception {
+    int mcc = BooleanQuery.getMaxClauseCount();
+    try {
+      int maxBasicQueries = 2;
+      // BooleanQuery recursively rewrites, so allow BooleanQuery just what it needs here,
+      // and let BasicQueryFactory throw an exception during rewrite:
+      BooleanQuery.setMaxClauseCount(3);
+      String query = "word1 or word2 or word3";
+      int[] expdnrs = {0, 3};
+      String[] fieldNames = {fieldName};
+      boolean tmbExceptionThrown;
+      try {
+        SurroundTst.doTest( query, fieldNames, new BasicQueryFactory(maxBasicQueries),
+                            db1.getSearcher(), expdnrs);
+        tmbExceptionThrown = false;
+      }
+      catch (TooManyBasicQueries tmb) {
+        tmbExceptionThrown = true;
+      }
+      if (! tmbExceptionThrown) {
+        Assert.fail("Expected TooManyBasicQueries exception");
+      }
+    }
+    finally {
+      BooleanQuery.setMaxClauseCount(mcc);
+    }
+  }
 }
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test03Distance.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test03Distance.java
index 9dca811..ba2f506 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test03Distance.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test03Distance.java
@@ -16,17 +16,13 @@
  */
 package org.apache.lucene.queryparser.surround.query;
 
-import junit.framework.TestSuite;
-import junit.textui.TestRunner;
+import org.junit.BeforeClass;
+import org.junit.AfterClass;
 
 import org.apache.lucene.util.LuceneTestCase;
 
 public class Test03Distance extends LuceneTestCase {
-  public static void main(String args[]) {
-    TestRunner.run(new TestSuite(Test03Distance.class));
-  }
 
-  boolean verbose = false;
   int maxBasicQueries = 16;
 
   String [] exceptionQueries = {
@@ -42,15 +38,15 @@ public class Test03Distance extends LuceneTestCase {
   };
 
   public void test00Exceptions() throws Exception {
-    String m = ExceptionQueryTst.getFailQueries(exceptionQueries, verbose);
+    String m = SurroundTst.getNonExceptionQueries(exceptionQueries);
     if (m.length() > 0) {
       fail("No ParseException for:\n" + m);
     }
   }
 
-  final String fieldName = "bi";
+  static final String fieldName = "bi";
 
-  String[] docs1 = {
+  static String[] docs1 = {
     "word1 word2 word3",
     "word4 word5",
     "ord1 ord2 ord3",
@@ -58,21 +54,27 @@ public class Test03Distance extends LuceneTestCase {
     "a c e a b c"
   };
 
-  SingleFieldTestDb db1;
+  static MultiFieldTestDb db1;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    db1 = MultiFieldTestDb.create(random(), docs1, fieldName);
+    db2 = MultiFieldTestDb.create(random(), docs2, fieldName);
+    db3 = MultiFieldTestDb.create(random(), docs3, fieldName);
+  }
 
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    db1 = new SingleFieldTestDb(random(), docs1, fieldName);
-    db2 = new SingleFieldTestDb(random(), docs2, fieldName);
-    db3 = new SingleFieldTestDb(random(), docs3, fieldName);
+  @AfterClass
+  public static void afterClass() throws Exception {
+    db1.close();
+    db2.close();
+    db3.close();
   }
 
-  private void distanceTst(String query, int[] expdnrs, SingleFieldTestDb db) throws Exception {
-    BooleanQueryTst bqt = new BooleanQueryTst( query, expdnrs, db, fieldName, this,
-                                                new BasicQueryFactory(maxBasicQueries));
-    bqt.setVerbose(verbose);
-    bqt.doTest();
+
+  private void distanceTst(String query, int[] expdnrs, MultiFieldTestDb db) throws Exception {
+    String[] fieldNames = {fieldName};
+    SurroundTst.doTest( query, fieldNames, new BasicQueryFactory(maxBasicQueries),
+                        db.getSearcher(), expdnrs);
   }
 
   public void distanceTest1(String query, int[] expdnrs) throws Exception {
@@ -181,13 +183,13 @@ public class Test03Distance extends LuceneTestCase {
     int[] expdnrs = {3}; distanceTest1( "(orda2 OR orda3) 2N (word2 OR worda3)", expdnrs);
   }
 
-  String[] docs2 = {
+  static String[] docs2 = {
     "w1 w2 w3 w4 w5",
     "w1 w3 w2 w3",
     ""
   };
 
-  SingleFieldTestDb db2;
+  static MultiFieldTestDb db2;
 
   public void distanceTest2(String query, int[] expdnrs) throws Exception {
     distanceTst(query, expdnrs, db2);
@@ -197,10 +199,10 @@ public class Test03Distance extends LuceneTestCase {
     int[] expdnrs = {0}; distanceTest2( "W (w1, w2, w3)", expdnrs);
   }
   public void test2Nprefix01a() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "N(w1, w2, w3)", expdnrs);
+    int[] expdnrs = {1,0}; distanceTest2( "N(w1, w2, w3)", expdnrs);
   }
   public void test2Nprefix01b() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "N(w3, w1, w2)", expdnrs);
+    int[] expdnrs = {1,0}; distanceTest2( "N(w3, w1, w2)", expdnrs);
   }
 
   public void test2Wprefix02() throws Exception {
@@ -208,10 +210,10 @@ public class Test03Distance extends LuceneTestCase {
   }
 
   public void test2Nprefix02a() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "2N(w1,w2,w3)", expdnrs);
+    int[] expdnrs = {1,0}; distanceTest2( "2N(w1,w2,w3)", expdnrs);
   }
   public void test2Nprefix02b() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "2N(w2,w3,w1)", expdnrs);
+    int[] expdnrs = {1,0}; distanceTest2( "2N(w2,w3,w1)", expdnrs);
   }
 
   public void test2Wnested01() throws Exception {
@@ -222,20 +224,20 @@ public class Test03Distance extends LuceneTestCase {
   }
 
   public void test2Wnested02() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "w1 2W w2 2W w3", expdnrs);
+    int[] expdnrs = {1,0}; distanceTest2( "w1 2W w2 2W w3", expdnrs);
   }
   public void test2Nnested02() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "w1 2N w2 2N w3", expdnrs);
+    int[] expdnrs = {1,0}; distanceTest2( "w1 2N w2 2N w3", expdnrs);
   }
 
-  String[] docs3 = {
+  static String[] docs3 = {
     "low pressure temperature inversion and rain",
     "when the temperature has a negative height above a depression no precipitation gradient is expected",
     "when the temperature has a negative height gradient above a depression no precipitation is expected",
     ""
   };
 
-  SingleFieldTestDb db3;
+  static MultiFieldTestDb db3;
 
   public void distanceTest3(String query, int[] expdnrs) throws Exception {
     distanceTst(query, expdnrs, db3);
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test04Fields.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test04Fields.java
new file mode 100644
index 0000000..a8270ab
--- /dev/null
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test04Fields.java
@@ -0,0 +1,78 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.queryparser.surround.query;
+
+import org.junit.BeforeClass;
+import org.junit.AfterClass;
+
+import org.apache.lucene.util.LuceneTestCase;
+
+public class Test04Fields extends LuceneTestCase {
+
+  int maxBasicQueries = 16;
+
+  String [] exceptionQueries = {
+    "bi1:bi2:",
+    "bi1:bi2:()",
+    "(bi1:bi2:())",
+  };
+
+  public void test00Exceptions() throws Exception {
+    String m = SurroundTst.getNonExceptionQueries(exceptionQueries);
+    if (m.length() > 0) {
+      fail("No ParseException for:\n" + m);
+    }
+  }
+
+  static final String[] fieldNames = {"bi1", "bi2"};
+
+  static String[][] docsFields1 = {
+    {"word1 word2 word3", "word1 word2 word3 word4"},
+    {"word1 word5 word6", "word4 word5 word6"},
+    {"ord1 ord2 ord3", "word1 ord2 ord3 ord4"},
+    {"orda1 orda2 orda3 word2 worda3", "orda1 orda2 orda3 word2 worda3 worda4"},
+    {"a c e a b c", "a c e a b c f"}
+  };
+
+  static MultiFieldTestDb mfdb1;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    mfdb1 = new MultiFieldTestDb(random(), docsFields1, fieldNames);
+  }
+
+  @AfterClass
+  public static void afterClass() throws Exception {
+    mfdb1.close();
+  }
+
+  private void disMaxTst(String query, int[] expdnrs, MultiFieldTestDb db) throws Exception {
+    SurroundTst.doTest( query, fieldNames, new BasicQueryFactory(maxBasicQueries),
+                        db.getSearcher(), expdnrs);
+  }
+
+  public void testTruncSingleTerm() throws Exception {
+    int[] expdnrs = {0,2,1};
+    disMaxTst("word1*", expdnrs, mfdb1);
+  }
+
+  public void testDistanceQuery() throws Exception {
+    int[] expdnrs = {0,2,1};
+    disMaxTst("word1* w (word2 or word5 or ord2)", expdnrs, mfdb1);
+  }
+
+}
