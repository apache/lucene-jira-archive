Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldTermStack.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldTermStack.java	(revision 1096641)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldTermStack.java	(working copy)
@@ -24,6 +24,7 @@
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.TermFreqVector;
 import org.apache.lucene.index.TermPositionVector;
+import org.apache.lucene.index.TermVectorMapper;
 import org.apache.lucene.index.TermVectorOffsetInfo;
 import org.apache.lucene.util.BytesRef;
 
@@ -67,30 +68,12 @@
   public FieldTermStack( IndexReader reader, int docId, String fieldName, final FieldQuery fieldQuery ) throws IOException {
     this.fieldName = fieldName;
 
-    TermFreqVector tfv = reader.getTermFreqVector( docId, fieldName );
-    if( tfv == null ) return; // just return to make null snippets
-    TermPositionVector tpv = null;
-    try{
-      tpv = (TermPositionVector)tfv;
-    }
-    catch( ClassCastException e ){
-      return; // just return to make null snippets
-    }
-    
     Set<String> termSet = fieldQuery.getTermSet( fieldName );
     // just return to make null snippet if un-matched fieldName specified when fieldMatch == true
     if( termSet == null ) return;
     
-    for( BytesRef term : tpv.getTerms() ){
-      if( !termSet.contains( term.utf8ToString() ) ) continue;
-      int index = tpv.indexOf( term );
-      TermVectorOffsetInfo[] tvois = tpv.getOffsets( index );
-      if( tvois == null ) return; // just return to make null snippets
-      int[] poss = tpv.getTermPositions( index );
-      if( poss == null ) return; // just return to make null snippets
-      for( int i = 0; i < tvois.length; i++ )
-        termList.add( new TermInfo( term.utf8ToString(), tvois[i].getStartOffset(), tvois[i].getEndOffset(), poss[i] ) );
-    }
+    TermVectorMapper tvm = new QueryTermVectorMapper(termSet, termList);
+    reader.getTermFreqVector(docId, fieldName, tvm);
     
     // sort by position
     Collections.sort( termList );
@@ -157,4 +140,28 @@
       return ( this.position - o.position );
     }
   }
+  
+  private static class QueryTermVectorMapper extends TermVectorMapper {
+    
+    private Set<String> termSet;
+    private LinkedList<TermInfo> termList;
+
+    public QueryTermVectorMapper(Set<String> termSet, LinkedList<TermInfo> termList) {
+      this.termSet = termSet;
+      this.termList = termList;
+    }
+    
+    @Override
+    public void map(BytesRef term, int frequency,
+        TermVectorOffsetInfo[] offsets, int[] positions) {
+      if(!termSet.contains( term.utf8ToString() ) || offsets == null || positions == null) return;
+      for( int i = 0; i < frequency; i++ )
+        termList.add( new TermInfo( term.utf8ToString(), offsets[i].getStartOffset(), offsets[i].getEndOffset(), positions[i] ) );
+    }
+
+    @Override
+    public void setExpectations(String field, int numTerms,
+        boolean storeOffsets, boolean storePositions) {
+    }
+  }
 }
