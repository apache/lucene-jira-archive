Index: lucene/src/test/org/apache/lucene/util/LuceneTestCase.java
===================================================================
--- lucene/src/test/org/apache/lucene/util/LuceneTestCase.java	(revision 998212)
+++ lucene/src/test/org/apache/lucene/util/LuceneTestCase.java	(working copy)
@@ -716,11 +716,7 @@
         tmpFile.mkdir();
         try {
           Constructor<? extends Directory> ctor = clazz.getConstructor(File.class);
-          Directory d = ctor.newInstance(tmpFile);
-          // try not to enable this hack unless we must.
-          if (d instanceof MMapDirectory && Constants.WINDOWS && MMapDirectory.UNMAP_SUPPORTED)
-            ((MMapDirectory)d).setUseUnmap(true);
-          return d;
+          return ctor.newInstance(tmpFile);
         } catch (Exception e2) {
           // try .open(File)
           Method method = clazz.getMethod("open", new Class[] { File.class });
Index: lucene/src/java/org/apache/lucene/store/MMapDirectory.java
===================================================================
--- lucene/src/java/org/apache/lucene/store/MMapDirectory.java	(revision 998212)
+++ lucene/src/java/org/apache/lucene/store/MMapDirectory.java	(working copy)
@@ -64,7 +64,7 @@
  * an important limitation to be aware of.
  *
  * <p>This class supplies the workaround mentioned in the bug report
- * (disabled by default, see {@link #setUseUnmap}), which may fail on
+ * (see {@link #setUseUnmap}), which may fail on
  * non-Sun JVMs. It forcefully unmaps the buffer on close by using
  * an undocumented internal cleanup functionality.
  * {@link #UNMAP_SUPPORTED} is <code>true</code>, if the workaround
@@ -78,7 +78,7 @@
  * </p>
  */
 public class MMapDirectory extends FSDirectory {
-  private boolean useUnmapHack = false;
+  private boolean useUnmapHack = UNMAP_SUPPORTED;
   private int maxBBuf = Constants.JRE_IS_64BIT ? Integer.MAX_VALUE : (256 * 1024 * 1024);
 
   /** Create a new MMapDirectory for the named location.
@@ -259,6 +259,8 @@
 
     @Override
     public Object clone() {
+      if (buffer == null)
+        throw new AlreadyClosedException("MMapIndexInput already closed");
       MMapIndexInput clone = (MMapIndexInput)super.clone();
       clone.isClone = true;
       clone.buffer = buffer.duplicate();
@@ -267,9 +269,9 @@
 
     @Override
     public void close() throws IOException {
-      if (isClone || buffer == null) return;
       // unmap the buffer (if enabled) and at least unset it for GC
       try {
+        if (isClone || buffer == null) return;
         cleanMapping(buffer);
       } finally {
         buffer = null;
@@ -382,6 +384,8 @@
   
     @Override
     public Object clone() {
+      if (buffers == null)
+        throw new AlreadyClosedException("MultiMMapIndexInput already closed");
       MultiMMapIndexInput clone = (MultiMMapIndexInput)super.clone();
       clone.isClone = true;
       clone.buffers = new ByteBuffer[buffers.length];
@@ -403,8 +407,8 @@
   
     @Override
     public void close() throws IOException {
-      if (isClone || buffers == null) return;
       try {
+        if (isClone || buffers == null) return;
         for (int bufNr = 0; bufNr < buffers.length; bufNr++) {
           // unmap the buffer (if enabled) and at least unset it for GC
           try {
Index: lucene/src/java/org/apache/lucene/store/FSDirectory.java
===================================================================
--- lucene/src/java/org/apache/lucene/store/FSDirectory.java	(revision 998212)
+++ lucene/src/java/org/apache/lucene/store/FSDirectory.java	(working copy)
@@ -183,8 +183,9 @@
    *  The directory returned uses the {@link NativeFSLockFactory}.
    *
    *  <p>Currently this returns {@link NIOFSDirectory}
-   *  on non-Windows JREs and {@link SimpleFSDirectory}
-   *  on Windows. It is highly recommended that you consult the
+   *  on non-Windows JREs, {@link MMapDirectory} on 64-bit 
+   *  Sun Windows JREs, and {@link SimpleFSDirectory} for other
+   *  JRes on Windows. It is highly recommended that you consult the
    *  implementation's documentation for your platform before
    *  using this method.
    *
@@ -193,11 +194,8 @@
    * the event that higher performance defaults become
    * possible; if the precise implementation is important to
    * your application, please instantiate it directly,
-   * instead. On 64 bit systems, it may also good to
-   * return {@link MMapDirectory}, but this is disabled
-   * because of officially missing unmap support in Java.
-   * For optimal performance you should consider using
-   * this implementation on 64 bit JVMs.
+   * instead. For optimal performance you should consider using
+   * {@link MMapDirectory} on 64 bit JVMs.
    *
    * <p>See <a href="#subclasses">above</a> */
   public static FSDirectory open(File path) throws IOException {
@@ -208,7 +206,10 @@
    *  also specify a custom {@link LockFactory}. */
   public static FSDirectory open(File path, LockFactory lockFactory) throws IOException {
     if (Constants.WINDOWS) {
-      return new SimpleFSDirectory(path, lockFactory);
+      if (MMapDirectory.UNMAP_SUPPORTED && Constants.JRE_IS_64BIT)
+        return new MMapDirectory(path, lockFactory);
+      else
+        return new SimpleFSDirectory(path, lockFactory);
     } else {
       return new NIOFSDirectory(path, lockFactory);
     }
