From b7dd23351e47bb6067e5729bdc96901fd33312bd Mon Sep 17 00:00:00 2001
From: Atri Sharma <atri@apache.org>
Date: Mon, 10 Jun 2019 12:57:49 +0530
Subject: [PATCH] LUCENE-8769: Introduce Range Query Type With Multiple Ranges

Currently, multiple ranges need to be specified in different
PointRangeQueries, thus leading to performance implications when
the BKD tree is deep, since each range query will need a traversal.

This commit introduces a new range query type which has multiple
ranges logically connected. This patch introduces AND and NOT operators,
with OR in follow up patches
---
 .../apache/lucene/document/DoublePoint.java   |  34 +
 .../apache/lucene/document/FloatPoint.java    |  34 +
 .../org/apache/lucene/document/IntPoint.java  |  34 +
 .../org/apache/lucene/document/LongPoint.java |  34 +
 .../apache/lucene/search/MultiRangeQuery.java | 421 ++++++++++
 .../lucene/search/TestMultiRangeQueries.java  | 719 ++++++++++++++++++
 6 files changed, 1276 insertions(+)
 create mode 100644 lucene/core/src/java/org/apache/lucene/search/MultiRangeQuery.java
 create mode 100644 lucene/core/src/test/org/apache/lucene/search/TestMultiRangeQueries.java

diff --git a/lucene/core/src/java/org/apache/lucene/document/DoublePoint.java b/lucene/core/src/java/org/apache/lucene/document/DoublePoint.java
index e442bec525..c50fafdcf8 100644
--- a/lucene/core/src/java/org/apache/lucene/document/DoublePoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/DoublePoint.java
@@ -20,6 +20,7 @@ import java.util.Arrays;
 import java.util.Collection;
 
 import org.apache.lucene.index.PointValues;
+import org.apache.lucene.search.MultiRangeQuery;
 import org.apache.lucene.search.PointInSetQuery;
 import org.apache.lucene.search.PointRangeQuery;
 import org.apache.lucene.search.Query;
@@ -45,6 +46,30 @@ import org.apache.lucene.util.NumericUtils;
  */
 public final class DoublePoint extends Field {
 
+  /** Builder for multi range queries for DoublePoints */
+  public static class DoublePointMultiRangeBuilder extends MultiRangeQuery.Builder {
+    public DoublePointMultiRangeBuilder(String field, int bytesPerDim, int numDims) {
+      super(field, bytesPerDim, numDims);
+    }
+
+    @Override
+    public MultiRangeQuery build() {
+      return new MultiRangeQuery(field, numDims, bytesPerDim, clauses) {
+        @Override
+        protected String toString(int dimension, byte[] value) {
+          return Double.toString(decodeDimension(value, 0));
+        }
+      };
+    }
+
+    public void add(double[] lowerValue, double[] upperValue, MultiRangeQuery.LogicalOperandType type) {
+      if (upperValue.length != numDims || lowerValue.length != numDims) {
+        throw new IllegalArgumentException("Passed in range does not conform to specified dimensions");
+      }
+      add(pack(lowerValue).bytes, pack(upperValue).bytes, type);
+    }
+  }
+
   /**
    * Return the least double that compares greater than {@code d} consistently
    * with {@link Double#compare}. The only difference with
@@ -232,6 +257,15 @@ public final class DoublePoint extends Field {
     };
   }
 
+  /**
+   * Create a new builder for MultiRangeQuery
+   * @param field field name, must not be {@code null}.
+   * @param numDims number of dimensions in this builder's range
+   */
+  public static DoublePointMultiRangeBuilder newMultiRangeQueryBuilder(String field, int numDims) {
+    return new DoublePointMultiRangeBuilder(field, Double.BYTES, numDims);
+  }
+
   /**
    * Create a query matching any of the specified 1D values.  This is the points equivalent of {@code TermsQuery}.
    * 
diff --git a/lucene/core/src/java/org/apache/lucene/document/FloatPoint.java b/lucene/core/src/java/org/apache/lucene/document/FloatPoint.java
index b6d508ffe6..4731db4ce2 100644
--- a/lucene/core/src/java/org/apache/lucene/document/FloatPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/FloatPoint.java
@@ -20,6 +20,7 @@ import java.util.Arrays;
 import java.util.Collection;
 
 import org.apache.lucene.index.PointValues;
+import org.apache.lucene.search.MultiRangeQuery;
 import org.apache.lucene.search.PointInSetQuery;
 import org.apache.lucene.search.PointRangeQuery;
 import org.apache.lucene.search.Query;
@@ -45,6 +46,30 @@ import org.apache.lucene.util.NumericUtils;
  */
 public final class FloatPoint extends Field {
 
+  /** Builder for multi range queries for FloatPoints */
+  public static class FloatPointMultiRangeBuilder extends MultiRangeQuery.Builder {
+    public FloatPointMultiRangeBuilder(String field, int bytesPerDim, int numDims) {
+      super(field, bytesPerDim, numDims);
+    }
+
+    @Override
+    public MultiRangeQuery build() {
+      return new MultiRangeQuery(field, numDims, bytesPerDim, clauses) {
+        @Override
+        protected String toString(int dimension, byte[] value) {
+          return Float.toString(decodeDimension(value, 0));
+        }
+      };
+    }
+
+    public void add(float[] lowerValue, float[] upperValue, MultiRangeQuery.LogicalOperandType type) {
+      if (upperValue.length != numDims || lowerValue.length != numDims) {
+        throw new IllegalArgumentException("Passed in range does not conform to specified dimensions");
+      }
+      add(pack(lowerValue).bytes, pack(upperValue).bytes, type);
+    }
+  }
+
   /**
    * Return the least float that compares greater than {@code f} consistently
    * with {@link Float#compare}. The only difference with
@@ -284,4 +309,13 @@ public final class FloatPoint extends Field {
     }
     return newSetQuery(field, unboxed);
   }
+
+  /**
+   * Create a new builder for MultiRangeQuery
+   * @param field field name, must not be {@code null}.
+   * @param numDims number of dimensions in this builder's range
+   */
+  public static FloatPointMultiRangeBuilder newMultiRangeQueryBuilder(String field, int numDims) {
+    return new FloatPointMultiRangeBuilder(field, Float.BYTES, numDims);
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/document/IntPoint.java b/lucene/core/src/java/org/apache/lucene/document/IntPoint.java
index da4f391cf3..ce6fbd8d9e 100644
--- a/lucene/core/src/java/org/apache/lucene/document/IntPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/IntPoint.java
@@ -20,6 +20,7 @@ import java.util.Arrays;
 import java.util.Collection;
 
 import org.apache.lucene.index.PointValues;
+import org.apache.lucene.search.MultiRangeQuery;
 import org.apache.lucene.search.PointInSetQuery;
 import org.apache.lucene.search.PointRangeQuery;
 import org.apache.lucene.search.Query;
@@ -45,6 +46,30 @@ import org.apache.lucene.util.NumericUtils;
  */
 public final class IntPoint extends Field {
 
+  /** Builder for multi range queries for IntPoints */
+  public static class IntPointMultiRangeBuilder extends MultiRangeQuery.Builder {
+    public IntPointMultiRangeBuilder(String field, int bytesPerDim, int numDims) {
+      super(field, bytesPerDim, numDims);
+    }
+
+    @Override
+    public MultiRangeQuery build() {
+      return new MultiRangeQuery(field, numDims, bytesPerDim, clauses) {
+        @Override
+        protected String toString(int dimension, byte[] value) {
+          return Integer.toString(decodeDimension(value, 0));
+        }
+      };
+    }
+
+    public void add(int[] lowerValue, int[] upperValue, MultiRangeQuery.LogicalOperandType type) {
+      if (upperValue.length != numDims || lowerValue.length != numDims) {
+        throw new IllegalArgumentException("Passed in range does not conform to specified dimensions");
+      }
+      add(pack(lowerValue).bytes, pack(upperValue).bytes, type);
+    }
+  }
+
   private static FieldType getType(int numDims) {
     FieldType type = new FieldType();
     type.setDimensions(numDims, Integer.BYTES);
@@ -256,4 +281,13 @@ public final class IntPoint extends Field {
     }
     return newSetQuery(field, unboxed);
   }
+
+  /**
+   * Create a new builder for MultiRangeQuery
+   * @param field field name, must not be {@code null}.
+   * @param numDims number of dimensions in this builder's range
+   */
+  public static IntPointMultiRangeBuilder newMultiRangeQueryBuilder(String field, int numDims) {
+    return new IntPointMultiRangeBuilder(field, Integer.BYTES, numDims);
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/document/LongPoint.java b/lucene/core/src/java/org/apache/lucene/document/LongPoint.java
index 835a37ad37..f9cb047185 100644
--- a/lucene/core/src/java/org/apache/lucene/document/LongPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/LongPoint.java
@@ -22,6 +22,7 @@ import java.util.Collection;
 import org.apache.lucene.index.PointValues;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.BoostQuery;
+import org.apache.lucene.search.MultiRangeQuery;
 import org.apache.lucene.search.PointInSetQuery;
 import org.apache.lucene.search.PointRangeQuery;
 import org.apache.lucene.search.Query;
@@ -48,6 +49,30 @@ import org.apache.lucene.util.NumericUtils;
  */
 public final class LongPoint extends Field {
 
+  /** Builder for multi range queries for LongPoints */
+  public static class LongPointMultiRangeBuilder extends MultiRangeQuery.Builder {
+    public LongPointMultiRangeBuilder(String field, int bytesPerDim, int numDims) {
+      super(field, bytesPerDim, numDims);
+    }
+
+    @Override
+    public MultiRangeQuery build() {
+      return new MultiRangeQuery(field, numDims, bytesPerDim, clauses) {
+        @Override
+        protected String toString(int dimension, byte[] value) {
+          return Long.toString(decodeDimension(value, 0));
+        }
+      };
+    }
+
+    public void add(long[] lowerValue, long[] upperValue, MultiRangeQuery.LogicalOperandType type) {
+      if (upperValue.length != numDims || lowerValue.length != numDims) {
+        throw new IllegalArgumentException("Passed in range does not conform to specified dimensions");
+      }
+      add(pack(lowerValue).bytes, pack(upperValue).bytes, type);
+    }
+  }
+
   private static FieldType getType(int numDims) {
     FieldType type = new FieldType();
     type.setDimensions(numDims, Long.BYTES);
@@ -282,4 +307,13 @@ public final class LongPoint extends Field {
     }
     return query;
   }
+
+  /**
+   * Create a new builder for MultiRangeQuery
+   * @param field field name, must not be {@code null}.
+   * @param numDims number of dimensions in this builder's range
+   */
+  public static LongPointMultiRangeBuilder newMultiRangeQueryBuilder(String field, int numDims) {
+    return new LongPointMultiRangeBuilder(field, Long.BYTES, numDims);
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/MultiRangeQuery.java b/lucene/core/src/java/org/apache/lucene/search/MultiRangeQuery.java
new file mode 100644
index 0000000000..77933b4a68
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/MultiRangeQuery.java
@@ -0,0 +1,421 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.PointValues;
+import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.DocIdSetBuilder;
+
+/**
+ * Abstract class for range queries involving multiple ranges against physical points such as {@code IntPoints}
+ * @lucene.experimental
+ */
+public abstract class MultiRangeQuery extends Query {
+  /**
+   * Types of logical connectors for multiple ranges in a single query
+   */
+  public enum LogicalOperandType {
+    AND,
+    NOT
+  }
+
+  /**
+   * Representation of a single clause in a MultiRangeQuery
+   */
+  public static class RangeClause {
+    byte[] lowerValue;
+    byte[] upperValue;
+    LogicalOperandType operandType;
+
+    public RangeClause(byte[] lowerValue, byte[] upperValue, LogicalOperandType type) {
+      this.lowerValue = lowerValue;
+      this.upperValue = upperValue;
+      this.operandType = type;
+    }
+  }
+
+  /** A builder for multirange queries. */
+  public static abstract class Builder {
+
+    protected final String field;
+    protected final int bytesPerDim;
+    protected final int numDims;
+    protected final List<RangeClause> clauses = new ArrayList<>();
+
+    /** Sole constructor. */
+    public Builder(String field, int bytesPerDim, int numDims) {
+      if (field == null) {
+        throw new IllegalArgumentException("field should not be null");
+      }
+      if (bytesPerDim <= 0) {
+        throw new IllegalArgumentException("bytesPerDim should be a valid value");
+      }
+      if (numDims <= 0) {
+        throw new IllegalArgumentException("numDims should be a valid value");
+      }
+
+      this.field = field;
+      this.bytesPerDim = bytesPerDim;
+      this.numDims = numDims;
+    }
+
+    /**
+     * Add a new clause to this {@link Builder}.
+     */
+    public Builder add(RangeClause clause) {
+      clauses.add(clause);
+      return this;
+    }
+
+    /**
+     * Add a new clause to this {@link Builder}.
+     */
+    public Builder add(byte[] lowerValue, byte[] upperValue, LogicalOperandType operandType) {
+      MultiRangeQuery.checkArgs(lowerValue, upperValue);
+      return add(new RangeClause(lowerValue, upperValue, operandType));
+    }
+
+    /** Create a new {@link MultiRangeQuery} based on the parameters that have
+     *  been set on this builder. */
+    public abstract MultiRangeQuery build();
+  }
+
+  final String field;
+  final int numDims;
+  final int bytesPerDim;
+  final List<RangeClause> rangeClauses;
+  /**
+   * Expert: create a multidimensional range query with multiple connected ranges
+   *
+   * @param field field name. must not be {@code null}.
+   * @param rangeClauses Range Clauses for this query
+   * @param numDims number of dimensions.
+   */
+  protected MultiRangeQuery(String field, int numDims, int bytesPerDim, List<RangeClause> rangeClauses) {
+    this.field = field;
+    this.numDims = numDims;
+    this.bytesPerDim = bytesPerDim;
+    this.rangeClauses = rangeClauses;
+  }
+
+  /**
+   * Check preconditions for all factory methods
+   * @throws IllegalArgumentException if {@code field}, {@code lowerPoint} or {@code upperPoint} are null.
+   */
+  public static void checkArgs(Object lowerPoint, Object upperPoint) {
+    if (lowerPoint == null) {
+      throw new IllegalArgumentException("lowerPoint must not be null");
+    }
+    if (upperPoint == null) {
+      throw new IllegalArgumentException("upperPoint must not be null");
+    }
+  }
+
+  @Override
+  public void visit(QueryVisitor visitor) {
+    if (visitor.acceptField(field)) {
+      visitor.visitLeaf(this);
+    }
+  }
+
+  @Override
+  public final Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {
+
+    // We don't use RandomAccessWeight here: it's no good to approximate with "match all docs".
+    // This is an inverted structure and should be used in the first pass:
+
+    return new ConstantScoreWeight(this, boost) {
+
+      private PointValues.IntersectVisitor getIntersectVisitor(DocIdSetBuilder result) {
+        return new PointValues.IntersectVisitor() {
+
+          DocIdSetBuilder.BulkAdder adder;
+
+          @Override
+          public void grow(int count) {
+            adder = result.grow(count);
+          }
+
+          @Override
+          public void visit(int docID) {
+            adder.add(docID);
+          }
+
+          @Override
+          public void visit(int docID, byte[] packedValue) {
+            //
+            for (RangeClause rangeClause : rangeClauses) {
+              for (int dim = 0; dim < numDims; dim++) {
+                boolean outsideRange = false;
+                int offset = dim * bytesPerDim;
+                if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) < 0) {
+                  // Doc's value is too low, in this dimension
+                  if (rangeClause.operandType == LogicalOperandType.AND) {
+                    return;
+                  }
+                  // For NOT ranges, we will still consider the value if it is outside the range
+                  outsideRange = true;
+                }
+                if (Arrays.compareUnsigned(packedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) > 0) {
+                  // Doc's value is too high, in this dimension
+                  if (rangeClause.operandType == LogicalOperandType.AND) {
+                    return;
+                  }
+                  outsideRange = true;
+                }
+
+                if (rangeClause.operandType == LogicalOperandType.NOT && !outsideRange) {
+                  // The point falls within the range for NOT operand
+                  return;
+                }
+              }
+            }
+
+            // Doc is in-bounds
+            adder.add(docID);
+          }
+
+          @Override
+          public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {
+
+            boolean crosses = false;
+
+            for (RangeClause rangeClause : rangeClauses) {
+              for (int dim = 0; dim < numDims; dim++) {
+                int offset = dim * bytesPerDim;
+
+                // NOT is used as a filter
+                if (rangeClause.operandType == LogicalOperandType.NOT) {
+                  if (Arrays.compareUnsigned(rangeClause.lowerValue, offset, offset + bytesPerDim, minPackedValue, offset, offset + bytesPerDim) <= 0 &&
+                        Arrays.compareUnsigned(rangeClause.upperValue, offset, offset + bytesPerDim, maxPackedValue, offset, offset + bytesPerDim) >= 0) {
+                    return PointValues.Relation.CELL_OUTSIDE_QUERY;
+                  }
+                }
+                else {
+                  if (Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) > 0 ||
+                      Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) < 0) {
+                    return PointValues.Relation.CELL_OUTSIDE_QUERY;
+                  }
+
+                  // All AND ranges need to agree on the location of point.
+                  crosses |= Arrays.compareUnsigned(minPackedValue, offset, offset + bytesPerDim, rangeClause.lowerValue, offset, offset + bytesPerDim) < 0 ||
+                      Arrays.compareUnsigned(maxPackedValue, offset, offset + bytesPerDim, rangeClause.upperValue, offset, offset + bytesPerDim) > 0;
+                }
+              }
+            }
+
+            if (crosses) {
+              return PointValues.Relation.CELL_CROSSES_QUERY;
+            } else {
+              return PointValues.Relation.CELL_INSIDE_QUERY;
+            }
+          }
+        };
+      }
+
+      @Override
+      public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {
+        LeafReader reader = context.reader();
+
+        PointValues values = reader.getPointValues(field);
+        if (values == null) {
+          // No docs in this segment/field indexed any points
+          return null;
+        }
+
+        if (values.getNumIndexDimensions() != numDims) {
+          throw new IllegalArgumentException("field=\"" + field + "\" was indexed with numIndexDimensions=" + values.getNumIndexDimensions() + " but this query has numDims=" + numDims);
+        }
+        if (bytesPerDim != values.getBytesPerDimension()) {
+          throw new IllegalArgumentException("field=\"" + field + "\" was indexed with bytesPerDim=" + values.getBytesPerDimension() + " but this query has bytesPerDim=" + bytesPerDim);
+        }
+
+        boolean allDocsMatch;
+        if (values.getDocCount() == reader.maxDoc()) {
+          final byte[] fieldPackedLower = values.getMinPackedValue();
+          final byte[] fieldPackedUpper = values.getMaxPackedValue();
+          allDocsMatch = true;
+          for (RangeClause rangeClause : rangeClauses) {
+            for (int i = 0; i < numDims; ++i) {
+              int offset = i * bytesPerDim;
+              if (Arrays.compareUnsigned(rangeClause.lowerValue, offset, offset + bytesPerDim, fieldPackedLower, offset, offset + bytesPerDim) > 0
+                  || Arrays.compareUnsigned(rangeClause.upperValue, offset, offset + bytesPerDim, fieldPackedUpper, offset, offset + bytesPerDim) < 0) {
+                allDocsMatch = false;
+                break;
+              }
+              else if (rangeClause.operandType == LogicalOperandType.NOT) {
+                // Negative range: Value lies in a NOT range
+                allDocsMatch = false;
+                break;
+              }
+            }
+          }
+        } else {
+          allDocsMatch = false;
+        }
+
+        final Weight weight = this;
+        if (allDocsMatch) {
+          // all docs have a value and all points are within bounds, so everything matches
+          return new ScorerSupplier() {
+            @Override
+            public Scorer get(long leadCost) {
+              return new ConstantScoreScorer(weight, score(), scoreMode, DocIdSetIterator.all(reader.maxDoc()));
+            }
+
+            @Override
+            public long cost() {
+              return reader.maxDoc();
+            }
+          };
+        } else {
+          return new ScorerSupplier() {
+
+            final DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);
+            final PointValues.IntersectVisitor visitor = getIntersectVisitor(result);
+            long cost = -1;
+
+            @Override
+            public Scorer get(long leadCost) throws IOException {
+              values.intersect(visitor);
+              DocIdSetIterator iterator = result.build().iterator();
+              return new ConstantScoreScorer(weight, score(), scoreMode, iterator);
+            }
+
+            @Override
+            public long cost() {
+              if (cost == -1) {
+                // Computing the cost may be expensive, so only do it if necessary
+                cost = values.estimatePointCount(visitor);
+                assert cost >= 0;
+              }
+              return cost;
+            }
+          };
+        }
+      }
+
+      @Override
+      public Scorer scorer(LeafReaderContext context) throws IOException {
+        ScorerSupplier scorerSupplier = scorerSupplier(context);
+        if (scorerSupplier == null) {
+          return null;
+        }
+        return scorerSupplier.get(Long.MAX_VALUE);
+      }
+
+      @Override
+      public boolean isCacheable(LeafReaderContext ctx) {
+        return true;
+      }
+
+    };
+  }
+
+  public String getField() {
+    return field;
+  }
+
+  public int getNumDims() {
+    return numDims;
+  }
+
+  public int getBytesPerDim() {
+    return bytesPerDim;
+  }
+
+  @Override
+  public final int hashCode() {
+    int hash = classHash();
+    hash = 31 * hash + field.hashCode();
+    for (RangeClause rangeClause : rangeClauses) {
+      hash = 31 * hash + Arrays.hashCode(rangeClause.lowerValue);
+      hash = 31 * hash + Arrays.hashCode(rangeClause.lowerValue);
+    }
+    hash = 31 * hash + numDims;
+    hash = 31 * hash + Objects.hashCode(bytesPerDim);
+    return hash;
+  }
+
+  @Override
+  public final boolean equals(Object o) {
+    return sameClassAs(o) &&
+        equalsTo(getClass().cast(o));
+  }
+
+  private boolean equalsTo(MultiRangeQuery other) {
+    return Objects.equals(field, other.field) &&
+        numDims == other.numDims &&
+        bytesPerDim == other.bytesPerDim &&
+        rangeClauses.equals(other.rangeClauses);
+  }
+
+  @Override
+  public final String toString(String field) {
+    final StringBuilder sb = new StringBuilder();
+    if (this.field.equals(field) == false) {
+      sb.append(this.field);
+      sb.append(':');
+    }
+
+    int count = 0;
+    // print ourselves as "range per dimension per value"
+    for (RangeClause rangeClause : rangeClauses) {
+      if (count > 0) {
+        sb.append(',');
+      }
+      sb.append(rangeClause.operandType);
+      sb.append('{');
+      for (int i = 0; i < numDims; i++) {
+        if (i > 0) {
+          sb.append(',');
+        }
+
+        int startOffset = bytesPerDim * i;
+
+        sb.append('[');
+        sb.append(toString(i, ArrayUtil.copyOfSubArray(rangeClause.lowerValue, startOffset, startOffset + bytesPerDim)));
+        sb.append(" TO ");
+        sb.append(toString(i, ArrayUtil.copyOfSubArray(rangeClause.upperValue, startOffset, startOffset + bytesPerDim)));
+        sb.append(']');
+      }
+      sb.append('}');
+      ++count;
+    }
+
+    return sb.toString();
+  }
+
+  /**
+   * Returns a string of a single value in a human-readable format for debugging.
+   * This is used by {@link #toString()}.
+   *
+   * @param dimension dimension of the particular value
+   * @param value single value, never null
+   * @return human readable value for debugging
+   */
+  protected abstract String toString(int dimension, byte[] value);
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestMultiRangeQueries.java b/lucene/core/src/test/org/apache/lucene/search/TestMultiRangeQueries.java
new file mode 100644
index 0000000000..d503ac9c4c
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestMultiRangeQueries.java
@@ -0,0 +1,719 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.search;
+
+import java.io.IOException;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.DoublePoint;
+import org.apache.lucene.document.FloatPoint;
+import org.apache.lucene.document.IntPoint;
+import org.apache.lucene.document.LongPoint;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+
+public class TestMultiRangeQueries extends LuceneTestCase {
+  public void testDoubleRandomMultiRangeQuery() throws IOException {
+    final int numDims = TestUtil.nextInt(random(), 1, 3);
+    final int numVals = TestUtil.nextInt(random(), 3, 8);
+    Directory dir = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    double[] value = new double[numDims];
+    for (int i = 0; i < numDims; ++i) {
+      value[i] = TestUtil.nextInt(random(), 1, 10);
+    }
+    doc.add(new DoublePoint("point", value));
+    w.addDocument(doc);
+    IndexReader reader = w.getReader();
+    IndexSearcher searcher = new IndexSearcher(reader);
+    searcher.setQueryCache(null);
+    DoublePoint.DoublePointMultiRangeBuilder builder = DoublePoint.newMultiRangeQueryBuilder("point", numDims);
+    for (int j = 0;j < numVals; j++) {
+      double[] lowerBound = new double[numDims];
+      double[] upperBound = new double[numDims];
+      for (int i = 0; i < numDims; ++i) {
+        lowerBound[i] = value[i] - random().nextInt(1);
+        upperBound[i] = value[i] + random().nextInt(1);
+      }
+      builder.add(lowerBound, upperBound, MultiRangeQuery.LogicalOperandType.AND);
+    }
+
+    Query query = builder.build();
+    searcher.search(query, Integer.MAX_VALUE);
+
+    reader.close();
+    w.close();
+    dir.close();
+  }
+
+  public void testDoublePointMultiRangeQuery() throws IOException {
+    Directory dir = newDirectory();
+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
+    double[] firstPoint = {112.7, 296.0, 512.4};
+    double[] secondPoint = {219.3, 514.8, 624.3};
+
+    Document doc = new Document();
+    doc.add(new DoublePoint("point", firstPoint));
+    iw.addDocument(doc);
+    iw.commit();
+
+    doc = new Document();
+    doc.add(new DoublePoint("point", secondPoint));
+    iw.addDocument(doc);
+    iw.commit();
+
+    // One AND ranges match
+    double[] firstLowerRange= {111, 294.3, 502.4};
+    double[] firstUpperRange = {117.3, 301.8, 514.3};
+
+    double[] secondLowerRange = {15.3, 4.8, 415.1};
+    double[] secondUpperRange = {200.4, 402.4, 583.2};
+
+    DoublePoint.DoublePointMultiRangeBuilder builder = DoublePoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder.add(firstLowerRange, firstUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder.add(secondLowerRange, secondUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    Query query = builder.build();
+
+    IndexReader reader = iw.getReader();
+    final IndexSearcher searcher = newSearcher(reader);
+    iw.close();
+
+    assertEquals(searcher.count(query), 1);
+
+    // One range does not match
+    double[] matchingLowerRange= {111, 294.3, 502.4};
+    double[] matchingUpperRange = {117.3, 301.8, 514.3};
+
+    double[] nonMatchingLowerRange = {703.2, 901.4, 415.1};
+    double[] nonMatchingUpperRange = {1103.4, 1006.1, 583.2};
+
+
+    DoublePoint.DoublePointMultiRangeBuilder builder2 = DoublePoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder2.add(matchingLowerRange,matchingUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder2.add(nonMatchingLowerRange, nonMatchingUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    query = builder2.build();
+
+    assertEquals(searcher.count(query), 0);
+
+    // Overlapping ranges should select smaller range
+    double[] largerRangeLowerRange = {103.7, 294.3, 502.4};
+    double[] largerRangeUpperRange = {310.4, 518.7, 653.7};
+
+    double[] smallerRangeLowerRange = {214.7, 512.7, 619.3};
+    double[] smallerUpperRange = {220.2, 523.3, 631.7};
+    DoublePoint.DoublePointMultiRangeBuilder builder3 = DoublePoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder3.add(largerRangeLowerRange, largerRangeUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder3.add(smallerRangeLowerRange, smallerUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    query = builder3.build();
+
+    TopDocs topDocs = searcher.search(query, Integer.MAX_VALUE);
+
+    assertEquals(topDocs.scoreDocs.length, 1);
+    assertEquals(topDocs.scoreDocs[0].doc, 1);
+
+    // One NOT range does not match
+    double[] andLowerRange = {103.7, 294.3, 502.4};
+    double[] andUpperRange = {310.4, 518.7, 653.7};
+
+    double[] notLowerRange = {214.7, 512.7, 619.3};
+    double[] notUpperRange = {220.2, 523.3, 631.7};
+    DoublePoint.DoublePointMultiRangeBuilder builder4 = DoublePoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder4.add(andLowerRange, andUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder4.add(notLowerRange, notUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+
+    query = builder4.build();
+
+    assertEquals(searcher.count(query), 1);
+
+    // None of the NOT ranges contain any values
+    double[] firstNotLowerRange = {3.7, 2.3, 7.4};
+    double[] firstNotUpperRange = {5.4, 4.7, 8.7};
+
+    double[] secondNotLowerRange = {28.7, 36.7, 33.3};
+    double[] secondNotUpperRange = {32.2, 41.3, 35.7};
+    DoublePoint.DoublePointMultiRangeBuilder builder5 = DoublePoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder5.add(firstNotLowerRange, firstNotUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+    builder5.add(secondNotLowerRange, secondNotUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+
+    query = builder5.build();
+
+    assertEquals(searcher.count(query), 2);
+
+    // Ranges exclude everything
+    double[] firstExclusionLowerRange= {111, 294.3, 502.4};
+    double[] firstExclusionUpperRange = {117.3, 301.8, 514.3};
+
+    double[] secondExclusionLowerRange = {15.3, 4.8, 415.1};
+    double[] secondExclusionUpperRange = {220.4, 402.4, 583.2};
+
+    DoublePoint.DoublePointMultiRangeBuilder builder6 = DoublePoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder6.add(firstExclusionLowerRange, firstExclusionUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+    builder6.add(secondExclusionLowerRange, secondExclusionUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+
+    query = builder6.build();
+
+    assertEquals(searcher.count(query), 0);
+
+    reader.close();
+    dir.close();
+  }
+
+  public void testLongRandomMultiRangeQuery() throws IOException {
+    final int numDims = TestUtil.nextInt(random(), 1, 3);
+    final int numVals = TestUtil.nextInt(random(), 3, 8);
+    Directory dir = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    long[] value = new long[numDims];
+    for (int i = 0; i < numDims; ++i) {
+      value[i] = TestUtil.nextLong(random(), 1, 10);
+    }
+    doc.add(new LongPoint("point", value));
+    w.addDocument(doc);
+    IndexReader reader = w.getReader();
+    IndexSearcher searcher = new IndexSearcher(reader);
+    searcher.setQueryCache(null);
+    LongPoint.LongPointMultiRangeBuilder builder = LongPoint.newMultiRangeQueryBuilder("point", numDims);
+    for (int j = 0;j < numVals; j++) {
+      long[] lowerBound = new long[numDims];
+      long[] upperBound = new long[numDims];
+      for (int i = 0; i < numDims; ++i) {
+        lowerBound[i] = value[i] - random().nextInt(1);
+        upperBound[i] = value[i] + random().nextInt(1);
+      }
+      builder.add(lowerBound, upperBound, MultiRangeQuery.LogicalOperandType.AND);
+    }
+
+    Query query = builder.build();
+    searcher.search(query, Integer.MAX_VALUE);
+
+    reader.close();
+    w.close();
+    dir.close();
+  }
+
+  public void testLongPointMultiRangeQuery() throws IOException {
+    Directory dir = newDirectory();
+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
+    long[] firstPoint = {112, 296, 512};
+    long[] secondPoint = {219, 514, 624};
+
+    Document doc = new Document();
+    doc.add(new LongPoint("point", firstPoint));
+    iw.addDocument(doc);
+    iw.commit();
+
+    doc = new Document();
+    doc.add(new LongPoint("point", secondPoint));
+    iw.addDocument(doc);
+    iw.commit();
+
+    // One AND ranges match
+    long[] firstLowerRange= {111, 294, 502};
+    long[] firstUpperRange = {117, 301, 514};
+
+    long[] secondLowerRange = {15, 4, 415};
+    long[] secondUpperRange = {200, 402, 583};
+
+    LongPoint.LongPointMultiRangeBuilder builder = LongPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder.add(firstLowerRange, firstUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder.add(secondLowerRange, secondUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    Query query = builder.build();
+
+    IndexReader reader = iw.getReader();
+    final IndexSearcher searcher = newSearcher(reader);
+    iw.close();
+
+    assertEquals(searcher.count(query), 1);
+
+    // One range does not match
+    long[] matchingLowerRange= {111, 294, 502};
+    long[] matchingUpperRange = {117, 301, 514};
+
+    long[] nonMatchingLowerRange = {703, 901, 415};
+    long[] nonMatchingUpperRange = {1103, 1006, 583};
+
+
+    LongPoint.LongPointMultiRangeBuilder builder2 = LongPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder2.add(matchingLowerRange,matchingUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder2.add(nonMatchingLowerRange, nonMatchingUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    query = builder2.build();
+
+    assertEquals(searcher.count(query), 0);
+
+    // Overlapping ranges should select smaller range
+    long[] largerRangeLowerRange = {103, 294, 502};
+    long[] largerRangeUpperRange = {310, 518, 653};
+
+    long[] smallerRangeLowerRange = {214, 512, 619};
+    long[] smallerUpperRange = {220, 523, 631};
+    LongPoint.LongPointMultiRangeBuilder builder3 = LongPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder3.add(largerRangeLowerRange, largerRangeUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder3.add(smallerRangeLowerRange, smallerUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    query = builder3.build();
+
+    TopDocs topDocs = searcher.search(query, Integer.MAX_VALUE);
+
+    assertEquals(topDocs.scoreDocs.length, 1);
+    assertEquals(topDocs.scoreDocs[0].doc, 1);
+
+    // One NOT range does not match
+    long[] andLowerRange = {103, 294, 502};
+    long[] andUpperRange = {310, 518, 653};
+
+    long[] notLowerRange = {214, 512, 619};
+    long[] notUpperRange = {220, 523, 631};
+    LongPoint.LongPointMultiRangeBuilder builder4 = LongPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder4.add(andLowerRange, andUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder4.add(notLowerRange, notUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+
+    query = builder4.build();
+
+    assertEquals(searcher.count(query), 1);
+
+    // None of the NOT ranges contain any values
+    long[] firstNotLowerRange = {3, 2, 7};
+    long[] firstNotUpperRange = {5, 4, 8};
+
+    long[] secondNotLowerRange = {28, 36, 33};
+    long[] secondNotUpperRange = {32, 41, 35};
+    LongPoint.LongPointMultiRangeBuilder builder5 = LongPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder5.add(firstNotLowerRange, firstNotUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+    builder5.add(secondNotLowerRange, secondNotUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+
+    query = builder5.build();
+
+    assertEquals(searcher.count(query), 2);
+
+    // Ranges exclude everything
+    long[] firstExclusionLowerRange= {111, 294, 502};
+    long[] firstExclusionUpperRange = {117, 301, 514};
+
+    long[] secondExclusionLowerRange = {15, 4, 415};
+    long[] secondExclusionUpperRange = {220, 402, 583};
+
+    LongPoint.LongPointMultiRangeBuilder builder6 = LongPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder6.add(firstExclusionLowerRange, firstExclusionUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+    builder6.add(secondExclusionLowerRange, secondExclusionUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+
+    query = builder6.build();
+
+    assertEquals(searcher.count(query), 0);
+
+    reader.close();
+    dir.close();
+  }
+
+  public void testFloatRandomMultiRangeQuery() throws IOException {
+    final int numDims = TestUtil.nextInt(random(), 1, 3);
+    final int numVals = TestUtil.nextInt(random(), 3, 8);
+    Directory dir = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    float[] value = new float[numDims];
+    for (int i = 0; i < numDims; ++i) {
+      value[i] = TestUtil.nextInt(random(), 1, 10);
+    }
+    doc.add(new FloatPoint("point", value));
+    w.addDocument(doc);
+    IndexReader reader = w.getReader();
+    IndexSearcher searcher = new IndexSearcher(reader);
+    searcher.setQueryCache(null);
+    FloatPoint.FloatPointMultiRangeBuilder builder = FloatPoint.newMultiRangeQueryBuilder("point", numDims);
+    for (int j = 0;j < numVals; j++) {
+      float[] lowerBound = new float[numDims];
+      float[] upperBound = new float[numDims];
+      for (int i = 0; i < numDims; ++i) {
+        lowerBound[i] = value[i] - random().nextInt(1);
+        upperBound[i] = value[i] + random().nextInt(1);
+      }
+      builder.add(lowerBound, upperBound, MultiRangeQuery.LogicalOperandType.AND);
+    }
+
+    Query query = builder.build();
+    searcher.search(query, Integer.MAX_VALUE);
+
+    reader.close();
+    w.close();
+    dir.close();
+  }
+
+  public void testFloatPointMultiRangeQuery() throws IOException {
+    Directory dir = newDirectory();
+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
+    float[] firstPoint = {112.4f, 296.3f, 512.4f};
+    float[] secondPoint = {219.3f, 514.9f, 624.3f};
+
+    Document doc = new Document();
+    doc.add(new FloatPoint("point", firstPoint));
+    iw.addDocument(doc);
+    iw.commit();
+
+    doc = new Document();
+    doc.add(new FloatPoint("point", secondPoint));
+    iw.addDocument(doc);
+    iw.commit();
+
+    // One AND ranges match
+    float[] firstLowerRange= {111.4f, 294.2f, 502.7f};
+    float[] firstUpperRange = {117.8f, 301.9f, 514.3f};
+
+    float[] secondLowerRange = {15.7f, 4.2f, 415.6f};
+    float[] secondUpperRange = {200.3f, 402.1f, 583.7f};
+
+    FloatPoint.FloatPointMultiRangeBuilder builder = FloatPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder.add(firstLowerRange, firstUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder.add(secondLowerRange, secondUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    Query query = builder.build();
+
+    IndexReader reader = iw.getReader();
+    final IndexSearcher searcher = newSearcher(reader);
+    iw.close();
+
+    assertEquals(searcher.count(query), 1);
+
+    // One range does not match
+    float[] matchingLowerRange= {111.3f, 294.5f, 502.2f};
+    float[] matchingUpperRange = {117f, 301.2f, 514};
+
+    float[] nonMatchingLowerRange = {703.2f, 901.1f, 415.3f};
+    float[] nonMatchingUpperRange = {1103.3f, 1006.5f, 583.3f};
+
+
+    FloatPoint.FloatPointMultiRangeBuilder builder2 = FloatPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder2.add(matchingLowerRange,matchingUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder2.add(nonMatchingLowerRange, nonMatchingUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    query = builder2.build();
+
+    assertEquals(searcher.count(query), 0);
+
+    // Overlapping ranges should select smaller range
+    float[] largerRangeLowerRange = {103.3f, 294.5f, 502.3f};
+    float[] largerRangeUpperRange = {310.9f, 518.2f, 653.3f};
+
+    float[] smallerRangeLowerRange = {214.2f, 512.3f, 619.7f};
+    float[] smallerUpperRange = {220.2f, 523.7f, 631.2f};
+    FloatPoint.FloatPointMultiRangeBuilder builder3 = FloatPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder3.add(largerRangeLowerRange, largerRangeUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder3.add(smallerRangeLowerRange, smallerUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    query = builder3.build();
+
+    TopDocs topDocs = searcher.search(query, Integer.MAX_VALUE);
+
+    assertEquals(topDocs.scoreDocs.length, 1);
+    assertEquals(topDocs.scoreDocs[0].doc, 1);
+
+    // One NOT range does not match
+    float[] andLowerRange = {103.4f, 294.2f, 502.7f};
+    float[] andUpperRange = {310.2f, 518.6f, 653.3f};
+
+    float[] notLowerRange = {214.3f, 512.4f, 619.5f};
+    float[] notUpperRange = {220.2f, 523.6f, 631.2f};
+    FloatPoint.FloatPointMultiRangeBuilder builder4 = FloatPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder4.add(andLowerRange, andUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder4.add(notLowerRange, notUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+
+    query = builder4.build();
+
+    assertEquals(searcher.count(query), 1);
+
+    // None of the NOT ranges contain any values
+    float[] firstNotLowerRange = {3.4f, 2.7f, 7.3f};
+    float[] firstNotUpperRange = {5.4f, 4.2f, 8.7f};
+
+    float[] secondNotLowerRange = {28.3f, 36.2f, 33.3f};
+    float[] secondNotUpperRange = {32.7f, 41.4f, 35.2f};
+    FloatPoint.FloatPointMultiRangeBuilder builder5 = FloatPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder5.add(firstNotLowerRange, firstNotUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+    builder5.add(secondNotLowerRange, secondNotUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+
+    query = builder5.build();
+
+    assertEquals(searcher.count(query), 2);
+
+    // Ranges exclude everything
+    float[] firstExclusionLowerRange= {111.3f, 294.6f, 502.2f};
+    float[] firstExclusionUpperRange = {117.1f, 301.2f, 514.8f};
+
+    float[] secondExclusionLowerRange = {15.3f, 4.2f, 415.8f};
+    float[] secondExclusionUpperRange = {220.2f, 402.5f, 583.7f};
+
+    FloatPoint.FloatPointMultiRangeBuilder builder6 = FloatPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder6.add(firstExclusionLowerRange, firstExclusionUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+    builder6.add(secondExclusionLowerRange, secondExclusionUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+
+    query = builder6.build();
+
+    assertEquals(searcher.count(query), 0);
+
+    reader.close();
+    dir.close();
+  }
+
+  public void testIntRandomMultiRangeQuery() throws IOException {
+    final int numDims = TestUtil.nextInt(random(), 1, 3);
+    final int numVals = TestUtil.nextInt(random(), 3, 8);
+    Directory dir = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    int[] value = new int[numDims];
+    for (int i = 0; i < numDims; ++i) {
+      value[i] = TestUtil.nextInt(random(), 1, 10);
+    }
+    doc.add(new IntPoint("point", value));
+    w.addDocument(doc);
+    IndexReader reader = w.getReader();
+    IndexSearcher searcher = new IndexSearcher(reader);
+    searcher.setQueryCache(null);
+    FloatPoint.FloatPointMultiRangeBuilder builder = FloatPoint.newMultiRangeQueryBuilder("point", numDims);
+    for (int j = 0;j < numVals; j++) {
+      float[] lowerBound = new float[numDims];
+      float[] upperBound = new float[numDims];
+      for (int i = 0; i < numDims; ++i) {
+        lowerBound[i] = value[i] - random().nextInt(1);
+        upperBound[i] = value[i] + random().nextInt(1);
+      }
+      builder.add(lowerBound, upperBound, MultiRangeQuery.LogicalOperandType.AND);
+    }
+
+    Query query = builder.build();
+    searcher.search(query, Integer.MAX_VALUE);
+
+    reader.close();
+    w.close();
+    dir.close();
+  }
+
+  public void testIntPointMultiRangeQuery() throws IOException {
+    Directory dir = newDirectory();
+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
+    int[] firstPoint = {112, 296, 512};
+    int[] secondPoint = {219, 514, 624};
+
+    Document doc = new Document();
+    doc.add(new IntPoint("point", firstPoint));
+    iw.addDocument(doc);
+    iw.commit();
+
+    doc = new Document();
+    doc.add(new IntPoint("point", secondPoint));
+    iw.addDocument(doc);
+    iw.commit();
+
+    // One AND ranges match
+    int[] firstLowerRange= {111, 294, 502};
+    int[] firstUpperRange = {117, 301, 514};
+
+    int[] secondLowerRange = {15, 4, 415};
+    int[] secondUpperRange = {200, 402, 583};
+
+    IntPoint.IntPointMultiRangeBuilder builder = IntPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder.add(firstLowerRange, firstUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder.add(secondLowerRange, secondUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    Query query = builder.build();
+
+    IndexReader reader = iw.getReader();
+    final IndexSearcher searcher = newSearcher(reader);
+    iw.close();
+
+    assertEquals(searcher.count(query), 1);
+
+    // One range does not match
+    int[] matchingLowerRange= {111, 294, 502};
+    int[] matchingUpperRange = {117, 301, 514};
+
+    int[] nonMatchingLowerRange = {703, 901, 415};
+    int[] nonMatchingUpperRange = {1103, 1006, 583};
+
+
+    IntPoint.IntPointMultiRangeBuilder builder2 = IntPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder2.add(matchingLowerRange,matchingUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder2.add(nonMatchingLowerRange, nonMatchingUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    query = builder2.build();
+
+    assertEquals(searcher.count(query), 0);
+
+    // Overlapping ranges should select smaller range
+    int[] largerRangeLowerRange = {103, 294, 502};
+    int[] largerRangeUpperRange = {310, 518, 653};
+
+    int[] smallerRangeLowerRange = {214, 512, 619};
+    int[] smallerUpperRange = {220, 523, 631};
+    IntPoint.IntPointMultiRangeBuilder builder3 = IntPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder3.add(largerRangeLowerRange, largerRangeUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder3.add(smallerRangeLowerRange, smallerUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    query = builder3.build();
+
+    TopDocs topDocs = searcher.search(query, Integer.MAX_VALUE);
+
+    assertEquals(topDocs.scoreDocs.length, 1);
+    assertEquals(topDocs.scoreDocs[0].doc, 1);
+
+    // One NOT range does not match
+    int[] andLowerRange = {103, 294, 502};
+    int[] andUpperRange = {310, 518, 653};
+
+    int[] notLowerRange = {214, 512, 619};
+    int[] notUpperRange = {220, 523, 631};
+    IntPoint.IntPointMultiRangeBuilder builder4 = IntPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder4.add(andLowerRange, andUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    builder4.add(notLowerRange, notUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+
+    query = builder4.build();
+
+    assertEquals(searcher.count(query), 1);
+
+    // None of the NOT ranges contain any values
+    int[] firstNotLowerRange = {3, 2, 7};
+    int[] firstNotUpperRange = {5, 4, 8};
+
+    int[] secondNotLowerRange = {28, 36, 33};
+    int[] secondNotUpperRange = {32, 41, 35};
+    IntPoint.IntPointMultiRangeBuilder builder5 = IntPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder5.add(firstNotLowerRange, firstNotUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+    builder5.add(secondNotLowerRange, secondNotUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+
+    query = builder5.build();
+
+    assertEquals(searcher.count(query), 2);
+
+    // Ranges exclude everything
+    int[] firstExclusionLowerRange= {111, 294, 502};
+    int[] firstExclusionUpperRange = {117, 301, 514};
+
+    int[] secondExclusionLowerRange = {15, 4, 415};
+    int[] secondExclusionUpperRange = {220, 402, 583};
+
+    IntPoint.IntPointMultiRangeBuilder builder6 = IntPoint.newMultiRangeQueryBuilder("point", 3);
+
+    builder6.add(firstExclusionLowerRange, firstExclusionUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+    builder6.add(secondExclusionLowerRange, secondExclusionUpperRange, MultiRangeQuery.LogicalOperandType.NOT);
+
+    query = builder6.build();
+
+    assertEquals(searcher.count(query), 0);
+
+    reader.close();
+    dir.close();
+  }
+
+  public void testToString() {
+    double[] firstDoubleLowerRange= {111, 294.3, 502.4};
+    double[] firstDoubleUpperRange = {117.3, 301.8, 514.3};
+
+    double[] secondDoubleLowerRange = {15.3, 412.8, 415.1};
+    double[] secondDoubleUpperRange = {200.4, 567.4, 642.2};
+
+    DoublePoint.DoublePointMultiRangeBuilder stringTestbuilder = DoublePoint.newMultiRangeQueryBuilder("point", 3);
+
+    stringTestbuilder.add(firstDoubleLowerRange, firstDoubleUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    stringTestbuilder.add(secondDoubleLowerRange, secondDoubleUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    Query query = stringTestbuilder.build();
+
+    assertEquals("point:AND{[111.0 TO 117.3],[294.3 TO 301.8],[502.4 TO 514.3]},AND{[15.3 TO 200.4],[412.8 TO 567.4],[415.1 TO 642.2]}",
+        query.toString());
+
+    long[] firstLongLowerRange= {111, 294, 502};
+    long[] firstLongUpperRange = {117, 301, 514};
+
+    long[] secondLongLowerRange = {15, 412, 415};
+    long[] secondLongUpperRange = {200, 567, 642};
+
+    LongPoint.LongPointMultiRangeBuilder stringLongTestbuilder = LongPoint.newMultiRangeQueryBuilder("point", 3);
+
+    stringLongTestbuilder.add(firstLongLowerRange, firstLongUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    stringLongTestbuilder.add(secondLongLowerRange, secondLongUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    query = stringLongTestbuilder.build();
+
+    assertEquals("point:AND{[111 TO 117],[294 TO 301],[502 TO 514]},AND{[15 TO 200],[412 TO 567],[415 TO 642]}",
+        query.toString());
+
+    float[] firstFloatLowerRange= {111.3f, 294.4f, 502.2f};
+    float[] firstFloatUpperRange = {117.7f, 301.2f, 514.4f};
+
+    float[] secondFloatLowerRange = {15.3f, 412.2f, 415.9f};
+    float[] secondFloatUpperRange = {200.2f, 567.4f, 642.3f};
+
+    FloatPoint.FloatPointMultiRangeBuilder stringFloatTestbuilder = FloatPoint.newMultiRangeQueryBuilder("point", 3);
+
+    stringFloatTestbuilder.add(firstFloatLowerRange, firstFloatUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    stringFloatTestbuilder.add(secondFloatLowerRange, secondFloatUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    query = stringFloatTestbuilder.build();
+
+    assertEquals("point:AND{[111.3 TO 117.7],[294.4 TO 301.2],[502.2 TO 514.4]},AND{[15.3 TO 200.2],[412.2 TO 567.4],[415.9 TO 642.3]}",
+        query.toString());
+
+    int[] firstIntLowerRange= {111, 294, 502};
+    int[] firstIntUpperRange = {117, 301, 514};
+
+    int[] secondIntLowerRange = {15, 412, 415};
+    int[] secondIntUpperRange = {200, 567, 642};
+
+    IntPoint.IntPointMultiRangeBuilder stringIntTestbuilder = IntPoint.newMultiRangeQueryBuilder("point", 3);
+
+    stringIntTestbuilder.add(firstIntLowerRange, firstIntUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+    stringIntTestbuilder.add(secondIntLowerRange, secondIntUpperRange, MultiRangeQuery.LogicalOperandType.AND);
+
+    query = stringIntTestbuilder.build();
+
+    assertEquals("point:AND{[111 TO 117],[294 TO 301],[502 TO 514]},AND{[15 TO 200],[412 TO 567],[415 TO 642]}",
+        query.toString());
+  }
+}
-- 
2.17.2 (Apple Git-113)

