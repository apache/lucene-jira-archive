Index: lucene/queries/src/java/org/apache/lucene/queries/mlt/MoreLikeThis.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/mlt/MoreLikeThis.java	(revision 1660376)
+++ lucene/queries/src/java/org/apache/lucene/queries/mlt/MoreLikeThis.java	(working copy)
@@ -43,6 +43,7 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
@@ -152,7 +153,7 @@
    * @see #getMinTermFreq
    * @see #setMinTermFreq
    */
-  public static final int DEFAULT_MIN_TERM_FREQ = 2;
+  public static final int DEFAULT_MIN_TERM_FREQ = 1;
 
   /**
    * Ignore words which do not occur in at least this many docs.
@@ -160,7 +161,7 @@
    * @see #getMinDocFreq
    * @see #setMinDocFreq
    */
-  public static final int DEFAULT_MIN_DOC_FREQ = 5;
+  public static final int DEFAULT_MIN_DOC_FREQ = 1;
 
   /**
    * Ignore words which occur in more than this many docs.
@@ -250,6 +251,11 @@
   private boolean boost = DEFAULT_BOOST;
 
   /**
+   * Current set of skip terms.
+   */
+  private Set<Term> skipTerms = null;
+
+  /**
    * Field name we'll analyze.
    */
   private String[] fieldNames = DEFAULT_FIELD_NAMES;
@@ -309,6 +315,13 @@
   }
 
   /**
+   * Sets a list of terms to never select from
+   */
+  public void setSkipTerms(Set<Term> skipTerms) {
+    this.skipTerms = skipTerms;
+  }
+
+  /**
    * Constructor requiring an IndexReader.
    */
   public MoreLikeThis(IndexReader ir) {
@@ -610,10 +623,59 @@
   }
 
   /**
+   * Return a query that will return docs like the passed Terms.
+   *
+   * @return a query that will return docs like the passed Terms.
+   */
+  public Query like(Terms... likeTerms) throws IOException {
+    Map<String, Int> termFreqMap = new HashMap<>();
+    for (Terms vector : likeTerms) {
+      addTermFrequencies(termFreqMap, vector);
+    }
+    return createQuery(createQueue(termFreqMap));
+  }
+
+  /**
+   * Return a query that will return docs like the passed Fields.
+   *
+   * @return a query that will return docs like the passed Fields.
+   */
+  public Query like(Fields... likeFields) throws IOException {
+    // get all field names
+    Set<String> fieldNames = new HashSet<>();
+    for (Fields fields : likeFields) {
+      for (String fieldName : fields) {
+        fieldNames.add(fieldName);
+      }
+    }
+    // term selection is per field, then appended to a single boolean query
+    BooleanQuery bq = new BooleanQuery();
+    for (String fieldName : fieldNames) {
+      Map<String, Int> termFreqMap = new HashMap<>();
+      for (Fields fields : likeFields) {
+        Terms vector = fields.terms(fieldName);
+        if (vector != null) {
+          addTermFrequencies(termFreqMap, vector, fieldName);
+        }
+      }
+      addToQuery(createQueue(termFreqMap, fieldName), bq);
+    }
+    return bq;
+  }
+
+  /**
    * Create the More like query from a PriorityQueue
    */
   private Query createQuery(PriorityQueue<ScoreTerm> q) {
     BooleanQuery query = new BooleanQuery();
+    addToQuery(q, query);
+    return query;
+  }
+
+  /**
+   * Add to an existing boolean query the More Like This query from this PriorityQueue
+   */
+  private void addToQuery(PriorityQueue<ScoreTerm> q, BooleanQuery query) {
     ScoreTerm scoreTerm;
     float bestScore = -1;
 
@@ -635,7 +697,6 @@
         break;
       }
     }
-    return query;
   }
 
   /**
@@ -644,6 +705,16 @@
    * @param words a map of words keyed on the word(String) with Int objects as the values.
    */
   private PriorityQueue<ScoreTerm> createQueue(Map<String, Int> words) throws IOException {
+    return createQueue(words, this.fieldNames);
+  }
+
+  /**
+   * Create a PriorityQueue from a word-&gt;tf map.
+   *
+   * @param words a map of words keyed on the word(String) with Int objects as the values.
+   * @param fieldNames an array of field names to override defaults.
+   */
+  private PriorityQueue<ScoreTerm> createQueue(Map<String, Int> words, String... fieldNames) throws IOException {
     // have collected all words in doc and their freqs
     int numDocs = ir.numDocs();
     final int limit = Math.min(maxQueryTerms, words.size());
@@ -741,7 +812,7 @@
           }
         }
       } else {
-        addTermFrequencies(termFreqMap, vector);
+        addTermFrequencies(termFreqMap, vector, fieldName);
       }
     }
 
@@ -773,6 +844,17 @@
    * @param vector List of terms and their frequencies for a doc/field
    */
   private void addTermFrequencies(Map<String, Int> termFreqMap, Terms vector) throws IOException {
+    addTermFrequencies(termFreqMap, vector, null);
+  }
+
+  /**
+   * Adds terms and frequencies found in vector into the Map termFreqMap
+   *
+   * @param termFreqMap a Map of terms and their frequencies
+   * @param vector List of terms and their frequencies for a doc/field
+   * @param fieldName Optional field name of the terms for skip terms
+   */
+  private void addTermFrequencies(Map<String, Int> termFreqMap, Terms vector, String fieldName) throws IOException {
     final TermsEnum termsEnum = vector.iterator(null);
     final CharsRefBuilder spare = new CharsRefBuilder();
     BytesRef text;
@@ -782,6 +864,9 @@
       if (isNoiseWord(term)) {
         continue;
       }
+      if (isSkipTerm(fieldName, term)) {
+        continue;
+      }
       final int freq = (int) termsEnum.totalTermFreq();
 
       // increment frequency
@@ -823,6 +908,9 @@
         if (isNoiseWord(word)) {
           continue;
         }
+        if (isSkipTerm(fieldName, word)) {
+          continue;
+        }
 
         // increment frequency
         Int cnt = termFreqMap.get(word);
@@ -854,6 +942,12 @@
     return stopWords != null && stopWords.contains(term);
   }
 
+  /**
+   * determines if the passed term is to be skipped all together
+   */
+  private boolean isSkipTerm(String field, String value) {
+    return field != null && skipTerms != null && skipTerms.contains(new Term(field, value));
+  }
 
   /**
    * Find words for a more-like-this query former.
