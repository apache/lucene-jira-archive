Index: lucene/core/src/java/org/apache/lucene/store/MMapDirectory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/MMapDirectory.java	(revision 1348156)
+++ lucene/core/src/java/org/apache/lucene/store/MMapDirectory.java	(working copy)
@@ -246,238 +246,44 @@
     };
   }
 
-  // Because Java's ByteBuffer uses an int to address the
-  // values, it's necessary to access a file >
-  // Integer.MAX_VALUE in size using multiple byte buffers.
-  private final class MMapIndexInput extends IndexInput {
+  private final class MMapIndexInput extends ByteBufferIndexInput {
   
-    private ByteBuffer[] buffers;
-  
-    private final long length, chunkSizeMask, chunkSize;
-    private final int chunkSizePower;
-  
-    private int curBufIndex;
-  
-    private ByteBuffer curBuf; // redundant for speed: buffers[curBufIndex]
-  
-    private boolean isClone = false;
-    private final Set<MMapIndexInput> clones = Collections.newSetFromMap(new WeakHashMap<MMapIndexInput,Boolean>());
-
     MMapIndexInput(String resourceDescription, RandomAccessFile raf, long offset, long length, int chunkSizePower) throws IOException {
-      super(resourceDescription);
-      this.length = length;
-      this.chunkSizePower = chunkSizePower;
-      this.chunkSize = 1L << chunkSizePower;
-      this.chunkSizeMask = chunkSize - 1L;
-      
-      if (chunkSizePower < 0 || chunkSizePower > 30)
-        throw new IllegalArgumentException("Invalid chunkSizePower used for ByteBuffer size: " + chunkSizePower);
-      
-      if ((length >>> chunkSizePower) >= Integer.MAX_VALUE)
-        throw new IllegalArgumentException("RandomAccessFile too big for chunk size: " + raf.toString());
-      
-      // we always allocate one more buffer, the last one may be a 0 byte one
-      final int nrBuffers = (int) (length >>> chunkSizePower) + 1;
-      
-      //System.out.println("length="+length+", chunkSizePower=" + chunkSizePower + ", chunkSizeMask=" + chunkSizeMask + ", nrBuffers=" + nrBuffers);
-      
-      this.buffers = new ByteBuffer[nrBuffers];
-      
-      long bufferStart = 0L;
-      FileChannel rafc = raf.getChannel();
-      for (int bufNr = 0; bufNr < nrBuffers; bufNr++) { 
-        int bufSize = (int) ( (length > (bufferStart + chunkSize))
-          ? chunkSize
-          : (length - bufferStart)
-        );
-        this.buffers[bufNr] = rafc.map(MapMode.READ_ONLY, offset + bufferStart, bufSize);
-        bufferStart += bufSize;
-      }
-      seek(0L);
+      super(resourceDescription, map(raf, offset, length, chunkSizePower), length, chunkSizePower);
     }
-  
-    @Override
-    public byte readByte() throws IOException {
-      try {
-        return curBuf.get();
-      } catch (BufferUnderflowException e) {
-        do {
-          curBufIndex++;
-          if (curBufIndex >= buffers.length) {
-            throw new EOFException("read past EOF: " + this);
-          }
-          curBuf = buffers[curBufIndex];
-          curBuf.position(0);
-        } while (!curBuf.hasRemaining());
-        return curBuf.get();
-      } catch (NullPointerException npe) {
-        throw new AlreadyClosedException("MMapIndexInput already closed: " + this);
-      }
-    }
-  
-    @Override
-    public void readBytes(byte[] b, int offset, int len) throws IOException {
-      try {
-        curBuf.get(b, offset, len);
-      } catch (BufferUnderflowException e) {
-        int curAvail = curBuf.remaining();
-        while (len > curAvail) {
-          curBuf.get(b, offset, curAvail);
-          len -= curAvail;
-          offset += curAvail;
-          curBufIndex++;
-          if (curBufIndex >= buffers.length) {
-            throw new EOFException("read past EOF: " + this);
-          }
-          curBuf = buffers[curBufIndex];
-          curBuf.position(0);
-          curAvail = curBuf.remaining();
-        }
-        curBuf.get(b, offset, len);
-      } catch (NullPointerException npe) {
-        throw new AlreadyClosedException("MMapIndexInput already closed: " + this);
-      }
-    }
-  
-    @Override
-    public short readShort() throws IOException {
-      try {
-        return curBuf.getShort();
-      } catch (BufferUnderflowException e) {
-        return super.readShort();
-      } catch (NullPointerException npe) {
-        throw new AlreadyClosedException("MMapIndexInput already closed: " + this);
-      }
-    }
-
-    @Override
-    public int readInt() throws IOException {
-      try {
-        return curBuf.getInt();
-      } catch (BufferUnderflowException e) {
-        return super.readInt();
-      } catch (NullPointerException npe) {
-        throw new AlreadyClosedException("MMapIndexInput already closed: " + this);
-      }
-    }
-
-    @Override
-    public long readLong() throws IOException {
-      try {
-        return curBuf.getLong();
-      } catch (BufferUnderflowException e) {
-        return super.readLong();
-      } catch (NullPointerException npe) {
-        throw new AlreadyClosedException("MMapIndexInput already closed: " + this);
-      }
-    }
     
     @Override
-    public long getFilePointer() {
-      try {
-        return (((long) curBufIndex) << chunkSizePower) + curBuf.position();
-      } catch (NullPointerException npe) {
-        throw new AlreadyClosedException("MMapIndexInput already closed: " + this);
-      }
+    void freeBuffer(ByteBuffer b) throws IOException {
+      cleanMapping(b);
     }
+  }
   
-    @Override
-    public void seek(long pos) throws IOException {
-      // we use >> here to preserve negative, so we will catch AIOOBE:
-      final int bi = (int) (pos >> chunkSizePower);
-      try {
-        final ByteBuffer b = buffers[bi];
-        b.position((int) (pos & chunkSizeMask));
-        // write values, on exception all is unchanged
-        this.curBufIndex = bi;
-        this.curBuf = b;
-      } catch (ArrayIndexOutOfBoundsException aioobe) {
-        if (pos < 0L) {
-          throw new IllegalArgumentException("Seeking to negative position: " + this);
-        }
-        throw new EOFException("seek past EOF: " + this);
-      } catch (IllegalArgumentException iae) {
-        if (pos < 0L) {
-          throw new IllegalArgumentException("Seeking to negative position: " + this);
-        }
-        throw new EOFException("seek past EOF: " + this);
-      } catch (NullPointerException npe) {
-        throw new AlreadyClosedException("MMapIndexInput already closed: " + this);
-      }
-    }
-  
-    @Override
-    public long length() {
-      return length;
-    }
-  
-    @Override
-    public MMapIndexInput clone() {
-      if (buffers == null) {
-        throw new AlreadyClosedException("MMapIndexInput already closed: " + this);
-      }
-      final MMapIndexInput clone = (MMapIndexInput)super.clone();
-      clone.isClone = true;
-      // we keep clone.clones, so it shares the same map with original and we have no additional cost on clones
-      assert clone.clones == this.clones;
-      clone.buffers = new ByteBuffer[buffers.length];
-      for (int bufNr = 0; bufNr < buffers.length; bufNr++) {
-        clone.buffers[bufNr] = buffers[bufNr].duplicate();
-      }
-      try {
-        clone.seek(getFilePointer());
-      } catch(IOException ioe) {
-        throw new RuntimeException("Should never happen: " + this, ioe);
-      }
-      
-      // register the new clone in our clone list to clean it up on closing:
-      synchronized(this.clones) {
-        this.clones.add(clone);
-      }
-      
-      return clone;
-    }
+  private final ByteBuffer[] map(RandomAccessFile raf, long offset, long length, int chunkSizePower) throws IOException {
+    if (chunkSizePower < 0 || chunkSizePower > 30)
+      throw new IllegalArgumentException("Invalid chunkSizePower used for ByteBuffer size: " + chunkSizePower);
     
-    private void unsetBuffers() {
-      buffers = null;
-      curBuf = null;
-      curBufIndex = 0;
-    }
-  
-    @Override
-    public void close() throws IOException {
-      try {
-        if (isClone || buffers == null) return;
+    if ((length >>> chunkSizePower) >= Integer.MAX_VALUE)
+      throw new IllegalArgumentException("RandomAccessFile too big for chunk size: " + raf.toString());
+    
+    final long chunkSize = 1L << chunkSizePower;
+    
+    // we always allocate one more buffer, the last one may be a 0 byte one
+    final int nrBuffers = (int) (length >>> chunkSizePower) + 1;
         
-        // for extra safety unset also all clones' buffers:
-        synchronized(this.clones) {
-          for (final MMapIndexInput clone : this.clones) {
-            assert clone.isClone;
-            clone.unsetBuffers();
-          }
-          this.clones.clear();
-        }
-        
-        curBuf = null; curBufIndex = 0; // nuke curr pointer early
-        for (int bufNr = 0; bufNr < buffers.length; bufNr++) {
-          cleanMapping(buffers[bufNr]);
-        }
-      } finally {
-        unsetBuffers();
-      }
+    ByteBuffer buffers[] = new ByteBuffer[nrBuffers];
+    
+    long bufferStart = 0L;
+    FileChannel rafc = raf.getChannel();
+    for (int bufNr = 0; bufNr < nrBuffers; bufNr++) { 
+      int bufSize = (int) ( (length > (bufferStart + chunkSize))
+        ? chunkSize
+        : (length - bufferStart)
+      );
+      buffers[bufNr] = rafc.map(MapMode.READ_ONLY, offset + bufferStart, bufSize);
+      bufferStart += bufSize;
     }
-
-    // make sure we have identity on equals/hashCode for WeakHashMap
-    @Override
-    public int hashCode() {
-      return System.identityHashCode(this);
-    }
-
-    // make sure we have identity on equals/hashCode for WeakHashMap
-    @Override
-    public boolean equals(Object obj) {
-      return obj == this;
-    }
+    
+    return buffers;
   }
 
 }
Index: lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput.java	(working copy)
@@ -0,0 +1,248 @@
+package org.apache.lucene.store;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.nio.BufferUnderflowException;
+import java.nio.ByteBuffer;
+import java.util.Collections;
+import java.util.Set;
+import java.util.WeakHashMap;
+
+/** 
+ * Because Java's ByteBuffer uses an int to address the
+ * values, it's necessary to access a file >
+ * Integer.MAX_VALUE in size using multiple byte buffers.
+ */
+abstract class ByteBufferIndexInput extends IndexInput {
+
+  private ByteBuffer[] buffers;
+
+  private final long length, chunkSizeMask;
+  private final int chunkSizePower;
+
+  private int curBufIndex;
+
+  private ByteBuffer curBuf; // redundant for speed: buffers[curBufIndex]
+
+  private boolean isClone = false;
+  private final Set<ByteBufferIndexInput> clones = Collections.newSetFromMap(new WeakHashMap<ByteBufferIndexInput,Boolean>());
+
+  ByteBufferIndexInput(String resourceDescription, ByteBuffer[] buffers, long length, int chunkSizePower) throws IOException {
+    super(resourceDescription);
+    this.buffers = buffers;
+    this.length = length;
+    this.chunkSizePower = chunkSizePower;
+    final long chunkSize = 1L << chunkSizePower;
+    this.chunkSizeMask = chunkSize - 1L;
+    
+    assert chunkSizePower >= 0 && chunkSizePower <= 30;   
+    assert (length >>> chunkSizePower) < Integer.MAX_VALUE;
+
+    seek(0L);
+  }
+
+  @Override
+  public byte readByte() throws IOException {
+    try {
+      return curBuf.get();
+    } catch (BufferUnderflowException e) {
+      do {
+        curBufIndex++;
+        if (curBufIndex >= buffers.length) {
+          throw new EOFException("read past EOF: " + this);
+        }
+        curBuf = buffers[curBufIndex];
+        curBuf.position(0);
+      } while (!curBuf.hasRemaining());
+      return curBuf.get();
+    } catch (NullPointerException npe) {
+      throw new AlreadyClosedException("ByteBufferIndexInput already closed: " + this);
+    }
+  }
+
+  @Override
+  public void readBytes(byte[] b, int offset, int len) throws IOException {
+    try {
+      curBuf.get(b, offset, len);
+    } catch (BufferUnderflowException e) {
+      int curAvail = curBuf.remaining();
+      while (len > curAvail) {
+        curBuf.get(b, offset, curAvail);
+        len -= curAvail;
+        offset += curAvail;
+        curBufIndex++;
+        if (curBufIndex >= buffers.length) {
+          throw new EOFException("read past EOF: " + this);
+        }
+        curBuf = buffers[curBufIndex];
+        curBuf.position(0);
+        curAvail = curBuf.remaining();
+      }
+      curBuf.get(b, offset, len);
+    } catch (NullPointerException npe) {
+      throw new AlreadyClosedException("ByteBufferIndexInput already closed: " + this);
+    }
+  }
+
+  @Override
+  public short readShort() throws IOException {
+    try {
+      return curBuf.getShort();
+    } catch (BufferUnderflowException e) {
+      return super.readShort();
+    } catch (NullPointerException npe) {
+      throw new AlreadyClosedException("ByteBufferIndexInput already closed: " + this);
+    }
+  }
+
+  @Override
+  public int readInt() throws IOException {
+    try {
+      return curBuf.getInt();
+    } catch (BufferUnderflowException e) {
+      return super.readInt();
+    } catch (NullPointerException npe) {
+      throw new AlreadyClosedException("ByteBufferIndexInput already closed: " + this);
+    }
+  }
+
+  @Override
+  public long readLong() throws IOException {
+    try {
+      return curBuf.getLong();
+    } catch (BufferUnderflowException e) {
+      return super.readLong();
+    } catch (NullPointerException npe) {
+      throw new AlreadyClosedException("ByteBufferIndexInput already closed: " + this);
+    }
+  }
+  
+  @Override
+  public long getFilePointer() {
+    try {
+      return (((long) curBufIndex) << chunkSizePower) + curBuf.position();
+    } catch (NullPointerException npe) {
+      throw new AlreadyClosedException("ByteBufferIndexInput already closed: " + this);
+    }
+  }
+
+  @Override
+  public void seek(long pos) throws IOException {
+    // we use >> here to preserve negative, so we will catch AIOOBE:
+    final int bi = (int) (pos >> chunkSizePower);
+    try {
+      final ByteBuffer b = buffers[bi];
+      b.position((int) (pos & chunkSizeMask));
+      // write values, on exception all is unchanged
+      this.curBufIndex = bi;
+      this.curBuf = b;
+    } catch (ArrayIndexOutOfBoundsException aioobe) {
+      if (pos < 0L) {
+        throw new IllegalArgumentException("Seeking to negative position: " + this);
+      }
+      throw new EOFException("seek past EOF: " + this);
+    } catch (IllegalArgumentException iae) {
+      if (pos < 0L) {
+        throw new IllegalArgumentException("Seeking to negative position: " + this);
+      }
+      throw new EOFException("seek past EOF: " + this);
+    } catch (NullPointerException npe) {
+      throw new AlreadyClosedException("ByteBufferIndexInput already closed: " + this);
+    }
+  }
+
+  @Override
+  public long length() {
+    return length;
+  }
+
+  @Override
+  public ByteBufferIndexInput clone() {
+    if (buffers == null) {
+      throw new AlreadyClosedException("ByteBufferIndexInput already closed: " + this);
+    }
+    final ByteBufferIndexInput clone = (ByteBufferIndexInput)super.clone();
+    clone.isClone = true;
+    // we keep clone.clones, so it shares the same map with original and we have no additional cost on clones
+    assert clone.clones == this.clones;
+    clone.buffers = new ByteBuffer[buffers.length];
+    for (int bufNr = 0; bufNr < buffers.length; bufNr++) {
+      clone.buffers[bufNr] = buffers[bufNr].duplicate();
+    }
+    try {
+      clone.seek(getFilePointer());
+    } catch(IOException ioe) {
+      throw new RuntimeException("Should never happen: " + this, ioe);
+    }
+    
+    // register the new clone in our clone list to clean it up on closing:
+    synchronized(this.clones) {
+      this.clones.add(clone);
+    }
+    
+    return clone;
+  }
+  
+  private void unsetBuffers() {
+    buffers = null;
+    curBuf = null;
+    curBufIndex = 0;
+  }
+
+  @Override
+  public void close() throws IOException {
+    try {
+      if (isClone || buffers == null) return;
+      
+      // for extra safety unset also all clones' buffers:
+      synchronized(this.clones) {
+        for (final ByteBufferIndexInput clone : this.clones) {
+          assert clone.isClone;
+          clone.unsetBuffers();
+        }
+        this.clones.clear();
+      }
+      
+      curBuf = null; curBufIndex = 0; // nuke curr pointer early
+      for (int bufNr = 0; bufNr < buffers.length; bufNr++) {
+        freeBuffer(buffers[bufNr]);
+      }
+    } finally {
+      unsetBuffers();
+    }
+  }
+
+  // make sure we have identity on equals/hashCode for WeakHashMap
+  @Override
+  public int hashCode() {
+    return System.identityHashCode(this);
+  }
+
+  // make sure we have identity on equals/hashCode for WeakHashMap
+  @Override
+  public boolean equals(Object obj) {
+    return obj == this;
+  }
+  
+  /**
+   * Called when the contents of a buffer will be no longer needed.
+   */
+  abstract void freeBuffer(ByteBuffer b) throws IOException;
+}

Property changes on: lucene/core/src/java/org/apache/lucene/store/ByteBufferIndexInput.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
