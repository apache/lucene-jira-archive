diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/DoubleSimScorer.java b/lucene/core/src/java/org/apache/lucene/search/similarities/DoubleSimScorer.java
new file mode 100644
index 0000000..1ecbe6d
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/DoubleSimScorer.java
@@ -0,0 +1,32 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search.similarities;
+
+import java.io.IOException;
+
+import org.apache.lucene.search.similarities.Similarity.SimScorer;
+
+abstract class DoubleSimScorer extends SimScorer {
+
+  @Override
+  public final float score(int doc, float freq) throws IOException {
+    return (float) scoreDouble(doc, freq);
+  }
+
+  protected abstract double scoreDouble(int doc, float freq) throws IOException;
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/SimilarityBase.java b/lucene/core/src/java/org/apache/lucene/search/similarities/SimilarityBase.java
index 380673a..843c9e4 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/SimilarityBase.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/SimilarityBase.java
@@ -226,7 +226,7 @@ public abstract class SimilarityBase extends Similarity {
    * {@link SimilarityBase#explain(BasicStats, int, Explanation, double)},
    * respectively.
    */
-  final class BasicSimScorer extends SimScorer {
+  final class BasicSimScorer extends DoubleSimScorer {
     private final BasicStats stats;
     private final NumericDocValues norms;
     
@@ -245,8 +245,8 @@ public abstract class SimilarityBase extends Similarity {
     }
     
     @Override
-    public float score(int doc, float freq) throws IOException {
-      return (float) SimilarityBase.this.score(stats, freq, getLengthValue(doc));
+    public double scoreDouble(int doc, float freq) throws IOException {
+      return SimilarityBase.this.score(stats, freq, getLengthValue(doc));
     }
 
     @Override
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase.java
index a0f2ece..e25631c 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase.java
@@ -365,16 +365,20 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
     SimWeight weight = similarity.computeWeight(boost, corpus, term);
     SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());
     try {
-      float score = scorer.score(0, freq);
+      double score;
+      if (scorer instanceof DoubleSimScorer)
+        score = ((DoubleSimScorer) scorer).scoreDouble(0, freq);
+      else
+        score = scorer.score(0, freq);
       // check that score isn't infinite or negative
-      assertTrue("infinite/NaN score: " + score, Float.isFinite(score));
+      assertTrue("infinite/NaN score: " + score, Double.isFinite(score));
       assertTrue("negative score: " + score, score >= 0);
       // check explanation matches
       Explanation explanation = scorer.explain(0, Explanation.match(freq, "freq, occurrences of term within document"));
-      if (score != explanation.getValue()) {
-        fail("expected: " + score + ", got: " + explanation);
+      if ((float) score != explanation.getValue()) {
+        fail("expected: " + (float) score + ", got: " + explanation);
       }
-      CheckHits.verifyExplanation("<test query>", 0, score, true, explanation);
+      CheckHits.verifyExplanation("<test query>", 0, (float) score, true, explanation);
       
       // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]
       final float prevFreq;
@@ -385,17 +389,20 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
         // previous in float space (e.g. for sloppyPhrase)
         prevFreq = Math.nextDown(freq);
       }
-      
-      float prevScore = scorer.score(0, prevFreq);
+      double prevScore;
+      if (scorer instanceof DoubleSimScorer)
+        prevScore = ((DoubleSimScorer) scorer).scoreDouble(0, prevFreq);
+      else
+        prevScore = scorer.score(0, prevFreq);
       // check that score isn't infinite or negative
-      assertTrue(Float.isFinite(prevScore));
+      assertTrue(Double.isFinite(prevScore));
       assertTrue(prevScore >= 0);
       // check explanation matches
       Explanation prevExplanation = scorer.explain(0, Explanation.match(prevFreq, "freq, occurrences of term within document"));
-      if (prevScore != prevExplanation.getValue()) {
+      if ((float) prevScore != prevExplanation.getValue()) {
         fail("expected: " + prevScore + ", got: " + prevExplanation);
       }
-      CheckHits.verifyExplanation("test query (prevFreq)", 0, prevScore, true, prevExplanation);
+      CheckHits.verifyExplanation("test query (prevFreq)", 0, (float) prevScore, true, prevExplanation);
 
       if (prevScore > score) {
         System.out.println(prevExplanation);
@@ -406,16 +413,20 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
       // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]
       if (norm > 1) {
         SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());
-        float prevNormScore = prevNormScorer.score(0, freq);
+        double prevNormScore;
+        if (prevNormScorer instanceof DoubleSimScorer)
+          prevNormScore = ((DoubleSimScorer) prevNormScorer).scoreDouble(0, freq);
+        else
+          prevNormScore = prevNormScorer.score(0, freq);
         // check that score isn't infinite or negative
-        assertTrue(Float.isFinite(prevNormScore));
+        assertTrue(Double.isFinite(prevNormScore));
         assertTrue(prevNormScore >= 0);
         // check explanation matches
         Explanation prevNormExplanation = prevNormScorer.explain(0, Explanation.match(freq, "freq, occurrences of term within document"));
-        if (prevNormScore != prevNormExplanation.getValue()) {
+        if ((float) prevNormScore != prevNormExplanation.getValue()) {
           fail("expected: " + prevNormScore + ", got: " + prevNormExplanation);
         }
-        CheckHits.verifyExplanation("test query (prevNorm)", 0, prevNormScore, true, prevNormExplanation);
+        CheckHits.verifyExplanation("test query (prevNorm)", 0, (float) prevNormScore, true, prevNormExplanation);
 
         if (prevNormScore < score) {
           System.out.println(prevNormExplanation);
@@ -429,16 +440,20 @@ public abstract class BaseSimilarityTestCase extends LuceneTestCase {
         TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);
         SimWeight prevWeight = similarity.computeWeight(boost, corpus, term);
         SimScorer prevTermScorer = similarity.simScorer(prevWeight, NORM_VALUES.get(norm).getContext());
-        float prevTermScore = prevTermScorer.score(0, freq);
+        double prevTermScore;
+        if (prevTermScorer instanceof DoubleSimScorer)
+          prevTermScore = ((DoubleSimScorer) prevTermScorer).scoreDouble(0, freq);
+        else
+          prevTermScore = prevTermScorer.score(0, freq);
         // check that score isn't infinite or negative
-        assertTrue(Float.isFinite(prevTermScore));
+        assertTrue(Double.isFinite(prevTermScore));
         assertTrue(prevTermScore >= 0);
         // check explanation matches
         Explanation prevTermExplanation = prevTermScorer.explain(0, Explanation.match(freq, "freq, occurrences of term within document"));
-        if (prevTermScore != prevTermExplanation.getValue()) {
+        if ((float) prevTermScore != prevTermExplanation.getValue()) {
           fail("expected: " + prevTermScore + ", got: " + prevTermExplanation);
         }
-        CheckHits.verifyExplanation("test query (prevTerm)", 0, prevTermScore, true, prevTermExplanation);
+        CheckHits.verifyExplanation("test query (prevTerm)", 0, (float) prevTermScore, true, prevTermExplanation);
 
         if (prevTermScore < score) {
           System.out.println(prevTermExplanation);
