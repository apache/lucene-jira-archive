Index: test/org/apache/lucene/realtime/RealtimeWriter.java
===================================================================
--- test/org/apache/lucene/realtime/RealtimeWriter.java	(revision 0)
+++ test/org/apache/lucene/realtime/RealtimeWriter.java	(revision 0)
@@ -0,0 +1,37 @@
+package org.apache.lucene.realtime;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.locks.ReentrantLock;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.store.instantiated.InstantiatedIndex;
+import org.apache.lucene.store.instantiated.InstantiatedIndexReader;
+import org.apache.lucene.store.instantiated.InstantiatedIndexWriter;
+
+/**
+ * Creates an instantiated index from the document.
+ */
+public class RealtimeWriter implements Writer {
+  //List<IndexReader> readers = new ArrayList<IndexReader>();
+  ReentrantLock lock = new ReentrantLock();
+  
+  public RealtimeWriter() {
+  }
+  
+  public void add(Document document, Analyzer analyzer) throws IOException {
+    InstantiatedIndex index = new InstantiatedIndex();
+    InstantiatedIndexWriter instWriter = new InstantiatedIndexWriter(index);
+    instWriter.addDocument(document, analyzer); 
+    InstantiatedIndexReader reader = new InstantiatedIndexReader(index);
+    //lock.lock();
+    //try {
+      //readers.add(reader);
+    //} finally {
+    //  lock.unlock();
+    //}
+  }
+}

Property changes on: test/org/apache/lucene/realtime/RealtimeWriter.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + "Date Rev Author URL Id"
Name: svn:eol-style
   + native

Index: test/org/apache/lucene/realtime/MultiThreadDocAdd.java
===================================================================
--- test/org/apache/lucene/realtime/MultiThreadDocAdd.java	(revision 0)
+++ test/org/apache/lucene/realtime/MultiThreadDocAdd.java	(revision 0)
@@ -0,0 +1,130 @@
+package org.apache.lucene.realtime;
+
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.document.Document;
+
+public class MultiThreadDocAdd
+{
+  int threadSize = 4;
+  int queueSize  = 1000;
+  int addStep = 1000;
+  ExecutorService threadPool;
+  BlockingQueue<Document> queue;
+  AtomicBoolean go;
+  Future[] futures;
+  Writer writer;
+  int numDocs;
+  Analyzer analyzer;
+
+  public MultiThreadDocAdd(Writer writer, Analyzer analyzer, int numDocs, int threadSize)
+  {
+    this.writer = writer;
+    this.analyzer = analyzer;
+    this.numDocs = numDocs;
+    this.threadSize = threadSize;
+    threadPool = Executors.newFixedThreadPool(threadSize);
+    queue = new ArrayBlockingQueue<Document>(queueSize);
+    Indexer[] indexers = new Indexer[threadSize];
+    futures = new Future[indexers.length];
+    go = new AtomicBoolean(true);
+    AtomicInteger count = new AtomicInteger(0);
+    for (int x = 0; x < indexers.length; x++)
+    {
+      indexers[x] = new Indexer(x + "", queue, writer, count, go);
+      futures[x] = threadPool.submit(indexers[x]);
+    }
+  }
+  
+  public void waitComplete() throws Exception {
+    System.out.println("wait complete");
+    go.set(false);
+    int finishCount = 0;
+    for (Future future : futures) {
+      future.get();
+      finishCount++;
+    }
+    assert futures.length == finishCount;
+    threadPool.shutdown();
+    threadPool.awaitTermination(9999999, TimeUnit.MILLISECONDS);
+  }
+  
+  public void add(Document doc) throws Exception {
+    if (!queue.offer(doc)) {
+      Thread.sleep(10);
+      add(doc);
+    }
+  }
+  
+  public class Indexer implements Callable {
+    private Writer writer;
+    BlockingQueue<Document> queue;
+    AtomicInteger count;
+    String name;
+    AtomicBoolean go;
+    int errorCount = 0;
+    public static final int MAX_ERROR_COUNT = 15;
+
+    public Indexer(String name, BlockingQueue<Document> queue,
+        Writer writer, AtomicInteger count, AtomicBoolean go) {
+      this.name = name;
+      this.queue = queue;
+      this.writer = writer;
+      this.count = count;
+      this.go = go;
+    }
+
+    public Object call() throws Exception {
+      System.out.println("Indexer.call numDocs:"+numDocs);
+      Document doc = null;
+      while (true) {
+        doc = queue.poll(500, TimeUnit.MILLISECONDS);
+        //if (doc == null) {
+        //  if (queue.size() == 0 && !go.get())
+        //    break;
+        //}
+        if (!go.get() && doc == null) {
+          System.out.println("go:"+go.get()+" doc=null");
+          break;
+        }
+        if (doc == null) continue;
+        try {
+          writer.add(doc, analyzer);
+        } catch (Throwable ex) {
+          System.out.println("problem adding doc:"+doc+" ex: "+ex);
+          ex.printStackTrace();
+          errorCount++;
+          queue.add(doc); // doc wasn't added, put it back
+          if (errorCount >= MAX_ERROR_COUNT) {
+            throw new Exception("max errors: "+errorCount, ex);
+          }
+          continue;
+        }
+        int i = count.incrementAndGet();
+        if (i % addStep == 0)
+          System.out.println("indexed "+name+" "+ + i + " docs");
+        //if (i >= numDocs) {
+        //  writer.flush();
+        //  System.out.println("Indexer "+name+":"+i+" numDocs:"+numDocs+" writer.numDocs:"+writer.numDocs());
+        //}
+      }
+      System.out.println("Indexer.call  "+name+" done");
+      //while (writer.numDocs() != numDocs) {
+      //  Thread.sleep(10);
+      //}
+      //assert queue.size() == 0;
+      //System.out.println("indexer " + name + " finished q.size: "
+      //    + queue.size());
+      return null;
+    }
+  }
+}

Property changes on: test/org/apache/lucene/realtime/MultiThreadDocAdd.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + "Date Rev Author URL Id"
Name: svn:eol-style
   + native

Index: test/org/apache/lucene/realtime/LuceneWriter.java
===================================================================
--- test/org/apache/lucene/realtime/LuceneWriter.java	(revision 0)
+++ test/org/apache/lucene/realtime/LuceneWriter.java	(revision 0)
@@ -0,0 +1,24 @@
+package org.apache.lucene.realtime;
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriter.MaxFieldLength;
+import org.apache.lucene.store.RAMDirectory;
+
+public class LuceneWriter implements Writer {
+  IndexWriter writer;
+
+  public LuceneWriter() throws Exception {
+    RAMDirectory ramDir = new RAMDirectory();
+    writer = new IndexWriter(ramDir, new StandardAnalyzer(), true,
+        MaxFieldLength.LIMITED);
+  }
+
+  public void add(Document document, Analyzer analyzer) throws IOException {
+    writer.addDocument(document, analyzer);
+  }
+}

Property changes on: test/org/apache/lucene/realtime/LuceneWriter.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + "Date Rev Author URL Id"
Name: svn:eol-style
   + native

Index: test/org/apache/lucene/realtime/LuceneRealtimeWriter.java
===================================================================
--- test/org/apache/lucene/realtime/LuceneRealtimeWriter.java	(revision 0)
+++ test/org/apache/lucene/realtime/LuceneRealtimeWriter.java	(revision 0)
@@ -0,0 +1,38 @@
+package org.apache.lucene.realtime;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.locks.ReentrantLock;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.SerialMergeScheduler;
+import org.apache.lucene.index.IndexWriter.MaxFieldLength;
+import org.apache.lucene.store.RAMDirectory;
+
+/**
+ * Writes the document to a RAMDirectory, then loads a reader from the RAMDir.
+ */
+public class LuceneRealtimeWriter implements Writer {
+  //List<IndexReader> readers = new ArrayList<IndexReader>();
+  ReentrantLock lock = new ReentrantLock();
+
+  public void add(Document document, Analyzer analyzer) throws Exception {
+    RAMDirectory ramDir = new RAMDirectory();
+    IndexWriter indexWriter = new IndexWriter(ramDir, analyzer, true,
+        MaxFieldLength.LIMITED);
+    indexWriter.setRAMBufferSizeMB(0.05); // 50K
+    indexWriter.setMergeScheduler(new SerialMergeScheduler());
+    indexWriter.addDocument(document, analyzer);
+    indexWriter.close();
+    IndexReader ir = IndexReader.open(ramDir);
+    //lock.lock();
+    //try {
+    //  readers.add(ir);
+    //} finally {
+    //  lock.unlock();
+   // }
+  }
+}

Property changes on: test/org/apache/lucene/realtime/LuceneRealtimeWriter.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + "Date Rev Author URL Id"
Name: svn:eol-style
   + native

Index: test/org/apache/lucene/realtime/Writer.java
===================================================================
--- test/org/apache/lucene/realtime/Writer.java	(revision 0)
+++ test/org/apache/lucene/realtime/Writer.java	(revision 0)
@@ -0,0 +1,8 @@
+package org.apache.lucene.realtime;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.document.Document;
+
+public interface Writer {
+  public void add(Document doc, Analyzer analyzer) throws Exception;
+}

Property changes on: test/org/apache/lucene/realtime/Writer.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + "Date Rev Author URL Id"
Name: svn:eol-style
   + native

Index: test/org/apache/lucene/realtime/BenchmarkRealtime.java
===================================================================
--- test/org/apache/lucene/realtime/BenchmarkRealtime.java	(revision 0)
+++ test/org/apache/lucene/realtime/BenchmarkRealtime.java	(revision 0)
@@ -0,0 +1,165 @@
+package org.apache.lucene.realtime;
+
+import java.text.NumberFormat;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.benchmark.byTask.feeds.EnwikiDocMaker;
+import org.apache.lucene.benchmark.byTask.utils.Config;
+import org.apache.lucene.document.Document;
+
+/**
+ * Compares realtime indexing techniques.
+ * 
+ * Uses the wikipedia XML file for generating the documents.
+ * 
+ */
+public class BenchmarkRealtime {
+  String enwikixmlPath = "/Users/jrutherg/dev/LUCENE-1539/contrib/benchmark/temp/enwiki-20070527-pages-articles.xml";
+
+  public static final int MAX_DOC = 50*1000;
+
+  static Map<String, String> typeMap = new HashMap<String, String>();
+  static {
+    typeMap.put("lw", "org.apache.lucene.realtime.LuceneWriter");
+    typeMap.put("lrw", "org.apache.lucene.realtime.LuceneRealtimeWriter");
+    typeMap.put("rw", "org.apache.lucene.realtime.RealtimeWriter");
+  }
+
+  List<CreateIndexResult> results = new ArrayList<CreateIndexResult>();
+
+  EnwikiDocMaker docMaker;
+
+  public static void main(String[] args) throws Exception {
+    new BenchmarkRealtime();
+  }
+
+  public BenchmarkRealtime() throws Exception {
+    docMaker = new EnwikiDocMaker();
+
+    Properties properties = new Properties();
+    properties.put("doc.tokenized", "true");
+    properties.put("doc.term.vector", "false");
+    properties.put("doc.stored", "true");
+    properties.put("docs.file", enwikixmlPath);
+    Config config = new Config(properties);
+    docMaker.setConfig(config);
+    docMaker.resetInputs();
+
+    int numRounds = 3;
+
+    rounds(numRounds, MAX_DOC, "lw");
+    rounds(numRounds, MAX_DOC, "lrw");
+    rounds(numRounds, MAX_DOC, "rw");
+
+    Collections.sort(results);
+    for (CreateIndexResult r : results) {
+      System.out.println(r.type + " " + r.duration);
+    }
+
+    CreateIndexResult lwF = findLowestOfType("lw", results);
+    CreateIndexResult lrwF = findLowestOfType("lrw", results);
+    CreateIndexResult rwF = findLowestOfType("rw", results);
+
+    List<CreateIndexResult> lowList = new ArrayList<CreateIndexResult>();
+    lowList.add(lwF);
+    lowList.add(lrwF);
+    lowList.add(rwF);
+    Collections.sort(lowList);
+    
+    System.out.println("-------------------------------");
+    System.out.println("numRounds:"+numRounds+" docs indexed:"+MAX_DOC);
+    System.out.println("lowest of each, percent compared with lowest");
+    CreateIndexResult low = lowList.get(0);
+    low.dif = 0.0;
+    for (int x=1; x < lowList.size(); x++) {
+      CreateIndexResult cir = lowList.get(x);
+      double d = calcPercentDif(low.duration, cir.duration);
+      cir.dif = d;
+    }
+    for (CreateIndexResult c : lowList) {
+      printCIR(c);
+    }
+    System.exit(0);
+  }
+
+  public static void printCIR(CreateIndexResult cir) {
+    NumberFormat pi = NumberFormat.getPercentInstance();
+    String percent = pi.format(cir.dif/100);
+    System.out.println(cir.type+":"+cir.duration+" dif:"+percent);
+  }
+  
+  public static double calcPercentDif(double a, double b) {
+    return ((b - a) / a) * 100;
+  }
+
+  // assumes list is sorted
+  private CreateIndexResult findLowestOfType(String type,
+      List<CreateIndexResult> results) {
+    for (CreateIndexResult cir : results) {
+      if (cir.type.equals(type)) {
+        return cir;
+      }
+    }
+    return null;
+  }
+
+  public void rounds(int rounds, int numDocs, String type) throws Exception {
+    String className = typeMap.get(type);
+    Class cl = Class.forName(className);
+    Writer writer = (Writer) cl.newInstance();
+    for (int x = 0; x < rounds; x++) {
+      results.add(createIndex(type, numDocs, writer));
+      System.out.println(type + " (" + (x + 1) + "/" + rounds + ") completed");
+    }
+  }
+
+  public static class CreateIndexResult implements
+      Comparable<CreateIndexResult> {
+    public long duration;
+
+    public int numDocs;
+
+    public String type;
+    public double dif;
+
+    public CreateIndexResult(long duration, int numDocs, String type) {
+      this.duration = duration;
+      this.numDocs = numDocs;
+      this.type = type;
+    }
+    
+    public int compareTo(CreateIndexResult r2) {
+      int c = (duration < r2.duration ? -1 : (duration == r2.duration ? 0 : 1));
+      if (c == 0) {
+        return type.compareTo(r2.type);
+      } else {
+        return c;
+      }
+    }
+  }
+
+  public CreateIndexResult createIndex(String type, int numDocs, Writer writer)
+      throws Exception {
+    long startTime = System.currentTimeMillis();
+
+    MultiThreadDocAdd docAdd = new MultiThreadDocAdd(writer,
+        new StandardAnalyzer(), numDocs, 4);
+    System.out.println("starting type:" + type);
+    StandardAnalyzer analyzer = new StandardAnalyzer();
+    for (int x = 0; x < numDocs; x++) {
+      Document doc = docMaker.makeDocument();
+      // writer.add(doc, analyzer);
+      docAdd.add(doc);
+    }
+    long duration = System.currentTimeMillis() - startTime;
+    CreateIndexResult r = new CreateIndexResult(duration, numDocs, type);
+    System.out.println(r.type + " " + r.duration);
+    return r;
+  }
+}

Property changes on: test/org/apache/lucene/realtime/BenchmarkRealtime.java
___________________________________________________________________
Name: svn:mime-type
   + text/plain
Name: svn:keywords
   + "Date Rev Author URL Id"
Name: svn:eol-style
   + native

