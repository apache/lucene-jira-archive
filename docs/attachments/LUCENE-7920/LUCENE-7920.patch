diff --git a/lucene/misc/src/java/org/apache/lucene/document/InetAddressPoint.java b/lucene/misc/src/java/org/apache/lucene/document/InetAddressPoint.java
index 5cda742..38e744c 100644
--- a/lucene/misc/src/java/org/apache/lucene/document/InetAddressPoint.java
+++ b/lucene/misc/src/java/org/apache/lucene/document/InetAddressPoint.java
@@ -212,15 +212,31 @@ public class InetAddressPoint extends Field {
    * @return a query matching documents with addresses contained within this network
    */
   public static Query newPrefixQuery(String field, InetAddress value, int prefixLength) {
-    if (value == null) {
+    return newPrefixQuery(field, value.getAddress(), prefixLength);
+  }
+
+  /** 
+   * Expert: create a prefix query for matching a CIDR network range. This may
+   * be useful compared to {@link #newPrefixQuery(String, InetAddress, int)} in
+   * case you do not want the prefix length to be interpreted as an ipv4 prefix
+   * length for ipv6-mapped ipv4 addresses.
+   *
+   * @param field field name. must not be {@code null}.
+   * @param addressBytes binary representation of the host address
+   * @param prefixLength the network prefix length for this address. This is also known as the subnet mask in the context of IPv4 addresses.
+   * @throws IllegalArgumentException if {@code field} is null, or prefixLength is invalid.
+   * @return a query matching documents with addresses contained within this network
+   */
+  public static Query newPrefixQuery(String field, byte[] addressBytes, int prefixLength) {
+    if (addressBytes == null) {
       throw new IllegalArgumentException("InetAddress must not be null");
     }
-    if (prefixLength < 0 || prefixLength > 8 * value.getAddress().length) {
+    if (prefixLength < 0 || prefixLength > 8 * addressBytes.length) {
       throw new IllegalArgumentException("illegal prefixLength '" + prefixLength + "'. Must be 0-32 for IPv4 ranges, 0-128 for IPv6 ranges");
     }
     // create the lower value by zeroing out the host portion, upper value by filling it with all ones.
-    byte lower[] = value.getAddress();
-    byte upper[] = value.getAddress();
+    byte lower[] = addressBytes.clone();
+    byte upper[] = addressBytes.clone();
     for (int i = prefixLength; i < 8 * lower.length; i++) {
       int m = 1 << (7 - (i & 7));
       lower[i >> 3] &= ~m;
diff --git a/lucene/misc/src/test/org/apache/lucene/document/TestInetAddressPoint.java b/lucene/misc/src/test/org/apache/lucene/document/TestInetAddressPoint.java
index 0e0901b..151286a 100644
--- a/lucene/misc/src/test/org/apache/lucene/document/TestInetAddressPoint.java
+++ b/lucene/misc/src/test/org/apache/lucene/document/TestInetAddressPoint.java
@@ -17,6 +17,7 @@
 package org.apache.lucene.document;
 
 import java.net.InetAddress;
+import java.util.Arrays;
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
@@ -132,6 +133,13 @@ public class TestInetAddressPoint extends LuceneTestCase {
         InetAddressPoint.newPrefixQuery("a", InetAddress.getByName("2001::a6bd:fc80"), 100));
   }
 
+  public void testPrefixQueryWithIpv6MappedIpv4() throws Exception {
+    byte[] ipv4Address = Arrays.copyOf(InetAddressPoint.IPV4_PREFIX, 16);
+    assertEquals(
+        InetAddressPoint.newPrefixQuery("a", ipv4Address, 96),
+        InetAddressPoint.newPrefixQuery("a", InetAddress.getByName("0.0.0.0"), 0));
+  }
+
   public void testNextUp() throws Exception {
     assertEquals(InetAddress.getByName("::1"),
         InetAddressPoint.nextUp(InetAddress.getByName("::")));
