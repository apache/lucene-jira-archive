diff --git lucene/core/src/java/org/apache/lucene/search/FieldValueHitQueue.java lucene/core/src/java/org/apache/lucene/search/FieldValueHitQueue.java
index 6dae17b..3da85e7 100644
--- lucene/core/src/java/org/apache/lucene/search/FieldValueHitQueue.java
+++ lucene/core/src/java/org/apache/lucene/search/FieldValueHitQueue.java
@@ -53,7 +53,7 @@ public abstract class FieldValueHitQueue<T extends FieldValueHitQueue.Entry> ext
    * there is just one comparator.
    */
   private static final class OneComparatorFieldValueHitQueue<T extends FieldValueHitQueue.Entry> extends FieldValueHitQueue<T> {
-    private final int oneReverseMul;
+    private final int oneOrderMul;
     
     public OneComparatorFieldValueHitQueue(SortField[] fields, int size)
         throws IOException {
@@ -61,9 +61,9 @@ public abstract class FieldValueHitQueue<T extends FieldValueHitQueue.Entry> ext
 
       SortField field = fields[0];
       setComparator(0,field.getComparator(size, 0));
-      oneReverseMul = field.reverse ? -1 : 1;
+      oneOrderMul = field.descending ? -1 : 1;
 
-      reverseMul[0] = oneReverseMul;
+      orderMuls[0] = oneOrderMul;
     }
 
     /**
@@ -78,7 +78,7 @@ public abstract class FieldValueHitQueue<T extends FieldValueHitQueue.Entry> ext
       assert hitA != hitB;
       assert hitA.slot != hitB.slot;
 
-      final int c = oneReverseMul * firstComparator.compare(hitA.slot, hitB.slot);
+      final int c = oneOrderMul * firstComparator.compare(hitA.slot, hitB.slot);
       if (c != 0) {
         return c > 0;
       }
@@ -103,7 +103,7 @@ public abstract class FieldValueHitQueue<T extends FieldValueHitQueue.Entry> ext
       for (int i = 0; i < numComparators; ++i) {
         SortField field = fields[i];
 
-        reverseMul[i] = field.reverse ? -1 : 1;
+        orderMuls[i] = field.descending ? -1 : 1;
         setComparator(i, field.getComparator(size, i));
       }
     }
@@ -116,7 +116,7 @@ public abstract class FieldValueHitQueue<T extends FieldValueHitQueue.Entry> ext
 
       int numComparators = comparators.length;
       for (int i = 0; i < numComparators; ++i) {
-        final int c = reverseMul[i] * comparators[i].compare(hitA.slot, hitB.slot);
+        final int c = orderMuls[i] * comparators[i].compare(hitA.slot, hitB.slot);
         if (c != 0) {
           // Short circuit
           return c > 0;
@@ -142,7 +142,7 @@ public abstract class FieldValueHitQueue<T extends FieldValueHitQueue.Entry> ext
     this.fields = fields;
     int numComparators = fields.length;
     comparators = new FieldComparator[numComparators];
-    reverseMul = new int[numComparators];
+    orderMuls = new int[numComparators];
   }
 
   /**
@@ -175,8 +175,8 @@ public abstract class FieldValueHitQueue<T extends FieldValueHitQueue.Entry> ext
     return comparators;
   }
 
-  public int[] getReverseMul() {
-    return reverseMul;
+  public int[] getOrderMultipliers() {
+    return orderMuls;
   }
 
   public void setComparator(int pos, FieldComparator<?> comparator) {
@@ -188,7 +188,7 @@ public abstract class FieldValueHitQueue<T extends FieldValueHitQueue.Entry> ext
   protected final SortField[] fields;
   protected final FieldComparator<?>[] comparators;  // use setComparator to change this array
   protected FieldComparator<?> firstComparator;      // this must always be equal to comparators[0]
-  protected final int[] reverseMul;
+  protected final int[] orderMuls;
 
   @Override
   protected abstract boolean lessThan (final Entry a, final Entry b);
diff --git lucene/core/src/java/org/apache/lucene/search/SortField.java lucene/core/src/java/org/apache/lucene/search/SortField.java
index daac17c..cd473de 100644
--- lucene/core/src/java/org/apache/lucene/search/SortField.java
+++ lucene/core/src/java/org/apache/lucene/search/SortField.java
@@ -93,7 +93,7 @@ public class SortField {
 
   private String field;
   private Type type;  // defaults to determining type dynamically
-  boolean reverse = false;  // defaults to natural order
+  boolean descending = false;  // defaults to ascending order
 
   // Used for CUSTOM sort
   private FieldComparatorSource comparatorSource;
@@ -116,11 +116,11 @@ public class SortField {
    * @param field  Name of field to sort by.  Can be <code>null</code> if
    *               <code>type</code> is SCORE or DOC.
    * @param type   Type of values in the terms.
-   * @param reverse True if natural order should be reversed.
+   * @param descending True if descending order should be used.
    */
-  public SortField(String field, Type type, boolean reverse) {
+  public SortField(String field, Type type, boolean descending) {
     initFieldType(field, type);
-    this.reverse = reverse;
+    this.descending = descending;
   }
 
   /** Pass this to {@link #setMissingValue} to have missing
@@ -164,11 +164,11 @@ public class SortField {
   /** Creates a sort, possibly in reverse, with a custom comparison function.
    * @param field Name of field to sort by; cannot be <code>null</code>.
    * @param comparator Returns a comparator for sorting hits.
-   * @param reverse True if natural order should be reversed.
+   * @param descending True if descending order should be used.
    */
-  public SortField(String field, FieldComparatorSource comparator, boolean reverse) {
+  public SortField(String field, FieldComparatorSource comparator, boolean descending) {
     initFieldType(field, Type.CUSTOM);
-    this.reverse = reverse;
+    this.descending = descending;
     this.comparatorSource = comparator;
   }
 
@@ -200,11 +200,11 @@ public class SortField {
     return type;
   }
 
-  /** Returns whether the sort should be reversed.
-   * @return  True if natural order should be reversed.
+  /** Returns whether the sort should be descending.
+   * @return  True if natural order should be descending, false for ascending.
    */
-  public boolean getReverse() {
-    return reverse;
+  public boolean getDescending() {
+    return descending;
   }
 
   /** Returns the {@link FieldComparatorSource} used for
@@ -263,7 +263,7 @@ public class SortField {
         break;
     }
 
-    if (reverse) buffer.append('!');
+    if (descending) buffer.append('!');
     if (missingValue != null) {
       buffer.append(" missingValue=");
       buffer.append(missingValue);
@@ -283,7 +283,7 @@ public class SortField {
     return (
       StringHelper.equals(other.field, this.field)
       && other.type == this.type
-      && other.reverse == this.reverse
+      && other.descending == this.descending
       && (other.comparatorSource == null ? this.comparatorSource == null : other.comparatorSource.equals(this.comparatorSource))
     );
   }
@@ -294,7 +294,7 @@ public class SortField {
    *  used). */
   @Override
   public int hashCode() {
-    int hash = type.hashCode() ^ 0x346565dd + Boolean.valueOf(reverse).hashCode() ^ 0xaf5998bb;
+    int hash = type.hashCode() ^ 0x346565dd + Boolean.valueOf(descending).hashCode() ^ 0xaf5998bb;
     if (field != null) hash += field.hashCode()^0xff5685dd;
     if (comparatorSource != null) hash += comparatorSource.hashCode();
     return hash;
@@ -345,7 +345,7 @@ public class SortField {
 
     case CUSTOM:
       assert comparatorSource != null;
-      return comparatorSource.newComparator(field, numHits, sortPos, reverse);
+      return comparatorSource.newComparator(field, numHits, sortPos, descending);
 
     case STRING:
       return new FieldComparator.TermOrdValComparator(numHits, field, missingValue == STRING_LAST);
diff --git lucene/core/src/java/org/apache/lucene/search/SortedNumericSortField.java lucene/core/src/java/org/apache/lucene/search/SortedNumericSortField.java
index eca8ab6..f9cffa2 100644
--- lucene/core/src/java/org/apache/lucene/search/SortedNumericSortField.java
+++ lucene/core/src/java/org/apache/lucene/search/SortedNumericSortField.java
@@ -113,7 +113,7 @@ public class SortedNumericSortField extends SortField {
   public String toString() {
     StringBuilder buffer = new StringBuilder();
     buffer.append("<sortednumeric" + ": \"").append(getField()).append("\">");
-    if (getReverse()) buffer.append('!');
+    if (getDescending()) buffer.append('!');
     if (missingValue != null) {
       buffer.append(" missingValue=");
       buffer.append(missingValue);
diff --git lucene/core/src/java/org/apache/lucene/search/SortedSetSortField.java lucene/core/src/java/org/apache/lucene/search/SortedSetSortField.java
index 402d99e..a7bb1cb 100644
--- lucene/core/src/java/org/apache/lucene/search/SortedSetSortField.java
+++ lucene/core/src/java/org/apache/lucene/search/SortedSetSortField.java
@@ -94,7 +94,7 @@ public class SortedSetSortField extends SortField {
   public String toString() {
     StringBuilder buffer = new StringBuilder();
     buffer.append("<sortedset" + ": \"").append(getField()).append("\">");
-    if (getReverse()) buffer.append('!');
+    if (getDescending()) buffer.append('!');
     if (missingValue != null) {
       buffer.append(" missingValue=");
       buffer.append(missingValue);
diff --git lucene/core/src/java/org/apache/lucene/search/TopDocs.java lucene/core/src/java/org/apache/lucene/search/TopDocs.java
index 062718d..8323143 100644
--- lucene/core/src/java/org/apache/lucene/search/TopDocs.java
+++ lucene/core/src/java/org/apache/lucene/search/TopDocs.java
@@ -122,7 +122,7 @@ public class TopDocs {
     // These are really FieldDoc instances:
     final ScoreDoc[][] shardHits;
     final FieldComparator<?>[] comparators;
-    final int[] reverseMul;
+    final int[] orderMuls;
 
     public MergeSortQueue(Sort sort, TopDocs[] shardHits) throws IOException {
       super(shardHits.length);
@@ -148,11 +148,11 @@ public class TopDocs {
 
       final SortField[] sortFields = sort.getSort();
       comparators = new FieldComparator[sortFields.length];
-      reverseMul = new int[sortFields.length];
+      orderMuls = new int[sortFields.length];
       for(int compIDX=0;compIDX<sortFields.length;compIDX++) {
         final SortField sortField = sortFields[compIDX];
         comparators[compIDX] = sortField.getComparator(1, compIDX);
-        reverseMul[compIDX] = sortField.getReverse() ? -1 : 1;
+        orderMuls[compIDX] = sortField.getDescending() ? -1 : 1;
       }
     }
 
@@ -169,7 +169,7 @@ public class TopDocs {
         final FieldComparator comp = comparators[compIDX];
         //System.out.println("    cmp idx=" + compIDX + " cmp1=" + firstFD.fields[compIDX] + " cmp2=" + secondFD.fields[compIDX] + " reverse=" + reverseMul[compIDX]);
 
-        final int cmp = reverseMul[compIDX] * comp.compareValues(firstFD.fields[compIDX], secondFD.fields[compIDX]);
+        final int cmp = orderMuls[compIDX] * comp.compareValues(firstFD.fields[compIDX], secondFD.fields[compIDX]);
         
         if (cmp != 0) {
           //System.out.println("    return " + (cmp < 0));
diff --git lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java
index 092ad3c..cfd83d4 100644
--- lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java
+++ lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java
@@ -47,7 +47,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       TopFieldCollector {
 
     FieldComparator<?> comparator;
-    final int reverseMul;
+    final int orderMul;
     final FieldValueHitQueue<Entry> queue;
     
     public OneComparatorNonScoringCollector(FieldValueHitQueue<Entry> queue,
@@ -55,7 +55,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       super(queue, numHits, fillFields);
       this.queue = queue;
       comparator = queue.getComparators()[0];
-      reverseMul = queue.getReverseMul()[0];
+      orderMul = queue.getOrderMultipliers()[0];
     }
     
     final void updateBottom(int doc) {
@@ -68,7 +68,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
     public void collect(int doc) throws IOException {
       ++totalHits;
       if (queueFull) {
-        if ((reverseMul * comparator.compareBottom(doc)) <= 0) {
+        if ((orderMul * comparator.compareBottom(doc)) <= 0) {
           // since docs are visited in doc Id order, if compare is 0, it means
           // this document is larger than anything else in the queue, and
           // therefore not competitive.
@@ -123,7 +123,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       ++totalHits;
       if (queueFull) {
         // Fastmatch: return if this hit is not competitive
-        final int cmp = reverseMul * comparator.compareBottom(doc);
+        final int cmp = orderMul * comparator.compareBottom(doc);
         if (cmp < 0 || (cmp == 0 && doc + docBase > bottom.doc)) {
           return;
         }
@@ -175,7 +175,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
     public void collect(int doc) throws IOException {
       ++totalHits;
       if (queueFull) {
-        if ((reverseMul * comparator.compareBottom(doc)) <= 0) {
+        if ((orderMul * comparator.compareBottom(doc)) <= 0) {
           // since docs are visited in doc Id order, if compare is 0, it means
           // this document is largest than anything else in the queue, and
           // therefore not competitive.
@@ -230,7 +230,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       ++totalHits;
       if (queueFull) {
         // Fastmatch: return if this hit is not competitive
-        final int cmp = reverseMul * comparator.compareBottom(doc);
+        final int cmp = orderMul * comparator.compareBottom(doc);
         if (cmp < 0 || (cmp == 0 && doc + docBase > bottom.doc)) {
           return;
         }
@@ -294,7 +294,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       }
       ++totalHits;
       if (queueFull) {
-        if ((reverseMul * comparator.compareBottom(doc)) <= 0) {
+        if ((orderMul * comparator.compareBottom(doc)) <= 0) {
           // since docs are visited in doc Id order, if compare is 0, it means
           // this document is largest than anything else in the queue, and
           // therefore not competitive.
@@ -347,7 +347,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       ++totalHits;
       if (queueFull) {
         // Fastmatch: return if this hit is not competitive
-        final int cmp = reverseMul * comparator.compareBottom(doc);
+        final int cmp = orderMul * comparator.compareBottom(doc);
         if (cmp < 0 || (cmp == 0 && doc + docBase > bottom.doc)) {
           return;
         }
@@ -382,14 +382,14 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
   private static class MultiComparatorNonScoringCollector extends TopFieldCollector {
     
     final FieldComparator<?>[] comparators;
-    final int[] reverseMul;
+    final int[] orders;
     final FieldValueHitQueue<Entry> queue;
     public MultiComparatorNonScoringCollector(FieldValueHitQueue<Entry> queue,
         int numHits, boolean fillFields) {
       super(queue, numHits, fillFields);
       this.queue = queue;
       comparators = queue.getComparators();
-      reverseMul = queue.getReverseMul();
+      orders = queue.getOrderMultipliers();
     }
     
     final void updateBottom(int doc) {
@@ -404,7 +404,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       if (queueFull) {
         // Fastmatch: return if this hit is not competitive
         for (int i = 0;; i++) {
-          final int c = reverseMul[i] * comparators[i].compareBottom(doc);
+          final int c = orders[i] * comparators[i].compareBottom(doc);
           if (c < 0) {
             // Definitely not competitive.
             return;
@@ -481,7 +481,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       if (queueFull) {
         // Fastmatch: return if this hit is not competitive
         for (int i = 0;; i++) {
-          final int c = reverseMul[i] * comparators[i].compareBottom(doc);
+          final int c = orders[i] * comparators[i].compareBottom(doc);
           if (c < 0) {
             // Definitely not competitive.
             return;
@@ -562,7 +562,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       if (queueFull) {
         // Fastmatch: return if this hit is not competitive
         for (int i = 0;; i++) {
-          final int c = reverseMul[i] * comparators[i].compareBottom(doc);
+          final int c = orders[i] * comparators[i].compareBottom(doc);
           if (c < 0) {
             // Definitely not competitive.
             return;
@@ -633,7 +633,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       if (queueFull) {
         // Fastmatch: return if this hit is not competitive
         for (int i = 0;; i++) {
-          final int c = reverseMul[i] * comparators[i].compareBottom(doc);
+          final int c = orders[i] * comparators[i].compareBottom(doc);
           if (c < 0) {
             // Definitely not competitive.
             return;
@@ -708,7 +708,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       if (queueFull) {
         // Fastmatch: return if this hit is not competitive
         for (int i = 0;; i++) {
-          final int c = reverseMul[i] * comparators[i].compareBottom(doc);
+          final int c = orders[i] * comparators[i].compareBottom(doc);
           if (c < 0) {
             // Definitely not competitive.
             return;
@@ -780,7 +780,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       if (queueFull) {
         // Fastmatch: return if this hit is not competitive
         for (int i = 0;; i++) {
-          final int c = reverseMul[i] * comparators[i].compareBottom(doc);
+          final int c = orders[i] * comparators[i].compareBottom(doc);
           if (c < 0) {
             // Definitely not competitive.
             return;
@@ -849,7 +849,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
     Scorer scorer;
     int collectedHits;
     final FieldComparator<?>[] comparators;
-    final int[] reverseMul;
+    final int[] orders;
     final FieldValueHitQueue<Entry> queue;
     final boolean trackDocScores;
     final boolean trackMaxScore;
@@ -865,7 +865,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       this.trackMaxScore = trackMaxScore;
       this.after = after;
       comparators = queue.getComparators();
-      reverseMul = queue.getReverseMul();
+      orders = queue.getOrderMultipliers();
 
       // Must set maxScore to NEG_INF, or otherwise Math.max always returns NaN.
       maxScore = Float.NEGATIVE_INFINITY;
@@ -903,7 +903,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
         // Fastmatch: return if this hit is no better than
         // the worst hit currently in the queue:
         for (int i = 0;; i++) {
-          final int c = reverseMul[i] * comparators[i].compareBottom(doc);
+          final int c = orders[i] * comparators[i].compareBottom(doc);
           if (c < 0) {
             // Definitely not competitive.
             return;
@@ -927,7 +927,7 @@ public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
       for(int compIDX=0;compIDX<comparators.length;compIDX++) {
         final FieldComparator comp = comparators[compIDX];
 
-        final int cmp = reverseMul[compIDX] * comp.compareTop(doc);
+        final int cmp = orders[compIDX] * comp.compareTop(doc);
         if (cmp > 0) {
           // Already collected on a previous page
           //System.out.println("    skip: before");
diff --git lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java
index fda7b64..3cd5161 100644
--- lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java
+++ lucene/core/src/test/org/apache/lucene/search/TestSearchAfter.java
@@ -115,19 +115,19 @@ public class TestSearchAfter extends LuceneTestCase {
     for(int i=0;i<limit;i++) {
       SortField sf = allSortFields.get(i);
       if (sf.getType() == SortField.Type.INT) {
-        SortField sf2 = new SortField(sf.getField(), SortField.Type.INT, sf.getReverse());
+        SortField sf2 = new SortField(sf.getField(), SortField.Type.INT, sf.getDescending());
         sf2.setMissingValue(random().nextInt());
         allSortFields.add(sf2);
       } else if (sf.getType() == SortField.Type.LONG) {
-        SortField sf2 = new SortField(sf.getField(), SortField.Type.LONG, sf.getReverse());
+        SortField sf2 = new SortField(sf.getField(), SortField.Type.LONG, sf.getDescending());
         sf2.setMissingValue(random().nextLong());
         allSortFields.add(sf2);
       } else if (sf.getType() == SortField.Type.FLOAT) {
-        SortField sf2 = new SortField(sf.getField(), SortField.Type.FLOAT, sf.getReverse());
+        SortField sf2 = new SortField(sf.getField(), SortField.Type.FLOAT, sf.getDescending());
         sf2.setMissingValue(random().nextFloat());
         allSortFields.add(sf2);
       } else if (sf.getType() == SortField.Type.DOUBLE) {
-        SortField sf2 = new SortField(sf.getField(), SortField.Type.DOUBLE, sf.getReverse());
+        SortField sf2 = new SortField(sf.getField(), SortField.Type.DOUBLE, sf.getDescending());
         sf2.setMissingValue(random().nextDouble());
         allSortFields.add(sf2);
       }
diff --git lucene/expressions/src/java/org/apache/lucene/expressions/Expression.java lucene/expressions/src/java/org/apache/lucene/expressions/Expression.java
index 0d8bd33..5616b91 100644
--- lucene/expressions/src/java/org/apache/lucene/expressions/Expression.java
+++ lucene/expressions/src/java/org/apache/lucene/expressions/Expression.java
@@ -81,8 +81,8 @@ public abstract class Expression {
   }
   
   /** Get a sort field which can be used to rank documents by this expression. */
-  public SortField getSortField(Bindings bindings, boolean reverse) {
-    return getValueSource(bindings).getSortField(reverse);
+  public SortField getSortField(Bindings bindings, boolean descending) {
+    return getValueSource(bindings).getSortField(descending);
   }
 
   /** Get a {@link Rescorer}, to rescore first-pass hits
diff --git lucene/expressions/src/java/org/apache/lucene/expressions/ExpressionSortField.java lucene/expressions/src/java/org/apache/lucene/expressions/ExpressionSortField.java
index 0a2df9f..9a127bf 100644
--- lucene/expressions/src/java/org/apache/lucene/expressions/ExpressionSortField.java
+++ lucene/expressions/src/java/org/apache/lucene/expressions/ExpressionSortField.java
@@ -63,7 +63,7 @@ class ExpressionSortField extends SortField {
     buffer.append(getField());
     buffer.append("\">");
     
-    if (getReverse()) {
+    if (getDescending()) {
       buffer.append('!');
     }
 
diff --git lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java
index f98f40d..7ac048d 100644
--- lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java
+++ lucene/expressions/src/test/org/apache/lucene/expressions/TestExpressionSorts.java
@@ -144,8 +144,8 @@ public class TestExpressionSorts extends LuceneTestCase {
         Expression expr = JavascriptCompiler.compile(s.getField());
         SimpleBindings simpleBindings = new SimpleBindings();
         simpleBindings.add(s);
-        boolean reverse = s.getType() == SortField.Type.SCORE || s.getReverse();
-        mutated[i] = expr.getSortField(simpleBindings, reverse);
+        boolean descending = s.getType() == SortField.Type.SCORE || s.getDescending();
+        mutated[i] = expr.getSortField(simpleBindings, descending);
       } else {
         mutated[i] = original[i];
       }
diff --git lucene/grouping/src/java/org/apache/lucene/search/grouping/AbstractAllGroupHeadsCollector.java lucene/grouping/src/java/org/apache/lucene/search/grouping/AbstractAllGroupHeadsCollector.java
index be6d8f8..d1745c9 100644
--- lucene/grouping/src/java/org/apache/lucene/search/grouping/AbstractAllGroupHeadsCollector.java
+++ lucene/grouping/src/java/org/apache/lucene/search/grouping/AbstractAllGroupHeadsCollector.java
@@ -32,12 +32,12 @@ import org.apache.lucene.util.FixedBitSet;
 @SuppressWarnings({"unchecked","rawtypes"})
 public abstract class AbstractAllGroupHeadsCollector<GH extends AbstractAllGroupHeadsCollector.GroupHead> extends SimpleCollector {
 
-  protected final int[] reversed;
+  protected final int[] orderMuls;
   protected final int compIDXEnd;
   protected final TemporalResult temporalResult;
 
   protected AbstractAllGroupHeadsCollector(int numberOfSorts) {
-    this.reversed = new int[numberOfSorts];
+    this.orderMuls = new int[numberOfSorts];
     this.compIDXEnd = numberOfSorts - 1;
     temporalResult = new TemporalResult();
   }
@@ -109,7 +109,7 @@ public abstract class AbstractAllGroupHeadsCollector<GH extends AbstractAllGroup
 
     // Ok now we need to check if the current doc is more relevant then current doc for this group
     for (int compIDX = 0; ; compIDX++) {
-      final int c = reversed[compIDX] * groupHead.compare(compIDX, doc);
+      final int c = orderMuls[compIDX] * groupHead.compare(compIDX, doc);
       if (c < 0) {
         // Definitely not competitive. So don't even bother to continue
         return;
diff --git lucene/grouping/src/java/org/apache/lucene/search/grouping/AbstractFirstPassGroupingCollector.java lucene/grouping/src/java/org/apache/lucene/search/grouping/AbstractFirstPassGroupingCollector.java
index ce64abd..fde7c20 100644
--- lucene/grouping/src/java/org/apache/lucene/search/grouping/AbstractFirstPassGroupingCollector.java
+++ lucene/grouping/src/java/org/apache/lucene/search/grouping/AbstractFirstPassGroupingCollector.java
@@ -37,7 +37,7 @@ abstract public class AbstractFirstPassGroupingCollector<GROUP_VALUE_TYPE> exten
 
   private final Sort groupSort;
   private final FieldComparator<?>[] comparators;
-  private final int[] reversed;
+  private final int[] orderMuls;
   private final int topNGroups;
   private final HashMap<GROUP_VALUE_TYPE, CollectedSearchGroup<GROUP_VALUE_TYPE>> groupMap;
   private final int compIDXEnd;
@@ -75,13 +75,13 @@ abstract public class AbstractFirstPassGroupingCollector<GROUP_VALUE_TYPE> exten
     final SortField[] sortFields = groupSort.getSort();
     comparators = new FieldComparator[sortFields.length];
     compIDXEnd = comparators.length - 1;
-    reversed = new int[sortFields.length];
+    orderMuls = new int[sortFields.length];
     for (int i = 0; i < sortFields.length; i++) {
       final SortField sortField = sortFields[i];
 
       // use topNGroups + 1 so we have a spare slot to use for comparing (tracked by this.spareSlot):
       comparators[i] = sortField.getComparator(topNGroups + 1, i);
-      reversed[i] = sortField.getReverse() ? -1 : 1;
+      orderMuls[i] = sortField.getDescending() ? -1 : 1;
     }
 
     spareSlot = topNGroups;
@@ -157,7 +157,7 @@ abstract public class AbstractFirstPassGroupingCollector<GROUP_VALUE_TYPE> exten
     // wasted effort as we will most likely be updating an existing group.
     if (orderedGroups != null) {
       for (int compIDX = 0;; compIDX++) {
-        final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);
+        final int c = orderMuls[compIDX] * comparators[compIDX].compareBottom(doc);
         if (c < 0) {
           // Definitely not competitive. So don't even bother to continue
           return;
@@ -244,7 +244,7 @@ abstract public class AbstractFirstPassGroupingCollector<GROUP_VALUE_TYPE> exten
       final FieldComparator<?> fc = comparators[compIDX];
       fc.copy(spareSlot, doc);
 
-      final int c = reversed[compIDX] * fc.compare(group.comparatorSlot, spareSlot);
+      final int c = orderMuls[compIDX] * fc.compare(group.comparatorSlot, spareSlot);
       if (c < 0) {
         // Definitely not competitive.
         return;
@@ -301,7 +301,7 @@ abstract public class AbstractFirstPassGroupingCollector<GROUP_VALUE_TYPE> exten
       public int compare(CollectedSearchGroup<?> o1, CollectedSearchGroup<?> o2) {
         for (int compIDX = 0;; compIDX++) {
           FieldComparator<?> fc = comparators[compIDX];
-          final int c = reversed[compIDX] * fc.compare(o1.comparatorSlot, o2.comparatorSlot);
+          final int c = orderMuls[compIDX] * fc.compare(o1.comparatorSlot, o2.comparatorSlot);
           if (c != 0) {
             return c;
           } else if (compIDX == compIDXEnd) {
diff --git lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector.java lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector.java
index 503ffbe..7880401 100644
--- lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector.java
+++ lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector.java
@@ -69,7 +69,7 @@ public class BlockGroupingCollector extends SimpleCollector {
   private final boolean needsScores;
 
   private final FieldComparator<?>[] comparators;
-  private final int[] reversed;
+  private final int[] orderMuls;
   private final int compIDXEnd;
   private int bottomSlot;
   private boolean queueFull;
@@ -161,7 +161,7 @@ public class BlockGroupingCollector extends SimpleCollector {
 
       final int numComparators = comparators.length;
       for (int compIDX=0;compIDX < numComparators; compIDX++) {
-        final int c = reversed[compIDX] * comparators[compIDX].compare(group1.comparatorSlot, group2.comparatorSlot);
+        final int c = orderMuls[compIDX] * comparators[compIDX].compare(group1.comparatorSlot, group2.comparatorSlot);
         if (c != 0) {
           // Short circuit
           return c > 0;
@@ -279,11 +279,11 @@ public class BlockGroupingCollector extends SimpleCollector {
     final SortField[] sortFields = groupSort.getSort();
     comparators = new FieldComparator<?>[sortFields.length];
     compIDXEnd = comparators.length - 1;
-    reversed = new int[sortFields.length];
+    orderMuls = new int[sortFields.length];
     for (int i = 0; i < sortFields.length; i++) {
       final SortField sortField = sortFields[i];
       comparators[i] = sortField.getComparator(topNGroups, i);
-      reversed[i] = sortField.getReverse() ? -1 : 1;
+      orderMuls[i] = sortField.getDescending() ? -1 : 1;
     }
   }
 
@@ -451,7 +451,7 @@ public class BlockGroupingCollector extends SimpleCollector {
       } else {
         // Compare to bottomSlot
         for (int compIDX = 0;; compIDX++) {
-          final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);
+          final int c = orderMuls[compIDX] * comparators[compIDX].compareBottom(doc);
           if (c < 0) {
             // Definitely not competitive -- done
             return;
@@ -481,7 +481,7 @@ public class BlockGroupingCollector extends SimpleCollector {
       // We're not sure this group will make it into the
       // queue yet
       for (int compIDX = 0;; compIDX++) {
-        final int c = reversed[compIDX] * comparators[compIDX].compareBottom(doc);
+        final int c = orderMuls[compIDX] * comparators[compIDX].compareBottom(doc);
         if (c < 0) {
           // Definitely not competitive -- done
           //System.out.println("    doc doesn't compete w/ top groups");
diff --git lucene/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.java lucene/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.java
index 032abbb..8d6dfb4 100644
--- lucene/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.java
+++ lucene/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.java
@@ -154,16 +154,16 @@ public class SearchGroup<GROUP_VALUE_TYPE> {
   private static class GroupComparator<T> implements Comparator<MergedGroup<T>> {
 
     public final FieldComparator[] comparators;
-    public final int[] reversed;
+    public final int[] orderMuls;
 
     public GroupComparator(Sort groupSort) throws IOException {
       final SortField[] sortFields = groupSort.getSort();
       comparators = new FieldComparator<?>[sortFields.length];
-      reversed = new int[sortFields.length];
+      orderMuls = new int[sortFields.length];
       for (int compIDX = 0; compIDX < sortFields.length; compIDX++) {
         final SortField sortField = sortFields[compIDX];
         comparators[compIDX] = sortField.getComparator(1, compIDX);
-        reversed[compIDX] = sortField.getReverse() ? -1 : 1;
+        orderMuls[compIDX] = sortField.getDescending() ? -1 : 1;
       }
     }
 
@@ -178,7 +178,7 @@ public class SearchGroup<GROUP_VALUE_TYPE> {
       final Object[] otherValues = other.topValues;
       //System.out.println("  groupValues=" + groupValues + " otherValues=" + otherValues);
       for (int compIDX = 0;compIDX < comparators.length; compIDX++) {
-        final int c = reversed[compIDX] * comparators[compIDX].compareValues(groupValues[compIDX],
+        final int c = orderMuls[compIDX] * comparators[compIDX].compareValues(groupValues[compIDX],
                                                                              otherValues[compIDX]);
         if (c != 0) {
           return c;
@@ -229,7 +229,7 @@ public class SearchGroup<GROUP_VALUE_TYPE> {
           //System.out.println("      old");
           boolean competes = false;
           for(int compIDX=0;compIDX<groupComp.comparators.length;compIDX++) {
-            final int cmp = groupComp.reversed[compIDX] * groupComp.comparators[compIDX].compareValues(group.sortValues[compIDX],
+            final int cmp = groupComp.orderMuls[compIDX] * groupComp.comparators[compIDX].compareValues(group.sortValues[compIDX],
                                                                                                        mergedGroup.topValues[compIDX]);
             if (cmp < 0) {
               // Definitely competes
diff --git lucene/grouping/src/java/org/apache/lucene/search/grouping/function/FunctionAllGroupHeadsCollector.java lucene/grouping/src/java/org/apache/lucene/search/grouping/function/FunctionAllGroupHeadsCollector.java
index 771660d..3dc441d 100644
--- lucene/grouping/src/java/org/apache/lucene/search/grouping/function/FunctionAllGroupHeadsCollector.java
+++ lucene/grouping/src/java/org/apache/lucene/search/grouping/function/FunctionAllGroupHeadsCollector.java
@@ -66,7 +66,7 @@ public class FunctionAllGroupHeadsCollector extends AbstractAllGroupHeadsCollect
 
     final SortField[] sortFields = sortWithinGroup.getSort();
     for (int i = 0; i < sortFields.length; i++) {
-      reversed[i] = sortFields[i].getReverse() ? -1 : 1;
+      orderMuls[i] = sortFields[i].getDescending() ? -1 : 1;
     }
   }
 
diff --git lucene/grouping/src/java/org/apache/lucene/search/grouping/term/TermAllGroupHeadsCollector.java lucene/grouping/src/java/org/apache/lucene/search/grouping/term/TermAllGroupHeadsCollector.java
index df0c0bb..29d5a93 100644
--- lucene/grouping/src/java/org/apache/lucene/search/grouping/term/TermAllGroupHeadsCollector.java
+++ lucene/grouping/src/java/org/apache/lucene/search/grouping/term/TermAllGroupHeadsCollector.java
@@ -127,7 +127,7 @@ public abstract class TermAllGroupHeadsCollector<GH extends AbstractAllGroupHead
 
       final SortField[] sortFields = sortWithinGroup.getSort();
       for (int i = 0; i < sortFields.length; i++) {
-        reversed[i] = sortFields[i].getReverse() ? -1 : 1;
+        orderMuls[i] = sortFields[i].getDescending() ? -1 : 1;
       }
     }
 
@@ -232,7 +232,7 @@ public abstract class TermAllGroupHeadsCollector<GH extends AbstractAllGroupHead
       fields = new SortField[sortFields.length];
       sortsIndex = new SortedDocValues[sortFields.length];
       for (int i = 0; i < sortFields.length; i++) {
-        reversed[i] = sortFields[i].getReverse() ? -1 : 1;
+        orderMuls[i] = sortFields[i].getDescending() ? -1 : 1;
         fields[i] = sortFields[i];
       }
     }
@@ -392,7 +392,7 @@ public abstract class TermAllGroupHeadsCollector<GH extends AbstractAllGroupHead
       fields = new SortField[sortFields.length];
       sortsIndex = new SortedDocValues[sortFields.length];
       for (int i = 0; i < sortFields.length; i++) {
-        reversed[i] = sortFields[i].getReverse() ? -1 : 1;
+        orderMuls[i] = sortFields[i].getDescending() ? -1 : 1;
         fields[i] = sortFields[i];
       }
     }
@@ -523,7 +523,7 @@ public abstract class TermAllGroupHeadsCollector<GH extends AbstractAllGroupHead
       final SortField[] sortFields = sortWithinGroup.getSort();
       fields = new SortField[sortFields.length];
       for (int i = 0; i < sortFields.length; i++) {
-        reversed[i] = sortFields[i].getReverse() ? -1 : 1;
+        orderMuls[i] = sortFields[i].getDescending() ? -1 : 1;
         fields[i] = sortFields[i];
       }
     }
diff --git lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java
index fbb5723..ad1adce 100644
--- lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java
+++ lucene/grouping/src/test/org/apache/lucene/search/grouping/AllGroupHeadsCollectorTest.java
@@ -495,7 +495,7 @@ public class AllGroupHeadsCollectorTest extends LuceneTestCase {
             cmp = d1.id - d2.id;
           }
           if (cmp != 0) {
-            return sf.getReverse() ? -cmp : cmp;
+            return sf.getDescending() ? -cmp : cmp;
           }
         }
         // Our sort always fully tie breaks:
diff --git lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
index f5942b0..936b5e2 100644
--- lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
+++ lucene/grouping/src/test/org/apache/lucene/search/grouping/TestGrouping.java
@@ -385,7 +385,7 @@ public class TestGrouping extends LuceneTestCase {
             cmp = d1.id - d2.id;
           }
           if (cmp != 0) {
-            return sf.getReverse() ? -cmp : cmp;
+            return sf.getDescending() ? -cmp : cmp;
           }
         }
         // Our sort always fully tie breaks:
diff --git lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector.java lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector.java
index 6fe1fc4..11f75fc 100644
--- lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector.java
+++ lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinCollector.java
@@ -84,7 +84,7 @@ public class ToParentBlockJoinCollector extends SimpleCollector {
   private final int numParentHits;
   private final FieldValueHitQueue<OneGroup> queue;
   private final FieldComparator[] comparators;
-  private final int[] reverseMul;
+  private final int[] orderMuls;
   private final int compEnd;
   private final boolean trackMaxScore;
   private final boolean trackScores;
@@ -116,7 +116,7 @@ public class ToParentBlockJoinCollector extends SimpleCollector {
     this.numParentHits = numParentHits;
     queue = FieldValueHitQueue.create(sort.getSort(), numParentHits);
     comparators = queue.getComparators();
-    reverseMul = queue.getReverseMul();
+    orderMuls = queue.getOrderMultipliers();
     compEnd = comparators.length - 1;
   }
   
@@ -162,7 +162,7 @@ public class ToParentBlockJoinCollector extends SimpleCollector {
       //System.out.println("  queueFull");
       // Fastmatch: return if this hit is not competitive
       for (int i = 0;; i++) {
-        final int c = reverseMul[i] * comparators[i].compareBottom(parentDoc);
+        final int c = orderMuls[i] * comparators[i].compareBottom(parentDoc);
         if (c < 0) {
           // Definitely not competitive.
           //System.out.println("    skip");
diff --git lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource.java lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource.java
index cb5847c..3324e80 100644
--- lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource.java
+++ lucene/misc/src/java/org/apache/lucene/index/sorter/BlockJoinComparatorSource.java
@@ -82,10 +82,10 @@ public class BlockJoinComparatorSource extends FieldComparatorSource {
     final int childSlots[] = new int[numHits];
     
     SortField parentFields[] = parentSort.getSort();
-    final int parentReverseMul[] = new int[parentFields.length];
+    final int parentOrder[] = new int[parentFields.length];
     final FieldComparator<?> parentComparators[] = new FieldComparator[parentFields.length];
     for (int i = 0; i < parentFields.length; i++) {
-      parentReverseMul[i] = parentFields[i].getReverse() ? -1 : 1;
+      parentOrder[i] = parentFields[i].getDescending() ? -1 : 1;
       parentComparators[i] = parentFields[i].getComparator(1, i);
     }
     
@@ -93,7 +93,7 @@ public class BlockJoinComparatorSource extends FieldComparatorSource {
     final int childReverseMul[] = new int[childFields.length];
     final FieldComparator<?> childComparators[] = new FieldComparator[childFields.length];
     for (int i = 0; i < childFields.length; i++) {
-      childReverseMul[i] = childFields[i].getReverse() ? -1 : 1;
+      childReverseMul[i] = childFields[i].getDescending() ? -1 : 1;
       childComparators[i] = childFields[i].getComparator(1, i);
     }
         
@@ -191,7 +191,7 @@ public class BlockJoinComparatorSource extends FieldComparatorSource {
             return compare(docID1, docID2, childComparators, childReverseMul);
           }
         } else {
-          int cmp = compare(parent1, parent2, parentComparators, parentReverseMul);
+          int cmp = compare(parent1, parent2, parentComparators, parentOrder);
           if (cmp == 0) {
             return parent1 - parent2;
           } else {
diff --git lucene/misc/src/java/org/apache/lucene/index/sorter/Sorter.java lucene/misc/src/java/org/apache/lucene/index/sorter/Sorter.java
index a3c75ae..8904760 100644
--- lucene/misc/src/java/org/apache/lucene/index/sorter/Sorter.java
+++ lucene/misc/src/java/org/apache/lucene/index/sorter/Sorter.java
@@ -213,11 +213,11 @@ final class Sorter {
    */
   DocMap sort(LeafReader reader) throws IOException {
     SortField fields[] = sort.getSort();
-    final int reverseMul[] = new int[fields.length];
+    final int orderMuls[] = new int[fields.length];
     final FieldComparator<?> comparators[] = new FieldComparator[fields.length];
     
     for (int i = 0; i < fields.length; i++) {
-      reverseMul[i] = fields[i].getReverse() ? -1 : 1;
+      orderMuls[i] = fields[i].getDescending() ? -1 : 1;
       comparators[i] = fields[i].getComparator(1, i);
       comparators[i].setNextReader(reader.getContext());
       comparators[i].setScorer(FAKESCORER);
@@ -231,7 +231,7 @@ final class Sorter {
             // the segments are always the same here...
             comparators[i].copy(0, docID1);
             comparators[i].setBottom(0);
-            int comp = reverseMul[i] * comparators[i].compareBottom(docID2);
+            int comp = orderMuls[i] * comparators[i].compareBottom(docID2);
             if (comp != 0) {
               return comp;
             }
diff --git lucene/queries/src/java/org/apache/lucene/queries/function/ValueSource.java lucene/queries/src/java/org/apache/lucene/queries/function/ValueSource.java
index 3cf9081..5f327b3 100644
--- lucene/queries/src/java/org/apache/lucene/queries/function/ValueSource.java
+++ lucene/queries/src/java/org/apache/lucene/queries/function/ValueSource.java
@@ -103,7 +103,7 @@ public abstract class ValueSource {
     public SortField rewrite(IndexSearcher searcher) throws IOException {
       Map context = newContext(searcher);
       createWeight(context, searcher);
-      return new SortField(getField(), new ValueSourceComparatorSource(context), getReverse());
+      return new SortField(getField(), new ValueSourceComparatorSource(context), getDescending());
     }
   }
 
diff --git solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.java solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.java
index 1c0ca43..527302e 100644
--- solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.java
+++ solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent.java
@@ -513,7 +513,7 @@ public class QueryElevationComponent extends SearchComponent implements SolrCore
     for (int i = 0; i < currentSorts.length; i++) {
       SortField sf = currentSorts[i];
       if (sf.getType() == SortField.Type.SCORE) {
-        sorts.add(new SortField("_elevate_", comparator, !sf.getReverse()));
+        sorts.add(new SortField("_elevate_", comparator, !sf.getDescending()));
         fields.add(null);
         modify = true;
       }
diff --git solr/core/src/java/org/apache/solr/handler/component/ShardDoc.java solr/core/src/java/org/apache/solr/handler/component/ShardDoc.java
index 97b831b..5a7bf57 100644
--- solr/core/src/java/org/apache/solr/handler/component/ShardDoc.java
+++ solr/core/src/java/org/apache/solr/handler/component/ShardDoc.java
@@ -128,10 +128,10 @@ class ShardFieldSortedHitQueue extends PriorityQueue<ShardDoc> {
 
      if (fields[i].getType() == SortField.Type.STRING) {
         this.fields[i] = new SortField(fieldname, SortField.Type.STRING,
-            fields[i].getReverse());
+            fields[i].getDescending());
       } else {
         this.fields[i] = new SortField(fieldname, fields[i].getType(),
-            fields[i].getReverse());
+            fields[i].getDescending());
       }
 
       //System.out.println("%%%%%%%%%%%%%%%%%% got "+fields[i].getType() +"   for "+ fieldname +"  fields[i].getReverse(): "+fields[i].getReverse());
@@ -156,7 +156,7 @@ class ShardFieldSortedHitQueue extends PriorityQueue<ShardDoc> {
     final int n = comparators.length;
     int c = 0;
     for (int i = 0; i < n && c == 0; i++) {
-      c = (fields[i].getReverse()) ? comparators[i].compare(docB, docA)
+      c = (fields[i].getDescending()) ? comparators[i].compare(docB, docA)
           : comparators[i].compare(docA, docB);
     }
 
diff --git solr/core/src/java/org/apache/solr/response/SortingResponseWriter.java solr/core/src/java/org/apache/solr/response/SortingResponseWriter.java
index ee3f143..46f9861 100644
--- solr/core/src/java/org/apache/solr/response/SortingResponseWriter.java
+++ solr/core/src/java/org/apache/solr/response/SortingResponseWriter.java
@@ -281,7 +281,7 @@ public class SortingResponseWriter implements QueryResponseWriter {
     for(int i=0; i<sortFields.length; ++i) {
       SortField sf = sortFields[i];
       String field = sf.getField();
-      boolean reverse = sf.getReverse();
+      boolean reverse = sf.getDescending();
       SchemaField schemaField = schema.getField(field);
       FieldType ft = schemaField.getType();
 
diff --git solr/core/src/test/org/apache/solr/search/QueryParsingTest.java solr/core/src/test/org/apache/solr/search/QueryParsingTest.java
index 482c02e..154b9c7 100644
--- solr/core/src/test/org/apache/solr/search/QueryParsingTest.java
+++ solr/core/src/test/org/apache/solr/search/QueryParsingTest.java
@@ -92,13 +92,13 @@ public class QueryParsingTest extends SolrTestCaseJ4 {
     sort = QueryParsing.parseSort("score aSc", req);
     SortField[] flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.Type.SCORE);
-    assertTrue(flds[0].getReverse());
+    assertTrue(flds[0].getDescending());
 
     spec = QueryParsing.parseSortSpec("score aSc", req);
     flds = spec.getSort().getSort();
     assertEquals(1, flds.length);
     assertEquals(flds[0].getType(), SortField.Type.SCORE);
-    assertTrue(flds[0].getReverse());
+    assertTrue(flds[0].getDescending());
     assertEquals(1, spec.getSchemaFields().size());
     assertNull(spec.getSchemaFields().get(0));
 
@@ -106,14 +106,14 @@ public class QueryParsingTest extends SolrTestCaseJ4 {
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.Type.FLOAT);
     assertEquals(flds[0].getField(), "weight");
-    assertEquals(flds[0].getReverse(), true);
+    assertEquals(flds[0].getDescending(), true);
 
     spec = QueryParsing.parseSortSpec("weight dEsC", req);
     flds = spec.getSort().getSort();
     assertEquals(1, flds.length);
     assertEquals(flds[0].getType(), SortField.Type.FLOAT);
     assertEquals(flds[0].getField(), "weight");
-    assertEquals(flds[0].getReverse(), true);
+    assertEquals(flds[0].getDescending(), true);
     assertEquals(1, spec.getSchemaFields().size());
     assertNotNull(spec.getSchemaFields().get(0));
     assertEquals("weight", spec.getSchemaFields().get(0).getName());
@@ -122,27 +122,27 @@ public class QueryParsingTest extends SolrTestCaseJ4 {
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.Type.FLOAT);
     assertEquals(flds[0].getField(), "weight");
-    assertEquals(flds[0].getReverse(), true);
+    assertEquals(flds[0].getDescending(), true);
     assertEquals(flds[1].getType(), SortField.Type.LONG);
     assertEquals(flds[1].getField(), "bday");
-    assertEquals(flds[1].getReverse(), false);
+    assertEquals(flds[1].getDescending(), false);
     //order aliases
     sort = QueryParsing.parseSort("weight top,bday asc", req);
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.Type.FLOAT);
     assertEquals(flds[0].getField(), "weight");
-    assertEquals(flds[0].getReverse(), true);
+    assertEquals(flds[0].getDescending(), true);
     assertEquals(flds[1].getType(), SortField.Type.LONG);
     assertEquals(flds[1].getField(), "bday");
-    assertEquals(flds[1].getReverse(), false);
+    assertEquals(flds[1].getDescending(), false);
     sort = QueryParsing.parseSort("weight top,bday bottom", req);
     flds = sort.getSort();
     assertEquals(flds[0].getType(), SortField.Type.FLOAT);
     assertEquals(flds[0].getField(), "weight");
-    assertEquals(flds[0].getReverse(), true);
+    assertEquals(flds[0].getDescending(), true);
     assertEquals(flds[1].getType(), SortField.Type.LONG);
     assertEquals(flds[1].getField(), "bday");
-    assertEquals(flds[1].getReverse(), false);
+    assertEquals(flds[1].getDescending(), false);
 
     //test weird spacing
     sort = QueryParsing.parseSort("weight         DESC,            bday         asc", req);
diff --git solr/core/src/test/org/apache/solr/search/TestSort.java solr/core/src/test/org/apache/solr/search/TestSort.java
index d6dac48..a48e814 100644
--- solr/core/src/test/org/apache/solr/search/TestSort.java
+++ solr/core/src/test/org/apache/solr/search/TestSort.java
@@ -149,7 +149,7 @@ public class TestSort extends SolrTestCaseJ4 {
                    names.length, fields.size());
       for (int j = 0; j < names.length; j++) {
         assertEquals("sorts["+j+"] had unexpected reverse: " + input,
-                     reverse[j], sorts[j].getReverse());
+                     reverse[j], sorts[j].getDescending());
 
         final Type type = sorts[j].getType();
 
