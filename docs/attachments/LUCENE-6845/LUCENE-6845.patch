diff --git a/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java b/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java
index bb5d498..697860a 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java
@@ -19,8 +19,6 @@ package org.apache.lucene.search;
 
 import java.io.IOException;
 
-import org.apache.lucene.search.spans.Spans;
-
 /**
  * This abstract class defines methods to iterate over a set of non-decreasing
  * doc ids. Note that this class assumes it iterates on doc Ids, and therefore
diff --git a/lucene/core/src/java/org/apache/lucene/search/TwoPhaseIterator.java b/lucene/core/src/java/org/apache/lucene/search/TwoPhaseIterator.java
index 3df07a8..3d774c5 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TwoPhaseIterator.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TwoPhaseIterator.java
@@ -20,11 +20,8 @@ package org.apache.lucene.search;
 import java.io.IOException;
 import java.util.Objects;
 
-import org.apache.lucene.search.spans.Spans;
-
 /**
  * Returned by {@link Scorer#asTwoPhaseIterator()}
- * and  {@link Spans#asTwoPhaseIterator()}
  * to expose an approximation of a {@link DocIdSetIterator}.
  * When the {@link #approximation()}'s
  * {@link DocIdSetIterator#nextDoc()} or {@link DocIdSetIterator#advance(int)}
@@ -100,8 +97,6 @@ public abstract class TwoPhaseIterator {
   public static TwoPhaseIterator asTwoPhaseIterator(DocIdSetIterator iter) {
     return (iter instanceof Scorer)
             ? ((Scorer) iter).asTwoPhaseIterator()
-            : (iter instanceof Spans)
-            ? ((Spans) iter).asTwoPhaseIterator()
             : null;
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpanScorer.java b/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpanScorer.java
new file mode 100644
index 0000000..e0fe9c3
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpanScorer.java
@@ -0,0 +1,104 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.ConjunctionDISI;
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.similarities.Similarity;
+
+/**
+ * Common super class for multiple sub spans required in a document.
+ */
+abstract class ConjunctionSpanScorer extends SpanScorer {
+  final SpanScorer[] subSpans; // in query order
+  final DocIdSetIterator conjunction; // use to move to next doc with all clauses
+  boolean atFirstInCurrentDoc; // a first start position is available in current doc for nextStartPosition
+  boolean oneExhaustedInCurrentDoc; // one subspans exhausted in current doc
+
+  ConjunctionSpanScorer(List<SpanScorer> subSpans, SpanWeight weight, Similarity.SimScorer docScorer) {
+    super(weight, docScorer);
+    if (subSpans.size() < 2) {
+      throw new IllegalArgumentException("Less than 2 subSpans.size():" + subSpans.size());
+    }
+    this.subSpans = subSpans.toArray(new SpanScorer[subSpans.size()]);
+    this.conjunction = ConjunctionDISI.intersect(subSpans);
+    this.atFirstInCurrentDoc = true; // ensure for doc -1 that start/end positions are -1
+  }
+
+  @Override
+  public int docID() {
+    return conjunction.docID();
+  }
+
+  @Override
+  public long cost() {
+    return conjunction.cost();
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    return (conjunction.nextDoc() == NO_MORE_DOCS)
+            ? NO_MORE_DOCS
+            : toMatchDoc();
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    return (conjunction.advance(target) == NO_MORE_DOCS)
+            ? NO_MORE_DOCS
+            : toMatchDoc();
+  }
+
+  int toMatchDoc() throws IOException {
+    oneExhaustedInCurrentDoc = false;
+    while (true) {
+      if (twoPhaseCurrentDocMatches()) {
+        return docID();
+      }
+      if (conjunction.nextDoc() == NO_MORE_DOCS) {
+        return NO_MORE_DOCS;
+      }
+    }
+  }
+
+
+  abstract boolean twoPhaseCurrentDocMatches() throws IOException;
+
+  /**
+   * Return a {@link TwoPhaseIterator} view of this ConjunctionSpanScorer.
+   */
+  @Override
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    TwoPhaseIterator res = new TwoPhaseIterator(conjunction) {
+
+      @Override
+      public boolean matches() throws IOException {
+        return twoPhaseCurrentDocMatches();
+      }
+    };
+    return res;
+  }
+
+  public SpanScorer[] getSubSpans() {
+    return subSpans;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java
deleted file mode 100644
index 8f600a4..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java
+++ /dev/null
@@ -1,102 +0,0 @@
-package org.apache.lucene.search.spans;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.List;
-
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.search.ConjunctionDISI;
-import org.apache.lucene.search.TwoPhaseIterator;
-
-/**
- * Common super class for multiple sub spans required in a document.
- */
-abstract class ConjunctionSpans extends Spans {
-  final Spans[] subSpans; // in query order
-  final DocIdSetIterator conjunction; // use to move to next doc with all clauses
-  boolean atFirstInCurrentDoc; // a first start position is available in current doc for nextStartPosition
-  boolean oneExhaustedInCurrentDoc; // one subspans exhausted in current doc
-
-  ConjunctionSpans(List<Spans> subSpans) {
-    if (subSpans.size() < 2) {
-      throw new IllegalArgumentException("Less than 2 subSpans.size():" + subSpans.size());
-    }
-    this.subSpans = subSpans.toArray(new Spans[subSpans.size()]);
-    this.conjunction = ConjunctionDISI.intersect(subSpans);
-    this.atFirstInCurrentDoc = true; // ensure for doc -1 that start/end positions are -1
-  }
-
-  @Override
-  public int docID() {
-    return conjunction.docID();
-  }
-
-  @Override
-  public long cost() {
-    return conjunction.cost();
-  }
-
-  @Override
-  public int nextDoc() throws IOException {
-    return (conjunction.nextDoc() == NO_MORE_DOCS)
-            ? NO_MORE_DOCS
-            : toMatchDoc();
-  }
-
-  @Override
-  public int advance(int target) throws IOException {
-    return (conjunction.advance(target) == NO_MORE_DOCS)
-            ? NO_MORE_DOCS
-            : toMatchDoc();
-  }
-
-  int toMatchDoc() throws IOException {
-    oneExhaustedInCurrentDoc = false;
-    while (true) {
-      if (twoPhaseCurrentDocMatches()) {
-        return docID();
-      }
-      if (conjunction.nextDoc() == NO_MORE_DOCS) {
-        return NO_MORE_DOCS;
-      }
-    }
-  }
-
-
-  abstract boolean twoPhaseCurrentDocMatches() throws IOException;
-
-  /**
-   * Return a {@link TwoPhaseIterator} view of this ConjunctionSpans.
-   */
-  @Override
-  public TwoPhaseIterator asTwoPhaseIterator() {
-    TwoPhaseIterator res = new TwoPhaseIterator(conjunction) {
-
-      @Override
-      public boolean matches() throws IOException {
-        return twoPhaseCurrentDocMatches();
-      }
-    };
-    return res;
-  }
-
-  public Spans[] getSubSpans() {
-    return subSpans;
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpanScorer.java b/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpanScorer.java
new file mode 100644
index 0000000..90ee824
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpanScorer.java
@@ -0,0 +1,63 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Objects;
+
+import org.apache.lucene.search.similarities.Similarity;
+
+abstract class ContainSpanScorer extends ConjunctionSpanScorer {
+  SpanScorer sourceSpans;
+  SpanScorer bigSpans;
+  SpanScorer littleSpans;
+
+  ContainSpanScorer(SpanWeight weight, Similarity.SimScorer simScorer, SpanScorer bigSpans, SpanScorer littleSpans, SpanScorer sourceSpans) {
+    super(Arrays.asList(bigSpans, littleSpans), weight, simScorer);
+    this.bigSpans = Objects.requireNonNull(bigSpans);
+    this.littleSpans = Objects.requireNonNull(littleSpans);
+    this.sourceSpans = Objects.requireNonNull(sourceSpans);
+  }
+
+  @Override
+  public int startPosition() { 
+    return atFirstInCurrentDoc ? -1
+            : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
+            : sourceSpans.startPosition(); 
+  }
+
+  @Override
+  public int endPosition() { 
+    return atFirstInCurrentDoc ? -1
+            : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
+            : sourceSpans.endPosition(); 
+  }
+
+  @Override
+  public int width() {
+    return sourceSpans.width();
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    bigSpans.collect(collector);
+    littleSpans.collect(collector);
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
deleted file mode 100644
index 5d90d76..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package org.apache.lucene.search.spans;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Objects;
-
-abstract class ContainSpans extends ConjunctionSpans {
-  Spans sourceSpans;
-  Spans bigSpans;
-  Spans littleSpans;
-
-  ContainSpans(Spans bigSpans, Spans littleSpans, Spans sourceSpans) {
-    super(Arrays.asList(bigSpans, littleSpans));
-    this.bigSpans = Objects.requireNonNull(bigSpans);
-    this.littleSpans = Objects.requireNonNull(littleSpans);
-    this.sourceSpans = Objects.requireNonNull(sourceSpans);
-  }
-
-  @Override
-  public int startPosition() { 
-    return atFirstInCurrentDoc ? -1
-            : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
-            : sourceSpans.startPosition(); 
-  }
-
-  @Override
-  public int endPosition() { 
-    return atFirstInCurrentDoc ? -1
-            : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
-            : sourceSpans.endPosition(); 
-  }
-
-  @Override
-  public int width() {
-    return sourceSpans.width();
-  }
-
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    bigSpans.collect(collector);
-    littleSpans.collect(collector);
-  }
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpanScorer.java b/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpanScorer.java
new file mode 100644
index 0000000..174ae7d
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpanScorer.java
@@ -0,0 +1,205 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Objects;
+
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.similarities.Similarity;
+
+/**
+ * A {@link SpanScorer} implementation wrapping another spans instance,
+ * allowing to filter spans matches easily by implementing {@link #accept}
+ */
+public abstract class FilterSpanScorer extends SpanScorer {
+ 
+  /** The wrapped spans instance. */
+  protected final SpanScorer in;
+  
+  private boolean atFirstInCurrentDoc = false;
+  private int startPos = -1;
+  
+  /** Wrap the given {@link SpanScorer}. */
+  protected FilterSpanScorer(SpanScorer in, Similarity.SimScorer docScorer) {
+    super((SpanWeight)in.getWeight(), docScorer);
+    this.in = Objects.requireNonNull(in);
+  }
+  
+  /** 
+   * Returns YES if the candidate should be an accepted match,
+   * NO if it should not, and NO_MORE_IN_CURRENT_DOC if iteration
+   * should move on to the next document.
+   */
+  protected abstract AcceptStatus accept(SpanScorer candidate) throws IOException;
+  
+  @Override
+  public final int nextDoc() throws IOException {
+    while (true) {
+      int doc = in.nextDoc();
+      if (doc == NO_MORE_DOCS) {
+        return NO_MORE_DOCS;
+      } else if (twoPhaseCurrentDocMatches()) {
+        return doc;
+      }
+    }
+  }
+
+  @Override
+  public final int advance(int target) throws IOException {
+    int doc = in.advance(target);
+    while (doc != NO_MORE_DOCS) {
+      if (twoPhaseCurrentDocMatches()) {
+        break;
+      }
+      doc = in.nextDoc();
+    }
+
+    return doc;
+  }
+
+  @Override
+  public final int docID() {
+    return in.docID();
+  }
+
+  @Override
+  public final int nextStartPosition() throws IOException {
+    if (atFirstInCurrentDoc) {
+      atFirstInCurrentDoc = false;
+      return startPos;
+    }
+
+    for (;;) {
+      startPos = in.nextStartPosition();
+      if (startPos == NO_MORE_POSITIONS) {
+        return NO_MORE_POSITIONS;
+      }
+      switch(accept(in)) {
+        case YES:
+          return startPos;
+        case NO:
+          break;
+        case NO_MORE_IN_CURRENT_DOC:
+          return startPos = NO_MORE_POSITIONS; // startPos ahead for the current doc.
+      }
+    }
+  }
+
+  @Override
+  public final int startPosition() {
+    return atFirstInCurrentDoc ? -1 : startPos;
+  }
+
+  @Override
+  public final int endPosition() {
+    return atFirstInCurrentDoc ? -1
+          : (startPos != NO_MORE_POSITIONS) ? in.endPosition() : NO_MORE_POSITIONS;
+  }
+
+  @Override
+  public int width() {
+    return in.width();
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    in.collect(collector);
+  }
+
+  @Override
+  public final long cost() {
+    return in.cost();
+  }
+  
+  @Override
+  public String toString() {
+    return "Filter(" + in.toString() + ")";
+  }
+  
+  @Override
+  public final TwoPhaseIterator asTwoPhaseIterator() {
+    TwoPhaseIterator inner = in.asTwoPhaseIterator();
+    if (inner != null) {
+      // wrapped instance has an approximation
+      return new TwoPhaseIterator(inner.approximation()) {
+        @Override
+        public boolean matches() throws IOException {
+          return inner.matches() && twoPhaseCurrentDocMatches();
+        }
+      };
+    } else {
+      // wrapped instance has no approximation, but 
+      // we can still defer matching until absolutely needed.
+      return new TwoPhaseIterator(in) {
+        @Override
+        public boolean matches() throws IOException {
+          return twoPhaseCurrentDocMatches();
+        }
+      };
+    }
+  }
+  
+  /**
+   * Returns true if the current document matches.
+   * <p>
+   * This is called during two-phase processing.
+   */
+  // return true if the current document matches
+  @SuppressWarnings("fallthrough")
+  private final boolean twoPhaseCurrentDocMatches() throws IOException {
+    atFirstInCurrentDoc = false;
+    startPos = in.nextStartPosition();
+    assert startPos != NO_MORE_POSITIONS;
+    for (;;) {
+      switch(accept(in)) {
+        case YES:
+          atFirstInCurrentDoc = true;
+          return true;
+        case NO:
+          startPos = in.nextStartPosition();
+          if (startPos != NO_MORE_POSITIONS) {
+            break;
+          }
+          // else fallthrough
+        case NO_MORE_IN_CURRENT_DOC:
+          startPos = -1;
+          return false;
+      }
+    }
+  }
+
+  /**
+   * Status returned from {@link FilterSpanScorer#accept(SpanScorer)} that indicates
+   * whether a candidate match should be accepted, rejected, or rejected
+   * and move on to the next document.
+   */
+  public static enum AcceptStatus {
+    /** Indicates the match should be accepted */
+    YES,
+
+    /** Indicates the match should be rejected */
+    NO,
+
+    /**
+     * Indicates the match should be rejected, and the enumeration may continue
+     * with the next document.
+     */
+    NO_MORE_IN_CURRENT_DOC
+  };
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java
deleted file mode 100644
index dbb1300..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java
+++ /dev/null
@@ -1,203 +0,0 @@
-package org.apache.lucene.search.spans;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.Objects;
-
-import org.apache.lucene.search.TwoPhaseIterator;
-
-/**
- * A {@link Spans} implementation wrapping another spans instance,
- * allowing to filter spans matches easily by implementing {@link #accept}
- */
-public abstract class FilterSpans extends Spans {
- 
-  /** The wrapped spans instance. */
-  protected final Spans in;
-  
-  private boolean atFirstInCurrentDoc = false;
-  private int startPos = -1;
-  
-  /** Wrap the given {@link Spans}. */
-  protected FilterSpans(Spans in) {
-    this.in = Objects.requireNonNull(in);
-  }
-  
-  /** 
-   * Returns YES if the candidate should be an accepted match,
-   * NO if it should not, and NO_MORE_IN_CURRENT_DOC if iteration
-   * should move on to the next document.
-   */
-  protected abstract AcceptStatus accept(Spans candidate) throws IOException;
-  
-  @Override
-  public final int nextDoc() throws IOException {
-    while (true) {
-      int doc = in.nextDoc();
-      if (doc == NO_MORE_DOCS) {
-        return NO_MORE_DOCS;
-      } else if (twoPhaseCurrentDocMatches()) {
-        return doc;
-      }
-    }
-  }
-
-  @Override
-  public final int advance(int target) throws IOException {
-    int doc = in.advance(target);
-    while (doc != NO_MORE_DOCS) {
-      if (twoPhaseCurrentDocMatches()) {
-        break;
-      }
-      doc = in.nextDoc();
-    }
-
-    return doc;
-  }
-
-  @Override
-  public final int docID() {
-    return in.docID();
-  }
-
-  @Override
-  public final int nextStartPosition() throws IOException {
-    if (atFirstInCurrentDoc) {
-      atFirstInCurrentDoc = false;
-      return startPos;
-    }
-
-    for (;;) {
-      startPos = in.nextStartPosition();
-      if (startPos == NO_MORE_POSITIONS) {
-        return NO_MORE_POSITIONS;
-      }
-      switch(accept(in)) {
-        case YES:
-          return startPos;
-        case NO:
-          break;
-        case NO_MORE_IN_CURRENT_DOC:
-          return startPos = NO_MORE_POSITIONS; // startPos ahead for the current doc.
-      }
-    }
-  }
-
-  @Override
-  public final int startPosition() {
-    return atFirstInCurrentDoc ? -1 : startPos;
-  }
-
-  @Override
-  public final int endPosition() {
-    return atFirstInCurrentDoc ? -1
-          : (startPos != NO_MORE_POSITIONS) ? in.endPosition() : NO_MORE_POSITIONS;
-  }
-
-  @Override
-  public int width() {
-    return in.width();
-  }
-
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    in.collect(collector);
-  }
-
-  @Override
-  public final long cost() {
-    return in.cost();
-  }
-  
-  @Override
-  public String toString() {
-    return "Filter(" + in.toString() + ")";
-  }
-  
-  @Override
-  public final TwoPhaseIterator asTwoPhaseIterator() {
-    TwoPhaseIterator inner = in.asTwoPhaseIterator();
-    if (inner != null) {
-      // wrapped instance has an approximation
-      return new TwoPhaseIterator(inner.approximation()) {
-        @Override
-        public boolean matches() throws IOException {
-          return inner.matches() && twoPhaseCurrentDocMatches();
-        }
-      };
-    } else {
-      // wrapped instance has no approximation, but 
-      // we can still defer matching until absolutely needed.
-      return new TwoPhaseIterator(in) {
-        @Override
-        public boolean matches() throws IOException {
-          return twoPhaseCurrentDocMatches();
-        }
-      };
-    }
-  }
-  
-  /**
-   * Returns true if the current document matches.
-   * <p>
-   * This is called during two-phase processing.
-   */
-  // return true if the current document matches
-  @SuppressWarnings("fallthrough")
-  private final boolean twoPhaseCurrentDocMatches() throws IOException {
-    atFirstInCurrentDoc = false;
-    startPos = in.nextStartPosition();
-    assert startPos != NO_MORE_POSITIONS;
-    for (;;) {
-      switch(accept(in)) {
-        case YES:
-          atFirstInCurrentDoc = true;
-          return true;
-        case NO:
-          startPos = in.nextStartPosition();
-          if (startPos != NO_MORE_POSITIONS) {
-            break;
-          }
-          // else fallthrough
-        case NO_MORE_IN_CURRENT_DOC:
-          startPos = -1;
-          return false;
-      }
-    }
-  }
-  
-  /**
-   * Status returned from {@link FilterSpans#accept(Spans)} that indicates
-   * whether a candidate match should be accepted, rejected, or rejected
-   * and move on to the next document.
-   */
-  public static enum AcceptStatus {
-    /** Indicates the match should be accepted */
-    YES,
-
-    /** Indicates the match should be rejected */
-    NO,
-
-    /**
-     * Indicates the match should be rejected, and the enumeration may continue
-     * with the next document.
-     */
-    NO_MORE_IN_CURRENT_DOC
-  };
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpanScorerOrdered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpanScorerOrdered.java
new file mode 100644
index 0000000..75d1ba3
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpanScorerOrdered.java
@@ -0,0 +1,163 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.lucene.search.similarities.Similarity;
+
+/**
+ * A SpanScorer that is formed from the ordered subspans of a SpanNearQuery
+ * where the subspans do not overlap and have a maximum slop between them.
+ * <p>
+ * The formed spans only contains minimum slop matches.<br>
+ * The matching slop is computed from the distance(s) between
+ * the non overlapping matching SpanScorer.<br>
+ * Successive matches are always formed from the successive SpanScorer
+ * of the SpanNearQuery.
+ * <p>
+ * The formed spans may contain overlaps when the slop is at least 1.
+ * For example, when querying using
+ * <pre>t1 t2 t3</pre>
+ * with slop at least 1, the fragment:
+ * <pre>t1 t2 t1 t3 t2 t3</pre>
+ * matches twice:
+ * <pre>t1 t2 .. t3      </pre>
+ * <pre>      t1 .. t2 t3</pre>
+ *
+ * Expert:
+ * Only public for subclassing.  Most implementations should not need this class
+ */
+public class NearSpanScorerOrdered extends ConjunctionSpanScorer {
+
+  protected int matchStart = -1;
+  protected int matchEnd = -1;
+  protected int matchWidth = -1;
+
+  private final int allowedSlop;
+  private final SpanNearQuery query;
+
+  public NearSpanScorerOrdered(SpanWeight weight, Similarity.SimScorer simScorer, List<SpanScorer> subSpans) throws IOException {
+    super(subSpans, weight, simScorer);
+    this.atFirstInCurrentDoc = true; // -1 startPosition/endPosition also at doc -1
+    this.query = (SpanNearQuery) weight.getQuery();
+    this.allowedSlop = query.slop;
+  }
+
+  @Override
+  boolean twoPhaseCurrentDocMatches() throws IOException {
+    assert unpositioned();
+    oneExhaustedInCurrentDoc = false;
+    while (subSpans[0].nextStartPosition() != NO_MORE_POSITIONS && !oneExhaustedInCurrentDoc) {
+      if (stretchToOrder() && matchWidth <= allowedSlop) {
+        return atFirstInCurrentDoc = true;
+      }
+    }
+    return false;
+  }
+
+  private boolean unpositioned() {
+    for (SpanScorer span : subSpans) {
+      if (span.startPosition() != -1)
+        return false;
+    }
+    return true;
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    if (atFirstInCurrentDoc) {
+      atFirstInCurrentDoc = false;
+      return matchStart;
+    }
+    oneExhaustedInCurrentDoc = false;
+    while (subSpans[0].nextStartPosition() != NO_MORE_POSITIONS && !oneExhaustedInCurrentDoc) {
+      if (stretchToOrder() && matchWidth <= allowedSlop) {
+        return matchStart;
+      }
+    }
+    return matchStart = matchEnd = NO_MORE_POSITIONS;
+  }
+
+  /**
+   * Order the subSpans within the same document by using nextStartPosition on all subSpans
+   * after the first as little as necessary.
+   * Return true when the subSpans could be ordered in this way,
+   * otherwise at least one is exhausted in the current doc.
+   */
+  private boolean stretchToOrder() throws IOException {
+    SpanScorer prevSpans = subSpans[0];
+    matchStart = prevSpans.startPosition();
+    assert prevSpans.startPosition() != NO_MORE_POSITIONS : "prevSpans no start position "+prevSpans;
+    assert prevSpans.endPosition() != NO_MORE_POSITIONS;
+    matchWidth = 0;
+    for (int i = 1; i < subSpans.length; i++) {
+      SpanScorer spans = subSpans[i];
+      assert spans.startPosition() != NO_MORE_POSITIONS;
+      assert spans.endPosition() != NO_MORE_POSITIONS;
+      if (advancePosition(spans, prevSpans.endPosition()) == NO_MORE_POSITIONS) {
+        oneExhaustedInCurrentDoc = true;
+        return false;
+      }
+      matchWidth += (spans.startPosition() - prevSpans.endPosition());
+      prevSpans = spans;
+    }
+    matchEnd = subSpans[subSpans.length - 1].endPosition();
+    return true; // all subSpans ordered and non overlapping
+  }
+
+  private static int advancePosition(SpanScorer spans, int position) throws IOException {
+    if (spans instanceof SpanNearQuery.GapSpanScorer) {
+      return ((SpanNearQuery.GapSpanScorer)spans).skipToPosition(position);
+    }
+    while (spans.startPosition() < position) {
+      spans.nextStartPosition();
+    }
+    return spans.startPosition();
+  }
+
+  @Override
+  public int startPosition() {
+    return atFirstInCurrentDoc ? -1 : matchStart;
+  }
+
+  @Override
+  public int endPosition() {
+    return atFirstInCurrentDoc ? -1 : matchEnd;
+  }
+
+  @Override
+  public int width() {
+    return matchWidth;
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    for (SpanScorer span : subSpans) {
+      span.collect(collector);
+    }
+  }
+
+  @Override
+  public String toString() {
+    return "NearSpanScorerOrdered("+query.toString()+")@"+docID()+": "+startPosition()+" - "+endPosition();
+  }
+
+}
+
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpanScorerUnordered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpanScorerUnordered.java
new file mode 100644
index 0000000..17c45e1
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpanScorerUnordered.java
@@ -0,0 +1,278 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.util.PriorityQueue;
+
+/**
+ * Similar to {@link NearSpanScorerOrdered}, but for the unordered case.
+ *
+ * Expert:
+ * Only public for subclassing.  Most implementations should not need this class
+ */
+public class NearSpanScorerUnordered extends ConjunctionSpanScorer {
+
+  private List<SpanScorerCell> subSpanCells; // in query order
+
+  private SpanPositionQueue spanPositionQueue;
+
+  private final int allowedSlop;
+  private final SpanNearQuery query;
+
+  public NearSpanScorerUnordered(SpanNearQuery.SpanNearWeight weight, Similarity.SimScorer docScorer, List<SpanScorer> subSpans)
+  throws IOException {
+    super(subSpans, weight, docScorer);
+
+    this.query = (SpanNearQuery) weight.getQuery();
+    this.allowedSlop = query.slop;
+
+    this.subSpanCells = new ArrayList<>(subSpans.size());
+    for (SpanScorer subSpan : subSpans) { // sub spans in query order
+      this.subSpanCells.add(new SpanScorerCell(subSpan));
+    }
+    spanPositionQueue = new SpanPositionQueue(subSpans.size());
+    singleCellToPositionQueue(); // -1 startPosition/endPosition also at doc -1
+  }
+
+  private void singleCellToPositionQueue() {
+    maxEndPositionCell = subSpanCells.get(0);
+    assert maxEndPositionCell.docID() == -1;
+    assert maxEndPositionCell.startPosition() == -1;
+    spanPositionQueue.add(maxEndPositionCell);
+  }
+
+  private void subSpanCellsToPositionQueue() throws IOException { // used when all subSpanCells arrived at the same doc.
+    spanPositionQueue.clear();
+    for (SpanScorerCell cell : subSpanCells) {
+      assert cell.startPosition() == -1;
+      cell.nextStartPosition();
+      assert cell.startPosition() != NO_MORE_POSITIONS;
+      spanPositionQueue.add(cell);
+    }
+  }
+
+  /** SpanScorerCell wraps a sub SpanScorer to maintain totalSpanLength and maxEndPositionCell */
+  private int totalSpanLength;
+  private SpanScorerCell maxEndPositionCell;
+
+  private class SpanScorerCell extends SpanScorer {
+    private int spanLength = -1;
+    final SpanScorer in;
+
+    public SpanScorerCell(SpanScorer spans) {
+      super((SpanWeight) NearSpanScorerUnordered.this.weight, NearSpanScorerUnordered.this.docScorer);
+      this.in = spans;
+    }
+
+    @Override
+    public int nextStartPosition() throws IOException {
+      int res = in.nextStartPosition();
+      if (res != NO_MORE_POSITIONS) {
+        adjustLength();
+      }
+      adjustMax(); // also after last end position in current doc.
+      return res;
+    }
+
+    private void adjustLength() {
+      if (spanLength != -1) {
+        totalSpanLength -= spanLength;  // subtract old, possibly from a previous doc
+      }
+      assert in.startPosition() != NO_MORE_POSITIONS;
+      spanLength = endPosition() - startPosition();
+      assert spanLength >= 0;
+      totalSpanLength += spanLength; // add new
+    }
+
+    private void adjustMax() {
+      assert docID() == maxEndPositionCell.docID();
+      if (endPosition() > maxEndPositionCell.endPosition()) {
+        maxEndPositionCell = this;
+      }
+    }
+
+    @Override
+    public int startPosition() {
+      return in.startPosition();
+    }
+
+    @Override
+    public int endPosition() {
+      return in.endPosition();
+    }
+
+    @Override
+    public int width() {
+      return in.width();
+    }
+
+    @Override
+    public void collect(SpanCollector collector) throws IOException {
+      in.collect(collector);
+    }
+
+    @Override
+    public TwoPhaseIterator asTwoPhaseIterator() {
+      return in.asTwoPhaseIterator();
+    }
+
+    @Override
+    public int docID() {
+      return in.docID();
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      return in.nextDoc();
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      return in.advance(target);
+    }
+
+    @Override
+    public long cost() {
+      return in.cost();
+    }
+
+    @Override
+    public String toString() {
+      return "NearSpanScorerUnordered.SpanScorerCell(" + in.toString() + ")";
+    }
+  }
+
+
+  private static class SpanPositionQueue extends PriorityQueue<SpanScorerCell> {
+    public SpanPositionQueue(int size) {
+      super(size);
+    }
+
+    @Override
+    protected final boolean lessThan(SpanScorerCell spans1, SpanScorerCell spans2) {
+      return positionsOrdered(spans1, spans2);
+    }
+  }
+
+  /** Check whether two SpanScorer in the same document are ordered with possible overlap.
+   * @return true iff spans1 starts before spans2
+   *              or the spans start at the same position,
+   *              and spans1 ends before spans2.
+   */
+  static final boolean positionsOrdered(SpanScorer spans1, SpanScorer spans2) {
+    assert spans1.docID() == spans2.docID() : "doc1 " + spans1.docID() + " != doc2 " + spans2.docID();
+    int start1 = spans1.startPosition();
+    int start2 = spans2.startPosition();
+    return (start1 == start2) ? (spans1.endPosition() < spans2.endPosition()) : (start1 < start2);
+  }
+
+  private SpanScorerCell minPositionCell() {
+    return spanPositionQueue.top();
+  }
+
+  private boolean atMatch() {
+    assert minPositionCell().docID() == maxEndPositionCell.docID();
+    return (maxEndPositionCell.endPosition() - minPositionCell().startPosition() - totalSpanLength) <= allowedSlop;
+  }
+
+  @Override
+  boolean twoPhaseCurrentDocMatches() throws IOException {
+    // at doc with all subSpans
+    subSpanCellsToPositionQueue();
+    while (true) {
+      if (atMatch()) {
+        atFirstInCurrentDoc = true;
+        oneExhaustedInCurrentDoc = false;
+        return true;
+      }
+      assert minPositionCell().startPosition() != NO_MORE_POSITIONS;
+      if (minPositionCell().nextStartPosition() != NO_MORE_POSITIONS) {
+        spanPositionQueue.updateTop();
+      }
+      else { // exhausted a subSpan in current doc
+        return false;
+      }
+    }
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    if (atFirstInCurrentDoc) {
+      atFirstInCurrentDoc = false;
+      return minPositionCell().startPosition();
+    }
+    while (minPositionCell().startPosition() == -1) { // initially at current doc
+      minPositionCell().nextStartPosition();
+      spanPositionQueue.updateTop();
+    }
+    assert minPositionCell().startPosition() != NO_MORE_POSITIONS;
+    while (true) {
+      if (minPositionCell().nextStartPosition() == NO_MORE_POSITIONS) {
+        oneExhaustedInCurrentDoc = true;
+        return NO_MORE_POSITIONS;
+      }
+      spanPositionQueue.updateTop();
+      if (atMatch()) {
+        return minPositionCell().startPosition();
+      }
+    }
+  }
+
+  @Override
+  public int startPosition() {
+    assert minPositionCell() != null;
+    return atFirstInCurrentDoc ? -1
+          : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
+          : minPositionCell().startPosition();
+  }
+
+  @Override
+  public int endPosition() {
+    return atFirstInCurrentDoc ? -1
+          : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
+          : maxEndPositionCell.endPosition();
+  }
+
+  @Override
+  public int width() {
+    return maxEndPositionCell.startPosition() - minPositionCell().startPosition();
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    for (SpanScorerCell cell : subSpanCells) {
+      cell.collect(collector);
+    }
+  }
+
+  @Override
+  public String toString() {
+    if (minPositionCell() != null) {
+      return getClass().getName() + "("+query.toString()+")@"+
+        (docID()+":"+startPosition()+"-"+endPosition());
+    } else {
+      return getClass().getName() + "("+query.toString()+")@ ?START?";
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
deleted file mode 100644
index 455b7ce..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
+++ /dev/null
@@ -1,161 +0,0 @@
-package org.apache.lucene.search.spans;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.List;
-
-/**
- * A Spans that is formed from the ordered subspans of a SpanNearQuery
- * where the subspans do not overlap and have a maximum slop between them.
- * <p>
- * The formed spans only contains minimum slop matches.<br>
- * The matching slop is computed from the distance(s) between
- * the non overlapping matching Spans.<br>
- * Successive matches are always formed from the successive Spans
- * of the SpanNearQuery.
- * <p>
- * The formed spans may contain overlaps when the slop is at least 1.
- * For example, when querying using
- * <pre>t1 t2 t3</pre>
- * with slop at least 1, the fragment:
- * <pre>t1 t2 t1 t3 t2 t3</pre>
- * matches twice:
- * <pre>t1 t2 .. t3      </pre>
- * <pre>      t1 .. t2 t3</pre>
- *
- * Expert:
- * Only public for subclassing.  Most implementations should not need this class
- */
-public class NearSpansOrdered extends ConjunctionSpans {
-
-  protected int matchStart = -1;
-  protected int matchEnd = -1;
-  protected int matchWidth = -1;
-
-  private final int allowedSlop;
-  private final SpanNearQuery query;
-
-  public NearSpansOrdered(SpanNearQuery query, List<Spans> subSpans) throws IOException {
-    super(subSpans);
-    this.atFirstInCurrentDoc = true; // -1 startPosition/endPosition also at doc -1
-    this.query = query;
-    this.allowedSlop = query.slop;
-  }
-
-  @Override
-  boolean twoPhaseCurrentDocMatches() throws IOException {
-    assert unpositioned();
-    oneExhaustedInCurrentDoc = false;
-    while (subSpans[0].nextStartPosition() != NO_MORE_POSITIONS && !oneExhaustedInCurrentDoc) {
-      if (stretchToOrder() && matchWidth <= allowedSlop) {
-        return atFirstInCurrentDoc = true;
-      }
-    }
-    return false;
-  }
-
-  private boolean unpositioned() {
-    for (Spans span : subSpans) {
-      if (span.startPosition() != -1)
-        return false;
-    }
-    return true;
-  }
-
-  @Override
-  public int nextStartPosition() throws IOException {
-    if (atFirstInCurrentDoc) {
-      atFirstInCurrentDoc = false;
-      return matchStart;
-    }
-    oneExhaustedInCurrentDoc = false;
-    while (subSpans[0].nextStartPosition() != NO_MORE_POSITIONS && !oneExhaustedInCurrentDoc) {
-      if (stretchToOrder() && matchWidth <= allowedSlop) {
-        return matchStart;
-      }
-    }
-    return matchStart = matchEnd = NO_MORE_POSITIONS;
-  }
-
-  /**
-   * Order the subSpans within the same document by using nextStartPosition on all subSpans
-   * after the first as little as necessary.
-   * Return true when the subSpans could be ordered in this way,
-   * otherwise at least one is exhausted in the current doc.
-   */
-  private boolean stretchToOrder() throws IOException {
-    Spans prevSpans = subSpans[0];
-    matchStart = prevSpans.startPosition();
-    assert prevSpans.startPosition() != NO_MORE_POSITIONS : "prevSpans no start position "+prevSpans;
-    assert prevSpans.endPosition() != NO_MORE_POSITIONS;
-    matchWidth = 0;
-    for (int i = 1; i < subSpans.length; i++) {
-      Spans spans = subSpans[i];
-      assert spans.startPosition() != NO_MORE_POSITIONS;
-      assert spans.endPosition() != NO_MORE_POSITIONS;
-      if (advancePosition(spans, prevSpans.endPosition()) == NO_MORE_POSITIONS) {
-        oneExhaustedInCurrentDoc = true;
-        return false;
-      }
-      matchWidth += (spans.startPosition() - prevSpans.endPosition());
-      prevSpans = spans;
-    }
-    matchEnd = subSpans[subSpans.length - 1].endPosition();
-    return true; // all subSpans ordered and non overlapping
-  }
-
-  private static int advancePosition(Spans spans, int position) throws IOException {
-    if (spans instanceof SpanNearQuery.GapSpans) {
-      return ((SpanNearQuery.GapSpans)spans).skipToPosition(position);
-    }
-    while (spans.startPosition() < position) {
-      spans.nextStartPosition();
-    }
-    return spans.startPosition();
-  }
-
-  @Override
-  public int startPosition() {
-    return atFirstInCurrentDoc ? -1 : matchStart;
-  }
-
-  @Override
-  public int endPosition() {
-    return atFirstInCurrentDoc ? -1 : matchEnd;
-  }
-
-  @Override
-  public int width() {
-    return matchWidth;
-  }
-
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    for (Spans span : subSpans) {
-      span.collect(collector);
-    }
-  }
-
-  @Override
-  public String toString() {
-    return "NearSpansOrdered("+query.toString()+")@"+docID()+": "+startPosition()+" - "+endPosition();
-  }
-
-}
-
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
deleted file mode 100644
index 4185882..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
+++ /dev/null
@@ -1,276 +0,0 @@
-package org.apache.lucene.search.spans;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.search.TwoPhaseIterator;
-import org.apache.lucene.util.PriorityQueue;
-
-/**
- * Similar to {@link NearSpansOrdered}, but for the unordered case.
- *
- * Expert:
- * Only public for subclassing.  Most implementations should not need this class
- */
-public class NearSpansUnordered extends ConjunctionSpans {
-
-  private List<SpansCell> subSpanCells; // in query order
-
-  private SpanPositionQueue spanPositionQueue;
-
-  private final int allowedSlop;
-  private final SpanNearQuery query;
-
-  public NearSpansUnordered(SpanNearQuery query, List<Spans> subSpans)
-  throws IOException {
-    super(subSpans);
-
-    this.query = query;
-    this.allowedSlop = query.slop;
-
-    this.subSpanCells = new ArrayList<>(subSpans.size());
-    for (Spans subSpan : subSpans) { // sub spans in query order
-      this.subSpanCells.add(new SpansCell(subSpan));
-    }
-    spanPositionQueue = new SpanPositionQueue(subSpans.size());
-    singleCellToPositionQueue(); // -1 startPosition/endPosition also at doc -1
-  }
-
-  private void singleCellToPositionQueue() {
-    maxEndPositionCell = subSpanCells.get(0);
-    assert maxEndPositionCell.docID() == -1;
-    assert maxEndPositionCell.startPosition() == -1;
-    spanPositionQueue.add(maxEndPositionCell);
-  }
-
-  private void subSpanCellsToPositionQueue() throws IOException { // used when all subSpanCells arrived at the same doc.
-    spanPositionQueue.clear();
-    for (SpansCell cell : subSpanCells) {
-      assert cell.startPosition() == -1;
-      cell.nextStartPosition();
-      assert cell.startPosition() != NO_MORE_POSITIONS;
-      spanPositionQueue.add(cell);
-    }
-  }
-
-  /** SpansCell wraps a sub Spans to maintain totalSpanLength and maxEndPositionCell */
-  private int totalSpanLength;
-  private SpansCell maxEndPositionCell;
-
-  private class SpansCell extends Spans {
-    private int spanLength = -1;
-    final Spans in;
-
-    public SpansCell(Spans spans) {
-      this.in = spans;
-    }
-
-    @Override
-    public int nextStartPosition() throws IOException {
-      int res = in.nextStartPosition();
-      if (res != NO_MORE_POSITIONS) {
-        adjustLength();
-      }
-      adjustMax(); // also after last end position in current doc.
-      return res;
-    }
-
-    private void adjustLength() {
-      if (spanLength != -1) {
-        totalSpanLength -= spanLength;  // subtract old, possibly from a previous doc
-      }
-      assert in.startPosition() != NO_MORE_POSITIONS;
-      spanLength = endPosition() - startPosition();
-      assert spanLength >= 0;
-      totalSpanLength += spanLength; // add new
-    }
-
-    private void adjustMax() {
-      assert docID() == maxEndPositionCell.docID();
-      if (endPosition() > maxEndPositionCell.endPosition()) {
-        maxEndPositionCell = this;
-      }
-    }
-
-    @Override
-    public int startPosition() {
-      return in.startPosition();
-    }
-
-    @Override
-    public int endPosition() {
-      return in.endPosition();
-    }
-
-    @Override
-    public int width() {
-      return in.width();
-    }
-
-    @Override
-    public void collect(SpanCollector collector) throws IOException {
-      in.collect(collector);
-    }
-
-    @Override
-    public TwoPhaseIterator asTwoPhaseIterator() {
-      return in.asTwoPhaseIterator();
-    }
-
-    @Override
-    public int docID() {
-      return in.docID();
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-      return in.nextDoc();
-    }
-
-    @Override
-    public int advance(int target) throws IOException {
-      return in.advance(target);
-    }
-
-    @Override
-    public long cost() {
-      return in.cost();
-    }
-
-    @Override
-    public String toString() {
-      return "NearSpansUnordered.SpansCell(" + in.toString() + ")";
-    }
-  }
-
-
-  private static class SpanPositionQueue extends PriorityQueue<SpansCell> {
-    public SpanPositionQueue(int size) {
-      super(size);
-    }
-
-    @Override
-    protected final boolean lessThan(SpansCell spans1, SpansCell spans2) {
-      return positionsOrdered(spans1, spans2);
-    }
-  }
-
-  /** Check whether two Spans in the same document are ordered with possible overlap.
-   * @return true iff spans1 starts before spans2
-   *              or the spans start at the same position,
-   *              and spans1 ends before spans2.
-   */
-  static final boolean positionsOrdered(Spans spans1, Spans spans2) {
-    assert spans1.docID() == spans2.docID() : "doc1 " + spans1.docID() + " != doc2 " + spans2.docID();
-    int start1 = spans1.startPosition();
-    int start2 = spans2.startPosition();
-    return (start1 == start2) ? (spans1.endPosition() < spans2.endPosition()) : (start1 < start2);
-  }
-
-  private SpansCell minPositionCell() {
-    return spanPositionQueue.top();
-  }
-
-  private boolean atMatch() {
-    assert minPositionCell().docID() == maxEndPositionCell.docID();
-    return (maxEndPositionCell.endPosition() - minPositionCell().startPosition() - totalSpanLength) <= allowedSlop;
-  }
-
-  @Override
-  boolean twoPhaseCurrentDocMatches() throws IOException {
-    // at doc with all subSpans
-    subSpanCellsToPositionQueue();
-    while (true) {
-      if (atMatch()) {
-        atFirstInCurrentDoc = true;
-        oneExhaustedInCurrentDoc = false;
-        return true;
-      }
-      assert minPositionCell().startPosition() != NO_MORE_POSITIONS;
-      if (minPositionCell().nextStartPosition() != NO_MORE_POSITIONS) {
-        spanPositionQueue.updateTop();
-      }
-      else { // exhausted a subSpan in current doc
-        return false;
-      }
-    }
-  }
-
-  @Override
-  public int nextStartPosition() throws IOException {
-    if (atFirstInCurrentDoc) {
-      atFirstInCurrentDoc = false;
-      return minPositionCell().startPosition();
-    }
-    while (minPositionCell().startPosition() == -1) { // initially at current doc
-      minPositionCell().nextStartPosition();
-      spanPositionQueue.updateTop();
-    }
-    assert minPositionCell().startPosition() != NO_MORE_POSITIONS;
-    while (true) {
-      if (minPositionCell().nextStartPosition() == NO_MORE_POSITIONS) {
-        oneExhaustedInCurrentDoc = true;
-        return NO_MORE_POSITIONS;
-      }
-      spanPositionQueue.updateTop();
-      if (atMatch()) {
-        return minPositionCell().startPosition();
-      }
-    }
-  }
-
-  @Override
-  public int startPosition() {
-    assert minPositionCell() != null;
-    return atFirstInCurrentDoc ? -1
-          : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
-          : minPositionCell().startPosition();
-  }
-
-  @Override
-  public int endPosition() {
-    return atFirstInCurrentDoc ? -1
-          : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
-          : maxEndPositionCell.endPosition();
-  }
-
-  @Override
-  public int width() {
-    return maxEndPositionCell.startPosition() - minPositionCell().startPosition();
-  }
-
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    for (SpansCell cell : subSpanCells) {
-      cell.collect(collector);
-    }
-  }
-
-  @Override
-  public String toString() {
-    if (minPositionCell() != null) {
-      return getClass().getName() + "("+query.toString()+")@"+
-        (docID()+":"+startPosition()+"-"+endPosition());
-    } else {
-      return getClass().getName() + "("+query.toString()+")@ ?START?";
-    }
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanBoostQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanBoostQuery.java
index c91f815..226138a 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanBoostQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanBoostQuery.java
@@ -170,8 +170,8 @@ public final class SpanBoostQuery extends SpanQuery {
       }
       
       @Override
-      public Spans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
-        return weight.getSpans(ctx, requiredPostings);
+      public SpanScorer getSpanScorer(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
+        return weight.getSpanScorer(ctx, requiredPostings);
       }
 
       @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanCollector.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanCollector.java
index 52cb441..13ae822 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanCollector.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanCollector.java
@@ -24,7 +24,7 @@ import java.io.IOException;
 
 /**
  * An interface defining the collection of postings information from the leaves
- * of a {@link org.apache.lucene.search.spans.Spans}
+ * of a {@link SpanScorer}
  *
  * @lucene.experimental
  */
@@ -40,7 +40,7 @@ public interface SpanCollector {
   public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException;
 
   /**
-   * Call to indicate that the driving Spans has moved to a new position
+   * Call to indicate that the driving SpanScorer has moved to a new position
    */
   public void reset();
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java
index 14c1f10..e2f6c28 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java
@@ -69,16 +69,16 @@ abstract class SpanContainQuery extends SpanQuery implements Cloneable {
       littleWeight.extractTerms(terms);
     }
 
-    ArrayList<Spans> prepareConjunction(final LeafReaderContext context, Postings postings) throws IOException {
-      Spans bigSpans = bigWeight.getSpans(context, postings);
+    ArrayList<SpanScorer> prepareConjunction(final LeafReaderContext context, Postings postings) throws IOException {
+      SpanScorer bigSpans = bigWeight.getSpanScorer(context, postings);
       if (bigSpans == null) {
         return null;
       }
-      Spans littleSpans = littleWeight.getSpans(context, postings);
+      SpanScorer littleSpans = littleWeight.getSpanScorer(context, postings);
       if (littleSpans == null) {
         return null;
       }
-      ArrayList<Spans> bigAndLittle = new ArrayList<>();
+      ArrayList<SpanScorer> bigAndLittle = new ArrayList<>();
       bigAndLittle.add(bigSpans);
       bigAndLittle.add(littleSpans);
       return bigAndLittle;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java
index 7ac20b7..2cc0f4e 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java
@@ -17,16 +17,16 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Map;
+
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.IndexSearcher;
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Map;
-
-/** Keep matches that contain another Spans. */
+/** Keep matches that contain another SpanScorer. */
 public final class SpanContainingQuery extends SpanContainQuery {
   /** Construct a SpanContainingQuery matching spans from <code>big</code>
    * that contain at least one spans from <code>little</code>.
@@ -62,16 +62,16 @@ public final class SpanContainingQuery extends SpanContainQuery {
      * The payload is from the spans of <code>big</code>.
      */
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
-      ArrayList<Spans> containerContained = prepareConjunction(context, requiredPostings);
+    public SpanScorer getSpanScorer(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+      ArrayList<SpanScorer> containerContained = prepareConjunction(context, requiredPostings);
       if (containerContained == null) {
         return null;
       }
 
-      Spans big = containerContained.get(0);
-      Spans little = containerContained.get(1);
+      SpanScorer big = containerContained.get(0);
+      SpanScorer little = containerContained.get(1);
 
-      return new ContainSpans(big, little, big) {
+      return new ContainSpanScorer(this, getSimScorer(context), big, little, big) {
 
         @Override
         boolean twoPhaseCurrentDocMatches() throws IOException {
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java
index c162c37..368cfff 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java
@@ -17,7 +17,7 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
-import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
+import org.apache.lucene.search.spans.FilterSpanScorer.AcceptStatus;
 
 import java.io.IOException;
 
@@ -35,7 +35,7 @@ public class SpanFirstQuery extends SpanPositionRangeQuery {
     super(match, 0, end);
   }
 
-  protected AcceptStatus acceptPosition(Spans spans) throws IOException {
+  protected AcceptStatus acceptPosition(SpanScorer spans) throws IOException {
     assert spans.startPosition() != spans.endPosition() : "start equals end: " + spans.startPosition();
     if (spans.startPosition() >= end)
       return AcceptStatus.NO_MORE_IN_CURRENT_DOC;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
index 7462da2..fee33ad 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
@@ -33,7 +33,6 @@ import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.util.ToStringUtils;
 
 /** Matches spans which are near one another.  One can specify <i>slop</i>, the
  * maximum number of intervening unmatched positions, as well as whether
@@ -202,16 +201,16 @@ public class SpanNearQuery extends SpanQuery implements Cloneable {
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+    public SpanScorer getSpanScorer(final LeafReaderContext context, Postings requiredPostings) throws IOException {
 
       Terms terms = context.reader().terms(field);
       if (terms == null) {
         return null; // field does not exist
       }
 
-      ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());
+      ArrayList<SpanScorer> subSpans = new ArrayList<>(clauses.size());
       for (SpanWeight w : subWeights) {
-        Spans subSpan = w.getSpans(context, requiredPostings);
+        SpanScorer subSpan = w.getSpanScorer(context, requiredPostings);
         if (subSpan != null) {
           subSpans.add(subSpan);
         } else {
@@ -220,8 +219,8 @@ public class SpanNearQuery extends SpanQuery implements Cloneable {
       }
 
       // all NearSpans require at least two subSpans
-      return (!inOrder) ? new NearSpansUnordered(SpanNearQuery.this, subSpans)
-          : new NearSpansOrdered(SpanNearQuery.this, subSpans);
+      return (!inOrder) ? new NearSpanScorerUnordered(this, getSimScorer(context), subSpans)
+          : new NearSpanScorerOrdered(this, getSimScorer(context), subSpans);
     }
 
     @Override
@@ -313,8 +312,8 @@ public class SpanNearQuery extends SpanQuery implements Cloneable {
       }
 
       @Override
-      public Spans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
-        return new GapSpans(width);
+      public SpanScorer getSpanScorer(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
+        return new GapSpanScorer(width);
       }
 
       @Override
@@ -324,13 +323,14 @@ public class SpanNearQuery extends SpanQuery implements Cloneable {
     }
   }
 
-  static class GapSpans extends Spans {
+  static class GapSpanScorer extends SpanScorer {
 
     int doc = -1;
     int pos = -1;
     final int width;
 
-    GapSpans(int width) {
+    GapSpanScorer(int width) {
+      super(null, null);
       this.width = width;
     }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
index 5a0bcd4..17f78b5 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
@@ -17,6 +17,11 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
@@ -25,12 +30,6 @@ import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TwoPhaseIterator;
-import org.apache.lucene.util.ToStringUtils;
-
-import java.io.IOException;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
 
 /** Removes matches which overlap with another SpanQuery or which are
  * within x tokens before or y tokens after another SpanQuery.
@@ -119,28 +118,33 @@ public final class SpanNotQuery extends SpanQuery {
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
-      Spans includeSpans = includeWeight.getSpans(context, requiredPostings);
+    public SpanScorer getSpanScorer(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+      SpanScorer includeSpans = includeWeight.getSpanScorer(context, requiredPostings);
       if (includeSpans == null) {
         return null;
       }
 
-      Spans excludeSpans = excludeWeight.getSpans(context, requiredPostings);
+      SpanScorer excludeSpans = excludeWeight.getSpanScorer(context, requiredPostings);
       if (excludeSpans == null) {
-        return includeSpans;
+        return new FilterSpanScorer(includeSpans, getSimScorer(context)) {
+          @Override
+          protected AcceptStatus accept(SpanScorer candidate) throws IOException {
+            return AcceptStatus.YES;
+          }
+        };
       }
 
       TwoPhaseIterator excludeTwoPhase = excludeSpans.asTwoPhaseIterator();
       DocIdSetIterator excludeApproximation = excludeTwoPhase == null ? null : excludeTwoPhase.approximation();
 
-      return new FilterSpans(includeSpans) {
+      return new FilterSpanScorer(includeSpans, getSimScorer(context)) {
         // last document we have checked matches() against for the exclusion, and failed
         // when using approximations, so we don't call it again, and pass thru all inclusions.
         int lastApproxDoc = -1;
         boolean lastApproxResult = false;
 
         @Override
-        protected AcceptStatus accept(Spans candidate) throws IOException {
+        protected AcceptStatus accept(SpanScorer candidate) throws IOException {
           // TODO: this logic is ugly and sneaky, can we clean it up?
           int doc = candidate.docID();
           if (doc > excludeSpans.docID()) {
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
index df96d71..f583138 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
@@ -17,6 +17,13 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
@@ -28,13 +35,6 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TwoPhaseIterator;
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
 
 /** Matches the union of its clauses.
  */
@@ -151,13 +151,13 @@ public final class SpanOrQuery extends SpanQuery {
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings)
+    public SpanScorer getSpanScorer(final LeafReaderContext context, Postings requiredPostings)
         throws IOException {
 
-      ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());
+      ArrayList<SpanScorer> subSpans = new ArrayList<>(clauses.size());
 
       for (SpanWeight w : subWeights) {
-        Spans spans = w.getSpans(context, requiredPostings);
+        SpanScorer spans = w.getSpanScorer(context, requiredPostings);
         if (spans != null) {
           subSpans.add(spans);
         }
@@ -166,23 +166,28 @@ public final class SpanOrQuery extends SpanQuery {
       if (subSpans.size() == 0) {
         return null;
       } else if (subSpans.size() == 1) {
-        return subSpans.get(0);
+        return new FilterSpanScorer(subSpans.get(0), getSimScorer(context)) {
+          @Override
+          protected AcceptStatus accept(SpanScorer candidate) throws IOException {
+            return AcceptStatus.YES;
+          }
+        };
       }
 
-      DisiPriorityQueue<Spans> byDocQueue = new DisiPriorityQueue<>(subSpans.size());
-      for (Spans spans : subSpans) {
+      DisiPriorityQueue<SpanScorer> byDocQueue = new DisiPriorityQueue<>(subSpans.size());
+      for (SpanScorer spans : subSpans) {
         byDocQueue.add(new DisiWrapper<>(spans));
       }
 
       SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1
 
-      return new Spans() {
-        Spans topPositionSpans = null;
+      return new SpanScorer(this, getSimScorer(context)) {
+        SpanScorer topPositionSpans = null;
 
         @Override
         public int nextDoc() throws IOException {
           topPositionSpans = null;
-          DisiWrapper<Spans> topDocSpans = byDocQueue.top();
+          DisiWrapper<SpanScorer> topDocSpans = byDocQueue.top();
           int currentDoc = topDocSpans.doc;
           do {
             topDocSpans.doc = topDocSpans.iterator.nextDoc();
@@ -194,7 +199,7 @@ public final class SpanOrQuery extends SpanQuery {
         @Override
         public int advance(int target) throws IOException {
           topPositionSpans = null;
-          DisiWrapper<Spans> topDocSpans = byDocQueue.top();
+          DisiWrapper<SpanScorer> topDocSpans = byDocQueue.top();
           do {
             topDocSpans.doc = topDocSpans.iterator.advance(target);
             topDocSpans = byDocQueue.updateTop();
@@ -204,14 +209,14 @@ public final class SpanOrQuery extends SpanQuery {
 
         @Override
         public int docID() {
-          DisiWrapper<Spans> topDocSpans = byDocQueue.top();
+          DisiWrapper<SpanScorer> topDocSpans = byDocQueue.top();
           return topDocSpans.doc;
         }
 
         @Override
         public TwoPhaseIterator asTwoPhaseIterator() {
           boolean hasApproximation = false;
-          for (DisiWrapper<Spans> w : byDocQueue) {
+          for (DisiWrapper<SpanScorer> w : byDocQueue) {
             if (w.twoPhaseView != null) {
               hasApproximation = true;
               break;
@@ -222,7 +227,7 @@ public final class SpanOrQuery extends SpanQuery {
             return null;
           }
 
-          return new TwoPhaseIterator(new DisjunctionDISIApproximation<Spans>(byDocQueue)) {
+          return new TwoPhaseIterator(new DisjunctionDISIApproximation<SpanScorer>(byDocQueue)) {
             @Override
             public boolean matches() throws IOException {
               return twoPhaseCurrentDocMatches();
@@ -233,7 +238,7 @@ public final class SpanOrQuery extends SpanQuery {
         int lastDocTwoPhaseMatched = -1;
 
         boolean twoPhaseCurrentDocMatches() throws IOException {
-          DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();
+          DisiWrapper<SpanScorer> listAtCurrentDoc = byDocQueue.topList();
           // remove the head of the list as long as it does not match
           final int currentDoc = listAtCurrentDoc.doc;
           while (listAtCurrentDoc.twoPhaseView != null) {
@@ -256,10 +261,10 @@ public final class SpanOrQuery extends SpanQuery {
 
         void fillPositionQueue() throws IOException { // called at first nextStartPosition
           assert byPositionQueue.size() == 0;
-          // add all matching Spans at current doc to byPositionQueue
-          DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();
+          // add all matching SpanScorer at current doc to byPositionQueue
+          DisiWrapper<SpanScorer> listAtCurrentDoc = byDocQueue.topList();
           while (listAtCurrentDoc != null) {
-            Spans spansAtDoc = listAtCurrentDoc.iterator;
+            SpanScorer spansAtDoc = listAtCurrentDoc.iterator;
             if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation
               if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation
                 if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false
@@ -331,7 +336,7 @@ public final class SpanOrQuery extends SpanQuery {
         public long cost() {
           if (cost == -1) {
             cost = 0;
-            for (Spans spans : subSpans) {
+            for (SpanScorer spans : subSpans) {
               cost += spans.cost();
             }
           }
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
index 85622a0..fb28041 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
@@ -17,18 +17,18 @@ package org.apache.lucene.search.spans;
  */
 
 
+import java.io.IOException;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
-
-import java.io.IOException;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
+import org.apache.lucene.search.spans.FilterSpanScorer.AcceptStatus;
 
 
 /**
@@ -54,17 +54,17 @@ public abstract class SpanPositionCheckQuery extends SpanQuery implements Clonea
    * Implementing classes are required to return whether the current position is a match for the passed in
    * "match" {@link SpanQuery}.
    *
-   * This is only called if the underlying last {@link Spans#nextStartPosition()} for the
+   * This is only called if the underlying last {@link SpanScorer#nextStartPosition()} for the
    * match indicated a valid start position.
    *
-   * @param spans The {@link Spans} instance, positioned at the spot to check
+   * @param spans The {@link SpanScorer} instance, positioned at the spot to check
    *
    * @return whether the match is accepted, rejected, or rejected and should move to the next doc.
    *
-   * @see Spans#nextDoc()
+   * @see SpanScorer#nextDoc()
    *
    */
-  protected abstract AcceptStatus acceptPosition(Spans spans) throws IOException;
+  protected abstract AcceptStatus acceptPosition(SpanScorer spans) throws IOException;
 
   @Override
   public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
@@ -92,11 +92,11 @@ public abstract class SpanPositionCheckQuery extends SpanQuery implements Clonea
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
-      Spans matchSpans = matchWeight.getSpans(context, requiredPostings);
-      return (matchSpans == null) ? null : new FilterSpans(matchSpans) {
+    public SpanScorer getSpanScorer(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+      SpanScorer matchSpans = matchWeight.getSpanScorer(context, requiredPostings);
+      return (matchSpans == null) ? null : new FilterSpanScorer(matchSpans, getSimScorer(context)) {
         @Override
-        protected AcceptStatus accept(Spans candidate) throws IOException {
+        protected AcceptStatus accept(SpanScorer candidate) throws IOException {
           return acceptPosition(candidate);
         }
       };
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionQueue.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionQueue.java
index cf83d13..8c790d2 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionQueue.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionQueue.java
@@ -19,12 +19,12 @@ package org.apache.lucene.search.spans;
 
 import org.apache.lucene.util.PriorityQueue;
 
-class SpanPositionQueue extends PriorityQueue<Spans> {
+class SpanPositionQueue extends PriorityQueue<SpanScorer> {
   SpanPositionQueue(int maxSize) {
     super(maxSize, false); // do not prepopulate
   }
 
-  protected boolean lessThan(Spans s1, Spans s2) {
+  protected boolean lessThan(SpanScorer s1, SpanScorer s2) {
     int start1 = s1.startPosition();
     int start2 = s2.startPosition();
     return (start1 < start2) ? true
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java
index c64253f..1cb27d2 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java
@@ -17,7 +17,7 @@ package org.apache.lucene.search.spans;
  */
 
 
-import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
+import org.apache.lucene.search.spans.FilterSpanScorer.AcceptStatus;
 
 import java.io.IOException;
 
@@ -38,7 +38,7 @@ public class SpanPositionRangeQuery extends SpanPositionCheckQuery {
   }
 
   @Override
-  protected AcceptStatus acceptPosition(Spans spans) throws IOException {
+  protected AcceptStatus acceptPosition(SpanScorer spans) throws IOException {
     assert spans.startPosition() != spans.endPosition();
     AcceptStatus res = (spans.startPosition() >= end)
         ? AcceptStatus.NO_MORE_IN_CURRENT_DOC
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java
index bae2e4c..770cf21 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java
@@ -18,53 +18,112 @@ package org.apache.lucene.search.spans;
  */
 
 import java.io.IOException;
-import java.util.Objects;
 
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.TwoPhaseIterator;
 import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.search.similarities.Similarity.SimScorer;
 
-/**
- * Public for extension only.
+/** Iterates through combinations of start/end positions per-doc.
+ *  Each start/end position represents a range of term positions within the current document.
+ *  These are enumerated in order, by increasing document number, within that by
+ *  increasing start position and finally by increasing end position.
  */
-public class SpanScorer extends Scorer {
-  /** underlying spans we are scoring from */
-  protected final Spans spans;
-  /** similarity used in default score impl */
+public abstract class SpanScorer extends Scorer {
+
+  public static final int NO_MORE_POSITIONS = Integer.MAX_VALUE;
+
   protected final Similarity.SimScorer docScorer;
 
+  protected SpanScorer(SpanWeight weight, SimScorer docScorer) {
+    super(weight);
+    this.docScorer = docScorer;
+  }
+
   /** accumulated sloppy freq (computed in setFreqCurrentDoc) */
   protected float freq;
   /** number of matches (computed in setFreqCurrentDoc) */
   protected int numMatches;
-  
+
   private int lastScoredDoc = -1; // last doc we called setFreqCurrentDoc() for
 
   /**
-   * Creates a new SpanScorer
-   * @lucene.internal
+   * Returns the next start position for the current doc.
+   * There is always at least one start/end position per doc.
+   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
    */
-  public SpanScorer(Spans spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
-    super(weight);
-    this.docScorer = docScorer;
-    this.spans = Objects.requireNonNull(spans);
-  }
+  public abstract int nextStartPosition() throws IOException;
 
-  @Override
-  public final int nextDoc() throws IOException {
-    return spans.nextDoc();
+  /**
+   * Returns the start position in the current doc, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
+   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
+   */
+  public abstract int startPosition();
+
+  /**
+   * Returns the end position for the current start position, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
+   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
+   */
+  public abstract int endPosition();
+
+  /**
+   * Return the width of the match, which is typically used to compute
+   * the {@link SimScorer#computeSlopFactor(int) slop factor}. It is only legal
+   * to call this method when the iterator is on a valid doc ID and positioned.
+   * The return value must be positive, and lower values means that the match is
+   * better.
+   */
+  public abstract int width();
+
+  /**
+   * Collect postings data from the leaves of the current SpanScorer.
+   *
+   * This method should only be called after {@link #nextStartPosition()}, and before
+   * {@link #NO_MORE_POSITIONS} has been reached.
+   *
+   * @param collector a SpanCollector
+   *
+   * @lucene.experimental
+   */
+  public abstract void collect(SpanCollector collector) throws IOException;
+
+  /**
+   * Optional method: Return a {@link TwoPhaseIterator} view of this
+   * {@link SpanScorer}. A return value of {@code null} indicates that
+   * two-phase iteration is not supported.
+   *
+   * Note that the returned {@link TwoPhaseIterator}'s
+   * {@link TwoPhaseIterator#approximation() approximation} must
+   * advance documents synchronously with this iterator:
+   * advancing the approximation must
+   * advance this iterator and vice-versa.
+   *
+   * Implementing this method is typically useful on a {@link SpanScorer}
+   * that has a high per-document overhead for confirming matches.
+   *
+   * The default implementation returns {@code null}.
+   */
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    return null;
   }
 
   @Override
-  public final int advance(int target) throws IOException {
-    return spans.advance(target);
+  public String toString() {
+    StringBuilder sb = new StringBuilder();
+    Class<? extends SpanScorer> clazz = getClass();
+    sb.append(clazz.isAnonymousClass() ? clazz.getName() : clazz.getSimpleName());
+    sb.append("(doc=").append(docID());
+    sb.append(",start=").append(startPosition());
+    sb.append(",end=").append(endPosition());
+    sb.append(")");
+    return sb.toString();
   }
-  
-  /** 
+
+  /**
    * Ensure setFreqCurrentDoc is called, if not already called for the current doc.
    */
-  private final void ensureFreq() throws IOException {
-    int currentDoc = spans.docID();
+  private void ensureFreq() throws IOException {
+    int currentDoc = docID();
     if (lastScoredDoc != currentDoc) {
       setFreqCurrentDoc();
       lastScoredDoc = currentDoc;
@@ -82,17 +141,17 @@ public class SpanScorer extends Scorer {
 
     doStartCurrentDoc();
 
-    assert spans.startPosition() == -1 : "incorrect initial start position, spans="+spans;
-    assert spans.endPosition() == -1 : "incorrect initial end position, spans="+spans;
+    assert startPosition() == -1 : "incorrect initial start position, " + this.toString();
+    assert endPosition() == -1 : "incorrect initial end position, " + this.toString();
     int prevStartPos = -1;
     int prevEndPos = -1;
 
-    int startPos = spans.nextStartPosition();
-    assert startPos != Spans.NO_MORE_POSITIONS : "initial startPos NO_MORE_POSITIONS, spans="+spans;
+    int startPos = nextStartPosition();
+    assert startPos != SpanScorer.NO_MORE_POSITIONS : "initial startPos NO_MORE_POSITIONS, " + this.toString();
     do {
       assert startPos >= prevStartPos;
-      int endPos = spans.endPosition();
-      assert endPos != Spans.NO_MORE_POSITIONS;
+      int endPos = endPosition();
+      assert endPos != SpanScorer.NO_MORE_POSITIONS;
       // This assertion can fail for Or spans on the same term:
       // assert (startPos != prevStartPos) || (endPos > prevEndPos) : "non increased endPos="+endPos;
       assert (startPos != prevStartPos) || (endPos >= prevEndPos) : "decreased endPos="+endPos;
@@ -101,15 +160,15 @@ public class SpanScorer extends Scorer {
         freq = 1;
         return;
       }
-      freq += docScorer.computeSlopFactor(spans.width());
+      freq += docScorer.computeSlopFactor(width());
       doCurrentSpans();
       prevStartPos = startPos;
       prevEndPos = endPos;
-      startPos = spans.nextStartPosition();
-    } while (startPos != Spans.NO_MORE_POSITIONS);
+      startPos = nextStartPosition();
+    } while (startPos != SpanScorer.NO_MORE_POSITIONS);
 
-    assert spans.startPosition() == Spans.NO_MORE_POSITIONS : "incorrect final start position, spans="+spans;
-    assert spans.endPosition() == Spans.NO_MORE_POSITIONS : "incorrect final end position, spans="+spans;
+    assert startPosition() == SpanScorer.NO_MORE_POSITIONS : "incorrect final start position, " + this.toString();
+    assert endPosition() == SpanScorer.NO_MORE_POSITIONS : "incorrect final end position, " + this.toString();
   }
 
   /**
@@ -118,22 +177,20 @@ public class SpanScorer extends Scorer {
   protected void doStartCurrentDoc() throws IOException {}
 
   /**
-   * Called each time the scorer's Spans is advanced during frequency calculation
+   * Called each time the scorer's SpanScorer is advanced during frequency calculation
    */
   protected void doCurrentSpans() throws IOException {}
-  
+
   /**
-   * Score the current doc. The default implementation scores the doc 
+   * Score the current doc. The default implementation scores the doc
    * with the similarity using the slop-adjusted {@link #freq}.
    */
   protected float scoreCurrentDoc() throws IOException {
-    return docScorer.score(spans.docID(), freq);
+    assert docScorer != null : getClass() + " has a null docScorer!";
+    return docScorer.score(docID(), freq);
   }
 
   @Override
-  public final int docID() { return spans.docID(); }
-
-  @Override
   public final float score() throws IOException {
     ensureFreq();
     return scoreCurrentDoc();
@@ -147,19 +204,9 @@ public class SpanScorer extends Scorer {
 
   /** Returns the intermediate "sloppy freq" adjusted for edit distance
    *  @lucene.internal */
-  // only public so .payloads can see it.
-  public final float sloppyFreq() throws IOException {
+  final float sloppyFreq() throws IOException {
     ensureFreq();
     return freq;
   }
 
-  @Override
-  public final long cost() {
-    return spans.cost();
-  }
-
-  @Override
-  public final TwoPhaseIterator asTwoPhaseIterator() {
-    return spans.asTwoPhaseIterator();
-  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
index e2961ab..b4d2b5b 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
@@ -17,6 +17,12 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.Collections;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.PostingsEnum;
@@ -27,13 +33,6 @@ import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.util.ToStringUtils;
-
-import java.io.IOException;
-import java.util.Collections;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
 
 /** Matches spans containing a term.
  * This should not be used for terms that are indexed at position Integer.MAX_VALUE.
@@ -98,7 +97,7 @@ public class SpanTermQuery extends SpanQuery {
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+    public SpanScorer getSpanScorer(final LeafReaderContext context, Postings requiredPostings) throws IOException {
 
       assert termContext.topReaderContext == ReaderUtil.getTopLevelContext(context) : "The top-reader used to create Weight (" + termContext.topReaderContext + ") is not the same as the current reader's top-reader (" + ReaderUtil.getTopLevelContext(context);
 
@@ -118,7 +117,7 @@ public class SpanTermQuery extends SpanQuery {
       termsEnum.seekExact(term.bytes(), state);
 
       final PostingsEnum postings = termsEnum.postings(null, requiredPostings.getRequiredPostings());
-      return new TermSpans(postings, term);
+      return new TermSpanScorer(this, getSimScorer(context), postings, term);
     }
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
index 4e587df..d5eeaf2 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
@@ -41,7 +41,7 @@ public abstract class SpanWeight extends Weight {
 
   /**
    * Enumeration defining what postings information should be retrieved from the
-   * index for a given Spans
+   * index for a given SpanScorer
    */
   public enum Postings {
     POSITIONS {
@@ -111,12 +111,12 @@ public abstract class SpanWeight extends Weight {
   public abstract void extractTermContexts(Map<Term, TermContext> contexts);
 
   /**
-   * Expert: Return a Spans object iterating over matches from this Weight
-   * @param ctx a LeafReaderContext for this Spans
-   * @return a Spans
+   * Expert: Return a SpanScorer object iterating over matches from this Weight
+   * @param ctx a LeafReaderContext for this SpanScorer
+   * @return a SpanScorer
    * @throws IOException on error
    */
-  public abstract Spans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException;
+  public abstract SpanScorer getSpanScorer(LeafReaderContext ctx, Postings requiredPostings) throws IOException;
 
   @Override
   public float getValueForNormalization() throws IOException {
@@ -139,9 +139,7 @@ public abstract class SpanWeight extends Weight {
     if (terms != null && terms.hasPositions() == false) {
       throw new IllegalStateException("field \"" + field + "\" was indexed without position data; cannot run SpanQuery (query=" + parentQuery + ")");
     }
-    Spans spans = getSpans(context, Postings.POSITIONS);
-    Similarity.SimScorer simScorer = getSimScorer(context);
-    return (spans == null) ? null : new SpanScorer(spans, this, simScorer);
+    return getSpanScorer(context, Postings.POSITIONS);
   }
 
   public Similarity.SimScorer getSimScorer(LeafReaderContext context) throws IOException {
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java
index 01bf937..2799e5e 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java
@@ -17,16 +17,16 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Map;
+
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.IndexSearcher;
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Map;
-
-/** Keep matches that are contained within another Spans. */
+/** Keep matches that are contained within another SpanScorer. */
 public final class SpanWithinQuery extends SpanContainQuery {
 
   /** Construct a SpanWithinQuery matching spans from <code>little</code>
@@ -63,16 +63,16 @@ public final class SpanWithinQuery extends SpanContainQuery {
      * The payload is from the spans of <code>little</code>.
      */
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
-      ArrayList<Spans> containerContained = prepareConjunction(context, requiredPostings);
+    public SpanScorer getSpanScorer(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+      ArrayList<SpanScorer> containerContained = prepareConjunction(context, requiredPostings);
       if (containerContained == null) {
         return null;
       }
 
-      Spans big = containerContained.get(0);
-      Spans little = containerContained.get(1);
+      SpanScorer big = containerContained.get(0);
+      SpanScorer little = containerContained.get(1);
 
-      return new ContainSpans(big, little, little) {
+      return new ContainSpanScorer(this, getSimScorer(context), big, little, little) {
 
         @Override
         boolean twoPhaseCurrentDocMatches() throws IOException {
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java b/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
deleted file mode 100644
index e947683..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package org.apache.lucene.search.spans;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.search.TwoPhaseIterator;
-import org.apache.lucene.search.similarities.Similarity.SimScorer;
-
-/** Iterates through combinations of start/end positions per-doc.
- *  Each start/end position represents a range of term positions within the current document.
- *  These are enumerated in order, by increasing document number, within that by
- *  increasing start position and finally by increasing end position.
- */
-public abstract class Spans extends DocIdSetIterator {
-  public static final int NO_MORE_POSITIONS = Integer.MAX_VALUE;
-
-  /**
-   * Returns the next start position for the current doc.
-   * There is always at least one start/end position per doc.
-   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
-   */
-  public abstract int nextStartPosition() throws IOException;
-
-  /**
-   * Returns the start position in the current doc, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
-   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
-   */
-  public abstract int startPosition();
-
-  /**
-   * Returns the end position for the current start position, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
-   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
-   */
-  public abstract int endPosition();
-
-  /**
-   * Return the width of the match, which is typically used to compute
-   * the {@link SimScorer#computeSlopFactor(int) slop factor}. It is only legal
-   * to call this method when the iterator is on a valid doc ID and positioned.
-   * The return value must be positive, and lower values means that the match is
-   * better.
-   */
-  public abstract int width();
-
-  /**
-   * Collect postings data from the leaves of the current Spans.
-   *
-   * This method should only be called after {@link #nextStartPosition()}, and before
-   * {@link #NO_MORE_POSITIONS} has been reached.
-   *
-   * @param collector a SpanCollector
-   *
-   * @lucene.experimental
-   */
-  public abstract void collect(SpanCollector collector) throws IOException;
-
-  /**
-   * Optional method: Return a {@link TwoPhaseIterator} view of this
-   * {@link Spans}. A return value of {@code null} indicates that
-   * two-phase iteration is not supported.
-   *
-   * Note that the returned {@link TwoPhaseIterator}'s
-   * {@link TwoPhaseIterator#approximation() approximation} must
-   * advance documents synchronously with this iterator:
-   * advancing the approximation must
-   * advance this iterator and vice-versa.
-   *
-   * Implementing this method is typically useful on a {@link Spans}
-   * that has a high per-document overhead for confirming matches.
-   *
-   * The default implementation returns {@code null}.
-   */
-  public TwoPhaseIterator asTwoPhaseIterator() {
-    return null;
-  }
-
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder();
-    Class<? extends Spans> clazz = getClass();
-    sb.append(clazz.isAnonymousClass() ? clazz.getName() : clazz.getSimpleName());
-    sb.append("(doc=").append(docID());
-    sb.append(",start=").append(startPosition());
-    sb.append(",end=").append(endPosition());
-    sb.append(")");
-    return sb.toString();
-  }
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/TermSpanScorer.java b/lucene/core/src/java/org/apache/lucene/search/spans/TermSpanScorer.java
new file mode 100644
index 0000000..f4960dd
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/TermSpanScorer.java
@@ -0,0 +1,132 @@
+package org.apache.lucene.search.spans;
+/*
+ * Copyright 2005 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import java.io.IOException;
+import java.util.Objects;
+
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.similarities.Similarity;
+
+/**
+ * Expert:
+ * Public for extension only.
+ * This does not work correctly for terms that indexed at position Integer.MAX_VALUE.
+ */
+public class TermSpanScorer extends SpanScorer {
+  protected final PostingsEnum postings;
+  protected final Term term;
+  protected int doc;
+  protected int freq;
+  protected int count;
+  protected int position;
+  protected boolean readPayload;
+
+  public TermSpanScorer(SpanWeight weight, Similarity.SimScorer scorer, PostingsEnum postings, Term term) {
+    super(weight, scorer);
+    this.postings = Objects.requireNonNull(postings);
+    this.term = Objects.requireNonNull(term);
+    this.doc = -1;
+    this.position = -1;
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    doc = postings.nextDoc();
+    if (doc != DocIdSetIterator.NO_MORE_DOCS) {
+      freq = postings.freq();
+      assert freq >= 1;
+      count = 0;
+    }
+    position = -1;
+    return doc;
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    assert target > doc;
+    doc = postings.advance(target);
+    if (doc != DocIdSetIterator.NO_MORE_DOCS) {
+      freq = postings.freq();
+      assert freq >= 1;
+      count = 0;
+    }
+    position = -1;
+    return doc;
+  }
+
+  @Override
+  public int docID() {
+    return doc;
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    if (count == freq) {
+      assert position != NO_MORE_POSITIONS;
+      return position = NO_MORE_POSITIONS;
+    }
+    int prevPosition = position;
+    position = postings.nextPosition();
+    assert position >= prevPosition : "prevPosition="+prevPosition+" > position="+position;
+    assert position != NO_MORE_POSITIONS; // int endPosition not possible
+    count++;
+    readPayload = false;
+    return position;
+  }
+
+  @Override
+  public int startPosition() {
+    return position;
+  }
+
+  @Override
+  public int endPosition() {
+    return (position == -1) ? -1
+          : (position != NO_MORE_POSITIONS) ? position + 1
+          : NO_MORE_POSITIONS;
+  }
+
+  @Override
+  public int width() {
+    return 0;
+  }
+
+  @Override
+  public long cost() {
+    return postings.cost();
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    collector.collectLeaf(postings, position, term);
+  }
+
+  @Override
+  public String toString() {
+    return "spans(" + term.toString() + ")@" +
+            (doc == -1 ? "START" : (doc == NO_MORE_DOCS) ? "ENDDOC"
+              : doc + " - " + (position == NO_MORE_POSITIONS ? "ENDPOS" : position));
+  }
+
+  public PostingsEnum getPostings() {
+    return postings;
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
deleted file mode 100644
index 93e8282..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
+++ /dev/null
@@ -1,130 +0,0 @@
-package org.apache.lucene.search.spans;
-/*
- * Copyright 2005 The Apache Software Foundation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-import org.apache.lucene.index.PostingsEnum;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.DocIdSetIterator;
-
-import java.io.IOException;
-import java.util.Objects;
-
-/**
- * Expert:
- * Public for extension only.
- * This does not work correctly for terms that indexed at position Integer.MAX_VALUE.
- */
-public class TermSpans extends Spans {
-  protected final PostingsEnum postings;
-  protected final Term term;
-  protected int doc;
-  protected int freq;
-  protected int count;
-  protected int position;
-  protected boolean readPayload;
-
-  public TermSpans(PostingsEnum postings, Term term) {
-    this.postings = Objects.requireNonNull(postings);
-    this.term = Objects.requireNonNull(term);
-    this.doc = -1;
-    this.position = -1;
-  }
-
-  @Override
-  public int nextDoc() throws IOException {
-    doc = postings.nextDoc();
-    if (doc != DocIdSetIterator.NO_MORE_DOCS) {
-      freq = postings.freq();
-      assert freq >= 1;
-      count = 0;
-    }
-    position = -1;
-    return doc;
-  }
-
-  @Override
-  public int advance(int target) throws IOException {
-    assert target > doc;
-    doc = postings.advance(target);
-    if (doc != DocIdSetIterator.NO_MORE_DOCS) {
-      freq = postings.freq();
-      assert freq >= 1;
-      count = 0;
-    }
-    position = -1;
-    return doc;
-  }
-
-  @Override
-  public int docID() {
-    return doc;
-  }
-
-  @Override
-  public int nextStartPosition() throws IOException {
-    if (count == freq) {
-      assert position != NO_MORE_POSITIONS;
-      return position = NO_MORE_POSITIONS;
-    }
-    int prevPosition = position;
-    position = postings.nextPosition();
-    assert position >= prevPosition : "prevPosition="+prevPosition+" > position="+position;
-    assert position != NO_MORE_POSITIONS; // int endPosition not possible
-    count++;
-    readPayload = false;
-    return position;
-  }
-
-  @Override
-  public int startPosition() {
-    return position;
-  }
-
-  @Override
-  public int endPosition() {
-    return (position == -1) ? -1
-          : (position != NO_MORE_POSITIONS) ? position + 1
-          : NO_MORE_POSITIONS;
-  }
-
-  @Override
-  public int width() {
-    return 0;
-  }
-
-  @Override
-  public long cost() {
-    return postings.cost();
-  }
-
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    collector.collectLeaf(postings, position, term);
-  }
-
-  @Override
-  public String toString() {
-    return "spans(" + term.toString() + ")@" +
-            (doc == -1 ? "START" : (doc == NO_MORE_DOCS) ? "ENDDOC"
-              : doc + " - " + (position == NO_MORE_POSITIONS ? "ENDPOS" : position));
-  }
-
-  public PostingsEnum getPostings() {
-    return postings;
-  }
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/package-info.java b/lucene/core/src/java/org/apache/lucene/search/spans/package-info.java
index 4fc88d3..413508a 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/package-info.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/package-info.java
@@ -19,7 +19,7 @@
  * The calculus of spans.
  * 
  * <p>A span is a <code>&lt;doc,startPosition,endPosition&gt;</code> tuple  that is enumerated by
- *    class {@link org.apache.lucene.search.spans.Spans Spans}.
+ *    class {@link org.apache.lucene.search.spans.SpanScorer SpanScorer}.
  *  </p>
  * 
  * <p>The following span query operators are implemented:
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java b/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java
index 85e4ebc..424fb0b 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java
@@ -42,9 +42,9 @@ import org.apache.lucene.search.spans.MultiSpansWrapper;
 import org.apache.lucene.search.spans.SpanCollector;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
@@ -254,9 +254,9 @@ public class TestPositionIncrement extends LuceneTestCase {
       System.out.println("\ngetPayloadSpans test");
     }
     PayloadSpanCollector collector = new PayloadSpanCollector();
-    Spans pspans = MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
-    while (pspans.nextDoc() != Spans.NO_MORE_DOCS) {
-      while (pspans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+    SpanScorer pspans = MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
+    while (pspans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+      while (pspans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
         if (VERBOSE) {
           System.out.println("doc " + pspans.docID() + ": span " + pspans.startPosition()
               + " to " + pspans.endPosition());
@@ -276,11 +276,11 @@ public class TestPositionIncrement extends LuceneTestCase {
     assertEquals(8, count);
 
     // System.out.println("\ngetSpans test");
-    Spans spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq);
+    SpanScorer spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq);
     count = 0;
     sawZero = false;
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-      while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+    while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
         count++;
         sawZero |= spans.startPosition() == 0;
         // System.out.println(spans.doc() + " - " + spans.start() + " - " +
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java
index 1a709ec..e7b01c8 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java
@@ -20,7 +20,6 @@ package org.apache.lucene.search.spans;
 import java.io.IOException;
 
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.similarities.Similarity;
 
 /**
  * Holds all implementations of classes in the o.a.l.s.spans package as a
@@ -33,7 +32,11 @@ final class JustCompileSearchSpans {
 
   private static final String UNSUPPORTED_MSG = "unsupported: used for back-compat testing only !";
 
-  static final class JustCompileSpans extends Spans {
+  static final class JustCompileSpanScorer extends SpanScorer {
+
+    JustCompileSpanScorer() {
+      super(null, null);
+    }
 
     @Override
     public int docID() {
@@ -100,65 +103,4 @@ final class JustCompileSearchSpans {
     
   }
 
-  static final class JustCompilePayloadSpans extends Spans {
-
-    @Override
-    public int docID() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public int advance(int target) throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public int startPosition() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public int endPosition() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public int width() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public void collect(SpanCollector collector) throws IOException {
-
-    }
-
-    @Override
-    public int nextStartPosition() throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public long cost() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-    
-  }
-  
-  static final class JustCompileSpanScorer extends SpanScorer {
-
-    protected JustCompileSpanScorer(Spans spans, SpanWeight weight,
-        Similarity.SimScorer docScorer) throws IOException {
-      super(spans, weight, docScorer);
-    }
-
-    @Override
-    protected float scoreCurrentDoc() throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-  }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java
index 8bb8442..a34a407 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java
@@ -251,7 +251,7 @@ public class TestFieldMaskingSpanQuery extends LuceneTestCase {
     SpanQuery q  = new SpanOrQuery(q1, new FieldMaskingSpanQuery(q2, "gender"));
     check(q, new int[] { 0, 1, 2, 3, 4 });
 
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
     assertNext(span, 0,0,1);
     assertNext(span, 1,0,1);
     assertNext(span, 1,1,2);
@@ -273,18 +273,18 @@ public class TestFieldMaskingSpanQuery extends LuceneTestCase {
     check(qA, new int[] { 0, 1, 2, 4 });
     check(qB, new int[] { 0, 1, 2, 4 });
   
-    Spans spanA = MultiSpansWrapper.wrap(searcher.getIndexReader(), qA);
-    Spans spanB = MultiSpansWrapper.wrap(searcher.getIndexReader(), qB);
+    SpanScorer spanA = MultiSpansWrapper.wrap(searcher.getIndexReader(), qA);
+    SpanScorer spanB = MultiSpansWrapper.wrap(searcher.getIndexReader(), qB);
     
-    while (spanA.nextDoc() != Spans.NO_MORE_DOCS) {
-      assertNotSame("spanB not still going", Spans.NO_MORE_DOCS, spanB.nextDoc());
-      while (spanA.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+    while (spanA.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+      assertNotSame("spanB not still going", SpanScorer.NO_MORE_DOCS, spanB.nextDoc());
+      while (spanA.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
         assertEquals("spanB start position", spanA.startPosition(), spanB.nextStartPosition());
         assertEquals("spanB end position", spanA.endPosition(), spanB.endPosition());
       }
-      assertEquals("spanB start position", Spans.NO_MORE_POSITIONS, spanB.nextStartPosition());
+      assertEquals("spanB start position", SpanScorer.NO_MORE_POSITIONS, spanB.nextStartPosition());
     }
-    assertEquals("spanB end doc", Spans.NO_MORE_DOCS, spanB.nextDoc());
+    assertEquals("spanB end doc", SpanScorer.NO_MORE_DOCS, spanB.nextDoc());
   }
   
   public void testSpans2() throws Exception {
@@ -299,7 +299,7 @@ public class TestFieldMaskingSpanQuery extends LuceneTestCase {
         new FieldMaskingSpanQuery(qB, "id") }, -1, false );
     check(q, new int[] { 0, 1, 2, 3 });
 
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
     assertNext(span, 0,0,1);
     assertNext(span, 1,1,2);
     assertNext(span, 2,0,1);
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestFilterSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestFilterSpans.java
index 239dfbe..45895f7 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestFilterSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestFilterSpans.java
@@ -28,11 +28,13 @@ public class TestFilterSpans extends LuceneTestCase {
 
   @Test
   public void testOverrides() throws Exception {
-    // verify that all methods of Spans are overridden by FilterSpans,
+    // verify that all methods of SpanScorer are overridden by FilterSpanScorer,
     // except those under the 'exclude' list
     Set<Method> exclude = new HashSet<>();
-    for (Method m : FilterSpans.class.getMethods()) {
-      if (m.getDeclaringClass() == Spans.class) {
+    exclude.add(FilterSpanScorer.class.getMethod("freq"));
+    exclude.add(FilterSpanScorer.class.getMethod("score"));
+    for (Method m : FilterSpanScorer.class.getMethods()) {
+      if (m.getDeclaringClass() == SpanScorer.class) {
         assertTrue("method " + m.getName() + " not overridden!", exclude.contains(m));
       }
     }
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
index 0f89e7b..fb868ff 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
@@ -109,7 +109,7 @@ public class TestNearSpansOrdered extends LuceneTestCase {
     CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {0,1});
   }
 
-  public String s(Spans span) {
+  public String s(SpanScorer span) {
     return s(span.docID(), span.startPosition(), span.endPosition());
   }
   public String s(int doc, int start, int end) {
@@ -118,7 +118,7 @@ public class TestNearSpansOrdered extends LuceneTestCase {
   
   public void testNearSpansNext() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
     assertNext(span,0,0,3);
     assertNext(span,1,0,4);
     assertFinished(span);
@@ -131,46 +131,46 @@ public class TestNearSpansOrdered extends LuceneTestCase {
    */
   public void testNearSpansAdvanceLikeNext() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
     assertEquals(0, span.advance(0));
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(0,0,3), s(span));
     assertEquals(1, span.advance(1));
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(1,0,4), s(span));
-    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
+    assertEquals(SpanScorer.NO_MORE_DOCS, span.advance(2));
   }
   
   public void testNearSpansNextThenAdvance() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
-    assertNotSame(Spans.NO_MORE_DOCS, span.nextDoc());
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    assertNotSame(SpanScorer.NO_MORE_DOCS, span.nextDoc());
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(0,0,3), s(span));
-    assertNotSame(Spans.NO_MORE_DOCS, span.advance(1));
+    assertNotSame(SpanScorer.NO_MORE_DOCS, span.advance(1));
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(1,0,4), s(span));
-    assertEquals(Spans.NO_MORE_DOCS, span.nextDoc());
+    assertEquals(SpanScorer.NO_MORE_DOCS, span.nextDoc());
   }
   
   public void testNearSpansNextThenAdvancePast() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
-    assertNotSame(Spans.NO_MORE_DOCS, span.nextDoc());
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    assertNotSame(SpanScorer.NO_MORE_DOCS, span.nextDoc());
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(0,0,3), s(span));
-    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
+    assertEquals(SpanScorer.NO_MORE_DOCS, span.advance(2));
   }
   
   public void testNearSpansAdvancePast() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
-    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    assertEquals(SpanScorer.NO_MORE_DOCS, span.advance(2));
   }
   
   public void testNearSpansAdvanceTo0() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
     assertEquals(0, span.advance(0));
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(0,0,3), s(span));
@@ -178,7 +178,7 @@ public class TestNearSpansOrdered extends LuceneTestCase {
 
   public void testNearSpansAdvanceTo1() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
+    SpanScorer span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
     assertEquals(1, span.advance(1));
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(1,0,4), s(span));
@@ -217,7 +217,7 @@ public class TestNearSpansOrdered extends LuceneTestCase {
         new SpanOrQuery(new SpanTermQuery(new Term(FIELD, "w1")), new SpanTermQuery(new Term(FIELD, "w2"))),
         new SpanTermQuery(new Term(FIELD, "w4"))
     }, 10, true);
-    Spans spans = MultiSpansWrapper.wrap(reader, q);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, q);
     assertNext(spans,0,0,4);
     assertNext(spans,0,1,4);
     assertFinished(spans);
@@ -227,7 +227,7 @@ public class TestNearSpansOrdered extends LuceneTestCase {
     SpanNearQuery q = new SpanNearQuery(new SpanQuery[]{
         new SpanTermQuery(new Term(FIELD, "t1")), new SpanTermQuery(new Term(FIELD, "t2"))
     }, 1, true);
-    Spans spans = MultiSpansWrapper.wrap(reader, q);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, q);
     assertNext(spans,4,0,2);
     assertFinished(spans);
   }
@@ -236,7 +236,7 @@ public class TestNearSpansOrdered extends LuceneTestCase {
     SpanNearQuery q = new SpanNearQuery(new SpanQuery[]{
         new SpanTermQuery(new Term(FIELD, "t2")), new SpanTermQuery(new Term(FIELD, "t1"))
     }, 1, true);
-    Spans spans = MultiSpansWrapper.wrap(reader, q);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, q);
     assertNext(spans,4,1,4);
     assertNext(spans,4,2,4);
     assertFinished(spans);
@@ -260,7 +260,7 @@ public class TestNearSpansOrdered extends LuceneTestCase {
         .addGap(1)
         .addClause(new SpanTermQuery(new Term(FIELD, "w2")))
         .build();
-    Spans spans = MultiSpansWrapper.wrap(reader, q);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, q);
     assertNext(spans, 1, 0, 3);
     assertNext(spans, 2, 0, 3);
     assertFinished(spans);
@@ -285,7 +285,7 @@ public class TestNearSpansOrdered extends LuceneTestCase {
         .addGap(2)
         .addClause(new SpanTermQuery(new Term(FIELD, "g")))
         .build();
-    Spans spans = MultiSpansWrapper.wrap(reader, q);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, q);
     assertNext(spans, 5, 0, 4);
     assertNext(spans, 5, 9, 13);
     assertFinished(spans);
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java
index e12f99d..1314b3c 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java
@@ -95,7 +95,7 @@ public class TestSpanCollection extends LuceneTestCase {
       "w1 w2 w1 w4 w2 w3"
   };
 
-  private void checkCollectedTerms(Spans spans, TermCollector collector, Term... expectedTerms) throws IOException {
+  private void checkCollectedTerms(SpanScorer spans, TermCollector collector, Term... expectedTerms) throws IOException {
     collector.reset();
     spans.collect(collector);
     for (Term t : expectedTerms) {
@@ -119,7 +119,7 @@ public class TestSpanCollection extends LuceneTestCase {
     SpanNearQuery q7 = new SpanNearQuery(new SpanQuery[]{q1, q6}, 1, true);
 
     TermCollector collector = new TermCollector();
-    Spans spans = MultiSpansWrapper.wrap(reader, q7, SpanWeight.Postings.POSITIONS);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, q7, SpanWeight.Postings.POSITIONS);
     assertEquals(0, spans.advance(0));
     spans.nextStartPosition();
     checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"));
@@ -139,7 +139,7 @@ public class TestSpanCollection extends LuceneTestCase {
     SpanOrQuery orQuery = new SpanOrQuery(q2, q3);
 
     TermCollector collector = new TermCollector();
-    Spans spans = MultiSpansWrapper.wrap(reader, orQuery, SpanWeight.Postings.POSITIONS);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, orQuery, SpanWeight.Postings.POSITIONS);
 
     assertEquals(1, spans.advance(1));
     spans.nextStartPosition();
@@ -169,7 +169,7 @@ public class TestSpanCollection extends LuceneTestCase {
     SpanNotQuery notq = new SpanNotQuery(nq, q3);
 
     TermCollector collector = new TermCollector();
-    Spans spans = MultiSpansWrapper.wrap(reader, notq, SpanWeight.Postings.POSITIONS);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, notq, SpanWeight.Postings.POSITIONS);
 
     assertEquals(2, spans.advance(2));
     spans.nextStartPosition();
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanContainQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanContainQuery.java
index a27eb78..9b21b04 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanContainQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanContainQuery.java
@@ -70,21 +70,21 @@ public class TestSpanContainQuery extends LuceneTestCase {
     CheckHits.checkHits(random(), query, field, searcher, results);
   }
 
-  Spans makeSpans(SpanQuery sq) throws Exception {
+  SpanScorer makeSpans(SpanQuery sq) throws Exception {
     return MultiSpansWrapper.wrap(searcher.getIndexReader(), sq);
   }
 
   void tstEqualSpans(String mes, SpanQuery expectedQ, SpanQuery actualQ) throws Exception {
-    Spans expected = makeSpans(expectedQ);
-    Spans actual = makeSpans(actualQ);
+    SpanScorer expected = makeSpans(expectedQ);
+    SpanScorer actual = makeSpans(actualQ);
     tstEqualSpans(mes, expected, actual);
   }
 
-  void tstEqualSpans(String mes, Spans expected, Spans actual) throws Exception {
-    while (expected.nextDoc() != Spans.NO_MORE_DOCS) {
+  void tstEqualSpans(String mes, SpanScorer expected, SpanScorer actual) throws Exception {
+    while (expected.nextDoc() != SpanScorer.NO_MORE_DOCS) {
       assertEquals(expected.docID(), actual.nextDoc());
       assertEquals(expected.docID(), actual.docID());
-      while (expected.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+      while (expected.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
         assertEquals(expected.startPosition(), actual.nextStartPosition());
         assertEquals("start", expected.startPosition(), actual.startPosition());
         assertEquals("end", expected.endPosition(), actual.endPosition());
@@ -108,7 +108,7 @@ public class TestSpanContainQuery extends LuceneTestCase {
     SpanQuery containingPhraseOr = spanContainingQuery(phraseQ, w23);
     SpanQuery containedPhraseOr = spanWithinQuery(phraseQ, w23);
     tstEqualSpans("containing phrase or", phraseQ, containingPhraseOr);
-    Spans spans = makeSpans(containedPhraseOr);
+    SpanScorer spans = makeSpans(containedPhraseOr);
     assertNext(spans,0,1,2);
     assertNext(spans,0,2,3);
     assertNext(spans,1,2,3);
@@ -124,7 +124,7 @@ public class TestSpanContainQuery extends LuceneTestCase {
     SpanQuery containingPhraseW2 = spanContainingQuery(phraseQ, stqw2);
     SpanQuery containedPhraseW2 = spanWithinQuery(phraseQ, stqw2);
     tstEqualSpans("containing phrase w2", phraseQ, containingPhraseW2);
-    Spans spans = makeSpans(containedPhraseW2);
+    SpanScorer spans = makeSpans(containedPhraseW2);
     assertNext(spans,0,1,2);
     assertNext(spans,1,2,3);
     assertFinished(spans);
@@ -138,7 +138,7 @@ public class TestSpanContainQuery extends LuceneTestCase {
     SpanQuery containingPhraseW3 = spanContainingQuery(phraseQ, stqw3);
     SpanQuery containedPhraseW3 = spanWithinQuery(phraseQ, stqw3);
     tstEqualSpans("containing phrase w3", phraseQ, containingPhraseW3);
-    Spans spans = makeSpans(containedPhraseW3);
+    SpanScorer spans = makeSpans(containedPhraseW3);
     assertNext(spans,0,2,3);
     assertNext(spans,1,3,4);
     assertFinished(spans);
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
index 200fdec..db2336a 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
@@ -190,7 +190,7 @@ public class TestSpans extends LuceneTestCase {
   public void testSpanNearOrderedOverlap() throws Exception {
     final SpanQuery query = spanNearOrderedQuery(field, 1, "t1", "t2", "t3");
     
-    Spans spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), query);
+    SpanScorer spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), query);
 
     assertEquals("first doc", 11, spans.nextDoc());
     assertEquals("first start", 0, spans.nextStartPosition());
@@ -205,7 +205,7 @@ public class TestSpans extends LuceneTestCase {
   public void testSpanNearUnOrdered() throws Exception {
     //See http://www.gossamer-threads.com/lists/lucene/java-dev/52270 for discussion about this test
     SpanQuery senq = spanNearUnorderedQuery(field, 0, "u1", "u2");
-    Spans spans = MultiSpansWrapper.wrap(reader, senq);
+    SpanScorer spans = MultiSpansWrapper.wrap(reader, senq);
     assertNext(spans, 4, 1, 3);
     assertNext(spans, 5, 2, 4);
     assertNext(spans, 8, 2, 4);
@@ -227,23 +227,23 @@ public class TestSpans extends LuceneTestCase {
     assertFinished(spans);
   }
 
-  private Spans orSpans(String[] terms) throws Exception {
+  private SpanScorer orSpans(String[] terms) throws Exception {
     return MultiSpansWrapper.wrap(searcher.getIndexReader(), spanOrQuery(field, terms));
   }
 
   public void testSpanOrEmpty() throws Exception {
-    Spans spans = orSpans(new String[0]);
+    SpanScorer spans = orSpans(new String[0]);
     assertFinished(spans);
   }
 
   public void testSpanOrSingle() throws Exception {
-    Spans spans = orSpans(new String[] {"w5"});
+    SpanScorer spans = orSpans(new String[] {"w5"});
     assertNext(spans, 0, 4, 5);
     assertFinished(spans);
   }
   
   public void testSpanOrDouble() throws Exception {
-    Spans spans = orSpans(new String[] {"w5", "yy"});
+    SpanScorer spans = orSpans(new String[] {"w5", "yy"});
     assertNext(spans, 0, 4, 5);
     assertNext(spans, 2, 3, 4);
     assertNext(spans, 3, 4, 5);
@@ -252,7 +252,7 @@ public class TestSpans extends LuceneTestCase {
   }
 
   public void testSpanOrDoubleAdvance() throws Exception {
-    Spans spans = orSpans(new String[] {"w5", "yy"});
+    SpanScorer spans = orSpans(new String[] {"w5", "yy"});
     assertEquals("initial advance", 3, spans.advance(3));
     assertNext(spans, 3, 4, 5);
     assertNext(spans, 7, 3, 4);
@@ -260,7 +260,7 @@ public class TestSpans extends LuceneTestCase {
   }
 
   public void testSpanOrUnused() throws Exception {
-    Spans spans = orSpans(new String[] {"w5", "unusedTerm", "yy"});
+    SpanScorer spans = orSpans(new String[] {"w5", "unusedTerm", "yy"});
     assertNext(spans, 0, 4, 5);
     assertNext(spans, 2, 3, 4);
     assertNext(spans, 3, 4, 5);
@@ -269,7 +269,7 @@ public class TestSpans extends LuceneTestCase {
   }
 
   public void testSpanOrTripleSameDoc() throws Exception {
-    Spans spans = orSpans(new String[] {"t1", "t2", "t3"});
+    SpanScorer spans = orSpans(new String[] {"t1", "t2", "t3"});
     assertNext(spans, 11, 0, 1);
     assertNext(spans, 11, 1, 2);
     assertNext(spans, 11, 2, 3);
@@ -414,12 +414,12 @@ public class TestSpans extends LuceneTestCase {
      SpanQuery iq = spanTermQuery(field, include);
      SpanQuery eq = spanTermQuery(field, exclude);
      SpanQuery snq = spanNotQuery(iq, eq, pre, post);
-     Spans spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), snq);
+     SpanScorer spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), snq);
 
      int i = 0;
      if (spans != null) {
-       while (spans.nextDoc() != Spans.NO_MORE_DOCS){
-         while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+       while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS){
+         while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
            i++;
          }
        }
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java
index adb3edc..845a7a1 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java
@@ -37,7 +37,7 @@ import org.junit.BeforeClass;
 import static org.apache.lucene.search.spans.SpanTestUtil.*;
 
 /**
- * Tests Spans (v2)
+ * Tests SpanScorer (v2)
  *
  */
 public class TestSpansEnum extends LuceneTestCase {
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/PositionSpan.java b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/PositionSpan.java
index 355ec6c..9c4cd50 100644
--- a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/PositionSpan.java
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/PositionSpan.java
@@ -17,7 +17,7 @@ package org.apache.lucene.search.highlight;
  */
 
 /**
- * Utility class to record Positions Spans
+ * Utility class to record Positions SpanScorer
  * @lucene.internal
  */
 public class PositionSpan {
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/SimpleSpanFragmenter.java b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/SimpleSpanFragmenter.java
index 4ca4bb2..4e0b8da 100644
--- a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/SimpleSpanFragmenter.java
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/SimpleSpanFragmenter.java
@@ -23,12 +23,12 @@ import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.search.spans.SpanScorer;
 
 
 /**
  * {@link Fragmenter} implementation which breaks text up into same-size
- * fragments but does not split up {@link Spans}. This is a simple sample class.
+ * fragments but does not split up {@link SpanScorer}. This is a simple sample class.
  */
 public class SimpleSpanFragmenter implements Fragmenter {
   private static final int DEFAULT_FRAGMENT_SIZE = 100;
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
index 4cd4566..585ec93 100644
--- a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
@@ -63,9 +63,9 @@ import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanNotQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.IOUtils;
 
@@ -286,17 +286,17 @@ public class WeightedSpanTermExtractor {
       LeafReaderContext context = getLeafContext();
       SpanWeight w = (SpanWeight) searcher.createNormalizedWeight(q, false);
       Bits acceptDocs = context.reader().getLiveDocs();
-      final Spans spans = w.getSpans(context, SpanWeight.Postings.POSITIONS);
+      final SpanScorer spans = w.getSpanScorer(context, SpanWeight.Postings.POSITIONS);
       if (spans == null) {
         return;
       }
 
       // collect span positions
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+      while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
         if (acceptDocs != null && acceptDocs.get(spans.docID()) == false) {
           continue;
         }
-        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+        while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
           spanPositions.add(new PositionSpan(spans.startPosition(), spans.endPosition() - 1));
         }
       }
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadFunction.java b/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadFunction.java
index 2a56122..8d22596 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadFunction.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadFunction.java
@@ -17,6 +17,7 @@ package org.apache.lucene.queries.payloads;
  */
 
 import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.spans.SpanScorer;
 
 /**
  * An abstract class that defines a way for PayloadScoreQuery instances to transform
@@ -41,7 +42,7 @@ public abstract class PayloadFunction {
    * @param currentPayloadScore The score for the current payload
    * @return The new current Score
    *
-   * @see org.apache.lucene.search.spans.Spans
+   * @see SpanScorer
    */
   public abstract float currentScore(int docId, String field, int start, int end, int numPayloadsSeen, float currentScore, float currentPayloadScore);
 
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadScoreQuery.java b/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadScoreQuery.java
index 3ba3503..bb8efee 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadScoreQuery.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadScoreQuery.java
@@ -32,9 +32,8 @@ import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.spans.SpanCollector;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.util.BytesRef;
 
 /**
@@ -116,13 +115,13 @@ public class PayloadScoreQuery extends SpanQuery {
     }
 
     @Override
-    public Spans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
-      return innerWeight.getSpans(ctx, requiredPostings.atLeast(Postings.PAYLOADS));
+    public SpanScorer getSpanScorer(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
+      return innerWeight.getSpanScorer(ctx, requiredPostings.atLeast(Postings.PAYLOADS));
     }
 
     @Override
     public Scorer scorer(LeafReaderContext context) throws IOException {
-      Spans spans = getSpans(context, Postings.PAYLOADS);
+      SpanScorer spans = getSpanScorer(context, Postings.PAYLOADS);
       if (spans == null)
         return null;
       return new PayloadSpanScorer(spans, this, innerWeight.getSimScorer(context));
@@ -162,9 +161,36 @@ public class PayloadScoreQuery extends SpanQuery {
 
     private int payloadsSeen;
     private float payloadScore;
+    private final SpanScorer in;
+
+    private PayloadSpanScorer(SpanScorer spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
+      super(weight, docScorer);
+      this.in = spans;
+    }
 
-    private PayloadSpanScorer(Spans spans, SpanWeight weight, Similarity.SimScorer docScorer) throws IOException {
-      super(spans, weight, docScorer);
+    @Override
+    public int nextStartPosition() throws IOException {
+      return in.nextStartPosition();
+    }
+
+    @Override
+    public int startPosition() {
+      return in.startPosition();
+    }
+
+    @Override
+    public int endPosition() {
+      return in.endPosition();
+    }
+
+    @Override
+    public int width() {
+      return in.width();
+    }
+
+    @Override
+    public void collect(SpanCollector collector) throws IOException {
+      in.collect(collector);
     }
 
     @Override
@@ -175,7 +201,7 @@ public class PayloadScoreQuery extends SpanQuery {
 
     @Override
     protected void doCurrentSpans() throws IOException {
-      spans.collect(this);
+      in.collect(this);
     }
 
     @Override
@@ -183,8 +209,8 @@ public class PayloadScoreQuery extends SpanQuery {
       BytesRef payload = postings.getPayload();
       if (payload == null)
         return;
-      float payloadFactor = docScorer.computePayloadFactor(docID(), spans.startPosition(), spans.endPosition(), payload);
-      payloadScore = function.currentScore(docID(), getField(), spans.startPosition(), spans.endPosition(),
+      float payloadFactor = docScorer.computePayloadFactor(docID(), in.startPosition(), in.endPosition(), payload);
+      payloadScore = function.currentScore(docID(), getField(), in.startPosition(), in.endPosition(),
                                             payloadsSeen, payloadScore, payloadFactor);
       payloadsSeen++;
     }
@@ -210,6 +236,26 @@ public class PayloadScoreQuery extends SpanQuery {
     public void reset() {
 
     }
+
+    @Override
+    public int docID() {
+      return in.docID();
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      return in.nextDoc();
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      return in.advance(target);
+    }
+
+    @Override
+    public long cost() {
+      return in.cost();
+    }
   }
 
 }
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/payloads/SpanPayloadCheckQuery.java b/lucene/queries/src/java/org/apache/lucene/queries/payloads/SpanPayloadCheckQuery.java
index f0f43f6..f79cdcf 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/payloads/SpanPayloadCheckQuery.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/payloads/SpanPayloadCheckQuery.java
@@ -28,14 +28,12 @@ import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Scorer;
-import org.apache.lucene.search.similarities.Similarity;
-import org.apache.lucene.search.spans.FilterSpans;
-import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
+import org.apache.lucene.search.spans.FilterSpanScorer;
+import org.apache.lucene.search.spans.FilterSpanScorer.AcceptStatus;
 import org.apache.lucene.search.spans.SpanCollector;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.util.BytesRef;
 
 /**
@@ -67,7 +65,7 @@ public class SpanPayloadCheckQuery extends SpanQuery {
   }
 
   /**
-   * Weight that pulls its Spans using a PayloadSpanCollector
+   * Weight that pulls its SpanScorer using a PayloadSpanCollector
    */
   public class SpanPayloadCheckWeight extends SpanWeight {
 
@@ -89,12 +87,12 @@ public class SpanPayloadCheckQuery extends SpanQuery {
     }
 
     @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+    public SpanScorer getSpanScorer(final LeafReaderContext context, Postings requiredPostings) throws IOException {
       final PayloadChecker collector = new PayloadChecker();
-      Spans matchSpans = matchWeight.getSpans(context, requiredPostings.atLeast(Postings.PAYLOADS));
-      return (matchSpans == null) ? null : new FilterSpans(matchSpans) {
+      SpanScorer matchSpans = matchWeight.getSpanScorer(context, requiredPostings.atLeast(Postings.PAYLOADS));
+      return (matchSpans == null) ? null : new FilterSpanScorer(matchSpans) {
         @Override
-        protected AcceptStatus accept(Spans candidate) throws IOException {
+        protected AcceptStatus accept(SpanScorer candidate) throws IOException {
           collector.reset();
           candidate.collect(collector);
           return collector.match();
@@ -112,9 +110,7 @@ public class SpanPayloadCheckQuery extends SpanQuery {
         throw new IllegalStateException("field \"" + field + "\" was indexed without position data; cannot run SpanQuery (query=" + parentQuery + ")");
       }
 
-      Spans spans = getSpans(context, Postings.PAYLOADS);
-      Similarity.SimScorer simScorer = simWeight == null ? null : similarity.simScorer(simWeight, context);
-      return (spans == null) ? null : new SpanScorer(spans, this, simScorer);
+      return getSpanScorer(context, Postings.PAYLOADS);
     }
   }
 
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadSpans.java b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadSpans.java
index ec39d54..3cf655f 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadSpans.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadSpans.java
@@ -48,9 +48,9 @@ import org.apache.lucene.search.spans.SpanFirstQuery;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanNotQuery;
 import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
@@ -72,7 +72,7 @@ public class TestPayloadSpans extends LuceneTestCase {
 
   public void testSpanTermQuery() throws Exception {
     SpanTermQuery stq;
-    Spans spans;
+    SpanScorer spans;
     stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "seventy"));
 
     spans = MultiSpansWrapper.wrap(indexReader, stq, SpanWeight.Postings.PAYLOADS);
@@ -91,7 +91,7 @@ public class TestPayloadSpans extends LuceneTestCase {
     SpanFirstQuery sfq;
     match = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
     sfq = new SpanFirstQuery(match, 2);
-    Spans spans = MultiSpansWrapper.wrap(indexReader, sfq, SpanWeight.Postings.PAYLOADS);
+    SpanScorer spans = MultiSpansWrapper.wrap(indexReader, sfq, SpanWeight.Postings.PAYLOADS);
     checkSpans(spans, 109, 1, 1, 1);
     //Test more complicated subclause
     SpanQuery[] clauses = new SpanQuery[2];
@@ -133,7 +133,7 @@ public class TestPayloadSpans extends LuceneTestCase {
   
   public void testNestedSpans() throws Exception {
     SpanTermQuery stq;
-    Spans spans;
+    SpanScorer spans;
     IndexSearcher searcher = getSearcher();
 
     stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "mark"));
@@ -187,7 +187,7 @@ public class TestPayloadSpans extends LuceneTestCase {
   }
   
   public void testFirstClauseWithoutPayload() throws Exception {
-    Spans spans;
+    SpanScorer spans;
     IndexSearcher searcher = getSearcher();
 
     SpanQuery[] clauses = new SpanQuery[3];
@@ -219,7 +219,7 @@ public class TestPayloadSpans extends LuceneTestCase {
   }
   
   public void testHeavilyNestedSpanQuery() throws Exception {
-    Spans spans;
+    SpanScorer spans;
     IndexSearcher searcher = getSearcher();
 
     SpanQuery[] clauses = new SpanQuery[3];
@@ -273,13 +273,13 @@ public class TestPayloadSpans extends LuceneTestCase {
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 1, true);
     VerifyingCollector collector = new VerifyingCollector();
-    Spans spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
+    SpanScorer spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
     for (int i = 0; i < topDocs.scoreDocs.length; i++) {
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+      while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+        while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
           collector.reset();
           spans.collect(collector);
           for (final BytesRef payload : collector.payloads) {
@@ -312,13 +312,13 @@ public class TestPayloadSpans extends LuceneTestCase {
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
     VerifyingCollector collector = new VerifyingCollector();
-    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
+    SpanScorer spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
     for (int i = 0; i < topDocs.scoreDocs.length; i++) {
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+      while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+        while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
           collector.reset();
           spans.collect(collector);
           for (final BytesRef payload: collector.payloads) {
@@ -350,14 +350,14 @@ public class TestPayloadSpans extends LuceneTestCase {
     SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
-    Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
+    SpanScorer spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq, SpanWeight.Postings.PAYLOADS);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
     VerifyingCollector collector = new VerifyingCollector();
     for (int i = 0; i < topDocs.scoreDocs.length; i++) {
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-        while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+      while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+        while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
           collector.reset();
           spans.collect(collector);
           for (final BytesRef payload : collector.payloads) {
@@ -402,15 +402,15 @@ public class TestPayloadSpans extends LuceneTestCase {
     }
   }
 
-  private void checkSpans(Spans spans, int expectedNumSpans, int expectedNumPayloads,
+  private void checkSpans(SpanScorer spans, int expectedNumSpans, int expectedNumPayloads,
                           int expectedPayloadLength, int expectedFirstByte) throws IOException {
     assertTrue("spans is null and it shouldn't be", spans != null);
     //each position match should have a span associated with it, since there is just one underlying term query, there should
     //only be one entry in the span
     VerifyingCollector collector = new VerifyingCollector();
     int seen = 0;
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-      while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+    while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
         collector.reset();
         spans.collect(collector);
         collector.verify(expectedPayloadLength, expectedFirstByte);
@@ -443,13 +443,13 @@ public class TestPayloadSpans extends LuceneTestCase {
     return searcher;
   }
   
-  private void checkSpans(Spans spans, int numSpans, int[] numPayloads) throws IOException {
+  private void checkSpans(SpanScorer spans, int numSpans, int[] numPayloads) throws IOException {
     int cnt = 0;
     VerifyingCollector collector = new VerifyingCollector();
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-      while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+    while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
         if(VERBOSE)
-          System.out.println("\nSpans Dump --");
+          System.out.println("\nSpanScorer Dump --");
         collector.reset();
         spans.collect(collector);
         assertEquals("payload size", numPayloads[cnt], collector.payloads.size());
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java
index aaf3e0a..ea99f3e 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java
@@ -41,8 +41,8 @@ import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.spans.MultiSpansWrapper;
 import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.English;
@@ -164,7 +164,7 @@ public class TestPayloadTermQuery extends LuceneTestCase {
       assertTrue(doc.score + " does not equal: " + 1, doc.score == 1);
     }
     CheckHits.checkExplanations(query, PayloadHelper.FIELD, searcher, true);
-    Spans spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), query);
+    SpanScorer spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), query);
     assertTrue("spans is null and it shouldn't be", spans != null);
     /*float score = hits.score(0);
     for (int i =1; i < hits.length(); i++)
@@ -215,13 +215,13 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     }
     assertTrue(numTens + " does not equal: " + 10, numTens == 10);
     CheckHits.checkExplanations(query, "field", searcher, true);
-    Spans spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), query);
+    SpanScorer spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), query);
     assertTrue("spans is null and it shouldn't be", spans != null);
     //should be two matches per document
     int count = 0;
     //100 hits times 2 matches per hit, we should have 200 in count
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-      while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+    while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
         count++;
       }
     }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanUtil.java b/lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanUtil.java
index 20b120d..de24a43 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanUtil.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanUtil.java
@@ -38,9 +38,9 @@ import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanScorer;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
 
 /**
  * Experimental class to get set of payloads for most standard Lucene queries.
@@ -176,10 +176,10 @@ public class PayloadSpanUtil {
 
     PayloadSpanCollector collector = new PayloadSpanCollector();
     for (LeafReaderContext leafReaderContext : context.leaves()) {
-      final Spans spans = w.getSpans(leafReaderContext, SpanWeight.Postings.PAYLOADS);
+      final SpanScorer spans = w.getSpanScorer(leafReaderContext, SpanWeight.Postings.PAYLOADS);
       if (spans != null) {
-        while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
-          while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+        while (spans.nextDoc() != SpanScorer.NO_MORE_DOCS) {
+          while (spans.nextStartPosition() != SpanScorer.NO_MORE_POSITIONS) {
             collector.reset();
             spans.collect(collector);
             payloads.addAll(collector.getPayloads());
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanScorer.java b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanScorer.java
new file mode 100644
index 0000000..e8820ff
--- /dev/null
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanScorer.java
@@ -0,0 +1,281 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.similarities.Similarity;
+
+/** 
+ * Wraps a SpanScorer with additional asserts
+ */
+class AssertingSpanScorer extends SpanScorer {
+  final SpanScorer in;
+  int doc = -1;
+  
+  /** 
+   * tracks current state of this spans
+   */
+  static enum State { 
+    /**
+     * document iteration has not yet begun ({@link #docID()} = -1) 
+     */
+    DOC_START,
+    
+    /**
+     * two-phase iterator has moved to a new docid, but {@link TwoPhaseIterator#matches()} has
+     * not been called or it returned false (so you should not do things with the enum)
+     */
+    DOC_UNVERIFIED,
+    
+    /**
+     * iterator set to a valid docID, but position iteration has not yet begun ({@link #startPosition() == -1})
+     */
+    POS_START,
+    
+    /**
+     * iterator set to a valid docID, and positioned (-1 < {@link #startPosition()} < {@link #NO_MORE_POSITIONS})
+     */
+    ITERATING,
+    
+    /**
+     * positions exhausted ({@link #startPosition()} = {@link #NO_MORE_POSITIONS})
+     */
+    POS_FINISHED,
+    
+    /** 
+     * documents exhausted ({@link #docID()} = {@link #NO_MORE_DOCS}) 
+     */
+    DOC_FINISHED 
+  };
+  
+  State state = State.DOC_START;
+  
+  AssertingSpanScorer(SpanScorer in, Similarity.SimScorer docScorer) {
+    super((SpanWeight)in.getWeight(), docScorer);
+    this.in = in;
+  }
+  
+  @Override
+  public int nextStartPosition() throws IOException {
+    assert state != State.DOC_START : "invalid position access, state=" + state + ": " + in;
+    assert state != State.DOC_FINISHED : "invalid position access, state=" + state + ": " + in;
+    assert state != State.DOC_UNVERIFIED : "invalid position access, state=" + state + ": " + in;
+    
+    checkCurrentPositions();
+    
+    // move to next position
+    int prev = in.startPosition();
+    int start = in.nextStartPosition();
+    assert start >= prev : "invalid startPosition (positions went backwards, previous=" + prev + "): " + in;
+    
+    // transition state if necessary
+    if (start == NO_MORE_POSITIONS) {
+      state = State.POS_FINISHED;
+    } else {
+      state = State.ITERATING;
+    }
+    
+    // check new positions
+    checkCurrentPositions();
+    return start;
+  }
+  
+  private void checkCurrentPositions() {    
+    int start = in.startPosition();
+    int end = in.endPosition();
+    
+    if (state == State.DOC_START || state == State.DOC_UNVERIFIED || state == State.POS_START) {
+      assert start == -1 : "invalid startPosition (should be -1): " + in;
+      assert end == -1 : "invalid endPosition (should be -1): " + in;
+    } else if (state == State.POS_FINISHED) {
+      assert start == NO_MORE_POSITIONS : "invalid startPosition (should be NO_MORE_POSITIONS): " + in;
+      assert end == NO_MORE_POSITIONS : "invalid endPosition (should be NO_MORE_POSITIONS): " + in;
+    } else {
+      assert start >= 0 : "invalid startPosition (negative): " + in;
+      assert start <= end : "invalid startPosition (> endPosition): " + in;
+    }    
+  }
+  
+  @Override
+  public int startPosition() {
+    checkCurrentPositions();
+    return in.startPosition();
+  }
+  
+  @Override
+  public int endPosition() {
+    checkCurrentPositions();
+    return in.endPosition();
+  }
+
+  @Override
+  public int width() {
+    assert state == State.ITERATING;
+    final int distance = in.width();
+    assert distance >= 0;
+    return distance;
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    assert state == State.ITERATING : "collect() called in illegal state: " + state + ": " + in;
+    in.collect(collector);
+  }
+
+  @Override
+  public int docID() {
+    int doc = in.docID();
+    assert doc == this.doc : "broken docID() impl: docID() = " + doc + ", but next/advance last returned: " + this.doc + ": " + in;
+    return doc;
+  }
+  
+  @Override
+  public int nextDoc() throws IOException {
+    assert state != State.DOC_FINISHED : "nextDoc() called after NO_MORE_DOCS: " + in;
+    int nextDoc = in.nextDoc();
+    assert nextDoc > doc : "backwards nextDoc from " + doc + " to " + nextDoc + ": " + in;
+    if (nextDoc == DocIdSetIterator.NO_MORE_DOCS) {
+      state = State.DOC_FINISHED;
+    } else {
+      assert in.startPosition() == -1 : "invalid initial startPosition() [should be -1]: " + in;
+      assert in.endPosition() == -1 : "invalid initial endPosition() [should be -1]: " + in;
+      state = State.POS_START;
+    }
+    doc = nextDoc;
+    return docID();
+  }
+  
+  @Override
+  public int advance(int target) throws IOException {
+    assert state != State.DOC_FINISHED : "advance() called after NO_MORE_DOCS: " + in;
+    assert target > doc : "target must be > docID(), got " + target + " <= " + doc + ": " + in;
+    int advanced = in.advance(target);
+    assert advanced >= target : "backwards advance from: " + target + " to: " + advanced + ": " + in;
+    if (advanced == DocIdSetIterator.NO_MORE_DOCS) {
+      state = State.DOC_FINISHED;
+    } else {
+      assert in.startPosition() == -1 : "invalid initial startPosition() [should be -1]: " + in;
+      assert in.endPosition() == -1 : "invalid initial endPosition() [should be -1]: " + in;
+      state = State.POS_START;
+    }
+    doc = advanced;
+    return docID();
+  }
+  
+  @Override
+  public String toString() {
+    return "Asserting(" + in + ")";
+  }
+
+  @Override
+  public long cost() {
+    return in.cost();
+  }
+
+  @Override
+  protected float scoreCurrentDoc() throws IOException {
+    assert in.docScorer != null : in.getClass() + " has no docScorer!";
+    return in.scoreCurrentDoc();
+  }
+
+  @Override
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    final TwoPhaseIterator iterator = in.asTwoPhaseIterator();
+    if (iterator == null) {
+      return null;
+    }
+    return new AssertingTwoPhaseView(iterator);
+  }
+
+  class AssertingTwoPhaseView extends TwoPhaseIterator {
+    final TwoPhaseIterator in;
+    int lastDoc = -1;
+    
+    AssertingTwoPhaseView(TwoPhaseIterator iterator) {
+      super(new AssertingDISI(iterator.approximation()));
+      this.in = iterator;
+    }
+    
+    @Override
+    public boolean matches() throws IOException {
+      if (approximation.docID() == -1 || approximation.docID() == DocIdSetIterator.NO_MORE_DOCS) {
+        throw new AssertionError("matches() should not be called on doc ID " + approximation.docID());
+      }
+      if (lastDoc == approximation.docID()) {
+        throw new AssertionError("matches() has been called twice on doc ID " + approximation.docID());
+      }
+      lastDoc = approximation.docID();
+      boolean v = in.matches();
+      if (v) {
+        state = State.POS_START;
+      }
+      return v;
+    }
+  }
+  
+  class AssertingDISI extends DocIdSetIterator {
+    final DocIdSetIterator in;
+    
+    AssertingDISI(DocIdSetIterator in) {
+      this.in = in;
+    }
+    
+    @Override
+    public int docID() {
+      assert in.docID() == AssertingSpanScorer.this.docID();
+      return in.docID();
+    }
+    
+    @Override
+    public int nextDoc() throws IOException {
+      assert state != State.DOC_FINISHED : "nextDoc() called after NO_MORE_DOCS: " + in;
+      int nextDoc = in.nextDoc();
+      assert nextDoc > doc : "backwards nextDoc from " + doc + " to " + nextDoc + ": " + in;
+      if (nextDoc == DocIdSetIterator.NO_MORE_DOCS) {
+        state = State.DOC_FINISHED;
+      } else {
+        state = State.DOC_UNVERIFIED;
+      }
+      doc = nextDoc;
+      return docID();
+    }
+    
+    @Override
+    public int advance(int target) throws IOException {
+      assert state != State.DOC_FINISHED : "advance() called after NO_MORE_DOCS: " + in;
+      assert target > doc : "target must be > docID(), got " + target + " <= " + doc + ": " + in;
+      int advanced = in.advance(target);
+      assert advanced >= target : "backwards advance from: " + target + " to: " + advanced + ": " + in;
+      if (advanced == DocIdSetIterator.NO_MORE_DOCS) {
+        state = State.DOC_FINISHED;
+      } else {
+        state = State.DOC_UNVERIFIED;
+      }
+      doc = advanced;
+      return docID();
+    }
+    
+    @Override
+    public long cost() {
+      return in.cost();
+    }
+  }
+}
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java
index 5c8197d..b5f30b4 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java
@@ -17,16 +17,17 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.Map;
+import java.util.Set;
+
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Scorer;
-
-import java.io.IOException;
-import java.util.Map;
-import java.util.Set;
+import org.apache.lucene.search.similarities.Similarity;
 
 /**
  * Wraps a SpanWeight with additional asserts
@@ -51,11 +52,16 @@ public class AssertingSpanWeight extends SpanWeight {
   }
 
   @Override
-  public Spans getSpans(LeafReaderContext context, Postings requiredPostings) throws IOException {
-    Spans spans = in.getSpans(context, requiredPostings);
+  public SpanScorer getSpanScorer(LeafReaderContext context, Postings requiredPostings) throws IOException {
+    SpanScorer spans = in.getSpanScorer(context, requiredPostings);
     if (spans == null)
       return null;
-    return new AssertingSpans(spans);
+    return new AssertingSpanScorer(spans, in.getSimScorer(context));
+  }
+
+  @Override
+  public Similarity.SimScorer getSimScorer(LeafReaderContext context) throws IOException {
+    return in.getSimScorer(context);
   }
 
   @Override
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java
deleted file mode 100644
index 4b9ff90..0000000
--- a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java
+++ /dev/null
@@ -1,273 +0,0 @@
-package org.apache.lucene.search.spans;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.search.TwoPhaseIterator;
-
-import java.io.IOException;
-
-/** 
- * Wraps a Spans with additional asserts 
- */
-class AssertingSpans extends Spans {
-  final Spans in;
-  int doc = -1;
-  
-  /** 
-   * tracks current state of this spans
-   */
-  static enum State { 
-    /**
-     * document iteration has not yet begun ({@link #docID()} = -1) 
-     */
-    DOC_START,
-    
-    /**
-     * two-phase iterator has moved to a new docid, but {@link TwoPhaseIterator#matches()} has
-     * not been called or it returned false (so you should not do things with the enum)
-     */
-    DOC_UNVERIFIED,
-    
-    /**
-     * iterator set to a valid docID, but position iteration has not yet begun ({@link #startPosition() == -1})
-     */
-    POS_START,
-    
-    /**
-     * iterator set to a valid docID, and positioned (-1 < {@link #startPosition()} < {@link #NO_MORE_POSITIONS})
-     */
-    ITERATING,
-    
-    /**
-     * positions exhausted ({@link #startPosition()} = {@link #NO_MORE_POSITIONS})
-     */
-    POS_FINISHED,
-    
-    /** 
-     * documents exhausted ({@link #docID()} = {@link #NO_MORE_DOCS}) 
-     */
-    DOC_FINISHED 
-  };
-  
-  State state = State.DOC_START;
-  
-  AssertingSpans(Spans in) {
-    this.in = in;
-  }
-  
-  @Override
-  public int nextStartPosition() throws IOException {
-    assert state != State.DOC_START : "invalid position access, state=" + state + ": " + in;
-    assert state != State.DOC_FINISHED : "invalid position access, state=" + state + ": " + in;
-    assert state != State.DOC_UNVERIFIED : "invalid position access, state=" + state + ": " + in;
-    
-    checkCurrentPositions();
-    
-    // move to next position
-    int prev = in.startPosition();
-    int start = in.nextStartPosition();
-    assert start >= prev : "invalid startPosition (positions went backwards, previous=" + prev + "): " + in;
-    
-    // transition state if necessary
-    if (start == NO_MORE_POSITIONS) {
-      state = State.POS_FINISHED;
-    } else {
-      state = State.ITERATING;
-    }
-    
-    // check new positions
-    checkCurrentPositions();
-    return start;
-  }
-  
-  private void checkCurrentPositions() {    
-    int start = in.startPosition();
-    int end = in.endPosition();
-    
-    if (state == State.DOC_START || state == State.DOC_UNVERIFIED || state == State.POS_START) {
-      assert start == -1 : "invalid startPosition (should be -1): " + in;
-      assert end == -1 : "invalid endPosition (should be -1): " + in;
-    } else if (state == State.POS_FINISHED) {
-      assert start == NO_MORE_POSITIONS : "invalid startPosition (should be NO_MORE_POSITIONS): " + in;
-      assert end == NO_MORE_POSITIONS : "invalid endPosition (should be NO_MORE_POSITIONS): " + in;
-    } else {
-      assert start >= 0 : "invalid startPosition (negative): " + in;
-      assert start <= end : "invalid startPosition (> endPosition): " + in;
-    }    
-  }
-  
-  @Override
-  public int startPosition() {
-    checkCurrentPositions();
-    return in.startPosition();
-  }
-  
-  @Override
-  public int endPosition() {
-    checkCurrentPositions();
-    return in.endPosition();
-  }
-
-  @Override
-  public int width() {
-    assert state == State.ITERATING;
-    final int distance = in.width();
-    assert distance >= 0;
-    return distance;
-  }
-
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    assert state == State.ITERATING : "collect() called in illegal state: " + state + ": " + in;
-    in.collect(collector);
-  }
-
-  @Override
-  public int docID() {
-    int doc = in.docID();
-    assert doc == this.doc : "broken docID() impl: docID() = " + doc + ", but next/advance last returned: " + this.doc + ": " + in;
-    return doc;
-  }
-  
-  @Override
-  public int nextDoc() throws IOException {
-    assert state != State.DOC_FINISHED : "nextDoc() called after NO_MORE_DOCS: " + in;
-    int nextDoc = in.nextDoc();
-    assert nextDoc > doc : "backwards nextDoc from " + doc + " to " + nextDoc + ": " + in;
-    if (nextDoc == DocIdSetIterator.NO_MORE_DOCS) {
-      state = State.DOC_FINISHED;
-    } else {
-      assert in.startPosition() == -1 : "invalid initial startPosition() [should be -1]: " + in;
-      assert in.endPosition() == -1 : "invalid initial endPosition() [should be -1]: " + in;
-      state = State.POS_START;
-    }
-    doc = nextDoc;
-    return docID();
-  }
-  
-  @Override
-  public int advance(int target) throws IOException {
-    assert state != State.DOC_FINISHED : "advance() called after NO_MORE_DOCS: " + in;
-    assert target > doc : "target must be > docID(), got " + target + " <= " + doc + ": " + in;
-    int advanced = in.advance(target);
-    assert advanced >= target : "backwards advance from: " + target + " to: " + advanced + ": " + in;
-    if (advanced == DocIdSetIterator.NO_MORE_DOCS) {
-      state = State.DOC_FINISHED;
-    } else {
-      assert in.startPosition() == -1 : "invalid initial startPosition() [should be -1]: " + in;
-      assert in.endPosition() == -1 : "invalid initial endPosition() [should be -1]: " + in;
-      state = State.POS_START;
-    }
-    doc = advanced;
-    return docID();
-  }
-  
-  @Override
-  public String toString() {
-    return "Asserting(" + in + ")";
-  }
-
-  @Override
-  public long cost() {
-    return in.cost();
-  }
-  
-  @Override
-  public TwoPhaseIterator asTwoPhaseIterator() {
-    final TwoPhaseIterator iterator = in.asTwoPhaseIterator();
-    if (iterator == null) {
-      return null;
-    }
-    return new AssertingTwoPhaseView(iterator);
-  }
-  
-  class AssertingTwoPhaseView extends TwoPhaseIterator {
-    final TwoPhaseIterator in;
-    int lastDoc = -1;
-    
-    AssertingTwoPhaseView(TwoPhaseIterator iterator) {
-      super(new AssertingDISI(iterator.approximation()));
-      this.in = iterator;
-    }
-    
-    @Override
-    public boolean matches() throws IOException {
-      if (approximation.docID() == -1 || approximation.docID() == DocIdSetIterator.NO_MORE_DOCS) {
-        throw new AssertionError("matches() should not be called on doc ID " + approximation.docID());
-      }
-      if (lastDoc == approximation.docID()) {
-        throw new AssertionError("matches() has been called twice on doc ID " + approximation.docID());
-      }
-      lastDoc = approximation.docID();
-      boolean v = in.matches();
-      if (v) {
-        state = State.POS_START;
-      }
-      return v;
-    }
-  }
-  
-  class AssertingDISI extends DocIdSetIterator {
-    final DocIdSetIterator in;
-    
-    AssertingDISI(DocIdSetIterator in) {
-      this.in = in;
-    }
-    
-    @Override
-    public int docID() {
-      assert in.docID() == AssertingSpans.this.docID();
-      return in.docID();
-    }
-    
-    @Override
-    public int nextDoc() throws IOException {
-      assert state != State.DOC_FINISHED : "nextDoc() called after NO_MORE_DOCS: " + in;
-      int nextDoc = in.nextDoc();
-      assert nextDoc > doc : "backwards nextDoc from " + doc + " to " + nextDoc + ": " + in;
-      if (nextDoc == DocIdSetIterator.NO_MORE_DOCS) {
-        state = State.DOC_FINISHED;
-      } else {
-        state = State.DOC_UNVERIFIED;
-      }
-      doc = nextDoc;
-      return docID();
-    }
-    
-    @Override
-    public int advance(int target) throws IOException {
-      assert state != State.DOC_FINISHED : "advance() called after NO_MORE_DOCS: " + in;
-      assert target > doc : "target must be > docID(), got " + target + " <= " + doc + ": " + in;
-      int advanced = in.advance(target);
-      assert advanced >= target : "backwards advance from: " + target + " to: " + advanced + ": " + in;
-      if (advanced == DocIdSetIterator.NO_MORE_DOCS) {
-        state = State.DOC_FINISHED;
-      } else {
-        state = State.DOC_UNVERIFIED;
-      }
-      doc = advanced;
-      return docID();
-    }
-    
-    @Override
-    public long cost() {
-      return in.cost();
-    }
-  }
-}
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/spans/MultiSpansWrapper.java b/lucene/test-framework/src/java/org/apache/lucene/search/spans/MultiSpansWrapper.java
index af580c7..457d207 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/spans/MultiSpansWrapper.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/spans/MultiSpansWrapper.java
@@ -34,11 +34,11 @@ import org.apache.lucene.search.IndexSearcher;
  */
 public class MultiSpansWrapper {
 
-  public static Spans wrap(IndexReader reader, SpanQuery spanQuery) throws IOException {
+  public static SpanScorer wrap(IndexReader reader, SpanQuery spanQuery) throws IOException {
     return wrap(reader, spanQuery, SpanWeight.Postings.POSITIONS);
   }
 
-  public static Spans wrap(IndexReader reader, SpanQuery spanQuery, SpanWeight.Postings requiredPostings) throws IOException {
+  public static SpanScorer wrap(IndexReader reader, SpanQuery spanQuery, SpanWeight.Postings requiredPostings) throws IOException {
 
     LeafReader lr = SlowCompositeReaderWrapper.wrap(reader); // slow, but ok for testing
     LeafReaderContext lrContext = lr.getContext();
@@ -47,6 +47,6 @@ public class MultiSpansWrapper {
 
     SpanWeight w = spanQuery.createWeight(searcher, false);
 
-    return w.getSpans(lrContext, requiredPostings);
+    return w.getSpanScorer(lrContext, requiredPostings);
   }
 }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java b/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
index a88c6ae..0ac5714 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
@@ -144,21 +144,21 @@ public class SpanTestUtil {
    * Assert the next iteration from {@code spans} is a match
    * from {@code start} to {@code end} in {@code doc}.
    */
-  public static void assertNext(Spans spans, int doc, int start, int end) throws IOException {
+  public static void assertNext(SpanScorer spans, int doc, int start, int end) throws IOException {
     if (spans.docID() >= doc) {
       assertEquals("docId", doc, spans.docID());
     } else { // nextDoc needed before testing start/end
       if (spans.docID() >= 0) {
-        assertEquals("nextStartPosition of previous doc", Spans.NO_MORE_POSITIONS, spans.nextStartPosition());
-        assertEquals("endPosition of previous doc", Spans.NO_MORE_POSITIONS, spans.endPosition());
+        assertEquals("nextStartPosition of previous doc", SpanScorer.NO_MORE_POSITIONS, spans.nextStartPosition());
+        assertEquals("endPosition of previous doc", SpanScorer.NO_MORE_POSITIONS, spans.endPosition());
       }
       assertEquals("nextDoc", doc, spans.nextDoc());
-      if (doc != Spans.NO_MORE_DOCS) {
+      if (doc != SpanScorer.NO_MORE_DOCS) {
         assertEquals("first startPosition", -1, spans.startPosition());
         assertEquals("first endPosition", -1, spans.endPosition());
       }
     }
-    if (doc != Spans.NO_MORE_DOCS) {
+    if (doc != SpanScorer.NO_MORE_DOCS) {
       assertEquals("nextStartPosition", start, spans.nextStartPosition());
       assertEquals("startPosition", start, spans.startPosition());
       assertEquals("endPosition", end, spans.endPosition());
@@ -168,9 +168,9 @@ public class SpanTestUtil {
   /** 
    * Assert that {@code spans} is exhausted.
    */
-  public static void assertFinished(Spans spans) throws Exception {
-    if (spans != null) { // null Spans is empty
-      assertNext(spans, Spans.NO_MORE_DOCS, -2, -2); // start and end positions will be ignored
+  public static void assertFinished(SpanScorer spans) throws Exception {
+    if (spans != null) { // null SpanScorer is empty
+      assertNext(spans, SpanScorer.NO_MORE_DOCS, -2, -2); // start and end positions will be ignored
     }
   }
 }
