Index: lucene/core/src/java/org/apache/lucene/index/FieldInfos.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/FieldInfos.java	(revision 1687828)
+++ lucene/core/src/java/org/apache/lucene/index/FieldInfos.java	(working copy)
@@ -17,13 +17,13 @@
  * limitations under the License.
  */
 
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Comparator;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
-import java.util.SortedMap;
-import java.util.TreeMap;
 
 import org.apache.lucene.util.ArrayUtil;
 
@@ -42,7 +42,7 @@
   
   // used only by fieldInfo(int)
   private final FieldInfo[] byNumberTable; // contiguous
-  private final SortedMap<Integer,FieldInfo> byNumberMap; // sparse
+  private final boolean byNumberTableIsDense;
   
   private final HashMap<String,FieldInfo> byName = new HashMap<>();
   private final Collection<FieldInfo> values; // for an unmodifiable iterator
@@ -58,14 +58,22 @@
     boolean hasFreq = false;
     boolean hasNorms = false;
     boolean hasDocValues = false;
-    
-    TreeMap<Integer, FieldInfo> byNumber = new TreeMap<>();
-    for (FieldInfo info : infos) {
+
+    FieldInfo[] sortedInfos = Arrays.copyOf(infos, infos.length);
+    Arrays.sort(sortedInfos, new Comparator<FieldInfo>() {
+      @Override
+      public int compare(FieldInfo o1, FieldInfo o2) {
+        return o1.number - o2.number;
+      }
+    });
+
+    for (int i = 0; i < sortedInfos.length; ++i) {
+      FieldInfo info = sortedInfos[i];
       if (info.number < 0) {
         throw new IllegalArgumentException("illegal field number: " + info.number + " for field " + info.name);
       }
-      FieldInfo previous = byNumber.put(info.number, info);
-      if (previous != null) {
+      FieldInfo previous = i == 0 ? null : sortedInfos[i - 1];
+      if (previous != null && previous.number == info.number) {
         throw new IllegalArgumentException("duplicate field numbers: " + previous.name + " and " + info.name + " have: " + info.number);
       }
       previous = byName.put(info.name, info);
@@ -89,22 +97,19 @@
     this.hasFreq = hasFreq;
     this.hasNorms = hasNorms;
     this.hasDocValues = hasDocValues;
-    this.values = Collections.unmodifiableCollection(byNumber.values());
-    Integer max = byNumber.isEmpty() ? null : Collections.max(byNumber.keySet());
-    
-    // Only usee TreeMap in the very sparse case (< 1/16th of the numbers are used),
-    // because TreeMap uses ~ 64 (32 bit JVM) or 120 (64 bit JVM w/o compressed oops)
-    // overall bytes per entry, but array uses 4 (32 bit JMV) or 8
-    // (64 bit JVM w/o compressed oops):
-    if (max != null && max < ArrayUtil.MAX_ARRAY_LENGTH && max < 16L*byNumber.size()) {
-      byNumberMap = null;
-      byNumberTable = new FieldInfo[max+1];
-      for (Map.Entry<Integer,FieldInfo> entry : byNumber.entrySet()) {
-        byNumberTable[entry.getKey()] = entry.getValue();
+    this.values = Collections.unmodifiableCollection(Arrays.asList(sortedInfos));
+
+    // Only use a sparse array in the very sparse case (< 1/16th of the numbers are used)
+    int max = sortedInfos.length == 0 ? -1 : sortedInfos[sortedInfos.length - 1].number;
+    this.byNumberTableIsDense = max != -1 && max < ArrayUtil.MAX_ARRAY_LENGTH && max < 16L*sortedInfos.length;
+    if (byNumberTableIsDense && sortedInfos.length != 0) {
+      this.byNumberTable = new FieldInfo[max + 1];
+      // rebuild, since there might be holes
+      for (FieldInfo info : sortedInfos) {
+        byNumberTable[info.number] = info;
       }
     } else {
-      byNumberMap = byNumber;
-      byNumberTable = null;
+      this.byNumberTable = sortedInfos;
     }
   }
   
@@ -178,13 +183,30 @@
     if (fieldNumber < 0) {
       throw new IllegalArgumentException("Illegal field number: " + fieldNumber);
     }
-    if (byNumberTable != null) {
+    if (byNumberTable.length == 0) {
+      return null;
+    }
+    if (byNumberTableIsDense) {
       if (fieldNumber >= byNumberTable.length) {
         return null;
       }
       return byNumberTable[fieldNumber];
     } else {
-      return byNumberMap.get(fieldNumber);
+      // binary search
+      int min = 0;
+      int max = byNumberTable.length - 1;
+      while (min < max) {
+        int midpoint = min + (max - min) / 2;
+        if (byNumberTable[midpoint].number < fieldNumber) {
+          min = midpoint + 1;
+        } else {
+          max = midpoint;
+        }
+      }
+      if (min == max && byNumberTable[max].number == fieldNumber) {
+        return byNumberTable[max];
+      }
+      return null;
     }
   }
   
