diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java
new file mode 100644
index 00000000000..945415aaaf8
--- /dev/null
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyFacetLabels.java
@@ -0,0 +1,180 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.facet.taxonomy;
+
+import org.apache.lucene.facet.FacetsConfig;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.util.IntsRef;
+
+import java.io.IOException;
+import java.util.Iterator;
+
+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.INVALID_ORDINAL;
+import static org.apache.lucene.facet.taxonomy.TaxonomyReader.ROOT_ORDINAL;
+
+/**
+ * Utility class to lookup facet labels for a document from taxonomy.
+ * One use case for such a utility class is to return facet label for
+ * each hit if a facet field is requested in the list of return fields.
+ *
+ * @lucene.experimental
+ **/
+public class TaxonomyFacetLabels {
+
+    /**
+     * Index field name provided to the constructor.
+     */
+    private final String indexFieldName;
+
+    /**
+     * {@code TaxonomyReader} provided to the constructor.
+     */
+    private final TaxonomyReader taxoReader;
+
+    /**
+     * {@code FacetsConfig} provided to the constructor.
+     */
+    private final FacetsConfig config;
+
+    /**
+     * {@code OrdinalsReader} used to decode ordinals previously indexed into a BinaryDocValues field
+     */
+    private final OrdinalsReader ordsReader;
+
+    /**
+     * Sole constructor.
+     */
+    public TaxonomyFacetLabels(TaxonomyReader taxoReader, FacetsConfig config, String indexFieldName) throws IOException {
+        this.taxoReader = taxoReader;
+        this.config = config;
+        this.indexFieldName = indexFieldName;
+        this.ordsReader = new DocValuesOrdinalsReader(indexFieldName);
+    }
+
+    /**
+     * Create and return an instance of {@link FacetLabelReader} that can be used to
+     * look up facet labels for a given docid and (optionally) a dimension.
+     *
+     * @param readerContext LeafReaderContext used to access the BinaryDocValues field
+     * @return an instance of {@link FacetLabelReader}
+     * @throws IOException for a variety of reasons
+     */
+    public FacetLabelReader getFacetLabelReader(LeafReaderContext readerContext) throws IOException {
+        return new FacetLabelReader(ordsReader, readerContext);
+    }
+
+    /**
+     * Utility class to lookup facet labels a given docid.
+     *
+     * <b>Note: This class is not Thread-Safe as it reuses an {@link IntsRef} buffer
+     * in order to minimize allocation during the ordinal decoding process </b>
+     *
+     * @lucene.experimental
+     */
+    public class FacetLabelReader {
+        private final OrdinalsReader.OrdinalsSegmentReader ordinalsSegmentReader;
+        private final IntsRef decodedOrds;
+        private int currentDocId;
+        private int currentPos;
+        private int[] parents;
+
+        /**
+         * Sole constructor.
+         */
+        public FacetLabelReader(OrdinalsReader ordsReader, LeafReaderContext readerContext) throws IOException {
+            ordinalsSegmentReader = ordsReader.getReader(readerContext);
+            decodedOrds = new IntsRef();
+            currentDocId = -1;
+            currentPos = -1;
+        }
+
+        /**
+         * Use {@link OrdinalsReader.OrdinalsSegmentReader} to decode ordinals for given docId.
+         * For each decoded ordinal use {@link TaxonomyReader} to lookup facet labels.
+         *
+         * @param docId input docId provided in non-decreasing order
+         * @return an instance of {@link Iterator} to get all facet labels
+         * @throws IOException if {@link TaxonomyReader} has problems getting path for an ordinal
+         */
+        public FacetLabel nextFacetLabel(int docId) throws IOException {
+            if (currentDocId != docId) {
+                ordinalsSegmentReader.get(docId, decodedOrds);
+                currentDocId = docId;
+                currentPos = decodedOrds.offset;
+            }
+
+            if (currentPos >= (decodedOrds.offset + decodedOrds.length)) {
+                return null;
+            }
+
+            int ord = decodedOrds.ints[currentPos++];
+            try {
+                return taxoReader.getPath(ord);
+            } catch (IOException ioe) {
+                throw new RuntimeException("[Index field=" + indexFieldName + "] Error reading label from " +
+                        "taxonomy for ordinal: " + ord, ioe);
+            }
+        }
+
+        private boolean isDescendant(int ord, int ancestorOrd) {
+            while (ord != INVALID_ORDINAL && ord != ROOT_ORDINAL) {
+                if (parents[ord] == ancestorOrd) {
+                    return true;
+                }
+                ord = parents[ord];
+            }
+            return false;
+        }
+
+        /**
+         * Use {@link OrdinalsReader.OrdinalsSegmentReader} to decode ordinals for given docId and dimension
+         * For each decoded ordinal use {@link TaxonomyReader} to lookup facet labels.
+         *
+         * @param docId input docId provided in non-decreasing order
+         * @return an instance of {@link Iterator} to get all facet labels
+         * @throws IOException if {@link TaxonomyReader} has problems getting path for an ordinal
+         */
+        public FacetLabel nextFacetLabel(int docId, String facetDimension) throws IOException {
+            final int parentOrd = taxoReader.getOrdinal(new FacetLabel(facetDimension));
+            if (parentOrd == INVALID_ORDINAL) {
+                throw new AssertionError("Root ordinal not found for facet dimension: " + facetDimension);
+            }
+
+            if (currentDocId != docId) {
+                ordinalsSegmentReader.get(docId, decodedOrds);
+                currentPos = decodedOrds.offset;
+                currentDocId = docId;
+            }
+
+            if (parents == null) {
+                parents = taxoReader.getParallelTaxonomyArrays().parents();
+            }
+
+            try {
+                for (; currentPos < decodedOrds.offset + decodedOrds.length; ) {
+                    if (isDescendant(decodedOrds.ints[currentPos++], parentOrd) == true) {
+                        return taxoReader.getPath(decodedOrds.ints[currentPos - 1]);
+                    }
+                }
+                return null;
+            } catch (IOException ioe) {
+                throw new RuntimeException("[Index field=" + indexFieldName + ", dimension=" + facetDimension
+                        + "] Error reading label from taxonomy for ordinal: " + decodedOrds.ints[currentPos - 1], ioe);
+            }
+        }
+    }
+}
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java
new file mode 100644
index 00000000000..920f5355aa5
--- /dev/null
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyLabels.java
@@ -0,0 +1,192 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.facet.taxonomy;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.facet.FacetField;
+import org.apache.lucene.facet.FacetTestCase;
+import org.apache.lucene.facet.FacetsCollector;
+import org.apache.lucene.facet.FacetsCollector.MatchingDocs;
+import org.apache.lucene.facet.FacetsConfig;
+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
+import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.IOUtils;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class TestTaxonomyLabels extends FacetTestCase {
+
+    private List<Document> prepareDocuments() {
+        List<Document> docs = new ArrayList<>();
+
+        Document doc = new Document();
+        doc.add(new FacetField("Author", "Bob"));
+        doc.add(new FacetField("Publish Date", "2010", "10", "15"));
+        docs.add(doc);
+
+        doc = new Document();
+        doc.add(new FacetField("Author", "Lisa"));
+        doc.add(new FacetField("Publish Date", "2010", "10", "20"));
+        docs.add(doc);
+
+        doc = new Document();
+        doc.add(new FacetField("Author", "Tom"));
+        doc.add(new FacetField("Publish Date", "2012", "1", "1"));
+        docs.add(doc);
+
+        doc = new Document();
+        doc.add(new FacetField("Author", "Susan"));
+        doc.add(new FacetField("Publish Date", "2012", "1", "7"));
+        docs.add(doc);
+
+        doc = new Document();
+        doc.add(new FacetField("Author", "Frank"));
+        doc.add(new FacetField("Publish Date", "1999", "5", "5"));
+        docs.add(doc);
+
+        return docs;
+    }
+
+    private List<Integer> allDocIds(MatchingDocs m, boolean decreasingDocIds) throws IOException {
+        DocIdSetIterator disi = m.bits.iterator();
+        List<Integer> docIds = new ArrayList<>();
+        while (disi.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
+            docIds.add(disi.docID());
+        }
+
+        if (decreasingDocIds == true) {
+            Collections.reverse(docIds);
+        }
+        return docIds;
+    }
+
+    private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,
+                                               List<MatchingDocs> matchingDocs) throws IOException {
+        return lookupFacetLabels(taxoLabels, matchingDocs, null, false);
+    }
+
+    private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels,
+                                               List<MatchingDocs> matchingDocs,
+                                               String dimension) throws IOException {
+        return lookupFacetLabels(taxoLabels, matchingDocs, dimension, false);
+    }
+
+    private List<FacetLabel> lookupFacetLabels(TaxonomyFacetLabels taxoLabels, List<MatchingDocs> matchingDocs, String dimension,
+                                               boolean decreasingDocIds) throws IOException {
+        List<FacetLabel> facetLabels = new ArrayList<>();
+
+        for (MatchingDocs m : matchingDocs) {
+            TaxonomyFacetLabels.FacetLabelReader facetLabelReader = taxoLabels.getFacetLabelReader(m.context);
+            List<Integer> docIds = allDocIds(m, decreasingDocIds);
+            FacetLabel facetLabel;
+            for (Integer docId : docIds) {
+                while (true) {
+                    if (dimension != null) {
+                        facetLabel = facetLabelReader.nextFacetLabel(docId, dimension);
+                    } else {
+                        facetLabel = facetLabelReader.nextFacetLabel(docId);
+                    }
+
+                    if (facetLabel == null) {
+                        break;
+                    }
+                    facetLabels.add(facetLabel);
+                }
+            }
+        }
+
+        return facetLabels;
+    }
+
+
+    public void testBasic() throws Exception {
+        Directory dir = newDirectory();
+        Directory taxoDir = newDirectory();
+
+        // Writes facet ords to a separate directory from the main index:
+        DirectoryTaxonomyWriter taxoWriter = new DirectoryTaxonomyWriter(taxoDir, IndexWriterConfig.OpenMode.CREATE);
+        RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+
+        FacetsConfig config = new FacetsConfig();
+        config.setHierarchical("Publish Date", true);
+
+        for (Document doc : prepareDocuments()) {
+            writer.addDocument(config.build(taxoWriter, doc));
+        }
+
+        // NRT open
+        IndexSearcher searcher = newSearcher(writer.getReader());
+        // NRT open
+        TaxonomyReader taxoReader = new DirectoryTaxonomyReader(taxoWriter);
+
+        FacetsCollector fc = new FacetsCollector();
+        searcher.search(new MatchAllDocsQuery(), fc);
+
+        TaxonomyFacetLabels taxoLabels = new TaxonomyFacetLabels(taxoReader, config, FacetsConfig.DEFAULT_INDEX_FIELD_NAME);
+
+        // Check labels for all dimensions
+        List<FacetLabel> facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs());
+        assertTrue(facetLabels.size() == 10);
+        assertTrue(facetLabels.stream()
+                .filter(l -> "Author".equals(l.components[0]))
+                .map(l -> l.components[1]).collect(Collectors.toSet())
+                .equals(Set.of("Bob", "Lisa", "Susan", "Frank", "Tom")));
+
+        assertTrue(facetLabels.stream()
+                .filter(l -> "Publish Date".equals(l.components[0]))
+                .map(l -> String.join("/", l.components[1], l.components[2], l.components[3]))
+                .collect(Collectors.toSet())
+                .equals(Set.of("2010/10/15", "2010/10/20", "2012/1/1", "2012/1/7", "1999/5/5")));
+
+        // Check labels for specific dimension
+        facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs(), "Publish Date");
+        assertTrue(facetLabels.size() == 5);
+        assertTrue(facetLabels.stream()
+                .filter(l -> "Publish Date".equals(l.components[0]))
+                .map(l -> String.join("/", l.components[1], l.components[2], l.components[3]))
+                .collect(Collectors.toSet())
+                .equals(Set.of("2010/10/15", "2010/10/20", "2012/1/1", "2012/1/7", "1999/5/5")));
+
+        try {
+            facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs(), null, true);
+            fail("Assertion error was not thrown for using docIds supplied in decreasing order");
+        } catch (AssertionError ae) {
+            assertTrue(ae.getMessage().contains("docs out of order"));
+        }
+
+        try {
+            facetLabels = lookupFacetLabels(taxoLabels, fc.getMatchingDocs(), "Publish Date", true);
+            fail("Assertion error was not thrown for using docIds supplied in decreasing order");
+        } catch (AssertionError ae) {
+            assertTrue(ae.getMessage().contains("docs out of order"));
+        }
+
+        writer.close();
+        IOUtils.close(taxoWriter, searcher.getIndexReader(), taxoReader, taxoDir, dir);
+    }
+}
