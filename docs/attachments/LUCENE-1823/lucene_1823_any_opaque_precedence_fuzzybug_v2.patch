Index: contrib/queryparser/build.xml
===================================================================
--- contrib/queryparser/build.xml	(revision 881959)
+++ contrib/queryparser/build.xml	(working copy)
@@ -24,6 +24,20 @@
   </description>
 
   <import file="../contrib-build.xml"/>
+	
+  	
+  <path id="classpath">
+    <pathelement path="${common.dir}/build/classes/java"/>
+    <pathelement path="${common.dir}/build/contrib/regex/classes/java"/>
+  </path>
+	
+  <target name="compile-regex">
+    <subant target="compile">
+      <fileset dir="${common.dir}/contrib/regex" includes="build.xml"/>
+    </subant>
+  </target>
+	
+  <target name="init" depends="common.init,compile-regex"/>
  
   <!--
     NOTE: see the README.javacc for details on how to fully regenerate the parser
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java	(revision 881959)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQueryParserWrapper.java	(working copy)
@@ -148,9 +148,9 @@
 
       QueryNodeProcessorPipeline newProcessorPipeline = new QueryNodeProcessorPipeline(
           getQueryProcessor().getQueryConfigHandler());
-      newProcessorPipeline.addProcessor(new WildcardQueryNodeProcessor());
-      newProcessorPipeline.addProcessor(new QPTestParserQueryNodeProcessor());
-      newProcessorPipeline.addProcessor(getQueryProcessor());
+      newProcessorPipeline.add(new WildcardQueryNodeProcessor());
+      newProcessorPipeline.add(new QPTestParserQueryNodeProcessor());
+      newProcessorPipeline.add(getQueryProcessor());
 
       setQueryProcessor(newProcessorPipeline);
 
@@ -393,6 +393,34 @@
     qp.setDefaultOperator(QueryParserWrapper.OR_OPERATOR);
     assertEquals(QueryParserWrapper.OR_OPERATOR, qp.getDefaultOperator());
   }
+  
+public void testFuzzy() throws Exception {
+    
+    assertQueryEquals("foo~0.5", null, "foo~0.5");
+    assertQueryEquals("foo~0.4453", null, "foo~0.4453");
+    assertQueryEquals("foo~0", null, "foo~0.0");
+    assertQueryEquals("foo~0.0", null, "foo~0.0");
+    
+    // tests min similarity
+    FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
+    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+    fq = (FuzzyQuery) getQuery("term~", null);
+    assertEquals(0.5f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+    
+    // should ignore the fuzzy value when it's equals or greater than 1
+    assertQueryEquals("foo~1.0", null, "foo");
+    assertQueryEquals("foo~1.1", null, "foo");
+    
+    // should return TermQuery if fuzzy value is greater or equals 1
+    assertTrue(getQuery("foo~1", null) instanceof TermQuery);
+    assertTrue(getQuery("foo~1.1", null) instanceof TermQuery);
+    assertTrue(getQuery("foo~0.5", null) instanceof FuzzyQuery);
+    assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
+    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
+        
+  }
 
   public void testPunct() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
@@ -436,17 +464,6 @@
 
     assertTrue(getQuery("term*", null) instanceof PrefixQuery);
     assertTrue(getQuery("term*^2", null) instanceof PrefixQuery);
-    assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
-    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
-    FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
-    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
-    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-    fq = (FuzzyQuery) getQuery("term~", null);
-    assertEquals(0.5f, fq.getMinSimilarity(), 0.1f);
-    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-
-    assertParseException("term~1.1"); // value > 1, throws exception
-
     assertTrue(getQuery("term*germ", null) instanceof WildcardQuery);
 
     /*
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java	(revision 881959)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard/TestQPHelper.java	(working copy)
@@ -150,7 +150,7 @@
   public static class QPTestParser extends StandardQueryParser {
     public QPTestParser(Analyzer a) {
       ((QueryNodeProcessorPipeline)getQueryNodeProcessor())
-          .addProcessor(new QPTestParserQueryNodeProcessor());
+          .add(new QPTestParserQueryNodeProcessor());
       this.setAnalyzer(a);
 
     }
@@ -395,6 +395,34 @@
         "+(title:dog title:cat) -author:\"bob dole\"");
 
   }
+  
+  public void testFuzzy() throws Exception {
+    
+    assertQueryEquals("foo~0.5", null, "foo~0.5");
+	  assertQueryEquals("foo~0.4453", null, "foo~0.4453");
+	  assertQueryEquals("foo~0", null, "foo~0.0");
+	  assertQueryEquals("foo~0.0", null, "foo~0.0");
+	  
+	  // tests min similarity
+	  FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
+    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+    fq = (FuzzyQuery) getQuery("term~", null);
+    assertEquals(0.5f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+	  
+	  // should ignore the fuzzy value when it's equals or greater than 1
+	  assertQueryEquals("foo~1.0", null, "foo");
+	  assertQueryEquals("foo~1.1", null, "foo");
+	  
+	  // should return TermQuery if fuzzy value is greater or equals 1
+	  assertTrue(getQuery("foo~1", null) instanceof TermQuery);
+	  assertTrue(getQuery("foo~1.1", null) instanceof TermQuery);
+	  assertTrue(getQuery("foo~0.5", null) instanceof FuzzyQuery);
+	  assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
+    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
+	  	  
+  }
 
   public void testPunct() throws Exception {
     Analyzer a = new WhitespaceAnalyzer();
@@ -438,17 +466,6 @@
 
     assertTrue(getQuery("term*", null) instanceof PrefixQuery);
     assertTrue(getQuery("term*^2", null) instanceof PrefixQuery);
-    assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
-    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
-    FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
-    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
-    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-    fq = (FuzzyQuery) getQuery("term~", null);
-    assertEquals(0.5f, fq.getMinSimilarity(), 0.1f);
-    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
-
-    assertQueryNodeException("term~1.1"); // value > 1, throws exception
-
     assertTrue(getQuery("term*germ", null) instanceof WildcardQuery);
 
     /*
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard2/RegexQueryParser.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard2/RegexQueryParser.java	(revision 0)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard2/RegexQueryParser.java	(revision 0)
@@ -0,0 +1,106 @@
+package org.apache.lucene.queryParser.standard2;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.queryParser.core.QueryNodeException;
+import org.apache.lucene.queryParser.core.QueryNodeParseException;
+import org.apache.lucene.queryParser.core.builders.QueryTreeBuilder;
+import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.core.parser.SyntaxParser;
+import org.apache.lucene.queryParser.standard.builders.StandardQueryBuilder;
+import org.apache.lucene.queryParser.standard.builders.StandardQueryTreeBuilder;
+import org.apache.lucene.queryParser.standard2.parser.Standard2SyntaxParser;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.regex.RegexQuery;
+
+public class RegexQueryParser extends Standard2QueryParser {
+
+  static private String EXTNAME = "regex";
+
+  // Syntax Parser that parses opaque extension for name regex
+  static private class RegexSyntaxParser implements SyntaxParser {
+
+    public QueryNode parse(CharSequence query, CharSequence field)
+        throws QueryNodeParseException {
+      return new RegexQueryNode(EXTNAME, query, field, 0, 0);
+    }
+
+    public void setOpaqueExtensions(Map<String, SyntaxParser> opaqueExtensions) {
+      // ignore OpaqueExtensions are not support by this parser
+    }
+  }
+
+  // Builder to implement the RegexQueryNode is created by the RegexSyntaxParser
+  static private class RegexQueryNode extends OpaqueQueryNode {
+
+    private static final long serialVersionUID = 2086778062006762726L;
+
+    public RegexQueryNode(CharSequence extensionName, CharSequence field,
+        CharSequence value, int begin, int end) {
+      super(extensionName, field, value, begin, end);
+    }
+  }
+
+  // Builder to implement the RegexQueryNode to RegexQuery mapping
+  static private class RegexQueryNodeBuilder implements StandardQueryBuilder {
+
+    public Query build(QueryNode queryNode) throws QueryNodeException {
+      RegexQueryNode regexpNode = (RegexQueryNode) queryNode;
+      RegexQuery q =  new RegexQuery(new Term(regexpNode.getField().toString(), regexpNode.getValue().toString()));
+//      if ( capability != null )
+//        q.setRegexImplementation(capability);
+      return q;
+    }
+
+  }
+
+  /**
+   * @see RegexQueryParser#RegExpQueryParser()
+   */
+  public RegexQueryParser() {
+    super();
+
+    // configure the SyntaxParser    
+    Map<String, SyntaxParser> opaqueExtensions = new HashMap<String, SyntaxParser>();
+    opaqueExtensions.put(EXTNAME, new RegexSyntaxParser());
+    
+    SyntaxParser syntaxParser = new Standard2SyntaxParser();
+    syntaxParser.setOpaqueExtensions(opaqueExtensions);
+    this.setSyntaxParser(syntaxParser);
+
+    // configure the Builder
+    QueryTreeBuilder builder = new StandardQueryTreeBuilder();
+    builder.setBuilder(RegexQueryNode.class, new RegexQueryNodeBuilder());
+    this.setQueryBuilder(builder);
+
+  }
+
+  /**
+   * @see RegexQueryParser#RegExpQueryParser(Analyzer)
+   */
+  public RegexQueryParser(Analyzer analyzer) {
+    this();
+    setAnalyzer(analyzer);
+  }
+}
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard2/TestOpaqueExtensionQuery.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard2/TestOpaqueExtensionQuery.java	(revision 0)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard2/TestOpaqueExtensionQuery.java	(revision 0)
@@ -0,0 +1,84 @@
+package org.apache.lucene.queryParser.standard2;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import junit.framework.TestCase;
+
+import org.apache.lucene.analysis.SimpleAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.store.RAMDirectory;
+
+public class TestOpaqueExtensionQuery extends TestCase {
+  private IndexSearcher searcher;
+  private final String FN = "text";
+
+
+  @Override
+  public void setUp() {
+    RAMDirectory directory = new RAMDirectory();
+    try {
+      IndexWriter writer = new IndexWriter(directory, new SimpleAnalyzer(), true, 
+                                           IndexWriter.MaxFieldLength.LIMITED);
+      Document doc = new Document();
+      doc.add(new Field(FN, "the quick brown fox jumps over the lazy dog", Field.Store.NO, Field.Index.ANALYZED));
+      writer.addDocument(doc);
+      writer.optimize();
+      writer.close();
+      searcher = new IndexSearcher(directory, true);
+    } catch (Exception e) {
+      fail(e.toString());
+    }
+  }
+
+  @Override
+  public void tearDown() {
+    try {
+      searcher.close();
+    } catch (Exception e) {
+      fail(e.toString());
+    }
+  }
+
+  private int  regexQueryNrHits(String query) throws Exception {
+    RegexQueryParser parser = new RegexQueryParser();
+    Query q = parser.parse(query, FN);
+    
+    return searcher.search(q, null, 1000).totalHits;
+  }
+
+  public void testRegex1Escaped() throws Exception {
+    assertEquals(1, regexQueryNrHits("regex::\\^q.\\[aeiou\\]c.\\*$"));
+  }
+
+  public void testRegex2Escaped() throws Exception {
+    assertEquals(0, regexQueryNrHits("regex::\\^.\\[aeiou\\]c.\\*$"));
+  }
+  
+  public void testRegex1Quoted() throws Exception {
+    assertEquals(0, regexQueryNrHits("regex::\"^.[aeiou]c.*$\""));
+  }
+
+  public void testRegex2Quoted() throws Exception {
+    assertEquals(1, regexQueryNrHits("regex::\"^q.[aeiou]c.*$\""));
+  }
+
+}
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/standard2/TestStandard2QueryParser.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/standard2/TestStandard2QueryParser.java	(revision 0)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/standard2/TestStandard2QueryParser.java	(revision 0)
@@ -0,0 +1,671 @@
+package org.apache.lucene.queryParser.standard2;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.io.Reader;
+import java.text.DateFormat;
+import java.util.Arrays;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.LowerCaseTokenizer;
+import org.apache.lucene.analysis.SimpleAnalyzer;
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.WhitespaceAnalyzer;
+import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
+import org.apache.lucene.analysis.tokenattributes.TermAttribute;
+import org.apache.lucene.document.DateField;
+import org.apache.lucene.document.DateTools;
+import org.apache.lucene.queryParser.core.QueryNodeException;
+import org.apache.lucene.queryParser.core.QueryNodeParseException;
+import org.apache.lucene.queryParser.core.QueryParserHelper;
+import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard.parser.ParseException;
+import org.apache.lucene.queryParser.standard2.Standard2QueryParser;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.FuzzyQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.PrefixQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TermRangeQuery;
+import org.apache.lucene.search.WildcardQuery;
+import org.apache.lucene.util.LocalizedTestCase;
+import org.apache.lucene.util.Version;
+
+/**
+ * <p>
+ * This test case tests {@link Standard2QueryParser}.
+ * </p>
+ * <p>
+ * It contains all tests from {@link TestQueryParser} with some adjusted to 
+ * fit the precedence requirement, plus some precedence test cases. 
+ * </p>
+ * 
+ * @see TestQueryParser
+ */
+public class TestStandard2QueryParser extends LocalizedTestCase {
+
+  public TestStandard2QueryParser(String name) {
+    super(name, new HashSet<String>(Arrays.asList(new String[] {
+        "testDateRange", "testNumber" })));
+  }
+
+  public static Analyzer qpAnalyzer = new QPTestAnalyzer();
+
+  public static class QPTestFilter extends TokenFilter {
+    /**
+     * Filter which discards the token 'stop' and which expands the token
+     * 'phrase' into 'phrase1 phrase2'
+     */
+    public QPTestFilter(TokenStream in) {
+      super(in);
+    }
+
+    boolean inPhrase = false;
+
+    int savedStart = 0, savedEnd = 0;
+
+    TermAttribute termAtt = addAttribute(TermAttribute.class);
+
+    OffsetAttribute offsetAtt = addAttribute(OffsetAttribute.class);
+
+    public boolean incrementToken() throws IOException {
+      if (inPhrase) {
+        inPhrase = false;
+        termAtt.setTermBuffer("phrase2");
+        offsetAtt.setOffset(savedStart, savedEnd);
+        return true;
+      } else
+        while (input.incrementToken())
+          if (termAtt.term().equals("phrase")) {
+            inPhrase = true;
+            savedStart = offsetAtt.startOffset();
+            savedEnd = offsetAtt.endOffset();
+            termAtt.setTermBuffer("phrase1");
+            offsetAtt.setOffset(savedStart, savedEnd);
+            return true;
+          } else if (!termAtt.term().equals("stop"))
+            return true;
+      return false;
+    }
+  }
+
+  public static class QPTestAnalyzer extends Analyzer {
+
+    /** Filters LowerCaseTokenizer with StopFilter. */
+    public final TokenStream tokenStream(String fieldName, Reader reader) {
+      return new QPTestFilter(new LowerCaseTokenizer(reader));
+    }
+  }
+
+  private int originalMaxClauses;
+
+  public void setUp() throws Exception {
+    super.setUp();
+    originalMaxClauses = BooleanQuery.getMaxClauseCount();
+  }
+
+  public Standard2QueryParser getParser(Analyzer a) throws Exception {
+    if (a == null)
+      a = new SimpleAnalyzer();
+    Standard2QueryParser qp = new Standard2QueryParser();
+    qp.setAnalyzer(a);
+    qp.setDefaultOperator(Operator.OR);
+    return qp;
+  }
+
+  public Query getQuery(String query, Analyzer a) throws Exception {
+    return getParser(a).parse(query, "field");
+  }
+
+  public void assertQueryEquals(String query, Analyzer a, String result)
+      throws Exception {
+    Query q = getQuery(query, a);
+    String s = q.toString("field");
+    if (!s.equals(result)) {
+      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
+          + "/");
+    }
+  }
+
+  public void assertWildcardQueryEquals(String query, boolean lowercase,
+      String result) throws Exception {
+    Standard2QueryParser qp = getParser(null);
+    qp.setLowercaseExpandedTerms(lowercase);
+    Query q = qp.parse(query, "field");
+    String s = q.toString("field");
+    if (!s.equals(result)) {
+      fail("WildcardQuery /" + query + "/ yielded /" + s + "/, expecting /"
+          + result + "/");
+    }
+  }
+
+  public void assertWildcardQueryEquals(String query, String result)
+      throws Exception {
+    Standard2QueryParser qp = getParser(null);
+    Query q = qp.parse(query, "field");
+    String s = q.toString("field");
+    if (!s.equals(result)) {
+      fail("WildcardQuery /" + query + "/ yielded /" + s + "/, expecting /"
+          + result + "/");
+    }
+  }
+
+  public Query getQueryDOA(String query, Analyzer a) throws Exception {
+    if (a == null)
+      a = new SimpleAnalyzer();
+    Standard2QueryParser qp = new Standard2QueryParser();
+    qp.setAnalyzer(a);
+    qp.setDefaultOperator(Operator.AND);
+    return qp.parse(query, "field");
+  }
+
+  public void assertQueryEqualsDOA(String query, Analyzer a, String result)
+      throws Exception {
+    Query q = getQueryDOA(query, a);
+    String s = q.toString("field");
+    if (!s.equals(result)) {
+      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
+          + "/");
+    }
+  }
+
+  // failing tests disabled since PrecedenceQueryParser
+  // is currently unmaintained
+  public void _testSimple() throws Exception {
+    assertQueryEquals("", null, "");
+
+    assertQueryEquals("term term term", null, "term term term");
+    assertQueryEquals("türm term term", null, "türm term term");
+    assertQueryEquals("ümlaut", null, "ümlaut");
+
+    assertQueryEquals("+a", null, "+a");
+    assertQueryEquals("-a", null, "-a");
+    assertQueryEquals("a AND b", null, "+a +b");
+    assertQueryEquals("(a AND b)", null, "+a +b");
+    assertQueryEquals("c OR (a AND b)", null, "c (+a +b)");
+    assertQueryEquals("a AND NOT b", null, "+a -b");
+    assertQueryEquals("a AND -b", null, "+a -b");
+    assertQueryEquals("a AND !b", null, "+a -b");
+    assertQueryEquals("a && b", null, "+a +b");
+    assertQueryEquals("a && ! b", null, "+a -b");
+
+    assertQueryEquals("a OR b", null, "a b");
+    assertQueryEquals("a || b", null, "a b");
+
+    assertQueryEquals("+term -term term", null, "+term -term term");
+    assertQueryEquals("foo:term AND field:anotherTerm", null,
+        "+foo:term +anotherterm");
+    assertQueryEquals("term AND \"phrase phrase\"", null,
+        "+term +\"phrase phrase\"");
+    assertQueryEquals("\"hello there\"", null, "\"hello there\"");
+    assertTrue(getQuery("a AND b", null) instanceof BooleanQuery);
+    assertTrue(getQuery("hello", null) instanceof TermQuery);
+    assertTrue(getQuery("\"hello there\"", null) instanceof PhraseQuery);
+
+    assertQueryEquals("germ term^2.0", null, "germ term^2.0");
+    assertQueryEquals("(term)^2.0", null, "term^2.0");
+    assertQueryEquals("(germ term)^2.0", null, "(germ term)^2.0");
+    assertQueryEquals("term^2.0", null, "term^2.0");
+    assertQueryEquals("term^2", null, "term^2.0");
+    assertQueryEquals("\"germ term\"^2.0", null, "\"germ term\"^2.0");
+    assertQueryEquals("\"term germ\"^2", null, "\"term germ\"^2.0");
+
+    assertQueryEquals("(foo OR bar) AND (baz OR boo)", null,
+        "+(foo bar) +(baz boo)");
+    assertQueryEquals("((a OR b) AND NOT c) OR d", null, "(+(a b) -c) d");
+    assertQueryEquals("+(apple \"steve jobs\") -(foo bar baz)", null,
+        "+(apple \"steve jobs\") -(foo bar baz)");
+    assertQueryEquals("+title:(dog OR cat) -author:\"bob dole\"", null,
+        "+(title:dog title:cat) -author:\"bob dole\"");
+
+    Standard2QueryParser qp = new Standard2QueryParser();
+    qp.setAnalyzer(new StandardAnalyzer(Version.LUCENE_CURRENT));
+    // make sure OR is the default:
+    assertEquals(Operator.OR, qp.getDefaultOperator());
+    qp.setDefaultOperator(Operator.AND);
+    assertEquals(Operator.AND, qp.getDefaultOperator());
+    qp.setDefaultOperator(Operator.OR);
+    assertEquals(Operator.OR, qp.getDefaultOperator());
+
+    assertQueryEquals("a OR !b", null, "a (-b)");
+    assertQueryEquals("a OR ! b", null, "a (-b)");
+    assertQueryEquals("a OR -b", null, "a (-b)");
+  }
+
+  public void testPunct() throws Exception {
+    Analyzer a = new WhitespaceAnalyzer();
+    assertQueryEquals("a&b", a, "a&b");
+    assertQueryEquals("a&&b", a, "a&&b");
+    assertQueryEquals(".NET", a, ".NET");
+  }
+
+  public void testSlop() throws Exception {
+    assertQueryEquals("\"term germ\"~2", null, "\"term germ\"~2");
+    assertQueryEquals("\"term germ\"~2 flork", null, "\"term germ\"~2 flork");
+    assertQueryEquals("\"term\"~2", null, "term");
+    assertQueryEquals("\" \"~2 germ", null, "germ");
+    assertQueryEquals("\"term germ\"~2^2", null, "\"term germ\"~2^2.0");
+  }
+
+  public void testNumber() throws Exception {
+    // The numbers go away because SimpleAnalzyer ignores them
+    assertQueryEquals("3", null, "");
+    assertQueryEquals("term 1.0 1 2", null, "term");
+    assertQueryEquals("term term1 term2", null, "term term term");
+
+    Analyzer a = new StandardAnalyzer(Version.LUCENE_CURRENT);
+    assertQueryEquals("3", a, "3");
+    assertQueryEquals("term 1.0 1 2", a, "term 1.0 1 2");
+    assertQueryEquals("term term1 term2", a, "term term1 term2");
+  }
+
+  // failing tests disabled since PrecedenceQueryParser
+  // is currently unmaintained
+  public void _testWildcard() throws Exception {
+    assertQueryEquals("term*", null, "term*");
+    assertQueryEquals("term*^2", null, "term*^2.0");
+    assertQueryEquals("term~", null, "term~0.5");
+    assertQueryEquals("term~0.7", null, "term~0.7");
+    assertQueryEquals("term~^2", null, "term^2.0~0.5");
+    assertQueryEquals("term^2~", null, "term^2.0~0.5");
+    assertQueryEquals("term*germ", null, "term*germ");
+    assertQueryEquals("term*germ^3", null, "term*germ^3.0");
+
+    assertTrue(getQuery("term*", null) instanceof PrefixQuery);
+    assertTrue(getQuery("term*^2", null) instanceof PrefixQuery);
+    assertTrue(getQuery("term~", null) instanceof FuzzyQuery);
+    assertTrue(getQuery("term~0.7", null) instanceof FuzzyQuery);
+    FuzzyQuery fq = (FuzzyQuery) getQuery("term~0.7", null);
+    assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+    fq = (FuzzyQuery) getQuery("term~", null);
+    assertEquals(0.5f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
+    try {
+      getQuery("term~1.1", null); // value > 1, throws exception
+      fail();
+    } catch (ParseException pe) {
+      // expected exception
+    }
+    assertTrue(getQuery("term*germ", null) instanceof WildcardQuery);
+
+    /*
+     * Tests to see that wild card terms are (or are not) properly lower-cased
+     * with propery parser configuration
+     */
+    // First prefix queries:
+    // by default, convert to lowercase:
+    assertWildcardQueryEquals("Term*", true, "term*");
+    // explicitly set lowercase:
+    assertWildcardQueryEquals("term*", true, "term*");
+    assertWildcardQueryEquals("Term*", true, "term*");
+    assertWildcardQueryEquals("TERM*", true, "term*");
+    // explicitly disable lowercase conversion:
+    assertWildcardQueryEquals("term*", false, "term*");
+    assertWildcardQueryEquals("Term*", false, "Term*");
+    assertWildcardQueryEquals("TERM*", false, "TERM*");
+    // Then 'full' wildcard queries:
+    // by default, convert to lowercase:
+    assertWildcardQueryEquals("Te?m", "te?m");
+    // explicitly set lowercase:
+    assertWildcardQueryEquals("te?m", true, "te?m");
+    assertWildcardQueryEquals("Te?m", true, "te?m");
+    assertWildcardQueryEquals("TE?M", true, "te?m");
+    assertWildcardQueryEquals("Te?m*gerM", true, "te?m*germ");
+    // explicitly disable lowercase conversion:
+    assertWildcardQueryEquals("te?m", false, "te?m");
+    assertWildcardQueryEquals("Te?m", false, "Te?m");
+    assertWildcardQueryEquals("TE?M", false, "TE?M");
+    assertWildcardQueryEquals("Te?m*gerM", false, "Te?m*gerM");
+    // Fuzzy queries:
+    assertWildcardQueryEquals("Term~", "term~0.5");
+    assertWildcardQueryEquals("Term~", true, "term~0.5");
+    assertWildcardQueryEquals("Term~", false, "Term~0.5");
+    // Range queries:
+    assertWildcardQueryEquals("[A TO C]", "[a TO c]");
+    assertWildcardQueryEquals("[A TO C]", true, "[a TO c]");
+    assertWildcardQueryEquals("[A TO C]", false, "[A TO C]");
+  }
+
+  public void testQPA() throws Exception {
+    assertQueryEquals("term term term", qpAnalyzer, "term term term");
+    assertQueryEquals("term +stop term", qpAnalyzer, "term term");
+    assertQueryEquals("term -stop term", qpAnalyzer, "term term");
+    assertQueryEquals("drop AND stop AND roll", qpAnalyzer, "+drop +roll");
+    assertQueryEquals("term phrase term", qpAnalyzer,
+        "term \"phrase1 phrase2\" term");
+    // note the parens in this next assertion differ from the original
+    // QueryParser behavior
+    assertQueryEquals("term AND NOT phrase term", qpAnalyzer,
+        "(+term -\"phrase1 phrase2\") term");
+    assertQueryEquals("stop", qpAnalyzer, "");
+    assertQueryEquals("stop OR stop AND stop", qpAnalyzer, "");
+    assertTrue(getQuery("term term term", qpAnalyzer) instanceof BooleanQuery);
+    assertTrue(getQuery("term +stop", qpAnalyzer) instanceof TermQuery);
+  }
+
+  public void testRange() throws Exception {
+    assertQueryEquals("[ a TO z]", null, "[a TO z]");
+    assertTrue(getQuery("[ a TO z]", null) instanceof TermRangeQuery);
+    assertQueryEquals("[ a TO z ]", null, "[a TO z]");
+    assertQueryEquals("{ a TO z}", null, "{a TO z}");
+    assertQueryEquals("{ a TO z }", null, "{a TO z}");
+    assertQueryEquals("{ a TO z }^2.0", null, "{a TO z}^2.0");
+    assertQueryEquals("[ a TO z] OR bar", null, "[a TO z] bar");
+    assertQueryEquals("[ a TO z] AND bar", null, "+[a TO z] +bar");
+    assertQueryEquals("( bar blar { a TO z}) ", null, "bar blar {a TO z}");
+    assertQueryEquals("gack ( bar blar { a TO z}) ", null,
+        "gack (bar blar {a TO z})");
+  }
+
+  public void testANYoperator() throws Exception {
+    assertQueryEquals("(a b c d e) ANY 2", null, "+a +b +c +d +e");
+    assertTrue(getQuery("(a b c d e) ANY 2", null) instanceof BooleanQuery);
+  }
+  
+  private String escapeDateString(String s) {
+    if (s.contains(" ")) {
+      return "\"" + s + "\"";
+    } else {
+      return s;
+    }
+  }
+
+  public String getDate(String s) throws Exception {
+    DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
+    return DateTools.dateToString(df.parse(s), DateTools.Resolution.DAY);
+  }
+
+  private String getLocalizedDate(int year, int month, int day,
+      boolean extendLastDate) {
+    DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
+    Calendar calendar = new GregorianCalendar();
+    calendar.set(year, month, day);
+    if (extendLastDate) {
+      calendar.set(Calendar.HOUR_OF_DAY, 23);
+      calendar.set(Calendar.MINUTE, 59);
+      calendar.set(Calendar.SECOND, 59);
+      calendar.set(Calendar.MILLISECOND, 999);
+    }
+    return df.format(calendar.getTime());
+  }
+
+  public void testDateRange() throws Exception {
+    String startDate = getLocalizedDate(2002, 1, 1, false);
+    String endDate = getLocalizedDate(2002, 1, 4, false);
+    Calendar endDateExpected = new GregorianCalendar();
+    endDateExpected.set(2002, 1, 4, 23, 59, 59);
+    endDateExpected.set(Calendar.MILLISECOND, 999);
+    final String defaultField = "default";
+    final String monthField = "month";
+    final String hourField = "hour";
+    Standard2QueryParser qp = new Standard2QueryParser();
+
+    // Don't set any date resolution and verify if DateField is used
+    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate,
+        endDateExpected.getTime(), null);
+
+    Map<CharSequence, DateTools.Resolution> dateRes =  new HashMap<CharSequence, DateTools.Resolution>();
+    
+    // set a field specific date resolution    
+    dateRes.put(monthField, DateTools.Resolution.MONTH);
+    qp.setDateResolution(dateRes);
+
+    // DateField should still be used for defaultField
+    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate,
+        endDateExpected.getTime(), null);
+
+    // set default date resolution to MILLISECOND
+    qp.setDateResolution(DateTools.Resolution.MILLISECOND);
+
+    // set second field specific date resolution
+    dateRes.put(hourField, DateTools.Resolution.HOUR);
+    qp.setDateResolution(dateRes);
+
+    // for this field no field specific date resolution has been set,
+    // so verify if the default resolution is used
+    assertDateRangeQueryEquals(qp, defaultField, startDate, endDate,
+        endDateExpected.getTime(), DateTools.Resolution.MILLISECOND);
+
+    // verify if field specific date resolutions are used for these two
+    // fields
+    assertDateRangeQueryEquals(qp, monthField, startDate, endDate,
+        endDateExpected.getTime(), DateTools.Resolution.MONTH);
+
+    assertDateRangeQueryEquals(qp, hourField, startDate, endDate,
+        endDateExpected.getTime(), DateTools.Resolution.HOUR);
+  }
+
+  /** for testing DateTools support */
+  private String getDate(String s, DateTools.Resolution resolution)
+      throws Exception {
+    DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);
+    return getDate(df.parse(s), resolution);
+  }
+
+  /** for testing DateTools support */
+  private String getDate(Date d, DateTools.Resolution resolution)
+      throws Exception {
+    if (resolution == null) {
+      return DateField.dateToString(d);
+    } else {
+      return DateTools.dateToString(d, resolution);
+    }
+  }
+
+  public void assertQueryEquals(Standard2QueryParser qp, String field, String query,
+      String result) throws Exception {
+    Query q = qp.parse(query, field);
+    String s = q.toString(field);
+    if (!s.equals(result)) {
+      fail("Query /" + query + "/ yielded /" + s + "/, expecting /" + result
+          + "/");
+    }
+  }
+
+  public void assertDateRangeQueryEquals(Standard2QueryParser qp, String field,
+      String startDate, String endDate, Date endDateInclusive,
+      DateTools.Resolution resolution) throws Exception {
+    assertQueryEquals(qp, field, field + ":[" + escapeDateString(startDate)
+        + " TO " + escapeDateString(endDate) + "]", "["
+        + getDate(startDate, resolution) + " TO "
+        + getDate(endDateInclusive, resolution) + "]");
+    assertQueryEquals(qp, field, field + ":{" + escapeDateString(startDate)
+        + " TO " + escapeDateString(endDate) + "}", "{"
+        + getDate(startDate, resolution) + " TO "
+        + getDate(endDate, resolution) + "}");
+  }
+
+  public void testEscaped() throws Exception {
+    Analyzer a = new WhitespaceAnalyzer();
+
+    assertQueryEquals("a\\-b:c", a, "a-b:c");
+    assertQueryEquals("a\\+b:c", a, "a+b:c");
+    assertQueryEquals("a\\:b:c", a, "a:b:c");
+    assertQueryEquals("a\\\\b:c", a, "a\\b:c");
+
+    assertQueryEquals("a:b\\-c", a, "a:b-c");
+    assertQueryEquals("a:b\\+c", a, "a:b+c");
+    assertQueryEquals("a:b\\:c", a, "a:b:c");
+    assertQueryEquals("a:b\\\\c", a, "a:b\\c");
+
+    assertQueryEquals("a:b\\-c*", a, "a:b-c*");
+    assertQueryEquals("a:b\\+c*", a, "a:b+c*");
+    assertQueryEquals("a:b\\:c*", a, "a:b:c*");
+
+    assertQueryEquals("a:b\\\\c*", a, "a:b\\c*");
+
+    assertQueryEquals("a:b\\-?c", a, "a:b-?c");
+    assertQueryEquals("a:b\\+?c", a, "a:b+?c");
+    assertQueryEquals("a:b\\:?c", a, "a:b:?c");
+
+    assertQueryEquals("a:b\\\\?c", a, "a:b\\?c");
+
+    assertQueryEquals("a:b\\-c~", a, "a:b-c~0.5");
+    assertQueryEquals("a:b\\+c~", a, "a:b+c~0.5");
+    assertQueryEquals("a:b\\:c~", a, "a:b:c~0.5");
+    assertQueryEquals("a:b\\\\c~", a, "a:b\\c~0.5");
+
+    assertQueryEquals("[ a\\- TO a\\+ ]", null, "[a- TO a+]");
+    assertQueryEquals("[ a\\: TO a\\~ ]", null, "[a: TO a~]");
+    assertQueryEquals("[ a\\\\ TO a\\* ]", null, "[a\\ TO a*]");
+  }
+
+  public void testTabNewlineCarriageReturn() throws Exception {
+    assertQueryEqualsDOA("+weltbank +worlbank", null, "+weltbank +worlbank");
+
+    assertQueryEqualsDOA("+weltbank\n+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \n+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \n +worlbank", null, "+weltbank +worlbank");
+
+    assertQueryEqualsDOA("+weltbank\r+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r +worlbank", null, "+weltbank +worlbank");
+
+    assertQueryEqualsDOA("+weltbank\r\n+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r\n+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r\n +worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \r \n +worlbank", null,
+        "+weltbank +worlbank");
+
+    assertQueryEqualsDOA("+weltbank\t+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \t+worlbank", null, "+weltbank +worlbank");
+    assertQueryEqualsDOA("weltbank \t +worlbank", null, "+weltbank +worlbank");
+  }
+
+  public void testSimpleDAO() throws Exception {
+    assertQueryEqualsDOA("term term term", null, "+term +term +term");
+    assertQueryEqualsDOA("term +term term", null, "+term +term +term");
+    assertQueryEqualsDOA("term term +term", null, "+term +term +term");
+    assertQueryEqualsDOA("term +term +term", null, "+term +term +term");
+    assertQueryEqualsDOA("-term term term", null, "-term +term +term");
+  }
+
+  public void testBoost() throws Exception {
+    HashSet<String> stopwords = new HashSet<String>();
+    stopwords.add("on");
+
+    StandardAnalyzer oneStopAnalyzer = new StandardAnalyzer(
+        Version.LUCENE_CURRENT, stopwords);
+
+    Standard2QueryParser qp = new Standard2QueryParser();
+    qp.setAnalyzer(oneStopAnalyzer);
+    Query q = qp.parse("on^1.0", "field");
+    assertNotNull(q);
+    q = qp.parse("\"hello\"^2.0", "field");
+    assertNotNull(q);
+    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
+    q = qp.parse("hello^2.0", "field");
+    assertNotNull(q);
+    assertEquals(q.getBoost(), (float) 2.0, (float) 0.5);
+    q = qp.parse("\"on\"^1.0", "field");
+    assertNotNull(q);
+
+    q = getParser(new StandardAnalyzer(Version.LUCENE_CURRENT)).parse("the^3",
+        "field");
+    assertNotNull(q);
+  }
+
+  public void testException() throws Exception {
+    try {
+      assertQueryEquals("\"some phrase", null, "abc");
+      fail("ParseException expected, not thrown");
+    } catch (QueryNodeParseException expected) {
+    }
+  }
+
+  public void testBooleanQuery() throws Exception {
+    BooleanQuery.setMaxClauseCount(2);
+    try {
+      getParser(new WhitespaceAnalyzer()).parse("one two three", "field");
+      fail("ParseException expected due to too many boolean clauses");
+    } catch (QueryNodeException expected) {
+      // too many boolean clauses, so ParseException is expected
+    }
+  }
+
+  /**
+   * This test differs from the original QueryParser, showing how the precedence
+   * issue has been corrected.
+   */
+  // failing tests disabled since PrecedenceQueryParser
+  // is currently unmaintained
+  public void testPrecedence() throws Exception {
+    Standard2QueryParser parser = getParser(new WhitespaceAnalyzer());
+    Query query1 = parser.parse("A AND B OR C AND D", "field");
+    Query query2 = parser.parse("(A AND B) OR (C AND D)", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A OR B C", "field");
+    query2 = parser.parse("(A B) C", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A AND B C", "field");
+    query2 = parser.parse("(+A +B) C", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A AND NOT B", "field");
+    query2 = parser.parse("+A -B", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A OR NOT B", "field");
+    query2 = parser.parse("A -B", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A OR NOT B AND C", "field");
+    query2 = parser.parse("A (-B +C)", "field");
+    assertEquals(query1, query2);
+    
+    parser.setDefaultOperator(Operator.AND);
+    query1 = parser.parse("A AND B OR C AND D", "field");
+    query2 = parser.parse("(A AND B) OR (C AND D)", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A AND B C", "field");
+    query2 = parser.parse("(A B) C", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A AND B C", "field");
+    query2 = parser.parse("(+A +B) C", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A AND NOT B", "field");
+    query2 = parser.parse("+A -B", "field");
+    assertEquals(query1, query2);
+
+    query1 = parser.parse("A AND NOT B OR C", "field");
+    query2 = parser.parse("(+A -B) OR C", "field");
+    assertEquals(query1, query2);
+    
+  }
+
+  public void tearDown() {
+    BooleanQuery.setMaxClauseCount(originalMaxClauses);
+  }
+
+}
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParserSimpleSample.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParserSimpleSample.java	(revision 881959)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParserSimpleSample.java	(working copy)
@@ -128,9 +128,9 @@
     QueryNodeProcessorPipeline spanProcessorPipeline = new QueryNodeProcessorPipeline(
         spanQueryConfigHandler);
     // @see SpansValidatorQueryNodeProcessor
-    spanProcessorPipeline.addProcessor(new SpansValidatorQueryNodeProcessor());
+    spanProcessorPipeline.add(new SpansValidatorQueryNodeProcessor());
     // @see UniqueFieldQueryNodeProcessor
-    spanProcessorPipeline.addProcessor(new UniqueFieldQueryNodeProcessor());
+    spanProcessorPipeline.add(new UniqueFieldQueryNodeProcessor());
 
     // print to show out the QueryNode tree before being processed
     System.out.println(queryTree);
Index: contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java
===================================================================
--- contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java	(revision 881959)
+++ contrib/queryparser/src/test/org/apache/lucene/queryParser/spans/TestSpanQueryParser.java	(working copy)
@@ -119,11 +119,9 @@
     this.spanProcessorPipeline
         .setQueryConfigHandler(this.spanQueryConfigHandler);
 
-    this.spanProcessorPipeline.addProcessor(new WildcardQueryNodeProcessor());
-    this.spanProcessorPipeline
-        .addProcessor(new SpansValidatorQueryNodeProcessor());
-    this.spanProcessorPipeline
-        .addProcessor(new UniqueFieldQueryNodeProcessor());
+    this.spanProcessorPipeline.add(new WildcardQueryNodeProcessor());
+    this.spanProcessorPipeline.add(new SpansValidatorQueryNodeProcessor());
+    this.spanProcessorPipeline.add(new UniqueFieldQueryNodeProcessor());
 
   }
 
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java	(revision 881959)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java	(working copy)
@@ -19,10 +19,15 @@
  */
 
 import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
 import java.util.Vector;
 
 import org.apache.lucene.messages.Message;
 import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryParser.core.QueryNodeError;
+import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.QueryNodeParseException;
 import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
 import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
@@ -30,24 +35,22 @@
 import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
 import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
 import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
-import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
 import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
 import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
+import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ProximityQueryNode;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
 import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
-import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
 import org.apache.lucene.queryParser.core.parser.SyntaxParser;
 
 @SuppressWarnings("all")
 public class StandardSyntaxParser implements SyntaxParser, StandardSyntaxParserConstants {
 
-        private static final int CONJ_NONE =0;
-        private static final int CONJ_AND =2;
-        private static final int CONJ_OR =2;
-
-
    // syntax parser constructor
    public StandardSyntaxParser() {
         this(new StringReader(""));
@@ -76,36 +79,12 @@
       }
     }
 
-// *   Query  ::= ( Clause )*
-// *   Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" )
-  final public int Conjunction() throws ParseException {
-  int ret = CONJ_NONE;
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case AND:
-    case OR:
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case AND:
-        jj_consume_token(AND);
-            ret = CONJ_AND;
-        break;
-      case OR:
-        jj_consume_token(OR);
-              ret = CONJ_OR;
-        break;
-      default:
-        jj_la1[0] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
-      break;
-    default:
-      jj_la1[1] = jj_gen;
-      ;
+    public void setOpaqueExtensions(Map<String, SyntaxParser> opaqueExtensions) {
+      // do nothing, opaque extensions are not support by this SyntaxParser    
     }
-    {if (true) return ret;}
-    throw new Error("Missing return statement in function");
-  }
 
+// *   Query  ::= ( Clause )*
+// *   Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" )
   final public ModifierQueryNode.Modifier Modifiers() throws ParseException {
   ModifierQueryNode.Modifier ret = ModifierQueryNode.Modifier.MOD_NONE;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -126,13 +105,13 @@
                ret = ModifierQueryNode.Modifier.MOD_NOT;
         break;
       default:
-        jj_la1[2] = jj_gen;
+        jj_la1[0] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       break;
     default:
-      jj_la1[3] = jj_gen;
+      jj_la1[1] = jj_gen;
       ;
     }
     {if (true) return ret;}
@@ -177,7 +156,7 @@
         ;
         break;
       default:
-        jj_la1[4] = jj_gen;
+        jj_la1[2] = jj_gen;
         break label_1;
       }
       c = DisjQuery(field);
@@ -206,7 +185,7 @@
         ;
         break;
       default:
-        jj_la1[5] = jj_gen;
+        jj_la1[3] = jj_gen;
         break label_2;
       }
       jj_consume_token(OR);
@@ -236,7 +215,7 @@
         ;
         break;
       default:
-        jj_la1[6] = jj_gen;
+        jj_la1[4] = jj_gen;
         break label_3;
       }
       jj_consume_token(AND);
@@ -255,44 +234,6 @@
     throw new Error("Missing return statement in function");
   }
 
-// QueryNode Query(CharSequence field) :
-// {
-// List clauses = new ArrayList();
-//   List modifiers = new ArrayList();
-//   QueryNode q, firstQuery=null;
-//   ModifierQueryNode.Modifier mods;
-//   int conj;
-// }
-// {
-//   mods=Modifiers() q=Clause(field)
-//   {
-//     if (mods == ModifierQueryNode.Modifier.MOD_NONE) firstQuery=q;
-//     
-//     // do not create modifier nodes with MOD_NONE
-//    	if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
-//    		q = new ModifierQueryNode(q, mods);
-//    	}
-//    	clauses.add(q);
-//   }
-//   (
-//     conj=Conjunction() mods=Modifiers() q=Clause(field)
-//     { 
-// 	    // do not create modifier nodes with MOD_NONE
-// 	   	if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
-// 	   		q = new ModifierQueryNode(q, mods);
-// 	   	}
-// 	   	clauses.add(q);
-// 	   	//TODO: figure out what to do with AND and ORs
-//   }
-//   )*
-//     {
-//      if (clauses.size() == 1 && firstQuery != null)
-//         return firstQuery;
-//       else {
-//   		return new BooleanQueryNode(clauses);
-//       }
-//     }
-// }
   final public QueryNode ModClause(CharSequence field) throws ParseException {
   QueryNode q;
   ModifierQueryNode.Modifier mods;
@@ -334,13 +275,13 @@
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[7] = jj_gen;
+        jj_la1[5] = jj_gen;
         ;
       }
                                                                  group=true;
       break;
     default:
-      jj_la1[8] = jj_gen;
+      jj_la1[6] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -381,7 +322,7 @@
         term = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[9] = jj_gen;
+        jj_la1[7] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -391,7 +332,7 @@
                                 fuzzy=true;
         break;
       default:
-        jj_la1[10] = jj_gen;
+        jj_la1[8] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -404,12 +345,12 @@
                                                          fuzzy=true;
           break;
         default:
-          jj_la1[11] = jj_gen;
+          jj_la1[9] = jj_gen;
           ;
         }
         break;
       default:
-        jj_la1[12] = jj_gen;
+        jj_la1[10] = jj_gen;
         ;
       }
        if (fuzzy) {
@@ -417,10 +358,16 @@
           try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
           } catch (Exception ignored) { }
-         if(fms < 0.0f || fms > 1.0f){
+         if(fms < 0.0f){
            {if (true) throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));}
+
+         } else if (fms >= 1.0f) {
+                q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
+
+         } else {
+                q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
          }
-         q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
+
        }
       break;
     case RANGEIN_START:
@@ -433,7 +380,7 @@
         goop1 = jj_consume_token(RANGEIN_QUOTED);
         break;
       default:
-        jj_la1[13] = jj_gen;
+        jj_la1[11] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -442,7 +389,7 @@
         jj_consume_token(RANGEIN_TO);
         break;
       default:
-        jj_la1[14] = jj_gen;
+        jj_la1[12] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -453,7 +400,7 @@
         goop2 = jj_consume_token(RANGEIN_QUOTED);
         break;
       default:
-        jj_la1[15] = jj_gen;
+        jj_la1[13] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -464,7 +411,7 @@
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[16] = jj_gen;
+        jj_la1[14] = jj_gen;
         ;
       }
           if (goop1.kind == RANGEIN_QUOTED) {
@@ -490,7 +437,7 @@
         goop1 = jj_consume_token(RANGEEX_QUOTED);
         break;
       default:
-        jj_la1[17] = jj_gen;
+        jj_la1[15] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -499,7 +446,7 @@
         jj_consume_token(RANGEEX_TO);
         break;
       default:
-        jj_la1[18] = jj_gen;
+        jj_la1[16] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -510,7 +457,7 @@
         goop2 = jj_consume_token(RANGEEX_QUOTED);
         break;
       default:
-        jj_la1[19] = jj_gen;
+        jj_la1[17] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -521,7 +468,7 @@
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[20] = jj_gen;
+        jj_la1[18] = jj_gen;
         ;
       }
           if (goop1.kind == RANGEEX_QUOTED) {
@@ -544,7 +491,7 @@
         fuzzySlop = jj_consume_token(FUZZY_SLOP);
         break;
       default:
-        jj_la1[21] = jj_gen;
+        jj_la1[19] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
@@ -553,7 +500,7 @@
         boost = jj_consume_token(NUMBER);
         break;
       default:
-        jj_la1[22] = jj_gen;
+        jj_la1[20] = jj_gen;
         ;
       }
          int phraseSlop = 0;
@@ -571,7 +518,7 @@
          }
       break;
     default:
-      jj_la1[23] = jj_gen;
+      jj_la1[21] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -617,13 +564,13 @@
   private Token jj_scanpos, jj_lastpos;
   private int jj_la;
   private int jj_gen;
-  final private int[] jj_la1 = new int[24];
+  final private int[] jj_la1 = new int[22];
   static private int[] jj_la1_0;
   static {
       jj_la1_init_0();
    }
    private static void jj_la1_init_0() {
-      jj_la1_0 = new int[] {0x300,0x300,0x1c00,0x1c00,0x763c00,0x200,0x100,0x10000,0x762000,0x440000,0x80000,0x80000,0x10000,0x6000000,0x800000,0x6000000,0x10000,0x60000000,0x8000000,0x60000000,0x10000,0x80000,0x10000,0x760000,};
+      jj_la1_0 = new int[] {0x1c00,0x1c00,0x763c00,0x200,0x100,0x10000,0x762000,0x440000,0x80000,0x80000,0x10000,0x6000000,0x800000,0x6000000,0x10000,0x60000000,0x8000000,0x60000000,0x10000,0x80000,0x10000,0x760000,};
    }
   final private JJCalls[] jj_2_rtns = new JJCalls[1];
   private boolean jj_rescan = false;
@@ -640,7 +587,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -655,7 +602,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -666,7 +613,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -677,7 +624,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -687,7 +634,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -697,7 +644,7 @@
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
-    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
+    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
@@ -814,7 +761,7 @@
       la1tokens[jj_kind] = true;
       jj_kind = -1;
     }
-    for (int i = 0; i < 24; i++) {
+    for (int i = 0; i < 22; i++) {
       if (jj_la1[i] == jj_gen) {
         for (int j = 0; j < 32; j++) {
           if ((jj_la1_0[i] & (1<<j)) != 0) {
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj	(revision 881959)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj	(working copy)
@@ -33,6 +33,7 @@
 import java.io.StringReader;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
 import java.util.Vector;
 
 import org.apache.lucene.messages.Message;
@@ -61,11 +62,6 @@
 
 @SuppressWarnings("all")
 public class StandardSyntaxParser implements SyntaxParser {
-
-	private static final int CONJ_NONE =0;
-	private static final int CONJ_AND =2;
-	private static final int CONJ_OR =2;
-
  
    // syntax parser constructor
    public StandardSyntaxParser() {
@@ -94,7 +90,10 @@
             throw e;
       }
     }
-   
+      
+    public void setOpaqueExtensions(Map<String, SyntaxParser> opaqueExtensions) {
+      // do nothing, opaque extensions are not support by this SyntaxParser    
+    }
 }
 
 PARSER_END(StandardSyntaxParser)
@@ -157,17 +156,6 @@
 // *   Query  ::= ( Clause )*
 // *   Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" )
 
-int Conjunction() : {
-  int ret = CONJ_NONE;
-}
-{
-  [
-    <AND> { ret = CONJ_AND; }
-    | <OR>  { ret = CONJ_OR; }
-  ]
-  { return ret; }
-}
-
 ModifierQueryNode.Modifier Modifiers() : {
   ModifierQueryNode.Modifier ret = ModifierQueryNode.Modifier.MOD_NONE;
 }
@@ -280,45 +268,6 @@
   }
 }
 
-// QueryNode Query(CharSequence field) :
-// {
-// List clauses = new ArrayList();
-//   List modifiers = new ArrayList();
-//   QueryNode q, firstQuery=null;
-//   ModifierQueryNode.Modifier mods;
-//   int conj;
-// }
-// {
-//   mods=Modifiers() q=Clause(field)
-//   {
-//     if (mods == ModifierQueryNode.Modifier.MOD_NONE) firstQuery=q;
-//     
-//     // do not create modifier nodes with MOD_NONE
-//    	if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
-//    		q = new ModifierQueryNode(q, mods);
-//    	}
-//    	clauses.add(q);
-//   }
-//   (
-//     conj=Conjunction() mods=Modifiers() q=Clause(field)
-//     { 
-// 	    // do not create modifier nodes with MOD_NONE
-// 	   	if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
-// 	   		q = new ModifierQueryNode(q, mods);
-// 	   	}
-// 	   	clauses.add(q);
-// 	   	//TODO: figure out what to do with AND and ORs
-//   }
-//   )*
-//     {
-//      if (clauses.size() == 1 && firstQuery != null)
-//         return firstQuery;
-//       else {
-//   		return new BooleanQueryNode(clauses);
-//       }
-//     }
-// }
-
 QueryNode ModClause(CharSequence field) : {
   QueryNode q; 
   ModifierQueryNode.Modifier mods;
@@ -392,10 +341,16 @@
        	  try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
        	  } catch (Exception ignored) { }
-       	 if(fms < 0.0f || fms > 1.0f){
+       	 if(fms < 0.0f){
        	   throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));
+       	   
+       	 } else if (fms >= 1.0f) {
+       	 	q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
+       	 
+       	 } else {
+       	 	q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
        	 }
-       	 q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
+       	 
        }
      }
      | ( <RANGEIN_START> ( goop1=<RANGEIN_GOOP>|goop1=<RANGEIN_QUOTED> )
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java	(revision 881959)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParserTokenManager.java	(working copy)
@@ -17,6 +17,34 @@
  * limitations under the License.
  */
 
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Vector;
+import org.apache.lucene.messages.Message;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryParser.core.QueryNodeError;
+import org.apache.lucene.queryParser.core.QueryNodeException;
+import org.apache.lucene.queryParser.core.QueryNodeParseException;
+import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
+import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
+import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
+import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
+import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
+import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ProximityQueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
+import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
+import org.apache.lucene.queryParser.core.parser.SyntaxParser;
 
 /** Token Manager. */
 public class StandardSyntaxParserTokenManager implements StandardSyntaxParserConstants
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/SyntaxParser.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/SyntaxParser.java	(revision 881959)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/SyntaxParser.java	(working copy)
@@ -17,6 +17,8 @@
  * limitations under the License.
  */
 
+import java.util.Map;
+
 import org.apache.lucene.queryParser.core.QueryNodeParseException;
 import org.apache.lucene.queryParser.core.nodes.QueryNode;
 
@@ -33,4 +35,10 @@
    */
   public QueryNode parse(CharSequence query, CharSequence field)
       throws QueryNodeParseException;
+  
+  /**
+   * Set a Map of Opaque Extension names and SyntaxParsers
+   * @param opaqueExtensions
+   */
+  public void setOpaqueExtensions(Map<String, SyntaxParser> opaqueExtensions); 
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/OpaqueExtensionUtil.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/OpaqueExtensionUtil.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/parser/OpaqueExtensionUtil.java	(revision 0)
@@ -0,0 +1,38 @@
+package org.apache.lucene.queryParser.core.parser;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Map;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryParser.core.QueryNodeParseException;
+import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
+
+public class OpaqueExtensionUtil {
+  
+  static public SyntaxParser getParser(String extensionName, Map<String, SyntaxParser> opaqueExtensions) throws QueryNodeParseException{
+    if (opaqueExtensions == null)
+        throw new QueryNodeParseException(new MessageImpl(QueryParserMessages.OPAQUE_EXTENSIONS_NOT_SUPPORTED));
+    if (!opaqueExtensions.containsKey(extensionName))
+      throw new QueryNodeParseException(new MessageImpl(QueryParserMessages.OPAQUE_EXTENSION_NAME_NOT_SUPPORTED, extensionName));
+    
+    SyntaxParser parser = opaqueExtensions.get(extensionName);
+    parser.setOpaqueExtensions(opaqueExtensions);
+    return parser;
+  }
+}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/QueryParserMessages.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/QueryParserMessages.java	(revision 881959)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/QueryParserMessages.java	(working copy)
@@ -43,8 +43,12 @@
   public static String INVALID_SYNTAX_ESCAPE_UNICODE_TRUNCATION;
   public static String INVALID_SYNTAX_ESCAPE_CHARACTER;
   public static String INVALID_SYNTAX_ESCAPE_NONE_HEX_UNICODE;
+  public static String INVALID_NUMBER_OF_ARGUMENTS_FOR_ANY;
   public static String NODE_ACTION_NOT_SUPPORTED;
   public static String PARAMETER_VALUE_NOT_SUPPORTED;
+  public static String OPAQUE_EXTENSIONS_NOT_SUPPORTED;
+  public static String OPAQUE_EXTENSION_NAME_NOT_SUPPORTED;
+  public static String OPAQUE_EXTENSION_PARSING_ERROR;
   public static String LUCENE_QUERY_CONVERSION_ERROR;
   public static String EMPTY_MESSAGE;
   public static String WILDCARD_NOT_SUPPORTED;
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/QueryNodeProcessorPipeline.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/QueryNodeProcessorPipeline.java	(revision 881959)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/processors/QueryNodeProcessorPipeline.java	(working copy)
@@ -17,7 +17,11 @@
  * limitations under the License.
  */
 
+import java.util.Collection;
+import java.util.Iterator;
 import java.util.LinkedList;
+import java.util.List;
+import java.util.ListIterator;
 
 import org.apache.lucene.queryParser.core.QueryNodeException;
 import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
@@ -33,11 +37,12 @@
  * processors were on the pipeline.
  * 
  * When a {@link QueryConfigHandler} object is set on a
- * {@link QueryNodeProcessorPipeline}, it takes care of also setting this
+ * {@link QueryNodeProcessorPipeline}, it also takes care of setting this
  * {@link QueryConfigHandler} on all processor on pipeline.
  * 
  */
-public class QueryNodeProcessorPipeline implements QueryNodeProcessor {
+public class QueryNodeProcessorPipeline implements QueryNodeProcessor,
+    List<QueryNodeProcessor> {
 
   private LinkedList<QueryNodeProcessor> processors = new LinkedList<QueryNodeProcessor>();
 
@@ -74,11 +79,10 @@
    * For reference about this method check:
    * {@link QueryNodeProcessor#process(QueryNode)}.
    * 
-   * @param queryTree
-   *          the query node tree to be processed
+   * @param queryTree the query node tree to be processed
    * 
-   * @throws QueryNodeException
-   *           if something goes wrong during the query node processing
+   * @throws QueryNodeException if something goes wrong during the query node
+   *         processing
    * 
    * @see QueryNode
    */
@@ -96,8 +100,10 @@
    * Adds a processor to the pipeline, it's always added to the end of the
    * pipeline.
    * 
-   * @param processor
-   *          the processor to be added
+   * @deprecated this class now conforms to {@link List} interface, so use
+   *             {@link #add(QueryNodeProcessor)} instead
+   * 
+   * @param processor the processor to be added
    */
   public void addProcessor(QueryNodeProcessor processor) {
     this.processors.add(processor);
@@ -110,8 +116,7 @@
    * For reference about this method check:
    * {@link QueryNodeProcessor#setQueryConfigHandler(QueryConfigHandler)}.
    * 
-   * @param queryConfigHandler
-   *          the query configuration handler to be set.
+   * @param queryConfigHandler the query configuration handler to be set.
    * 
    * @see QueryNodeProcessor#getQueryConfigHandler()
    * @see QueryConfigHandler
@@ -125,4 +130,195 @@
 
   }
 
+  /**
+   * @see List#add(Object)
+   */
+  public boolean add(QueryNodeProcessor processor) {
+    boolean added = this.processors.add(processor);
+
+    if (added) {
+      processor.setQueryConfigHandler(this.queryConfig);
+    }
+
+    return added;
+
+  }
+
+  /**
+   * @see List#add(int, Object)
+   */
+  public void add(int index, QueryNodeProcessor processor) {
+    this.processors.add(index, processor);
+    processor.setQueryConfigHandler(this.queryConfig);
+
+  }
+
+  /**
+   * @see List#addAll(Collection)
+   */
+  public boolean addAll(Collection<? extends QueryNodeProcessor> c) {
+    boolean anyAdded = this.processors.addAll(c);
+
+    for (QueryNodeProcessor processor : c) {
+      processor.setQueryConfigHandler(this.queryConfig);
+    }
+
+    return anyAdded;
+
+  }
+
+  /**
+   * @see List#addAll(int, Collection)
+   */
+  public boolean addAll(int index, Collection<? extends QueryNodeProcessor> c) {
+    boolean anyAdded = this.processors.addAll(index, c);
+
+    for (QueryNodeProcessor processor : c) {
+      processor.setQueryConfigHandler(this.queryConfig);
+    }
+
+    return anyAdded;
+    
+  }
+
+  /**
+   * @see List#clear()
+   */
+  public void clear() {
+    this.processors.clear();
+  }
+
+  /**
+   * @see List#contains(Object)
+   */
+  public boolean contains(Object o) {
+    return this.processors.contains(o);
+  }
+
+  /**
+   * @see List#containsAll(Collection)
+   */
+  public boolean containsAll(Collection<?> c) {
+    return this.processors.containsAll(c);
+  }
+
+  /**
+   * @see List#get(int)
+   */
+  public QueryNodeProcessor get(int index) {
+    return this.processors.get(index);
+  }
+
+  /**
+   * @see List#indexOf(Object)
+   */
+  public int indexOf(Object o) {
+    return this.processors.indexOf(o);
+  }
+
+  /**
+   * @see List#isEmpty()
+   */
+  public boolean isEmpty() {
+    return this.processors.isEmpty();
+  }
+
+  /**
+   * @see List#iterator()
+   */
+  public Iterator<QueryNodeProcessor> iterator() {
+    return this.processors.iterator();
+  }
+
+  /**
+   * @see List#lastIndexOf(Object)
+   */
+  public int lastIndexOf(Object o) {
+    return this.processors.lastIndexOf(o);
+  }
+
+  /**
+   * @see List#listIterator()
+   */
+  public ListIterator<QueryNodeProcessor> listIterator() {
+    return this.processors.listIterator();
+  }
+
+  /**
+   * @see List#listIterator(int)
+   */
+  public ListIterator<QueryNodeProcessor> listIterator(int index) {
+    return this.processors.listIterator(index);
+  }
+
+  /**
+   * @see List#remove(Object)
+   */
+  public boolean remove(Object o) {
+    return this.processors.remove(o);
+  }
+
+  /**
+   * @see List#remove(int)
+   */
+  public QueryNodeProcessor remove(int index) {
+    return this.processors.remove(index);
+  }
+
+  /**
+   * @see List#removeAll(Collection)
+   */
+  public boolean removeAll(Collection<?> c) {
+    return this.processors.removeAll(c);
+  }
+
+  /**
+   * @see List#retainAll(Collection)
+   */
+  public boolean retainAll(Collection<?> c) {
+    return this.processors.retainAll(c);
+  }
+
+  /**
+   * @see List#set(int, Object)
+   */
+  public QueryNodeProcessor set(int index, QueryNodeProcessor processor) {
+    QueryNodeProcessor oldProcessor = this.processors.set(index, processor);
+    
+    if (oldProcessor != processor) {
+      processor.setQueryConfigHandler(this.queryConfig);
+    }
+    
+    return oldProcessor;
+    
+  }
+
+  /**
+   * @see List#size()
+   */
+  public int size() {
+    return this.processors.size();
+  }
+
+  /**
+   * @see List#subList(int, int)
+   */
+  public List<QueryNodeProcessor> subList(int fromIndex, int toIndex) {
+    return this.processors.subList(fromIndex, toIndex);
+  }
+
+  /**
+   * @see List#toArray(Object[])
+   */
+  public <T> T[] toArray(T[] array) {
+    return this.processors.toArray(array);
+  }
+
+  /**
+   * @see List#toArray()
+   */
+  public Object[] toArray() {
+    return this.processors.toArray();
+  }
+
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/OpaqueQueryNode.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/OpaqueQueryNode.java	(revision 881959)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/core/nodes/OpaqueQueryNode.java	(working copy)
@@ -17,7 +17,10 @@
  * limitations under the License.
  */
 
+import java.util.Locale;
+
 import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
+import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax.Type;
 
 /**
  * A {@link OpaqueQueryNode} is used for specify values that are not supposed to
@@ -28,48 +31,61 @@
 
   private static final long serialVersionUID = 0L;
 
-  private CharSequence schema = null;
+  private CharSequence extensionName = null;
+  
+  private CharSequence field = null;
 
   private CharSequence value = null;
 
   /**
-   * @param schema
-   *          - schema identifier
+   * @param extensionName
+   *          - extensionName identifier
    * @param value
    *          - value that was not parsed
    */
-  public OpaqueQueryNode(CharSequence schema, CharSequence value) {
+  public OpaqueQueryNode(CharSequence extensionName,  CharSequence field, CharSequence value, int begin, int end) {
     this.setLeaf(true);
 
-    this.schema = schema;
+    this.extensionName = extensionName;
+    this.field = field;
     this.value = value;
 
   }
 
   @Override
   public String toString() {
-    return "<opaque schema='" + this.schema + "' value='" + this.value + "'/>";
+    return "<opaque extensionName='" + this.extensionName + "' field='"
+    + this.field + "' value='" + this.value + "'/>";
   }
 
   public CharSequence toQueryString(EscapeQuerySyntax escapeSyntaxParser) {
-    return "@" + this.schema + ":'" + this.value + "'";
+    if (isDefaultField(this.field)) {
+      return this.extensionName + "::\"" + getValueEscapedQuoted(escapeSyntaxParser) + "\"";
+    } else {
+      return this.extensionName + ":" + this.field +":'" + getValueEscapedQuoted(escapeSyntaxParser) + "'";
+    }
+    
+  }
+  
+  private CharSequence getValueEscapedQuoted(EscapeQuerySyntax escaper) {
+    return escaper.escape(this.value, Locale.getDefault(), Type.STRING);
   }
 
   @Override
   public QueryNode cloneTree() throws CloneNotSupportedException {
     OpaqueQueryNode clone = (OpaqueQueryNode) super.cloneTree();
 
-    clone.schema = this.schema;
+    clone.extensionName = this.extensionName;
     clone.value = this.value;
 
     return clone;
   }
 
   /**
-   * @return the schema
+   * @return the Extension Name
    */
-  public CharSequence getSchema() {
-    return this.schema;
+  public CharSequence getExtensionName() {
+    return this.extensionName;
   }
 
   /**
@@ -79,4 +95,12 @@
     return this.value;
   }
 
+  public CharSequence getField() {
+    return this.field;
+  }
+
+  public void setField(CharSequence field) {
+    this.field = field;
+  }
+  
 }
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/Standard2QueryParser.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/Standard2QueryParser.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/Standard2QueryParser.java	(revision 0)
@@ -0,0 +1,61 @@
+package org.apache.lucene.queryParser.standard2;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.queryParser.standard.StandardQueryParser;
+import org.apache.lucene.queryParser.standard.builders.StandardQueryTreeBuilder;
+import org.apache.lucene.queryParser.standard.config.StandardQueryConfigHandler;
+import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
+import org.apache.lucene.queryParser.standard2.parser.Standard2SyntaxParser;
+import org.apache.lucene.queryParser.standard2.processors.Standard2QueryNodeProcessorPipeline;
+
+/**
+ * <p>
+ * This query parser works exactly as the standard query parser ( {@link StandardQueryParser} ), 
+ * except that it respect the boolean precedence, so <a AND b OR c AND d> is parsed to <(+a +b) (+c +d)>
+ * instead of <+a +b +c +d>.
+ * </p>
+ * <p>
+ * EXPERT: This class extends {@link StandardQueryParser}, but uses {@link Standard2QueryNodeProcessorPipeline}
+ * instead of {@link StandardQueryNodeProcessorPipeline} to process the query tree.
+ * </p>
+ * 
+ * @see StandardQueryParser
+ */
+public class Standard2QueryParser extends StandardQueryParser {
+  
+  /**
+   * @see StandardQueryParser#StandardQueryParser()
+   */
+  public Standard2QueryParser() {
+    setSyntaxParser(new Standard2SyntaxParser());
+    setQueryBuilder(new StandardQueryTreeBuilder());
+    setQueryConfigHandler(new StandardQueryConfigHandler());
+    setQueryNodeProcessor(new Standard2QueryNodeProcessorPipeline(getQueryConfigHandler()));
+  }
+  
+  /**
+   * @see StandardQueryParser#StandardQueryParser(Analyzer)
+   */
+  public Standard2QueryParser(Analyzer analyer) {
+    this();
+    setAnalyzer(analyer);
+  }
+
+}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/package.html
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/package.html	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/package.html	(revision 0)
@@ -0,0 +1,39 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+This package contains the Precedence Query Parser Implementation
+
+<h2>Lucene Precedence Query Parser</h2>
+
+<p>
+The Precedence Query Parser extends the Standard Query Parser and enables 
+the boolean precedence. So, the query <a AND b OR c AND d> is parsed to 
+<(+a +b) (+c +d)> instead of <+a +b +c +d>.
+</p>
+<p>
+Check {@link org.apache.lucene.queryParser.standard.StandardQueryParser} for more details about the
+supported syntax and query parser functionalities. 
+</p>
+
+</body>
+</html>
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/EscapeQuerySyntaxImpl.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/EscapeQuerySyntaxImpl.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/EscapeQuerySyntaxImpl.java	(revision 0)
@@ -0,0 +1,296 @@
+package org.apache.lucene.queryParser.standard2.parser;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Locale;
+
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
+import org.apache.lucene.queryParser.core.parser.EscapeQuerySyntax;
+import org.apache.lucene.queryParser.core.util.UnescapedCharSequence;
+
+/**
+ */
+public class EscapeQuerySyntaxImpl implements EscapeQuerySyntax {
+
+  private static final char[] wildcardChars = { '*', '?' };
+
+  private static final String[] escapableTermExtraFirstChars = { "+", "-", "@" };
+
+  private static final String[] escapableTermChars = { "\"", "<", ">", "=",
+      "!", "(", ")", "^", "[", "{", ":", "]", "}", "~" };
+
+  // TODO: check what to do with these "*", "?", "\\"
+  private static final String[] escapableQuotedChars = { "\"" };
+  private static final String[] escapableWhiteChars = { " ", "\t", "\n", "\r",
+      "\f", "\b", "\u3000" };
+  private static final String[] escapableWordTokens = { "AND", "OR", "NOT",
+      "TO", "WITHIN", "SENTENCE", "PARAGRAPH", "INORDER" };
+
+  private static final CharSequence escapeChar(CharSequence str, Locale locale) {
+    if (str == null || str.length() == 0)
+      return str;
+
+    CharSequence buffer = str;
+
+    // regular escapable Char for terms
+    for (int i = 0; i < escapableTermChars.length; i++) {
+      buffer = replaceIgnoreCase(buffer, escapableTermChars[i].toLowerCase(),
+          "\\", locale);
+    }
+
+    // First Character of a term as more escaping chars
+    for (int i = 0; i < escapableTermExtraFirstChars.length; i++) {
+      if (buffer.charAt(0) == escapableTermExtraFirstChars[i].charAt(0)) {
+        buffer = "\\" + buffer.charAt(0)
+            + buffer.subSequence(1, buffer.length());
+        break;
+      }
+    }
+
+    return buffer;
+  }
+
+  private final CharSequence escapeQuoted(CharSequence str, Locale locale) {
+    if (str == null || str.length() == 0)
+      return str;
+
+    CharSequence buffer = str;
+
+    for (int i = 0; i < escapableQuotedChars.length; i++) {
+      buffer = replaceIgnoreCase(buffer, escapableTermChars[i].toLowerCase(),
+          "\\", locale);
+    }
+    return buffer;
+  }
+
+  private static final CharSequence escapeTerm(CharSequence term, Locale locale) {
+    if (term == null)
+      return term;
+
+    // Escape single Chars
+    term = escapeChar(term, locale);
+    term = escapeWhiteChar(term, locale);
+
+    // Escape Parser Words
+    for (int i = 0; i < escapableWordTokens.length; i++) {
+      if (escapableWordTokens[i].equalsIgnoreCase(term.toString()))
+        return "\\" + term;
+    }
+    return term;
+  }
+
+  /**
+   * replace with ignore case
+   * 
+   * @param string
+   *          string to get replaced
+   * @param sequence1
+   *          the old character sequence in lowercase
+   * @param escapeChar
+   *          the new character to prefix sequence1 in return string.
+   * @return the new String
+   */
+  private static CharSequence replaceIgnoreCase(CharSequence string,
+      CharSequence sequence1, CharSequence escapeChar, Locale locale) {
+    if (escapeChar == null || sequence1 == null || string == null)
+      throw new NullPointerException();
+
+    // empty string case
+    int count = string.length();
+    int sequence1Length = sequence1.length();
+    if (sequence1Length == 0) {
+      StringBuilder result = new StringBuilder((count + 1)
+          * escapeChar.length());
+      result.append(escapeChar);
+      for (int i = 0; i < count; i++) {
+        result.append(string.charAt(i));
+        result.append(escapeChar);
+      }
+      return result.toString();
+    }
+
+    // normal case
+    StringBuilder result = new StringBuilder();
+    char first = sequence1.charAt(0);
+    int start = 0, copyStart = 0, firstIndex;
+    while (start < count) {
+      if ((firstIndex = string.toString().toLowerCase(locale).indexOf(first,
+          start)) == -1)
+        break;
+      boolean found = true;
+      if (sequence1.length() > 1) {
+        if (firstIndex + sequence1Length > count)
+          break;
+        for (int i = 1; i < sequence1Length; i++) {
+          if (string.toString().toLowerCase(locale).charAt(firstIndex + i) != sequence1
+              .charAt(i)) {
+            found = false;
+            break;
+          }
+        }
+      }
+      if (found) {
+        result.append(string.toString().substring(copyStart, firstIndex));
+        result.append(escapeChar);
+        result.append(string.toString().substring(firstIndex,
+            firstIndex + sequence1Length));
+        copyStart = start = firstIndex + sequence1Length;
+      } else {
+        start = firstIndex + 1;
+      }
+    }
+    if (result.length() == 0 && copyStart == 0)
+      return string;
+    result.append(string.toString().substring(copyStart));
+    return result.toString();
+  }
+
+  /**
+   * escape all tokens that are part of the parser syntax on a given string
+   * 
+   * @param str
+   *          string to get replaced
+   * @param locale
+   *          locale to be used when performing string compares
+   * @return the new String
+   */
+  private static final CharSequence escapeWhiteChar(CharSequence str,
+      Locale locale) {
+    if (str == null || str.length() == 0)
+      return str;
+
+    CharSequence buffer = str;
+
+    for (int i = 0; i < escapableWhiteChars.length; i++) {
+      buffer = replaceIgnoreCase(buffer, escapableWhiteChars[i].toLowerCase(),
+          "\\", locale);
+    }
+    return buffer;
+  }
+
+  public CharSequence escape(CharSequence text, Locale locale, Type type) {
+    if (text == null || text.length() == 0)
+      return text;
+
+    // escape wildcards and the escape char (this has to be perform before
+    // anything else)
+    // since we need to preserve the UnescapedCharSequence and escape the
+    // original escape chars
+    if (text instanceof UnescapedCharSequence) {
+      text = ((UnescapedCharSequence) text).toStringEscaped(wildcardChars);
+    } else {
+      text = new UnescapedCharSequence(text).toStringEscaped(wildcardChars);
+    }
+
+    if (type == Type.STRING) {
+      return escapeQuoted(text, locale);
+    } else {
+      return escapeTerm(text, locale);
+    }
+  }
+
+  /**
+   * Returns a String where the escape char has been removed, or kept only once
+   * if there was a double escape.
+   * 
+   * Supports escaped unicode characters, e. g. translates <code>A</code> to
+   * <code>A</code>.
+   * 
+   */
+  public static UnescapedCharSequence discardEscapeChar(CharSequence input)
+      throws ParseException {
+    // Create char array to hold unescaped char sequence
+    char[] output = new char[input.length()];
+    boolean[] wasEscaped = new boolean[input.length()];
+
+    // The length of the output can be less than the input
+    // due to discarded escape chars. This variable holds
+    // the actual length of the output
+    int length = 0;
+
+    // We remember whether the last processed character was
+    // an escape character
+    boolean lastCharWasEscapeChar = false;
+
+    // The multiplier the current unicode digit must be multiplied with.
+    // E. g. the first digit must be multiplied with 16^3, the second with
+    // 16^2...
+    int codePointMultiplier = 0;
+
+    // Used to calculate the codepoint of the escaped unicode character
+    int codePoint = 0;
+
+    for (int i = 0; i < input.length(); i++) {
+      char curChar = input.charAt(i);
+      if (codePointMultiplier > 0) {
+        codePoint += hexToInt(curChar) * codePointMultiplier;
+        codePointMultiplier >>>= 4;
+        if (codePointMultiplier == 0) {
+          output[length++] = (char) codePoint;
+          codePoint = 0;
+        }
+      } else if (lastCharWasEscapeChar) {
+        if (curChar == 'u') {
+          // found an escaped unicode character
+          codePointMultiplier = 16 * 16 * 16;
+        } else {
+          // this character was escaped
+          output[length] = curChar;
+          wasEscaped[length] = true;
+          length++;
+        }
+        lastCharWasEscapeChar = false;
+      } else {
+        if (curChar == '\\') {
+          lastCharWasEscapeChar = true;
+        } else {
+          output[length] = curChar;
+          length++;
+        }
+      }
+    }
+
+    if (codePointMultiplier > 0) {
+      throw new ParseException(new MessageImpl(
+          QueryParserMessages.INVALID_SYNTAX_ESCAPE_UNICODE_TRUNCATION));
+    }
+
+    if (lastCharWasEscapeChar) {
+      throw new ParseException(new MessageImpl(
+          QueryParserMessages.INVALID_SYNTAX_ESCAPE_CHARACTER));
+    }
+
+    return new UnescapedCharSequence(output, wasEscaped, 0, length);
+  }
+
+  /** Returns the numeric value of the hexadecimal character */
+  private static final int hexToInt(char c) throws ParseException {
+    if ('0' <= c && c <= '9') {
+      return c - '0';
+    } else if ('a' <= c && c <= 'f') {
+      return c - 'a' + 10;
+    } else if ('A' <= c && c <= 'F') {
+      return c - 'A' + 10;
+    } else {
+      throw new ParseException(new MessageImpl(
+          QueryParserMessages.INVALID_SYNTAX_ESCAPE_NONE_HEX_UNICODE, c));
+    }
+  }
+
+}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/JavaCharStream.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/JavaCharStream.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/JavaCharStream.java	(revision 0)
@@ -0,0 +1,617 @@
+/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 4.1 */
+/* JavaCCOptions:STATIC=false,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
+package org.apache.lucene.queryParser.standard2.parser;
+
+/**
+ * An implementation of interface CharStream, where the stream is assumed to
+ * contain only ASCII characters (with java-like unicode escape processing).
+ */
+
+public
+class JavaCharStream
+{
+  /** Whether parser is static. */
+  public static final boolean staticFlag = false;
+
+  static final int hexval(char c) throws java.io.IOException {
+    switch(c)
+    {
+       case '0' :
+          return 0;
+       case '1' :
+          return 1;
+       case '2' :
+          return 2;
+       case '3' :
+          return 3;
+       case '4' :
+          return 4;
+       case '5' :
+          return 5;
+       case '6' :
+          return 6;
+       case '7' :
+          return 7;
+       case '8' :
+          return 8;
+       case '9' :
+          return 9;
+
+       case 'a' :
+       case 'A' :
+          return 10;
+       case 'b' :
+       case 'B' :
+          return 11;
+       case 'c' :
+       case 'C' :
+          return 12;
+       case 'd' :
+       case 'D' :
+          return 13;
+       case 'e' :
+       case 'E' :
+          return 14;
+       case 'f' :
+       case 'F' :
+          return 15;
+    }
+
+    throw new java.io.IOException(); // Should never come here
+  }
+
+/** Position in buffer. */
+  public int bufpos = -1;
+  int bufsize;
+  int available;
+  int tokenBegin;
+  protected int bufline[];
+  protected int bufcolumn[];
+
+  protected int column = 0;
+  protected int line = 1;
+
+  protected boolean prevCharIsCR = false;
+  protected boolean prevCharIsLF = false;
+
+  protected java.io.Reader inputStream;
+
+  protected char[] nextCharBuf;
+  protected char[] buffer;
+  protected int maxNextCharInd = 0;
+  protected int nextCharInd = -1;
+  protected int inBuf = 0;
+  protected int tabSize = 8;
+
+  protected void setTabSize(int i) { tabSize = i; }
+  protected int getTabSize(int i) { return tabSize; }
+
+  protected void ExpandBuff(boolean wrapAround)
+  {
+    char[] newbuffer = new char[bufsize + 2048];
+    int newbufline[] = new int[bufsize + 2048];
+    int newbufcolumn[] = new int[bufsize + 2048];
+
+    try
+    {
+      if (wrapAround)
+      {
+        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+        System.arraycopy(buffer, 0, newbuffer, bufsize - tokenBegin, bufpos);
+        buffer = newbuffer;
+
+        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+        System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
+        bufline = newbufline;
+
+        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+        System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
+        bufcolumn = newbufcolumn;
+
+        bufpos += (bufsize - tokenBegin);
+    }
+    else
+    {
+        System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
+        buffer = newbuffer;
+
+        System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
+        bufline = newbufline;
+
+        System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
+        bufcolumn = newbufcolumn;
+
+        bufpos -= tokenBegin;
+      }
+    }
+    catch (Throwable t)
+    {
+      throw new Error(t.getMessage());
+    }
+
+    available = (bufsize += 2048);
+    tokenBegin = 0;
+  }
+
+  protected void FillBuff() throws java.io.IOException
+  {
+    int i;
+    if (maxNextCharInd == 4096)
+      maxNextCharInd = nextCharInd = 0;
+
+    try {
+      if ((i = inputStream.read(nextCharBuf, maxNextCharInd,
+                                          4096 - maxNextCharInd)) == -1)
+      {
+        inputStream.close();
+        throw new java.io.IOException();
+      }
+      else
+         maxNextCharInd += i;
+      return;
+    }
+    catch(java.io.IOException e) {
+      if (bufpos != 0)
+      {
+        --bufpos;
+        backup(0);
+      }
+      else
+      {
+        bufline[bufpos] = line;
+        bufcolumn[bufpos] = column;
+      }
+      throw e;
+    }
+  }
+
+  protected char ReadByte() throws java.io.IOException
+  {
+    if (++nextCharInd >= maxNextCharInd)
+      FillBuff();
+
+    return nextCharBuf[nextCharInd];
+  }
+
+/** @return starting character for token. */
+  public char BeginToken() throws java.io.IOException
+  {
+    if (inBuf > 0)
+    {
+      --inBuf;
+
+      if (++bufpos == bufsize)
+        bufpos = 0;
+
+      tokenBegin = bufpos;
+      return buffer[bufpos];
+    }
+
+    tokenBegin = 0;
+    bufpos = -1;
+
+    return readChar();
+  }
+
+  protected void AdjustBuffSize()
+  {
+    if (available == bufsize)
+    {
+      if (tokenBegin > 2048)
+      {
+        bufpos = 0;
+        available = tokenBegin;
+      }
+      else
+        ExpandBuff(false);
+    }
+    else if (available > tokenBegin)
+      available = bufsize;
+    else if ((tokenBegin - available) < 2048)
+      ExpandBuff(true);
+    else
+      available = tokenBegin;
+  }
+
+  protected void UpdateLineColumn(char c)
+  {
+    column++;
+
+    if (prevCharIsLF)
+    {
+      prevCharIsLF = false;
+      line += (column = 1);
+    }
+    else if (prevCharIsCR)
+    {
+      prevCharIsCR = false;
+      if (c == '\n')
+      {
+        prevCharIsLF = true;
+      }
+      else
+        line += (column = 1);
+    }
+
+    switch (c)
+    {
+      case '\r' :
+        prevCharIsCR = true;
+        break;
+      case '\n' :
+        prevCharIsLF = true;
+        break;
+      case '\t' :
+        column--;
+        column += (tabSize - (column % tabSize));
+        break;
+      default :
+        break;
+    }
+
+    bufline[bufpos] = line;
+    bufcolumn[bufpos] = column;
+  }
+
+/** Read a character. */
+  public char readChar() throws java.io.IOException
+  {
+    if (inBuf > 0)
+    {
+      --inBuf;
+
+      if (++bufpos == bufsize)
+        bufpos = 0;
+
+      return buffer[bufpos];
+    }
+
+    char c;
+
+    if (++bufpos == available)
+      AdjustBuffSize();
+
+    if ((buffer[bufpos] = c = ReadByte()) == '\\')
+    {
+      UpdateLineColumn(c);
+
+      int backSlashCnt = 1;
+
+      for (;;) // Read all the backslashes
+      {
+        if (++bufpos == available)
+          AdjustBuffSize();
+
+        try
+        {
+          if ((buffer[bufpos] = c = ReadByte()) != '\\')
+          {
+            UpdateLineColumn(c);
+            // found a non-backslash char.
+            if ((c == 'u') && ((backSlashCnt & 1) == 1))
+            {
+              if (--bufpos < 0)
+                bufpos = bufsize - 1;
+
+              break;
+            }
+
+            backup(backSlashCnt);
+            return '\\';
+          }
+        }
+        catch(java.io.IOException e)
+        {
+	  // We are returning one backslash so we should only backup (count-1)
+          if (backSlashCnt > 1)
+            backup(backSlashCnt-1);
+
+          return '\\';
+        }
+
+        UpdateLineColumn(c);
+        backSlashCnt++;
+      }
+
+      // Here, we have seen an odd number of backslash's followed by a 'u'
+      try
+      {
+        while ((c = ReadByte()) == 'u')
+          ++column;
+
+        buffer[bufpos] = c = (char)(hexval(c) << 12 |
+                                    hexval(ReadByte()) << 8 |
+                                    hexval(ReadByte()) << 4 |
+                                    hexval(ReadByte()));
+
+        column += 4;
+      }
+      catch(java.io.IOException e)
+      {
+        throw new Error("Invalid escape character at line " + line +
+                                         " column " + column + ".");
+      }
+
+      if (backSlashCnt == 1)
+        return c;
+      else
+      {
+        backup(backSlashCnt - 1);
+        return '\\';
+      }
+    }
+    else
+    {
+      UpdateLineColumn(c);
+      return c;
+    }
+  }
+
+  @Deprecated
+  /**
+   * @deprecated
+   * @see #getEndColumn
+   */
+  public int getColumn() {
+    return bufcolumn[bufpos];
+  }
+
+  @Deprecated
+  /**
+   * @deprecated
+   * @see #getEndLine
+   */
+  public int getLine() {
+    return bufline[bufpos];
+  }
+
+/** Get end column. */
+  public int getEndColumn() {
+    return bufcolumn[bufpos];
+  }
+
+/** Get end line. */
+  public int getEndLine() {
+    return bufline[bufpos];
+  }
+
+/** @return column of token start */
+  public int getBeginColumn() {
+    return bufcolumn[tokenBegin];
+  }
+
+/** @return line number of token start */
+  public int getBeginLine() {
+    return bufline[tokenBegin];
+  }
+
+/** Retreat. */
+  public void backup(int amount) {
+
+    inBuf += amount;
+    if ((bufpos -= amount) < 0)
+      bufpos += bufsize;
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    available = bufsize = buffersize;
+    buffer = new char[buffersize];
+    bufline = new int[buffersize];
+    bufcolumn = new int[buffersize];
+    nextCharBuf = new char[4096];
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+    this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.Reader dstream)
+  {
+    this(dstream, 1, 1, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                 int startline, int startcolumn, int buffersize)
+  {
+    inputStream = dstream;
+    line = startline;
+    column = startcolumn - 1;
+
+    if (buffer == null || buffersize != buffer.length)
+    {
+      available = bufsize = buffersize;
+      buffer = new char[buffersize];
+      bufline = new int[buffersize];
+      bufcolumn = new int[buffersize];
+      nextCharBuf = new char[4096];
+    }
+    prevCharIsLF = prevCharIsCR = false;
+    tokenBegin = inBuf = maxNextCharInd = 0;
+    nextCharInd = bufpos = -1;
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream,
+                                        int startline, int startcolumn)
+  {
+    ReInit(dstream, startline, startcolumn, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.Reader dstream)
+  {
+    ReInit(dstream, 1, 1, 4096);
+  }
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+    this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+                        int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+    this(dstream, encoding, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, int startline,
+                        int startcolumn)
+  {
+    this(dstream, startline, startcolumn, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+    this(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Constructor. */
+  public JavaCharStream(java.io.InputStream dstream)
+  {
+    this(dstream, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+  int startcolumn, int buffersize)
+  {
+    ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                     int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(dstream, encoding, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, int startline,
+                     int startcolumn)
+  {
+    ReInit(dstream, startline, startcolumn, 4096);
+  }
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+    ReInit(dstream, encoding, 1, 1, 4096);
+  }
+
+/** Reinitialise. */
+  public void ReInit(java.io.InputStream dstream)
+  {
+    ReInit(dstream, 1, 1, 4096);
+  }
+
+  /** @return token image as String */
+  public String GetImage()
+  {
+    if (bufpos >= tokenBegin)
+      return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
+    else
+      return new String(buffer, tokenBegin, bufsize - tokenBegin) +
+                              new String(buffer, 0, bufpos + 1);
+  }
+
+  /** @return suffix */
+  public char[] GetSuffix(int len)
+  {
+    char[] ret = new char[len];
+
+    if ((bufpos + 1) >= len)
+      System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
+    else
+    {
+      System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
+                                                        len - bufpos - 1);
+      System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
+    }
+
+    return ret;
+  }
+
+  /** Set buffers back to null when finished. */
+  public void Done()
+  {
+    nextCharBuf = null;
+    buffer = null;
+    bufline = null;
+    bufcolumn = null;
+  }
+
+  /**
+   * Method to adjust line and column numbers for the start of a token.
+   */
+  public void adjustBeginLineColumn(int newLine, int newCol)
+  {
+    int start = tokenBegin;
+    int len;
+
+    if (bufpos >= tokenBegin)
+    {
+      len = bufpos - tokenBegin + inBuf + 1;
+    }
+    else
+    {
+      len = bufsize - tokenBegin + bufpos + 1 + inBuf;
+    }
+
+    int i = 0, j = 0, k = 0;
+    int nextColDiff = 0, columnDiff = 0;
+
+    while (i < len && bufline[j = start % bufsize] == bufline[k = ++start % bufsize])
+    {
+      bufline[j] = newLine;
+      nextColDiff = columnDiff + bufcolumn[k] - bufcolumn[j];
+      bufcolumn[j] = newCol + columnDiff;
+      columnDiff = nextColDiff;
+      i++;
+    }
+
+    if (i < len)
+    {
+      bufline[j] = newLine++;
+      bufcolumn[j] = newCol + columnDiff;
+
+      while (i++ < len)
+      {
+        if (bufline[j = start % bufsize] != bufline[++start % bufsize])
+          bufline[j] = newLine++;
+        else
+          bufline[j] = newLine;
+      }
+    }
+
+    line = bufline[j];
+    column = bufcolumn[j];
+  }
+
+}
+/* JavaCC - OriginalChecksum=cf9f0e39a9ca5ca182d86165c975d0a3 (do not edit this line) */
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/ParseException.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/ParseException.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/ParseException.java	(revision 0)
@@ -0,0 +1,201 @@
+/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 4.1 */
+/* JavaCCOptions:KEEP_LINE_COL=null */
+package org.apache.lucene.queryParser.standard2.parser;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+import org.apache.lucene.messages.Message;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryParser.core.QueryNodeParseException;
+import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
+
+/**
+ * This exception is thrown when parse errors are encountered. You can
+ * explicitly create objects of this exception type by calling the method
+ * generateParseException in the generated parser.
+ * 
+ * You can modify this class to customize your error reporting mechanisms so
+ * long as you retain the public fields.
+ */
+public class ParseException extends QueryNodeParseException {
+
+  /**
+   * The version identifier for this Serializable class. Increment only if the
+   * <i>serialized</i> form of the class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /**
+   * This constructor is used by the method "generateParseException" in the
+   * generated parser. Calling this constructor generates a new object of this
+   * type with the fields "currentToken", "expectedTokenSequences", and
+   * "tokenImage" set.
+   */
+  public ParseException(Token currentTokenVal,
+      int[][] expectedTokenSequencesVal, String[] tokenImageVal) {
+    super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, initialise(
+        currentTokenVal, expectedTokenSequencesVal, tokenImageVal)));
+    this.currentToken = currentTokenVal;
+    this.expectedTokenSequences = expectedTokenSequencesVal;
+    this.tokenImage = tokenImageVal;
+  }
+
+  public ParseException(Message message) {
+    super(message);
+  }
+  
+  public ParseException(Message message, Throwable throwable) {
+    super(message, throwable);
+  }
+
+  public ParseException() {
+    super(new MessageImpl(QueryParserMessages.INVALID_SYNTAX, "Error"));
+  }
+
+  /**
+   * This is the last token that has been consumed successfully. If this object
+   * has been created due to a parse error, the token followng this token will
+   * (therefore) be the first error token.
+   */
+  @SuppressWarnings("unused")
+  private Token currentToken;
+
+  /**
+   * Each entry in this array is an array of integers. Each array of integers
+   * represents a sequence of tokens (by their ordinal values) that is expected
+   * at this point of the parse.
+   */
+  @SuppressWarnings("unused")
+  private int[][] expectedTokenSequences;
+
+  /**
+   * This is a reference to the "tokenImage" array of the generated parser
+   * within which the parse error occurred. This array is defined in the
+   * generated ...Constants interface.
+   */
+  @SuppressWarnings("unused")
+  private String[] tokenImage;
+
+  /**
+   * It uses "currentToken" and "expectedTokenSequences" to generate a parse
+   * error message and returns it. If this object has been created due to a
+   * parse error, and you do not catch it (it gets thrown from the parser) the
+   * correct error message gets displayed.
+   */
+  private static String initialise(Token currentToken,
+      int[][] expectedTokenSequences, String[] tokenImage) {
+    String eol = System.getProperty("line.separator", "\n");
+    StringBuffer expected = new StringBuffer();
+    int maxSize = 0;
+    for (int i = 0; i < expectedTokenSequences.length; i++) {
+      if (maxSize < expectedTokenSequences[i].length) {
+        maxSize = expectedTokenSequences[i].length;
+      }
+      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
+        expected.append(tokenImage[expectedTokenSequences[i][j]]).append(' ');
+      }
+      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0) {
+        expected.append("...");
+      }
+      expected.append(eol).append("    ");
+    }
+    String retval = "Encountered \"";
+    Token tok = currentToken.next;
+    for (int i = 0; i < maxSize; i++) {
+      if (i != 0)
+        retval += " ";
+      if (tok.kind == 0) {
+        retval += tokenImage[0];
+        break;
+      }
+      retval += " " + tokenImage[tok.kind];
+      retval += " \"";
+      retval += add_escapes(tok.image);
+      retval += " \"";
+      tok = tok.next;
+    }
+    retval += "\" at line " + currentToken.next.beginLine + ", column "
+        + currentToken.next.beginColumn;
+    retval += "." + eol;
+    if (expectedTokenSequences.length == 1) {
+      retval += "Was expecting:" + eol + "    ";
+    } else {
+      retval += "Was expecting one of:" + eol + "    ";
+    }
+    retval += expected.toString();
+    return retval;
+  }
+
+  /**
+   * The end of line string for this machine.
+   */
+  @SuppressWarnings("unused")
+  private String eol = System.getProperty("line.separator", "\n");
+
+  /**
+   * Used to convert raw characters to their escaped version when these raw
+   * version cannot be used as part of an ASCII string literal.
+   */
+  static private String add_escapes(String str) {
+    StringBuffer retval = new StringBuffer();
+    char ch;
+    for (int i = 0; i < str.length(); i++) {
+      switch (str.charAt(i)) {
+      case 0:
+        continue;
+      case '\b':
+        retval.append("\\b");
+        continue;
+      case '\t':
+        retval.append("\\t");
+        continue;
+      case '\n':
+        retval.append("\\n");
+        continue;
+      case '\f':
+        retval.append("\\f");
+        continue;
+      case '\r':
+        retval.append("\\r");
+        continue;
+      case '\"':
+        retval.append("\\\"");
+        continue;
+      case '\'':
+        retval.append("\\\'");
+        continue;
+      case '\\':
+        retval.append("\\\\");
+        continue;
+      default:
+        if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+          String s = "0000" + Integer.toString(ch, 16);
+          retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+        } else {
+          retval.append(ch);
+        }
+        continue;
+      }
+    }
+    return retval.toString();
+  }
+
+}
+/*
+ * JavaCC - StandardChecksum=c04ac45b94787832e67e6d1b49d8774c (do not edit this
+ * line)
+ */
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Standard2SyntaxParser.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Standard2SyntaxParser.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Standard2SyntaxParser.java	(revision 0)
@@ -0,0 +1,1103 @@
+/* Generated By:JavaCC: Do not edit this line. Standard2SyntaxParser.java */
+package org.apache.lucene.queryParser.standard2.parser;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.List;
+import java.util.Vector;
+
+import org.apache.lucene.messages.Message;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryParser.core.QueryNodeError;
+import org.apache.lucene.queryParser.core.QueryNodeException;
+import org.apache.lucene.queryParser.core.QueryNodeParseException;
+import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
+import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
+import org.apache.lucene.queryParser.core.nodes.AnyQueryNode;
+import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
+import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
+import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
+import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
+import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
+import org.apache.lucene.queryParser.core.parser.OpaqueExtensionUtil;
+import org.apache.lucene.queryParser.core.parser.SyntaxParser;
+
+@SuppressWarnings("all")
+public class Standard2SyntaxParser implements SyntaxParser, Standard2SyntaxParserConstants {
+
+   // syntax parser constructor
+   public Standard2SyntaxParser() {
+        this(new StringReader(""));
+  }
+     /** Parses a query string, returning a {@link org.apache.lucene.queryParser.core.nodes.QueryNode}.
+     *  @param query  the query string to be parsed.
+     *  @throws ParseException if the parsing fails
+     */
+    public QueryNode parse(CharSequence query, CharSequence field) throws QueryNodeParseException {
+      ReInit(new StringReader(query.toString()));
+      try {
+        // TopLevelQuery is a Query followed by the end-of-input (EOF)
+        QueryNode querynode = TopLevelQuery(field);
+        return querynode;
+      }
+      catch (ParseException tme) {
+            tme.setQuery(query);
+            throw tme;
+      }
+      catch (Error tme) {
+          Message message = new MessageImpl(QueryParserMessages.INVALID_SYNTAX_CANNOT_PARSE, query, tme.getMessage());
+          QueryNodeParseException e = new QueryNodeParseException(tme);
+            e.setQuery(query);
+            e.setNonLocalizedMessage(message);
+            throw e;
+      }
+    }
+
+   private Map<String, SyntaxParser> opaqueExtensions = null;
+
+   public void setOpaqueExtensions(Map<String, SyntaxParser> opaqueExtensions) {
+     this.opaqueExtensions = opaqueExtensions;
+   }
+
+// *   Query  ::= ( Clause )*
+// *   Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" )
+
+// This makes sure that there is no garbage after the query string
+  final public QueryNode TopLevelQuery(CharSequence field) throws ParseException {
+        QueryNode q;
+    q = Query(field);
+    jj_consume_token(0);
+                {if (true) return q;}
+    throw new Error("Missing return statement in function");
+  }
+
+// These changes were made to introduce operator precedence:
+// - Clause() now returns a QueryNode. 
+// - The modifiers are consumed by Clause() and returned as part of the QueryNode Object
+// - Query does not consume conjunctions (AND, OR) anymore. 
+// - This is now done by two new non-terminals: ConjClause and DisjClause
+// The parse tree looks similar to this:
+//       Query ::= DisjQuery ( DisjQuery )*
+//   DisjQuery ::= ConjQuery ( OR ConjQuery )* 
+//   ConjQuery ::= Clause ( AND Clause )*
+//      Clause ::= [ Modifier ] ... 
+  final public QueryNode Query(CharSequence field) throws ParseException {
+  Vector clauses = null;
+  QueryNode c, first=null;
+    first = DisjQuery(field);
+    label_1:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case NOT:
+      case PLUS:
+      case MINUS:
+      case LPAREN:
+      case QUOTED:
+      case TERM:
+      case RANGEIN_START:
+      case RANGEEX_START:
+      case NUMBER:
+        ;
+        break;
+      default:
+        jj_la1[0] = jj_gen;
+        break label_1;
+      }
+      c = DisjQuery(field);
+             if (clauses == null) {
+                 clauses = new Vector();
+                 clauses.addElement(first);
+             }
+         clauses.addElement(c);
+    }
+        if (clauses != null) {
+                {if (true) return new BooleanQueryNode(clauses);}
+        } else {
+                {if (true) return first;}
+        }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public QueryNode DisjQuery(CharSequence field) throws ParseException {
+        QueryNode first, c;
+        Vector clauses = null;
+    first = ConjQuery(field);
+    label_2:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case OR:
+        ;
+        break;
+      default:
+        jj_la1[1] = jj_gen;
+        break label_2;
+      }
+      jj_consume_token(OR);
+      c = ConjQuery(field);
+     if (clauses == null) {
+         clauses = new Vector();
+         clauses.addElement(first);
+     }
+     clauses.addElement(c);
+    }
+    if (clauses != null) {
+            {if (true) return new OrQueryNode(clauses);}
+    } else {
+        {if (true) return first;}
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public QueryNode ConjQuery(CharSequence field) throws ParseException {
+        QueryNode first, c;
+        Vector clauses = null;
+    first = Clause(field);
+    label_3:
+    while (true) {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case AND:
+        ;
+        break;
+      default:
+        jj_la1[2] = jj_gen;
+        break label_3;
+      }
+      jj_consume_token(AND);
+      c = Clause(field);
+     if (clauses == null) {
+         clauses = new Vector();
+         clauses.addElement(first);
+     }
+     clauses.addElement(c);
+    }
+    if (clauses != null) {
+            {if (true) return new AndQueryNode(clauses);}
+    } else {
+        {if (true) return first;}
+    }
+    throw new Error("Missing return statement in function");
+  }
+
+  final public ModifierQueryNode.Modifier Modifiers() throws ParseException {
+  ModifierQueryNode.Modifier ret = ModifierQueryNode.Modifier.MOD_NONE;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case NOT:
+    case PLUS:
+    case MINUS:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case PLUS:
+        jj_consume_token(PLUS);
+              ret = ModifierQueryNode.Modifier.MOD_REQ;
+        break;
+      case MINUS:
+        jj_consume_token(MINUS);
+                 ret = ModifierQueryNode.Modifier.MOD_NOT;
+        break;
+      case NOT:
+        jj_consume_token(NOT);
+               ret = ModifierQueryNode.Modifier.MOD_NOT;
+        break;
+      default:
+        jj_la1[3] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      break;
+    default:
+      jj_la1[4] = jj_gen;
+      ;
+    }
+    {if (true) return ret;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public QueryNode Clause(CharSequence field) throws ParseException {
+  QueryNode q;
+  Token boost=null;
+  ModifierQueryNode.Modifier mods;
+    mods = Modifiers();
+    q = SimpleQuery(field);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case CARAT:
+      jj_consume_token(CARAT);
+      boost = jj_consume_token(NUMBER);
+      break;
+    default:
+      jj_la1[5] = jj_gen;
+      ;
+    }
+          // do not create modifier nodes with MOD_NONE
+          if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
+            q = new ModifierQueryNode(q, mods);
+          }
+
+      // avoid boosting null queries, such as those caused by stop words
+      if (boost != null &&  q != null) {
+        float f = (float)1.0;
+        try {
+                f = Float.valueOf(boost.image).floatValue();
+                q = new BoostQueryNode(q, f);
+                } catch (Exception ignored) {
+                /* Should this be handled somehow? (defaults to "no boost", if
+         * boost number is invalid)
+         */
+                }
+      }
+
+          {if (true) return q;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public QueryNode SimpleQuery(CharSequence field) throws ParseException {
+  QueryNode q;
+  Token fieldToken = null;
+    if (jj_2_4(2147483647)) {
+      q = OpaqueQuery(field);
+    } else {
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case LPAREN:
+      case QUOTED:
+      case TERM:
+      case RANGEIN_START:
+      case RANGEEX_START:
+      case NUMBER:
+        if (jj_2_1(2)) {
+          fieldToken = jj_consume_token(TERM);
+          jj_consume_token(COLON);
+               field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);
+        } else {
+          ;
+        }
+        if (jj_2_2(2147483647)) {
+          q = AnyOperator(field);
+        } else if (jj_2_3(3)) {
+          q = BaseQuery(field);
+        } else {
+          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+          case LPAREN:
+            jj_consume_token(LPAREN);
+            q = Query(field);
+            jj_consume_token(RPAREN);
+                                              if (fieldToken == null) { q = new GroupQueryNode(q); };
+            break;
+          default:
+            jj_la1[6] = jj_gen;
+            jj_consume_token(-1);
+            throw new ParseException();
+          }
+        }
+        break;
+      default:
+        jj_la1[7] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+    }
+      {if (true) return q;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public QueryNode BaseQuery(CharSequence field) throws ParseException {
+  QueryNode q;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case TERM:
+    case RANGEIN_START:
+    case RANGEEX_START:
+    case NUMBER:
+      q = Term(field);
+      break;
+    case QUOTED:
+      q = Phrase(field);
+      break;
+    default:
+      jj_la1[8] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+     {if (true) return q;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public QueryNode Phrase(CharSequence field) throws ParseException {
+  Token term, fuzzySlop=null;
+  QueryNode q =null;
+    term = jj_consume_token(QUOTED);
+                  q = new QuotedFieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image.substring(1, term.image.length()-1)), term.beginColumn + 1, term.endColumn - 1);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case FUZZY_SLOP:
+      fuzzySlop = jj_consume_token(FUZZY_SLOP);
+      break;
+    default:
+      jj_la1[9] = jj_gen;
+      ;
+    }
+     int phraseSlop = 0;
+
+     if (fuzzySlop != null) {
+       try {
+         phraseSlop = Float.valueOf(fuzzySlop.image.substring(1)).intValue();
+         q = new SlopQueryNode(q, phraseSlop);
+       }
+       catch (Exception ignored) {
+        /* Should this be handled somehow? (defaults to "no PhraseSlop", if
+         * slop number is invalid)
+         */
+       }
+     }
+     {if (true) return q;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public QueryNode Term(CharSequence field) throws ParseException {
+  Token term, fuzzySlop=null, goop1, goop2;
+  boolean fuzzy = false;
+  QueryNode q =null;
+  ParametricQueryNode qLower, qUpper;
+  float defaultMinSimilarity = 0.5f;
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case TERM:
+    case NUMBER:
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case TERM:
+        term = jj_consume_token(TERM);
+                         q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
+        break;
+      case NUMBER:
+        term = jj_consume_token(NUMBER);
+                         q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
+        break;
+      default:
+        jj_la1[10] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case FUZZY_SLOP:
+        fuzzySlop = jj_consume_token(FUZZY_SLOP);
+                                fuzzy=true;
+        break;
+      default:
+        jj_la1[11] = jj_gen;
+        ;
+      }
+       if (fuzzy) {
+          float fms = defaultMinSimilarity;
+          try {
+            fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
+          } catch (Exception ignored) { }
+         if(fms < 0.0f){
+           {if (true) throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));}
+
+         } else if (fms >= 1.0f) {
+                q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
+
+         } else {
+                q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
+         }
+
+       }
+      break;
+    case RANGEIN_START:
+      jj_consume_token(RANGEIN_START);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case RANGEIN_GOOP:
+        goop1 = jj_consume_token(RANGEIN_GOOP);
+        break;
+      case RANGEIN_QUOTED:
+        goop1 = jj_consume_token(RANGEIN_QUOTED);
+        break;
+      default:
+        jj_la1[12] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case RANGEIN_TO:
+        jj_consume_token(RANGEIN_TO);
+        break;
+      default:
+        jj_la1[13] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case RANGEIN_GOOP:
+        goop2 = jj_consume_token(RANGEIN_GOOP);
+        break;
+      case RANGEIN_QUOTED:
+        goop2 = jj_consume_token(RANGEIN_QUOTED);
+        break;
+      default:
+        jj_la1[14] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      jj_consume_token(RANGEIN_END);
+          if (goop1.kind == RANGEIN_QUOTED) {
+            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
+          }
+          if (goop2.kind == RANGEIN_QUOTED) {
+            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
+          }
+
+          qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GE,
+                                               EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
+                  qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LE,
+                                               EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
+          q = new ParametricRangeQueryNode(qLower, qUpper);
+      break;
+    case RANGEEX_START:
+      jj_consume_token(RANGEEX_START);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case RANGEEX_GOOP:
+        goop1 = jj_consume_token(RANGEEX_GOOP);
+        break;
+      case RANGEEX_QUOTED:
+        goop1 = jj_consume_token(RANGEEX_QUOTED);
+        break;
+      default:
+        jj_la1[15] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case RANGEEX_TO:
+        jj_consume_token(RANGEEX_TO);
+        break;
+      default:
+        jj_la1[16] = jj_gen;
+        ;
+      }
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case RANGEEX_GOOP:
+        goop2 = jj_consume_token(RANGEEX_GOOP);
+        break;
+      case RANGEEX_QUOTED:
+        goop2 = jj_consume_token(RANGEEX_QUOTED);
+        break;
+      default:
+        jj_la1[17] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
+      }
+      jj_consume_token(RANGEEX_END);
+          if (goop1.kind == RANGEEX_QUOTED) {
+            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
+          }
+          if (goop2.kind == RANGEEX_QUOTED) {
+            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
+          }
+          qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GT,
+                                               EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
+                  qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LT,
+                                               EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
+          q = new ParametricRangeQueryNode(qLower, qUpper);
+      break;
+    default:
+      jj_la1[18] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+      {if (true) return q;}
+    throw new Error("Missing return statement in function");
+  }
+
+  final public QueryNode AnyOperator(CharSequence field) throws ParseException {
+  Token number=null;
+  QueryNode q = null;
+  List<QueryNode> nodes = new ArrayList<QueryNode>();
+    jj_consume_token(LPAREN);
+    label_4:
+    while (true) {
+      q = BaseQuery(field);
+                                      nodes.add(q);
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case QUOTED:
+      case TERM:
+      case RANGEIN_START:
+      case RANGEEX_START:
+      case NUMBER:
+        ;
+        break;
+      default:
+        jj_la1[19] = jj_gen;
+        break label_4;
+      }
+    }
+    jj_consume_token(RPAREN);
+    jj_consume_token(ANY);
+    number = jj_consume_token(NUMBER);
+                int p = -1;
+                try {
+                        p = Float.valueOf(number.image).intValue();
+                }
+                catch (Exception ignored) { }
+                if(p < 0)
+                        {if (true) throw new ParseException(new MessageImpl(QueryParserMessages.PARAMETER_VALUE_NOT_SUPPORTED, "ANY", p));}
+                {if (true) return new AnyQueryNode(nodes, field, p);}
+    throw new Error("Missing return statement in function");
+  }
+
+// This parses an opaque query
+// <extesion>:<field>:"<value>"
+// <extesion>:<field>:<value>
+// <extesion>::"<value>" - default field 
+// <extesion>::<value>
+  final public QueryNode OpaqueQuery(CharSequence field) throws ParseException {
+  Token extensionToken, valueToken;
+  Token fieldToken = null;
+  CharSequence extensionName, value;
+    extensionToken = jj_consume_token(TERM);
+    jj_consume_token(COLON);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case TERM:
+      fieldToken = jj_consume_token(TERM);
+      break;
+    default:
+      jj_la1[20] = jj_gen;
+      ;
+    }
+    jj_consume_token(COLON);
+      extensionName = EscapeQuerySyntaxImpl.discardEscapeChar(extensionToken.image);
+      if (fieldToken != null) field = EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case QUOTED:
+      valueToken = jj_consume_token(QUOTED);
+                             value = EscapeQuerySyntaxImpl.discardEscapeChar(valueToken.image.substring(1, valueToken.image.length()-1));
+      break;
+    case TERM:
+      valueToken = jj_consume_token(TERM);
+                           value = EscapeQuerySyntaxImpl.discardEscapeChar(valueToken.image);
+      break;
+    case NUMBER:
+      valueToken = jj_consume_token(NUMBER);
+                             value = EscapeQuerySyntaxImpl.discardEscapeChar(valueToken.image);
+      break;
+    default:
+      jj_la1[21] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
+    }
+      try {
+        SyntaxParser parser = OpaqueExtensionUtil.getParser(extensionName.toString(), this.opaqueExtensions);
+        {if (true) return parser.parse(field, value);}
+      } catch (QueryNodeParseException ex) {
+        {if (true) throw new ParseException(new MessageImpl(QueryParserMessages.OPAQUE_EXTENSION_PARSING_ERROR, extensionName, value), ex);}
+      }
+    throw new Error("Missing return statement in function");
+  }
+
+  private boolean jj_2_1(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_1(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(0, xla); }
+  }
+
+  private boolean jj_2_2(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_2(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(1, xla); }
+  }
+
+  private boolean jj_2_3(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_3(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(2, xla); }
+  }
+
+  private boolean jj_2_4(int xla) {
+    jj_la = xla; jj_lastpos = jj_scanpos = token;
+    try { return !jj_3_4(); }
+    catch(LookaheadSuccess ls) { return true; }
+    finally { jj_save(3, xla); }
+  }
+
+  private boolean jj_3_4() {
+    if (jj_3R_7()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_14() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_16()) {
+    jj_scanpos = xsp;
+    if (jj_3R_17()) {
+    jj_scanpos = xsp;
+    if (jj_3R_18()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_7() {
+    if (jj_scan_token(TERM)) return true;
+    if (jj_scan_token(COLON)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(19)) jj_scanpos = xsp;
+    if (jj_scan_token(COLON)) return true;
+    xsp = jj_scanpos;
+    if (jj_3R_11()) {
+    jj_scanpos = xsp;
+    if (jj_3R_12()) {
+    jj_scanpos = xsp;
+    if (jj_3R_13()) return true;
+    }
+    }
+    return false;
+  }
+
+  private boolean jj_3R_18() {
+    if (jj_scan_token(RANGEEX_START)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(31)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(30)) return true;
+    }
+    xsp = jj_scanpos;
+    if (jj_scan_token(28)) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(31)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(30)) return true;
+    }
+    if (jj_scan_token(RANGEEX_END)) return true;
+    return false;
+  }
+
+  private boolean jj_3_1() {
+    if (jj_scan_token(TERM)) return true;
+    if (jj_scan_token(COLON)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_8() {
+    if (jj_3R_6()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_10() {
+    if (jj_3R_15()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_17() {
+    if (jj_scan_token(RANGEIN_START)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(27)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(26)) return true;
+    }
+    xsp = jj_scanpos;
+    if (jj_scan_token(24)) jj_scanpos = xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(27)) {
+    jj_scanpos = xsp;
+    if (jj_scan_token(26)) return true;
+    }
+    if (jj_scan_token(RANGEIN_END)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_5() {
+    if (jj_scan_token(LPAREN)) return true;
+    Token xsp;
+    if (jj_3R_8()) return true;
+    while (true) {
+      xsp = jj_scanpos;
+      if (jj_3R_8()) { jj_scanpos = xsp; break; }
+    }
+    if (jj_scan_token(RPAREN)) return true;
+    if (jj_scan_token(ANY)) return true;
+    if (jj_scan_token(NUMBER)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_15() {
+    if (jj_scan_token(QUOTED)) return true;
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_scan_token(20)) jj_scanpos = xsp;
+    return false;
+  }
+
+  private boolean jj_3_2() {
+    if (jj_3R_5()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_9() {
+    if (jj_3R_14()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_19() {
+    if (jj_scan_token(TERM)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_6() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_9()) {
+    jj_scanpos = xsp;
+    if (jj_3R_10()) return true;
+    }
+    return false;
+  }
+
+  private boolean jj_3R_21() {
+    if (jj_scan_token(FUZZY_SLOP)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_20() {
+    if (jj_scan_token(NUMBER)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_13() {
+    if (jj_scan_token(NUMBER)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_12() {
+    if (jj_scan_token(TERM)) return true;
+    return false;
+  }
+
+  private boolean jj_3R_11() {
+    if (jj_scan_token(QUOTED)) return true;
+    return false;
+  }
+
+  private boolean jj_3_3() {
+    if (jj_3R_6()) return true;
+    return false;
+  }
+
+  private boolean jj_3R_16() {
+    Token xsp;
+    xsp = jj_scanpos;
+    if (jj_3R_19()) {
+    jj_scanpos = xsp;
+    if (jj_3R_20()) return true;
+    }
+    xsp = jj_scanpos;
+    if (jj_3R_21()) jj_scanpos = xsp;
+    return false;
+  }
+
+  /** Generated Token Manager. */
+  public Standard2SyntaxParserTokenManager token_source;
+  JavaCharStream jj_input_stream;
+  /** Current token. */
+  public Token token;
+  /** Next token. */
+  public Token jj_nt;
+  private int jj_ntk;
+  private Token jj_scanpos, jj_lastpos;
+  private int jj_la;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[22];
+  static private int[] jj_la1_0;
+  static {
+      jj_la1_init_0();
+   }
+   private static void jj_la1_init_0() {
+      jj_la1_0 = new int[] {0xec3c00,0x200,0x100,0x1c00,0x1c00,0x10000,0x2000,0xec2000,0xec0000,0x100000,0x880000,0x100000,0xc000000,0x1000000,0xc000000,0xc0000000,0x10000000,0xc0000000,0xe80000,0xec0000,0x80000,0x8c0000,};
+   }
+  final private JJCalls[] jj_2_rtns = new JJCalls[4];
+  private boolean jj_rescan = false;
+  private int jj_gc = 0;
+
+  /** Constructor with InputStream. */
+  public Standard2SyntaxParser(java.io.InputStream stream) {
+     this(stream, null);
+  }
+  /** Constructor with InputStream and supplied encoding */
+  public Standard2SyntaxParser(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source = new Standard2SyntaxParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream) {
+     ReInit(stream, null);
+  }
+  /** Reinitialise. */
+  public void ReInit(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor. */
+  public Standard2SyntaxParser(java.io.Reader stream) {
+    jj_input_stream = new JavaCharStream(stream, 1, 1);
+    token_source = new Standard2SyntaxParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(java.io.Reader stream) {
+    jj_input_stream.ReInit(stream, 1, 1);
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Constructor with generated Token Manager. */
+  public Standard2SyntaxParser(Standard2SyntaxParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  /** Reinitialise. */
+  public void ReInit(Standard2SyntaxParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 22; i++) jj_la1[i] = -1;
+    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  }
+
+  private Token jj_consume_token(int kind) throws ParseException {
+    Token oldToken;
+    if ((oldToken = token).next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    if (token.kind == kind) {
+      jj_gen++;
+      if (++jj_gc > 100) {
+        jj_gc = 0;
+        for (int i = 0; i < jj_2_rtns.length; i++) {
+          JJCalls c = jj_2_rtns[i];
+          while (c != null) {
+            if (c.gen < jj_gen) c.first = null;
+            c = c.next;
+          }
+        }
+      }
+      return token;
+    }
+    token = oldToken;
+    jj_kind = kind;
+    throw generateParseException();
+  }
+
+  static private final class LookaheadSuccess extends java.lang.Error { }
+  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
+  private boolean jj_scan_token(int kind) {
+    if (jj_scanpos == jj_lastpos) {
+      jj_la--;
+      if (jj_scanpos.next == null) {
+        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
+      } else {
+        jj_lastpos = jj_scanpos = jj_scanpos.next;
+      }
+    } else {
+      jj_scanpos = jj_scanpos.next;
+    }
+    if (jj_rescan) {
+      int i = 0; Token tok = token;
+      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
+      if (tok != null) jj_add_error_token(kind, i);
+    }
+    if (jj_scanpos.kind != kind) return true;
+    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
+    return false;
+  }
+
+
+/** Get the next Token. */
+  final public Token getNextToken() {
+    if (token.next != null) token = token.next;
+    else token = token.next = token_source.getNextToken();
+    jj_ntk = -1;
+    jj_gen++;
+    return token;
+  }
+
+/** Get the specific Token. */
+  final public Token getToken(int index) {
+    Token t = token;
+    for (int i = 0; i < index; i++) {
+      if (t.next != null) t = t.next;
+      else t = t.next = token_source.getNextToken();
+    }
+    return t;
+  }
+
+  private int jj_ntk() {
+    if ((jj_nt=token.next) == null)
+      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
+    else
+      return (jj_ntk = jj_nt.kind);
+  }
+
+  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
+  private int[] jj_expentry;
+  private int jj_kind = -1;
+  private int[] jj_lasttokens = new int[100];
+  private int jj_endpos;
+
+  private void jj_add_error_token(int kind, int pos) {
+    if (pos >= 100) return;
+    if (pos == jj_endpos + 1) {
+      jj_lasttokens[jj_endpos++] = kind;
+    } else if (jj_endpos != 0) {
+      jj_expentry = new int[jj_endpos];
+      for (int i = 0; i < jj_endpos; i++) {
+        jj_expentry[i] = jj_lasttokens[i];
+      }
+      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
+        int[] oldentry = (int[])(it.next());
+        if (oldentry.length == jj_expentry.length) {
+          for (int i = 0; i < jj_expentry.length; i++) {
+            if (oldentry[i] != jj_expentry[i]) {
+              continue jj_entries_loop;
+            }
+          }
+          jj_expentries.add(jj_expentry);
+          break jj_entries_loop;
+        }
+      }
+      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
+    }
+  }
+
+  /** Generate ParseException. */
+  public ParseException generateParseException() {
+    jj_expentries.clear();
+    boolean[] la1tokens = new boolean[32];
+    if (jj_kind >= 0) {
+      la1tokens[jj_kind] = true;
+      jj_kind = -1;
+    }
+    for (int i = 0; i < 22; i++) {
+      if (jj_la1[i] == jj_gen) {
+        for (int j = 0; j < 32; j++) {
+          if ((jj_la1_0[i] & (1<<j)) != 0) {
+            la1tokens[j] = true;
+          }
+        }
+      }
+    }
+    for (int i = 0; i < 32; i++) {
+      if (la1tokens[i]) {
+        jj_expentry = new int[1];
+        jj_expentry[0] = i;
+        jj_expentries.add(jj_expentry);
+      }
+    }
+    jj_endpos = 0;
+    jj_rescan_token();
+    jj_add_error_token(0, 0);
+    int[][] exptokseq = new int[jj_expentries.size()][];
+    for (int i = 0; i < jj_expentries.size(); i++) {
+      exptokseq[i] = jj_expentries.get(i);
+    }
+    return new ParseException(token, exptokseq, tokenImage);
+  }
+
+  /** Enable tracing. */
+  final public void enable_tracing() {
+  }
+
+  /** Disable tracing. */
+  final public void disable_tracing() {
+  }
+
+  private void jj_rescan_token() {
+    jj_rescan = true;
+    for (int i = 0; i < 4; i++) {
+    try {
+      JJCalls p = jj_2_rtns[i];
+      do {
+        if (p.gen > jj_gen) {
+          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
+          switch (i) {
+            case 0: jj_3_1(); break;
+            case 1: jj_3_2(); break;
+            case 2: jj_3_3(); break;
+            case 3: jj_3_4(); break;
+          }
+        }
+        p = p.next;
+      } while (p != null);
+      } catch(LookaheadSuccess ls) { }
+    }
+    jj_rescan = false;
+  }
+
+  private void jj_save(int index, int xla) {
+    JJCalls p = jj_2_rtns[index];
+    while (p.gen > jj_gen) {
+      if (p.next == null) { p = p.next = new JJCalls(); break; }
+      p = p.next;
+    }
+    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
+  }
+
+  static final class JJCalls {
+    int gen;
+    Token first;
+    int arg;
+    JJCalls next;
+  }
+
+}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Standard2SyntaxParser.jj
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Standard2SyntaxParser.jj	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Standard2SyntaxParser.jj	(revision 0)
@@ -0,0 +1,480 @@
+/**
+ * Standard file is based on the TextParser.jj from lucene 2.3
+ */
+
+options {
+  STATIC=false;
+  JAVA_UNICODE_ESCAPE=true;
+  USER_CHAR_STREAM=false;
+  IGNORE_CASE=false;
+  JDK_VERSION="1.5";
+}
+
+PARSER_BEGIN(Standard2SyntaxParser)
+package org.apache.lucene.queryParser.standard2.parser;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.List;
+import java.util.Vector;
+
+import org.apache.lucene.messages.Message;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryParser.core.QueryNodeError;
+import org.apache.lucene.queryParser.core.QueryNodeException;
+import org.apache.lucene.queryParser.core.QueryNodeParseException;
+import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
+import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
+import org.apache.lucene.queryParser.core.nodes.AnyQueryNode;
+import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
+import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
+import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
+import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
+import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
+import org.apache.lucene.queryParser.core.parser.OpaqueExtensionUtil;
+import org.apache.lucene.queryParser.core.parser.SyntaxParser;
+
+@SuppressWarnings("all")
+public class Standard2SyntaxParser implements SyntaxParser {
+ 
+   // syntax parser constructor
+   public Standard2SyntaxParser() {
+   	this(new StringReader(""));
+  }
+     /** Parses a query string, returning a {@link org.apache.lucene.queryParser.core.nodes.QueryNode}.
+     *  @param query  the query string to be parsed.
+     *  @throws ParseException if the parsing fails
+     */
+    public QueryNode parse(CharSequence query, CharSequence field) throws QueryNodeParseException {
+      ReInit(new StringReader(query.toString()));
+      try {
+        // TopLevelQuery is a Query followed by the end-of-input (EOF)
+        QueryNode querynode = TopLevelQuery(field);
+        return querynode;
+      }
+      catch (ParseException tme) {
+            tme.setQuery(query);
+            throw tme;
+      }
+      catch (Error tme) {
+          Message message = new MessageImpl(QueryParserMessages.INVALID_SYNTAX_CANNOT_PARSE, query, tme.getMessage());
+          QueryNodeParseException e = new QueryNodeParseException(tme);
+            e.setQuery(query);
+            e.setNonLocalizedMessage(message);
+            throw e;
+      }
+    }
+    
+   private Map<String, SyntaxParser> opaqueExtensions = null;
+
+   public void setOpaqueExtensions(Map<String, SyntaxParser> opaqueExtensions) {
+     this.opaqueExtensions = opaqueExtensions;
+   }
+   
+}
+
+PARSER_END(Standard2SyntaxParser)
+
+/* ***************** */
+/* Token Definitions */
+/* ***************** */
+
+<*> TOKEN : {
+  <#_NUM_CHAR:   ["0"-"9"] >
+// every character that follows a backslash is considered as an escaped character
+| <#_ESCAPED_CHAR: "\\" ~[] >
+| <#_TERM_START_CHAR: ( ~[ " ", "\t", "\n", "\r", "\u3000", "+", "-", "!", "(", ")", ":", "^",
+                           "[", "]", "\"", "{", "}", "~", "\\" ]
+                       | <_ESCAPED_CHAR> ) >
+| <#_TERM_CHAR: ( <_TERM_START_CHAR> | <_ESCAPED_CHAR> | "-" | "+" ) >
+| <#_WHITESPACE: ( " " | "\t" | "\n" | "\r" | "\u3000") >
+| <#_QUOTED_CHAR: ( ~[ "\"", "\\" ] | <_ESCAPED_CHAR> ) >
+}
+
+<DEFAULT, Boost_LS, RangeIn, RangeEx, Any_LS> SKIP : {
+  < <_WHITESPACE>>
+}
+
+<DEFAULT> TOKEN : {
+  <AND:       ("AND" | "&&") >
+| <OR:        ("OR" | "||") >
+| <NOT:       ("NOT" | "!") >
+| <PLUS:      "+" >
+| <MINUS:     "-" >
+| <LPAREN:    "(" >
+| <RPAREN:    ")" >
+| <COLON:     ":" >
+| <CARAT:     "^" > : Boost_LS
+| <ANY:    "ANY" > : Any_LS
+| <QUOTED:     "\"" (<_QUOTED_CHAR>)* "\"">
+| <TERM:      <_TERM_START_CHAR> (<_TERM_CHAR>)*  >
+| <FUZZY_SLOP:     "~" ( (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? )? >
+| <RANGEIN_START: "[" > : RangeIn
+| <RANGEEX_START: "{" > : RangeEx
+}
+
+<Boost_LS, Any_LS> TOKEN : {
+<NUMBER:    (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? > : DEFAULT
+}
+
+<RangeIn> TOKEN : {
+<RANGEIN_TO: "TO">
+| <RANGEIN_END: "]"> : DEFAULT
+| <RANGEIN_QUOTED: "\"" (~["\""] | "\\\"")+ "\"">
+| <RANGEIN_GOOP: (~[ " ", "]" ])+ >
+}
+
+<RangeEx> TOKEN : {
+<RANGEEX_TO: "TO">
+| <RANGEEX_END: "}"> : DEFAULT
+| <RANGEEX_QUOTED: "\"" (~["\""] | "\\\"")+ "\"">
+| <RANGEEX_GOOP: (~[ " ", "}" ])+ >
+}
+
+// *   Query  ::= ( Clause )*
+// *   Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" )
+
+// This makes sure that there is no garbage after the query string
+QueryNode TopLevelQuery(CharSequence field) : 
+{
+	QueryNode q;
+}
+{
+	q=Query(field) <EOF>
+	{
+		return q;
+	}
+}
+
+// These changes were made to introduce operator precedence:
+// - Clause() now returns a QueryNode. 
+// - The modifiers are consumed by Clause() and returned as part of the QueryNode Object
+// - Query does not consume conjunctions (AND, OR) anymore. 
+// - This is now done by two new non-terminals: ConjClause and DisjClause
+// The parse tree looks similar to this:
+//       Query ::= DisjQuery ( DisjQuery )*
+//   DisjQuery ::= ConjQuery ( OR ConjQuery )* 
+//   ConjQuery ::= Clause ( AND Clause )*
+//      Clause ::= [ Modifier ] ... 
+
+
+QueryNode Query(CharSequence field) :
+{
+  Vector clauses = null;
+  QueryNode c, first=null;
+}
+{
+  first=DisjQuery(field)
+  (
+    c=DisjQuery(field)
+    { 
+	     if (clauses == null) {
+	         clauses = new Vector();
+	         clauses.addElement(first); 
+	     } 
+    	 clauses.addElement(c);
+    }
+    )*
+    {
+        if (clauses != null) { 
+	    	return new BooleanQueryNode(clauses);
+    	} else {
+        	return first;
+    	}
+    }
+}
+
+QueryNode DisjQuery(CharSequence field) : {
+	QueryNode first, c;
+	Vector clauses = null;
+}
+{
+  first = ConjQuery(field)
+  (
+   <OR> c=ConjQuery(field)
+   { 
+     if (clauses == null) {
+         clauses = new Vector();
+         clauses.addElement(first); 
+     } 
+     clauses.addElement(c);
+   }
+  )*
+  {
+    if (clauses != null) { 
+	    return new OrQueryNode(clauses);
+    } else {
+        return first;
+    }
+  }
+}
+
+QueryNode ConjQuery(CharSequence field) : {
+	QueryNode first, c;
+	Vector clauses = null;
+}
+{
+  first = Clause(field)
+  (
+   <AND> c=Clause(field)
+   { 
+     if (clauses == null) {
+         clauses = new Vector();
+         clauses.addElement(first);
+     } 
+     clauses.addElement(c); 
+   }
+  )*
+  {
+    if (clauses != null) {     
+	    return new AndQueryNode(clauses);
+    } else {
+        return first;
+    }
+  }
+}
+
+ModifierQueryNode.Modifier Modifiers() : {
+  ModifierQueryNode.Modifier ret = ModifierQueryNode.Modifier.MOD_NONE;
+}
+{
+  [
+     <PLUS> { ret = ModifierQueryNode.Modifier.MOD_REQ; }
+     | <MINUS> { ret = ModifierQueryNode.Modifier.MOD_NOT; }
+     | <NOT> { ret = ModifierQueryNode.Modifier.MOD_NOT; }
+  ]
+  { return ret; }
+}
+
+QueryNode Clause(CharSequence field) : {
+  QueryNode q; 
+  Token boost=null;
+  ModifierQueryNode.Modifier mods;
+}
+{
+   mods=Modifiers() q=SimpleQuery(field) [ <CARAT> boost=<NUMBER> ]
+   {
+   	  // do not create modifier nodes with MOD_NONE
+   	  if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
+   	    q = new ModifierQueryNode(q, mods);
+   	  }
+   	  
+      // avoid boosting null queries, such as those caused by stop words
+      if (boost != null &&  q != null) {
+        float f = (float)1.0;
+        try {
+    		f = Float.valueOf(boost.image).floatValue();
+    		q = new BoostQueryNode(q, f);
+  		} catch (Exception ignored) {
+  		/* Should this be handled somehow? (defaults to "no boost", if
+         * boost number is invalid)
+         */
+  		}
+      }
+      
+	  return q;		               
+    }    
+}
+
+QueryNode SimpleQuery(CharSequence field) : {
+  QueryNode q;
+  Token fieldToken = null;
+}
+{
+   (
+     LOOKAHEAD(OpaqueQuery(field)) q=OpaqueQuery(field)     
+     |(
+        [LOOKAHEAD(2) 
+          ( fieldToken=<TERM> <COLON> {
+               field=EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);             
+            }
+         )]        
+         ( LOOKAHEAD(AnyOperator(field)) q=AnyOperator(field)
+         | LOOKAHEAD(3) q=BaseQuery(field)
+         | <LPAREN> q=Query(field) <RPAREN> { if (fieldToken == null) { q = new GroupQueryNode(q); }; }
+         )
+      )
+   )
+   {    
+      return q;		               
+   }    
+}
+
+QueryNode BaseQuery(CharSequence field) : {
+  QueryNode q;
+}
+{
+   ( q=Term(field) | q=Phrase(field) ) 
+   { return q; }
+}
+
+QueryNode Phrase(CharSequence field) : {
+  Token term, fuzzySlop=null;
+  QueryNode q =null; 
+}
+{
+   term=<QUOTED> {q = new QuotedFieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image.substring(1, term.image.length()-1)), term.beginColumn + 1, term.endColumn - 1);}
+   [ fuzzySlop=<FUZZY_SLOP> ]
+   {       
+     int phraseSlop = 0;
+
+     if (fuzzySlop != null) {
+       try {
+         phraseSlop = Float.valueOf(fuzzySlop.image.substring(1)).intValue();
+         q = new SlopQueryNode(q, phraseSlop);    
+       }
+       catch (Exception ignored) {
+        /* Should this be handled somehow? (defaults to "no PhraseSlop", if
+         * slop number is invalid)
+         */		
+       }
+     }     
+     return q;     
+   }
+}
+
+QueryNode Term(CharSequence field) : {
+  Token term, fuzzySlop=null, goop1, goop2;
+  boolean fuzzy = false;
+  QueryNode q =null; 
+  ParametricQueryNode qLower, qUpper;
+  float defaultMinSimilarity = 0.5f;
+}
+{
+  (
+     (
+ 	   term=<TERM> { q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn); }
+       | term=<NUMBER> { q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn); }
+     )
+     [ fuzzySlop=<FUZZY_SLOP> { fuzzy=true; } ]
+     {
+       if (fuzzy) {
+       	  float fms = defaultMinSimilarity;
+       	  try {
+            fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
+       	  } catch (Exception ignored) { }
+       	 if(fms < 0.0f){
+       	   throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));
+       	   
+       	 } else if (fms >= 1.0f) {
+       	 	q = new FieldQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), term.beginColumn, term.endColumn);
+       	 
+       	 } else {
+       	 	q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
+       	 }
+       	 
+       }
+     }
+     | ( <RANGEIN_START> ( goop1=<RANGEIN_GOOP>|goop1=<RANGEIN_QUOTED> )
+         [ <RANGEIN_TO> ] ( goop2=<RANGEIN_GOOP>|goop2=<RANGEIN_QUOTED> )
+         <RANGEIN_END> )
+        {
+          if (goop1.kind == RANGEIN_QUOTED) {
+            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
+          }
+          if (goop2.kind == RANGEIN_QUOTED) {
+            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
+          }
+          
+          qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GE, 
+		                               EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
+		  qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LE, 
+		                               EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
+          q = new ParametricRangeQueryNode(qLower, qUpper);
+        }
+     | ( <RANGEEX_START> ( goop1=<RANGEEX_GOOP>|goop1=<RANGEEX_QUOTED> )
+         [ <RANGEEX_TO> ] ( goop2=<RANGEEX_GOOP>|goop2=<RANGEEX_QUOTED> )
+         <RANGEEX_END> )
+        {
+          if (goop1.kind == RANGEEX_QUOTED) {
+            goop1.image = goop1.image.substring(1, goop1.image.length()-1);
+          }
+          if (goop2.kind == RANGEEX_QUOTED) {
+            goop2.image = goop2.image.substring(1, goop2.image.length()-1);
+          }
+          qLower = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.GT, 
+		                               EscapeQuerySyntaxImpl.discardEscapeChar(goop1.image), goop1.beginColumn, goop1.endColumn);
+		  qUpper = new ParametricQueryNode(field, ParametricQueryNode.CompareOperator.LT, 
+		                               EscapeQuerySyntaxImpl.discardEscapeChar(goop2.image), goop2.beginColumn, goop2.endColumn);
+          q = new ParametricRangeQueryNode(qLower, qUpper);		  
+        }
+  )
+  {
+      return q;
+  }
+}
+
+QueryNode AnyOperator(CharSequence field) : {
+  Token number=null;
+  QueryNode q = null;
+  List<QueryNode> nodes = new ArrayList<QueryNode>();
+}
+{
+	<LPAREN> (q=BaseQuery(field){ nodes.add(q); })+ <RPAREN> <ANY> number=<NUMBER>
+	{			            		 
+		int p = -1;
+		try {
+			p = Float.valueOf(number.image).intValue();
+		}
+		catch (Exception ignored) { }
+		if(p < 0)
+			throw new ParseException(new MessageImpl(QueryParserMessages.PARAMETER_VALUE_NOT_SUPPORTED, "ANY", p));
+		return new AnyQueryNode(nodes, field, p);
+	} 	
+}
+
+// This parses an opaque query
+// <extesion>:<field>:"<value>"
+// <extesion>:<field>:<value>
+// <extesion>::"<value>" - default field 
+// <extesion>::<value>
+QueryNode OpaqueQuery(CharSequence field) : {
+  Token extensionToken, valueToken;
+  Token fieldToken = null;
+  CharSequence extensionName, value;
+}
+{
+   extensionToken=<TERM> <COLON> [fieldToken=<TERM>] <COLON> {
+      extensionName = EscapeQuerySyntaxImpl.discardEscapeChar(extensionToken.image);
+      if (fieldToken != null) field = EscapeQuerySyntaxImpl.discardEscapeChar(fieldToken.image);
+   } (
+       valueToken=<QUOTED> { value = EscapeQuerySyntaxImpl.discardEscapeChar(valueToken.image.substring(1, valueToken.image.length()-1)); }
+     | valueToken=<TERM> { value = EscapeQuerySyntaxImpl.discardEscapeChar(valueToken.image); } 
+     | valueToken=<NUMBER> { value = EscapeQuerySyntaxImpl.discardEscapeChar(valueToken.image); }
+   )   
+   {  
+      try {
+      	SyntaxParser parser = OpaqueExtensionUtil.getParser(extensionName.toString(), this.opaqueExtensions);
+      	return parser.parse(field, value);
+      } catch (QueryNodeParseException ex) {
+      	throw new ParseException(new MessageImpl(QueryParserMessages.OPAQUE_EXTENSION_PARSING_ERROR, extensionName, value), ex); 
+      }
+   }
+}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Standard2SyntaxParserConstants.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Standard2SyntaxParserConstants.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Standard2SyntaxParserConstants.java	(revision 0)
@@ -0,0 +1,121 @@
+/* Generated By:JavaCC: Do not edit this line. Standard2SyntaxParserConstants.java */
+package org.apache.lucene.queryParser.standard2.parser;
+
+
+/**
+ * Token literal values and constants.
+ * Generated by org.javacc.parser.OtherFilesGen#start()
+ */
+public interface Standard2SyntaxParserConstants {
+
+  /** End of File. */
+  int EOF = 0;
+  /** RegularExpression Id. */
+  int _NUM_CHAR = 1;
+  /** RegularExpression Id. */
+  int _ESCAPED_CHAR = 2;
+  /** RegularExpression Id. */
+  int _TERM_START_CHAR = 3;
+  /** RegularExpression Id. */
+  int _TERM_CHAR = 4;
+  /** RegularExpression Id. */
+  int _WHITESPACE = 5;
+  /** RegularExpression Id. */
+  int _QUOTED_CHAR = 6;
+  /** RegularExpression Id. */
+  int AND = 8;
+  /** RegularExpression Id. */
+  int OR = 9;
+  /** RegularExpression Id. */
+  int NOT = 10;
+  /** RegularExpression Id. */
+  int PLUS = 11;
+  /** RegularExpression Id. */
+  int MINUS = 12;
+  /** RegularExpression Id. */
+  int LPAREN = 13;
+  /** RegularExpression Id. */
+  int RPAREN = 14;
+  /** RegularExpression Id. */
+  int COLON = 15;
+  /** RegularExpression Id. */
+  int CARAT = 16;
+  /** RegularExpression Id. */
+  int ANY = 17;
+  /** RegularExpression Id. */
+  int QUOTED = 18;
+  /** RegularExpression Id. */
+  int TERM = 19;
+  /** RegularExpression Id. */
+  int FUZZY_SLOP = 20;
+  /** RegularExpression Id. */
+  int RANGEIN_START = 21;
+  /** RegularExpression Id. */
+  int RANGEEX_START = 22;
+  /** RegularExpression Id. */
+  int NUMBER = 23;
+  /** RegularExpression Id. */
+  int RANGEIN_TO = 24;
+  /** RegularExpression Id. */
+  int RANGEIN_END = 25;
+  /** RegularExpression Id. */
+  int RANGEIN_QUOTED = 26;
+  /** RegularExpression Id. */
+  int RANGEIN_GOOP = 27;
+  /** RegularExpression Id. */
+  int RANGEEX_TO = 28;
+  /** RegularExpression Id. */
+  int RANGEEX_END = 29;
+  /** RegularExpression Id. */
+  int RANGEEX_QUOTED = 30;
+  /** RegularExpression Id. */
+  int RANGEEX_GOOP = 31;
+
+  /** Lexical state. */
+  int Any_LS = 0;
+  /** Lexical state. */
+  int RangeEx = 1;
+  /** Lexical state. */
+  int RangeIn = 2;
+  /** Lexical state. */
+  int Boost_LS = 3;
+  /** Lexical state. */
+  int DEFAULT = 4;
+
+  /** Literal token values. */
+  String[] tokenImage = {
+    "<EOF>",
+    "<_NUM_CHAR>",
+    "<_ESCAPED_CHAR>",
+    "<_TERM_START_CHAR>",
+    "<_TERM_CHAR>",
+    "<_WHITESPACE>",
+    "<_QUOTED_CHAR>",
+    "<token of kind 7>",
+    "<AND>",
+    "<OR>",
+    "<NOT>",
+    "\"+\"",
+    "\"-\"",
+    "\"(\"",
+    "\")\"",
+    "\":\"",
+    "\"^\"",
+    "\"ANY\"",
+    "<QUOTED>",
+    "<TERM>",
+    "<FUZZY_SLOP>",
+    "\"[\"",
+    "\"{\"",
+    "<NUMBER>",
+    "\"TO\"",
+    "\"]\"",
+    "<RANGEIN_QUOTED>",
+    "<RANGEIN_GOOP>",
+    "\"TO\"",
+    "\"}\"",
+    "<RANGEEX_QUOTED>",
+    "<RANGEEX_GOOP>",
+  };
+
+}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Standard2SyntaxParserTokenManager.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Standard2SyntaxParserTokenManager.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Standard2SyntaxParserTokenManager.java	(revision 0)
@@ -0,0 +1,1379 @@
+/* Generated By:JavaCC: Do not edit this line. Standard2SyntaxParserTokenManager.java */
+package org.apache.lucene.queryParser.standard2.parser;
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.List;
+import java.util.Vector;
+import org.apache.lucene.messages.Message;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryParser.core.QueryNodeError;
+import org.apache.lucene.queryParser.core.QueryNodeException;
+import org.apache.lucene.queryParser.core.QueryNodeParseException;
+import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
+import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
+import org.apache.lucene.queryParser.core.nodes.AnyQueryNode;
+import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryParser.core.nodes.BoostQueryNode;
+import org.apache.lucene.queryParser.core.nodes.FieldQueryNode;
+import org.apache.lucene.queryParser.core.nodes.FuzzyQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryParser.core.nodes.GroupQueryNode;
+import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
+import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ParametricQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ParametricRangeQueryNode;
+import org.apache.lucene.queryParser.core.nodes.SlopQueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNodeImpl;
+import org.apache.lucene.queryParser.core.nodes.QuotedFieldQueryNode;
+import org.apache.lucene.queryParser.core.parser.OpaqueExtensionUtil;
+import org.apache.lucene.queryParser.core.parser.SyntaxParser;
+
+/** Token Manager. */
+public class Standard2SyntaxParserTokenManager implements Standard2SyntaxParserConstants
+{
+
+  /** Debug output. */
+  public  java.io.PrintStream debugStream = System.out;
+  /** Set debug output. */
+  public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
+private final int jjStopStringLiteralDfa_4(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x20000L) != 0L)
+         {
+            jjmatchedKind = 19;
+            return 2;
+         }
+         return -1;
+      case 1:
+         if ((active0 & 0x20000L) != 0L)
+         {
+            jjmatchedKind = 19;
+            jjmatchedPos = 1;
+            return 1;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_4(int pos, long active0)
+{
+   return jjMoveNfa_4(jjStopStringLiteralDfa_4(pos, active0), pos + 1);
+}
+private int jjStopAtPos(int pos, int kind)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   return pos + 1;
+}
+private int jjMoveStringLiteralDfa0_4()
+{
+   switch(curChar)
+   {
+      case 40:
+         return jjStopAtPos(0, 13);
+      case 41:
+         return jjStopAtPos(0, 14);
+      case 43:
+         return jjStopAtPos(0, 11);
+      case 45:
+         return jjStopAtPos(0, 12);
+      case 58:
+         return jjStopAtPos(0, 15);
+      case 65:
+         return jjMoveStringLiteralDfa1_4(0x20000L);
+      case 91:
+         return jjStopAtPos(0, 21);
+      case 94:
+         return jjStopAtPos(0, 16);
+      case 123:
+         return jjStopAtPos(0, 22);
+      default :
+         return jjMoveNfa_4(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_4(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_4(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 78:
+         return jjMoveStringLiteralDfa2_4(active0, 0x20000L);
+      default :
+         break;
+   }
+   return jjStartNfa_4(0, active0);
+}
+private int jjMoveStringLiteralDfa2_4(long old0, long active0)
+{
+   if (((active0 &= old0)) == 0L)
+      return jjStartNfa_4(0, old0);
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_4(1, active0);
+      return 2;
+   }
+   switch(curChar)
+   {
+      case 89:
+         if ((active0 & 0x20000L) != 0L)
+            return jjStartNfaWithStates_4(2, 17, 28);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_4(1, active0);
+}
+private int jjStartNfaWithStates_4(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_4(state, pos + 1);
+}
+static final long[] jjbitVec0 = {
+   0x1L, 0x0L, 0x0L, 0x0L
+};
+static final long[] jjbitVec1 = {
+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec3 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+static final long[] jjbitVec4 = {
+   0xfffefffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+};
+private int jjMoveNfa_4(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 28;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 28:
+               case 20:
+                  if ((0xfbfffcf8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 2:
+                  if ((0xfbfffcf8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 0:
+                  if ((0xfbffd4f8ffffd9ffL & l) != 0L)
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddTwoStates(20, 21);
+                  }
+                  else if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddStates(0, 2);
+                  else if (curChar == 33)
+                  {
+                     if (kind > 10)
+                        kind = 10;
+                  }
+                  if (curChar == 38)
+                     jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 1:
+                  if ((0xfbfffcf8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 4:
+                  if (curChar == 38 && kind > 8)
+                     kind = 8;
+                  break;
+               case 5:
+                  if (curChar == 38)
+                     jjstateSet[jjnewStateCnt++] = 4;
+                  break;
+               case 13:
+                  if (curChar == 33 && kind > 10)
+                     kind = 10;
+                  break;
+               case 14:
+                  if (curChar == 34)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 15:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 17:
+                  jjCheckNAddStates(0, 2);
+                  break;
+               case 18:
+                  if (curChar == 34 && kind > 18)
+                     kind = 18;
+                  break;
+               case 19:
+                  if ((0xfbffd4f8ffffd9ffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 22:
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 25:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjAddStates(3, 4);
+                  break;
+               case 26:
+                  if (curChar == 46)
+                     jjCheckNAdd(27);
+                  break;
+               case 27:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjCheckNAdd(27);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 28:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddTwoStates(20, 21);
+                  }
+                  else if (curChar == 92)
+                     jjCheckNAddTwoStates(22, 22);
+                  break;
+               case 2:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddTwoStates(20, 21);
+                  }
+                  else if (curChar == 92)
+                     jjCheckNAddTwoStates(22, 22);
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 1;
+                  break;
+               case 0:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddTwoStates(20, 21);
+                  }
+                  else if (curChar == 126)
+                  {
+                     if (kind > 20)
+                        kind = 20;
+                     jjstateSet[jjnewStateCnt++] = 25;
+                  }
+                  else if (curChar == 92)
+                     jjCheckNAdd(22);
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 11;
+                  else if (curChar == 124)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  else if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 6;
+                  else if (curChar == 65)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 1:
+                  if ((0x97ffffff87ffffffL & l) != 0L)
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddTwoStates(20, 21);
+                  }
+                  else if (curChar == 92)
+                     jjCheckNAddTwoStates(22, 22);
+                  if (curChar == 68)
+                  {
+                     if (kind > 8)
+                        kind = 8;
+                  }
+                  break;
+               case 3:
+                  if (curChar == 65)
+                     jjstateSet[jjnewStateCnt++] = 2;
+                  break;
+               case 6:
+                  if (curChar == 82 && kind > 9)
+                     kind = 9;
+                  break;
+               case 7:
+                  if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 6;
+                  break;
+               case 8:
+                  if (curChar == 124 && kind > 9)
+                     kind = 9;
+                  break;
+               case 9:
+                  if (curChar == 124)
+                     jjstateSet[jjnewStateCnt++] = 8;
+                  break;
+               case 10:
+                  if (curChar == 84 && kind > 10)
+                     kind = 10;
+                  break;
+               case 11:
+                  if (curChar == 79)
+                     jjstateSet[jjnewStateCnt++] = 10;
+                  break;
+               case 12:
+                  if (curChar == 78)
+                     jjstateSet[jjnewStateCnt++] = 11;
+                  break;
+               case 15:
+                  if ((0xffffffffefffffffL & l) != 0L)
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 16:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 17;
+                  break;
+               case 17:
+                  jjCheckNAddStates(0, 2);
+                  break;
+               case 19:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 20:
+                  if ((0x97ffffff87ffffffL & l) == 0L)
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 21:
+                  if (curChar == 92)
+                     jjCheckNAddTwoStates(22, 22);
+                  break;
+               case 22:
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 23:
+                  if (curChar == 92)
+                     jjCheckNAdd(22);
+                  break;
+               case 24:
+                  if (curChar != 126)
+                     break;
+                  if (kind > 20)
+                     kind = 20;
+                  jjstateSet[jjnewStateCnt++] = 25;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 28:
+               case 20:
+                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 2:
+                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 0:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  if (jjCanMove_2(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 19)
+                        kind = 19;
+                     jjCheckNAddTwoStates(20, 21);
+                  }
+                  break;
+               case 1:
+                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 15:
+               case 17:
+                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     jjCheckNAddStates(0, 2);
+                  break;
+               case 19:
+                  if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               case 22:
+                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 19)
+                     kind = 19;
+                  jjCheckNAddTwoStates(20, 21);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 28 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_3()
+{
+   return jjMoveNfa_3(0, 0);
+}
+private int jjMoveNfa_3(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 4;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x3ff000000000000L & l) != 0L)
+                  {
+                     if (kind > 23)
+                        kind = 23;
+                     jjCheckNAddTwoStates(1, 2);
+                  }
+                  else if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  break;
+               case 1:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 23)
+                     kind = 23;
+                  jjCheckNAddTwoStates(1, 2);
+                  break;
+               case 2:
+                  if (curChar == 46)
+                     jjCheckNAdd(3);
+                  break;
+               case 3:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 23)
+                     kind = 23;
+                  jjCheckNAdd(3);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 7)
+                     kind = 7;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 4 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private final int jjStopStringLiteralDfa_1(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x10000000L) != 0L)
+         {
+            jjmatchedKind = 31;
+            return 6;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_1(int pos, long active0)
+{
+   return jjMoveNfa_1(jjStopStringLiteralDfa_1(pos, active0), pos + 1);
+}
+private int jjMoveStringLiteralDfa0_1()
+{
+   switch(curChar)
+   {
+      case 84:
+         return jjMoveStringLiteralDfa1_1(0x10000000L);
+      case 125:
+         return jjStopAtPos(0, 29);
+      default :
+         return jjMoveNfa_1(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_1(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_1(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 79:
+         if ((active0 & 0x10000000L) != 0L)
+            return jjStartNfaWithStates_1(1, 28, 6);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_1(0, active0);
+}
+private int jjStartNfaWithStates_1(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_1(state, pos + 1);
+}
+private int jjMoveNfa_1(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 7;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0xfffffffeffffffffL & l) != 0L)
+                  {
+                     if (kind > 31)
+                        kind = 31;
+                     jjCheckNAdd(6);
+                  }
+                  if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 1:
+                  if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 2:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 3:
+                  if (curChar == 34)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 5:
+                  if (curChar == 34 && kind > 30)
+                     kind = 30;
+                  break;
+               case 6:
+                  if ((0xfffffffeffffffffL & l) == 0L)
+                     break;
+                  if (kind > 31)
+                     kind = 31;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if ((0xdfffffffffffffffL & l) == 0L)
+                     break;
+                  if (kind > 31)
+                     kind = 31;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  jjAddStates(5, 7);
+                  break;
+               case 4:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 31)
+                        kind = 31;
+                     jjCheckNAdd(6);
+                  }
+                  break;
+               case 2:
+                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     jjAddStates(5, 7);
+                  break;
+               case 6:
+                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 31)
+                     kind = 31;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private int jjMoveStringLiteralDfa0_0()
+{
+   return jjMoveNfa_0(0, 0);
+}
+private int jjMoveNfa_0(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 4;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0x3ff000000000000L & l) != 0L)
+                  {
+                     if (kind > 23)
+                        kind = 23;
+                     jjCheckNAddTwoStates(1, 2);
+                  }
+                  else if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  break;
+               case 1:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 23)
+                     kind = 23;
+                  jjCheckNAddTwoStates(1, 2);
+                  break;
+               case 2:
+                  if (curChar == 46)
+                     jjCheckNAdd(3);
+                  break;
+               case 3:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 23)
+                     kind = 23;
+                  jjCheckNAdd(3);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 7)
+                     kind = 7;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 4 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+private final int jjStopStringLiteralDfa_2(int pos, long active0)
+{
+   switch (pos)
+   {
+      case 0:
+         if ((active0 & 0x1000000L) != 0L)
+         {
+            jjmatchedKind = 27;
+            return 6;
+         }
+         return -1;
+      default :
+         return -1;
+   }
+}
+private final int jjStartNfa_2(int pos, long active0)
+{
+   return jjMoveNfa_2(jjStopStringLiteralDfa_2(pos, active0), pos + 1);
+}
+private int jjMoveStringLiteralDfa0_2()
+{
+   switch(curChar)
+   {
+      case 84:
+         return jjMoveStringLiteralDfa1_2(0x1000000L);
+      case 93:
+         return jjStopAtPos(0, 25);
+      default :
+         return jjMoveNfa_2(0, 0);
+   }
+}
+private int jjMoveStringLiteralDfa1_2(long active0)
+{
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) {
+      jjStopStringLiteralDfa_2(0, active0);
+      return 1;
+   }
+   switch(curChar)
+   {
+      case 79:
+         if ((active0 & 0x1000000L) != 0L)
+            return jjStartNfaWithStates_2(1, 24, 6);
+         break;
+      default :
+         break;
+   }
+   return jjStartNfa_2(0, active0);
+}
+private int jjStartNfaWithStates_2(int pos, int kind, int state)
+{
+   jjmatchedKind = kind;
+   jjmatchedPos = pos;
+   try { curChar = input_stream.readChar(); }
+   catch(java.io.IOException e) { return pos + 1; }
+   return jjMoveNfa_2(state, pos + 1);
+}
+private int jjMoveNfa_2(int startState, int curPos)
+{
+   int startsAt = 0;
+   jjnewStateCnt = 7;
+   int i = 1;
+   jjstateSet[0] = startState;
+   int kind = 0x7fffffff;
+   for (;;)
+   {
+      if (++jjround == 0x7fffffff)
+         ReInitRounds();
+      if (curChar < 64)
+      {
+         long l = 1L << curChar;
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if ((0xfffffffeffffffffL & l) != 0L)
+                  {
+                     if (kind > 27)
+                        kind = 27;
+                     jjCheckNAdd(6);
+                  }
+                  if ((0x100002600L & l) != 0L)
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  else if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 1:
+                  if (curChar == 34)
+                     jjCheckNAddTwoStates(2, 4);
+                  break;
+               case 2:
+                  if ((0xfffffffbffffffffL & l) != 0L)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 3:
+                  if (curChar == 34)
+                     jjCheckNAddStates(5, 7);
+                  break;
+               case 5:
+                  if (curChar == 34 && kind > 26)
+                     kind = 26;
+                  break;
+               case 6:
+                  if ((0xfffffffeffffffffL & l) == 0L)
+                     break;
+                  if (kind > 27)
+                     kind = 27;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else if (curChar < 128)
+      {
+         long l = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+               case 6:
+                  if ((0xffffffffdfffffffL & l) == 0L)
+                     break;
+                  if (kind > 27)
+                     kind = 27;
+                  jjCheckNAdd(6);
+                  break;
+               case 2:
+                  jjAddStates(5, 7);
+                  break;
+               case 4:
+                  if (curChar == 92)
+                     jjstateSet[jjnewStateCnt++] = 3;
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      else
+      {
+         int hiByte = (int)(curChar >> 8);
+         int i1 = hiByte >> 6;
+         long l1 = 1L << (hiByte & 077);
+         int i2 = (curChar & 0xff) >> 6;
+         long l2 = 1L << (curChar & 077);
+         do
+         {
+            switch(jjstateSet[--i])
+            {
+               case 0:
+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 7)
+                        kind = 7;
+                  }
+                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
+                  {
+                     if (kind > 27)
+                        kind = 27;
+                     jjCheckNAdd(6);
+                  }
+                  break;
+               case 2:
+                  if (jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     jjAddStates(5, 7);
+                  break;
+               case 6:
+                  if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
+                     break;
+                  if (kind > 27)
+                     kind = 27;
+                  jjCheckNAdd(6);
+                  break;
+               default : break;
+            }
+         } while(i != startsAt);
+      }
+      if (kind != 0x7fffffff)
+      {
+         jjmatchedKind = kind;
+         jjmatchedPos = curPos;
+         kind = 0x7fffffff;
+      }
+      ++curPos;
+      if ((i = jjnewStateCnt) == (startsAt = 7 - (jjnewStateCnt = startsAt)))
+         return curPos;
+      try { curChar = input_stream.readChar(); }
+      catch(java.io.IOException e) { return curPos; }
+   }
+}
+static final int[] jjnextStates = {
+   15, 16, 18, 25, 26, 2, 4, 5, 
+};
+private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 48:
+         return ((jjbitVec0[i2] & l2) != 0L);
+      default :
+         return false;
+   }
+}
+private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec3[i2] & l2) != 0L);
+      default :
+         if ((jjbitVec1[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2)
+{
+   switch(hiByte)
+   {
+      case 0:
+         return ((jjbitVec3[i2] & l2) != 0L);
+      case 48:
+         return ((jjbitVec1[i2] & l2) != 0L);
+      default :
+         if ((jjbitVec4[i1] & l1) != 0L)
+            return true;
+         return false;
+   }
+}
+
+/** Token literal values. */
+public static final String[] jjstrLiteralImages = {
+"", null, null, null, null, null, null, null, null, null, null, "\53", "\55", 
+"\50", "\51", "\72", "\136", "\101\116\131", null, null, null, "\133", "\173", null, 
+"\124\117", "\135", null, null, "\124\117", "\175", null, null, };
+
+/** Lexer state names. */
+public static final String[] lexStateNames = {
+   "Any_LS",
+   "RangeEx",
+   "RangeIn",
+   "Boost_LS",
+   "DEFAULT",
+};
+
+/** Lex State array. */
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, -1, -1, -1, 2, 1, 4, -1, 
+   4, -1, -1, -1, 4, -1, -1, 
+};
+static final long[] jjtoToken = {
+   0xffffff01L, 
+};
+static final long[] jjtoSkip = {
+   0x80L, 
+};
+protected JavaCharStream input_stream;
+private final int[] jjrounds = new int[28];
+private final int[] jjstateSet = new int[56];
+protected char curChar;
+/** Constructor. */
+public Standard2SyntaxParserTokenManager(JavaCharStream stream){
+   if (JavaCharStream.staticFlag)
+      throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
+   input_stream = stream;
+}
+
+/** Constructor. */
+public Standard2SyntaxParserTokenManager(JavaCharStream stream, int lexState){
+   this(stream);
+   SwitchTo(lexState);
+}
+
+/** Reinitialise parser. */
+public void ReInit(JavaCharStream stream)
+{
+   jjmatchedPos = jjnewStateCnt = 0;
+   curLexState = defaultLexState;
+   input_stream = stream;
+   ReInitRounds();
+}
+private void ReInitRounds()
+{
+   int i;
+   jjround = 0x80000001;
+   for (i = 28; i-- > 0;)
+      jjrounds[i] = 0x80000000;
+}
+
+/** Reinitialise parser. */
+public void ReInit(JavaCharStream stream, int lexState)
+{
+   ReInit(stream);
+   SwitchTo(lexState);
+}
+
+/** Switch to specified lex state. */
+public void SwitchTo(int lexState)
+{
+   if (lexState >= 5 || lexState < 0)
+      throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
+   else
+      curLexState = lexState;
+}
+
+protected Token jjFillToken()
+{
+   final Token t;
+   final String curTokenImage;
+   final int beginLine;
+   final int endLine;
+   final int beginColumn;
+   final int endColumn;
+   String im = jjstrLiteralImages[jjmatchedKind];
+   curTokenImage = (im == null) ? input_stream.GetImage() : im;
+   beginLine = input_stream.getBeginLine();
+   beginColumn = input_stream.getBeginColumn();
+   endLine = input_stream.getEndLine();
+   endColumn = input_stream.getEndColumn();
+   t = Token.newToken(jjmatchedKind, curTokenImage);
+
+   t.beginLine = beginLine;
+   t.endLine = endLine;
+   t.beginColumn = beginColumn;
+   t.endColumn = endColumn;
+
+   return t;
+}
+
+int curLexState = 4;
+int defaultLexState = 4;
+int jjnewStateCnt;
+int jjround;
+int jjmatchedPos;
+int jjmatchedKind;
+
+/** Get the next Token. */
+public Token getNextToken() 
+{
+  Token matchedToken;
+  int curPos = 0;
+
+  EOFLoop :
+  for (;;)
+  {
+   try
+   {
+      curChar = input_stream.BeginToken();
+   }
+   catch(java.io.IOException e)
+   {
+      jjmatchedKind = 0;
+      matchedToken = jjFillToken();
+      return matchedToken;
+   }
+
+   switch(curLexState)
+   {
+     case 0:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_0();
+       break;
+     case 1:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_1();
+       break;
+     case 2:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_2();
+       break;
+     case 3:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_3();
+       break;
+     case 4:
+       jjmatchedKind = 0x7fffffff;
+       jjmatchedPos = 0;
+       curPos = jjMoveStringLiteralDfa0_4();
+       break;
+   }
+     if (jjmatchedKind != 0x7fffffff)
+     {
+        if (jjmatchedPos + 1 < curPos)
+           input_stream.backup(curPos - jjmatchedPos - 1);
+        if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
+        {
+           matchedToken = jjFillToken();
+       if (jjnewLexState[jjmatchedKind] != -1)
+         curLexState = jjnewLexState[jjmatchedKind];
+           return matchedToken;
+        }
+        else
+        {
+         if (jjnewLexState[jjmatchedKind] != -1)
+           curLexState = jjnewLexState[jjmatchedKind];
+           continue EOFLoop;
+        }
+     }
+     int error_line = input_stream.getEndLine();
+     int error_column = input_stream.getEndColumn();
+     String error_after = null;
+     boolean EOFSeen = false;
+     try { input_stream.readChar(); input_stream.backup(1); }
+     catch (java.io.IOException e1) {
+        EOFSeen = true;
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+        if (curChar == '\n' || curChar == '\r') {
+           error_line++;
+           error_column = 0;
+        }
+        else
+           error_column++;
+     }
+     if (!EOFSeen) {
+        input_stream.backup(1);
+        error_after = curPos <= 1 ? "" : input_stream.GetImage();
+     }
+     throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
+  }
+}
+
+private void jjCheckNAdd(int state)
+{
+   if (jjrounds[state] != jjround)
+   {
+      jjstateSet[jjnewStateCnt++] = state;
+      jjrounds[state] = jjround;
+   }
+}
+private void jjAddStates(int start, int end)
+{
+   do {
+      jjstateSet[jjnewStateCnt++] = jjnextStates[start];
+   } while (start++ != end);
+}
+private void jjCheckNAddTwoStates(int state1, int state2)
+{
+   jjCheckNAdd(state1);
+   jjCheckNAdd(state2);
+}
+
+private void jjCheckNAddStates(int start, int end)
+{
+   do {
+      jjCheckNAdd(jjnextStates[start]);
+   } while (start++ != end);
+}
+
+}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Token.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Token.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/Token.java	(revision 0)
@@ -0,0 +1,131 @@
+/* Generated By:JavaCC: Do not edit this line. Token.java Version 4.1 */
+/* JavaCCOptions:TOKEN_EXTENDS=,KEEP_LINE_COL=null,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
+package org.apache.lucene.queryParser.standard2.parser;
+
+/**
+ * Describes the input token stream.
+ */
+
+public class Token implements java.io.Serializable {
+
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /**
+   * An integer that describes the kind of this token.  This numbering
+   * system is determined by JavaCCParser, and a table of these numbers is
+   * stored in the file ...Constants.java.
+   */
+  public int kind;
+
+  /** The line number of the first character of this Token. */
+  public int beginLine;
+  /** The column number of the first character of this Token. */
+  public int beginColumn;
+  /** The line number of the last character of this Token. */
+  public int endLine;
+  /** The column number of the last character of this Token. */
+  public int endColumn;
+
+  /**
+   * The string image of the token.
+   */
+  public String image;
+
+  /**
+   * A reference to the next regular (non-special) token from the input
+   * stream.  If this is the last token from the input stream, or if the
+   * token manager has not read tokens beyond this one, this field is
+   * set to null.  This is true only if this token is also a regular
+   * token.  Otherwise, see below for a description of the contents of
+   * this field.
+   */
+  public Token next;
+
+  /**
+   * This field is used to access special tokens that occur prior to this
+   * token, but after the immediately preceding regular (non-special) token.
+   * If there are no such special tokens, this field is set to null.
+   * When there are more than one such special token, this field refers
+   * to the last of these special tokens, which in turn refers to the next
+   * previous special token through its specialToken field, and so on
+   * until the first special token (whose specialToken field is null).
+   * The next fields of special tokens refer to other special tokens that
+   * immediately follow it (without an intervening regular token).  If there
+   * is no such token, this field is null.
+   */
+  public Token specialToken;
+
+  /**
+   * An optional attribute value of the Token.
+   * Tokens which are not used as syntactic sugar will often contain
+   * meaningful values that will be used later on by the compiler or
+   * interpreter. This attribute value is often different from the image.
+   * Any subclass of Token that actually wants to return a non-null value can
+   * override this method as appropriate.
+   */
+  public Object getValue() {
+    return null;
+  }
+
+  /**
+   * No-argument constructor
+   */
+  public Token() {}
+
+  /**
+   * Constructs a new token for the specified Image.
+   */
+  public Token(int kind)
+  {
+    this(kind, null);
+  }
+
+  /**
+   * Constructs a new token for the specified Image and Kind.
+   */
+  public Token(int kind, String image)
+  {
+    this.kind = kind;
+    this.image = image;
+  }
+
+  /**
+   * Returns the image.
+   */
+  public String toString()
+  {
+    return image;
+  }
+
+  /**
+   * Returns a new Token object, by default. However, if you want, you
+   * can create and return subclass objects based on the value of ofKind.
+   * Simply add the cases to the switch for all those special cases.
+   * For example, if you have a subclass of Token called IDToken that
+   * you want to create if ofKind is ID, simply add something like :
+   *
+   *    case MyParserConstants.ID : return new IDToken(ofKind, image);
+   *
+   * to the following switch statement. Then you can cast matchedToken
+   * variable to the appropriate type and use sit in your lexical actions.
+   */
+  public static Token newToken(int ofKind, String image)
+  {
+    switch(ofKind)
+    {
+      default : return new Token(ofKind, image);
+    }
+  }
+
+  public static Token newToken(int ofKind)
+  {
+    return newToken(ofKind, null);
+  }
+
+}
+/* JavaCC - OriginalChecksum=a6f6af25e76a633f5f193c2611e66306 (do not edit this line) */
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/TokenMgrError.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/TokenMgrError.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/TokenMgrError.java	(revision 0)
@@ -0,0 +1,147 @@
+/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 4.1 */
+/* JavaCCOptions: */
+package org.apache.lucene.queryParser.standard2.parser;
+
+/** Token Manager Error. */
+public class TokenMgrError extends Error
+{
+
+  /**
+   * The version identifier for this Serializable class.
+   * Increment only if the <i>serialized</i> form of the
+   * class changes.
+   */
+  private static final long serialVersionUID = 1L;
+
+  /*
+   * Ordinals for various reasons why an Error of this type can be thrown.
+   */
+
+  /**
+   * Lexical error occurred.
+   */
+  static final int LEXICAL_ERROR = 0;
+
+  /**
+   * An attempt was made to create a second instance of a static token manager.
+   */
+  static final int STATIC_LEXER_ERROR = 1;
+
+  /**
+   * Tried to change to an invalid lexical state.
+   */
+  static final int INVALID_LEXICAL_STATE = 2;
+
+  /**
+   * Detected (and bailed out of) an infinite loop in the token manager.
+   */
+  static final int LOOP_DETECTED = 3;
+
+  /**
+   * Indicates the reason why the exception is thrown. It will have
+   * one of the above 4 values.
+   */
+  int errorCode;
+
+  /**
+   * Replaces unprintable characters by their escaped (or unicode escaped)
+   * equivalents in the given string
+   */
+  protected static final String addEscapes(String str) {
+    StringBuffer retval = new StringBuffer();
+    char ch;
+    for (int i = 0; i < str.length(); i++) {
+      switch (str.charAt(i))
+      {
+        case 0 :
+          continue;
+        case '\b':
+          retval.append("\\b");
+          continue;
+        case '\t':
+          retval.append("\\t");
+          continue;
+        case '\n':
+          retval.append("\\n");
+          continue;
+        case '\f':
+          retval.append("\\f");
+          continue;
+        case '\r':
+          retval.append("\\r");
+          continue;
+        case '\"':
+          retval.append("\\\"");
+          continue;
+        case '\'':
+          retval.append("\\\'");
+          continue;
+        case '\\':
+          retval.append("\\\\");
+          continue;
+        default:
+          if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
+            String s = "0000" + Integer.toString(ch, 16);
+            retval.append("\\u" + s.substring(s.length() - 4, s.length()));
+          } else {
+            retval.append(ch);
+          }
+          continue;
+      }
+    }
+    return retval.toString();
+  }
+
+  /**
+   * Returns a detailed message for the Error when it is thrown by the
+   * token manager to indicate a lexical error.
+   * Parameters :
+   *    EOFSeen     : indicates if EOF caused the lexical error
+   *    curLexState : lexical state in which this error occurred
+   *    errorLine   : line number when the error occurred
+   *    errorColumn : column number when the error occurred
+   *    errorAfter  : prefix that was seen before this error occurred
+   *    curchar     : the offending character
+   * Note: You can customize the lexical error message by modifying this method.
+   */
+  protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
+    return("Lexical error at line " +
+          errorLine + ", column " +
+          errorColumn + ".  Encountered: " +
+          (EOFSeen ? "<EOF> " : ("\"" + addEscapes(String.valueOf(curChar)) + "\"") + " (" + (int)curChar + "), ") +
+          "after : \"" + addEscapes(errorAfter) + "\"");
+  }
+
+  /**
+   * You can also modify the body of this method to customize your error messages.
+   * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
+   * of end-users concern, so you can return something like :
+   *
+   *     "Internal Error : Please file a bug report .... "
+   *
+   * from this method for such cases in the release version of your parser.
+   */
+  public String getMessage() {
+    return super.getMessage();
+  }
+
+  /*
+   * Constructors of various flavors follow.
+   */
+
+  /** No arg constructor. */
+  public TokenMgrError() {
+  }
+
+  /** Constructor with message and reason. */
+  public TokenMgrError(String message, int reason) {
+    super(message);
+    errorCode = reason;
+  }
+
+  /** Full Constructor. */
+  public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {
+    this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
+  }
+}
+/* JavaCC - OriginalChecksum=f12aee326c9d017759e706bef9b50888 (do not edit this line) */
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/package.html
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/package.html	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/parser/package.html	(revision 0)
@@ -0,0 +1,34 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+<h2>Lucene Query Parser</h2>
+<p>
+The package org.apache.lucene.queryParser.standard.parser contains the query parser.
+</p>
+<p>
+This text parser only performs the syntax validation and creates an QueryNode tree
+from a query string.
+- support for opaque terms
+</p>
+</body>
+</html>
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/AnyValidatorQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/AnyValidatorQueryNodeProcessor.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/AnyValidatorQueryNodeProcessor.java	(revision 0)
@@ -0,0 +1,95 @@
+package org.apache.lucene.queryParser.standard2.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryParser.core.messages.QueryParserMessages;
+import org.apache.lucene.messages.MessageImpl;
+import org.apache.lucene.queryParser.core.QueryNodeException;
+import org.apache.lucene.queryParser.core.nodes.AnyQueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryParser.standard.parser.EscapeQuerySyntaxImpl;
+
+public class AnyValidatorQueryNodeProcessor extends QueryNodeProcessorImpl {
+    
+    public AnyValidatorQueryNodeProcessor() {
+        // empty constructor
+    }
+
+    /* (non-Javadoc)
+     * @see corg.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl#postProcessNode(org.apache.lucene.queryParser.nodes.QueryNode)
+     */
+    @Override
+    protected QueryNode postProcessNode(QueryNode node)
+            throws QueryNodeException {
+        
+        return node;
+        
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl#preProcessNode(org.apache.lucene.queryParser.nodes.QueryNode)
+     */
+    @Override
+    protected QueryNode preProcessNode(QueryNode node)
+            throws QueryNodeException {
+        
+        if (node instanceof AnyQueryNode) {
+            AnyQueryNode anyNode = (AnyQueryNode) node;
+            CharSequence queryString = anyNode.toQueryString(new EscapeQuerySyntaxImpl());
+            
+            if (anyNode.getMinimumMatchingElements() <= 1) {
+                
+                throw new QueryNodeException(new MessageImpl(QueryParserMessages.INVALID_NUMBER_OF_ARGUMENTS_FOR_ANY, queryString));
+                
+            }
+            
+            if (anyNode.getChildren() == null || anyNode.getChildren().size() < 2) {
+                
+                // TODO: maybe a message should be created only for this case
+                throw new QueryNodeException(new MessageImpl(QueryParserMessages.INVALID_NUMBER_OF_ARGUMENTS_FOR_ANY, queryString));
+                
+            }
+            
+            if (anyNode.getChildren().size() < anyNode.getMinimumMatchingElements()) {
+                
+                // TODO: a message should be created only for this case
+                throw new QueryNodeException(new MessageImpl(QueryParserMessages.INVALID_NUMBER_OF_ARGUMENTS_FOR_ANY, queryString));
+                
+            }
+            
+        }
+        
+        return node;
+        
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.lucene.queryParser.processors.QueryNodeProcessorImpl#setChildrenOrder(java.util.List)
+     */
+    @Override
+    protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+            throws QueryNodeException {
+        
+        return children;
+        
+    }
+    
+}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/BooleanModifiersQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/BooleanModifiersQueryNodeProcessor.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/BooleanModifiersQueryNodeProcessor.java	(revision 0)
@@ -0,0 +1,138 @@
+package org.apache.lucene.queryParser.standard2.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.queryParser.core.QueryNodeException;
+import org.apache.lucene.queryParser.core.nodes.AndQueryNode;
+import org.apache.lucene.queryParser.core.nodes.BooleanQueryNode;
+import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode;
+import org.apache.lucene.queryParser.core.nodes.OrQueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.core.nodes.ModifierQueryNode.Modifier;
+import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
+import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute;
+import org.apache.lucene.queryParser.standard.config.DefaultOperatorAttribute.Operator;
+import org.apache.lucene.queryParser.standard2.Standard2QueryParser;
+
+/**
+ * <p>
+ * This processor is used to apply the correct {@link ModifierQueryNode} to {@link BooleanQueryNode}s children.
+ * </p>
+ * <p>
+ * It walks through the query node tree looking for {@link BooleanQueryNode}s. If an {@link AndQueryNode} is found,
+ * every children, which is not a {@link ModifierQueryNode} or the {@link ModifierQueryNode} 
+ * is {@link Modifier#MOD_NONE}, becomes a {@link Modifier#MOD_REQ}. For any other
+ * {@link BooleanQueryNode} which is not an {@link OrQueryNode}, it checks the default operator is {@link Operator#AND},
+ * if it is, the same operation when an {@link AndQueryNode} is found is applied to it.
+ * </p>
+ * 
+ * @see DefaultOperatorAttribute
+ * @see Standard2QueryParser#setDefaultOperator(Operator)
+ */
+public class BooleanModifiersQueryNodeProcessor extends QueryNodeProcessorImpl {
+
+  private ArrayList<QueryNode> childrenBuffer = new ArrayList<QueryNode>();
+
+  private Boolean usingAnd = false;
+
+  public BooleanModifiersQueryNodeProcessor() {
+    // empty constructor
+  }
+
+  @Override
+  public QueryNode process(QueryNode queryTree) throws QueryNodeException {
+
+    if (!getQueryConfigHandler().hasAttribute(DefaultOperatorAttribute.class)) {
+      throw new IllegalArgumentException(
+          "DefaultOperatorAttribute should be set on the QueryConfigHandler");
+    }
+
+    this.usingAnd = Operator.AND == getQueryConfigHandler().getAttribute(
+        DefaultOperatorAttribute.class).getOperator();
+
+    return super.process(queryTree);
+
+  }
+
+  @Override
+  protected QueryNode postProcessNode(QueryNode node) throws QueryNodeException {
+
+    if (node instanceof AndQueryNode) {
+      this.childrenBuffer.clear();
+      List<QueryNode> children = node.getChildren();
+
+      for (QueryNode child : children) {
+        this.childrenBuffer.add(applyModifier(child, Modifier.MOD_REQ));
+      }
+
+      node.set(this.childrenBuffer);
+
+    } else if (this.usingAnd && node instanceof BooleanQueryNode
+        && !(node instanceof OrQueryNode)) {
+
+      this.childrenBuffer.clear();
+      List<QueryNode> children = node.getChildren();
+
+      for (QueryNode child : children) {
+        this.childrenBuffer.add(applyModifier(child, Modifier.MOD_REQ));
+      }
+
+      node.set(this.childrenBuffer);
+
+    }
+
+    return node;
+
+  }
+
+  private QueryNode applyModifier(QueryNode node, Modifier mod) {
+
+    // check if modifier is not already defined and is default
+    if (!(node instanceof ModifierQueryNode)) {
+      return new ModifierQueryNode(node, mod);
+
+    } else {
+      ModifierQueryNode modNode = (ModifierQueryNode) node;
+
+      if (modNode.getModifier() == Modifier.MOD_NONE) {
+        return new ModifierQueryNode(modNode.getChild(), mod);
+      }
+
+    }
+
+    return node;
+
+  }
+
+  @Override
+  protected QueryNode preProcessNode(QueryNode node) throws QueryNodeException {
+    return node;
+  }
+
+  @Override
+  protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+      throws QueryNodeException {
+
+    return children;
+
+  }
+
+}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/OpaqueQueryNodeProcessor.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/OpaqueQueryNodeProcessor.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/OpaqueQueryNodeProcessor.java	(revision 0)
@@ -0,0 +1,70 @@
+package org.apache.lucene.queryParser.standard2.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+
+import org.apache.lucene.queryParser.core.QueryNodeException;
+import org.apache.lucene.queryParser.core.nodes.OpaqueQueryNode;
+import org.apache.lucene.queryParser.core.nodes.QueryNode;
+import org.apache.lucene.queryParser.core.processors.QueryNodeProcessorImpl;
+
+public class OpaqueQueryNodeProcessor extends QueryNodeProcessorImpl {
+    
+    public OpaqueQueryNodeProcessor() {
+        // empty constructor
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.lucene.queryParser.processors.QueryNodeProcessorImpl#postProcessNode(org.apache.lucene.queryParser.nodes.QueryNode)
+     */
+    @Override
+    protected QueryNode postProcessNode(QueryNode node)
+            throws QueryNodeException {
+        
+        return node;
+        
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.lucene.queryParser.processors.QueryNodeProcessorImpl#preProcessNode(org.apache.lucene.queryParser.nodes.QueryNode)
+     */
+    @Override
+    protected QueryNode preProcessNode(QueryNode node)
+            throws QueryNodeException {
+        
+        if (node instanceof OpaqueQueryNode) {
+          // nothing to do for now
+        }
+        
+        return node;
+        
+    }
+
+    /* (non-Javadoc)
+     * @see org.apache.lucene.queryParser.processors.QueryNodeProcessorImpl#setChildrenOrder(java.util.List)
+     */
+    @Override
+    protected List<QueryNode> setChildrenOrder(List<QueryNode> children)
+            throws QueryNodeException {
+        
+        return children;
+        
+    }
+    
+}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/Standard2QueryNodeProcessorPipeline.java
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/Standard2QueryNodeProcessorPipeline.java	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/Standard2QueryNodeProcessorPipeline.java	(revision 0)
@@ -0,0 +1,61 @@
+package org.apache.lucene.queryParser.standard2.processors;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.queryParser.core.config.QueryConfigHandler;
+import org.apache.lucene.queryParser.standard.processors.GroupQueryNodeProcessor;
+import org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline;
+import org.apache.lucene.queryParser.standard2.Standard2QueryParser;
+
+/**
+ * <p>
+ * This processor pipeline extends {@link StandardQueryNodeProcessorPipeline} and enables
+ * boolean precedence on it.
+ * </p>
+ * <p>
+ * EXPERT: the precedence is enabled by removing {@link GroupQueryNodeProcessor} from the
+ * {@link StandardQueryNodeProcessorPipeline} and appending {@link BooleanModifiersQueryNodeProcessor}
+ * to the pipeline.
+ * </p>
+ * 
+ * @see Standard2QueryParser
+ *  @see StandardQueryNodeProcessorPipeline
+ */
+public class Standard2QueryNodeProcessorPipeline extends StandardQueryNodeProcessorPipeline {
+
+  /**
+   * @see StandardQueryNodeProcessorPipeline#StandardQueryNodeProcessorPipeline(QueryConfigHandler)
+   */
+  public Standard2QueryNodeProcessorPipeline(QueryConfigHandler queryConfig) {
+    super(queryConfig);
+    
+    for (int i = 0 ; i < this.size() ; i++) {
+      
+      if (this.get(i).getClass().equals(GroupQueryNodeProcessor.class)) {
+        this.remove(i--);
+      }
+      
+    }
+    
+    addProcessor(new BooleanModifiersQueryNodeProcessor());
+    addProcessor(new AnyValidatorQueryNodeProcessor());
+    addProcessor(new OpaqueQueryNodeProcessor());
+    
+  }
+
+}
Index: contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/package.html
===================================================================
--- contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/package.html	(revision 0)
+++ contrib/queryparser/src/java/org/apache/lucene/queryParser/standard2/processors/package.html	(revision 0)
@@ -0,0 +1,47 @@
+<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<html>
+<head>
+   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+</head>
+<body>
+
+This package contains the processors used by Precedence Query Parser
+
+<h2>Lucene Precedence Query Parser Processors</h2>
+
+<p>
+This package contains the 2 {@link org.apache.lucene.queryParser.core.processors.QueryNodeProcessor}s used by
+{@link org.apache.lucene.queryParser.precedence.PrecedenceQueryParser.
+</p>
+<p>
+{@link org.apache.lucene.queryParser.precedence.processors.BooleanModifiersQueryNodeProcessor}: this processor
+is used to apply {@link org.apache.lucene.queryParser.core.nodes.ModifierQueryNode}s on 
+{@link org.apache.lucene.queryParser.core.nodes.BooleanQueryNode} children according to the boolean type
+or the default operator.
+</p>
+<p>
+{@link org.apache.lucene.queryParser.precedence.processors.PrecedenceQueryNodeProcessorPipeline}: this 
+processor pipeline is used by {@link org.apache.lucene.queryParser.precedence.PrecedenceQueryParser}. It extends
+{@link org.apache.lucene.queryParser.standard.processors.StandardQueryNodeProcessorPipeline} and rearrange
+the pipeline so the boolean precedence is processed correctly. Check {@link org.apache.lucene.queryParser.precedence.processors.PrecedenceQueryNodeProcessorPipeline}
+for more details. 
+</p>
+
+</body>
+</html>
Index: contrib/queryparser/src/resources/org/apache/lucene/queryParser/core/messages/QueryParserMessages.properties
===================================================================
--- contrib/queryparser/src/resources/org/apache/lucene/queryParser/core/messages/QueryParserMessages.properties	(revision 881959)
+++ contrib/queryparser/src/resources/org/apache/lucene/queryParser/core/messages/QueryParserMessages.properties	(working copy)
@@ -22,12 +22,24 @@
 INVALID_SYNTAX_ESCAPE_NONE_HEX_UNICODE = None-hex character in unicode escape sequence: {0}
 
 #<CREATEDBY>Apache Lucene Community</CREATEDBY>
+INVALID_NUMBER_OF_ARGUMENTS_FOR_ANY = Invalid ANY operator, the number of arguments should always be greater than 1 and the minimum match value lower than the number of arguments: {0}.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
 NODE_ACTION_NOT_SUPPORTED = This node does not support this action.
 
 #<CREATEDBY>Apache Lucene Community</CREATEDBY>
 PARAMETER_VALUE_NOT_SUPPORTED = Parameter {1} with value {0} not supported.
 
 #<CREATEDBY>Apache Lucene Community</CREATEDBY>
+OPAQUE_EXTENSIONS_NOT_SUPPORTED = Opaque Extensions are not supported by this parser.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+OPAQUE_EXTENSION_NAME_NOT_SUPPORTED = Opaque Extension name {0} is not supported by this parser.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
+OPAQUE_EXTENSION_PARSING_ERROR = Opaque Extension name {0} reported a parsing error for query: {1}
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
 #  <REPLACEMENT arg="{0}" value="query"/>
 #  <REPLACEMENT arg="{1}" value="error/class"/>
 LUCENE_QUERY_CONVERSION_ERROR = Cannot convert query to lucene syntax: {0} error: {1}
Index: contrib/db/bdb-je/build.xml
===================================================================
--- contrib/db/bdb-je/build.xml	(revision 881959)
+++ contrib/db/bdb-je/build.xml	(working copy)
@@ -21,7 +21,7 @@
     Lucene Berkeley DB Java Edition integration
   </description>
 
-  <property name="je.version" value="3.3.69" />
+  <property name="je.version" value="3.3.93" />
 
   <path id="je.jar">
     <pathelement location="lib/je-${je.version}/lib/je-${je.version}.jar" />
