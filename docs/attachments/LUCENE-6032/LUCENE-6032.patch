Index: lucene/core/src/java/org/apache/lucene/search/DocValuesDocIdSet.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DocValuesDocIdSet.java	(revision 1635064)
+++ lucene/core/src/java/org/apache/lucene/search/DocValuesDocIdSet.java	(working copy)
@@ -19,8 +19,6 @@
 import java.io.IOException;
 
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.BitDocIdSet;
-import org.apache.lucene.util.FixedBitSet;
 
 /**
  * Base class for DocIdSet to be used with DocValues. The implementation
@@ -76,82 +74,7 @@
   }
 
   @Override
-  public final DocIdSetIterator iterator() throws IOException {
-    if (acceptDocs == null) {
-      // Specialization optimization disregard acceptDocs
-      return new DocIdSetIterator() {
-        private int doc = -1;
-        
-        @Override
-        public int docID() {
-          return doc;
-        }
-      
-        @Override
-        public int nextDoc() {
-          do {
-            doc++;
-            if (doc >= maxDoc) {
-              return doc = NO_MORE_DOCS;
-            }
-          } while (!matchDoc(doc));
-          return doc;
-        }
-      
-        @Override
-        public int advance(int target) {
-          for(doc=target; doc<maxDoc; doc++) {
-            if (matchDoc(doc)) {
-              return doc;
-            }
-          }
-          return doc = NO_MORE_DOCS;
-        }
-
-        @Override
-        public long cost() {
-          return maxDoc;
-        }
-      };
-    } else if (acceptDocs instanceof FixedBitSet) {
-      // special case for FixedBitSet: use the iterator and filter it
-      // (used e.g. when Filters are chained by FilteredQuery)
-      return new FilteredDocIdSetIterator(new BitDocIdSet((FixedBitSet) acceptDocs).iterator()) {
-        @Override
-        protected boolean match(int doc) {
-          return DocValuesDocIdSet.this.matchDoc(doc);
-        }
-      };
-    } else {
-      // Stupid consultation of acceptDocs and matchDoc()
-      return new DocIdSetIterator() {
-        private int doc = -1;
-        
-        @Override
-        public int docID() {
-          return doc;
-        }
-      
-        @Override
-        public int nextDoc() {
-          return advance(doc + 1);
-        }
-      
-        @Override
-        public int advance(int target) {
-          for(doc=target; doc<maxDoc; doc++) {
-            if (acceptDocs.get(doc) && matchDoc(doc)) {
-              return doc;
-            }
-          }
-          return doc = NO_MORE_DOCS;
-        }
-
-        @Override
-        public long cost() {
-          return maxDoc;
-        }
-      };
-    }
+  public DocIdSetIterator iterator() throws IOException {
+    throw new UnsupportedOperationException();
   }
 }
Index: lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java	(revision 1635064)
+++ lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java	(working copy)
@@ -102,11 +102,23 @@
         Explanation inner = weight.explain (ir, i);
         Filter f = FilteredQuery.this.filter;
         DocIdSet docIdSet = f.getDocIdSet(ir, ir.reader().getLiveDocs());
-        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSetIterator.empty() : docIdSet.iterator();
-        if (docIdSetIterator == null) {
-          docIdSetIterator = DocIdSetIterator.empty();
+        final boolean match;
+        if (docIdSet == null) {
+          match = false;
+        } else {
+          Bits bits = docIdSet.bits();
+          if (bits != null) {
+            match = bits.get(i);
+          } else {
+            DocIdSetIterator disi = docIdSet.iterator();
+            if (disi == null) {
+              match = false;
+            } else {
+              match = disi.advance(i) == i;
+            }
+          }
         }
-        if (docIdSetIterator.advance(i) == i) {
+        if (match) {
           return inner;
         } else {
           Explanation result = new Explanation
@@ -503,15 +515,29 @@
 
     @Override
     public Scorer filteredScorer(LeafReaderContext context, Weight weight, DocIdSet docIdSet) throws IOException {
-      final DocIdSetIterator filterIter = docIdSet.iterator();
-      if (filterIter == null) {
-        // this means the filter does not accept any documents.
-        return null;
-      }  
-      
       final Bits filterAcceptDocs = docIdSet.bits();
-      // force if RA is requested
-      final boolean useRandomAccess = filterAcceptDocs != null && useRandomAccess(filterAcceptDocs, filterIter.cost());
+      final DocIdSetIterator filterIter;
+      final boolean useRandomAccess;
+      if (filterAcceptDocs == null) {
+        // the filter does not support random access
+        useRandomAccess = false;
+        filterIter = docIdSet.iterator();
+      } else {
+        DocIdSetIterator it = null;
+        try {
+           it = docIdSet.iterator();
+           if (it == null) {
+             // the filter doesn't match any document
+             return null;
+           }
+        } catch (UnsupportedOperationException e) {
+          // it == null
+        } finally {
+          filterIter = it;
+          useRandomAccess = filterIter == null || useRandomAccess(filterAcceptDocs, filterIter.cost());
+        }
+      }
+
       if (useRandomAccess) {
         // if we are using random access, we return the inner scorer, just with other acceptDocs
         return weight.scorer(context, filterAcceptDocs);
@@ -552,7 +578,14 @@
     @Override
     public Scorer filteredScorer(LeafReaderContext context,
         Weight weight, DocIdSet docIdSet) throws IOException {
-      final DocIdSetIterator filterIter = docIdSet.iterator();
+      
+      final DocIdSetIterator filterIter;
+      try {
+        filterIter = docIdSet.iterator();
+      } catch (UnsupportedOperationException e) {
+        // the filter does not support sequential access
+        return RANDOM_ACCESS_FILTER_STRATEGY.filteredScorer(context, weight, docIdSet);
+      }
       if (filterIter == null) {
         // this means the filter does not accept any documents.
         return null;
Index: lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery.java	(revision 1635064)
+++ lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery.java	(working copy)
@@ -116,7 +116,7 @@
     directory.close();
     super.tearDown();
   }
-  
+
   public void testFilteredQuery() throws Exception {
     // force the filter to be executed as bits
     tFilteredQuery(true);
@@ -155,10 +155,10 @@
     hits = searcher.search (filteredquery, null, 1000).scoreDocs;
     assertEquals (0, hits.length);
     QueryUtils.check(random(), filteredquery,searcher);
-    
+
     // test boost
     Filter f = newStaticFilterA();
-    
+
     float boost = 2.5f;
     BooleanQuery bq1 = new BooleanQuery();
     TermQuery tq = new TermQuery (new Term ("field", "one"));
@@ -165,7 +165,7 @@
     tq.setBoost(boost);
     bq1.add(tq, Occur.MUST);
     bq1.add(new TermQuery (new Term ("field", "five")), Occur.MUST);
-    
+
     BooleanQuery bq2 = new BooleanQuery();
     tq = new TermQuery (new Term ("field", "one"));
     filteredquery = new FilteredQuery(tq, f, randomFilterStrategy(random(), useRandomAccess));
@@ -173,12 +173,12 @@
     bq2.add(filteredquery, Occur.MUST);
     bq2.add(new TermQuery (new Term ("field", "five")), Occur.MUST);
     assertScoreEquals(bq1, bq2);
-    
+
     assertEquals(boost, filteredquery.getBoost(), 0);
-    assertEquals(1.0f, tq.getBoost(), 0); // the boost value of the underlying query shouldn't have changed 
+    assertEquals(1.0f, tq.getBoost(), 0); // the boost value of the underlying query shouldn't have changed
   }
 
-  // must be static for serialization tests 
+  // must be static for serialization tests
   private static Filter newStaticFilterA() {
     return new Filter() {
       @Override
@@ -190,7 +190,7 @@
       }
     };
   }
-  
+
   /**
    * Tests whether the scores of the two queries are the same.
    */
@@ -197,9 +197,9 @@
   public void assertScoreEquals(Query q1, Query q2) throws Exception {
     ScoreDoc[] hits1 = searcher.search (q1, null, 1000).scoreDocs;
     ScoreDoc[] hits2 = searcher.search (q2, null, 1000).scoreDocs;
-      
+
     assertEquals(hits1.length, hits2.length);
-    
+
     for (int i = 0; i < hits1.length; i++) {
       assertEquals(hits1[i].score, hits2[i].score, 0.000001f);
     }
@@ -239,7 +239,7 @@
     bq.add(query, BooleanClause.Occur.MUST);
     ScoreDoc[] hits = searcher.search(bq, null, 1000).scoreDocs;
     assertEquals(0, hits.length);
-    QueryUtils.check(random(), query,searcher);    
+    QueryUtils.check(random(), query,searcher);
   }
 
   public void testBooleanSHOULD() throws Exception {
@@ -257,7 +257,7 @@
     bq.add(query, BooleanClause.Occur.SHOULD);
     ScoreDoc[] hits = searcher.search(bq, null, 1000).scoreDocs;
     assertEquals(2, hits.length);
-    QueryUtils.check(random(), query,searcher);    
+    QueryUtils.check(random(), query,searcher);
   }
 
   // Make sure BooleanQuery, which does out-of-order
@@ -276,9 +276,9 @@
     bq.add(new TermQuery(new Term("field", "two")), BooleanClause.Occur.SHOULD);
     ScoreDoc[] hits = searcher.search(query, 1000).scoreDocs;
     assertEquals(1, hits.length);
-    QueryUtils.check(random(), query, searcher);    
+    QueryUtils.check(random(), query, searcher);
   }
-  
+
   public void testChainedFilters() throws Exception {
     // force the filter to be executed as bits
     tChainedFilters(true);
@@ -285,7 +285,7 @@
     // force the filter to be executed as iterator
     tChainedFilters(false);
   }
-  
+
   private void tChainedFilters(final boolean useRandomAccess) throws Exception {
     Query query = new FilteredQuery(new FilteredQuery(
       new MatchAllDocsQuery(), new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("field", "three")))), randomFilterStrategy(random(), useRandomAccess)),
@@ -292,7 +292,7 @@
       new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("field", "four")))), randomFilterStrategy(random(), useRandomAccess));
     ScoreDoc[] hits = searcher.search(query, 10).scoreDocs;
     assertEquals(2, hits.length);
-    QueryUtils.check(random(), query, searcher);    
+    QueryUtils.check(random(), query, searcher);
 
     // one more:
     query = new FilteredQuery(query,
@@ -299,9 +299,9 @@
       new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term("field", "five")))), randomFilterStrategy(random(), useRandomAccess));
     hits = searcher.search(query, 10).scoreDocs;
     assertEquals(1, hits.length);
-    QueryUtils.check(random(), query, searcher);    
+    QueryUtils.check(random(), query, searcher);
   }
-  
+
   public void testEqualsHashcode() throws Exception {
     // some tests before, if the used queries and filters work:
     assertEquals(new PrefixFilter(new Term("field", "o")), new PrefixFilter(new Term("field", "o")));
@@ -313,15 +313,15 @@
     // now test FilteredQuery equals/hashcode:
     QueryUtils.checkHashEquals(new FilteredQuery(new TermQuery(new Term("field", "one")), new PrefixFilter(new Term("field", "o"))));
     QueryUtils.checkUnequal(
-      new FilteredQuery(new TermQuery(new Term("field", "one")), new PrefixFilter(new Term("field", "o"))), 
+      new FilteredQuery(new TermQuery(new Term("field", "one")), new PrefixFilter(new Term("field", "o"))),
       new FilteredQuery(new TermQuery(new Term("field", "two")), new PrefixFilter(new Term("field", "o")))
     );
     QueryUtils.checkUnequal(
-      new FilteredQuery(new TermQuery(new Term("field", "one")), new PrefixFilter(new Term("field", "a"))), 
+      new FilteredQuery(new TermQuery(new Term("field", "one")), new PrefixFilter(new Term("field", "a"))),
       new FilteredQuery(new TermQuery(new Term("field", "one")), new PrefixFilter(new Term("field", "o")))
     );
   }
-  
+
   public void testInvalidArguments() throws Exception {
     try {
       new FilteredQuery(null, null);
@@ -342,21 +342,21 @@
       // pass
     }
   }
-  
+
   private FilterStrategy randomFilterStrategy() {
     return randomFilterStrategy(random(), true);
   }
-  
+
   private void assertRewrite(FilteredQuery fq, Class<? extends Query> clazz) throws Exception {
     // assign crazy boost to FQ
     final float boost = random().nextFloat() * 100.f;
     fq.setBoost(boost);
-    
-    
+
+
     // assign crazy boost to inner
     final float innerBoost = random().nextFloat() * 100.f;
     fq.getQuery().setBoost(innerBoost);
-    
+
     // check the class and boosts of rewritten query
     final Query rewritten = searcher.rewrite(fq);
     assertTrue("is not instance of " + clazz.getName(), clazz.isInstance(rewritten));
@@ -367,7 +367,7 @@
     } else {
       assertEquals(boost * innerBoost, rewritten.getBoost(), 1.E-5f);
     }
-    
+
     // check that the original query was not modified
     assertEquals(boost, fq.getBoost(), 1.E-5f);
     assertEquals(innerBoost, fq.getQuery().getBoost(), 1.E-5f);
@@ -377,13 +377,13 @@
     assertRewrite(new FilteredQuery(new TermQuery(new Term("field", "one")), new PrefixFilter(new Term("field", "o")), randomFilterStrategy()), FilteredQuery.class);
     assertRewrite(new FilteredQuery(new PrefixQuery(new Term("field", "one")), new PrefixFilter(new Term("field", "o")), randomFilterStrategy()), FilteredQuery.class);
   }
-  
+
   public void testGetFilterStrategy() {
     FilterStrategy randomFilterStrategy = randomFilterStrategy();
     FilteredQuery filteredQuery = new FilteredQuery(new TermQuery(new Term("field", "one")), new PrefixFilter(new Term("field", "o")), randomFilterStrategy);
     assertSame(randomFilterStrategy, filteredQuery.getFilterStrategy());
   }
-  
+
   private static FilteredQuery.FilterStrategy randomFilterStrategy(Random random, final boolean useRandomAccess) {
     if (useRandomAccess) {
       return new FilteredQuery.RandomAccessFilterStrategy() {
@@ -395,7 +395,7 @@
     }
     return TestUtil.randomFilterStrategy(random);
   }
-  
+
   /*
    * Test if the QueryFirst strategy calls the bits only if the document has
    * been matched by the query and not otherwise
@@ -417,7 +417,7 @@
     }
     IndexReader reader = writer.getReader();
     writer.close();
-    
+
     IndexSearcher searcher = newSearcher(reader);
     Query query = new FilteredQuery(new TermQuery(new Term("field", "0")),
         new Filter() {
@@ -448,7 +448,7 @@
                   return null;
                 }
                 return new Bits() {
-                  
+
                   @Override
                   public boolean get(int index) {
                     assertTrue("filter was called for a non-matching doc",
@@ -455,15 +455,15 @@
                         bitSet.get(index));
                     return bitSet.get(index);
                   }
-                  
+
                   @Override
                   public int length() {
                     return bitSet.length();
                   }
-                  
+
                 };
               }
-              
+
               @Override
               public DocIdSetIterator iterator() throws IOException {
                 assertTrue(
@@ -471,16 +471,16 @@
                     nullBitset);
                 return reader.termDocsEnum(new Term("field", "0"));
               }
-              
+
             };
           }
         }, FilteredQuery.QUERY_FIRST_FILTER_STRATEGY);
-    
+
     TopDocs search = searcher.search(query, 10);
-    assertEquals(totalDocsWithZero, search.totalHits);  
+    assertEquals(totalDocsWithZero, search.totalHits);
     IOUtils.close(reader, directory);
   }
-  
+
   /*
    * Test if the leapfrog strategy works correctly in terms
    * of advancing / next the right thing first
@@ -497,7 +497,7 @@
         totalDocsWithZero++;
       }
       doc.add (newTextField("field", ""+num, Field.Store.YES));
-      writer.addDocument (doc);  
+      writer.addDocument (doc);
     }
     IndexReader reader = writer.getReader();
     writer.close();
@@ -529,42 +529,80 @@
               boolean advanceCalled;
               @Override
               public int nextDoc() throws IOException {
-                assertTrue("queryFirst: "+ queryFirst + " advanced: " + advanceCalled + " next: "+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);  
+                assertTrue("queryFirst: "+ queryFirst + " advanced: " + advanceCalled + " next: "+ nextCalled, nextCalled || advanceCalled ^ !queryFirst);
                 nextCalled = true;
                 return termDocsEnum.nextDoc();
               }
-              
+
               @Override
               public int docID() {
                 return termDocsEnum.docID();
               }
-              
+
               @Override
               public int advance(int target) throws IOException {
-                assertTrue("queryFirst: "+ queryFirst + " advanced: " + advanceCalled + " next: "+ nextCalled, advanceCalled || nextCalled ^ queryFirst);  
+                assertTrue("queryFirst: "+ queryFirst + " advanced: " + advanceCalled + " next: "+ nextCalled, advanceCalled || nextCalled ^ queryFirst);
                 advanceCalled = true;
                 return termDocsEnum.advance(target);
               }
-              
+
               @Override
               public long cost() {
                 return termDocsEnum.cost();
-              } 
+              }
             };
           }
-          
+
         };
       }
         }, queryFirst ? FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY : random()
             .nextBoolean() ? FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY
             : FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY);  // if filterFirst, we can use random here since bits are null
-    
+
     TopDocs search = searcher.search(query, 10);
     assertEquals(totalDocsWithZero, search.totalHits);
     IOUtils.close(reader, directory);
   }
-}
 
+  public void testFallBackToRandomAccessIfNoIterator() throws IOException {
+    final int iters = 10 + random().nextInt(10);
+    for (final boolean hasRandomAccess : new boolean[] {true, false}) {
+      final Filter filter = new Filter() {
+        @Override
+        public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
+          return new DocIdSet() {
 
+            @Override
+            public long ramBytesUsed() {
+              return 0;
+            }
 
+            @Override
+            public DocIdSetIterator iterator() throws IOException {
+              throw new UnsupportedOperationException();
+            }
 
+            @Override
+            public Bits bits() {
+              if (hasRandomAccess) {
+                return new Bits.MatchAllBits(5);
+              } else {
+                return null;
+              }
+            }
+            
+          };
+        }
+      };
+      for (int i = 0; i < iters; ++i) {
+        try {
+          TopDocs topDocs = searcher.search(new FilteredQuery(query, filter, randomFilterStrategy()), 1 + random().nextInt(5));
+          assertTrue(hasRandomAccess);
+          assertEquals(3, topDocs.totalHits);
+        } catch (UnsupportedOperationException e) {
+          assertFalse(hasRandomAccess);
+        }
+      }
+    }
+  }
+}
