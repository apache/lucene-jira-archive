Index: lucene/core/src/java/org/apache/lucene/util/packed/gen_BulkOperation.py
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/packed/gen_BulkOperation.py	(revision 1376547)
+++ lucene/core/src/java/org/apache/lucene/util/packed/gen_BulkOperation.py	(working copy)
@@ -291,6 +291,38 @@
     p64_encode(bpv, f, 32, values)
     p64_encode(bpv, f, 64, values)
 
+class Registers:
+
+  def __init__(self):
+    self.used = set()
+    self.map = {}
+    self.count = 0
+
+  def __alloc(self):
+    for n in xrange(self.count):
+      if n not in self.used:
+        self.used.add(n)
+        return n, False
+    n = self.count
+    self.used.add(n)
+    self.count += 1
+    return n, True
+
+  def add(self, name):
+    #print 'ADD %s' % name
+    assert name not in self.map
+    n, isNew = self.__alloc()
+    self.map[name] = n
+    return n, isNew
+
+  def get(self, name):
+    return self.map[name]
+
+  def free(self, name):
+    #print 'FREE %s' % name
+    self.used.remove(self.map[name])
+    
+
 def p64_decode(bpv, f, bits, values):
   typ = get_type(bits)
   cast_start, cast_end = casts(typ)
@@ -334,6 +366,7 @@
     return
   f.write("      assert blocksOffset + 8 * iterations * blockCount() <= blocks.length;\n")
   f.write("      assert valuesOffset + iterations * valueCount() <= values.length;\n")
+  regs = Registers()
   f.write("      for (int i = 0; i < iterations; ++i) {\n")
   blocks = values * bpv / 8
   for i in xrange(0, values):
@@ -343,33 +376,45 @@
     bit_end = ((i + 1) * bpv - 1) % 8
     shift = lambda b: 8 * (byte_end - b - 1) + 1 + bit_end
     if bit_start == 0:
-      f.write("        final %s byte%d = blocks[blocksOffset++] & 0xFF;\n" %(typ, byte_start))
+      reg, isNew = regs.add(byte_start)
+      f.write('        ')
+      if isNew:
+        f.write('%s ' % typ)
+      f.write("byte%d = blocks[blocksOffset++] & 0xFF;\n" % reg)
     for b in xrange(byte_start + 1, byte_end + 1):
-      f.write("        final %s byte%d = blocks[blocksOffset++] & 0xFF;\n" %(typ, b))
+      reg, isNew = regs.add(b)
+      f.write('        ')
+      if isNew:
+        f.write('%s ' % typ)
+      f.write("byte%d = blocks[blocksOffset++] & 0xFF;\n" % reg)
     f.write("        values[valuesOffset++] =")
     if byte_start == byte_end:
       if bit_start == 0:
         if bit_end == 7:
-          f.write(" byte%d" %byte_start)
+          f.write(" byte%d" % regs.get(byte_start))
         else:
-          f.write(" byte%d >>> %d" %(byte_start, 7 - bit_end))
+          f.write(" byte%d >>> %d" % (regs.get(byte_start), 7 - bit_end))
       else:
         if bit_end == 7:
-          f.write(" byte%d & %d" %(byte_start, 2 ** (8 - bit_start) - 1))
+          f.write(" byte%d & %d" %(regs.get(byte_start), 2 ** (8 - bit_start) - 1))
         else:
-          f.write(" (byte%d >>> %d) & %d" %(byte_start, 7 - bit_end, 2 ** (bit_end - bit_start + 1) - 1))
+          f.write(" (byte%d >>> %d) & %d" %(regs.get(byte_start), 7 - bit_end, 2 ** (bit_end - bit_start + 1) - 1))
     else:
       if bit_start == 0:
-        f.write(" (byte%d << %d)" %(byte_start, shift(byte_start)))
+        f.write(" (byte%d << %d)" %(regs.get(byte_start), shift(byte_start)))
       else:
-        f.write(" ((byte%d & %d) << %d)" %(byte_start, 2 ** (8 - bit_start) - 1, shift(byte_start)))
+        f.write(" ((byte%d & %d) << %d)" %(regs.get(byte_start), 2 ** (8 - bit_start) - 1, shift(byte_start)))
       for b in xrange(byte_start + 1, byte_end):
-        f.write(" | (byte%d << %d)" %(b, shift(b)))
+        f.write(" | (byte%d << %d)" %(regs.get(b), shift(b)))
       if bit_end == 7:
-        f.write(" | byte%d" %byte_end)
+        f.write(" | byte%d" % regs.get(byte_end))
       else:
-        f.write(" | (byte%d >>> %d)" %(byte_end, 7 - bit_end))
+        f.write(" | (byte%d >>> %d)" %(regs.get(byte_end), 7 - bit_end))
     f.write(";\n")
+    for b in xrange(byte_start, byte_end):
+      regs.free(b)
+    if bit_end == 7:
+      regs.free(byte_end)
   f.write("      }\n")
   f.write("    }\n\n")
 
