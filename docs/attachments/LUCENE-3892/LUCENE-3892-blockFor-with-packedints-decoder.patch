Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java	(revision 1363612)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java	(working copy)
@@ -20,13 +20,14 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;      
 import java.nio.IntBuffer;
+import java.nio.LongBuffer;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.PostingsWriterBase;
 import org.apache.lucene.codecs.TermStats;
-import org.apache.lucene.codecs.pfor.ForUtil;  // nocommit move here?
+import org.apache.lucene.codecs.block.ForUtil;  // nocommit move here?
 import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.index.FieldInfo;
@@ -78,14 +79,20 @@
   private long posTermStartFP;
   private long payTermStartFP;
 
-  final int[] docDeltaBuffer;
-  final int[] freqBuffer;
+  final long[] docDeltaBuffer;
+  final long[] freqBuffer;
+  final LongBuffer docDeltaLBuffer;
+  final LongBuffer freqLBuffer;
   private int docBufferUpto;
 
-  final int[] posDeltaBuffer;
-  final int[] payloadLengthBuffer;
-  final int[] offsetStartDeltaBuffer;
-  final int[] offsetLengthBuffer;
+  final long[] posDeltaBuffer;
+  final long[] payloadLengthBuffer;
+  final long[] offsetStartDeltaBuffer;
+  final long[] offsetLengthBuffer;
+  final LongBuffer posDeltaLBuffer;
+  final LongBuffer payloadLengthLBuffer;
+  final LongBuffer offsetStartDeltaLBuffer;
+  final LongBuffer offsetLengthLBuffer;
   private int posBufferUpto;
 
   private byte[] payloadBytes;
@@ -104,7 +111,7 @@
   private int docCount;
 
   final byte[] encoded;
-  final IntBuffer encodedBuffer;
+  final LongBuffer encodedBuffer;
 
   private final BlockSkipWriter skipWriter;
   
@@ -120,25 +127,32 @@
     try {
       CodecUtil.writeHeader(docOut, DOC_CODEC, VERSION_CURRENT);
       if (state.fieldInfos.hasProx()) {
-        posDeltaBuffer = new int[blockSize];
+        posDeltaBuffer = new long[blockSize];
+        posDeltaLBuffer = LongBuffer.wrap(posDeltaBuffer);
         posOut = state.directory.createOutput(IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockPostingsFormat.POS_EXTENSION),
                                               state.context);
         CodecUtil.writeHeader(posOut, POS_CODEC, VERSION_CURRENT);
 
         if (state.fieldInfos.hasPayloads()) {
           payloadBytes = new byte[128];
-          payloadLengthBuffer = new int[blockSize];
+          payloadLengthBuffer = new long[blockSize];
+          payloadLengthLBuffer = LongBuffer.wrap(payloadLengthBuffer);
         } else {
           payloadBytes = null;
           payloadLengthBuffer = null;
+          payloadLengthLBuffer = null;
         }
 
         if (state.fieldInfos.hasOffsets()) {
-          offsetStartDeltaBuffer = new int[blockSize];
-          offsetLengthBuffer = new int[blockSize];
+          offsetStartDeltaBuffer = new long[blockSize];
+          offsetLengthBuffer = new long[blockSize];
+          offsetStartDeltaLBuffer = LongBuffer.wrap(offsetStartDeltaBuffer);
+          offsetLengthLBuffer = LongBuffer.wrap(offsetLengthBuffer);
         } else {
           offsetStartDeltaBuffer = null;
           offsetLengthBuffer = null;
+          offsetStartDeltaLBuffer = null;
+          offsetLengthLBuffer = null;
         }
 
         if (state.fieldInfos.hasPayloads() || state.fieldInfos.hasOffsets()) {
@@ -151,6 +165,10 @@
         payloadLengthBuffer = null;
         offsetStartDeltaBuffer = null;
         offsetLengthBuffer = null;
+        posDeltaLBuffer = null;
+        payloadLengthLBuffer = null;
+        offsetStartDeltaLBuffer = null;
+        offsetLengthLBuffer = null;
         payloadBytes = null;
       }
       this.payOut = payOut;
@@ -162,8 +180,10 @@
       }
     }
 
-    docDeltaBuffer = new int[blockSize];
-    freqBuffer = new int[blockSize];
+    docDeltaBuffer = new long[blockSize];
+    freqBuffer = new long[blockSize];
+    docDeltaLBuffer = LongBuffer.wrap(docDeltaBuffer);
+    freqLBuffer = LongBuffer.wrap(freqBuffer);
 
     skipWriter = new BlockSkipWriter(blockSize,
                                      maxSkipLevels, 
@@ -172,8 +192,8 @@
                                      posOut,
                                      payOut);
 
-    encoded = new byte[blockSize*4 + 4];
-    encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
+    encoded = new byte[blockSize*4];
+    encodedBuffer = ByteBuffer.wrap(encoded).asLongBuffer();
   }
 
   @Override
@@ -210,10 +230,9 @@
     skipWriter.resetSkip();
   }
 
-  private void writeBlock(int[] buffer, IndexOutput out) throws IOException {
-    final int header = ForUtil.compress(buffer, encodedBuffer);
-    //System.out.println("    block has " + numBytes + " bytes");
-    out.writeVInt(header);
+  private void writeBlock(LongBuffer buffer, IndexOutput out) throws IOException {
+    int header = ForUtil.compress(buffer, encodedBuffer);
+    out.writeInt(header);
     out.writeBytes(encoded, ForUtil.getEncodedSize(header));
   }
 
@@ -278,12 +297,12 @@
       if (DEBUG) {
         System.out.println("  write docDelta block @ fp=" + docOut.getFilePointer());
       }
-      writeBlock(docDeltaBuffer, docOut);
+      writeBlock(docDeltaLBuffer, docOut);
       if (fieldHasFreqs) {
         if (DEBUG) {
           System.out.println("  write freq block @ fp=" + docOut.getFilePointer());
         }
-        writeBlock(freqBuffer, docOut);
+        writeBlock(freqLBuffer, docOut);
       }
       docBufferUpto = 0;
     }
@@ -327,17 +346,17 @@
       if (DEBUG) {
         System.out.println("  write pos bulk block @ fp=" + posOut.getFilePointer());
       }
-      writeBlock(posDeltaBuffer, posOut);
+      writeBlock(posDeltaLBuffer, posOut);
 
       if (fieldHasPayloads) {
-        writeBlock(payloadLengthBuffer, payOut);
+        writeBlock(payloadLengthLBuffer, payOut);
         payOut.writeVInt(payloadByteUpto);
         payOut.writeBytes(payloadBytes, 0, payloadByteUpto);
         payloadByteUpto = 0;
       }
       if (fieldHasOffsets) {
-        writeBlock(offsetStartDeltaBuffer, payOut);
-        writeBlock(offsetLengthBuffer, payOut);
+        writeBlock(offsetStartDeltaLBuffer, payOut);
+        writeBlock(offsetLengthLBuffer, payOut);
       }
       posBufferUpto = 0;
     }
@@ -400,8 +419,8 @@
 
     // vInt encode the remaining doc deltas and freqs:
     for(int i=0;i<docBufferUpto;i++) {
-      final int docDelta = docDeltaBuffer[i];
-      final int freq = freqBuffer[i];
+      final int docDelta = (int)docDeltaBuffer[i];
+      final int freq = (int)freqBuffer[i];
       if (!fieldHasFreqs) {
         docOut.writeVInt(docDelta);
       } else if (freqBuffer[i] == 1) {
@@ -439,9 +458,9 @@
         int lastPayloadLength = -1;
         int payloadBytesReadUpto = 0;
         for(int i=0;i<posBufferUpto;i++) {
-          final int posDelta = posDeltaBuffer[i];
+          final int posDelta = (int)posDeltaBuffer[i];
           if (fieldHasPayloads) {
-            final int payloadLength = payloadLengthBuffer[i];
+            final int payloadLength = (int)payloadLengthBuffer[i];
             if (payloadLength != lastPayloadLength) {
               lastPayloadLength = payloadLength;
               posOut.writeVInt((posDelta<<1)|1);
@@ -469,8 +488,8 @@
             if (DEBUG) {
               System.out.println("          write offset @ pos.fp=" + posOut.getFilePointer());
             }
-            posOut.writeVInt(offsetStartDeltaBuffer[i]);
-            posOut.writeVInt(offsetLengthBuffer[i]);
+            posOut.writeVInt((int)offsetStartDeltaBuffer[i]);
+            posOut.writeVInt((int)offsetLengthBuffer[i]);
           }
         }
 
Index: lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java	(working copy)
@@ -0,0 +1,133 @@
+package org.apache.lucene.codecs.block;
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.nio.LongBuffer;
+import java.nio.IntBuffer;
+import java.nio.ByteBuffer;
+import java.util.Arrays;
+
+import org.apache.lucene.util.packed.PackedInts;
+import org.apache.lucene.util.packed.PackedInts.Reader;
+import org.apache.lucene.util.packed.PackedInts.Writer;
+import org.apache.lucene.util.packed.PackedInts.Mutable;
+import org.apache.lucene.util.packed.PackedInts.Encoder;
+import org.apache.lucene.util.packed.PackedInts.Decoder;
+
+/**
+ * Encode all values in normal area with fixed bit width, 
+ * which is determined by the max value in this block.
+ */
+public class ForUtil {
+  protected static final int[] MASK = {   0x00000000,
+    0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f,
+    0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff,
+    0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff, 0x0001ffff, 0x0003ffff,
+    0x0007ffff, 0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
+    0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff, 0x1fffffff, 0x3fffffff,
+    0x7fffffff, 0xffffffff};
+
+  /** Compress given int[] into output stream, with For format
+   */
+  public static int compress(final LongBuffer data, LongBuffer packed) throws IOException {
+    int numBits=getNumBits(data.array());
+
+    if (numBits == 0) { // when block is equal, save the value once
+      packed.put(0, data.get(0)<<32); // java uses big endian for LongBuffer impl 
+      return (getHeader(1,numBits));
+    }
+
+    PackedInts.Format format = PackedInts.Format.PACKED;
+    PackedInts.Encoder encoder = PackedInts.getEncoder(format, PackedInts.VERSION_CURRENT, numBits);
+    int perIter = encoder.values();
+    int iters = 128/perIter;
+    int nblocks = encoder.blocks()*iters;
+    assert 128 % perIter == 0;
+
+    packed.rewind();
+    data.rewind();
+
+    encoder.encode(data, packed, iters);
+
+    int encodedSize = nblocks*2;
+    return getHeader(encodedSize,numBits);
+  }
+
+  /** Decompress given ouput stream into int array.
+   */
+  public static void decompress(LongBuffer data, LongBuffer packed, int header) throws IOException {
+    // nocommit assert header isn't "malformed", ie besides
+    // numBytes / bit-width there is nothing else!
+    
+    packed.rewind();
+    data.rewind();
+    int numBits = ((header >> 8) & MASK[6]);
+
+    if (numBits == 0) {
+      long[] tmp = new long[128];
+      long v = packed.get(0);
+      Arrays.fill(tmp, (int)(v>>>32));
+      data.put(tmp);
+      return;
+    }
+
+    PackedInts.Format format = PackedInts.Format.PACKED;
+    PackedInts.Decoder decoder = PackedInts.getDecoder(format, PackedInts.VERSION_CURRENT, numBits);
+    int perIter = decoder.values();
+    int iters = 128/perIter;
+    int nblocks = decoder.blocks()*iters;
+    assert 128 % perIter == 0;
+
+    decoder.decode(packed, data, iters);
+  }
+
+  static int getNumBits(final long[] data) {
+    if (isAllEqual(data)) {
+      return 0;
+    }
+    int size=data.length;
+    int optBits=1;
+    for (int i=0; i<size; ++i) {
+      while ((data[i] & ~MASK[optBits]) != 0) {
+        optBits++;
+      }
+    }
+    return optBits;
+  }
+
+  protected static boolean isAllEqual(final long[] data) {
+    int len = data.length;
+    long v = data[0];
+    for (int i=1; i<len; i++) {
+      if (data[i] != v) {
+        return false;
+      }
+    }
+    return true;
+  }
+  static int getHeader(int encodedSize, int numBits) {
+    return  (encodedSize)
+          | ((numBits) << 8);
+  }
+  public static int getEncodedSize(int header) {
+    return ((header & MASK[8]))*4;
+  }
+  public static int getNumBits(int header) {
+    return ((header >> 8) & MASK[6]);
+  }
+}
Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java	(revision 1363612)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java	(working copy)
@@ -20,11 +20,12 @@
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.IntBuffer;
+import java.nio.LongBuffer;
 
 import org.apache.lucene.codecs.BlockTermState;
 import org.apache.lucene.codecs.CodecUtil;
 import org.apache.lucene.codecs.PostingsReaderBase;
-import org.apache.lucene.codecs.pfor.ForUtil;
+import org.apache.lucene.codecs.block.ForUtil;
 import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
@@ -290,11 +291,14 @@
 
   final class BlockDocsEnum extends DocsEnum {
     private final byte[] encoded;
-    private final IntBuffer encodedBuffer;
+    private final LongBuffer encodedBuffer;
     
-    private final int[] docDeltaBuffer = new int[blockSize];
-    private final int[] freqBuffer = new int[blockSize];
+    private final long[] docDeltaBuffer = new long[blockSize];
+    private final long[] freqBuffer = new long[blockSize];
 
+    private final LongBuffer docDeltaLBuffer = LongBuffer.wrap(docDeltaBuffer);
+    private final LongBuffer freqLBuffer = LongBuffer.wrap(freqBuffer);
+
     private int docBufferUpto;
 
     private BlockSkipReader skipper;
@@ -331,8 +335,8 @@
       indexHasPos = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
       indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
       indexHasPayloads = fieldInfo.hasPayloads();
-      encoded = new byte[blockSize*4 + 4];
-      encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();      
+      encoded = new byte[blockSize*4];
+      encodedBuffer = ByteBuffer.wrap(encoded).asLongBuffer();
     }
 
     public boolean canReuse(IndexInput docIn, FieldInfo fieldInfo) {
@@ -370,10 +374,11 @@
       return doc;
     }
     
-    private void readBlock(IndexInput in, int[] buffer) throws IOException {
-      int header = in.readVInt();
-      in.readBytes(encoded, 0, ForUtil.getEncodedSize(header));
-      ForUtil.decompress(encodedBuffer, buffer, header);
+    private void readBlock(IndexInput in, LongBuffer buffer) throws IOException {
+      int header = in.readInt();
+      int numBytes = ForUtil.getEncodedSize(header);
+      in.readBytes(encoded,0, numBytes);
+      ForUtil.decompress(buffer, encodedBuffer, header);
     }
 
     private void refillDocs() throws IOException {
@@ -384,13 +389,13 @@
         if (DEBUG) {
           System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
         }
-        readBlock(docIn, docDeltaBuffer);
+        readBlock(docIn, docDeltaLBuffer);
 
         if (indexHasFreq) {
           if (DEBUG) {
             System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
           }
-          readBlock(docIn, freqBuffer);
+          readBlock(docIn, freqLBuffer);
         }
       } else {
         // Read vInts:
@@ -445,7 +450,7 @@
 
         if (liveDocs == null || liveDocs.get(accum)) {
           doc = accum;
-          freq = freqBuffer[docBufferUpto];
+          freq = (int)freqBuffer[docBufferUpto];
           docBufferUpto++;
           if (DEBUG) {
             System.out.println("  return doc=" + doc + " freq=" + freq);
@@ -534,12 +539,16 @@
   final class BlockDocsAndPositionsEnum extends DocsAndPositionsEnum {
     
     private final byte[] encoded;
-    private final IntBuffer encodedBuffer;
+    private final LongBuffer encodedBuffer;
 
-    private final int[] docDeltaBuffer = new int[blockSize];
-    private final int[] freqBuffer = new int[blockSize];
-    private final int[] posDeltaBuffer = new int[blockSize];
+    private final long[] docDeltaBuffer = new long[blockSize];
+    private final long[] freqBuffer = new long[blockSize];
+    private final long[] posDeltaBuffer = new long[blockSize];
 
+    private final LongBuffer docDeltaLBuffer = LongBuffer.wrap(docDeltaBuffer);
+    private final LongBuffer freqLBuffer = LongBuffer.wrap(freqBuffer);
+    private final LongBuffer posDeltaLBuffer = LongBuffer.wrap(posDeltaBuffer);
+
     private int docBufferUpto;
     private int posBufferUpto;
 
@@ -595,8 +604,8 @@
       this.startDocIn = BlockPostingsReader.this.docIn;
       this.docIn = (IndexInput) startDocIn.clone();
       this.posIn = (IndexInput) BlockPostingsReader.this.posIn.clone();
-      encoded = new byte[blockSize*4 + 4];
-      encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
+      encoded = new byte[blockSize*4];
+      encodedBuffer = ByteBuffer.wrap(encoded).asLongBuffer();
       indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
       indexHasPayloads = fieldInfo.hasPayloads();
     }
@@ -646,15 +655,17 @@
       return doc;
     }
 
-    private void readBlock(IndexInput in, int[] buffer) throws IOException {
-      int header = in.readVInt();
-      in.readBytes(encoded, 0, ForUtil.getEncodedSize(header));
-      ForUtil.decompress(encodedBuffer, buffer, header);
+    private void readBlock(IndexInput in, LongBuffer buffer) throws IOException {
+      int header = in.readInt();
+      int numBytes = ForUtil.getEncodedSize(header);
+      in.readBytes(encoded,0, numBytes);
+      ForUtil.decompress(buffer, encodedBuffer, header);
     }
 
     private void skipBlock(IndexInput in) throws IOException {
-      int header = in.readVInt();
+      int header = in.readInt();
       in.seek(in.getFilePointer() + ForUtil.getEncodedSize(header));
+      //in.seek(in.getFilePointer() + 128*4);
     }
 
     private void refillDocs() throws IOException {
@@ -666,13 +677,13 @@
           System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
         }
 
-        readBlock(docIn, docDeltaBuffer);
+        readBlock(docIn, docDeltaLBuffer);
 
         if (DEBUG) {
           System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
         }
 
-        readBlock(docIn, freqBuffer);
+        readBlock(docIn, freqLBuffer);
       } else {
         // Read vInts:
         if (DEBUG) {
@@ -724,7 +735,7 @@
         if (DEBUG) {
           System.out.println("        bulk pos block @ fp=" + posIn.getFilePointer());
         }
-        readBlock(posIn, posDeltaBuffer);
+        readBlock(posIn, posDeltaLBuffer);
       }
     }
 
@@ -751,8 +762,8 @@
         if (DEBUG) {
           System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
         }
-        accum += docDeltaBuffer[docBufferUpto];
-        freq = freqBuffer[docBufferUpto];
+        accum += (int)docDeltaBuffer[docBufferUpto];
+        freq = (int)freqBuffer[docBufferUpto];
         posPendingCount += freq;
         docBufferUpto++;
         docUpto++;
@@ -946,16 +957,24 @@
   final class EverythingEnum extends DocsAndPositionsEnum {
     
     private final byte[] encoded;
-    private final IntBuffer encodedBuffer;
+    private final LongBuffer encodedBuffer;
 
-    private final int[] docDeltaBuffer = new int[blockSize];
-    private final int[] freqBuffer = new int[blockSize];
-    private final int[] posDeltaBuffer = new int[blockSize];
+    private final long[] docDeltaBuffer = new long[blockSize];
+    private final long[] freqBuffer = new long[blockSize];
+    private final long[] posDeltaBuffer = new long[blockSize];
 
-    private final int[] payloadLengthBuffer;
-    private final int[] offsetStartDeltaBuffer;
-    private final int[] offsetLengthBuffer;
+    private final LongBuffer docDeltaLBuffer = LongBuffer.wrap(docDeltaBuffer);
+    private final LongBuffer freqLBuffer = LongBuffer.wrap(freqBuffer);
+    private final LongBuffer posDeltaLBuffer = LongBuffer.wrap(posDeltaBuffer);
 
+    private final long[] payloadLengthBuffer;
+    private final long[] offsetStartDeltaBuffer;
+    private final long[] offsetLengthBuffer;
+
+    private final LongBuffer payloadLengthLBuffer;
+    private final LongBuffer offsetStartDeltaLBuffer;
+    private final LongBuffer offsetLengthLBuffer;
+
     private byte[] payloadBytes;
     private int payloadByteUpto;
     private int payloadLength;
@@ -1026,26 +1045,33 @@
       this.docIn = (IndexInput) startDocIn.clone();
       this.posIn = (IndexInput) BlockPostingsReader.this.posIn.clone();
       this.payIn = (IndexInput) BlockPostingsReader.this.payIn.clone();
-      encoded = new byte[blockSize*4 + 4];
-      encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
+      encoded = new byte[blockSize*4];
+      encodedBuffer = ByteBuffer.wrap(encoded).asLongBuffer();
       indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
       if (indexHasOffsets) {
-        offsetStartDeltaBuffer = new int[blockSize];
-        offsetLengthBuffer = new int[blockSize];
+        offsetStartDeltaBuffer = new long[blockSize];
+        offsetLengthBuffer = new long[blockSize];
+        offsetStartDeltaLBuffer = LongBuffer.wrap(offsetStartDeltaBuffer); 
+        offsetLengthLBuffer = LongBuffer.wrap(offsetLengthBuffer); 
       } else {
         offsetStartDeltaBuffer = null;
+        offsetStartDeltaLBuffer = null;
         offsetLengthBuffer = null;
+        offsetLengthLBuffer = null;
         startOffset = -1;
         endOffset = -1;
       }
 
       indexHasPayloads = fieldInfo.hasPayloads();
       if (indexHasPayloads) {
-        payloadLengthBuffer = new int[blockSize];
+        payloadLengthBuffer = new long[blockSize];
+        payloadLengthLBuffer = LongBuffer.wrap(payloadLengthBuffer); 
+
         payloadBytes = new byte[128];
         payload = new BytesRef();
       } else {
         payloadLengthBuffer = null;
+        payloadLengthLBuffer = null;
         payloadBytes = null;
         payload = null;
       }
@@ -1097,15 +1123,17 @@
       return doc;
     }
 
-    private void readBlock(IndexInput in, int[] buffer) throws IOException {
-      int header = in.readVInt();
-      in.readBytes(encoded, 0, ForUtil.getEncodedSize(header));
-      ForUtil.decompress(encodedBuffer, buffer, header);
+    private void readBlock(IndexInput in, LongBuffer buffer) throws IOException {
+      int header = in.readInt();
+      int numBytes = ForUtil.getEncodedSize(header);
+      in.readBytes(encoded,0, numBytes);
+      ForUtil.decompress(buffer, encodedBuffer, header);
     }
 
     private void skipBlock(IndexInput in) throws IOException {
-      int header = in.readVInt();
+      int header = in.readInt();
       in.seek(in.getFilePointer() + ForUtil.getEncodedSize(header));
+      //in.seek(in.getFilePointer() + 128*4);
     }
 
     private void refillDocs() throws IOException {
@@ -1117,13 +1145,13 @@
           System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
         }
 
-        readBlock(docIn, docDeltaBuffer);
+        readBlock(docIn, docDeltaLBuffer);
 
         if (DEBUG) {
           System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
         }
 
-        readBlock(docIn, freqBuffer);
+        readBlock(docIn, freqLBuffer);
       } else {
         // Read vInts:
         if (DEBUG) {
@@ -1192,13 +1220,13 @@
         if (DEBUG) {
           System.out.println("        bulk pos block @ fp=" + posIn.getFilePointer());
         }
-        readBlock(posIn, posDeltaBuffer);
+        readBlock(posIn, posDeltaLBuffer);
 
         if (indexHasPayloads) {
           if (DEBUG) {
             System.out.println("        bulk payload block @ pay.fp=" + payIn.getFilePointer());
           }
-          readBlock(payIn, payloadLengthBuffer);
+          readBlock(payIn, payloadLengthLBuffer);
           int numBytes = payIn.readVInt();
           if (DEBUG) {
             System.out.println("        " + numBytes + " payload bytes @ pay.fp=" + payIn.getFilePointer());
@@ -1214,8 +1242,8 @@
           if (DEBUG) {
             System.out.println("        bulk offset block @ pay.fp=" + payIn.getFilePointer());
           }
-          readBlock(payIn, offsetStartDeltaBuffer);
-          readBlock(payIn, offsetLengthBuffer);
+          readBlock(payIn, offsetStartDeltaLBuffer);
+          readBlock(payIn, offsetLengthLBuffer);
         }
       }
     }
@@ -1248,8 +1276,8 @@
         if (DEBUG) {
           System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
         }
-        accum += docDeltaBuffer[docBufferUpto];
-        freq = freqBuffer[docBufferUpto];
+        accum += (int)docDeltaBuffer[docBufferUpto];
+        freq = (int)freqBuffer[docBufferUpto];
         posPendingCount += freq;
         docBufferUpto++;
         docUpto++;
@@ -1400,8 +1428,8 @@
           if (indexHasOffsets) {
             // Must load offset blocks merely to sum
             // up into lastEndOffset:
-            readBlock(payIn, offsetStartDeltaBuffer);
-            readBlock(payIn, offsetLengthBuffer);
+            readBlock(payIn, offsetStartDeltaLBuffer);
+            readBlock(payIn, offsetLengthLBuffer);
             for(int i=0;i<blockSize;i++) {
               lastEndOffset += offsetStartDeltaBuffer[i] + offsetLengthBuffer[i];
             }
@@ -1476,12 +1504,12 @@
       position += posDeltaBuffer[posBufferUpto];
 
       if (indexHasPayloads) {
-        payloadLength = payloadLengthBuffer[posBufferUpto];
+        payloadLength = (int)payloadLengthBuffer[posBufferUpto];
       }
 
       if (indexHasOffsets) {
-        startOffset = lastEndOffset + offsetStartDeltaBuffer[posBufferUpto];
-        endOffset = startOffset + offsetLengthBuffer[posBufferUpto];
+        startOffset = lastEndOffset + (int)offsetStartDeltaBuffer[posBufferUpto];
+        endOffset = startOffset + (int)offsetLengthBuffer[posBufferUpto];
         lastEndOffset = endOffset;
       }
 
Index: build.xml
===================================================================
--- build.xml	(revision 1363263)
+++ build.xml	(working copy)
@@ -74,13 +74,19 @@
 
   <target name="compile" description="Compile Lucene and Solr">
     <sequential>
-
       <subant target="compile" inheritall="false" failonerror="true">
         <fileset dir="lucene" includes="build.xml" />
         <fileset dir="solr" includes="build.xml" />
       </subant>
     </sequential>
   </target>
+  <target name="compile-core" description="Compile">
+    <sequential>
+      <subant target="compile-core" inheritall="false" failonerror="true">
+        <fileset dir="lucene" includes="build.xml" />
+      </subant>
+    </sequential>
+  </target>
 
   <property name="version" value="5.0-SNAPSHOT"/>
   <property name="maven-build-dir" value="maven-build"/>
