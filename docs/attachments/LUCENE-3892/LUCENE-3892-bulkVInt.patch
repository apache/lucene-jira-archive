Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java	(revision 1370404)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java	(working copy)
@@ -138,14 +138,42 @@
   }
 
   static void readBlock(IndexInput in, byte[] encoded, IntBuffer encodedBuffer, int[] buffer) throws IOException {
+    // nocommit
+    /*
     int header = in.readVInt();
     in.readBytes(encoded, 0, ForUtil.getEncodedSize(header));
     ForUtil.decompress(encodedBuffer, buffer, header);
+    */
+    final int numBytes = in.readVInt(); // read header
+    if (numBytes == 0) { // 1's
+      Arrays.fill(buffer, 1);
+      return;
+    }
+    in.readBytes(encoded, 0, numBytes); // readBytes
+              
+    int upto = 0;
+              
+    // decode bytes
+    for(int i=0;i<buffer.length;i++) {
+      byte b = encoded[upto++];
+      int j = b & 0x7F;
+      for (int shift = 7; (b & 0x80) != 0; shift += 7) {
+        b = encoded[upto++];
+        j |= (b & 0x7F) << shift;
+      }
+      buffer[i] = j;
+    }
   }
 
   static void skipBlock(IndexInput in) throws IOException {
+    // nocommit
+    /*
     int header = in.readVInt();
     in.seek(in.getFilePointer() + ForUtil.getEncodedSize(header));
+    */
+
+    final int numBytes = in.readVInt(); // read header
+    in.seek(in.getFilePointer() + numBytes);
   }
 
   // Must keep final because we do non-standard clone
@@ -364,7 +392,7 @@
       indexHasPos = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
       indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
       indexHasPayloads = fieldInfo.hasPayloads();
-      encoded = new byte[BLOCK_SIZE*4];
+      encoded = new byte[BLOCK_SIZE*5];
       encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();      
     }
 
@@ -628,7 +656,7 @@
       this.startDocIn = BlockPostingsReader.this.docIn;
       this.docIn = (IndexInput) startDocIn.clone();
       this.posIn = (IndexInput) BlockPostingsReader.this.posIn.clone();
-      encoded = new byte[BLOCK_SIZE*4];
+      encoded = new byte[BLOCK_SIZE*5];
       encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
       indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
       indexHasPayloads = fieldInfo.hasPayloads();
@@ -1054,7 +1082,7 @@
       this.docIn = (IndexInput) startDocIn.clone();
       this.posIn = (IndexInput) BlockPostingsReader.this.posIn.clone();
       this.payIn = (IndexInput) BlockPostingsReader.this.payIn.clone();
-      encoded = new byte[BLOCK_SIZE*4];
+      encoded = new byte[BLOCK_SIZE*5];
       encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
       indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
       if (indexHasOffsets) {
Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java	(revision 1370404)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java	(working copy)
@@ -176,7 +176,8 @@
                                      posOut,
                                      payOut);
 
-    encoded = new byte[BLOCK_SIZE*4];
+    // nocommit
+    encoded = new byte[BLOCK_SIZE*5];
     encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
   }
 
@@ -214,10 +215,43 @@
     skipWriter.resetSkip();
   }
 
+  // nocommit make int[] block encoder pluggable
   private void writeBlock(int[] buffer, IndexOutput out) throws IOException {
+    // nocommit
+    /*
     final int header = ForUtil.compress(buffer, encodedBuffer);
     out.writeVInt(header);
     out.writeBytes(encoded, ForUtil.getEncodedSize(header));
+    */
+
+    int upto = 0;
+
+    // nocommit generalize to all-same-value?
+    boolean allOnes = true;
+    // encode ints
+    for(int i=0;i<buffer.length;i++) {
+      int j = buffer[i];
+      if (j != 1) {
+        allOnes = false;
+      }
+      while ((j & ~0x7F) != 0) {
+        encoded[upto++] = (byte)((j & 0x7f) | 0x80);
+        j >>>= 7;
+      }
+      encoded[upto++] = (byte)j;
+    }
+          
+    if (allOnes) {
+      // the most common int pattern (all 1's)
+      // write a special header (numBytes=0) for this case.
+      out.writeVInt(0);
+    } else {
+      // write header (length in bytes)
+      out.writeVInt(upto);
+          
+      // write block
+      out.writeBytes(encoded, 0, upto);
+    }
   }
 
   @Override
