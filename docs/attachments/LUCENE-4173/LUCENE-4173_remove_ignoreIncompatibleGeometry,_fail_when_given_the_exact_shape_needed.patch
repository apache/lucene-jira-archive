Index: lucene/spatial/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java	(revision 1383496)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java	(revision )
@@ -18,6 +18,7 @@
  */
 
 import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.shape.Shape;
 import org.apache.lucene.spatial.SpatialMatchConcern;
 import org.apache.lucene.spatial.StrategyTestCase;
 import org.junit.Before;
@@ -33,6 +34,12 @@
     super.setUp();
     this.ctx = SpatialContext.GEO;
     this.strategy = new BBoxStrategy(ctx, "bbox");
+  }
+
+  /* Convert DATA_WORLD_CITIES_POINTS to bbox */
+  @Override
+  protected Shape getDocuments_convertShape(Shape shape) {
+    return shape.getBoundingBox();
   }
 
   @Test
Index: lucene/spatial/src/java/org/apache/lucene/spatial/SpatialStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/SpatialStrategy.java	(revision 1383496)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/SpatialStrategy.java	(revision )
@@ -19,9 +19,7 @@
 
 import com.spatial4j.core.context.SpatialContext;
 import com.spatial4j.core.shape.Shape;
-
 import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.search.Filter;
@@ -57,7 +55,6 @@
  */
 public abstract class SpatialStrategy {
 
-  protected boolean ignoreIncompatibleGeometry = false;
   protected final SpatialContext ctx;
   private final String fieldName;
 
@@ -121,14 +118,6 @@
    * Make a Filter
    */
   public abstract Filter makeFilter(SpatialArgs args);
-
-  public boolean isIgnoreIncompatibleGeometry() {
-    return ignoreIncompatibleGeometry;
-  }
-
-  public void setIgnoreIncompatibleGeometry(boolean ignoreIncompatibleGeometry) {
-    this.ignoreIncompatibleGeometry = ignoreIncompatibleGeometry;
-  }
 
   @Override
   public String toString() {
Index: lucene/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesStrategy.java	(revision 1383496)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesStrategy.java	(revision )
@@ -26,7 +26,6 @@
 import org.apache.lucene.document.DoubleField;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.search.BooleanClause;
@@ -79,19 +78,19 @@
 
   @Override
   public Field[] createIndexableFields(Shape shape) {
-    if( shape instanceof Point ) {
-      Point point = (Point)shape;
+    if (shape instanceof Point)
+      return createIndexableFields((Point) shape);
+    throw new IllegalArgumentException("Can only index Point, not " + shape);
+  }
+
+  /** @see #createIndexableFields(com.spatial4j.core.shape.Shape) */
+  public Field[] createIndexableFields(Point point) {
-      FieldType doubleFieldType = new FieldType(DoubleField.TYPE_NOT_STORED);
-      doubleFieldType.setNumericPrecisionStep(precisionStep);
-      Field[] f = new Field[2];
-      f[0] = new DoubleField(fieldNameX, point.getX(), doubleFieldType);
-      f[1] = new DoubleField(fieldNameY, point.getY(), doubleFieldType);
-      return f;
+    FieldType doubleFieldType = new FieldType(DoubleField.TYPE_NOT_STORED);
+    doubleFieldType.setNumericPrecisionStep(precisionStep);
+    Field[] f = new Field[2];
+    f[0] = new DoubleField(fieldNameX, point.getX(), doubleFieldType);
+    f[1] = new DoubleField(fieldNameY, point.getY(), doubleFieldType);
+    return f;
-    }
-    if( !ignoreIncompatibleGeometry ) {
-      throw new IllegalArgumentException( "TwoDoublesStrategy can not index: "+shape );
-    }
-    return new Field[0]; // nothing (solr does not support null)
   }
 
   @Override
Index: lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase.java	(revision 1383496)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase.java	(revision )
@@ -27,7 +27,6 @@
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.StoredField;
 import org.apache.lucene.document.StringField;
-import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.spatial.query.SpatialArgsParser;
 import org.junit.Assert;
 
@@ -86,15 +85,23 @@
       document.add(new StringField("id", data.id, Field.Store.YES));
       document.add(new StringField("name", data.name, Field.Store.YES));
       Shape shape = new ShapeReadWriter(ctx).readShape(data.shape);
+      shape = getDocuments_convertShape(shape);
+      if (shape != null) {
-      for (Field f : strategy.createIndexableFields(shape)) {
-        document.add(f);
-      }
-      if (storeShape)
-        document.add(new StoredField(strategy.getFieldName(), ctx.toString(shape)));
+        for (Field f : strategy.createIndexableFields(shape)) {
+          document.add(f);
+        }
+        if (storeShape)
+          document.add(new StoredField(strategy.getFieldName(), ctx.toString(shape)));
+      }
 
       documents.add(document);
     }
     return documents;
+  }
+
+  /** Subclasses may override to transform or remove a shape for indexing */
+  protected Shape getDocuments_convertShape(Shape shape) {
+    return shape;
   }
 
   protected Iterator<SampleData> getSampleData(String testDataFile) throws IOException {
Index: lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxStrategy.java	(revision 1383496)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxStrategy.java	(revision )
@@ -24,7 +24,6 @@
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.StringField;
-import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
@@ -93,7 +92,12 @@
 
   @Override
   public Field[] createIndexableFields(Shape shape) {
-    Rectangle bbox = shape.getBoundingBox();
+    if (shape instanceof Rectangle)
+      return createIndexableFields((Rectangle)shape);
+    throw new IllegalArgumentException("Can only index Rectangle, not " + shape);
+  }
+
+  public Field[] createIndexableFields(Rectangle bbox) {
     FieldType doubleFieldType = new FieldType(DoubleField.TYPE_NOT_STORED);
     doubleFieldType.setNumericPrecisionStep(precisionStep);
     Field[] fields = new Field[5];
@@ -111,8 +115,18 @@
 
   @Override
   public ValueSource makeValueSource(SpatialArgs args) {
+    Shape shape = args.getShape();
+    /* DWS: TODO
+    double queryPowerFactor = 1;
+    if (!(shape instanceof Rectangle)) {
+      double queryBBoxArea = shape.getBoundingBox().getArea(ctx);
+      double queryArea = shape.getArea(ctx);
+      if (queryBBoxArea != 0)
+        queryPowerFactor = queryArea / queryBBoxArea;
+    }
+    */
     return new BBoxSimilarityValueSource(
-        this, new AreaSimilarity(args.getShape().getBoundingBox(), queryPower, targetPower));
+        this, new AreaSimilarity(shape.getBoundingBox(), queryPower, targetPower));
   }
 
 
@@ -136,7 +150,11 @@
 
 
   private Query makeSpatialQuery(SpatialArgs args) {
-    Rectangle bbox = args.getShape().getBoundingBox();
+    Shape shape = args.getShape();
+    if (!(shape instanceof Rectangle))
+      throw new IllegalArgumentException("Can only query by Rectangle, not " + shape);
+
+    Rectangle bbox = (Rectangle) shape;
     Query spatial = null;
 
     // Useful for understanding Relations:
