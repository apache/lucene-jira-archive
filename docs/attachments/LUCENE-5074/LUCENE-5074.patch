Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/NumericRangeQueryBuilder.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/NumericRangeQueryBuilder.java	(revision 1495839)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/NumericRangeQueryBuilder.java	(working copy)
@@ -90,8 +90,8 @@
   @Override
   public Query getQuery(Element e) throws ParserException {
     String field = DOMUtils.getAttributeWithInheritanceOrFail(e, "fieldName");
-    String lowerTerm = DOMUtils.getAttributeOrFail(e, "lowerTerm");
-    String upperTerm = DOMUtils.getAttributeOrFail(e, "upperTerm");
+    String lowerTerm = DOMUtils.getAttribute(e, "lowerTerm", null);
+    String upperTerm = DOMUtils.getAttribute(e, "upperTerm", null);
     boolean lowerInclusive = DOMUtils.getAttribute(e, "includeLower", true);
     boolean upperInclusive = DOMUtils.getAttribute(e, "includeUpper", true);
     int precisionStep = DOMUtils.getAttribute(e, "precisionStep", NumericUtils.PRECISION_STEP_DEFAULT);
@@ -100,26 +100,27 @@
     try {
       Query filter;
       if (type.equalsIgnoreCase("int")) {
-        filter = NumericRangeQuery.newIntRange(field, precisionStep, Integer
-            .valueOf(lowerTerm), Integer.valueOf(upperTerm), lowerInclusive,
+        filter = NumericRangeQuery.newIntRange(field, precisionStep, lowerTerm == null ? null : Integer
+            .valueOf(lowerTerm), upperTerm == null ? null : Integer.valueOf(upperTerm), lowerInclusive,
             upperInclusive);
       } else if (type.equalsIgnoreCase("long")) {
-        filter = NumericRangeQuery.newLongRange(field, precisionStep, Long
-            .valueOf(lowerTerm), Long.valueOf(upperTerm), lowerInclusive,
+        filter = NumericRangeQuery.newLongRange(field, precisionStep, lowerTerm == null ? null : Long
+            .valueOf(lowerTerm), upperTerm == null ? null : Long.valueOf(upperTerm), lowerInclusive,
             upperInclusive);
       } else if (type.equalsIgnoreCase("double")) {
-        filter = NumericRangeQuery.newDoubleRange(field, precisionStep, Double
-            .valueOf(lowerTerm), Double.valueOf(upperTerm), lowerInclusive,
+        filter = NumericRangeQuery.newDoubleRange(field, precisionStep, lowerTerm == null ? null : Double
+            .valueOf(lowerTerm), upperTerm == null ? null : Double.valueOf(upperTerm), lowerInclusive,
             upperInclusive);
       } else if (type.equalsIgnoreCase("float")) {
-        filter = NumericRangeQuery.newFloatRange(field, precisionStep, Float
-            .valueOf(lowerTerm), Float.valueOf(upperTerm), lowerInclusive,
+        filter = NumericRangeQuery.newFloatRange(field, precisionStep, lowerTerm == null ? null : Float
+            .valueOf(lowerTerm), upperTerm == null ? null : Float.valueOf(upperTerm), lowerInclusive,
             upperInclusive);
       } else {
         throw new ParserException("type attribute must be one of: [long, int, double, float]");
       }
       return filter;
-    } catch (NumberFormatException nfe) {
+    }
+    catch (NumberFormatException nfe) {
       throw new ParserException("Could not parse lowerTerm or upperTerm into a number", nfe);
     }
   }
Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/NumericRangeFilterBuilder.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/NumericRangeFilterBuilder.java	(revision 1495839)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/NumericRangeFilterBuilder.java	(working copy)
@@ -115,8 +115,8 @@
   @Override
   public Filter getFilter(Element e) throws ParserException {
     String field = DOMUtils.getAttributeWithInheritanceOrFail(e, "fieldName");
-    String lowerTerm = DOMUtils.getAttributeOrFail(e, "lowerTerm");
-    String upperTerm = DOMUtils.getAttributeOrFail(e, "upperTerm");
+    String lowerTerm = DOMUtils.getAttribute(e, "lowerTerm", null);
+    String upperTerm = DOMUtils.getAttribute(e, "upperTerm", null);
     boolean lowerInclusive = DOMUtils.getAttribute(e, "includeLower", true);
     boolean upperInclusive = DOMUtils.getAttribute(e, "includeUpper", true);
     int precisionStep = DOMUtils.getAttribute(e, "precisionStep", NumericUtils.PRECISION_STEP_DEFAULT);
@@ -125,20 +125,20 @@
     try {
       Filter filter;
       if (type.equalsIgnoreCase("int")) {
-        filter = NumericRangeFilter.newIntRange(field, precisionStep, Integer
-            .valueOf(lowerTerm), Integer.valueOf(upperTerm), lowerInclusive,
+        filter = NumericRangeFilter.newIntRange(field, precisionStep, lowerTerm == null ? null : Integer
+            .valueOf(lowerTerm), upperTerm == null ? null : Integer.valueOf(upperTerm), lowerInclusive,
             upperInclusive);
       } else if (type.equalsIgnoreCase("long")) {
-        filter = NumericRangeFilter.newLongRange(field, precisionStep, Long
-            .valueOf(lowerTerm), Long.valueOf(upperTerm), lowerInclusive,
+        filter = NumericRangeFilter.newLongRange(field, precisionStep, lowerTerm == null ? null : Long
+            .valueOf(lowerTerm), upperTerm == null ? null : Long.valueOf(upperTerm), lowerInclusive,
             upperInclusive);
       } else if (type.equalsIgnoreCase("double")) {
-        filter = NumericRangeFilter.newDoubleRange(field, precisionStep, Double
-            .valueOf(lowerTerm), Double.valueOf(upperTerm), lowerInclusive,
+        filter = NumericRangeFilter.newDoubleRange(field, precisionStep, lowerTerm == null ? null : Double
+            .valueOf(lowerTerm), upperTerm == null ? null : Double.valueOf(upperTerm), lowerInclusive,
             upperInclusive);
       } else if (type.equalsIgnoreCase("float")) {
-        filter = NumericRangeFilter.newFloatRange(field, precisionStep, Float
-            .valueOf(lowerTerm), Float.valueOf(upperTerm), lowerInclusive,
+        filter = NumericRangeFilter.newFloatRange(field, precisionStep, lowerTerm == null ? null : Float
+            .valueOf(lowerTerm), upperTerm == null ? null : Float.valueOf(upperTerm), lowerInclusive,
             upperInclusive);
       } else {
         throw new ParserException("type attribute must be one of: [long, int, double, float]");
