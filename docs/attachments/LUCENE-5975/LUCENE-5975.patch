Index: lucene/core/src/java/org/apache/lucene/codecs/lucene40/BitVector.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/lucene40/BitVector.java	(revision 1627169)
+++ lucene/core/src/java/org/apache/lucene/codecs/lucene40/BitVector.java	(working copy)
@@ -359,9 +359,9 @@
 
       if (version >= VERSION_CHECKSUM) {
         CodecUtil.checkFooter(input);
-      } else {
+      } else if (version >= VERSION_DGAPS_CLEARED) {
         CodecUtil.checkEOF(input);
-      }
+      } // otherwise, before this we cannot even check that we read the entire file due to bugs in those versions!!!!
       assert verifyCount();
     } finally {
       input.close();
Index: lucene/core/src/test/org/apache/lucene/codecs/lucene40/AncientBitVector.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/codecs/lucene40/AncientBitVector.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/codecs/lucene40/AncientBitVector.java	(working copy)
@@ -0,0 +1,29 @@
+package org.apache.lucene.codecs.lucene40;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.store.Directory;
+
+/** base class for old bitvector versions */
+abstract class AncientBitVector {
+  abstract void write(Directory d, String name) throws IOException;
+  abstract void set(int bit);
+  abstract boolean get(int bit);
+}

Property changes on: lucene/core/src/test/org/apache/lucene/codecs/lucene40/AncientBitVector.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_0_0.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_0_0.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_0_0.java	(working copy)
@@ -0,0 +1,266 @@
+package org.apache.lucene.codecs.lucene40;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+
+/** Optimized implementation of a vector of bits.  This is more-or-less like
+  java.util.BitSet, but also includes the following:
+  <ul>
+  <li>a count() method, which efficiently computes the number of one bits;</li>
+  <li>optimized read from and write to disk;</li>
+  <li>inlinable get() method;</li>
+  <li>store and load, as bit set or d-gaps, depending on sparseness;</li> 
+  </ul>
+  */
+final class BitVector_3_0_0 extends AncientBitVector implements Cloneable {
+
+  private byte[] bits;
+  private int size;
+  private int count = -1;
+
+  /** Constructs a vector capable of holding <code>n</code> bits. */
+  public BitVector_3_0_0(int n) {
+    size = n;
+    bits = new byte[(size >> 3) + 1];
+  }
+  
+  BitVector_3_0_0(byte[] bits, int size) {
+    this.bits = bits;
+    this.size = size;
+  }
+  
+  @Override
+  public Object clone() {
+    byte[] copyBits = new byte[bits.length];
+    System.arraycopy(bits, 0, copyBits, 0, bits.length);
+    return new BitVector_3_0_0(copyBits, size);
+  }
+  
+  /** Sets the value of <code>bit</code> to one. */
+  public final void set(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    bits[bit >> 3] |= 1 << (bit & 7);
+    count = -1;
+  }
+
+  /** Sets the value of <code>bit</code> to true, and
+   *  returns true if bit was already set */
+  public final boolean getAndSet(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    final int pos = bit >> 3;
+    final int v = bits[pos];
+    final int flag = 1 << (bit & 7);
+    if ((flag & v) != 0)
+      return true;
+    else {
+      bits[pos] = (byte) (v | flag);
+      if (count != -1)
+        count++;
+      return false;
+    }
+  }
+
+  /** Sets the value of <code>bit</code> to zero. */
+  public final void clear(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    bits[bit >> 3] &= ~(1 << (bit & 7));
+    count = -1;
+  }
+
+  /** Returns <code>true</code> if <code>bit</code> is one and
+    <code>false</code> if it is zero. */
+  public final boolean get(int bit) {
+    assert bit >= 0 && bit < size: "bit " + bit + " is out of bounds 0.." + (size-1);
+    return (bits[bit >> 3] & (1 << (bit & 7))) != 0;
+  }
+
+  /** Returns the number of bits in this vector.  This is also one greater than
+    the number of the largest valid bit number. */
+  public final int size() {
+    return size;
+  }
+
+  /** Returns the total number of one bits in this vector.  This is efficiently
+    computed and cached, so that, if the vector is not changed, no
+    recomputation is done for repeated calls. */
+  public final int count() {
+    // if the vector has been modified
+    if (count == -1) {
+      int c = 0;
+      int end = bits.length;
+      for (int i = 0; i < end; i++)
+        c += BYTE_COUNTS[bits[i] & 0xFF];	  // sum bits per byte
+      count = c;
+    }
+    return count;
+  }
+
+  private static final byte[] BYTE_COUNTS = {	  // table of bits/byte
+    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
+  };
+
+
+  /** Writes this vector to the file <code>name</code> in Directory
+    <code>d</code>, in a format that can be read by the constructor {@link
+    #BitVector_3_0_0(Directory, String)}.  */
+  public final void write(Directory d, String name) throws IOException {
+    IndexOutput output = d.createOutput(name, IOContext.DEFAULT);
+    try {
+      if (isSparse()) { 
+        writeDgaps(output); // sparse bit-set more efficiently saved as d-gaps.
+      } else {
+        writeBits(output);
+      }
+    } finally {
+      output.close();
+    }
+  }
+     
+  /** Write as a bit set */
+  private void writeBits(IndexOutput output) throws IOException {
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    output.writeBytes(bits, bits.length);
+  }
+  
+  /** Write as a d-gaps list */
+  private void writeDgaps(IndexOutput output) throws IOException {
+    output.writeInt(-1);            // mark using d-gaps                         
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    int last=0;
+    int n = count();
+    int m = bits.length;
+    for (int i=0; i<m && n>0; i++) {
+      if (bits[i]!=0) {
+        output.writeVInt(i-last);
+        output.writeByte(bits[i]);
+        last = i;
+        n -= BYTE_COUNTS[bits[i] & 0xFF];
+      }
+    }
+  }
+
+  /** Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. */
+  private boolean isSparse() {
+    // note: order of comparisons below set to favor smaller values (no binary range search.)
+    // note: adding 4 because we start with ((int) -1) to indicate d-gaps format.
+    // note: we write the d-gap for the byte number, and the byte (bits[i]) itself, therefore
+    //       multiplying count by (8+8) or (8+16) or (8+24) etc.:
+    //       - first 8 for writing bits[i] (1 byte vs. 1 bit), and 
+    //       - second part for writing the byte-number d-gap as vint. 
+    // note: factor is for read/write of byte-arrays being faster than vints.  
+    int factor = 10;  
+    if (bits.length < (1<< 7)) return factor * (4 + (8+ 8)*count()) < size();
+    if (bits.length < (1<<14)) return factor * (4 + (8+16)*count()) < size();
+    if (bits.length < (1<<21)) return factor * (4 + (8+24)*count()) < size();
+    if (bits.length < (1<<28)) return factor * (4 + (8+32)*count()) < size();
+    return                            factor * (4 + (8+40)*count()) < size();
+  }
+
+  /** Constructs a bit vector from the file <code>name</code> in Directory
+    <code>d</code>, as written by the {@link #write} method.
+    */
+  public BitVector_3_0_0(Directory d, String name) throws IOException {
+    IndexInput input = d.openInput(name, IOContext.DEFAULT);
+    try {
+      size = input.readInt();       // read size
+      if (size == -1) {
+        readDgaps(input);
+      } else {
+        readBits(input);
+      }
+    } finally {
+      input.close();
+    }
+  }
+
+  /** Read as a bit set */
+  private void readBits(IndexInput input) throws IOException {
+    count = input.readInt();        // read count
+    bits = new byte[(size >> 3) + 1];     // allocate bits
+    input.readBytes(bits, 0, bits.length);
+  }
+
+  /** read as a d-gaps list */ 
+  private void readDgaps(IndexInput input) throws IOException {
+    size = input.readInt();       // (re)read size
+    count = input.readInt();        // read count
+    bits = new byte[(size >> 3) + 1];     // allocate bits
+    int last=0;
+    int n = count();
+    while (n>0) {
+      last += input.readVInt();
+      bits[last] = input.readByte();
+      n -= BYTE_COUNTS[bits[last] & 0xFF];
+    }          
+  }
+
+  /**
+   * Retrieve a subset of this BitVector.
+   * 
+   * @param start
+   *            starting index, inclusive
+   * @param end
+   *            ending index, exclusive
+   * @return subset
+   */
+  public BitVector_3_0_0 subset(int start, int end) {
+    if (start < 0 || end > size() || end < start)
+      throw new IndexOutOfBoundsException();
+    // Special case -- return empty vector is start == end
+    if (end == start) return new BitVector_3_0_0(0);
+    byte[] bits = new byte[((end - start - 1) >>> 3) + 1];
+    int s = start >>> 3;
+    for (int i = 0; i < bits.length; i++) {
+      int cur = 0xFF & this.bits[i + s];
+      int next = i + s + 1 >= this.bits.length ? 0 : 0xFF & this.bits[i + s + 1];
+      bits[i] = (byte) ((cur >>> (start & 7)) | ((next << (8 - (start & 7)))));
+    }
+    int bitsToClear = (bits.length * 8 - (end - start)) % 8;
+    bits[bits.length - 1] &= ~(0xFF << (8 - bitsToClear));
+    return new BitVector_3_0_0(bits, end - start);
+  }
+}

Property changes on: lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_0_0.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_0_2.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_0_2.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_0_2.java	(working copy)
@@ -0,0 +1,279 @@
+package org.apache.lucene.codecs.lucene40;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+
+/** Optimized implementation of a vector of bits.  This is more-or-less like
+  java.util.BitSet, but also includes the following:
+  <ul>
+  <li>a count() method, which efficiently computes the number of one bits;</li>
+  <li>optimized read from and write to disk;</li>
+  <li>inlinable get() method;</li>
+  <li>store and load, as bit set or d-gaps, depending on sparseness;</li> 
+  </ul>
+  */
+final class BitVector_3_0_2 extends AncientBitVector implements Cloneable {
+
+  private byte[] bits;
+  private int size;
+  private int count;
+
+  /** Constructs a vector capable of holding <code>n</code> bits. */
+  public BitVector_3_0_2(int n) {
+    size = n;
+    bits = new byte[(size >> 3) + 1];
+    count = 0;
+  }
+  
+  BitVector_3_0_2(byte[] bits, int size) {
+    this.bits = bits;
+    this.size = size;
+    count = -1;
+  }
+  
+  @Override
+  public Object clone() {
+    byte[] copyBits = new byte[bits.length];
+    System.arraycopy(bits, 0, copyBits, 0, bits.length);
+    BitVector_3_0_2 clone = new BitVector_3_0_2(copyBits, size);
+    clone.count = count;
+    return clone;
+  }
+  
+  /** Sets the value of <code>bit</code> to one. */
+  public final void set(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    bits[bit >> 3] |= 1 << (bit & 7);
+    count = -1;
+  }
+
+  /** Sets the value of <code>bit</code> to true, and
+   *  returns true if bit was already set */
+  public final boolean getAndSet(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    final int pos = bit >> 3;
+    final int v = bits[pos];
+    final int flag = 1 << (bit & 7);
+    if ((flag & v) != 0)
+      return true;
+    else {
+      bits[pos] = (byte) (v | flag);
+      if (count != -1)
+        count++;
+      return false;
+    }
+  }
+
+  /** Sets the value of <code>bit</code> to zero. */
+  public final void clear(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    bits[bit >> 3] &= ~(1 << (bit & 7));
+    count = -1;
+  }
+
+  /** Returns <code>true</code> if <code>bit</code> is one and
+    <code>false</code> if it is zero. */
+  public final boolean get(int bit) {
+    assert bit >= 0 && bit < size: "bit " + bit + " is out of bounds 0.." + (size-1);
+    return (bits[bit >> 3] & (1 << (bit & 7))) != 0;
+  }
+
+  /** Returns the number of bits in this vector.  This is also one greater than
+    the number of the largest valid bit number. */
+  public final int size() {
+    return size;
+  }
+
+  /** Returns the total number of one bits in this vector.  This is efficiently
+    computed and cached, so that, if the vector is not changed, no
+    recomputation is done for repeated calls. */
+  public final int count() {
+    // if the vector has been modified
+    if (count == -1) {
+      int c = 0;
+      int end = bits.length;
+      for (int i = 0; i < end; i++)
+        c += BYTE_COUNTS[bits[i] & 0xFF];	  // sum bits per byte
+      count = c;
+    }
+    return count;
+  }
+
+  /** For testing */
+  public final int getRecomputedCount() {
+    int c = 0;
+    int end = bits.length;
+    for (int i = 0; i < end; i++)
+      c += BYTE_COUNTS[bits[i] & 0xFF];	  // sum bits per byte
+    return c;
+  }
+
+  private static final byte[] BYTE_COUNTS = {	  // table of bits/byte
+    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
+  };
+
+
+  /** Writes this vector to the file <code>name</code> in Directory
+    <code>d</code>, in a format that can be read by the constructor {@link
+    #BitVector_3_0_2(Directory, String)}.  */
+  public final void write(Directory d, String name) throws IOException {
+    IndexOutput output = d.createOutput(name, IOContext.DEFAULT);
+    try {
+      if (isSparse()) { 
+        writeDgaps(output); // sparse bit-set more efficiently saved as d-gaps.
+      } else {
+        writeBits(output);
+      }
+    } finally {
+      output.close();
+    }
+  }
+     
+  /** Write as a bit set */
+  private void writeBits(IndexOutput output) throws IOException {
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    output.writeBytes(bits, bits.length);
+  }
+  
+  /** Write as a d-gaps list */
+  private void writeDgaps(IndexOutput output) throws IOException {
+    output.writeInt(-1);            // mark using d-gaps                         
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    int last=0;
+    int n = count();
+    int m = bits.length;
+    for (int i=0; i<m && n>0; i++) {
+      if (bits[i]!=0) {
+        output.writeVInt(i-last);
+        output.writeByte(bits[i]);
+        last = i;
+        n -= BYTE_COUNTS[bits[i] & 0xFF];
+      }
+    }
+  }
+
+  /** Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. */
+  private boolean isSparse() {
+    // note: order of comparisons below set to favor smaller values (no binary range search.)
+    // note: adding 4 because we start with ((int) -1) to indicate d-gaps format.
+    // note: we write the d-gap for the byte number, and the byte (bits[i]) itself, therefore
+    //       multiplying count by (8+8) or (8+16) or (8+24) etc.:
+    //       - first 8 for writing bits[i] (1 byte vs. 1 bit), and 
+    //       - second part for writing the byte-number d-gap as vint. 
+    // note: factor is for read/write of byte-arrays being faster than vints.  
+    int factor = 10;  
+    if (bits.length < (1<< 7)) return factor * (4 + (8+ 8)*count()) < size();
+    if (bits.length < (1<<14)) return factor * (4 + (8+16)*count()) < size();
+    if (bits.length < (1<<21)) return factor * (4 + (8+24)*count()) < size();
+    if (bits.length < (1<<28)) return factor * (4 + (8+32)*count()) < size();
+    return                            factor * (4 + (8+40)*count()) < size();
+  }
+
+  /** Constructs a bit vector from the file <code>name</code> in Directory
+    <code>d</code>, as written by the {@link #write} method.
+    */
+  public BitVector_3_0_2(Directory d, String name) throws IOException {
+    IndexInput input = d.openInput(name, IOContext.DEFAULT);
+    try {
+      size = input.readInt();       // read size
+      if (size == -1) {
+        readDgaps(input);
+      } else {
+        readBits(input);
+      }
+    } finally {
+      input.close();
+    }
+  }
+
+  /** Read as a bit set */
+  private void readBits(IndexInput input) throws IOException {
+    count = input.readInt();        // read count
+    bits = new byte[(size >> 3) + 1];     // allocate bits
+    input.readBytes(bits, 0, bits.length);
+  }
+
+  /** read as a d-gaps list */ 
+  private void readDgaps(IndexInput input) throws IOException {
+    size = input.readInt();       // (re)read size
+    count = input.readInt();        // read count
+    bits = new byte[(size >> 3) + 1];     // allocate bits
+    int last=0;
+    int n = count();
+    while (n>0) {
+      last += input.readVInt();
+      bits[last] = input.readByte();
+      n -= BYTE_COUNTS[bits[last] & 0xFF];
+    }          
+  }
+
+  /**
+   * Retrieve a subset of this BitVector.
+   * 
+   * @param start
+   *            starting index, inclusive
+   * @param end
+   *            ending index, exclusive
+   * @return subset
+   */
+  public BitVector_3_0_2 subset(int start, int end) {
+    if (start < 0 || end > size() || end < start)
+      throw new IndexOutOfBoundsException();
+    // Special case -- return empty vector is start == end
+    if (end == start) return new BitVector_3_0_2(0);
+    byte[] bits = new byte[((end - start - 1) >>> 3) + 1];
+    int s = start >>> 3;
+    for (int i = 0; i < bits.length; i++) {
+      int cur = 0xFF & this.bits[i + s];
+      int next = i + s + 1 >= this.bits.length ? 0 : 0xFF & this.bits[i + s + 1];
+      bits[i] = (byte) ((cur >>> (start & 7)) | ((next << (8 - (start & 7)))));
+    }
+    int bitsToClear = (bits.length * 8 - (end - start)) % 8;
+    bits[bits.length - 1] &= ~(0xFF << (8 - bitsToClear));
+    return new BitVector_3_0_2(bits, end - start);
+  }
+}

Property changes on: lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_0_2.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_1_0.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_1_0.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_1_0.java	(working copy)
@@ -0,0 +1,279 @@
+package org.apache.lucene.codecs.lucene40;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+
+/** Optimized implementation of a vector of bits.  This is more-or-less like
+  java.util.BitSet, but also includes the following:
+  <ul>
+  <li>a count() method, which efficiently computes the number of one bits;</li>
+  <li>optimized read from and write to disk;</li>
+  <li>inlinable get() method;</li>
+  <li>store and load, as bit set or d-gaps, depending on sparseness;</li> 
+  </ul>
+  */
+final class BitVector_3_1_0 extends AncientBitVector implements Cloneable {
+
+  private byte[] bits;
+  private int size;
+  private int count;
+
+  /** Constructs a vector capable of holding <code>n</code> bits. */
+  public BitVector_3_1_0(int n) {
+    size = n;
+    bits = new byte[(size >> 3) + 1];
+    count = 0;
+  }
+  
+  BitVector_3_1_0(byte[] bits, int size) {
+    this.bits = bits;
+    this.size = size;
+    count = -1;
+  }
+  
+  @Override
+  public Object clone() {
+    byte[] copyBits = new byte[bits.length];
+    System.arraycopy(bits, 0, copyBits, 0, bits.length);
+    BitVector_3_1_0 clone = new BitVector_3_1_0(copyBits, size);
+    clone.count = count;
+    return clone;
+  }
+  
+  /** Sets the value of <code>bit</code> to one. */
+  public final void set(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
+    }
+    bits[bit >> 3] |= 1 << (bit & 7);
+    count = -1;
+  }
+
+  /** Sets the value of <code>bit</code> to true, and
+   *  returns true if bit was already set */
+  public final boolean getAndSet(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
+    }
+    final int pos = bit >> 3;
+    final int v = bits[pos];
+    final int flag = 1 << (bit & 7);
+    if ((flag & v) != 0)
+      return true;
+    else {
+      bits[pos] = (byte) (v | flag);
+      if (count != -1)
+        count++;
+      return false;
+    }
+  }
+
+  /** Sets the value of <code>bit</code> to zero. */
+  public final void clear(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    bits[bit >> 3] &= ~(1 << (bit & 7));
+    count = -1;
+  }
+
+  /** Returns <code>true</code> if <code>bit</code> is one and
+    <code>false</code> if it is zero. */
+  public final boolean get(int bit) {
+    assert bit >= 0 && bit < size: "bit " + bit + " is out of bounds 0.." + (size-1);
+    return (bits[bit >> 3] & (1 << (bit & 7))) != 0;
+  }
+
+  /** Returns the number of bits in this vector.  This is also one greater than
+    the number of the largest valid bit number. */
+  public final int size() {
+    return size;
+  }
+
+  /** Returns the total number of one bits in this vector.  This is efficiently
+    computed and cached, so that, if the vector is not changed, no
+    recomputation is done for repeated calls. */
+  public final int count() {
+    // if the vector has been modified
+    if (count == -1) {
+      int c = 0;
+      int end = bits.length;
+      for (int i = 0; i < end; i++)
+        c += BYTE_COUNTS[bits[i] & 0xFF];	  // sum bits per byte
+      count = c;
+    }
+    return count;
+  }
+
+  /** For testing */
+  public final int getRecomputedCount() {
+    int c = 0;
+    int end = bits.length;
+    for (int i = 0; i < end; i++)
+      c += BYTE_COUNTS[bits[i] & 0xFF];	  // sum bits per byte
+    return c;
+  }
+
+  private static final byte[] BYTE_COUNTS = {	  // table of bits/byte
+    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
+  };
+
+
+  /** Writes this vector to the file <code>name</code> in Directory
+    <code>d</code>, in a format that can be read by the constructor {@link
+    #BitVector_3_1_0(Directory, String)}.  */
+  public final void write(Directory d, String name) throws IOException {
+    IndexOutput output = d.createOutput(name, IOContext.DEFAULT);
+    try {
+      if (isSparse()) { 
+        writeDgaps(output); // sparse bit-set more efficiently saved as d-gaps.
+      } else {
+        writeBits(output);
+      }
+    } finally {
+      output.close();
+    }
+  }
+     
+  /** Write as a bit set */
+  private void writeBits(IndexOutput output) throws IOException {
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    output.writeBytes(bits, bits.length);
+  }
+  
+  /** Write as a d-gaps list */
+  private void writeDgaps(IndexOutput output) throws IOException {
+    output.writeInt(-1);            // mark using d-gaps                         
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    int last=0;
+    int n = count();
+    int m = bits.length;
+    for (int i=0; i<m && n>0; i++) {
+      if (bits[i]!=0) {
+        output.writeVInt(i-last);
+        output.writeByte(bits[i]);
+        last = i;
+        n -= BYTE_COUNTS[bits[i] & 0xFF];
+      }
+    }
+  }
+
+  /** Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. */
+  private boolean isSparse() {
+    // note: order of comparisons below set to favor smaller values (no binary range search.)
+    // note: adding 4 because we start with ((int) -1) to indicate d-gaps format.
+    // note: we write the d-gap for the byte number, and the byte (bits[i]) itself, therefore
+    //       multiplying count by (8+8) or (8+16) or (8+24) etc.:
+    //       - first 8 for writing bits[i] (1 byte vs. 1 bit), and 
+    //       - second part for writing the byte-number d-gap as vint. 
+    // note: factor is for read/write of byte-arrays being faster than vints.  
+    int factor = 10;  
+    if (bits.length < (1<< 7)) return factor * (4 + (8+ 8)*count()) < size();
+    if (bits.length < (1<<14)) return factor * (4 + (8+16)*count()) < size();
+    if (bits.length < (1<<21)) return factor * (4 + (8+24)*count()) < size();
+    if (bits.length < (1<<28)) return factor * (4 + (8+32)*count()) < size();
+    return                            factor * (4 + (8+40)*count()) < size();
+  }
+
+  /** Constructs a bit vector from the file <code>name</code> in Directory
+    <code>d</code>, as written by the {@link #write} method.
+    */
+  public BitVector_3_1_0(Directory d, String name) throws IOException {
+    IndexInput input = d.openInput(name, IOContext.DEFAULT);
+    try {
+      size = input.readInt();       // read size
+      if (size == -1) {
+        readDgaps(input);
+      } else {
+        readBits(input);
+      }
+    } finally {
+      input.close();
+    }
+  }
+
+  /** Read as a bit set */
+  private void readBits(IndexInput input) throws IOException {
+    count = input.readInt();        // read count
+    bits = new byte[(size >> 3) + 1];     // allocate bits
+    input.readBytes(bits, 0, bits.length);
+  }
+
+  /** read as a d-gaps list */ 
+  private void readDgaps(IndexInput input) throws IOException {
+    size = input.readInt();       // (re)read size
+    count = input.readInt();        // read count
+    bits = new byte[(size >> 3) + 1];     // allocate bits
+    int last=0;
+    int n = count();
+    while (n>0) {
+      last += input.readVInt();
+      bits[last] = input.readByte();
+      n -= BYTE_COUNTS[bits[last] & 0xFF];
+    }          
+  }
+
+  /**
+   * Retrieve a subset of this BitVector.
+   * 
+   * @param start
+   *            starting index, inclusive
+   * @param end
+   *            ending index, exclusive
+   * @return subset
+   */
+  public BitVector_3_1_0 subset(int start, int end) {
+    if (start < 0 || end > size() || end < start)
+      throw new IndexOutOfBoundsException();
+    // Special case -- return empty vector is start == end
+    if (end == start) return new BitVector_3_1_0(0);
+    byte[] bits = new byte[((end - start - 1) >>> 3) + 1];
+    int s = start >>> 3;
+    for (int i = 0; i < bits.length; i++) {
+      int cur = 0xFF & this.bits[i + s];
+      int next = i + s + 1 >= this.bits.length ? 0 : 0xFF & this.bits[i + s + 1];
+      bits[i] = (byte) ((cur >>> (start & 7)) | ((next << (8 - (start & 7)))));
+    }
+    int bitsToClear = (bits.length * 8 - (end - start)) % 8;
+    bits[bits.length - 1] &= ~(0xFF << (8 - bitsToClear));
+    return new BitVector_3_1_0(bits, end - start);
+  }
+}

Property changes on: lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_1_0.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_4_0.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_4_0.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_4_0.java	(working copy)
@@ -0,0 +1,305 @@
+package org.apache.lucene.codecs.lucene40;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+
+/** Optimized implementation of a vector of bits.  This is more-or-less like
+ *  java.util.BitSet, but also includes the following:
+ *  <ul>
+ *  <li>a count() method, which efficiently computes the number of one bits;</li>
+ *  <li>optimized read from and write to disk;</li>
+ *  <li>inlinable get() method;</li>
+ *  <li>store and load, as bit set or d-gaps, depending on sparseness;</li> 
+ *  </ul>
+ *
+ *  @lucene.internal
+ */
+final class BitVector_3_4_0 extends AncientBitVector implements Cloneable {
+
+  private byte[] bits;
+  private int size;
+  private int count;
+
+  /** Constructs a vector capable of holding <code>n</code> bits. */
+  public BitVector_3_4_0(int n) {
+    size = n;
+    bits = new byte[getNumBytes(size)];
+    count = 0;
+  }
+
+  BitVector_3_4_0(byte[] bits, int size) {
+    this.bits = bits;
+    this.size = size;
+    count = -1;
+  }
+  
+  private int getNumBytes(int size) {
+    int bytesLength = size >>> 3;
+    if ((size & 7) != 0) {
+      bytesLength++;
+    }
+    return bytesLength;
+  }
+  
+  @Override
+  public Object clone() {
+    byte[] copyBits = new byte[bits.length];
+    System.arraycopy(bits, 0, copyBits, 0, bits.length);
+    BitVector_3_4_0 clone = new BitVector_3_4_0(copyBits, size);
+    clone.count = count;
+    return clone;
+  }
+  
+  /** Sets the value of <code>bit</code> to one. */
+  public final void set(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
+    }
+    bits[bit >> 3] |= 1 << (bit & 7);
+    count = -1;
+  }
+
+  /** Sets the value of <code>bit</code> to true, and
+   *  returns true if bit was already set */
+  public final boolean getAndSet(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
+    }
+    final int pos = bit >> 3;
+    final int v = bits[pos];
+    final int flag = 1 << (bit & 7);
+    if ((flag & v) != 0)
+      return true;
+    else {
+      bits[pos] = (byte) (v | flag);
+      if (count != -1)
+        count++;
+      return false;
+    }
+  }
+
+  /** Sets the value of <code>bit</code> to zero. */
+  public final void clear(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    bits[bit >> 3] &= ~(1 << (bit & 7));
+    count = -1;
+  }
+
+  /** Returns <code>true</code> if <code>bit</code> is one and
+    <code>false</code> if it is zero. */
+  public final boolean get(int bit) {
+    assert bit >= 0 && bit < size: "bit " + bit + " is out of bounds 0.." + (size-1);
+    return (bits[bit >> 3] & (1 << (bit & 7))) != 0;
+  }
+
+  /** Returns the number of bits in this vector.  This is also one greater than
+    the number of the largest valid bit number. */
+  public final int size() {
+    return size;
+  }
+
+  /** Returns the total number of one bits in this vector.  This is efficiently
+    computed and cached, so that, if the vector is not changed, no
+    recomputation is done for repeated calls. */
+  public final int count() {
+    // if the vector has been modified
+    if (count == -1) {
+      int c = 0;
+      int end = bits.length;
+      for (int i = 0; i < end; i++)
+        c += BYTE_COUNTS[bits[i] & 0xFF];	  // sum bits per byte
+      count = c;
+    }
+    return count;
+  }
+
+  /** For testing */
+  public final int getRecomputedCount() {
+    int c = 0;
+    int end = bits.length;
+    for (int i = 0; i < end; i++)
+      c += BYTE_COUNTS[bits[i] & 0xFF];	  // sum bits per byte
+    return c;
+  }
+
+  private static final byte[] BYTE_COUNTS = {	  // table of bits/byte
+    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
+  };
+
+  private static String CODEC = "BitVector";
+
+  // Version before version tracking was added:
+  private final static int VERSION_PRE = -1;
+
+  // First version:
+  private final static int VERSION_START = 0;
+
+  // Increment version to change it:
+  private final static int VERSION_CURRENT = VERSION_START;
+
+  /** Writes this vector to the file <code>name</code> in Directory
+    <code>d</code>, in a format that can be read by the constructor {@link
+    #BitVector_3_4_0(Directory, String)}.  */
+  public final void write(Directory d, String name) throws IOException {
+    IndexOutput output = d.createOutput(name, IOContext.DEFAULT);
+    try {
+      output.writeInt(-2);
+      CodecUtil.writeHeader(output, CODEC, VERSION_CURRENT);
+      if (isSparse()) { 
+        writeDgaps(output); // sparse bit-set more efficiently saved as d-gaps.
+      } else {
+        writeBits(output);
+      }
+    } finally {
+      output.close();
+    }
+  }
+     
+  /** Write as a bit set */
+  private void writeBits(IndexOutput output) throws IOException {
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    output.writeBytes(bits, bits.length);
+  }
+  
+  /** Write as a d-gaps list */
+  private void writeDgaps(IndexOutput output) throws IOException {
+    output.writeInt(-1);            // mark using d-gaps                         
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    int last=0;
+    int n = count();
+    int m = bits.length;
+    for (int i=0; i<m && n>0; i++) {
+      if (bits[i]!=0) {
+        output.writeVInt(i-last);
+        output.writeByte(bits[i]);
+        last = i;
+        n -= BYTE_COUNTS[bits[i] & 0xFF];
+      }
+    }
+  }
+
+  /** Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. */
+  private boolean isSparse() {
+
+    final int setCount = count();
+    if (setCount == 0) {
+      return true;
+    }
+
+    final int avgGapLength = bits.length / setCount;
+
+    // expected number of bytes for vInt encoding of each gap
+    final int expectedDGapBytes;
+    if (avgGapLength <= (1<< 7)) {
+      expectedDGapBytes = 1;
+    } else if (avgGapLength <= (1<<14)) {
+      expectedDGapBytes = 2;
+    } else if (avgGapLength <= (1<<21)) {
+      expectedDGapBytes = 3;
+    } else if (avgGapLength <= (1<<28)) {
+      expectedDGapBytes = 4;
+    } else {
+      expectedDGapBytes = 5;
+    }
+
+    // +1 because we write the byte itself that contains the
+    // set bit
+    final int bytesPerSetBit = expectedDGapBytes + 1;
+    
+    // note: adding 32 because we start with ((int) -1) to indicate d-gaps format.
+    final long expectedBits = 32 + 8 * bytesPerSetBit * count();
+
+    // note: factor is for read/write of byte-arrays being faster than vints.  
+    final long factor = 10;  
+    return factor * expectedBits < size();
+  }
+
+  /** Constructs a bit vector from the file <code>name</code> in Directory
+    <code>d</code>, as written by the {@link #write} method.
+    */
+  public BitVector_3_4_0(Directory d, String name) throws IOException {
+    IndexInput input = d.openInput(name, IOContext.DEFAULT);
+
+    try {
+      final int firstInt = input.readInt();
+      final int version;
+      if (firstInt == -2) {
+        // New format, with full header & version:
+        version = CodecUtil.checkHeader(input, CODEC, VERSION_START, VERSION_START);
+        size = input.readInt();
+      } else {
+        version = VERSION_PRE;
+        size = firstInt;
+      }
+      if (size == -1) {
+        readDgaps(input);
+      } else {
+        readBits(input);
+      }
+    } finally {
+      input.close();
+    }
+  }
+
+  /** Read as a bit set */
+  private void readBits(IndexInput input) throws IOException {
+    count = input.readInt();        // read count
+    bits = new byte[getNumBytes(size)];     // allocate bits
+    input.readBytes(bits, 0, bits.length);
+  }
+
+  /** read as a d-gaps list */ 
+  private void readDgaps(IndexInput input) throws IOException {
+    size = input.readInt();       // (re)read size
+    count = input.readInt();        // read count
+    bits = new byte[(size >> 3) + 1];     // allocate bits
+    int last=0;
+    int n = count();
+    while (n>0) {
+      last += input.readVInt();
+      bits[last] = input.readByte();
+      n -= BYTE_COUNTS[bits[last] & 0xFF];
+    }          
+  }
+}

Property changes on: lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_4_0.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_5_0.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_5_0.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_5_0.java	(working copy)
@@ -0,0 +1,312 @@
+package org.apache.lucene.codecs.lucene40;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.codecs.CodecUtil;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.IndexInput;
+import org.apache.lucene.store.IndexOutput;
+import org.apache.lucene.util.Bits;
+
+/** Optimized implementation of a vector of bits.  This is more-or-less like
+ *  java.util.BitSet, but also includes the following:
+ *  <ul>
+ *  <li>a count() method, which efficiently computes the number of one bits;</li>
+ *  <li>optimized read from and write to disk;</li>
+ *  <li>inlinable get() method;</li>
+ *  <li>store and load, as bit set or d-gaps, depending on sparseness;</li> 
+ *  </ul>
+ *
+ *  @lucene.internal
+ */
+final class BitVector_3_5_0 extends AncientBitVector implements Cloneable, Bits {
+
+  private byte[] bits;
+  private int size;
+  private int count;
+
+  /** Constructs a vector capable of holding <code>n</code> bits. */
+  public BitVector_3_5_0(int n) {
+    size = n;
+    bits = new byte[getNumBytes(size)];
+    count = 0;
+  }
+
+  BitVector_3_5_0(byte[] bits, int size) {
+    this.bits = bits;
+    this.size = size;
+    count = -1;
+  }
+  
+  private int getNumBytes(int size) {
+    int bytesLength = size >>> 3;
+    if ((size & 7) != 0) {
+      bytesLength++;
+    }
+    return bytesLength;
+  }
+  
+  @Override
+  public Object clone() {
+    byte[] copyBits = new byte[bits.length];
+    System.arraycopy(bits, 0, copyBits, 0, bits.length);
+    BitVector_3_5_0 clone = new BitVector_3_5_0(copyBits, size);
+    clone.count = count;
+    return clone;
+  }
+  
+  /** Sets the value of <code>bit</code> to one. */
+  public final void set(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
+    }
+    bits[bit >> 3] |= 1 << (bit & 7);
+    count = -1;
+  }
+
+  /** Sets the value of <code>bit</code> to true, and
+   *  returns true if bit was already set */
+  public final boolean getAndSet(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException("bit=" + bit + " size=" + size);
+    }
+    final int pos = bit >> 3;
+    final int v = bits[pos];
+    final int flag = 1 << (bit & 7);
+    if ((flag & v) != 0)
+      return true;
+    else {
+      bits[pos] = (byte) (v | flag);
+      if (count != -1)
+        count++;
+      return false;
+    }
+  }
+
+  /** Sets the value of <code>bit</code> to zero. */
+  public final void clear(int bit) {
+    if (bit >= size) {
+      throw new ArrayIndexOutOfBoundsException(bit);
+    }
+    bits[bit >> 3] &= ~(1 << (bit & 7));
+    count = -1;
+  }
+
+  /** Returns <code>true</code> if <code>bit</code> is one and
+    <code>false</code> if it is zero. */
+  public final boolean get(int bit) {
+    assert bit >= 0 && bit < size: "bit " + bit + " is out of bounds 0.." + (size-1);
+    return (bits[bit >> 3] & (1 << (bit & 7))) != 0;
+  }
+
+  /** Returns the number of bits in this vector.  This is also one greater than
+    the number of the largest valid bit number. */
+  public final int size() {
+    return size;
+  }
+
+  /** Returns the number of bits in this vector.  This is also one greater than
+    the number of the largest valid bit number. */
+  public final int length() {
+    return size;
+  }
+
+  /** Returns the total number of one bits in this vector.  This is efficiently
+    computed and cached, so that, if the vector is not changed, no
+    recomputation is done for repeated calls. */
+  public final int count() {
+    // if the vector has been modified
+    if (count == -1) {
+      int c = 0;
+      int end = bits.length;
+      for (int i = 0; i < end; i++)
+        c += BYTE_COUNTS[bits[i] & 0xFF];	  // sum bits per byte
+      count = c;
+    }
+    return count;
+  }
+
+  /** For testing */
+  public final int getRecomputedCount() {
+    int c = 0;
+    int end = bits.length;
+    for (int i = 0; i < end; i++)
+      c += BYTE_COUNTS[bits[i] & 0xFF];	  // sum bits per byte
+    return c;
+  }
+
+  private static final byte[] BYTE_COUNTS = {	  // table of bits/byte
+    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
+    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
+  };
+
+  private static String CODEC = "BitVector";
+
+  // Version before version tracking was added:
+  private final static int VERSION_PRE = -1;
+
+  // First version:
+  private final static int VERSION_START = 0;
+
+  // Increment version to change it:
+  private final static int VERSION_CURRENT = VERSION_START;
+
+  /** Writes this vector to the file <code>name</code> in Directory
+    <code>d</code>, in a format that can be read by the constructor {@link
+    #BitVector_3_5_0(Directory, String)}.  */
+  public final void write(Directory d, String name) throws IOException {
+    IndexOutput output = d.createOutput(name, IOContext.DEFAULT);
+    try {
+      output.writeInt(-2);
+      CodecUtil.writeHeader(output, CODEC, VERSION_CURRENT);
+      if (isSparse()) { 
+        writeDgaps(output); // sparse bit-set more efficiently saved as d-gaps.
+      } else {
+        writeBits(output);
+      }
+    } finally {
+      output.close();
+    }
+  }
+     
+  /** Write as a bit set */
+  private void writeBits(IndexOutput output) throws IOException {
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    output.writeBytes(bits, bits.length);
+  }
+  
+  /** Write as a d-gaps list */
+  private void writeDgaps(IndexOutput output) throws IOException {
+    output.writeInt(-1);            // mark using d-gaps                         
+    output.writeInt(size());        // write size
+    output.writeInt(count());       // write count
+    int last=0;
+    int n = count();
+    int m = bits.length;
+    for (int i=0; i<m && n>0; i++) {
+      if (bits[i]!=0) {
+        output.writeVInt(i-last);
+        output.writeByte(bits[i]);
+        last = i;
+        n -= BYTE_COUNTS[bits[i] & 0xFF];
+      }
+    }
+  }
+
+  /** Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. */
+  private boolean isSparse() {
+
+    final int setCount = count();
+    if (setCount == 0) {
+      return true;
+    }
+
+    final int avgGapLength = bits.length / setCount;
+
+    // expected number of bytes for vInt encoding of each gap
+    final int expectedDGapBytes;
+    if (avgGapLength <= (1<< 7)) {
+      expectedDGapBytes = 1;
+    } else if (avgGapLength <= (1<<14)) {
+      expectedDGapBytes = 2;
+    } else if (avgGapLength <= (1<<21)) {
+      expectedDGapBytes = 3;
+    } else if (avgGapLength <= (1<<28)) {
+      expectedDGapBytes = 4;
+    } else {
+      expectedDGapBytes = 5;
+    }
+
+    // +1 because we write the byte itself that contains the
+    // set bit
+    final int bytesPerSetBit = expectedDGapBytes + 1;
+    
+    // note: adding 32 because we start with ((int) -1) to indicate d-gaps format.
+    final long expectedBits = 32 + 8 * bytesPerSetBit * count();
+
+    // note: factor is for read/write of byte-arrays being faster than vints.  
+    final long factor = 10;  
+    return factor * expectedBits < size();
+  }
+
+  /** Constructs a bit vector from the file <code>name</code> in Directory
+    <code>d</code>, as written by the {@link #write} method.
+    */
+  public BitVector_3_5_0(Directory d, String name) throws IOException {
+    IndexInput input = d.openInput(name, IOContext.DEFAULT);
+
+    try {
+      final int firstInt = input.readInt();
+      final int version;
+      if (firstInt == -2) {
+        // New format, with full header & version:
+        version = CodecUtil.checkHeader(input, CODEC, VERSION_START, VERSION_START);
+        size = input.readInt();
+      } else {
+        version = VERSION_PRE;
+        size = firstInt;
+      }
+      if (size == -1) {
+        readDgaps(input);
+      } else {
+        readBits(input);
+      }
+    } finally {
+      input.close();
+    }
+  }
+
+  /** Read as a bit set */
+  private void readBits(IndexInput input) throws IOException {
+    count = input.readInt();        // read count
+    bits = new byte[getNumBytes(size)];     // allocate bits
+    input.readBytes(bits, 0, bits.length);
+  }
+
+  /** read as a d-gaps list */ 
+  private void readDgaps(IndexInput input) throws IOException {
+    size = input.readInt();       // (re)read size
+    count = input.readInt();        // read count
+    bits = new byte[(size >> 3) + 1];     // allocate bits
+    int last=0;
+    int n = count();
+    while (n>0) {
+      last += input.readVInt();
+      bits[last] = input.readByte();
+      n -= BYTE_COUNTS[bits[last] & 0xFF];
+    }          
+  }
+}

Property changes on: lucene/core/src/test/org/apache/lucene/codecs/lucene40/BitVector_3_5_0.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/test/org/apache/lucene/codecs/lucene40/TestBitVectorBackCompat.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/codecs/lucene40/TestBitVectorBackCompat.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/codecs/lucene40/TestBitVectorBackCompat.java	(working copy)
@@ -0,0 +1,96 @@
+package org.apache.lucene.codecs.lucene40;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.Constructor;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.store.IOContext;
+import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+
+/** Tests BitVector against all released 3.x versions */
+public class TestBitVectorBackCompat extends LuceneTestCase {
+  static final List<Class<? extends AncientBitVector>> clazzes = new ArrayList<>();
+  static {
+    clazzes.add(BitVector_3_0_0.class);
+    clazzes.add(BitVector_3_0_2.class);
+    clazzes.add(BitVector_3_1_0.class);
+    clazzes.add(BitVector_3_4_0.class);
+    clazzes.add(BitVector_3_5_0.class);
+  }
+  
+  static AncientBitVector newBitVector(int size, Class<? extends AncientBitVector> clazz) throws Exception {
+    Constructor<? extends AncientBitVector> ctor = clazz.getConstructor(int.class);
+    return ctor.newInstance(size);
+  }
+  
+  public void testRandom() throws Exception {
+    for (Class<? extends AncientBitVector> clazz : clazzes) {
+      for (int i = 0; i < 50; i++) {
+        try {
+          doTestRandom(clazz);
+        } catch (Throwable t) {
+          System.out.println("failed with version: " + clazz.getSimpleName());
+          IOUtils.reThrow(t);
+        }
+      }
+    }
+  }
+  
+  private void doTestRandom(Class<? extends AncientBitVector> clazz) throws Exception {    
+    // set random bits, of some sparsity
+    int size = TestUtil.nextInt(random(), 1, 100_000);
+    int numSet = random().nextInt(size);
+    
+    AncientBitVector bv = newBitVector(size, clazz);
+    if (numSet == size) {
+      for (int i = 0; i < size; i++) {
+        bv.set(i);
+      }
+    } else {
+      for (int i = 0; i < numSet; i++) {
+        while (true) {
+          final int o = random().nextInt(size);
+          if (!bv.get(o)) {
+            bv.set(o);
+            break;
+          }
+        }
+      }
+    }
+    
+    // serialize to ramdir
+    RAMDirectory ramdir = new RAMDirectory();
+    bv.write(ramdir, "bits");
+    
+    // read back with current code
+    BitVector current = new BitVector(ramdir, "bits", IOContext.DEFAULT);
+    
+    assertEquals(size, current.size());
+    for (int i = 0; i < size; i++) {
+      // we must assert they are opposites: because we look at "live docs" but these wrote "deleted docs"
+      assertEquals(bv.get(i), !current.get(i));
+    }
+    
+    ramdir.close();
+  }
+}

Property changes on: lucene/core/src/test/org/apache/lucene/codecs/lucene40/TestBitVectorBackCompat.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
