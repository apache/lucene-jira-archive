Index: lucene/core/src/java/org/apache/lucene/codecs/block/gendecompress.py
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/gendecompress.py	(revision 1369254)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/gendecompress.py	(working copy)
@@ -75,18 +75,18 @@
     w("final class PackedIntsDecompress {\n")
 
     w('\n  // nocommit: assess perf of this to see if specializing is really needed\n')
-    w('\n  // NOTE: hardwired to blockSize == 128\n\n')
+    w('\n  // NOTE: hardwired to blockSize == 32*k \n\n')
 
-    w('  public static void decode0(final IntBuffer compressedBuffer, final int[] output) {\n')
-    w('    Arrays.fill(output, compressedBuffer.get());\n')
+    w('  public static void decode0(final IntBuffer compressedBuffer, final int[] output, int iteration) {\n')
+    w('    Arrays.fill(output, 0, iteration*32, compressedBuffer.get());\n')
     w('  }\n')
 
     for numFrameBits in xrange(1, 33):
-      w('  public static void decode%d(final IntBuffer compressedBuffer, final int[] output) {\n' % numFrameBits)
+      w('  public static void decode%d(final IntBuffer compressedBuffer, final int[] output, int iteration) {\n' % numFrameBits)
       w('    final int numFrameBits = %d;\n' % numFrameBits)
       w('    final int mask = (int) ((1L<<numFrameBits) - 1);\n')
       w('    int outputOffset = 0;\n')
-      w('    for(int step=0;step<4;step++) {\n')
+      w('    for(int step=0;step<iteration;step++) {\n')
 
       for i in range(numFrameBits): # declare int vars and init from buffer
         w("      int intValue" + str(i) + " = compressedBuffer.get();\n")
Index: lucene/core/src/java/org/apache/lucene/codecs/block/PackedIntsDecompress.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/PackedIntsDecompress.java	(revision 1369254)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/PackedIntsDecompress.java	(working copy)
@@ -25,16 +25,16 @@
 
   // nocommit: assess perf of this to see if specializing is really needed
 
-  // NOTE: hardwired to blockSize == 128
+  // NOTE: hardwired to blockSize == 32*k 
 
-  public static void decode0(final IntBuffer compressedBuffer, final int[] output) {
-    Arrays.fill(output, compressedBuffer.get());
+  public static void decode0(final IntBuffer compressedBuffer, final int[] output, int iteration) {
+    Arrays.fill(output, 0, iteration*32, compressedBuffer.get());
   }
-  public static void decode1(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode1(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 1;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       output[0 + outputOffset] = intValue0 & mask;
       output[1 + outputOffset] = (intValue0 >>> 1) & mask;
@@ -71,11 +71,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode2(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode2(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 2;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       output[0 + outputOffset] = intValue0 & mask;
@@ -113,11 +113,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode3(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode3(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 3;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -156,11 +156,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode4(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode4(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 4;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -200,11 +200,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode5(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode5(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 5;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -245,11 +245,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode6(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode6(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 6;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -291,11 +291,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode7(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode7(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 7;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -338,11 +338,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode8(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode8(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 8;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -386,11 +386,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode9(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode9(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 9;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -435,11 +435,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode10(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode10(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 10;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -485,11 +485,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode11(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode11(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 11;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -536,11 +536,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode12(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode12(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 12;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -588,11 +588,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode13(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode13(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 13;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -641,11 +641,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode14(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode14(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 14;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -695,11 +695,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode15(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode15(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 15;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -750,11 +750,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode16(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode16(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 16;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -806,11 +806,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode17(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode17(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 17;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -863,11 +863,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode18(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode18(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 18;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -921,11 +921,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode19(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode19(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 19;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -980,11 +980,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode20(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode20(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 20;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1040,11 +1040,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode21(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode21(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 21;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1101,11 +1101,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode22(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode22(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 22;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1163,11 +1163,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode23(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode23(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 23;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1226,11 +1226,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode24(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode24(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 24;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1290,11 +1290,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode25(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode25(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 25;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1355,11 +1355,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode26(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode26(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 26;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1421,11 +1421,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode27(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode27(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 27;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1488,11 +1488,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode28(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode28(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 28;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1556,11 +1556,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode29(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode29(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 29;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1625,11 +1625,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode30(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode30(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 30;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1695,11 +1695,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode31(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode31(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 31;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1766,11 +1766,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode32(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode32(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 32;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java	(revision 1369254)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java	(working copy)
@@ -37,7 +37,16 @@
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IOUtils;
 
-// nocommit javadocs
+/**
+ * Concrete class that writes docId(maybe frq,pos,offset,payloads) list
+ * with postings format.
+ *
+ * Postings list for each term will be stored separately. 
+ *
+ * @see BlockSkipWriter for details about skipping setting and postings layout.
+ *
+ */
+public final class BlockPostingsReader extends PostingsReaderBase {
 
 public final class BlockPostingsWriter extends PostingsWriterBase {
 
@@ -60,10 +69,8 @@
   final IndexOutput posOut;
   final IndexOutput payOut;
 
-  static final int DEFAULT_BLOCK_SIZE = 128;
+  final static int blockSize = BlockPostingsFormat.DEFAULT_BLOCK_SIZE;
 
-  final int blockSize;
-
   private IndexOutput termsOut;
 
   // How current field indexes postings:
@@ -91,12 +98,12 @@
   private int payloadByteUpto;
 
   private int lastBlockDocID;
-  private boolean saveNextPosBlock;
   private long lastBlockPosFP;
   private long lastBlockPayFP;
   private int lastBlockPosBufferUpto;
   private int lastBlockStartOffset;
   private int lastBlockPayloadByteUpto;
+
   private int lastDocID;
   private int lastPosition;
   private int lastStartOffset;
@@ -107,9 +114,8 @@
 
   private final BlockSkipWriter skipWriter;
   
-  public BlockPostingsWriter(SegmentWriteState state, int blockSize) throws IOException {
+  public BlockPostingsWriter(SegmentWriteState state) throws IOException {
     super();
-    this.blockSize = blockSize;
 
     docOut = state.directory.createOutput(IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockPostingsFormat.DOC_EXTENSION),
                                           state.context);
@@ -164,14 +170,14 @@
     docDeltaBuffer = new int[blockSize];
     freqBuffer = new int[blockSize];
 
-    skipWriter = new BlockSkipWriter(blockSize,
-                                     maxSkipLevels, 
+    skipWriter = new BlockSkipWriter(maxSkipLevels, 
+                                     blockSize,
                                      state.segmentInfo.getDocCount(),
                                      docOut,
                                      posOut,
                                      payOut);
 
-    encoded = new byte[blockSize*4 + 4];
+    encoded = new byte[blockSize*4];
     encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
   }
 
@@ -201,8 +207,8 @@
         payTermStartFP = payOut.getFilePointer();
       }
     }
+    lastDocID = 0;
     lastBlockDocID = -1;
-    lastDocID = 0;
     if (DEBUG) {
       System.out.println("FPW.startTerm startFP=" + docTermStartFP);
     }
@@ -211,7 +217,6 @@
 
   private void writeBlock(int[] buffer, IndexOutput out) throws IOException {
     final int header = ForUtil.compress(buffer, encodedBuffer);
-    //System.out.println("    block has " + numBytes + " bytes");
     out.writeVInt(header);
     out.writeBytes(encoded, ForUtil.getEncodedSize(header));
   }
@@ -219,61 +224,25 @@
   @Override
   public void startDoc(int docID, int termDocFreq) throws IOException {
     if (DEBUG) {
-      System.out.println("FPW.startDoc docID=" + docID);
+      System.out.println("FPW.startDoc docID["+docBufferUpto+"]=" + docID);
     }
+    final int docDelta = docID - lastDocID;
 
-    // nocommit do this in finishDoc... but does it fail...?
-    // is it not always called...?
-    if (posOut != null && saveNextPosBlock) {
-      lastBlockPosFP = posOut.getFilePointer();
-      if (payOut != null) {
-        lastBlockPayFP = payOut.getFilePointer();
-      }
-      lastBlockPosBufferUpto = posBufferUpto;
-      lastBlockStartOffset = lastStartOffset;
-      lastBlockPayloadByteUpto = payloadByteUpto;
-      saveNextPosBlock = false;
-      if (DEBUG) {
-        System.out.println("  now save lastBlockPosFP=" + lastBlockPosFP + " lastBlockPosBufferUpto=" + lastBlockPosBufferUpto + " lastBlockPayloadByteUpto=" + lastBlockPayloadByteUpto);
-      }
-    }
-
-    final int docDelta = docID - lastDocID;
     if (docID < 0 || (docCount > 0 && docDelta <= 0)) {
       throw new CorruptIndexException("docs out of order (" + docID + " <= " + lastDocID + " ) (docOut: " + docOut + ")");
     }
-    lastDocID = docID;
 
     docDeltaBuffer[docBufferUpto] = docDelta;
-    if (DEBUG) {
-      System.out.println("  docDeltaBuffer[" + docBufferUpto + "]=" + docDelta);
-    }
+//    if (DEBUG) {
+//      System.out.println("  docDeltaBuffer[" + docBufferUpto + "]=" + docDelta);
+//    }
     if (fieldHasFreqs) {
       freqBuffer[docBufferUpto] = termDocFreq;
     }
-
     docBufferUpto++;
     docCount++;
 
     if (docBufferUpto == blockSize) {
-      // nocommit maybe instead of buffering skip before
-      // writing a block based on last block's end data
-      // ... we could buffer after writing the block?  only
-      // iffiness with that approach is it could be a
-      // pointlness skip?  like we may stop adding docs
-      // right after that, then we have skip point AFTER
-      // last doc.  the thing is, in finishTerm we are
-      // already sometimes adding a skip point AFTER the
-      // last doc?
-      if (lastBlockDocID != -1) {
-        if (DEBUG) {
-          System.out.println("  bufferSkip at writeBlock: lastDocID=" + lastBlockDocID + " docCount=" + (docCount-blockSize));
-        }
-        skipWriter.bufferSkip(lastBlockDocID, docCount-blockSize, lastBlockPosFP, lastBlockPayFP, lastBlockPosBufferUpto, lastBlockStartOffset, lastBlockPayloadByteUpto);
-      }
-      lastBlockDocID = docID;
-      saveNextPosBlock = true;
-
       if (DEBUG) {
         System.out.println("  write docDelta block @ fp=" + docOut.getFilePointer());
       }
@@ -284,9 +253,8 @@
         }
         writeBlock(freqBuffer, docOut);
       }
-      docBufferUpto = 0;
     }
-
+    lastDocID = docID;
     lastPosition = 0;
     lastStartOffset = 0;
   }
@@ -294,9 +262,9 @@
   /** Add a new position & payload */
   @Override
   public void addPosition(int position, BytesRef payload, int startOffset, int endOffset) throws IOException {
-    if (DEBUG) {
-      System.out.println("FPW.addPosition pos=" + position + " posBufferUpto=" + posBufferUpto + (fieldHasPayloads ? " payloadByteUpto=" + payloadByteUpto: ""));
-    }
+//    if (DEBUG) {
+//      System.out.println("FPW.addPosition pos=" + position + " posBufferUpto=" + posBufferUpto + (fieldHasPayloads ? " payloadByteUpto=" + payloadByteUpto: ""));
+//    }
     posDeltaBuffer[posBufferUpto] = position - lastPosition;
     if (fieldHasPayloads) {
       if (payload == null || payload.length == 0) {
@@ -343,7 +311,35 @@
   }
 
   @Override
-  public void finishDoc() {
+  public void finishDoc() throws IOException {
+    // Have collected a block of docs, and get a new doc. 
+    // Should write skip data as well as postings list for current block
+    if (lastBlockDocID != -1 && docBufferUpto == 1) {
+      if (DEBUG) {
+        System.out.println("  bufferSkip at writeBlock: lastDocID=" + lastBlockDocID + " docCount=" + (docCount-1));
+      }
+      skipWriter.bufferSkip(lastBlockDocID, docCount-1, lastBlockPosFP, lastBlockPayFP, lastBlockPosBufferUpto, lastBlockStartOffset, lastBlockPayloadByteUpto);
+    }
+
+    // Since we don't know df for current term, we had to buffer
+    // those skip data for each block, and when a new doc comes, 
+    // write them to skip file.
+    if (docBufferUpto == blockSize) {
+      lastBlockDocID = lastDocID;
+      if (posOut != null) {
+        if (payOut != null) {
+          lastBlockPayFP = payOut.getFilePointer();
+        }
+        lastBlockPosFP = posOut.getFilePointer();
+        lastBlockPosBufferUpto = posBufferUpto;
+        lastBlockStartOffset = lastStartOffset;
+        lastBlockPayloadByteUpto = payloadByteUpto;
+      }
+      if (DEBUG) {
+        System.out.println("  docBufferUpto="+docBufferUpto+" now get lastBlockDocID="+lastBlockDocID+" lastBlockPosFP=" + lastBlockPosFP + " lastBlockPosBufferUpto=" + lastBlockPosBufferUpto + " lastBlockPayloadByteUpto=" + lastBlockPayloadByteUpto);
+      }
+      docBufferUpto = 0;
+    }
   }
 
   private static class PendingTerm {
@@ -367,7 +363,6 @@
   /** Called when we are done adding docs to this term */
   @Override
   public void finishTerm(TermStats stats) throws IOException {
-
     assert stats.docFreq > 0;
 
     // TODO: wasteful we are counting this (counting # docs
@@ -378,19 +373,6 @@
       System.out.println("FPW.finishTerm docFreq=" + stats.docFreq);
     }
 
-    // nocommit silly that skipper must write skip when we no
-    // postings come after it, but if we don't do this, skip
-    // reader incorrectly thinks it can read another level 0
-    // skip entry here!:
-    //if (docCount > blockSize && docBufferUpto > 0) {
-    if (docCount > blockSize) {
-      final int lastDocCount = blockSize*(docCount/blockSize);
-      if (DEBUG) {
-        System.out.println("  bufferSkip at finishTerm: lastDocID=" + lastBlockDocID + " docCount=" + lastDocCount);
-      }
-      skipWriter.bufferSkip(lastBlockDocID, lastDocCount, lastBlockPosFP, lastBlockPayFP, lastBlockPosBufferUpto, lastBlockStartOffset, lastBlockPayloadByteUpto);
-    }
-
     if (DEBUG) {
       if (docBufferUpto > 0) {
         System.out.println("  write doc/freq vInt block (count=" + docBufferUpto + ") at fp=" + docOut.getFilePointer() + " docTermStartFP=" + docTermStartFP);
Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockSkipWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockSkipWriter.java	(revision 1369254)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockSkipWriter.java	(working copy)
@@ -23,10 +23,29 @@
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.codecs.MultiLevelSkipListWriter;
 
-// nocommit do we need more frequent skips at level > 0?
-// 128*128 is immense?  may need to decouple
+// nocommit may need to decouple
 // baseSkipInterval & theRestSkipInterval?
 
+/**
+ * Write skip lists with multiple levels, and support skip within block ints.
+ *
+ * Assume that docFreq = 28, skipInterval = blockSize = 12
+ *
+ *  |       block#0       | |      block#1        | |vInts|
+ *  d d d d d d d d d d d d d d d d d d d d d d d d d d d d (posting list)
+ *                          ^                       ^       (level 0 skip point)
+ *
+ * Note that skipWriter will ignore first document in block#0, since 
+ * it is useless as a skip point.  Also, we'll never skip into the vInts
+ * block, only record skip data at the start its start point(if it exist).
+ *
+ * For each skip point, we will record: 
+ * 1. lastDocID, 
+ * 2. its related file points(position, payload), 
+ * 3. related numbers or uptos(position, payload).
+ * 4. start offset.
+ *
+ */
 final class BlockSkipWriter extends MultiLevelSkipListWriter {
   private boolean DEBUG = BlockPostingsReader.DEBUG;
   
@@ -52,8 +71,8 @@
   private boolean fieldHasOffsets;
   private boolean fieldHasPayloads;
 
-  public BlockSkipWriter(int skipInterval, int maxSkipLevels, int docCount, IndexOutput docOut, IndexOutput posOut, IndexOutput payOut) {
-    super(skipInterval, maxSkipLevels, docCount);
+  public BlockSkipWriter(int maxSkipLevels, int blockSize, int docCount, IndexOutput docOut, IndexOutput posOut, IndexOutput payOut) {
+    super(blockSize, maxSkipLevels, docCount);
     this.docOut = docOut;
     this.posOut = posOut;
     this.payOut = payOut;
Index: lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java	(revision 1369254)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java	(working copy)
@@ -22,7 +22,7 @@
  * Encode all values in normal area with fixed bit width, 
  * which is determined by the max value in this block.
  */
-public class ForUtil {
+public final class ForUtil {
   protected static final int[] MASK = {   0x00000000,
     0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f,
     0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff,
@@ -30,13 +30,14 @@
     0x0007ffff, 0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
     0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff, 0x1fffffff, 0x3fffffff,
     0x7fffffff, 0xffffffff};
+  protected static final int blockSize = BlockPostingsFormat.DEFAULT_BLOCK_SIZE;
+  protected static final int totalIterations = blockSize/32;
 
   /** Compress given int[] into Integer buffer, with For format
    *
    * @param data        uncompressed data
-   * @param size        num of ints to compress
    * @param intBuffer   integer buffer to hold compressed data
-   * @return encoded block byte size
+   * @return the header for current block 
    */
   public static int compress(final int[] data, IntBuffer intBuffer) {
     int numBits=getNumBits(data);
@@ -66,6 +67,7 @@
    *
    * @param intBuffer   integer buffer to hold compressed data
    * @param data        int array to hold uncompressed data
+   * @param header      header of current block, which contains numFrameBits
    */
   public static void decompress(IntBuffer intBuffer, int[] data, int header) {
     // since this buffer is reused at upper level, rewind first
@@ -73,56 +75,62 @@
 
     // nocommit assert header isn't "malformed", ie besides
     // numBytes / bit-width there is nothing else!
-
     int numBits = ((header >> 8) & MASK[6]);
 
-    decompressCore(intBuffer, data, numBits);
+    decompressCore(intBuffer, data, numBits, totalIterations);
   }
 
-  /**
-   * IntBuffer will not be rewinded in this method, therefore
-   * caller should ensure that the position is set to the first
-   * encoded int before decoding.
+  /** Decompress given Integer buffer into int array.
+   *
+   * @param intBuffer   integer buffer to hold compressed data
+   * @param data        int array to hold uncompressed data
+   * @param header      header for current block
+   * @param iteration   this method will decode iter*32 ints from compressed data.
    */
-  static void decompressCore(IntBuffer intBuffer, int[] data, int numBits) {
-    assert numBits<=32;
-    assert numBits>=0;
+  public static void decompress(IntBuffer intBuffer, int[] data, int header, int iteration) {
+    // since this buffer is reused at upper level, rewind first
+    intBuffer.rewind();
 
-    // TODO: PackedIntsDecompress is hardewired to size==128 only
+    int numBits = ((header >> 8) & MASK[6]);
+
+    decompressCore(intBuffer, data, numBits, iteration);
+  }
+
+  static void decompressCore(IntBuffer intBuffer, int[] data, int numBits, int iteration) {
     switch(numBits) {
-      case 0: PackedIntsDecompress.decode0(intBuffer, data); break;
-      case 1: PackedIntsDecompress.decode1(intBuffer, data); break;
-      case 2: PackedIntsDecompress.decode2(intBuffer, data); break;
-      case 3: PackedIntsDecompress.decode3(intBuffer, data); break;
-      case 4: PackedIntsDecompress.decode4(intBuffer, data); break;
-      case 5: PackedIntsDecompress.decode5(intBuffer, data); break;
-      case 6: PackedIntsDecompress.decode6(intBuffer, data); break;
-      case 7: PackedIntsDecompress.decode7(intBuffer, data); break;
-      case 8: PackedIntsDecompress.decode8(intBuffer, data); break;
-      case 9: PackedIntsDecompress.decode9(intBuffer, data); break;
-      case 10: PackedIntsDecompress.decode10(intBuffer, data); break;
-      case 11: PackedIntsDecompress.decode11(intBuffer, data); break;
-      case 12: PackedIntsDecompress.decode12(intBuffer, data); break;
-      case 13: PackedIntsDecompress.decode13(intBuffer, data); break;
-      case 14: PackedIntsDecompress.decode14(intBuffer, data); break;
-      case 15: PackedIntsDecompress.decode15(intBuffer, data); break;
-      case 16: PackedIntsDecompress.decode16(intBuffer, data); break;
-      case 17: PackedIntsDecompress.decode17(intBuffer, data); break;
-      case 18: PackedIntsDecompress.decode18(intBuffer, data); break;
-      case 19: PackedIntsDecompress.decode19(intBuffer, data); break;
-      case 20: PackedIntsDecompress.decode20(intBuffer, data); break;
-      case 21: PackedIntsDecompress.decode21(intBuffer, data); break;
-      case 22: PackedIntsDecompress.decode22(intBuffer, data); break;
-      case 23: PackedIntsDecompress.decode23(intBuffer, data); break;
-      case 24: PackedIntsDecompress.decode24(intBuffer, data); break;
-      case 25: PackedIntsDecompress.decode25(intBuffer, data); break;
-      case 26: PackedIntsDecompress.decode26(intBuffer, data); break;
-      case 27: PackedIntsDecompress.decode27(intBuffer, data); break;
-      case 28: PackedIntsDecompress.decode28(intBuffer, data); break;
-      case 29: PackedIntsDecompress.decode29(intBuffer, data); break;
-      case 30: PackedIntsDecompress.decode30(intBuffer, data); break;
-      case 31: PackedIntsDecompress.decode31(intBuffer, data); break;
-      case 32: PackedIntsDecompress.decode32(intBuffer, data); break;
+      case 0: PackedIntsDecompress.decode0(intBuffer, data, iteration); break;
+      case 1: PackedIntsDecompress.decode1(intBuffer, data, iteration); break;
+      case 2: PackedIntsDecompress.decode2(intBuffer, data, iteration); break;
+      case 3: PackedIntsDecompress.decode3(intBuffer, data, iteration); break;
+      case 4: PackedIntsDecompress.decode4(intBuffer, data, iteration); break;
+      case 5: PackedIntsDecompress.decode5(intBuffer, data, iteration); break;
+      case 6: PackedIntsDecompress.decode6(intBuffer, data, iteration); break;
+      case 7: PackedIntsDecompress.decode7(intBuffer, data, iteration); break;
+      case 8: PackedIntsDecompress.decode8(intBuffer, data, iteration); break;
+      case 9: PackedIntsDecompress.decode9(intBuffer, data, iteration); break;
+      case 10: PackedIntsDecompress.decode10(intBuffer, data, iteration); break;
+      case 11: PackedIntsDecompress.decode11(intBuffer, data, iteration); break;
+      case 12: PackedIntsDecompress.decode12(intBuffer, data, iteration); break;
+      case 13: PackedIntsDecompress.decode13(intBuffer, data, iteration); break;
+      case 14: PackedIntsDecompress.decode14(intBuffer, data, iteration); break;
+      case 15: PackedIntsDecompress.decode15(intBuffer, data, iteration); break;
+      case 16: PackedIntsDecompress.decode16(intBuffer, data, iteration); break;
+      case 17: PackedIntsDecompress.decode17(intBuffer, data, iteration); break;
+      case 18: PackedIntsDecompress.decode18(intBuffer, data, iteration); break;
+      case 19: PackedIntsDecompress.decode19(intBuffer, data, iteration); break;
+      case 20: PackedIntsDecompress.decode20(intBuffer, data, iteration); break;
+      case 21: PackedIntsDecompress.decode21(intBuffer, data, iteration); break;
+      case 22: PackedIntsDecompress.decode22(intBuffer, data, iteration); break;
+      case 23: PackedIntsDecompress.decode23(intBuffer, data, iteration); break;
+      case 24: PackedIntsDecompress.decode24(intBuffer, data, iteration); break;
+      case 25: PackedIntsDecompress.decode25(intBuffer, data, iteration); break;
+      case 26: PackedIntsDecompress.decode26(intBuffer, data, iteration); break;
+      case 27: PackedIntsDecompress.decode27(intBuffer, data, iteration); break;
+      case 28: PackedIntsDecompress.decode28(intBuffer, data, iteration); break;
+      case 29: PackedIntsDecompress.decode29(intBuffer, data, iteration); break;
+      case 30: PackedIntsDecompress.decode30(intBuffer, data, iteration); break;
+      case 31: PackedIntsDecompress.decode31(intBuffer, data, iteration); break;
+      case 32: PackedIntsDecompress.decode32(intBuffer, data, iteration); break;
     }
   }
 
@@ -163,6 +171,7 @@
     return optBits;
   }
 
+  // nocommit: we must have a util function for this, hmm?
   protected static boolean isAllEqual(final int[] data) {
     int len = data.length;
     int v = data[0];
@@ -177,23 +186,22 @@
   /** 
    * Generate the 4 byte header, which contains (from lsb to msb):
    *
-   * 8 bits for encoded block int size (excluded header, this limits DEFAULT_BLOCK_SIZE <= 2^8)
    * 6 bits for num of frame bits (when 0, values in this block are all the same)
-   * other bits unused
+   * other bits for encoded block int size (excluded header), so we can use crazy block size
    *
    */
   static int getHeader(int encodedSize, int numBits) {
-    return  (encodedSize)
-          | ((numBits) << 8);
+    return  (numBits)
+          | ((encodedSize) << 6);
   }
 
   /** 
    * Expert: get metadata from header. 
    */
+  public static int getNumBits(int header) {
+    return ((header & MASK[6]));
+  }
   public static int getEncodedSize(int header) {
-    return ((header & MASK[8]))*4;
+    return ((header >>> 6))*4;
   }
-  public static int getNumBits(int header) {
-    return ((header >> 8) & MASK[6]);
-  }
 }
Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsFormat.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsFormat.java	(revision 1369254)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsFormat.java	(working copy)
@@ -31,8 +31,7 @@
 import org.apache.lucene.util.IOUtils;
 
 /**
- * Pass ForFactory to a PostingsWriter/ReaderBase, and get 
- * customized postings format plugged.
+ * Encodes/decode terms, postings and proximity data.
  */
 public final class BlockPostingsFormat extends PostingsFormat {
   public static final String DOC_EXTENSION = "doc";
@@ -42,6 +41,7 @@
   private final int minTermBlockSize;
   private final int maxTermBlockSize;
   public final static int DEFAULT_BLOCK_SIZE = 128;
+  public final static int DEFAULT_SKIP_INTERVAL = 32;
 
   public BlockPostingsFormat() {
     this(BlockTreeTermsWriter.DEFAULT_MIN_BLOCK_SIZE, BlockTreeTermsWriter.DEFAULT_MAX_BLOCK_SIZE);
@@ -62,8 +62,7 @@
 
   @Override
   public FieldsConsumer fieldsConsumer(SegmentWriteState state) throws IOException {
-    // TODO: implement a new PostingsWriterBase to improve skip-settings
-    PostingsWriterBase postingsWriter = new BlockPostingsWriter(state, 128);
+    PostingsWriterBase postingsWriter = new BlockPostingsWriter(state);
 
     boolean success = false;
     try {
@@ -86,8 +85,7 @@
                                                                 state.fieldInfos,
                                                                 state.segmentInfo,
                                                                 state.context,
-                                                                state.segmentSuffix,
-                                                                128);
+                                                                state.segmentSuffix);
     boolean success = false;
     try {
       FieldsProducer ret = new BlockTreeTermsReader(state.dir,
Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockSkipReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockSkipReader.java	(revision 1369254)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockSkipReader.java	(working copy)
@@ -24,14 +24,35 @@
 import org.apache.lucene.store.IndexInput;
 
 /**
- * Implements the skip list reader for the 4.0 posting list format
+ * Implements the skip list reader for block postings format
  * that stores positions and payloads.
  * 
- * @see Lucene40PostingsFormat
- * @lucene.experimental
+ * Although this skipper uses MultiLevelSkipListReader as an interface, 
+ * its definition of skip position will be a little different. 
+ *
+ * For example, when skipInterval = blockSize = 3, df = 2*skipInterval = 6, 
+ * 
+ * 0 1 2 3 4 5
+ * d d d d d d    (posting list)
+ *     ^     ^    (skip point in MultiLeveSkipWriter)
+ *       ^        (skip point in BlockSkipWriter)
+ *
+ * In this case, MultiLevelSkipListReader will use the last document as a skip point, 
+ * while BlockSkipReader should assume no skip point will comes. 
+ *
+ * If we use the interface directly in BlockSkipReader, it may silly try to read 
+ * another skip data after the only skip point is loaded. 
+ *
+ * To illustrate this, we can call skipTo(d[5]), since skip point d[3] has smaller docId,
+ * and numSkipped+blockSize== df, the MultiLevelSkipListReader will assume the skip list
+ * isn't exhausted yet, and try to load a non-existed skip point
+ *
+ * Therefore, we'll trim df before passing it to the interface. see trim(int)
+ *
  */
 final class BlockSkipReader extends MultiLevelSkipListReader {
   private boolean DEBUG = BlockPostingsReader.DEBUG;
+  private int blockSize;
 
   private long docPointer[];
   private long posPointer[];
@@ -47,8 +68,9 @@
   private long lastDocPointer;
   private int lastPosBufferUpto;
 
-  public BlockSkipReader(IndexInput skipStream, int maxSkipLevels, int skipInterval, boolean hasPos, boolean hasOffsets, boolean hasPayloads) {
-    super(skipStream, maxSkipLevels, skipInterval);
+  public BlockSkipReader(IndexInput skipStream, int maxSkipLevels, int blockSize, boolean hasPos, boolean hasOffsets, boolean hasPayloads) {
+    super(skipStream, maxSkipLevels, blockSize);
+    this.blockSize = blockSize;
     docPointer = new long[maxSkipLevels];
     if (hasPos) {
       posPointer = new long[maxSkipLevels];
@@ -73,8 +95,22 @@
     }
   }
 
+
+  /**
+   * Trim original docFreq to tell skipReader read proper number of skip points.
+   *
+   * Since our definition in BlockSkip* is a little different from MultiLevelSkip*
+   * This trimed docFreq will prevent skipReader from:
+   * 1. silly reading a non-existed skip point after the last block boundary
+   * 2. moving into the vInt block
+   *
+   */
+  protected int trim(int df) {
+    return df % blockSize == 0? df - 1: df;
+  }
+
   public void init(long skipPointer, long docBasePointer, long posBasePointer, long payBasePointer, int df) {
-    super.init(skipPointer, df);
+    super.init(skipPointer, trim(df));
     lastDocPointer = docBasePointer;
     lastPosPointer = posBasePointer;
     lastPayPointer = payBasePointer;
Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java	(revision 1369254)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java	(working copy)
@@ -43,7 +43,14 @@
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IOUtils;
 
-// nocommit javadocs
+
+/**
+ * Concrete class that reads docId(maybe frq,pos,offset,payloads) list
+ * with postings format.
+ *
+ * @see BlockSkipReader for details
+ *
+ */
 public final class BlockPostingsReader extends PostingsReaderBase {
 
   private final IndexInput docIn;
@@ -55,10 +62,9 @@
   // nocommit
   final String segment;
 
-  // NOTE: not private to avoid access$NNN methods:
-  final int blockSize;
+  final static int blockSize = BlockPostingsFormat.DEFAULT_BLOCK_SIZE;
 
-  public BlockPostingsReader(Directory dir, FieldInfos fieldInfos, SegmentInfo segmentInfo, IOContext ioContext, String segmentSuffix, int blockSize) throws IOException {
+  public BlockPostingsReader(Directory dir, FieldInfos fieldInfos, SegmentInfo segmentInfo, IOContext ioContext, String segmentSuffix) throws IOException {
     boolean success = false;
     segment = segmentInfo.name;
     IndexInput docIn = null;
@@ -99,8 +105,6 @@
         IOUtils.closeWhileHandlingException(docIn, posIn, payIn);
       }
     }
-
-    this.blockSize = blockSize;
   }
 
   @Override
@@ -116,6 +120,24 @@
     }
   }
 
+  static void readVIntBlock(IndexInput docIn, int[] docBuffer, int[] freqBuffer, int num, boolean indexHasFreq) throws IOException {
+    if (indexHasFreq) {
+      for(int i=0;i<num;i++) {
+        final int code = docIn.readVInt();
+        docBuffer[i] = code >>> 1;
+        if ((code & 1) != 0) {
+          freqBuffer[i] = 1;
+        } else {
+          freqBuffer[i] = docIn.readVInt();
+        }
+      }
+    } else {
+      for(int i=0;i<num;i++) {
+        docBuffer[i] = docIn.readVInt();
+      }
+    }
+  }
+
   static void readBlock(IndexInput in, byte[] encoded, IntBuffer encodedBuffer, int[] buffer) throws IOException {
     int header = in.readVInt();
     in.readBytes(encoded, 0, ForUtil.getEncodedSize(header));
@@ -300,6 +322,7 @@
     }
   }
 
+
   final class BlockDocsEnum extends DocsEnum {
     private final byte[] encoded;
     private final IntBuffer encodedBuffer;
@@ -309,6 +332,9 @@
 
     private int docBufferUpto;
 
+    // How may ints encoded as ForBlock
+    private int blockInts;
+
     private BlockSkipReader skipper;
     private boolean skipped;
 
@@ -343,7 +369,7 @@
       indexHasPos = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
       indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
       indexHasPayloads = fieldInfo.hasPayloads();
-      encoded = new byte[blockSize*4 + 4];
+      encoded = new byte[blockSize*4];
       encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();      
     }
 
@@ -371,6 +397,7 @@
       accum = 0;
       docUpto = 0;
       docBufferUpto = blockSize;
+      blockInts = docFreq/blockSize*blockSize;
       skipped = false;
       return this;
     }
@@ -385,16 +412,25 @@
       return doc;
     }
     
+
+    /**
+     * Decode a piece of ints int docDelta(and docTermFreq) buffer.
+     * 
+     * When fully is set false, we'll simplly skip to the end of current block
+     * after partial decoding is done.
+     */
     private void refillDocs() throws IOException {
+      //System.out.println("["+docFreq+"]"+" refillDoc");
       final int left = docFreq - docUpto;
       assert left > 0;
 
-      if (left >= blockSize) {
+      // We are still reading inside a block, otherwise we 
+      // should consider to handle the tail after these blocks 
+      if (docUpto < blockInts) {
         if (DEBUG) {
           System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
         }
         readBlock(docIn, encoded, encodedBuffer, docDeltaBuffer);
-
         if (indexHasFreq) {
           if (DEBUG) {
             System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
@@ -402,50 +438,33 @@
           readBlock(docIn, encoded, encodedBuffer, freqBuffer);
         }
       } else {
-        // Read vInts:
         if (DEBUG) {
           System.out.println("    fill last vInt block from fp=" + docIn.getFilePointer());
         }
-        for(int i=0;i<left;i++) {
-          final int code = docIn.readVInt();
-          if (indexHasFreq) {
-            docDeltaBuffer[i] = code >>> 1;
-            if ((code & 1) != 0) {
-              freqBuffer[i] = 1;
-            } else {
-              freqBuffer[i] = docIn.readVInt();
-            }
-          } else {
-            docDeltaBuffer[i] = code;
-          }
-        }
+        readVIntBlock(docIn, docDeltaBuffer, freqBuffer, left, indexHasFreq);
       }
       docBufferUpto = 0;
     }
 
     @Override
     public int nextDoc() throws IOException {
-
       if (DEBUG) {
         System.out.println("\nFPR.nextDoc");
       }
-
       while (true) {
         if (DEBUG) {
           System.out.println("  docUpto=" + docUpto + " (of df=" + docFreq + ") docBufferUpto=" + docBufferUpto);
         }
-
         if (docUpto == docFreq) {
           if (DEBUG) {
             System.out.println("  return doc=END");
           }
           return doc = NO_MORE_DOCS;
         }
-
+        //System.out.println("["+docFreq+"]"+" nextDoc");
         if (docBufferUpto == blockSize) {
           refillDocs();
         }
-
         if (DEBUG) {
           System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
         }
@@ -461,15 +480,13 @@
           }
           return doc;
         }
-
         if (DEBUG) {
           System.out.println("  doc=" + accum + " is deleted; try next doc");
         }
-
         docBufferUpto++;
       }
     }
-    
+
     @Override
     public int advance(int target) throws IOException {
       // nocommit make frq block load lazy/skippable
@@ -478,12 +495,12 @@
       // nocommit put cheating back!  does it help?
       // nocommit use skipper!!!  it has next last doc id!!
       //if (docFreq > blockSize && target - (blockSize - docBufferUpto) - 2*blockSize > accum) {
+
+      // We allow the skipper to run iff:
+      // 1. We have enough ints to use partial decode
+      // 2. The target is not within one skip
       if (docFreq > blockSize && target - accum > blockSize) {
 
-        if (DEBUG) {
-          System.out.println("load skipper");
-        }
-
         if (skipper == null) {
           // Lazy init: first time this enum has ever been used for skipping
           skipper = new BlockSkipReader((IndexInput) docIn.clone(),
@@ -498,6 +515,14 @@
           assert skipOffset != -1;
           // This is the first time this enum has skipped
           // since reset() was called; load the skip data:
+          //
+          // We don't always use the real docFreq, to prevent the skipper
+          // from 
+          // 1. silly reading a non-existed skip point after the last block boundary
+          // 2. moving into the vInt block
+          // 
+          // See BlockSkipReader for detailed explanation
+          //
           skipper.init(docTermStartFP+skipOffset, docTermStartFP, 0, 0, docFreq);
           skipped = true;
         }
@@ -506,18 +531,16 @@
 
         if (newDocUpto > docUpto) {
           // Skipper moved
-
           if (DEBUG) {
             System.out.println("skipper moved to docUpto=" + newDocUpto + " vs current=" + docUpto + "; docID=" + skipper.getDoc() + " fp=" + skipper.getDocPointer());
           }
-
           assert newDocUpto % blockSize == (blockSize-1): "got " + newDocUpto;
           docUpto = newDocUpto+1;
 
-          // Force block read next:
+          // Force to read next block
           docBufferUpto = blockSize;
-          accum = skipper.getDoc();
-          docIn.seek(skipper.getDocPointer());
+          accum = skipper.getDoc();               // actually, this is just lastSkipEntry
+          docIn.seek(skipper.getDocPointer());    // now point to the block we want to search
         }
       }
 
@@ -530,11 +553,9 @@
           return doc;
         }
       }
-
       if (DEBUG) {
         System.out.println("  advance return doc=END");
       }
-
       return NO_MORE_DOCS;
     }
   }
@@ -552,6 +573,8 @@
     private int docBufferUpto;
     private int posBufferUpto;
 
+    private int blockInts;
+
     private BlockSkipReader skipper;
     private boolean skipped;
 
@@ -604,7 +627,7 @@
       this.startDocIn = BlockPostingsReader.this.docIn;
       this.docIn = (IndexInput) startDocIn.clone();
       this.posIn = (IndexInput) BlockPostingsReader.this.posIn.clone();
-      encoded = new byte[blockSize*4 + 4];
+      encoded = new byte[blockSize*4];
       encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
       indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
       indexHasPayloads = fieldInfo.hasPayloads();
@@ -641,6 +664,7 @@
       accum = 0;
       docUpto = 0;
       docBufferUpto = blockSize;
+      blockInts = docFreq/blockSize*blockSize;
       skipped = false;
       return this;
     }
@@ -656,35 +680,23 @@
     }
 
     private void refillDocs() throws IOException {
+      //System.out.println("["+docFreq+"]"+" refillDoc");
       final int left = docFreq - docUpto;
       assert left > 0;
-
-      if (left >= blockSize) {
+      if (docUpto < blockInts) {
         if (DEBUG) {
           System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
         }
-
         readBlock(docIn, encoded, encodedBuffer, docDeltaBuffer);
-
         if (DEBUG) {
           System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
         }
-
         readBlock(docIn, encoded, encodedBuffer, freqBuffer);
       } else {
-        // Read vInts:
         if (DEBUG) {
           System.out.println("    fill last vInt doc block from fp=" + docIn.getFilePointer());
         }
-        for(int i=0;i<left;i++) {
-          final int code = docIn.readVInt();
-          docDeltaBuffer[i] = code >>> 1;
-          if ((code & 1) != 0) {
-            freqBuffer[i] = 1;
-          } else {
-            freqBuffer[i] = docIn.readVInt();
-          }
-        }
+        readVIntBlock(docIn, docDeltaBuffer, freqBuffer, left, true);
       }
       docBufferUpto = 0;
     }
@@ -712,7 +724,6 @@
           } else {
             posDeltaBuffer[i] = code;
           }
-
           if (indexHasOffsets) {
             posIn.readVInt();
             posIn.readVInt();
@@ -728,24 +739,20 @@
 
     @Override
     public int nextDoc() throws IOException {
-
       if (DEBUG) {
         System.out.println("  FPR.nextDoc");
       }
-
       while (true) {
         if (DEBUG) {
           System.out.println("    docUpto=" + docUpto + " (of df=" + docFreq + ") docBufferUpto=" + docBufferUpto);
         }
-
         if (docUpto == docFreq) {
           return doc = NO_MORE_DOCS;
         }
-
+        //System.out.println("["+docFreq+"]"+" nextDoc");
         if (docBufferUpto == blockSize) {
           refillDocs();
         }
-
         if (DEBUG) {
           System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
         }
@@ -757,13 +764,12 @@
 
         if (liveDocs == null || liveDocs.get(accum)) {
           doc = accum;
+          position = 0;
           if (DEBUG) {
             System.out.println("    return doc=" + doc + " freq=" + freq + " posPendingCount=" + posPendingCount);
           }
-          position = 0;
           return doc;
         }
-
         if (DEBUG) {
           System.out.println("    doc=" + accum + " is deleted; try next doc");
         }
@@ -783,15 +789,8 @@
       //if (docFreq > blockSize && target - (blockSize - docBufferUpto) - 2*blockSize > accum) {
       if (docFreq > blockSize && target - accum > blockSize) {
 
-        if (DEBUG) {
-          System.out.println("    try skipper");
-        }
-
         if (skipper == null) {
           // Lazy init: first time this enum has ever been used for skipping
-          if (DEBUG) {
-            System.out.println("    create skipper");
-          }
           skipper = new BlockSkipReader((IndexInput) docIn.clone(),
                                         BlockPostingsWriter.maxSkipLevels,
                                         blockSize,
@@ -804,9 +803,6 @@
           assert skipOffset != -1;
           // This is the first time this enum has skipped
           // since reset() was called; load the skip data:
-          if (DEBUG) {
-            System.out.println("    init skipper");
-          }
           skipper.init(docTermStartFP+skipOffset, docTermStartFP, posTermStartFP, payTermStartFP, docFreq);
           skipped = true;
         }
@@ -815,7 +811,7 @@
 
         if (newDocUpto > docUpto) {
           // Skipper moved
-
+          //
           if (DEBUG) {
             System.out.println("    skipper moved to docUpto=" + newDocUpto + " vs current=" + docUpto + "; docID=" + skipper.getDoc() + " fp=" + skipper.getDocPointer() + " pos.fp=" + skipper.getPosPointer() + " pos.bufferUpto=" + skipper.getPosBufferUpto());
           }
@@ -823,7 +819,6 @@
           assert newDocUpto % blockSize == (blockSize-1): "got " + newDocUpto;
           docUpto = newDocUpto+1;
 
-          // Force block read next:
           docBufferUpto = blockSize;
           accum = skipper.getDoc();
           docIn.seek(skipper.getDocPointer());
@@ -965,6 +960,8 @@
     private int docBufferUpto;
     private int posBufferUpto;
 
+    private int blockInts;
+
     private BlockSkipReader skipper;
     private boolean skipped;
 
@@ -1024,7 +1021,7 @@
       this.docIn = (IndexInput) startDocIn.clone();
       this.posIn = (IndexInput) BlockPostingsReader.this.posIn.clone();
       this.payIn = (IndexInput) BlockPostingsReader.this.payIn.clone();
-      encoded = new byte[blockSize*4 + 4];
+      encoded = new byte[blockSize*4];
       encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
       indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
       if (indexHasOffsets) {
@@ -1081,6 +1078,7 @@
       accum = 0;
       docUpto = 0;
       docBufferUpto = blockSize;
+      blockInts = docFreq/blockSize*blockSize;
       skipped = false;
       return this;
     }
@@ -1096,35 +1094,24 @@
     }
 
     private void refillDocs() throws IOException {
+      //System.out.println("["+docFreq+"]"+" refillDoc");
       final int left = docFreq - docUpto;
       assert left > 0;
 
-      if (left >= blockSize) {
+      if (docUpto < blockInts) {
         if (DEBUG) {
           System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
         }
-
         readBlock(docIn, encoded, encodedBuffer, docDeltaBuffer);
-
         if (DEBUG) {
           System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
         }
-
         readBlock(docIn, encoded, encodedBuffer, freqBuffer);
       } else {
-        // Read vInts:
         if (DEBUG) {
           System.out.println("    fill last vInt doc block from fp=" + docIn.getFilePointer());
         }
-        for(int i=0;i<left;i++) {
-          final int code = docIn.readVInt();
-          docDeltaBuffer[i] = code >>> 1;
-          if ((code & 1) != 0) {
-            freqBuffer[i] = 1;
-          } else {
-            freqBuffer[i] = docIn.readVInt();
-          }
-        }
+        readVIntBlock(docIn, docDeltaBuffer, freqBuffer, left, true);
       }
       docBufferUpto = 0;
     }
@@ -1187,10 +1174,10 @@
           }
           readBlock(payIn, encoded, encodedBuffer, payloadLengthBuffer);
           int numBytes = payIn.readVInt();
+          if (numBytes > payloadBytes.length) {
           if (DEBUG) {
             System.out.println("        " + numBytes + " payload bytes @ pay.fp=" + payIn.getFilePointer());
           }
-          if (numBytes > payloadBytes.length) {
             payloadBytes = ArrayUtil.grow(payloadBytes, numBytes);
           }
           payIn.readBytes(payloadBytes, 0, numBytes);
@@ -1209,29 +1196,24 @@
 
     @Override
     public int nextDoc() throws IOException {
-
       if (DEBUG) {
         System.out.println("  FPR.nextDoc");
       }
-
       if (indexHasPayloads) {
         payloadByteUpto += payloadLength;
         payloadLength = 0;
       }
-
       while (true) {
         if (DEBUG) {
           System.out.println("    docUpto=" + docUpto + " (of df=" + docFreq + ") docBufferUpto=" + docBufferUpto);
         }
-
         if (docUpto == docFreq) {
           return doc = NO_MORE_DOCS;
         }
-
+        //System.out.println("["+docFreq+"]"+" nextDoc");
         if (docBufferUpto == blockSize) {
           refillDocs();
         }
-
         if (DEBUG) {
           System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
         }
@@ -1251,7 +1233,6 @@
           lastStartOffset = 0;
           return doc;
         }
-
         if (DEBUG) {
           System.out.println("    doc=" + accum + " is deleted; try next doc");
         }
@@ -1271,15 +1252,9 @@
       //if (docFreq > blockSize && target - (blockSize - docBufferUpto) - 2*blockSize > accum) {
       if (docFreq > blockSize && target - accum > blockSize) {
 
-        if (DEBUG) {
-          System.out.println("    try skipper");
-        }
 
         if (skipper == null) {
           // Lazy init: first time this enum has ever been used for skipping
-          if (DEBUG) {
-            System.out.println("    create skipper");
-          }
           skipper = new BlockSkipReader((IndexInput) docIn.clone(),
                                         BlockPostingsWriter.maxSkipLevels,
                                         blockSize,
@@ -1292,9 +1267,6 @@
           assert skipOffset != -1;
           // This is the first time this enum has skipped
           // since reset() was called; load the skip data:
-          if (DEBUG) {
-            System.out.println("    init skipper");
-          }
           skipper.init(docTermStartFP+skipOffset, docTermStartFP, posTermStartFP, payTermStartFP, docFreq);
           skipped = true;
         }
@@ -1303,15 +1275,12 @@
 
         if (newDocUpto > docUpto) {
           // Skipper moved
-
           if (DEBUG) {
             System.out.println("    skipper moved to docUpto=" + newDocUpto + " vs current=" + docUpto + "; docID=" + skipper.getDoc() + " fp=" + skipper.getDocPointer() + " pos.fp=" + skipper.getPosPointer() + " pos.bufferUpto=" + skipper.getPosBufferUpto() + " pay.fp=" + skipper.getPayPointer() + " lastStartOffset=" + lastStartOffset);
           }
-
           assert newDocUpto % blockSize == (blockSize-1): "got " + newDocUpto;
           docUpto = newDocUpto+1;
 
-          // Force block read next:
           docBufferUpto = blockSize;
           accum = skipper.getDoc();
           docIn.seek(skipper.getDocPointer());
@@ -1325,10 +1294,10 @@
 
       // Now scan:
       while (nextDoc() != NO_MORE_DOCS) {
-        if (doc >= target) {
           if (DEBUG) {
             System.out.println("  advance return doc=" + doc);
           }
+        if (doc >= target) {
           return doc;
         }
       }
