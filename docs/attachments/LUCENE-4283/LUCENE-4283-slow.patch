Index: lucene/core/src/java/org/apache/lucene/codecs/block/gendecompress.py
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/gendecompress.py	(revision 1368831)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/gendecompress.py	(working copy)
@@ -75,18 +75,18 @@
     w("final class PackedIntsDecompress {\n")
 
     w('\n  // nocommit: assess perf of this to see if specializing is really needed\n')
-    w('\n  // NOTE: hardwired to blockSize == 128\n\n')
+    w('\n  // NOTE: hardwired to blockSize == 32*k \n\n')
 
-    w('  public static void decode0(final IntBuffer compressedBuffer, final int[] output) {\n')
-    w('    Arrays.fill(output, compressedBuffer.get());\n')
+    w('  public static void decode0(final IntBuffer compressedBuffer, final int[] output, int iteration) {\n')
+    w('    Arrays.fill(output, 0, iteration*32, compressedBuffer.get());\n')
     w('  }\n')
 
     for numFrameBits in xrange(1, 33):
-      w('  public static void decode%d(final IntBuffer compressedBuffer, final int[] output) {\n' % numFrameBits)
+      w('  public static void decode%d(final IntBuffer compressedBuffer, final int[] output, int iteration) {\n' % numFrameBits)
       w('    final int numFrameBits = %d;\n' % numFrameBits)
       w('    final int mask = (int) ((1L<<numFrameBits) - 1);\n')
       w('    int outputOffset = 0;\n')
-      w('    for(int step=0;step<4;step++) {\n')
+      w('    for(int step=0;step<iteration;step++) {\n')
 
       for i in range(numFrameBits): # declare int vars and init from buffer
         w("      int intValue" + str(i) + " = compressedBuffer.get();\n")
Index: lucene/core/src/java/org/apache/lucene/codecs/block/PackedIntsDecompress.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/PackedIntsDecompress.java	(revision 1368831)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/PackedIntsDecompress.java	(working copy)
@@ -25,16 +25,16 @@
 
   // nocommit: assess perf of this to see if specializing is really needed
 
-  // NOTE: hardwired to blockSize == 128
+  // NOTE: hardwired to blockSize == 32*k 
 
-  public static void decode0(final IntBuffer compressedBuffer, final int[] output) {
-    Arrays.fill(output, compressedBuffer.get());
+  public static void decode0(final IntBuffer compressedBuffer, final int[] output, int iteration) {
+    Arrays.fill(output, 0, iteration*32, compressedBuffer.get());
   }
-  public static void decode1(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode1(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 1;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       output[0 + outputOffset] = intValue0 & mask;
       output[1 + outputOffset] = (intValue0 >>> 1) & mask;
@@ -71,11 +71,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode2(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode2(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 2;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       output[0 + outputOffset] = intValue0 & mask;
@@ -113,11 +113,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode3(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode3(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 3;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -156,11 +156,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode4(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode4(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 4;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -200,11 +200,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode5(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode5(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 5;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -245,11 +245,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode6(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode6(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 6;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -291,11 +291,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode7(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode7(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 7;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -338,11 +338,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode8(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode8(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 8;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -386,11 +386,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode9(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode9(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 9;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -435,11 +435,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode10(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode10(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 10;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -485,11 +485,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode11(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode11(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 11;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -536,11 +536,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode12(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode12(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 12;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -588,11 +588,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode13(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode13(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 13;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -641,11 +641,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode14(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode14(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 14;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -695,11 +695,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode15(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode15(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 15;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -750,11 +750,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode16(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode16(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 16;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -806,11 +806,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode17(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode17(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 17;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -863,11 +863,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode18(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode18(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 18;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -921,11 +921,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode19(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode19(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 19;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -980,11 +980,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode20(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode20(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 20;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1040,11 +1040,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode21(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode21(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 21;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1101,11 +1101,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode22(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode22(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 22;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1163,11 +1163,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode23(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode23(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 23;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1226,11 +1226,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode24(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode24(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 24;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1290,11 +1290,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode25(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode25(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 25;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1355,11 +1355,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode26(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode26(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 26;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1421,11 +1421,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode27(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode27(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 27;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1488,11 +1488,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode28(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode28(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 28;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1556,11 +1556,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode29(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode29(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 29;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1625,11 +1625,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode30(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode30(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 30;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1695,11 +1695,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode31(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode31(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 31;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
@@ -1766,11 +1766,11 @@
       outputOffset += 32;
     }
   }
-  public static void decode32(final IntBuffer compressedBuffer, final int[] output) {
+  public static void decode32(final IntBuffer compressedBuffer, final int[] output, int iteration) {
     final int numFrameBits = 32;
     final int mask = (int) ((1L<<numFrameBits) - 1);
     int outputOffset = 0;
-    for(int step=0;step<4;step++) {
+    for(int step=0;step<iteration;step++) {
       int intValue0 = compressedBuffer.get();
       int intValue1 = compressedBuffer.get();
       int intValue2 = compressedBuffer.get();
Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java	(revision 1368831)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsWriter.java	(working copy)
@@ -60,9 +60,11 @@
   final IndexOutput posOut;
   final IndexOutput payOut;
 
-  static final int DEFAULT_BLOCK_SIZE = 128;
+  final static int blockSize = BlockPostingsFormat.DEFAULT_BLOCK_SIZE;
+  final static int skipInterval = BlockPostingsFormat.DEFAULT_SKIP_INTERVAL;
 
-  final int blockSize;
+  // how many slices(or intervals) one block holds
+  final static int skipsPerBlock = blockSize/skipInterval;
 
   private IndexOutput termsOut;
 
@@ -90,13 +92,13 @@
   private byte[] payloadBytes;
   private int payloadByteUpto;
 
-  private int lastBlockDocID;
-  private boolean saveNextPosBlock;
-  private long lastBlockPosFP;
-  private long lastBlockPayFP;
-  private int lastBlockPosBufferUpto;
-  private int lastBlockStartOffset;
-  private int lastBlockPayloadByteUpto;
+  final int[] lastBlockDocIDs;
+  private long[] lastBlockPosFPs;
+  private long[] lastBlockPayFPs;
+  private int[] lastBlockPosBufferUptos;
+  private int[] lastBlockStartOffsets;
+  private int[] lastBlockPayloadByteUptos;
+
   private int lastDocID;
   private int lastPosition;
   private int lastStartOffset;
@@ -107,9 +109,8 @@
 
   private final BlockSkipWriter skipWriter;
   
-  public BlockPostingsWriter(SegmentWriteState state, int blockSize) throws IOException {
+  public BlockPostingsWriter(SegmentWriteState state) throws IOException {
     super();
-    this.blockSize = blockSize;
 
     docOut = state.directory.createOutput(IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, BlockPostingsFormat.DOC_EXTENSION),
                                           state.context);
@@ -164,14 +165,21 @@
     docDeltaBuffer = new int[blockSize];
     freqBuffer = new int[blockSize];
 
-    skipWriter = new BlockSkipWriter(blockSize,
+    lastBlockDocIDs = new int[skipsPerBlock];
+    lastBlockPosFPs = new long[skipsPerBlock];
+    lastBlockPayFPs = new long[skipsPerBlock];
+    lastBlockPosBufferUptos = new int[skipsPerBlock];
+    lastBlockStartOffsets = new int[skipsPerBlock];
+    lastBlockPayloadByteUptos = new int[skipsPerBlock];
+
+    skipWriter = new BlockSkipWriter(skipInterval,
                                      maxSkipLevels, 
                                      state.segmentInfo.getDocCount(),
                                      docOut,
                                      posOut,
                                      payOut);
 
-    encoded = new byte[blockSize*4 + 4];
+    encoded = new byte[blockSize*4];
     encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
   }
 
@@ -201,7 +209,7 @@
         payTermStartFP = payOut.getFilePointer();
       }
     }
-    lastBlockDocID = -1;
+    lastBlockDocIDs[0] = -1;
     lastDocID = 0;
     if (DEBUG) {
       System.out.println("FPW.startTerm startFP=" + docTermStartFP);
@@ -211,7 +219,6 @@
 
   private void writeBlock(int[] buffer, IndexOutput out) throws IOException {
     final int header = ForUtil.compress(buffer, encodedBuffer);
-    //System.out.println("    block has " + numBytes + " bytes");
     out.writeVInt(header);
     out.writeBytes(encoded, ForUtil.getEncodedSize(header));
   }
@@ -219,61 +226,38 @@
   @Override
   public void startDoc(int docID, int termDocFreq) throws IOException {
     if (DEBUG) {
-      System.out.println("FPW.startDoc docID=" + docID);
+      System.out.println("FPW.startDoc docID["+docBufferUpto+"]=" + docID);
     }
-
-    // nocommit do this in finishDoc... but does it fail...?
-    // is it not always called...?
-    if (posOut != null && saveNextPosBlock) {
-      lastBlockPosFP = posOut.getFilePointer();
-      if (payOut != null) {
-        lastBlockPayFP = payOut.getFilePointer();
-      }
-      lastBlockPosBufferUpto = posBufferUpto;
-      lastBlockStartOffset = lastStartOffset;
-      lastBlockPayloadByteUpto = payloadByteUpto;
-      saveNextPosBlock = false;
-      if (DEBUG) {
-        System.out.println("  now save lastBlockPosFP=" + lastBlockPosFP + " lastBlockPosBufferUpto=" + lastBlockPosBufferUpto + " lastBlockPayloadByteUpto=" + lastBlockPayloadByteUpto);
-      }
-    }
-
     final int docDelta = docID - lastDocID;
     if (docID < 0 || (docCount > 0 && docDelta <= 0)) {
       throw new CorruptIndexException("docs out of order (" + docID + " <= " + lastDocID + " ) (docOut: " + docOut + ")");
     }
-    lastDocID = docID;
 
     docDeltaBuffer[docBufferUpto] = docDelta;
-    if (DEBUG) {
-      System.out.println("  docDeltaBuffer[" + docBufferUpto + "]=" + docDelta);
-    }
+//    if (DEBUG) {
+//      System.out.println("  docDeltaBuffer[" + docBufferUpto + "]=" + docDelta);
+//    }
     if (fieldHasFreqs) {
       freqBuffer[docBufferUpto] = termDocFreq;
     }
-
     docBufferUpto++;
     docCount++;
 
+    // nocommit do this in finishDoc... but does it fail...?
+    // is it not always called...?
+
+    // Since we don't know df for current term, we had to buffer
+    // those skip data for each block, and when a block of docs are
+    // collected, write them to skip file.
+    //
+
+    // have collected a block of docs, should write skip data as well as 
+    // postings list for previous block
     if (docBufferUpto == blockSize) {
-      // nocommit maybe instead of buffering skip before
-      // writing a block based on last block's end data
-      // ... we could buffer after writing the block?  only
-      // iffiness with that approach is it could be a
-      // pointlness skip?  like we may stop adding docs
-      // right after that, then we have skip point AFTER
-      // last doc.  the thing is, in finishTerm we are
-      // already sometimes adding a skip point AFTER the
-      // last doc?
-      if (lastBlockDocID != -1) {
-        if (DEBUG) {
-          System.out.println("  bufferSkip at writeBlock: lastDocID=" + lastBlockDocID + " docCount=" + (docCount-blockSize));
-        }
-        skipWriter.bufferSkip(lastBlockDocID, docCount-blockSize, lastBlockPosFP, lastBlockPayFP, lastBlockPosBufferUpto, lastBlockStartOffset, lastBlockPayloadByteUpto);
+      skipWriter.bufferSkip(lastBlockDocIDs, docCount-blockSize, lastBlockPosFPs, lastBlockPayFPs, lastBlockPosBufferUptos, lastBlockStartOffsets, lastBlockPayloadByteUptos);
+      if (DEBUG) {
+        System.out.println("  bufferSkip at writeBlock: lastDocID=" + lastBlockDocIDs[0] + " docCount=" + (docCount-blockSize));
       }
-      lastBlockDocID = docID;
-      saveNextPosBlock = true;
-
       if (DEBUG) {
         System.out.println("  write docDelta block @ fp=" + docOut.getFilePointer());
       }
@@ -287,6 +271,23 @@
       docBufferUpto = 0;
     }
 
+    int slice = (docBufferUpto-1)/skipInterval;
+    if (docBufferUpto % skipInterval == 1) {
+      lastBlockDocIDs[slice] = lastDocID;
+      if (posOut != null) {
+        if (payOut != null) {
+          lastBlockPayFPs[slice] = payOut.getFilePointer();
+        }
+        lastBlockPosFPs[slice] = posOut.getFilePointer();
+        lastBlockPosBufferUptos[slice] = posBufferUpto;
+        lastBlockStartOffsets[slice] = lastStartOffset;
+        lastBlockPayloadByteUptos[slice] = payloadByteUpto;
+      }
+      if (DEBUG) {
+        System.out.println("  docBufferUpto="+docBufferUpto+" now get lastBlockDocID="+lastBlockDocIDs[slice]+" lastBlockPosFP=" + lastBlockPosFPs[slice] + " lastBlockPosBufferUpto=" + lastBlockPosBufferUptos[slice] + " lastBlockPayloadByteUpto=" + lastBlockPayloadByteUptos[slice]);
+      }
+    }
+    lastDocID = docID;
     lastPosition = 0;
     lastStartOffset = 0;
   }
@@ -382,13 +383,15 @@
     // postings come after it, but if we don't do this, skip
     // reader incorrectly thinks it can read another level 0
     // skip entry here!:
-    //if (docCount > blockSize && docBufferUpto > 0) {
-    if (docCount > blockSize) {
-      final int lastDocCount = blockSize*(docCount/blockSize);
+
+    // if there are vInt block following, we won't skip into it,
+    // but should skip to its startpoint
+    final int lastDocCount = blockSize*(docCount/blockSize);
+    if (docCount > blockSize && docCount != lastDocCount) {
       if (DEBUG) {
-        System.out.println("  bufferSkip at finishTerm: lastDocID=" + lastBlockDocID + " docCount=" + lastDocCount);
+        System.out.println("  bufferSkip at finishTerm: lastDocID=" + lastBlockDocIDs[0] + " docCount=" + lastDocCount);
       }
-      skipWriter.bufferSkip(lastBlockDocID, lastDocCount, lastBlockPosFP, lastBlockPayFP, lastBlockPosBufferUpto, lastBlockStartOffset, lastBlockPayloadByteUpto);
+      skipWriter.bufferSkip(lastBlockDocIDs[0], lastDocCount, lastBlockPosFPs[0], lastBlockPayFPs[0], lastBlockPosBufferUptos[0], lastBlockStartOffsets[0], lastBlockPayloadByteUptos[0]);
     }
 
     if (DEBUG) {
Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockSkipWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockSkipWriter.java	(revision 1368831)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockSkipWriter.java	(working copy)
@@ -23,12 +23,33 @@
 import org.apache.lucene.store.IndexOutput;
 import org.apache.lucene.codecs.MultiLevelSkipListWriter;
 
-// nocommit do we need more frequent skips at level > 0?
-// 128*128 is immense?  may need to decouple
+// nocommit may need to decouple
 // baseSkipInterval & theRestSkipInterval?
 
+/**
+ * Write skip lists with multiple levels, and support skip within block ints.
+ *
+ * Assume that docFreq = 28, blockSize=12, and skipInterval=3
+ *
+ *  |       block#0       | |      block#1        | |vInts|
+ *  d d d d d d d d d d d d d d d d d d d d d d d d d d d d (posting list)
+ *        ^     ^     ^     ^     ^     ^     ^     ^       (level 0 skip point)
+ *
+ * Note that skipWriter will ignore first document in block#0, since 
+ * it is useless as a skip point.  Also, we'll never skip into the vInts
+ * block, only record skip data at the start its start point(if it exist).
+ *
+ * For each skip point, we will record: 
+ * 1. lastDocID, 
+ * 2. its related file points(position, payload), 
+ * 3. related numbers or uptos(position, payload).
+ * 4. start offset.
+ *
+ */
+
 final class BlockSkipWriter extends MultiLevelSkipListWriter {
   private boolean DEBUG = BlockPostingsReader.DEBUG;
+  private int skipInterval;
   
   private int[] lastSkipDoc;
   private long[] lastSkipDocPointer;
@@ -57,6 +78,7 @@
     this.docOut = docOut;
     this.posOut = posOut;
     this.payOut = payOut;
+    this.skipInterval = skipInterval;
     
     lastSkipDoc = new int[maxSkipLevels];
     lastSkipDocPointer = new long[maxSkipLevels];
@@ -108,6 +130,24 @@
     this.curStartOffset = startOffset;
     bufferSkip(numDocs);
   }
+
+  /**
+   * Sets the values for skip data in current block
+   */
+  public void bufferSkip(int[] docs, int numDocs, long[] posFPs, long[] payFPs, int[] posBufferUptos, int[] startOffsets, int[] payloadByteUptos) throws IOException {
+    this.curDocPointer = docOut.getFilePointer();
+    // first doc is useless as skip point
+    // nocommit: ugly use 128/32 as this magic number
+    for (int i=(numDocs==0 ? 1:0); i<4; i++) {
+      this.curPosPointer = posFPs[i];
+      this.curPayPointer = payFPs[i];
+      this.curPosBufferUpto = posBufferUptos[i];
+      this.curPayloadByteUpto = payloadByteUptos[i];
+      this.curStartOffset = startOffsets[i];
+      this.curDoc = docs[i];
+      bufferSkip(numDocs+i*skipInterval);
+    }
+  }
   
   @Override
   protected void writeSkipData(int level, IndexOutput skipBuffer) throws IOException {
Index: lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java	(revision 1368831)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/ForUtil.java	(working copy)
@@ -79,50 +79,72 @@
     decompressCore(intBuffer, data, numBits);
   }
 
+  /** Decompress given Integer buffer into int array.
+   *
+   * @param intBuffer   integer buffer to hold compressed data
+   * @param data        int array to hold uncompressed data
+   * @param header      header for current block
+   * @param iteration   this method will decode iter*32 ints from compressed data.
+   */
+  public static void decompress(IntBuffer intBuffer, int[] data, int header, int iteration) {
+    // since this buffer is reused at upper level, rewind first
+    intBuffer.rewind();
+
+    int numBits = ((header >> 8) & MASK[6]);
+
+    decompressPart(intBuffer, data, numBits, iteration);
+  }
+
+
+
   /**
    * IntBuffer will not be rewinded in this method, therefore
    * caller should ensure that the position is set to the first
    * encoded int before decoding.
    */
   static void decompressCore(IntBuffer intBuffer, int[] data, int numBits) {
-    assert numBits<=32;
+    assert numBits<=32 : numBits;
     assert numBits>=0;
+    // 4*32=blockSize=128
+    decompressPart(intBuffer, data, numBits, 4);
+  }
 
+  static void decompressPart(IntBuffer intBuffer, int[] data, int numBits, int iteration) {
     // TODO: PackedIntsDecompress is hardewired to size==128 only
     switch(numBits) {
-      case 0: PackedIntsDecompress.decode0(intBuffer, data); break;
-      case 1: PackedIntsDecompress.decode1(intBuffer, data); break;
-      case 2: PackedIntsDecompress.decode2(intBuffer, data); break;
-      case 3: PackedIntsDecompress.decode3(intBuffer, data); break;
-      case 4: PackedIntsDecompress.decode4(intBuffer, data); break;
-      case 5: PackedIntsDecompress.decode5(intBuffer, data); break;
-      case 6: PackedIntsDecompress.decode6(intBuffer, data); break;
-      case 7: PackedIntsDecompress.decode7(intBuffer, data); break;
-      case 8: PackedIntsDecompress.decode8(intBuffer, data); break;
-      case 9: PackedIntsDecompress.decode9(intBuffer, data); break;
-      case 10: PackedIntsDecompress.decode10(intBuffer, data); break;
-      case 11: PackedIntsDecompress.decode11(intBuffer, data); break;
-      case 12: PackedIntsDecompress.decode12(intBuffer, data); break;
-      case 13: PackedIntsDecompress.decode13(intBuffer, data); break;
-      case 14: PackedIntsDecompress.decode14(intBuffer, data); break;
-      case 15: PackedIntsDecompress.decode15(intBuffer, data); break;
-      case 16: PackedIntsDecompress.decode16(intBuffer, data); break;
-      case 17: PackedIntsDecompress.decode17(intBuffer, data); break;
-      case 18: PackedIntsDecompress.decode18(intBuffer, data); break;
-      case 19: PackedIntsDecompress.decode19(intBuffer, data); break;
-      case 20: PackedIntsDecompress.decode20(intBuffer, data); break;
-      case 21: PackedIntsDecompress.decode21(intBuffer, data); break;
-      case 22: PackedIntsDecompress.decode22(intBuffer, data); break;
-      case 23: PackedIntsDecompress.decode23(intBuffer, data); break;
-      case 24: PackedIntsDecompress.decode24(intBuffer, data); break;
-      case 25: PackedIntsDecompress.decode25(intBuffer, data); break;
-      case 26: PackedIntsDecompress.decode26(intBuffer, data); break;
-      case 27: PackedIntsDecompress.decode27(intBuffer, data); break;
-      case 28: PackedIntsDecompress.decode28(intBuffer, data); break;
-      case 29: PackedIntsDecompress.decode29(intBuffer, data); break;
-      case 30: PackedIntsDecompress.decode30(intBuffer, data); break;
-      case 31: PackedIntsDecompress.decode31(intBuffer, data); break;
-      case 32: PackedIntsDecompress.decode32(intBuffer, data); break;
+      case 0: PackedIntsDecompress.decode0(intBuffer, data, iteration); break;
+      case 1: PackedIntsDecompress.decode1(intBuffer, data, iteration); break;
+      case 2: PackedIntsDecompress.decode2(intBuffer, data, iteration); break;
+      case 3: PackedIntsDecompress.decode3(intBuffer, data, iteration); break;
+      case 4: PackedIntsDecompress.decode4(intBuffer, data, iteration); break;
+      case 5: PackedIntsDecompress.decode5(intBuffer, data, iteration); break;
+      case 6: PackedIntsDecompress.decode6(intBuffer, data, iteration); break;
+      case 7: PackedIntsDecompress.decode7(intBuffer, data, iteration); break;
+      case 8: PackedIntsDecompress.decode8(intBuffer, data, iteration); break;
+      case 9: PackedIntsDecompress.decode9(intBuffer, data, iteration); break;
+      case 10: PackedIntsDecompress.decode10(intBuffer, data, iteration); break;
+      case 11: PackedIntsDecompress.decode11(intBuffer, data, iteration); break;
+      case 12: PackedIntsDecompress.decode12(intBuffer, data, iteration); break;
+      case 13: PackedIntsDecompress.decode13(intBuffer, data, iteration); break;
+      case 14: PackedIntsDecompress.decode14(intBuffer, data, iteration); break;
+      case 15: PackedIntsDecompress.decode15(intBuffer, data, iteration); break;
+      case 16: PackedIntsDecompress.decode16(intBuffer, data, iteration); break;
+      case 17: PackedIntsDecompress.decode17(intBuffer, data, iteration); break;
+      case 18: PackedIntsDecompress.decode18(intBuffer, data, iteration); break;
+      case 19: PackedIntsDecompress.decode19(intBuffer, data, iteration); break;
+      case 20: PackedIntsDecompress.decode20(intBuffer, data, iteration); break;
+      case 21: PackedIntsDecompress.decode21(intBuffer, data, iteration); break;
+      case 22: PackedIntsDecompress.decode22(intBuffer, data, iteration); break;
+      case 23: PackedIntsDecompress.decode23(intBuffer, data, iteration); break;
+      case 24: PackedIntsDecompress.decode24(intBuffer, data, iteration); break;
+      case 25: PackedIntsDecompress.decode25(intBuffer, data, iteration); break;
+      case 26: PackedIntsDecompress.decode26(intBuffer, data, iteration); break;
+      case 27: PackedIntsDecompress.decode27(intBuffer, data, iteration); break;
+      case 28: PackedIntsDecompress.decode28(intBuffer, data, iteration); break;
+      case 29: PackedIntsDecompress.decode29(intBuffer, data, iteration); break;
+      case 30: PackedIntsDecompress.decode30(intBuffer, data, iteration); break;
+      case 31: PackedIntsDecompress.decode31(intBuffer, data, iteration); break;
+      case 32: PackedIntsDecompress.decode32(intBuffer, data, iteration); break;
     }
   }
 
Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsFormat.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsFormat.java	(revision 1368831)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsFormat.java	(working copy)
@@ -42,6 +42,7 @@
   private final int minTermBlockSize;
   private final int maxTermBlockSize;
   public final static int DEFAULT_BLOCK_SIZE = 128;
+  public final static int DEFAULT_SKIP_INTERVAL = 32;
 
   public BlockPostingsFormat() {
     this(BlockTreeTermsWriter.DEFAULT_MIN_BLOCK_SIZE, BlockTreeTermsWriter.DEFAULT_MAX_BLOCK_SIZE);
@@ -63,7 +64,7 @@
   @Override
   public FieldsConsumer fieldsConsumer(SegmentWriteState state) throws IOException {
     // TODO: implement a new PostingsWriterBase to improve skip-settings
-    PostingsWriterBase postingsWriter = new BlockPostingsWriter(state, 128);
+    PostingsWriterBase postingsWriter = new BlockPostingsWriter(state);
 
     boolean success = false;
     try {
@@ -86,8 +87,7 @@
                                                                 state.fieldInfos,
                                                                 state.segmentInfo,
                                                                 state.context,
-                                                                state.segmentSuffix,
-                                                                128);
+                                                                state.segmentSuffix);
     boolean success = false;
     try {
       FieldsProducer ret = new BlockTreeTermsReader(state.dir,
Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockSkipReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockSkipReader.java	(revision 1368831)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockSkipReader.java	(working copy)
@@ -24,11 +24,25 @@
 import org.apache.lucene.store.IndexInput;
 
 /**
- * Implements the skip list reader for the 4.0 posting list format
+ * Implements the skip list reader for block postings format
  * that stores positions and payloads.
  * 
- * @see Lucene40PostingsFormat
- * @lucene.experimental
+ * Although this skipper uses MultiLevelSkipListReader as an interface, 
+ * its definition of skip position will be a little different. 
+ *
+ * For example, when df==2*skipInterval==6, 
+ * 
+ * d d d d d d    (posting list)
+ *     ^     ^    (skip point in MultiLeveSkipWriter)
+ *       ^        (skip point in BlockSkipWriter)
+ *
+ * In this case, MultiLevelSkipListReader will use the last document as a skip point, 
+ * while BlockSkipReader should assume no skip point will comes. 
+ * If we use the interface directly,it may silly read skip data even the 
+ * target skip point is out of boundary.
+ * 
+ * Therefore, we'll trim the df before passing it to the interface.
+ *
  */
 final class BlockSkipReader extends MultiLevelSkipListReader {
   private boolean DEBUG = BlockPostingsReader.DEBUG;
Index: lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java	(revision 1368831)
+++ lucene/core/src/java/org/apache/lucene/codecs/block/BlockPostingsReader.java	(working copy)
@@ -55,10 +55,12 @@
   // nocommit
   final String segment;
 
-  // NOTE: not private to avoid access$NNN methods:
-  final int blockSize;
+  // nocommit: is it ok to set these two fixed?
+  final static int blockSize = BlockPostingsFormat.DEFAULT_BLOCK_SIZE;
+  final static int skipInterval = BlockPostingsFormat.DEFAULT_SKIP_INTERVAL;
+  final static int skipsPerBlock = blockSize/skipInterval;
 
-  public BlockPostingsReader(Directory dir, FieldInfos fieldInfos, SegmentInfo segmentInfo, IOContext ioContext, String segmentSuffix, int blockSize) throws IOException {
+  public BlockPostingsReader(Directory dir, FieldInfos fieldInfos, SegmentInfo segmentInfo, IOContext ioContext, String segmentSuffix) throws IOException {
     boolean success = false;
     segment = segmentInfo.name;
     IndexInput docIn = null;
@@ -100,7 +102,7 @@
       }
     }
 
-    this.blockSize = blockSize;
+    assert blockSize % skipInterval == 0;
   }
 
   @Override
@@ -122,6 +124,23 @@
     ForUtil.decompress(encodedBuffer, buffer, header);
   }
 
+  static void readBlockAndSkip(IndexInput in, byte[] encoded, IntBuffer encodedBuffer, int[] buffer, int slice) throws IOException {
+    int header = in.readVInt();
+    int size = ForUtil.getEncodedSize(header);
+    int sliceSize = size/skipsPerBlock;
+    int iteration = skipInterval/32;
+    
+    if (size > 4) { 
+      in.seek(in.getFilePointer() + sliceSize*slice);                  // seek to target slice
+      in.readBytes(encoded, 0, sliceSize);                             // load that slice of block
+      ForUtil.decompress(encodedBuffer, buffer, header, iteration);    // partially decode
+      in.seek(in.getFilePointer() + sliceSize*(skipsPerBlock-slice-1)); // skip to the end of block
+    } else {  // the all-value-same case
+      in.readBytes(encoded, 0, 4);                                     // read the symbol int
+      ForUtil.decompress(encodedBuffer, buffer, header, 1);
+    }
+  }
+
   static void skipBlock(IndexInput in) throws IOException {
     int header = in.readVInt();
     in.seek(in.getFilePointer() + ForUtil.getEncodedSize(header));
@@ -300,7 +319,8 @@
     }
   }
 
-  final class BlockDocsEnum extends DocsEnum {
+
+  final public class BlockDocsEnum extends DocsEnum {
     private final byte[] encoded;
     private final IntBuffer encodedBuffer;
     
@@ -309,6 +329,13 @@
 
     private int docBufferUpto;
 
+    // since a block is partilly decoded or fully decoded, another block or part
+    // should be read later if docBufferUpto is equal to this value
+    private int maxDocBufferUpto;
+
+    // how may ints encoded as ForBlock
+    private int blockInts;
+
     private BlockSkipReader skipper;
     private boolean skipped;
 
@@ -343,7 +370,7 @@
       indexHasPos = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
       indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
       indexHasPayloads = fieldInfo.hasPayloads();
-      encoded = new byte[blockSize*4 + 4];
+      encoded = new byte[blockSize*4];
       encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();      
     }
 
@@ -371,6 +398,8 @@
       accum = 0;
       docUpto = 0;
       docBufferUpto = blockSize;
+      maxDocBufferUpto = docBufferUpto;
+      blockInts = docFreq/blockSize*blockSize;
       skipped = false;
       return this;
     }
@@ -385,54 +414,66 @@
       return doc;
     }
     
-    private void refillDocs() throws IOException {
+    private void readVIntBlock(int num) throws IOException {
+      for(int i=0;i<num;i++) {
+        final int code = docIn.readVInt();
+        if (indexHasFreq) {
+          docDeltaBuffer[i] = code >>> 1;
+          if ((code & 1) != 0) {
+            freqBuffer[i] = 1;
+          } else {
+            freqBuffer[i] = docIn.readVInt();
+          }
+        } else {
+          docDeltaBuffer[i] = code;
+        }
+      }
+    }
+
+    private void refillDocs(boolean fully) throws IOException {
       final int left = docFreq - docUpto;
       assert left > 0;
 
-      if (left >= blockSize) {
-        if (DEBUG) {
-          System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
-        }
-        readBlock(docIn, encoded, encodedBuffer, docDeltaBuffer);
+      // We are still reading inside a block, otherwise we 
+      // should consider to handle the tail after these blocks 
+      if (docUpto < blockInts) {
+        
+        if (fully) {
+          readBlock(docIn, encoded, encodedBuffer, docDeltaBuffer);
+          if (indexHasFreq) {
+            readBlock(docIn, encoded, encodedBuffer, freqBuffer);
+          }
+          maxDocBufferUpto = blockSize;
+        } else {
+          long lastDocFP = docIn.getFilePointer();
+          int slice = docUpto % blockSize / skipInterval;
 
-        if (indexHasFreq) {
-          if (DEBUG) {
-            System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
+          readBlockAndSkip(docIn, encoded, encodedBuffer, docDeltaBuffer, slice);
+          if (indexHasFreq) {
+            readBlockAndSkip(docIn, encoded, encodedBuffer, freqBuffer, slice);
           }
-          readBlock(docIn, encoded, encodedBuffer, freqBuffer);
+          // current buffer is partly filled, may read remaining ints later
+          if (slice != blockSize/skipInterval - 1) {
+            docIn.seek(lastDocFP);
+          }
+          maxDocBufferUpto = skipInterval;
         }
       } else {
-        // Read vInts:
-        if (DEBUG) {
-          System.out.println("    fill last vInt block from fp=" + docIn.getFilePointer());
-        }
-        for(int i=0;i<left;i++) {
-          final int code = docIn.readVInt();
-          if (indexHasFreq) {
-            docDeltaBuffer[i] = code >>> 1;
-            if ((code & 1) != 0) {
-              freqBuffer[i] = 1;
-            } else {
-              freqBuffer[i] = docIn.readVInt();
-            }
-          } else {
-            docDeltaBuffer[i] = code;
-          }
-        }
+        readVIntBlock(left);
+        maxDocBufferUpto = blockSize;
       }
       docBufferUpto = 0;
     }
 
     @Override
     public int nextDoc() throws IOException {
-
       if (DEBUG) {
         System.out.println("\nFPR.nextDoc");
       }
 
       while (true) {
         if (DEBUG) {
-          System.out.println("  docUpto=" + docUpto + " (of df=" + docFreq + ") docBufferUpto=" + docBufferUpto);
+          System.out.println("    docUpto=" + docUpto + " (of df=" + docFreq + ") docBufferUpto=" + docBufferUpto);
         }
 
         if (docUpto == docFreq) {
@@ -442,12 +483,19 @@
           return doc = NO_MORE_DOCS;
         }
 
-        if (docBufferUpto == blockSize) {
-          refillDocs();
+        if (docBufferUpto == maxDocBufferUpto) {
+          if (maxDocBufferUpto != blockSize) {
+            // previous we didn't decode a whole block, should fill docs now, 
+            // but only another skipInterval ints from current block
+            refillDocs(false);
+          } else {
+            // decode the whole block
+            refillDocs(true);
+          }
         }
 
         if (DEBUG) {
-          System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
+          System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto+"]=" + docDeltaBuffer[docBufferUpto]);
         }
         accum += docDeltaBuffer[docBufferUpto];
         docUpto++;
@@ -469,7 +517,7 @@
         docBufferUpto++;
       }
     }
-    
+
     @Override
     public int advance(int target) throws IOException {
       // nocommit make frq block load lazy/skippable
@@ -478,17 +526,24 @@
       // nocommit put cheating back!  does it help?
       // nocommit use skipper!!!  it has next last doc id!!
       //if (docFreq > blockSize && target - (blockSize - docBufferUpto) - 2*blockSize > accum) {
-      if (docFreq > blockSize && target - accum > blockSize) {
 
+      // we allow the skipper to run when:
+      // 1. we have enough ints to use partial decode
+      // 2. the target is not within one skip
+      // 3. we'll not skip into vInt block
+      if (docFreq > blockSize && target - accum > skipInterval && accum + skipInterval <= blockInts) {
         if (DEBUG) {
-          System.out.println("load skipper");
+          System.out.println("    try skipper");
         }
 
         if (skipper == null) {
           // Lazy init: first time this enum has ever been used for skipping
+          if (DEBUG) {
+            System.out.println("    create skipper");
+          }
           skipper = new BlockSkipReader((IndexInput) docIn.clone(),
                                         BlockPostingsWriter.maxSkipLevels,
-                                        blockSize,
+                                        skipInterval,
                                         indexHasPos,
                                         indexHasOffsets,
                                         indexHasPayloads);
@@ -498,8 +553,20 @@
           assert skipOffset != -1;
           // This is the first time this enum has skipped
           // since reset() was called; load the skip data:
-          skipper.init(docTermStartFP+skipOffset, docTermStartFP, 0, 0, docFreq);
+          //
+          // We don't always use the real docFreq, to prevent the skipper
+          // from 
+          // 1. silly reading a non-existed skip point after the last block boundary
+          // 2. moving into the vInt block
+          // 
+          // See BlockSkipReader for detailed explanation
+          //
+          int fakedf = docFreq % blockSize == 0? docFreq - 1: blockInts + skipInterval - 1;
+          skipper.init(docTermStartFP+skipOffset, docTermStartFP, 0, 0, fakedf);
           skipped = true;
+          if (DEBUG) {
+            System.out.println("    init skipper");
+          }
         }
 
         final int newDocUpto = skipper.skipTo(target); 
@@ -511,13 +578,13 @@
             System.out.println("skipper moved to docUpto=" + newDocUpto + " vs current=" + docUpto + "; docID=" + skipper.getDoc() + " fp=" + skipper.getDocPointer());
           }
 
-          assert newDocUpto % blockSize == (blockSize-1): "got " + newDocUpto;
+          assert newDocUpto % skipInterval == (skipInterval-1): "got " + newDocUpto;
           docUpto = newDocUpto+1;
 
-          // Force block read next:
-          docBufferUpto = blockSize;
-          accum = skipper.getDoc();
-          docIn.seek(skipper.getDocPointer());
+          // Force to read next slice of block
+          maxDocBufferUpto = docBufferUpto = skipInterval;
+          accum = skipper.getDoc();               // actually, this is just lastSkipEntry
+          docIn.seek(skipper.getDocPointer());    // now point to the block we want to search
         }
       }
 
@@ -552,6 +619,10 @@
     private int docBufferUpto;
     private int posBufferUpto;
 
+    private int maxDocBufferUpto;
+    private int blockInts;
+
+
     private BlockSkipReader skipper;
     private boolean skipped;
 
@@ -604,7 +675,7 @@
       this.startDocIn = BlockPostingsReader.this.docIn;
       this.docIn = (IndexInput) startDocIn.clone();
       this.posIn = (IndexInput) BlockPostingsReader.this.posIn.clone();
-      encoded = new byte[blockSize*4 + 4];
+      encoded = new byte[blockSize*4];
       encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
       indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
       indexHasPayloads = fieldInfo.hasPayloads();
@@ -641,6 +712,8 @@
       accum = 0;
       docUpto = 0;
       docBufferUpto = blockSize;
+      maxDocBufferUpto = docBufferUpto;
+      blockInts = docFreq/blockSize*blockSize;
       skipped = false;
       return this;
     }
@@ -655,36 +728,42 @@
       return doc;
     }
 
-    private void refillDocs() throws IOException {
+    private void readVIntBlock(int num) throws IOException {
+      for(int i=0;i<num;i++) {
+        final int code = docIn.readVInt();
+        docDeltaBuffer[i] = code >>> 1;
+        if ((code & 1) != 0) {
+          freqBuffer[i] = 1;
+        } else {
+          freqBuffer[i] = docIn.readVInt();
+        }
+      }
+    }
+
+    private void refillDocs(boolean fully) throws IOException {
       final int left = docFreq - docUpto;
       assert left > 0;
 
-      if (left >= blockSize) {
-        if (DEBUG) {
-          System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
-        }
+      if (docUpto < blockInts) {
+        if (fully) {
+          readBlock(docIn, encoded, encodedBuffer, docDeltaBuffer);
+          readBlock(docIn, encoded, encodedBuffer, freqBuffer);
+          maxDocBufferUpto = blockSize;
+        } else {
+          long lastDocFP = docIn.getFilePointer();
+          int slice = docUpto % blockSize / skipInterval;
 
-        readBlock(docIn, encoded, encodedBuffer, docDeltaBuffer);
+          readBlockAndSkip(docIn, encoded, encodedBuffer, docDeltaBuffer, slice);
+          readBlockAndSkip(docIn, encoded, encodedBuffer, freqBuffer, slice);
 
-        if (DEBUG) {
-          System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
+          if (slice != blockSize/skipInterval - 1) {
+            docIn.seek(lastDocFP);
+          }
+          maxDocBufferUpto = skipInterval;
         }
-
-        readBlock(docIn, encoded, encodedBuffer, freqBuffer);
       } else {
-        // Read vInts:
-        if (DEBUG) {
-          System.out.println("    fill last vInt doc block from fp=" + docIn.getFilePointer());
-        }
-        for(int i=0;i<left;i++) {
-          final int code = docIn.readVInt();
-          docDeltaBuffer[i] = code >>> 1;
-          if ((code & 1) != 0) {
-            freqBuffer[i] = 1;
-          } else {
-            freqBuffer[i] = docIn.readVInt();
-          }
-        }
+        readVIntBlock(left);
+        maxDocBufferUpto = blockSize;
       }
       docBufferUpto = 0;
     }
@@ -728,7 +807,6 @@
 
     @Override
     public int nextDoc() throws IOException {
-
       if (DEBUG) {
         System.out.println("  FPR.nextDoc");
       }
@@ -742,12 +820,16 @@
           return doc = NO_MORE_DOCS;
         }
 
-        if (docBufferUpto == blockSize) {
-          refillDocs();
+        if (docBufferUpto == maxDocBufferUpto) {
+          if (maxDocBufferUpto != blockSize) {
+            refillDocs(false);
+          } else {
+            refillDocs(true);
+          }
         }
 
         if (DEBUG) {
-          System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto + "]=" + docDeltaBuffer[docBufferUpto]);
+          System.out.println("    accum=" + accum + " docDeltaBuffer[" + docBufferUpto+"]=" + docDeltaBuffer[docBufferUpto]);
         }
         accum += docDeltaBuffer[docBufferUpto];
         freq = freqBuffer[docBufferUpto];
@@ -781,7 +863,7 @@
       // nocommit put cheating back!  does it help?
       // nocommit use skipper!!!  it has next last doc id!!
       //if (docFreq > blockSize && target - (blockSize - docBufferUpto) - 2*blockSize > accum) {
-      if (docFreq > blockSize && target - accum > blockSize) {
+      if (docFreq > blockSize && target - accum > skipInterval && accum + skipInterval <= blockInts) {
 
         if (DEBUG) {
           System.out.println("    try skipper");
@@ -794,7 +876,7 @@
           }
           skipper = new BlockSkipReader((IndexInput) docIn.clone(),
                                         BlockPostingsWriter.maxSkipLevels,
-                                        blockSize,
+                                        skipInterval,
                                         true,
                                         indexHasOffsets,
                                         indexHasPayloads);
@@ -807,7 +889,8 @@
           if (DEBUG) {
             System.out.println("    init skipper");
           }
-          skipper.init(docTermStartFP+skipOffset, docTermStartFP, posTermStartFP, payTermStartFP, docFreq);
+          int fakedf = docFreq % blockSize == 0? docFreq - 1: blockInts + skipInterval - 1;
+          skipper.init(docTermStartFP+skipOffset, docTermStartFP, posTermStartFP, payTermStartFP, fakedf);
           skipped = true;
         }
 
@@ -820,11 +903,10 @@
             System.out.println("    skipper moved to docUpto=" + newDocUpto + " vs current=" + docUpto + "; docID=" + skipper.getDoc() + " fp=" + skipper.getDocPointer() + " pos.fp=" + skipper.getPosPointer() + " pos.bufferUpto=" + skipper.getPosBufferUpto());
           }
 
-          assert newDocUpto % blockSize == (blockSize-1): "got " + newDocUpto;
+          assert newDocUpto % skipInterval == (skipInterval-1): "got " + newDocUpto;
           docUpto = newDocUpto+1;
 
-          // Force block read next:
-          docBufferUpto = blockSize;
+          maxDocBufferUpto = docBufferUpto = skipInterval;
           accum = skipper.getDoc();
           docIn.seek(skipper.getDocPointer());
           posPendingFP = skipper.getPosPointer();
@@ -965,6 +1047,9 @@
     private int docBufferUpto;
     private int posBufferUpto;
 
+    private int maxDocBufferUpto;
+    private int blockInts;
+
     private BlockSkipReader skipper;
     private boolean skipped;
 
@@ -1024,7 +1109,7 @@
       this.docIn = (IndexInput) startDocIn.clone();
       this.posIn = (IndexInput) BlockPostingsReader.this.posIn.clone();
       this.payIn = (IndexInput) BlockPostingsReader.this.payIn.clone();
-      encoded = new byte[blockSize*4 + 4];
+      encoded = new byte[blockSize*4];
       encodedBuffer = ByteBuffer.wrap(encoded).asIntBuffer();
       indexHasOffsets = fieldInfo.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
       if (indexHasOffsets) {
@@ -1081,6 +1166,8 @@
       accum = 0;
       docUpto = 0;
       docBufferUpto = blockSize;
+      maxDocBufferUpto = docBufferUpto;
+      blockInts = docFreq/blockSize*blockSize;
       skipped = false;
       return this;
     }
@@ -1095,28 +1182,8 @@
       return doc;
     }
 
-    private void refillDocs() throws IOException {
-      final int left = docFreq - docUpto;
-      assert left > 0;
-
-      if (left >= blockSize) {
-        if (DEBUG) {
-          System.out.println("    fill doc block from fp=" + docIn.getFilePointer());
-        }
-
-        readBlock(docIn, encoded, encodedBuffer, docDeltaBuffer);
-
-        if (DEBUG) {
-          System.out.println("    fill freq block from fp=" + docIn.getFilePointer());
-        }
-
-        readBlock(docIn, encoded, encodedBuffer, freqBuffer);
-      } else {
-        // Read vInts:
-        if (DEBUG) {
-          System.out.println("    fill last vInt doc block from fp=" + docIn.getFilePointer());
-        }
-        for(int i=0;i<left;i++) {
+    private void readVIntBlock(int num) throws IOException {
+        for(int i=0;i<num;i++) {
           final int code = docIn.readVInt();
           docDeltaBuffer[i] = code >>> 1;
           if ((code & 1) != 0) {
@@ -1125,6 +1192,32 @@
             freqBuffer[i] = docIn.readVInt();
           }
         }
+    }
+
+    private void refillDocs(boolean fully) throws IOException {
+      final int left = docFreq - docUpto;
+      assert left > 0;
+
+      if (docUpto < blockInts) {
+        if (fully) {
+          readBlock(docIn, encoded, encodedBuffer, docDeltaBuffer);
+          readBlock(docIn, encoded, encodedBuffer, freqBuffer);
+          maxDocBufferUpto = blockSize;
+        } else {
+          long lastDocFP = docIn.getFilePointer();
+          int slice = docUpto % blockSize / skipInterval;
+
+          readBlockAndSkip(docIn, encoded, encodedBuffer, docDeltaBuffer, slice);
+          readBlockAndSkip(docIn, encoded, encodedBuffer, freqBuffer, slice);
+
+          if (slice != blockSize/skipInterval - 1) {
+            docIn.seek(lastDocFP);
+          }
+          maxDocBufferUpto = skipInterval;
+        }
+      } else {
+        readVIntBlock(left);
+        maxDocBufferUpto = blockSize;
       }
       docBufferUpto = 0;
     }
@@ -1209,7 +1302,6 @@
 
     @Override
     public int nextDoc() throws IOException {
-
       if (DEBUG) {
         System.out.println("  FPR.nextDoc");
       }
@@ -1228,8 +1320,12 @@
           return doc = NO_MORE_DOCS;
         }
 
-        if (docBufferUpto == blockSize) {
-          refillDocs();
+        if (docBufferUpto == maxDocBufferUpto) {
+          if (maxDocBufferUpto != blockSize) {
+            refillDocs(false);
+          } else {
+            refillDocs(true);
+          }
         }
 
         if (DEBUG) {
@@ -1269,7 +1365,7 @@
       // nocommit put cheating back!  does it help?
       // nocommit use skipper!!!  it has next last doc id!!
       //if (docFreq > blockSize && target - (blockSize - docBufferUpto) - 2*blockSize > accum) {
-      if (docFreq > blockSize && target - accum > blockSize) {
+      if (docFreq > blockSize && target - accum > skipInterval && accum + skipInterval <= blockInts) {
 
         if (DEBUG) {
           System.out.println("    try skipper");
@@ -1282,7 +1378,7 @@
           }
           skipper = new BlockSkipReader((IndexInput) docIn.clone(),
                                         BlockPostingsWriter.maxSkipLevels,
-                                        blockSize,
+                                        skipInterval,
                                         true,
                                         indexHasOffsets,
                                         indexHasPayloads);
@@ -1295,7 +1391,8 @@
           if (DEBUG) {
             System.out.println("    init skipper");
           }
-          skipper.init(docTermStartFP+skipOffset, docTermStartFP, posTermStartFP, payTermStartFP, docFreq);
+          int fakedf = docFreq % blockSize == 0? docFreq - 1: blockInts + skipInterval - 1;
+          skipper.init(docTermStartFP+skipOffset, docTermStartFP, posTermStartFP, payTermStartFP, fakedf);
           skipped = true;
         }
 
@@ -1308,11 +1405,10 @@
             System.out.println("    skipper moved to docUpto=" + newDocUpto + " vs current=" + docUpto + "; docID=" + skipper.getDoc() + " fp=" + skipper.getDocPointer() + " pos.fp=" + skipper.getPosPointer() + " pos.bufferUpto=" + skipper.getPosBufferUpto() + " pay.fp=" + skipper.getPayPointer() + " lastStartOffset=" + lastStartOffset);
           }
 
-          assert newDocUpto % blockSize == (blockSize-1): "got " + newDocUpto;
+          assert newDocUpto % skipInterval == (skipInterval-1): "got " + newDocUpto;
           docUpto = newDocUpto+1;
 
-          // Force block read next:
-          docBufferUpto = blockSize;
+          maxDocBufferUpto = docBufferUpto = skipInterval;
           accum = skipper.getDoc();
           docIn.seek(skipper.getDocPointer());
           posPendingFP = skipper.getPosPointer();
