diff --git a/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiQueryMaker.java b/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiQueryMaker.java
index 2e070c9..9471472 100644
--- a/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiQueryMaker.java
+++ b/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiQueryMaker.java
@@ -28,10 +28,10 @@ import org.apache.lucene.queryparser.classic.QueryParser;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.search.spans.SpanFirstQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanFirstQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.benchmark.byTask.tasks.NewAnalyzerTask;
 
 /**
diff --git a/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java b/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java
index 3425f42..ca8dee0 100644
--- a/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java
+++ b/lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java
@@ -22,10 +22,10 @@ import org.apache.lucene.index.Term;
 import org.apache.lucene.queryparser.classic.QueryParser;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.search.spans.SpanFirstQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanFirstQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.benchmark.byTask.tasks.NewAnalyzerTask;
 
 import java.util.ArrayList;
diff --git a/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java b/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
index 53e3753..1698f60 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
@@ -23,7 +23,6 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
 
-import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.util.CollectionUtil;
 
 /** A conjunction of DocIdSetIterators.
diff --git a/lucene/core/src/java/org/apache/lucene/search/ConjunctionSpans.java b/lucene/core/src/java/org/apache/lucene/search/ConjunctionSpans.java
new file mode 100644
index 0000000..afc234e
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/ConjunctionSpans.java
@@ -0,0 +1,118 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.List;
+
+/**
+ * Common super class for multiple sub spans required in a document.
+ */
+abstract class ConjunctionSpans extends Spans {
+  final Spans[] subSpans; // in query order
+  final DocIdSetIterator conjunction; // use to move to next doc with all clauses
+  boolean atFirstInCurrentDoc; // a first start position is available in current doc for nextStartPosition
+  boolean oneExhaustedInCurrentDoc; // one subspans exhausted in current doc
+
+  ConjunctionSpans(List<Spans> subSpans) {
+    if (subSpans.size() < 2) {
+      throw new IllegalArgumentException("Less than 2 subSpans.size():" + subSpans.size());
+    }
+    this.subSpans = subSpans.toArray(new Spans[subSpans.size()]);
+    this.conjunction = ConjunctionDISI.intersectSpans(subSpans);
+    this.atFirstInCurrentDoc = true; // ensure for doc -1 that start/end positions are -1
+  }
+
+  @Override
+  public int docID() {
+    return conjunction.docID();
+  }
+
+  @Override
+  public long cost() {
+    return conjunction.cost();
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    return (conjunction.nextDoc() == NO_MORE_DOCS)
+            ? NO_MORE_DOCS
+            : toMatchDoc();
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    return (conjunction.advance(target) == NO_MORE_DOCS)
+            ? NO_MORE_DOCS
+            : toMatchDoc();
+  }
+
+  int toMatchDoc() throws IOException {
+    oneExhaustedInCurrentDoc = false;
+    while (true) {
+      if (twoPhaseCurrentDocMatches()) {
+        return docID();
+      }
+      if (conjunction.nextDoc() == NO_MORE_DOCS) {
+        return NO_MORE_DOCS;
+      }
+    }
+  }
+
+
+  abstract boolean twoPhaseCurrentDocMatches() throws IOException;
+
+  /**
+   * Return a {@link TwoPhaseIterator} view of this ConjunctionSpans.
+   */
+  @Override
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    float totalMatchCost = 0;
+    // Compute the matchCost as the total matchCost/positionsCostant of the sub spans.
+    for (Spans spans : subSpans) {
+      TwoPhaseIterator tpi = spans.asTwoPhaseIterator();
+      if (tpi != null) {
+        totalMatchCost += tpi.matchCost();
+      } else {
+        totalMatchCost += spans.positionsCost();
+      }
+    }
+    final float matchCost = totalMatchCost;
+
+    return new TwoPhaseIterator(conjunction) {
+      @Override
+      public boolean matches() throws IOException {
+        return twoPhaseCurrentDocMatches();
+      }
+
+      @Override
+      public float matchCost() {
+        return matchCost;
+      }
+    };
+  }
+
+  @Override
+  public float positionsCost() {
+    throw new UnsupportedOperationException(); // asTwoPhaseIterator never returns null here.
+  }
+
+  public Spans[] getSubSpans() {
+    return subSpans;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/ContainSpans.java b/lucene/core/src/java/org/apache/lucene/search/ContainSpans.java
new file mode 100644
index 0000000..17a7235
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/ContainSpans.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Objects;
+
+abstract class ContainSpans extends ConjunctionSpans {
+  Spans sourceSpans;
+  Spans bigSpans;
+  Spans littleSpans;
+
+  ContainSpans(Spans bigSpans, Spans littleSpans, Spans sourceSpans) {
+    super(Arrays.asList(bigSpans, littleSpans));
+    this.bigSpans = Objects.requireNonNull(bigSpans);
+    this.littleSpans = Objects.requireNonNull(littleSpans);
+    this.sourceSpans = Objects.requireNonNull(sourceSpans);
+  }
+
+  @Override
+  public int startPosition() { 
+    return atFirstInCurrentDoc ? -1
+            : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
+            : sourceSpans.startPosition(); 
+  }
+
+  @Override
+  public int endPosition() { 
+    return atFirstInCurrentDoc ? -1
+            : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
+            : sourceSpans.endPosition(); 
+  }
+
+  @Override
+  public int width() {
+    return sourceSpans.width();
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    bigSpans.collect(collector);
+    littleSpans.collect(collector);
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisiWrapper.java b/lucene/core/src/java/org/apache/lucene/search/DisiWrapper.java
index f254340..3ea8196 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisiWrapper.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisiWrapper.java
@@ -17,8 +17,6 @@
 package org.apache.lucene.search;
 
 
-import org.apache.lucene.search.spans.Spans;
-
 /**
  * Wrapper used in {@link DisiPriorityQueue}.
  * @lucene.internal
diff --git a/lucene/core/src/java/org/apache/lucene/search/FieldMaskingSpanQuery.java b/lucene/core/src/java/org/apache/lucene/search/FieldMaskingSpanQuery.java
new file mode 100644
index 0000000..ddf6546
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/FieldMaskingSpanQuery.java
@@ -0,0 +1,134 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import org.apache.lucene.index.IndexReader;
+
+import java.io.IOException;
+import java.util.Objects;
+
+/**
+ * <p>Wrapper to allow {@link SpanQuery} objects participate in composite
+ * single-field SpanQueries by 'lying' about their search field. That is, 
+ * the masked SpanQuery will function as normal, 
+ * but {@link SpanQuery#getField()} simply hands back the value supplied 
+ * in this class's constructor.</p>
+ * 
+ * <p>This can be used to support Queries like {@link SpanNearQuery} or
+ * {@link SpanOrQuery} across different fields, which is not ordinarily
+ * permitted.</p>
+ * 
+ * <p>This can be useful for denormalized relational data: for example, when 
+ * indexing a document with conceptually many 'children': </p>
+ * 
+ * <pre>
+ *  teacherid: 1
+ *  studentfirstname: james
+ *  studentsurname: jones
+ *  
+ *  teacherid: 2
+ *  studenfirstname: james
+ *  studentsurname: smith
+ *  studentfirstname: sally
+ *  studentsurname: jones
+ * </pre>
+ * 
+ * <p>a SpanNearQuery with a slop of 0 can be applied across two 
+ * {@link SpanTermQuery} objects as follows:
+ * <pre class="prettyprint">
+ *    SpanQuery q1  = new SpanTermQuery(new Term("studentfirstname", "james"));
+ *    SpanQuery q2  = new SpanTermQuery(new Term("studentsurname", "jones"));
+ *    SpanQuery q2m = new FieldMaskingSpanQuery(q2, "studentfirstname");
+ *    Query q = new SpanNearQuery(new SpanQuery[]{q1, q2m}, -1, false);
+ * </pre>
+ * to search for 'studentfirstname:james studentsurname:jones' and find 
+ * teacherid 1 without matching teacherid 2 (which has a 'james' in position 0 
+ * and 'jones' in position 1).
+ * 
+ * <p>Note: as {@link #getField()} returns the masked field, scoring will be 
+ * done using the Similarity and collection statistics of the field name supplied,
+ * but with the term statistics of the real field. This may lead to exceptions,
+ * poor performance, and unexpected scoring behaviour.
+ */
+public final class FieldMaskingSpanQuery extends SpanQuery {
+  private final SpanQuery maskedQuery;
+  private final String field;
+    
+  public FieldMaskingSpanQuery(SpanQuery maskedQuery, String maskedField) {
+    this.maskedQuery = Objects.requireNonNull(maskedQuery);
+    this.field = Objects.requireNonNull(maskedField);
+  }
+
+  @Override
+  public String getField() {
+    return field;
+  }
+
+  public SpanQuery getMaskedQuery() {
+    return maskedQuery;
+  }
+
+  // :NOTE: getBoost and setBoost are not proxied to the maskedQuery
+  // ...this is done to be more consistent with things like SpanFirstQuery
+
+  @Override
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    return maskedQuery.createWeight(searcher, needsScores);
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    FieldMaskingSpanQuery clone = null;
+
+    SpanQuery rewritten = (SpanQuery) maskedQuery.rewrite(reader);
+    if (rewritten != maskedQuery) {
+      return new FieldMaskingSpanQuery(rewritten, field);
+    }
+
+    return super.rewrite(reader);
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("mask(");
+    buffer.append(maskedQuery.toString(field));
+    buffer.append(")");
+    buffer.append(" as ");
+    buffer.append(this.field);
+    return buffer.toString();
+  }
+  
+  @Override
+  public boolean equals(Object o) {
+    if (! super.equals(o)) {
+      return false;
+    }
+    FieldMaskingSpanQuery other = (FieldMaskingSpanQuery) o;
+    return (this.getField().equals(other.getField())
+            && this.getMaskedQuery().equals(other.getMaskedQuery()));
+
+  }
+  
+  @Override
+  public int hashCode() {
+    return super.hashCode()
+          ^ getMaskedQuery().hashCode()
+          ^ getField().hashCode();
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/FilterSpans.java b/lucene/core/src/java/org/apache/lucene/search/FilterSpans.java
new file mode 100644
index 0000000..82e0197
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/FilterSpans.java
@@ -0,0 +1,226 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.Objects;
+
+/**
+ * A {@link Spans} implementation wrapping another spans instance,
+ * allowing to filter spans matches easily by implementing {@link #accept}
+ */
+public abstract class FilterSpans extends Spans {
+ 
+  /** The wrapped spans instance. */
+  protected final Spans in;
+  
+  private boolean atFirstInCurrentDoc = false;
+  private int startPos = -1;
+  
+  /** Wrap the given {@link Spans}. */
+  protected FilterSpans(Spans in) {
+    this.in = Objects.requireNonNull(in);
+  }
+  
+  /** 
+   * Returns YES if the candidate should be an accepted match,
+   * NO if it should not, and NO_MORE_IN_CURRENT_DOC if iteration
+   * should move on to the next document.
+   */
+  protected abstract AcceptStatus accept(Spans candidate) throws IOException;
+  
+  @Override
+  public final int nextDoc() throws IOException {
+    while (true) {
+      int doc = in.nextDoc();
+      if (doc == NO_MORE_DOCS) {
+        return NO_MORE_DOCS;
+      } else if (twoPhaseCurrentDocMatches()) {
+        return doc;
+      }
+    }
+  }
+
+  @Override
+  public final int advance(int target) throws IOException {
+    int doc = in.advance(target);
+    while (doc != NO_MORE_DOCS) {
+      if (twoPhaseCurrentDocMatches()) {
+        break;
+      }
+      doc = in.nextDoc();
+    }
+
+    return doc;
+  }
+
+  @Override
+  public final int docID() {
+    return in.docID();
+  }
+
+  @Override
+  public final int nextStartPosition() throws IOException {
+    if (atFirstInCurrentDoc) {
+      atFirstInCurrentDoc = false;
+      return startPos;
+    }
+
+    for (;;) {
+      startPos = in.nextStartPosition();
+      if (startPos == NO_MORE_POSITIONS) {
+        return NO_MORE_POSITIONS;
+      }
+      switch(accept(in)) {
+        case YES:
+          return startPos;
+        case NO:
+          break;
+        case NO_MORE_IN_CURRENT_DOC:
+          return startPos = NO_MORE_POSITIONS; // startPos ahead for the current doc.
+      }
+    }
+  }
+
+  @Override
+  public final int startPosition() {
+    return atFirstInCurrentDoc ? -1 : startPos;
+  }
+
+  @Override
+  public final int endPosition() {
+    return atFirstInCurrentDoc ? -1
+          : (startPos != NO_MORE_POSITIONS) ? in.endPosition() : NO_MORE_POSITIONS;
+  }
+
+  @Override
+  public int width() {
+    return in.width();
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    in.collect(collector);
+  }
+
+  @Override
+  public final long cost() {
+    return in.cost();
+  }
+  
+  @Override
+  public String toString() {
+    return "Filter(" + in.toString() + ")";
+  }
+  
+  @Override
+  public final TwoPhaseIterator asTwoPhaseIterator() {
+    TwoPhaseIterator inner = in.asTwoPhaseIterator();
+    if (inner != null) {
+      // wrapped instance has an approximation
+      return new TwoPhaseIterator(inner.approximation()) {
+        @Override
+        public boolean matches() throws IOException {
+          return inner.matches() && twoPhaseCurrentDocMatches();
+        }
+
+        @Override
+        public float matchCost() {
+          return inner.matchCost(); // underestimate
+        }
+
+        @Override
+        public String toString() {
+          return "FilterSpans@asTwoPhaseIterator(inner=" + inner + ", in=" + in + ")";
+        }
+      };
+    } else {
+      // wrapped instance has no approximation, but 
+      // we can still defer matching until absolutely needed.
+      return new TwoPhaseIterator(in) {
+        @Override
+        public boolean matches() throws IOException {
+          return twoPhaseCurrentDocMatches();
+        }
+
+        @Override
+        public float matchCost() {
+          return in.positionsCost(); // overestimate
+        }
+
+        @Override
+        public String toString() {
+          return "FilterSpans@asTwoPhaseIterator(in=" + in + ")";
+        }
+      };
+    }
+  }
+  
+  @Override
+  public float positionsCost() {
+    throw new UnsupportedOperationException(); // asTwoPhaseIterator never returns null
+  }
+
+  /**
+   * Returns true if the current document matches.
+   * <p>
+   * This is called during two-phase processing.
+   */
+  // return true if the current document matches
+  @SuppressWarnings("fallthrough")
+  private final boolean twoPhaseCurrentDocMatches() throws IOException {
+    atFirstInCurrentDoc = false;
+    startPos = in.nextStartPosition();
+    assert startPos != NO_MORE_POSITIONS;
+    for (;;) {
+      switch(accept(in)) {
+        case YES:
+          atFirstInCurrentDoc = true;
+          return true;
+        case NO:
+          startPos = in.nextStartPosition();
+          if (startPos != NO_MORE_POSITIONS) {
+            break;
+          }
+          // else fallthrough
+        case NO_MORE_IN_CURRENT_DOC:
+          startPos = -1;
+          return false;
+      }
+    }
+  }
+
+  /**
+   * Status returned from {@link FilterSpans#accept(Spans)} that indicates
+   * whether a candidate match should be accepted, rejected, or rejected
+   * and move on to the next document.
+   */
+  public static enum AcceptStatus {
+    /** Indicates the match should be accepted */
+    YES,
+
+    /** Indicates the match should be rejected */
+    NO,
+
+    /**
+     * Indicates the match should be rejected, and the enumeration may continue
+     * with the next document.
+     */
+    NO_MORE_IN_CURRENT_DOC
+  };
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/NearSpansOrdered.java b/lucene/core/src/java/org/apache/lucene/search/NearSpansOrdered.java
new file mode 100644
index 0000000..abc8b1a
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/NearSpansOrdered.java
@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.List;
+
+/**
+ * A Spans that is formed from the ordered subspans of a SpanNearQuery
+ * where the subspans do not overlap and have a maximum slop between them.
+ * <p>
+ * The formed spans only contains minimum slop matches.<br>
+ * The matching slop is computed from the distance(s) between
+ * the non overlapping matching Spans.<br>
+ * Successive matches are always formed from the successive Spans
+ * of the SpanNearQuery.
+ * <p>
+ * The formed spans may contain overlaps when the slop is at least 1.
+ * For example, when querying using
+ * <pre>t1 t2 t3</pre>
+ * with slop at least 1, the fragment:
+ * <pre>t1 t2 t1 t3 t2 t3</pre>
+ * matches twice:
+ * <pre>t1 t2 .. t3      </pre>
+ * <pre>      t1 .. t2 t3</pre>
+ *
+ * Expert:
+ * Only public for subclassing.  Most implementations should not need this class
+ */
+public class NearSpansOrdered extends ConjunctionSpans {
+
+  protected int matchStart = -1;
+  protected int matchEnd = -1;
+  protected int matchWidth = -1;
+
+  private final int allowedSlop;
+
+  public NearSpansOrdered(int allowedSlop, List<Spans> subSpans) throws IOException {
+    super(subSpans);
+    this.atFirstInCurrentDoc = true; // -1 startPosition/endPosition also at doc -1
+    this.allowedSlop = allowedSlop;
+  }
+
+  @Override
+  boolean twoPhaseCurrentDocMatches() throws IOException {
+    assert unpositioned();
+    oneExhaustedInCurrentDoc = false;
+    while (subSpans[0].nextStartPosition() != NO_MORE_POSITIONS && !oneExhaustedInCurrentDoc) {
+      if (stretchToOrder() && matchWidth <= allowedSlop) {
+        return atFirstInCurrentDoc = true;
+      }
+    }
+    return false;
+  }
+
+  private boolean unpositioned() {
+    for (Spans span : subSpans) {
+      if (span.startPosition() != -1)
+        return false;
+    }
+    return true;
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    if (atFirstInCurrentDoc) {
+      atFirstInCurrentDoc = false;
+      return matchStart;
+    }
+    oneExhaustedInCurrentDoc = false;
+    while (subSpans[0].nextStartPosition() != NO_MORE_POSITIONS && !oneExhaustedInCurrentDoc) {
+      if (stretchToOrder() && matchWidth <= allowedSlop) {
+        return matchStart;
+      }
+    }
+    return matchStart = matchEnd = NO_MORE_POSITIONS;
+  }
+
+  /**
+   * Order the subSpans within the same document by using nextStartPosition on all subSpans
+   * after the first as little as necessary.
+   * Return true when the subSpans could be ordered in this way,
+   * otherwise at least one is exhausted in the current doc.
+   */
+  private boolean stretchToOrder() throws IOException {
+    Spans prevSpans = subSpans[0];
+    matchStart = prevSpans.startPosition();
+    assert prevSpans.startPosition() != NO_MORE_POSITIONS : "prevSpans no start position "+prevSpans;
+    assert prevSpans.endPosition() != NO_MORE_POSITIONS;
+    matchWidth = 0;
+    for (int i = 1; i < subSpans.length; i++) {
+      Spans spans = subSpans[i];
+      assert spans.startPosition() != NO_MORE_POSITIONS;
+      assert spans.endPosition() != NO_MORE_POSITIONS;
+      if (advancePosition(spans, prevSpans.endPosition()) == NO_MORE_POSITIONS) {
+        oneExhaustedInCurrentDoc = true;
+        return false;
+      }
+      matchWidth += (spans.startPosition() - prevSpans.endPosition());
+      prevSpans = spans;
+    }
+    matchEnd = subSpans[subSpans.length - 1].endPosition();
+    return true; // all subSpans ordered and non overlapping
+  }
+
+  private static int advancePosition(Spans spans, int position) throws IOException {
+    if (spans instanceof SpanNearQuery.GapSpans) {
+      return ((SpanNearQuery.GapSpans)spans).skipToPosition(position);
+    }
+    while (spans.startPosition() < position) {
+      spans.nextStartPosition();
+    }
+    return spans.startPosition();
+  }
+
+  @Override
+  public int startPosition() {
+    return atFirstInCurrentDoc ? -1 : matchStart;
+  }
+
+  @Override
+  public int endPosition() {
+    return atFirstInCurrentDoc ? -1 : matchEnd;
+  }
+
+  @Override
+  public int width() {
+    return matchWidth;
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    for (Spans span : subSpans) {
+      span.collect(collector);
+    }
+  }
+
+}
+
diff --git a/lucene/core/src/java/org/apache/lucene/search/NearSpansUnordered.java b/lucene/core/src/java/org/apache/lucene/search/NearSpansUnordered.java
new file mode 100644
index 0000000..8c76da9
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/NearSpansUnordered.java
@@ -0,0 +1,267 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.util.PriorityQueue;
+
+/**
+ * Similar to {@link NearSpansOrdered}, but for the unordered case.
+ *
+ * Expert:
+ * Only public for subclassing.  Most implementations should not need this class
+ */
+public class NearSpansUnordered extends ConjunctionSpans {
+
+  private List<SpansCell> subSpanCells; // in query order
+  private final int allowedSlop;
+
+  private SpanPositionQueue spanPositionQueue;
+
+  public NearSpansUnordered(int allowedSlop, List<Spans> subSpans)
+  throws IOException {
+    super(subSpans);
+
+    this.subSpanCells = new ArrayList<>(subSpans.size());
+    for (Spans subSpan : subSpans) { // sub spans in query order
+      this.subSpanCells.add(new SpansCell(subSpan));
+    }
+    spanPositionQueue = new SpanPositionQueue(subSpans.size());
+    singleCellToPositionQueue(); // -1 startPosition/endPosition also at doc -1
+    this.allowedSlop = allowedSlop;
+  }
+
+  private void singleCellToPositionQueue() {
+    maxEndPositionCell = subSpanCells.get(0);
+    assert maxEndPositionCell.docID() == -1;
+    assert maxEndPositionCell.startPosition() == -1;
+    spanPositionQueue.add(maxEndPositionCell);
+  }
+
+  private void subSpanCellsToPositionQueue() throws IOException { // used when all subSpanCells arrived at the same doc.
+    spanPositionQueue.clear();
+    for (SpansCell cell : subSpanCells) {
+      assert cell.startPosition() == -1;
+      cell.nextStartPosition();
+      assert cell.startPosition() != NO_MORE_POSITIONS;
+      spanPositionQueue.add(cell);
+    }
+  }
+
+  /** SpansCell wraps a sub Spans to maintain totalSpanLength and maxEndPositionCell */
+  private int totalSpanLength;
+  private SpansCell maxEndPositionCell;
+
+  private class SpansCell extends Spans {
+    private int spanLength = -1;
+    final Spans in;
+
+    public SpansCell(Spans spans) {
+      this.in = spans;
+    }
+
+    @Override
+    public int nextStartPosition() throws IOException {
+      int res = in.nextStartPosition();
+      if (res != NO_MORE_POSITIONS) {
+        adjustLength();
+      }
+      adjustMax(); // also after last end position in current doc.
+      return res;
+    }
+
+    private void adjustLength() {
+      if (spanLength != -1) {
+        totalSpanLength -= spanLength;  // subtract old, possibly from a previous doc
+      }
+      assert in.startPosition() != NO_MORE_POSITIONS;
+      spanLength = endPosition() - startPosition();
+      assert spanLength >= 0;
+      totalSpanLength += spanLength; // add new
+    }
+
+    private void adjustMax() {
+      assert docID() == maxEndPositionCell.docID();
+      if (endPosition() > maxEndPositionCell.endPosition()) {
+        maxEndPositionCell = this;
+      }
+    }
+
+    @Override
+    public int startPosition() {
+      return in.startPosition();
+    }
+
+    @Override
+    public int endPosition() {
+      return in.endPosition();
+    }
+
+    @Override
+    public int width() {
+      return in.width();
+    }
+
+    @Override
+    public void collect(SpanCollector collector) throws IOException {
+      in.collect(collector);
+    }
+
+    @Override
+    public TwoPhaseIterator asTwoPhaseIterator() {
+      return in.asTwoPhaseIterator();
+    }
+
+    @Override
+    public float positionsCost() {
+      return in.positionsCost();
+    }
+
+    @Override
+    public int docID() {
+      return in.docID();
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      return in.nextDoc();
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      return in.advance(target);
+    }
+
+    @Override
+    public long cost() {
+      return in.cost();
+    }
+
+    @Override
+    public String toString() {
+      return "NearSpansUnordered.SpansCell(" + in.toString() + ")";
+    }
+  }
+
+
+  private static class SpanPositionQueue extends PriorityQueue<SpansCell> {
+    public SpanPositionQueue(int size) {
+      super(size);
+    }
+
+    @Override
+    protected final boolean lessThan(SpansCell spans1, SpansCell spans2) {
+      return positionsOrdered(spans1, spans2);
+    }
+  }
+
+  /** Check whether two Spans in the same document are ordered with possible overlap.
+   * @return true iff spans1 starts before spans2
+   *              or the spans start at the same position,
+   *              and spans1 ends before spans2.
+   */
+  static boolean positionsOrdered(Spans spans1, Spans spans2) {
+    assert spans1.docID() == spans2.docID() : "doc1 " + spans1.docID() + " != doc2 " + spans2.docID();
+    int start1 = spans1.startPosition();
+    int start2 = spans2.startPosition();
+    return (start1 == start2) ? (spans1.endPosition() < spans2.endPosition()) : (start1 < start2);
+  }
+
+  private SpansCell minPositionCell() {
+    return spanPositionQueue.top();
+  }
+
+  private boolean atMatch() {
+    assert minPositionCell().docID() == maxEndPositionCell.docID();
+    return (maxEndPositionCell.endPosition() - minPositionCell().startPosition() - totalSpanLength) <= allowedSlop;
+  }
+
+  @Override
+  boolean twoPhaseCurrentDocMatches() throws IOException {
+    // at doc with all subSpans
+    subSpanCellsToPositionQueue();
+    while (true) {
+      if (atMatch()) {
+        atFirstInCurrentDoc = true;
+        oneExhaustedInCurrentDoc = false;
+        return true;
+      }
+      assert minPositionCell().startPosition() != NO_MORE_POSITIONS;
+      if (minPositionCell().nextStartPosition() != NO_MORE_POSITIONS) {
+        spanPositionQueue.updateTop();
+      }
+      else { // exhausted a subSpan in current doc
+        return false;
+      }
+    }
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    if (atFirstInCurrentDoc) {
+      atFirstInCurrentDoc = false;
+      return minPositionCell().startPosition();
+    }
+    while (minPositionCell().startPosition() == -1) { // initially at current doc
+      minPositionCell().nextStartPosition();
+      spanPositionQueue.updateTop();
+    }
+    assert minPositionCell().startPosition() != NO_MORE_POSITIONS;
+    while (true) {
+      if (minPositionCell().nextStartPosition() == NO_MORE_POSITIONS) {
+        oneExhaustedInCurrentDoc = true;
+        return NO_MORE_POSITIONS;
+      }
+      spanPositionQueue.updateTop();
+      if (atMatch()) {
+        return minPositionCell().startPosition();
+      }
+    }
+  }
+
+  @Override
+  public int startPosition() {
+    assert minPositionCell() != null;
+    return atFirstInCurrentDoc ? -1
+          : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
+          : minPositionCell().startPosition();
+  }
+
+  @Override
+  public int endPosition() {
+    return atFirstInCurrentDoc ? -1
+          : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
+          : maxEndPositionCell.endPosition();
+  }
+
+  @Override
+  public int width() {
+    return maxEndPositionCell.startPosition() - minPositionCell().startPosition();
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    for (SpansCell cell : subSpanCells) {
+      cell.collect(collector);
+    }
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/ScoringWrapperSpans.java b/lucene/core/src/java/org/apache/lucene/search/ScoringWrapperSpans.java
new file mode 100644
index 0000000..c02a379
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/ScoringWrapperSpans.java
@@ -0,0 +1,94 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+
+import org.apache.lucene.search.similarities.Similarity;
+
+/**
+ * A Spans that wraps another Spans with a different SimScorer
+ */
+public class ScoringWrapperSpans extends Spans {
+
+  private final Spans in;
+
+  /**
+   * Creates a new ScoringWrapperSpans
+   * @param spans the scorer to wrap
+   * @param simScorer  the SimScorer to use for scoring
+   */
+  public ScoringWrapperSpans(Spans spans, Similarity.SimScorer simScorer) {
+    this.in = spans;
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    return in.nextStartPosition();
+  }
+
+  @Override
+  public int startPosition() {
+    return in.startPosition();
+  }
+
+  @Override
+  public int endPosition() {
+    return in.endPosition();
+  }
+
+  @Override
+  public int width() {
+    return in.width();
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    in.collect(collector);
+  }
+
+  @Override
+  public int docID() {
+    return in.docID();
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    return in.nextDoc();
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    return in.advance(target);
+  }
+
+  @Override
+  public long cost() {
+    return in.cost();
+  }
+
+  @Override
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    return in.asTwoPhaseIterator();
+  }
+
+  @Override
+  public float positionsCost() {
+    return in.positionsCost();
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanBoostQuery.java b/lucene/core/src/java/org/apache/lucene/search/SpanBoostQuery.java
new file mode 100644
index 0000000..ee47f3c
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanBoostQuery.java
@@ -0,0 +1,160 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.TreeMap;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+
+/**
+ * Counterpart of {@link BoostQuery} for spans.
+ */
+public final class SpanBoostQuery extends SpanQuery {
+
+  private final SpanQuery query;
+  private final float boost;
+
+  /** Sole constructor: wrap {@code query} in such a way that the produced
+   *  scores will be boosted by {@code boost}. */
+  public SpanBoostQuery(SpanQuery query, float boost) {
+    this.query = Objects.requireNonNull(query);
+    this.boost = boost;
+  }
+
+  /**
+   * Return the wrapped {@link SpanQuery}.
+   */
+  public SpanQuery getQuery() {
+    return query;
+  }
+
+  /**
+   * Return the applied boost.
+   */
+  public float getBoost() {
+    return boost;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (super.equals(obj) == false) {
+      return false;
+    }
+    SpanBoostQuery that = (SpanBoostQuery) obj;
+    return query.equals(that.query)
+        && Float.floatToIntBits(boost) == Float.floatToIntBits(that.boost);
+  }
+
+  @Override
+  public int hashCode() {
+    int h = super.hashCode();
+    h = 31 * h + query.hashCode();
+    h = 31 * h + Float.floatToIntBits(boost);
+    return h;
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    if (boost == 1f) {
+      return query;
+    }
+
+    final SpanQuery rewritten = (SpanQuery) query.rewrite(reader);
+    if (query != rewritten) {
+      return new SpanBoostQuery(rewritten, boost);
+    }
+
+    if (query.getClass() == SpanBoostQuery.class) {
+      SpanBoostQuery in = (SpanBoostQuery) query;
+      return new SpanBoostQuery(in.query, boost * in.boost);
+    }
+
+    return super.rewrite(reader);
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder builder = new StringBuilder();
+    builder.append("(");
+    builder.append(query.toString(field));
+    builder.append(")^");
+    builder.append(boost);
+    return builder.toString();
+  }
+
+  @Override
+  public String getField() {
+    return query.getField();
+  }
+
+  @Override
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    final SpanWeight weight = query.createWeight(searcher, needsScores);
+    if (needsScores == false) {
+      return weight;
+    }
+    Map<Term, TermContext> terms = new TreeMap<>();
+    weight.extractTermContexts(terms);
+    weight.normalize(1f, boost);
+    return new SpanWeight(this, searcher, terms) {
+      
+      @Override
+      public void extractTerms(Set<Term> terms) {
+        weight.extractTerms(terms);
+      }
+
+      @Override
+      public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+        return weight.explain(context, doc);
+      }
+
+      @Override
+      public float getValueForNormalization() throws IOException {
+        return weight.getValueForNormalization();
+      }
+
+      @Override
+      public void normalize(float norm, float boost) {
+        weight.normalize(norm, SpanBoostQuery.this.boost * boost);
+      }
+      
+      @Override
+      public Spans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
+        return weight.getSpans(ctx, requiredPostings);
+      }
+
+      @Override
+      public SpanScorer scorer(LeafReaderContext context) throws IOException {
+        return weight.scorer(context);
+      }
+
+      @Override
+      public void extractTermContexts(Map<Term,TermContext> contexts) {
+        weight.extractTermContexts(contexts);
+      }
+    };
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanCollector.java b/lucene/core/src/java/org/apache/lucene/search/SpanCollector.java
new file mode 100644
index 0000000..d9116ae
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanCollector.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.Term;
+
+import java.io.IOException;
+
+/**
+ * An interface defining the collection of postings information from the leaves
+ * of a {@link Spans}
+ *
+ * @lucene.experimental
+ */
+public interface SpanCollector {
+
+  /**
+   * Collect information from postings
+   * @param postings a {@link PostingsEnum}
+   * @param position the position of the PostingsEnum
+   * @param term     the {@link Term} for this postings list
+   * @throws IOException on error
+   */
+  public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException;
+
+  /**
+   * Call to indicate that the driving Spans has moved to a new position
+   */
+  public void reset();
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanContainQuery.java b/lucene/core/src/java/org/apache/lucene/search/SpanContainQuery.java
new file mode 100644
index 0000000..b577ebe
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanContainQuery.java
@@ -0,0 +1,146 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+abstract class SpanContainQuery extends SpanQuery implements Cloneable {
+
+  SpanQuery big;
+  SpanQuery little;
+
+  SpanContainQuery(SpanQuery big, SpanQuery little) {
+    this.big = Objects.requireNonNull(big);
+    this.little = Objects.requireNonNull(little);
+    Objects.requireNonNull(big.getField());
+    Objects.requireNonNull(little.getField());
+    if (! big.getField().equals(little.getField())) {
+      throw new IllegalArgumentException("big and little not same field");
+    }
+  }
+
+  @Override
+  public String getField() { return big.getField(); }
+  
+  public SpanQuery getBig() {
+    return big;
+  }
+
+  public SpanQuery getLittle() {
+    return little;
+  }
+
+  public abstract class SpanContainWeight extends SpanWeight {
+
+    final SpanWeight bigWeight;
+    final SpanWeight littleWeight;
+
+    public SpanContainWeight(IndexSearcher searcher, Map<Term, TermContext> terms,
+                             SpanWeight bigWeight, SpanWeight littleWeight) throws IOException {
+      super(SpanContainQuery.this, searcher, terms);
+      this.bigWeight = bigWeight;
+      this.littleWeight = littleWeight;
+    }
+
+    /**
+     * Extract terms from both <code>big</code> and <code>little</code>.
+     */
+    @Override
+    public void extractTerms(Set<Term> terms) {
+      bigWeight.extractTerms(terms);
+      littleWeight.extractTerms(terms);
+    }
+
+    ArrayList<Spans> prepareConjunction(final LeafReaderContext context, Postings postings) throws IOException {
+      Spans bigSpans = bigWeight.getSpans(context, postings);
+      if (bigSpans == null) {
+        return null;
+      }
+      Spans littleSpans = littleWeight.getSpans(context, postings);
+      if (littleSpans == null) {
+        return null;
+      }
+      ArrayList<Spans> bigAndLittle = new ArrayList<>();
+      bigAndLittle.add(bigSpans);
+      bigAndLittle.add(littleSpans);
+      return bigAndLittle;
+    }
+
+    @Override
+    public void extractTermContexts(Map<Term, TermContext> contexts) {
+      bigWeight.extractTermContexts(contexts);
+      littleWeight.extractTermContexts(contexts);
+    }
+
+  }
+
+  String toString(String field, String name) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append(name);
+    buffer.append("(");
+    buffer.append(big.toString(field));
+    buffer.append(", ");
+    buffer.append(little.toString(field));
+    buffer.append(")");
+    return buffer.toString();
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    SpanQuery rewrittenBig = (SpanQuery) big.rewrite(reader);
+    SpanQuery rewrittenLittle = (SpanQuery) little.rewrite(reader);
+    if (big != rewrittenBig || little != rewrittenLittle) {
+      try {
+        SpanContainQuery clone = (SpanContainQuery) super.clone();
+        clone.big = rewrittenBig;
+        clone.little = rewrittenLittle;
+        return clone;
+      } catch (CloneNotSupportedException e) {
+        throw new AssertionError(e);
+      }
+    }
+    return super.rewrite(reader);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (! super.equals(o)) {
+      return false;
+    }
+    SpanContainQuery other = (SpanContainQuery)o;
+    return big.equals(other.big) && little.equals(other.little);
+  }
+
+  @Override
+  public int hashCode() {
+    int h = Integer.rotateLeft(super.hashCode(), 1);
+    h ^= big.hashCode();
+    h = Integer.rotateLeft(h, 1);
+    h ^= little.hashCode();
+    return h;
+  }
+}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanContainingQuery.java b/lucene/core/src/java/org/apache/lucene/search/SpanContainingQuery.java
new file mode 100644
index 0000000..29df98f
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanContainingQuery.java
@@ -0,0 +1,118 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Map;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+
+/** Keep matches that contain another SpanScorer. */
+public final class SpanContainingQuery extends SpanContainQuery {
+  /** Construct a SpanContainingQuery matching spans from <code>big</code>
+   * that contain at least one spans from <code>little</code>.
+   * This query has the boost of <code>big</code>.
+   * <code>big</code> and <code>little</code> must be in the same field.
+   */
+  public SpanContainingQuery(SpanQuery big, SpanQuery little) {
+    super(big, little);
+  }
+
+  @Override
+  public String toString(String field) {
+    return toString(field, "SpanContaining");
+  }
+
+  @Override
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    SpanWeight bigWeight = big.createWeight(searcher, false);
+    SpanWeight littleWeight = little.createWeight(searcher, false);
+    return new SpanContainingWeight(searcher, needsScores ? getTermContexts(bigWeight, littleWeight) : null,
+                                      bigWeight, littleWeight);
+  }
+
+  public class SpanContainingWeight extends SpanContainWeight {
+
+    public SpanContainingWeight(IndexSearcher searcher, Map<Term, TermContext> terms,
+                                SpanWeight bigWeight, SpanWeight littleWeight) throws IOException {
+      super(searcher, terms, bigWeight, littleWeight);
+    }
+
+    /**
+     * Return spans from <code>big</code> that contain at least one spans from <code>little</code>.
+     * The payload is from the spans of <code>big</code>.
+     */
+    @Override
+    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+      ArrayList<Spans> containerContained = prepareConjunction(context, requiredPostings);
+      if (containerContained == null) {
+        return null;
+      }
+
+      Spans big = containerContained.get(0);
+      Spans little = containerContained.get(1);
+
+      return new ContainSpans(big, little, big) {
+
+        @Override
+        boolean twoPhaseCurrentDocMatches() throws IOException {
+          oneExhaustedInCurrentDoc = false;
+          assert littleSpans.startPosition() == -1;
+          while (bigSpans.nextStartPosition() != NO_MORE_POSITIONS) {
+            while (littleSpans.startPosition() < bigSpans.startPosition()) {
+              if (littleSpans.nextStartPosition() == NO_MORE_POSITIONS) {
+                oneExhaustedInCurrentDoc = true;
+                return false;
+              }
+            }
+            if (bigSpans.endPosition() >= littleSpans.endPosition()) {
+              atFirstInCurrentDoc = true;
+              return true;
+            }
+          }
+          oneExhaustedInCurrentDoc = true;
+          return false;
+        }
+
+        @Override
+        public int nextStartPosition() throws IOException {
+          if (atFirstInCurrentDoc) {
+            atFirstInCurrentDoc = false;
+            return bigSpans.startPosition();
+          }
+          while (bigSpans.nextStartPosition() != NO_MORE_POSITIONS) {
+            while (littleSpans.startPosition() < bigSpans.startPosition()) {
+              if (littleSpans.nextStartPosition() == NO_MORE_POSITIONS) {
+                oneExhaustedInCurrentDoc = true;
+                return NO_MORE_POSITIONS;
+              }
+            }
+            if (bigSpans.endPosition() >= littleSpans.endPosition()) {
+              return bigSpans.startPosition();
+            }
+          }
+          oneExhaustedInCurrentDoc = true;
+          return NO_MORE_POSITIONS;
+        }
+      };
+    }
+  }
+}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanFirstQuery.java b/lucene/core/src/java/org/apache/lucene/search/SpanFirstQuery.java
new file mode 100644
index 0000000..3238cd1
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanFirstQuery.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import org.apache.lucene.search.FilterSpans.AcceptStatus;
+
+import java.io.IOException;
+
+/**
+ * Matches spans near the beginning of a field.
+ * <p>
+ * This class is a simple extension of {@link SpanPositionRangeQuery} in that it assumes the
+ * start to be zero and only checks the end boundary.
+ */
+public class SpanFirstQuery extends SpanPositionRangeQuery {
+
+  /** Construct a SpanFirstQuery matching spans in <code>match</code> whose end
+   * position is less than or equal to <code>end</code>. */
+  public SpanFirstQuery(SpanQuery match, int end) {
+    super(match, 0, end);
+  }
+
+  protected AcceptStatus acceptPosition(Spans spans) throws IOException {
+    assert spans.startPosition() != spans.endPosition() : "start equals end: " + spans.startPosition();
+    if (spans.startPosition() >= end)
+      return AcceptStatus.NO_MORE_IN_CURRENT_DOC;
+    else if (spans.endPosition() <= end)
+      return AcceptStatus.YES;
+    else
+      return AcceptStatus.NO;
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("spanFirst(");
+    buffer.append(match.toString(field));
+    buffer.append(", ");
+    buffer.append(end);
+    buffer.append(")");
+    return buffer.toString();
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanMultiTermQueryWrapper.java b/lucene/core/src/java/org/apache/lucene/search/SpanMultiTermQueryWrapper.java
new file mode 100644
index 0000000..dac8b01
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanMultiTermQueryWrapper.java
@@ -0,0 +1,247 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.BooleanClause.Occur;
+
+/**
+ * Wraps any {@link MultiTermQuery} as a {@link SpanQuery}, 
+ * so it can be nested within other SpanQuery classes.
+ * <p>
+ * The query is rewritten by default to a {@link SpanOrQuery} containing
+ * the expanded terms, but this can be customized. 
+ * <p>
+ * Example:
+ * <blockquote><pre class="prettyprint">
+ * {@code
+ * WildcardQuery wildcard = new WildcardQuery(new Term("field", "bro?n"));
+ * SpanQuery spanWildcard = new SpanMultiTermQueryWrapper<WildcardQuery>(wildcard);
+ * // do something with spanWildcard, such as use it in a SpanFirstQuery
+ * }
+ * </pre></blockquote>
+ */
+public class SpanMultiTermQueryWrapper<Q extends MultiTermQuery> extends SpanQuery {
+
+  protected final Q query;
+  private SpanRewriteMethod rewriteMethod;
+
+  /**
+   * Create a new SpanMultiTermQueryWrapper. 
+   * 
+   * @param query Query to wrap.
+   */
+  @SuppressWarnings({"rawtypes","unchecked"})
+  public SpanMultiTermQueryWrapper(Q query) {
+    this.query = Objects.requireNonNull(query);
+    this.rewriteMethod = selectRewriteMethod(query);
+  }
+
+  private static SpanRewriteMethod selectRewriteMethod(MultiTermQuery query) {
+    MultiTermQuery.RewriteMethod method = query.getRewriteMethod();
+    if (method instanceof TopTermsRewrite) {
+      final int pqsize = ((TopTermsRewrite) method).getSize();
+      return new TopTermsSpanBooleanQueryRewrite(pqsize);
+    } else {
+      return SCORING_SPAN_QUERY_REWRITE;
+    }
+  }
+
+  /**
+   * Expert: returns the rewriteMethod
+   */
+  public final SpanRewriteMethod getRewriteMethod() {
+    return rewriteMethod;
+  }
+
+  /**
+   * Expert: sets the rewrite method. This only makes sense
+   * to be a span rewrite method.
+   */
+  public final void setRewriteMethod(SpanRewriteMethod rewriteMethod) {
+    this.rewriteMethod = rewriteMethod;
+  }
+
+  @Override
+  public String getField() {
+    return query.getField();
+  }
+
+  @Override
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    throw new IllegalArgumentException("Rewrite first!");
+  }
+
+  /** Returns the wrapped query */
+  public Query getWrappedQuery() {
+    return query;
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder builder = new StringBuilder();
+    builder.append("SpanMultiTermQueryWrapper(");
+    // NOTE: query.toString must be placed in a temp local to avoid compile errors on Java 8u20
+    // see https://bugs.openjdk.java.net/browse/JDK-8056984?page=com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab
+    String queryStr = query.toString(field);
+    builder.append(queryStr);
+    builder.append(")");
+    return builder.toString();
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    return rewriteMethod.rewrite(reader, query);
+  }
+  
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = super.hashCode();
+    result = prime * result + query.hashCode();
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (! super.equals(obj)) {
+      return false;
+    }
+    SpanMultiTermQueryWrapper<?> other = (SpanMultiTermQueryWrapper<?>) obj;
+    return query.equals(other.query);
+  }
+
+  /** Abstract class that defines how the query is rewritten. */
+  public static abstract class SpanRewriteMethod extends MultiTermQuery.RewriteMethod {
+    @Override
+    public abstract SpanQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException;
+  }
+
+  /**
+   * A rewrite method that first translates each term into a SpanTermQuery in a
+   * {@link Occur#SHOULD} clause in a BooleanQuery, and keeps the
+   * scores as computed by the query.
+   * 
+   * @see #setRewriteMethod
+   */
+  public final static SpanRewriteMethod SCORING_SPAN_QUERY_REWRITE = new SpanRewriteMethod() {
+    private final ScoringRewrite<List<SpanQuery>> delegate = new ScoringRewrite<List<SpanQuery>>() {
+      @Override
+      protected List<SpanQuery> getTopLevelBuilder() {
+        return new ArrayList<SpanQuery>();
+      }
+
+      protected Query build(List<SpanQuery> builder) {
+        return new SpanOrQuery(builder.toArray(new SpanQuery[builder.size()]));
+      }
+
+      @Override
+      protected void checkMaxClauseCount(int count) {
+        // we accept all terms as SpanOrQuery has no limits
+      }
+    
+      @Override
+      protected void addClause(List<SpanQuery> topLevel, Term term, int docCount, float boost, TermContext states) {
+        final SpanTermQuery q = new SpanTermQuery(term, states);
+        topLevel.add(q);
+      }
+    };
+    
+    @Override
+    public SpanQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException {
+      return (SpanQuery) delegate.rewrite(reader, query);
+    }
+  };
+  
+  /**
+   * A rewrite method that first translates each term into a SpanTermQuery in a
+   * {@link Occur#SHOULD} clause in a BooleanQuery, and keeps the
+   * scores as computed by the query.
+   * 
+   * <p>
+   * This rewrite method only uses the top scoring terms so it will not overflow
+   * the boolean max clause count.
+   * 
+   * @see #setRewriteMethod
+   */
+  public static final class TopTermsSpanBooleanQueryRewrite extends SpanRewriteMethod  {
+    private final TopTermsRewrite<List<SpanQuery>> delegate;
+  
+    /** 
+     * Create a TopTermsSpanBooleanQueryRewrite for 
+     * at most <code>size</code> terms.
+     */
+    public TopTermsSpanBooleanQueryRewrite(int size) {
+      delegate = new TopTermsRewrite<List<SpanQuery>>(size) {
+        @Override
+        protected int getMaxSize() {
+          return Integer.MAX_VALUE;
+        }
+    
+        @Override
+        protected List<SpanQuery> getTopLevelBuilder() {
+          return new ArrayList<SpanQuery>();
+        }
+
+        @Override
+        protected Query build(List<SpanQuery> builder) {
+          return new SpanOrQuery(builder.toArray(new SpanQuery[builder.size()]));
+        }
+
+        @Override
+        protected void addClause(List<SpanQuery> topLevel, Term term, int docFreq, float boost, TermContext states) {
+          final SpanTermQuery q = new SpanTermQuery(term, states);
+          topLevel.add(q);
+        }
+      };
+    }
+    
+    /** return the maximum priority queue size */
+    public int getSize() {
+      return delegate.getSize();
+    }
+
+    @Override
+    public SpanQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException {
+      return (SpanQuery) delegate.rewrite(reader, query);
+    }
+  
+    @Override
+    public int hashCode() {
+      return 31 * delegate.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (this == obj) return true;
+      if (obj == null) return false;
+      if (getClass() != obj.getClass()) return false;
+      final TopTermsSpanBooleanQueryRewrite other = (TopTermsSpanBooleanQueryRewrite) obj;
+      return delegate.equals(other.delegate);
+    }
+    
+  }
+  
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanNearQuery.java b/lucene/core/src/java/org/apache/lucene/search/SpanNearQuery.java
new file mode 100644
index 0000000..077e723
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanNearQuery.java
@@ -0,0 +1,391 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.index.Terms;
+
+/** Matches spans which are near one another.  One can specify <i>slop</i>, the
+ * maximum number of intervening unmatched positions, as well as whether
+ * matches are required to be in-order.
+ */
+public class SpanNearQuery extends SpanQuery implements Cloneable {
+
+  /**
+   * A builder for SpanNearQueries
+   */
+  public static class Builder {
+    private final boolean ordered;
+    private final String field;
+    private final List<SpanQuery> clauses = new LinkedList<>();
+    private int slop;
+
+    /**
+     * Construct a new builder
+     * @param field the field to search in
+     * @param ordered whether or not clauses must be in-order to match
+     */
+    public Builder(String field, boolean ordered) {
+      this.field = field;
+      this.ordered = ordered;
+    }
+
+    /**
+     * Add a new clause
+     */
+    public Builder addClause(SpanQuery clause) {
+      if (Objects.equals(clause.getField(), field) == false)
+        throw new IllegalArgumentException("Cannot add clause " + clause + " to SpanNearQuery for field " + field);
+      this.clauses.add(clause);
+      return this;
+    }
+
+    /**
+     * Add a gap after the previous clause of a defined width
+     */
+    public Builder addGap(int width) {
+      if (!ordered)
+        throw new IllegalArgumentException("Gaps can only be added to ordered near queries");
+      this.clauses.add(new SpanGapQuery(field, width));
+      return this;
+    }
+
+    /**
+     * Set the slop for this query
+     */
+    public Builder setSlop(int slop) {
+      this.slop = slop;
+      return this;
+    }
+
+    /**
+     * Build the query
+     */
+    public SpanNearQuery build() {
+      return new SpanNearQuery(clauses.toArray(new SpanQuery[clauses.size()]), slop, ordered);
+    }
+
+  }
+
+  /**
+   * Returns a {@link Builder} for an ordered query on a particular field
+   */
+  public static Builder newOrderedNearQuery(String field) {
+    return new Builder(field, true);
+  }
+
+  /**
+   * Returns a {@link Builder} for an unordered query on a particular field
+   */
+  public static Builder newUnorderedNearQuery(String field) {
+    return new Builder(field, false);
+  }
+
+  protected List<SpanQuery> clauses;
+  protected int slop;
+  protected boolean inOrder;
+
+  protected String field;
+
+  /** Construct a SpanNearQuery.  Matches spans matching a span from each
+   * clause, with up to <code>slop</code> total unmatched positions between
+   * them.
+   * <br>When <code>inOrder</code> is true, the spans from each clause
+   * must be in the same order as in <code>clauses</code> and must be non-overlapping.
+   * <br>When <code>inOrder</code> is false, the spans from each clause
+   * need not be ordered and may overlap.
+   * @param clausesIn the clauses to find near each other, in the same field, at least 2.
+   * @param slop The slop value
+   * @param inOrder true if order is important
+   */
+  public SpanNearQuery(SpanQuery[] clausesIn, int slop, boolean inOrder) {
+    this.clauses = new ArrayList<>(clausesIn.length);
+    for (SpanQuery clause : clausesIn) {
+      if (this.field == null) {                               // check field
+        this.field = clause.getField();
+      } else if (clause.getField() != null && !clause.getField().equals(field)) {
+        throw new IllegalArgumentException("Clauses must have same field.");
+      }
+      this.clauses.add(clause);
+    }
+    this.slop = slop;
+    this.inOrder = inOrder;
+  }
+
+  /** Return the clauses whose spans are matched. */
+  public SpanQuery[] getClauses() {
+    return clauses.toArray(new SpanQuery[clauses.size()]);
+  }
+
+  /** Return the maximum number of intervening unmatched positions permitted.*/
+  public int getSlop() { return slop; }
+
+  /** Return true if matches are required to be in-order.*/
+  public boolean isInOrder() { return inOrder; }
+
+  @Override
+  public String getField() { return field; }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("spanNear([");
+    Iterator<SpanQuery> i = clauses.iterator();
+    while (i.hasNext()) {
+      SpanQuery clause = i.next();
+      buffer.append(clause.toString(field));
+      if (i.hasNext()) {
+        buffer.append(", ");
+      }
+    }
+    buffer.append("], ");
+    buffer.append(slop);
+    buffer.append(", ");
+    buffer.append(inOrder);
+    buffer.append(")");
+    return buffer.toString();
+  }
+
+  @Override
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    List<SpanWeight> subWeights = new ArrayList<>();
+    for (SpanQuery q : clauses) {
+      subWeights.add(q.createWeight(searcher, false));
+    }
+    return new SpanNearWeight(subWeights, searcher, needsScores ? getTermContexts(subWeights) : null);
+  }
+
+  public class SpanNearWeight extends SpanWeight {
+
+    final List<SpanWeight> subWeights;
+
+    public SpanNearWeight(List<SpanWeight> subWeights, IndexSearcher searcher, Map<Term, TermContext> terms) throws IOException {
+      super(SpanNearQuery.this, searcher, terms);
+      this.subWeights = subWeights;
+    }
+
+    @Override
+    public void extractTermContexts(Map<Term, TermContext> contexts) {
+      for (SpanWeight w : subWeights) {
+        w.extractTermContexts(contexts);
+      }
+    }
+
+    @Override
+    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+
+      Terms terms = context.reader().terms(field);
+      if (terms == null) {
+        return null; // field does not exist
+      }
+
+      ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());
+      for (SpanWeight w : subWeights) {
+        Spans subSpan = w.getSpans(context, requiredPostings);
+        if (subSpan != null) {
+          subSpans.add(subSpan);
+        } else {
+          return null; // all required
+        }
+      }
+
+      // all NearSpans require at least two subSpans
+      return (!inOrder) ? new NearSpansUnordered(slop, subSpans)
+          : new NearSpansOrdered(slop, subSpans);
+    }
+
+    @Override
+    public void extractTerms(Set<Term> terms) {
+      for (SpanWeight w : subWeights) {
+        w.extractTerms(terms);
+      }
+    }
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    boolean actuallyRewritten = false;
+    List<SpanQuery> rewrittenClauses = new ArrayList<>();
+    for (int i = 0 ; i < clauses.size(); i++) {
+      SpanQuery c = clauses.get(i);
+      SpanQuery query = (SpanQuery) c.rewrite(reader);
+      actuallyRewritten |= query != c;
+      rewrittenClauses.add(query);
+    }
+    if (actuallyRewritten) {
+      try {
+        SpanNearQuery rewritten = (SpanNearQuery) clone();
+        rewritten.clauses = rewrittenClauses;
+        return rewritten;
+      } catch (CloneNotSupportedException e) {
+        throw new AssertionError(e);
+      }
+    }
+    return super.rewrite(reader);
+  }
+
+  /** Returns true iff <code>o</code> is equal to this. */
+  @Override
+  public boolean equals(Object o) {
+    if (! super.equals(o)) {
+      return false;
+    }
+    final SpanNearQuery spanNearQuery = (SpanNearQuery) o;
+
+    return (inOrder == spanNearQuery.inOrder)
+        && (slop == spanNearQuery.slop)
+        && clauses.equals(spanNearQuery.clauses);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = super.hashCode();
+    result ^= clauses.hashCode();
+    result += slop;
+    int fac = 1 + (inOrder ? 8 : 4);
+    return fac * result;
+  }
+
+  private static class SpanGapQuery extends SpanQuery {
+
+    private final String field;
+    private final int width;
+
+    public SpanGapQuery(String field, int width) {
+      this.field = field;
+      this.width = width;
+    }
+
+    @Override
+    public String getField() {
+      return field;
+    }
+
+    @Override
+    public String toString(String field) {
+      return "SpanGap(" + field + ":" + width + ")";
+    }
+
+    @Override
+    public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+      return new SpanGapWeight(searcher);
+    }
+
+    private class SpanGapWeight extends SpanWeight {
+
+      SpanGapWeight(IndexSearcher searcher) throws IOException {
+        super(SpanGapQuery.this, searcher, null);
+      }
+
+      @Override
+      public void extractTermContexts(Map<Term, TermContext> contexts) {
+
+      }
+
+      @Override
+      public Spans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
+        return new GapSpans(width);
+      }
+
+      @Override
+      public void extractTerms(Set<Term> terms) {
+
+      }
+    }
+  }
+
+  static class GapSpans extends Spans {
+
+    int doc = -1;
+    int pos = -1;
+    final int width;
+
+    GapSpans(int width) {
+      this.width = width;
+    }
+
+    @Override
+    public int nextStartPosition() throws IOException {
+      return ++pos;
+    }
+
+    public int skipToPosition(int position) throws IOException {
+      return pos = position;
+    }
+
+    @Override
+    public int startPosition() {
+      return pos;
+    }
+
+    @Override
+    public int endPosition() {
+      return pos + width;
+    }
+
+    @Override
+    public int width() {
+      return width;
+    }
+
+    @Override
+    public void collect(SpanCollector collector) throws IOException {
+
+    }
+
+    @Override
+    public int docID() {
+      return doc;
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      pos = -1;
+      return ++doc;
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      pos = -1;
+      return doc = target;
+    }
+
+    @Override
+    public long cost() {
+      return 0;
+    }
+
+    @Override
+    public float positionsCost() {
+      throw new UnsupportedOperationException();
+    }
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanNotQuery.java b/lucene/core/src/java/org/apache/lucene/search/SpanNotQuery.java
new file mode 100644
index 0000000..9082600
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanNotQuery.java
@@ -0,0 +1,224 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+
+/** Removes matches which overlap with another SpanQuery or which are
+ * within x tokens before or y tokens after another SpanQuery.
+ */
+public final class SpanNotQuery extends SpanQuery {
+  private SpanQuery include;
+  private SpanQuery exclude;
+  private final int pre;
+  private final int post;
+
+  /** Construct a SpanNotQuery matching spans from <code>include</code> which
+   * have no overlap with spans from <code>exclude</code>.*/
+  public SpanNotQuery(SpanQuery include, SpanQuery exclude) {
+     this(include, exclude, 0, 0);
+  }
+
+
+  /** Construct a SpanNotQuery matching spans from <code>include</code> which
+   * have no overlap with spans from <code>exclude</code> within
+   * <code>dist</code> tokens of <code>include</code>. */
+  public SpanNotQuery(SpanQuery include, SpanQuery exclude, int dist) {
+     this(include, exclude, dist, dist);
+  }
+
+  /** Construct a SpanNotQuery matching spans from <code>include</code> which
+   * have no overlap with spans from <code>exclude</code> within
+   * <code>pre</code> tokens before or <code>post</code> tokens of <code>include</code>. */
+  public SpanNotQuery(SpanQuery include, SpanQuery exclude, int pre, int post) {
+    this.include = Objects.requireNonNull(include);
+    this.exclude = Objects.requireNonNull(exclude);
+    this.pre = (pre >=0) ? pre : 0;
+    this.post = (post >= 0) ? post : 0;
+
+    if (include.getField() != null && exclude.getField() != null && !include.getField().equals(exclude.getField()))
+      throw new IllegalArgumentException("Clauses must have same field.");
+  }
+
+  /** Return the SpanQuery whose matches are filtered. */
+  public SpanQuery getInclude() { return include; }
+
+  /** Return the SpanQuery whose matches must not overlap those returned. */
+  public SpanQuery getExclude() { return exclude; }
+
+  @Override
+  public String getField() { return include.getField(); }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("spanNot(");
+    buffer.append(include.toString(field));
+    buffer.append(", ");
+    buffer.append(exclude.toString(field));
+    buffer.append(", ");
+    buffer.append(Integer.toString(pre));
+    buffer.append(", ");
+    buffer.append(Integer.toString(post));
+    buffer.append(")");
+    return buffer.toString();
+  }
+
+
+  @Override
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    SpanWeight includeWeight = include.createWeight(searcher, false);
+    SpanWeight excludeWeight = exclude.createWeight(searcher, false);
+    return new SpanNotWeight(searcher, needsScores ? getTermContexts(includeWeight, excludeWeight) : null,
+                                  includeWeight, excludeWeight);
+  }
+
+  public class SpanNotWeight extends SpanWeight {
+
+    final SpanWeight includeWeight;
+    final SpanWeight excludeWeight;
+
+    public SpanNotWeight(IndexSearcher searcher, Map<Term, TermContext> terms,
+                         SpanWeight includeWeight, SpanWeight excludeWeight) throws IOException {
+      super(SpanNotQuery.this, searcher, terms);
+      this.includeWeight = includeWeight;
+      this.excludeWeight = excludeWeight;
+    }
+
+    @Override
+    public void extractTermContexts(Map<Term, TermContext> contexts) {
+      includeWeight.extractTermContexts(contexts);
+    }
+
+    @Override
+    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+      Spans includeSpans = includeWeight.getSpans(context, requiredPostings);
+      if (includeSpans == null) {
+        return null;
+      }
+
+      Spans excludeSpans = excludeWeight.getSpans(context, requiredPostings);
+      if (excludeSpans == null) {
+        return new ScoringWrapperSpans(includeSpans, getSimScorer(context));
+      }
+
+      TwoPhaseIterator excludeTwoPhase = excludeSpans.asTwoPhaseIterator();
+      DocIdSetIterator excludeApproximation = excludeTwoPhase == null ? null : excludeTwoPhase.approximation();
+
+      return new FilterSpans(includeSpans) {
+        // last document we have checked matches() against for the exclusion, and failed
+        // when using approximations, so we don't call it again, and pass thru all inclusions.
+        int lastApproxDoc = -1;
+        boolean lastApproxResult = false;
+
+        @Override
+        protected AcceptStatus accept(Spans candidate) throws IOException {
+          // TODO: this logic is ugly and sneaky, can we clean it up?
+          int doc = candidate.docID();
+          if (doc > excludeSpans.docID()) {
+            // catch up 'exclude' to the current doc
+            if (excludeTwoPhase != null) {
+              if (excludeApproximation.advance(doc) == doc) {
+                lastApproxDoc = doc;
+                lastApproxResult = excludeTwoPhase.matches();
+              }
+            } else {
+              excludeSpans.advance(doc);
+            }
+          } else if (excludeTwoPhase != null && doc == excludeSpans.docID() && doc != lastApproxDoc) {
+            // excludeSpans already sitting on our candidate doc, but matches not called yet.
+            lastApproxDoc = doc;
+            lastApproxResult = excludeTwoPhase.matches();
+          }
+
+          if (doc != excludeSpans.docID() || (doc == lastApproxDoc && lastApproxResult == false)) {
+            return AcceptStatus.YES;
+          }
+
+          if (excludeSpans.startPosition() == -1) { // init exclude start position if needed
+            excludeSpans.nextStartPosition();
+          }
+
+          while (excludeSpans.endPosition() <= candidate.startPosition() - pre) {
+            // exclude end position is before a possible exclusion
+            if (excludeSpans.nextStartPosition() == NO_MORE_POSITIONS) {
+              return AcceptStatus.YES; // no more exclude at current doc.
+            }
+          }
+
+          // exclude end position far enough in current doc, check start position:
+          if (candidate.endPosition() + post <= excludeSpans.startPosition()) {
+            return AcceptStatus.YES;
+          } else {
+            return AcceptStatus.NO;
+          }
+        }
+      };
+    }
+
+    @Override
+    public void extractTerms(Set<Term> terms) {
+      includeWeight.extractTerms(terms);
+    }
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    SpanQuery rewrittenInclude = (SpanQuery) include.rewrite(reader);
+    SpanQuery rewrittenExclude = (SpanQuery) exclude.rewrite(reader);
+    if (rewrittenInclude != include || rewrittenExclude != exclude) {
+      return new SpanNotQuery(rewrittenInclude, rewrittenExclude, pre, post);
+    }
+    return super.rewrite(reader);
+  }
+    /** Returns true iff <code>o</code> is equal to this. */
+  @Override
+  public boolean equals(Object o) {
+    if (!super.equals(o))
+      return false;
+
+    SpanNotQuery other = (SpanNotQuery)o;
+    return this.include.equals(other.include)
+            && this.exclude.equals(other.exclude)
+            && this.pre == other.pre
+            && this.post == other.post;
+  }
+
+  @Override
+  public int hashCode() {
+    int h = super.hashCode();
+    h = Integer.rotateLeft(h, 1);
+    h ^= include.hashCode();
+    h = Integer.rotateLeft(h, 1);
+    h ^= exclude.hashCode();
+    h = Integer.rotateLeft(h, 1);
+    h ^= pre;
+    h = Integer.rotateLeft(h, 1);
+    h ^= post;
+    return h;
+  }
+
+}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanOrQuery.java b/lucene/core/src/java/org/apache/lucene/search/SpanOrQuery.java
new file mode 100644
index 0000000..155c342
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanOrQuery.java
@@ -0,0 +1,371 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+
+
+/** Matches the union of its clauses.
+ */
+public final class SpanOrQuery extends SpanQuery {
+  private List<SpanQuery> clauses;
+  private String field;
+
+  /** Construct a SpanOrQuery merging the provided clauses.
+   * All clauses must have the same field.
+   */
+  public SpanOrQuery(SpanQuery... clauses) {
+    this.clauses = new ArrayList<>(clauses.length);
+    for (SpanQuery seq : clauses) {
+      addClause(seq);
+    }
+  }
+
+  /** Adds a clause to this query */
+  private final void addClause(SpanQuery clause) {
+    if (field == null) {
+      field = clause.getField();
+    } else if (clause.getField() != null && !clause.getField().equals(field)) {
+      throw new IllegalArgumentException("Clauses must have same field.");
+    }
+    this.clauses.add(clause);
+  }
+
+  /** Return the clauses whose spans are matched. */
+  public SpanQuery[] getClauses() {
+    return clauses.toArray(new SpanQuery[clauses.size()]);
+  }
+
+  @Override
+  public String getField() { return field; }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    SpanOrQuery rewritten = new SpanOrQuery();
+    boolean actuallyRewritten = false;
+    for (int i = 0 ; i < clauses.size(); i++) {
+      SpanQuery c = clauses.get(i);
+      SpanQuery query = (SpanQuery) c.rewrite(reader);
+      actuallyRewritten |= query != c;
+      rewritten.addClause(query);
+    }
+    if (actuallyRewritten) {
+      return rewritten;
+    }
+    return super.rewrite(reader);
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("spanOr([");
+    Iterator<SpanQuery> i = clauses.iterator();
+    while (i.hasNext()) {
+      SpanQuery clause = i.next();
+      buffer.append(clause.toString(field));
+      if (i.hasNext()) {
+        buffer.append(", ");
+      }
+    }
+    buffer.append("])");
+    return buffer.toString();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (! super.equals(o)) {
+      return false;
+    }
+    final SpanOrQuery that = (SpanOrQuery) o;
+    return clauses.equals(that.clauses);
+  }
+
+  @Override
+  public int hashCode() {
+    int h = super.hashCode();
+    h = (h * 7) ^ clauses.hashCode();
+    return h;
+  }
+
+  @Override
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    List<SpanWeight> subWeights = new ArrayList<>(clauses.size());
+    for (SpanQuery q : clauses) {
+      subWeights.add(q.createWeight(searcher, false));
+    }
+    return new SpanOrWeight(searcher, needsScores ? getTermContexts(subWeights) : null, subWeights);
+  }
+
+  public class SpanOrWeight extends SpanWeight {
+
+    final List<SpanWeight> subWeights;
+
+    public SpanOrWeight(IndexSearcher searcher, Map<Term, TermContext> terms, List<SpanWeight> subWeights) throws IOException {
+      super(SpanOrQuery.this, searcher, terms);
+      this.subWeights = subWeights;
+    }
+
+    @Override
+    public void extractTerms(Set<Term> terms) {
+      for (final SpanWeight w: subWeights) {
+        w.extractTerms(terms);
+      }
+    }
+
+    @Override
+    public void extractTermContexts(Map<Term, TermContext> contexts) {
+      for (SpanWeight w : subWeights) {
+        w.extractTermContexts(contexts);
+      }
+    }
+
+    @Override
+    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings)
+        throws IOException {
+
+      ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());
+
+      for (SpanWeight w : subWeights) {
+        Spans spans = w.getSpans(context, requiredPostings);
+        if (spans != null) {
+          subSpans.add(spans);
+        }
+      }
+
+      if (subSpans.size() == 0) {
+        return null;
+      } else if (subSpans.size() == 1) {
+        return new ScoringWrapperSpans(subSpans.get(0), getSimScorer(context));
+      }
+
+      DisiPriorityQueue byDocQueue = new DisiPriorityQueue(subSpans.size());
+      for (Spans spans : subSpans) {
+        byDocQueue.add(new DisiWrapper(spans));
+      }
+
+      SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1
+
+      return new Spans() {
+        Spans topPositionSpans = null;
+
+        @Override
+        public int nextDoc() throws IOException {
+          topPositionSpans = null;
+          DisiWrapper topDocSpans = byDocQueue.top();
+          int currentDoc = topDocSpans.doc;
+          do {
+            topDocSpans.doc = topDocSpans.iterator.nextDoc();
+            topDocSpans = byDocQueue.updateTop();
+          } while (topDocSpans.doc == currentDoc);
+          return topDocSpans.doc;
+        }
+
+        @Override
+        public int advance(int target) throws IOException {
+          topPositionSpans = null;
+          DisiWrapper topDocSpans = byDocQueue.top();
+          do {
+            topDocSpans.doc = topDocSpans.iterator.advance(target);
+            topDocSpans = byDocQueue.updateTop();
+          } while (topDocSpans.doc < target);
+          return topDocSpans.doc;
+        }
+
+        @Override
+        public int docID() {
+          DisiWrapper topDocSpans = byDocQueue.top();
+          return topDocSpans.doc;
+        }
+
+        @Override
+        public TwoPhaseIterator asTwoPhaseIterator() {
+          float sumMatchCost = 0; // See also DisjunctionScorer.asTwoPhaseIterator()
+          long sumApproxCost = 0;
+
+          for (DisiWrapper w : byDocQueue) {
+            if (w.twoPhaseView != null) {
+              long costWeight = (w.cost <= 1) ? 1 : w.cost;
+              sumMatchCost += w.twoPhaseView.matchCost() * costWeight;
+              sumApproxCost += costWeight;
+            }
+          }
+
+          if (sumApproxCost == 0) { // no sub spans supports approximations
+            computePositionsCost();
+            return null;
+          }
+
+          final float matchCost = sumMatchCost / sumApproxCost;
+
+          return new TwoPhaseIterator(new DisjunctionDISIApproximation(byDocQueue)) {
+            @Override
+            public boolean matches() throws IOException {
+              return twoPhaseCurrentDocMatches();
+            }
+
+            @Override
+            public float matchCost() {
+              return matchCost;
+            }
+          };
+        }
+
+        float positionsCost = -1;
+
+        void computePositionsCost() {
+          float sumPositionsCost = 0;
+          long sumCost = 0;
+          for (DisiWrapper w : byDocQueue) {
+            long costWeight = (w.cost <= 1) ? 1 : w.cost;
+            sumPositionsCost += w.spans.positionsCost() * costWeight;
+            sumCost += costWeight;
+          }
+          positionsCost = sumPositionsCost / sumCost;
+        }
+
+        @Override
+        public float positionsCost() {
+          // This may be called when asTwoPhaseIterator returned null,
+          // which happens when none of the sub spans supports approximations.
+          assert positionsCost > 0;
+          return positionsCost;
+        }
+
+        int lastDocTwoPhaseMatched = -1;
+
+        boolean twoPhaseCurrentDocMatches() throws IOException {
+          DisiWrapper listAtCurrentDoc = byDocQueue.topList();
+          // remove the head of the list as long as it does not match
+          final int currentDoc = listAtCurrentDoc.doc;
+          while (listAtCurrentDoc.twoPhaseView != null) {
+            if (listAtCurrentDoc.twoPhaseView.matches()) {
+              // use this spans for positions at current doc:
+              listAtCurrentDoc.lastApproxMatchDoc = currentDoc;
+              break;
+            }
+            // do not use this spans for positions at current doc:
+            listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;
+            listAtCurrentDoc = listAtCurrentDoc.next;
+            if (listAtCurrentDoc == null) {
+              return false;
+            }
+          }
+          lastDocTwoPhaseMatched = currentDoc;
+          topPositionSpans = null;
+          return true;
+        }
+
+        void fillPositionQueue() throws IOException { // called at first nextStartPosition
+          assert byPositionQueue.size() == 0;
+          // add all matching Spans at current doc to byPositionQueue
+          DisiWrapper listAtCurrentDoc = byDocQueue.topList();
+          while (listAtCurrentDoc != null) {
+            Spans spansAtDoc = listAtCurrentDoc.spans;
+            if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation
+              if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation
+                if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false
+                  spansAtDoc = null;
+                } else {
+                  if (listAtCurrentDoc.lastApproxMatchDoc != listAtCurrentDoc.doc) {
+                    if (!listAtCurrentDoc.twoPhaseView.matches()) {
+                      spansAtDoc = null;
+                    }
+                  }
+                }
+              }
+            }
+
+            if (spansAtDoc != null) {
+              assert spansAtDoc.docID() == listAtCurrentDoc.doc;
+              assert spansAtDoc.startPosition() == -1;
+              spansAtDoc.nextStartPosition();
+              assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;
+              byPositionQueue.add(spansAtDoc);
+            }
+            listAtCurrentDoc = listAtCurrentDoc.next;
+          }
+          assert byPositionQueue.size() > 0;
+        }
+
+        @Override
+        public int nextStartPosition() throws IOException {
+          if (topPositionSpans == null) {
+            byPositionQueue.clear();
+            fillPositionQueue(); // fills byPositionQueue at first position
+            topPositionSpans = byPositionQueue.top();
+          } else {
+            topPositionSpans.nextStartPosition();
+            topPositionSpans = byPositionQueue.updateTop();
+          }
+          return topPositionSpans.startPosition();
+        }
+
+        @Override
+        public int startPosition() {
+          return topPositionSpans == null ? -1 : topPositionSpans.startPosition();
+        }
+
+        @Override
+        public int endPosition() {
+          return topPositionSpans == null ? -1 : topPositionSpans.endPosition();
+        }
+
+        @Override
+        public int width() {
+          return topPositionSpans.width();
+        }
+
+        @Override
+        public void collect(SpanCollector collector) throws IOException {
+          if (topPositionSpans != null)
+            topPositionSpans.collect(collector);
+        }
+
+        @Override
+        public String toString() {
+          return "spanOr(" + SpanOrQuery.this + ")@" + docID() + ": " + startPosition() + " - " + endPosition();
+        }
+
+        long cost = -1;
+
+        @Override
+        public long cost() {
+          if (cost == -1) {
+            cost = 0;
+            for (Spans spans : subSpans) {
+              cost += spans.cost();
+            }
+          }
+          return cost;
+        }
+      };
+    }
+  }
+
+}
+
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanPositionCheckQuery.java b/lucene/core/src/java/org/apache/lucene/search/SpanPositionCheckQuery.java
new file mode 100644
index 0000000..74b9cb3
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanPositionCheckQuery.java
@@ -0,0 +1,135 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.FilterSpans.AcceptStatus;
+
+
+/**
+ * Base class for filtering a SpanQuery based on the position of a match.
+ **/
+public abstract class SpanPositionCheckQuery extends SpanQuery implements Cloneable {
+  protected SpanQuery match;
+
+  public SpanPositionCheckQuery(SpanQuery match) {
+    this.match = Objects.requireNonNull(match);
+  }
+
+  /**
+   * @return the SpanQuery whose matches are filtered.
+   *
+   * */
+  public SpanQuery getMatch() { return match; }
+
+  @Override
+  public String getField() { return match.getField(); }
+
+  /**
+   * Implementing classes are required to return whether the current position is a match for the passed in
+   * "match" {@link SpanQuery}.
+   *
+   * This is only called if the underlying last {@link Spans#nextStartPosition()} for the
+   * match indicated a valid start position.
+   *
+   * @param spans The {@link Spans} instance, positioned at the spot to check
+   *
+   * @return whether the match is accepted, rejected, or rejected and should move to the next doc.
+   *
+   * @see Spans#nextDoc()
+   *
+   */
+  protected abstract AcceptStatus acceptPosition(Spans spans) throws IOException;
+
+  @Override
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    SpanWeight matchWeight = match.createWeight(searcher, false);
+    return new SpanPositionCheckWeight(matchWeight, searcher, needsScores ? getTermContexts(matchWeight) : null);
+  }
+
+  public class SpanPositionCheckWeight extends SpanWeight {
+
+    final SpanWeight matchWeight;
+
+    public SpanPositionCheckWeight(SpanWeight matchWeight, IndexSearcher searcher, Map<Term, TermContext> terms) throws IOException {
+      super(SpanPositionCheckQuery.this, searcher, terms);
+      this.matchWeight = matchWeight;
+    }
+
+    @Override
+    public void extractTerms(Set<Term> terms) {
+      matchWeight.extractTerms(terms);
+    }
+
+    @Override
+    public void extractTermContexts(Map<Term, TermContext> contexts) {
+      matchWeight.extractTermContexts(contexts);
+    }
+
+    @Override
+    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+      Spans matchSpans = matchWeight.getSpans(context, requiredPostings);
+      return (matchSpans == null) ? null : new FilterSpans(matchSpans) {
+        @Override
+        protected AcceptStatus accept(Spans candidate) throws IOException {
+          return acceptPosition(candidate);
+        }
+      };
+    }
+
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    SpanQuery rewritten = (SpanQuery) match.rewrite(reader);
+    if (rewritten != match) {
+      try {
+        SpanPositionCheckQuery clone = (SpanPositionCheckQuery) this.clone();
+        clone.match = rewritten;
+        return clone;
+      } catch (CloneNotSupportedException e) {
+        throw new AssertionError(e);
+      }
+    }
+
+    return super.rewrite(reader);
+  }
+
+  /** Returns true iff <code>o</code> is equal to this. */
+  @Override
+  public boolean equals(Object o) {
+    if (! super.equals(o)) {
+      return false;
+    }
+    SpanPositionCheckQuery spcq = (SpanPositionCheckQuery) o;
+    return match.equals(spcq.match);
+  }
+
+  @Override
+  public int hashCode() {
+    return match.hashCode() ^ super.hashCode();
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanPositionQueue.java b/lucene/core/src/java/org/apache/lucene/search/SpanPositionQueue.java
new file mode 100644
index 0000000..c99c63a
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanPositionQueue.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import org.apache.lucene.util.PriorityQueue;
+
+class SpanPositionQueue extends PriorityQueue<Spans> {
+  SpanPositionQueue(int maxSize) {
+    super(maxSize, false); // do not prepopulate
+  }
+
+  protected boolean lessThan(Spans s1, Spans s2) {
+    int start1 = s1.startPosition();
+    int start2 = s2.startPosition();
+    return (start1 < start2) ? true
+          : (start1 == start2) ? s1.endPosition() < s2.endPosition()
+          : false;
+  }
+}
+
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanPositionRangeQuery.java b/lucene/core/src/java/org/apache/lucene/search/SpanPositionRangeQuery.java
new file mode 100644
index 0000000..14bbf51
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanPositionRangeQuery.java
@@ -0,0 +1,91 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import org.apache.lucene.search.FilterSpans.AcceptStatus;
+
+import java.io.IOException;
+
+
+/**
+ * Checks to see if the {@link #getMatch()} lies between a start and end position
+ *
+ * See {@link SpanFirstQuery} for a derivation that is optimized for the case where start position is 0.
+ */
+public class SpanPositionRangeQuery extends SpanPositionCheckQuery {
+  protected int start;
+  protected int end;
+
+  public SpanPositionRangeQuery(SpanQuery match, int start, int end) {
+    super(match);
+    this.start = start;
+    this.end = end;
+  }
+
+  @Override
+  protected AcceptStatus acceptPosition(Spans spans) throws IOException {
+    assert spans.startPosition() != spans.endPosition();
+    AcceptStatus res = (spans.startPosition() >= end)
+        ? AcceptStatus.NO_MORE_IN_CURRENT_DOC
+        : (spans.startPosition() >= start && spans.endPosition() <= end)
+        ? AcceptStatus.YES : AcceptStatus.NO;
+    return res;
+  }
+
+  /**
+   * @return The minimum position permitted in a match
+   */
+  public int getStart() {
+    return start;
+  }
+
+  /**
+   * @return the maximum end position permitted in a match.
+   */
+  public int getEnd() {
+    return end;
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("spanPosRange(");
+    buffer.append(match.toString(field));
+    buffer.append(", ").append(start).append(", ");
+    buffer.append(end);
+    buffer.append(")");
+    return buffer.toString();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (! super.equals(o)) {
+      return false;
+    }
+    SpanPositionRangeQuery other = (SpanPositionRangeQuery)o;
+    return this.end == other.end && this.start == other.start;
+  }
+
+  @Override
+  public int hashCode() {
+    int h = super.hashCode() ^ end;
+    h = (h * 127) ^ start;
+    return h;
+  }
+
+}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanQuery.java b/lucene/core/src/java/org/apache/lucene/search/SpanQuery.java
new file mode 100644
index 0000000..030b6e4
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanQuery.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Map;
+import java.util.TreeMap;
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+
+/** Base class for span-based queries. */
+public abstract class SpanQuery extends Query {
+
+  /**
+   * Returns the name of the field matched by this query.
+   */
+  public abstract String getField();
+
+  @Override
+  public abstract SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException;
+
+  /**
+   * Build a map of terms to termcontexts, for use in constructing SpanWeights
+   * @lucene.internal
+   */
+  public static Map<Term, TermContext> getTermContexts(SpanWeight... weights) {
+    Map<Term, TermContext> terms = new TreeMap<>();
+    for (SpanWeight w : weights) {
+      w.extractTermContexts(terms);
+    }
+    return terms;
+  }
+
+  /**
+   * Build a map of terms to termcontexts, for use in constructing SpanWeights
+   * @lucene.internal
+   */
+  public static Map<Term, TermContext> getTermContexts(Collection<SpanWeight> weights) {
+    Map<Term, TermContext> terms = new TreeMap<>();
+    for (SpanWeight w : weights) {
+      w.extractTermContexts(terms);
+    }
+    return terms;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanScorer.java b/lucene/core/src/java/org/apache/lucene/search/SpanScorer.java
new file mode 100644
index 0000000..e8b2c68
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanScorer.java
@@ -0,0 +1,147 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.Objects;
+
+import org.apache.lucene.search.similarities.Similarity;
+
+/**
+ * A basic {@link Scorer} over {@link Spans}.
+ * @lucene.experimental
+ */
+public class SpanScorer extends Scorer {
+
+  protected final Spans spans;
+  protected final Similarity.SimScorer docScorer;
+
+  /** accumulated sloppy freq (computed in setFreqCurrentDoc) */
+  private float freq;
+  /** number of matches (computed in setFreqCurrentDoc) */
+  private int numMatches;
+  private int lastScoredDoc = -1; // last doc we called setFreqCurrentDoc() for
+
+  /** Sole constructor. */
+  public SpanScorer(SpanWeight weight, Spans spans, Similarity.SimScorer docScorer) {
+    super(weight);
+    this.spans = Objects.requireNonNull(spans);
+    this.docScorer = docScorer;
+  }
+
+  /** return the Spans for this Scorer **/
+  public Spans getSpans() {
+    return spans;
+  }
+
+  @Override
+  public int docID() {
+    return spans.docID();
+  }
+
+  @Override
+  public DocIdSetIterator iterator() {
+    return spans;
+  }
+
+  @Override
+  public TwoPhaseIterator twoPhaseIterator() {
+    return spans.asTwoPhaseIterator();
+  }
+
+  /**
+   * Score the current doc. The default implementation scores the doc
+   * with the similarity using the slop-adjusted {@link #freq}.
+   */
+  protected float scoreCurrentDoc() throws IOException {
+    assert docScorer != null : getClass() + " has a null docScorer!";
+    return docScorer.score(docID(), freq);
+  }
+
+  /**
+   * Sets {@link #freq} and {@link #numMatches} for the current document.
+   * <p>
+   * This will be called at most once per document.
+   */
+  protected final void setFreqCurrentDoc() throws IOException {
+    freq = 0.0f;
+    numMatches = 0;
+
+    spans.doStartCurrentDoc();
+
+    assert spans.startPosition() == -1 : "incorrect initial start position, " + this.toString();
+    assert spans.endPosition() == -1 : "incorrect initial end position, " + this.toString();
+    int prevStartPos = -1;
+    int prevEndPos = -1;
+
+    int startPos = spans.nextStartPosition();
+    assert startPos != Spans.NO_MORE_POSITIONS : "initial startPos NO_MORE_POSITIONS, " + this.toString();
+    do {
+      assert startPos >= prevStartPos;
+      int endPos = spans.endPosition();
+      assert endPos != Spans.NO_MORE_POSITIONS;
+      // This assertion can fail for Or spans on the same term:
+      // assert (startPos != prevStartPos) || (endPos > prevEndPos) : "non increased endPos="+endPos;
+      assert (startPos != prevStartPos) || (endPos >= prevEndPos) : "decreased endPos="+endPos;
+      numMatches++;
+      if (docScorer == null) {  // scores not required, break out here
+        freq = 1;
+        return;
+      }
+      freq += docScorer.computeSlopFactor(spans.width());
+      spans.doCurrentSpans();
+      prevStartPos = startPos;
+      prevEndPos = endPos;
+      startPos = spans.nextStartPosition();
+    } while (startPos != Spans.NO_MORE_POSITIONS);
+
+    assert spans.startPosition() == Spans.NO_MORE_POSITIONS : "incorrect final start position, " + this.toString();
+    assert spans.endPosition() == Spans.NO_MORE_POSITIONS : "incorrect final end position, " + this.toString();
+  }
+
+  /**
+   * Ensure setFreqCurrentDoc is called, if not already called for the current doc.
+   */
+  private void ensureFreq() throws IOException {
+    int currentDoc = docID();
+    if (lastScoredDoc != currentDoc) {
+      setFreqCurrentDoc();
+      lastScoredDoc = currentDoc;
+    }
+  }
+
+  @Override
+  public final float score() throws IOException {
+    ensureFreq();
+    return scoreCurrentDoc();
+  }
+
+  @Override
+  public final int freq() throws IOException {
+    ensureFreq();
+    return numMatches;
+  }
+
+  /** Returns the intermediate "sloppy freq" adjusted for edit distance
+   *  @lucene.internal */
+  final float sloppyFreq() throws IOException {
+    ensureFreq();
+    return freq;
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/SpanTermQuery.java
new file mode 100644
index 0000000..64e103c
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanTermQuery.java
@@ -0,0 +1,180 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.Collections;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.ReaderUtil;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.index.TermState;
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.index.TermsEnum;
+
+/** Matches spans containing a term.
+ * This should not be used for terms that are indexed at position Integer.MAX_VALUE.
+ */
+public class SpanTermQuery extends SpanQuery {
+
+  protected final Term term;
+  protected final TermContext termContext;
+
+  /** Construct a SpanTermQuery matching the named term's spans. */
+  public SpanTermQuery(Term term) {
+    this.term = Objects.requireNonNull(term);
+    this.termContext = null;
+  }
+
+  /**
+   * Expert: Construct a SpanTermQuery matching the named term's spans, using
+   * the provided TermContext
+   */
+  public SpanTermQuery(Term term, TermContext context) {
+    this.term = Objects.requireNonNull(term);
+    this.termContext = context;
+  }
+
+  /** Return the term whose spans are matched. */
+  public Term getTerm() { return term; }
+
+  @Override
+  public String getField() { return term.field(); }
+
+  @Override
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    final TermContext context;
+    final IndexReaderContext topContext = searcher.getTopReaderContext();
+    if (termContext == null || termContext.topReaderContext != topContext) {
+      context = TermContext.build(topContext, term);
+    }
+    else {
+      context = termContext;
+    }
+    return new SpanTermWeight(context, searcher, needsScores ? Collections.singletonMap(term, context) : null);
+  }
+
+  public class SpanTermWeight extends SpanWeight {
+
+    final TermContext termContext;
+
+    public SpanTermWeight(TermContext termContext, IndexSearcher searcher, Map<Term, TermContext> terms) throws IOException {
+      super(SpanTermQuery.this, searcher, terms);
+      this.termContext = termContext;
+      assert termContext != null : "TermContext must not be null";
+    }
+
+    @Override
+    public void extractTerms(Set<Term> terms) {
+      terms.add(term);
+    }
+
+    @Override
+    public void extractTermContexts(Map<Term, TermContext> contexts) {
+      contexts.put(term, termContext);
+    }
+
+    @Override
+    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+
+      assert termContext.topReaderContext == ReaderUtil.getTopLevelContext(context) : "The top-reader used to create Weight (" + termContext.topReaderContext + ") is not the same as the current reader's top-reader (" + ReaderUtil.getTopLevelContext(context);
+
+      final TermState state = termContext.get(context.ord);
+      if (state == null) { // term is not present in that reader
+        assert context.reader().docFreq(term) == 0 : "no termstate found but term exists in reader term=" + term;
+        return null;
+      }
+
+      final Terms terms = context.reader().terms(term.field());
+      if (terms == null)
+        return null;
+      if (terms.hasPositions() == false)
+        throw new IllegalStateException("field \"" + term.field() + "\" was indexed without position data; cannot run SpanTermQuery (term=" + term.text() + ")");
+
+      final TermsEnum termsEnum = terms.iterator();
+      termsEnum.seekExact(term.bytes(), state);
+
+      final PostingsEnum postings = termsEnum.postings(null, requiredPostings.getRequiredPostings());
+      float positionsCost = termPositionsCost(termsEnum) * PHRASE_TO_SPAN_TERM_POSITIONS_COST;
+      return new TermSpans(getSimScorer(context), postings, term, positionsCost);
+    }
+  }
+
+  /** A guess of
+   * the relative cost of dealing with the term positions
+   * when using a SpanNearQuery instead of a PhraseQuery.
+   */
+  private static final float PHRASE_TO_SPAN_TERM_POSITIONS_COST = 4.0f;
+
+  private static final int TERM_POSNS_SEEK_OPS_PER_DOC = 128;
+
+  private static final int TERM_OPS_PER_POS = 7;
+
+  /** Returns an expected cost in simple operations
+   *  of processing the occurrences of a term
+   *  in a document that contains the term.
+   *  <br>This may be inaccurate when {@link TermsEnum#totalTermFreq()} is not available.
+   *  @param termsEnum The term is the term at which this TermsEnum is positioned.
+   *  <p>
+   *  This is a copy of org.apache.lucene.search.PhraseQuery.termPositionsCost().
+   *  <br>
+   *  TODO: keep only a single copy of this method and the constants used in it
+   *  when SpanTermQuery moves to the o.a.l.search package.
+   */
+  static float termPositionsCost(TermsEnum termsEnum) throws IOException {
+    int docFreq = termsEnum.docFreq();
+    assert docFreq > 0;
+    long totalTermFreq = termsEnum.totalTermFreq(); // -1 when not available
+    float expOccurrencesInMatchingDoc = (totalTermFreq < docFreq) ? 1 : (totalTermFreq / (float) docFreq);
+    return TERM_POSNS_SEEK_OPS_PER_DOC + expOccurrencesInMatchingDoc * TERM_OPS_PER_POS;
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    if (term.field().equals(field))
+      buffer.append(term.text());
+    else
+      buffer.append(term.toString());
+    return buffer.toString();
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = super.hashCode();
+    result = prime * result + term.hashCode();
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (! super.equals(obj)) {
+      return false;
+    }
+    SpanTermQuery other = (SpanTermQuery) obj;
+    return term.equals(other.term);
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanWeight.java b/lucene/core/src/java/org/apache/lucene/search/SpanWeight.java
new file mode 100644
index 0000000..eef06e1
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanWeight.java
@@ -0,0 +1,164 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.Map;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.search.similarities.Similarity.SimScorer;
+
+/**
+ * Expert-only.  Public for use by other weight implementations
+ */
+public abstract class SpanWeight extends Weight {
+
+  /**
+   * Enumeration defining what postings information should be retrieved from the
+   * index for a given Spans
+   */
+  public enum Postings {
+    POSITIONS {
+      @Override
+      public int getRequiredPostings() {
+        return PostingsEnum.POSITIONS;
+      }
+    },
+    PAYLOADS {
+      @Override
+      public int getRequiredPostings() {
+        return PostingsEnum.PAYLOADS;
+      }
+    },
+    OFFSETS {
+      @Override
+      public int getRequiredPostings() {
+        return PostingsEnum.PAYLOADS | PostingsEnum.OFFSETS;
+      }
+    };
+
+    public abstract int getRequiredPostings();
+
+    public Postings atLeast(Postings postings) {
+      if (postings.compareTo(this) > 0)
+        return postings;
+      return this;
+    }
+  }
+
+  protected final Similarity similarity;
+  protected final Similarity.SimWeight simWeight;
+  protected final String field;
+
+  /**
+   * Create a new SpanWeight
+   * @param query the parent query
+   * @param searcher the IndexSearcher to query against
+   * @param termContexts a map of terms to termcontexts for use in building the similarity.  May
+   *                     be null if scores are not required
+   * @throws IOException on error
+   */
+  public SpanWeight(SpanQuery query, IndexSearcher searcher, Map<Term, TermContext> termContexts) throws IOException {
+    super(query);
+    this.field = query.getField();
+    this.similarity = searcher.getSimilarity(termContexts != null);
+    this.simWeight = buildSimWeight(query, searcher, termContexts);
+  }
+
+  private Similarity.SimWeight buildSimWeight(SpanQuery query, IndexSearcher searcher, Map<Term, TermContext> termContexts) throws IOException {
+    if (termContexts == null || termContexts.size() == 0 || query.getField() == null)
+      return null;
+    TermStatistics[] termStats = new TermStatistics[termContexts.size()];
+    int i = 0;
+    for (Term term : termContexts.keySet()) {
+      termStats[i] = searcher.termStatistics(term, termContexts.get(term));
+      i++;
+    }
+    CollectionStatistics collectionStats = searcher.collectionStatistics(query.getField());
+    return searcher.getSimilarity(true).computeWeight(collectionStats, termStats);
+  }
+
+  /**
+   * Collect all TermContexts used by this Weight
+   * @param contexts a map to add the TermContexts to
+   */
+  public abstract void extractTermContexts(Map<Term, TermContext> contexts);
+
+  /**
+   * Expert: Return a Spans object iterating over matches from this Weight
+   * @param ctx a LeafReaderContext for this Spans
+   * @return a Spans
+   * @throws IOException on error
+   */
+  public abstract Spans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException;
+
+  @Override
+  public float getValueForNormalization() throws IOException {
+    return simWeight == null ? 1.0f : simWeight.getValueForNormalization();
+  }
+
+  @Override
+  public void normalize(float queryNorm, float boost) {
+    if (simWeight != null) {
+      simWeight.normalize(queryNorm, boost);
+    }
+  }
+
+  @Override
+  public SpanScorer scorer(LeafReaderContext context) throws IOException {
+    final Spans spans = getSpans(context, Postings.POSITIONS);
+    if (spans == null) {
+      return null;
+    }
+    final Similarity.SimScorer docScorer = getSimScorer(context);
+    return new SpanScorer(this, spans, docScorer);
+  }
+
+  /**
+   * Return a SimScorer for this context
+   * @param context the LeafReaderContext
+   * @return a SimWeight
+   * @throws IOException on error
+   */
+  public Similarity.SimScorer getSimScorer(LeafReaderContext context) throws IOException {
+    return simWeight == null ? null : similarity.simScorer(simWeight, context);
+  }
+
+  @Override
+  public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+    SpanScorer scorer = scorer(context);
+    if (scorer != null) {
+      int newDoc = scorer.iterator().advance(doc);
+      if (newDoc == doc) {
+        float freq = scorer.sloppyFreq();
+        SimScorer docScorer = similarity.simScorer(simWeight, context);
+        Explanation freqExplanation = Explanation.match(freq, "phraseFreq=" + freq);
+        Explanation scoreExplanation = docScorer.explain(doc, freqExplanation);
+        return Explanation.match(scoreExplanation.getValue(),
+            "weight("+getQuery()+" in "+doc+") [" + similarity.getClass().getSimpleName() + "], result of:",
+            scoreExplanation);
+      }
+    }
+
+    return Explanation.noMatch("no matching term");
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/SpanWithinQuery.java b/lucene/core/src/java/org/apache/lucene/search/SpanWithinQuery.java
new file mode 100644
index 0000000..1764df8
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/SpanWithinQuery.java
@@ -0,0 +1,120 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Map;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+
+/** Keep matches that are contained within another Spans. */
+public final class SpanWithinQuery extends SpanContainQuery {
+
+  /** Construct a SpanWithinQuery matching spans from <code>little</code>
+   * that are inside of <code>big</code>.
+   * This query has the boost of <code>little</code>.
+   * <code>big</code> and <code>little</code> must be in the same field.
+   */
+  public SpanWithinQuery(SpanQuery big, SpanQuery little) {
+    super(big, little);
+  }
+
+  @Override
+  public String toString(String field) {
+    return toString(field, "SpanWithin");
+  }
+
+  @Override
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    SpanWeight bigWeight = big.createWeight(searcher, false);
+    SpanWeight littleWeight = little.createWeight(searcher, false);
+    return new SpanWithinWeight(searcher, needsScores ? getTermContexts(bigWeight, littleWeight) : null,
+                                      bigWeight, littleWeight);
+  }
+
+  public class SpanWithinWeight extends SpanContainWeight {
+
+    public SpanWithinWeight(IndexSearcher searcher, Map<Term, TermContext> terms,
+                            SpanWeight bigWeight, SpanWeight littleWeight) throws IOException {
+      super(searcher, terms, bigWeight, littleWeight);
+    }
+
+    /**
+     * Return spans from <code>little</code> that are contained in a spans from <code>big</code>.
+     * The payload is from the spans of <code>little</code>.
+     */
+    @Override
+    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+      ArrayList<Spans> containerContained = prepareConjunction(context, requiredPostings);
+      if (containerContained == null) {
+        return null;
+      }
+
+      Spans big = containerContained.get(0);
+      Spans little = containerContained.get(1);
+
+      return new ContainSpans(big, little, little) {
+
+        @Override
+        boolean twoPhaseCurrentDocMatches() throws IOException {
+          oneExhaustedInCurrentDoc = false;
+          assert littleSpans.startPosition() == -1;
+          while (littleSpans.nextStartPosition() != NO_MORE_POSITIONS) {
+            while (bigSpans.endPosition() < littleSpans.endPosition()) {
+              if (bigSpans.nextStartPosition() == NO_MORE_POSITIONS) {
+                oneExhaustedInCurrentDoc = true;
+                return false;
+              }
+            }
+            if (bigSpans.startPosition() <= littleSpans.startPosition()) {
+              atFirstInCurrentDoc = true;
+              return true;
+            }
+          }
+          oneExhaustedInCurrentDoc = true;
+          return false;
+        }
+
+        @Override
+        public int nextStartPosition() throws IOException {
+          if (atFirstInCurrentDoc) {
+            atFirstInCurrentDoc = false;
+            return littleSpans.startPosition();
+          }
+          while (littleSpans.nextStartPosition() != NO_MORE_POSITIONS) {
+            while (bigSpans.endPosition() < littleSpans.endPosition()) {
+              if (bigSpans.nextStartPosition() == NO_MORE_POSITIONS) {
+                oneExhaustedInCurrentDoc = true;
+                return NO_MORE_POSITIONS;
+              }
+            }
+            if (bigSpans.startPosition() <= littleSpans.startPosition()) {
+              return littleSpans.startPosition();
+            }
+          }
+          oneExhaustedInCurrentDoc = true;
+          return NO_MORE_POSITIONS;
+        }
+      };
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/Spans.java b/lucene/core/src/java/org/apache/lucene/search/Spans.java
new file mode 100644
index 0000000..1736e6f
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/Spans.java
@@ -0,0 +1,116 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+
+import org.apache.lucene.search.similarities.Similarity.SimScorer;
+
+/** Iterates through combinations of start/end positions per-doc.
+ *  Each start/end position represents a range of term positions within the current document.
+ *  These are enumerated in order, by increasing document number, within that by
+ *  increasing start position and finally by increasing end position.
+ */
+public abstract class Spans extends DocIdSetIterator {
+
+  public static final int NO_MORE_POSITIONS = Integer.MAX_VALUE;
+
+  /**
+   * Returns the next start position for the current doc.
+   * There is always at least one start/end position per doc.
+   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
+   */
+  public abstract int nextStartPosition() throws IOException;
+
+  /**
+   * Returns the start position in the current doc, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
+   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
+   */
+  public abstract int startPosition();
+
+  /**
+   * Returns the end position for the current start position, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
+   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
+   */
+  public abstract int endPosition();
+
+  /**
+   * Return the width of the match, which is typically used to compute
+   * the {@link SimScorer#computeSlopFactor(int) slop factor}. It is only legal
+   * to call this method when the iterator is on a valid doc ID and positioned.
+   * The return value must be positive, and lower values means that the match is
+   * better.
+   */
+  public abstract int width();
+
+  /**
+   * Collect postings data from the leaves of the current Spans.
+   *
+   * This method should only be called after {@link #nextStartPosition()}, and before
+   * {@link #NO_MORE_POSITIONS} has been reached.
+   *
+   * @param collector a SpanCollector
+   *
+   * @lucene.experimental
+   */
+  public abstract void collect(SpanCollector collector) throws IOException;
+
+  /**
+   * Return an estimation of the cost of using the positions of
+   * this {@link Spans} for any single document, but only after
+   * {@link #asTwoPhaseIterator} returned {@code null}.
+   * Otherwise this method should not be called.
+   * The returned value is independent of the current document.
+   *
+   * @lucene.experimental
+   */
+  public abstract float positionsCost();
+
+  /**
+   * Optional method: Return a {@link TwoPhaseIterator} view of this
+   * {@link Scorer}. A return value of {@code null} indicates that
+   * two-phase iteration is not supported.
+   * @see Scorer#twoPhaseIterator()
+   */
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    return null;
+  }
+
+  @Override
+  public String toString() {
+    StringBuilder sb = new StringBuilder();
+    Class<? extends Spans> clazz = getClass();
+    sb.append(clazz.isAnonymousClass() ? clazz.getName() : clazz.getSimpleName());
+    sb.append("(doc=").append(docID());
+    sb.append(",start=").append(startPosition());
+    sb.append(",end=").append(endPosition());
+    sb.append(")");
+    return sb.toString();
+  }
+
+  /**
+   * Called before the current doc's frequency is calculated
+   */
+  protected void doStartCurrentDoc() throws IOException {}
+
+  /**
+   * Called each time the scorer's SpanScorer is advanced during frequency calculation
+   */
+  protected void doCurrentSpans() throws IOException {}
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/TermSpans.java b/lucene/core/src/java/org/apache/lucene/search/TermSpans.java
new file mode 100644
index 0000000..7be421b
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/TermSpans.java
@@ -0,0 +1,138 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.Objects;
+
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.similarities.Similarity;
+
+/**
+ * Expert:
+ * Public for extension only.
+ * This does not work correctly for terms that indexed at position Integer.MAX_VALUE.
+ */
+public class TermSpans extends Spans {
+  protected final PostingsEnum postings;
+  protected final Term term;
+  protected int doc;
+  protected int freq;
+  protected int count;
+  protected int position;
+  protected boolean readPayload;
+  private final float positionsCost;
+
+  public TermSpans(Similarity.SimScorer scorer,
+                    PostingsEnum postings, Term term, float positionsCost) {
+    this.postings = Objects.requireNonNull(postings);
+    this.term = Objects.requireNonNull(term);
+    this.doc = -1;
+    this.position = -1;
+    assert positionsCost > 0; // otherwise the TermSpans should not be created.
+    this.positionsCost = positionsCost;
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    doc = postings.nextDoc();
+    if (doc != NO_MORE_DOCS) {
+      freq = postings.freq();
+      assert freq >= 1;
+      count = 0;
+    }
+    position = -1;
+    return doc;
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    assert target > doc;
+    doc = postings.advance(target);
+    if (doc != NO_MORE_DOCS) {
+      freq = postings.freq();
+      assert freq >= 1;
+      count = 0;
+    }
+    position = -1;
+    return doc;
+  }
+
+  @Override
+  public int docID() {
+    return doc;
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    if (count == freq) {
+      assert position != NO_MORE_POSITIONS;
+      return position = NO_MORE_POSITIONS;
+    }
+    int prevPosition = position;
+    position = postings.nextPosition();
+    assert position >= prevPosition : "prevPosition="+prevPosition+" > position="+position;
+    assert position != NO_MORE_POSITIONS; // int endPosition not possible
+    count++;
+    readPayload = false;
+    return position;
+  }
+
+  @Override
+  public int startPosition() {
+    return position;
+  }
+
+  @Override
+  public int endPosition() {
+    return (position == -1) ? -1
+          : (position != NO_MORE_POSITIONS) ? position + 1
+          : NO_MORE_POSITIONS;
+  }
+
+  @Override
+  public int width() {
+    return 0;
+  }
+
+  @Override
+  public long cost() {
+    return postings.cost();
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    collector.collectLeaf(postings, position, term);
+  }
+
+  @Override
+  public float positionsCost() {
+    return positionsCost;
+  }
+
+  @Override
+  public String toString() {
+    return "spans(" + term.toString() + ")@" +
+            (doc == -1 ? "START" : (doc == NO_MORE_DOCS) ? "ENDDOC"
+              : doc + " - " + (position == NO_MORE_POSITIONS ? "ENDPOS" : position));
+  }
+
+  public PostingsEnum getPostings() {
+    return postings;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/package-info.java b/lucene/core/src/java/org/apache/lucene/search/package-info.java
index 27f7d55..df1f99a 100644
--- a/lucene/core/src/java/org/apache/lucene/search/package-info.java
+++ b/lucene/core/src/java/org/apache/lucene/search/package-info.java
@@ -33,7 +33,7 @@
  * <h2>Search Basics</h2>
  * <p>
  * Lucene offers a wide variety of {@link org.apache.lucene.search.Query} implementations, most of which are in
- * this package, its subpackage ({@link org.apache.lucene.search.spans spans},
+ * this package,
  * or the <a href="{@docRoot}/../queries/overview-summary.html">queries module</a>. These implementations can be combined in a wide 
  * variety of ways to provide complex querying capabilities along with information about where matches took place in the document 
  * collection. The <a href="#query">Query Classes</a> section below highlights some of the more important Query classes. For details 
@@ -136,13 +136,13 @@
  *                 incorporate synonyms.
  *         </li>
  *         <li>
- *             <p>{@link org.apache.lucene.search.spans.SpanNearQuery SpanNearQuery}
+ *             <p>{@link org.apache.lucene.search.SpanNearQuery SpanNearQuery}
  *                 &mdash; Matches a sequence of other
- *                 {@link org.apache.lucene.search.spans.SpanQuery SpanQuery}
- *                 instances. {@link org.apache.lucene.search.spans.SpanNearQuery SpanNearQuery} allows for
+ *                 {@link org.apache.lucene.search.SpanQuery SpanQuery}
+ *                 instances. {@link org.apache.lucene.search.SpanNearQuery SpanNearQuery} allows for
  *                 much more
  *                 complicated phrase queries since it is constructed from other 
- *                     {@link org.apache.lucene.search.spans.SpanQuery SpanQuery}
+ *                     {@link org.apache.lucene.search.SpanQuery SpanQuery}
  *                 instances, instead of only {@link org.apache.lucene.search.TermQuery TermQuery}
  *                 instances.</p>
  *         </li>
@@ -209,7 +209,86 @@
  *     determined using
  *     <a href="http://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a>.
  *     This type of query can be useful when accounting for spelling variations in the collection.
- * 
+ *
+ * <h3>Span queries</h3>
+ *
+ * <p>A span is a <code>&lt;doc,startPosition,endPosition&gt;</code> tuple  that is enumerated by
+ *    class {@link org.apache.lucene.search.Spans Spans}.
+ *  </p>
+ *
+ * <p>The following span query operators are implemented:
+ *
+ * <ul>
+ *
+ * <li>A {@link org.apache.lucene.search.SpanTermQuery SpanTermQuery} matches all spans
+ *    containing a particular {@link org.apache.lucene.index.Term Term}.
+ *    This should not be used for terms that are indexed at position Integer.MAX_VALUE.
+ * </li>
+ *
+ * <li> A {@link org.apache.lucene.search.SpanNearQuery SpanNearQuery} matches spans
+ * which occur near one another, and can be used to implement things like
+ * phrase search (when constructed from {@link org.apache.lucene.search.SpanTermQuery}s)
+ * and inter-phrase proximity (when constructed from other {@link org.apache.lucene.search.SpanNearQuery}s).</li>
+ *
+ * <li> A {@link org.apache.lucene.search.SpanWithinQuery SpanWithinQuery} matches spans
+ * which occur inside of another spans. </li>
+ *
+ * <li> A {@link org.apache.lucene.search.SpanContainingQuery SpanContainingQuery} matches spans
+ * which contain another spans. </li>
+ *
+ * <li>A {@link org.apache.lucene.search.SpanOrQuery SpanOrQuery} merges spans from a
+ * number of other {@link org.apache.lucene.search.SpanQuery}s.</li>
+ *
+ * <li>A {@link org.apache.lucene.search.SpanNotQuery SpanNotQuery} removes spans
+ * matching one {@link org.apache.lucene.search.SpanQuery SpanQuery} which overlap (or comes
+ * near) another.  This can be used, e.g., to implement within-paragraph
+ * search.</li>
+ *
+ * <li>A {@link org.apache.lucene.search.SpanFirstQuery SpanFirstQuery} matches spans
+ * matching <code>q</code> whose end position is less than
+ * <code>n</code>.  This can be used to constrain matches to the first
+ * part of the document.</li>
+ *
+ * <li>A {@link org.apache.lucene.search.SpanPositionRangeQuery SpanPositionRangeQuery} is
+ * a more general form of SpanFirstQuery that can constrain matches to arbitrary portions of the document.</li>
+ *
+ * </ul>
+ *
+ * In all cases, output spans are minimally inclusive.  In other words, a
+ * span formed by matching a span in x and y starts at the lesser of the
+ * two starts and ends at the greater of the two ends.
+ *
+ * <p>For example, a span query which matches "John Kerry" within ten
+ * words of "George Bush" within the first 100 words of the document
+ * could be constructed with:
+ * <pre class="prettyprint">
+ * SpanQuery john   = new SpanTermQuery(new Term("content", "john"));
+ * SpanQuery kerry  = new SpanTermQuery(new Term("content", "kerry"));
+ * SpanQuery george = new SpanTermQuery(new Term("content", "george"));
+ * SpanQuery bush   = new SpanTermQuery(new Term("content", "bush"));
+ *
+ * SpanQuery johnKerry =
+ *    new SpanNearQuery(new SpanQuery[] {john, kerry}, 0, true);
+ *
+ * SpanQuery georgeBush =
+ *    new SpanNearQuery(new SpanQuery[] {george, bush}, 0, true);
+ *
+ * SpanQuery johnKerryNearGeorgeBush =
+ *    new SpanNearQuery(new SpanQuery[] {johnKerry, georgeBush}, 10, false);
+ *
+ * SpanQuery johnKerryNearGeorgeBushAtStart =
+ *    new SpanFirstQuery(johnKerryNearGeorgeBush, 100);
+ * </pre>
+ *
+ * <p>Span queries may be freely intermixed with other Lucene queries.
+ * So, for example, the above query can be restricted to documents which
+ * also use the word "iraq" with:
+ *
+ * <pre class="prettyprint">
+ * Query query = new BooleanQuery();
+ * query.add(johnKerryNearGeorgeBushAtStart, true, false);
+ * query.add(new TermQuery("content", "iraq"), true, false);
+ * </pre>
  * 
  * <a name="scoring"></a>
  * <h2>Scoring &mdash; Introduction</h2>
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java
index 9605c83..3ddd5ba 100644
--- a/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/Similarity.java
@@ -26,7 +26,7 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TermStatistics;
-import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.SpanQuery;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.SmallFloat;
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java
deleted file mode 100644
index e275dec..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.List;
-
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.search.ConjunctionDISI;
-import org.apache.lucene.search.TwoPhaseIterator;
-
-/**
- * Common super class for multiple sub spans required in a document.
- */
-abstract class ConjunctionSpans extends Spans {
-  final Spans[] subSpans; // in query order
-  final DocIdSetIterator conjunction; // use to move to next doc with all clauses
-  boolean atFirstInCurrentDoc; // a first start position is available in current doc for nextStartPosition
-  boolean oneExhaustedInCurrentDoc; // one subspans exhausted in current doc
-
-  ConjunctionSpans(List<Spans> subSpans) {
-    if (subSpans.size() < 2) {
-      throw new IllegalArgumentException("Less than 2 subSpans.size():" + subSpans.size());
-    }
-    this.subSpans = subSpans.toArray(new Spans[subSpans.size()]);
-    this.conjunction = ConjunctionDISI.intersectSpans(subSpans);
-    this.atFirstInCurrentDoc = true; // ensure for doc -1 that start/end positions are -1
-  }
-
-  @Override
-  public int docID() {
-    return conjunction.docID();
-  }
-
-  @Override
-  public long cost() {
-    return conjunction.cost();
-  }
-
-  @Override
-  public int nextDoc() throws IOException {
-    return (conjunction.nextDoc() == NO_MORE_DOCS)
-            ? NO_MORE_DOCS
-            : toMatchDoc();
-  }
-
-  @Override
-  public int advance(int target) throws IOException {
-    return (conjunction.advance(target) == NO_MORE_DOCS)
-            ? NO_MORE_DOCS
-            : toMatchDoc();
-  }
-
-  int toMatchDoc() throws IOException {
-    oneExhaustedInCurrentDoc = false;
-    while (true) {
-      if (twoPhaseCurrentDocMatches()) {
-        return docID();
-      }
-      if (conjunction.nextDoc() == NO_MORE_DOCS) {
-        return NO_MORE_DOCS;
-      }
-    }
-  }
-
-
-  abstract boolean twoPhaseCurrentDocMatches() throws IOException;
-
-  /**
-   * Return a {@link TwoPhaseIterator} view of this ConjunctionSpans.
-   */
-  @Override
-  public TwoPhaseIterator asTwoPhaseIterator() {
-    float totalMatchCost = 0;
-    // Compute the matchCost as the total matchCost/positionsCostant of the sub spans.
-    for (Spans spans : subSpans) {
-      TwoPhaseIterator tpi = spans.asTwoPhaseIterator();
-      if (tpi != null) {
-        totalMatchCost += tpi.matchCost();
-      } else {
-        totalMatchCost += spans.positionsCost();
-      }
-    }
-    final float matchCost = totalMatchCost;
-
-    return new TwoPhaseIterator(conjunction) {
-      @Override
-      public boolean matches() throws IOException {
-        return twoPhaseCurrentDocMatches();
-      }
-
-      @Override
-      public float matchCost() {
-        return matchCost;
-      }
-    };
-  }
-
-  @Override
-  public float positionsCost() {
-    throw new UnsupportedOperationException(); // asTwoPhaseIterator never returns null here.
-  }
-
-  public Spans[] getSubSpans() {
-    return subSpans;
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
deleted file mode 100644
index 4e021c7..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Objects;
-
-abstract class ContainSpans extends ConjunctionSpans {
-  Spans sourceSpans;
-  Spans bigSpans;
-  Spans littleSpans;
-
-  ContainSpans(Spans bigSpans, Spans littleSpans, Spans sourceSpans) {
-    super(Arrays.asList(bigSpans, littleSpans));
-    this.bigSpans = Objects.requireNonNull(bigSpans);
-    this.littleSpans = Objects.requireNonNull(littleSpans);
-    this.sourceSpans = Objects.requireNonNull(sourceSpans);
-  }
-
-  @Override
-  public int startPosition() { 
-    return atFirstInCurrentDoc ? -1
-            : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
-            : sourceSpans.startPosition(); 
-  }
-
-  @Override
-  public int endPosition() { 
-    return atFirstInCurrentDoc ? -1
-            : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
-            : sourceSpans.endPosition(); 
-  }
-
-  @Override
-  public int width() {
-    return sourceSpans.width();
-  }
-
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    bigSpans.collect(collector);
-    littleSpans.collect(collector);
-  }
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
deleted file mode 100644
index 8a2dae3..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
+++ /dev/null
@@ -1,136 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-
-import java.io.IOException;
-import java.util.Objects;
-
-/**
- * <p>Wrapper to allow {@link SpanQuery} objects participate in composite 
- * single-field SpanQueries by 'lying' about their search field. That is, 
- * the masked SpanQuery will function as normal, 
- * but {@link SpanQuery#getField()} simply hands back the value supplied 
- * in this class's constructor.</p>
- * 
- * <p>This can be used to support Queries like {@link SpanNearQuery} or 
- * {@link SpanOrQuery} across different fields, which is not ordinarily 
- * permitted.</p>
- * 
- * <p>This can be useful for denormalized relational data: for example, when 
- * indexing a document with conceptually many 'children': </p>
- * 
- * <pre>
- *  teacherid: 1
- *  studentfirstname: james
- *  studentsurname: jones
- *  
- *  teacherid: 2
- *  studenfirstname: james
- *  studentsurname: smith
- *  studentfirstname: sally
- *  studentsurname: jones
- * </pre>
- * 
- * <p>a SpanNearQuery with a slop of 0 can be applied across two 
- * {@link SpanTermQuery} objects as follows:
- * <pre class="prettyprint">
- *    SpanQuery q1  = new SpanTermQuery(new Term("studentfirstname", "james"));
- *    SpanQuery q2  = new SpanTermQuery(new Term("studentsurname", "jones"));
- *    SpanQuery q2m = new FieldMaskingSpanQuery(q2, "studentfirstname");
- *    Query q = new SpanNearQuery(new SpanQuery[]{q1, q2m}, -1, false);
- * </pre>
- * to search for 'studentfirstname:james studentsurname:jones' and find 
- * teacherid 1 without matching teacherid 2 (which has a 'james' in position 0 
- * and 'jones' in position 1).
- * 
- * <p>Note: as {@link #getField()} returns the masked field, scoring will be 
- * done using the Similarity and collection statistics of the field name supplied,
- * but with the term statistics of the real field. This may lead to exceptions,
- * poor performance, and unexpected scoring behaviour.
- */
-public final class FieldMaskingSpanQuery extends SpanQuery {
-  private final SpanQuery maskedQuery;
-  private final String field;
-    
-  public FieldMaskingSpanQuery(SpanQuery maskedQuery, String maskedField) {
-    this.maskedQuery = Objects.requireNonNull(maskedQuery);
-    this.field = Objects.requireNonNull(maskedField);
-  }
-
-  @Override
-  public String getField() {
-    return field;
-  }
-
-  public SpanQuery getMaskedQuery() {
-    return maskedQuery;
-  }
-
-  // :NOTE: getBoost and setBoost are not proxied to the maskedQuery
-  // ...this is done to be more consistent with things like SpanFirstQuery
-
-  @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    return maskedQuery.createWeight(searcher, needsScores);
-  }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    FieldMaskingSpanQuery clone = null;
-
-    SpanQuery rewritten = (SpanQuery) maskedQuery.rewrite(reader);
-    if (rewritten != maskedQuery) {
-      return new FieldMaskingSpanQuery(rewritten, field);
-    }
-
-    return super.rewrite(reader);
-  }
-
-  @Override
-  public String toString(String field) {
-    StringBuilder buffer = new StringBuilder();
-    buffer.append("mask(");
-    buffer.append(maskedQuery.toString(field));
-    buffer.append(")");
-    buffer.append(" as ");
-    buffer.append(this.field);
-    return buffer.toString();
-  }
-  
-  @Override
-  public boolean equals(Object o) {
-    if (! super.equals(o)) {
-      return false;
-    }
-    FieldMaskingSpanQuery other = (FieldMaskingSpanQuery) o;
-    return (this.getField().equals(other.getField())
-            && this.getMaskedQuery().equals(other.getMaskedQuery()));
-
-  }
-  
-  @Override
-  public int hashCode() {
-    return super.hashCode()
-          ^ getMaskedQuery().hashCode()
-          ^ getField().hashCode();
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java
deleted file mode 100644
index 79d5136..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java
+++ /dev/null
@@ -1,228 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.Objects;
-
-import org.apache.lucene.search.TwoPhaseIterator;
-
-/**
- * A {@link Spans} implementation wrapping another spans instance,
- * allowing to filter spans matches easily by implementing {@link #accept}
- */
-public abstract class FilterSpans extends Spans {
- 
-  /** The wrapped spans instance. */
-  protected final Spans in;
-  
-  private boolean atFirstInCurrentDoc = false;
-  private int startPos = -1;
-  
-  /** Wrap the given {@link Spans}. */
-  protected FilterSpans(Spans in) {
-    this.in = Objects.requireNonNull(in);
-  }
-  
-  /** 
-   * Returns YES if the candidate should be an accepted match,
-   * NO if it should not, and NO_MORE_IN_CURRENT_DOC if iteration
-   * should move on to the next document.
-   */
-  protected abstract AcceptStatus accept(Spans candidate) throws IOException;
-  
-  @Override
-  public final int nextDoc() throws IOException {
-    while (true) {
-      int doc = in.nextDoc();
-      if (doc == NO_MORE_DOCS) {
-        return NO_MORE_DOCS;
-      } else if (twoPhaseCurrentDocMatches()) {
-        return doc;
-      }
-    }
-  }
-
-  @Override
-  public final int advance(int target) throws IOException {
-    int doc = in.advance(target);
-    while (doc != NO_MORE_DOCS) {
-      if (twoPhaseCurrentDocMatches()) {
-        break;
-      }
-      doc = in.nextDoc();
-    }
-
-    return doc;
-  }
-
-  @Override
-  public final int docID() {
-    return in.docID();
-  }
-
-  @Override
-  public final int nextStartPosition() throws IOException {
-    if (atFirstInCurrentDoc) {
-      atFirstInCurrentDoc = false;
-      return startPos;
-    }
-
-    for (;;) {
-      startPos = in.nextStartPosition();
-      if (startPos == NO_MORE_POSITIONS) {
-        return NO_MORE_POSITIONS;
-      }
-      switch(accept(in)) {
-        case YES:
-          return startPos;
-        case NO:
-          break;
-        case NO_MORE_IN_CURRENT_DOC:
-          return startPos = NO_MORE_POSITIONS; // startPos ahead for the current doc.
-      }
-    }
-  }
-
-  @Override
-  public final int startPosition() {
-    return atFirstInCurrentDoc ? -1 : startPos;
-  }
-
-  @Override
-  public final int endPosition() {
-    return atFirstInCurrentDoc ? -1
-          : (startPos != NO_MORE_POSITIONS) ? in.endPosition() : NO_MORE_POSITIONS;
-  }
-
-  @Override
-  public int width() {
-    return in.width();
-  }
-
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    in.collect(collector);
-  }
-
-  @Override
-  public final long cost() {
-    return in.cost();
-  }
-  
-  @Override
-  public String toString() {
-    return "Filter(" + in.toString() + ")";
-  }
-  
-  @Override
-  public final TwoPhaseIterator asTwoPhaseIterator() {
-    TwoPhaseIterator inner = in.asTwoPhaseIterator();
-    if (inner != null) {
-      // wrapped instance has an approximation
-      return new TwoPhaseIterator(inner.approximation()) {
-        @Override
-        public boolean matches() throws IOException {
-          return inner.matches() && twoPhaseCurrentDocMatches();
-        }
-
-        @Override
-        public float matchCost() {
-          return inner.matchCost(); // underestimate
-        }
-
-        @Override
-        public String toString() {
-          return "FilterSpans@asTwoPhaseIterator(inner=" + inner + ", in=" + in + ")";
-        }
-      };
-    } else {
-      // wrapped instance has no approximation, but 
-      // we can still defer matching until absolutely needed.
-      return new TwoPhaseIterator(in) {
-        @Override
-        public boolean matches() throws IOException {
-          return twoPhaseCurrentDocMatches();
-        }
-
-        @Override
-        public float matchCost() {
-          return in.positionsCost(); // overestimate
-        }
-
-        @Override
-        public String toString() {
-          return "FilterSpans@asTwoPhaseIterator(in=" + in + ")";
-        }
-      };
-    }
-  }
-  
-  @Override
-  public float positionsCost() {
-    throw new UnsupportedOperationException(); // asTwoPhaseIterator never returns null
-  }
-
-  /**
-   * Returns true if the current document matches.
-   * <p>
-   * This is called during two-phase processing.
-   */
-  // return true if the current document matches
-  @SuppressWarnings("fallthrough")
-  private final boolean twoPhaseCurrentDocMatches() throws IOException {
-    atFirstInCurrentDoc = false;
-    startPos = in.nextStartPosition();
-    assert startPos != NO_MORE_POSITIONS;
-    for (;;) {
-      switch(accept(in)) {
-        case YES:
-          atFirstInCurrentDoc = true;
-          return true;
-        case NO:
-          startPos = in.nextStartPosition();
-          if (startPos != NO_MORE_POSITIONS) {
-            break;
-          }
-          // else fallthrough
-        case NO_MORE_IN_CURRENT_DOC:
-          startPos = -1;
-          return false;
-      }
-    }
-  }
-
-  /**
-   * Status returned from {@link FilterSpans#accept(Spans)} that indicates
-   * whether a candidate match should be accepted, rejected, or rejected
-   * and move on to the next document.
-   */
-  public static enum AcceptStatus {
-    /** Indicates the match should be accepted */
-    YES,
-
-    /** Indicates the match should be rejected */
-    NO,
-
-    /**
-     * Indicates the match should be rejected, and the enumeration may continue
-     * with the next document.
-     */
-    NO_MORE_IN_CURRENT_DOC
-  };
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
deleted file mode 100644
index f405473..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
+++ /dev/null
@@ -1,154 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.List;
-
-/**
- * A Spans that is formed from the ordered subspans of a SpanNearQuery
- * where the subspans do not overlap and have a maximum slop between them.
- * <p>
- * The formed spans only contains minimum slop matches.<br>
- * The matching slop is computed from the distance(s) between
- * the non overlapping matching Spans.<br>
- * Successive matches are always formed from the successive Spans
- * of the SpanNearQuery.
- * <p>
- * The formed spans may contain overlaps when the slop is at least 1.
- * For example, when querying using
- * <pre>t1 t2 t3</pre>
- * with slop at least 1, the fragment:
- * <pre>t1 t2 t1 t3 t2 t3</pre>
- * matches twice:
- * <pre>t1 t2 .. t3      </pre>
- * <pre>      t1 .. t2 t3</pre>
- *
- * Expert:
- * Only public for subclassing.  Most implementations should not need this class
- */
-public class NearSpansOrdered extends ConjunctionSpans {
-
-  protected int matchStart = -1;
-  protected int matchEnd = -1;
-  protected int matchWidth = -1;
-
-  private final int allowedSlop;
-
-  public NearSpansOrdered(int allowedSlop, List<Spans> subSpans) throws IOException {
-    super(subSpans);
-    this.atFirstInCurrentDoc = true; // -1 startPosition/endPosition also at doc -1
-    this.allowedSlop = allowedSlop;
-  }
-
-  @Override
-  boolean twoPhaseCurrentDocMatches() throws IOException {
-    assert unpositioned();
-    oneExhaustedInCurrentDoc = false;
-    while (subSpans[0].nextStartPosition() != NO_MORE_POSITIONS && !oneExhaustedInCurrentDoc) {
-      if (stretchToOrder() && matchWidth <= allowedSlop) {
-        return atFirstInCurrentDoc = true;
-      }
-    }
-    return false;
-  }
-
-  private boolean unpositioned() {
-    for (Spans span : subSpans) {
-      if (span.startPosition() != -1)
-        return false;
-    }
-    return true;
-  }
-
-  @Override
-  public int nextStartPosition() throws IOException {
-    if (atFirstInCurrentDoc) {
-      atFirstInCurrentDoc = false;
-      return matchStart;
-    }
-    oneExhaustedInCurrentDoc = false;
-    while (subSpans[0].nextStartPosition() != NO_MORE_POSITIONS && !oneExhaustedInCurrentDoc) {
-      if (stretchToOrder() && matchWidth <= allowedSlop) {
-        return matchStart;
-      }
-    }
-    return matchStart = matchEnd = NO_MORE_POSITIONS;
-  }
-
-  /**
-   * Order the subSpans within the same document by using nextStartPosition on all subSpans
-   * after the first as little as necessary.
-   * Return true when the subSpans could be ordered in this way,
-   * otherwise at least one is exhausted in the current doc.
-   */
-  private boolean stretchToOrder() throws IOException {
-    Spans prevSpans = subSpans[0];
-    matchStart = prevSpans.startPosition();
-    assert prevSpans.startPosition() != NO_MORE_POSITIONS : "prevSpans no start position "+prevSpans;
-    assert prevSpans.endPosition() != NO_MORE_POSITIONS;
-    matchWidth = 0;
-    for (int i = 1; i < subSpans.length; i++) {
-      Spans spans = subSpans[i];
-      assert spans.startPosition() != NO_MORE_POSITIONS;
-      assert spans.endPosition() != NO_MORE_POSITIONS;
-      if (advancePosition(spans, prevSpans.endPosition()) == NO_MORE_POSITIONS) {
-        oneExhaustedInCurrentDoc = true;
-        return false;
-      }
-      matchWidth += (spans.startPosition() - prevSpans.endPosition());
-      prevSpans = spans;
-    }
-    matchEnd = subSpans[subSpans.length - 1].endPosition();
-    return true; // all subSpans ordered and non overlapping
-  }
-
-  private static int advancePosition(Spans spans, int position) throws IOException {
-    if (spans instanceof SpanNearQuery.GapSpans) {
-      return ((SpanNearQuery.GapSpans)spans).skipToPosition(position);
-    }
-    while (spans.startPosition() < position) {
-      spans.nextStartPosition();
-    }
-    return spans.startPosition();
-  }
-
-  @Override
-  public int startPosition() {
-    return atFirstInCurrentDoc ? -1 : matchStart;
-  }
-
-  @Override
-  public int endPosition() {
-    return atFirstInCurrentDoc ? -1 : matchEnd;
-  }
-
-  @Override
-  public int width() {
-    return matchWidth;
-  }
-
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    for (Spans span : subSpans) {
-      span.collect(collector);
-    }
-  }
-
-}
-
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
deleted file mode 100644
index c3402bc..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
+++ /dev/null
@@ -1,268 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.search.TwoPhaseIterator;
-import org.apache.lucene.util.PriorityQueue;
-
-/**
- * Similar to {@link NearSpansOrdered}, but for the unordered case.
- *
- * Expert:
- * Only public for subclassing.  Most implementations should not need this class
- */
-public class NearSpansUnordered extends ConjunctionSpans {
-
-  private List<SpansCell> subSpanCells; // in query order
-  private final int allowedSlop;
-
-  private SpanPositionQueue spanPositionQueue;
-
-  public NearSpansUnordered(int allowedSlop, List<Spans> subSpans)
-  throws IOException {
-    super(subSpans);
-
-    this.subSpanCells = new ArrayList<>(subSpans.size());
-    for (Spans subSpan : subSpans) { // sub spans in query order
-      this.subSpanCells.add(new SpansCell(subSpan));
-    }
-    spanPositionQueue = new SpanPositionQueue(subSpans.size());
-    singleCellToPositionQueue(); // -1 startPosition/endPosition also at doc -1
-    this.allowedSlop = allowedSlop;
-  }
-
-  private void singleCellToPositionQueue() {
-    maxEndPositionCell = subSpanCells.get(0);
-    assert maxEndPositionCell.docID() == -1;
-    assert maxEndPositionCell.startPosition() == -1;
-    spanPositionQueue.add(maxEndPositionCell);
-  }
-
-  private void subSpanCellsToPositionQueue() throws IOException { // used when all subSpanCells arrived at the same doc.
-    spanPositionQueue.clear();
-    for (SpansCell cell : subSpanCells) {
-      assert cell.startPosition() == -1;
-      cell.nextStartPosition();
-      assert cell.startPosition() != NO_MORE_POSITIONS;
-      spanPositionQueue.add(cell);
-    }
-  }
-
-  /** SpansCell wraps a sub Spans to maintain totalSpanLength and maxEndPositionCell */
-  private int totalSpanLength;
-  private SpansCell maxEndPositionCell;
-
-  private class SpansCell extends Spans {
-    private int spanLength = -1;
-    final Spans in;
-
-    public SpansCell(Spans spans) {
-      this.in = spans;
-    }
-
-    @Override
-    public int nextStartPosition() throws IOException {
-      int res = in.nextStartPosition();
-      if (res != NO_MORE_POSITIONS) {
-        adjustLength();
-      }
-      adjustMax(); // also after last end position in current doc.
-      return res;
-    }
-
-    private void adjustLength() {
-      if (spanLength != -1) {
-        totalSpanLength -= spanLength;  // subtract old, possibly from a previous doc
-      }
-      assert in.startPosition() != NO_MORE_POSITIONS;
-      spanLength = endPosition() - startPosition();
-      assert spanLength >= 0;
-      totalSpanLength += spanLength; // add new
-    }
-
-    private void adjustMax() {
-      assert docID() == maxEndPositionCell.docID();
-      if (endPosition() > maxEndPositionCell.endPosition()) {
-        maxEndPositionCell = this;
-      }
-    }
-
-    @Override
-    public int startPosition() {
-      return in.startPosition();
-    }
-
-    @Override
-    public int endPosition() {
-      return in.endPosition();
-    }
-
-    @Override
-    public int width() {
-      return in.width();
-    }
-
-    @Override
-    public void collect(SpanCollector collector) throws IOException {
-      in.collect(collector);
-    }
-
-    @Override
-    public TwoPhaseIterator asTwoPhaseIterator() {
-      return in.asTwoPhaseIterator();
-    }
-
-    @Override
-    public float positionsCost() {
-      return in.positionsCost();
-    }
-
-    @Override
-    public int docID() {
-      return in.docID();
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-      return in.nextDoc();
-    }
-
-    @Override
-    public int advance(int target) throws IOException {
-      return in.advance(target);
-    }
-
-    @Override
-    public long cost() {
-      return in.cost();
-    }
-
-    @Override
-    public String toString() {
-      return "NearSpansUnordered.SpansCell(" + in.toString() + ")";
-    }
-  }
-
-
-  private static class SpanPositionQueue extends PriorityQueue<SpansCell> {
-    public SpanPositionQueue(int size) {
-      super(size);
-    }
-
-    @Override
-    protected final boolean lessThan(SpansCell spans1, SpansCell spans2) {
-      return positionsOrdered(spans1, spans2);
-    }
-  }
-
-  /** Check whether two Spans in the same document are ordered with possible overlap.
-   * @return true iff spans1 starts before spans2
-   *              or the spans start at the same position,
-   *              and spans1 ends before spans2.
-   */
-  static boolean positionsOrdered(Spans spans1, Spans spans2) {
-    assert spans1.docID() == spans2.docID() : "doc1 " + spans1.docID() + " != doc2 " + spans2.docID();
-    int start1 = spans1.startPosition();
-    int start2 = spans2.startPosition();
-    return (start1 == start2) ? (spans1.endPosition() < spans2.endPosition()) : (start1 < start2);
-  }
-
-  private SpansCell minPositionCell() {
-    return spanPositionQueue.top();
-  }
-
-  private boolean atMatch() {
-    assert minPositionCell().docID() == maxEndPositionCell.docID();
-    return (maxEndPositionCell.endPosition() - minPositionCell().startPosition() - totalSpanLength) <= allowedSlop;
-  }
-
-  @Override
-  boolean twoPhaseCurrentDocMatches() throws IOException {
-    // at doc with all subSpans
-    subSpanCellsToPositionQueue();
-    while (true) {
-      if (atMatch()) {
-        atFirstInCurrentDoc = true;
-        oneExhaustedInCurrentDoc = false;
-        return true;
-      }
-      assert minPositionCell().startPosition() != NO_MORE_POSITIONS;
-      if (minPositionCell().nextStartPosition() != NO_MORE_POSITIONS) {
-        spanPositionQueue.updateTop();
-      }
-      else { // exhausted a subSpan in current doc
-        return false;
-      }
-    }
-  }
-
-  @Override
-  public int nextStartPosition() throws IOException {
-    if (atFirstInCurrentDoc) {
-      atFirstInCurrentDoc = false;
-      return minPositionCell().startPosition();
-    }
-    while (minPositionCell().startPosition() == -1) { // initially at current doc
-      minPositionCell().nextStartPosition();
-      spanPositionQueue.updateTop();
-    }
-    assert minPositionCell().startPosition() != NO_MORE_POSITIONS;
-    while (true) {
-      if (minPositionCell().nextStartPosition() == NO_MORE_POSITIONS) {
-        oneExhaustedInCurrentDoc = true;
-        return NO_MORE_POSITIONS;
-      }
-      spanPositionQueue.updateTop();
-      if (atMatch()) {
-        return minPositionCell().startPosition();
-      }
-    }
-  }
-
-  @Override
-  public int startPosition() {
-    assert minPositionCell() != null;
-    return atFirstInCurrentDoc ? -1
-          : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
-          : minPositionCell().startPosition();
-  }
-
-  @Override
-  public int endPosition() {
-    return atFirstInCurrentDoc ? -1
-          : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
-          : maxEndPositionCell.endPosition();
-  }
-
-  @Override
-  public int width() {
-    return maxEndPositionCell.startPosition() - minPositionCell().startPosition();
-  }
-
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    for (SpansCell cell : subSpanCells) {
-      cell.collect(collector);
-    }
-  }
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/ScoringWrapperSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/ScoringWrapperSpans.java
deleted file mode 100644
index d38ae83..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/ScoringWrapperSpans.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-
-import org.apache.lucene.search.similarities.Similarity;
-import org.apache.lucene.search.TwoPhaseIterator;
-
-/**
- * A Spans that wraps another Spans with a different SimScorer
- */
-public class ScoringWrapperSpans extends Spans {
-
-  private final Spans in;
-
-  /**
-   * Creates a new ScoringWrapperSpans
-   * @param spans the scorer to wrap
-   * @param simScorer  the SimScorer to use for scoring
-   */
-  public ScoringWrapperSpans(Spans spans, Similarity.SimScorer simScorer) {
-    this.in = spans;
-  }
-
-  @Override
-  public int nextStartPosition() throws IOException {
-    return in.nextStartPosition();
-  }
-
-  @Override
-  public int startPosition() {
-    return in.startPosition();
-  }
-
-  @Override
-  public int endPosition() {
-    return in.endPosition();
-  }
-
-  @Override
-  public int width() {
-    return in.width();
-  }
-
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    in.collect(collector);
-  }
-
-  @Override
-  public int docID() {
-    return in.docID();
-  }
-
-  @Override
-  public int nextDoc() throws IOException {
-    return in.nextDoc();
-  }
-
-  @Override
-  public int advance(int target) throws IOException {
-    return in.advance(target);
-  }
-
-  @Override
-  public long cost() {
-    return in.cost();
-  }
-
-  @Override
-  public TwoPhaseIterator asTwoPhaseIterator() {
-    return in.asTwoPhaseIterator();
-  }
-
-  @Override
-  public float positionsCost() {
-    return in.positionsCost();
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanBoostQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanBoostQuery.java
deleted file mode 100644
index 911fdc0..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanBoostQuery.java
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-import java.util.TreeMap;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermContext;
-import org.apache.lucene.search.BoostQuery;
-import org.apache.lucene.search.Explanation;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.Scorer;
-
-/**
- * Counterpart of {@link BoostQuery} for spans.
- */
-public final class SpanBoostQuery extends SpanQuery {
-
-  private final SpanQuery query;
-  private final float boost;
-
-  /** Sole constructor: wrap {@code query} in such a way that the produced
-   *  scores will be boosted by {@code boost}. */
-  public SpanBoostQuery(SpanQuery query, float boost) {
-    this.query = Objects.requireNonNull(query);
-    this.boost = boost;
-  }
-
-  /**
-   * Return the wrapped {@link SpanQuery}.
-   */
-  public SpanQuery getQuery() {
-    return query;
-  }
-
-  /**
-   * Return the applied boost.
-   */
-  public float getBoost() {
-    return boost;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (super.equals(obj) == false) {
-      return false;
-    }
-    SpanBoostQuery that = (SpanBoostQuery) obj;
-    return query.equals(that.query)
-        && Float.floatToIntBits(boost) == Float.floatToIntBits(that.boost);
-  }
-
-  @Override
-  public int hashCode() {
-    int h = super.hashCode();
-    h = 31 * h + query.hashCode();
-    h = 31 * h + Float.floatToIntBits(boost);
-    return h;
-  }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    if (boost == 1f) {
-      return query;
-    }
-
-    final SpanQuery rewritten = (SpanQuery) query.rewrite(reader);
-    if (query != rewritten) {
-      return new SpanBoostQuery(rewritten, boost);
-    }
-
-    if (query.getClass() == SpanBoostQuery.class) {
-      SpanBoostQuery in = (SpanBoostQuery) query;
-      return new SpanBoostQuery(in.query, boost * in.boost);
-    }
-
-    return super.rewrite(reader);
-  }
-
-  @Override
-  public String toString(String field) {
-    StringBuilder builder = new StringBuilder();
-    builder.append("(");
-    builder.append(query.toString(field));
-    builder.append(")^");
-    builder.append(boost);
-    return builder.toString();
-  }
-
-  @Override
-  public String getField() {
-    return query.getField();
-  }
-
-  @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    final SpanWeight weight = query.createWeight(searcher, needsScores);
-    if (needsScores == false) {
-      return weight;
-    }
-    Map<Term, TermContext> terms = new TreeMap<>();
-    weight.extractTermContexts(terms);
-    weight.normalize(1f, boost);
-    return new SpanWeight(this, searcher, terms) {
-      
-      @Override
-      public void extractTerms(Set<Term> terms) {
-        weight.extractTerms(terms);
-      }
-
-      @Override
-      public Explanation explain(LeafReaderContext context, int doc) throws IOException {
-        return weight.explain(context, doc);
-      }
-
-      @Override
-      public float getValueForNormalization() throws IOException {
-        return weight.getValueForNormalization();
-      }
-
-      @Override
-      public void normalize(float norm, float boost) {
-        weight.normalize(norm, SpanBoostQuery.this.boost * boost);
-      }
-      
-      @Override
-      public Spans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
-        return weight.getSpans(ctx, requiredPostings);
-      }
-
-      @Override
-      public SpanScorer scorer(LeafReaderContext context) throws IOException {
-        return weight.scorer(context);
-      }
-
-      @Override
-      public void extractTermContexts(Map<Term,TermContext> contexts) {
-        weight.extractTermContexts(contexts);
-      }
-    };
-  }
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanCollector.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanCollector.java
deleted file mode 100644
index adaf6f0..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanCollector.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import org.apache.lucene.index.PostingsEnum;
-import org.apache.lucene.index.Term;
-
-import java.io.IOException;
-
-/**
- * An interface defining the collection of postings information from the leaves
- * of a {@link org.apache.lucene.search.spans.Spans}
- *
- * @lucene.experimental
- */
-public interface SpanCollector {
-
-  /**
-   * Collect information from postings
-   * @param postings a {@link PostingsEnum}
-   * @param position the position of the PostingsEnum
-   * @param term     the {@link Term} for this postings list
-   * @throws IOException on error
-   */
-  public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException;
-
-  /**
-   * Call to indicate that the driving Spans has moved to a new position
-   */
-  public void reset();
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java
deleted file mode 100644
index 551138d..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainQuery.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermContext;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-
-abstract class SpanContainQuery extends SpanQuery implements Cloneable {
-
-  SpanQuery big;
-  SpanQuery little;
-
-  SpanContainQuery(SpanQuery big, SpanQuery little) {
-    this.big = Objects.requireNonNull(big);
-    this.little = Objects.requireNonNull(little);
-    Objects.requireNonNull(big.getField());
-    Objects.requireNonNull(little.getField());
-    if (! big.getField().equals(little.getField())) {
-      throw new IllegalArgumentException("big and little not same field");
-    }
-  }
-
-  @Override
-  public String getField() { return big.getField(); }
-  
-  public SpanQuery getBig() {
-    return big;
-  }
-
-  public SpanQuery getLittle() {
-    return little;
-  }
-
-  public abstract class SpanContainWeight extends SpanWeight {
-
-    final SpanWeight bigWeight;
-    final SpanWeight littleWeight;
-
-    public SpanContainWeight(IndexSearcher searcher, Map<Term, TermContext> terms,
-                             SpanWeight bigWeight, SpanWeight littleWeight) throws IOException {
-      super(SpanContainQuery.this, searcher, terms);
-      this.bigWeight = bigWeight;
-      this.littleWeight = littleWeight;
-    }
-
-    /**
-     * Extract terms from both <code>big</code> and <code>little</code>.
-     */
-    @Override
-    public void extractTerms(Set<Term> terms) {
-      bigWeight.extractTerms(terms);
-      littleWeight.extractTerms(terms);
-    }
-
-    ArrayList<Spans> prepareConjunction(final LeafReaderContext context, Postings postings) throws IOException {
-      Spans bigSpans = bigWeight.getSpans(context, postings);
-      if (bigSpans == null) {
-        return null;
-      }
-      Spans littleSpans = littleWeight.getSpans(context, postings);
-      if (littleSpans == null) {
-        return null;
-      }
-      ArrayList<Spans> bigAndLittle = new ArrayList<>();
-      bigAndLittle.add(bigSpans);
-      bigAndLittle.add(littleSpans);
-      return bigAndLittle;
-    }
-
-    @Override
-    public void extractTermContexts(Map<Term, TermContext> contexts) {
-      bigWeight.extractTermContexts(contexts);
-      littleWeight.extractTermContexts(contexts);
-    }
-
-  }
-
-  String toString(String field, String name) {
-    StringBuilder buffer = new StringBuilder();
-    buffer.append(name);
-    buffer.append("(");
-    buffer.append(big.toString(field));
-    buffer.append(", ");
-    buffer.append(little.toString(field));
-    buffer.append(")");
-    return buffer.toString();
-  }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    SpanQuery rewrittenBig = (SpanQuery) big.rewrite(reader);
-    SpanQuery rewrittenLittle = (SpanQuery) little.rewrite(reader);
-    if (big != rewrittenBig || little != rewrittenLittle) {
-      try {
-        SpanContainQuery clone = (SpanContainQuery) super.clone();
-        clone.big = rewrittenBig;
-        clone.little = rewrittenLittle;
-        return clone;
-      } catch (CloneNotSupportedException e) {
-        throw new AssertionError(e);
-      }
-    }
-    return super.rewrite(reader);
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (! super.equals(o)) {
-      return false;
-    }
-    SpanContainQuery other = (SpanContainQuery)o;
-    return big.equals(other.big) && little.equals(other.little);
-  }
-
-  @Override
-  public int hashCode() {
-    int h = Integer.rotateLeft(super.hashCode(), 1);
-    h ^= big.hashCode();
-    h = Integer.rotateLeft(h, 1);
-    h ^= little.hashCode();
-    return h;
-  }
-}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java
deleted file mode 100644
index bfa3f85..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Map;
-
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermContext;
-import org.apache.lucene.search.IndexSearcher;
-
-/** Keep matches that contain another SpanScorer. */
-public final class SpanContainingQuery extends SpanContainQuery {
-  /** Construct a SpanContainingQuery matching spans from <code>big</code>
-   * that contain at least one spans from <code>little</code>.
-   * This query has the boost of <code>big</code>.
-   * <code>big</code> and <code>little</code> must be in the same field.
-   */
-  public SpanContainingQuery(SpanQuery big, SpanQuery little) {
-    super(big, little);
-  }
-
-  @Override
-  public String toString(String field) {
-    return toString(field, "SpanContaining");
-  }
-
-  @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    SpanWeight bigWeight = big.createWeight(searcher, false);
-    SpanWeight littleWeight = little.createWeight(searcher, false);
-    return new SpanContainingWeight(searcher, needsScores ? getTermContexts(bigWeight, littleWeight) : null,
-                                      bigWeight, littleWeight);
-  }
-
-  public class SpanContainingWeight extends SpanContainWeight {
-
-    public SpanContainingWeight(IndexSearcher searcher, Map<Term, TermContext> terms,
-                                SpanWeight bigWeight, SpanWeight littleWeight) throws IOException {
-      super(searcher, terms, bigWeight, littleWeight);
-    }
-
-    /**
-     * Return spans from <code>big</code> that contain at least one spans from <code>little</code>.
-     * The payload is from the spans of <code>big</code>.
-     */
-    @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
-      ArrayList<Spans> containerContained = prepareConjunction(context, requiredPostings);
-      if (containerContained == null) {
-        return null;
-      }
-
-      Spans big = containerContained.get(0);
-      Spans little = containerContained.get(1);
-
-      return new ContainSpans(big, little, big) {
-
-        @Override
-        boolean twoPhaseCurrentDocMatches() throws IOException {
-          oneExhaustedInCurrentDoc = false;
-          assert littleSpans.startPosition() == -1;
-          while (bigSpans.nextStartPosition() != NO_MORE_POSITIONS) {
-            while (littleSpans.startPosition() < bigSpans.startPosition()) {
-              if (littleSpans.nextStartPosition() == NO_MORE_POSITIONS) {
-                oneExhaustedInCurrentDoc = true;
-                return false;
-              }
-            }
-            if (bigSpans.endPosition() >= littleSpans.endPosition()) {
-              atFirstInCurrentDoc = true;
-              return true;
-            }
-          }
-          oneExhaustedInCurrentDoc = true;
-          return false;
-        }
-
-        @Override
-        public int nextStartPosition() throws IOException {
-          if (atFirstInCurrentDoc) {
-            atFirstInCurrentDoc = false;
-            return bigSpans.startPosition();
-          }
-          while (bigSpans.nextStartPosition() != NO_MORE_POSITIONS) {
-            while (littleSpans.startPosition() < bigSpans.startPosition()) {
-              if (littleSpans.nextStartPosition() == NO_MORE_POSITIONS) {
-                oneExhaustedInCurrentDoc = true;
-                return NO_MORE_POSITIONS;
-              }
-            }
-            if (bigSpans.endPosition() >= littleSpans.endPosition()) {
-              return bigSpans.startPosition();
-            }
-          }
-          oneExhaustedInCurrentDoc = true;
-          return NO_MORE_POSITIONS;
-        }
-      };
-    }
-  }
-}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java
deleted file mode 100644
index 5672d77..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
-
-import java.io.IOException;
-
-/**
- * Matches spans near the beginning of a field.
- * <p>
- * This class is a simple extension of {@link SpanPositionRangeQuery} in that it assumes the
- * start to be zero and only checks the end boundary.
- */
-public class SpanFirstQuery extends SpanPositionRangeQuery {
-
-  /** Construct a SpanFirstQuery matching spans in <code>match</code> whose end
-   * position is less than or equal to <code>end</code>. */
-  public SpanFirstQuery(SpanQuery match, int end) {
-    super(match, 0, end);
-  }
-
-  protected AcceptStatus acceptPosition(Spans spans) throws IOException {
-    assert spans.startPosition() != spans.endPosition() : "start equals end: " + spans.startPosition();
-    if (spans.startPosition() >= end)
-      return AcceptStatus.NO_MORE_IN_CURRENT_DOC;
-    else if (spans.endPosition() <= end)
-      return AcceptStatus.YES;
-    else
-      return AcceptStatus.NO;
-  }
-
-  @Override
-  public String toString(String field) {
-    StringBuilder buffer = new StringBuilder();
-    buffer.append("spanFirst(");
-    buffer.append(match.toString(field));
-    buffer.append(", ");
-    buffer.append(end);
-    buffer.append(")");
-    return buffer.toString();
-  }
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
deleted file mode 100644
index 95b7e93..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Objects;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermContext;
-import org.apache.lucene.search.BooleanClause.Occur;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.ScoringRewrite;
-import org.apache.lucene.search.TopTermsRewrite;
-
-/**
- * Wraps any {@link MultiTermQuery} as a {@link SpanQuery}, 
- * so it can be nested within other SpanQuery classes.
- * <p>
- * The query is rewritten by default to a {@link SpanOrQuery} containing
- * the expanded terms, but this can be customized. 
- * <p>
- * Example:
- * <blockquote><pre class="prettyprint">
- * {@code
- * WildcardQuery wildcard = new WildcardQuery(new Term("field", "bro?n"));
- * SpanQuery spanWildcard = new SpanMultiTermQueryWrapper<WildcardQuery>(wildcard);
- * // do something with spanWildcard, such as use it in a SpanFirstQuery
- * }
- * </pre></blockquote>
- */
-public class SpanMultiTermQueryWrapper<Q extends MultiTermQuery> extends SpanQuery {
-
-  protected final Q query;
-  private SpanRewriteMethod rewriteMethod;
-
-  /**
-   * Create a new SpanMultiTermQueryWrapper. 
-   * 
-   * @param query Query to wrap.
-   */
-  @SuppressWarnings({"rawtypes","unchecked"})
-  public SpanMultiTermQueryWrapper(Q query) {
-    this.query = Objects.requireNonNull(query);
-    this.rewriteMethod = selectRewriteMethod(query);
-  }
-
-  private static SpanRewriteMethod selectRewriteMethod(MultiTermQuery query) {
-    MultiTermQuery.RewriteMethod method = query.getRewriteMethod();
-    if (method instanceof TopTermsRewrite) {
-      final int pqsize = ((TopTermsRewrite) method).getSize();
-      return new TopTermsSpanBooleanQueryRewrite(pqsize);
-    } else {
-      return SCORING_SPAN_QUERY_REWRITE;
-    }
-  }
-
-  /**
-   * Expert: returns the rewriteMethod
-   */
-  public final SpanRewriteMethod getRewriteMethod() {
-    return rewriteMethod;
-  }
-
-  /**
-   * Expert: sets the rewrite method. This only makes sense
-   * to be a span rewrite method.
-   */
-  public final void setRewriteMethod(SpanRewriteMethod rewriteMethod) {
-    this.rewriteMethod = rewriteMethod;
-  }
-
-  @Override
-  public String getField() {
-    return query.getField();
-  }
-
-  @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    throw new IllegalArgumentException("Rewrite first!");
-  }
-
-  /** Returns the wrapped query */
-  public Query getWrappedQuery() {
-    return query;
-  }
-
-  @Override
-  public String toString(String field) {
-    StringBuilder builder = new StringBuilder();
-    builder.append("SpanMultiTermQueryWrapper(");
-    // NOTE: query.toString must be placed in a temp local to avoid compile errors on Java 8u20
-    // see https://bugs.openjdk.java.net/browse/JDK-8056984?page=com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab
-    String queryStr = query.toString(field);
-    builder.append(queryStr);
-    builder.append(")");
-    return builder.toString();
-  }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    return rewriteMethod.rewrite(reader, query);
-  }
-  
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = super.hashCode();
-    result = prime * result + query.hashCode();
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (! super.equals(obj)) {
-      return false;
-    }
-    SpanMultiTermQueryWrapper<?> other = (SpanMultiTermQueryWrapper<?>) obj;
-    return query.equals(other.query);
-  }
-
-  /** Abstract class that defines how the query is rewritten. */
-  public static abstract class SpanRewriteMethod extends MultiTermQuery.RewriteMethod {
-    @Override
-    public abstract SpanQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException;
-  }
-
-  /**
-   * A rewrite method that first translates each term into a SpanTermQuery in a
-   * {@link Occur#SHOULD} clause in a BooleanQuery, and keeps the
-   * scores as computed by the query.
-   * 
-   * @see #setRewriteMethod
-   */
-  public final static SpanRewriteMethod SCORING_SPAN_QUERY_REWRITE = new SpanRewriteMethod() {
-    private final ScoringRewrite<List<SpanQuery>> delegate = new ScoringRewrite<List<SpanQuery>>() {
-      @Override
-      protected List<SpanQuery> getTopLevelBuilder() {
-        return new ArrayList<SpanQuery>();
-      }
-
-      protected Query build(List<SpanQuery> builder) {
-        return new SpanOrQuery(builder.toArray(new SpanQuery[builder.size()]));
-      }
-
-      @Override
-      protected void checkMaxClauseCount(int count) {
-        // we accept all terms as SpanOrQuery has no limits
-      }
-    
-      @Override
-      protected void addClause(List<SpanQuery> topLevel, Term term, int docCount, float boost, TermContext states) {
-        final SpanTermQuery q = new SpanTermQuery(term, states);
-        topLevel.add(q);
-      }
-    };
-    
-    @Override
-    public SpanQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException {
-      return (SpanQuery) delegate.rewrite(reader, query);
-    }
-  };
-  
-  /**
-   * A rewrite method that first translates each term into a SpanTermQuery in a
-   * {@link Occur#SHOULD} clause in a BooleanQuery, and keeps the
-   * scores as computed by the query.
-   * 
-   * <p>
-   * This rewrite method only uses the top scoring terms so it will not overflow
-   * the boolean max clause count.
-   * 
-   * @see #setRewriteMethod
-   */
-  public static final class TopTermsSpanBooleanQueryRewrite extends SpanRewriteMethod  {
-    private final TopTermsRewrite<List<SpanQuery>> delegate;
-  
-    /** 
-     * Create a TopTermsSpanBooleanQueryRewrite for 
-     * at most <code>size</code> terms.
-     */
-    public TopTermsSpanBooleanQueryRewrite(int size) {
-      delegate = new TopTermsRewrite<List<SpanQuery>>(size) {
-        @Override
-        protected int getMaxSize() {
-          return Integer.MAX_VALUE;
-        }
-    
-        @Override
-        protected List<SpanQuery> getTopLevelBuilder() {
-          return new ArrayList<SpanQuery>();
-        }
-
-        @Override
-        protected Query build(List<SpanQuery> builder) {
-          return new SpanOrQuery(builder.toArray(new SpanQuery[builder.size()]));
-        }
-
-        @Override
-        protected void addClause(List<SpanQuery> topLevel, Term term, int docFreq, float boost, TermContext states) {
-          final SpanTermQuery q = new SpanTermQuery(term, states);
-          topLevel.add(q);
-        }
-      };
-    }
-    
-    /** return the maximum priority queue size */
-    public int getSize() {
-      return delegate.getSize();
-    }
-
-    @Override
-    public SpanQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException {
-      return (SpanQuery) delegate.rewrite(reader, query);
-    }
-  
-    @Override
-    public int hashCode() {
-      return 31 * delegate.hashCode();
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-      if (this == obj) return true;
-      if (obj == null) return false;
-      if (getClass() != obj.getClass()) return false;
-      final TopTermsSpanBooleanQueryRewrite other = (TopTermsSpanBooleanQueryRewrite) obj;
-      return delegate.equals(other.delegate);
-    }
-    
-  }
-  
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
deleted file mode 100644
index 167a7d1..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
+++ /dev/null
@@ -1,393 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermContext;
-import org.apache.lucene.index.Terms;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-
-/** Matches spans which are near one another.  One can specify <i>slop</i>, the
- * maximum number of intervening unmatched positions, as well as whether
- * matches are required to be in-order.
- */
-public class SpanNearQuery extends SpanQuery implements Cloneable {
-
-  /**
-   * A builder for SpanNearQueries
-   */
-  public static class Builder {
-    private final boolean ordered;
-    private final String field;
-    private final List<SpanQuery> clauses = new LinkedList<>();
-    private int slop;
-
-    /**
-     * Construct a new builder
-     * @param field the field to search in
-     * @param ordered whether or not clauses must be in-order to match
-     */
-    public Builder(String field, boolean ordered) {
-      this.field = field;
-      this.ordered = ordered;
-    }
-
-    /**
-     * Add a new clause
-     */
-    public Builder addClause(SpanQuery clause) {
-      if (Objects.equals(clause.getField(), field) == false)
-        throw new IllegalArgumentException("Cannot add clause " + clause + " to SpanNearQuery for field " + field);
-      this.clauses.add(clause);
-      return this;
-    }
-
-    /**
-     * Add a gap after the previous clause of a defined width
-     */
-    public Builder addGap(int width) {
-      if (!ordered)
-        throw new IllegalArgumentException("Gaps can only be added to ordered near queries");
-      this.clauses.add(new SpanGapQuery(field, width));
-      return this;
-    }
-
-    /**
-     * Set the slop for this query
-     */
-    public Builder setSlop(int slop) {
-      this.slop = slop;
-      return this;
-    }
-
-    /**
-     * Build the query
-     */
-    public SpanNearQuery build() {
-      return new SpanNearQuery(clauses.toArray(new SpanQuery[clauses.size()]), slop, ordered);
-    }
-
-  }
-
-  /**
-   * Returns a {@link Builder} for an ordered query on a particular field
-   */
-  public static Builder newOrderedNearQuery(String field) {
-    return new Builder(field, true);
-  }
-
-  /**
-   * Returns a {@link Builder} for an unordered query on a particular field
-   */
-  public static Builder newUnorderedNearQuery(String field) {
-    return new Builder(field, false);
-  }
-
-  protected List<SpanQuery> clauses;
-  protected int slop;
-  protected boolean inOrder;
-
-  protected String field;
-
-  /** Construct a SpanNearQuery.  Matches spans matching a span from each
-   * clause, with up to <code>slop</code> total unmatched positions between
-   * them.
-   * <br>When <code>inOrder</code> is true, the spans from each clause
-   * must be in the same order as in <code>clauses</code> and must be non-overlapping.
-   * <br>When <code>inOrder</code> is false, the spans from each clause
-   * need not be ordered and may overlap.
-   * @param clausesIn the clauses to find near each other, in the same field, at least 2.
-   * @param slop The slop value
-   * @param inOrder true if order is important
-   */
-  public SpanNearQuery(SpanQuery[] clausesIn, int slop, boolean inOrder) {
-    this.clauses = new ArrayList<>(clausesIn.length);
-    for (SpanQuery clause : clausesIn) {
-      if (this.field == null) {                               // check field
-        this.field = clause.getField();
-      } else if (clause.getField() != null && !clause.getField().equals(field)) {
-        throw new IllegalArgumentException("Clauses must have same field.");
-      }
-      this.clauses.add(clause);
-    }
-    this.slop = slop;
-    this.inOrder = inOrder;
-  }
-
-  /** Return the clauses whose spans are matched. */
-  public SpanQuery[] getClauses() {
-    return clauses.toArray(new SpanQuery[clauses.size()]);
-  }
-
-  /** Return the maximum number of intervening unmatched positions permitted.*/
-  public int getSlop() { return slop; }
-
-  /** Return true if matches are required to be in-order.*/
-  public boolean isInOrder() { return inOrder; }
-
-  @Override
-  public String getField() { return field; }
-
-  @Override
-  public String toString(String field) {
-    StringBuilder buffer = new StringBuilder();
-    buffer.append("spanNear([");
-    Iterator<SpanQuery> i = clauses.iterator();
-    while (i.hasNext()) {
-      SpanQuery clause = i.next();
-      buffer.append(clause.toString(field));
-      if (i.hasNext()) {
-        buffer.append(", ");
-      }
-    }
-    buffer.append("], ");
-    buffer.append(slop);
-    buffer.append(", ");
-    buffer.append(inOrder);
-    buffer.append(")");
-    return buffer.toString();
-  }
-
-  @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    List<SpanWeight> subWeights = new ArrayList<>();
-    for (SpanQuery q : clauses) {
-      subWeights.add(q.createWeight(searcher, false));
-    }
-    return new SpanNearWeight(subWeights, searcher, needsScores ? getTermContexts(subWeights) : null);
-  }
-
-  public class SpanNearWeight extends SpanWeight {
-
-    final List<SpanWeight> subWeights;
-
-    public SpanNearWeight(List<SpanWeight> subWeights, IndexSearcher searcher, Map<Term, TermContext> terms) throws IOException {
-      super(SpanNearQuery.this, searcher, terms);
-      this.subWeights = subWeights;
-    }
-
-    @Override
-    public void extractTermContexts(Map<Term, TermContext> contexts) {
-      for (SpanWeight w : subWeights) {
-        w.extractTermContexts(contexts);
-      }
-    }
-
-    @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
-
-      Terms terms = context.reader().terms(field);
-      if (terms == null) {
-        return null; // field does not exist
-      }
-
-      ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());
-      for (SpanWeight w : subWeights) {
-        Spans subSpan = w.getSpans(context, requiredPostings);
-        if (subSpan != null) {
-          subSpans.add(subSpan);
-        } else {
-          return null; // all required
-        }
-      }
-
-      // all NearSpans require at least two subSpans
-      return (!inOrder) ? new NearSpansUnordered(slop, subSpans)
-          : new NearSpansOrdered(slop, subSpans);
-    }
-
-    @Override
-    public void extractTerms(Set<Term> terms) {
-      for (SpanWeight w : subWeights) {
-        w.extractTerms(terms);
-      }
-    }
-  }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    boolean actuallyRewritten = false;
-    List<SpanQuery> rewrittenClauses = new ArrayList<>();
-    for (int i = 0 ; i < clauses.size(); i++) {
-      SpanQuery c = clauses.get(i);
-      SpanQuery query = (SpanQuery) c.rewrite(reader);
-      actuallyRewritten |= query != c;
-      rewrittenClauses.add(query);
-    }
-    if (actuallyRewritten) {
-      try {
-        SpanNearQuery rewritten = (SpanNearQuery) clone();
-        rewritten.clauses = rewrittenClauses;
-        return rewritten;
-      } catch (CloneNotSupportedException e) {
-        throw new AssertionError(e);
-      }
-    }
-    return super.rewrite(reader);
-  }
-
-  /** Returns true iff <code>o</code> is equal to this. */
-  @Override
-  public boolean equals(Object o) {
-    if (! super.equals(o)) {
-      return false;
-    }
-    final SpanNearQuery spanNearQuery = (SpanNearQuery) o;
-
-    return (inOrder == spanNearQuery.inOrder)
-        && (slop == spanNearQuery.slop)
-        && clauses.equals(spanNearQuery.clauses);
-  }
-
-  @Override
-  public int hashCode() {
-    int result = super.hashCode();
-    result ^= clauses.hashCode();
-    result += slop;
-    int fac = 1 + (inOrder ? 8 : 4);
-    return fac * result;
-  }
-
-  private static class SpanGapQuery extends SpanQuery {
-
-    private final String field;
-    private final int width;
-
-    public SpanGapQuery(String field, int width) {
-      this.field = field;
-      this.width = width;
-    }
-
-    @Override
-    public String getField() {
-      return field;
-    }
-
-    @Override
-    public String toString(String field) {
-      return "SpanGap(" + field + ":" + width + ")";
-    }
-
-    @Override
-    public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-      return new SpanGapWeight(searcher);
-    }
-
-    private class SpanGapWeight extends SpanWeight {
-
-      SpanGapWeight(IndexSearcher searcher) throws IOException {
-        super(SpanGapQuery.this, searcher, null);
-      }
-
-      @Override
-      public void extractTermContexts(Map<Term, TermContext> contexts) {
-
-      }
-
-      @Override
-      public Spans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException {
-        return new GapSpans(width);
-      }
-
-      @Override
-      public void extractTerms(Set<Term> terms) {
-
-      }
-    }
-  }
-
-  static class GapSpans extends Spans {
-
-    int doc = -1;
-    int pos = -1;
-    final int width;
-
-    GapSpans(int width) {
-      this.width = width;
-    }
-
-    @Override
-    public int nextStartPosition() throws IOException {
-      return ++pos;
-    }
-
-    public int skipToPosition(int position) throws IOException {
-      return pos = position;
-    }
-
-    @Override
-    public int startPosition() {
-      return pos;
-    }
-
-    @Override
-    public int endPosition() {
-      return pos + width;
-    }
-
-    @Override
-    public int width() {
-      return width;
-    }
-
-    @Override
-    public void collect(SpanCollector collector) throws IOException {
-
-    }
-
-    @Override
-    public int docID() {
-      return doc;
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-      pos = -1;
-      return ++doc;
-    }
-
-    @Override
-    public int advance(int target) throws IOException {
-      pos = -1;
-      return doc = target;
-    }
-
-    @Override
-    public long cost() {
-      return 0;
-    }
-
-    @Override
-    public float positionsCost() {
-      throw new UnsupportedOperationException();
-    }
-  }
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
deleted file mode 100644
index 5b2aeac..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
+++ /dev/null
@@ -1,228 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermContext;
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TwoPhaseIterator;
-
-/** Removes matches which overlap with another SpanQuery or which are
- * within x tokens before or y tokens after another SpanQuery.
- */
-public final class SpanNotQuery extends SpanQuery {
-  private SpanQuery include;
-  private SpanQuery exclude;
-  private final int pre;
-  private final int post;
-
-  /** Construct a SpanNotQuery matching spans from <code>include</code> which
-   * have no overlap with spans from <code>exclude</code>.*/
-  public SpanNotQuery(SpanQuery include, SpanQuery exclude) {
-     this(include, exclude, 0, 0);
-  }
-
-
-  /** Construct a SpanNotQuery matching spans from <code>include</code> which
-   * have no overlap with spans from <code>exclude</code> within
-   * <code>dist</code> tokens of <code>include</code>. */
-  public SpanNotQuery(SpanQuery include, SpanQuery exclude, int dist) {
-     this(include, exclude, dist, dist);
-  }
-
-  /** Construct a SpanNotQuery matching spans from <code>include</code> which
-   * have no overlap with spans from <code>exclude</code> within
-   * <code>pre</code> tokens before or <code>post</code> tokens of <code>include</code>. */
-  public SpanNotQuery(SpanQuery include, SpanQuery exclude, int pre, int post) {
-    this.include = Objects.requireNonNull(include);
-    this.exclude = Objects.requireNonNull(exclude);
-    this.pre = (pre >=0) ? pre : 0;
-    this.post = (post >= 0) ? post : 0;
-
-    if (include.getField() != null && exclude.getField() != null && !include.getField().equals(exclude.getField()))
-      throw new IllegalArgumentException("Clauses must have same field.");
-  }
-
-  /** Return the SpanQuery whose matches are filtered. */
-  public SpanQuery getInclude() { return include; }
-
-  /** Return the SpanQuery whose matches must not overlap those returned. */
-  public SpanQuery getExclude() { return exclude; }
-
-  @Override
-  public String getField() { return include.getField(); }
-
-  @Override
-  public String toString(String field) {
-    StringBuilder buffer = new StringBuilder();
-    buffer.append("spanNot(");
-    buffer.append(include.toString(field));
-    buffer.append(", ");
-    buffer.append(exclude.toString(field));
-    buffer.append(", ");
-    buffer.append(Integer.toString(pre));
-    buffer.append(", ");
-    buffer.append(Integer.toString(post));
-    buffer.append(")");
-    return buffer.toString();
-  }
-
-
-  @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    SpanWeight includeWeight = include.createWeight(searcher, false);
-    SpanWeight excludeWeight = exclude.createWeight(searcher, false);
-    return new SpanNotWeight(searcher, needsScores ? getTermContexts(includeWeight, excludeWeight) : null,
-                                  includeWeight, excludeWeight);
-  }
-
-  public class SpanNotWeight extends SpanWeight {
-
-    final SpanWeight includeWeight;
-    final SpanWeight excludeWeight;
-
-    public SpanNotWeight(IndexSearcher searcher, Map<Term, TermContext> terms,
-                         SpanWeight includeWeight, SpanWeight excludeWeight) throws IOException {
-      super(SpanNotQuery.this, searcher, terms);
-      this.includeWeight = includeWeight;
-      this.excludeWeight = excludeWeight;
-    }
-
-    @Override
-    public void extractTermContexts(Map<Term, TermContext> contexts) {
-      includeWeight.extractTermContexts(contexts);
-    }
-
-    @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
-      Spans includeSpans = includeWeight.getSpans(context, requiredPostings);
-      if (includeSpans == null) {
-        return null;
-      }
-
-      Spans excludeSpans = excludeWeight.getSpans(context, requiredPostings);
-      if (excludeSpans == null) {
-        return new ScoringWrapperSpans(includeSpans, getSimScorer(context));
-      }
-
-      TwoPhaseIterator excludeTwoPhase = excludeSpans.asTwoPhaseIterator();
-      DocIdSetIterator excludeApproximation = excludeTwoPhase == null ? null : excludeTwoPhase.approximation();
-
-      return new FilterSpans(includeSpans) {
-        // last document we have checked matches() against for the exclusion, and failed
-        // when using approximations, so we don't call it again, and pass thru all inclusions.
-        int lastApproxDoc = -1;
-        boolean lastApproxResult = false;
-
-        @Override
-        protected AcceptStatus accept(Spans candidate) throws IOException {
-          // TODO: this logic is ugly and sneaky, can we clean it up?
-          int doc = candidate.docID();
-          if (doc > excludeSpans.docID()) {
-            // catch up 'exclude' to the current doc
-            if (excludeTwoPhase != null) {
-              if (excludeApproximation.advance(doc) == doc) {
-                lastApproxDoc = doc;
-                lastApproxResult = excludeTwoPhase.matches();
-              }
-            } else {
-              excludeSpans.advance(doc);
-            }
-          } else if (excludeTwoPhase != null && doc == excludeSpans.docID() && doc != lastApproxDoc) {
-            // excludeSpans already sitting on our candidate doc, but matches not called yet.
-            lastApproxDoc = doc;
-            lastApproxResult = excludeTwoPhase.matches();
-          }
-
-          if (doc != excludeSpans.docID() || (doc == lastApproxDoc && lastApproxResult == false)) {
-            return AcceptStatus.YES;
-          }
-
-          if (excludeSpans.startPosition() == -1) { // init exclude start position if needed
-            excludeSpans.nextStartPosition();
-          }
-
-          while (excludeSpans.endPosition() <= candidate.startPosition() - pre) {
-            // exclude end position is before a possible exclusion
-            if (excludeSpans.nextStartPosition() == NO_MORE_POSITIONS) {
-              return AcceptStatus.YES; // no more exclude at current doc.
-            }
-          }
-
-          // exclude end position far enough in current doc, check start position:
-          if (candidate.endPosition() + post <= excludeSpans.startPosition()) {
-            return AcceptStatus.YES;
-          } else {
-            return AcceptStatus.NO;
-          }
-        }
-      };
-    }
-
-    @Override
-    public void extractTerms(Set<Term> terms) {
-      includeWeight.extractTerms(terms);
-    }
-  }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    SpanQuery rewrittenInclude = (SpanQuery) include.rewrite(reader);
-    SpanQuery rewrittenExclude = (SpanQuery) exclude.rewrite(reader);
-    if (rewrittenInclude != include || rewrittenExclude != exclude) {
-      return new SpanNotQuery(rewrittenInclude, rewrittenExclude, pre, post);
-    }
-    return super.rewrite(reader);
-  }
-    /** Returns true iff <code>o</code> is equal to this. */
-  @Override
-  public boolean equals(Object o) {
-    if (!super.equals(o))
-      return false;
-
-    SpanNotQuery other = (SpanNotQuery)o;
-    return this.include.equals(other.include)
-            && this.exclude.equals(other.exclude)
-            && this.pre == other.pre
-            && this.post == other.post;
-  }
-
-  @Override
-  public int hashCode() {
-    int h = super.hashCode();
-    h = Integer.rotateLeft(h, 1);
-    h ^= include.hashCode();
-    h = Integer.rotateLeft(h, 1);
-    h ^= exclude.hashCode();
-    h = Integer.rotateLeft(h, 1);
-    h ^= pre;
-    h = Integer.rotateLeft(h, 1);
-    h ^= post;
-    return h;
-  }
-
-}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
deleted file mode 100644
index c07ec38..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
+++ /dev/null
@@ -1,377 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermContext;
-import org.apache.lucene.search.DisiPriorityQueue;
-import org.apache.lucene.search.DisiWrapper;
-import org.apache.lucene.search.DisjunctionDISIApproximation;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TwoPhaseIterator;
-
-
-/** Matches the union of its clauses.
- */
-public final class SpanOrQuery extends SpanQuery {
-  private List<SpanQuery> clauses;
-  private String field;
-
-  /** Construct a SpanOrQuery merging the provided clauses.
-   * All clauses must have the same field.
-   */
-  public SpanOrQuery(SpanQuery... clauses) {
-    this.clauses = new ArrayList<>(clauses.length);
-    for (SpanQuery seq : clauses) {
-      addClause(seq);
-    }
-  }
-
-  /** Adds a clause to this query */
-  private final void addClause(SpanQuery clause) {
-    if (field == null) {
-      field = clause.getField();
-    } else if (clause.getField() != null && !clause.getField().equals(field)) {
-      throw new IllegalArgumentException("Clauses must have same field.");
-    }
-    this.clauses.add(clause);
-  }
-
-  /** Return the clauses whose spans are matched. */
-  public SpanQuery[] getClauses() {
-    return clauses.toArray(new SpanQuery[clauses.size()]);
-  }
-
-  @Override
-  public String getField() { return field; }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    SpanOrQuery rewritten = new SpanOrQuery();
-    boolean actuallyRewritten = false;
-    for (int i = 0 ; i < clauses.size(); i++) {
-      SpanQuery c = clauses.get(i);
-      SpanQuery query = (SpanQuery) c.rewrite(reader);
-      actuallyRewritten |= query != c;
-      rewritten.addClause(query);
-    }
-    if (actuallyRewritten) {
-      return rewritten;
-    }
-    return super.rewrite(reader);
-  }
-
-  @Override
-  public String toString(String field) {
-    StringBuilder buffer = new StringBuilder();
-    buffer.append("spanOr([");
-    Iterator<SpanQuery> i = clauses.iterator();
-    while (i.hasNext()) {
-      SpanQuery clause = i.next();
-      buffer.append(clause.toString(field));
-      if (i.hasNext()) {
-        buffer.append(", ");
-      }
-    }
-    buffer.append("])");
-    return buffer.toString();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (! super.equals(o)) {
-      return false;
-    }
-    final SpanOrQuery that = (SpanOrQuery) o;
-    return clauses.equals(that.clauses);
-  }
-
-  @Override
-  public int hashCode() {
-    int h = super.hashCode();
-    h = (h * 7) ^ clauses.hashCode();
-    return h;
-  }
-
-  @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    List<SpanWeight> subWeights = new ArrayList<>(clauses.size());
-    for (SpanQuery q : clauses) {
-      subWeights.add(q.createWeight(searcher, false));
-    }
-    return new SpanOrWeight(searcher, needsScores ? getTermContexts(subWeights) : null, subWeights);
-  }
-
-  public class SpanOrWeight extends SpanWeight {
-
-    final List<SpanWeight> subWeights;
-
-    public SpanOrWeight(IndexSearcher searcher, Map<Term, TermContext> terms, List<SpanWeight> subWeights) throws IOException {
-      super(SpanOrQuery.this, searcher, terms);
-      this.subWeights = subWeights;
-    }
-
-    @Override
-    public void extractTerms(Set<Term> terms) {
-      for (final SpanWeight w: subWeights) {
-        w.extractTerms(terms);
-      }
-    }
-
-    @Override
-    public void extractTermContexts(Map<Term, TermContext> contexts) {
-      for (SpanWeight w : subWeights) {
-        w.extractTermContexts(contexts);
-      }
-    }
-
-    @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings)
-        throws IOException {
-
-      ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());
-
-      for (SpanWeight w : subWeights) {
-        Spans spans = w.getSpans(context, requiredPostings);
-        if (spans != null) {
-          subSpans.add(spans);
-        }
-      }
-
-      if (subSpans.size() == 0) {
-        return null;
-      } else if (subSpans.size() == 1) {
-        return new ScoringWrapperSpans(subSpans.get(0), getSimScorer(context));
-      }
-
-      DisiPriorityQueue byDocQueue = new DisiPriorityQueue(subSpans.size());
-      for (Spans spans : subSpans) {
-        byDocQueue.add(new DisiWrapper(spans));
-      }
-
-      SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1
-
-      return new Spans() {
-        Spans topPositionSpans = null;
-
-        @Override
-        public int nextDoc() throws IOException {
-          topPositionSpans = null;
-          DisiWrapper topDocSpans = byDocQueue.top();
-          int currentDoc = topDocSpans.doc;
-          do {
-            topDocSpans.doc = topDocSpans.iterator.nextDoc();
-            topDocSpans = byDocQueue.updateTop();
-          } while (topDocSpans.doc == currentDoc);
-          return topDocSpans.doc;
-        }
-
-        @Override
-        public int advance(int target) throws IOException {
-          topPositionSpans = null;
-          DisiWrapper topDocSpans = byDocQueue.top();
-          do {
-            topDocSpans.doc = topDocSpans.iterator.advance(target);
-            topDocSpans = byDocQueue.updateTop();
-          } while (topDocSpans.doc < target);
-          return topDocSpans.doc;
-        }
-
-        @Override
-        public int docID() {
-          DisiWrapper topDocSpans = byDocQueue.top();
-          return topDocSpans.doc;
-        }
-
-        @Override
-        public TwoPhaseIterator asTwoPhaseIterator() {
-          float sumMatchCost = 0; // See also DisjunctionScorer.asTwoPhaseIterator()
-          long sumApproxCost = 0;
-
-          for (DisiWrapper w : byDocQueue) {
-            if (w.twoPhaseView != null) {
-              long costWeight = (w.cost <= 1) ? 1 : w.cost;
-              sumMatchCost += w.twoPhaseView.matchCost() * costWeight;
-              sumApproxCost += costWeight;
-            }
-          }
-
-          if (sumApproxCost == 0) { // no sub spans supports approximations
-            computePositionsCost();
-            return null;
-          }
-
-          final float matchCost = sumMatchCost / sumApproxCost;
-
-          return new TwoPhaseIterator(new DisjunctionDISIApproximation(byDocQueue)) {
-            @Override
-            public boolean matches() throws IOException {
-              return twoPhaseCurrentDocMatches();
-            }
-
-            @Override
-            public float matchCost() {
-              return matchCost;
-            }
-          };
-        }
-
-        float positionsCost = -1;
-
-        void computePositionsCost() {
-          float sumPositionsCost = 0;
-          long sumCost = 0;
-          for (DisiWrapper w : byDocQueue) {
-            long costWeight = (w.cost <= 1) ? 1 : w.cost;
-            sumPositionsCost += w.spans.positionsCost() * costWeight;
-            sumCost += costWeight;
-          }
-          positionsCost = sumPositionsCost / sumCost;
-        }
-
-        @Override
-        public float positionsCost() {
-          // This may be called when asTwoPhaseIterator returned null,
-          // which happens when none of the sub spans supports approximations.
-          assert positionsCost > 0;
-          return positionsCost;
-        }
-
-        int lastDocTwoPhaseMatched = -1;
-
-        boolean twoPhaseCurrentDocMatches() throws IOException {
-          DisiWrapper listAtCurrentDoc = byDocQueue.topList();
-          // remove the head of the list as long as it does not match
-          final int currentDoc = listAtCurrentDoc.doc;
-          while (listAtCurrentDoc.twoPhaseView != null) {
-            if (listAtCurrentDoc.twoPhaseView.matches()) {
-              // use this spans for positions at current doc:
-              listAtCurrentDoc.lastApproxMatchDoc = currentDoc;
-              break;
-            }
-            // do not use this spans for positions at current doc:
-            listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;
-            listAtCurrentDoc = listAtCurrentDoc.next;
-            if (listAtCurrentDoc == null) {
-              return false;
-            }
-          }
-          lastDocTwoPhaseMatched = currentDoc;
-          topPositionSpans = null;
-          return true;
-        }
-
-        void fillPositionQueue() throws IOException { // called at first nextStartPosition
-          assert byPositionQueue.size() == 0;
-          // add all matching Spans at current doc to byPositionQueue
-          DisiWrapper listAtCurrentDoc = byDocQueue.topList();
-          while (listAtCurrentDoc != null) {
-            Spans spansAtDoc = listAtCurrentDoc.spans;
-            if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation
-              if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation
-                if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false
-                  spansAtDoc = null;
-                } else {
-                  if (listAtCurrentDoc.lastApproxMatchDoc != listAtCurrentDoc.doc) {
-                    if (!listAtCurrentDoc.twoPhaseView.matches()) {
-                      spansAtDoc = null;
-                    }
-                  }
-                }
-              }
-            }
-
-            if (spansAtDoc != null) {
-              assert spansAtDoc.docID() == listAtCurrentDoc.doc;
-              assert spansAtDoc.startPosition() == -1;
-              spansAtDoc.nextStartPosition();
-              assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;
-              byPositionQueue.add(spansAtDoc);
-            }
-            listAtCurrentDoc = listAtCurrentDoc.next;
-          }
-          assert byPositionQueue.size() > 0;
-        }
-
-        @Override
-        public int nextStartPosition() throws IOException {
-          if (topPositionSpans == null) {
-            byPositionQueue.clear();
-            fillPositionQueue(); // fills byPositionQueue at first position
-            topPositionSpans = byPositionQueue.top();
-          } else {
-            topPositionSpans.nextStartPosition();
-            topPositionSpans = byPositionQueue.updateTop();
-          }
-          return topPositionSpans.startPosition();
-        }
-
-        @Override
-        public int startPosition() {
-          return topPositionSpans == null ? -1 : topPositionSpans.startPosition();
-        }
-
-        @Override
-        public int endPosition() {
-          return topPositionSpans == null ? -1 : topPositionSpans.endPosition();
-        }
-
-        @Override
-        public int width() {
-          return topPositionSpans.width();
-        }
-
-        @Override
-        public void collect(SpanCollector collector) throws IOException {
-          if (topPositionSpans != null)
-            topPositionSpans.collect(collector);
-        }
-
-        @Override
-        public String toString() {
-          return "spanOr(" + SpanOrQuery.this + ")@" + docID() + ": " + startPosition() + " - " + endPosition();
-        }
-
-        long cost = -1;
-
-        @Override
-        public long cost() {
-          if (cost == -1) {
-            cost = 0;
-            for (Spans spans : subSpans) {
-              cost += spans.cost();
-            }
-          }
-          return cost;
-        }
-      };
-    }
-  }
-
-}
-
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
deleted file mode 100644
index b2166e4..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermContext;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
-
-
-/**
- * Base class for filtering a SpanQuery based on the position of a match.
- **/
-public abstract class SpanPositionCheckQuery extends SpanQuery implements Cloneable {
-  protected SpanQuery match;
-
-  public SpanPositionCheckQuery(SpanQuery match) {
-    this.match = Objects.requireNonNull(match);
-  }
-
-  /**
-   * @return the SpanQuery whose matches are filtered.
-   *
-   * */
-  public SpanQuery getMatch() { return match; }
-
-  @Override
-  public String getField() { return match.getField(); }
-
-  /**
-   * Implementing classes are required to return whether the current position is a match for the passed in
-   * "match" {@link SpanQuery}.
-   *
-   * This is only called if the underlying last {@link Spans#nextStartPosition()} for the
-   * match indicated a valid start position.
-   *
-   * @param spans The {@link Spans} instance, positioned at the spot to check
-   *
-   * @return whether the match is accepted, rejected, or rejected and should move to the next doc.
-   *
-   * @see Spans#nextDoc()
-   *
-   */
-  protected abstract AcceptStatus acceptPosition(Spans spans) throws IOException;
-
-  @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    SpanWeight matchWeight = match.createWeight(searcher, false);
-    return new SpanPositionCheckWeight(matchWeight, searcher, needsScores ? getTermContexts(matchWeight) : null);
-  }
-
-  public class SpanPositionCheckWeight extends SpanWeight {
-
-    final SpanWeight matchWeight;
-
-    public SpanPositionCheckWeight(SpanWeight matchWeight, IndexSearcher searcher, Map<Term, TermContext> terms) throws IOException {
-      super(SpanPositionCheckQuery.this, searcher, terms);
-      this.matchWeight = matchWeight;
-    }
-
-    @Override
-    public void extractTerms(Set<Term> terms) {
-      matchWeight.extractTerms(terms);
-    }
-
-    @Override
-    public void extractTermContexts(Map<Term, TermContext> contexts) {
-      matchWeight.extractTermContexts(contexts);
-    }
-
-    @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
-      Spans matchSpans = matchWeight.getSpans(context, requiredPostings);
-      return (matchSpans == null) ? null : new FilterSpans(matchSpans) {
-        @Override
-        protected AcceptStatus accept(Spans candidate) throws IOException {
-          return acceptPosition(candidate);
-        }
-      };
-    }
-
-  }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    SpanQuery rewritten = (SpanQuery) match.rewrite(reader);
-    if (rewritten != match) {
-      try {
-        SpanPositionCheckQuery clone = (SpanPositionCheckQuery) this.clone();
-        clone.match = rewritten;
-        return clone;
-      } catch (CloneNotSupportedException e) {
-        throw new AssertionError(e);
-      }
-    }
-
-    return super.rewrite(reader);
-  }
-
-  /** Returns true iff <code>o</code> is equal to this. */
-  @Override
-  public boolean equals(Object o) {
-    if (! super.equals(o)) {
-      return false;
-    }
-    SpanPositionCheckQuery spcq = (SpanPositionCheckQuery) o;
-    return match.equals(spcq.match);
-  }
-
-  @Override
-  public int hashCode() {
-    return match.hashCode() ^ super.hashCode();
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionQueue.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionQueue.java
deleted file mode 100644
index 2d2bd16..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionQueue.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import org.apache.lucene.util.PriorityQueue;
-
-class SpanPositionQueue extends PriorityQueue<Spans> {
-  SpanPositionQueue(int maxSize) {
-    super(maxSize, false); // do not prepopulate
-  }
-
-  protected boolean lessThan(Spans s1, Spans s2) {
-    int start1 = s1.startPosition();
-    int start2 = s2.startPosition();
-    return (start1 < start2) ? true
-          : (start1 == start2) ? s1.endPosition() < s2.endPosition()
-          : false;
-  }
-}
-
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java
deleted file mode 100644
index eafc04d..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
-
-import java.io.IOException;
-
-
-/**
- * Checks to see if the {@link #getMatch()} lies between a start and end position
- *
- * See {@link SpanFirstQuery} for a derivation that is optimized for the case where start position is 0.
- */
-public class SpanPositionRangeQuery extends SpanPositionCheckQuery {
-  protected int start;
-  protected int end;
-
-  public SpanPositionRangeQuery(SpanQuery match, int start, int end) {
-    super(match);
-    this.start = start;
-    this.end = end;
-  }
-
-  @Override
-  protected AcceptStatus acceptPosition(Spans spans) throws IOException {
-    assert spans.startPosition() != spans.endPosition();
-    AcceptStatus res = (spans.startPosition() >= end)
-        ? AcceptStatus.NO_MORE_IN_CURRENT_DOC
-        : (spans.startPosition() >= start && spans.endPosition() <= end)
-        ? AcceptStatus.YES : AcceptStatus.NO;
-    return res;
-  }
-
-  /**
-   * @return The minimum position permitted in a match
-   */
-  public int getStart() {
-    return start;
-  }
-
-  /**
-   * @return the maximum end position permitted in a match.
-   */
-  public int getEnd() {
-    return end;
-  }
-
-  @Override
-  public String toString(String field) {
-    StringBuilder buffer = new StringBuilder();
-    buffer.append("spanPosRange(");
-    buffer.append(match.toString(field));
-    buffer.append(", ").append(start).append(", ");
-    buffer.append(end);
-    buffer.append(")");
-    return buffer.toString();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (! super.equals(o)) {
-      return false;
-    }
-    SpanPositionRangeQuery other = (SpanPositionRangeQuery)o;
-    return this.end == other.end && this.start == other.start;
-  }
-
-  @Override
-  public int hashCode() {
-    int h = super.hashCode() ^ end;
-    h = (h * 127) ^ start;
-    return h;
-  }
-
-}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java
deleted file mode 100644
index 12a1129..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.Collection;
-import java.util.Map;
-import java.util.TreeMap;
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermContext;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-
-/** Base class for span-based queries. */
-public abstract class SpanQuery extends Query {
-
-  /**
-   * Returns the name of the field matched by this query.
-   */
-  public abstract String getField();
-
-  @Override
-  public abstract SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException;
-
-  /**
-   * Build a map of terms to termcontexts, for use in constructing SpanWeights
-   * @lucene.internal
-   */
-  public static Map<Term, TermContext> getTermContexts(SpanWeight... weights) {
-    Map<Term, TermContext> terms = new TreeMap<>();
-    for (SpanWeight w : weights) {
-      w.extractTermContexts(terms);
-    }
-    return terms;
-  }
-
-  /**
-   * Build a map of terms to termcontexts, for use in constructing SpanWeights
-   * @lucene.internal
-   */
-  public static Map<Term, TermContext> getTermContexts(Collection<SpanWeight> weights) {
-    Map<Term, TermContext> terms = new TreeMap<>();
-    for (SpanWeight w : weights) {
-      w.extractTermContexts(terms);
-    }
-    return terms;
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java
deleted file mode 100644
index 4841ddc..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.Objects;
-
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.search.Scorer;
-import org.apache.lucene.search.TwoPhaseIterator;
-import org.apache.lucene.search.similarities.Similarity;
-
-/**
- * A basic {@link Scorer} over {@link Spans}.
- * @lucene.experimental
- */
-public class SpanScorer extends Scorer {
-
-  protected final Spans spans;
-  protected final Similarity.SimScorer docScorer;
-
-  /** accumulated sloppy freq (computed in setFreqCurrentDoc) */
-  private float freq;
-  /** number of matches (computed in setFreqCurrentDoc) */
-  private int numMatches;
-  private int lastScoredDoc = -1; // last doc we called setFreqCurrentDoc() for
-
-  /** Sole constructor. */
-  public SpanScorer(SpanWeight weight, Spans spans, Similarity.SimScorer docScorer) {
-    super(weight);
-    this.spans = Objects.requireNonNull(spans);
-    this.docScorer = docScorer;
-  }
-
-  /** return the Spans for this Scorer **/
-  public Spans getSpans() {
-    return spans;
-  }
-
-  @Override
-  public int docID() {
-    return spans.docID();
-  }
-
-  @Override
-  public DocIdSetIterator iterator() {
-    return spans;
-  }
-
-  @Override
-  public TwoPhaseIterator twoPhaseIterator() {
-    return spans.asTwoPhaseIterator();
-  }
-
-  /**
-   * Score the current doc. The default implementation scores the doc
-   * with the similarity using the slop-adjusted {@link #freq}.
-   */
-  protected float scoreCurrentDoc() throws IOException {
-    assert docScorer != null : getClass() + " has a null docScorer!";
-    return docScorer.score(docID(), freq);
-  }
-
-  /**
-   * Sets {@link #freq} and {@link #numMatches} for the current document.
-   * <p>
-   * This will be called at most once per document.
-   */
-  protected final void setFreqCurrentDoc() throws IOException {
-    freq = 0.0f;
-    numMatches = 0;
-
-    spans.doStartCurrentDoc();
-
-    assert spans.startPosition() == -1 : "incorrect initial start position, " + this.toString();
-    assert spans.endPosition() == -1 : "incorrect initial end position, " + this.toString();
-    int prevStartPos = -1;
-    int prevEndPos = -1;
-
-    int startPos = spans.nextStartPosition();
-    assert startPos != Spans.NO_MORE_POSITIONS : "initial startPos NO_MORE_POSITIONS, " + this.toString();
-    do {
-      assert startPos >= prevStartPos;
-      int endPos = spans.endPosition();
-      assert endPos != Spans.NO_MORE_POSITIONS;
-      // This assertion can fail for Or spans on the same term:
-      // assert (startPos != prevStartPos) || (endPos > prevEndPos) : "non increased endPos="+endPos;
-      assert (startPos != prevStartPos) || (endPos >= prevEndPos) : "decreased endPos="+endPos;
-      numMatches++;
-      if (docScorer == null) {  // scores not required, break out here
-        freq = 1;
-        return;
-      }
-      freq += docScorer.computeSlopFactor(spans.width());
-      spans.doCurrentSpans();
-      prevStartPos = startPos;
-      prevEndPos = endPos;
-      startPos = spans.nextStartPosition();
-    } while (startPos != Spans.NO_MORE_POSITIONS);
-
-    assert spans.startPosition() == Spans.NO_MORE_POSITIONS : "incorrect final start position, " + this.toString();
-    assert spans.endPosition() == Spans.NO_MORE_POSITIONS : "incorrect final end position, " + this.toString();
-  }
-
-  /**
-   * Ensure setFreqCurrentDoc is called, if not already called for the current doc.
-   */
-  private void ensureFreq() throws IOException {
-    int currentDoc = docID();
-    if (lastScoredDoc != currentDoc) {
-      setFreqCurrentDoc();
-      lastScoredDoc = currentDoc;
-    }
-  }
-
-  @Override
-  public final float score() throws IOException {
-    ensureFreq();
-    return scoreCurrentDoc();
-  }
-
-  @Override
-  public final int freq() throws IOException {
-    ensureFreq();
-    return numMatches;
-  }
-
-  /** Returns the intermediate "sloppy freq" adjusted for edit distance
-   *  @lucene.internal */
-  final float sloppyFreq() throws IOException {
-    ensureFreq();
-    return freq;
-  }
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
deleted file mode 100644
index bf6c6d0..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
+++ /dev/null
@@ -1,181 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.Collections;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-
-import org.apache.lucene.index.IndexReaderContext;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.PostingsEnum;
-import org.apache.lucene.index.ReaderUtil;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermContext;
-import org.apache.lucene.index.TermState;
-import org.apache.lucene.index.Terms;
-import org.apache.lucene.index.TermsEnum;
-import org.apache.lucene.search.IndexSearcher;
-
-/** Matches spans containing a term.
- * This should not be used for terms that are indexed at position Integer.MAX_VALUE.
- */
-public class SpanTermQuery extends SpanQuery {
-
-  protected final Term term;
-  protected final TermContext termContext;
-
-  /** Construct a SpanTermQuery matching the named term's spans. */
-  public SpanTermQuery(Term term) {
-    this.term = Objects.requireNonNull(term);
-    this.termContext = null;
-  }
-
-  /**
-   * Expert: Construct a SpanTermQuery matching the named term's spans, using
-   * the provided TermContext
-   */
-  public SpanTermQuery(Term term, TermContext context) {
-    this.term = Objects.requireNonNull(term);
-    this.termContext = context;
-  }
-
-  /** Return the term whose spans are matched. */
-  public Term getTerm() { return term; }
-
-  @Override
-  public String getField() { return term.field(); }
-
-  @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    final TermContext context;
-    final IndexReaderContext topContext = searcher.getTopReaderContext();
-    if (termContext == null || termContext.topReaderContext != topContext) {
-      context = TermContext.build(topContext, term);
-    }
-    else {
-      context = termContext;
-    }
-    return new SpanTermWeight(context, searcher, needsScores ? Collections.singletonMap(term, context) : null);
-  }
-
-  public class SpanTermWeight extends SpanWeight {
-
-    final TermContext termContext;
-
-    public SpanTermWeight(TermContext termContext, IndexSearcher searcher, Map<Term, TermContext> terms) throws IOException {
-      super(SpanTermQuery.this, searcher, terms);
-      this.termContext = termContext;
-      assert termContext != null : "TermContext must not be null";
-    }
-
-    @Override
-    public void extractTerms(Set<Term> terms) {
-      terms.add(term);
-    }
-
-    @Override
-    public void extractTermContexts(Map<Term, TermContext> contexts) {
-      contexts.put(term, termContext);
-    }
-
-    @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
-
-      assert termContext.topReaderContext == ReaderUtil.getTopLevelContext(context) : "The top-reader used to create Weight (" + termContext.topReaderContext + ") is not the same as the current reader's top-reader (" + ReaderUtil.getTopLevelContext(context);
-
-      final TermState state = termContext.get(context.ord);
-      if (state == null) { // term is not present in that reader
-        assert context.reader().docFreq(term) == 0 : "no termstate found but term exists in reader term=" + term;
-        return null;
-      }
-
-      final Terms terms = context.reader().terms(term.field());
-      if (terms == null)
-        return null;
-      if (terms.hasPositions() == false)
-        throw new IllegalStateException("field \"" + term.field() + "\" was indexed without position data; cannot run SpanTermQuery (term=" + term.text() + ")");
-
-      final TermsEnum termsEnum = terms.iterator();
-      termsEnum.seekExact(term.bytes(), state);
-
-      final PostingsEnum postings = termsEnum.postings(null, requiredPostings.getRequiredPostings());
-      float positionsCost = termPositionsCost(termsEnum) * PHRASE_TO_SPAN_TERM_POSITIONS_COST;
-      return new TermSpans(getSimScorer(context), postings, term, positionsCost);
-    }
-  }
-
-  /** A guess of
-   * the relative cost of dealing with the term positions
-   * when using a SpanNearQuery instead of a PhraseQuery.
-   */
-  private static final float PHRASE_TO_SPAN_TERM_POSITIONS_COST = 4.0f;
-
-  private static final int TERM_POSNS_SEEK_OPS_PER_DOC = 128;
-
-  private static final int TERM_OPS_PER_POS = 7;
-
-  /** Returns an expected cost in simple operations
-   *  of processing the occurrences of a term
-   *  in a document that contains the term.
-   *  <br>This may be inaccurate when {@link TermsEnum#totalTermFreq()} is not available.
-   *  @param termsEnum The term is the term at which this TermsEnum is positioned.
-   *  <p>
-   *  This is a copy of org.apache.lucene.search.PhraseQuery.termPositionsCost().
-   *  <br>
-   *  TODO: keep only a single copy of this method and the constants used in it
-   *  when SpanTermQuery moves to the o.a.l.search package.
-   */
-  static float termPositionsCost(TermsEnum termsEnum) throws IOException {
-    int docFreq = termsEnum.docFreq();
-    assert docFreq > 0;
-    long totalTermFreq = termsEnum.totalTermFreq(); // -1 when not available
-    float expOccurrencesInMatchingDoc = (totalTermFreq < docFreq) ? 1 : (totalTermFreq / (float) docFreq);
-    return TERM_POSNS_SEEK_OPS_PER_DOC + expOccurrencesInMatchingDoc * TERM_OPS_PER_POS;
-  }
-
-  @Override
-  public String toString(String field) {
-    StringBuilder buffer = new StringBuilder();
-    if (term.field().equals(field))
-      buffer.append(term.text());
-    else
-      buffer.append(term.toString());
-    return buffer.toString();
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = super.hashCode();
-    result = prime * result + term.hashCode();
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (! super.equals(obj)) {
-      return false;
-    }
-    SpanTermQuery other = (SpanTermQuery) obj;
-    return term.equals(other.term);
-  }
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
deleted file mode 100644
index 8209bd0..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.Map;
-
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.PostingsEnum;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermContext;
-import org.apache.lucene.search.CollectionStatistics;
-import org.apache.lucene.search.Explanation;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.TermStatistics;
-import org.apache.lucene.search.Weight;
-import org.apache.lucene.search.similarities.Similarity;
-import org.apache.lucene.search.similarities.Similarity.SimScorer;
-
-/**
- * Expert-only.  Public for use by other weight implementations
- */
-public abstract class SpanWeight extends Weight {
-
-  /**
-   * Enumeration defining what postings information should be retrieved from the
-   * index for a given Spans
-   */
-  public enum Postings {
-    POSITIONS {
-      @Override
-      public int getRequiredPostings() {
-        return PostingsEnum.POSITIONS;
-      }
-    },
-    PAYLOADS {
-      @Override
-      public int getRequiredPostings() {
-        return PostingsEnum.PAYLOADS;
-      }
-    },
-    OFFSETS {
-      @Override
-      public int getRequiredPostings() {
-        return PostingsEnum.PAYLOADS | PostingsEnum.OFFSETS;
-      }
-    };
-
-    public abstract int getRequiredPostings();
-
-    public Postings atLeast(Postings postings) {
-      if (postings.compareTo(this) > 0)
-        return postings;
-      return this;
-    }
-  }
-
-  protected final Similarity similarity;
-  protected final Similarity.SimWeight simWeight;
-  protected final String field;
-
-  /**
-   * Create a new SpanWeight
-   * @param query the parent query
-   * @param searcher the IndexSearcher to query against
-   * @param termContexts a map of terms to termcontexts for use in building the similarity.  May
-   *                     be null if scores are not required
-   * @throws IOException on error
-   */
-  public SpanWeight(SpanQuery query, IndexSearcher searcher, Map<Term, TermContext> termContexts) throws IOException {
-    super(query);
-    this.field = query.getField();
-    this.similarity = searcher.getSimilarity(termContexts != null);
-    this.simWeight = buildSimWeight(query, searcher, termContexts);
-  }
-
-  private Similarity.SimWeight buildSimWeight(SpanQuery query, IndexSearcher searcher, Map<Term, TermContext> termContexts) throws IOException {
-    if (termContexts == null || termContexts.size() == 0 || query.getField() == null)
-      return null;
-    TermStatistics[] termStats = new TermStatistics[termContexts.size()];
-    int i = 0;
-    for (Term term : termContexts.keySet()) {
-      termStats[i] = searcher.termStatistics(term, termContexts.get(term));
-      i++;
-    }
-    CollectionStatistics collectionStats = searcher.collectionStatistics(query.getField());
-    return searcher.getSimilarity(true).computeWeight(collectionStats, termStats);
-  }
-
-  /**
-   * Collect all TermContexts used by this Weight
-   * @param contexts a map to add the TermContexts to
-   */
-  public abstract void extractTermContexts(Map<Term, TermContext> contexts);
-
-  /**
-   * Expert: Return a Spans object iterating over matches from this Weight
-   * @param ctx a LeafReaderContext for this Spans
-   * @return a Spans
-   * @throws IOException on error
-   */
-  public abstract Spans getSpans(LeafReaderContext ctx, Postings requiredPostings) throws IOException;
-
-  @Override
-  public float getValueForNormalization() throws IOException {
-    return simWeight == null ? 1.0f : simWeight.getValueForNormalization();
-  }
-
-  @Override
-  public void normalize(float queryNorm, float boost) {
-    if (simWeight != null) {
-      simWeight.normalize(queryNorm, boost);
-    }
-  }
-
-  @Override
-  public SpanScorer scorer(LeafReaderContext context) throws IOException {
-    final Spans spans = getSpans(context, Postings.POSITIONS);
-    if (spans == null) {
-      return null;
-    }
-    final Similarity.SimScorer docScorer = getSimScorer(context);
-    return new SpanScorer(this, spans, docScorer);
-  }
-
-  /**
-   * Return a SimScorer for this context
-   * @param context the LeafReaderContext
-   * @return a SimWeight
-   * @throws IOException on error
-   */
-  public Similarity.SimScorer getSimScorer(LeafReaderContext context) throws IOException {
-    return simWeight == null ? null : similarity.simScorer(simWeight, context);
-  }
-
-  @Override
-  public Explanation explain(LeafReaderContext context, int doc) throws IOException {
-    SpanScorer scorer = scorer(context);
-    if (scorer != null) {
-      int newDoc = scorer.iterator().advance(doc);
-      if (newDoc == doc) {
-        float freq = scorer.sloppyFreq();
-        SimScorer docScorer = similarity.simScorer(simWeight, context);
-        Explanation freqExplanation = Explanation.match(freq, "phraseFreq=" + freq);
-        Explanation scoreExplanation = docScorer.explain(doc, freqExplanation);
-        return Explanation.match(scoreExplanation.getValue(),
-            "weight("+getQuery()+" in "+doc+") [" + similarity.getClass().getSimpleName() + "], result of:",
-            scoreExplanation);
-      }
-    }
-
-    return Explanation.noMatch("no matching term");
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java
deleted file mode 100644
index 6fbfb67..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Map;
-
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermContext;
-import org.apache.lucene.search.IndexSearcher;
-
-/** Keep matches that are contained within another Spans. */
-public final class SpanWithinQuery extends SpanContainQuery {
-
-  /** Construct a SpanWithinQuery matching spans from <code>little</code>
-   * that are inside of <code>big</code>.
-   * This query has the boost of <code>little</code>.
-   * <code>big</code> and <code>little</code> must be in the same field.
-   */
-  public SpanWithinQuery(SpanQuery big, SpanQuery little) {
-    super(big, little);
-  }
-
-  @Override
-  public String toString(String field) {
-    return toString(field, "SpanWithin");
-  }
-
-  @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    SpanWeight bigWeight = big.createWeight(searcher, false);
-    SpanWeight littleWeight = little.createWeight(searcher, false);
-    return new SpanWithinWeight(searcher, needsScores ? getTermContexts(bigWeight, littleWeight) : null,
-                                      bigWeight, littleWeight);
-  }
-
-  public class SpanWithinWeight extends SpanContainWeight {
-
-    public SpanWithinWeight(IndexSearcher searcher, Map<Term, TermContext> terms,
-                            SpanWeight bigWeight, SpanWeight littleWeight) throws IOException {
-      super(searcher, terms, bigWeight, littleWeight);
-    }
-
-    /**
-     * Return spans from <code>little</code> that are contained in a spans from <code>big</code>.
-     * The payload is from the spans of <code>little</code>.
-     */
-    @Override
-    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
-      ArrayList<Spans> containerContained = prepareConjunction(context, requiredPostings);
-      if (containerContained == null) {
-        return null;
-      }
-
-      Spans big = containerContained.get(0);
-      Spans little = containerContained.get(1);
-
-      return new ContainSpans(big, little, little) {
-
-        @Override
-        boolean twoPhaseCurrentDocMatches() throws IOException {
-          oneExhaustedInCurrentDoc = false;
-          assert littleSpans.startPosition() == -1;
-          while (littleSpans.nextStartPosition() != NO_MORE_POSITIONS) {
-            while (bigSpans.endPosition() < littleSpans.endPosition()) {
-              if (bigSpans.nextStartPosition() == NO_MORE_POSITIONS) {
-                oneExhaustedInCurrentDoc = true;
-                return false;
-              }
-            }
-            if (bigSpans.startPosition() <= littleSpans.startPosition()) {
-              atFirstInCurrentDoc = true;
-              return true;
-            }
-          }
-          oneExhaustedInCurrentDoc = true;
-          return false;
-        }
-
-        @Override
-        public int nextStartPosition() throws IOException {
-          if (atFirstInCurrentDoc) {
-            atFirstInCurrentDoc = false;
-            return littleSpans.startPosition();
-          }
-          while (littleSpans.nextStartPosition() != NO_MORE_POSITIONS) {
-            while (bigSpans.endPosition() < littleSpans.endPosition()) {
-              if (bigSpans.nextStartPosition() == NO_MORE_POSITIONS) {
-                oneExhaustedInCurrentDoc = true;
-                return NO_MORE_POSITIONS;
-              }
-            }
-            if (bigSpans.startPosition() <= littleSpans.startPosition()) {
-              return littleSpans.startPosition();
-            }
-          }
-          oneExhaustedInCurrentDoc = true;
-          return NO_MORE_POSITIONS;
-        }
-      };
-    }
-  }
-
-}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java b/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
deleted file mode 100644
index 7857708..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.search.Scorer;
-import org.apache.lucene.search.TwoPhaseIterator;
-import org.apache.lucene.search.similarities.Similarity.SimScorer;
-
-/** Iterates through combinations of start/end positions per-doc.
- *  Each start/end position represents a range of term positions within the current document.
- *  These are enumerated in order, by increasing document number, within that by
- *  increasing start position and finally by increasing end position.
- */
-public abstract class Spans extends DocIdSetIterator {
-
-  public static final int NO_MORE_POSITIONS = Integer.MAX_VALUE;
-
-  /**
-   * Returns the next start position for the current doc.
-   * There is always at least one start/end position per doc.
-   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
-   */
-  public abstract int nextStartPosition() throws IOException;
-
-  /**
-   * Returns the start position in the current doc, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
-   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
-   */
-  public abstract int startPosition();
-
-  /**
-   * Returns the end position for the current start position, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
-   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
-   */
-  public abstract int endPosition();
-
-  /**
-   * Return the width of the match, which is typically used to compute
-   * the {@link SimScorer#computeSlopFactor(int) slop factor}. It is only legal
-   * to call this method when the iterator is on a valid doc ID and positioned.
-   * The return value must be positive, and lower values means that the match is
-   * better.
-   */
-  public abstract int width();
-
-  /**
-   * Collect postings data from the leaves of the current Spans.
-   *
-   * This method should only be called after {@link #nextStartPosition()}, and before
-   * {@link #NO_MORE_POSITIONS} has been reached.
-   *
-   * @param collector a SpanCollector
-   *
-   * @lucene.experimental
-   */
-  public abstract void collect(SpanCollector collector) throws IOException;
-
-  /**
-   * Return an estimation of the cost of using the positions of
-   * this {@link Spans} for any single document, but only after
-   * {@link #asTwoPhaseIterator} returned {@code null}.
-   * Otherwise this method should not be called.
-   * The returned value is independent of the current document.
-   *
-   * @lucene.experimental
-   */
-  public abstract float positionsCost();
-
-  /**
-   * Optional method: Return a {@link TwoPhaseIterator} view of this
-   * {@link Scorer}. A return value of {@code null} indicates that
-   * two-phase iteration is not supported.
-   * @see Scorer#twoPhaseIterator()
-   */
-  public TwoPhaseIterator asTwoPhaseIterator() {
-    return null;
-  }
-
-  @Override
-  public String toString() {
-    StringBuilder sb = new StringBuilder();
-    Class<? extends Spans> clazz = getClass();
-    sb.append(clazz.isAnonymousClass() ? clazz.getName() : clazz.getSimpleName());
-    sb.append("(doc=").append(docID());
-    sb.append(",start=").append(startPosition());
-    sb.append(",end=").append(endPosition());
-    sb.append(")");
-    return sb.toString();
-  }
-
-  /**
-   * Called before the current doc's frequency is calculated
-   */
-  protected void doStartCurrentDoc() throws IOException {}
-
-  /**
-   * Called each time the scorer's SpanScorer is advanced during frequency calculation
-   */
-  protected void doCurrentSpans() throws IOException {}
-
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
deleted file mode 100644
index f1e1aed..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-import java.io.IOException;
-import java.util.Objects;
-
-import org.apache.lucene.index.PostingsEnum;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.search.similarities.Similarity;
-
-/**
- * Expert:
- * Public for extension only.
- * This does not work correctly for terms that indexed at position Integer.MAX_VALUE.
- */
-public class TermSpans extends Spans {
-  protected final PostingsEnum postings;
-  protected final Term term;
-  protected int doc;
-  protected int freq;
-  protected int count;
-  protected int position;
-  protected boolean readPayload;
-  private final float positionsCost;
-
-  public TermSpans(Similarity.SimScorer scorer,
-                    PostingsEnum postings, Term term, float positionsCost) {
-    this.postings = Objects.requireNonNull(postings);
-    this.term = Objects.requireNonNull(term);
-    this.doc = -1;
-    this.position = -1;
-    assert positionsCost > 0; // otherwise the TermSpans should not be created.
-    this.positionsCost = positionsCost;
-  }
-
-  @Override
-  public int nextDoc() throws IOException {
-    doc = postings.nextDoc();
-    if (doc != DocIdSetIterator.NO_MORE_DOCS) {
-      freq = postings.freq();
-      assert freq >= 1;
-      count = 0;
-    }
-    position = -1;
-    return doc;
-  }
-
-  @Override
-  public int advance(int target) throws IOException {
-    assert target > doc;
-    doc = postings.advance(target);
-    if (doc != DocIdSetIterator.NO_MORE_DOCS) {
-      freq = postings.freq();
-      assert freq >= 1;
-      count = 0;
-    }
-    position = -1;
-    return doc;
-  }
-
-  @Override
-  public int docID() {
-    return doc;
-  }
-
-  @Override
-  public int nextStartPosition() throws IOException {
-    if (count == freq) {
-      assert position != NO_MORE_POSITIONS;
-      return position = NO_MORE_POSITIONS;
-    }
-    int prevPosition = position;
-    position = postings.nextPosition();
-    assert position >= prevPosition : "prevPosition="+prevPosition+" > position="+position;
-    assert position != NO_MORE_POSITIONS; // int endPosition not possible
-    count++;
-    readPayload = false;
-    return position;
-  }
-
-  @Override
-  public int startPosition() {
-    return position;
-  }
-
-  @Override
-  public int endPosition() {
-    return (position == -1) ? -1
-          : (position != NO_MORE_POSITIONS) ? position + 1
-          : NO_MORE_POSITIONS;
-  }
-
-  @Override
-  public int width() {
-    return 0;
-  }
-
-  @Override
-  public long cost() {
-    return postings.cost();
-  }
-
-  @Override
-  public void collect(SpanCollector collector) throws IOException {
-    collector.collectLeaf(postings, position, term);
-  }
-
-  @Override
-  public float positionsCost() {
-    return positionsCost;
-  }
-
-  @Override
-  public String toString() {
-    return "spans(" + term.toString() + ")@" +
-            (doc == -1 ? "START" : (doc == NO_MORE_DOCS) ? "ENDDOC"
-              : doc + " - " + (position == NO_MORE_POSITIONS ? "ENDPOS" : position));
-  }
-
-  public PostingsEnum getPostings() {
-    return postings;
-  }
-}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/package-info.java b/lucene/core/src/java/org/apache/lucene/search/spans/package-info.java
deleted file mode 100644
index 4fc88d3..0000000
--- a/lucene/core/src/java/org/apache/lucene/search/spans/package-info.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * The calculus of spans.
- * 
- * <p>A span is a <code>&lt;doc,startPosition,endPosition&gt;</code> tuple  that is enumerated by
- *    class {@link org.apache.lucene.search.spans.Spans Spans}.
- *  </p>
- * 
- * <p>The following span query operators are implemented:
- * 
- * <ul>
- * 
- * <li>A {@link org.apache.lucene.search.spans.SpanTermQuery SpanTermQuery} matches all spans
- *    containing a particular {@link org.apache.lucene.index.Term Term}.
- *    This should not be used for terms that are indexed at position Integer.MAX_VALUE.
- * </li>
- * 
- * <li> A {@link org.apache.lucene.search.spans.SpanNearQuery SpanNearQuery} matches spans
- * which occur near one another, and can be used to implement things like
- * phrase search (when constructed from {@link org.apache.lucene.search.spans.SpanTermQuery}s)
- * and inter-phrase proximity (when constructed from other {@link org.apache.lucene.search.spans.SpanNearQuery}s).</li>
- *
- * <li> A {@link org.apache.lucene.search.spans.SpanWithinQuery SpanWithinQuery} matches spans
- * which occur inside of another spans. </li>
- *
- * <li> A {@link org.apache.lucene.search.spans.SpanContainingQuery SpanContainingQuery} matches spans
- * which contain another spans. </li>
- * 
- * <li>A {@link org.apache.lucene.search.spans.SpanOrQuery SpanOrQuery} merges spans from a
- * number of other {@link org.apache.lucene.search.spans.SpanQuery}s.</li>
- * 
- * <li>A {@link org.apache.lucene.search.spans.SpanNotQuery SpanNotQuery} removes spans
- * matching one {@link org.apache.lucene.search.spans.SpanQuery SpanQuery} which overlap (or comes
- * near) another.  This can be used, e.g., to implement within-paragraph
- * search.</li>
- * 
- * <li>A {@link org.apache.lucene.search.spans.SpanFirstQuery SpanFirstQuery} matches spans
- * matching <code>q</code> whose end position is less than
- * <code>n</code>.  This can be used to constrain matches to the first
- * part of the document.</li>
- * 
- * <li>A {@link org.apache.lucene.search.spans.SpanPositionRangeQuery SpanPositionRangeQuery} is
- * a more general form of SpanFirstQuery that can constrain matches to arbitrary portions of the document.</li>
- * 
- * </ul>
- * 
- * In all cases, output spans are minimally inclusive.  In other words, a
- * span formed by matching a span in x and y starts at the lesser of the
- * two starts and ends at the greater of the two ends.
- * 
- * <p>For example, a span query which matches "John Kerry" within ten
- * words of "George Bush" within the first 100 words of the document
- * could be constructed with:
- * <pre class="prettyprint">
- * SpanQuery john   = new SpanTermQuery(new Term("content", "john"));
- * SpanQuery kerry  = new SpanTermQuery(new Term("content", "kerry"));
- * SpanQuery george = new SpanTermQuery(new Term("content", "george"));
- * SpanQuery bush   = new SpanTermQuery(new Term("content", "bush"));
- * 
- * SpanQuery johnKerry =
- *    new SpanNearQuery(new SpanQuery[] {john, kerry}, 0, true);
- * 
- * SpanQuery georgeBush =
- *    new SpanNearQuery(new SpanQuery[] {george, bush}, 0, true);
- * 
- * SpanQuery johnKerryNearGeorgeBush =
- *    new SpanNearQuery(new SpanQuery[] {johnKerry, georgeBush}, 10, false);
- * 
- * SpanQuery johnKerryNearGeorgeBushAtStart =
- *    new SpanFirstQuery(johnKerryNearGeorgeBush, 100);
- * </pre>
- * 
- * <p>Span queries may be freely intermixed with other Lucene queries.
- * So, for example, the above query can be restricted to documents which
- * also use the word "iraq" with:
- * 
- * <pre class="prettyprint">
- * Query query = new BooleanQuery();
- * query.add(johnKerryNearGeorgeBushAtStart, true, false);
- * query.add(new TermQuery("content", "iraq"), true, false);
- * </pre>
- */
-package org.apache.lucene.search.spans;
diff --git a/lucene/core/src/test/org/apache/lucene/search/JustCompileSearchSpans.java b/lucene/core/src/test/org/apache/lucene/search/JustCompileSearchSpans.java
new file mode 100644
index 0000000..ee48d73
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/JustCompileSearchSpans.java
@@ -0,0 +1,111 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.SpanCollector;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanWeight;
+import org.apache.lucene.search.Spans;
+
+/**
+ * Holds all implementations of classes in the o.a.l.s.spans package as a
+ * back-compatibility test. It does not run any tests per-se, however if
+ * someone adds a method to an interface or abstract method to an abstract
+ * class, one of the implementations here will fail to compile and so we know
+ * back-compat policy was violated.
+ */
+final class JustCompileSearchSpans {
+
+  private static final String UNSUPPORTED_MSG = "unsupported: used for back-compat testing only !";
+
+  static final class JustCompileSpans extends Spans {
+
+    @Override
+    public int docID() {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+    
+    @Override
+    public int startPosition() {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+
+    @Override
+    public int endPosition() {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+
+    @Override
+    public int width() {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+
+    @Override
+    public void collect(SpanCollector collector) throws IOException {
+
+    }
+
+    @Override
+    public int nextStartPosition() throws IOException {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+
+    @Override
+    public long cost() {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+
+    @Override
+    public float positionsCost() {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+  }
+
+  static final class JustCompileSpanQuery extends SpanQuery {
+
+    @Override
+    public String getField() {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+
+    @Override
+    public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+
+    @Override
+    public String toString(String field) {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+    
+  }
+
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBasics.java b/lucene/core/src/test/org/apache/lucene/search/TestBasics.java
new file mode 100644
index 0000000..c6caea2
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBasics.java
@@ -0,0 +1,407 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.*;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.English;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+
+import static org.apache.lucene.search.spans.SpanTestUtil.*;
+
+/**
+ * Tests basic search capabilities.
+ *
+ * <p>Uses a collection of 1000 documents, each the english rendition of their
+ * document number.  For example, the document numbered 333 has text "three
+ * hundred thirty three".
+ *
+ * <p>Tests are each a single query, and its hits are checked to ensure that
+ * all and only the correct documents are returned, thus providing end-to-end
+ * testing of the indexing and search code.
+ *
+ */
+public class TestBasics extends LuceneTestCase {
+  private static IndexSearcher searcher;
+  private static IndexReader reader;
+  private static Directory directory;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.SIMPLE, true))
+            .setMaxBufferedDocs(TestUtil.nextInt(random(), 100, 1000)).setMergePolicy(newLogMergePolicy()));
+    //writer.infoStream = System.out;
+    for (int i = 0; i < 2000; i++) {
+      Document doc = new Document();
+      doc.add(newTextField("field", English.intToEnglish(i), Field.Store.YES));
+      writer.addDocument(doc);
+    }
+    reader = writer.getReader();
+    searcher = newSearcher(reader);
+    writer.close();
+  }
+
+  @AfterClass
+  public static void afterClass() throws Exception {
+    reader.close();
+    directory.close();
+    searcher = null;
+    reader = null;
+    directory = null;
+  }
+
+  public void testTerm() throws Exception {
+    Query query = new TermQuery(new Term("field", "seventy"));
+    checkHits(query, new int[]
+      {70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 170, 171, 172, 173, 174, 175,
+              176, 177, 178, 179, 270, 271, 272, 273, 274, 275, 276, 277, 278,
+              279, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 470, 471,
+              472, 473, 474, 475, 476, 477, 478, 479, 570, 571, 572, 573, 574,
+              575, 576, 577, 578, 579, 670, 671, 672, 673, 674, 675, 676, 677,
+              678, 679, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 870,
+              871, 872, 873, 874, 875, 876, 877, 878, 879, 970, 971, 972, 973,
+              974, 975, 976, 977, 978, 979, 1070, 1071, 1072, 1073, 1074, 1075,
+              1076, 1077, 1078, 1079, 1170, 1171, 1172, 1173, 1174, 1175, 1176,
+              1177, 1178, 1179, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277,
+              1278, 1279, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378,
+              1379, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479,
+              1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1670,
+              1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1770, 1771,
+              1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1870, 1871, 1872,
+              1873, 1874, 1875, 1876, 1877,
+              1878, 1879, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978,
+              1979});
+    }
+
+  public void testTerm2() throws Exception {
+    Query query = new TermQuery(new Term("field", "seventish"));
+    checkHits(query, new int[] {});
+  }
+
+  public void testPhrase() throws Exception {
+    PhraseQuery query = new PhraseQuery("field", "seventy", "seven");
+    checkHits(query, new int[]
+      {77, 177, 277, 377, 477, 577, 677, 777, 877,
+              977, 1077, 1177, 1277, 1377, 1477, 1577, 1677, 1777, 1877, 1977});
+  }
+
+  public void testPhrase2() throws Exception {
+    PhraseQuery query = new PhraseQuery("field", "seventish", "sevenon");
+    checkHits(query, new int[] {});
+  }
+
+  public void testBoolean() throws Exception {
+    BooleanQuery.Builder query = new BooleanQuery.Builder();
+    query.add(new TermQuery(new Term("field", "seventy")), BooleanClause.Occur.MUST);
+    query.add(new TermQuery(new Term("field", "seven")), BooleanClause.Occur.MUST);
+    checkHits(query.build(), new int[]
+      {77, 177, 277, 377, 477, 577, 677, 770, 771, 772, 773, 774, 775, 776, 777,
+              778, 779, 877, 977, 1077, 1177, 1277, 1377, 1477, 1577, 1677,
+              1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1877,
+              1977});
+  }
+
+  public void testBoolean2() throws Exception {
+    BooleanQuery.Builder query = new BooleanQuery.Builder();
+    query.add(new TermQuery(new Term("field", "sevento")), BooleanClause.Occur.MUST);
+    query.add(new TermQuery(new Term("field", "sevenly")), BooleanClause.Occur.MUST);
+    checkHits(query.build(), new int[] {});
+  }
+
+  public void testSpanNearExact() throws Exception {
+    SpanQuery query = spanNearOrderedQuery("field", 0, "seventy", "seven");
+    
+    checkHits(query, new int[]
+      {77, 177, 277, 377, 477, 577, 677, 777, 877, 977, 1077, 1177, 1277, 1377, 1477, 1577, 1677, 1777, 1877, 1977});
+
+    assertTrue(searcher.explain(query, 77).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 977).getValue() > 0.0f);
+  }
+  
+  public void testSpanTermQuery() throws Exception {
+    checkHits(spanTermQuery("field", "seventy"), 
+              new int[] { 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 170,
+        171, 172, 173, 174, 175, 176, 177, 178, 179, 270, 271, 272, 273, 274,
+        275, 276, 277, 278, 279, 370, 371, 372, 373, 374, 375, 376, 377, 378,
+        379, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 570, 571, 572,
+        573, 574, 575, 576, 577, 578, 579, 670, 671, 672, 673, 674, 675, 676,
+        677, 678, 679, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 870,
+        871, 872, 873, 874, 875, 876, 877, 878, 879, 970, 971, 972, 973, 974,
+        975, 976, 977, 978, 979, 1070, 1071, 1072, 1073, 1074, 1075, 1076,
+        1077, 1078, 1079, 1170, 1270, 1370, 1470, 1570, 1670, 1770, 1870, 1970,
+        1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1271, 1272, 1273,
+        1274, 1275, 1276, 1277, 1278, 1279, 1371, 1372, 1373, 1374, 1375, 1376,
+        1377, 1378, 1379, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479,
+        1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1671, 1672, 1673,
+        1674, 1675, 1676, 1677, 1678, 1679, 1771, 1772, 1773, 1774, 1775, 1776,
+        1777, 1778, 1779, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879,
+        1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979 });
+  }
+
+  public void testSpanNearUnordered() throws Exception {
+    checkHits(spanNearUnorderedQuery("field", 4, "nine", "six"), 
+              new int[] { 609, 629, 639, 649, 659, 669, 679, 689, 699, 906, 926, 936, 946, 956,
+              966, 976, 986, 996, 1609, 1629, 1639, 1649, 1659, 1669,
+              1679, 1689, 1699, 1906, 1926, 1936, 1946, 1956, 1966, 1976, 1986,
+              1996});
+  }
+
+  public void testSpanNearOrdered() throws Exception {
+    checkHits(spanNearOrderedQuery("field", 4, "nine", "six"), 
+              new int[] { 906, 926, 936, 946, 956, 966, 976, 986, 996, 1906, 1926, 
+                          1936, 1946, 1956, 1966, 1976, 1986, 1996});
+  }
+
+  public void testSpanNot() throws Exception {
+    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
+    SpanQuery query = spanNotQuery(near, spanTermQuery("field", "forty"));
+
+    checkHits(query, new int[]
+      {801, 821, 831, 851, 861, 871, 881, 891, 1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
+
+    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+  
+  public void testSpanWithMultipleNotSingle() throws Exception {
+    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
+    SpanQuery or = spanOrQuery("field", "forty");
+    SpanQuery query = spanNotQuery(near, or);
+
+    checkHits(query, new int[]
+      {801, 821, 831, 851, 861, 871, 881, 891,
+              1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
+
+    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+
+  public void testSpanWithMultipleNotMany() throws Exception {
+    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
+    SpanQuery or = spanOrQuery("field", "forty", "sixty", "eighty");
+    SpanQuery query = spanNotQuery(near, or);
+
+    checkHits(query, new int[]
+      {801, 821, 831, 851, 871, 891, 1801, 1821, 1831, 1851, 1871, 1891});
+
+    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+
+  public void testNpeInSpanNearWithSpanNot() throws Exception {
+    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
+    SpanQuery exclude = spanNearOrderedQuery("field", 1, "hundred", "forty");
+    SpanQuery query = spanNotQuery(near, exclude);
+
+    checkHits(query, new int[]
+      {801, 821, 831, 851, 861, 871, 881, 891,
+              1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
+
+    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+
+  public void testNpeInSpanNearInSpanFirstInSpanNot() throws Exception {
+    final int n = 5;
+    SpanQuery include = spanFirstQuery(spanTermQuery("field", "forty"), n);
+    SpanQuery near = spanNearOrderedQuery("field", n-1, "hundred", "forty");
+    SpanQuery exclude = spanFirstQuery(near, n-1);
+    SpanQuery q = spanNotQuery(include, exclude);
+    
+    checkHits(q, new int[]{40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048,
+            1049, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1240, 1241, 1242, 1243, 1244,
+            1245, 1246, 1247, 1248, 1249, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1440, 1441, 1442,
+            1443, 1444, 1445, 1446, 1447, 1448, 1449, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1640,
+            1641, 1642, 1643, 1644, 1645, 1646, 1647,
+            1648, 1649, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1840, 1841, 1842, 1843, 1844, 1845, 1846,
+            1847, 1848, 1849, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949});
+  }
+  
+  public void testSpanNotWindowOne() throws Exception {
+    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "forty");
+    SpanQuery query = spanNotQuery(near, spanTermQuery("field", "one"), 1, 1);
+
+    checkHits(query, new int[]
+      {840, 842, 843, 844, 845, 846, 847, 848, 849,
+          1840, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849});
+
+    assertTrue(searcher.explain(query, 840).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 1842).getValue() > 0.0f);
+  }
+  
+  public void testSpanNotWindowTwoBefore() throws Exception {
+    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "forty");
+    SpanQuery query = spanNotQuery(near, spanTermQuery("field", "one"), 2, 0);
+
+    checkHits(query, new int[]
+      {840, 841, 842, 843, 844, 845, 846, 847, 848, 849});
+
+    assertTrue(searcher.explain(query, 840).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 849).getValue() > 0.0f);
+  }
+
+  public void testSpanNotWindowNeg() throws Exception {
+    //test handling of invalid window < 0
+    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
+    SpanQuery or = spanOrQuery("field", "forty");
+    SpanQuery query = spanNotQuery(near, or);
+
+    checkHits(query, new int[]
+       {801, 821, 831, 851, 861, 871, 881, 891,
+               1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
+
+    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+  
+  public void testSpanNotWindowDoubleExcludesBefore() throws Exception {
+    //test hitting two excludes before an include
+    SpanQuery near = spanNearOrderedQuery("field", 2, "forty", "two");
+    SpanQuery exclude = spanTermQuery("field", "one");
+    SpanQuery query = spanNotQuery(near, exclude, 4, 1);
+
+    checkHits(query, new int[]
+       {42, 242, 342, 442, 542, 642, 742, 842, 942});
+
+    assertTrue(searcher.explain(query, 242).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 942).getValue() > 0.0f);
+  }
+  
+  public void testSpanFirst() throws Exception {
+    SpanQuery query = spanFirstQuery(spanTermQuery("field", "five"), 1);
+
+    checkHits(query, new int[]
+      {5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513,
+       514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527,
+       528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541,
+       542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555,
+       556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569,
+       570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583,
+       584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597,
+       598, 599});
+
+    assertTrue(searcher.explain(query, 5).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 599).getValue() > 0.0f);
+
+  }
+
+  public void testSpanPositionRange() throws Exception {
+    SpanQuery term1 = spanTermQuery("field", "five");
+    SpanQuery query = spanPositionRangeQuery(term1, 1, 2);
+    
+    checkHits(query, new int[]
+      {25,35, 45, 55, 65, 75, 85, 95});
+    assertTrue(searcher.explain(query, 25).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 95).getValue() > 0.0f);
+
+    query = spanPositionRangeQuery(term1, 0, 1);
+    checkHits(query, new int[]
+      {5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512,
+              513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525,
+              526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538,
+              539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551,
+              552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564,
+              565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577,
+              578, 579, 580, 581, 582, 583, 584,
+              585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597,
+              598, 599});
+
+    query = spanPositionRangeQuery(term1, 6, 7);
+    checkHits(query, new int[]{});
+  }
+
+  public void testSpanOr() throws Exception {
+    SpanQuery near1 = spanNearOrderedQuery("field", 0, "thirty", "three");
+    SpanQuery near2 = spanNearOrderedQuery("field", 0, "forty", "seven");
+    SpanQuery query = spanOrQuery(near1, near2);
+
+    checkHits(query, new int[]
+      {33, 47, 133, 147, 233, 247, 333, 347, 433, 447, 533, 547, 633, 647, 733,
+              747, 833, 847, 933, 947, 1033, 1047, 1133, 1147, 1233, 1247, 1333,
+              1347, 1433, 1447, 1533, 1547, 1633, 1647, 1733, 1747, 1833, 1847, 1933, 1947});
+
+    assertTrue(searcher.explain(query, 33).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 947).getValue() > 0.0f);
+  }
+
+  public void testSpanExactNested() throws Exception {
+    SpanQuery near1 = spanNearOrderedQuery("field", 0, "three", "hundred");
+    SpanQuery near2 = spanNearOrderedQuery("field", 0, "thirty", "three");
+    SpanQuery query = spanNearOrderedQuery(0, near1, near2);
+    
+    checkHits(query, new int[] {333, 1333});
+
+    assertTrue(searcher.explain(query, 333).getValue() > 0.0f);
+  }
+
+  public void testSpanNearOr() throws Exception {
+    SpanQuery to1 = spanOrQuery("field", "six", "seven");
+    SpanQuery to2 = spanOrQuery("field", "seven", "six");
+    SpanQuery query = spanNearOrderedQuery(10, to1, to2);
+    
+    checkHits(query, new int[]
+      {606, 607, 626, 627, 636, 637, 646, 647, 656, 657, 666, 667, 676, 677,
+              686, 687, 696, 697, 706, 707, 726, 727, 736, 737, 746, 747, 756,
+              757, 766, 767, 776, 777, 786, 787, 796, 797, 1606, 1607, 1626,
+              1627, 1636, 1637, 1646, 1647, 1656, 1657, 1666, 1667, 1676, 1677,
+              1686, 1687, 1696, 1697, 1706, 1707, 1726, 1727, 1736, 1737,
+              1746, 1747, 1756, 1757, 1766, 1767, 1776, 1777, 1786, 1787, 1796,
+              1797});
+  }
+
+  public void testSpanComplex1() throws Exception {
+    SpanQuery tt1 = spanNearOrderedQuery("field", 0, "six", "hundred");
+    SpanQuery tt2 = spanNearOrderedQuery("field", 0, "seven", "hundred");
+
+    SpanQuery to1 = spanOrQuery(tt1, tt2);
+    SpanQuery to2 = spanOrQuery("field", "seven", "six");
+    SpanQuery query = spanNearOrderedQuery(100, to1, to2);
+    
+    checkHits(query, new int[]
+      {606, 607, 626, 627, 636, 637, 646, 647, 656, 657, 666, 667, 676, 677, 686, 687, 696,
+              697, 706, 707, 726, 727, 736, 737, 746, 747, 756, 757,
+              766, 767, 776, 777, 786, 787, 796, 797, 1606, 1607, 1626, 1627, 1636, 1637, 1646,
+              1647, 1656, 1657,
+              1666, 1667, 1676, 1677, 1686, 1687, 1696, 1697, 1706, 1707, 1726, 1727, 1736, 1737,
+              1746, 1747, 1756, 1757, 1766, 1767, 1776, 1777, 1786, 1787, 1796, 1797});
+  }
+  
+  private void checkHits(Query query, int[] results) throws IOException {
+    CheckHits.checkHits(random(), query, "field", searcher, results);
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java
index 3970355..99bc82c 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBooleanQuery.java
@@ -46,8 +46,6 @@ import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanTopLevelScorers.BoostedScorer;
 import org.apache.lucene.search.similarities.ClassicSimilarity;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.NamedThreadFactory;
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestComplexExplanations.java b/lucene/core/src/test/org/apache/lucene/search/TestComplexExplanations.java
index 1a4591d..47568b0 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestComplexExplanations.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestComplexExplanations.java
@@ -24,7 +24,6 @@ import java.util.List;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.similarities.ClassicSimilarity;
-import org.apache.lucene.search.spans.*;
 
 /**
  * TestExplanations subclass that builds up super crazy complex queries
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java
index 79c32d3..40e1081 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java
@@ -39,7 +39,6 @@ import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestFieldMaskingSpanQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestFieldMaskingSpanQuery.java
new file mode 100644
index 0000000..f8662f3
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestFieldMaskingSpanQuery.java
@@ -0,0 +1,323 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.FieldMaskingSpanQuery;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.search.SpanWeight;
+import org.apache.lucene.search.Spans;
+import org.apache.lucene.search.similarities.TFIDFSimilarity;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+
+import static org.apache.lucene.search.spans.SpanTestUtil.assertFinished;
+import static org.apache.lucene.search.spans.SpanTestUtil.assertNext;
+
+public class TestFieldMaskingSpanQuery extends LuceneTestCase {
+
+  protected static Document doc(Field[] fields) {
+    Document doc = new Document();
+    for (int i = 0; i < fields.length; i++) {
+      doc.add(fields[i]);
+    }
+    return doc;
+  }
+  
+  protected static Field field(String name, String value) {
+    return newTextField(name, value, Field.Store.NO);
+  }
+
+  protected static IndexSearcher searcher;
+  protected static Directory directory;
+  protected static IndexReader reader;
+  
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    directory = newDirectory();
+    RandomIndexWriter writer= new RandomIndexWriter(random(), directory, newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
+    
+    writer.addDocument(doc(new Field[] { field("id", "0")
+                                         ,
+                                         field("gender", "male"),
+                                         field("first",  "james"),
+                                         field("last",   "jones")     }));
+                                               
+    writer.addDocument(doc(new Field[] { field("id", "1")
+                                         ,
+                                         field("gender", "male"),
+                                         field("first",  "james"),
+                                         field("last",   "smith")
+                                         ,
+                                         field("gender", "female"),
+                                         field("first",  "sally"),
+                                         field("last",   "jones")     }));
+    
+    writer.addDocument(doc(new Field[] { field("id", "2")
+                                         ,
+                                         field("gender", "female"),
+                                         field("first",  "greta"),
+                                         field("last",   "jones")
+                                         ,
+                                         field("gender", "female"),
+                                         field("first",  "sally"),
+                                         field("last",   "smith")
+                                         ,
+                                         field("gender", "male"),
+                                         field("first",  "james"),
+                                         field("last",   "jones")     }));
+     
+    writer.addDocument(doc(new Field[] { field("id", "3")
+                                         ,
+                                         field("gender", "female"),
+                                         field("first",  "lisa"),
+                                         field("last",   "jones")
+                                         ,
+                                         field("gender", "male"),
+                                         field("first",  "bob"),
+                                         field("last",   "costas")     }));
+    
+    writer.addDocument(doc(new Field[] { field("id", "4")
+                                         ,
+                                         field("gender", "female"),
+                                         field("first",  "sally"),
+                                         field("last",   "smith")
+                                         ,
+                                         field("gender", "female"),
+                                         field("first",  "linda"),
+                                         field("last",   "dixit")
+                                         ,
+                                         field("gender", "male"),
+                                         field("first",  "bubba"),
+                                         field("last",   "jones")     }));
+    reader = writer.getReader();
+    writer.forceMerge(1);
+    writer.close();
+    searcher = new IndexSearcher(getOnlyLeafReader(reader));
+  }
+
+  @AfterClass
+  public static void afterClass() throws Exception {
+    searcher = null;
+    reader.close();
+    reader = null;
+    directory.close();
+    directory = null;
+  }
+
+  protected void check(SpanQuery q, int[] docs) throws Exception {
+    CheckHits.checkHitCollector(random(), q, null, searcher, docs);
+  }
+
+  public void testRewrite0() throws Exception {
+    SpanQuery q = new FieldMaskingSpanQuery
+      (new SpanTermQuery(new Term("last", "sally")) , "first");
+    SpanQuery qr = (SpanQuery) searcher.rewrite(q);
+
+    QueryUtils.checkEqual(q, qr);
+
+    Set<Term> terms = new HashSet<>();
+    qr.createWeight(searcher, false).extractTerms(terms);
+    assertEquals(1, terms.size());
+  }
+  
+  public void testRewrite1() throws Exception {
+    // mask an anon SpanQuery class that rewrites to something else.
+    SpanQuery q = new FieldMaskingSpanQuery
+      (new SpanTermQuery(new Term("last", "sally")) {
+          @Override
+          public Query rewrite(IndexReader reader) {
+            return new SpanOrQuery(new SpanTermQuery(new Term("first", "sally")),
+                new SpanTermQuery(new Term("first", "james")));
+          }
+        }, "first");
+
+    SpanQuery qr = (SpanQuery) searcher.rewrite(q);
+
+    QueryUtils.checkUnequal(q, qr);
+
+    Set<Term> terms = new HashSet<>();
+    qr.createWeight(searcher, false).extractTerms(terms);
+    assertEquals(2, terms.size());
+  }
+  
+  public void testRewrite2() throws Exception {
+    SpanQuery q1 = new SpanTermQuery(new Term("last", "smith"));
+    SpanQuery q2 = new SpanTermQuery(new Term("last", "jones"));
+    SpanQuery q = new SpanNearQuery(new SpanQuery[]
+      { q1, new FieldMaskingSpanQuery(q2, "last")}, 1, true );
+    Query qr = searcher.rewrite(q);
+
+    QueryUtils.checkEqual(q, qr);
+
+    HashSet<Term> set = new HashSet<>();
+    qr.createWeight(searcher, true).extractTerms(set);
+    assertEquals(2, set.size());
+  }
+  
+  public void testEquality1() {
+    SpanQuery q1 = new FieldMaskingSpanQuery
+      (new SpanTermQuery(new Term("last", "sally")) , "first");
+    SpanQuery q2 = new FieldMaskingSpanQuery
+      (new SpanTermQuery(new Term("last", "sally")) , "first");
+    SpanQuery q3 = new FieldMaskingSpanQuery
+      (new SpanTermQuery(new Term("last", "sally")) , "XXXXX");
+    SpanQuery q4 = new FieldMaskingSpanQuery
+      (new SpanTermQuery(new Term("last", "XXXXX")) , "first");
+    SpanQuery q5 = new FieldMaskingSpanQuery
+      (new SpanTermQuery(new Term("xXXX", "sally")) , "first");
+    QueryUtils.checkEqual(q1, q2);
+    QueryUtils.checkUnequal(q1, q3);
+    QueryUtils.checkUnequal(q1, q4);
+    QueryUtils.checkUnequal(q1, q5);
+  }
+  
+  public void testNoop0() throws Exception {
+    SpanQuery q1 = new SpanTermQuery(new Term("last", "sally"));
+    SpanQuery q = new FieldMaskingSpanQuery(q1, "first");
+    check(q, new int[] { /* :EMPTY: */ });
+  }
+  public void testNoop1() throws Exception {
+    SpanQuery q1 = new SpanTermQuery(new Term("last", "smith"));
+    SpanQuery q2 = new SpanTermQuery(new Term("last", "jones"));
+    SpanQuery q = new SpanNearQuery(new SpanQuery[]
+      { q1, new FieldMaskingSpanQuery(q2, "last")}, 0, true );
+    check(q, new int[] { 1, 2 });
+    q = new SpanNearQuery(new SpanQuery[]
+      { new FieldMaskingSpanQuery(q1, "last"),
+        new FieldMaskingSpanQuery(q2, "last")}, 0, true );
+    check(q, new int[] { 1, 2 });
+  }
+  
+  public void testSimple1() throws Exception {
+    SpanQuery q1 = new SpanTermQuery(new Term("first", "james"));
+    SpanQuery q2 = new SpanTermQuery(new Term("last", "jones"));
+    SpanQuery q = new SpanNearQuery(new SpanQuery[]
+      { q1, new FieldMaskingSpanQuery(q2, "first")}, -1, false );
+    check(q, new int[] { 0, 2 });
+    q = new SpanNearQuery(new SpanQuery[]
+      { new FieldMaskingSpanQuery(q2, "first"), q1}, -1, false );
+    check(q, new int[] { 0, 2 });
+    q = new SpanNearQuery(new SpanQuery[]
+      { q2, new FieldMaskingSpanQuery(q1, "last")}, -1, false );
+    check(q, new int[] { 0, 2 });
+    q = new SpanNearQuery(new SpanQuery[]
+      { new FieldMaskingSpanQuery(q1, "last"), q2}, -1, false );
+    check(q, new int[] { 0, 2 });
+
+  }
+  
+  public void testSimple2() throws Exception {
+    assumeTrue("Broken scoring: LUCENE-3723", 
+        searcher.getSimilarity(true) instanceof TFIDFSimilarity);
+    SpanQuery q1 = new SpanTermQuery(new Term("gender", "female"));
+    SpanQuery q2 = new SpanTermQuery(new Term("last", "smith"));
+    SpanQuery q = new SpanNearQuery(new SpanQuery[]
+      { q1, new FieldMaskingSpanQuery(q2, "gender")}, -1, false );
+    check(q, new int[] { 2, 4 });
+    q = new SpanNearQuery(new SpanQuery[]
+      { new FieldMaskingSpanQuery(q1, "id"),
+        new FieldMaskingSpanQuery(q2, "id") }, -1, false );
+    check(q, new int[] { 2, 4 });
+  }
+
+  public void testSpans0() throws Exception {
+    SpanQuery q1 = new SpanTermQuery(new Term("gender", "female"));
+    SpanQuery q2 = new SpanTermQuery(new Term("first",  "james"));
+    SpanQuery q  = new SpanOrQuery(q1, new FieldMaskingSpanQuery(q2, "gender"));
+    check(q, new int[] { 0, 1, 2, 3, 4 });
+
+    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertNext(span, 0,0,1);
+    assertNext(span, 1,0,1);
+    assertNext(span, 1,1,2);
+    assertNext(span, 2,0,1);
+    assertNext(span, 2,1,2);
+    assertNext(span, 2,2,3);
+    assertNext(span, 3,0,1);
+    assertNext(span, 4,0,1);
+    assertNext(span, 4,1,2);
+    assertFinished(span);
+  }
+  
+  public void testSpans1() throws Exception {
+    SpanQuery q1 = new SpanTermQuery(new Term("first", "sally"));
+    SpanQuery q2 = new SpanTermQuery(new Term("first", "james"));
+    SpanQuery qA = new SpanOrQuery(q1, q2);
+    SpanQuery qB = new FieldMaskingSpanQuery(qA, "id");
+                                            
+    check(qA, new int[] { 0, 1, 2, 4 });
+    check(qB, new int[] { 0, 1, 2, 4 });
+  
+    Spans spanA = qA.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    Spans spanB = qB.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    
+    while (spanA.nextDoc() != Spans.NO_MORE_DOCS) {
+      assertNotSame("spanB not still going", Spans.NO_MORE_DOCS, spanB.nextDoc());
+      while (spanA.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+        assertEquals("spanB start position", spanA.startPosition(), spanB.nextStartPosition());
+        assertEquals("spanB end position", spanA.endPosition(), spanB.endPosition());
+      }
+      assertEquals("spanB start position", Spans.NO_MORE_POSITIONS, spanB.nextStartPosition());
+    }
+    assertEquals("spanB end doc", Spans.NO_MORE_DOCS, spanB.nextDoc());
+  }
+  
+  public void testSpans2() throws Exception {
+    assumeTrue("Broken scoring: LUCENE-3723",
+        searcher.getSimilarity(true) instanceof TFIDFSimilarity);
+    SpanQuery qA1 = new SpanTermQuery(new Term("gender", "female"));
+    SpanQuery qA2 = new SpanTermQuery(new Term("first",  "james"));
+    SpanQuery qA  = new SpanOrQuery(qA1, new FieldMaskingSpanQuery(qA2, "gender"));
+    SpanQuery qB  = new SpanTermQuery(new Term("last",   "jones"));
+    SpanQuery q   = new SpanNearQuery(new SpanQuery[]
+      { new FieldMaskingSpanQuery(qA, "id"),
+        new FieldMaskingSpanQuery(qB, "id") }, -1, false );
+    check(q, new int[] { 0, 1, 2, 3 });
+
+    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertNext(span, 0,0,1);
+    assertNext(span, 1,1,2);
+    assertNext(span, 2,0,1);
+    assertNext(span, 2,2,3);
+    assertNext(span, 3,0,1);
+    assertFinished(span);
+  }
+  
+  public String s(int doc, int start, int end) {
+    return "s(" + doc + "," + start + "," + end +")";
+  }
+  
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestFilterSpans.java b/lucene/core/src/test/org/apache/lucene/search/TestFilterSpans.java
new file mode 100644
index 0000000..7ae9ebc
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestFilterSpans.java
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import java.lang.reflect.Method;
+
+import org.apache.lucene.search.FilterSpans;
+import org.apache.lucene.search.Spans;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
+
+public class TestFilterSpans extends LuceneTestCase {
+
+  @Test
+  public void testOverrides() throws Exception {
+    // verify that all methods of Spans are overridden by FilterSpans,
+    for (Method m : FilterSpans.class.getMethods()) {
+      if (m.getDeclaringClass() == Spans.class) {
+        fail("method " + m.getName() + " not overridden!");
+      }
+    }
+  }
+  
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestNearSpansOrdered.java b/lucene/core/src/test/org/apache/lucene/search/TestNearSpansOrdered.java
new file mode 100644
index 0000000..fb12e22
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestNearSpansOrdered.java
@@ -0,0 +1,311 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.search.SpanWeight;
+import org.apache.lucene.search.Spans;
+import org.apache.lucene.search.Weight;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+
+import static org.apache.lucene.search.spans.SpanTestUtil.assertFinished;
+import static org.apache.lucene.search.spans.SpanTestUtil.assertNext;
+
+public class TestNearSpansOrdered extends LuceneTestCase {
+  protected IndexSearcher searcher;
+  protected Directory directory;
+  protected IndexReader reader;
+
+  public static final String FIELD = "field";
+
+  @Override
+  public void tearDown() throws Exception {
+    reader.close();
+    directory.close();
+    super.tearDown();
+  }
+  
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    directory = newDirectory();
+    RandomIndexWriter writer= new RandomIndexWriter(random(), directory, newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
+    for (int i = 0; i < docFields.length; i++) {
+      Document doc = new Document();
+      doc.add(newTextField(FIELD, docFields[i], Field.Store.NO));
+      writer.addDocument(doc);
+    }
+    writer.forceMerge(1);
+    reader = writer.getReader();
+    writer.close();
+    searcher = newSearcher(getOnlyLeafReader(reader));
+  }
+
+  protected String[] docFields = {
+    "w1 w2 w3 w4 w5",
+    "w1 w3 w2 w3 zz",
+    "w1 xx w2 yy w3",
+    "w1 w3 xx w2 yy w3 zz",
+    "t1 t2 t2 t1",
+    "g x x g g x x x g g x x g"
+  };
+
+  protected SpanNearQuery makeQuery(String s1, String s2, String s3,
+                                    int slop, boolean inOrder) {
+    return new SpanNearQuery
+      (new SpanQuery[] {
+        new SpanTermQuery(new Term(FIELD, s1)),
+        new SpanTermQuery(new Term(FIELD, s2)),
+        new SpanTermQuery(new Term(FIELD, s3)) },
+       slop,
+       inOrder);
+  }
+  protected SpanNearQuery makeQuery() {
+    return makeQuery("w1","w2","w3",1,true);
+  }
+
+  protected SpanNearQuery makeOverlappedQuery(
+      String sqt1, String sqt2, boolean sqOrdered,
+      String t3, boolean ordered) {
+    return new SpanNearQuery(
+      new SpanQuery[] {
+        new SpanNearQuery(new SpanQuery[] {
+          new SpanTermQuery(new Term(FIELD, sqt1)),
+            new SpanTermQuery(new Term(FIELD, sqt2)) },
+            1,
+            sqOrdered
+          ),
+          new SpanTermQuery(new Term(FIELD, t3)) },
+          0,
+          ordered);
+  }
+  
+  public void testSpanNearQuery() throws Exception {
+    SpanNearQuery q = makeQuery();
+    CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {0,1});
+  }
+
+  public String s(Spans span) {
+    return s(span.docID(), span.startPosition(), span.endPosition());
+  }
+  public String s(int doc, int start, int end) {
+    return "s(" + doc + "," + start + "," + end +")";
+  }
+  
+  public void testNearSpansNext() throws Exception {
+    SpanNearQuery q = makeQuery();
+    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertNext(span,0,0,3);
+    assertNext(span,1,0,4);
+    assertFinished(span);
+  }
+
+  /**
+   * test does not imply that skipTo(doc+1) should work exactly the
+   * same as next -- it's only applicable in this case since we know doc
+   * does not contain more than one span
+   */
+  public void testNearSpansAdvanceLikeNext() throws Exception {
+    SpanNearQuery q = makeQuery();
+    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(0, span.advance(0));
+    assertEquals(0, span.nextStartPosition());
+    assertEquals(s(0,0,3), s(span));
+    assertEquals(1, span.advance(1));
+    assertEquals(0, span.nextStartPosition());
+    assertEquals(s(1,0,4), s(span));
+    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
+  }
+  
+  public void testNearSpansNextThenAdvance() throws Exception {
+    SpanNearQuery q = makeQuery();
+    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertNotSame(Spans.NO_MORE_DOCS, span.nextDoc());
+    assertEquals(0, span.nextStartPosition());
+    assertEquals(s(0,0,3), s(span));
+    assertNotSame(Spans.NO_MORE_DOCS, span.advance(1));
+    assertEquals(0, span.nextStartPosition());
+    assertEquals(s(1,0,4), s(span));
+    assertEquals(Spans.NO_MORE_DOCS, span.nextDoc());
+  }
+  
+  public void testNearSpansNextThenAdvancePast() throws Exception {
+    SpanNearQuery q = makeQuery();
+    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertNotSame(Spans.NO_MORE_DOCS, span.nextDoc());
+    assertEquals(0, span.nextStartPosition());
+    assertEquals(s(0,0,3), s(span));
+    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
+  }
+  
+  public void testNearSpansAdvancePast() throws Exception {
+    SpanNearQuery q = makeQuery();
+    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
+  }
+  
+  public void testNearSpansAdvanceTo0() throws Exception {
+    SpanNearQuery q = makeQuery();
+    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(0, span.advance(0));
+    assertEquals(0, span.nextStartPosition());
+    assertEquals(s(0,0,3), s(span));
+  }
+
+  public void testNearSpansAdvanceTo1() throws Exception {
+    SpanNearQuery q = makeQuery();
+    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(1, span.advance(1));
+    assertEquals(0, span.nextStartPosition());
+    assertEquals(s(1,0,4), s(span));
+  }
+
+  /**
+   * not a direct test of NearSpans, but a demonstration of how/when
+   * this causes problems
+   */
+  public void testSpanNearScorerSkipTo1() throws Exception {
+    SpanNearQuery q = makeQuery();
+    Weight w = searcher.createNormalizedWeight(q, true);
+    IndexReaderContext topReaderContext = searcher.getTopReaderContext();
+    LeafReaderContext leave = topReaderContext.leaves().get(0);
+    Scorer s = w.scorer(leave);
+    assertEquals(1, s.iterator().advance(1));
+  }
+
+  public void testOverlappedOrderedSpan() throws Exception {
+    SpanNearQuery q = makeOverlappedQuery("w5", "w3", false, "w4", true);
+    CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {});
+  }
+  
+  public void testOverlappedNonOrderedSpan() throws Exception {
+    SpanNearQuery q = makeOverlappedQuery("w3", "w5", true, "w4", false);
+    CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {0});
+  }
+
+  public void testNonOverlappedOrderedSpan() throws Exception {
+    SpanNearQuery q = makeOverlappedQuery("w3", "w4", true, "w5", true);
+    CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {0});
+  }
+
+  public void testOrderedSpanIteration() throws Exception {
+    SpanNearQuery q = new SpanNearQuery(new SpanQuery[]{
+        new SpanOrQuery(new SpanTermQuery(new Term(FIELD, "w1")), new SpanTermQuery(new Term(FIELD, "w2"))),
+        new SpanTermQuery(new Term(FIELD, "w4"))
+    }, 10, true);
+    Spans spans = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertNext(spans,0,0,4);
+    assertNext(spans,0,1,4);
+    assertFinished(spans);
+  }
+
+  public void testOrderedSpanIterationSameTerms1() throws Exception {
+    SpanNearQuery q = new SpanNearQuery(new SpanQuery[]{
+        new SpanTermQuery(new Term(FIELD, "t1")), new SpanTermQuery(new Term(FIELD, "t2"))
+    }, 1, true);
+    Spans spans = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertNext(spans,4,0,2);
+    assertFinished(spans);
+  }
+
+  public void testOrderedSpanIterationSameTerms2() throws Exception {
+    SpanNearQuery q = new SpanNearQuery(new SpanQuery[]{
+        new SpanTermQuery(new Term(FIELD, "t2")), new SpanTermQuery(new Term(FIELD, "t1"))
+    }, 1, true);
+    Spans spans = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertNext(spans,4,1,4);
+    assertNext(spans,4,2,4);
+    assertFinished(spans);
+  }
+
+  /**
+   * not a direct test of NearSpans, but a demonstration of how/when
+   * this causes problems
+   */
+  public void testSpanNearScorerExplain() throws Exception {
+    SpanNearQuery q = makeQuery();
+    Explanation e = searcher.explain(q, 1);
+    assertTrue("Scorer explanation value for doc#1 isn't positive: "
+               + e.toString(),
+               0.0f <= e.getValue());
+  }
+
+  public void testGaps() throws Exception {
+    SpanNearQuery q = SpanNearQuery.newOrderedNearQuery(FIELD)
+        .addClause(new SpanTermQuery(new Term(FIELD, "w1")))
+        .addGap(1)
+        .addClause(new SpanTermQuery(new Term(FIELD, "w2")))
+        .build();
+    Spans spans = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertNext(spans, 1, 0, 3);
+    assertNext(spans, 2, 0, 3);
+    assertFinished(spans);
+
+    q = SpanNearQuery.newOrderedNearQuery(FIELD)
+        .addClause(new SpanTermQuery(new Term(FIELD, "w1")))
+        .addGap(1)
+        .addClause(new SpanTermQuery(new Term(FIELD, "w2")))
+        .addGap(1)
+        .addClause(new SpanTermQuery(new Term(FIELD, "w3")))
+        .setSlop(1)
+        .build();
+    spans = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertNext(spans, 2, 0, 5);
+    assertNext(spans, 3, 0, 6);
+    assertFinished(spans);
+  }
+
+  public void testMultipleGaps() throws Exception {
+    SpanQuery q = SpanNearQuery.newOrderedNearQuery(FIELD)
+        .addClause(new SpanTermQuery(new Term(FIELD, "g")))
+        .addGap(2)
+        .addClause(new SpanTermQuery(new Term(FIELD, "g")))
+        .build();
+    Spans spans = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertNext(spans, 5, 0, 4);
+    assertNext(spans, 5, 9, 13);
+    assertFinished(spans);
+  }
+
+  /*
+    protected String[] docFields = {
+    "w1 w2 w3 w4 w5",
+    "w1 w3 w2 w3 zz",
+    "w1 xx w2 yy w3",
+    "w1 w3 xx w2 yy w3 zz",
+    "t1 t2 t2 t1",
+    "g x x g g x x x g g x x g"
+  };
+   */
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java b/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java
index 227b15d..1404b38 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java
@@ -37,12 +37,6 @@ import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.spans.SpanCollector;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.Spans;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.search.spans.SpanWeight;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java b/lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java
index d029e01..a878c78 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestQueryRescorer.java
@@ -31,9 +31,6 @@ import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.similarities.ClassicSimilarity;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSpanBoostQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestSpanBoostQuery.java
new file mode 100644
index 0000000..a0de1cd
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSpanBoostQuery.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.SpanBoostQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.util.LuceneTestCase;
+
+
+public class TestSpanBoostQuery extends LuceneTestCase {
+
+  public void testEquals() {
+    final float boost = random().nextFloat() * 3 - 1;
+    SpanTermQuery q = new SpanTermQuery(new Term("foo", "bar"));
+    SpanBoostQuery q1 = new SpanBoostQuery(q, boost);
+    SpanBoostQuery q2 = new SpanBoostQuery(q, boost);
+    assertEquals(q1, q2);
+    assertEquals(q1.getBoost(), q2.getBoost(), 0f);
+ 
+    float boost2 = boost;
+    while (boost == boost2) {
+      boost2 = random().nextFloat() * 3 - 1;
+    }
+    SpanBoostQuery q3 = new SpanBoostQuery(q, boost2);
+    assertFalse(q1.equals(q3));
+    assertFalse(q1.hashCode() == q3.hashCode());
+  }
+
+  public void testToString() {
+    assertEquals("(foo:bar)^2.0", new SpanBoostQuery(new SpanTermQuery(new Term("foo", "bar")), 2).toString());
+    SpanOrQuery bq = new SpanOrQuery(
+        new SpanTermQuery(new Term("foo", "bar")),
+        new SpanTermQuery(new Term("foo", "baz")));
+    assertEquals("(spanOr([foo:bar, foo:baz]))^2.0", new SpanBoostQuery(bq, 2).toString());
+  }
+
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSpanCollection.java b/lucene/core/src/test/org/apache/lucene/search/TestSpanCollection.java
new file mode 100644
index 0000000..e167362
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSpanCollection.java
@@ -0,0 +1,189 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.FieldType;
+import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.IndexOptions;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.SpanCollector;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanNotQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.search.SpanWeight;
+import org.apache.lucene.search.Spans;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
+
+public class TestSpanCollection extends LuceneTestCase {
+
+  protected IndexSearcher searcher;
+  protected Directory directory;
+  protected IndexReader reader;
+
+  public static final String FIELD = "field";
+
+  public static FieldType OFFSETS = new FieldType(TextField.TYPE_STORED);
+  static {
+    OFFSETS.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    reader.close();
+    directory.close();
+    super.tearDown();
+  }
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+        newIndexWriterConfig(new MockAnalyzer(random())));
+    for (int i = 0; i < docFields.length; i++) {
+      Document doc = new Document();
+      doc.add(newField(FIELD, docFields[i], OFFSETS));
+      writer.addDocument(doc);
+    }
+    writer.forceMerge(1);
+    reader = writer.getReader();
+    writer.close();
+    searcher = newSearcher(getOnlyLeafReader(reader));
+  }
+
+  private static class TermCollector implements SpanCollector {
+
+    final Set<Term> terms = new HashSet<>();
+
+    @Override
+    public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException {
+      terms.add(term);
+    }
+
+    @Override
+    public void reset() {
+      terms.clear();
+    }
+
+  }
+
+  protected String[] docFields = {
+      "w1 w2 w3 w4 w5",
+      "w1 w3 w2 w3 zz",
+      "w1 xx w2 yy w4",
+      "w1 w2 w1 w4 w2 w3"
+  };
+
+  private void checkCollectedTerms(Spans spans, TermCollector collector, Term... expectedTerms) throws IOException {
+    collector.reset();
+    spans.collect(collector);
+    for (Term t : expectedTerms) {
+      assertTrue("Missing term " + t, collector.terms.contains(t));
+    }
+    assertEquals("Unexpected terms found", expectedTerms.length, collector.terms.size());
+  }
+
+  @Test
+  public void testNestedNearQuery() throws IOException {
+
+    // near(w1, near(w2, or(w3, w4)))
+
+    SpanTermQuery q1 = new SpanTermQuery(new Term(FIELD, "w1"));
+    SpanTermQuery q2 = new SpanTermQuery(new Term(FIELD, "w2"));
+    SpanTermQuery q3 = new SpanTermQuery(new Term(FIELD, "w3"));
+    SpanTermQuery q4 = new SpanTermQuery(new Term(FIELD, "w4"));
+
+    SpanOrQuery q5 = new SpanOrQuery(q4, q3);
+    SpanNearQuery q6 = new SpanNearQuery(new SpanQuery[]{q2, q5}, 1, true);
+    SpanNearQuery q7 = new SpanNearQuery(new SpanQuery[]{q1, q6}, 1, true);
+
+    TermCollector collector = new TermCollector();
+    Spans spans = q7.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertEquals(0, spans.advance(0));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"));
+
+    assertEquals(3, spans.advance(3));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w4"));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"));
+
+  }
+
+  @Test
+  public void testOrQuery() throws IOException {
+    SpanTermQuery q2 = new SpanTermQuery(new Term(FIELD, "w2"));
+    SpanTermQuery q3 = new SpanTermQuery(new Term(FIELD, "w3"));
+    SpanOrQuery orQuery = new SpanOrQuery(q2, q3);
+
+    TermCollector collector = new TermCollector();
+    Spans spans = orQuery.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+
+    assertEquals(1, spans.advance(1));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w3"));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w2"));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w3"));
+
+    assertEquals(3, spans.advance(3));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w2"));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w2"));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w3"));
+  }
+
+  @Test
+  public void testSpanNotQuery() throws IOException {
+
+    SpanTermQuery q1 = new SpanTermQuery(new Term(FIELD, "w1"));
+    SpanTermQuery q2 = new SpanTermQuery(new Term(FIELD, "w2"));
+    SpanTermQuery q3 = new SpanTermQuery(new Term(FIELD, "w3"));
+
+    SpanNearQuery nq = new SpanNearQuery(new SpanQuery[]{q1, q2}, 2, true);
+    SpanNotQuery notq = new SpanNotQuery(nq, q3);
+
+    TermCollector collector = new TermCollector();
+    Spans spans = notq.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+
+    assertEquals(2, spans.advance(2));
+    spans.nextStartPosition();
+    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"));
+
+  }
+
+}
+
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSpanContainQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestSpanContainQuery.java
new file mode 100644
index 0000000..2e761d9
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSpanContainQuery.java
@@ -0,0 +1,151 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanWeight;
+import org.apache.lucene.search.Spans;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+
+import static org.apache.lucene.search.spans.SpanTestUtil.*;
+
+public class TestSpanContainQuery extends LuceneTestCase {
+  IndexSearcher searcher;
+  IndexReader reader;
+  Directory directory;
+
+  static final String field = "field";
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    directory = newDirectory();
+    RandomIndexWriter writer= new RandomIndexWriter(random(), directory, newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
+    for (int i = 0; i < docFields.length; i++) {
+      Document doc = new Document();
+      doc.add(newTextField(field, docFields[i], Field.Store.YES));
+      writer.addDocument(doc);
+    }
+    writer.forceMerge(1);
+    reader = writer.getReader();
+    writer.close();
+    searcher = newSearcher(getOnlyLeafReader(reader));
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    reader.close();
+    directory.close();
+    super.tearDown();
+  }
+
+  String[] docFields = {
+    "w1 w2 w3 w4 w5",
+    "w1 w3 w2 w3",
+    "w1 xx w2 yy w3",
+    "w1 w3 xx w2 yy w3",
+  };
+
+  void checkHits(Query query, int[] results) throws Exception {
+    CheckHits.checkHits(random(), query, field, searcher, results);
+  }
+
+  Spans makeSpans(SpanQuery sq) throws Exception {
+    return sq.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+  }
+
+  void tstEqualSpans(String mes, SpanQuery expectedQ, SpanQuery actualQ) throws Exception {
+    Spans expected = makeSpans(expectedQ);
+    Spans actual = makeSpans(actualQ);
+    tstEqualSpans(mes, expected, actual);
+  }
+
+  void tstEqualSpans(String mes, Spans expected, Spans actual) throws Exception {
+    while (expected.nextDoc() != Spans.NO_MORE_DOCS) {
+      assertEquals(expected.docID(), actual.nextDoc());
+      assertEquals(expected.docID(), actual.docID());
+      while (expected.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+        assertEquals(expected.startPosition(), actual.nextStartPosition());
+        assertEquals("start", expected.startPosition(), actual.startPosition());
+        assertEquals("end", expected.endPosition(), actual.endPosition());
+      }
+    }
+  }
+
+  public void testSpanContainTerm() throws Exception {
+    SpanQuery stq = spanTermQuery(field, "w3");
+    SpanQuery containingQ = spanContainingQuery(stq, stq);
+    SpanQuery containedQ = spanWithinQuery(stq, stq);
+    tstEqualSpans("containing", stq, containingQ);
+    tstEqualSpans("containing", stq, containedQ);
+  }
+
+  public void testSpanContainPhraseBothWords() throws Exception {
+    String w2 = "w2";
+    String w3 = "w3";
+    SpanQuery phraseQ = spanNearOrderedQuery(field, 0, w2, w3);
+    SpanQuery w23 = spanOrQuery(field, w2, w3);
+    SpanQuery containingPhraseOr = spanContainingQuery(phraseQ, w23);
+    SpanQuery containedPhraseOr = spanWithinQuery(phraseQ, w23);
+    tstEqualSpans("containing phrase or", phraseQ, containingPhraseOr);
+    Spans spans = makeSpans(containedPhraseOr);
+    assertNext(spans,0,1,2);
+    assertNext(spans,0,2,3);
+    assertNext(spans,1,2,3);
+    assertNext(spans,1,3,4);
+    assertFinished(spans);
+  }
+
+  public void testSpanContainPhraseFirstWord() throws Exception {
+    String w2 = "w2";
+    String w3 = "w3";
+    SpanQuery stqw2 = spanTermQuery(field, w2);
+    SpanQuery phraseQ = spanNearOrderedQuery(field, 0, w2, w3);
+    SpanQuery containingPhraseW2 = spanContainingQuery(phraseQ, stqw2);
+    SpanQuery containedPhraseW2 = spanWithinQuery(phraseQ, stqw2);
+    tstEqualSpans("containing phrase w2", phraseQ, containingPhraseW2);
+    Spans spans = makeSpans(containedPhraseW2);
+    assertNext(spans,0,1,2);
+    assertNext(spans,1,2,3);
+    assertFinished(spans);
+  }
+
+  public void testSpanContainPhraseSecondWord() throws Exception {
+    String w2 = "w2";
+    String w3 = "w3";
+    SpanQuery stqw3 = spanTermQuery(field, w3);
+    SpanQuery phraseQ = spanNearOrderedQuery(field, 0, w2, w3);
+    SpanQuery containingPhraseW3 = spanContainingQuery(phraseQ, stqw3);
+    SpanQuery containedPhraseW3 = spanWithinQuery(phraseQ, stqw3);
+    tstEqualSpans("containing phrase w3", phraseQ, containingPhraseW3);
+    Spans spans = makeSpans(containedPhraseW3);
+    assertNext(spans,0,2,3);
+    assertNext(spans,1,3,4);
+    assertFinished(spans);
+  }
+
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSpanExplanations.java b/lucene/core/src/test/org/apache/lucene/search/TestSpanExplanations.java
new file mode 100644
index 0000000..41bcb51
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSpanExplanations.java
@@ -0,0 +1,168 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import org.apache.lucene.search.*;
+
+/**
+ * TestExplanations subclass focusing on span queries
+ */
+public class TestSpanExplanations extends BaseExplanationTestCase {
+
+  /* simple SpanTermQueries */
+  
+  public void testST1() throws Exception {
+    SpanQuery q = st("w1");
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testST2() throws Exception {
+    SpanQuery q = st("w1");
+    qtest(new BoostQuery(q, 1000), new int[] {0,1,2,3});
+  }
+  public void testST4() throws Exception {
+    SpanQuery q = st("xx");
+    qtest(q, new int[] {2,3});
+  }
+  public void testST5() throws Exception {
+    SpanQuery q = st("xx");
+    qtest(new BoostQuery(q, 1000), new int[] {2,3});
+  }
+
+  /* some SpanFirstQueries */
+  
+  public void testSF1() throws Exception {
+    SpanQuery q = sf(("w1"),1);
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testSF2() throws Exception {
+    SpanQuery q = sf(("w1"),1);
+    qtest(new BoostQuery(q, 1000), new int[] {0,1,2,3});
+  }
+  public void testSF4() throws Exception {
+    SpanQuery q = sf(("xx"),2);
+    qtest(q, new int[] {2});
+  }
+  public void testSF5() throws Exception {
+    SpanQuery q = sf(("yy"),2);
+    qtest(q, new int[] { });
+  }
+  public void testSF6() throws Exception {
+    SpanQuery q = sf(("yy"),4);
+    qtest(new BoostQuery(q, 1000), new int[] {2});
+  }
+  
+  /* some SpanOrQueries */
+
+  public void testSO1() throws Exception {
+    SpanQuery q = sor("w1","QQ");
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testSO2() throws Exception {
+    SpanQuery q = sor("w1","w3","zz");
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testSO3() throws Exception {
+    SpanQuery q = sor("w5","QQ","yy");
+    qtest(q, new int[] {0,2,3});
+  }
+  public void testSO4() throws Exception {
+    SpanQuery q = sor("w5","QQ","yy");
+    qtest(q, new int[] {0,2,3});
+  }
+
+  
+  
+  /* some SpanNearQueries */
+  
+  public void testSNear1() throws Exception {
+    SpanQuery q = snear("w1","QQ",100,true);
+    qtest(q, new int[] {});
+  }
+  public void testSNear2() throws Exception {
+    SpanQuery q = snear("w1","xx",100,true);
+    qtest(q, new int[] {2,3});
+  }
+  public void testSNear3() throws Exception {
+    SpanQuery q = snear("w1","xx",0,true);
+    qtest(q, new int[] {2});
+  }
+  public void testSNear4() throws Exception {
+    SpanQuery q = snear("w1","xx",1,true);
+    qtest(q, new int[] {2,3});
+  }
+  public void testSNear5() throws Exception {
+    SpanQuery q = snear("xx","w1",0,false);
+    qtest(q, new int[] {2});
+  }
+
+  public void testSNear6() throws Exception {
+    SpanQuery q = snear("w1","w2","QQ",100,true);
+    qtest(q, new int[] {});
+  }
+  public void testSNear7() throws Exception {
+    SpanQuery q = snear("w1","xx","w2",100,true);
+    qtest(q, new int[] {2,3});
+  }
+  public void testSNear8() throws Exception {
+    SpanQuery q = snear("w1","xx","w2",0,true);
+    qtest(q, new int[] {2});
+  }
+  public void testSNear9() throws Exception {
+    SpanQuery q = snear("w1","xx","w2",1,true);
+    qtest(q, new int[] {2,3});
+  }
+  public void testSNear10() throws Exception {
+    SpanQuery q = snear("xx","w1","w2",0,false);
+    qtest(q, new int[] {2});
+  }
+  public void testSNear11() throws Exception {
+    SpanQuery q = snear("w1","w2","w3",1,true);
+    qtest(q, new int[] {0,1});
+  }
+
+  
+  /* some SpanNotQueries */
+
+  public void testSNot1() throws Exception {
+    SpanQuery q = snot(sf("w1",10),st("QQ"));
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testSNot2() throws Exception {
+    SpanQuery q = snot(sf("w1",10),st("QQ"));
+    qtest(new BoostQuery(q, 1000), new int[] {0,1,2,3});
+  }
+  public void testSNot4() throws Exception {
+    SpanQuery q = snot(sf("w1",10),st("xx"));
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testSNot5() throws Exception {
+    SpanQuery q = snot(sf("w1",10),st("xx"));
+    qtest(new BoostQuery(q, 1000), new int[] {0,1,2,3});
+  }
+  public void testSNot7() throws Exception {
+    SpanQuery f = snear("w1","w3",10,true);
+    SpanQuery q = snot(f, st("xx"));
+    qtest(q, new int[] {0,1,3});
+  }
+  public void testSNot10() throws Exception {
+    SpanQuery t = st("xx");
+    SpanQuery q = snot(snear("w1","w3",10,true), t);
+    qtest(q, new int[] {0,1,3});
+  }
+
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSpanExplanationsOfNonMatches.java b/lucene/core/src/test/org/apache/lucene/search/TestSpanExplanationsOfNonMatches.java
new file mode 100644
index 0000000..5a0e3cf
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSpanExplanationsOfNonMatches.java
@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+/**
+ * subclass of TestSimpleExplanations that verifies non matches.
+ */
+public class TestSpanExplanationsOfNonMatches
+  extends TestSpanExplanations {
+
+  /**
+   * Overrides superclass to ignore matches and focus on non-matches
+   *
+   * @see CheckHits#checkNoMatchExplanations
+   */
+  @Override
+  public void qtest(Query q, int[] expDocNrs) throws Exception {
+    CheckHits.checkNoMatchExplanations(q, FIELD, searcher, expDocNrs);
+  }
+    
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSpanFirstQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestSpanFirstQuery.java
new file mode 100644
index 0000000..8033dff
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSpanFirstQuery.java
@@ -0,0 +1,68 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.automaton.CharacterRunAutomaton;
+import org.apache.lucene.util.automaton.RegExp;
+
+import static org.apache.lucene.search.spans.SpanTestUtil.*;
+
+public class TestSpanFirstQuery extends LuceneTestCase {
+  public void testStartPositions() throws Exception {
+    Directory dir = newDirectory();
+    
+    // mimic StopAnalyzer
+    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(new RegExp("the|a|of").toAutomaton());
+    Analyzer analyzer = new MockAnalyzer(random(), MockTokenizer.SIMPLE, true, stopSet);
+    
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, analyzer);
+    Document doc = new Document();
+    doc.add(newTextField("field", "the quick brown fox", Field.Store.NO));
+    writer.addDocument(doc);
+    Document doc2 = new Document();
+    doc2.add(newTextField("field", "quick brown fox", Field.Store.NO));
+    writer.addDocument(doc2);
+    
+    IndexReader reader = writer.getReader();
+    IndexSearcher searcher = newSearcher(reader);
+    
+    // user queries on "starts-with quick"
+    SpanQuery sfq = spanFirstQuery(spanTermQuery("field", "quick"), 1);
+    assertEquals(1, searcher.search(sfq, 10).totalHits);
+    
+    // user queries on "starts-with the quick"
+    SpanQuery include = spanFirstQuery(spanTermQuery("field", "quick"), 2);
+    sfq = spanNotQuery(include, sfq);
+    assertEquals(1, searcher.search(sfq, 10).totalHits);
+    
+    writer.close();
+    reader.close();
+    dir.close();
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSpanMultiTermQueryWrapper.java b/lucene/core/src/test/org/apache/lucene/search/TestSpanMultiTermQueryWrapper.java
new file mode 100644
index 0000000..4f98c7c
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSpanMultiTermQueryWrapper.java
@@ -0,0 +1,256 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.FuzzyQuery;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.PrefixQuery;
+import org.apache.lucene.search.RegexpQuery;
+import org.apache.lucene.search.SpanFirstQuery;
+import org.apache.lucene.search.SpanMultiTermQueryWrapper;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanNotQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanPositionRangeQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.search.WildcardQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.Test;
+
+/**
+ * Tests for {@link SpanMultiTermQueryWrapper}, wrapping a few MultiTermQueries.
+ */
+public class TestSpanMultiTermQueryWrapper extends LuceneTestCase {
+  private Directory directory;
+  private IndexReader reader;
+  private IndexSearcher searcher;
+  
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    directory = newDirectory();
+    RandomIndexWriter iw = new RandomIndexWriter(random(), directory);
+    Document doc = new Document();
+    Field field = newTextField("field", "", Field.Store.NO);
+    doc.add(field);
+    
+    field.setStringValue("quick brown fox");
+    iw.addDocument(doc);
+    field.setStringValue("jumps over lazy broun dog");
+    iw.addDocument(doc);
+    field.setStringValue("jumps over extremely very lazy broxn dog");
+    iw.addDocument(doc);
+    reader = iw.getReader();
+    iw.close();
+    searcher = newSearcher(reader);
+  }
+  
+  @Override
+  public void tearDown() throws Exception {
+    reader.close();
+    directory.close();
+    super.tearDown();
+  }
+  
+  public void testWildcard() throws Exception {
+    WildcardQuery wq = new WildcardQuery(new Term("field", "bro?n"));
+    SpanQuery swq = new SpanMultiTermQueryWrapper<>(wq);
+    // will only match quick brown fox
+    SpanFirstQuery sfq = new SpanFirstQuery(swq, 2);
+    assertEquals(1, searcher.search(sfq, 10).totalHits);
+  }
+  
+  public void testPrefix() throws Exception {
+    WildcardQuery wq = new WildcardQuery(new Term("field", "extrem*"));
+    SpanQuery swq = new SpanMultiTermQueryWrapper<>(wq);
+    // will only match "jumps over extremely very lazy broxn dog"
+    SpanFirstQuery sfq = new SpanFirstQuery(swq, 3);
+    assertEquals(1, searcher.search(sfq, 10).totalHits);
+  }
+  
+  public void testFuzzy() throws Exception {
+    FuzzyQuery fq = new FuzzyQuery(new Term("field", "broan"));
+    SpanQuery sfq = new SpanMultiTermQueryWrapper<>(fq);
+    // will not match quick brown fox
+    SpanPositionRangeQuery sprq = new SpanPositionRangeQuery(sfq, 3, 6);
+    assertEquals(2, searcher.search(sprq, 10).totalHits);
+  }
+  
+  public void testFuzzy2() throws Exception {
+    // maximum of 1 term expansion
+    FuzzyQuery fq = new FuzzyQuery(new Term("field", "broan"), 1, 0, 1, false);
+    SpanQuery sfq = new SpanMultiTermQueryWrapper<>(fq);
+    // will only match jumps over lazy broun dog
+    SpanPositionRangeQuery sprq = new SpanPositionRangeQuery(sfq, 0, 100);
+    assertEquals(1, searcher.search(sprq, 10).totalHits);
+  }
+  public void testNoSuchMultiTermsInNear() throws Exception {
+    //test to make sure non existent multiterms aren't throwing null pointer exceptions  
+    FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
+    SpanQuery spanNoSuch = new SpanMultiTermQueryWrapper<>(fuzzyNoSuch);
+    SpanQuery term = new SpanTermQuery(new Term("field", "brown"));
+    SpanQuery near = new SpanNearQuery(new SpanQuery[]{term, spanNoSuch}, 1, true);
+    assertEquals(0, searcher.search(near, 10).totalHits);
+    //flip order
+    near = new SpanNearQuery(new SpanQuery[]{spanNoSuch, term}, 1, true);
+    assertEquals(0, searcher.search(near, 10).totalHits);
+    
+    WildcardQuery wcNoSuch = new WildcardQuery(new Term("field", "noSuch*"));
+    SpanQuery spanWCNoSuch = new SpanMultiTermQueryWrapper<>(wcNoSuch);
+    near = new SpanNearQuery(new SpanQuery[]{term, spanWCNoSuch}, 1, true);
+    assertEquals(0, searcher.search(near, 10).totalHits);
+  
+    RegexpQuery rgxNoSuch = new RegexpQuery(new Term("field", "noSuch"));
+    SpanQuery spanRgxNoSuch = new SpanMultiTermQueryWrapper<>(rgxNoSuch);
+    near = new SpanNearQuery(new SpanQuery[]{term, spanRgxNoSuch}, 1, true);
+    assertEquals(0, searcher.search(near, 10).totalHits);
+    
+    PrefixQuery prfxNoSuch = new PrefixQuery(new Term("field", "noSuch"));
+    SpanQuery spanPrfxNoSuch = new SpanMultiTermQueryWrapper<>(prfxNoSuch);
+    near = new SpanNearQuery(new SpanQuery[]{term, spanPrfxNoSuch}, 1, true);
+    assertEquals(0, searcher.search(near, 10).totalHits);
+
+    //test single noSuch
+    near = new SpanNearQuery(new SpanQuery[]{spanPrfxNoSuch}, 1, true);
+    assertEquals(0, searcher.search(near, 10).totalHits);
+    
+    //test double noSuch
+    near = new SpanNearQuery(new SpanQuery[]{spanPrfxNoSuch, spanPrfxNoSuch}, 1, true);
+    assertEquals(0, searcher.search(near, 10).totalHits);
+
+  }
+  
+  public void testNoSuchMultiTermsInNotNear() throws Exception {
+    //test to make sure non existent multiterms aren't throwing non-matching field exceptions  
+    FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
+    SpanQuery spanNoSuch = new SpanMultiTermQueryWrapper<>(fuzzyNoSuch);
+    SpanQuery term = new SpanTermQuery(new Term("field", "brown"));
+    SpanNotQuery notNear = new SpanNotQuery(term, spanNoSuch, 0,0);
+    assertEquals(1, searcher.search(notNear, 10).totalHits);
+
+    //flip
+    notNear = new SpanNotQuery(spanNoSuch, term, 0,0);
+    assertEquals(0, searcher.search(notNear, 10).totalHits);
+    
+    //both noSuch
+    notNear = new SpanNotQuery(spanNoSuch, spanNoSuch, 0,0);
+    assertEquals(0, searcher.search(notNear, 10).totalHits);
+
+    WildcardQuery wcNoSuch = new WildcardQuery(new Term("field", "noSuch*"));
+    SpanQuery spanWCNoSuch = new SpanMultiTermQueryWrapper<>(wcNoSuch);
+    notNear = new SpanNotQuery(term, spanWCNoSuch, 0,0);
+    assertEquals(1, searcher.search(notNear, 10).totalHits);
+  
+    RegexpQuery rgxNoSuch = new RegexpQuery(new Term("field", "noSuch"));
+    SpanQuery spanRgxNoSuch = new SpanMultiTermQueryWrapper<>(rgxNoSuch);
+    notNear = new SpanNotQuery(term, spanRgxNoSuch, 1, 1);
+    assertEquals(1, searcher.search(notNear, 10).totalHits);
+    
+    PrefixQuery prfxNoSuch = new PrefixQuery(new Term("field", "noSuch"));
+    SpanQuery spanPrfxNoSuch = new SpanMultiTermQueryWrapper<>(prfxNoSuch);
+    notNear = new SpanNotQuery(term, spanPrfxNoSuch, 1, 1);
+    assertEquals(1, searcher.search(notNear, 10).totalHits);
+    
+  }
+  
+  public void testNoSuchMultiTermsInOr() throws Exception {
+    //test to make sure non existent multiterms aren't throwing null pointer exceptions  
+    FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
+    SpanQuery spanNoSuch = new SpanMultiTermQueryWrapper<>(fuzzyNoSuch);
+    SpanQuery term = new SpanTermQuery(new Term("field", "brown"));
+    SpanOrQuery near = new SpanOrQuery(new SpanQuery[]{term, spanNoSuch});
+    assertEquals(1, searcher.search(near, 10).totalHits);
+    
+    //flip
+    near = new SpanOrQuery(new SpanQuery[]{spanNoSuch, term});
+    assertEquals(1, searcher.search(near, 10).totalHits);
+
+    
+    WildcardQuery wcNoSuch = new WildcardQuery(new Term("field", "noSuch*"));
+    SpanQuery spanWCNoSuch = new SpanMultiTermQueryWrapper<>(wcNoSuch);
+    near = new SpanOrQuery(new SpanQuery[]{term, spanWCNoSuch});
+    assertEquals(1, searcher.search(near, 10).totalHits);
+  
+    RegexpQuery rgxNoSuch = new RegexpQuery(new Term("field", "noSuch"));
+    SpanQuery spanRgxNoSuch = new SpanMultiTermQueryWrapper<>(rgxNoSuch);
+    near = new SpanOrQuery(new SpanQuery[]{term, spanRgxNoSuch});
+    assertEquals(1, searcher.search(near, 10).totalHits);
+    
+    PrefixQuery prfxNoSuch = new PrefixQuery(new Term("field", "noSuch"));
+    SpanQuery spanPrfxNoSuch = new SpanMultiTermQueryWrapper<>(prfxNoSuch);
+    near = new SpanOrQuery(new SpanQuery[]{term, spanPrfxNoSuch});
+    assertEquals(1, searcher.search(near, 10).totalHits);
+    
+    near = new SpanOrQuery(new SpanQuery[]{spanPrfxNoSuch});
+    assertEquals(0, searcher.search(near, 10).totalHits);
+    
+    near = new SpanOrQuery(new SpanQuery[]{spanPrfxNoSuch, spanPrfxNoSuch});
+    assertEquals(0, searcher.search(near, 10).totalHits);
+
+  }
+  
+  
+  public void testNoSuchMultiTermsInSpanFirst() throws Exception {
+    //this hasn't been a problem  
+    FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
+    SpanQuery spanNoSuch = new SpanMultiTermQueryWrapper<>(fuzzyNoSuch);
+    SpanQuery spanFirst = new SpanFirstQuery(spanNoSuch, 10);
+ 
+    assertEquals(0, searcher.search(spanFirst, 10).totalHits);
+    
+    WildcardQuery wcNoSuch = new WildcardQuery(new Term("field", "noSuch*"));
+    SpanQuery spanWCNoSuch = new SpanMultiTermQueryWrapper<>(wcNoSuch);
+    spanFirst = new SpanFirstQuery(spanWCNoSuch, 10);
+    assertEquals(0, searcher.search(spanFirst, 10).totalHits);
+  
+    RegexpQuery rgxNoSuch = new RegexpQuery(new Term("field", "noSuch"));
+    SpanQuery spanRgxNoSuch = new SpanMultiTermQueryWrapper<>(rgxNoSuch);
+    spanFirst = new SpanFirstQuery(spanRgxNoSuch, 10);
+    assertEquals(0, searcher.search(spanFirst, 10).totalHits);
+    
+    PrefixQuery prfxNoSuch = new PrefixQuery(new Term("field", "noSuch"));
+    SpanQuery spanPrfxNoSuch = new SpanMultiTermQueryWrapper<>(prfxNoSuch);
+    spanFirst = new SpanFirstQuery(spanPrfxNoSuch, 10);
+    assertEquals(0, searcher.search(spanFirst, 10).totalHits);
+  }
+
+  @Test
+  public void testWrappedQueryIsNotModified() {
+    final PrefixQuery pq = new PrefixQuery(new Term("field", "test"));
+    int pqHash = pq.hashCode();
+    SpanMultiTermQueryWrapper<PrefixQuery> wrapper = new SpanMultiTermQueryWrapper<>(pq);
+    assertEquals(pqHash, pq.hashCode());
+    wrapper.setRewriteMethod(new SpanMultiTermQueryWrapper.SpanRewriteMethod() {
+      @Override
+      public SpanQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException {
+        return null;
+      }
+    });
+    assertEquals(pqHash, pq.hashCode());
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSpanNearQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestSpanNearQuery.java
new file mode 100644
index 0000000..6662b23
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSpanNearQuery.java
@@ -0,0 +1,96 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.StringField;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+
+/** Basic tests for SpanNearQuery */
+public class TestSpanNearQuery extends LuceneTestCase {
+  
+  public void testHashcodeEquals() {
+    SpanTermQuery q1 = new SpanTermQuery(new Term("field", "foo"));
+    SpanTermQuery q2 = new SpanTermQuery(new Term("field", "bar"));
+    SpanTermQuery q3 = new SpanTermQuery(new Term("field", "baz"));
+    
+    SpanNearQuery near1 = new SpanNearQuery(new SpanQuery[] { q1, q2 }, 10, true);
+    SpanNearQuery near2 = new SpanNearQuery(new SpanQuery[] { q2, q3 }, 10, true);
+    QueryUtils.check(near1);
+    QueryUtils.check(near2);
+    QueryUtils.checkUnequal(near1, near2);
+  }
+  
+  public void testDifferentField() throws Exception {
+    SpanTermQuery q1 = new SpanTermQuery(new Term("field1", "foo"));
+    SpanTermQuery q2 = new SpanTermQuery(new Term("field2", "bar"));
+    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
+      new SpanNearQuery(new SpanQuery[] { q1, q2 }, 10, true);
+    });
+    assertTrue(expected.getMessage().contains("must have same field"));
+  }
+  
+  public void testNoPositions() throws IOException {
+    Directory dir = newDirectory();
+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new StringField("foo", "bar", Field.Store.NO));
+    iw.addDocument(doc);
+    
+    IndexReader ir = iw.getReader();
+    iw.close();
+    
+    IndexSearcher is = new IndexSearcher(ir);
+    SpanTermQuery query = new SpanTermQuery(new Term("foo", "bar"));
+    SpanTermQuery query2 = new SpanTermQuery(new Term("foo", "baz"));
+
+    IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {
+      is.search(new SpanNearQuery(new SpanQuery[] { query, query2 }, 10, true), 5);
+    });
+    assertTrue(expected.getMessage().contains("was indexed without position data"));
+
+    ir.close();
+    dir.close();
+  }
+
+  public void testBuilder() throws Exception {
+
+    // Can't add subclauses from different fields
+    expectThrows(IllegalArgumentException.class, () -> {
+      SpanNearQuery.newOrderedNearQuery("field1").addClause(new SpanTermQuery(new Term("field2", "term")));
+    });
+
+    // Can't add gaps to unordered queries
+    expectThrows(IllegalArgumentException.class, () -> {
+      SpanNearQuery.newUnorderedNearQuery("field1").addGap(1);
+    });
+
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSpanNotQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestSpanNotQuery.java
new file mode 100644
index 0000000..123a450
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSpanNotQuery.java
@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.StringField;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.search.SpanNotQuery;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+
+/** Basic tests for SpanNotQuery */
+public class TestSpanNotQuery extends LuceneTestCase {
+  
+  public void testHashcodeEquals() {
+    SpanTermQuery q1 = new SpanTermQuery(new Term("field", "foo"));
+    SpanTermQuery q2 = new SpanTermQuery(new Term("field", "bar"));
+    SpanTermQuery q3 = new SpanTermQuery(new Term("field", "baz"));
+    
+    SpanNotQuery not1 = new SpanNotQuery(q1, q2);
+    SpanNotQuery not2 = new SpanNotQuery(q2, q3);
+    QueryUtils.check(not1);
+    QueryUtils.check(not2);
+    QueryUtils.checkUnequal(not1, not2);
+  }
+  
+  public void testDifferentField() throws Exception {
+    SpanTermQuery q1 = new SpanTermQuery(new Term("field1", "foo"));
+    SpanTermQuery q2 = new SpanTermQuery(new Term("field2", "bar"));
+    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
+      new SpanNotQuery(q1, q2);
+    });
+    assertTrue(expected.getMessage().contains("must have same field"));
+  }
+  
+  public void testNoPositions() throws IOException {
+    Directory dir = newDirectory();
+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new StringField("foo", "bar", Field.Store.NO));
+    iw.addDocument(doc);
+    
+    IndexReader ir = iw.getReader();
+    iw.close();
+    
+    IndexSearcher is = new IndexSearcher(ir);
+    SpanTermQuery query = new SpanTermQuery(new Term("foo", "bar"));
+    SpanTermQuery query2 = new SpanTermQuery(new Term("foo", "baz"));
+
+    IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {
+      is.search(new SpanNotQuery(query, query2), 5);
+    });
+    assertTrue(expected.getMessage().contains("was indexed without position data"));
+
+    ir.close();
+    dir.close();
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSpanOrQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestSpanOrQuery.java
new file mode 100644
index 0000000..335837c
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSpanOrQuery.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.util.LuceneTestCase;
+
+/** Basic tests for SpanOrQuery */
+public class TestSpanOrQuery extends LuceneTestCase {
+  
+  public void testHashcodeEquals() {
+    SpanTermQuery q1 = new SpanTermQuery(new Term("field", "foo"));
+    SpanTermQuery q2 = new SpanTermQuery(new Term("field", "bar"));
+    SpanTermQuery q3 = new SpanTermQuery(new Term("field", "baz"));
+    
+    SpanOrQuery or1 = new SpanOrQuery(q1, q2);
+    SpanOrQuery or2 = new SpanOrQuery(q2, q3);
+    QueryUtils.check(or1);
+    QueryUtils.check(or2);
+    QueryUtils.checkUnequal(or1, or2);
+  }
+  
+  public void testSpanOrEmpty() throws Exception {
+    SpanOrQuery a = new SpanOrQuery();
+    SpanOrQuery b = new SpanOrQuery();
+    assertTrue("empty should equal", a.equals(b));
+  }
+  
+  public void testDifferentField() throws Exception {
+    SpanTermQuery q1 = new SpanTermQuery(new Term("field1", "foo"));
+    SpanTermQuery q2 = new SpanTermQuery(new Term("field2", "bar"));
+    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
+      new SpanOrQuery(q1, q2);
+    });
+    assertTrue(expected.getMessage().contains("must have same field"));
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSpanSearchEquivalence.java b/lucene/core/src/test/org/apache/lucene/search/TestSpanSearchEquivalence.java
new file mode 100644
index 0000000..00db419
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSpanSearchEquivalence.java
@@ -0,0 +1,480 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.SearchEquivalenceTestBase;
+import org.apache.lucene.search.SpanBoostQuery;
+import org.apache.lucene.search.SpanContainingQuery;
+import org.apache.lucene.search.SpanFirstQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanNotQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanPositionRangeQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.search.SpanWithinQuery;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.spans.AssertingSpanQuery;
+
+import static org.apache.lucene.search.spans.SpanTestUtil.*;
+
+/**
+ * Basic equivalence tests for span queries
+ */
+public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
+  
+  // TODO: we could go a little crazy for a lot of these,
+  // but these are just simple minimal cases in case something 
+  // goes horribly wrong. Put more intense tests elsewhere.
+
+  /** SpanTermQuery(A) = TermQuery(A) */
+  public void testSpanTermVersusTerm() throws Exception {
+    Term t1 = randomTerm();
+    assertSameScores(new TermQuery(t1), spanQuery(new SpanTermQuery(t1)));
+  }
+  
+  /** SpanOrQuery(A) = SpanTermQuery(A) */
+  public void testSpanOrVersusTerm() throws Exception {
+    Term t1 = randomTerm();
+    SpanQuery term = spanQuery(new SpanTermQuery(t1));
+    assertSameSet(spanQuery(new SpanOrQuery(term)), term);
+  }
+  
+  /** SpanOrQuery(A, A) = SpanTermQuery(A) */
+  public void testSpanOrDoubleVersusTerm() throws Exception {
+    Term t1 = randomTerm();
+    SpanQuery term = spanQuery(new SpanTermQuery(t1));
+    assertSameSet(spanQuery(new SpanOrQuery(term, term)), term);
+  }
+  
+  /** SpanOrQuery(A, B) = (A B) */
+  public void testSpanOrVersusBooleanTerm() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    BooleanQuery.Builder q1 = new BooleanQuery.Builder();
+    q1.add(new TermQuery(t1), Occur.SHOULD);
+    q1.add(new TermQuery(t2), Occur.SHOULD);
+    SpanQuery q2 = spanQuery(new SpanOrQuery(spanQuery(new SpanTermQuery(t1)), spanQuery(new SpanTermQuery(t2))));
+    assertSameSet(q1.build(), q2);
+  }
+  
+  /** SpanOrQuery(SpanNearQuery[A B], SpanNearQuery[C D]) = (SpanNearQuery[A B], SpanNearQuery[C D]) */
+  public void testSpanOrVersusBooleanNear() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    Term t3 = randomTerm();
+    Term t4 = randomTerm();
+    SpanQuery near1 = spanQuery(new SpanNearQuery(new SpanQuery[] { 
+                                               spanQuery(new SpanTermQuery(t1)), 
+                                               spanQuery(new SpanTermQuery(t2)) 
+                                             }, 10, random().nextBoolean()));
+    SpanQuery near2 = spanQuery(new SpanNearQuery(new SpanQuery[] { 
+                                               spanQuery(new SpanTermQuery(t3)), 
+                                               spanQuery(new SpanTermQuery(t4)) 
+                                             }, 10, random().nextBoolean()));
+    BooleanQuery.Builder q1 = new BooleanQuery.Builder();
+    q1.add(near1, Occur.SHOULD);
+    q1.add(near2, Occur.SHOULD);
+    SpanQuery q2 = spanQuery(new SpanOrQuery(near1, near2));
+    assertSameSet(q1.build(), q2);
+  }
+  
+  /** SpanNotQuery(A, B) ⊆ SpanTermQuery(A) */
+  public void testSpanNotVersusSpanTerm() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    assertSubsetOf(spanQuery(new SpanNotQuery(spanQuery(new SpanTermQuery(t1)), spanQuery(new SpanTermQuery(t2)))), 
+                   spanQuery(new SpanTermQuery(t1)));
+  }
+  
+  /** SpanNotQuery(A, [B C]) ⊆ SpanTermQuery(A) */
+  public void testSpanNotNearVersusSpanTerm() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    Term t3 = randomTerm();
+    SpanQuery near = spanQuery(new SpanNearQuery(new SpanQuery[] { 
+                                              spanQuery(new SpanTermQuery(t2)), 
+                                              spanQuery(new SpanTermQuery(t3)) 
+                                            }, 10, random().nextBoolean()));
+    assertSubsetOf(spanQuery(new SpanNotQuery(spanQuery(new SpanTermQuery(t1)), near)), spanQuery(new SpanTermQuery(t1)));
+  }
+  
+  /** SpanNotQuery([A B], C) ⊆ SpanNearQuery([A B]) */
+  public void testSpanNotVersusSpanNear() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    Term t3 = randomTerm();
+    SpanQuery near = spanQuery(new SpanNearQuery(new SpanQuery[] { 
+                                              spanQuery(new SpanTermQuery(t1)), 
+                                              spanQuery(new SpanTermQuery(t2)) 
+                                            }, 10, random().nextBoolean()));
+    assertSubsetOf(spanQuery(new SpanNotQuery(near, spanQuery(new SpanTermQuery(t3)))), near);
+  }
+  
+  /** SpanNotQuery([A B], [C D]) ⊆ SpanNearQuery([A B]) */
+  public void testSpanNotNearVersusSpanNear() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    Term t3 = randomTerm();
+    Term t4 = randomTerm();
+    SpanQuery near1 = spanQuery(new SpanNearQuery(new SpanQuery[] { 
+                                               spanQuery(new SpanTermQuery(t1)), 
+                                               spanQuery(new SpanTermQuery(t2)) 
+                                             }, 10, random().nextBoolean()));
+    SpanQuery near2 = spanQuery(new SpanNearQuery(new SpanQuery[] { 
+                                               spanQuery(new SpanTermQuery(t3)), 
+                                               spanQuery(new SpanTermQuery(t4)) 
+                                             }, 10, random().nextBoolean()));
+    assertSubsetOf(spanQuery(new SpanNotQuery(near1, near2)), near1);
+  }
+  
+  /** SpanFirstQuery(A, 10) ⊆ SpanTermQuery(A) */
+  public void testSpanFirstVersusSpanTerm() throws Exception {
+    Term t1 = randomTerm();
+    assertSubsetOf(spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), 10)), 
+                   spanQuery(new SpanTermQuery(t1)));
+  }
+  
+  /** SpanNearQuery([A, B], 0, true) = "A B" */
+  public void testSpanNearVersusPhrase() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
+                           };
+    SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, 0, true));
+    PhraseQuery q2 = new PhraseQuery(t1.field(), t1.bytes(), t2.bytes());
+    if (t1.equals(t2)) {
+      assertSameSet(q1, q2);
+    } else {
+      assertSameScores(q1, q2);
+    }
+  }
+  
+  /** SpanNearQuery([A, B], ∞, false) = +A +B */
+  public void testSpanNearVersusBooleanAnd() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
+                           };
+    SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, Integer.MAX_VALUE, false));
+    BooleanQuery.Builder q2 = new BooleanQuery.Builder();
+    q2.add(new TermQuery(t1), Occur.MUST);
+    q2.add(new TermQuery(t2), Occur.MUST);
+    assertSameSet(q1, q2.build());
+  }
+  
+  /** SpanNearQuery([A B], 0, false) ⊆ SpanNearQuery([A B], 1, false) */
+  public void testSpanNearVersusSloppySpanNear() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
+                           };
+    SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, 0, false));
+    SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, 1, false));
+    assertSubsetOf(q1, q2);
+  }
+  
+  /** SpanNearQuery([A B], 3, true) ⊆ SpanNearQuery([A B], 3, false) */
+  public void testSpanNearInOrderVersusOutOfOrder() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
+                           };
+    SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, 3, true));
+    SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, 3, false));
+    assertSubsetOf(q1, q2);
+  }
+  
+  /** SpanNearQuery([A B], N, false) ⊆ SpanNearQuery([A B], N+1, false) */
+  public void testSpanNearIncreasingSloppiness() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
+                           };
+    for (int i = 0; i < 10; i++) {
+      SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, i, false));
+      SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, i+1, false));
+      assertSubsetOf(q1, q2);
+    }
+  }
+  
+  /** SpanNearQuery([A B C], N, false) ⊆ SpanNearQuery([A B C], N+1, false) */
+  public void testSpanNearIncreasingSloppiness3() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    Term t3 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)), 
+                             spanQuery(new SpanTermQuery(t3)) 
+                           };
+    for (int i = 0; i < 10; i++) {
+      SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, i, false));
+      SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, i+1, false));
+      assertSubsetOf(q1, q2);
+    }
+  }
+  
+  /** SpanNearQuery([A B], N, true) ⊆ SpanNearQuery([A B], N+1, true) */
+  public void testSpanNearIncreasingOrderedSloppiness() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
+                           };
+    for (int i = 0; i < 10; i++) {
+      SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, i, false));
+      SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, i+1, false));
+      assertSubsetOf(q1, q2);
+    }
+  }
+  
+  /** SpanNearQuery([A B C], N, true) ⊆ SpanNearQuery([A B C], N+1, true) */
+  public void testSpanNearIncreasingOrderedSloppiness3() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    Term t3 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)), 
+                             spanQuery(new SpanTermQuery(t3)) 
+                           };
+    for (int i = 0; i < 10; i++) {
+      SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, i, true));
+      SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, i+1, true));
+      assertSubsetOf(q1, q2);
+    }
+  }
+  
+  /** SpanPositionRangeQuery(A, M, N) ⊆ TermQuery(A) */
+  public void testSpanRangeTerm() throws Exception {
+    Term t1 = randomTerm();
+    for (int i = 0; i < 5; i++) {
+      for (int j = 0; j < 5; j++) {
+        Query q1 = spanQuery(new SpanPositionRangeQuery(spanQuery(new SpanTermQuery(t1)), i, i+j));
+        Query q2 = new TermQuery(t1);
+        assertSubsetOf(q1, q2);
+      }
+    }
+  }
+  
+  /** SpanPositionRangeQuery(A, M, N) ⊆ SpanFirstQuery(A, M, N+1) */
+  public void testSpanRangeTermIncreasingEnd() throws Exception {
+    Term t1 = randomTerm();
+    for (int i = 0; i < 5; i++) {
+      for (int j = 0; j < 5; j++) {
+        Query q1 = spanQuery(new SpanPositionRangeQuery(spanQuery(new SpanTermQuery(t1)), i, i+j));
+        Query q2 = spanQuery(new SpanPositionRangeQuery(spanQuery(new SpanTermQuery(t1)), i, i+j+1));
+        assertSubsetOf(q1, q2);
+      }
+    }
+  }
+  
+  /** SpanPositionRangeQuery(A, 0, ∞) = TermQuery(A) */
+  public void testSpanRangeTermEverything() throws Exception {
+    Term t1 = randomTerm();
+    Query q1 = spanQuery(new SpanPositionRangeQuery(spanQuery(new SpanTermQuery(t1)), 0, Integer.MAX_VALUE));
+    Query q2 = new TermQuery(t1);
+    assertSameSet(q1, q2);
+  }
+  
+  /** SpanPositionRangeQuery([A B], M, N) ⊆ SpanNearQuery([A B]) */
+  public void testSpanRangeNear() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
+                           };
+    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
+    for (int i = 0; i < 5; i++) {
+      for (int j = 0; j < 5; j++) {
+        Query q1 = spanQuery(new SpanPositionRangeQuery(nearQuery, i, i+j));
+        Query q2 = nearQuery;
+        assertSubsetOf(q1, q2);
+      }
+    }
+  }
+  
+  /** SpanPositionRangeQuery([A B], M, N) ⊆ SpanFirstQuery([A B], M, N+1) */
+  public void testSpanRangeNearIncreasingEnd() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2))
+                           };
+    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
+    for (int i = 0; i < 5; i++) {
+      for (int j = 0; j < 5; j++) {
+        Query q1 = spanQuery(new SpanPositionRangeQuery(nearQuery, i, i+j));
+        Query q2 = spanQuery(new SpanPositionRangeQuery(nearQuery, i, i+j+1));
+        assertSubsetOf(q1, q2);
+      }
+    }
+  }
+  
+  /** SpanPositionRangeQuery([A B], ∞) = SpanNearQuery([A B]) */
+  public void testSpanRangeNearEverything() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
+                           };
+    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
+    Query q1 = spanQuery(new SpanPositionRangeQuery(nearQuery, 0, Integer.MAX_VALUE));
+    Query q2 = nearQuery;
+    assertSameSet(q1, q2);
+  }
+  
+  /** SpanFirstQuery(A, N) ⊆ TermQuery(A) */
+  public void testSpanFirstTerm() throws Exception {
+    Term t1 = randomTerm();
+    for (int i = 0; i < 10; i++) {
+      Query q1 = spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), i));
+      Query q2 = new TermQuery(t1);
+      assertSubsetOf(q1, q2);
+    }
+  }
+  
+  /** SpanFirstQuery(A, N) ⊆ SpanFirstQuery(A, N+1) */
+  public void testSpanFirstTermIncreasing() throws Exception {
+    Term t1 = randomTerm();
+    for (int i = 0; i < 10; i++) {
+      Query q1 = spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), i));
+      Query q2 = spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), i+1));
+      assertSubsetOf(q1, q2);
+    }
+  }
+  
+  /** SpanFirstQuery(A, ∞) = TermQuery(A) */
+  public void testSpanFirstTermEverything() throws Exception {
+    Term t1 = randomTerm();
+    Query q1 = spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), Integer.MAX_VALUE));
+    Query q2 = new TermQuery(t1);
+    assertSameSet(q1, q2);
+  }
+  
+  /** SpanFirstQuery([A B], N) ⊆ SpanNearQuery([A B]) */
+  public void testSpanFirstNear() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
+                           };
+    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
+    for (int i = 0; i < 10; i++) {
+      Query q1 = spanQuery(new SpanFirstQuery(nearQuery, i));
+      Query q2 = nearQuery;
+      assertSubsetOf(q1, q2);
+    }
+  }
+  
+  /** SpanFirstQuery([A B], N) ⊆ SpanFirstQuery([A B], N+1) */
+  public void testSpanFirstNearIncreasing() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
+                           };
+    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
+    for (int i = 0; i < 10; i++) {
+      Query q1 = spanQuery(new SpanFirstQuery(nearQuery, i));
+      Query q2 = spanQuery(new SpanFirstQuery(nearQuery, i+1));
+      assertSubsetOf(q1, q2);
+    }
+  }
+  
+  /** SpanFirstQuery([A B], ∞) = SpanNearQuery([A B]) */
+  public void testSpanFirstNearEverything() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+                             spanQuery(new SpanTermQuery(t1)), 
+                             spanQuery(new SpanTermQuery(t2)) 
+                           };
+    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
+    Query q1 = spanQuery(new SpanFirstQuery(nearQuery, Integer.MAX_VALUE));
+    Query q2 = nearQuery;
+    assertSameSet(q1, q2);
+  }
+  
+  /** SpanWithinQuery(A, B) ⊆ SpanNearQuery(A) */
+  public void testSpanWithinVsNear() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] {
+        spanQuery(new SpanTermQuery(t1)), 
+        spanQuery(new SpanTermQuery(t2)) 
+      };
+    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
+    
+    Term t3 = randomTerm();
+    SpanQuery termQuery = spanQuery(new SpanTermQuery(t3));
+    Query q1 = spanQuery(new SpanWithinQuery(nearQuery, termQuery));
+    assertSubsetOf(q1, termQuery);
+  }
+  
+  /** SpanWithinQuery(A, B) = SpanContainingQuery(A, B) */
+  public void testSpanWithinVsContaining() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpanQuery subquery[] = new SpanQuery[] { 
+        spanQuery(new SpanTermQuery(t1)), 
+        spanQuery(new SpanTermQuery(t2)) 
+      };
+    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
+    
+    Term t3 = randomTerm();
+    SpanQuery termQuery = spanQuery(new SpanTermQuery(t3));
+    Query q1 = spanQuery(new SpanWithinQuery(nearQuery, termQuery));
+    Query q2 = spanQuery(new SpanContainingQuery(nearQuery, termQuery));
+    assertSameSet(q1, q2);
+  }
+
+  public void testSpanBoostQuerySimplification() throws Exception {
+    float b1 = random().nextFloat() * 10;
+    float b2 = random().nextFloat() * 10;
+    Term term = randomTerm();
+
+    Query q1 = new SpanBoostQuery(new SpanBoostQuery(new SpanTermQuery(term), b2), b1);
+    // Use AssertingQuery to prevent BoostQuery from merging inner and outer boosts
+    Query q2 = new SpanBoostQuery(new AssertingSpanQuery(new SpanBoostQuery(new SpanTermQuery(term), b2)), b1);
+
+    assertSameScores(q1, q2);
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSpanTermQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestSpanTermQuery.java
new file mode 100644
index 0000000..e52740c
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSpanTermQuery.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.StringField;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+
+/** Basic tests for SpanTermQuery */
+public class TestSpanTermQuery extends LuceneTestCase {
+  
+  public void testHashcodeEquals() {
+    SpanTermQuery q1 = new SpanTermQuery(new Term("field", "foo"));
+    SpanTermQuery q2 = new SpanTermQuery(new Term("field", "bar"));
+    QueryUtils.check(q1);
+    QueryUtils.check(q2);
+    QueryUtils.checkUnequal(q1, q2);
+  }
+  
+  public void testNoPositions() throws IOException {
+    Directory dir = newDirectory();
+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
+    Document doc = new Document();
+    doc.add(new StringField("foo", "bar", Field.Store.NO));
+    iw.addDocument(doc);
+    
+    IndexReader ir = iw.getReader();
+    iw.close();
+    
+    IndexSearcher is = new IndexSearcher(ir);
+    SpanTermQuery query = new SpanTermQuery(new Term("foo", "bar"));
+    IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {
+      is.search(query, 5);
+    });
+    assertTrue(expected.getMessage().contains("was indexed without position data"));
+
+    ir.close();
+    dir.close();
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSpans.java b/lucene/core/src/test/org/apache/lucene/search/TestSpans.java
new file mode 100644
index 0000000..93a06d8
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSpans.java
@@ -0,0 +1,464 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.ReaderUtil;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.FuzzyQuery;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.PrefixQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.SpanMultiTermQueryWrapper;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanWeight;
+import org.apache.lucene.search.Spans;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.similarities.ClassicSimilarity;
+import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+
+import static org.apache.lucene.search.spans.SpanTestUtil.assertFinished;
+import static org.apache.lucene.search.spans.SpanTestUtil.assertNext;
+import static org.apache.lucene.search.spans.SpanTestUtil.spanNearOrderedQuery;
+import static org.apache.lucene.search.spans.SpanTestUtil.spanNearUnorderedQuery;
+import static org.apache.lucene.search.spans.SpanTestUtil.spanNotQuery;
+import static org.apache.lucene.search.spans.SpanTestUtil.spanOrQuery;
+import static org.apache.lucene.search.spans.SpanTestUtil.spanTermQuery;
+
+public class TestSpans extends LuceneTestCase {
+  private IndexSearcher searcher;
+  private IndexReader reader;
+  private Directory directory;
+  
+  public static final String field = "field";
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    directory = newDirectory();
+    RandomIndexWriter writer= new RandomIndexWriter(random(), directory, newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
+    for (int i = 0; i < docFields.length; i++) {
+      Document doc = new Document();
+      doc.add(newTextField(field, docFields[i], Field.Store.YES));
+      writer.addDocument(doc);
+    }
+    writer.forceMerge(1);
+    reader = writer.getReader();
+    writer.close();
+    searcher = newSearcher(getOnlyLeafReader(reader));
+  }
+  
+  @Override
+  public void tearDown() throws Exception {
+    reader.close();
+    directory.close();
+    super.tearDown();
+  }
+  
+  private String[] docFields = {
+    "w1 w2 w3 w4 w5",
+    "w1 w3 w2 w3",
+    "w1 xx w2 yy w3",
+    "w1 w3 xx w2 yy w3",
+    "u2 u2 u1",
+    "u2 xx u2 u1",
+    "u2 u2 xx u1",
+    "u2 xx u2 yy u1",
+    "u2 xx u1 u2",
+    "u2 u1 xx u2",
+    "u1 u2 xx u2",
+    "t1 t2 t1 t3 t2 t3",
+    "s2 s1 s1 xx xx s2 xx s2 xx s1 xx xx xx xx xx s2 xx",
+    "r1 s11",
+    "r1 s21"
+
+  };
+  
+  private void checkHits(Query query, int[] results) throws IOException {
+    CheckHits.checkHits(random(), query, field, searcher, results);
+  }
+  
+  private void orderedSlopTest3SQ(
+        SpanQuery q1,
+        SpanQuery q2,
+        SpanQuery q3,
+        int slop,
+        int[] expectedDocs) throws IOException {
+    SpanQuery query = spanNearOrderedQuery(slop, q1, q2, q3);
+    checkHits(query, expectedDocs);
+  }
+  
+  public void orderedSlopTest3(int slop, int[] expectedDocs) throws IOException {
+    orderedSlopTest3SQ(
+       spanTermQuery(field, "w1"),
+       spanTermQuery(field, "w2"),
+       spanTermQuery(field, "w3"),
+       slop,
+       expectedDocs);
+  }
+  
+  public void orderedSlopTest3Equal(int slop, int[] expectedDocs) throws IOException {
+    orderedSlopTest3SQ(
+       spanTermQuery(field, "w1"),
+       spanTermQuery(field, "w3"),
+       spanTermQuery(field, "w3"),
+       slop,
+       expectedDocs);
+  }
+  
+  public void orderedSlopTest1Equal(int slop, int[] expectedDocs) throws IOException {
+    orderedSlopTest3SQ(
+       spanTermQuery(field, "u2"),
+       spanTermQuery(field, "u2"),
+       spanTermQuery(field, "u1"),
+       slop,
+       expectedDocs);
+  }
+  
+  public void testSpanNearOrdered01() throws Exception {
+    orderedSlopTest3(0, new int[] {0});
+  }
+
+  public void testSpanNearOrdered02() throws Exception {
+    orderedSlopTest3(1, new int[] {0,1});
+  }
+
+  public void testSpanNearOrdered03() throws Exception {
+    orderedSlopTest3(2, new int[] {0,1,2});
+  }
+
+  public void testSpanNearOrdered04() throws Exception {
+    orderedSlopTest3(3, new int[] {0,1,2,3});
+  }
+
+  public void testSpanNearOrdered05() throws Exception {
+    orderedSlopTest3(4, new int[] {0,1,2,3});
+  }
+  
+  public void testSpanNearOrderedEqual01() throws Exception {
+    orderedSlopTest3Equal(0, new int[] {});
+  }
+
+  public void testSpanNearOrderedEqual02() throws Exception {
+    orderedSlopTest3Equal(1, new int[] {1});
+  }
+
+  public void testSpanNearOrderedEqual03() throws Exception {
+    orderedSlopTest3Equal(2, new int[] {1});
+  }
+
+  public void testSpanNearOrderedEqual04() throws Exception {
+    orderedSlopTest3Equal(3, new int[] {1,3});
+  }
+  
+  public void testSpanNearOrderedEqual11() throws Exception {
+    orderedSlopTest1Equal(0, new int[] {4});
+  }
+  
+  public void testSpanNearOrderedEqual12() throws Exception {
+    orderedSlopTest1Equal(0, new int[] {4});
+  }
+  
+  public void testSpanNearOrderedEqual13() throws Exception {
+    orderedSlopTest1Equal(1, new int[] {4,5,6});
+  }
+  
+  public void testSpanNearOrderedEqual14() throws Exception {
+    orderedSlopTest1Equal(2, new int[] {4,5,6,7});
+  }
+
+  public void testSpanNearOrderedEqual15() throws Exception {
+    orderedSlopTest1Equal(3, new int[] {4,5,6,7});
+  }
+
+  public void testSpanNearOrderedOverlap() throws Exception {
+    final SpanQuery query = spanNearOrderedQuery(field, 1, "t1", "t2", "t3");
+    
+    Spans spans = query.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+
+    assertEquals("first doc", 11, spans.nextDoc());
+    assertEquals("first start", 0, spans.nextStartPosition());
+    assertEquals("first end", 4, spans.endPosition());
+
+    assertEquals("second start", 2, spans.nextStartPosition());
+    assertEquals("second end", 6, spans.endPosition());
+
+    assertFinished(spans);  
+  }
+
+  public void testSpanNearUnOrdered() throws Exception {
+    //See http://www.gossamer-threads.com/lists/lucene/java-dev/52270 for discussion about this test
+    SpanQuery senq = spanNearUnorderedQuery(field, 0, "u1", "u2");
+    Spans spans = senq.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertNext(spans, 4, 1, 3);
+    assertNext(spans, 5, 2, 4);
+    assertNext(spans, 8, 2, 4);
+    assertNext(spans, 9, 0, 2);
+    assertNext(spans, 10, 0, 2);
+    assertFinished(spans);
+
+    senq = spanNearUnorderedQuery(1, senq, spanTermQuery(field, "u2")); 
+    spans = senq.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+    assertNext(spans, 4, 0, 3);
+    assertNext(spans, 4, 1, 3); // unordered spans can be subsets
+    assertNext(spans, 5, 0, 4);
+    assertNext(spans, 5, 2, 4);
+    assertNext(spans, 8, 0, 4);
+    assertNext(spans, 8, 2, 4);
+    assertNext(spans, 9, 0, 2);
+    assertNext(spans, 9, 0, 4);
+    assertNext(spans, 10, 0, 2);
+    assertFinished(spans);
+  }
+
+  private Spans orSpans(String[] terms) throws Exception {
+    return spanOrQuery(field, terms).createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+  }
+
+  public void testSpanOrEmpty() throws Exception {
+    Spans spans = orSpans(new String[0]);
+    assertFinished(spans);
+  }
+
+  public void testSpanOrSingle() throws Exception {
+    Spans spans = orSpans(new String[] {"w5"});
+    assertNext(spans, 0, 4, 5);
+    assertFinished(spans);
+  }
+  
+  public void testSpanOrDouble() throws Exception {
+    Spans spans = orSpans(new String[] {"w5", "yy"});
+    assertNext(spans, 0, 4, 5);
+    assertNext(spans, 2, 3, 4);
+    assertNext(spans, 3, 4, 5);
+    assertNext(spans, 7, 3, 4);
+    assertFinished(spans);
+  }
+
+  public void testSpanOrDoubleAdvance() throws Exception {
+    Spans spans = orSpans(new String[] {"w5", "yy"});
+    assertEquals("initial advance", 3, spans.advance(3));
+    assertNext(spans, 3, 4, 5);
+    assertNext(spans, 7, 3, 4);
+    assertFinished(spans);
+  }
+
+  public void testSpanOrUnused() throws Exception {
+    Spans spans = orSpans(new String[] {"w5", "unusedTerm", "yy"});
+    assertNext(spans, 0, 4, 5);
+    assertNext(spans, 2, 3, 4);
+    assertNext(spans, 3, 4, 5);
+    assertNext(spans, 7, 3, 4);
+    assertFinished(spans);
+  }
+
+  public void testSpanOrTripleSameDoc() throws Exception {
+    Spans spans = orSpans(new String[] {"t1", "t2", "t3"});
+    assertNext(spans, 11, 0, 1);
+    assertNext(spans, 11, 1, 2);
+    assertNext(spans, 11, 2, 3);
+    assertNext(spans, 11, 3, 4);
+    assertNext(spans, 11, 4, 5);
+    assertNext(spans, 11, 5, 6);
+    assertFinished(spans);
+  }
+
+  public void testSpanScorerZeroSloppyFreq() throws Exception {
+    IndexReaderContext topReaderContext = searcher.getTopReaderContext();
+    List<LeafReaderContext> leaves = topReaderContext.leaves();
+    int subIndex = ReaderUtil.subIndex(11, leaves);
+    for (int i = 0, c = leaves.size(); i < c; i++) {
+      final LeafReaderContext ctx = leaves.get(i);
+     
+      final Similarity sim = new ClassicSimilarity() {
+        @Override
+        public float sloppyFreq(int distance) {
+          return 0.0f;
+        }
+      };
+  
+      final Similarity oldSim = searcher.getSimilarity(true);
+      Scorer spanScorer;
+      try {
+        searcher.setSimilarity(sim);
+        SpanQuery snq = spanNearOrderedQuery(field, 1, "t1", "t2");
+        spanScorer = searcher.createNormalizedWeight(snq, true).scorer(ctx);
+      } finally {
+        searcher.setSimilarity(oldSim);
+      }
+      if (i == subIndex) {
+        assertTrue("first doc", spanScorer.iterator().nextDoc() != DocIdSetIterator.NO_MORE_DOCS);
+        assertEquals("first doc number", spanScorer.docID() + ctx.docBase, 11);
+        float score = spanScorer.score();
+        assertTrue("first doc score should be zero, " + score, score == 0.0f);
+      } else {
+        assertTrue("no second doc", spanScorer == null || spanScorer.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);
+      }
+    }
+  }
+
+  // LUCENE-1404
+  private void addDoc(IndexWriter writer, String id, String text) throws IOException {
+    final Document doc = new Document();
+    doc.add( newStringField("id", id, Field.Store.YES) );
+    doc.add( newTextField("text", text, Field.Store.YES) );
+    writer.addDocument(doc);
+  }
+
+  // LUCENE-1404
+  private int hitCount(IndexSearcher searcher, String word) throws Throwable {
+    return searcher.search(new TermQuery(new Term("text", word)), 10).totalHits;
+  }
+
+  // LUCENE-1404
+  private SpanQuery createSpan(String value) {
+    return spanTermQuery("text", value);
+  }                     
+  
+  // LUCENE-1404
+  private SpanQuery createSpan(int slop, boolean ordered, SpanQuery[] clauses) {
+    if (ordered) {
+      return spanNearOrderedQuery(slop, clauses);
+    } else {
+      return spanNearUnorderedQuery(slop, clauses);
+    }
+  }
+
+  // LUCENE-1404
+  private SpanQuery createSpan(int slop, boolean ordered, String term1, String term2) {
+    return createSpan(slop, ordered, new SpanQuery[] {createSpan(term1), createSpan(term2)});
+  }
+
+  // LUCENE-1404
+  public void testNPESpanQuery() throws Throwable {
+    final Directory dir = newDirectory();
+    final IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(new MockAnalyzer(random())));
+
+    // Add documents
+    addDoc(writer, "1", "the big dogs went running to the market");
+    addDoc(writer, "2", "the cat chased the mouse, then the cat ate the mouse quickly");
+    
+    // Commit
+    writer.close();
+
+    // Get searcher
+    final IndexReader reader = DirectoryReader.open(dir);
+    final IndexSearcher searcher = newSearcher(reader);
+
+    // Control (make sure docs indexed)
+    assertEquals(2, hitCount(searcher, "the"));
+    assertEquals(1, hitCount(searcher, "cat"));
+    assertEquals(1, hitCount(searcher, "dogs"));
+    assertEquals(0, hitCount(searcher, "rabbit"));
+
+    // This throws exception (it shouldn't)
+    assertEquals(1,
+                 searcher.search(createSpan(0, true,                                 
+                                            new SpanQuery[] {createSpan(4, false, "chased", "cat"),
+                                                             createSpan("ate")}), 10).totalHits);
+    reader.close();
+    dir.close();
+  }
+
+  public void testSpanNotWithMultiterm() throws Exception {
+    SpanQuery q = spanNotQuery(
+        spanTermQuery(field, "r1"),
+        new SpanMultiTermQueryWrapper<>(new PrefixQuery(new Term(field, "s1"))),3,3);
+    checkHits(q,  new int[] {14});
+
+    q = spanNotQuery(
+        spanTermQuery(field, "r1"),
+        new SpanMultiTermQueryWrapper<>(new FuzzyQuery(new Term(field, "s12"), 1, 2)),3,3);
+    checkHits(q,  new int[] {14});
+
+    q = spanNotQuery(
+        new SpanMultiTermQueryWrapper<>(new PrefixQuery(new Term(field, "r"))),
+        spanTermQuery(field, "s21"),3,3);
+    checkHits(q,  new int[] {13});
+
+
+  }
+  
+  public void testSpanNots() throws Throwable{
+     assertEquals("SpanNotIncludeExcludeSame1", 0, spanCount("s2", "s2", 0, 0), 0);
+     assertEquals("SpanNotIncludeExcludeSame2", 0, spanCount("s2", "s2", 10, 10), 0);
+     
+     //focus on behind
+     assertEquals("SpanNotS2NotS1_6_0", 1, spanCount("s2", "s1", 6, 0));
+     assertEquals("SpanNotS2NotS1_5_0", 2, spanCount("s2", "s1", 5, 0));
+     assertEquals("SpanNotS2NotS1_3_0", 3, spanCount("s2", "s1", 3, 0));
+     assertEquals("SpanNotS2NotS1_2_0", 4, spanCount("s2", "s1", 2, 0));
+     assertEquals("SpanNotS2NotS1_0_0", 4, spanCount("s2", "s1", 0, 0));
+     
+     //focus on both
+     assertEquals("SpanNotS2NotS1_3_1", 2, spanCount("s2", "s1", 3, 1));
+     assertEquals("SpanNotS2NotS1_2_1", 3, spanCount("s2", "s1", 2, 1));
+     assertEquals("SpanNotS2NotS1_1_1", 3, spanCount("s2", "s1", 1, 1));
+     assertEquals("SpanNotS2NotS1_10_10", 0, spanCount("s2", "s1", 10, 10));
+     
+     //focus on ahead
+     assertEquals("SpanNotS1NotS2_10_10", 0, spanCount("s1", "s2", 10, 10));  
+     assertEquals("SpanNotS1NotS2_0_1", 3, spanCount("s1", "s2", 0, 1));  
+     assertEquals("SpanNotS1NotS2_0_2", 3, spanCount("s1", "s2", 0, 2));  
+     assertEquals("SpanNotS1NotS2_0_3", 2, spanCount("s1", "s2", 0, 3));  
+     assertEquals("SpanNotS1NotS2_0_4", 1, spanCount("s1", "s2", 0, 4));
+     assertEquals("SpanNotS1NotS2_0_8", 0, spanCount("s1", "s2", 0, 8));
+     
+     //exclude doesn't exist
+     assertEquals("SpanNotS1NotS3_8_8", 3, spanCount("s1", "s3", 8, 8));
+
+     //include doesn't exist
+     assertEquals("SpanNotS3NotS1_8_8", 0, spanCount("s3", "s1", 8, 8));
+
+  }
+  
+  private int spanCount(String include, String exclude, int pre, int post) throws IOException{
+     SpanQuery iq = spanTermQuery(field, include);
+     SpanQuery eq = spanTermQuery(field, exclude);
+     SpanQuery snq = spanNotQuery(iq, eq, pre, post);
+     Spans spans = snq.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
+
+     int i = 0;
+     if (spans != null) {
+       while (spans.nextDoc() != Spans.NO_MORE_DOCS){
+         while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
+           i++;
+         }
+       }
+     }
+     return i;
+  }
+  
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestSpansEnum.java b/lucene/core/src/test/org/apache/lucene/search/TestSpansEnum.java
new file mode 100644
index 0000000..e44dab3
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/TestSpansEnum.java
@@ -0,0 +1,122 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.English;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+
+import static org.apache.lucene.search.spans.SpanTestUtil.*;
+
+/**
+ * Tests Spans (v2)
+ *
+ */
+public class TestSpansEnum extends LuceneTestCase {
+  private static IndexSearcher searcher;
+  private static IndexReader reader;
+  private static Directory directory;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+        newIndexWriterConfig(new MockAnalyzer(random()))
+            .setMaxBufferedDocs(TestUtil.nextInt(random(), 100, 1000)).setMergePolicy(newLogMergePolicy()));
+    //writer.infoStream = System.out;
+    for (int i = 0; i < 10; i++) {
+      Document doc = new Document();
+      doc.add(newTextField("field", English.intToEnglish(i), Field.Store.YES));
+      writer.addDocument(doc);
+    }
+    for (int i = 100; i < 110; i++) {
+      Document doc = new Document(); // doc id 10-19 have 100-109
+      doc.add(newTextField("field", English.intToEnglish(i), Field.Store.YES));
+      writer.addDocument(doc);
+    }
+    reader = writer.getReader();
+    searcher = newSearcher(reader);
+    writer.close();
+  }
+
+  @AfterClass
+  public static void afterClass() throws Exception {
+    reader.close();
+    directory.close();
+    searcher = null;
+    reader = null;
+    directory = null;
+  }
+
+  private void checkHits(Query query, int[] results) throws IOException {
+    CheckHits.checkHits(random(), query, "field", searcher, results);
+  }
+
+  public void testSpansEnumOr1() throws Exception {
+    checkHits(spanOrQuery("field", "one", "two"), 
+              new int[] {1, 2, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
+  }
+
+  public void testSpansEnumOr2() throws Exception {
+    checkHits(spanOrQuery("field", "one", "eleven"), 
+              new int[] {1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
+  }
+
+  public void testSpansEnumOr3() throws Exception {
+    checkHits(spanOrQuery("field", "twelve", "eleven"), 
+              new int[] {});
+  }
+  
+  public SpanQuery spanTQ(String s) {
+    return spanTermQuery("field", s);
+  }
+
+  public void testSpansEnumOrNot1() throws Exception {
+    checkHits(spanNotQuery(spanOrQuery("field", "one", "two"), spanTermQuery("field", "one")),
+              new int[] {2,12});
+  }
+
+  public void testSpansEnumNotBeforeAfter1() throws Exception {
+    checkHits(spanNotQuery(spanTermQuery("field", "hundred"), spanTermQuery("field", "one")), 
+              new int[] {10, 11, 12, 13, 14, 15, 16, 17, 18, 19}); // include all "one hundred ..."
+  }
+
+  public void testSpansEnumNotBeforeAfter2() throws Exception {
+    checkHits(spanNotQuery(spanTermQuery("field", "hundred"), spanTermQuery("field", "one"), 1, 0),
+              new int[] {}); // exclude all "one hundred ..."
+  }
+
+  public void testSpansEnumNotBeforeAfter3() throws Exception {
+    checkHits(spanNotQuery(spanTermQuery("field", "hundred"), spanTermQuery("field", "one"), 0, 1),
+              new int[] {10, 12, 13, 14, 15, 16, 17, 18, 19}); // exclude "one hundred one"
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarity2.java b/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarity2.java
index 8052923..c632954 100644
--- a/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarity2.java
+++ b/lucene/core/src/test/org/apache/lucene/search/similarities/TestSimilarity2.java
@@ -36,8 +36,8 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java
deleted file mode 100644
index f844795..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-
-import org.apache.lucene.search.IndexSearcher;
-
-/**
- * Holds all implementations of classes in the o.a.l.s.spans package as a
- * back-compatibility test. It does not run any tests per-se, however if
- * someone adds a method to an interface or abstract method to an abstract
- * class, one of the implementations here will fail to compile and so we know
- * back-compat policy was violated.
- */
-final class JustCompileSearchSpans {
-
-  private static final String UNSUPPORTED_MSG = "unsupported: used for back-compat testing only !";
-
-  static final class JustCompileSpans extends Spans {
-
-    @Override
-    public int docID() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public int nextDoc() throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public int advance(int target) throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-    
-    @Override
-    public int startPosition() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public int endPosition() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public int width() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public void collect(SpanCollector collector) throws IOException {
-
-    }
-
-    @Override
-    public int nextStartPosition() throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public long cost() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public float positionsCost() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-  }
-
-  static final class JustCompileSpanQuery extends SpanQuery {
-
-    @Override
-    public String getField() {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-
-    @Override
-    public String toString(String field) {
-      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
-    }
-    
-  }
-
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestBasics.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestBasics.java
deleted file mode 100644
index b18a38d..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestBasics.java
+++ /dev/null
@@ -1,406 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-
-import org.apache.lucene.analysis.*;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.CheckHits;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.PhraseQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.English;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.TestUtil;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-
-import static org.apache.lucene.search.spans.SpanTestUtil.*;
-
-/**
- * Tests basic search capabilities.
- *
- * <p>Uses a collection of 1000 documents, each the english rendition of their
- * document number.  For example, the document numbered 333 has text "three
- * hundred thirty three".
- *
- * <p>Tests are each a single query, and its hits are checked to ensure that
- * all and only the correct documents are returned, thus providing end-to-end
- * testing of the indexing and search code.
- *
- */
-public class TestBasics extends LuceneTestCase {
-  private static IndexSearcher searcher;
-  private static IndexReader reader;
-  private static Directory directory;
-
-  @BeforeClass
-  public static void beforeClass() throws Exception {
-    directory = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
-        newIndexWriterConfig(new MockAnalyzer(random(), MockTokenizer.SIMPLE, true))
-            .setMaxBufferedDocs(TestUtil.nextInt(random(), 100, 1000)).setMergePolicy(newLogMergePolicy()));
-    //writer.infoStream = System.out;
-    for (int i = 0; i < 2000; i++) {
-      Document doc = new Document();
-      doc.add(newTextField("field", English.intToEnglish(i), Field.Store.YES));
-      writer.addDocument(doc);
-    }
-    reader = writer.getReader();
-    searcher = newSearcher(reader);
-    writer.close();
-  }
-
-  @AfterClass
-  public static void afterClass() throws Exception {
-    reader.close();
-    directory.close();
-    searcher = null;
-    reader = null;
-    directory = null;
-  }
-
-  public void testTerm() throws Exception {
-    Query query = new TermQuery(new Term("field", "seventy"));
-    checkHits(query, new int[]
-      {70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 170, 171, 172, 173, 174, 175,
-              176, 177, 178, 179, 270, 271, 272, 273, 274, 275, 276, 277, 278,
-              279, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 470, 471,
-              472, 473, 474, 475, 476, 477, 478, 479, 570, 571, 572, 573, 574,
-              575, 576, 577, 578, 579, 670, 671, 672, 673, 674, 675, 676, 677,
-              678, 679, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 870,
-              871, 872, 873, 874, 875, 876, 877, 878, 879, 970, 971, 972, 973,
-              974, 975, 976, 977, 978, 979, 1070, 1071, 1072, 1073, 1074, 1075,
-              1076, 1077, 1078, 1079, 1170, 1171, 1172, 1173, 1174, 1175, 1176,
-              1177, 1178, 1179, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277,
-              1278, 1279, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378,
-              1379, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479,
-              1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1670,
-              1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1770, 1771,
-              1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1870, 1871, 1872,
-              1873, 1874, 1875, 1876, 1877,
-              1878, 1879, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978,
-              1979});
-    }
-
-  public void testTerm2() throws Exception {
-    Query query = new TermQuery(new Term("field", "seventish"));
-    checkHits(query, new int[] {});
-  }
-
-  public void testPhrase() throws Exception {
-    PhraseQuery query = new PhraseQuery("field", "seventy", "seven");
-    checkHits(query, new int[]
-      {77, 177, 277, 377, 477, 577, 677, 777, 877,
-              977, 1077, 1177, 1277, 1377, 1477, 1577, 1677, 1777, 1877, 1977});
-  }
-
-  public void testPhrase2() throws Exception {
-    PhraseQuery query = new PhraseQuery("field", "seventish", "sevenon");
-    checkHits(query, new int[] {});
-  }
-
-  public void testBoolean() throws Exception {
-    BooleanQuery.Builder query = new BooleanQuery.Builder();
-    query.add(new TermQuery(new Term("field", "seventy")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term("field", "seven")), BooleanClause.Occur.MUST);
-    checkHits(query.build(), new int[]
-      {77, 177, 277, 377, 477, 577, 677, 770, 771, 772, 773, 774, 775, 776, 777,
-              778, 779, 877, 977, 1077, 1177, 1277, 1377, 1477, 1577, 1677,
-              1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1877,
-              1977});
-  }
-
-  public void testBoolean2() throws Exception {
-    BooleanQuery.Builder query = new BooleanQuery.Builder();
-    query.add(new TermQuery(new Term("field", "sevento")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term("field", "sevenly")), BooleanClause.Occur.MUST);
-    checkHits(query.build(), new int[] {});
-  }
-
-  public void testSpanNearExact() throws Exception {
-    SpanQuery query = spanNearOrderedQuery("field", 0, "seventy", "seven");
-    
-    checkHits(query, new int[]
-      {77, 177, 277, 377, 477, 577, 677, 777, 877, 977, 1077, 1177, 1277, 1377, 1477, 1577, 1677, 1777, 1877, 1977});
-
-    assertTrue(searcher.explain(query, 77).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 977).getValue() > 0.0f);
-  }
-  
-  public void testSpanTermQuery() throws Exception {
-    checkHits(spanTermQuery("field", "seventy"), 
-              new int[] { 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 170,
-        171, 172, 173, 174, 175, 176, 177, 178, 179, 270, 271, 272, 273, 274,
-        275, 276, 277, 278, 279, 370, 371, 372, 373, 374, 375, 376, 377, 378,
-        379, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 570, 571, 572,
-        573, 574, 575, 576, 577, 578, 579, 670, 671, 672, 673, 674, 675, 676,
-        677, 678, 679, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 870,
-        871, 872, 873, 874, 875, 876, 877, 878, 879, 970, 971, 972, 973, 974,
-        975, 976, 977, 978, 979, 1070, 1071, 1072, 1073, 1074, 1075, 1076,
-        1077, 1078, 1079, 1170, 1270, 1370, 1470, 1570, 1670, 1770, 1870, 1970,
-        1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1271, 1272, 1273,
-        1274, 1275, 1276, 1277, 1278, 1279, 1371, 1372, 1373, 1374, 1375, 1376,
-        1377, 1378, 1379, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479,
-        1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1671, 1672, 1673,
-        1674, 1675, 1676, 1677, 1678, 1679, 1771, 1772, 1773, 1774, 1775, 1776,
-        1777, 1778, 1779, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879,
-        1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979 });
-  }
-
-  public void testSpanNearUnordered() throws Exception {
-    checkHits(spanNearUnorderedQuery("field", 4, "nine", "six"), 
-              new int[] { 609, 629, 639, 649, 659, 669, 679, 689, 699, 906, 926, 936, 946, 956,
-              966, 976, 986, 996, 1609, 1629, 1639, 1649, 1659, 1669,
-              1679, 1689, 1699, 1906, 1926, 1936, 1946, 1956, 1966, 1976, 1986,
-              1996});
-  }
-
-  public void testSpanNearOrdered() throws Exception {
-    checkHits(spanNearOrderedQuery("field", 4, "nine", "six"), 
-              new int[] { 906, 926, 936, 946, 956, 966, 976, 986, 996, 1906, 1926, 
-                          1936, 1946, 1956, 1966, 1976, 1986, 1996});
-  }
-
-  public void testSpanNot() throws Exception {
-    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
-    SpanQuery query = spanNotQuery(near, spanTermQuery("field", "forty"));
-
-    checkHits(query, new int[]
-      {801, 821, 831, 851, 861, 871, 881, 891, 1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
-
-    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
-  }
-  
-  public void testSpanWithMultipleNotSingle() throws Exception {
-    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
-    SpanQuery or = spanOrQuery("field", "forty");
-    SpanQuery query = spanNotQuery(near, or);
-
-    checkHits(query, new int[]
-      {801, 821, 831, 851, 861, 871, 881, 891,
-              1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
-
-    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
-  }
-
-  public void testSpanWithMultipleNotMany() throws Exception {
-    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
-    SpanQuery or = spanOrQuery("field", "forty", "sixty", "eighty");
-    SpanQuery query = spanNotQuery(near, or);
-
-    checkHits(query, new int[]
-      {801, 821, 831, 851, 871, 891, 1801, 1821, 1831, 1851, 1871, 1891});
-
-    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
-  }
-
-  public void testNpeInSpanNearWithSpanNot() throws Exception {
-    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
-    SpanQuery exclude = spanNearOrderedQuery("field", 1, "hundred", "forty");
-    SpanQuery query = spanNotQuery(near, exclude);
-
-    checkHits(query, new int[]
-      {801, 821, 831, 851, 861, 871, 881, 891,
-              1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
-
-    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
-  }
-
-  public void testNpeInSpanNearInSpanFirstInSpanNot() throws Exception {
-    final int n = 5;
-    SpanQuery include = spanFirstQuery(spanTermQuery("field", "forty"), n);
-    SpanQuery near = spanNearOrderedQuery("field", n-1, "hundred", "forty");
-    SpanQuery exclude = spanFirstQuery(near, n-1);
-    SpanQuery q = spanNotQuery(include, exclude);
-    
-    checkHits(q, new int[]{40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048,
-            1049, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1240, 1241, 1242, 1243, 1244,
-            1245, 1246, 1247, 1248, 1249, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1440, 1441, 1442,
-            1443, 1444, 1445, 1446, 1447, 1448, 1449, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1640,
-            1641, 1642, 1643, 1644, 1645, 1646, 1647,
-            1648, 1649, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1840, 1841, 1842, 1843, 1844, 1845, 1846,
-            1847, 1848, 1849, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949});
-  }
-  
-  public void testSpanNotWindowOne() throws Exception {
-    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "forty");
-    SpanQuery query = spanNotQuery(near, spanTermQuery("field", "one"), 1, 1);
-
-    checkHits(query, new int[]
-      {840, 842, 843, 844, 845, 846, 847, 848, 849,
-          1840, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849});
-
-    assertTrue(searcher.explain(query, 840).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 1842).getValue() > 0.0f);
-  }
-  
-  public void testSpanNotWindowTwoBefore() throws Exception {
-    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "forty");
-    SpanQuery query = spanNotQuery(near, spanTermQuery("field", "one"), 2, 0);
-
-    checkHits(query, new int[]
-      {840, 841, 842, 843, 844, 845, 846, 847, 848, 849});
-
-    assertTrue(searcher.explain(query, 840).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 849).getValue() > 0.0f);
-  }
-
-  public void testSpanNotWindowNeg() throws Exception {
-    //test handling of invalid window < 0
-    SpanQuery near = spanNearOrderedQuery("field", 4, "eight", "one");
-    SpanQuery or = spanOrQuery("field", "forty");
-    SpanQuery query = spanNotQuery(near, or);
-
-    checkHits(query, new int[]
-       {801, 821, 831, 851, 861, 871, 881, 891,
-               1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
-
-    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
-  }
-  
-  public void testSpanNotWindowDoubleExcludesBefore() throws Exception {
-    //test hitting two excludes before an include
-    SpanQuery near = spanNearOrderedQuery("field", 2, "forty", "two");
-    SpanQuery exclude = spanTermQuery("field", "one");
-    SpanQuery query = spanNotQuery(near, exclude, 4, 1);
-
-    checkHits(query, new int[]
-       {42, 242, 342, 442, 542, 642, 742, 842, 942});
-
-    assertTrue(searcher.explain(query, 242).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 942).getValue() > 0.0f);
-  }
-  
-  public void testSpanFirst() throws Exception {
-    SpanQuery query = spanFirstQuery(spanTermQuery("field", "five"), 1);
-
-    checkHits(query, new int[]
-      {5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513,
-       514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527,
-       528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541,
-       542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555,
-       556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569,
-       570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583,
-       584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597,
-       598, 599});
-
-    assertTrue(searcher.explain(query, 5).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 599).getValue() > 0.0f);
-
-  }
-
-  public void testSpanPositionRange() throws Exception {
-    SpanQuery term1 = spanTermQuery("field", "five");
-    SpanQuery query = spanPositionRangeQuery(term1, 1, 2);
-    
-    checkHits(query, new int[]
-      {25,35, 45, 55, 65, 75, 85, 95});
-    assertTrue(searcher.explain(query, 25).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 95).getValue() > 0.0f);
-
-    query = spanPositionRangeQuery(term1, 0, 1);
-    checkHits(query, new int[]
-      {5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512,
-              513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525,
-              526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538,
-              539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551,
-              552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564,
-              565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577,
-              578, 579, 580, 581, 582, 583, 584,
-              585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597,
-              598, 599});
-
-    query = spanPositionRangeQuery(term1, 6, 7);
-    checkHits(query, new int[]{});
-  }
-
-  public void testSpanOr() throws Exception {
-    SpanQuery near1 = spanNearOrderedQuery("field", 0, "thirty", "three");
-    SpanQuery near2 = spanNearOrderedQuery("field", 0, "forty", "seven");
-    SpanQuery query = spanOrQuery(near1, near2);
-
-    checkHits(query, new int[]
-      {33, 47, 133, 147, 233, 247, 333, 347, 433, 447, 533, 547, 633, 647, 733,
-              747, 833, 847, 933, 947, 1033, 1047, 1133, 1147, 1233, 1247, 1333,
-              1347, 1433, 1447, 1533, 1547, 1633, 1647, 1733, 1747, 1833, 1847, 1933, 1947});
-
-    assertTrue(searcher.explain(query, 33).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 947).getValue() > 0.0f);
-  }
-
-  public void testSpanExactNested() throws Exception {
-    SpanQuery near1 = spanNearOrderedQuery("field", 0, "three", "hundred");
-    SpanQuery near2 = spanNearOrderedQuery("field", 0, "thirty", "three");
-    SpanQuery query = spanNearOrderedQuery(0, near1, near2);
-    
-    checkHits(query, new int[] {333, 1333});
-
-    assertTrue(searcher.explain(query, 333).getValue() > 0.0f);
-  }
-
-  public void testSpanNearOr() throws Exception {
-    SpanQuery to1 = spanOrQuery("field", "six", "seven");
-    SpanQuery to2 = spanOrQuery("field", "seven", "six");
-    SpanQuery query = spanNearOrderedQuery(10, to1, to2);
-    
-    checkHits(query, new int[]
-      {606, 607, 626, 627, 636, 637, 646, 647, 656, 657, 666, 667, 676, 677,
-              686, 687, 696, 697, 706, 707, 726, 727, 736, 737, 746, 747, 756,
-              757, 766, 767, 776, 777, 786, 787, 796, 797, 1606, 1607, 1626,
-              1627, 1636, 1637, 1646, 1647, 1656, 1657, 1666, 1667, 1676, 1677,
-              1686, 1687, 1696, 1697, 1706, 1707, 1726, 1727, 1736, 1737,
-              1746, 1747, 1756, 1757, 1766, 1767, 1776, 1777, 1786, 1787, 1796,
-              1797});
-  }
-
-  public void testSpanComplex1() throws Exception {
-    SpanQuery tt1 = spanNearOrderedQuery("field", 0, "six", "hundred");
-    SpanQuery tt2 = spanNearOrderedQuery("field", 0, "seven", "hundred");
-
-    SpanQuery to1 = spanOrQuery(tt1, tt2);
-    SpanQuery to2 = spanOrQuery("field", "seven", "six");
-    SpanQuery query = spanNearOrderedQuery(100, to1, to2);
-    
-    checkHits(query, new int[]
-      {606, 607, 626, 627, 636, 637, 646, 647, 656, 657, 666, 667, 676, 677, 686, 687, 696,
-              697, 706, 707, 726, 727, 736, 737, 746, 747, 756, 757,
-              766, 767, 776, 777, 786, 787, 796, 797, 1606, 1607, 1626, 1627, 1636, 1637, 1646,
-              1647, 1656, 1657,
-              1666, 1667, 1676, 1677, 1686, 1687, 1696, 1697, 1706, 1707, 1726, 1727, 1736, 1737,
-              1746, 1747, 1756, 1757, 1766, 1767, 1776, 1777, 1786, 1787, 1796, 1797});
-  }
-  
-  private void checkHits(Query query, int[] results) throws IOException {
-    CheckHits.checkHits(random(), query, "field", searcher, results);
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java
deleted file mode 100644
index b4435e7..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java
+++ /dev/null
@@ -1,316 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.CheckHits;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.QueryUtils;
-import org.apache.lucene.search.similarities.TFIDFSimilarity;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-
-import java.util.HashSet;
-import java.util.Set;
-
-import static org.apache.lucene.search.spans.SpanTestUtil.assertFinished;
-import static org.apache.lucene.search.spans.SpanTestUtil.assertNext;
-
-public class TestFieldMaskingSpanQuery extends LuceneTestCase {
-
-  protected static Document doc(Field[] fields) {
-    Document doc = new Document();
-    for (int i = 0; i < fields.length; i++) {
-      doc.add(fields[i]);
-    }
-    return doc;
-  }
-  
-  protected static Field field(String name, String value) {
-    return newTextField(name, value, Field.Store.NO);
-  }
-
-  protected static IndexSearcher searcher;
-  protected static Directory directory;
-  protected static IndexReader reader;
-  
-  @BeforeClass
-  public static void beforeClass() throws Exception {
-    directory = newDirectory();
-    RandomIndexWriter writer= new RandomIndexWriter(random(), directory, newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
-    
-    writer.addDocument(doc(new Field[] { field("id", "0")
-                                         ,
-                                         field("gender", "male"),
-                                         field("first",  "james"),
-                                         field("last",   "jones")     }));
-                                               
-    writer.addDocument(doc(new Field[] { field("id", "1")
-                                         ,
-                                         field("gender", "male"),
-                                         field("first",  "james"),
-                                         field("last",   "smith")
-                                         ,
-                                         field("gender", "female"),
-                                         field("first",  "sally"),
-                                         field("last",   "jones")     }));
-    
-    writer.addDocument(doc(new Field[] { field("id", "2")
-                                         ,
-                                         field("gender", "female"),
-                                         field("first",  "greta"),
-                                         field("last",   "jones")
-                                         ,
-                                         field("gender", "female"),
-                                         field("first",  "sally"),
-                                         field("last",   "smith")
-                                         ,
-                                         field("gender", "male"),
-                                         field("first",  "james"),
-                                         field("last",   "jones")     }));
-     
-    writer.addDocument(doc(new Field[] { field("id", "3")
-                                         ,
-                                         field("gender", "female"),
-                                         field("first",  "lisa"),
-                                         field("last",   "jones")
-                                         ,
-                                         field("gender", "male"),
-                                         field("first",  "bob"),
-                                         field("last",   "costas")     }));
-    
-    writer.addDocument(doc(new Field[] { field("id", "4")
-                                         ,
-                                         field("gender", "female"),
-                                         field("first",  "sally"),
-                                         field("last",   "smith")
-                                         ,
-                                         field("gender", "female"),
-                                         field("first",  "linda"),
-                                         field("last",   "dixit")
-                                         ,
-                                         field("gender", "male"),
-                                         field("first",  "bubba"),
-                                         field("last",   "jones")     }));
-    reader = writer.getReader();
-    writer.forceMerge(1);
-    writer.close();
-    searcher = new IndexSearcher(getOnlyLeafReader(reader));
-  }
-
-  @AfterClass
-  public static void afterClass() throws Exception {
-    searcher = null;
-    reader.close();
-    reader = null;
-    directory.close();
-    directory = null;
-  }
-
-  protected void check(SpanQuery q, int[] docs) throws Exception {
-    CheckHits.checkHitCollector(random(), q, null, searcher, docs);
-  }
-
-  public void testRewrite0() throws Exception {
-    SpanQuery q = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "sally")) , "first");
-    SpanQuery qr = (SpanQuery) searcher.rewrite(q);
-
-    QueryUtils.checkEqual(q, qr);
-
-    Set<Term> terms = new HashSet<>();
-    qr.createWeight(searcher, false).extractTerms(terms);
-    assertEquals(1, terms.size());
-  }
-  
-  public void testRewrite1() throws Exception {
-    // mask an anon SpanQuery class that rewrites to something else.
-    SpanQuery q = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "sally")) {
-          @Override
-          public Query rewrite(IndexReader reader) {
-            return new SpanOrQuery(new SpanTermQuery(new Term("first", "sally")),
-                new SpanTermQuery(new Term("first", "james")));
-          }
-        }, "first");
-
-    SpanQuery qr = (SpanQuery) searcher.rewrite(q);
-
-    QueryUtils.checkUnequal(q, qr);
-
-    Set<Term> terms = new HashSet<>();
-    qr.createWeight(searcher, false).extractTerms(terms);
-    assertEquals(2, terms.size());
-  }
-  
-  public void testRewrite2() throws Exception {
-    SpanQuery q1 = new SpanTermQuery(new Term("last", "smith"));
-    SpanQuery q2 = new SpanTermQuery(new Term("last", "jones"));
-    SpanQuery q = new SpanNearQuery(new SpanQuery[]
-      { q1, new FieldMaskingSpanQuery(q2, "last")}, 1, true );
-    Query qr = searcher.rewrite(q);
-
-    QueryUtils.checkEqual(q, qr);
-
-    HashSet<Term> set = new HashSet<>();
-    qr.createWeight(searcher, true).extractTerms(set);
-    assertEquals(2, set.size());
-  }
-  
-  public void testEquality1() {
-    SpanQuery q1 = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "sally")) , "first");
-    SpanQuery q2 = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "sally")) , "first");
-    SpanQuery q3 = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "sally")) , "XXXXX");
-    SpanQuery q4 = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "XXXXX")) , "first");
-    SpanQuery q5 = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("xXXX", "sally")) , "first");
-    QueryUtils.checkEqual(q1, q2);
-    QueryUtils.checkUnequal(q1, q3);
-    QueryUtils.checkUnequal(q1, q4);
-    QueryUtils.checkUnequal(q1, q5);
-  }
-  
-  public void testNoop0() throws Exception {
-    SpanQuery q1 = new SpanTermQuery(new Term("last", "sally"));
-    SpanQuery q = new FieldMaskingSpanQuery(q1, "first");
-    check(q, new int[] { /* :EMPTY: */ });
-  }
-  public void testNoop1() throws Exception {
-    SpanQuery q1 = new SpanTermQuery(new Term("last", "smith"));
-    SpanQuery q2 = new SpanTermQuery(new Term("last", "jones"));
-    SpanQuery q = new SpanNearQuery(new SpanQuery[]
-      { q1, new FieldMaskingSpanQuery(q2, "last")}, 0, true );
-    check(q, new int[] { 1, 2 });
-    q = new SpanNearQuery(new SpanQuery[]
-      { new FieldMaskingSpanQuery(q1, "last"),
-        new FieldMaskingSpanQuery(q2, "last")}, 0, true );
-    check(q, new int[] { 1, 2 });
-  }
-  
-  public void testSimple1() throws Exception {
-    SpanQuery q1 = new SpanTermQuery(new Term("first", "james"));
-    SpanQuery q2 = new SpanTermQuery(new Term("last", "jones"));
-    SpanQuery q = new SpanNearQuery(new SpanQuery[]
-      { q1, new FieldMaskingSpanQuery(q2, "first")}, -1, false );
-    check(q, new int[] { 0, 2 });
-    q = new SpanNearQuery(new SpanQuery[]
-      { new FieldMaskingSpanQuery(q2, "first"), q1}, -1, false );
-    check(q, new int[] { 0, 2 });
-    q = new SpanNearQuery(new SpanQuery[]
-      { q2, new FieldMaskingSpanQuery(q1, "last")}, -1, false );
-    check(q, new int[] { 0, 2 });
-    q = new SpanNearQuery(new SpanQuery[]
-      { new FieldMaskingSpanQuery(q1, "last"), q2}, -1, false );
-    check(q, new int[] { 0, 2 });
-
-  }
-  
-  public void testSimple2() throws Exception {
-    assumeTrue("Broken scoring: LUCENE-3723", 
-        searcher.getSimilarity(true) instanceof TFIDFSimilarity);
-    SpanQuery q1 = new SpanTermQuery(new Term("gender", "female"));
-    SpanQuery q2 = new SpanTermQuery(new Term("last", "smith"));
-    SpanQuery q = new SpanNearQuery(new SpanQuery[]
-      { q1, new FieldMaskingSpanQuery(q2, "gender")}, -1, false );
-    check(q, new int[] { 2, 4 });
-    q = new SpanNearQuery(new SpanQuery[]
-      { new FieldMaskingSpanQuery(q1, "id"),
-        new FieldMaskingSpanQuery(q2, "id") }, -1, false );
-    check(q, new int[] { 2, 4 });
-  }
-
-  public void testSpans0() throws Exception {
-    SpanQuery q1 = new SpanTermQuery(new Term("gender", "female"));
-    SpanQuery q2 = new SpanTermQuery(new Term("first",  "james"));
-    SpanQuery q  = new SpanOrQuery(q1, new FieldMaskingSpanQuery(q2, "gender"));
-    check(q, new int[] { 0, 1, 2, 3, 4 });
-
-    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertNext(span, 0,0,1);
-    assertNext(span, 1,0,1);
-    assertNext(span, 1,1,2);
-    assertNext(span, 2,0,1);
-    assertNext(span, 2,1,2);
-    assertNext(span, 2,2,3);
-    assertNext(span, 3,0,1);
-    assertNext(span, 4,0,1);
-    assertNext(span, 4,1,2);
-    assertFinished(span);
-  }
-  
-  public void testSpans1() throws Exception {
-    SpanQuery q1 = new SpanTermQuery(new Term("first", "sally"));
-    SpanQuery q2 = new SpanTermQuery(new Term("first", "james"));
-    SpanQuery qA = new SpanOrQuery(q1, q2);
-    SpanQuery qB = new FieldMaskingSpanQuery(qA, "id");
-                                            
-    check(qA, new int[] { 0, 1, 2, 4 });
-    check(qB, new int[] { 0, 1, 2, 4 });
-  
-    Spans spanA = qA.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    Spans spanB = qB.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    
-    while (spanA.nextDoc() != Spans.NO_MORE_DOCS) {
-      assertNotSame("spanB not still going", Spans.NO_MORE_DOCS, spanB.nextDoc());
-      while (spanA.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-        assertEquals("spanB start position", spanA.startPosition(), spanB.nextStartPosition());
-        assertEquals("spanB end position", spanA.endPosition(), spanB.endPosition());
-      }
-      assertEquals("spanB start position", Spans.NO_MORE_POSITIONS, spanB.nextStartPosition());
-    }
-    assertEquals("spanB end doc", Spans.NO_MORE_DOCS, spanB.nextDoc());
-  }
-  
-  public void testSpans2() throws Exception {
-    assumeTrue("Broken scoring: LUCENE-3723",
-        searcher.getSimilarity(true) instanceof TFIDFSimilarity);
-    SpanQuery qA1 = new SpanTermQuery(new Term("gender", "female"));
-    SpanQuery qA2 = new SpanTermQuery(new Term("first",  "james"));
-    SpanQuery qA  = new SpanOrQuery(qA1, new FieldMaskingSpanQuery(qA2, "gender"));
-    SpanQuery qB  = new SpanTermQuery(new Term("last",   "jones"));
-    SpanQuery q   = new SpanNearQuery(new SpanQuery[]
-      { new FieldMaskingSpanQuery(qA, "id"),
-        new FieldMaskingSpanQuery(qB, "id") }, -1, false );
-    check(q, new int[] { 0, 1, 2, 3 });
-
-    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertNext(span, 0,0,1);
-    assertNext(span, 1,1,2);
-    assertNext(span, 2,0,1);
-    assertNext(span, 2,2,3);
-    assertNext(span, 3,0,1);
-    assertFinished(span);
-  }
-  
-  public String s(int doc, int start, int end) {
-    return "s(" + doc + "," + start + "," + end +")";
-  }
-  
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestFilterSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestFilterSpans.java
deleted file mode 100644
index 2ec87ce..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestFilterSpans.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-import java.lang.reflect.Method;
-
-import org.apache.lucene.util.LuceneTestCase;
-import org.junit.Test;
-
-public class TestFilterSpans extends LuceneTestCase {
-
-  @Test
-  public void testOverrides() throws Exception {
-    // verify that all methods of Spans are overridden by FilterSpans,
-    for (Method m : FilterSpans.class.getMethods()) {
-      if (m.getDeclaringClass() == Spans.class) {
-        fail("method " + m.getName() + " not overridden!");
-      }
-    }
-  }
-  
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
deleted file mode 100644
index f297f33..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
+++ /dev/null
@@ -1,305 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReaderContext;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.CheckHits;
-import org.apache.lucene.search.Explanation;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Scorer;
-import org.apache.lucene.search.Weight;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-
-import static org.apache.lucene.search.spans.SpanTestUtil.assertFinished;
-import static org.apache.lucene.search.spans.SpanTestUtil.assertNext;
-
-public class TestNearSpansOrdered extends LuceneTestCase {
-  protected IndexSearcher searcher;
-  protected Directory directory;
-  protected IndexReader reader;
-
-  public static final String FIELD = "field";
-
-  @Override
-  public void tearDown() throws Exception {
-    reader.close();
-    directory.close();
-    super.tearDown();
-  }
-  
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    directory = newDirectory();
-    RandomIndexWriter writer= new RandomIndexWriter(random(), directory, newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
-    for (int i = 0; i < docFields.length; i++) {
-      Document doc = new Document();
-      doc.add(newTextField(FIELD, docFields[i], Field.Store.NO));
-      writer.addDocument(doc);
-    }
-    writer.forceMerge(1);
-    reader = writer.getReader();
-    writer.close();
-    searcher = newSearcher(getOnlyLeafReader(reader));
-  }
-
-  protected String[] docFields = {
-    "w1 w2 w3 w4 w5",
-    "w1 w3 w2 w3 zz",
-    "w1 xx w2 yy w3",
-    "w1 w3 xx w2 yy w3 zz",
-    "t1 t2 t2 t1",
-    "g x x g g x x x g g x x g"
-  };
-
-  protected SpanNearQuery makeQuery(String s1, String s2, String s3,
-                                    int slop, boolean inOrder) {
-    return new SpanNearQuery
-      (new SpanQuery[] {
-        new SpanTermQuery(new Term(FIELD, s1)),
-        new SpanTermQuery(new Term(FIELD, s2)),
-        new SpanTermQuery(new Term(FIELD, s3)) },
-       slop,
-       inOrder);
-  }
-  protected SpanNearQuery makeQuery() {
-    return makeQuery("w1","w2","w3",1,true);
-  }
-
-  protected SpanNearQuery makeOverlappedQuery(
-      String sqt1, String sqt2, boolean sqOrdered,
-      String t3, boolean ordered) {
-    return new SpanNearQuery(
-      new SpanQuery[] {
-        new SpanNearQuery(new SpanQuery[] {
-          new SpanTermQuery(new Term(FIELD, sqt1)),
-            new SpanTermQuery(new Term(FIELD, sqt2)) },
-            1,
-            sqOrdered
-          ),
-          new SpanTermQuery(new Term(FIELD, t3)) },
-          0,
-          ordered);
-  }
-  
-  public void testSpanNearQuery() throws Exception {
-    SpanNearQuery q = makeQuery();
-    CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {0,1});
-  }
-
-  public String s(Spans span) {
-    return s(span.docID(), span.startPosition(), span.endPosition());
-  }
-  public String s(int doc, int start, int end) {
-    return "s(" + doc + "," + start + "," + end +")";
-  }
-  
-  public void testNearSpansNext() throws Exception {
-    SpanNearQuery q = makeQuery();
-    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertNext(span,0,0,3);
-    assertNext(span,1,0,4);
-    assertFinished(span);
-  }
-
-  /**
-   * test does not imply that skipTo(doc+1) should work exactly the
-   * same as next -- it's only applicable in this case since we know doc
-   * does not contain more than one span
-   */
-  public void testNearSpansAdvanceLikeNext() throws Exception {
-    SpanNearQuery q = makeQuery();
-    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertEquals(0, span.advance(0));
-    assertEquals(0, span.nextStartPosition());
-    assertEquals(s(0,0,3), s(span));
-    assertEquals(1, span.advance(1));
-    assertEquals(0, span.nextStartPosition());
-    assertEquals(s(1,0,4), s(span));
-    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
-  }
-  
-  public void testNearSpansNextThenAdvance() throws Exception {
-    SpanNearQuery q = makeQuery();
-    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertNotSame(Spans.NO_MORE_DOCS, span.nextDoc());
-    assertEquals(0, span.nextStartPosition());
-    assertEquals(s(0,0,3), s(span));
-    assertNotSame(Spans.NO_MORE_DOCS, span.advance(1));
-    assertEquals(0, span.nextStartPosition());
-    assertEquals(s(1,0,4), s(span));
-    assertEquals(Spans.NO_MORE_DOCS, span.nextDoc());
-  }
-  
-  public void testNearSpansNextThenAdvancePast() throws Exception {
-    SpanNearQuery q = makeQuery();
-    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertNotSame(Spans.NO_MORE_DOCS, span.nextDoc());
-    assertEquals(0, span.nextStartPosition());
-    assertEquals(s(0,0,3), s(span));
-    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
-  }
-  
-  public void testNearSpansAdvancePast() throws Exception {
-    SpanNearQuery q = makeQuery();
-    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
-  }
-  
-  public void testNearSpansAdvanceTo0() throws Exception {
-    SpanNearQuery q = makeQuery();
-    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertEquals(0, span.advance(0));
-    assertEquals(0, span.nextStartPosition());
-    assertEquals(s(0,0,3), s(span));
-  }
-
-  public void testNearSpansAdvanceTo1() throws Exception {
-    SpanNearQuery q = makeQuery();
-    Spans span = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertEquals(1, span.advance(1));
-    assertEquals(0, span.nextStartPosition());
-    assertEquals(s(1,0,4), s(span));
-  }
-
-  /**
-   * not a direct test of NearSpans, but a demonstration of how/when
-   * this causes problems
-   */
-  public void testSpanNearScorerSkipTo1() throws Exception {
-    SpanNearQuery q = makeQuery();
-    Weight w = searcher.createNormalizedWeight(q, true);
-    IndexReaderContext topReaderContext = searcher.getTopReaderContext();
-    LeafReaderContext leave = topReaderContext.leaves().get(0);
-    Scorer s = w.scorer(leave);
-    assertEquals(1, s.iterator().advance(1));
-  }
-
-  public void testOverlappedOrderedSpan() throws Exception {
-    SpanNearQuery q = makeOverlappedQuery("w5", "w3", false, "w4", true);
-    CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {});
-  }
-  
-  public void testOverlappedNonOrderedSpan() throws Exception {
-    SpanNearQuery q = makeOverlappedQuery("w3", "w5", true, "w4", false);
-    CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {0});
-  }
-
-  public void testNonOverlappedOrderedSpan() throws Exception {
-    SpanNearQuery q = makeOverlappedQuery("w3", "w4", true, "w5", true);
-    CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {0});
-  }
-
-  public void testOrderedSpanIteration() throws Exception {
-    SpanNearQuery q = new SpanNearQuery(new SpanQuery[]{
-        new SpanOrQuery(new SpanTermQuery(new Term(FIELD, "w1")), new SpanTermQuery(new Term(FIELD, "w2"))),
-        new SpanTermQuery(new Term(FIELD, "w4"))
-    }, 10, true);
-    Spans spans = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertNext(spans,0,0,4);
-    assertNext(spans,0,1,4);
-    assertFinished(spans);
-  }
-
-  public void testOrderedSpanIterationSameTerms1() throws Exception {
-    SpanNearQuery q = new SpanNearQuery(new SpanQuery[]{
-        new SpanTermQuery(new Term(FIELD, "t1")), new SpanTermQuery(new Term(FIELD, "t2"))
-    }, 1, true);
-    Spans spans = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertNext(spans,4,0,2);
-    assertFinished(spans);
-  }
-
-  public void testOrderedSpanIterationSameTerms2() throws Exception {
-    SpanNearQuery q = new SpanNearQuery(new SpanQuery[]{
-        new SpanTermQuery(new Term(FIELD, "t2")), new SpanTermQuery(new Term(FIELD, "t1"))
-    }, 1, true);
-    Spans spans = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertNext(spans,4,1,4);
-    assertNext(spans,4,2,4);
-    assertFinished(spans);
-  }
-
-  /**
-   * not a direct test of NearSpans, but a demonstration of how/when
-   * this causes problems
-   */
-  public void testSpanNearScorerExplain() throws Exception {
-    SpanNearQuery q = makeQuery();
-    Explanation e = searcher.explain(q, 1);
-    assertTrue("Scorer explanation value for doc#1 isn't positive: "
-               + e.toString(),
-               0.0f <= e.getValue());
-  }
-
-  public void testGaps() throws Exception {
-    SpanNearQuery q = SpanNearQuery.newOrderedNearQuery(FIELD)
-        .addClause(new SpanTermQuery(new Term(FIELD, "w1")))
-        .addGap(1)
-        .addClause(new SpanTermQuery(new Term(FIELD, "w2")))
-        .build();
-    Spans spans = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertNext(spans, 1, 0, 3);
-    assertNext(spans, 2, 0, 3);
-    assertFinished(spans);
-
-    q = SpanNearQuery.newOrderedNearQuery(FIELD)
-        .addClause(new SpanTermQuery(new Term(FIELD, "w1")))
-        .addGap(1)
-        .addClause(new SpanTermQuery(new Term(FIELD, "w2")))
-        .addGap(1)
-        .addClause(new SpanTermQuery(new Term(FIELD, "w3")))
-        .setSlop(1)
-        .build();
-    spans = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertNext(spans, 2, 0, 5);
-    assertNext(spans, 3, 0, 6);
-    assertFinished(spans);
-  }
-
-  public void testMultipleGaps() throws Exception {
-    SpanQuery q = SpanNearQuery.newOrderedNearQuery(FIELD)
-        .addClause(new SpanTermQuery(new Term(FIELD, "g")))
-        .addGap(2)
-        .addClause(new SpanTermQuery(new Term(FIELD, "g")))
-        .build();
-    Spans spans = q.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertNext(spans, 5, 0, 4);
-    assertNext(spans, 5, 9, 13);
-    assertFinished(spans);
-  }
-
-  /*
-    protected String[] docFields = {
-    "w1 w2 w3 w4 w5",
-    "w1 w3 w2 w3 zz",
-    "w1 xx w2 yy w3",
-    "w1 w3 xx w2 yy w3 zz",
-    "t1 t2 t2 t1",
-    "g x x g g x x x g g x x g"
-  };
-   */
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanBoostQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanBoostQuery.java
deleted file mode 100644
index e511136..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanBoostQuery.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.util.LuceneTestCase;
-
-
-public class TestSpanBoostQuery extends LuceneTestCase {
-
-  public void testEquals() {
-    final float boost = random().nextFloat() * 3 - 1;
-    SpanTermQuery q = new SpanTermQuery(new Term("foo", "bar"));
-    SpanBoostQuery q1 = new SpanBoostQuery(q, boost);
-    SpanBoostQuery q2 = new SpanBoostQuery(q, boost);
-    assertEquals(q1, q2);
-    assertEquals(q1.getBoost(), q2.getBoost(), 0f);
- 
-    float boost2 = boost;
-    while (boost == boost2) {
-      boost2 = random().nextFloat() * 3 - 1;
-    }
-    SpanBoostQuery q3 = new SpanBoostQuery(q, boost2);
-    assertFalse(q1.equals(q3));
-    assertFalse(q1.hashCode() == q3.hashCode());
-  }
-
-  public void testToString() {
-    assertEquals("(foo:bar)^2.0", new SpanBoostQuery(new SpanTermQuery(new Term("foo", "bar")), 2).toString());
-    SpanOrQuery bq = new SpanOrQuery(
-        new SpanTermQuery(new Term("foo", "bar")),
-        new SpanTermQuery(new Term("foo", "baz")));
-    assertEquals("(spanOr([foo:bar, foo:baz]))^2.0", new SpanBoostQuery(bq, 2).toString());
-  }
-
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java
deleted file mode 100644
index 7b90b2b..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanCollection.java
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.TextField;
-import org.apache.lucene.index.IndexOptions;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.NoMergePolicy;
-import org.apache.lucene.index.PostingsEnum;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-import org.junit.Test;
-
-import java.io.IOException;
-import java.util.HashSet;
-import java.util.Set;
-
-public class TestSpanCollection extends LuceneTestCase {
-
-  protected IndexSearcher searcher;
-  protected Directory directory;
-  protected IndexReader reader;
-
-  public static final String FIELD = "field";
-
-  public static FieldType OFFSETS = new FieldType(TextField.TYPE_STORED);
-  static {
-    OFFSETS.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);
-  }
-
-  @Override
-  public void tearDown() throws Exception {
-    reader.close();
-    directory.close();
-    super.tearDown();
-  }
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    directory = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
-        newIndexWriterConfig(new MockAnalyzer(random())));
-    for (int i = 0; i < docFields.length; i++) {
-      Document doc = new Document();
-      doc.add(newField(FIELD, docFields[i], OFFSETS));
-      writer.addDocument(doc);
-    }
-    writer.forceMerge(1);
-    reader = writer.getReader();
-    writer.close();
-    searcher = newSearcher(getOnlyLeafReader(reader));
-  }
-
-  private static class TermCollector implements SpanCollector {
-
-    final Set<Term> terms = new HashSet<>();
-
-    @Override
-    public void collectLeaf(PostingsEnum postings, int position, Term term) throws IOException {
-      terms.add(term);
-    }
-
-    @Override
-    public void reset() {
-      terms.clear();
-    }
-
-  }
-
-  protected String[] docFields = {
-      "w1 w2 w3 w4 w5",
-      "w1 w3 w2 w3 zz",
-      "w1 xx w2 yy w4",
-      "w1 w2 w1 w4 w2 w3"
-  };
-
-  private void checkCollectedTerms(Spans spans, TermCollector collector, Term... expectedTerms) throws IOException {
-    collector.reset();
-    spans.collect(collector);
-    for (Term t : expectedTerms) {
-      assertTrue("Missing term " + t, collector.terms.contains(t));
-    }
-    assertEquals("Unexpected terms found", expectedTerms.length, collector.terms.size());
-  }
-
-  @Test
-  public void testNestedNearQuery() throws IOException {
-
-    // near(w1, near(w2, or(w3, w4)))
-
-    SpanTermQuery q1 = new SpanTermQuery(new Term(FIELD, "w1"));
-    SpanTermQuery q2 = new SpanTermQuery(new Term(FIELD, "w2"));
-    SpanTermQuery q3 = new SpanTermQuery(new Term(FIELD, "w3"));
-    SpanTermQuery q4 = new SpanTermQuery(new Term(FIELD, "w4"));
-
-    SpanOrQuery q5 = new SpanOrQuery(q4, q3);
-    SpanNearQuery q6 = new SpanNearQuery(new SpanQuery[]{q2, q5}, 1, true);
-    SpanNearQuery q7 = new SpanNearQuery(new SpanQuery[]{q1, q6}, 1, true);
-
-    TermCollector collector = new TermCollector();
-    Spans spans = q7.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertEquals(0, spans.advance(0));
-    spans.nextStartPosition();
-    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"));
-
-    assertEquals(3, spans.advance(3));
-    spans.nextStartPosition();
-    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w4"));
-    spans.nextStartPosition();
-    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"), new Term(FIELD, "w3"));
-
-  }
-
-  @Test
-  public void testOrQuery() throws IOException {
-    SpanTermQuery q2 = new SpanTermQuery(new Term(FIELD, "w2"));
-    SpanTermQuery q3 = new SpanTermQuery(new Term(FIELD, "w3"));
-    SpanOrQuery orQuery = new SpanOrQuery(q2, q3);
-
-    TermCollector collector = new TermCollector();
-    Spans spans = orQuery.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-
-    assertEquals(1, spans.advance(1));
-    spans.nextStartPosition();
-    checkCollectedTerms(spans, collector, new Term(FIELD, "w3"));
-    spans.nextStartPosition();
-    checkCollectedTerms(spans, collector, new Term(FIELD, "w2"));
-    spans.nextStartPosition();
-    checkCollectedTerms(spans, collector, new Term(FIELD, "w3"));
-
-    assertEquals(3, spans.advance(3));
-    spans.nextStartPosition();
-    checkCollectedTerms(spans, collector, new Term(FIELD, "w2"));
-    spans.nextStartPosition();
-    checkCollectedTerms(spans, collector, new Term(FIELD, "w2"));
-    spans.nextStartPosition();
-    checkCollectedTerms(spans, collector, new Term(FIELD, "w3"));
-  }
-
-  @Test
-  public void testSpanNotQuery() throws IOException {
-
-    SpanTermQuery q1 = new SpanTermQuery(new Term(FIELD, "w1"));
-    SpanTermQuery q2 = new SpanTermQuery(new Term(FIELD, "w2"));
-    SpanTermQuery q3 = new SpanTermQuery(new Term(FIELD, "w3"));
-
-    SpanNearQuery nq = new SpanNearQuery(new SpanQuery[]{q1, q2}, 2, true);
-    SpanNotQuery notq = new SpanNotQuery(nq, q3);
-
-    TermCollector collector = new TermCollector();
-    Spans spans = notq.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-
-    assertEquals(2, spans.advance(2));
-    spans.nextStartPosition();
-    checkCollectedTerms(spans, collector, new Term(FIELD, "w1"), new Term(FIELD, "w2"));
-
-  }
-
-}
-
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanContainQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanContainQuery.java
deleted file mode 100644
index 3e50183..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanContainQuery.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.search.CheckHits;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-
-import static org.apache.lucene.search.spans.SpanTestUtil.*;
-
-public class TestSpanContainQuery extends LuceneTestCase {
-  IndexSearcher searcher;
-  IndexReader reader;
-  Directory directory;
-
-  static final String field = "field";
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    directory = newDirectory();
-    RandomIndexWriter writer= new RandomIndexWriter(random(), directory, newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
-    for (int i = 0; i < docFields.length; i++) {
-      Document doc = new Document();
-      doc.add(newTextField(field, docFields[i], Field.Store.YES));
-      writer.addDocument(doc);
-    }
-    writer.forceMerge(1);
-    reader = writer.getReader();
-    writer.close();
-    searcher = newSearcher(getOnlyLeafReader(reader));
-  }
-
-  @Override
-  public void tearDown() throws Exception {
-    reader.close();
-    directory.close();
-    super.tearDown();
-  }
-
-  String[] docFields = {
-    "w1 w2 w3 w4 w5",
-    "w1 w3 w2 w3",
-    "w1 xx w2 yy w3",
-    "w1 w3 xx w2 yy w3",
-  };
-
-  void checkHits(Query query, int[] results) throws Exception {
-    CheckHits.checkHits(random(), query, field, searcher, results);
-  }
-
-  Spans makeSpans(SpanQuery sq) throws Exception {
-    return sq.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-  }
-
-  void tstEqualSpans(String mes, SpanQuery expectedQ, SpanQuery actualQ) throws Exception {
-    Spans expected = makeSpans(expectedQ);
-    Spans actual = makeSpans(actualQ);
-    tstEqualSpans(mes, expected, actual);
-  }
-
-  void tstEqualSpans(String mes, Spans expected, Spans actual) throws Exception {
-    while (expected.nextDoc() != Spans.NO_MORE_DOCS) {
-      assertEquals(expected.docID(), actual.nextDoc());
-      assertEquals(expected.docID(), actual.docID());
-      while (expected.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-        assertEquals(expected.startPosition(), actual.nextStartPosition());
-        assertEquals("start", expected.startPosition(), actual.startPosition());
-        assertEquals("end", expected.endPosition(), actual.endPosition());
-      }
-    }
-  }
-
-  public void testSpanContainTerm() throws Exception {
-    SpanQuery stq = spanTermQuery(field, "w3");
-    SpanQuery containingQ = spanContainingQuery(stq, stq);
-    SpanQuery containedQ = spanWithinQuery(stq, stq);
-    tstEqualSpans("containing", stq, containingQ);
-    tstEqualSpans("containing", stq, containedQ);
-  }
-
-  public void testSpanContainPhraseBothWords() throws Exception {
-    String w2 = "w2";
-    String w3 = "w3";
-    SpanQuery phraseQ = spanNearOrderedQuery(field, 0, w2, w3);
-    SpanQuery w23 = spanOrQuery(field, w2, w3);
-    SpanQuery containingPhraseOr = spanContainingQuery(phraseQ, w23);
-    SpanQuery containedPhraseOr = spanWithinQuery(phraseQ, w23);
-    tstEqualSpans("containing phrase or", phraseQ, containingPhraseOr);
-    Spans spans = makeSpans(containedPhraseOr);
-    assertNext(spans,0,1,2);
-    assertNext(spans,0,2,3);
-    assertNext(spans,1,2,3);
-    assertNext(spans,1,3,4);
-    assertFinished(spans);
-  }
-
-  public void testSpanContainPhraseFirstWord() throws Exception {
-    String w2 = "w2";
-    String w3 = "w3";
-    SpanQuery stqw2 = spanTermQuery(field, w2);
-    SpanQuery phraseQ = spanNearOrderedQuery(field, 0, w2, w3);
-    SpanQuery containingPhraseW2 = spanContainingQuery(phraseQ, stqw2);
-    SpanQuery containedPhraseW2 = spanWithinQuery(phraseQ, stqw2);
-    tstEqualSpans("containing phrase w2", phraseQ, containingPhraseW2);
-    Spans spans = makeSpans(containedPhraseW2);
-    assertNext(spans,0,1,2);
-    assertNext(spans,1,2,3);
-    assertFinished(spans);
-  }
-
-  public void testSpanContainPhraseSecondWord() throws Exception {
-    String w2 = "w2";
-    String w3 = "w3";
-    SpanQuery stqw3 = spanTermQuery(field, w3);
-    SpanQuery phraseQ = spanNearOrderedQuery(field, 0, w2, w3);
-    SpanQuery containingPhraseW3 = spanContainingQuery(phraseQ, stqw3);
-    SpanQuery containedPhraseW3 = spanWithinQuery(phraseQ, stqw3);
-    tstEqualSpans("containing phrase w3", phraseQ, containingPhraseW3);
-    Spans spans = makeSpans(containedPhraseW3);
-    assertNext(spans,0,2,3);
-    assertNext(spans,1,3,4);
-    assertFinished(spans);
-  }
-
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanations.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanations.java
deleted file mode 100644
index b986cd4..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanations.java
+++ /dev/null
@@ -1,168 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import org.apache.lucene.search.*;
-
-/**
- * TestExplanations subclass focusing on span queries
- */
-public class TestSpanExplanations extends BaseExplanationTestCase {
-
-  /* simple SpanTermQueries */
-  
-  public void testST1() throws Exception {
-    SpanQuery q = st("w1");
-    qtest(q, new int[] {0,1,2,3});
-  }
-  public void testST2() throws Exception {
-    SpanQuery q = st("w1");
-    qtest(new BoostQuery(q, 1000), new int[] {0,1,2,3});
-  }
-  public void testST4() throws Exception {
-    SpanQuery q = st("xx");
-    qtest(q, new int[] {2,3});
-  }
-  public void testST5() throws Exception {
-    SpanQuery q = st("xx");
-    qtest(new BoostQuery(q, 1000), new int[] {2,3});
-  }
-
-  /* some SpanFirstQueries */
-  
-  public void testSF1() throws Exception {
-    SpanQuery q = sf(("w1"),1);
-    qtest(q, new int[] {0,1,2,3});
-  }
-  public void testSF2() throws Exception {
-    SpanQuery q = sf(("w1"),1);
-    qtest(new BoostQuery(q, 1000), new int[] {0,1,2,3});
-  }
-  public void testSF4() throws Exception {
-    SpanQuery q = sf(("xx"),2);
-    qtest(q, new int[] {2});
-  }
-  public void testSF5() throws Exception {
-    SpanQuery q = sf(("yy"),2);
-    qtest(q, new int[] { });
-  }
-  public void testSF6() throws Exception {
-    SpanQuery q = sf(("yy"),4);
-    qtest(new BoostQuery(q, 1000), new int[] {2});
-  }
-  
-  /* some SpanOrQueries */
-
-  public void testSO1() throws Exception {
-    SpanQuery q = sor("w1","QQ");
-    qtest(q, new int[] {0,1,2,3});
-  }
-  public void testSO2() throws Exception {
-    SpanQuery q = sor("w1","w3","zz");
-    qtest(q, new int[] {0,1,2,3});
-  }
-  public void testSO3() throws Exception {
-    SpanQuery q = sor("w5","QQ","yy");
-    qtest(q, new int[] {0,2,3});
-  }
-  public void testSO4() throws Exception {
-    SpanQuery q = sor("w5","QQ","yy");
-    qtest(q, new int[] {0,2,3});
-  }
-
-  
-  
-  /* some SpanNearQueries */
-  
-  public void testSNear1() throws Exception {
-    SpanQuery q = snear("w1","QQ",100,true);
-    qtest(q, new int[] {});
-  }
-  public void testSNear2() throws Exception {
-    SpanQuery q = snear("w1","xx",100,true);
-    qtest(q, new int[] {2,3});
-  }
-  public void testSNear3() throws Exception {
-    SpanQuery q = snear("w1","xx",0,true);
-    qtest(q, new int[] {2});
-  }
-  public void testSNear4() throws Exception {
-    SpanQuery q = snear("w1","xx",1,true);
-    qtest(q, new int[] {2,3});
-  }
-  public void testSNear5() throws Exception {
-    SpanQuery q = snear("xx","w1",0,false);
-    qtest(q, new int[] {2});
-  }
-
-  public void testSNear6() throws Exception {
-    SpanQuery q = snear("w1","w2","QQ",100,true);
-    qtest(q, new int[] {});
-  }
-  public void testSNear7() throws Exception {
-    SpanQuery q = snear("w1","xx","w2",100,true);
-    qtest(q, new int[] {2,3});
-  }
-  public void testSNear8() throws Exception {
-    SpanQuery q = snear("w1","xx","w2",0,true);
-    qtest(q, new int[] {2});
-  }
-  public void testSNear9() throws Exception {
-    SpanQuery q = snear("w1","xx","w2",1,true);
-    qtest(q, new int[] {2,3});
-  }
-  public void testSNear10() throws Exception {
-    SpanQuery q = snear("xx","w1","w2",0,false);
-    qtest(q, new int[] {2});
-  }
-  public void testSNear11() throws Exception {
-    SpanQuery q = snear("w1","w2","w3",1,true);
-    qtest(q, new int[] {0,1});
-  }
-
-  
-  /* some SpanNotQueries */
-
-  public void testSNot1() throws Exception {
-    SpanQuery q = snot(sf("w1",10),st("QQ"));
-    qtest(q, new int[] {0,1,2,3});
-  }
-  public void testSNot2() throws Exception {
-    SpanQuery q = snot(sf("w1",10),st("QQ"));
-    qtest(new BoostQuery(q, 1000), new int[] {0,1,2,3});
-  }
-  public void testSNot4() throws Exception {
-    SpanQuery q = snot(sf("w1",10),st("xx"));
-    qtest(q, new int[] {0,1,2,3});
-  }
-  public void testSNot5() throws Exception {
-    SpanQuery q = snot(sf("w1",10),st("xx"));
-    qtest(new BoostQuery(q, 1000), new int[] {0,1,2,3});
-  }
-  public void testSNot7() throws Exception {
-    SpanQuery f = snear("w1","w3",10,true);
-    SpanQuery q = snot(f, st("xx"));
-    qtest(q, new int[] {0,1,3});
-  }
-  public void testSNot10() throws Exception {
-    SpanQuery t = st("xx");
-    SpanQuery q = snot(snear("w1","w3",10,true), t);
-    qtest(q, new int[] {0,1,3});
-  }
-
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanationsOfNonMatches.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanationsOfNonMatches.java
deleted file mode 100644
index eeaf8e7..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanationsOfNonMatches.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.CheckHits;
-
-
-/**
- * subclass of TestSimpleExplanations that verifies non matches.
- */
-public class TestSpanExplanationsOfNonMatches
-  extends TestSpanExplanations {
-
-  /**
-   * Overrides superclass to ignore matches and focus on non-matches
-   *
-   * @see CheckHits#checkNoMatchExplanations
-   */
-  @Override
-  public void qtest(Query q, int[] expDocNrs) throws Exception {
-    CheckHits.checkNoMatchExplanations(q, FIELD, searcher, expDocNrs);
-  }
-    
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java
deleted file mode 100644
index 228ad79..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.analysis.MockTokenizer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.automaton.CharacterRunAutomaton;
-import org.apache.lucene.util.automaton.RegExp;
-
-import static org.apache.lucene.search.spans.SpanTestUtil.*;
-
-public class TestSpanFirstQuery extends LuceneTestCase {
-  public void testStartPositions() throws Exception {
-    Directory dir = newDirectory();
-    
-    // mimic StopAnalyzer
-    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(new RegExp("the|a|of").toAutomaton());
-    Analyzer analyzer = new MockAnalyzer(random(), MockTokenizer.SIMPLE, true, stopSet);
-    
-    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, analyzer);
-    Document doc = new Document();
-    doc.add(newTextField("field", "the quick brown fox", Field.Store.NO));
-    writer.addDocument(doc);
-    Document doc2 = new Document();
-    doc2.add(newTextField("field", "quick brown fox", Field.Store.NO));
-    writer.addDocument(doc2);
-    
-    IndexReader reader = writer.getReader();
-    IndexSearcher searcher = newSearcher(reader);
-    
-    // user queries on "starts-with quick"
-    SpanQuery sfq = spanFirstQuery(spanTermQuery("field", "quick"), 1);
-    assertEquals(1, searcher.search(sfq, 10).totalHits);
-    
-    // user queries on "starts-with the quick"
-    SpanQuery include = spanFirstQuery(spanTermQuery("field", "quick"), 2);
-    sfq = spanNotQuery(include, sfq);
-    assertEquals(1, searcher.search(sfq, 10).totalHits);
-    
-    writer.close();
-    reader.close();
-    dir.close();
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanMultiTermQueryWrapper.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanMultiTermQueryWrapper.java
deleted file mode 100644
index cedd7ff..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanMultiTermQueryWrapper.java
+++ /dev/null
@@ -1,248 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.FuzzyQuery;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.PrefixQuery;
-import org.apache.lucene.search.RegexpQuery;
-import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-import org.junit.Test;
-
-/**
- * Tests for {@link SpanMultiTermQueryWrapper}, wrapping a few MultiTermQueries.
- */
-public class TestSpanMultiTermQueryWrapper extends LuceneTestCase {
-  private Directory directory;
-  private IndexReader reader;
-  private IndexSearcher searcher;
-  
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    directory = newDirectory();
-    RandomIndexWriter iw = new RandomIndexWriter(random(), directory);
-    Document doc = new Document();
-    Field field = newTextField("field", "", Field.Store.NO);
-    doc.add(field);
-    
-    field.setStringValue("quick brown fox");
-    iw.addDocument(doc);
-    field.setStringValue("jumps over lazy broun dog");
-    iw.addDocument(doc);
-    field.setStringValue("jumps over extremely very lazy broxn dog");
-    iw.addDocument(doc);
-    reader = iw.getReader();
-    iw.close();
-    searcher = newSearcher(reader);
-  }
-  
-  @Override
-  public void tearDown() throws Exception {
-    reader.close();
-    directory.close();
-    super.tearDown();
-  }
-  
-  public void testWildcard() throws Exception {
-    WildcardQuery wq = new WildcardQuery(new Term("field", "bro?n"));
-    SpanQuery swq = new SpanMultiTermQueryWrapper<>(wq);
-    // will only match quick brown fox
-    SpanFirstQuery sfq = new SpanFirstQuery(swq, 2);
-    assertEquals(1, searcher.search(sfq, 10).totalHits);
-  }
-  
-  public void testPrefix() throws Exception {
-    WildcardQuery wq = new WildcardQuery(new Term("field", "extrem*"));
-    SpanQuery swq = new SpanMultiTermQueryWrapper<>(wq);
-    // will only match "jumps over extremely very lazy broxn dog"
-    SpanFirstQuery sfq = new SpanFirstQuery(swq, 3);
-    assertEquals(1, searcher.search(sfq, 10).totalHits);
-  }
-  
-  public void testFuzzy() throws Exception {
-    FuzzyQuery fq = new FuzzyQuery(new Term("field", "broan"));
-    SpanQuery sfq = new SpanMultiTermQueryWrapper<>(fq);
-    // will not match quick brown fox
-    SpanPositionRangeQuery sprq = new SpanPositionRangeQuery(sfq, 3, 6);
-    assertEquals(2, searcher.search(sprq, 10).totalHits);
-  }
-  
-  public void testFuzzy2() throws Exception {
-    // maximum of 1 term expansion
-    FuzzyQuery fq = new FuzzyQuery(new Term("field", "broan"), 1, 0, 1, false);
-    SpanQuery sfq = new SpanMultiTermQueryWrapper<>(fq);
-    // will only match jumps over lazy broun dog
-    SpanPositionRangeQuery sprq = new SpanPositionRangeQuery(sfq, 0, 100);
-    assertEquals(1, searcher.search(sprq, 10).totalHits);
-  }
-  public void testNoSuchMultiTermsInNear() throws Exception {
-    //test to make sure non existent multiterms aren't throwing null pointer exceptions  
-    FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
-    SpanQuery spanNoSuch = new SpanMultiTermQueryWrapper<>(fuzzyNoSuch);
-    SpanQuery term = new SpanTermQuery(new Term("field", "brown"));
-    SpanQuery near = new SpanNearQuery(new SpanQuery[]{term, spanNoSuch}, 1, true);
-    assertEquals(0, searcher.search(near, 10).totalHits);
-    //flip order
-    near = new SpanNearQuery(new SpanQuery[]{spanNoSuch, term}, 1, true);
-    assertEquals(0, searcher.search(near, 10).totalHits);
-    
-    WildcardQuery wcNoSuch = new WildcardQuery(new Term("field", "noSuch*"));
-    SpanQuery spanWCNoSuch = new SpanMultiTermQueryWrapper<>(wcNoSuch);
-    near = new SpanNearQuery(new SpanQuery[]{term, spanWCNoSuch}, 1, true);
-    assertEquals(0, searcher.search(near, 10).totalHits);
-  
-    RegexpQuery rgxNoSuch = new RegexpQuery(new Term("field", "noSuch"));
-    SpanQuery spanRgxNoSuch = new SpanMultiTermQueryWrapper<>(rgxNoSuch);
-    near = new SpanNearQuery(new SpanQuery[]{term, spanRgxNoSuch}, 1, true);
-    assertEquals(0, searcher.search(near, 10).totalHits);
-    
-    PrefixQuery prfxNoSuch = new PrefixQuery(new Term("field", "noSuch"));
-    SpanQuery spanPrfxNoSuch = new SpanMultiTermQueryWrapper<>(prfxNoSuch);
-    near = new SpanNearQuery(new SpanQuery[]{term, spanPrfxNoSuch}, 1, true);
-    assertEquals(0, searcher.search(near, 10).totalHits);
-
-    //test single noSuch
-    near = new SpanNearQuery(new SpanQuery[]{spanPrfxNoSuch}, 1, true);
-    assertEquals(0, searcher.search(near, 10).totalHits);
-    
-    //test double noSuch
-    near = new SpanNearQuery(new SpanQuery[]{spanPrfxNoSuch, spanPrfxNoSuch}, 1, true);
-    assertEquals(0, searcher.search(near, 10).totalHits);
-
-  }
-  
-  public void testNoSuchMultiTermsInNotNear() throws Exception {
-    //test to make sure non existent multiterms aren't throwing non-matching field exceptions  
-    FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
-    SpanQuery spanNoSuch = new SpanMultiTermQueryWrapper<>(fuzzyNoSuch);
-    SpanQuery term = new SpanTermQuery(new Term("field", "brown"));
-    SpanNotQuery notNear = new SpanNotQuery(term, spanNoSuch, 0,0);
-    assertEquals(1, searcher.search(notNear, 10).totalHits);
-
-    //flip
-    notNear = new SpanNotQuery(spanNoSuch, term, 0,0);
-    assertEquals(0, searcher.search(notNear, 10).totalHits);
-    
-    //both noSuch
-    notNear = new SpanNotQuery(spanNoSuch, spanNoSuch, 0,0);
-    assertEquals(0, searcher.search(notNear, 10).totalHits);
-
-    WildcardQuery wcNoSuch = new WildcardQuery(new Term("field", "noSuch*"));
-    SpanQuery spanWCNoSuch = new SpanMultiTermQueryWrapper<>(wcNoSuch);
-    notNear = new SpanNotQuery(term, spanWCNoSuch, 0,0);
-    assertEquals(1, searcher.search(notNear, 10).totalHits);
-  
-    RegexpQuery rgxNoSuch = new RegexpQuery(new Term("field", "noSuch"));
-    SpanQuery spanRgxNoSuch = new SpanMultiTermQueryWrapper<>(rgxNoSuch);
-    notNear = new SpanNotQuery(term, spanRgxNoSuch, 1, 1);
-    assertEquals(1, searcher.search(notNear, 10).totalHits);
-    
-    PrefixQuery prfxNoSuch = new PrefixQuery(new Term("field", "noSuch"));
-    SpanQuery spanPrfxNoSuch = new SpanMultiTermQueryWrapper<>(prfxNoSuch);
-    notNear = new SpanNotQuery(term, spanPrfxNoSuch, 1, 1);
-    assertEquals(1, searcher.search(notNear, 10).totalHits);
-    
-  }
-  
-  public void testNoSuchMultiTermsInOr() throws Exception {
-    //test to make sure non existent multiterms aren't throwing null pointer exceptions  
-    FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
-    SpanQuery spanNoSuch = new SpanMultiTermQueryWrapper<>(fuzzyNoSuch);
-    SpanQuery term = new SpanTermQuery(new Term("field", "brown"));
-    SpanOrQuery near = new SpanOrQuery(new SpanQuery[]{term, spanNoSuch});
-    assertEquals(1, searcher.search(near, 10).totalHits);
-    
-    //flip
-    near = new SpanOrQuery(new SpanQuery[]{spanNoSuch, term});
-    assertEquals(1, searcher.search(near, 10).totalHits);
-
-    
-    WildcardQuery wcNoSuch = new WildcardQuery(new Term("field", "noSuch*"));
-    SpanQuery spanWCNoSuch = new SpanMultiTermQueryWrapper<>(wcNoSuch);
-    near = new SpanOrQuery(new SpanQuery[]{term, spanWCNoSuch});
-    assertEquals(1, searcher.search(near, 10).totalHits);
-  
-    RegexpQuery rgxNoSuch = new RegexpQuery(new Term("field", "noSuch"));
-    SpanQuery spanRgxNoSuch = new SpanMultiTermQueryWrapper<>(rgxNoSuch);
-    near = new SpanOrQuery(new SpanQuery[]{term, spanRgxNoSuch});
-    assertEquals(1, searcher.search(near, 10).totalHits);
-    
-    PrefixQuery prfxNoSuch = new PrefixQuery(new Term("field", "noSuch"));
-    SpanQuery spanPrfxNoSuch = new SpanMultiTermQueryWrapper<>(prfxNoSuch);
-    near = new SpanOrQuery(new SpanQuery[]{term, spanPrfxNoSuch});
-    assertEquals(1, searcher.search(near, 10).totalHits);
-    
-    near = new SpanOrQuery(new SpanQuery[]{spanPrfxNoSuch});
-    assertEquals(0, searcher.search(near, 10).totalHits);
-    
-    near = new SpanOrQuery(new SpanQuery[]{spanPrfxNoSuch, spanPrfxNoSuch});
-    assertEquals(0, searcher.search(near, 10).totalHits);
-
-  }
-  
-  
-  public void testNoSuchMultiTermsInSpanFirst() throws Exception {
-    //this hasn't been a problem  
-    FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
-    SpanQuery spanNoSuch = new SpanMultiTermQueryWrapper<>(fuzzyNoSuch);
-    SpanQuery spanFirst = new SpanFirstQuery(spanNoSuch, 10);
- 
-    assertEquals(0, searcher.search(spanFirst, 10).totalHits);
-    
-    WildcardQuery wcNoSuch = new WildcardQuery(new Term("field", "noSuch*"));
-    SpanQuery spanWCNoSuch = new SpanMultiTermQueryWrapper<>(wcNoSuch);
-    spanFirst = new SpanFirstQuery(spanWCNoSuch, 10);
-    assertEquals(0, searcher.search(spanFirst, 10).totalHits);
-  
-    RegexpQuery rgxNoSuch = new RegexpQuery(new Term("field", "noSuch"));
-    SpanQuery spanRgxNoSuch = new SpanMultiTermQueryWrapper<>(rgxNoSuch);
-    spanFirst = new SpanFirstQuery(spanRgxNoSuch, 10);
-    assertEquals(0, searcher.search(spanFirst, 10).totalHits);
-    
-    PrefixQuery prfxNoSuch = new PrefixQuery(new Term("field", "noSuch"));
-    SpanQuery spanPrfxNoSuch = new SpanMultiTermQueryWrapper<>(prfxNoSuch);
-    spanFirst = new SpanFirstQuery(spanPrfxNoSuch, 10);
-    assertEquals(0, searcher.search(spanFirst, 10).totalHits);
-  }
-
-  @Test
-  public void testWrappedQueryIsNotModified() {
-    final PrefixQuery pq = new PrefixQuery(new Term("field", "test"));
-    int pqHash = pq.hashCode();
-    SpanMultiTermQueryWrapper<PrefixQuery> wrapper = new SpanMultiTermQueryWrapper<>(pq);
-    assertEquals(pqHash, pq.hashCode());
-    wrapper.setRewriteMethod(new SpanMultiTermQueryWrapper.SpanRewriteMethod() {
-      @Override
-      public SpanQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException {
-        return null;
-      }
-    });
-    assertEquals(pqHash, pq.hashCode());
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanNearQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanNearQuery.java
deleted file mode 100644
index fbc098c..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanNearQuery.java
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.StringField;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.QueryUtils;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-
-/** Basic tests for SpanNearQuery */
-public class TestSpanNearQuery extends LuceneTestCase {
-  
-  public void testHashcodeEquals() {
-    SpanTermQuery q1 = new SpanTermQuery(new Term("field", "foo"));
-    SpanTermQuery q2 = new SpanTermQuery(new Term("field", "bar"));
-    SpanTermQuery q3 = new SpanTermQuery(new Term("field", "baz"));
-    
-    SpanNearQuery near1 = new SpanNearQuery(new SpanQuery[] { q1, q2 }, 10, true);
-    SpanNearQuery near2 = new SpanNearQuery(new SpanQuery[] { q2, q3 }, 10, true);
-    QueryUtils.check(near1);
-    QueryUtils.check(near2);
-    QueryUtils.checkUnequal(near1, near2);
-  }
-  
-  public void testDifferentField() throws Exception {
-    SpanTermQuery q1 = new SpanTermQuery(new Term("field1", "foo"));
-    SpanTermQuery q2 = new SpanTermQuery(new Term("field2", "bar"));
-    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
-      new SpanNearQuery(new SpanQuery[] { q1, q2 }, 10, true);
-    });
-    assertTrue(expected.getMessage().contains("must have same field"));
-  }
-  
-  public void testNoPositions() throws IOException {
-    Directory dir = newDirectory();
-    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new StringField("foo", "bar", Field.Store.NO));
-    iw.addDocument(doc);
-    
-    IndexReader ir = iw.getReader();
-    iw.close();
-    
-    IndexSearcher is = new IndexSearcher(ir);
-    SpanTermQuery query = new SpanTermQuery(new Term("foo", "bar"));
-    SpanTermQuery query2 = new SpanTermQuery(new Term("foo", "baz"));
-
-    IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {
-      is.search(new SpanNearQuery(new SpanQuery[] { query, query2 }, 10, true), 5);
-    });
-    assertTrue(expected.getMessage().contains("was indexed without position data"));
-
-    ir.close();
-    dir.close();
-  }
-
-  public void testBuilder() throws Exception {
-
-    // Can't add subclauses from different fields
-    expectThrows(IllegalArgumentException.class, () -> {
-      SpanNearQuery.newOrderedNearQuery("field1").addClause(new SpanTermQuery(new Term("field2", "term")));
-    });
-
-    // Can't add gaps to unordered queries
-    expectThrows(IllegalArgumentException.class, () -> {
-      SpanNearQuery.newUnorderedNearQuery("field1").addGap(1);
-    });
-
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanNotQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanNotQuery.java
deleted file mode 100644
index 4ffb270..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanNotQuery.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.StringField;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.QueryUtils;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-
-/** Basic tests for SpanNotQuery */
-public class TestSpanNotQuery extends LuceneTestCase {
-  
-  public void testHashcodeEquals() {
-    SpanTermQuery q1 = new SpanTermQuery(new Term("field", "foo"));
-    SpanTermQuery q2 = new SpanTermQuery(new Term("field", "bar"));
-    SpanTermQuery q3 = new SpanTermQuery(new Term("field", "baz"));
-    
-    SpanNotQuery not1 = new SpanNotQuery(q1, q2);
-    SpanNotQuery not2 = new SpanNotQuery(q2, q3);
-    QueryUtils.check(not1);
-    QueryUtils.check(not2);
-    QueryUtils.checkUnequal(not1, not2);
-  }
-  
-  public void testDifferentField() throws Exception {
-    SpanTermQuery q1 = new SpanTermQuery(new Term("field1", "foo"));
-    SpanTermQuery q2 = new SpanTermQuery(new Term("field2", "bar"));
-    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
-      new SpanNotQuery(q1, q2);
-    });
-    assertTrue(expected.getMessage().contains("must have same field"));
-  }
-  
-  public void testNoPositions() throws IOException {
-    Directory dir = newDirectory();
-    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new StringField("foo", "bar", Field.Store.NO));
-    iw.addDocument(doc);
-    
-    IndexReader ir = iw.getReader();
-    iw.close();
-    
-    IndexSearcher is = new IndexSearcher(ir);
-    SpanTermQuery query = new SpanTermQuery(new Term("foo", "bar"));
-    SpanTermQuery query2 = new SpanTermQuery(new Term("foo", "baz"));
-
-    IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {
-      is.search(new SpanNotQuery(query, query2), 5);
-    });
-    assertTrue(expected.getMessage().contains("was indexed without position data"));
-
-    ir.close();
-    dir.close();
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanOrQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanOrQuery.java
deleted file mode 100644
index b0fe485..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanOrQuery.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.QueryUtils;
-import org.apache.lucene.util.LuceneTestCase;
-
-/** Basic tests for SpanOrQuery */
-public class TestSpanOrQuery extends LuceneTestCase {
-  
-  public void testHashcodeEquals() {
-    SpanTermQuery q1 = new SpanTermQuery(new Term("field", "foo"));
-    SpanTermQuery q2 = new SpanTermQuery(new Term("field", "bar"));
-    SpanTermQuery q3 = new SpanTermQuery(new Term("field", "baz"));
-    
-    SpanOrQuery or1 = new SpanOrQuery(q1, q2);
-    SpanOrQuery or2 = new SpanOrQuery(q2, q3);
-    QueryUtils.check(or1);
-    QueryUtils.check(or2);
-    QueryUtils.checkUnequal(or1, or2);
-  }
-  
-  public void testSpanOrEmpty() throws Exception {
-    SpanOrQuery a = new SpanOrQuery();
-    SpanOrQuery b = new SpanOrQuery();
-    assertTrue("empty should equal", a.equals(b));
-  }
-  
-  public void testDifferentField() throws Exception {
-    SpanTermQuery q1 = new SpanTermQuery(new Term("field1", "foo"));
-    SpanTermQuery q2 = new SpanTermQuery(new Term("field2", "bar"));
-    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
-      new SpanOrQuery(q1, q2);
-    });
-    assertTrue(expected.getMessage().contains("must have same field"));
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java
deleted file mode 100644
index 7d7fbe4..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java
+++ /dev/null
@@ -1,469 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.BooleanClause.Occur;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.PhraseQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.SearchEquivalenceTestBase;
-import org.apache.lucene.search.TermQuery;
-
-import static org.apache.lucene.search.spans.SpanTestUtil.*;
-
-/**
- * Basic equivalence tests for span queries
- */
-public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
-  
-  // TODO: we could go a little crazy for a lot of these,
-  // but these are just simple minimal cases in case something 
-  // goes horribly wrong. Put more intense tests elsewhere.
-
-  /** SpanTermQuery(A) = TermQuery(A) */
-  public void testSpanTermVersusTerm() throws Exception {
-    Term t1 = randomTerm();
-    assertSameScores(new TermQuery(t1), spanQuery(new SpanTermQuery(t1)));
-  }
-  
-  /** SpanOrQuery(A) = SpanTermQuery(A) */
-  public void testSpanOrVersusTerm() throws Exception {
-    Term t1 = randomTerm();
-    SpanQuery term = spanQuery(new SpanTermQuery(t1));
-    assertSameSet(spanQuery(new SpanOrQuery(term)), term);
-  }
-  
-  /** SpanOrQuery(A, A) = SpanTermQuery(A) */
-  public void testSpanOrDoubleVersusTerm() throws Exception {
-    Term t1 = randomTerm();
-    SpanQuery term = spanQuery(new SpanTermQuery(t1));
-    assertSameSet(spanQuery(new SpanOrQuery(term, term)), term);
-  }
-  
-  /** SpanOrQuery(A, B) = (A B) */
-  public void testSpanOrVersusBooleanTerm() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    BooleanQuery.Builder q1 = new BooleanQuery.Builder();
-    q1.add(new TermQuery(t1), Occur.SHOULD);
-    q1.add(new TermQuery(t2), Occur.SHOULD);
-    SpanQuery q2 = spanQuery(new SpanOrQuery(spanQuery(new SpanTermQuery(t1)), spanQuery(new SpanTermQuery(t2))));
-    assertSameSet(q1.build(), q2);
-  }
-  
-  /** SpanOrQuery(SpanNearQuery[A B], SpanNearQuery[C D]) = (SpanNearQuery[A B], SpanNearQuery[C D]) */
-  public void testSpanOrVersusBooleanNear() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    Term t3 = randomTerm();
-    Term t4 = randomTerm();
-    SpanQuery near1 = spanQuery(new SpanNearQuery(new SpanQuery[] { 
-                                               spanQuery(new SpanTermQuery(t1)), 
-                                               spanQuery(new SpanTermQuery(t2)) 
-                                             }, 10, random().nextBoolean()));
-    SpanQuery near2 = spanQuery(new SpanNearQuery(new SpanQuery[] { 
-                                               spanQuery(new SpanTermQuery(t3)), 
-                                               spanQuery(new SpanTermQuery(t4)) 
-                                             }, 10, random().nextBoolean()));
-    BooleanQuery.Builder q1 = new BooleanQuery.Builder();
-    q1.add(near1, Occur.SHOULD);
-    q1.add(near2, Occur.SHOULD);
-    SpanQuery q2 = spanQuery(new SpanOrQuery(near1, near2));
-    assertSameSet(q1.build(), q2);
-  }
-  
-  /** SpanNotQuery(A, B) ⊆ SpanTermQuery(A) */
-  public void testSpanNotVersusSpanTerm() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    assertSubsetOf(spanQuery(new SpanNotQuery(spanQuery(new SpanTermQuery(t1)), spanQuery(new SpanTermQuery(t2)))), 
-                   spanQuery(new SpanTermQuery(t1)));
-  }
-  
-  /** SpanNotQuery(A, [B C]) ⊆ SpanTermQuery(A) */
-  public void testSpanNotNearVersusSpanTerm() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    Term t3 = randomTerm();
-    SpanQuery near = spanQuery(new SpanNearQuery(new SpanQuery[] { 
-                                              spanQuery(new SpanTermQuery(t2)), 
-                                              spanQuery(new SpanTermQuery(t3)) 
-                                            }, 10, random().nextBoolean()));
-    assertSubsetOf(spanQuery(new SpanNotQuery(spanQuery(new SpanTermQuery(t1)), near)), spanQuery(new SpanTermQuery(t1)));
-  }
-  
-  /** SpanNotQuery([A B], C) ⊆ SpanNearQuery([A B]) */
-  public void testSpanNotVersusSpanNear() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    Term t3 = randomTerm();
-    SpanQuery near = spanQuery(new SpanNearQuery(new SpanQuery[] { 
-                                              spanQuery(new SpanTermQuery(t1)), 
-                                              spanQuery(new SpanTermQuery(t2)) 
-                                            }, 10, random().nextBoolean()));
-    assertSubsetOf(spanQuery(new SpanNotQuery(near, spanQuery(new SpanTermQuery(t3)))), near);
-  }
-  
-  /** SpanNotQuery([A B], [C D]) ⊆ SpanNearQuery([A B]) */
-  public void testSpanNotNearVersusSpanNear() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    Term t3 = randomTerm();
-    Term t4 = randomTerm();
-    SpanQuery near1 = spanQuery(new SpanNearQuery(new SpanQuery[] { 
-                                               spanQuery(new SpanTermQuery(t1)), 
-                                               spanQuery(new SpanTermQuery(t2)) 
-                                             }, 10, random().nextBoolean()));
-    SpanQuery near2 = spanQuery(new SpanNearQuery(new SpanQuery[] { 
-                                               spanQuery(new SpanTermQuery(t3)), 
-                                               spanQuery(new SpanTermQuery(t4)) 
-                                             }, 10, random().nextBoolean()));
-    assertSubsetOf(spanQuery(new SpanNotQuery(near1, near2)), near1);
-  }
-  
-  /** SpanFirstQuery(A, 10) ⊆ SpanTermQuery(A) */
-  public void testSpanFirstVersusSpanTerm() throws Exception {
-    Term t1 = randomTerm();
-    assertSubsetOf(spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), 10)), 
-                   spanQuery(new SpanTermQuery(t1)));
-  }
-  
-  /** SpanNearQuery([A, B], 0, true) = "A B" */
-  public void testSpanNearVersusPhrase() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-                             spanQuery(new SpanTermQuery(t1)), 
-                             spanQuery(new SpanTermQuery(t2)) 
-                           };
-    SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, 0, true));
-    PhraseQuery q2 = new PhraseQuery(t1.field(), t1.bytes(), t2.bytes());
-    if (t1.equals(t2)) {
-      assertSameSet(q1, q2);
-    } else {
-      assertSameScores(q1, q2);
-    }
-  }
-  
-  /** SpanNearQuery([A, B], ∞, false) = +A +B */
-  public void testSpanNearVersusBooleanAnd() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-                             spanQuery(new SpanTermQuery(t1)), 
-                             spanQuery(new SpanTermQuery(t2)) 
-                           };
-    SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, Integer.MAX_VALUE, false));
-    BooleanQuery.Builder q2 = new BooleanQuery.Builder();
-    q2.add(new TermQuery(t1), Occur.MUST);
-    q2.add(new TermQuery(t2), Occur.MUST);
-    assertSameSet(q1, q2.build());
-  }
-  
-  /** SpanNearQuery([A B], 0, false) ⊆ SpanNearQuery([A B], 1, false) */
-  public void testSpanNearVersusSloppySpanNear() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-                             spanQuery(new SpanTermQuery(t1)), 
-                             spanQuery(new SpanTermQuery(t2)) 
-                           };
-    SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, 0, false));
-    SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, 1, false));
-    assertSubsetOf(q1, q2);
-  }
-  
-  /** SpanNearQuery([A B], 3, true) ⊆ SpanNearQuery([A B], 3, false) */
-  public void testSpanNearInOrderVersusOutOfOrder() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-                             spanQuery(new SpanTermQuery(t1)), 
-                             spanQuery(new SpanTermQuery(t2)) 
-                           };
-    SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, 3, true));
-    SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, 3, false));
-    assertSubsetOf(q1, q2);
-  }
-  
-  /** SpanNearQuery([A B], N, false) ⊆ SpanNearQuery([A B], N+1, false) */
-  public void testSpanNearIncreasingSloppiness() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-                             spanQuery(new SpanTermQuery(t1)), 
-                             spanQuery(new SpanTermQuery(t2)) 
-                           };
-    for (int i = 0; i < 10; i++) {
-      SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, i, false));
-      SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, i+1, false));
-      assertSubsetOf(q1, q2);
-    }
-  }
-  
-  /** SpanNearQuery([A B C], N, false) ⊆ SpanNearQuery([A B C], N+1, false) */
-  public void testSpanNearIncreasingSloppiness3() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    Term t3 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-                             spanQuery(new SpanTermQuery(t1)), 
-                             spanQuery(new SpanTermQuery(t2)), 
-                             spanQuery(new SpanTermQuery(t3)) 
-                           };
-    for (int i = 0; i < 10; i++) {
-      SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, i, false));
-      SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, i+1, false));
-      assertSubsetOf(q1, q2);
-    }
-  }
-  
-  /** SpanNearQuery([A B], N, true) ⊆ SpanNearQuery([A B], N+1, true) */
-  public void testSpanNearIncreasingOrderedSloppiness() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-                             spanQuery(new SpanTermQuery(t1)), 
-                             spanQuery(new SpanTermQuery(t2)) 
-                           };
-    for (int i = 0; i < 10; i++) {
-      SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, i, false));
-      SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, i+1, false));
-      assertSubsetOf(q1, q2);
-    }
-  }
-  
-  /** SpanNearQuery([A B C], N, true) ⊆ SpanNearQuery([A B C], N+1, true) */
-  public void testSpanNearIncreasingOrderedSloppiness3() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    Term t3 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-                             spanQuery(new SpanTermQuery(t1)), 
-                             spanQuery(new SpanTermQuery(t2)), 
-                             spanQuery(new SpanTermQuery(t3)) 
-                           };
-    for (int i = 0; i < 10; i++) {
-      SpanQuery q1 = spanQuery(new SpanNearQuery(subquery, i, true));
-      SpanQuery q2 = spanQuery(new SpanNearQuery(subquery, i+1, true));
-      assertSubsetOf(q1, q2);
-    }
-  }
-  
-  /** SpanPositionRangeQuery(A, M, N) ⊆ TermQuery(A) */
-  public void testSpanRangeTerm() throws Exception {
-    Term t1 = randomTerm();
-    for (int i = 0; i < 5; i++) {
-      for (int j = 0; j < 5; j++) {
-        Query q1 = spanQuery(new SpanPositionRangeQuery(spanQuery(new SpanTermQuery(t1)), i, i+j));
-        Query q2 = new TermQuery(t1);
-        assertSubsetOf(q1, q2);
-      }
-    }
-  }
-  
-  /** SpanPositionRangeQuery(A, M, N) ⊆ SpanFirstQuery(A, M, N+1) */
-  public void testSpanRangeTermIncreasingEnd() throws Exception {
-    Term t1 = randomTerm();
-    for (int i = 0; i < 5; i++) {
-      for (int j = 0; j < 5; j++) {
-        Query q1 = spanQuery(new SpanPositionRangeQuery(spanQuery(new SpanTermQuery(t1)), i, i+j));
-        Query q2 = spanQuery(new SpanPositionRangeQuery(spanQuery(new SpanTermQuery(t1)), i, i+j+1));
-        assertSubsetOf(q1, q2);
-      }
-    }
-  }
-  
-  /** SpanPositionRangeQuery(A, 0, ∞) = TermQuery(A) */
-  public void testSpanRangeTermEverything() throws Exception {
-    Term t1 = randomTerm();
-    Query q1 = spanQuery(new SpanPositionRangeQuery(spanQuery(new SpanTermQuery(t1)), 0, Integer.MAX_VALUE));
-    Query q2 = new TermQuery(t1);
-    assertSameSet(q1, q2);
-  }
-  
-  /** SpanPositionRangeQuery([A B], M, N) ⊆ SpanNearQuery([A B]) */
-  public void testSpanRangeNear() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-                             spanQuery(new SpanTermQuery(t1)), 
-                             spanQuery(new SpanTermQuery(t2)) 
-                           };
-    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
-    for (int i = 0; i < 5; i++) {
-      for (int j = 0; j < 5; j++) {
-        Query q1 = spanQuery(new SpanPositionRangeQuery(nearQuery, i, i+j));
-        Query q2 = nearQuery;
-        assertSubsetOf(q1, q2);
-      }
-    }
-  }
-  
-  /** SpanPositionRangeQuery([A B], M, N) ⊆ SpanFirstQuery([A B], M, N+1) */
-  public void testSpanRangeNearIncreasingEnd() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-                             spanQuery(new SpanTermQuery(t1)), 
-                             spanQuery(new SpanTermQuery(t2)) 
-                           };
-    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
-    for (int i = 0; i < 5; i++) {
-      for (int j = 0; j < 5; j++) {
-        Query q1 = spanQuery(new SpanPositionRangeQuery(nearQuery, i, i+j));
-        Query q2 = spanQuery(new SpanPositionRangeQuery(nearQuery, i, i+j+1));
-        assertSubsetOf(q1, q2);
-      }
-    }
-  }
-  
-  /** SpanPositionRangeQuery([A B], ∞) = SpanNearQuery([A B]) */
-  public void testSpanRangeNearEverything() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-                             spanQuery(new SpanTermQuery(t1)), 
-                             spanQuery(new SpanTermQuery(t2)) 
-                           };
-    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
-    Query q1 = spanQuery(new SpanPositionRangeQuery(nearQuery, 0, Integer.MAX_VALUE));
-    Query q2 = nearQuery;
-    assertSameSet(q1, q2);
-  }
-  
-  /** SpanFirstQuery(A, N) ⊆ TermQuery(A) */
-  public void testSpanFirstTerm() throws Exception {
-    Term t1 = randomTerm();
-    for (int i = 0; i < 10; i++) {
-      Query q1 = spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), i));
-      Query q2 = new TermQuery(t1);
-      assertSubsetOf(q1, q2);
-    }
-  }
-  
-  /** SpanFirstQuery(A, N) ⊆ SpanFirstQuery(A, N+1) */
-  public void testSpanFirstTermIncreasing() throws Exception {
-    Term t1 = randomTerm();
-    for (int i = 0; i < 10; i++) {
-      Query q1 = spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), i));
-      Query q2 = spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), i+1));
-      assertSubsetOf(q1, q2);
-    }
-  }
-  
-  /** SpanFirstQuery(A, ∞) = TermQuery(A) */
-  public void testSpanFirstTermEverything() throws Exception {
-    Term t1 = randomTerm();
-    Query q1 = spanQuery(new SpanFirstQuery(spanQuery(new SpanTermQuery(t1)), Integer.MAX_VALUE));
-    Query q2 = new TermQuery(t1);
-    assertSameSet(q1, q2);
-  }
-  
-  /** SpanFirstQuery([A B], N) ⊆ SpanNearQuery([A B]) */
-  public void testSpanFirstNear() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-                             spanQuery(new SpanTermQuery(t1)), 
-                             spanQuery(new SpanTermQuery(t2)) 
-                           };
-    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
-    for (int i = 0; i < 10; i++) {
-      Query q1 = spanQuery(new SpanFirstQuery(nearQuery, i));
-      Query q2 = nearQuery;
-      assertSubsetOf(q1, q2);
-    }
-  }
-  
-  /** SpanFirstQuery([A B], N) ⊆ SpanFirstQuery([A B], N+1) */
-  public void testSpanFirstNearIncreasing() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-                             spanQuery(new SpanTermQuery(t1)), 
-                             spanQuery(new SpanTermQuery(t2)) 
-                           };
-    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
-    for (int i = 0; i < 10; i++) {
-      Query q1 = spanQuery(new SpanFirstQuery(nearQuery, i));
-      Query q2 = spanQuery(new SpanFirstQuery(nearQuery, i+1));
-      assertSubsetOf(q1, q2);
-    }
-  }
-  
-  /** SpanFirstQuery([A B], ∞) = SpanNearQuery([A B]) */
-  public void testSpanFirstNearEverything() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-                             spanQuery(new SpanTermQuery(t1)), 
-                             spanQuery(new SpanTermQuery(t2)) 
-                           };
-    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
-    Query q1 = spanQuery(new SpanFirstQuery(nearQuery, Integer.MAX_VALUE));
-    Query q2 = nearQuery;
-    assertSameSet(q1, q2);
-  }
-  
-  /** SpanWithinQuery(A, B) ⊆ SpanNearQuery(A) */
-  public void testSpanWithinVsNear() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-        spanQuery(new SpanTermQuery(t1)), 
-        spanQuery(new SpanTermQuery(t2)) 
-      };
-    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
-    
-    Term t3 = randomTerm();
-    SpanQuery termQuery = spanQuery(new SpanTermQuery(t3));
-    Query q1 = spanQuery(new SpanWithinQuery(nearQuery, termQuery));
-    assertSubsetOf(q1, termQuery);
-  }
-  
-  /** SpanWithinQuery(A, B) = SpanContainingQuery(A, B) */
-  public void testSpanWithinVsContaining() throws Exception {
-    Term t1 = randomTerm();
-    Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { 
-        spanQuery(new SpanTermQuery(t1)), 
-        spanQuery(new SpanTermQuery(t2)) 
-      };
-    SpanQuery nearQuery = spanQuery(new SpanNearQuery(subquery, 10, true));
-    
-    Term t3 = randomTerm();
-    SpanQuery termQuery = spanQuery(new SpanTermQuery(t3));
-    Query q1 = spanQuery(new SpanWithinQuery(nearQuery, termQuery));
-    Query q2 = spanQuery(new SpanContainingQuery(nearQuery, termQuery));
-    assertSameSet(q1, q2);
-  }
-
-  public void testSpanBoostQuerySimplification() throws Exception {
-    float b1 = random().nextFloat() * 10;
-    float b2 = random().nextFloat() * 10;
-    Term term = randomTerm();
-
-    Query q1 = new SpanBoostQuery(new SpanBoostQuery(new SpanTermQuery(term), b2), b1);
-    // Use AssertingQuery to prevent BoostQuery from merging inner and outer boosts
-    Query q2 = new SpanBoostQuery(new AssertingSpanQuery(new SpanBoostQuery(new SpanTermQuery(term), b2)), b1);
-
-    assertSameScores(q1, q2);
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanTermQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanTermQuery.java
deleted file mode 100644
index a1498ce..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanTermQuery.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.StringField;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.QueryUtils;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-
-/** Basic tests for SpanTermQuery */
-public class TestSpanTermQuery extends LuceneTestCase {
-  
-  public void testHashcodeEquals() {
-    SpanTermQuery q1 = new SpanTermQuery(new Term("field", "foo"));
-    SpanTermQuery q2 = new SpanTermQuery(new Term("field", "bar"));
-    QueryUtils.check(q1);
-    QueryUtils.check(q2);
-    QueryUtils.checkUnequal(q1, q2);
-  }
-  
-  public void testNoPositions() throws IOException {
-    Directory dir = newDirectory();
-    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);
-    Document doc = new Document();
-    doc.add(new StringField("foo", "bar", Field.Store.NO));
-    iw.addDocument(doc);
-    
-    IndexReader ir = iw.getReader();
-    iw.close();
-    
-    IndexSearcher is = new IndexSearcher(ir);
-    SpanTermQuery query = new SpanTermQuery(new Term("foo", "bar"));
-    IllegalStateException expected = expectThrows(IllegalStateException.class, () -> {
-      is.search(query, 5);
-    });
-    assertTrue(expected.getMessage().contains("was indexed without position data"));
-
-    ir.close();
-    dir.close();
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
deleted file mode 100644
index 2983301..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
+++ /dev/null
@@ -1,460 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-import java.util.List;
-
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexReaderContext;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.IndexWriterConfig;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.ReaderUtil;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.CheckHits;
-import org.apache.lucene.search.DocIdSetIterator;
-import org.apache.lucene.search.FuzzyQuery;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.PrefixQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.Scorer;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.similarities.ClassicSimilarity;
-import org.apache.lucene.search.similarities.Similarity;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.LuceneTestCase;
-
-import static org.apache.lucene.search.spans.SpanTestUtil.assertFinished;
-import static org.apache.lucene.search.spans.SpanTestUtil.assertNext;
-import static org.apache.lucene.search.spans.SpanTestUtil.spanNearOrderedQuery;
-import static org.apache.lucene.search.spans.SpanTestUtil.spanNearUnorderedQuery;
-import static org.apache.lucene.search.spans.SpanTestUtil.spanNotQuery;
-import static org.apache.lucene.search.spans.SpanTestUtil.spanOrQuery;
-import static org.apache.lucene.search.spans.SpanTestUtil.spanTermQuery;
-
-public class TestSpans extends LuceneTestCase {
-  private IndexSearcher searcher;
-  private IndexReader reader;
-  private Directory directory;
-  
-  public static final String field = "field";
-
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    directory = newDirectory();
-    RandomIndexWriter writer= new RandomIndexWriter(random(), directory, newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
-    for (int i = 0; i < docFields.length; i++) {
-      Document doc = new Document();
-      doc.add(newTextField(field, docFields[i], Field.Store.YES));
-      writer.addDocument(doc);
-    }
-    writer.forceMerge(1);
-    reader = writer.getReader();
-    writer.close();
-    searcher = newSearcher(getOnlyLeafReader(reader));
-  }
-  
-  @Override
-  public void tearDown() throws Exception {
-    reader.close();
-    directory.close();
-    super.tearDown();
-  }
-  
-  private String[] docFields = {
-    "w1 w2 w3 w4 w5",
-    "w1 w3 w2 w3",
-    "w1 xx w2 yy w3",
-    "w1 w3 xx w2 yy w3",
-    "u2 u2 u1",
-    "u2 xx u2 u1",
-    "u2 u2 xx u1",
-    "u2 xx u2 yy u1",
-    "u2 xx u1 u2",
-    "u2 u1 xx u2",
-    "u1 u2 xx u2",
-    "t1 t2 t1 t3 t2 t3",
-    "s2 s1 s1 xx xx s2 xx s2 xx s1 xx xx xx xx xx s2 xx",
-    "r1 s11",
-    "r1 s21"
-
-  };
-  
-  private void checkHits(Query query, int[] results) throws IOException {
-    CheckHits.checkHits(random(), query, field, searcher, results);
-  }
-  
-  private void orderedSlopTest3SQ(
-        SpanQuery q1,
-        SpanQuery q2,
-        SpanQuery q3,
-        int slop,
-        int[] expectedDocs) throws IOException {
-    SpanQuery query = spanNearOrderedQuery(slop, q1, q2, q3);
-    checkHits(query, expectedDocs);
-  }
-  
-  public void orderedSlopTest3(int slop, int[] expectedDocs) throws IOException {
-    orderedSlopTest3SQ(
-       spanTermQuery(field, "w1"),
-       spanTermQuery(field, "w2"),
-       spanTermQuery(field, "w3"),
-       slop,
-       expectedDocs);
-  }
-  
-  public void orderedSlopTest3Equal(int slop, int[] expectedDocs) throws IOException {
-    orderedSlopTest3SQ(
-       spanTermQuery(field, "w1"),
-       spanTermQuery(field, "w3"),
-       spanTermQuery(field, "w3"),
-       slop,
-       expectedDocs);
-  }
-  
-  public void orderedSlopTest1Equal(int slop, int[] expectedDocs) throws IOException {
-    orderedSlopTest3SQ(
-       spanTermQuery(field, "u2"),
-       spanTermQuery(field, "u2"),
-       spanTermQuery(field, "u1"),
-       slop,
-       expectedDocs);
-  }
-  
-  public void testSpanNearOrdered01() throws Exception {
-    orderedSlopTest3(0, new int[] {0});
-  }
-
-  public void testSpanNearOrdered02() throws Exception {
-    orderedSlopTest3(1, new int[] {0,1});
-  }
-
-  public void testSpanNearOrdered03() throws Exception {
-    orderedSlopTest3(2, new int[] {0,1,2});
-  }
-
-  public void testSpanNearOrdered04() throws Exception {
-    orderedSlopTest3(3, new int[] {0,1,2,3});
-  }
-
-  public void testSpanNearOrdered05() throws Exception {
-    orderedSlopTest3(4, new int[] {0,1,2,3});
-  }
-  
-  public void testSpanNearOrderedEqual01() throws Exception {
-    orderedSlopTest3Equal(0, new int[] {});
-  }
-
-  public void testSpanNearOrderedEqual02() throws Exception {
-    orderedSlopTest3Equal(1, new int[] {1});
-  }
-
-  public void testSpanNearOrderedEqual03() throws Exception {
-    orderedSlopTest3Equal(2, new int[] {1});
-  }
-
-  public void testSpanNearOrderedEqual04() throws Exception {
-    orderedSlopTest3Equal(3, new int[] {1,3});
-  }
-  
-  public void testSpanNearOrderedEqual11() throws Exception {
-    orderedSlopTest1Equal(0, new int[] {4});
-  }
-  
-  public void testSpanNearOrderedEqual12() throws Exception {
-    orderedSlopTest1Equal(0, new int[] {4});
-  }
-  
-  public void testSpanNearOrderedEqual13() throws Exception {
-    orderedSlopTest1Equal(1, new int[] {4,5,6});
-  }
-  
-  public void testSpanNearOrderedEqual14() throws Exception {
-    orderedSlopTest1Equal(2, new int[] {4,5,6,7});
-  }
-
-  public void testSpanNearOrderedEqual15() throws Exception {
-    orderedSlopTest1Equal(3, new int[] {4,5,6,7});
-  }
-
-  public void testSpanNearOrderedOverlap() throws Exception {
-    final SpanQuery query = spanNearOrderedQuery(field, 1, "t1", "t2", "t3");
-    
-    Spans spans = query.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-
-    assertEquals("first doc", 11, spans.nextDoc());
-    assertEquals("first start", 0, spans.nextStartPosition());
-    assertEquals("first end", 4, spans.endPosition());
-
-    assertEquals("second start", 2, spans.nextStartPosition());
-    assertEquals("second end", 6, spans.endPosition());
-
-    assertFinished(spans);  
-  }
-
-  public void testSpanNearUnOrdered() throws Exception {
-    //See http://www.gossamer-threads.com/lists/lucene/java-dev/52270 for discussion about this test
-    SpanQuery senq = spanNearUnorderedQuery(field, 0, "u1", "u2");
-    Spans spans = senq.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertNext(spans, 4, 1, 3);
-    assertNext(spans, 5, 2, 4);
-    assertNext(spans, 8, 2, 4);
-    assertNext(spans, 9, 0, 2);
-    assertNext(spans, 10, 0, 2);
-    assertFinished(spans);
-
-    senq = spanNearUnorderedQuery(1, senq, spanTermQuery(field, "u2")); 
-    spans = senq.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-    assertNext(spans, 4, 0, 3);
-    assertNext(spans, 4, 1, 3); // unordered spans can be subsets
-    assertNext(spans, 5, 0, 4);
-    assertNext(spans, 5, 2, 4);
-    assertNext(spans, 8, 0, 4);
-    assertNext(spans, 8, 2, 4);
-    assertNext(spans, 9, 0, 2);
-    assertNext(spans, 9, 0, 4);
-    assertNext(spans, 10, 0, 2);
-    assertFinished(spans);
-  }
-
-  private Spans orSpans(String[] terms) throws Exception {
-    return spanOrQuery(field, terms).createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-  }
-
-  public void testSpanOrEmpty() throws Exception {
-    Spans spans = orSpans(new String[0]);
-    assertFinished(spans);
-  }
-
-  public void testSpanOrSingle() throws Exception {
-    Spans spans = orSpans(new String[] {"w5"});
-    assertNext(spans, 0, 4, 5);
-    assertFinished(spans);
-  }
-  
-  public void testSpanOrDouble() throws Exception {
-    Spans spans = orSpans(new String[] {"w5", "yy"});
-    assertNext(spans, 0, 4, 5);
-    assertNext(spans, 2, 3, 4);
-    assertNext(spans, 3, 4, 5);
-    assertNext(spans, 7, 3, 4);
-    assertFinished(spans);
-  }
-
-  public void testSpanOrDoubleAdvance() throws Exception {
-    Spans spans = orSpans(new String[] {"w5", "yy"});
-    assertEquals("initial advance", 3, spans.advance(3));
-    assertNext(spans, 3, 4, 5);
-    assertNext(spans, 7, 3, 4);
-    assertFinished(spans);
-  }
-
-  public void testSpanOrUnused() throws Exception {
-    Spans spans = orSpans(new String[] {"w5", "unusedTerm", "yy"});
-    assertNext(spans, 0, 4, 5);
-    assertNext(spans, 2, 3, 4);
-    assertNext(spans, 3, 4, 5);
-    assertNext(spans, 7, 3, 4);
-    assertFinished(spans);
-  }
-
-  public void testSpanOrTripleSameDoc() throws Exception {
-    Spans spans = orSpans(new String[] {"t1", "t2", "t3"});
-    assertNext(spans, 11, 0, 1);
-    assertNext(spans, 11, 1, 2);
-    assertNext(spans, 11, 2, 3);
-    assertNext(spans, 11, 3, 4);
-    assertNext(spans, 11, 4, 5);
-    assertNext(spans, 11, 5, 6);
-    assertFinished(spans);
-  }
-
-  public void testSpanScorerZeroSloppyFreq() throws Exception {
-    IndexReaderContext topReaderContext = searcher.getTopReaderContext();
-    List<LeafReaderContext> leaves = topReaderContext.leaves();
-    int subIndex = ReaderUtil.subIndex(11, leaves);
-    for (int i = 0, c = leaves.size(); i < c; i++) {
-      final LeafReaderContext ctx = leaves.get(i);
-     
-      final Similarity sim = new ClassicSimilarity() {
-        @Override
-        public float sloppyFreq(int distance) {
-          return 0.0f;
-        }
-      };
-  
-      final Similarity oldSim = searcher.getSimilarity(true);
-      Scorer spanScorer;
-      try {
-        searcher.setSimilarity(sim);
-        SpanQuery snq = spanNearOrderedQuery(field, 1, "t1", "t2");
-        spanScorer = searcher.createNormalizedWeight(snq, true).scorer(ctx);
-      } finally {
-        searcher.setSimilarity(oldSim);
-      }
-      if (i == subIndex) {
-        assertTrue("first doc", spanScorer.iterator().nextDoc() != DocIdSetIterator.NO_MORE_DOCS);
-        assertEquals("first doc number", spanScorer.docID() + ctx.docBase, 11);
-        float score = spanScorer.score();
-        assertTrue("first doc score should be zero, " + score, score == 0.0f);
-      } else {
-        assertTrue("no second doc", spanScorer == null || spanScorer.iterator().nextDoc() == DocIdSetIterator.NO_MORE_DOCS);
-      }
-    }
-  }
-
-  // LUCENE-1404
-  private void addDoc(IndexWriter writer, String id, String text) throws IOException {
-    final Document doc = new Document();
-    doc.add( newStringField("id", id, Field.Store.YES) );
-    doc.add( newTextField("text", text, Field.Store.YES) );
-    writer.addDocument(doc);
-  }
-
-  // LUCENE-1404
-  private int hitCount(IndexSearcher searcher, String word) throws Throwable {
-    return searcher.search(new TermQuery(new Term("text", word)), 10).totalHits;
-  }
-
-  // LUCENE-1404
-  private SpanQuery createSpan(String value) {
-    return spanTermQuery("text", value);
-  }                     
-  
-  // LUCENE-1404
-  private SpanQuery createSpan(int slop, boolean ordered, SpanQuery[] clauses) {
-    if (ordered) {
-      return spanNearOrderedQuery(slop, clauses);
-    } else {
-      return spanNearUnorderedQuery(slop, clauses);
-    }
-  }
-
-  // LUCENE-1404
-  private SpanQuery createSpan(int slop, boolean ordered, String term1, String term2) {
-    return createSpan(slop, ordered, new SpanQuery[] {createSpan(term1), createSpan(term2)});
-  }
-
-  // LUCENE-1404
-  public void testNPESpanQuery() throws Throwable {
-    final Directory dir = newDirectory();
-    final IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(new MockAnalyzer(random())));
-
-    // Add documents
-    addDoc(writer, "1", "the big dogs went running to the market");
-    addDoc(writer, "2", "the cat chased the mouse, then the cat ate the mouse quickly");
-    
-    // Commit
-    writer.close();
-
-    // Get searcher
-    final IndexReader reader = DirectoryReader.open(dir);
-    final IndexSearcher searcher = newSearcher(reader);
-
-    // Control (make sure docs indexed)
-    assertEquals(2, hitCount(searcher, "the"));
-    assertEquals(1, hitCount(searcher, "cat"));
-    assertEquals(1, hitCount(searcher, "dogs"));
-    assertEquals(0, hitCount(searcher, "rabbit"));
-
-    // This throws exception (it shouldn't)
-    assertEquals(1,
-                 searcher.search(createSpan(0, true,                                 
-                                            new SpanQuery[] {createSpan(4, false, "chased", "cat"),
-                                                             createSpan("ate")}), 10).totalHits);
-    reader.close();
-    dir.close();
-  }
-
-  public void testSpanNotWithMultiterm() throws Exception {
-    SpanQuery q = spanNotQuery(
-        spanTermQuery(field, "r1"),
-        new SpanMultiTermQueryWrapper<>(new PrefixQuery(new Term(field, "s1"))),3,3);
-    checkHits(q,  new int[] {14});
-
-    q = spanNotQuery(
-        spanTermQuery(field, "r1"),
-        new SpanMultiTermQueryWrapper<>(new FuzzyQuery(new Term(field, "s12"), 1, 2)),3,3);
-    checkHits(q,  new int[] {14});
-
-    q = spanNotQuery(
-        new SpanMultiTermQueryWrapper<>(new PrefixQuery(new Term(field, "r"))),
-        spanTermQuery(field, "s21"),3,3);
-    checkHits(q,  new int[] {13});
-
-
-  }
-  
-  public void testSpanNots() throws Throwable{
-     assertEquals("SpanNotIncludeExcludeSame1", 0, spanCount("s2", "s2", 0, 0), 0);
-     assertEquals("SpanNotIncludeExcludeSame2", 0, spanCount("s2", "s2", 10, 10), 0);
-     
-     //focus on behind
-     assertEquals("SpanNotS2NotS1_6_0", 1, spanCount("s2", "s1", 6, 0));
-     assertEquals("SpanNotS2NotS1_5_0", 2, spanCount("s2", "s1", 5, 0));
-     assertEquals("SpanNotS2NotS1_3_0", 3, spanCount("s2", "s1", 3, 0));
-     assertEquals("SpanNotS2NotS1_2_0", 4, spanCount("s2", "s1", 2, 0));
-     assertEquals("SpanNotS2NotS1_0_0", 4, spanCount("s2", "s1", 0, 0));
-     
-     //focus on both
-     assertEquals("SpanNotS2NotS1_3_1", 2, spanCount("s2", "s1", 3, 1));
-     assertEquals("SpanNotS2NotS1_2_1", 3, spanCount("s2", "s1", 2, 1));
-     assertEquals("SpanNotS2NotS1_1_1", 3, spanCount("s2", "s1", 1, 1));
-     assertEquals("SpanNotS2NotS1_10_10", 0, spanCount("s2", "s1", 10, 10));
-     
-     //focus on ahead
-     assertEquals("SpanNotS1NotS2_10_10", 0, spanCount("s1", "s2", 10, 10));  
-     assertEquals("SpanNotS1NotS2_0_1", 3, spanCount("s1", "s2", 0, 1));  
-     assertEquals("SpanNotS1NotS2_0_2", 3, spanCount("s1", "s2", 0, 2));  
-     assertEquals("SpanNotS1NotS2_0_3", 2, spanCount("s1", "s2", 0, 3));  
-     assertEquals("SpanNotS1NotS2_0_4", 1, spanCount("s1", "s2", 0, 4));
-     assertEquals("SpanNotS1NotS2_0_8", 0, spanCount("s1", "s2", 0, 8));
-     
-     //exclude doesn't exist
-     assertEquals("SpanNotS1NotS3_8_8", 3, spanCount("s1", "s3", 8, 8));
-
-     //include doesn't exist
-     assertEquals("SpanNotS3NotS1_8_8", 0, spanCount("s3", "s1", 8, 8));
-
-  }
-  
-  private int spanCount(String include, String exclude, int pre, int post) throws IOException{
-     SpanQuery iq = spanTermQuery(field, include);
-     SpanQuery eq = spanTermQuery(field, exclude);
-     SpanQuery snq = spanNotQuery(iq, eq, pre, post);
-     Spans spans = snq.createWeight(searcher, false).getSpans(searcher.getIndexReader().leaves().get(0), SpanWeight.Postings.POSITIONS);
-
-     int i = 0;
-     if (spans != null) {
-       while (spans.nextDoc() != Spans.NO_MORE_DOCS){
-         while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
-           i++;
-         }
-       }
-     }
-     return i;
-  }
-  
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java
deleted file mode 100644
index 10509a8..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.search.spans;
-
-
-import java.io.IOException;
-
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.search.CheckHits;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.English;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.TestUtil;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-
-import static org.apache.lucene.search.spans.SpanTestUtil.*;
-
-/**
- * Tests Spans (v2)
- *
- */
-public class TestSpansEnum extends LuceneTestCase {
-  private static IndexSearcher searcher;
-  private static IndexReader reader;
-  private static Directory directory;
-
-  @BeforeClass
-  public static void beforeClass() throws Exception {
-    directory = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
-        newIndexWriterConfig(new MockAnalyzer(random()))
-            .setMaxBufferedDocs(TestUtil.nextInt(random(), 100, 1000)).setMergePolicy(newLogMergePolicy()));
-    //writer.infoStream = System.out;
-    for (int i = 0; i < 10; i++) {
-      Document doc = new Document();
-      doc.add(newTextField("field", English.intToEnglish(i), Field.Store.YES));
-      writer.addDocument(doc);
-    }
-    for (int i = 100; i < 110; i++) {
-      Document doc = new Document(); // doc id 10-19 have 100-109
-      doc.add(newTextField("field", English.intToEnglish(i), Field.Store.YES));
-      writer.addDocument(doc);
-    }
-    reader = writer.getReader();
-    searcher = newSearcher(reader);
-    writer.close();
-  }
-
-  @AfterClass
-  public static void afterClass() throws Exception {
-    reader.close();
-    directory.close();
-    searcher = null;
-    reader = null;
-    directory = null;
-  }
-
-  private void checkHits(Query query, int[] results) throws IOException {
-    CheckHits.checkHits(random(), query, "field", searcher, results);
-  }
-
-  public void testSpansEnumOr1() throws Exception {
-    checkHits(spanOrQuery("field", "one", "two"), 
-              new int[] {1, 2, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
-  }
-
-  public void testSpansEnumOr2() throws Exception {
-    checkHits(spanOrQuery("field", "one", "eleven"), 
-              new int[] {1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
-  }
-
-  public void testSpansEnumOr3() throws Exception {
-    checkHits(spanOrQuery("field", "twelve", "eleven"), 
-              new int[] {});
-  }
-  
-  public SpanQuery spanTQ(String s) {
-    return spanTermQuery("field", s);
-  }
-
-  public void testSpansEnumOrNot1() throws Exception {
-    checkHits(spanNotQuery(spanOrQuery("field", "one", "two"), spanTermQuery("field", "one")),
-              new int[] {2,12});
-  }
-
-  public void testSpansEnumNotBeforeAfter1() throws Exception {
-    checkHits(spanNotQuery(spanTermQuery("field", "hundred"), spanTermQuery("field", "one")), 
-              new int[] {10, 11, 12, 13, 14, 15, 16, 17, 18, 19}); // include all "one hundred ..."
-  }
-
-  public void testSpansEnumNotBeforeAfter2() throws Exception {
-    checkHits(spanNotQuery(spanTermQuery("field", "hundred"), spanTermQuery("field", "one"), 1, 0),
-              new int[] {}); // exclude all "one hundred ..."
-  }
-
-  public void testSpansEnumNotBeforeAfter3() throws Exception {
-    checkHits(spanNotQuery(spanTermQuery("field", "hundred"), spanTermQuery("field", "one"), 0, 1),
-              new int[] {10, 12, 13, 14, 15, 16, 17, 18, 19}); // exclude "one hundred one"
-  }
-}
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/QueryScorer.java b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/QueryScorer.java
index 25d9b3c..355a3f9 100644
--- a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/QueryScorer.java
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/QueryScorer.java
@@ -29,7 +29,7 @@ import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.memory.MemoryIndex;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.SpanQuery;
 
 /**
  * {@link Scorer} implementation which scores text fragments by the number of
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/SimpleSpanFragmenter.java b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/SimpleSpanFragmenter.java
index 7b708d8..ff89493 100644
--- a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/SimpleSpanFragmenter.java
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/SimpleSpanFragmenter.java
@@ -23,7 +23,7 @@ import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.search.Spans;
 
 
 /**
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
index 650be87..f8f588e 100644
--- a/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
@@ -56,15 +56,15 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.join.ToChildBlockJoinQuery;
 import org.apache.lucene.search.join.ToParentBlockJoinQuery;
-import org.apache.lucene.search.spans.FieldMaskingSpanQuery;
-import org.apache.lucene.search.spans.SpanFirstQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanNotQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.Spans;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.search.spans.SpanWeight;
+import org.apache.lucene.search.FieldMaskingSpanQuery;
+import org.apache.lucene.search.SpanFirstQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanNotQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.Spans;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.search.SpanWeight;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.IOUtils;
 
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/MultiTermHighlighting.java b/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/MultiTermHighlighting.java
index 56345c2..b1c70fb 100644
--- a/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/MultiTermHighlighting.java
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/postingshighlight/MultiTermHighlighting.java
@@ -36,11 +36,11 @@ import org.apache.lucene.search.FuzzyQuery;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermRangeQuery;
-import org.apache.lucene.search.spans.SpanMultiTermQueryWrapper;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanNotQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanPositionCheckQuery;
+import org.apache.lucene.search.SpanMultiTermQueryWrapper;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanNotQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanPositionCheckQuery;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.CharsRef;
 import org.apache.lucene.util.UnicodeUtil;
diff --git a/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterPhraseTest.java b/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterPhraseTest.java
index 5baf59c..aa4f6e1 100644
--- a/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterPhraseTest.java
+++ b/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterPhraseTest.java
@@ -41,9 +41,9 @@ import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SimpleCollector;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.LuceneTestCase;
diff --git a/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java b/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
index 936d121..817d89b 100644
--- a/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
+++ b/lucene/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
@@ -81,12 +81,12 @@ import org.apache.lucene.search.join.QueryBitSetProducer;
 import org.apache.lucene.search.join.ScoreMode;
 import org.apache.lucene.search.join.ToChildBlockJoinQuery;
 import org.apache.lucene.search.join.ToParentBlockJoinQuery;
-import org.apache.lucene.search.spans.SpanMultiTermQueryWrapper;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanNotQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanMultiTermQueryWrapper;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanNotQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
diff --git a/lucene/highlighter/src/test/org/apache/lucene/search/highlight/MissesTest.java b/lucene/highlighter/src/test/org/apache/lucene/search/highlight/MissesTest.java
index 6289faf..b4a5ba4 100644
--- a/lucene/highlighter/src/test/org/apache/lucene/search/highlight/MissesTest.java
+++ b/lucene/highlighter/src/test/org/apache/lucene/search/highlight/MissesTest.java
@@ -27,9 +27,9 @@ import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.util.LuceneTestCase;
 
 public class MissesTest extends LuceneTestCase {
diff --git a/lucene/highlighter/src/test/org/apache/lucene/search/highlight/TokenSourcesTest.java b/lucene/highlighter/src/test/org/apache/lucene/search/highlight/TokenSourcesTest.java
index 581ff2f..7e295db 100644
--- a/lucene/highlighter/src/test/org/apache/lucene/search/highlight/TokenSourcesTest.java
+++ b/lucene/highlighter/src/test/org/apache/lucene/search/highlight/TokenSourcesTest.java
@@ -45,9 +45,9 @@ import org.apache.lucene.search.DisjunctionMaxQuery;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.TestUtil;
diff --git a/lucene/highlighter/src/test/org/apache/lucene/search/postingshighlight/TestMultiTermHighlighting.java b/lucene/highlighter/src/test/org/apache/lucene/search/postingshighlight/TestMultiTermHighlighting.java
index 0620bd6..5c5c057 100644
--- a/lucene/highlighter/src/test/org/apache/lucene/search/postingshighlight/TestMultiTermHighlighting.java
+++ b/lucene/highlighter/src/test/org/apache/lucene/search/postingshighlight/TestMultiTermHighlighting.java
@@ -46,13 +46,13 @@ import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TermRangeQuery;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.WildcardQuery;
-import org.apache.lucene.search.spans.SpanFirstQuery;
-import org.apache.lucene.search.spans.SpanMultiTermQueryWrapper;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanNotQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanFirstQuery;
+import org.apache.lucene.search.SpanMultiTermQueryWrapper;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanNotQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 
diff --git a/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndexAgainstRAMDir.java b/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndexAgainstRAMDir.java
index ba1263e..67d3fb9 100644
--- a/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndexAgainstRAMDir.java
+++ b/lucene/memory/src/test/org/apache/lucene/index/memory/TestMemoryIndexAgainstRAMDir.java
@@ -25,7 +25,6 @@ import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import java.util.function.IntSupplier;
 import java.util.function.Supplier;
 
 import org.apache.lucene.analysis.Analyzer;
@@ -82,9 +81,9 @@ import org.apache.lucene.search.Query;
 import org.apache.lucene.search.RegexpQuery;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.spans.SpanMultiTermQueryWrapper;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.SpanMultiTermQueryWrapper;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.ByteBlockPool.Allocator;
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadFunction.java b/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadFunction.java
index afb7c7b..378da2a 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadFunction.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadFunction.java
@@ -16,7 +16,7 @@
  */
 package org.apache.lucene.queries.payloads;
 import org.apache.lucene.search.Explanation;
-import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.search.Spans;
 
 /**
  * An abstract class that defines a way for PayloadScoreQuery instances to transform
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadScoreQuery.java b/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadScoreQuery.java
index d35eb35..9fbfcbb 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadScoreQuery.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/payloads/PayloadScoreQuery.java
@@ -29,12 +29,12 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
-import org.apache.lucene.search.spans.FilterSpans;
-import org.apache.lucene.search.spans.SpanCollector;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanScorer;
-import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.search.FilterSpans;
+import org.apache.lucene.search.SpanCollector;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanScorer;
+import org.apache.lucene.search.SpanWeight;
+import org.apache.lucene.search.Spans;
 import org.apache.lucene.util.BytesRef;
 
 /**
diff --git a/lucene/queries/src/java/org/apache/lucene/queries/payloads/SpanPayloadCheckQuery.java b/lucene/queries/src/java/org/apache/lucene/queries/payloads/SpanPayloadCheckQuery.java
index 62704b4..6078d9b 100644
--- a/lucene/queries/src/java/org/apache/lucene/queries/payloads/SpanPayloadCheckQuery.java
+++ b/lucene/queries/src/java/org/apache/lucene/queries/payloads/SpanPayloadCheckQuery.java
@@ -27,13 +27,13 @@ import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.similarities.Similarity;
-import org.apache.lucene.search.spans.FilterSpans;
-import org.apache.lucene.search.spans.FilterSpans.AcceptStatus;
-import org.apache.lucene.search.spans.SpanCollector;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanScorer;
-import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.search.FilterSpans;
+import org.apache.lucene.search.FilterSpans.AcceptStatus;
+import org.apache.lucene.search.SpanCollector;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanScorer;
+import org.apache.lucene.search.SpanWeight;
+import org.apache.lucene.search.Spans;
 import org.apache.lucene.util.BytesRef;
 
 /**
@@ -45,7 +45,7 @@ public class SpanPayloadCheckQuery extends SpanQuery {
   protected final SpanQuery match;
 
   /**
-   * @param match The underlying {@link org.apache.lucene.search.spans.SpanQuery} to check
+   * @param match The underlying {@link SpanQuery} to check
    * @param payloadToMatch The {@link java.util.List} of payloads to match
    */
   public SpanPayloadCheckQuery(SpanQuery match, List<BytesRef> payloadToMatch) {
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadCheckQuery.java b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadCheckQuery.java
index 7067ef2..b152c94 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadCheckQuery.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadCheckQuery.java
@@ -34,10 +34,10 @@ import org.apache.lucene.index.Term;
 import org.apache.lucene.search.CheckHits;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanPositionRangeQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanPositionRangeQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.English;
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadExplanations.java b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadExplanations.java
index f5ac15f..c9fcf5a 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadExplanations.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadExplanations.java
@@ -19,11 +19,11 @@ package org.apache.lucene.queries.payloads;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BaseExplanationTestCase;
 import org.apache.lucene.search.similarities.ClassicSimilarity;
-import org.apache.lucene.search.spans.SpanBoostQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanBoostQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.util.BytesRef;
 
 /**
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadScoreQuery.java b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadScoreQuery.java
index 043e969..aa36501 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadScoreQuery.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadScoreQuery.java
@@ -38,11 +38,11 @@ import org.apache.lucene.search.QueryUtils;
 import org.apache.lucene.search.TermStatistics;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.similarities.ClassicSimilarity;
-import org.apache.lucene.search.spans.SpanContainingQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanContainingQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.English;
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadSpans.java b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadSpans.java
index 2c0204d..ddc1530 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadSpans.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadSpans.java
@@ -42,14 +42,14 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
-import org.apache.lucene.search.spans.SpanCollector;
-import org.apache.lucene.search.spans.SpanFirstQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanNotQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.Spans;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.search.spans.SpanWeight;
+import org.apache.lucene.search.SpanCollector;
+import org.apache.lucene.search.SpanFirstQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanNotQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.Spans;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.search.SpanWeight;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java
index dfa0191..64efdee 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/payloads/TestPayloadTermQuery.java
@@ -38,10 +38,10 @@ import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.similarities.ClassicSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.search.SpanWeight;
+import org.apache.lucene.search.Spans;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.English;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java
index 1faea18..46fe4ac 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java
@@ -34,12 +34,12 @@ import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TermRangeQuery;
-import org.apache.lucene.search.spans.SpanBoostQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanNotQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanBoostQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanNotQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 
 /**
  * QueryParser which permits complex phrase query syntax eg "(john jon
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java
index 4f01a2d..792994e 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java
@@ -26,7 +26,7 @@ package org.apache.lucene.queryparser.surround.query;
  
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanTermQuery;
 
 /** Factory for creating basic term queries */
 public class BasicQueryFactory {
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java
index 74fd3ae..e143ba7 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java
@@ -22,8 +22,8 @@ import java.io.IOException;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.MatchNoDocsQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanQuery;
 
 /** Factory for NEAR queries */
 public class DistanceQuery extends ComposedQuery implements DistanceSubQuery {
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java
index 2db315f..f477d05 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java
@@ -59,10 +59,10 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.MatchNoDocsQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanBoostQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanBoostQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 
 
 /**
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/BoostingTermBuilder.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/BoostingTermBuilder.java
index 3c9668e..48f2f37 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/BoostingTermBuilder.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/BoostingTermBuilder.java
@@ -21,9 +21,9 @@ import org.apache.lucene.queryparser.xml.DOMUtils;
 import org.apache.lucene.queryparser.xml.ParserException;
 import org.apache.lucene.queries.payloads.AveragePayloadFunction;
 import org.apache.lucene.queries.payloads.PayloadScoreQuery;
-import org.apache.lucene.search.spans.SpanBoostQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanBoostQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.w3c.dom.Element;
 
 /**
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanBuilderBase.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanBuilderBase.java
index 48b7450..b8fb8e7 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanBuilderBase.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanBuilderBase.java
@@ -17,7 +17,7 @@
 package org.apache.lucene.queryparser.xml.builders;
 
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanQuery; // javadocs
+import org.apache.lucene.search.SpanQuery; // javadocs
 import org.apache.lucene.queryparser.xml.ParserException;
 import org.w3c.dom.Element;
 /**
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanFirstBuilder.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanFirstBuilder.java
index 5247511..735677e 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanFirstBuilder.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanFirstBuilder.java
@@ -16,9 +16,9 @@
  */
 package org.apache.lucene.queryparser.xml.builders;
 
-import org.apache.lucene.search.spans.SpanBoostQuery;
-import org.apache.lucene.search.spans.SpanFirstQuery;
-import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.SpanBoostQuery;
+import org.apache.lucene.search.SpanFirstQuery;
+import org.apache.lucene.search.SpanQuery;
 import org.apache.lucene.queryparser.xml.DOMUtils;
 import org.apache.lucene.queryparser.xml.ParserException;
 import org.w3c.dom.Element;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanNearBuilder.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanNearBuilder.java
index c6b6c81..328af84 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanNearBuilder.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanNearBuilder.java
@@ -16,9 +16,9 @@
  */
 package org.apache.lucene.queryparser.xml.builders;
 
-import org.apache.lucene.search.spans.SpanBoostQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.SpanBoostQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanQuery;
 import org.apache.lucene.queryparser.xml.DOMUtils;
 import org.apache.lucene.queryparser.xml.ParserException;
 import org.w3c.dom.Element;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanNotBuilder.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanNotBuilder.java
index 9bac89d..0fa047f 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanNotBuilder.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanNotBuilder.java
@@ -16,9 +16,9 @@
  */
 package org.apache.lucene.queryparser.xml.builders;
 
-import org.apache.lucene.search.spans.SpanBoostQuery;
-import org.apache.lucene.search.spans.SpanNotQuery;
-import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.SpanBoostQuery;
+import org.apache.lucene.search.SpanNotQuery;
+import org.apache.lucene.search.SpanQuery;
 import org.apache.lucene.queryparser.xml.DOMUtils;
 import org.apache.lucene.queryparser.xml.ParserException;
 import org.w3c.dom.Element;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanOrBuilder.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanOrBuilder.java
index a5d5f6a..a63067e 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanOrBuilder.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanOrBuilder.java
@@ -16,9 +16,9 @@
  */
 package org.apache.lucene.queryparser.xml.builders;
 
-import org.apache.lucene.search.spans.SpanBoostQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.SpanBoostQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
 import org.apache.lucene.queryparser.xml.DOMUtils;
 import org.apache.lucene.queryparser.xml.ParserException;
 import org.w3c.dom.Element;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanOrTermsBuilder.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanOrTermsBuilder.java
index d30653e..5942e51 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanOrTermsBuilder.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanOrTermsBuilder.java
@@ -20,10 +20,10 @@ import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.spans.SpanBoostQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanBoostQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.queryparser.xml.DOMUtils;
 import org.apache.lucene.queryparser.xml.ParserException;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanQueryBuilder.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanQueryBuilder.java
index 74d03b3..3d3c821 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanQueryBuilder.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanQueryBuilder.java
@@ -15,7 +15,7 @@
  * limitations under the License.
  */
 package org.apache.lucene.queryparser.xml.builders;
-import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.SpanQuery;
 import org.apache.lucene.queryparser.xml.ParserException;
 import org.apache.lucene.queryparser.xml.QueryBuilder;
 import org.w3c.dom.Element;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanQueryBuilderFactory.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanQueryBuilderFactory.java
index 6f41428..c090e20 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanQueryBuilderFactory.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanQueryBuilderFactory.java
@@ -17,7 +17,7 @@
 package org.apache.lucene.queryparser.xml.builders;
 
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.SpanQuery;
 import org.apache.lucene.queryparser.xml.ParserException;
 import org.w3c.dom.Element;
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanTermBuilder.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanTermBuilder.java
index 560a8ac..22d4b54 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanTermBuilder.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanTermBuilder.java
@@ -17,9 +17,9 @@
 package org.apache.lucene.queryparser.xml.builders;
 
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.spans.SpanBoostQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanBoostQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.queryparser.xml.DOMUtils;
 import org.apache.lucene.queryparser.xml.ParserException;
 import org.w3c.dom.Element;
diff --git a/lucene/queryparser/src/resources/org/apache/lucene/queryparser/xml/LuceneCoreQuery.dtd b/lucene/queryparser/src/resources/org/apache/lucene/queryparser/xml/LuceneCoreQuery.dtd
index 48f94ae..8d0890e 100644
--- a/lucene/queryparser/src/resources/org/apache/lucene/queryparser/xml/LuceneCoreQuery.dtd
+++ b/lucene/queryparser/src/resources/org/apache/lucene/queryparser/xml/LuceneCoreQuery.dtd
@@ -191,7 +191,7 @@ Passes content directly through to the standard LuceneQuery parser see "Lucene Q
 
   (Text below is copied from the javadocs of BoostingTermQuery)
    
-  The BoostingTermQuery is very similar to the {@link org.apache.lucene.search.spans.SpanTermQuery} except
+  The BoostingTermQuery is very similar to the {@link org.apache.lucene.search.SpanTermQuery} except
   that it factors in the value of the payload located at each of the positions where the
   {@link org.apache.lucene.index.Term} occurs.
 
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanOrQueryNodeBuilder.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanOrQueryNodeBuilder.java
index aa21a27..1f322b7 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanOrQueryNodeBuilder.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanOrQueryNodeBuilder.java
@@ -23,8 +23,8 @@ import org.apache.lucene.queryparser.flexible.core.builders.QueryTreeBuilder;
 import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
 import org.apache.lucene.queryparser.flexible.standard.builders.StandardQueryBuilder;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
 
 /**
  * This builder creates {@link SpanOrQuery}s from a {@link BooleanQueryNode}.<br>
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanTermQueryNodeBuilder.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanTermQueryNodeBuilder.java
index d498308..3478820 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanTermQueryNodeBuilder.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanTermQueryNodeBuilder.java
@@ -21,7 +21,7 @@ import org.apache.lucene.queryparser.flexible.core.QueryNodeException;
 import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
 import org.apache.lucene.queryparser.flexible.standard.builders.StandardQueryBuilder;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanTermQuery;
 
 /**
  * This builder creates {@link SpanTermQuery}s from a {@link FieldQueryNode}
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpansQueryTreeBuilder.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpansQueryTreeBuilder.java
index 7ad2c0d..1a65f4f 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpansQueryTreeBuilder.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpansQueryTreeBuilder.java
@@ -22,7 +22,7 @@ import org.apache.lucene.queryparser.flexible.core.nodes.BooleanQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
 import org.apache.lucene.queryparser.flexible.standard.builders.StandardQueryBuilder;
-import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.SpanQuery;
 
 /**
  * Sets up a query tree builder to build a span query tree from a query node
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParser.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParser.java
index 0bcfedf..bc8d998 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParser.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParser.java
@@ -23,9 +23,9 @@ import org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser;
 import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorPipeline;
 import org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser;
 import org.apache.lucene.queryparser.flexible.standard.processors.WildcardQueryNodeProcessor;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.util.LuceneTestCase;
 
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParserSimpleSample.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParserSimpleSample.java
index 65bb72b..bc6c433 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParserSimpleSample.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParserSimpleSample.java
@@ -23,8 +23,8 @@ import org.apache.lucene.queryparser.flexible.core.parser.SyntaxParser;
 import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorPipeline;
 import org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.util.LuceneTestCase;
 
 /**
diff --git a/lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanCollector.java b/lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanCollector.java
index cbade08..b301c35 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanCollector.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanCollector.java
@@ -18,7 +18,7 @@ package org.apache.lucene.payloads;
 
 import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.spans.SpanCollector;
+import org.apache.lucene.search.SpanCollector;
 import org.apache.lucene.util.BytesRef;
 
 import java.io.IOException;
diff --git a/lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanUtil.java b/lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanUtil.java
index 20cd2c0..82ec728 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanUtil.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/payloads/PayloadSpanUtil.java
@@ -34,12 +34,12 @@ import org.apache.lucene.search.MultiPhraseQuery;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.Spans;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.search.spans.SpanWeight;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.Spans;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.search.SpanWeight;
 
 /**
  * Experimental class to get set of payloads for most standard Lucene queries.
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/TermAutomatonQuery.java b/lucene/sandbox/src/java/org/apache/lucene/search/TermAutomatonQuery.java
index e9321df..1998e9e 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/TermAutomatonQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/TermAutomatonQuery.java
@@ -32,7 +32,6 @@ import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.TermState;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.similarities.Similarity;
-import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.automaton.Operations;
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
index cde2cdd..cf84ebd 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
@@ -24,7 +24,6 @@ import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanQuery.java b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanQuery.java
index bf98ba1..afb41d2 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanQuery.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanQuery.java
@@ -19,6 +19,8 @@ package org.apache.lucene.search.spans;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanWeight;
 
 import java.io.IOException;
 
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java
index ae20d83..eedebcf 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpanWeight.java
@@ -25,6 +25,10 @@ import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanScorer;
+import org.apache.lucene.search.SpanWeight;
+import org.apache.lucene.search.Spans;
 import org.apache.lucene.search.similarities.Similarity;
 
 /**
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java
index 9dba2c7..7250cd5 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java
@@ -19,6 +19,8 @@ package org.apache.lucene.search.spans;
 import java.io.IOException;
 
 import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.SpanCollector;
+import org.apache.lucene.search.Spans;
 import org.apache.lucene.search.TwoPhaseIterator;
 
 /** 
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java b/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
index 1388043..a728537 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
@@ -20,6 +20,16 @@ import java.io.IOException;
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.search.SpanContainingQuery;
+import org.apache.lucene.search.SpanFirstQuery;
+import org.apache.lucene.search.SpanNearQuery;
+import org.apache.lucene.search.SpanNotQuery;
+import org.apache.lucene.search.SpanOrQuery;
+import org.apache.lucene.search.SpanPositionRangeQuery;
+import org.apache.lucene.search.SpanQuery;
+import org.apache.lucene.search.SpanTermQuery;
+import org.apache.lucene.search.SpanWithinQuery;
+import org.apache.lucene.search.Spans;
 
 import static org.junit.Assert.*;
 
diff --git a/solr/core/src/test/org/apache/solr/highlight/HighlighterTest.java b/solr/core/src/test/org/apache/solr/highlight/HighlighterTest.java
index 1a432db..5dbb20c 100644
--- a/solr/core/src/test/org/apache/solr/highlight/HighlighterTest.java
+++ b/solr/core/src/test/org/apache/solr/highlight/HighlighterTest.java
@@ -28,7 +28,7 @@ import org.apache.lucene.analysis.core.WhitespaceAnalyzer;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.queries.payloads.SpanPayloadCheckQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.SpanTermQuery;
 import org.apache.lucene.util.BytesRef;
 import org.apache.solr.SolrTestCaseJ4;
 import org.apache.solr.common.params.HighlightParams;
