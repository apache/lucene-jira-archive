diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
index 843421b..145a5ce 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
@@ -134,14 +134,7 @@ final class LatLonPointDistanceQuery extends Query {
         
         // approximation (postfiltering has not yet been applied)
         DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());
-        // subset of documents that need no postfiltering, this is purely an optimization
-        final BitSet preApproved;
-        // dumb heuristic: if the field is really sparse, use a sparse impl
-        if (values.getDocCount(field) * 100L < reader.maxDoc()) {
-          preApproved = new SparseFixedBitSet(reader.maxDoc());
-        } else {
-          preApproved = new FixedBitSet(reader.maxDoc());
-        }
+
         values.intersect(field,
                          new IntersectVisitor() {
                            @Override
@@ -152,14 +145,11 @@ final class LatLonPointDistanceQuery extends Query {
                            @Override
                            public void visit(int docID) {
                              result.add(docID);
-                             preApproved.set(docID);
                            }
 
                            @Override
                            public void visit(int docID, byte[] packedValue) {
-                             // we bounds check individual values, as subtrees may cross, but we are being sent the values anyway:
-                             // this reduces the amount of docvalues fetches (improves approximation)
-
+                             // bounding box check
                              if (StringHelper.compare(Integer.BYTES, packedValue, 0, maxLat, 0) > 0 ||
                                  StringHelper.compare(Integer.BYTES, packedValue, 0, minLat, 0) < 0) {
                                // latitude out of bounding box range
@@ -172,8 +162,18 @@ final class LatLonPointDistanceQuery extends Query {
                                // longitude out of bounding box range
                                return;
                              }
-
-                             result.add(docID);
+                             
+                             double docLatitude = decodeLatitude(packedValue, 0);
+                             double docLongitude = decodeLongitude(packedValue, Integer.BYTES);
+
+                             // first check the partial distance, if its more than that, it can't be <= radiusMeters
+                             double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);
+                             if (h1 <= maxPartialDistance) {
+                               // fully confirm with part 2:
+                               if (SloppyMath.haversinMeters(h1) <= radiusMeters) {
+                                 result.add(docID);
+                               }
+                             }
                            }
                            
                            // algorithm: we create a bounding box (two bounding boxes if we cross the dateline).
@@ -231,44 +231,7 @@ final class LatLonPointDistanceQuery extends Query {
         if (disi == null) {
           return null;
         }
-
-        // return two-phase iterator using docvalues to postfilter candidates
-        SortedNumericDocValues docValues = DocValues.getSortedNumeric(reader, field);
-        TwoPhaseIterator iterator = new TwoPhaseIterator(disi) {
-          @Override
-          public boolean matches() throws IOException {
-            int docId = disi.docID();
-            if (preApproved.get(docId)) {
-              return true;
-            } else {
-              docValues.setDocument(docId);
-              int count = docValues.count();
-              for (int i = 0; i < count; i++) {
-                long encoded = docValues.valueAt(i);
-                double docLatitude = decodeLatitude((int)(encoded >> 32));
-                double docLongitude = decodeLongitude((int)(encoded & 0xFFFFFFFF));
-
-                // first check the partial distance, if its more than that, it can't be <= radiusMeters
-                double h1 = SloppyMath.haversinSortKey(latitude, longitude, docLatitude, docLongitude);
-                if (h1 > maxPartialDistance) {
-                  continue;
-                }
-
-                // fully confirm with part 2:
-                if (SloppyMath.haversinMeters(h1) <= radiusMeters) {
-                  return true;
-                }
-              }
-              return false;
-            }
-          }
-
-          @Override
-          public float matchCost() {
-            return 20; // TODO: make this fancier
-          }
-        };
-        return new ConstantScoreScorer(this, score(), iterator);
+        return new ConstantScoreScorer(this, score(), disi);
       }
     };
   }
