Index: lucene/src/java/org/apache/lucene/index/FieldsWriter.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/FieldsWriter.java	(revision 1236678)
+++ lucene/src/java/org/apache/lucene/index/FieldsWriter.java	(working copy)
@@ -121,6 +121,13 @@
     fieldsStream.writeVInt(0);
   }
 
+  void finish(int numDocs) throws IOException {
+    if (4 + ((long) numDocs) * 8 != indexStream.getFilePointer()) {
+      String fieldsIdxName = IndexFileNames.segmentFileName(segment,  IndexFileNames.FIELDS_INDEX_EXTENSION);
+      throw new RuntimeException("after flush: fdx size mismatch: " + numDocs + " docs vs " + indexStream.getFilePointer() + " length in bytes of " + fieldsIdxName + " file exists?=" + directory.fileExists(fieldsIdxName));
+    }
+  }
+
   void close() throws IOException {
     if (directory != null) {
       try {
Index: lucene/src/java/org/apache/lucene/index/SegmentMerger.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/SegmentMerger.java	(revision 1236678)
+++ lucene/src/java/org/apache/lucene/index/SegmentMerger.java	(working copy)
@@ -227,21 +227,11 @@
                                             reader, matchingFieldsReader);
         }
       }
+      fieldsWriter.finish(docCount);
     } finally {
       fieldsWriter.close();
     }
 
-    final String fileName = IndexFileNames.segmentFileName(segment, IndexFileNames.FIELDS_INDEX_EXTENSION);
-    final long fdxFileLength = directory.fileLength(fileName);
-
-    if (4+((long) docCount)*8 != fdxFileLength)
-      // This is most likely a bug in Sun JRE 1.6.0_04/_05;
-      // we detect that the bug has struck, here, and
-      // throw an exception to prevent the corruption from
-      // entering the index.  See LUCENE-1282 for
-      // details.
-      throw new RuntimeException("mergeFields produced an invalid result: docCount is " + docCount + " but fdx file size is " + fdxFileLength + " file=" + fileName + " file exists?=" + directory.fileExists(fileName) + "; now aborting this merge to prevent index corruption");
-
     segmentWriteState = new SegmentWriteState(null, directory, segment, fieldInfos, docCount, termIndexInterval, null);
     return docCount;
   }
@@ -348,20 +338,10 @@
           
         }
       }
+      termVectorsWriter.finish(mergedDocs);
     } finally {
       termVectorsWriter.close();
     }
-
-    final String fileName = IndexFileNames.segmentFileName(segment, IndexFileNames.VECTORS_INDEX_EXTENSION);
-    final long tvxSize = directory.fileLength(fileName);
-
-    if (4+((long) mergedDocs)*16 != tvxSize)
-      // This is most likely a bug in Sun JRE 1.6.0_04/_05;
-      // we detect that the bug has struck, here, and
-      // throw an exception to prevent the corruption from
-      // entering the index.  See LUCENE-1282 for
-      // details.
-      throw new RuntimeException("mergeVectors produced an invalid result: mergedDocs is " + mergedDocs + " but tvx size is " + tvxSize + " file=" + fileName + " file exists?=" + directory.fileExists(fileName) + "; now aborting this merge to prevent index corruption");
   }
 
   private void copyVectorsWithDeletions(final TermVectorsWriter termVectorsWriter,
Index: lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriter.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriter.java	(revision 1236678)
+++ lucene/src/java/org/apache/lucene/index/TermVectorsTermsWriter.java	(working copy)
@@ -52,13 +52,16 @@
   synchronized void flush(Map<TermsHashConsumerPerThread,Collection<TermsHashConsumerPerField>> threadsAndFields, final SegmentWriteState state) throws IOException {
     if (tvx != null) {
       // At least one doc in this run had term vectors enabled
+      assert state.segmentName != null;
       fill(state.numDocs);
-      IOUtils.close(tvx, tvf, tvd);
-      tvx = tvd = tvf = null;
-      assert state.segmentName != null;
-      String idxName = IndexFileNames.segmentFileName(state.segmentName, IndexFileNames.VECTORS_INDEX_EXTENSION);
-      if (4 + ((long) state.numDocs) * 16 != state.directory.fileLength(idxName)) {
-        throw new RuntimeException("after flush: tvx size mismatch: " + state.numDocs + " docs vs " + state.directory.fileLength(idxName) + " length in bytes of " + idxName + " file exists?=" + state.directory.fileExists(idxName));
+      try {
+        if (4 + ((long) state.numDocs) * 16 != tvx.getFilePointer()) {
+          String idxName = IndexFileNames.segmentFileName(state.segmentName, IndexFileNames.VECTORS_INDEX_EXTENSION);
+          throw new RuntimeException("after flush: tvx size mismatch: " + state.numDocs + " docs vs " + tvx.getFilePointer() + " length in bytes of " + idxName + " file exists?=" + state.directory.fileExists(idxName));
+        }
+      } finally {
+        IOUtils.close(tvx, tvf, tvd);
+        tvx = tvd = tvf = null;
       }
 
       lastDocID = 0;
Index: lucene/src/java/org/apache/lucene/index/TermVectorsWriter.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/TermVectorsWriter.java	(revision 1236678)
+++ lucene/src/java/org/apache/lucene/index/TermVectorsWriter.java	(working copy)
@@ -31,9 +31,14 @@
   private FieldInfos fieldInfos;
   final UnicodeUtil.UTF8Result[] utf8Results = new UnicodeUtil.UTF8Result[] {new UnicodeUtil.UTF8Result(),
                                                                              new UnicodeUtil.UTF8Result()};
+  // used only by assert/checks
+  final String segment;
+  final Directory directory;
 
   public TermVectorsWriter(Directory directory, String segment,
                            FieldInfos fieldInfos) throws IOException {
+    this.segment = segment;
+    this.directory = directory;
     boolean success = false;
     try {
       // Open files for TermVector storage
@@ -197,6 +202,18 @@
     assert tvf.getFilePointer() == tvfPosition;
   }
   
+  void finish(int numDocs) throws IOException {
+    if (4 + ((long) numDocs) * 16 != tvx.getFilePointer()) {
+      String idxName = IndexFileNames.segmentFileName(segment, IndexFileNames.VECTORS_INDEX_EXTENSION);
+      // This is most likely a bug in Sun JRE 1.6.0_04/_05;
+      // we detect that the bug has struck, here, and
+      // throw an exception to prevent the corruption from
+      // entering the index.  See LUCENE-1282 for
+      // details.
+      throw new RuntimeException("ergeVectors produced an invalid result: mergedDocs is " + numDocs + " docs vs " + tvx.getFilePointer() + " length in bytes of " + idxName + " file exists?=" + directory.fileExists(idxName));
+    }
+  }
+  
   /** Close all streams. */
   final void close() throws IOException {
     // make an effort to close all streams we can but remember and re-throw
Index: lucene/src/java/org/apache/lucene/index/StoredFieldsWriter.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/StoredFieldsWriter.java	(revision 1236678)
+++ lucene/src/java/org/apache/lucene/index/StoredFieldsWriter.java	(working copy)
@@ -49,13 +49,12 @@
     }
 
     if (fieldsWriter != null) {
-      fieldsWriter.close();
-      fieldsWriter = null;
-      lastDocID = 0;
-
-      String fieldsIdxName = IndexFileNames.segmentFileName(state.segmentName, IndexFileNames.FIELDS_INDEX_EXTENSION);
-      if (4 + ((long) state.numDocs) * 8 != state.directory.fileLength(fieldsIdxName)) {
-        throw new RuntimeException("after flush: fdx size mismatch: " + state.numDocs + " docs vs " + state.directory.fileLength(fieldsIdxName) + " length in bytes of " + fieldsIdxName + " file exists?=" + state.directory.fileExists(fieldsIdxName));
+      try {
+        fieldsWriter.finish(state.numDocs);
+      } finally {
+        fieldsWriter.close();
+        fieldsWriter = null;
+        lastDocID = 0;
       }
     }
   }
