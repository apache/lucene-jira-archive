diff --git a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
index bfc0808..5cd1671 100644
--- a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
+++ b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
@@ -17,15 +17,6 @@ package org.apache.lucene.search.payloads;
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.TreeSet;
-
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.LeafReaderContext;
@@ -34,6 +25,7 @@ import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.DisjunctionMaxQuery;
+import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.FilteredQuery;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MultiPhraseQuery;
@@ -46,6 +38,15 @@ import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.Spans;
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeSet;
+
 /**
  * Experimental class to get set of payloads for most standard Lucene queries.
  * Operates like Highlighter - IndexReader should only contain doc of interest,
@@ -190,7 +191,7 @@ public class PayloadSpanUtil {
     for (LeafReaderContext leafReaderContext : context.leaves()) {
       final Spans spans = query.getSpans(leafReaderContext, leafReaderContext.reader().getLiveDocs(), termContexts);
       if (spans != null) {
-        while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+        while (spans.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
           while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
             if (spans.isPayloadAvailable()) {
               Collection<byte[]> payload = spans.getPayload();
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java
index 8f600a4..8e2cac9 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java
@@ -17,17 +17,18 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.List;
-
-import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.ConjunctionDISI;
+import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.TwoPhaseIterator;
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
 /**
  * Common super class for multiple sub spans required in a document.
  */
-abstract class ConjunctionSpans extends Spans {
+abstract class ConjunctionSpans implements Spans {
   final Spans[] subSpans; // in query order
   final DocIdSetIterator conjunction; // use to move to next doc with all clauses
   boolean atFirstInCurrentDoc; // a first start position is available in current doc for nextStartPosition
@@ -38,10 +39,18 @@ abstract class ConjunctionSpans extends Spans {
       throw new IllegalArgumentException("Less than 2 subSpans.size():" + subSpans.size());
     }
     this.subSpans = subSpans.toArray(new Spans[subSpans.size()]);
-    this.conjunction = ConjunctionDISI.intersect(subSpans);
+    this.conjunction = ConjunctionDISI.intersect(buildIteratorList(subSpans));
     this.atFirstInCurrentDoc = true; // ensure for doc -1 that start/end positions are -1
   }
 
+  private List<DocIdSetIterator> buildIteratorList(List<Spans> spans) {
+    List<DocIdSetIterator> iterators = new ArrayList<>(spans.size());
+    for (Spans s : spans) {
+      iterators.add(new Spans.Iterator(s));
+    }
+    return iterators;
+  }
+
   @Override
   public int docID() {
     return conjunction.docID();
@@ -54,15 +63,15 @@ abstract class ConjunctionSpans extends Spans {
 
   @Override
   public int nextDoc() throws IOException {
-    return (conjunction.nextDoc() == NO_MORE_DOCS)
-            ? NO_MORE_DOCS
+    return (conjunction.nextDoc() == DocIdSetIterator.NO_MORE_DOCS)
+            ? DocIdSetIterator.NO_MORE_DOCS
             : toMatchDoc();
   }
 
   @Override
   public int advance(int target) throws IOException {
-    return (conjunction.advance(target) == NO_MORE_DOCS)
-            ? NO_MORE_DOCS
+    return (conjunction.advance(target) == DocIdSetIterator.NO_MORE_DOCS)
+            ? DocIdSetIterator.NO_MORE_DOCS
             : toMatchDoc();
   }
 
@@ -72,8 +81,8 @@ abstract class ConjunctionSpans extends Spans {
       if (twoPhaseCurrentDocMatches()) {
         return docID();
       }
-      if (conjunction.nextDoc() == NO_MORE_DOCS) {
-        return NO_MORE_DOCS;
+      if (conjunction.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {
+        return DocIdSetIterator.NO_MORE_DOCS;
       }
     }
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
index 65c8b47..3b8a47d 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
@@ -57,4 +57,9 @@ abstract class ContainSpans extends ConjunctionSpans {
   public Collection<byte[]> getPayload() throws IOException {
     return sourceSpans.getPayload();
   }
+
+  @Override
+  public String toString() {
+    return Spans.buildSpansString(this);
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java
index af33e67..bf310d1 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java
@@ -17,17 +17,18 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.TwoPhaseIterator;
+
 import java.io.IOException;
 import java.util.Collection;
 import java.util.Objects;
 
-import org.apache.lucene.search.TwoPhaseIterator;
-
 /**
  * A {@link Spans} implementation wrapping another spans instance,
  * allowing to filter spans matches easily by implementing {@link #accept}
  */
-public abstract class FilterSpans extends Spans {
+public abstract class FilterSpans implements Spans {
  
   /** The wrapped spans instance. */
   protected final Spans in;
@@ -51,8 +52,8 @@ public abstract class FilterSpans extends Spans {
   public final int nextDoc() throws IOException {
     while (true) {
       int doc = in.nextDoc();
-      if (doc == NO_MORE_DOCS) {
-        return NO_MORE_DOCS;
+      if (doc == DocIdSetIterator.NO_MORE_DOCS) {
+        return DocIdSetIterator.NO_MORE_DOCS;
       } else if (twoPhaseCurrentDocMatches()) {
         return doc;
       }
@@ -62,7 +63,7 @@ public abstract class FilterSpans extends Spans {
   @Override
   public final int advance(int target) throws IOException {
     int doc = in.advance(target);
-    while (doc != NO_MORE_DOCS) {
+    while (doc != DocIdSetIterator.NO_MORE_DOCS) {
       if (twoPhaseCurrentDocMatches()) {
         break;
       }
@@ -145,7 +146,7 @@ public abstract class FilterSpans extends Spans {
     } else {
       // wrapped instance has no approximation, but 
       // we can still defer matching until absolutely needed.
-      return new TwoPhaseIterator(in) {
+      return new TwoPhaseIterator(new Spans.Iterator(in)) {
         @Override
         public boolean matches() throws IOException {
           return twoPhaseCurrentDocMatches();
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
index bd22c30..1d44590 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
@@ -72,7 +72,7 @@ public class NearSpansUnordered extends NearSpans {
   private int totalSpanLength;
   private SpansCell maxEndPositionCell;
 
-  private class SpansCell extends Spans {
+  private class SpansCell implements Spans {
     private int spanLength = -1;
     final Spans in;
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
index 9d0d09a..606ba94 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
@@ -17,26 +17,25 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
-import java.io.IOException;
-
-import java.util.List;
-import java.util.Collection;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.ToStringUtils;
-import org.apache.lucene.search.Query;
 import org.apache.lucene.search.DisiPriorityQueue;
 import org.apache.lucene.search.DisiWrapper;
-import org.apache.lucene.search.TwoPhaseIterator;
 import org.apache.lucene.search.DisjunctionDISIApproximation;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.ToStringUtils;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 
 
 /** Matches the union of its clauses.
@@ -169,9 +168,9 @@ public class SpanOrQuery extends SpanQuery implements Cloneable {
       return subSpans.get(0);
     }
 
-    DisiPriorityQueue<Spans> byDocQueue = new DisiPriorityQueue<>(subSpans.size());
+    DisiPriorityQueue<Spans.Iterator> byDocQueue = new DisiPriorityQueue<>(subSpans.size());
     for (Spans spans : subSpans) {
-      byDocQueue.add(new DisiWrapper<>(spans));
+      byDocQueue.add(new DisiWrapper<>(new Spans.Iterator(spans)));
     }
 
     SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1
@@ -182,7 +181,7 @@ public class SpanOrQuery extends SpanQuery implements Cloneable {
       @Override
       public int nextDoc() throws IOException {
         topPositionSpans = null;
-        DisiWrapper<Spans> topDocSpans = byDocQueue.top();
+        DisiWrapper<Spans.Iterator> topDocSpans = byDocQueue.top();
         int currentDoc = topDocSpans.doc;
         do {
           topDocSpans.doc = topDocSpans.iterator.nextDoc();
@@ -194,7 +193,7 @@ public class SpanOrQuery extends SpanQuery implements Cloneable {
       @Override
       public int advance(int target) throws IOException {
         topPositionSpans = null;
-        DisiWrapper<Spans> topDocSpans = byDocQueue.top();
+        DisiWrapper<Spans.Iterator> topDocSpans = byDocQueue.top();
         do {
           topDocSpans.doc = topDocSpans.iterator.advance(target);
           topDocSpans = byDocQueue.updateTop();
@@ -204,14 +203,14 @@ public class SpanOrQuery extends SpanQuery implements Cloneable {
 
       @Override
       public int docID() {
-        DisiWrapper<Spans> topDocSpans = byDocQueue.top();
+        DisiWrapper<Spans.Iterator> topDocSpans = byDocQueue.top();
         return topDocSpans.doc;
       }
 
       @Override
       public TwoPhaseIterator asTwoPhaseIterator() {
         boolean hasApproximation = false;
-        for (DisiWrapper<Spans> w : byDocQueue) {
+        for (DisiWrapper<Spans.Iterator> w : byDocQueue) {
           if (w.twoPhaseView != null) {
             hasApproximation = true;
             break;
@@ -222,7 +221,7 @@ public class SpanOrQuery extends SpanQuery implements Cloneable {
           return null;
         }
 
-        return new TwoPhaseIterator(new DisjunctionDISIApproximation<Spans>(byDocQueue)) {
+        return new TwoPhaseIterator(new DisjunctionDISIApproximation<Spans.Iterator>(byDocQueue)) {
           @Override
           public boolean matches() throws IOException {
             return twoPhaseCurrentDocMatches();
@@ -233,7 +232,7 @@ public class SpanOrQuery extends SpanQuery implements Cloneable {
       int lastDocTwoPhaseMatched = -1;
 
       boolean twoPhaseCurrentDocMatches() throws IOException {
-        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();
+        DisiWrapper<Spans.Iterator> listAtCurrentDoc = byDocQueue.topList();
         // remove the head of the list as long as it does not match
         final int currentDoc = listAtCurrentDoc.doc;
         while (listAtCurrentDoc.twoPhaseView != null) {
@@ -257,9 +256,9 @@ public class SpanOrQuery extends SpanQuery implements Cloneable {
       void fillPositionQueue() throws IOException { // called at first nextStartPosition
         assert byPositionQueue.size() == 0;
         // add all matching Spans at current doc to byPositionQueue
-        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();
+        DisiWrapper<Spans.Iterator> listAtCurrentDoc = byDocQueue.topList();
         while (listAtCurrentDoc != null) {
-          Spans spansAtDoc = listAtCurrentDoc.iterator;
+          Spans spansAtDoc = listAtCurrentDoc.iterator.spans;
           if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation
             if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation
               if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java b/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
index 7bf1123..ca77d64 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
@@ -17,18 +17,19 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.Collection;
-
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.TwoPhaseIterator;
 
+import java.io.IOException;
+import java.util.Collection;
+
 /** Iterates through combinations of start/end positions per-doc.
  *  Each start/end position represents a range of term positions within the current document.
  *  These are enumerated in order, by increasing document number, within that by
  *  increasing start position and finally by increasing end position.
  */
-public abstract class Spans extends DocIdSetIterator {
+public interface Spans {
+
   public static final int NO_MORE_POSITIONS = Integer.MAX_VALUE;
 
   /**
@@ -36,19 +37,19 @@ public abstract class Spans extends DocIdSetIterator {
    * There is always at least one start/end position per doc.
    * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
    */
-  public abstract int nextStartPosition() throws IOException;
+  public int nextStartPosition() throws IOException;
 
   /**
    * Returns the start position in the current doc, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
    * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
    */
-  public abstract int startPosition();
+  public int startPosition();
 
   /**
    * Returns the end position for the current start position, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
    * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
    */
-  public abstract int endPosition();
+  public int endPosition();
 
   /**
    * Returns the payload data for the current start/end position.
@@ -66,7 +67,7 @@ public abstract class Spans extends DocIdSetIterator {
    * @return a List of byte arrays containing the data of this payload, otherwise null if isPayloadAvailable is false
    * @throws IOException if there is a low-level I/O error
    */
-  public abstract Collection<byte[]> getPayload() throws IOException;
+  public Collection<byte[]> getPayload() throws IOException;
 
   /**
    * Checks if a payload can be loaded at the current start/end position.
@@ -77,7 +78,7 @@ public abstract class Spans extends DocIdSetIterator {
    * @return true if there is a payload available at this start/end position
    *              that can be loaded
    */
-  public abstract boolean isPayloadAvailable() throws IOException;
+  public boolean isPayloadAvailable() throws IOException;
 
   /**
    * Optional method: Return a {@link TwoPhaseIterator} view of this
@@ -95,19 +96,113 @@ public abstract class Spans extends DocIdSetIterator {
    *
    * The default implementation returns {@code null}.
    */
-  public TwoPhaseIterator asTwoPhaseIterator() {
-    return null;
-  }
+  public TwoPhaseIterator asTwoPhaseIterator();
+
+  /**
+   * Returns the following:
+   * <ul>
+   * <li><code>-1</code> if {@link #nextDoc()} or
+   * {@link #advance(int)} were not called yet.
+   * <li>{@link org.apache.lucene.search.DocIdSetIterator#NO_MORE_DOCS} if the iterator has exhausted.
+   * <li>Otherwise it should return the doc ID it is currently on.
+   * </ul>
+   * <p>
+   *
+   * @since 2.9
+   */
+  public abstract int docID();
+
+  /**
+   * Advances to the next document in the set and returns the doc it is
+   * currently on, or {@link org.apache.lucene.search.DocIdSetIterator#NO_MORE_DOCS} if there are no more docs in the
+   * set.<br>
+   *
+   * <b>NOTE:</b> after the iterator has exhausted you should not call this
+   * method, as it may result in unpredicted behavior.
+   *
+   * @since 2.9
+   */
+  public abstract int nextDoc() throws IOException;
 
-  @Override
-  public String toString() {
+  /**
+   * Advances to the first beyond the current whose document number is greater
+   * than or equal to <i>target</i>, and returns the document number itself.
+   * Exhausts the iterator and returns {@link org.apache.lucene.search.DocIdSetIterator#NO_MORE_DOCS} if <i>target</i>
+   * is greater than the highest document number in the set.
+   * <p>
+   * The behavior of this method is <b>undefined</b> when called with
+   * <code> target &le; current</code>, or after the iterator has exhausted.
+   * Both cases may result in unpredicted behavior.
+   * <p>
+   * When <code> target &gt; current</code> it behaves as if written:
+   *
+   * <pre class="prettyprint">
+   * int advance(int target) {
+   *   int doc;
+   *   while ((doc = nextDoc()) &lt; target) {
+   *   }
+   *   return doc;
+   * }
+   * </pre>
+   *
+   * Some implementations are considerably more efficient than that.
+   * <p>
+   * <b>NOTE:</b> this method may be called with {@link org.apache.lucene.search.DocIdSetIterator#NO_MORE_DOCS} for
+   * efficiency by some Scorers. If your implementation cannot efficiently
+   * determine that it should exhaust, it is recommended that you check for that
+   * value in each call to this method.
+   * <p>
+   *
+   * @since 2.9
+   */
+  public int advance(int target) throws IOException;
+
+  /**
+   * Returns the estimated cost of this {@link DocIdSetIterator}.
+   * <p>
+   * This is generally an upper bound of the number of documents this iterator
+   * might match, but may be a rough heuristic, hardcoded value, or otherwise
+   * completely inaccurate.
+   */
+  public long cost();
+  
+  public static String buildSpansString(Spans spans) {
     StringBuilder sb = new StringBuilder();
-    Class<? extends Spans> clazz = getClass();
+    Class<? extends Spans> clazz = spans.getClass();
     sb.append(clazz.isAnonymousClass() ? clazz.getName() : clazz.getSimpleName());
-    sb.append("(doc=").append(docID());
-    sb.append(",start=").append(startPosition());
-    sb.append(",end=").append(endPosition());
+    sb.append("(doc=").append(spans.docID());
+    sb.append(",start=").append(spans.startPosition());
+    sb.append(",end=").append(spans.endPosition());
     sb.append(")");
     return sb.toString();
   }
+
+  public static class Iterator extends DocIdSetIterator {
+
+    public final Spans spans;
+
+    public Iterator(Spans spans) {
+      this.spans = spans;
+    }
+
+    @Override
+    public int docID() {
+      return spans.docID();
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      return spans.nextDoc();
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      return spans.advance(target);
+    }
+
+    @Override
+    public long cost() {
+      return spans.cost();
+    }
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
index 5351b3d..1303c17 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
@@ -19,6 +19,7 @@ package org.apache.lucene.search.spans;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.TwoPhaseIterator;
 import org.apache.lucene.util.BytesRef;
 
 import java.io.IOException;
@@ -31,7 +32,7 @@ import java.util.Objects;
  * Public for extension only.
  * This does not work correctly for terms that indexed at position Integer.MAX_VALUE.
  */
-public class TermSpans extends Spans {
+public class TermSpans implements Spans {
   protected final PostingsEnum postings;
   protected final Term term;
   protected int doc;
@@ -129,9 +130,14 @@ public class TermSpans extends Spans {
   }
 
   @Override
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    return null;
+  }
+
+  @Override
   public String toString() {
     return "spans(" + term.toString() + ")@" +
-            (doc == -1 ? "START" : (doc == NO_MORE_DOCS) ? "ENDDOC"
+            (doc == -1 ? "START" : (doc == DocIdSetIterator.NO_MORE_DOCS) ? "ENDDOC"
               : doc + " - " + (position == NO_MORE_POSITIONS ? "ENDPOS" : position));
   }
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java b/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java
index dc1b2f3..3c56716 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java
@@ -17,34 +17,36 @@ package org.apache.lucene.search;
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.io.StringReader;
-import java.nio.charset.StandardCharsets;
-import java.util.Collection;
-
-import org.apache.lucene.analysis.*;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockPayloadAnalyzer;
+import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.PostingsEnum;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.SlowCompositeReaderWrapper;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.store.Directory;
 import org.apache.lucene.search.payloads.PayloadSpanUtil;
 import org.apache.lucene.search.spans.MultiSpansWrapper;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.Spans;
-import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.LuceneTestCase;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Collection;
 
 /**
  * Term position unit test.
@@ -239,7 +241,7 @@ public class TestPositionIncrement extends LuceneTestCase {
       System.out.println("\ngetPayloadSpans test");
     }
     Spans pspans = MultiSpansWrapper.wrap(is.getIndexReader(), snq);
-    while (pspans.nextDoc() != Spans.NO_MORE_DOCS) {
+    while (pspans.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
       while (pspans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
         if (VERBOSE) {
           System.out.println("doc " + pspans.docID() + ": span " + pspans.startPosition()
@@ -262,7 +264,7 @@ public class TestPositionIncrement extends LuceneTestCase {
     Spans spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq);
     count = 0;
     sawZero = false;
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+    while (spans.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
       while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
         count++;
         sawZero |= spans.startPosition() == 0;
diff --git a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java
index d351680..43c3894 100644
--- a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadSpans.java
@@ -16,32 +16,24 @@ package org.apache.lucene.search.payloads;
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.io.StringReader;
-import java.nio.charset.StandardCharsets;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
-
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.analysis.TokenFilter;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
-import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.payloads.PayloadHelper;
-import org.apache.lucene.search.payloads.PayloadSpanUtil;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.spans.MultiSpansWrapper;
@@ -55,6 +47,13 @@ import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
 
+import java.io.IOException;
+import java.io.StringReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
 public class TestPayloadSpans extends LuceneTestCase {
   private IndexSearcher searcher;
   private Similarity similarity = new DefaultSimilarity();
@@ -126,7 +125,7 @@ public class TestPayloadSpans extends LuceneTestCase {
     writer.close();
     
 
-    checkSpans(MultiSpansWrapper.wrap(reader, snq), 1,new int[]{2});
+    checkSpans(MultiSpansWrapper.wrap(reader, snq), 1, new int[]{2});
     reader.close();
     directory.close();
   }
@@ -147,7 +146,7 @@ public class TestPayloadSpans extends LuceneTestCase {
 
     spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), spanNearQuery);
     assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 2, new int[]{3,3});
+    checkSpans(spans, 2, new int[]{3, 3});
 
      
     clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
@@ -181,7 +180,7 @@ public class TestPayloadSpans extends LuceneTestCase {
 
     spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), nestedSpanNearQuery);
     assertTrue("spans is null and it shouldn't be", spans != null);
-    checkSpans(spans, 2, new int[]{3,3});
+    checkSpans(spans, 2, new int[]{3, 3});
     closeIndexReader.close();
     directory.close();
   }
@@ -277,7 +276,7 @@ public class TestPayloadSpans extends LuceneTestCase {
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
     for (int i = 0; i < topDocs.scoreDocs.length; i++) {
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+      while (spans.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
         while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
           Collection<byte[]> payloads = spans.getPayload();
   
@@ -315,7 +314,7 @@ public class TestPayloadSpans extends LuceneTestCase {
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
     for (int i = 0; i < topDocs.scoreDocs.length; i++) {
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+      while (spans.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
         while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
           Collection<byte[]> payloads = spans.getPayload();
   
@@ -353,7 +352,7 @@ public class TestPayloadSpans extends LuceneTestCase {
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
     for (int i = 0; i < topDocs.scoreDocs.length; i++) {
-      while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+      while (spans.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
         while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
           Collection<byte[]> payloads = spans.getPayload();
   
@@ -407,7 +406,7 @@ public class TestPayloadSpans extends LuceneTestCase {
     //each position match should have a span associated with it, since there is just one underlying term query, there should
     //only be one entry in the span
     int seen = 0;
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+    while (spans.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
       while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
         assertEquals("isPayloadAvailable should return true/false as payloads are expected", expectedNumPayloads > 0, spans.isPayloadAvailable());
         //See payload helper, for the PayloadHelper.FIELD field, there is a single byte payload at every token
@@ -449,7 +448,7 @@ public class TestPayloadSpans extends LuceneTestCase {
   private void checkSpans(Spans spans, int numSpans, int[] numPayloads) throws IOException {
     int cnt = 0;
 
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+    while (spans.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
       while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
         if(VERBOSE)
           System.out.println("\nSpans Dump --");
diff --git a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java
index 9f9f887..054691d 100644
--- a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java
@@ -17,6 +17,7 @@ package org.apache.lucene.search.payloads;
  */
 
 import org.apache.lucene.analysis.*;
+import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.English;
@@ -216,7 +217,7 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     //should be two matches per document
     int count = 0;
     //100 hits times 2 matches per hit, we should have 200 in count
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+    while (spans.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
       while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
         count++;
       }
@@ -260,7 +261,7 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     //should be two matches per document
     int count = 0;
     //100 hits times 2 matches per hit, we should have 200 in count
-    while (spans.nextDoc() != Spans.NO_MORE_DOCS) {
+    while (spans.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
       while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
         count++;
       }
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java
index b3fc9e4..167ceab 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/JustCompileSearchSpans.java
@@ -17,17 +17,18 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.Collection;
-import java.util.Map;
-import java.util.Set;
-
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.TwoPhaseIterator;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.util.Bits;
 
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+
 /**
  * Holds all implementations of classes in the o.a.l.s.spans package as a
  * back-compatibility test. It does not run any tests per-se, however if
@@ -39,7 +40,7 @@ final class JustCompileSearchSpans {
 
   private static final String UNSUPPORTED_MSG = "unsupported: used for back-compat testing only !";
 
-  static final class JustCompileSpans extends Spans {
+  static final class JustCompileSpans implements Spans {
 
     @Override
     public int docID() {
@@ -82,6 +83,11 @@ final class JustCompileSearchSpans {
     }
 
     @Override
+    public TwoPhaseIterator asTwoPhaseIterator() {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+
+    @Override
     public long cost() {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
@@ -111,7 +117,7 @@ final class JustCompileSearchSpans {
     
   }
 
-  static final class JustCompilePayloadSpans extends Spans {
+  static final class JustCompilePayloadSpans implements Spans {
 
     @Override
     public int docID() {
@@ -154,6 +160,11 @@ final class JustCompileSearchSpans {
     }
 
     @Override
+    public TwoPhaseIterator asTwoPhaseIterator() {
+      throw new UnsupportedOperationException(UNSUPPORTED_MSG);
+    }
+
+    @Override
     public long cost() {
       throw new UnsupportedOperationException(UNSUPPORTED_MSG);
     }
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java
index c7276e2..08b72a6 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java
@@ -17,9 +17,6 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
-import java.util.HashSet;
-import java.util.Set;
-
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
@@ -27,6 +24,7 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.QueryUtils;
@@ -36,7 +34,11 @@ import org.apache.lucene.util.LuceneTestCase;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
-import static org.apache.lucene.search.spans.SpanTestUtil.*;
+import java.util.HashSet;
+import java.util.Set;
+
+import static org.apache.lucene.search.spans.SpanTestUtil.assertFinished;
+import static org.apache.lucene.search.spans.SpanTestUtil.assertNext;
 
 public class TestFieldMaskingSpanQuery extends LuceneTestCase {
 
@@ -286,15 +288,15 @@ public class TestFieldMaskingSpanQuery extends LuceneTestCase {
     Spans spanA = MultiSpansWrapper.wrap(searcher.getIndexReader(), qA);
     Spans spanB = MultiSpansWrapper.wrap(searcher.getIndexReader(), qB);
     
-    while (spanA.nextDoc() != Spans.NO_MORE_DOCS) {
-      assertNotSame("spanB not still going", Spans.NO_MORE_DOCS, spanB.nextDoc());
+    while (spanA.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
+      assertNotSame("spanB not still going", DocIdSetIterator.NO_MORE_DOCS, spanB.nextDoc());
       while (spanA.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
         assertEquals("spanB start position", spanA.startPosition(), spanB.nextStartPosition());
         assertEquals("spanB end position", spanA.endPosition(), spanB.endPosition());
       }
       assertEquals("spanB start position", Spans.NO_MORE_POSITIONS, spanB.nextStartPosition());
     }
-    assertEquals("spanB end doc", Spans.NO_MORE_DOCS, spanB.nextDoc());
+    assertEquals("spanB end doc", DocIdSetIterator.NO_MORE_DOCS, spanB.nextDoc());
   }
   
   public void testSpans2() throws Exception {
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
index c6938b4..bd9f54d 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
@@ -26,6 +26,7 @@ import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Scorer;
@@ -135,34 +136,34 @@ public class TestNearSpansOrdered extends LuceneTestCase {
     assertEquals(1, span.advance(1));
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(1,0,4), s(span));
-    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
+    assertEquals(DocIdSetIterator.NO_MORE_DOCS, span.advance(2));
   }
   
   public void testNearSpansNextThenAdvance() throws Exception {
     SpanNearQuery q = makeQuery();
     Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
-    assertNotSame(Spans.NO_MORE_DOCS, span.nextDoc());
+    assertNotSame(DocIdSetIterator.NO_MORE_DOCS, span.nextDoc());
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(0,0,3), s(span));
-    assertNotSame(Spans.NO_MORE_DOCS, span.advance(1));
+    assertNotSame(DocIdSetIterator.NO_MORE_DOCS, span.advance(1));
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(1,0,4), s(span));
-    assertEquals(Spans.NO_MORE_DOCS, span.nextDoc());
+    assertEquals(DocIdSetIterator.NO_MORE_DOCS, span.nextDoc());
   }
   
   public void testNearSpansNextThenAdvancePast() throws Exception {
     SpanNearQuery q = makeQuery();
     Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
-    assertNotSame(Spans.NO_MORE_DOCS, span.nextDoc());
+    assertNotSame(DocIdSetIterator.NO_MORE_DOCS, span.nextDoc());
     assertEquals(0, span.nextStartPosition());
     assertEquals(s(0,0,3), s(span));
-    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
+    assertEquals(DocIdSetIterator.NO_MORE_DOCS, span.advance(2));
   }
   
   public void testNearSpansAdvancePast() throws Exception {
     SpanNearQuery q = makeQuery();
     Spans span = MultiSpansWrapper.wrap(searcher.getIndexReader(), q);
-    assertEquals(Spans.NO_MORE_DOCS, span.advance(2));
+    assertEquals(DocIdSetIterator.NO_MORE_DOCS, span.advance(2));
   }
   
   public void testNearSpansAdvanceTo0() throws Exception {
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanContainQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanContainQuery.java
index a27eb78..7fe231f 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanContainQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanContainQuery.java
@@ -23,6 +23,7 @@ import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.store.Directory;
@@ -81,7 +82,7 @@ public class TestSpanContainQuery extends LuceneTestCase {
   }
 
   void tstEqualSpans(String mes, Spans expected, Spans actual) throws Exception {
-    while (expected.nextDoc() != Spans.NO_MORE_DOCS) {
+    while (expected.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
       assertEquals(expected.docID(), actual.nextDoc());
       assertEquals(expected.docID(), actual.docID());
       while (expected.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
index d9d53f3..c1a8ee3 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
@@ -418,7 +418,7 @@ public class TestSpans extends LuceneTestCase {
 
      int i = 0;
      if (spans != null) {
-       while (spans.nextDoc() != Spans.NO_MORE_DOCS){
+       while (spans.nextDoc() != DocIdSetIterator.NO_MORE_DOCS){
          while (spans.nextStartPosition() != Spans.NO_MORE_POSITIONS) {
            i++;
          }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java
index 59c69b1..20a7e29 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java
@@ -17,17 +17,16 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.Collection;
-
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.TwoPhaseIterator;
-import org.apache.lucene.search.spans.Spans;
+
+import java.io.IOException;
+import java.util.Collection;
 
 /** 
  * Wraps a Spans with additional asserts 
  */
-class AssertingSpans extends Spans {
+class AssertingSpans implements Spans {
   final Spans in;
   int doc = -1;
   
@@ -62,7 +61,7 @@ class AssertingSpans extends Spans {
     POS_FINISHED,
     
     /** 
-     * documents exhausted ({@link #docID()} = {@link #NO_MORE_DOCS}) 
+     * documents exhausted ({@link #docID()} = {@link org.apache.lucene.search.DocIdSetIterator#NO_MORE_DOCS})
      */
     DOC_FINISHED 
   };
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java b/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
index 4e86f5b..66bf6ef 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/spans/SpanTestUtil.java
@@ -17,12 +17,13 @@ package org.apache.lucene.search.spans;
  * limitations under the License.
  */
 
-import java.io.IOException;
-
 import org.apache.lucene.index.Term;
+import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.QueryUtils;
 
-import static org.junit.Assert.*;
+import java.io.IOException;
+
+import static org.junit.Assert.assertEquals;
 
 /** Some utility methods used for testing span queries */
 public class SpanTestUtil {
@@ -152,12 +153,12 @@ public class SpanTestUtil {
         assertEquals("endPosition of previous doc", Spans.NO_MORE_POSITIONS, spans.endPosition());
       }
       assertEquals("nextDoc", doc, spans.nextDoc());
-      if (doc != Spans.NO_MORE_DOCS) {
+      if (doc != DocIdSetIterator.NO_MORE_DOCS) {
         assertEquals("first startPosition", -1, spans.startPosition());
         assertEquals("first endPosition", -1, spans.endPosition());
       }
     }
-    if (doc != Spans.NO_MORE_DOCS) {
+    if (doc != DocIdSetIterator.NO_MORE_DOCS) {
       assertEquals("nextStartPosition", start, spans.nextStartPosition());
       assertEquals("startPosition", start, spans.startPosition());
       assertEquals("endPosition", end, spans.endPosition());
@@ -169,7 +170,7 @@ public class SpanTestUtil {
    */
   public static void assertFinished(Spans spans) throws Exception {
     if (spans != null) { // null Spans is empty
-      assertNext(spans, Spans.NO_MORE_DOCS, -2, -2); // start and end positions will be ignored
+      assertNext(spans, DocIdSetIterator.NO_MORE_DOCS, -2, -2); // start and end positions will be ignored
     }
   }
 }
