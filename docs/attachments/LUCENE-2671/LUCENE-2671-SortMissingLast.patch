Index: lucene/src/java/org/apache/lucene/search/FieldComparator.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/FieldComparator.java	(revision 1001529)
+++ lucene/src/java/org/apache/lucene/search/FieldComparator.java	(working copy)
@@ -22,14 +22,22 @@
 import java.util.Locale;
 
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.FieldCache.DoubleParser;
-import org.apache.lucene.search.FieldCache.LongParser;
-import org.apache.lucene.search.FieldCache.ByteParser;
-import org.apache.lucene.search.FieldCache.FloatParser;
-import org.apache.lucene.search.FieldCache.IntParser;
-import org.apache.lucene.search.FieldCache.ShortParser;
 import org.apache.lucene.search.FieldCache.DocTermsIndex;
 import org.apache.lucene.search.FieldCache.DocTerms;
+import org.apache.lucene.search.cache.ByteValuesCreator;
+import org.apache.lucene.search.cache.CachedArray;
+import org.apache.lucene.search.cache.CachedArrayCreator;
+import org.apache.lucene.search.cache.DoubleValuesCreator;
+import org.apache.lucene.search.cache.FloatValuesCreator;
+import org.apache.lucene.search.cache.IntValuesCreator;
+import org.apache.lucene.search.cache.LongValuesCreator;
+import org.apache.lucene.search.cache.ShortValuesCreator;
+import org.apache.lucene.search.cache.CachedArray.ByteValues;
+import org.apache.lucene.search.cache.CachedArray.DoubleValues;
+import org.apache.lucene.search.cache.CachedArray.FloatValues;
+import org.apache.lucene.search.cache.CachedArray.IntValues;
+import org.apache.lucene.search.cache.CachedArray.LongValues;
+import org.apache.lucene.search.cache.CachedArray.ShortValues;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.packed.Direct8;
 import org.apache.lucene.util.packed.Direct16;
@@ -173,113 +181,128 @@
    */
   public abstract Comparable<?> value(int slot);
 
-  /** Parses field's values as byte (using {@link
-   *  FieldCache#getBytes} and sorts by ascending value */
-  public static final class ByteComparator extends FieldComparator {
-    private final byte[] values;
-    private byte[] currentReaderValues;
-    private final String field;
-    private ByteParser parser;
-    private byte bottom;
+    
+  /** Sorts by ascending docID */
+  public static final class DocComparator extends FieldComparator {
+    private final int[] docIDs;
+    private int docBase;
+    private int bottom;
 
-    ByteComparator(int numHits, String field, FieldCache.Parser parser) {
-      values = new byte[numHits];
-      this.field = field;
-      this.parser = (ByteParser) parser;
+    DocComparator(int numHits) {
+      docIDs = new int[numHits];
     }
 
     @Override
     public int compare(int slot1, int slot2) {
-      return values[slot1] - values[slot2];
+      // No overflow risk because docIDs are non-negative
+      return docIDs[slot1] - docIDs[slot2];
     }
 
     @Override
     public int compareBottom(int doc) {
-      return bottom - currentReaderValues[doc];
+      // No overflow risk because docIDs are non-negative
+      return bottom - (docBase + doc);
     }
 
     @Override
     public void copy(int slot, int doc) {
-      values[slot] = currentReaderValues[doc];
+      docIDs[slot] = docBase + doc;
     }
 
     @Override
-    public FieldComparator setNextReader(IndexReader reader, int docBase) throws IOException {
-      currentReaderValues = FieldCache.DEFAULT.getBytes(reader, field, parser);
+    public FieldComparator setNextReader(IndexReader reader, int docBase) {
+      // TODO: can we "map" our docIDs to the current
+      // reader? saves having to then subtract on every
+      // compare call
+      this.docBase = docBase;
       return this;
     }
     
     @Override
     public void setBottom(final int bottom) {
-      this.bottom = values[bottom];
+      this.bottom = docIDs[bottom];
     }
 
     @Override
     public Comparable<?> value(int slot) {
-      return Byte.valueOf(values[slot]);
+      return Integer.valueOf(docIDs[slot]);
     }
   }
 
-  /** Sorts by ascending docID */
-  public static final class DocComparator extends FieldComparator {
-    private final int[] docIDs;
-    private int docBase;
-    private int bottom;
+  public static abstract class NumericComparator<T extends CachedArray> extends FieldComparator {
+    protected final CachedArrayCreator<T> creator;
+    protected T cached;
+    protected final boolean checkMissing;
+    
+    public NumericComparator( CachedArrayCreator<T> c, boolean checkMissing ) {
+      this.creator = c;
+      this.checkMissing = checkMissing;
+    }
+  }
 
-    DocComparator(int numHits) {
-      docIDs = new int[numHits];
+  /** Parses field's values as byte (using {@link
+   *  FieldCache#getBytes} and sorts by ascending value */
+  public static final class ByteComparator extends NumericComparator<ByteValues> {
+    private final byte[] values;
+    private final byte missingValue;
+    private byte bottom;
+
+    ByteComparator(int numHits, ByteValuesCreator creator, Byte missingValue ) {
+      super( creator, missingValue!=null );
+      values = new byte[numHits];
+      this.missingValue = checkMissing
+         ? missingValue.byteValue() : 0;
     }
 
     @Override
     public int compare(int slot1, int slot2) {
-      // No overflow risk because docIDs are non-negative
-      return docIDs[slot1] - docIDs[slot2];
+      return values[slot1] - values[slot2];
     }
 
     @Override
     public int compareBottom(int doc) {
-      // No overflow risk because docIDs are non-negative
-      return bottom - (docBase + doc);
+      final byte v2 = (checkMissing && !cached.valid.get(doc)) 
+        ? missingValue : cached.values[doc];
+      return bottom - v2;
     }
 
     @Override
     public void copy(int slot, int doc) {
-      docIDs[slot] = docBase + doc;
+      values[slot] = ( checkMissing && cached.valid != null && !cached.valid.get(doc) )
+        ? missingValue : cached.values[doc];
     }
 
     @Override
-    public FieldComparator setNextReader(IndexReader reader, int docBase) {
-      // TODO: can we "map" our docIDs to the current
-      // reader? saves having to then subtract on every
-      // compare call
-      this.docBase = docBase;
+    public FieldComparator setNextReader(IndexReader reader, int docBase) throws IOException {
+      cached = FieldCache.DEFAULT.getBytes(reader, creator.field, creator );
       return this;
     }
     
     @Override
     public void setBottom(final int bottom) {
-      this.bottom = docIDs[bottom];
+      this.bottom = values[bottom];
     }
 
     @Override
     public Comparable<?> value(int slot) {
-      return Integer.valueOf(docIDs[slot]);
+      return Byte.valueOf(values[slot]);
     }
   }
 
+  
   /** Parses field's values as double (using {@link
    *  FieldCache#getDoubles} and sorts by ascending value */
-  public static final class DoubleComparator extends FieldComparator {
+  public static final class DoubleComparator extends NumericComparator<DoubleValues> {
     private final double[] values;
-    private double[] currentReaderValues;
-    private final String field;
-    private DoubleParser parser;
+    private final double missingValue;
     private double bottom;
 
-    DoubleComparator(int numHits, String field, FieldCache.Parser parser) {
+
+    DoubleComparator(int numHits, DoubleValuesCreator creator, Double missingValue ) {
+      super( creator, missingValue != null );
       values = new double[numHits];
-      this.field = field;
-      this.parser = (DoubleParser) parser;
+      this.missingValue = checkMissing
+        ? missingValue.doubleValue() : 0;
     }
 
     @Override
@@ -297,7 +320,9 @@
 
     @Override
     public int compareBottom(int doc) {
-      final double v2 = currentReaderValues[doc];
+      final double v2 = (checkMissing && !cached.valid.get(doc)) 
+        ? missingValue : cached.values[doc];
+      
       if (bottom > v2) {
         return 1;
       } else if (bottom < v2) {
@@ -309,12 +334,13 @@
 
     @Override
     public void copy(int slot, int doc) {
-      values[slot] = currentReaderValues[doc];
+      values[slot] = ( checkMissing && cached.valid != null && !cached.valid.get(doc) )
+        ? missingValue : cached.values[doc];
     }
 
     @Override
     public FieldComparator setNextReader(IndexReader reader, int docBase) throws IOException {
-      currentReaderValues = FieldCache.DEFAULT.getDoubles(reader, field, parser);
+      cached = FieldCache.DEFAULT.getDoubles(reader, creator.field, creator );
       return this;
     }
     
@@ -331,19 +357,18 @@
 
   /** Parses field's values as float (using {@link
    *  FieldCache#getFloats} and sorts by ascending value */
-  public static final class FloatComparator extends FieldComparator {
+  public static final class FloatComparator extends NumericComparator<FloatValues> {
     private final float[] values;
-    private float[] currentReaderValues;
-    private final String field;
-    private FloatParser parser;
+    private final float missingValue;
     private float bottom;
 
-    FloatComparator(int numHits, String field, FieldCache.Parser parser) {
+    FloatComparator(int numHits, FloatValuesCreator creator, Float missingValue ) {
+      super( creator, missingValue != null );
       values = new float[numHits];
-      this.field = field;
-      this.parser = (FloatParser) parser;
+      this.missingValue = checkMissing
+        ? missingValue.floatValue() : 0;
     }
-
+    
     @Override
     public int compare(int slot1, int slot2) {
       // TODO: are there sneaky non-branch ways to compute
@@ -361,9 +386,10 @@
 
     @Override
     public int compareBottom(int doc) {
-      // TODO: are there sneaky non-branch ways to compute
-      // sign of float?
-      final float v2 = currentReaderValues[doc];
+      // TODO: are there sneaky non-branch ways to compute sign of float?
+      final float v2 = (checkMissing && !cached.valid.get(doc)) 
+        ? missingValue : cached.values[doc];
+      
       if (bottom > v2) {
         return 1;
       } else if (bottom < v2) {
@@ -375,12 +401,13 @@
 
     @Override
     public void copy(int slot, int doc) {
-      values[slot] = currentReaderValues[doc];
+      values[slot] = ( checkMissing && cached.valid != null && !cached.valid.get(doc) )
+        ? missingValue : cached.values[doc];
     }
 
     @Override
     public FieldComparator setNextReader(IndexReader reader, int docBase) throws IOException {
-      currentReaderValues = FieldCache.DEFAULT.getFloats(reader, field, parser);
+      cached = FieldCache.DEFAULT.getFloats(reader, creator.field, creator );
       return this;
     }
     
@@ -397,19 +424,18 @@
 
   /** Parses field's values as int (using {@link
    *  FieldCache#getInts} and sorts by ascending value */
-  public static final class IntComparator extends FieldComparator {
+  public static final class IntComparator extends NumericComparator<IntValues> {
     private final int[] values;
-    private int[] currentReaderValues;
-    private final String field;
-    private IntParser parser;
     private int bottom;                           // Value of bottom of queue
-
-    IntComparator(int numHits, String field, FieldCache.Parser parser) {
+    final int missingValue;
+    
+    IntComparator(int numHits, IntValuesCreator creator, Integer missingValue ) {
+      super( creator, missingValue != null );
       values = new int[numHits];
-      this.field = field;
-      this.parser = (IntParser) parser;
+      this.missingValue = checkMissing
+        ? missingValue.intValue() : 0;
     }
-
+        
     @Override
     public int compare(int slot1, int slot2) {
       // TODO: there are sneaky non-branch ways to compute
@@ -433,7 +459,9 @@
       // -1/+1/0 sign
       // Cannot return bottom - values[slot2] because that
       // may overflow
-      final int v2 = currentReaderValues[doc];
+      final int v2 = (checkMissing && !cached.valid.get(doc)) 
+        ? missingValue : cached.values[doc];
+      
       if (bottom > v2) {
         return 1;
       } else if (bottom < v2) {
@@ -445,12 +473,13 @@
 
     @Override
     public void copy(int slot, int doc) {
-      values[slot] = currentReaderValues[doc];
+      values[slot] = ( checkMissing && cached.valid != null && !cached.valid.get(doc) )
+        ? missingValue : cached.values[doc];
     }
 
     @Override
     public FieldComparator setNextReader(IndexReader reader, int docBase) throws IOException {
-      currentReaderValues = FieldCache.DEFAULT.getInts(reader, field, parser);  
+      cached = FieldCache.DEFAULT.getInts(reader, creator.field, creator);  
       return this;
     }
     
@@ -467,19 +496,18 @@
 
   /** Parses field's values as long (using {@link
    *  FieldCache#getLongs} and sorts by ascending value */
-  public static final class LongComparator extends FieldComparator {
+  public static final class LongComparator extends NumericComparator<LongValues> {
     private final long[] values;
-    private long[] currentReaderValues;
-    private final String field;
-    private LongParser parser;
     private long bottom;
+    private final long missingValue;
 
-    LongComparator(int numHits, String field, FieldCache.Parser parser) {
+    LongComparator(int numHits, LongValuesCreator creator, Long missingValue ) {
+      super( creator, missingValue != null );
       values = new long[numHits];
-      this.field = field;
-      this.parser = (LongParser) parser;
+      this.missingValue = checkMissing
+        ? missingValue.longValue() : 0;
     }
-
+    
     @Override
     public int compare(int slot1, int slot2) {
       // TODO: there are sneaky non-branch ways to compute
@@ -499,7 +527,9 @@
     public int compareBottom(int doc) {
       // TODO: there are sneaky non-branch ways to compute
       // -1/+1/0 sign
-      final long v2 = currentReaderValues[doc];
+      final long v2 = (checkMissing && !cached.valid.get(doc)) 
+        ? missingValue : cached.values[doc];
+      
       if (bottom > v2) {
         return 1;
       } else if (bottom < v2) {
@@ -511,12 +541,13 @@
 
     @Override
     public void copy(int slot, int doc) {
-      values[slot] = currentReaderValues[doc];
+      values[slot] = ( checkMissing && cached.valid != null && !cached.valid.get(doc) )
+        ? missingValue : cached.values[doc];
     }
 
     @Override
     public FieldComparator setNextReader(IndexReader reader, int docBase) throws IOException {
-      currentReaderValues = FieldCache.DEFAULT.getLongs(reader, field, parser);
+      cached = FieldCache.DEFAULT.getLongs(reader, creator.field, creator);
       return this;
     }
     
@@ -589,17 +620,16 @@
 
   /** Parses field's values as short (using {@link
    *  FieldCache#getShorts} and sorts by ascending value */
-  public static final class ShortComparator extends FieldComparator {
+  public static final class ShortComparator extends NumericComparator<ShortValues> {
     private final short[] values;
-    private short[] currentReaderValues;
-    private final String field;
-    private ShortParser parser;
     private short bottom;
-
-    ShortComparator(int numHits, String field, FieldCache.Parser parser) {
+    private final short missingValue;
+    
+    ShortComparator(int numHits, ShortValuesCreator creator, Short missingValue ) {
+      super( creator, missingValue != null );
       values = new short[numHits];
-      this.field = field;
-      this.parser = (ShortParser) parser;
+      this.missingValue = checkMissing
+        ? missingValue.shortValue() : 0;
     }
 
     @Override
@@ -609,17 +639,21 @@
 
     @Override
     public int compareBottom(int doc) {
-      return bottom - currentReaderValues[doc];
+      final short v2 = (checkMissing && !cached.valid.get(doc)) 
+        ? missingValue : cached.values[doc];
+      
+      return bottom - v2;
     }
 
     @Override
     public void copy(int slot, int doc) {
-      values[slot] = currentReaderValues[doc];
+      values[slot] = ( checkMissing && cached.valid != null && !cached.valid.get(doc) )
+        ? missingValue : cached.values[doc];
     }
 
     @Override
     public FieldComparator setNextReader(IndexReader reader, int docBase) throws IOException {
-      currentReaderValues = FieldCache.DEFAULT.getShorts(reader, field, parser);
+      cached = FieldCache.DEFAULT.getShorts(reader, creator.field, creator );
       return this;
     }
     
Index: lucene/src/java/org/apache/lucene/search/SortField.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/SortField.java	(revision 1001529)
+++ lucene/src/java/org/apache/lucene/search/SortField.java	(working copy)
@@ -21,6 +21,13 @@
 import java.io.Serializable;
 import java.util.Locale;
 
+import org.apache.lucene.search.cache.ByteValuesCreator;
+import org.apache.lucene.search.cache.CachedArrayCreator;
+import org.apache.lucene.search.cache.DoubleValuesCreator;
+import org.apache.lucene.search.cache.FloatValuesCreator;
+import org.apache.lucene.search.cache.IntValuesCreator;
+import org.apache.lucene.search.cache.LongValuesCreator;
+import org.apache.lucene.search.cache.ShortValuesCreator;
 import org.apache.lucene.util.StringHelper;
 
 /**
@@ -93,7 +100,8 @@
   private int type;  // defaults to determining type dynamically
   private Locale locale;    // defaults to "natural order" (no Locale)
   boolean reverse = false;  // defaults to natural order
-  private FieldCache.Parser parser;
+  private CachedArrayCreator<?> creator;
+  public Object missingValue = null; // used for 'sortMissingFirst/Last'
 
   // Used for CUSTOM sort
   private FieldComparatorSource comparatorSource;
@@ -129,6 +137,8 @@
    *  by testing which numeric parser the parser subclasses.
    * @throws IllegalArgumentException if the parser fails to
    *  subclass an existing numeric parser, or field is null
+   *  
+   *  @deprecated use EntryCreator version
    */
   public SortField (String field, FieldCache.Parser parser) {
     this(field, parser, false);
@@ -144,21 +154,74 @@
    * @param reverse True if natural order should be reversed.
    * @throws IllegalArgumentException if the parser fails to
    *  subclass an existing numeric parser, or field is null
+   *  
+   *  @deprecated use EntryCreator version
    */
   public SortField (String field, FieldCache.Parser parser, boolean reverse) {
-    if (parser instanceof FieldCache.IntParser) initFieldType(field, INT);
-    else if (parser instanceof FieldCache.FloatParser) initFieldType(field, FLOAT);
-    else if (parser instanceof FieldCache.ShortParser) initFieldType(field, SHORT);
-    else if (parser instanceof FieldCache.ByteParser) initFieldType(field, BYTE);
-    else if (parser instanceof FieldCache.LongParser) initFieldType(field, LONG);
-    else if (parser instanceof FieldCache.DoubleParser) initFieldType(field, DOUBLE);
+    if (field == null) {
+      throw new IllegalArgumentException("field can only be null when type is SCORE or DOC");
+    } 
+    this.field = StringHelper.intern(field);
+    this.reverse = reverse;
+    
+    if (parser instanceof FieldCache.IntParser) {
+      this.type = INT;
+      this.creator = new IntValuesCreator( field, (FieldCache.IntParser)parser );
+    }
+    else if (parser instanceof FieldCache.FloatParser) {
+      this.type = FLOAT;
+      this.creator = new FloatValuesCreator( field, (FieldCache.FloatParser)parser );
+    }
+    else if (parser instanceof FieldCache.ShortParser) {
+      this.type = SHORT;
+      this.creator = new ShortValuesCreator( field, (FieldCache.ShortParser)parser );
+    }
+    else if (parser instanceof FieldCache.ByteParser) {
+      this.type = BYTE;
+      this.creator = new ByteValuesCreator( field, (FieldCache.ByteParser)parser );
+    }
+    else if (parser instanceof FieldCache.LongParser) {
+      this.type = LONG;
+      this.creator = new LongValuesCreator( field, (FieldCache.LongParser)parser );
+    }
+    else if (parser instanceof FieldCache.DoubleParser) {
+      this.type = DOUBLE;
+      this.creator = new DoubleValuesCreator( field, (FieldCache.DoubleParser)parser );
+    }
     else
       throw new IllegalArgumentException("Parser instance does not subclass existing numeric parser from FieldCache (got " + parser + ")");
 
+  }
+  
+  /**
+   * Sort by a cached entry value
+   * @param creator
+   * @param reverse
+   * @param sortMissingLast
+   */
+  public SortField( CachedArrayCreator<?> creator, boolean reverse ) 
+  {
+    this.field = StringHelper.intern(creator.field);
     this.reverse = reverse;
-    this.parser = parser;
+    this.creator = creator;
+    this.type = creator.getSortTypeID();
   }
+  
+  public SortField setMissingValue( Object v )
+  {
+    missingValue = v;
+    if( missingValue != null ) {
+      if( this.creator == null ) {
+        throw new IllegalArgumentException( "Missing value only works for sort fields with a CachedArray" );
+      }
 
+      // Set the flag to get bits 
+      creator.setFlag( CachedArrayCreator.OPTION_CACHE_BITS );
+    }
+    return this;
+  }
+  
+
   /** Creates a sort by terms in the given field sorted
    * according to the given locale.
    * @param field  Name of field to sort by, cannot be <code>null</code>.
@@ -210,6 +273,18 @@
     } else {
       this.field = StringHelper.intern(field);
     }
+    
+    if( creator != null ) {
+      throw new IllegalStateException( "creator already exists: "+creator );
+    }
+    switch( type ) {
+    case BYTE:   creator = new ByteValuesCreator( field, null ); break;
+    case SHORT:  creator = new ShortValuesCreator( field, null ); break;
+    case INT:    creator = new IntValuesCreator( field, null ); break;
+    case LONG:   creator = new LongValuesCreator( field, null ); break;
+    case FLOAT:  creator = new FloatValuesCreator( field, null ); break;
+    case DOUBLE: creator = new DoubleValuesCreator( field, null ); break;
+    }
   }
 
   /** Returns the name of the field.  Could return <code>null</code>
@@ -238,11 +313,16 @@
   /** Returns the instance of a {@link FieldCache} parser that fits to the given sort type.
    * May return <code>null</code> if no parser was specified. Sorting is using the default parser then.
    * @return An instance of a {@link FieldCache} parser, or <code>null</code>.
+   * @deprecated use getEntryCreator()
    */
   public FieldCache.Parser getParser() {
-    return parser;
+    return (creator==null) ? null : creator.getParser();
   }
 
+  public CachedArrayCreator<?> getEntryCreator() {
+    return creator;
+  }
+
   /** Returns whether the sort should be reversed.
    * @return  True if natural order should be reversed.
    */
@@ -311,7 +391,7 @@
     }
 
     if (locale != null) buffer.append('(').append(locale).append(')');
-    if (parser != null) buffer.append('(').append(parser).append(')');
+    if (creator != null) buffer.append('(').append(creator).append(')');
     if (reverse) buffer.append('!');
 
     return buffer.toString();
@@ -332,7 +412,7 @@
       && other.reverse == this.reverse
       && (other.locale == null ? this.locale == null : other.locale.equals(this.locale))
       && (other.comparatorSource == null ? this.comparatorSource == null : other.comparatorSource.equals(this.comparatorSource))
-      && (other.parser == null ? this.parser == null : other.parser.equals(this.parser))
+      && (other.creator == null ? this.creator == null : other.creator.equals(this.creator))
     );
   }
 
@@ -347,7 +427,7 @@
     if (field != null) hash += field.hashCode()^0xff5685dd;
     if (locale != null) hash += locale.hashCode()^0x08150815;
     if (comparatorSource != null) hash += comparatorSource.hashCode();
-    if (parser != null) hash += parser.hashCode()^0x3aaf56ff;
+    if (creator != null) hash += creator.hashCode()^0x3aaf56ff;
     return hash;
   }
 
@@ -387,22 +467,22 @@
       return new FieldComparator.DocComparator(numHits);
 
     case SortField.INT:
-      return new FieldComparator.IntComparator(numHits, field, parser);
+      return new FieldComparator.IntComparator(numHits, (IntValuesCreator)creator, (Integer)missingValue );
 
     case SortField.FLOAT:
-      return new FieldComparator.FloatComparator(numHits, field, parser);
+      return new FieldComparator.FloatComparator(numHits, (FloatValuesCreator)creator, (Float)missingValue );
 
     case SortField.LONG:
-      return new FieldComparator.LongComparator(numHits, field, parser);
+      return new FieldComparator.LongComparator(numHits, (LongValuesCreator)creator, (Long)missingValue );
 
     case SortField.DOUBLE:
-      return new FieldComparator.DoubleComparator(numHits, field, parser);
+      return new FieldComparator.DoubleComparator(numHits, (DoubleValuesCreator)creator, (Double)missingValue );
 
     case SortField.BYTE:
-      return new FieldComparator.ByteComparator(numHits, field, parser);
+      return new FieldComparator.ByteComparator(numHits, (ByteValuesCreator)creator, (Byte)missingValue );
 
     case SortField.SHORT:
-      return new FieldComparator.ShortComparator(numHits, field, parser);
+      return new FieldComparator.ShortComparator(numHits, (ShortValuesCreator)creator, (Short)missingValue );
 
     case SortField.CUSTOM:
       assert comparatorSource != null;
Index: lucene/src/test/org/apache/lucene/search/TestSort.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestSort.java	(revision 1001529)
+++ lucene/src/test/org/apache/lucene/search/TestSort.java	(working copy)
@@ -43,6 +43,13 @@
 import org.apache.lucene.queryParser.ParseException;
 import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.FieldValueHitQueue.Entry;
+import org.apache.lucene.search.cache.ByteValuesCreator;
+import org.apache.lucene.search.cache.CachedArrayCreator;
+import org.apache.lucene.search.cache.DoubleValuesCreator;
+import org.apache.lucene.search.cache.FloatValuesCreator;
+import org.apache.lucene.search.cache.IntValuesCreator;
+import org.apache.lucene.search.cache.LongValuesCreator;
+import org.apache.lucene.search.cache.ShortValuesCreator;
 import org.apache.lucene.store.LockObtainFailedException;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.DocIdBitSet;
@@ -68,6 +75,7 @@
   private Query queryE;
   private Query queryF;
   private Query queryG;
+  private Query queryM;
   private Sort sort;
 
   // document data:
@@ -78,23 +86,29 @@
   // the string field to sort by string
     // the i18n field includes accented characters for testing locale-specific sorting
   private String[][] data = new String[][] {
-  // tracer  contents         int            float           string   custom   i18n               long            double, 'short', byte, 'custom parser encoding'
-  {   "A",   "x a",           "5",           "4f",           "c",     "A-3",   "p\u00EAche",      "10",           "-4.0", "3", "126", "J"},//A, x
-  {   "B",   "y a",           "5",           "3.4028235E38", "i",     "B-10",  "HAT",             "1000000000", "40.0", "24", "1", "I"},//B, y
-  {   "C",   "x a b c",       "2147483647",  "1.0",          "j",     "A-2",   "p\u00E9ch\u00E9", "99999999",   "40.00002343", "125", "15", "H"},//C, x
-  {   "D",   "y a b c",       "-1",          "0.0f",         "a",     "C-0",   "HUT",             String.valueOf(Long.MAX_VALUE),           String.valueOf(Double.MIN_VALUE), String.valueOf(Short.MIN_VALUE), String.valueOf(Byte.MIN_VALUE), "G"},//D, y
-  {   "E",   "x a b c d",     "5",           "2f",           "h",     "B-8",   "peach",           String.valueOf(Long.MIN_VALUE),           String.valueOf(Double.MAX_VALUE), String.valueOf(Short.MAX_VALUE),           String.valueOf(Byte.MAX_VALUE), "F"},//E,x
-  {   "F",   "y a b c d",     "2",           "3.14159f",     "g",     "B-1",   "H\u00C5T",        "-44",           "343.034435444", "-3", "0", "E"},//F,y
-  {   "G",   "x a b c d",     "3",           "-1.0",         "f",     "C-100", "sin",             "323254543543", "4.043544", "5", "100", "D"},//G,x
-  {   "H",   "y a b c d",     "0",           "1.4E-45",      "e",     "C-88",  "H\u00D8T",        "1023423423005","4.043545", "10", "-50", "C"},//H,y
-  {   "I",   "x a b c d e f", "-2147483648", "1.0e+0",       "d",     "A-10",  "s\u00EDn",        "332422459999", "4.043546", "-340", "51", "B"},//I,x
-  {   "J",   "y a b c d e f", "4",           ".5",           "b",     "C-7",   "HOT",             "34334543543",  "4.0000220343", "300", "2", "A"},//J,y
+  // tracer  contents         int            float           string   custom   i18n               long            double,          short,     byte, 'custom parser encoding'
+  {   "A",   "x a",           "5",           "4f",           "c",     "A-3",   "p\u00EAche",      "10",           "-4.0",            "3",    "126", "J"},//A, x
+  {   "B",   "y a",           "5",           "3.4028235E38", "i",     "B-10",  "HAT",             "1000000000",   "40.0",           "24",      "1", "I"},//B, y
+  {   "C",   "x a b c",       "2147483647",  "1.0",          "j",     "A-2",   "p\u00E9ch\u00E9", "99999999","40.00002343",        "125",     "15", "H"},//C, x
+  {   "D",   "y a b c",       "-1",          "0.0f",         "a",     "C-0",   "HUT",   String.valueOf(Long.MAX_VALUE),String.valueOf(Double.MIN_VALUE), String.valueOf(Short.MIN_VALUE), String.valueOf(Byte.MIN_VALUE), "G"},//D, y
+  {   "E",   "x a b c d",     "5",           "2f",           "h",     "B-8",   "peach", String.valueOf(Long.MIN_VALUE),String.valueOf(Double.MAX_VALUE), String.valueOf(Short.MAX_VALUE),           String.valueOf(Byte.MAX_VALUE), "F"},//E,x
+  {   "F",   "y a b c d",     "2",           "3.14159f",     "g",     "B-1",   "H\u00C5T",        "-44",          "343.034435444",  "-3",      "0", "E"},//F,y
+  {   "G",   "x a b c d",     "3",           "-1.0",         "f",     "C-100", "sin",             "323254543543", "4.043544",        "5",    "100", "D"},//G,x
+  {   "H",   "y a b c d",     "0",           "1.4E-45",      "e",     "C-88",  "H\u00D8T",        "1023423423005","4.043545",       "10",    "-50", "C"},//H,y
+  {   "I",   "x a b c d e f", "-2147483648", "1.0e+0",       "d",     "A-10",  "s\u00EDn",        "332422459999", "4.043546",     "-340",     "51", "B"},//I,x
+  {   "J",   "y a b c d e f", "4",           ".5",           "b",     "C-7",   "HOT",             "34334543543",  "4.0000220343",  "300",      "2", "A"},//J,y
   {   "W",   "g",             "1",           null,           null,    null,    null,              null,           null, null, null, null},
   {   "X",   "g",             "1",           "0.1",          null,    null,    null,              null,           null, null, null, null},
   {   "Y",   "g",             "1",           "0.2",          null,    null,    null,              null,           null, null, null, null},
-  {   "Z",   "f g",           null,          null,           null,    null,    null,              null,           null, null, null, null}
-  };
+  {   "Z",   "f g",           null,          null,           null,    null,    null,              null,           null, null, null, null},
   
+  // Sort Missing first/last
+  {   "a",   "m",            null,          null,           null,    null,    null,              null,           null, null, null, null},
+  {   "b",   "m",            "4",           "4.0",           "4",    null,    null,              "4",           "4", "4", "4", null},
+  {   "c",   "m",            "5",           "5.0",           "5",    null,    null,              "5",           "5", "5", "5", null},
+  {   "d",   "m",            null,          null,           null,    null,    null,              null,           null, null, null, null}
+  }; 
+  
   // the sort order of Ø versus U depends on the version of the rules being used
   // for the inherited root locale: Ø's order isnt specified in Locale.US since 
   // its not used in english.
@@ -217,6 +231,7 @@
     queryE = new TermQuery (new Term ("contents", "e"));
     queryF = new TermQuery (new Term ("contents", "f"));
     queryG = new TermQuery (new Term ("contents", "g"));
+    queryM = new TermQuery (new Term ("contents", "m"));
     sort = new Sort();
   }
   
@@ -277,6 +292,42 @@
     assertMatches (full, queryY, sort, "DJHFB");
   }
   
+  private static class SortMissingLastTestHelper {
+    CachedArrayCreator<?> creator;
+    Object min;
+    Object max;
+    
+    SortMissingLastTestHelper( CachedArrayCreator<?> c, Object min, Object max ) {
+      creator = c;
+      this.min = min;
+      this.max = max;
+    }
+  }
+
+  // test sorts where the type of field is specified
+  public void testSortMissingLast() throws Exception {
+    
+    SortMissingLastTestHelper[] testers = new SortMissingLastTestHelper[] {
+        new SortMissingLastTestHelper( new ByteValuesCreator(   "byte",   null ), Byte.MIN_VALUE,    Byte.MAX_VALUE ),
+        new SortMissingLastTestHelper( new ShortValuesCreator(  "short",  null ), Short.MIN_VALUE,   Short.MAX_VALUE ),
+        new SortMissingLastTestHelper( new IntValuesCreator(    "int",    null ), Integer.MIN_VALUE, Integer.MAX_VALUE ),
+        new SortMissingLastTestHelper( new LongValuesCreator(   "long",   null ), Long.MIN_VALUE,    Long.MAX_VALUE ),
+        new SortMissingLastTestHelper( new FloatValuesCreator(  "float",  null ), Float.MIN_VALUE,   Float.MAX_VALUE ),
+        new SortMissingLastTestHelper( new DoubleValuesCreator( "double", null ), Double.MIN_VALUE,  Double.MAX_VALUE ),
+    };
+    
+    for( SortMissingLastTestHelper t : testers ) {
+      sort.setSort (new SortField( t.creator, false ), SortField.FIELD_DOC );
+      assertMatches("creator:"+t.creator, full, queryM, sort, "adbc" );
+
+      sort.setSort (new SortField( t.creator, false ).setMissingValue( t.max ), SortField.FIELD_DOC );
+      assertMatches("creator:"+t.creator, full, queryM, sort, "bcad" );
+
+      sort.setSort (new SortField( t.creator, false ).setMissingValue( t.min ), SortField.FIELD_DOC );
+      assertMatches("creator:"+t.creator, full, queryM, sort, "adbc" );
+    }
+  }
+  
   /**
    * Test String sorting: small queue to many matches, multi field sort, reverse sort
    */
@@ -1042,13 +1093,17 @@
 
   }
 
+  private void assertMatches(Searcher searcher, Query query, Sort sort, String expectedResult) throws IOException {
+    assertMatches( null, searcher, query, sort, expectedResult );
+  }
+
   // make sure the documents returned by the search match the expected list
-  private void assertMatches(Searcher searcher, Query query, Sort sort,
+  private void assertMatches(String msg, Searcher searcher, Query query, Sort sort,
       String expectedResult) throws IOException {
     //ScoreDoc[] result = searcher.search (query, null, 1000, sort).scoreDocs;
     TopDocs hits = searcher.search (query, null, expectedResult.length(), sort);
     ScoreDoc[] result = hits.scoreDocs;
-    assertEquals(hits.totalHits, expectedResult.length());
+    assertEquals(expectedResult.length(),hits.totalHits);
     StringBuilder buff = new StringBuilder(10);
     int n = result.length;
     for (int i=0; i<n; ++i) {
@@ -1058,7 +1113,7 @@
         buff.append (v[j]);
       }
     }
-    assertEquals (expectedResult, buff.toString());
+    assertEquals (msg, expectedResult, buff.toString());
   }
 
   private HashMap<String,Float> getScores (ScoreDoc[] hits, Searcher searcher)
