Index: D:/wEclipse/lucene-2.0-trunk/lucene/src/java/org/apache/lucene/queryParser/QueryParser.jj
===================================================================
--- D:/wEclipse/lucene-2.0-trunk/lucene/src/java/org/apache/lucene/queryParser/QueryParser.jj	(revision 454774)
+++ D:/wEclipse/lucene-2.0-trunk/lucene/src/java/org/apache/lucene/queryParser/QueryParser.jj	(working copy)
@@ -82,6 +82,7 @@
  * @author Brian Goetz
  * @author Peter Halacsy
  * @author Tatu Saloranta
+ * @author Patrick Turcotte
  */
 
 public class QueryParser {
@@ -105,6 +106,8 @@
   private Operator operator = OR_OPERATOR;
 
   boolean lowercaseExpandedTerms = true;
+  
+  boolean useLocalizedOperators = false;
 
   Analyzer analyzer;
   String field;
@@ -260,6 +263,7 @@
    */
   public void setLocale(Locale locale) {
     this.locale = locale;
+    createLocalizedTokenMap();    
   }
 
   /**
@@ -269,6 +273,22 @@
     return locale;
   }
 
+  /**
+   * Set use of localized operator.
+   *
+   * If <code>true</code>, Operators are going to be read in resourcesBundles
+   * org.apache.lucene.queryParser.QueryParser[locale].properties.
+   * Default is <code>false</code>.
+   */
+  public void setUseLocalizedOperators(boolean useLocalizedOperators){
+  	this.useLocalizedOperators = useLocalizedOperators;
+  	createLocalizedTokenMap();
+  }
+  
+  public boolean getUseLocalizedOperators(){
+  	return useLocalizedOperators;
+  }
+   
   protected void addClause(Vector clauses, int conj, int mods, Query q) {
     boolean required, prohibited;
 
@@ -590,6 +610,32 @@
   }
 
   /**
+   * Create map for AND, OR and NOT token based on Locale.
+   */
+  private void createLocalizedTokenMap() {
+  	token_source.useLocalizedOperators = useLocalizedOperators;
+  	if (useLocalizedOperators) {
+		// read stuff from ResourceBundle
+		ResourceBundle bundle = ResourceBundle.getBundle("org.apache.lucene.queryParser.QueryParser", locale);
+		
+		String string = bundle.getString("AND");
+		List andCases = new ArrayList();
+		andCases.add(string);
+		token_source.andCases = andCases;
+		
+		string = bundle.getString("OR");
+		List orCases = new ArrayList();
+		orCases.add(string);
+		token_source.orCases = orCases;
+		
+		string = bundle.getString("NOT");
+		List notCases = new ArrayList();
+		notCases.add(string);
+		token_source.notCases = notCases;
+  	}
+  }
+
+  /**
    * Returns a String where the escape char has been
    * removed, or kept only once if there was a double escape.
    */
@@ -637,7 +683,7 @@
     QueryParser qp = new QueryParser("field",
                            new org.apache.lucene.analysis.SimpleAnalyzer());
     Query q = qp.parse(args[0]);
-    System.out.println(q.toString("field"));
+    System.out.println(q.toString("field")); 
   }
 }
 
@@ -685,6 +731,23 @@
 | <CARAT:     "^" > : Boost
 | <QUOTED:     "\"" (~["\""])+ "\"">
 | <TERM:      <_TERM_START_CHAR> (<_TERM_CHAR>)*  >
+{
+	String text = matchedToken.image;
+	if (useLocalizedOperators){
+		if (andCases.contains(text)){
+			matchedToken.kind = AND;
+		}
+		else if (orCases.contains(text)) {
+			matchedToken.kind = OR;
+		}
+		else if (notCases.contains(text)) {
+			matchedToken.kind = NOT;
+		}
+		else {
+			matchedToken.kind = TERM;
+		}
+	}
+}
 | <FUZZY_SLOP:     "~" ( (<_NUM_CHAR>)+ ( "." (<_NUM_CHAR>)+ )? )? >
 | <PREFIXTERM:  <_TERM_START_CHAR> (<_TERM_CHAR>)* "*" >
 | <WILDTERM:  <_TERM_START_CHAR>
@@ -711,6 +774,8 @@
 | <RANGEEX_GOOP: (~[ " ", "}" ])+ >
 }
 
+
+
 // *   Query  ::= ( Clause )*
 // *   Clause ::= ["+", "-"] [<TERM> ":"] ( <TERM> | "(" Query ")" )
 
@@ -902,3 +967,11 @@
     return q;
   }
 }
+
+TOKEN_MGR_DECLS :
+{
+	List andCases = new ArrayList();
+	List orCases = new ArrayList();
+	List notCases = new ArrayList();
+	boolean useLocalizedOperators = false;
+}
