diff --git a/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java b/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
index 37b7e3ed92..e09cdd4013 100644
--- a/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
+++ b/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
@@ -31,6 +31,7 @@ import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.DisjunctionMaxQuery;
 import org.apache.lucene.search.MultiPhraseQuery;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
@@ -542,13 +543,33 @@ public class QueryBuilder {
   }
 
   /**
-   * Creates a span near (phrase) query from a graph token stream. The articulation points of the graph are visited in
-   * order and the queries created at each point are merged in the returned near query.
+   * Creates graph phrase query from the tokenstream contents
    */
-  protected SpanQuery analyzeGraphPhrase(TokenStream source, String field, int phraseSlop)
+  protected Query analyzeGraphPhrase(TokenStream source, String field, int phraseSlop)
       throws IOException {
     source.reset();
     GraphTokenStreamFiniteStrings graph = new GraphTokenStreamFiniteStrings(source);
+    if (phraseSlop > 0) {
+      /**
+       * Creates a boolean query from the graph token stream by extracting all the finite strings from the graph
+       * and using them to create phrase queries with the appropriate slop.
+       */
+      BooleanQuery.Builder builder = new BooleanQuery.Builder();
+      Iterator<TokenStream> it = graph.getFiniteStrings();
+      while (it.hasNext()) {
+        Query query = createFieldQuery(it.next(), BooleanClause.Occur.MUST, field, true, phraseSlop);
+        if (query != null) {
+          builder.add(query, BooleanClause.Occur.SHOULD);
+        }
+      }
+      return builder.build();
+    }
+
+    /**
+     * Creates a span near (phrase) query from a graph token stream.
+     * The articulation points of the graph are visited in order and the queries
+     * created at each point are merged in the returned near query.
+     */
     List<SpanQuery> clauses = new ArrayList<>();
     int[] articulationPoints = graph.articulationPoints();
     int lastState = 0;
@@ -610,7 +631,7 @@ public class QueryBuilder {
     } else if (clauses.size() == 1) {
       return clauses.get(0);
     } else {
-      return new SpanNearQuery(clauses.toArray(new SpanQuery[0]), phraseSlop, true);
+      return new SpanNearQuery(clauses.toArray(new SpanQuery[0]), 0, true);
     }
   }
 
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java b/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
index 1604f51945..afc1238a80 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
@@ -170,6 +170,17 @@ public class TestQueryBuilder extends LuceneTestCase {
         queryBuilder.createPhraseQuery("field", "guinea pig"));
   }
 
+  public void testMultiWordSynonymsPhraseWithSlop() throws Exception {
+    BooleanQuery expected = new BooleanQuery.Builder()
+        .add(new PhraseQuery.Builder().setSlop(4)
+                .add(new Term("field", "guinea")).add(new Term("field", "pig")).build(), BooleanClause.Occur.SHOULD)
+        .add(new TermQuery(new Term("field", "cavy")), BooleanClause.Occur.SHOULD)
+        .build();
+    QueryBuilder queryBuilder = new QueryBuilder(new MockSynonymAnalyzer());
+    assertEquals(expected,
+        queryBuilder.createPhraseQuery("field", "guinea pig", 4));
+  }
+
   /** forms graph query */
   public void testMultiWordSynonymsBoolean() throws Exception {
     for (BooleanClause.Occur occur : new BooleanClause.Occur[] {BooleanClause.Occur.SHOULD, BooleanClause.Occur.MUST}) {
