diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java
index 56ccbb6..970dcff 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java
@@ -129,6 +129,9 @@ public class AnalyzingInfixSuggester extends Lookup implements Closeable {
   private final Directory dir;
   final int minPrefixChars;
 
+  private final boolean allTermsRequired;
+  private final boolean highlight;
+
   /** Used for ongoing NRT additions/updates. */
   private IndexWriter writer;
 
@@ -138,7 +141,13 @@ public class AnalyzingInfixSuggester extends Lookup implements Closeable {
   /** Default minimum number of leading characters before
    *  PrefixQuery is used (4). */
   public static final int DEFAULT_MIN_PREFIX_CHARS = 4;
-
+  
+  /** Default boolean clause option for multiple terms matching (all terms required). */
+  public static final boolean DEFAULT_ALL_TERMS_REQUIRED = true;
+ 
+  /** Default higlighting option. */
+  public static final boolean DEFAULT_HIGHLIGHT = true;
+ 
   /** How we sort the postings and search results. */
   private static final Sort SORT = new Sort(new SortField("weight", SortField.Type.LONG, true));
 
@@ -148,7 +157,7 @@ public class AnalyzingInfixSuggester extends Lookup implements Closeable {
    *  Lucene index).  Note that {@link #close}
    *  will also close the provided directory. */
   public AnalyzingInfixSuggester(Version matchVersion, Directory dir, Analyzer analyzer) throws IOException {
-    this(matchVersion, dir, analyzer, analyzer, DEFAULT_MIN_PREFIX_CHARS);
+    this(matchVersion, dir, analyzer, analyzer, DEFAULT_MIN_PREFIX_CHARS, DEFAULT_ALL_TERMS_REQUIRED, DEFAULT_HIGHLIGHT);    
   }
 
   /** Create a new instance, loading from a previously built
@@ -164,7 +173,27 @@ public class AnalyzingInfixSuggester extends Lookup implements Closeable {
    *     faster).
    */
   public AnalyzingInfixSuggester(Version matchVersion, Directory dir, Analyzer indexAnalyzer, Analyzer queryAnalyzer, int minPrefixChars) throws IOException {
-
+    this(matchVersion, dir, indexAnalyzer, queryAnalyzer, minPrefixChars, DEFAULT_ALL_TERMS_REQUIRED, DEFAULT_HIGHLIGHT);
+  }
+  
+  /** Create a new instance, loading from a previously built
+   *  AnalyzingInfixSuggester directory, if it exists.  This directory must be
+   *  private to the infix suggester (i.e., not an external
+   *  Lucene index).  Note that {@link #close}
+   *  will also close the provided directory.
+   *
+   *  @param minPrefixChars Minimum number of leading characters
+   *     before PrefixQuery is used (default 4).
+   *     Prefixes shorter than this are indexed as character
+   *     ngrams (increasing index size but making lookups
+   *     faster).
+   *
+   *  @param allTermsRequired All terms in the suggest query must be matched.
+   *  @param highlight Highlight suggest query in suggestions.
+   */
+  public AnalyzingInfixSuggester(Version matchVersion, Directory dir, Analyzer indexAnalyzer, Analyzer queryAnalyzer, int minPrefixChars,
+                                 boolean allTermsRequired, boolean highlight) throws IOException {
+                                   
     if (minPrefixChars < 0) {
       throw new IllegalArgumentException("minPrefixChars must be >= 0; got: " + minPrefixChars);
     }
@@ -174,6 +203,8 @@ public class AnalyzingInfixSuggester extends Lookup implements Closeable {
     this.matchVersion = matchVersion;
     this.dir = dir;
     this.minPrefixChars = minPrefixChars;
+    this.allTermsRequired = allTermsRequired;
+    this.highlight = highlight;
 
     if (DirectoryReader.indexExists(dir)) {
       // Already built; open it:
@@ -340,7 +371,7 @@ public class AnalyzingInfixSuggester extends Lookup implements Closeable {
 
   @Override
   public List<LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) throws IOException {
-    return lookup(key, contexts, num, true, true);
+    return lookup(key, contexts, num, allTermsRequired, highlight);
   }
 
   /** Lookup, without any context. */
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester.java
index 35bd65d..3a5d492 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester.java
@@ -115,6 +115,24 @@ public class BlendedInfixSuggester extends AnalyzingInfixSuggester {
     this.numFactor = numFactor;
   }
 
+  /**
+   * Create a new instance, loading from a previously built
+   * directory, if it exists.
+   *
+   * @param blenderType Type of blending strategy, see BlenderType for more precisions
+   * @param numFactor   Factor to multiply the number of searched elements before ponderate
+   * @param allTermsRequired All terms in the suggest query must be matched.
+   * @param highlight Highlight suggest query in suggestions.
+   * @throws IOException If there are problems opening the underlying Lucene index.
+   */
+  public BlendedInfixSuggester(Version matchVersion, Directory dir, Analyzer indexAnalyzer, Analyzer queryAnalyzer,
+                               int minPrefixChars, BlenderType blenderType, int numFactor,
+                               boolean allTermsRequired, boolean highlight) throws IOException {
+      super(matchVersion, dir, indexAnalyzer, queryAnalyzer, minPrefixChars, allTermsRequired, highlight);
+      this.blenderType = blenderType;
+      this.numFactor = numFactor;
+  }  
+  
   @Override
   public List<Lookup.LookupResult> lookup(CharSequence key, Set<BytesRef> contexts, boolean onlyMorePopular, int num) throws IOException {
     // here we multiply the number of searched element by the defined factor
diff --git a/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest.java b/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest.java
index 5866e51..82b5940 100644
--- a/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest.java
+++ b/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggesterTest.java
@@ -93,10 +93,50 @@ public class AnalyzingInfixSuggesterTest extends LuceneTestCase {
     assertEquals("a <b>p</b>enny saved is a <b>p</b>enny earned", results.get(0).highlightKey);
     assertEquals(10, results.get(0).value);
     assertEquals(new BytesRef("foobaz"), results.get(0).payload);
+    
+    results = suggester.lookup(TestUtil.stringToCharSequence("money penny", random()), 10, false, true);
+    assertEquals(1, results.size());
+    assertEquals("a penny saved is a penny earned", results.get(0).key);
+    assertEquals("a <b>penny</b> saved is a <b>penny</b> earned", results.get(0).highlightKey);
+    assertEquals(10, results.get(0).value);
+    assertEquals(new BytesRef("foobaz"), results.get(0).payload);
+     
+    results = suggester.lookup(TestUtil.stringToCharSequence("penny ea", random()), 10, false, true);
+    assertEquals(2, results.size());
+    assertEquals("a penny saved is a penny earned", results.get(0).key);
+    assertEquals("a <b>penny</b> saved is a <b>penny</b> <b>ea</b>rned", results.get(0).highlightKey);
+    assertEquals("lend me your ear", results.get(1).key);
+    assertEquals("lend me your <b>ea</b>r", results.get(1).highlightKey);
+    
+    results = suggester.lookup(TestUtil.stringToCharSequence("money penny", random()), 10, false, false);
+    assertEquals(1, results.size());
+    assertEquals("a penny saved is a penny earned", results.get(0).key);
+    assertNull(results.get(0).highlightKey);
+    
+    testConstructorDefaults(suggester, keys, a, true, true);
+    testConstructorDefaults(suggester, keys, a, true, false);
+    testConstructorDefaults(suggester, keys, a, false, false);
+    testConstructorDefaults(suggester, keys, a, false, true);
 
     suggester.close();
   }
 
+  private void testConstructorDefaults(AnalyzingInfixSuggester suggester, Input[] keys, Analyzer a, 
+                                       boolean allTermsRequired, boolean highlight) throws IOException {
+    AnalyzingInfixSuggester suggester2 = new AnalyzingInfixSuggester(TEST_VERSION_CURRENT, newDirectory(), a, a, 3, allTermsRequired, highlight);
+    suggester2.build(new InputArrayIterator(keys));
+    
+    CharSequence key = TestUtil.stringToCharSequence("penny ea", random());
+
+    List<LookupResult> results1 = suggester.lookup(key, 10, allTermsRequired, highlight);
+    List<LookupResult> results2 = suggester2.lookup(key, false, 10);
+    assertEquals(results1.size(), results2.size());
+    assertEquals(results1.get(0).key, results2.get(0).key);
+    assertEquals(results1.get(0).highlightKey, results2.get(0).highlightKey);
+   
+    suggester2.close();
+  }
+  
   public void testAfterLoad() throws Exception {
     Input keys[] = new Input[] {
       new Input("lend me your ear", 8, new BytesRef("foobar")),
