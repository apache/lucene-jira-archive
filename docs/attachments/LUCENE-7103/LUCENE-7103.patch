diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java
index 86c9134..ef4c3f3 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java
@@ -26,9 +26,10 @@ import org.apache.lucene.index.SortedNumericDocValues;
 import org.apache.lucene.search.FieldComparator;
 import org.apache.lucene.search.LeafFieldComparator;
 import org.apache.lucene.search.Scorer;
-import org.apache.lucene.spatial.util.GeoDistanceUtils;
+import org.apache.lucene.spatial.util.GeoProjectionUtils;
 import org.apache.lucene.spatial.util.GeoRect;
 import org.apache.lucene.spatial.util.GeoUtils;
+import org.apache.lucene.util.SloppyMath;
 
 /**
  * Compares documents by distance from an origin point
@@ -96,7 +97,7 @@ class LatLonPointDistanceComparator extends FieldComparator<Double> implements L
         crossesDateLine = false;
       } else {
         assert Double.isFinite(bottom);
-        GeoRect box = GeoUtils.circleToBBox(longitude, latitude, bottom);
+        GeoRect box = GeoUtils.circleToBBox(longitude, latitude, haversin2(bottom));
         // pre-encode our box to our integer encoding, so we don't have to decode 
         // to double values for uncompetitive hits. This has some cost!
         int minLatEncoded = LatLonPoint.encodeLatitude(box.minLat);
@@ -166,7 +167,7 @@ class LatLonPointDistanceComparator extends FieldComparator<Double> implements L
       if (outsideBox == false) {
         double docLatitude = LatLonPoint.decodeLatitude(latitudeBits);
         double docLongitude = LatLonPoint.decodeLongitude(longitudeBits);
-        minValue = Math.min(minValue, GeoDistanceUtils.haversin(latitude, longitude, docLatitude, docLongitude));
+        minValue = Math.min(minValue, haversin1(latitude, longitude, docLatitude, docLongitude));
       }
     }
     return Double.compare(bottom, minValue);
@@ -174,7 +175,7 @@ class LatLonPointDistanceComparator extends FieldComparator<Double> implements L
   
   @Override
   public void copy(int slot, int doc) throws IOException {
-    values[slot] = distance(doc);
+    values[slot] = sortKey(doc);
   }
   
   @Override
@@ -190,17 +191,17 @@ class LatLonPointDistanceComparator extends FieldComparator<Double> implements L
   
   @Override
   public Double value(int slot) {
-    return Double.valueOf(values[slot]);
+    return Double.valueOf(haversin2(values[slot]));
   }
   
   @Override
   public int compareTop(int doc) throws IOException {
-    return Double.compare(topValue, distance(doc));
+    return Double.compare(topValue, haversin2(sortKey(doc)));
   }
   
   // TODO: optimize for single-valued case?
   // TODO: do all kinds of other optimizations!
-  double distance(int doc) {
+  double sortKey(int doc) {
     currentDocs.setDocument(doc);
 
     int numValues = currentDocs.count();
@@ -213,8 +214,32 @@ class LatLonPointDistanceComparator extends FieldComparator<Double> implements L
       long encoded = currentDocs.valueAt(i);
       double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));
       double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));
-      minValue = Math.min(minValue, GeoDistanceUtils.haversin(latitude, longitude, docLatitude, docLongitude));
+      minValue = Math.min(minValue, haversin1(latitude, longitude, docLatitude, docLongitude));
     }
     return minValue;
   }
+
+  // sort by first part of the haversin computation. note that this value is meaningless to the user.
+  // invoke haversin2() to "complete" the calculation and get a distance in meters.
+  static double haversin1(double lat1, double lon1, double lat2, double lon2) {
+    double dLat = SloppyMath.TO_RADIANS * (lat2 - lat1);
+    double dLon = SloppyMath.TO_RADIANS * (lon2 - lon1);
+    lat1 = SloppyMath.TO_RADIANS * (lat1);
+    lat2 = SloppyMath.TO_RADIANS * (lat2);
+
+    final double sinDLatO2 = SloppyMath.sin(dLat / 2);
+    final double sinDLonO2 = SloppyMath.sin(dLon / 2);
+
+    return sinDLatO2*sinDLatO2 + sinDLonO2 * sinDLonO2 * SloppyMath.cos(lat1) * SloppyMath.cos(lat2);
+  }
+
+  // second half of the haversin calculation, used to convert results from haversin1 (used internally
+  // for sorting) for display purposes.
+  static double haversin2(double partial) {
+    if (Double.isInfinite(partial)) {
+      return partial;
+    }
+    double c = 2 * SloppyMath.asin(Math.sqrt(partial));
+    return (GeoProjectionUtils.SEMIMAJOR_AXIS * c);
+  }
 }
diff --git a/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java b/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java
index a776b3f..83a08b7 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java
@@ -289,4 +289,24 @@ public class TestLatLonPointDistanceSort extends LuceneTestCase {
     writer.close();
     dir.close();
   }
+
+  /** Test this method sorts the same way as real haversin */
+  public void testPartialHaversin() {
+    for (int i = 0; i < 100000; i++) {
+      double centerLat = -90 + 180.0 * random().nextDouble();
+      double centerLon = -180 + 360.0 * random().nextDouble();
+
+      double lat1 = -90 + 180.0 * random().nextDouble();
+      double lon1 = -180 + 360.0 * random().nextDouble();
+
+      double lat2 = -90 + 180.0 * random().nextDouble();
+      double lon2 = -180 + 360.0 * random().nextDouble();
+
+      int expected = Integer.signum(Double.compare(GeoDistanceUtils.haversin(centerLat, centerLon, lat1, lon1),
+                                                   GeoDistanceUtils.haversin(centerLat, centerLon, lat2, lon2)));
+      int actual = Integer.signum(Double.compare(LatLonPointDistanceComparator.haversin1(centerLat, centerLon, lat1, lon1),
+                                                 LatLonPointDistanceComparator.haversin1(centerLat, centerLon, lat2, lon2)));
+      assertEquals(expected, actual);
+    }
+  }
 }
