From f17640a57e4518bd8abd1a4a39c32444d40b3001 Mon Sep 17 00:00:00 2001
From: dceccarelli4 <dceccarelli4@bloomberg.net>
Date: Mon, 11 Nov 2019 18:38:10 +0000
Subject: [PATCH 1/8] Refactor TopGroups unit tests

---
 .../lucene/search/grouping/TopGroupsTest.java | 295 +++++++-----------
 1 file changed, 110 insertions(+), 185 deletions(-)

diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
index 8fb661dbc79..11029fe4be1 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
@@ -16,186 +16,125 @@
  */
 package org.apache.lucene.search.grouping;
 
+import java.util.Arrays;
+
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.Sort;
+import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TotalHits;
 import org.apache.lucene.util.LuceneTestCase;
 
 import org.junit.Ignore;
+import org.junit.Test;
 
+/*
+ * This class implements tests for the <code>TopGroup.merge</code> method
+ * using a narrative approach. Use of a creative narrative may seem unusual
+ * or even silly but the idea behind it is to make it hopefully easier to
+ * reason about the documents and groups and scores in the test whilst testing
+ * several scenario permutations.
+ *
+ * Imagine:
+ *
+ * Each document represents (say) a picture book of an animal.
+ * We are searching for two books and wish to draw a picture of our own, inspired by the books.
+ * We think that large animals are easier to draw and therefore order the books by the featured animal's size.
+ * We think that different colors would make for a good drawing and therefore group the books by the featured animal's color.
+ *
+ * Index content:
+ *
+ * The documents are in 2 groups ("blue" and "red") and there are 4 documents across 2 shards:
+ * shard 1 (blue whale, red ant) and shard 2 (blue dragonfly, red squirrel).
+ *
+ * If all documents are present the "blue whale" and the "red squirrel" documents would be returned
+ * for our drawing since they are the largest animals in their respective groups.
+ */
 public class TopGroupsTest extends LuceneTestCase {
 
-  @Ignore // https://issues.apache.org/jira/browse/LUCENE-8996
+  private static String RED_GROUP_KEY = "RED";
+  private static String BLUE_GROUP_KEY = "BLUE";
+
+  private static Sort GROUP_SORT = Sort.RELEVANCE;
+  private static Sort DOC_SORT = Sort.RELEVANCE;
+
+  private static int DOC_OFFSET = 0;
+  private static int TOP_DOC_N = 10;
+
+
+  private static ScoreDoc DOC_RED_ANT = new ScoreDoc(1 /* docid */, 1.0f /* score */);
+  private static ScoreDoc DOC_RED_SQUIRREL = new ScoreDoc(3 /* docid */, 3.0f /* score */);
+  private static ScoreDoc DOC_BLUE_DRAGONFLY = new ScoreDoc(2 /* docid */, 2.0f /* score */);
+  private static ScoreDoc DOC_BLUE_WHALE = new ScoreDoc(4 /* docid */, 4.0f /* score */);
+
+  private static TopGroups.ScoreMergeMode MERGE_MODE = TopGroups.ScoreMergeMode.Total;
+
+  @Test
   public void testAllGroupsEmptyInSecondPass() {
-    narrativeMergeTestImplementation(false, false, false, false);
-  }
+    GroupDocs<String> emptyRed = createEmptyGroupDocs(RED_GROUP_KEY);
+    GroupDocs<String> emptyBlue = createEmptyGroupDocs(BLUE_GROUP_KEY);
 
-  @Ignore // https://issues.apache.org/jira/browse/LUCENE-8996
-  public void testSomeGroupsEmptyInSecondPass() {
-    narrativeMergeTestImplementation(false, false, false, true);
-    narrativeMergeTestImplementation(false, false, true, false);
-    narrativeMergeTestImplementation(false, false, true, true);
-
-    narrativeMergeTestImplementation(false, true, false, false);
-    narrativeMergeTestImplementation(false, true, false, true);
-    narrativeMergeTestImplementation(false, true, true, false);
-    narrativeMergeTestImplementation(false, true, true, true);
-
-    narrativeMergeTestImplementation(true, false, false, false);
-    narrativeMergeTestImplementation(true, false, false, true);
-    narrativeMergeTestImplementation(true, false, true, false);
-    narrativeMergeTestImplementation(true, false, true, true);
-
-    narrativeMergeTestImplementation(true, true, false, false);
-    narrativeMergeTestImplementation(true, true, false, true);
-    narrativeMergeTestImplementation(true, true, true, false);
-  }
+    TopGroups<String> emptyGroups = createTopGroups(new GroupDocs[] {emptyRed, emptyBlue}, Float.NaN);
 
-  public void testNoGroupsEmptyInSecondPass() {
-    narrativeMergeTestImplementation(true, true, true, true);
+    // if we merge two empty groups the final maxScore should be Float.NaN
+    TopGroups mergedGroups = TopGroups.merge(new TopGroups[] {emptyGroups, emptyGroups}, GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
+    assertTrue("Score should be equal to Float.NaN when merging empty top groups", Float.isNaN(mergedGroups.maxScore));
   }
 
-  /*
-   * This method implements tests for the <code>TopGroup.merge</code> method
-   * using a narrative approach. Use of a creative narrative may seem unusual
-   * or even silly but the idea behind it is to make it hopefully easier to
-   * reason about the documents and groups and scores in the test whilst testing
-   * several scenario permutations.
-   *
-   * Imagine:
-   *
-   * Each document represents (say) a picture book of an animal.
-   * We are searching for two books and wish to draw a picture of our own, inspired by the books.
-   * We think that large animals are easier to draw and therefore order the books by the featured animal's size.
-   * We think that different colors would make for a good drawing and therefore group the books by the featured animal's color.
-   *
-   * Index content:
-   *
-   * The documents are in 2 groups ("blue" and "red") and there are 4 documents across 2 shards:
-   * shard 1 (blue whale, red ant) and shard 2 (blue dragonfly, red squirrel).
-   *
-   * If all documents are present the "blue whale" and the "red squirrel" documents would be returned
-   * for our drawing since they are the largest animals in their respective groups.
-   *
-   * Test permutations (haveBlueWhale, haveRedAnt, haveBlueDragonfly, haveRedSquirrel) arise because
-   * in the first pass of the search all documents can be present, but
-   * in the second pass of the search some documents could be missing
-   * if they have been deleted 'just so' between the two phases.
-   *
-   * Additionally a <code>haveAnimal == false</code> condition also represents scenarios where a given
-   * group has documents on some but not all shards in the collection.
-   */
-  private void narrativeMergeTestImplementation(
-      boolean haveBlueWhale,
-      boolean haveRedAnt,
-      boolean haveBlueDragonfly,
-      boolean haveRedSquirrel) {
-
-    final String blueGroupValue = "blue";
-    final String redGroupValue = "red";
-
-    final Integer redAntSize = 1;
-    final Integer blueDragonflySize = 10;
-    final Integer redSquirrelSize = 100;
-    final Integer blueWhaleSize = 1000;
-
-    final float redAntScore = redAntSize;
-    final float blueDragonflyScore = blueDragonflySize;
-    final float redSquirrelScore = redSquirrelSize;
-    final float blueWhaleScore = blueWhaleSize;
-
-    final Sort sort = Sort.RELEVANCE;
-
-    final TopGroups<String> shard1TopGroups;
-    {
-      final GroupDocs<String> group1 = haveBlueWhale
-          ? createSingletonGroupDocs(blueGroupValue, new Object[] { blueWhaleSize }, 1 /* docId */, blueWhaleScore, 0 /* shardIndex */)
-              : createEmptyGroupDocs(blueGroupValue, new Object[] { blueWhaleSize });
-
-      final GroupDocs<String> group2 = haveRedAnt
-          ? createSingletonGroupDocs(redGroupValue, new Object[] { redAntSize }, 2 /* docId */, redAntScore, 0 /* shardIndex */)
-              : createEmptyGroupDocs(redGroupValue, new Object[] { redAntSize });
-
-      shard1TopGroups = new TopGroups<String>(
-          sort.getSort() /* groupSort */,
-          sort.getSort() /* withinGroupSort */,
-          group1.scoreDocs.length + group2.scoreDocs.length /* totalHitCount */,
-          group1.scoreDocs.length + group2.scoreDocs.length /* totalGroupedHitCount */,
-          combineGroupDocs(group1, group2) /* groups */,
-          (haveBlueWhale ? blueWhaleScore : (haveRedAnt ? redAntScore : Float.NaN)) /* maxScore */);
-    }
-
-    final TopGroups<String> shard2TopGroups;
-    {
-      final GroupDocs<String> group1 = haveBlueDragonfly
-          ? createSingletonGroupDocs(blueGroupValue, new Object[] { blueDragonflySize }, 3 /* docId */, blueDragonflyScore, 1 /* shardIndex */)
-              : createEmptyGroupDocs(blueGroupValue, new Object[] { blueDragonflySize });
-
-      final GroupDocs<String> group2 = haveRedSquirrel
-      ? createSingletonGroupDocs(redGroupValue, new Object[] { redSquirrelSize }, 4 /* docId */, redSquirrelScore, 1 /* shardIndex */)
-          : createEmptyGroupDocs(redGroupValue, new Object[] { redSquirrelSize });
-
-      shard2TopGroups = new TopGroups<String>(
-          sort.getSort() /* groupSort */,
-          sort.getSort() /* withinGroupSort */,
-          group1.scoreDocs.length + group2.scoreDocs.length /* totalHitCount */,
-          group1.scoreDocs.length + group2.scoreDocs.length /* totalGroupedHitCount */,
-          combineGroupDocs(group1, group2) /* groups */,
-          (haveRedSquirrel ? redSquirrelScore : (haveBlueDragonfly ? blueDragonflyScore : Float.NaN)) /* maxScore */);
-    }
-
-    final TopGroups<String> mergedTopGroups = TopGroups.<String>merge(
-        combineTopGroups(shard1TopGroups, shard2TopGroups),
-        sort /* groupSort */,
-        sort /* docSort */,
-        0 /* docOffset */,
-        2 /* docTopN */,
-        TopGroups.ScoreMergeMode.None);
-    assertNotNull(mergedTopGroups);
-
-    final int expectedCount =
-        (haveBlueWhale     ? 1 : 0) +
-        (haveRedAnt        ? 1 : 0) +
-        (haveBlueDragonfly ? 1 : 0) +
-        (haveRedSquirrel   ? 1 : 0);
-
-    assertEquals(expectedCount, mergedTopGroups.totalHitCount);
-    assertEquals(expectedCount, mergedTopGroups.totalGroupedHitCount);
-
-    assertEquals(2, mergedTopGroups.groups.length);
-    {
-      assertEquals(blueGroupValue, mergedTopGroups.groups[0].groupValue);
-      final float expectedBlueMaxScore =
-          (haveBlueWhale ? blueWhaleScore : (haveBlueDragonfly ? blueDragonflyScore : Float.MIN_VALUE));
-      checkMaxScore(expectedBlueMaxScore, mergedTopGroups.groups[0].maxScore);
-    }
-    {
-      assertEquals(redGroupValue, mergedTopGroups.groups[1].groupValue);
-      final float expectedRedMaxScore =
-          (haveRedSquirrel ? redSquirrelScore : (haveRedAnt ? redAntScore : Float.MIN_VALUE));
-      checkMaxScore(expectedRedMaxScore, mergedTopGroups.groups[1].maxScore);
-    }
-
-    final float expectedMaxScore =
-        (haveBlueWhale ? blueWhaleScore
-            : (haveRedSquirrel ? redSquirrelScore
-                : (haveBlueDragonfly ? blueDragonflyScore
-                    : (haveRedAnt ? redAntScore
-                        : Float.MIN_VALUE))));
-    checkMaxScore(expectedMaxScore, mergedTopGroups.maxScore);
+  @Test
+  @Ignore("Ignore until https://issues.apache.org/jira/browse/LUCENE-8996 is resolved")
+  public void testMergeARealScoreWithNanShouldntReturnNaN() {
+    GroupDocs<String> emptyRed = createEmptyGroupDocs(RED_GROUP_KEY);
+    GroupDocs<String> emptyBlue = createEmptyGroupDocs(BLUE_GROUP_KEY);
+
+    GroupDocs<String> fullRed = createGroupDocs(RED_GROUP_KEY, new ScoreDoc[] {DOC_RED_ANT, DOC_RED_SQUIRREL}, DOC_RED_SQUIRREL.score /*score*/, DOC_RED_SQUIRREL.score /*max score*/);
+    GroupDocs<String> fullBlue = createGroupDocs(BLUE_GROUP_KEY, new ScoreDoc[] {DOC_BLUE_DRAGONFLY, DOC_BLUE_WHALE}, DOC_BLUE_WHALE.score /*score*/, DOC_BLUE_WHALE.score /*max score*/);
+
+    final float maxScoreShard1 = fullBlue.maxScore;
+    // shard one has real groups with a max score
+    TopGroups<String> topGroupsShard1 = createTopGroups(new GroupDocs[] {fullBlue, fullRed}, maxScoreShard1);
+    // shard two has empty groups with max score Float.NaN
+    TopGroups<String> topGroupsShard2 = createTopGroups(new GroupDocs[] {emptyBlue, emptyRed}, Float.NaN);
+
+    // merging the groups must produce a TopGroups object with maxScore equals to maxScoreShard1
+    TopGroups mergedGroups = TopGroups.merge(new TopGroups[] {topGroupsShard1, topGroupsShard2}, GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
+    assertEquals(maxScoreShard1, mergedGroups.maxScore, 0.0);
   }
 
-  private static void checkMaxScore(float expected, float actual) {
-    if (Float.isNaN(expected)) {
-      assertTrue(Float.isNaN(actual));
-    } else {
-      assertEquals(expected, actual, 0.0);
-    }
+  @Test
+  public void testMergeARealScoresReturnTheRightResults() {
+    GroupDocs<String> redSquirrelGroupDocs = createGroupDocs(RED_GROUP_KEY, new ScoreDoc[] {DOC_RED_SQUIRREL}, DOC_RED_SQUIRREL.score /*score*/, DOC_RED_SQUIRREL.score /*max score*/);
+    GroupDocs<String> blueWhaleGroupDocs = createGroupDocs(BLUE_GROUP_KEY, new ScoreDoc[] {DOC_BLUE_WHALE}, DOC_BLUE_WHALE.score /*score*/, DOC_BLUE_WHALE.score /*max score*/);
+    GroupDocs<String> blueDragonflyGroupDocs = createGroupDocs(BLUE_GROUP_KEY, new ScoreDoc[] {DOC_BLUE_DRAGONFLY}, DOC_BLUE_DRAGONFLY.score /*score*/, DOC_BLUE_DRAGONFLY.score /*max score*/);
+    GroupDocs<String> redAntGroupDocs = createGroupDocs(RED_GROUP_KEY, new ScoreDoc[] {DOC_RED_ANT}, DOC_RED_ANT.score /*score*/, DOC_RED_ANT.score /*max score*/);
+
+    // shard one has real groups with a max score
+    TopGroups<String> topGroupsShard1 = createTopGroups(new GroupDocs[] {blueWhaleGroupDocs, redAntGroupDocs}, blueWhaleGroupDocs.maxScore);
+    // shard two has empty groups with max score Float.NaN
+    TopGroups<String> topGroupsShard2 = createTopGroups(new GroupDocs[] {blueDragonflyGroupDocs, redSquirrelGroupDocs}, blueDragonflyGroupDocs.maxScore);
+
+    // merging the groups should produce a group that has blueWhaleGroupDocs.max as a maxScore
+    TopGroups mergedGroups = TopGroups.merge(new TopGroups[] {topGroupsShard1, topGroupsShard2}, GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
+    assertEquals(blueWhaleGroupDocs.maxScore, mergedGroups.maxScore, 0.0);
+    // also the first group should be blue and contain the biggest blue animal (the whale)
+    assertEquals(DOC_BLUE_WHALE.doc, mergedGroups.groups[0].scoreDocs[0].doc);
+    // the second group should be red and contain the biggest red animal (the squirrel)
+    assertEquals(DOC_RED_SQUIRREL.doc, mergedGroups.groups[1].scoreDocs[0].doc);
   }
 
   // helper methods
 
-  private static GroupDocs<String> createEmptyGroupDocs(String groupValue, Object[] groupSortValues) {
+  /* Create a TopGroup containing the given GroupDocs - sort will be by score and total hit count and group hit
+  * count will be randomized values*/
+  private static TopGroups<String> createTopGroups(GroupDocs<String> groups[], float maxScore){
+    SortField[] sortByScore = new SortField[] {SortField.FIELD_SCORE};
+    int totalHitCount = 0; // randomize
+    int totalGroupedHitCount = 0; // randomize
+    return new TopGroups<String>(sortByScore, sortByScore, totalHitCount, totalGroupedHitCount, groups, maxScore);
+  }
+
+  /* Create a GroupDocs with no documents - if the shard didn't have documents matching the query */
+  private static GroupDocs<String> createEmptyGroupDocs(String groupValue) {
+    Object[] groupSortValues = new Object[0];
     return new  GroupDocs<String>(
         Float.NaN /* score */,
         Float.NaN /* maxScore */,
@@ -203,33 +142,19 @@ public class TopGroupsTest extends LuceneTestCase {
         new ScoreDoc[0],
         groupValue,
         groupSortValues);
-    }
+  }
 
-  private static GroupDocs<String> createSingletonGroupDocs(String groupValue, Object[] groupSortValues,
-      int docId, float docScore, int shardIndex) {
-    return new  GroupDocs<String>(
-        Float.NaN /* score */,
-        docScore /* maxScore */,
-        new TotalHits(1, TotalHits.Relation.EQUAL_TO),
-        new ScoreDoc[] { new ScoreDoc(docId, docScore, shardIndex) },
+  /* Create a GroupDocs with the given an array of ScoreDocs that belong to the group. It assumes
+  * that we are sorting only on scores and fetches the scores from the given ScoreDocs  */
+  private static GroupDocs<String> createGroupDocs(String groupValue, ScoreDoc[] scoreDocs, float score, float maxScore) {
+    // extract the scores from the scoreDocs
+    Object[] groupSortValues = Arrays.stream(scoreDocs).map(doc -> doc.score).toArray();
+    return new  GroupDocs<>(
+        score,
+        maxScore,
+        new TotalHits(0, TotalHits.Relation.EQUAL_TO),
+        scoreDocs,
         groupValue,
         groupSortValues);
-    }
-
-  private static GroupDocs<String>[] combineGroupDocs(GroupDocs<String> group0, GroupDocs<String> group1) {
-    @SuppressWarnings({"unchecked","rawtypes"})
-    final GroupDocs<String>[] groups = new GroupDocs[2];
-    groups[0] = group0;
-    groups[1] = group1;
-    return groups;
   }
-
-  private static TopGroups<String>[] combineTopGroups(TopGroups<String> group0, TopGroups<String> group1) {
-    @SuppressWarnings({"unchecked","rawtypes"})
-    final TopGroups<String>[] groups = new TopGroups[2];
-    groups[0] = group0;
-    groups[1] = group1;
-    return groups;
-  }
-
 }
-- 
2.20.1 (Apple Git-117)


From f9b27cd9df497b71f3938abfe7baa3a38a900769 Mon Sep 17 00:00:00 2001
From: dceccarelli4 <dceccarelli4@bloomberg.net>
Date: Tue, 12 Nov 2019 15:24:12 +0000
Subject: [PATCH 2/8] Refactor TopGroupsTest.java

---
 .../lucene/search/grouping/TopGroupsTest.java | 88 ++++++++++---------
 1 file changed, 46 insertions(+), 42 deletions(-)

diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
index 11029fe4be1..f01e53147c4 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
@@ -18,15 +18,18 @@ package org.apache.lucene.search.grouping;
 
 import java.util.Arrays;
 
+import com.carrotsearch.randomizedtesting.RandomizedTest;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.Sort;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TotalHits;
-import org.apache.lucene.util.LuceneTestCase;
 
 import org.junit.Ignore;
 import org.junit.Test;
 
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertEquals;
+
 /*
  * This class implements tests for the <code>TopGroup.merge</code> method
  * using a narrative approach. Use of a creative narrative may seem unusual
@@ -49,71 +52,71 @@ import org.junit.Test;
  * If all documents are present the "blue whale" and the "red squirrel" documents would be returned
  * for our drawing since they are the largest animals in their respective groups.
  */
-public class TopGroupsTest extends LuceneTestCase {
+public class TopGroupsTest extends RandomizedTest {
 
-  private static String RED_GROUP_KEY = "RED";
-  private static String BLUE_GROUP_KEY = "BLUE";
+  private final static String RED_GROUP_KEY = "RED";
+  private final static String BLUE_GROUP_KEY = "BLUE";
 
-  private static Sort GROUP_SORT = Sort.RELEVANCE;
-  private static Sort DOC_SORT = Sort.RELEVANCE;
+  private final static Sort GROUP_SORT = Sort.RELEVANCE;
+  private final static Sort DOC_SORT = Sort.RELEVANCE;
 
-  private static int DOC_OFFSET = 0;
-  private static int TOP_DOC_N = 10;
+  private final static int DOC_OFFSET = 0;
+  private final static int TOP_DOC_N = 10;
 
 
-  private static ScoreDoc DOC_RED_ANT = new ScoreDoc(1 /* docid */, 1.0f /* score */);
-  private static ScoreDoc DOC_RED_SQUIRREL = new ScoreDoc(3 /* docid */, 3.0f /* score */);
-  private static ScoreDoc DOC_BLUE_DRAGONFLY = new ScoreDoc(2 /* docid */, 2.0f /* score */);
-  private static ScoreDoc DOC_BLUE_WHALE = new ScoreDoc(4 /* docid */, 4.0f /* score */);
+  private final static ScoreDoc DOC_RED_ANT = new ScoreDoc(1 /* docid */, 1.0f /* score */);
+  private final static ScoreDoc DOC_RED_SQUIRREL = new ScoreDoc(3 /* docid */, 3.0f /* score */);
+  private final static ScoreDoc DOC_BLUE_DRAGONFLY = new ScoreDoc(2 /* docid */, 2.0f /* score */);
+  private final static ScoreDoc DOC_BLUE_WHALE = new ScoreDoc(4 /* docid */, 4.0f /* score */);
 
-  private static TopGroups.ScoreMergeMode MERGE_MODE = TopGroups.ScoreMergeMode.Total;
+  private final static TopGroups.ScoreMergeMode MERGE_MODE = TopGroups.ScoreMergeMode.Total;
 
   @Test
   public void testAllGroupsEmptyInSecondPass() {
-    GroupDocs<String> emptyRed = createEmptyGroupDocs(RED_GROUP_KEY);
-    GroupDocs<String> emptyBlue = createEmptyGroupDocs(BLUE_GROUP_KEY);
+    final GroupDocs<String> emptyRed = createEmptyGroupDocs(RED_GROUP_KEY);
+    final GroupDocs<String> emptyBlue = createEmptyGroupDocs(BLUE_GROUP_KEY);
 
-    TopGroups<String> emptyGroups = createTopGroups(new GroupDocs[] {emptyRed, emptyBlue}, Float.NaN);
+    final TopGroups<String> emptyGroups = createTopGroups(new GroupDocs[]{emptyRed, emptyBlue}, Float.NaN);
 
     // if we merge two empty groups the final maxScore should be Float.NaN
-    TopGroups mergedGroups = TopGroups.merge(new TopGroups[] {emptyGroups, emptyGroups}, GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
+    final TopGroups mergedGroups = TopGroups.merge(new TopGroups[]{emptyGroups, emptyGroups}, GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
     assertTrue("Score should be equal to Float.NaN when merging empty top groups", Float.isNaN(mergedGroups.maxScore));
   }
 
   @Test
   @Ignore("Ignore until https://issues.apache.org/jira/browse/LUCENE-8996 is resolved")
   public void testMergeARealScoreWithNanShouldntReturnNaN() {
-    GroupDocs<String> emptyRed = createEmptyGroupDocs(RED_GROUP_KEY);
-    GroupDocs<String> emptyBlue = createEmptyGroupDocs(BLUE_GROUP_KEY);
+    final GroupDocs<String> emptyRed = createEmptyGroupDocs(RED_GROUP_KEY);
+    final GroupDocs<String> emptyBlue = createEmptyGroupDocs(BLUE_GROUP_KEY);
 
-    GroupDocs<String> fullRed = createGroupDocs(RED_GROUP_KEY, new ScoreDoc[] {DOC_RED_ANT, DOC_RED_SQUIRREL}, DOC_RED_SQUIRREL.score /*score*/, DOC_RED_SQUIRREL.score /*max score*/);
-    GroupDocs<String> fullBlue = createGroupDocs(BLUE_GROUP_KEY, new ScoreDoc[] {DOC_BLUE_DRAGONFLY, DOC_BLUE_WHALE}, DOC_BLUE_WHALE.score /*score*/, DOC_BLUE_WHALE.score /*max score*/);
+    final GroupDocs<String> fullRed = createGroupDocs(RED_GROUP_KEY, new ScoreDoc[]{DOC_RED_ANT, DOC_RED_SQUIRREL}, DOC_RED_SQUIRREL.score /*score*/, DOC_RED_SQUIRREL.score /*max score*/);
+    GroupDocs<String> fullBlue = createGroupDocs(BLUE_GROUP_KEY, new ScoreDoc[]{DOC_BLUE_DRAGONFLY, DOC_BLUE_WHALE}, DOC_BLUE_WHALE.score /*score*/, DOC_BLUE_WHALE.score /*max score*/);
 
     final float maxScoreShard1 = fullBlue.maxScore;
     // shard one has real groups with a max score
-    TopGroups<String> topGroupsShard1 = createTopGroups(new GroupDocs[] {fullBlue, fullRed}, maxScoreShard1);
+    final TopGroups<String> topGroupsShard1 = createTopGroups(new GroupDocs[]{fullBlue, fullRed}, maxScoreShard1);
     // shard two has empty groups with max score Float.NaN
-    TopGroups<String> topGroupsShard2 = createTopGroups(new GroupDocs[] {emptyBlue, emptyRed}, Float.NaN);
+    final TopGroups<String> topGroupsShard2 = createTopGroups(new GroupDocs[]{emptyBlue, emptyRed}, Float.NaN);
 
     // merging the groups must produce a TopGroups object with maxScore equals to maxScoreShard1
-    TopGroups mergedGroups = TopGroups.merge(new TopGroups[] {topGroupsShard1, topGroupsShard2}, GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
+    final TopGroups mergedGroups = TopGroups.merge(new TopGroups[]{topGroupsShard1, topGroupsShard2}, GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
     assertEquals(maxScoreShard1, mergedGroups.maxScore, 0.0);
   }
 
   @Test
   public void testMergeARealScoresReturnTheRightResults() {
-    GroupDocs<String> redSquirrelGroupDocs = createGroupDocs(RED_GROUP_KEY, new ScoreDoc[] {DOC_RED_SQUIRREL}, DOC_RED_SQUIRREL.score /*score*/, DOC_RED_SQUIRREL.score /*max score*/);
-    GroupDocs<String> blueWhaleGroupDocs = createGroupDocs(BLUE_GROUP_KEY, new ScoreDoc[] {DOC_BLUE_WHALE}, DOC_BLUE_WHALE.score /*score*/, DOC_BLUE_WHALE.score /*max score*/);
-    GroupDocs<String> blueDragonflyGroupDocs = createGroupDocs(BLUE_GROUP_KEY, new ScoreDoc[] {DOC_BLUE_DRAGONFLY}, DOC_BLUE_DRAGONFLY.score /*score*/, DOC_BLUE_DRAGONFLY.score /*max score*/);
-    GroupDocs<String> redAntGroupDocs = createGroupDocs(RED_GROUP_KEY, new ScoreDoc[] {DOC_RED_ANT}, DOC_RED_ANT.score /*score*/, DOC_RED_ANT.score /*max score*/);
+    final GroupDocs<String> redSquirrelGroupDocs = createGroupDocs(RED_GROUP_KEY, new ScoreDoc[]{DOC_RED_SQUIRREL}, DOC_RED_SQUIRREL.score /*score*/, DOC_RED_SQUIRREL.score /*max score*/);
+    final GroupDocs<String> blueWhaleGroupDocs = createGroupDocs(BLUE_GROUP_KEY, new ScoreDoc[]{DOC_BLUE_WHALE}, DOC_BLUE_WHALE.score /*score*/, DOC_BLUE_WHALE.score /*max score*/);
+    final GroupDocs<String> blueDragonflyGroupDocs = createGroupDocs(BLUE_GROUP_KEY, new ScoreDoc[]{DOC_BLUE_DRAGONFLY}, DOC_BLUE_DRAGONFLY.score /*score*/, DOC_BLUE_DRAGONFLY.score /*max score*/);
+    final GroupDocs<String> redAntGroupDocs = createGroupDocs(RED_GROUP_KEY, new ScoreDoc[]{DOC_RED_ANT}, DOC_RED_ANT.score /*score*/, DOC_RED_ANT.score /*max score*/);
 
     // shard one has real groups with a max score
-    TopGroups<String> topGroupsShard1 = createTopGroups(new GroupDocs[] {blueWhaleGroupDocs, redAntGroupDocs}, blueWhaleGroupDocs.maxScore);
+    final TopGroups<String> topGroupsShard1 = createTopGroups(new GroupDocs[]{blueWhaleGroupDocs, redAntGroupDocs}, blueWhaleGroupDocs.maxScore);
     // shard two has empty groups with max score Float.NaN
-    TopGroups<String> topGroupsShard2 = createTopGroups(new GroupDocs[] {blueDragonflyGroupDocs, redSquirrelGroupDocs}, blueDragonflyGroupDocs.maxScore);
+    final TopGroups<String> topGroupsShard2 = createTopGroups(new GroupDocs[]{blueDragonflyGroupDocs, redSquirrelGroupDocs}, blueDragonflyGroupDocs.maxScore);
 
     // merging the groups should produce a group that has blueWhaleGroupDocs.max as a maxScore
-    TopGroups mergedGroups = TopGroups.merge(new TopGroups[] {topGroupsShard1, topGroupsShard2}, GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
+    final TopGroups mergedGroups = TopGroups.merge(new TopGroups[]{topGroupsShard1, topGroupsShard2}, GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
     assertEquals(blueWhaleGroupDocs.maxScore, mergedGroups.maxScore, 0.0);
     // also the first group should be blue and contain the biggest blue animal (the whale)
     assertEquals(DOC_BLUE_WHALE.doc, mergedGroups.groups[0].scoreDocs[0].doc);
@@ -124,18 +127,19 @@ public class TopGroupsTest extends LuceneTestCase {
   // helper methods
 
   /* Create a TopGroup containing the given GroupDocs - sort will be by score and total hit count and group hit
-  * count will be randomized values*/
-  private static TopGroups<String> createTopGroups(GroupDocs<String> groups[], float maxScore){
-    SortField[] sortByScore = new SortField[] {SortField.FIELD_SCORE};
-    int totalHitCount = 0; // randomize
-    int totalGroupedHitCount = 0; // randomize
+   * count will be randomized values */
+  private static TopGroups<String> createTopGroups(GroupDocs<String> groups[], float maxScore) {
+    final SortField[] sortByScore = new SortField[]{SortField.FIELD_SCORE};
+    final int totalHitCount = randomIntBetween(0, 1000);
+    final int totalGroupedHitCount = randomIntBetween(0, totalHitCount);
     return new TopGroups<String>(sortByScore, sortByScore, totalHitCount, totalGroupedHitCount, groups, maxScore);
   }
 
-  /* Create a GroupDocs with no documents - if the shard didn't have documents matching the query */
+  /* Create a GroupDocs with no documents, the response sent by a shard that did not have documents
+   matching the given group */
   private static GroupDocs<String> createEmptyGroupDocs(String groupValue) {
-    Object[] groupSortValues = new Object[0];
-    return new  GroupDocs<String>(
+    final Object[] groupSortValues = new Object[0]; // empty: no groupSortValues
+    return new GroupDocs<String>(
         Float.NaN /* score */,
         Float.NaN /* maxScore */,
         new TotalHits(0, TotalHits.Relation.EQUAL_TO),
@@ -145,11 +149,11 @@ public class TopGroupsTest extends LuceneTestCase {
   }
 
   /* Create a GroupDocs with the given an array of ScoreDocs that belong to the group. It assumes
-  * that we are sorting only on scores and fetches the scores from the given ScoreDocs  */
+   * that we are sorting only on scores and fetches the scores from the given ScoreDocs  */
   private static GroupDocs<String> createGroupDocs(String groupValue, ScoreDoc[] scoreDocs, float score, float maxScore) {
     // extract the scores from the scoreDocs
-    Object[] groupSortValues = Arrays.stream(scoreDocs).map(doc -> doc.score).toArray();
-    return new  GroupDocs<>(
+    final Object[] groupSortValues = Arrays.stream(scoreDocs).map(doc -> doc.score).toArray();
+    return new GroupDocs<>(
         score,
         maxScore,
         new TotalHits(0, TotalHits.Relation.EQUAL_TO),
-- 
2.20.1 (Apple Git-117)


From 1a18f55d9ab63b3f239e43149a39edae341000ec Mon Sep 17 00:00:00 2001
From: dceccarelli4 <dceccarelli4@bloomberg.net>
Date: Tue, 12 Nov 2019 16:39:41 +0000
Subject: [PATCH 3/8] missing final

---
 .../test/org/apache/lucene/search/grouping/TopGroupsTest.java   | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
index f01e53147c4..ba69cf80f62 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
@@ -90,7 +90,7 @@ public class TopGroupsTest extends RandomizedTest {
     final GroupDocs<String> emptyBlue = createEmptyGroupDocs(BLUE_GROUP_KEY);
 
     final GroupDocs<String> fullRed = createGroupDocs(RED_GROUP_KEY, new ScoreDoc[]{DOC_RED_ANT, DOC_RED_SQUIRREL}, DOC_RED_SQUIRREL.score /*score*/, DOC_RED_SQUIRREL.score /*max score*/);
-    GroupDocs<String> fullBlue = createGroupDocs(BLUE_GROUP_KEY, new ScoreDoc[]{DOC_BLUE_DRAGONFLY, DOC_BLUE_WHALE}, DOC_BLUE_WHALE.score /*score*/, DOC_BLUE_WHALE.score /*max score*/);
+    final GroupDocs<String> fullBlue = createGroupDocs(BLUE_GROUP_KEY, new ScoreDoc[]{DOC_BLUE_DRAGONFLY, DOC_BLUE_WHALE}, DOC_BLUE_WHALE.score /*score*/, DOC_BLUE_WHALE.score /*max score*/);
 
     final float maxScoreShard1 = fullBlue.maxScore;
     // shard one has real groups with a max score
-- 
2.20.1 (Apple Git-117)


From 1d8ed464425383458ed6acd8ea278bede4267305 Mon Sep 17 00:00:00 2001
From: dceccarelli4 <dceccarelli4@bloomberg.net>
Date: Wed, 13 Nov 2019 12:36:17 +0000
Subject: [PATCH 4/8] Fix javac warnings

---
 .../lucene/search/grouping/TopGroupsTest.java | 44 ++++++++++++++-----
 1 file changed, 33 insertions(+), 11 deletions(-)

diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
index ba69cf80f62..5b7cf146c04 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
@@ -27,6 +27,7 @@ import org.apache.lucene.search.TotalHits;
 import org.junit.Ignore;
 import org.junit.Test;
 
+import static junit.framework.TestCase.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.assertEquals;
 
@@ -76,10 +77,11 @@ public class TopGroupsTest extends RandomizedTest {
     final GroupDocs<String> emptyRed = createEmptyGroupDocs(RED_GROUP_KEY);
     final GroupDocs<String> emptyBlue = createEmptyGroupDocs(BLUE_GROUP_KEY);
 
-    final TopGroups<String> emptyGroups = createTopGroups(new GroupDocs[]{emptyRed, emptyBlue}, Float.NaN);
+    final TopGroups<String> emptyGroups = createTopGroups(groupResults(emptyRed, emptyBlue), Float.NaN);
 
     // if we merge two empty groups the final maxScore should be Float.NaN
-    final TopGroups mergedGroups = TopGroups.merge(new TopGroups[]{emptyGroups, emptyGroups}, GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
+    final TopGroups<String> mergedGroups = TopGroups.merge(shardResponses(emptyGroups, emptyGroups), GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
+    assertNotNull("Merged groups cannot be null", mergedGroups);
     assertTrue("Score should be equal to Float.NaN when merging empty top groups", Float.isNaN(mergedGroups.maxScore));
   }
 
@@ -94,12 +96,13 @@ public class TopGroupsTest extends RandomizedTest {
 
     final float maxScoreShard1 = fullBlue.maxScore;
     // shard one has real groups with a max score
-    final TopGroups<String> topGroupsShard1 = createTopGroups(new GroupDocs[]{fullBlue, fullRed}, maxScoreShard1);
+    final TopGroups<String> topGroupsShard1 = createTopGroups(groupResults(fullBlue, fullRed), maxScoreShard1);
     // shard two has empty groups with max score Float.NaN
-    final TopGroups<String> topGroupsShard2 = createTopGroups(new GroupDocs[]{emptyBlue, emptyRed}, Float.NaN);
+    final TopGroups<String> topGroupsShard2 = createTopGroups(groupResults(emptyBlue, emptyRed), Float.NaN);
 
     // merging the groups must produce a TopGroups object with maxScore equals to maxScoreShard1
-    final TopGroups mergedGroups = TopGroups.merge(new TopGroups[]{topGroupsShard1, topGroupsShard2}, GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
+    final TopGroups mergedGroups = TopGroups.merge(shardResponses(topGroupsShard1, topGroupsShard2), GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
+    assertNotNull("Merged groups cannot be null", mergedGroups);
     assertEquals(maxScoreShard1, mergedGroups.maxScore, 0.0);
   }
 
@@ -111,12 +114,13 @@ public class TopGroupsTest extends RandomizedTest {
     final GroupDocs<String> redAntGroupDocs = createGroupDocs(RED_GROUP_KEY, new ScoreDoc[]{DOC_RED_ANT}, DOC_RED_ANT.score /*score*/, DOC_RED_ANT.score /*max score*/);
 
     // shard one has real groups with a max score
-    final TopGroups<String> topGroupsShard1 = createTopGroups(new GroupDocs[]{blueWhaleGroupDocs, redAntGroupDocs}, blueWhaleGroupDocs.maxScore);
+    final TopGroups<String> topGroupsShard1 = createTopGroups(groupResults(blueWhaleGroupDocs, redAntGroupDocs), blueWhaleGroupDocs.maxScore);
     // shard two has empty groups with max score Float.NaN
-    final TopGroups<String> topGroupsShard2 = createTopGroups(new GroupDocs[]{blueDragonflyGroupDocs, redSquirrelGroupDocs}, blueDragonflyGroupDocs.maxScore);
+    final TopGroups<String> topGroupsShard2 = createTopGroups(groupResults(blueDragonflyGroupDocs, redSquirrelGroupDocs), blueDragonflyGroupDocs.maxScore);
 
     // merging the groups should produce a group that has blueWhaleGroupDocs.max as a maxScore
-    final TopGroups mergedGroups = TopGroups.merge(new TopGroups[]{topGroupsShard1, topGroupsShard2}, GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
+    final TopGroups mergedGroups = TopGroups.merge(shardResponses(topGroupsShard1, topGroupsShard2), GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
+    assertNotNull("Merged groups cannot be null", mergedGroups);
     assertEquals(blueWhaleGroupDocs.maxScore, mergedGroups.maxScore, 0.0);
     // also the first group should be blue and contain the biggest blue animal (the whale)
     assertEquals(DOC_BLUE_WHALE.doc, mergedGroups.groups[0].scoreDocs[0].doc);
@@ -126,20 +130,38 @@ public class TopGroupsTest extends RandomizedTest {
 
   // helper methods
 
+  // takes a pair of groups and returns them in an array
+  private static GroupDocs<String>[] groupResults(GroupDocs<String> group1, GroupDocs<String> group2){
+    @SuppressWarnings("unchecked")
+     GroupDocs<String>[] groupDocs = new GroupDocs[2];
+     groupDocs[0] = group1;
+     groupDocs[1] = group2;
+     return groupDocs;
+  }
+
+  // takes a pair of shard responses and returns an array
+  private static TopGroups<String>[] shardResponses(TopGroups<String> topGroups1, TopGroups<String> topGroups2){
+    @SuppressWarnings("unchecked")
+    TopGroups<String>[] responses = new TopGroups[2];
+    responses[0] = topGroups1;
+    responses[1] = topGroups2;
+    return responses;
+  }
+
   /* Create a TopGroup containing the given GroupDocs - sort will be by score and total hit count and group hit
    * count will be randomized values */
-  private static TopGroups<String> createTopGroups(GroupDocs<String> groups[], float maxScore) {
+  private static <T> TopGroups<T> createTopGroups(GroupDocs<T>[] groups, float maxScore) {
     final SortField[] sortByScore = new SortField[]{SortField.FIELD_SCORE};
     final int totalHitCount = randomIntBetween(0, 1000);
     final int totalGroupedHitCount = randomIntBetween(0, totalHitCount);
-    return new TopGroups<String>(sortByScore, sortByScore, totalHitCount, totalGroupedHitCount, groups, maxScore);
+    return new TopGroups<>(sortByScore, sortByScore, totalHitCount, totalGroupedHitCount, groups, maxScore);
   }
 
   /* Create a GroupDocs with no documents, the response sent by a shard that did not have documents
    matching the given group */
   private static GroupDocs<String> createEmptyGroupDocs(String groupValue) {
     final Object[] groupSortValues = new Object[0]; // empty: no groupSortValues
-    return new GroupDocs<String>(
+    return new GroupDocs<>(
         Float.NaN /* score */,
         Float.NaN /* maxScore */,
         new TotalHits(0, TotalHits.Relation.EQUAL_TO),
-- 
2.20.1 (Apple Git-117)


From 2b48091e10ef13bde2093ce28ddc586131ba0b49 Mon Sep 17 00:00:00 2001
From: dceccarelli4 <dceccarelli4@bloomberg.net>
Date: Wed, 13 Nov 2019 12:47:21 +0000
Subject: [PATCH 5/8] Fix warnings

---
 .../test/org/apache/lucene/search/grouping/TopGroupsTest.java | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
index 5b7cf146c04..c723e4821e8 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
@@ -133,7 +133,7 @@ public class TopGroupsTest extends RandomizedTest {
   // takes a pair of groups and returns them in an array
   private static GroupDocs<String>[] groupResults(GroupDocs<String> group1, GroupDocs<String> group2){
     @SuppressWarnings("unchecked")
-     GroupDocs<String>[] groupDocs = new GroupDocs[2];
+     GroupDocs<String>[] groupDocs = (GroupDocs<String>[])new GroupDocs[2];
      groupDocs[0] = group1;
      groupDocs[1] = group2;
      return groupDocs;
@@ -142,7 +142,7 @@ public class TopGroupsTest extends RandomizedTest {
   // takes a pair of shard responses and returns an array
   private static TopGroups<String>[] shardResponses(TopGroups<String> topGroups1, TopGroups<String> topGroups2){
     @SuppressWarnings("unchecked")
-    TopGroups<String>[] responses = new TopGroups[2];
+    TopGroups<String>[] responses = (TopGroups<String>[])new TopGroups<?>[2];
     responses[0] = topGroups1;
     responses[1] = topGroups2;
     return responses;
-- 
2.20.1 (Apple Git-117)


From 45f4b1b506519d1d749575c0012a10331af903a3 Mon Sep 17 00:00:00 2001
From: dceccarelli4 <dceccarelli4@bloomberg.net>
Date: Wed, 20 Nov 2019 17:23:56 +0000
Subject: [PATCH 6/8] Use LuceneTestCase

---
 .../org/apache/lucene/search/grouping/TopGroupsTest.java  | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
index c723e4821e8..1d6ece19989 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
@@ -18,12 +18,12 @@ package org.apache.lucene.search.grouping;
 
 import java.util.Arrays;
 
-import com.carrotsearch.randomizedtesting.RandomizedTest;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.Sort;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TotalHits;
 
+import org.apache.lucene.util.LuceneTestCase;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -53,7 +53,7 @@ import static org.junit.Assert.assertEquals;
  * If all documents are present the "blue whale" and the "red squirrel" documents would be returned
  * for our drawing since they are the largest animals in their respective groups.
  */
-public class TopGroupsTest extends RandomizedTest {
+public class TopGroupsTest extends LuceneTestCase {
 
   private final static String RED_GROUP_KEY = "RED";
   private final static String BLUE_GROUP_KEY = "BLUE";
@@ -152,8 +152,8 @@ public class TopGroupsTest extends RandomizedTest {
    * count will be randomized values */
   private static <T> TopGroups<T> createTopGroups(GroupDocs<T>[] groups, float maxScore) {
     final SortField[] sortByScore = new SortField[]{SortField.FIELD_SCORE};
-    final int totalHitCount = randomIntBetween(0, 1000);
-    final int totalGroupedHitCount = randomIntBetween(0, totalHitCount);
+    final int totalHitCount = random().nextInt(1000);
+    final int totalGroupedHitCount = random().nextInt(totalHitCount);
     return new TopGroups<>(sortByScore, sortByScore, totalHitCount, totalGroupedHitCount, groups, maxScore);
   }
 
-- 
2.20.1 (Apple Git-117)


From cc610fcc9342fada40c5ba9ad9424913fb8a6065 Mon Sep 17 00:00:00 2001
From: dceccarelli4 <dceccarelli4@bloomberg.net>
Date: Wed, 20 Nov 2019 17:50:32 +0000
Subject: [PATCH 7/8] Fix precommit

---
 .../test/org/apache/lucene/search/grouping/TopGroupsTest.java | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
index 1d6ece19989..36f2468f5e4 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
@@ -27,10 +27,6 @@ import org.apache.lucene.util.LuceneTestCase;
 import org.junit.Ignore;
 import org.junit.Test;
 
-import static junit.framework.TestCase.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.assertEquals;
-
 /*
  * This class implements tests for the <code>TopGroup.merge</code> method
  * using a narrative approach. Use of a creative narrative may seem unusual
-- 
2.20.1 (Apple Git-117)


From beda21acfdd1c39f6090a76c364da80cffe1e6fc Mon Sep 17 00:00:00 2001
From: dceccarelli4 <dceccarelli4@bloomberg.net>
Date: Fri, 22 Nov 2019 16:29:32 +0000
Subject: [PATCH 8/8] Remove javac warnings

---
 .../org/apache/lucene/search/grouping/TopGroupsTest.java    | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
index 36f2468f5e4..8c0bab34352 100644
--- a/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
+++ b/lucene/grouping/src/test/org/apache/lucene/search/grouping/TopGroupsTest.java
@@ -97,7 +97,7 @@ public class TopGroupsTest extends LuceneTestCase {
     final TopGroups<String> topGroupsShard2 = createTopGroups(groupResults(emptyBlue, emptyRed), Float.NaN);
 
     // merging the groups must produce a TopGroups object with maxScore equals to maxScoreShard1
-    final TopGroups mergedGroups = TopGroups.merge(shardResponses(topGroupsShard1, topGroupsShard2), GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
+    final TopGroups<String> mergedGroups = TopGroups.merge(shardResponses(topGroupsShard1, topGroupsShard2), GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
     assertNotNull("Merged groups cannot be null", mergedGroups);
     assertEquals(maxScoreShard1, mergedGroups.maxScore, 0.0);
   }
@@ -115,7 +115,7 @@ public class TopGroupsTest extends LuceneTestCase {
     final TopGroups<String> topGroupsShard2 = createTopGroups(groupResults(blueDragonflyGroupDocs, redSquirrelGroupDocs), blueDragonflyGroupDocs.maxScore);
 
     // merging the groups should produce a group that has blueWhaleGroupDocs.max as a maxScore
-    final TopGroups mergedGroups = TopGroups.merge(shardResponses(topGroupsShard1, topGroupsShard2), GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
+    final TopGroups<String> mergedGroups = TopGroups.merge(shardResponses(topGroupsShard1, topGroupsShard2), GROUP_SORT, DOC_SORT, DOC_OFFSET, TOP_DOC_N, MERGE_MODE);
     assertNotNull("Merged groups cannot be null", mergedGroups);
     assertEquals(blueWhaleGroupDocs.maxScore, mergedGroups.maxScore, 0.0);
     // also the first group should be blue and contain the biggest blue animal (the whale)
@@ -129,7 +129,7 @@ public class TopGroupsTest extends LuceneTestCase {
   // takes a pair of groups and returns them in an array
   private static GroupDocs<String>[] groupResults(GroupDocs<String> group1, GroupDocs<String> group2){
     @SuppressWarnings("unchecked")
-     GroupDocs<String>[] groupDocs = (GroupDocs<String>[])new GroupDocs[2];
+     GroupDocs<String>[] groupDocs = (GroupDocs<String>[])new GroupDocs<?>[2];
      groupDocs[0] = group1;
      groupDocs[1] = group2;
      return groupDocs;
-- 
2.20.1 (Apple Git-117)

