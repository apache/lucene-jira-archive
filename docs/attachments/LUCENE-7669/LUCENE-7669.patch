diff --git a/lucene/core/src/java/org/apache/lucene/geo/GeoEncodingUtils.java b/lucene/core/src/java/org/apache/lucene/geo/GeoEncodingUtils.java
index 663cb2e..9cb261e 100644
--- a/lucene/core/src/java/org/apache/lucene/geo/GeoEncodingUtils.java
+++ b/lucene/core/src/java/org/apache/lucene/geo/GeoEncodingUtils.java
@@ -178,7 +178,7 @@ public final class GeoEncodingUtils {
    *  It works the same way as {@link #createDistancePredicate}.
    *  @lucene.internal */
   public static PolygonPredicate createPolygonPredicate(Polygon[] polygons, Polygon2D tree) {
-    final Rectangle boundingBox = Rectangle.fromPolygon(polygons);
+    final Rectangle boundingBox = Rectangle.fromPolygon(polygons, true);
     final Function<Rectangle, Relation> boxToRelation = box -> tree.relate(
         box.minLat, box.maxLat, box.minLon, box.maxLon);
     final Grid subBoxes = createSubBoxes(boundingBox, boxToRelation);
diff --git a/lucene/core/src/java/org/apache/lucene/geo/Rectangle.java b/lucene/core/src/java/org/apache/lucene/geo/Rectangle.java
index a8200c6..5e568a4 100644
--- a/lucene/core/src/java/org/apache/lucene/geo/Rectangle.java
+++ b/lucene/core/src/java/org/apache/lucene/geo/Rectangle.java
@@ -35,6 +35,8 @@ import static org.apache.lucene.util.SloppyMath.cos;
 import static org.apache.lucene.util.SloppyMath.toDegrees;
 import static org.apache.lucene.util.SloppyMath.toRadians;
 
+import org.apache.lucene.util.InPlaceMergeSorter;
+
 /** Represents a lat/lon rectangle. */
 public class Rectangle {
   /** maximum longitude value (in degrees) */
@@ -169,19 +171,74 @@ public class Rectangle {
     return toDegrees(l2);
   }
 
-  /** Returns the bounding box over an array of polygons */
-  public static Rectangle fromPolygon(Polygon[] polygons) {
+  /** Returns one of the smallest bounding boxes over an array of polygons.
+   *  When {@code maybeWrap} is true, then the returned polygon may cross the
+   *  dateline, which may help return a smaller bounding box.
+   */
+  public static Rectangle fromPolygon(Polygon[] polygons, boolean maybeWrap) {
+    if (polygons.length < 1) {
+      throw new IllegalArgumentException("Empty multipolygon");
+    }
+
     // compute bounding box
     double minLat = Double.POSITIVE_INFINITY;
     double maxLat = Double.NEGATIVE_INFINITY;
-    double minLon = Double.POSITIVE_INFINITY;
-    double maxLon = Double.NEGATIVE_INFINITY;
 
-    for (int i = 0;i < polygons.length; i++) {
+    for (int i = 0; i < polygons.length; i++) {
       minLat = Math.min(polygons[i].minLat, minLat);
       maxLat = Math.max(polygons[i].maxLat, maxLat);
-      minLon = Math.min(polygons[i].minLon, minLon);
-      maxLon = Math.max(polygons[i].maxLon, maxLon);
+    }
+
+    double minLon = Double.POSITIVE_INFINITY;
+    double maxLon = Double.NEGATIVE_INFINITY;
+    if (maybeWrap == false) {
+      for (int i = 0; i < polygons.length; i++) {
+        minLon = Math.min(polygons[i].minLon, minLon);
+        maxLon = Math.max(polygons[i].maxLon, maxLon);
+      }
+    } else {
+      double[] minLons = new double[polygons.length];
+      double[] maxLons = new double[polygons.length];
+      for (int i = 0; i < polygons.length; i++) {
+        minLons[i] = polygons[i].minLon;
+        maxLons[i] = polygons[i].maxLon;
+      }
+
+      new InPlaceMergeSorter() {
+        @Override
+        protected void swap(int i, int j) {
+          double tmp = minLons[i];
+          minLons[i] = minLons[j];
+          minLons[j] = tmp;
+          tmp = maxLons[i];
+          maxLons[i] = maxLons[j];
+          maxLons[j] = tmp;
+        }
+
+        @Override
+        protected int compare(int i, int j) {
+          return Double.compare(minLons[i], minLons[j]);
+        }
+      }.sort(0, minLons.length);
+
+      for (int i = 1; i < polygons.length; i++) {
+        maxLons[i] = Math.max(maxLons[i], maxLons[i-1]);
+      }
+
+      minLon = minLons[0];
+      maxLon = maxLons[polygons.length - 1];
+      double lonDelta = maxLon - minLon;
+      for (int i = 1; i < polygons.length; i++) {
+        final double min = minLons[i];
+        final double max = maxLons[i - 1];
+        final double delta = max - min + 360;
+        if (delta < lonDelta) {
+          assert min > max;
+          minLon = min;
+          maxLon = max;
+          lonDelta = delta;
+        }
+      }
     }
 
     return new Rectangle(minLat, maxLat, minLon, maxLon);
diff --git a/lucene/core/src/test/org/apache/lucene/geo/TestRectangle.java b/lucene/core/src/test/org/apache/lucene/geo/TestRectangle.java
new file mode 100644
index 0000000..8c81b4e
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/geo/TestRectangle.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.geo;
+
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+
+public class TestRectangle extends LuceneTestCase {
+
+  public void testFromPolygon() {
+    Polygon p1 = new Polygon(new double[] {1, 3, 3, 1}, new double[] {6, 6, 8, 6});
+    assertEquals(new Rectangle(1, 3, 6, 8), Rectangle.fromPolygon(new Polygon[] { p1 }, false));
+    assertEquals(new Rectangle(1, 3, 6, 8), Rectangle.fromPolygon(new Polygon[] { p1 }, true));
+
+    Polygon p2 = new Polygon(new double[] {40, 42, 42, 40}, new double[] {-160, -160, -150, -160});
+    assertEquals(new Rectangle(1, 42, -160, 8), Rectangle.fromPolygon(new Polygon[] { p1, p2 }, false));
+    assertEquals(new Rectangle(1, 42, -160, 8), Rectangle.fromPolygon(new Polygon[] { p1, p2 }, true));
+
+    Polygon p3 = new Polygon(new double[] {12, 15, 15, 12}, new double[] {120, 120, 125, 120});
+    assertEquals(new Rectangle(1, 42, -160, 125), Rectangle.fromPolygon(new Polygon[] { p1, p2, p3 }, false));
+    assertEquals(new Rectangle(1, 42, 6, -150), Rectangle.fromPolygon(new Polygon[] { p1, p2, p3 }, true));
+  }
+
+  public void testFromPolygonRandom() {
+    final int iters = atLeast(10);
+    for (int iter = 0; iter < iters; ++iter) {
+      final Polygon[] polygons = new Polygon[TestUtil.nextInt(random(), 1, 100)];
+      for (int i = 0; i < polygons.length; ++i) {
+        polygons[i] = GeoTestUtil.nextPolygon();
+      }
+      Rectangle rect1 = Rectangle.fromPolygon(polygons, false);
+      verify(polygons, rect1);
+      Rectangle rect2 = Rectangle.fromPolygon(polygons, true);
+      verify(polygons, rect2);
+      assertTrue(rect1.maxLon - rect1.minLon >= rect2.maxLon - rect2.minLon + (rect2.crossesDateline() ? 360 : 0));
+    }
+  }
+
+  private static void verify(Polygon[] polygons, Rectangle rectangle) {
+    for (Polygon polygon : polygons) {
+      assertTrue(rectangle.maxLat >= polygon.maxLat);
+      assertTrue(rectangle.minLat <= polygon.minLat);
+      if (rectangle.crossesDateline()) {
+        assertTrue(rectangle.maxLon >= polygon.maxLon || rectangle.minLon <= polygon.minLon);
+      } else {
+        assertTrue(rectangle.maxLon >= polygon.maxLon);
+        assertTrue(rectangle.minLon <= polygon.minLon);
+      }
+    }
+  }
+
+}
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
index c272b4d..ee835f7 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
@@ -76,13 +76,10 @@ final class LatLonPointInPolygonQuery extends Query {
 
   @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {
-
-    // I don't use RandomAccessWeight here: it's no good to approximate with "match all docs"; this is an inverted structure and should be
-    // used in the first pass:
     
     // bounding box over all polygons, this can speed up tree intersection/cheaply improve approximation for complex multi-polygons
     // these are pre-encoded with LatLonPoint's encoding
-    final Rectangle box = Rectangle.fromPolygon(polygons);
+    final Rectangle box = Rectangle.fromPolygon(polygons, false);
     final byte minLat[] = new byte[Integer.BYTES];
     final byte maxLat[] = new byte[Integer.BYTES];
     final byte minLon[] = new byte[Integer.BYTES];
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java
index ca61f02..2113d4a 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java
@@ -44,7 +44,7 @@ public final class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
    * that fall within or on the boundary of the polygons defined by the input parameters. 
    */
   public GeoPointInPolygonQuery(String field, Polygon... polygons) {
-    this(field, Rectangle.fromPolygon(polygons), polygons);
+    this(field, Rectangle.fromPolygon(polygons, false), polygons);
   }
   
   // internal constructor
diff --git a/lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil.java b/lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil.java
index 619b682..c6465c9 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil.java
@@ -549,7 +549,7 @@ public class GeoTestUtil {
     for (Object o : flattened) {
       final Rectangle r;
       if (o instanceof Polygon) {
-        r = Rectangle.fromPolygon(new Polygon[] { (Polygon) o });
+        r = Rectangle.fromPolygon(new Polygon[] { (Polygon) o }, false);
         minLat = Math.min(minLat, r.minLat);
         maxLat = Math.max(maxLat, r.maxLat);
         minLon = Math.min(minLon, r.minLon);
