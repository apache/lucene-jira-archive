Index: lucene/core/src/java/org/apache/lucene/search/FieldComparator.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/FieldComparator.java	(revision 1704070)
+++ lucene/core/src/java/org/apache/lucene/search/FieldComparator.java	(working copy)
@@ -824,6 +824,8 @@
 
     @Override
     public void setTopValue(BytesRef value) {
+      // nocommit: should we clone value so we won't be affected by future mutations the caller may make?
+      
       // null is fine: it means the last doc of the prior
       // search was missing this value
       topValue = value;
@@ -832,6 +834,9 @@
 
     @Override
     public BytesRef value(int slot) {
+      // null out the corrisponding Builder to prevent future changes to returned BytesRef instance
+      // in cases where the user makes additional slot changes after calling value
+      tempBRs[slot] = null;
       return values[slot];
     }
 
@@ -960,6 +965,8 @@
 
     @Override
     public void setTopValue(BytesRef value) {
+      // nocommit: should we clone value so we won't be affected by future mutations the caller may make?
+      
       // null is fine: it means the last doc of the prior
       // search was missing this value
       topValue = value;
@@ -967,6 +974,9 @@
 
     @Override
     public BytesRef value(int slot) {
+      // null out the corrisponding Builder to prevent future changes to returned BytesRef instance
+      // in cases where the user makes additional slot changes after calling value
+      tempBRs[slot] = null;
       return values[slot];
     }
 
Index: lucene/core/src/test/org/apache/lucene/search/TestFieldComparatorValues.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestFieldComparatorValues.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/search/TestFieldComparatorValues.java	(working copy)
@@ -0,0 +1,290 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.apache.lucene.document.BinaryDocValuesField;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.DoubleDocValuesField;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.FloatDocValuesField;
+import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.document.SortedDocValuesField;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestFieldComparatorValues extends LuceneTestCase {
+
+  /**
+   * @param sf The SortField to get a FieldComparator from
+   * @param fieldData list of Field instances to index, in any arbitrary order 
+   *        - elements may be null to indicate no value should be indexed
+   * @param expectedValues the expected list of sortable values returned by 
+   *        {@link FieldComparator#value} for the corrisponding entry in the fieldData
+   */
+  protected void testComparator(SortField sf, List<Field> fieldData, List<Object> expectedValues) throws IOException {
+    assertEquals(fieldData.size(), expectedValues.size());
+    
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+    for (Field f : fieldData) {
+      Document doc = new Document();
+      if (null != f) {
+        doc.add(f);
+      }
+      writer.addDocument(doc);
+    }
+    IndexReader ir = writer.getReader();
+    writer.close();
+
+    List<Object> actualValues = new ArrayList<Object>(expectedValues.size());
+    FieldComparator<?> fc = sf.getComparator(1, 0); // single slot is fine for this test
+    
+    for (LeafReaderContext leafContext : ir.leaves()) {
+      int numLeafDocs = leafContext.reader().numDocs();
+      LeafFieldComparator lc = fc.getLeafComparator(leafContext);
+      for (int leafDocId = 0; leafDocId < numLeafDocs; leafDocId++) {
+        // trivial example, real use cases might involve multiple slots
+        // and more conditionally comparison of slots/values
+        lc.copy(0, leafDocId);
+        // happy with doc in slot, want to capture value for doc...
+        actualValues.add(fc.value(0));
+      }
+    }
+
+    assertEquals(expectedValues, actualValues);
+
+    ir.close();
+    dir.close();
+  }
+
+  public void testString() throws IOException {
+    testComparator(new SortField("value", SortField.Type.STRING),
+                   Arrays.asList(new SortedDocValuesField("value", new BytesRef("foo")),
+                                 new SortedDocValuesField("value", new BytesRef("bar"))),
+                   Arrays.asList(new BytesRef("foo"),
+                                 new BytesRef("bar")));
+  }
+
+  public void testStringMissing() throws IOException {
+    testComparator(new SortField("value", SortField.Type.STRING),
+                   Arrays.asList(new SortedDocValuesField("value", new BytesRef("foo")),
+                                 null,
+                                 new SortedDocValuesField("value", new BytesRef("bar"))),
+                   Arrays.asList(new BytesRef("foo"),
+                                 null,
+                                 new BytesRef("bar")));
+  }
+
+  public void testStringMissingLast() throws IOException {
+    SortField sortField = new SortField("value", SortField.Type.STRING);
+    sortField.setMissingValue(SortField.STRING_LAST);
+    
+    testComparator(sortField,
+                   Arrays.asList(new SortedDocValuesField("value", new BytesRef("foo")),
+                                 null,
+                                 new SortedDocValuesField("value", new BytesRef("bar"))),
+                   Arrays.asList(new BytesRef("foo"),
+                                 null,
+                                 new BytesRef("bar")));
+  }
+  
+   public void testStringMissingFirst() throws IOException {
+    SortField sortField = new SortField("value", SortField.Type.STRING);
+    sortField.setMissingValue(SortField.STRING_FIRST);
+    
+    testComparator(sortField,
+                   Arrays.asList(new SortedDocValuesField("value", new BytesRef("foo")),
+                                 null,
+                                 new SortedDocValuesField("value", new BytesRef("bar"))),
+                   Arrays.asList(new BytesRef("foo"),
+                                 null,
+                                 new BytesRef("bar")));
+  }
+ 
+  public void testStringVal() throws IOException {
+    testComparator(new SortField("value", SortField.Type.STRING_VAL),
+                   Arrays.asList(new BinaryDocValuesField("value", new BytesRef("foo")),
+                                 new BinaryDocValuesField("value", new BytesRef("bar"))),
+                   Arrays.asList(new BytesRef("foo"),
+                                 new BytesRef("bar")));
+  }
+
+  public void testStringValSorted() throws IOException {
+    testComparator(new SortField("value", SortField.Type.STRING_VAL),
+                   Arrays.asList(new SortedDocValuesField("value", new BytesRef("foo")),
+                                 new SortedDocValuesField("value", new BytesRef("bar"))),
+                   Arrays.asList(new BytesRef("foo"),
+                                 new BytesRef("bar")));
+  }
+
+  public void testInt() throws IOException {
+    testComparator(new SortField("value", SortField.Type.INT),
+                   Arrays.asList(new NumericDocValuesField("value", 300000),
+                                 new NumericDocValuesField("value", Integer.MAX_VALUE),
+                                 new NumericDocValuesField("value", Integer.MIN_VALUE),
+                                 new NumericDocValuesField("value", -1),
+                                 new NumericDocValuesField("value", 4)),
+                   Arrays.asList(300000, Integer.MAX_VALUE, Integer.MIN_VALUE, -1, 4));
+  }
+
+  public void testIntMissing() throws IOException {
+    testComparator(new SortField("value", SortField.Type.INT),
+                   Arrays.asList(new NumericDocValuesField("value", 4),
+                                 null,
+                                 new NumericDocValuesField("value", Integer.MAX_VALUE),
+                                 new NumericDocValuesField("value", Integer.MIN_VALUE),
+                                 new NumericDocValuesField("value", -1)),
+                   // missing ints get sort value of 0 by default
+                   Arrays.asList(4, 0, Integer.MAX_VALUE, Integer.MIN_VALUE, -1));
+  }
+  
+  public void testIntMissingRandom() throws IOException {
+    final int missingValue = random().nextInt();
+    SortField sortField = new SortField("value", SortField.Type.INT);
+    sortField.setMissingValue(missingValue);
+    
+    testComparator(sortField,
+                   Arrays.asList(new NumericDocValuesField("value", 4),
+                                 null,
+                                 new NumericDocValuesField("value", -1)),
+                   Arrays.asList(4, missingValue, -1));
+  }
+  
+  public void testLong() throws IOException {
+    testComparator(new SortField("value", SortField.Type.LONG),
+                   Arrays.asList(new NumericDocValuesField("value", 3000000000L),
+                                 new NumericDocValuesField("value", -1),
+                                 new NumericDocValuesField("value", Long.MAX_VALUE),
+                                 new NumericDocValuesField("value", Long.MIN_VALUE),
+                                 new NumericDocValuesField("value", 4)),
+                   Arrays.asList(3000000000L, -1L, Long.MAX_VALUE, Long.MIN_VALUE, 4L));
+  }
+  
+  public void testLongMissing() throws IOException {
+    testComparator(new SortField("value", SortField.Type.LONG),
+                   Arrays.asList(new NumericDocValuesField("value", 3000000000L),
+                                 null,
+                                 new NumericDocValuesField("value", Long.MAX_VALUE),
+                                 new NumericDocValuesField("value", Long.MIN_VALUE),
+                                 new NumericDocValuesField("value", 4)),
+                   // missing longs get sort value of 0 by default
+                   Arrays.asList(3000000000L, 0L, Long.MAX_VALUE, Long.MIN_VALUE, 4L));
+  }
+  
+  /** Tests sorting on type long, specifying the missing value should be treated as Long.MAX_VALUE */
+  public void testLongMissingRandom() throws IOException {
+    final long missingValue = random().nextLong();
+    SortField sortField = new SortField("value", SortField.Type.LONG);
+    sortField.setMissingValue(missingValue);
+    
+    testComparator(sortField,
+                   Arrays.asList(new NumericDocValuesField("value", 3000000000L),
+                                 null,
+                                 new NumericDocValuesField("value", Long.MAX_VALUE),
+                                 new NumericDocValuesField("value", Long.MIN_VALUE),
+                                 new NumericDocValuesField("value", 4)),
+                   Arrays.asList(3000000000L, missingValue, Long.MAX_VALUE, Long.MIN_VALUE, 4L));
+  }
+  
+  public void testFloat() throws IOException {
+    testComparator(new SortField("value", SortField.Type.FLOAT),
+                   Arrays.asList(new FloatDocValuesField("value", 30.1F),
+                                 new FloatDocValuesField("value", Float.MAX_VALUE),
+                                 new FloatDocValuesField("value", Float.MIN_VALUE),
+                                 new FloatDocValuesField("value", Float.MIN_NORMAL),
+                                 new FloatDocValuesField("value", Float.NEGATIVE_INFINITY),
+                                 new FloatDocValuesField("value", Float.POSITIVE_INFINITY),
+                                 new FloatDocValuesField("value", -4F)),
+                   Arrays.asList(30.1F, Float.MAX_VALUE, Float.MIN_VALUE, Float.MIN_NORMAL,
+                                 Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, -4F));
+  }
+
+  public void testFloatMissing() throws IOException {
+    testComparator(new SortField("value", SortField.Type.FLOAT),
+                   Arrays.asList(new FloatDocValuesField("value", 30.1F),
+                                 new FloatDocValuesField("value", Float.MAX_VALUE),
+                                 null,
+                                 new FloatDocValuesField("value", Float.POSITIVE_INFINITY),
+                                 new FloatDocValuesField("value", -4F)),
+                   // missing float get sort value of 0 by default
+                   Arrays.asList(30.1F, Float.MAX_VALUE, 0.0F, Float.POSITIVE_INFINITY, -4F));
+  }
+
+  public void testFloatMissingRandom() throws IOException {
+    final float missingValue = random().nextFloat();
+    SortField sortField = new SortField("value", SortField.Type.FLOAT);
+    sortField.setMissingValue(missingValue);
+
+    testComparator(sortField,
+                   Arrays.asList(new FloatDocValuesField("value", 30.1F),
+                                 new FloatDocValuesField("value", Float.MAX_VALUE),
+                                 null,
+                                 new FloatDocValuesField("value", Float.POSITIVE_INFINITY),
+                                 new FloatDocValuesField("value", -4F)),
+                   Arrays.asList(30.1F, Float.MAX_VALUE, missingValue, Float.POSITIVE_INFINITY, -4F));
+  }
+
+  public void testDouble() throws IOException {
+    testComparator(new SortField("value", SortField.Type.DOUBLE),
+                   Arrays.asList(new DoubleDocValuesField("value", 30.1D),
+                                 new DoubleDocValuesField("value", +0D),
+                                 new DoubleDocValuesField("value", -0D),
+                                 new DoubleDocValuesField("value", Double.MAX_VALUE),
+                                 new DoubleDocValuesField("value", Double.MIN_VALUE),
+                                 new DoubleDocValuesField("value", Double.MIN_NORMAL),
+                                 new DoubleDocValuesField("value", Double.NEGATIVE_INFINITY),
+                                 new DoubleDocValuesField("value", Double.POSITIVE_INFINITY),
+                                 new DoubleDocValuesField("value", -4.2333333333332D)),
+                   Arrays.asList(30.1D, +0D, -0D, Double.MAX_VALUE, Double.MIN_VALUE, Double.MIN_NORMAL,
+                                 Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, -4.2333333333332D));
+  }
+  
+  public void testDoubleMissing() throws IOException {
+    testComparator(new SortField("value", SortField.Type.DOUBLE),
+                   Arrays.asList(new DoubleDocValuesField("value", 30.1D),
+                                 new DoubleDocValuesField("value", Double.MAX_VALUE),
+                                 null,
+                                 new DoubleDocValuesField("value", Double.POSITIVE_INFINITY),
+                                 new DoubleDocValuesField("value", -4.2333333333333D)),
+                   // missing float get sort value of 0 by default
+                   Arrays.asList(30.1D, Double.MAX_VALUE, 0.0D, Double.POSITIVE_INFINITY, -4.2333333333333D));
+  }
+  
+  public void testDoubleMissingRandom() throws IOException {
+    final double missingValue = random().nextDouble();
+    SortField sortField = new SortField("value", SortField.Type.DOUBLE);
+    sortField.setMissingValue(missingValue);
+    
+    testComparator(sortField,
+                   Arrays.asList(new DoubleDocValuesField("value", 30.1D),
+                                 null,
+                                 new DoubleDocValuesField("value", -4.2333333333333D)),
+                   Arrays.asList(30.1D, missingValue, -4.2333333333333D));
+  }
+}

Property changes on: lucene/core/src/test/org/apache/lucene/search/TestFieldComparatorValues.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/core/src/test/org/apache/lucene/search/TestSortRandom.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestSortRandom.java	(revision 1704070)
+++ lucene/core/src/test/org/apache/lucene/search/TestSortRandom.java	(working copy)
@@ -204,6 +204,9 @@
           System.out.println("    " + hitIDX + ": " + (br == null ? "<missing>" : br.utf8ToString()) + " id=" + s.doc(fd.doc).get("id"));
         }
       }
+
+      FieldComparator fc = sf.getComparator(1,0);
+      
       for(int hitIDX=0;hitIDX<hits.scoreDocs.length;hitIDX++) {
         final FieldDoc fd = (FieldDoc) hits.scoreDocs[hitIDX];
         BytesRef br = expected.get(hitIDX);
@@ -211,6 +214,20 @@
         BytesRef br2 = (BytesRef) fd.fields[0];
         
         assertEquals(br, br2);
+        
+        assertEquals(0, fc.compareValues(br, br2));
+        if (0 < hitIDX) {
+          BytesRef prev = (BytesRef) ((FieldDoc) hits.scoreDocs[hitIDX - 1]).fields[0];
+          int prevDoc = hits.scoreDocs[hitIDX - 1].doc;
+          int doc = hits.scoreDocs[hitIDX].doc;
+          int cmp = (reverse ? -1 : 1) * fc.compareValues(prev, br2);
+
+          assertTrue(sort.toString() + ": #" + hitIDX + ": " + cmp + "==compareValues(" +
+                     (prev == null ? "<missing>" : prev.utf8ToString()) + ", " +
+                     (br2 == null ? "<missing>" : br2.utf8ToString()) + ") for " + prevDoc + " vs " + doc,
+                     (cmp < 0 || ( (0 == cmp) && (prevDoc < doc)) ) );
+                      
+        }
       }
     }
 
Index: lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java	(revision 1704070)
+++ lucene/core/src/test/org/apache/lucene/search/TestTopDocsMerge.java	(working copy)
@@ -105,7 +105,11 @@
 
       for(int docIDX=0;docIDX<numDocs;docIDX++) {
         final Document doc = new Document();
-        doc.add(new SortedDocValuesField("string", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));
+        // 10% of the time, the document is missing the string value
+        if (random().nextInt(10) != 7) {
+          doc.add(new SortedDocValuesField("string", new BytesRef(TestUtil.randomRealisticUnicodeString(random()))));
+        }
+        
         doc.add(newTextField("text", content[random().nextInt(content.length)], Field.Store.NO));
         doc.add(new FloatDocValuesField("float", random().nextFloat()));
         final int intValue;
@@ -155,6 +159,14 @@
     }
 
     final List<SortField> sortFields = new ArrayList<>();
+    for (boolean rev : new boolean[] { true, false }) {
+      for (Object missing : new Object[] { SortField.STRING_FIRST, SortField.STRING_LAST }) {
+        SortField sf = new SortField("string", SortField.Type.STRING, rev);
+        sf.setMissingValue(missing);
+        sortFields.add(sf);
+      }
+    }
+    // these have missingValue==null, but that can't be explicitly set in loop above
     sortFields.add(new SortField("string", SortField.Type.STRING, true));
     sortFields.add(new SortField("string", SortField.Type.STRING, false));
     sortFields.add(new SortField("int", SortField.Type.INT, true));
