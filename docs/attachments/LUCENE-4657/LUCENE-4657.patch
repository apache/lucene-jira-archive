Index: lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java	(revision 1428589)
+++ lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.java	(working copy)
@@ -45,7 +45,6 @@
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.FieldCache;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.store.AlreadyClosedException;
@@ -1035,9 +1034,7 @@
               idField.setStringValue(Integer.toString(i));
               int action = random.nextInt(100);
               if (action%30 == 0) {
-                // TODO: deleteAll has bugs when dropping its readers! w.deleteAll();
-                // this is hiding the bugs to stop the jenkins madness!!!!
-                w.deleteDocuments(new MatchAllDocsQuery());
+                w.deleteAll();
               } else if (action%2 == 0) {
                 w.updateDocument(new Term("id", idField.stringValue()), doc);
               } else {
@@ -1047,11 +1044,10 @@
                 IndexReader r = null;
                 try {
                   r = DirectoryReader.open(w, random.nextBoolean());
-                  // TODO: more bugs!
-                  // if (random.nextBoolean() && r.maxDoc() > 0) {
-                  //  int docid = random.nextInt(r.maxDoc());
-                  //  w.tryDeleteDocument(r, docid);
-                  //}
+                  if (random.nextBoolean() && r.maxDoc() > 0) {
+                    int docid = random.nextInt(r.maxDoc());
+                    w.tryDeleteDocument(r, docid);
+                  }
                 } finally {
                   IOUtils.closeWhileHandlingException(r);
                 }
Index: lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/IndexWriter.java	(revision 1428589)
+++ lucene/core/src/java/org/apache/lucene/index/IndexWriter.java	(working copy)
@@ -453,15 +453,23 @@
     /** Remove all our references to readers, and commits
      *  any pending changes. */
     synchronized void dropAll(boolean doSave) throws IOException {
+      Throwable priorE = null;
       final Iterator<Map.Entry<SegmentInfoPerCommit,ReadersAndLiveDocs>> it = readerMap.entrySet().iterator();
       while(it.hasNext()) {
         final ReadersAndLiveDocs rld = it.next().getValue();
-        if (doSave && rld.writeLiveDocs(directory)) {
-          // Make sure we only write del docs for a live segment:
-          assert infoIsLive(rld.info);
-          // Must checkpoint w/ deleter, because we just
-          // created created new _X_N.del file.
-          deleter.checkpoint(segmentInfos, false);
+
+        try {
+          if (doSave && rld.writeLiveDocs(directory)) {
+            // Make sure we only write del docs for a live segment:
+            assert infoIsLive(rld.info);
+            // Must checkpoint w/ deleter, because we just
+            // created created new _X_N.del file.
+            deleter.checkpoint(segmentInfos, false);
+          }
+        } catch (Throwable t) {
+          if (priorE != null) {
+            priorE = t;
+          }
         }
 
         // Important to remove as-we-go, not with .clear()
@@ -474,9 +482,18 @@
         // actually close the SRs; this happens when a
         // near real-time reader is kept open after the
         // IndexWriter instance is closed:
-        rld.dropReaders();
+        try {
+          rld.dropReaders();
+        } catch (Throwable t) {
+          if (priorE != null) {
+            priorE = t;
+          }
+        }
       }
       assert readerMap.size() == 0;
+      if (priorE != null) {
+        throw new RuntimeException(priorE);
+      }
     }
 
     /**
@@ -3065,13 +3082,6 @@
       }
     }
 
-    // If new deletes were applied while we were merging
-    // (which happens if eg commit() or getReader() is
-    // called during our merge), then it better be the case
-    // that the delGen has increased for all our merged
-    // segments:
-    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();
-
     merge.info.setBufferedDeletesGen(minGen);
 
     return mergedDeletes;
Index: lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream.java	(revision 1428589)
+++ lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream.java	(working copy)
@@ -168,6 +168,8 @@
       infoStream.message("BD", "applyDeletes: infos=" + infos + " packetCount=" + deletes.size());
     }
 
+    final long gen = nextGen++;
+
     List<SegmentInfoPerCommit> infos2 = new ArrayList<SegmentInfoPerCommit>();
     infos2.addAll(infos);
     Collections.sort(infos2, sortSegInfoByDelGen);
@@ -255,7 +257,7 @@
          */
         delIDX--;
         infosIDX--;
-        info.setBufferedDeletesGen(nextGen);
+        info.setBufferedDeletesGen(gen);
 
       } else {
         //System.out.println("  gt");
@@ -290,7 +292,7 @@
             infoStream.message("BD", "seg=" + info + " segGen=" + segGen + " coalesced deletes=[" + (coalescedDeletes == null ? "null" : coalescedDeletes) + "] newDelCount=" + delCount + (segAllDeletes ? " 100% deleted" : ""));
           }
         }
-        info.setBufferedDeletesGen(nextGen);
+        info.setBufferedDeletesGen(gen);
 
         infosIDX--;
       }
@@ -302,7 +304,7 @@
     }
     // assert infos != segmentInfos || !any() : "infos=" + infos + " segmentInfos=" + segmentInfos + " any=" + any;
 
-    return new ApplyDeletesResult(anyNewDeletes, nextGen++, allDeleted);
+    return new ApplyDeletesResult(anyNewDeletes, gen, allDeleted);
   }
 
   synchronized long getNextGen() {
