Index: lucene/core/src/java/org/apache/lucene/search/FieldComparator.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/FieldComparator.java	(revision 1650205)
+++ lucene/core/src/java/org/apache/lucene/search/FieldComparator.java	(working copy)
@@ -867,6 +867,21 @@
 
     @Override
     public void setScorer(Scorer scorer) {}
+    
+    /** expert: compares two documents in this leaf */
+    public int compareDocs(int doc1, int doc2) {
+      int ord1 = termsIndex.getOrd(doc1);
+      int ord2 = termsIndex.getOrd(doc2);
+      if (missingOrd != -1) {
+        if (ord1 == -1) {
+          ord1 = missingOrd;
+        }
+        if (ord1 == -1) {
+          ord2 = missingOrd;
+        }
+      }
+      return Integer.compare(ord1, ord2);
+    }
   }
   
   /** Sorts by field's natural Term sort order.  All
Index: lucene/misc/src/java/org/apache/lucene/index/Sorter.java
===================================================================
--- lucene/misc/src/java/org/apache/lucene/index/Sorter.java	(revision 1650205)
+++ lucene/misc/src/java/org/apache/lucene/index/Sorter.java	(working copy)
@@ -20,6 +20,7 @@
 import java.io.IOException;
 import java.util.Comparator;
 
+import org.apache.lucene.search.FieldComparator.TermOrdValComparator;
 import org.apache.lucene.search.LeafFieldComparator;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.Sort;
@@ -84,7 +85,7 @@
 
     /** Compare docID1 against docID2. The contract for the return value is the
      *  same as {@link Comparator#compare(Object, Object)}. */
-    public abstract int compare(int docID1, int docID2);
+    public abstract int compare(int docID1, int docID2) throws IOException;
 
   }
 
@@ -103,7 +104,11 @@
     
     @Override
     protected int compare(int i, int j) {
-      return comparator.compare(docs[i], docs[j]);
+      try {
+        return comparator.compare(docs[i], docs[j]);
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
     }
     
     @Override
@@ -130,12 +135,16 @@
 
     @Override
     protected int compareSaved(int i, int j) {
-      return comparator.compare(tmp[i], docs[j]);
+      try {
+        return comparator.compare(tmp[i], docs[j]);
+      } catch (IOException e) {
+        throw new RuntimeException(e);
+      }
     }
   }
 
   /** Computes the old-to-new permutation over the given comparator. */
-  private static Sorter.DocMap sort(final int maxDoc, DocComparator comparator) {
+  private static Sorter.DocMap sort(final int maxDoc, DocComparator comparator) throws IOException {
     // check if the index is sorted
     boolean sorted = true;
     for (int i = 1; i < maxDoc; ++i) {
@@ -219,26 +228,41 @@
       comparators[i] = fields[i].getComparator(1, i).getLeafComparator(reader.getContext());
       comparators[i].setScorer(FAKESCORER);
     }
-    final DocComparator comparator = new DocComparator() {
-      @Override
-      public int compare(int docID1, int docID2) {
-        try {
+    
+    final DocComparator comparator;
+    if (comparators.length == 1 && comparators[0] instanceof TermOrdValComparator) {
+      // single-comparator string impl (no term lookups)
+      final TermOrdValComparator termOrds = (TermOrdValComparator) comparators[0];
+      final int singleMul = reverseMul[0];
+      comparator = new DocComparator() {
+        @Override
+        public int compare(int docID1, int docID2) throws IOException {
+          int comp = termOrds.compareDocs(docID1, docID2);
+          if (comp != 0) {
+            return singleMul * comp;
+          } else {
+            return Integer.compare(docID1, docID2);
+          }
+        }
+      };
+    } else {
+      // generic multi-comparator impl
+      comparator = new DocComparator() {
+        @Override
+        public int compare(int docID1, int docID2) throws IOException {
           for (int i = 0; i < comparators.length; i++) {
-            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,
-            // the segments are always the same here...
-            comparators[i].copy(0, docID1);
-            comparators[i].setBottom(0);
-            int comp = reverseMul[i] * comparators[i].compareBottom(docID2);
+            LeafFieldComparator comparator = comparators[i];
+            comparator.copy(0, docID1);
+            comparator.setBottom(0);
+            int comp = comparator.compareBottom(docID2);
             if (comp != 0) {
-              return comp;
+              return reverseMul[i] * comp;
             }
           }
           return Integer.compare(docID1, docID2); // docid order tiebreak
-        } catch (IOException e) {
-          throw new RuntimeException(e);
         }
-      }
-    };
+      };
+    }
     return sort(reader.maxDoc(), comparator);
   }
 
Index: lucene/misc/src/java/org/apache/lucene/index/SortingMergePolicy.java
===================================================================
--- lucene/misc/src/java/org/apache/lucene/index/SortingMergePolicy.java	(revision 1650205)
+++ lucene/misc/src/java/org/apache/lucene/index/SortingMergePolicy.java	(working copy)
@@ -89,6 +89,7 @@
             infoStream.message("SMP", "seg=" + leaf + " " + sortDescription);
           }
         }
+        long startTime = System.nanoTime();
         // wrap readers, to be optimal for merge;
         List<LeafReader> wrapped = new ArrayList<>(unsortedReaders.size());
         for (LeafReader leaf : unsortedReaders) {
@@ -106,6 +107,10 @@
         }
         docMap = sorter.sort(atomicView);
         sortedView = SortingLeafReader.wrap(atomicView, docMap);
+        long endTime = System.nanoTime();
+        if (infoStream.isEnabled("SMP")) {
+          infoStream.message("SMP", ((endTime-startTime)/1000000) + " msec to build sorted docmaps");
+        }
       }
       // a null doc map means that the readers are already sorted
       if (docMap == null) {
