Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFieldFragList.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFieldFragList.java	(revision 0)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFieldFragList.java	(revision 0)
@@ -0,0 +1,139 @@
+package org.apache.lucene.search.vectorhighlight;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.search.vectorhighlight.FieldPhraseList.FieldPhraseInfo;
+import org.apache.lucene.search.vectorhighlight.FieldPhraseList.FieldPhraseInfo.Toffs;
+
+/* (non-Javadoc)
+ * @see org.apache.lucene.search.vectorhighlight.FieldFragList
+ */
+public abstract class BaseFieldFragList implements FieldFragList {
+
+  private List<FieldFragInfo> fragInfos = new ArrayList<FieldFragInfo>();
+  
+  protected int fragCharSize;
+
+  /**
+   * a constructor.
+   * 
+   * @param fragCharSize the length (number of chars) of a fragment
+   */
+  public BaseFieldFragList( int fragCharSize ){
+    this.fragCharSize = fragCharSize;
+  }
+
+  /* (non-Javadoc)
+   * @see org.apache.lucene.search.vectorhighlight.FieldFragList#add( int startOffset, int endOffset, List<WeightedPhraseInfo> phraseInfoList )
+   */
+  @Override
+  public abstract void add( int startOffset, int endOffset, List<FieldPhraseInfo> phraseInfoList );
+  
+  /* (non-Javadoc)
+   * @see org.apache.lucene.search.vectorhighlight.FieldFragList#getFragInfos()
+   */ 
+  @Override
+  public List<FieldFragInfo> getFragInfos() {
+    return fragInfos;
+  }
+
+  public static class FieldFragInfo {
+
+    private List<SubInfo> subInfos;
+    private float score;
+    private int startOffset;
+    private int endOffset;
+
+    public FieldFragInfo( int startOffset, int endOffset, List<SubInfo> subInfos, float score ){
+      this.startOffset = startOffset;
+      this.endOffset = endOffset;
+      this.score = score;
+      this.subInfos = subInfos;
+    }
+    
+    public List<SubInfo> getSubInfos(){
+      return subInfos;
+    }
+    
+    public float getScore(){
+      return score;
+    }
+    
+    public int getStartOffset(){
+      return startOffset;
+    }
+    
+    public int getEndOffset(){
+      return endOffset;
+    }
+    
+    @Override
+    public String toString(){
+      StringBuilder sb = new StringBuilder();
+      sb.append( "subInfos=(" );
+      for( SubInfo si : subInfos )
+        sb.append( si.toString() );
+      sb.append( ")/" ).append( score ).append( '(' ).append( startOffset ).append( ',' ).append( endOffset ).append( ')' );
+      return sb.toString();
+    }
+    
+    public static class SubInfo {
+      
+      // unnecessary member, just exists for debugging purpose
+      private final String text;  
+      
+      // usually termsOffsets.size() == 1,
+      // but if position-gap > 1 and slop > 0 then size() could be greater than 1
+      private final List<Toffs> termsOffsets; 
+      
+      private int seqnum;
+
+      public SubInfo( String text, List<Toffs> termsOffsets, int seqnum ){
+        this.text = text;
+        this.termsOffsets = termsOffsets;
+        this.seqnum = seqnum;
+      }
+      
+      public List<Toffs> getTermsOffsets(){
+        return termsOffsets;
+      }
+      
+      public int getSeqnum(){
+        return seqnum;
+      }
+      
+      public String getText(){
+        return text;
+      }
+      
+      @Override
+      public String toString(){
+        StringBuilder sb = new StringBuilder();
+        sb.append( text ).append( '(' );
+        for( Toffs to : termsOffsets )
+          sb.append( to.toString() );
+        sb.append( ')' );
+        return sb.toString();
+      }
+    }
+  }
+  
+}
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragListBuilder.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragListBuilder.java	(revision 0)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragListBuilder.java	(revision 0)
@@ -0,0 +1,99 @@
+package org.apache.lucene.search.vectorhighlight;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.lucene.search.vectorhighlight.FieldPhraseList.FieldPhraseInfo;
+
+/**
+ * A abstract implementation of {@link FragListBuilder}.
+ */
+public abstract class BaseFragListBuilder implements FragListBuilder {
+  
+  public static final int MARGIN_DEFAULT = 6;
+  public static final int MIN_FRAG_CHAR_SIZE_FACTOR = 3;
+
+  final int margin;
+  final int minFragCharSize;
+
+  public BaseFragListBuilder( int margin ){
+    if( margin < 0 )
+      throw new IllegalArgumentException( "margin(" + margin + ") is too small. It must be 0 or higher." );
+
+    this.margin = margin;
+    this.minFragCharSize = Math.max( 1, margin * MIN_FRAG_CHAR_SIZE_FACTOR );
+  }
+
+  public BaseFragListBuilder(){
+    this( MARGIN_DEFAULT );
+  }
+  
+  protected FieldFragList createFieldFragList( FieldPhraseList fieldPhraseList, FieldFragList fieldFragList, int fragCharSize ){
+    List<FieldPhraseInfo> wpil = new ArrayList<FieldPhraseInfo>();
+    Iterator<FieldPhraseInfo> ite = fieldPhraseList.getPhraseList().iterator();
+    FieldPhraseInfo phraseInfo = null;
+    int startOffset = 0;
+    boolean taken = false;
+    while( true ){
+      if( !taken ){
+        if( !ite.hasNext() ) break;
+        phraseInfo = ite.next();
+      }
+      taken = false;
+      if( phraseInfo == null ) break;
+
+      // if the phrase violates the border of previous fragment, discard it and try next phrase
+      if( phraseInfo.getStartOffset() < startOffset ) continue;
+
+      wpil.clear();
+      wpil.add( phraseInfo );
+      int st = phraseInfo.getStartOffset() - margin < startOffset ?
+          startOffset : phraseInfo.getStartOffset() - margin;
+      int en = st + fragCharSize;
+      if( phraseInfo.getEndOffset() > en )
+        en = phraseInfo.getEndOffset();
+      startOffset = en;
+
+      while( true ){
+        if( ite.hasNext() ){
+          phraseInfo = ite.next();
+          taken = true;
+          if( phraseInfo == null ) break;
+        }
+        else
+          break;
+        if( phraseInfo.getEndOffset() <= en )
+          wpil.add( phraseInfo );
+        else
+          break;
+      }
+      fieldFragList.add( st, en, wpil );
+    }
+    return fieldFragList;
+  }
+
+  /* (non-Javadoc)
+   * @see org.apache.lucene.search.vectorhighlight.FragListBuilder#createFieldFragList(FieldPhraseList fieldPhraseList, int fragCharSize)
+   */ 
+  @Override
+  public abstract FieldFragList createFieldFragList( FieldPhraseList fieldPhraseList, int fragCharSize );
+  
+}
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragmentsBuilder.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragmentsBuilder.java	(revision 1333494)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/BaseFragmentsBuilder.java	(working copy)
@@ -27,9 +27,9 @@
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.highlight.DefaultEncoder;
 import org.apache.lucene.search.highlight.Encoder;
-import org.apache.lucene.search.vectorhighlight.FieldFragList.WeightedFragInfo;
-import org.apache.lucene.search.vectorhighlight.FieldFragList.WeightedFragInfo.SubInfo;
-import org.apache.lucene.search.vectorhighlight.FieldPhraseList.WeightedPhraseInfo.Toffs;
+import org.apache.lucene.search.vectorhighlight.BaseFieldFragList.FieldFragInfo;
+import org.apache.lucene.search.vectorhighlight.BaseFieldFragList.FieldFragInfo.SubInfo;
+import org.apache.lucene.search.vectorhighlight.FieldPhraseList.FieldPhraseInfo.Toffs;
 
 public abstract class BaseFragmentsBuilder implements FragmentsBuilder {
 
@@ -71,7 +71,7 @@
     throw new IllegalArgumentException( "type of preTags/postTags must be a String or String[]" );
   }
   
-  public abstract List<WeightedFragInfo> getWeightedFragInfoList( List<WeightedFragInfo> src );
+  public abstract List<FieldFragInfo> getWeightedFragInfoList( List<FieldFragInfo> src );
 
   private static final Encoder NULL_ENCODER = new DefaultEncoder();
   
@@ -103,7 +103,7 @@
     if( maxNumFragments < 0 )
       throw new IllegalArgumentException( "maxNumFragments(" + maxNumFragments + ") must be positive number." );
 
-    List<WeightedFragInfo> fragInfos = getWeightedFragInfoList( fieldFragList.getFragInfos() );
+    List<FieldFragInfo> fragInfos = getWeightedFragInfoList( fieldFragList.getFragInfos() );
     
     List<String> fragments = new ArrayList<String>( maxNumFragments );
     Field[] values = getFields( reader, docId, fieldName );
@@ -111,7 +111,7 @@
     StringBuilder buffer = new StringBuilder();
     int[] nextValueIndex = { 0 };
     for( int n = 0; n < maxNumFragments && n < fragInfos.size(); n++ ){
-      WeightedFragInfo fragInfo = fragInfos.get( n );
+      FieldFragInfo fragInfo = fragInfos.get( n );
       fragments.add( makeFragment( buffer, nextValueIndex, values, fragInfo, preTags, postTags, encoder ) );
     }
     return fragments.toArray( new String[fragments.size()] );
@@ -130,31 +130,31 @@
   }
 
   @Deprecated
-  protected String makeFragment( StringBuilder buffer, int[] index, String[] values, WeightedFragInfo fragInfo ){
-    final int s = fragInfo.startOffset;
-    return makeFragment( fragInfo, getFragmentSource( buffer, index, values, s, fragInfo.endOffset ), s,
+  protected String makeFragment( StringBuilder buffer, int[] index, String[] values, FieldFragInfo fragInfo ){
+    final int s = fragInfo.getStartOffset();
+    return makeFragment( fragInfo, getFragmentSource( buffer, index, values, s, fragInfo.getEndOffset() ), s,
         preTags, postTags, NULL_ENCODER );
   }
   
-  private String makeFragment( WeightedFragInfo fragInfo, String src, int s,
+  private String makeFragment( FieldFragInfo fragInfo, String src, int s,
       String[] preTags, String[] postTags, Encoder encoder ){
     StringBuilder fragment = new StringBuilder();
     int srcIndex = 0;
-    for( SubInfo subInfo : fragInfo.subInfos ){
-      for( Toffs to : subInfo.termsOffsets ){
+    for( SubInfo subInfo : fragInfo.getSubInfos() ){
+      for( Toffs to : subInfo.getTermsOffsets() ){
         fragment
-          .append( encoder.encodeText( src.substring( srcIndex, to.startOffset - s ) ) )
-          .append( getPreTag( preTags, subInfo.seqnum ) )
-          .append( encoder.encodeText( src.substring( to.startOffset - s, to.endOffset - s ) ) )
-          .append( getPostTag( postTags, subInfo.seqnum ) );
-        srcIndex = to.endOffset - s;
+          .append( encoder.encodeText( src.substring( srcIndex, to.getStartOffset() - s ) ) )
+          .append( getPreTag( preTags, subInfo.getSeqnum() ) )
+          .append( encoder.encodeText( src.substring( to.getStartOffset() - s, to.getEndOffset() - s ) ) )
+          .append( getPostTag( postTags, subInfo.getSeqnum() ) );
+        srcIndex = to.getEndOffset() - s;
       }
     }
     fragment.append( encoder.encodeText( src.substring( srcIndex ) ) );
     return fragment.toString();
   }
 
-  protected String makeFragment( StringBuilder buffer, int[] index, Field[] values, WeightedFragInfo fragInfo,
+  protected String makeFragment( StringBuilder buffer, int[] index, Field[] values, FieldFragInfo fragInfo,
       String[] preTags, String[] postTags, Encoder encoder ){
     StringBuilder fragment = new StringBuilder();
     final int s = fragInfo.getStartOffset();
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FastVectorHighlighter.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FastVectorHighlighter.java	(revision 1333494)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FastVectorHighlighter.java	(working copy)
@@ -45,7 +45,7 @@
   }
 
   /**
-   * a constructor. Using {@link SimpleFragListBuilder} and {@link ScoreOrderFragmentsBuilder}.
+   * a constructor. Using {@link FragListBuilder} and {@link ScoreOrderFragmentsBuilder}.
    * 
    * @param phraseHighlight true or false for phrase highlighting
    * @param fieldMatch true of false for field matching
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldFragList.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldFragList.java	(revision 1333494)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldFragList.java	(working copy)
@@ -17,121 +17,31 @@
  * limitations under the License.
  */
 
-import java.util.ArrayList;
 import java.util.List;
 
-import org.apache.lucene.search.vectorhighlight.FieldPhraseList.WeightedPhraseInfo;
-import org.apache.lucene.search.vectorhighlight.FieldPhraseList.WeightedPhraseInfo.Toffs;
+import org.apache.lucene.search.vectorhighlight.BaseFieldFragList.FieldFragInfo;
+import org.apache.lucene.search.vectorhighlight.FieldPhraseList.FieldPhraseInfo;
 
 /**
  * FieldFragList has a list of "frag info" that is used by FragmentsBuilder class
  * to create fragments (snippets).
  */
-public class FieldFragList {
-
-  private List<WeightedFragInfo> fragInfos = new ArrayList<WeightedFragInfo>();
-
-  /**
-   * a constructor.
-   * 
-   * @param fragCharSize the length (number of chars) of a fragment
-   */
-  public FieldFragList( int fragCharSize ){
-  }
+public interface FieldFragList {
 
   /**
-   * convert the list of WeightedPhraseInfo to WeightedFragInfo, then add it to the fragInfos
+   * convert the list of FieldPhraseInfo to FieldFragInfo, then add it to the fragInfos
    * 
    * @param startOffset start offset of the fragment
    * @param endOffset end offset of the fragment
-   * @param phraseInfoList list of WeightedPhraseInfo objects
+   * @param phraseInfoList list of FieldPhraseInfo objects
    */
-  public void add( int startOffset, int endOffset, List<WeightedPhraseInfo> phraseInfoList ){
-    fragInfos.add( new WeightedFragInfo( startOffset, endOffset, phraseInfoList ) );
-  }
-  
+  public abstract void add( int startOffset, int endOffset, List<FieldPhraseInfo> phraseInfoList );
+
   /**
-   * return the list of WeightedFragInfos.
+   * return the list of FieldFragInfos.
    * 
    * @return fragInfos.
-   */ 
-  public List<WeightedFragInfo> getFragInfos() {
-    return fragInfos;
-  }
-
-  public static class WeightedFragInfo {
-
-    List<SubInfo> subInfos;
-    float totalBoost;
-    int startOffset;
-    int endOffset;
-
-    public WeightedFragInfo( int startOffset, int endOffset, List<WeightedPhraseInfo> phraseInfoList ){
-      this.startOffset = startOffset;
-      this.endOffset = endOffset;
-      subInfos = new ArrayList<SubInfo>();
-      for( WeightedPhraseInfo phraseInfo : phraseInfoList ){
-        SubInfo subInfo = new SubInfo( phraseInfo.text, phraseInfo.termsOffsets, phraseInfo.seqnum );
-        subInfos.add( subInfo );
-        totalBoost += phraseInfo.boost;
-      }
-    }
-    
-    public List<SubInfo> getSubInfos(){
-      return subInfos;
-    }
-    
-    public float getTotalBoost(){
-      return totalBoost;
-    }
-    
-    public int getStartOffset(){
-      return startOffset;
-    }
-    
-    public int getEndOffset(){
-      return endOffset;
-    }
-    
-    @Override
-    public String toString(){
-      StringBuilder sb = new StringBuilder();
-      sb.append( "subInfos=(" );
-      for( SubInfo si : subInfos )
-        sb.append( si.toString() );
-      sb.append( ")/" ).append( totalBoost ).append( '(' ).append( startOffset ).append( ',' ).append( endOffset ).append( ')' );
-      return sb.toString();
-    }
-    
-    public static class SubInfo {
-      final String text;  // unnecessary member, just exists for debugging purpose
-      final List<Toffs> termsOffsets;   // usually termsOffsets.size() == 1,
-                              // but if position-gap > 1 and slop > 0 then size() could be greater than 1
-      int seqnum;
+   */
+  public abstract List<FieldFragInfo> getFragInfos();
 
-      SubInfo( String text, List<Toffs> termsOffsets, int seqnum ){
-        this.text = text;
-        this.termsOffsets = termsOffsets;
-        this.seqnum = seqnum;
-      }
-      
-      public List<Toffs> getTermsOffsets(){
-        return termsOffsets;
-      }
-      
-      public int getSeqnum(){
-        return seqnum;
-      }
-      
-      @Override
-      public String toString(){
-        StringBuilder sb = new StringBuilder();
-        sb.append( text ).append( '(' );
-        for( Toffs to : termsOffsets )
-          sb.append( to.toString() );
-        sb.append( ')' );
-        return sb.toString();
-      }
-    }
-  }
-}
+}
\ No newline at end of file
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList.java	(revision 1333494)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldPhraseList.java	(working copy)
@@ -1,4 +1,5 @@
 package org.apache.lucene.search.vectorhighlight;
+
 /**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -24,12 +25,12 @@
 import org.apache.lucene.search.vectorhighlight.FieldTermStack.TermInfo;
 
 /**
- * FieldPhraseList has a list of WeightedPhraseInfo that is used by FragListBuilder
+ * FieldPhraseList has a list of FieldPhraseInfo that is used by FragListBuilder
  * to create a FieldFragList object.
  */
 public class FieldPhraseList {
 
-  LinkedList<WeightedPhraseInfo> phraseList = new LinkedList<WeightedPhraseInfo>();
+  private LinkedList<FieldPhraseInfo> phraseList = new LinkedList<FieldPhraseInfo>();
   
   /**
    * create a FieldPhraseList that has no limit on the number of phrases to analyze
@@ -38,7 +39,7 @@
    * @param fieldQuery FieldQuery object
    */
   public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery){
-      this (fieldTermStack, fieldQuery, Integer.MAX_VALUE);
+    this( fieldTermStack, fieldQuery, Integer.MAX_VALUE );
   }
   
   /**
@@ -49,17 +50,17 @@
    * @param phraseLimit maximum size of phraseList
    */
   public FieldPhraseList( FieldTermStack fieldTermStack, FieldQuery fieldQuery, int phraseLimit){
-    final String field = fieldTermStack.getFieldName();
-
+    
+    String fieldName = fieldTermStack.getFieldName();
+    
     LinkedList<TermInfo> phraseCandidate = new LinkedList<TermInfo>();
     QueryPhraseMap currMap = null;
     QueryPhraseMap nextMap = null;
-    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) )
-    {      
+    while( !fieldTermStack.isEmpty() && (phraseList.size() < phraseLimit) ){      
       phraseCandidate.clear();
 
       TermInfo ti = fieldTermStack.pop();
-      currMap = fieldQuery.getFieldTermMap( field, ti.getText() );
+      currMap = fieldQuery.getFieldTermMap( fieldName, ti.getText() );
 
       // if not found, discard top TermInfo from stack, then try next element
       if( currMap == null ) continue;
@@ -75,14 +76,14 @@
           if( ti != null )
             fieldTermStack.push( ti );
           if( currMap.isValidTermOrPhrase( phraseCandidate ) ){
-            addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );
+            addIfNoOverlap( new FieldPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );
           }
           else{
             while( phraseCandidate.size() > 1 ){
               fieldTermStack.push( phraseCandidate.removeLast() );
-              currMap = fieldQuery.searchPhrase( field, phraseCandidate );
+              currMap = fieldQuery.searchPhrase( fieldName, phraseCandidate );
               if( currMap != null ){
-                addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );
+                addIfNoOverlap( new FieldPhraseInfo( phraseCandidate, currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );
                 break;
               }
             }
@@ -96,30 +97,49 @@
       }
     }
   }
-  
-  void addIfNoOverlap( WeightedPhraseInfo wpi ){
-    for( WeightedPhraseInfo existWpi : phraseList ){
-      if( existWpi.isOffsetOverlap( wpi ) ) return;
+
+  /**
+   * @return the phraseList
+   */
+  public LinkedList<FieldPhraseInfo> getPhraseList() {
+    return phraseList;
+  }
+
+  public void addIfNoOverlap( FieldPhraseInfo wpi ){
+    for( FieldPhraseInfo existWpi : phraseList ){
+      if( existWpi.isOffsetOverlap( wpi ) ) {
+        existWpi.getTermsInfos().addAll( wpi.getTermsInfos() );
+        return;
+      }
     }
     phraseList.add( wpi );
   }
   
-  public static class WeightedPhraseInfo {
+  public static class FieldPhraseInfo {
 
-    String text;  // unnecessary member, just exists for debugging purpose
-    List<Toffs> termsOffsets;   // usually termsOffsets.size() == 1,
-                            // but if position-gap > 1 and slop > 0 then size() could be greater than 1
-    float boost;  // query boost
-    int seqnum;
+    // unnecessary member, just exists for debugging purpose
+    private String text;  
+    
+    // usually termsOffsets.size() == 1,
+    // but if position-gap > 1 and slop > 0 then size() could be greater than 1
+    private List<Toffs> termsOffsets;  
+    
+    // Term-info
+    private List<TermInfo> termsInfos;
+    
+    // query boost
+    private float boost;  
+    private int seqnum;
     
-    public WeightedPhraseInfo( LinkedList<TermInfo> terms, float boost ){
+    public FieldPhraseInfo( LinkedList<TermInfo> terms, float boost ){
       this( terms, boost, 0 );
     }
     
-    public WeightedPhraseInfo( LinkedList<TermInfo> terms, float boost, int number ){
+    public FieldPhraseInfo( LinkedList<TermInfo> terms, float boost, int number ){
       this.boost = boost;
       this.seqnum = number;
       termsOffsets = new ArrayList<Toffs>( terms.size() );
+      termsInfos = new ArrayList<TermInfo>( terms );
       TermInfo ti = terms.get( 0 );
       termsOffsets.add( new Toffs( ti.getStartOffset(), ti.getEndOffset() ) );
       if( terms.size() == 1 ){
@@ -143,6 +163,22 @@
       }
       text = sb.toString();
     }
+
+    public List<TermInfo> getTermsInfos() {
+      return termsInfos;
+    }
+
+    public float getBoost(){
+      return boost;
+    }
+    
+    public String getText(){
+      return text;
+    }
+    
+    public List<Toffs> getTermsOffset(){
+      return termsOffsets;
+    }
     
     public int getStartOffset(){
       return termsOffsets.get( 0 ).startOffset;
@@ -151,8 +187,12 @@
     public int getEndOffset(){
       return termsOffsets.get( termsOffsets.size() - 1 ).endOffset;
     }
+
+    public int getSeqnum(){
+      return seqnum;
+    }
     
-    public boolean isOffsetOverlap( WeightedPhraseInfo other ){
+    public boolean isOffsetOverlap( FieldPhraseInfo other ){
       int so = getStartOffset();
       int eo = getEndOffset();
       int oso = other.getStartOffset();
@@ -167,7 +207,7 @@
     @Override
     public String toString(){
       StringBuilder sb = new StringBuilder();
-      sb.append( text ).append( '(' ).append( boost ).append( ")(" );
+      sb.append( text.trim() ).append( '(' ).append( boost ).append( ")(" );
       for( Toffs to : termsOffsets ){
         sb.append( to );
       }
@@ -176,21 +216,27 @@
     }
     
     public static class Toffs {
-      int startOffset;
-      int endOffset;
+      
+      private int startOffset;
+      private int endOffset;
+      
       public Toffs( int startOffset, int endOffset ){
         this.startOffset = startOffset;
         this.endOffset = endOffset;
       }
+      
       public void setEndOffset( int endOffset ){
         this.endOffset = endOffset;
       }
+      
       public int getStartOffset(){
         return startOffset;
       }
+      
       public int getEndOffset(){
         return endOffset;
       }
+      
       @Override
       public String toString(){
         StringBuilder sb = new StringBuilder();
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java	(revision 1333494)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldQuery.java	(working copy)
@@ -273,7 +273,7 @@
    *      - fieldMatch==false
    *          termSetMap=Map<null,Set<"john","lennon">>
    */
-    void saveTerms( Collection<Query> flatQueries, IndexReader reader ) throws IOException{
+  void saveTerms( Collection<Query> flatQueries, IndexReader reader ) throws IOException{
     for( Query query : flatQueries ){
       Set<String> termSet = getTermSet( query );
       if( query instanceof TermQuery )
@@ -365,7 +365,7 @@
       return map;
     }
 
-      void add( Query query, IndexReader reader ) throws IOException {
+    void add( Query query, IndexReader reader ) throws IOException {
       if( query instanceof TermQuery ){
         addTerm( ((TermQuery)query).getTerm(), query.getBoost() );
       }
@@ -402,7 +402,7 @@
     public boolean isTerminal(){
       return terminal;
     }
-    
+
     public int getSlop(){
       return slop;
     }
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldTermStack.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldTermStack.java	(revision 1333494)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldTermStack.java	(working copy)
@@ -18,27 +18,30 @@
 
 import java.io.IOException;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.LinkedList;
+import java.util.Map;
 import java.util.Set;
 
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.WhitespaceAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.Field.Index;
-import org.apache.lucene.document.Field.Store;
-import org.apache.lucene.document.Field.TermVector;
+//import org.apache.lucene.analysis.Analyzer;
+//import org.apache.lucene.analysis.WhitespaceAnalyzer;
+//import org.apache.lucene.document.Document;
+//import org.apache.lucene.document.Field;
+//import org.apache.lucene.document.Field.Index;
+//import org.apache.lucene.document.Field.Store;
+//import org.apache.lucene.document.Field.TermVector;
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.IndexWriterConfig;
+//import org.apache.lucene.index.IndexWriter;
+//import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermFreqVector;
 import org.apache.lucene.index.TermPositionVector;
 import org.apache.lucene.index.TermVectorOffsetInfo;
-import org.apache.lucene.queryParser.QueryParser;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.RAMDirectory;
-import org.apache.lucene.util.Version;
+//import org.apache.lucene.queryParser.QueryParser;
+//import org.apache.lucene.search.Query;
+//import org.apache.lucene.store.Directory;
+//import org.apache.lucene.store.RAMDirectory;
+//import org.apache.lucene.util.Version;
 
 /**
  * <code>FieldTermStack</code> is a stack that keeps query terms in the specified field
@@ -49,24 +52,24 @@
   private final String fieldName;
   LinkedList<TermInfo> termList = new LinkedList<TermInfo>();
   
-  public static void main( String[] args ) throws Exception {
-    Analyzer analyzer = new WhitespaceAnalyzer(Version.LUCENE_CURRENT);
-    QueryParser parser = new QueryParser(Version.LUCENE_CURRENT,  "f", analyzer );
-    Query query = parser.parse( "a x:b" );
-    FieldQuery fieldQuery = new FieldQuery( query, true, false );
-    
-    Directory dir = new RAMDirectory();
-    IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(Version.LUCENE_CURRENT, analyzer));
-    Document doc = new Document();
-    doc.add( new Field( "f", "a a a b b c a b b c d e f", Store.YES, Index.ANALYZED, TermVector.WITH_POSITIONS_OFFSETS ) );
-    doc.add( new Field( "f", "b a b a f", Store.YES, Index.ANALYZED, TermVector.WITH_POSITIONS_OFFSETS ) );
-    writer.addDocument( doc );
-    writer.close();
-    
-    IndexReader reader = IndexReader.open( dir, true );
-    new FieldTermStack( reader, 0, "f", fieldQuery );
-    reader.close();
-  }
+//  public static void main( String[] args ) throws Exception {
+//    Analyzer analyzer = new WhitespaceAnalyzer(Version.LUCENE_CURRENT);
+//    QueryParser parser = new QueryParser(Version.LUCENE_CURRENT,  "f", analyzer );
+//    Query query = parser.parse( "a x:b" );
+//    FieldQuery fieldQuery = new FieldQuery( query, true, false );
+//    
+//    Directory dir = new RAMDirectory();
+//    IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(Version.LUCENE_CURRENT, analyzer));
+//    Document doc = new Document();
+//    doc.add( new Field( "f", "a a a b b c a b b c d e f", Store.YES, Index.ANALYZED, TermVector.WITH_POSITIONS_OFFSETS ) );
+//    doc.add( new Field( "f", "b a b a f", Store.YES, Index.ANALYZED, TermVector.WITH_POSITIONS_OFFSETS ) );
+//    writer.addDocument( doc );
+//    writer.close();
+//    
+//    IndexReader reader = IndexReader.open( dir, true );
+//    new FieldTermStack( reader, 0, "f", fieldQuery );
+//    reader.close();
+//  }
 
   /**
    * a constructor.
@@ -93,8 +96,12 @@
     catch( ClassCastException e ){
       return; // just return to make null snippets
     }
-    
+
+    Map<String,Float> lookup = new HashMap<String,Float>();
     
+    int numDocs = reader.numDocs() - reader.numDeletedDocs();
+    float weight = 0;
+
     for( String term : tpv.getTerms() ){
       if( !termSet.contains( term ) ) continue;
       int index = tpv.indexOf( term );
@@ -102,8 +109,17 @@
       if( tvois == null ) return; // just return to make null snippets
       int[] poss = tpv.getTermPositions( index );
       if( poss == null ) return; // just return to make null snippets
+      
+      // We don't want to retrieve docFreq every time.
+      if ( lookup.containsKey( term ) ) 
+        weight = lookup.get(term).floatValue();
+      else {
+        weight = ( float ) ( Math.log( numDocs / ( double ) ( reader.docFreq( new Term(fieldName, term) ) + 1 ) ) + 1.0 );
+        lookup.put( term, new Float( weight ) );
+      }
+      
       for( int i = 0; i < tvois.length; i++ )
-        termList.add( new TermInfo( term, tvois[i].getStartOffset(), tvois[i].getEndOffset(), poss[i] ) );
+        termList.add( new TermInfo( term, tvois[i].getStartOffset(), tvois[i].getEndOffset(), poss[i], weight ) );
     }
     
     // sort by position
@@ -143,22 +159,30 @@
   
   public static class TermInfo implements Comparable<TermInfo>{
 
-    final String text;
-    final int startOffset;
-    final int endOffset;
-    final int position;
+    private final String text;
+    private final int startOffset;
+    private final int endOffset;
+    private final int position;
+    private final float weight;
 
-    TermInfo( String text, int startOffset, int endOffset, int position ){
+    public TermInfo( String text, int startOffset, int endOffset, int position, float weight ){
       this.text = text;
       this.startOffset = startOffset;
       this.endOffset = endOffset;
       this.position = position;
+      this.weight = weight;
+    }
+    
+    // A constructor for the test-case
+    public TermInfo( String text, int startOffset, int endOffset, int position ){
+      this( text, startOffset, endOffset, position, 1 );
     }
     
     public String getText(){ return text; }
     public int getStartOffset(){ return startOffset; }
     public int getEndOffset(){ return endOffset; }
     public int getPosition(){ return position; }
+    public float getWeight(){ return weight; }
     
     @Override
     public String toString(){
@@ -171,4 +195,4 @@
       return ( this.position - o.position );
     }
   }
-}
+}
\ No newline at end of file
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FragListBuilder.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FragListBuilder.java	(revision 1333494)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FragListBuilder.java	(working copy)
@@ -31,4 +31,5 @@
    * @return the created FieldFragList object
    */
   public FieldFragList createFieldFragList( FieldPhraseList fieldPhraseList, int fragCharSize );
+
 }
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/ScoreOrderFragmentsBuilder.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/ScoreOrderFragmentsBuilder.java	(revision 1333494)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/ScoreOrderFragmentsBuilder.java	(working copy)
@@ -21,7 +21,7 @@
 import java.util.Comparator;
 import java.util.List;
 
-import org.apache.lucene.search.vectorhighlight.FieldFragList.WeightedFragInfo;
+import org.apache.lucene.search.vectorhighlight.BaseFieldFragList.FieldFragInfo;
 
 /**
  * An implementation of FragmentsBuilder that outputs score-order fragments.
@@ -57,20 +57,21 @@
    * Sort by score the list of WeightedFragInfo
    */
   @Override
-  public List<WeightedFragInfo> getWeightedFragInfoList( List<WeightedFragInfo> src ) {
+  public List<FieldFragInfo> getWeightedFragInfoList( List<FieldFragInfo> src ) {
     Collections.sort( src, new ScoreComparator() );
     return src;
   }
+  
+  public static class ScoreComparator implements Comparator<FieldFragInfo> {
 
-  public static class ScoreComparator implements Comparator<WeightedFragInfo> {
-
-    public int compare( WeightedFragInfo o1, WeightedFragInfo o2 ) {
-      if( o1.totalBoost > o2.totalBoost ) return -1;
-      else if( o1.totalBoost < o2.totalBoost ) return 1;
+    @Override
+    public int compare( FieldFragInfo o1, FieldFragInfo o2 ) {
+      if( o1.getScore() > o2.getScore() ) return -1;
+      else if( o1.getScore() < o2.getScore() ) return 1;
       // if same score then check startOffset
       else{
-        if( o1.startOffset < o2.startOffset ) return -1;
-        else if( o1.startOffset > o2.startOffset ) return 1;
+        if( o1.getStartOffset() < o2.getStartOffset() ) return -1;
+        else if( o1.getStartOffset() > o2.getStartOffset() ) return 1;
       }
       return 0;
     }
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SimpleFieldFragList.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SimpleFieldFragList.java	(revision 0)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SimpleFieldFragList.java	(revision 0)
@@ -0,0 +1,53 @@
+package org.apache.lucene.search.vectorhighlight;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.search.vectorhighlight.BaseFieldFragList.FieldFragInfo.SubInfo;
+import org.apache.lucene.search.vectorhighlight.FieldPhraseList.FieldPhraseInfo;
+
+/**
+ * A simple implementation of {@link FielFragList}.
+ */
+public class SimpleFieldFragList extends BaseFieldFragList {
+
+  /**
+   * a constructor.
+   * 
+   * @param fragCharSize the length (number of chars) of a fragment
+   */
+  public SimpleFieldFragList( int fragCharSize ) {
+    super( fragCharSize );
+  }
+
+  /* (non-Javadoc)
+   * @see org.apache.lucene.search.vectorhighlight.FieldFragList#add(int startOffset, int endOffset, List<FieldPhraseInfo> phraseInfoList)
+   */ 
+  @Override
+  public void add( int startOffset, int endOffset, List<FieldPhraseInfo> phraseInfoList ) {
+    float score = 0;
+    List<SubInfo> subInfos = new ArrayList<SubInfo>();
+    for( FieldPhraseInfo phraseInfo : phraseInfoList ){
+      subInfos.add( new SubInfo( phraseInfo.getText(), phraseInfo.getTermsOffset(), phraseInfo.getSeqnum() ) );
+      score += phraseInfo.getBoost();
+    }
+    getFragInfos().add( new FieldFragInfo( startOffset, endOffset, subInfos, score ) );
+  }
+}
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SimpleFragListBuilder.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SimpleFragListBuilder.java	(revision 1333494)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SimpleFragListBuilder.java	(working copy)
@@ -17,83 +17,23 @@
  * limitations under the License.
  */
 
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
-import org.apache.lucene.search.vectorhighlight.FieldPhraseList.WeightedPhraseInfo;
-
 /**
  * A simple implementation of {@link FragListBuilder}.
  */
-public class SimpleFragListBuilder implements FragListBuilder {
+public class SimpleFragListBuilder extends BaseFragListBuilder {
   
-  public static final int MARGIN_DEFAULT = 6;
-  public static final int MIN_FRAG_CHAR_SIZE_FACTOR = 3;
-
-  final int margin;
-  final int minFragCharSize;
-
-  public SimpleFragListBuilder( int margin ){
-    if( margin < 0 )
-      throw new IllegalArgumentException( "margin(" + margin + ") is too small. It must be 0 or higher." );
-
-    this.margin = margin;
-    this.minFragCharSize = Math.max( 1, margin * MIN_FRAG_CHAR_SIZE_FACTOR );
+  public SimpleFragListBuilder() {
+    super();
   }
 
-  public SimpleFragListBuilder(){
-    this( MARGIN_DEFAULT );
+  public SimpleFragListBuilder(int margin) {
+    super(margin);
   }
 
-  public FieldFragList createFieldFragList(FieldPhraseList fieldPhraseList, int fragCharSize) {
-    if( fragCharSize < minFragCharSize )
-      throw new IllegalArgumentException( "fragCharSize(" + fragCharSize + ") is too small. It must be " +
-          minFragCharSize + " or higher." );
-
-    FieldFragList ffl = new FieldFragList( fragCharSize );
-
-    List<WeightedPhraseInfo> wpil = new ArrayList<WeightedPhraseInfo>();
-    Iterator<WeightedPhraseInfo> ite = fieldPhraseList.phraseList.iterator();
-    WeightedPhraseInfo phraseInfo = null;
-    int startOffset = 0;
-    boolean taken = false;
-    while( true ){
-      if( !taken ){
-        if( !ite.hasNext() ) break;
-        phraseInfo = ite.next();
-      }
-      taken = false;
-      if( phraseInfo == null ) break;
-
-      // if the phrase violates the border of previous fragment, discard it and try next phrase
-      if( phraseInfo.getStartOffset() < startOffset ) continue;
-
-      wpil.clear();
-      wpil.add( phraseInfo );
-      int st = phraseInfo.getStartOffset() - margin < startOffset ?
-          startOffset : phraseInfo.getStartOffset() - margin;
-      int en = st + fragCharSize;
-      if( phraseInfo.getEndOffset() > en )
-        en = phraseInfo.getEndOffset();
-      startOffset = en;
-
-      while( true ){
-        if( ite.hasNext() ){
-          phraseInfo = ite.next();
-          taken = true;
-          if( phraseInfo == null ) break;
-        }
-        else
-          break;
-        if( phraseInfo.getEndOffset() <= en )
-          wpil.add( phraseInfo );
-        else
-          break;
-      }
-      ffl.add( st, en, wpil );
-    }
-    return ffl;
+  /* (non-Javadoc)
+   * @see org.apache.lucene.search.vectorhighlight.FragListBuilder#createFieldFragList(FieldPhraseList fieldPhraseList, int fragCharSize)
+   */ 
+  public FieldFragList createFieldFragList( FieldPhraseList fieldPhraseList, int fragCharSize ){
+    return createFieldFragList( fieldPhraseList, new SimpleFieldFragList( fragCharSize ), fragCharSize );
   }
-
-}
+}
\ No newline at end of file
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SimpleFragmentsBuilder.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SimpleFragmentsBuilder.java	(revision 1333494)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SimpleFragmentsBuilder.java	(working copy)
@@ -19,7 +19,7 @@
 
 import java.util.List;
 
-import org.apache.lucene.search.vectorhighlight.FieldFragList.WeightedFragInfo;
+import org.apache.lucene.search.vectorhighlight.BaseFieldFragList.FieldFragInfo;
 
 /**
  * A simple implementation of FragmentsBuilder.
@@ -56,7 +56,7 @@
    * do nothing. return the source list.
    */
   @Override
-  public List<WeightedFragInfo> getWeightedFragInfoList( List<WeightedFragInfo> src ) {
+  public List<FieldFragInfo> getWeightedFragInfoList( List<FieldFragInfo> src ) {
     return src;
   }
 }
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SingleFragListBuilder.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SingleFragListBuilder.java	(revision 1333494)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/SingleFragListBuilder.java	(working copy)
@@ -21,11 +21,11 @@
 import java.util.Iterator;
 import java.util.List;
 
-import org.apache.lucene.search.vectorhighlight.FieldFragList.WeightedFragInfo;
-import org.apache.lucene.search.vectorhighlight.FieldPhraseList.WeightedPhraseInfo;
+import org.apache.lucene.search.vectorhighlight.BaseFieldFragList.FieldFragInfo;
+import org.apache.lucene.search.vectorhighlight.FieldPhraseList.FieldPhraseInfo;
 
 /**
- * An implementation class of {@link FragListBuilder} that generates one {@link WeightedFragInfo} object.
+ * An implementation class of {@link FragListBuilder} that generates one {@link FieldFragInfo} object.
  * Typical use case of this class is that you can get an entire field contents
  * by using both of this class and {@link SimpleFragmentsBuilder}.<br/>
  * <pre>
@@ -38,11 +38,11 @@
   public FieldFragList createFieldFragList(FieldPhraseList fieldPhraseList,
       int fragCharSize) {
 
-    FieldFragList ffl = new FieldFragList( fragCharSize );
+    FieldFragList ffl = new SimpleFieldFragList( fragCharSize );
 
-    List<WeightedPhraseInfo> wpil = new ArrayList<WeightedPhraseInfo>();
-    Iterator<WeightedPhraseInfo> ite = fieldPhraseList.phraseList.iterator();
-    WeightedPhraseInfo phraseInfo = null;
+    List<FieldPhraseInfo> wpil = new ArrayList<FieldPhraseInfo>();
+    Iterator<FieldPhraseInfo> ite = fieldPhraseList.getPhraseList().iterator();
+    FieldPhraseInfo phraseInfo = null;
     while( true ){
       if( !ite.hasNext() ) break;
       phraseInfo = ite.next();
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/WeightedFieldFragList.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/WeightedFieldFragList.java	(revision 0)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/WeightedFieldFragList.java	(revision 0)
@@ -0,0 +1,77 @@
+package org.apache.lucene.search.vectorhighlight;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.lucene.search.vectorhighlight.BaseFieldFragList.FieldFragInfo.SubInfo;
+import org.apache.lucene.search.vectorhighlight.FieldPhraseList.FieldPhraseInfo;
+import org.apache.lucene.search.vectorhighlight.FieldTermStack.TermInfo;
+
+/**
+ * A weighted implementation of {@link FieldFragList}.
+ */
+public class WeightedFieldFragList extends BaseFieldFragList {
+
+  /**
+   * a constructor.
+   * 
+   * @param fragCharSize the length (number of chars) of a fragment
+   */
+  public WeightedFieldFragList( int fragCharSize ) {
+    super( fragCharSize );
+  }
+
+  /* (non-Javadoc)
+   * @see org.apache.lucene.search.vectorhighlight.FieldFragList#add(int startOffset, int endOffset, List<FieldPhraseInfo> phraseInfoList)
+   */ 
+  @Override
+  public void add( int startOffset, int endOffset, List<FieldPhraseInfo> phraseInfoList ) {
+    
+    List<SubInfo> subInfos = new ArrayList<SubInfo>();
+    Set<String> distinctTerms = new HashSet<String>();
+
+    int length = 0;
+    float score = 0;
+    String text;
+
+    for( FieldPhraseInfo phraseInfo : phraseInfoList ){
+      subInfos.add( new SubInfo( phraseInfo.getText(), phraseInfo.getTermsOffset(), phraseInfo.getSeqnum() ) );
+      for( TermInfo ti : phraseInfo.getTermsInfos() ) {
+        text = ti.getText();
+        if ( text.contains( "_" ) ) 
+          text = text.substring( 0, text.indexOf( '_' ) );
+        if ( distinctTerms.add( text ) ) 
+          score += Math.pow( ti.getWeight(), 2 ) * phraseInfo.getBoost();
+      }
+      length++;
+    }
+    
+    // We want that terms per fragment (length) is included into the weight. Otherwise a one-word-query
+    // would cause an equal weight for all fragments regardless of how much words are in there.  
+    // To avoid that fragments with a lot of words possibly "outrank" more relevant fragments
+    // we "bend" the length with a standard-normalization.  
+    score *= length * ( 1 / Math.sqrt( length ) );
+    
+    getFragInfos().add( new FieldFragInfo( startOffset, endOffset, subInfos, score ) );
+  }
+  
+}
\ No newline at end of file
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/WeightedFragListBuilder.java
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/WeightedFragListBuilder.java	(revision 0)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/WeightedFragListBuilder.java	(revision 0)
@@ -0,0 +1,41 @@
+package org.apache.lucene.search.vectorhighlight;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * A weighted implementation of {@link FragListBuilder}.
+ */
+public class WeightedFragListBuilder extends BaseFragListBuilder {
+  
+  public WeightedFragListBuilder() {
+    super();
+  }
+
+  public WeightedFragListBuilder(int margin) {
+    super(margin);
+  }
+
+  /* (non-Javadoc)
+   * @see org.apache.lucene.search.vectorhighlight.FragListBuilder#createFieldFragList(FieldPhraseList fieldPhraseList, int fragCharSize)
+   */ 
+  @Override
+  public FieldFragList createFieldFragList( FieldPhraseList fieldPhraseList, int fragCharSize ){
+    return createFieldFragList( fieldPhraseList, new WeightedFieldFragList( fragCharSize ), fragCharSize );
+  }
+  
+}
Index: lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/package.html
===================================================================
--- lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/package.html	(revision 1333494)
+++ lucene/contrib/highlighter/src/java/org/apache/lucene/search/vectorhighlight/package.html	(working copy)
@@ -26,8 +26,8 @@
 <li>support phrase-unit highlighting with slops</li>
 <li>support multi-term (includes wildcard, range, regexp, etc) queries</li>
 <li>need Java 1.5</li>
-<li>highlight fields need to be TermVector.WITH_POSITIONS_OFFSETS</li>
-<li>take into account query boost to score fragments</li>
+<li>highlight fields need to be stored with Positions and Offsets</li>
+<li>take into account query boost and/or IDF-weight to score fragments</li>
 <li>support colored highlight tags</li>
 <li>pluggable FragListBuilder</li>
 <li>pluggable FragmentsBuilder</li>
@@ -96,7 +96,7 @@
 
 <h3>Step 2.</h3>
 <p>In Step 2, Fast Vector Highlighter generates {@link org.apache.lucene.search.vectorhighlight.FieldTermStack}. Fast Vector Highlighter uses {@link org.apache.lucene.index.TermFreqVector} data
-(must be stored {@link org.apache.lucene.document.Field.TermVector#WITH_POSITIONS_OFFSETS})
+(must be stored {@link org.apache.lucene.document.FieldType#setStoreTermVectorOffsets(boolean)} and {@link org.apache.lucene.document.FieldType#setStoreTermVectorPositions(boolean)})
 to generate it. <code>FieldTermStack</code> keeps the terms in the user query.
 Therefore, in this sample case, Fast Vector Highlighter generates the following <code>FieldTermStack</code>:</p>
 <pre>
@@ -121,10 +121,12 @@
 |"search library"|[(12,18),(26,33)]|w=1|
 +----------------+-----------------+---+
 </pre>
-<p>The type of each entry is <code>WeightedPhraseInfo</code> that consists of
-an array of terms offsets and weight. The weight (Fast Vector Highlighter uses query boost to
-calculate the weight) will be taken into account when Fast Vector Highlighter creates
-{@link org.apache.lucene.search.vectorhighlight.FieldFragList} in the next step.</p>
+<p>The type of each entry is <code>FieldPhraseInfo</code> that consists of
+an array of  <code>Toffs</code> (terms offsets) and an array <code>TermInfo</code> (terms information). 
+<!--The weight (Fast Vector Highlighter uses query boost to-->
+<!--calculate the weight) will be taken into account when Fast Vector Highlighter creates-->
+<!--{@link org.apache.lucene.search.vectorhighlight.FieldFragList} in the next step.-->
+</p>
 <h3>Step 4.</h3>
 <p>In Step 4, Fast Vector Highlighter creates <code>FieldFragList</code> by reference to
 <code>FieldPhraseList</code>. In this sample case, the following
@@ -134,9 +136,42 @@
 +---------------------------------+
 |"Lucene"[(0,6)]                  |
 |"search library"[(12,18),(26,33)]|
-|totalBoost=3                     |
+|score=3                          |
 +---------------------------------+
 </pre>
+
+<p>
+The calculation of the score of each fragment depends on the implementation of <code>FragListBuilder</code> and <code>FieldFragList</code>. 
+Currently there are basically to approaches available:
+<ul>
+<li>SimpleFragListBuilder: <i>sum-of-boosts</i>-approach. The score is calculated by summarizing the query-boosts per term. Per default a term is boosted by 1.0</li>
+<li>WeightedFragListBuilder: <i>sum-of-distinct-weights</i>-approach. The score is calculated by summarizing the IDF-weights of distinct terms.</li>
+</ul> 
+<p>Comparison of the two approaches</b>:</p>
+<table border="1">
+<caption>
+	<b>query = das alte testament</b>
+</caption>
+<tr><th>Terms in fragment</th><th>sum-of-distinct-weights</th><th>sum-of-boosts</th></tr>
+<tr><td>das alte testament</td><td>5.339621</td><td>3.0</td></tr>
+<tr><td>das alte testament</td><td>5.339621</td><td>3.0</td></tr>
+<tr><td>das testament alte</td><td>5.339621</td><td>3.0</td></tr>
+<tr><td>das alte testament</td><td>5.339621</td><td>3.0</td></tr>
+<tr><td>das testament</td><td>2.9455688</td><td>2.0</td></tr>
+<tr><td>das alte</td><td>2.4759595</td><td>2.0</td></tr>
+<tr><td>das das das das</td><td>1.5015357</td><td>4.0</td></tr>
+<tr><td>das das das</td><td>1.3003681</td><td>3.0</td></tr>
+<tr><td>das das</td><td>1.061746</td><td>2.0</td></tr>
+<tr><td>alte</td><td>1.0</td><td>1.0</td></tr>
+<tr><td>alte</td><td>1.0</td><td>1.0</td></tr>
+<tr><td>das</td><td>0.7507678</td><td>1.0</td></tr>
+<tr><td>das</td><td>0.7507678</td><td>1.0</td></tr>
+<tr><td>das</td><td>0.7507678</td><td>1.0</td></tr>
+<tr><td>das</td><td>0.7507678</td><td>1.0</td></tr>
+<tr><td>das</td><td>0.7507678</td><td>1.0</td></tr>
+</table>
+
+
 <h3>Step 5.</h3>
 <p>In Step 5, by using <code>FieldFragList</code> and the field stored data,
 Fast Vector Highlighter creates highlighted snippets!</p>
Index: lucene/contrib/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FieldPhraseListTest.java
===================================================================
--- lucene/contrib/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FieldPhraseListTest.java	(revision 1333494)
+++ lucene/contrib/highlighter/src/test/org/apache/lucene/search/vectorhighlight/FieldPhraseListTest.java	(working copy)
@@ -27,13 +27,13 @@
     FieldQuery fq = new FieldQuery( tq( "a" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "a(1.0)((0,1))", fpl.phraseList.get( 0 ).toString() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "a(1.0)((0,1))", fpl.getPhraseList().get( 0 ).toString() );
 
     fq = new FieldQuery( tq( "b" ), true, true );
     stack = new FieldTermStack( reader, 0, F, fq );
     fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 0, fpl.phraseList.size() );
+    assertEquals( 0, fpl.getPhraseList().size() );
   }
   
   public void test2TermsIndex() throws Exception {
@@ -42,9 +42,9 @@
     FieldQuery fq = new FieldQuery( tq( "a" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 2, fpl.phraseList.size() );
-    assertEquals( "a(1.0)((0,1))", fpl.phraseList.get( 0 ).toString() );
-    assertEquals( "a(1.0)((2,3))", fpl.phraseList.get( 1 ).toString() );
+    assertEquals( 2, fpl.getPhraseList().size() );
+    assertEquals( "a(1.0)((0,1))", fpl.getPhraseList().get( 0 ).toString() );
+    assertEquals( "a(1.0)((2,3))", fpl.getPhraseList().get( 1 ).toString() );
   }
   
   public void test1PhraseIndex() throws Exception {
@@ -53,14 +53,14 @@
     FieldQuery fq = new FieldQuery( pqF( "a", "b" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "ab(1.0)((0,3))", fpl.phraseList.get( 0 ).toString() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "ab(1.0)((0,3))", fpl.getPhraseList().get( 0 ).toString() );
 
     fq = new FieldQuery( tq( "b" ), true, true );
     stack = new FieldTermStack( reader, 0, F, fq );
     fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "b(1.0)((2,3))", fpl.phraseList.get( 0 ).toString() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "b(1.0)((2,3))", fpl.getPhraseList().get( 0 ).toString() );
   }
   
   public void test1PhraseIndexB() throws Exception {
@@ -72,8 +72,8 @@
     FieldQuery fq = new FieldQuery( pqF( "ba", "ac" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "baac(1.0)((2,5))", fpl.phraseList.get( 0 ).toString() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "baac(1.0)((2,5))", fpl.getPhraseList().get( 0 ).toString() );
   }
   
   public void test2ConcatTermsIndexB() throws Exception {
@@ -85,9 +85,9 @@
     FieldQuery fq = new FieldQuery( tq( "ab" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 2, fpl.phraseList.size() );
-    assertEquals( "ab(1.0)((0,2))", fpl.phraseList.get( 0 ).toString() );
-    assertEquals( "ab(1.0)((2,4))", fpl.phraseList.get( 1 ).toString() );
+    assertEquals( 2, fpl.getPhraseList().size() );
+    assertEquals( "ab(1.0)((0,2))", fpl.getPhraseList().get( 0 ).toString() );
+    assertEquals( "ab(1.0)((2,4))", fpl.getPhraseList().get( 1 ).toString() );
   }
   
   public void test2Terms1PhraseIndex() throws Exception {
@@ -97,16 +97,16 @@
     FieldQuery fq = new FieldQuery( pqF( "a", "b" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "ab(1.0)((4,7))", fpl.phraseList.get( 0 ).toString() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "ab(1.0)((4,7))", fpl.getPhraseList().get( 0 ).toString() );
 
     // phraseHighlight = false
     fq = new FieldQuery( pqF( "a", "b" ), false, true );
     stack = new FieldTermStack( reader, 0, F, fq );
     fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 2, fpl.phraseList.size() );
-    assertEquals( "a(1.0)((2,3))", fpl.phraseList.get( 0 ).toString() );
-    assertEquals( "ab(1.0)((4,7))", fpl.phraseList.get( 1 ).toString() );
+    assertEquals( 2, fpl.getPhraseList().size() );
+    assertEquals( "a(1.0)((2,3))", fpl.getPhraseList().get( 0 ).toString() );
+    assertEquals( "ab(1.0)((4,7))", fpl.getPhraseList().get( 1 ).toString() );
   }
   
   public void testPhraseSlop() throws Exception {
@@ -115,10 +115,10 @@
     FieldQuery fq = new FieldQuery( pqF( 2F, 1, "a", "c" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "ac(2.0)((4,5)(8,9))", fpl.phraseList.get( 0 ).toString() );
-    assertEquals( 4, fpl.phraseList.get( 0 ).getStartOffset() );
-    assertEquals( 9, fpl.phraseList.get( 0 ).getEndOffset() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "ac(2.0)((4,5)(8,9))", fpl.getPhraseList().get( 0 ).toString() );
+    assertEquals( 4, fpl.getPhraseList().get( 0 ).getStartOffset() );
+    assertEquals( 9, fpl.getPhraseList().get( 0 ).getEndOffset() );
   }
   
   public void test2PhrasesOverlap() throws Exception {
@@ -130,8 +130,8 @@
     FieldQuery fq = new FieldQuery( query, true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "abc(1.0)((2,7))", fpl.phraseList.get( 0 ).toString() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "abc(1.0)((2,7))", fpl.getPhraseList().get( 0 ).toString() );
   }
   
   public void test3TermsPhrase() throws Exception {
@@ -140,8 +140,8 @@
     FieldQuery fq = new FieldQuery( pqF( "a", "b", "c" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "abc(1.0)((6,11))", fpl.phraseList.get( 0 ).toString() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "abc(1.0)((6,11))", fpl.getPhraseList().get( 0 ).toString() );
   }
   
   public void testSearchLongestPhrase() throws Exception {
@@ -153,9 +153,9 @@
     FieldQuery fq = new FieldQuery( query, true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 2, fpl.phraseList.size() );
-    assertEquals( "ab(1.0)((2,5))", fpl.phraseList.get( 0 ).toString() );
-    assertEquals( "abc(1.0)((10,15))", fpl.phraseList.get( 1 ).toString() );
+    assertEquals( 2, fpl.getPhraseList().size() );
+    assertEquals( "ab(1.0)((2,5))", fpl.getPhraseList().get( 0 ).toString() );
+    assertEquals( "abc(1.0)((10,15))", fpl.getPhraseList().get( 1 ).toString() );
   }
   
   public void test1PhraseShortMV() throws Exception {
@@ -164,8 +164,8 @@
     FieldQuery fq = new FieldQuery( tq( "d" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "d(1.0)((9,10))", fpl.phraseList.get( 0 ).toString() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "d(1.0)((9,10))", fpl.getPhraseList().get( 0 ).toString() );
   }
   
   public void test1PhraseLongMV() throws Exception {
@@ -174,9 +174,9 @@
     FieldQuery fq = new FieldQuery( pqF( "search", "engines" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 2, fpl.phraseList.size() );
-    assertEquals( "searchengines(1.0)((102,116))", fpl.phraseList.get( 0 ).toString() );
-    assertEquals( "searchengines(1.0)((157,171))", fpl.phraseList.get( 1 ).toString() );
+    assertEquals( 2, fpl.getPhraseList().size() );
+    assertEquals( "searchengines(1.0)((102,116))", fpl.getPhraseList().get( 0 ).toString() );
+    assertEquals( "searchengines(1.0)((157,171))", fpl.getPhraseList().get( 1 ).toString() );
   }
 
   public void test1PhraseLongMVB() throws Exception {
@@ -185,8 +185,8 @@
     FieldQuery fq = new FieldQuery( pqF( "sp", "pe", "ee", "ed" ), true, true ); // "speed" -(2gram)-> "sp","pe","ee","ed"
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "sppeeeed(1.0)((88,93))", fpl.phraseList.get( 0 ).toString() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "sppeeeed(1.0)((88,93))", fpl.getPhraseList().get( 0 ).toString() );
   }
   
   /* This test shows a big speedup from limiting the number of analyzed phrases in 
@@ -212,10 +212,10 @@
       FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
       FieldPhraseList fpl = new FieldPhraseList( stack, fq, limit);
       if (limit < 0 || limit > 16000)
-          assertEquals( 16000, fpl.phraseList.size() );
+          assertEquals( 16000, fpl.getPhraseList().size() );
       else
-          assertEquals( limit, fpl.phraseList.size() );
-      assertEquals( "a(1.0)((0,1))", fpl.phraseList.get( 0 ).toString() );      
+          assertEquals( limit, fpl.getPhraseList().size() );
+      assertEquals( "a(1.0)((0,1))", fpl.getPhraseList().get( 0 ).toString() );      
   }
   */
 }
Index: lucene/contrib/highlighter/src/test/org/apache/lucene/search/vectorhighlight/IndexTimeSynonymTest.java
===================================================================
--- lucene/contrib/highlighter/src/test/org/apache/lucene/search/vectorhighlight/IndexTimeSynonymTest.java	(revision 1333494)
+++ lucene/contrib/highlighter/src/test/org/apache/lucene/search/vectorhighlight/IndexTimeSynonymTest.java	(working copy)
@@ -154,10 +154,10 @@
     FieldQuery fq = new FieldQuery( pqF( "personal", "computer" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "personalcomputer(1.0)((3,5))", fpl.phraseList.get( 0 ).toString() );
-    assertEquals( 3, fpl.phraseList.get( 0 ).getStartOffset() );
-    assertEquals( 5, fpl.phraseList.get( 0 ).getEndOffset() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "personalcomputer(1.0)((3,5))", fpl.getPhraseList().get( 0 ).toString() );
+    assertEquals( 3, fpl.getPhraseList().get( 0 ).getStartOffset() );
+    assertEquals( 5, fpl.getPhraseList().get( 0 ).getEndOffset() );
   }
   
   public void testFieldPhraseListIndex1w2wSearch1partial() throws Exception {
@@ -166,10 +166,10 @@
     FieldQuery fq = new FieldQuery( tq( "computer" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "computer(1.0)((3,5))", fpl.phraseList.get( 0 ).toString() );
-    assertEquals( 3, fpl.phraseList.get( 0 ).getStartOffset() );
-    assertEquals( 5, fpl.phraseList.get( 0 ).getEndOffset() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "computer(1.0)((3,5))", fpl.getPhraseList().get( 0 ).toString() );
+    assertEquals( 3, fpl.getPhraseList().get( 0 ).getStartOffset() );
+    assertEquals( 5, fpl.getPhraseList().get( 0 ).getEndOffset() );
   }
   
   public void testFieldPhraseListIndex1w2wSearch1term1phrase() throws Exception {
@@ -181,10 +181,10 @@
     FieldQuery fq = new FieldQuery( bq, true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertTrue( fpl.phraseList.get( 0 ).toString().indexOf( "(1.0)((3,5))" ) > 0 );
-    assertEquals( 3, fpl.phraseList.get( 0 ).getStartOffset() );
-    assertEquals( 5, fpl.phraseList.get( 0 ).getEndOffset() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertTrue( fpl.getPhraseList().get( 0 ).toString().indexOf( "(1.0)((3,5))" ) > 0 );
+    assertEquals( 3, fpl.getPhraseList().get( 0 ).getStartOffset() );
+    assertEquals( 5, fpl.getPhraseList().get( 0 ).getEndOffset() );
   }
   
   public void testFieldPhraseListIndex2w1wSearch1term() throws Exception {
@@ -193,10 +193,10 @@
     FieldQuery fq = new FieldQuery( tq( "pc" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "pc(1.0)((3,20))", fpl.phraseList.get( 0 ).toString() );
-    assertEquals( 3, fpl.phraseList.get( 0 ).getStartOffset() );
-    assertEquals( 20, fpl.phraseList.get( 0 ).getEndOffset() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "pc(1.0)((3,20))", fpl.getPhraseList().get( 0 ).toString() );
+    assertEquals( 3, fpl.getPhraseList().get( 0 ).getStartOffset() );
+    assertEquals( 20, fpl.getPhraseList().get( 0 ).getEndOffset() );
   }
   
   public void testFieldPhraseListIndex2w1wSearch1phrase() throws Exception {
@@ -205,10 +205,10 @@
     FieldQuery fq = new FieldQuery( pqF( "personal", "computer" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "personalcomputer(1.0)((3,20))", fpl.phraseList.get( 0 ).toString() );
-    assertEquals( 3, fpl.phraseList.get( 0 ).getStartOffset() );
-    assertEquals( 20, fpl.phraseList.get( 0 ).getEndOffset() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "personalcomputer(1.0)((3,20))", fpl.getPhraseList().get( 0 ).toString() );
+    assertEquals( 3, fpl.getPhraseList().get( 0 ).getStartOffset() );
+    assertEquals( 20, fpl.getPhraseList().get( 0 ).getEndOffset() );
   }
   
   public void testFieldPhraseListIndex2w1wSearch1partial() throws Exception {
@@ -217,10 +217,10 @@
     FieldQuery fq = new FieldQuery( tq( "computer" ), true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertEquals( "computer(1.0)((3,20))", fpl.phraseList.get( 0 ).toString() );
-    assertEquals( 3, fpl.phraseList.get( 0 ).getStartOffset() );
-    assertEquals( 20, fpl.phraseList.get( 0 ).getEndOffset() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertEquals( "computer(1.0)((3,20))", fpl.getPhraseList().get( 0 ).toString() );
+    assertEquals( 3, fpl.getPhraseList().get( 0 ).getStartOffset() );
+    assertEquals( 20, fpl.getPhraseList().get( 0 ).getEndOffset() );
   }
   
   public void testFieldPhraseListIndex2w1wSearch1term1phrase() throws Exception {
@@ -232,10 +232,10 @@
     FieldQuery fq = new FieldQuery( bq, true, true );
     FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
     FieldPhraseList fpl = new FieldPhraseList( stack, fq );
-    assertEquals( 1, fpl.phraseList.size() );
-    assertTrue( fpl.phraseList.get( 0 ).toString().indexOf( "(1.0)((3,20))" ) > 0 );
-    assertEquals( 3, fpl.phraseList.get( 0 ).getStartOffset() );
-    assertEquals( 20, fpl.phraseList.get( 0 ).getEndOffset() );
+    assertEquals( 1, fpl.getPhraseList().size() );
+    assertTrue( fpl.getPhraseList().get( 0 ).toString().indexOf( "(1.0)((3,20))" ) > 0 );
+    assertEquals( 3, fpl.getPhraseList().get( 0 ).getStartOffset() );
+    assertEquals( 20, fpl.getPhraseList().get( 0 ).getEndOffset() );
   }
 
   private void makeIndex1w() throws Exception {
Index: lucene/contrib/highlighter/src/test/org/apache/lucene/search/vectorhighlight/WeightedFragListBuilderTest.java
===================================================================
--- lucene/contrib/highlighter/src/test/org/apache/lucene/search/vectorhighlight/WeightedFragListBuilderTest.java	(revision 0)
+++ lucene/contrib/highlighter/src/test/org/apache/lucene/search/vectorhighlight/WeightedFragListBuilderTest.java	(revision 0)
@@ -0,0 +1,34 @@
+package org.apache.lucene.search.vectorhighlight;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class WeightedFragListBuilderTest extends AbstractTestCase {
+  
+  public void test1PhraseLongMV() throws Exception {
+    makeIndexLongMV();
+
+    FieldQuery fq = new FieldQuery( pqF( "the", "both" ), true, true );
+    FieldTermStack stack = new FieldTermStack( reader, 0, F, fq );
+    FieldPhraseList fpl = new FieldPhraseList( stack, fq );
+    WeightedFragListBuilder sflb = new WeightedFragListBuilder();
+    FieldFragList ffl = sflb.createFieldFragList( fpl, 100 );
+    assertEquals( 1, ffl.getFragInfos().size() );
+    assertEquals( "subInfos=(theboth((195,203)))/2.828427(189,289)", ffl.getFragInfos().get( 0 ).toString() );
+  }
+
+}
Index: solr/core/src/java/org/apache/solr/highlight/WeightedFragListBuilder.java
===================================================================
--- solr/core/src/java/org/apache/solr/highlight/WeightedFragListBuilder.java	(revision 0)
+++ solr/core/src/java/org/apache/solr/highlight/WeightedFragListBuilder.java	(revision 0)
@@ -0,0 +1,59 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.solr.highlight;
+
+import org.apache.lucene.search.vectorhighlight.FragListBuilder;
+import org.apache.solr.common.params.DefaultSolrParams;
+import org.apache.solr.common.params.SolrParams;
+
+public class WeightedFragListBuilder extends HighlightingPluginBase implements
+    SolrFragListBuilder {
+
+  public FragListBuilder getFragListBuilder(SolrParams params) {
+    numRequests++;
+    if( defaults != null ) {
+      params = new DefaultSolrParams( params, defaults );
+    }
+    
+    return new org.apache.lucene.search.vectorhighlight.WeightedFragListBuilder();
+  }
+
+  ///////////////////////////////////////////////////////////////////////
+  //////////////////////// SolrInfoMBeans methods ///////////////////////
+  ///////////////////////////////////////////////////////////////////////
+
+  @Override
+  public String getDescription() {
+    return "WeightedFragListBuilder";
+  }
+
+  @Override
+  public String getSource() {
+    return "$URL: http://svn.apache.org/repos/asf/lucene/dev/trunk/solr/core/src/java/org/apache/solr/highlight/WeightedFragListBuilder.java $";
+  }
+
+  @Override
+  public String getSourceId() {
+    return "$Id: WeightedFragListBuilder.java $";
+  }
+
+  @Override
+  public String getVersion() {
+    return "$Revision: $";
+  }
+}
