Index: java/org/apache/lucene/util/CloseableThreadLocal.java
===================================================================
--- java/org/apache/lucene/util/CloseableThreadLocal.java	(revision 695616)
+++ java/org/apache/lucene/util/CloseableThreadLocal.java	(working copy)
@@ -42,17 +42,25 @@
  *  references are cleared and then GC is freely able to
  *  reclaim space by objects stored in it. */
 
-public final class CloseableThreadLocal {
+public class CloseableThreadLocal {
 
   private ThreadLocal t = new ThreadLocal();
 
   private Map hardRefs = new HashMap();
-
+  
+  protected Object initialValue() {
+    return null;
+  }
+  
   public Object get() {
     WeakReference weakRef = (WeakReference) t.get();
-    if (weakRef == null)
-      return null;
-    else {
+    if (weakRef == null) {
+      Object iv = initialValue();
+      if (iv != null) {
+        set(iv);
+        return iv;
+      } else return null;
+    } else {
       Object v = weakRef.get();
       // This can never be null, because we hold a hard
       // reference to the underlying object:
Index: test/org/apache/lucene/index/TestCloseableThreadLocal.java
===================================================================
--- test/org/apache/lucene/index/TestCloseableThreadLocal.java	(revision 0)
+++ test/org/apache/lucene/index/TestCloseableThreadLocal.java	(revision 0)
@@ -0,0 +1,20 @@
+package org.apache.lucene.index;
+
+import org.apache.lucene.util.CloseableThreadLocal;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestCloseableThreadLocal extends LuceneTestCase {
+  public static final String TEST_VALUE = "initvaluetest";
+  
+  public void testInitValue() {
+    InitValueThreadLocal tl = new InitValueThreadLocal();
+    String str = (String)tl.get();
+    assertEquals(TEST_VALUE, str);
+  }
+  
+  public class InitValueThreadLocal extends CloseableThreadLocal {
+    protected Object initialValue() {
+      return TEST_VALUE;
+    } 
+  }
+}
