Index: lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java	(revision 04916239337f4e1435e70ba78bb174c019f9f925)
+++ lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java	(date 1543753202000)
@@ -56,6 +56,11 @@
   // see http://earth-info.nga.mil/GandG/publications/tr8350.2/wgs84fin.pdf
   public static final double EARTH_MEAN_RADIUS_METERS = 6_371_008.7714;
 
+  /** linear precision for orientation **/
+  public static final double PRECISION = 1e-10;
+  /** squared precision for orientation **/
+  public static final double PRECISION_SQUARED = PRECISION * PRECISION;
+
   // No instance:
   private GeoUtils() {
   }
@@ -181,16 +186,16 @@
   // see the "Orient2D" method described here:
   // http://www.cs.berkeley.edu/~jrs/meshpapers/robnotes.pdf
   // https://www.cs.cmu.edu/~quake/robust.html
-  // Note that this one does not yet have the floating point tricks to be exact!
+  // Note that this one does not yet have the floating point tricks to be exact! Instead we
+  // limit the precision of our determinant  and consider points with small values to be co-linear
   public static int orient(double ax, double ay, double bx, double by, double cx, double cy) {
-    double v1 = (bx - ax) * (cy - ay);
-    double v2 = (cx - ax) * (by - ay);
-    if (v1 > v2) {
-      return 1;
-    } else if (v1 < v2) {
+    double det = (bx - ax) * (cy - ay) - (cx - ax) * (by - ay);
+    if (Math.abs(det) < PRECISION_SQUARED) {
+      return 0;
+    } else if (det < 0) {
       return -1;
     } else {
-      return 0;
+      return 1;
     }
   }
 
Index: lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils.java	(revision 04916239337f4e1435e70ba78bb174c019f9f925)
+++ lucene/core/src/test/org/apache/lucene/geo/TestGeoUtils.java	(date 1543753593000)
@@ -305,4 +305,49 @@
     assertTrue(GeoUtils.within90LonDegrees(150, -170, -140));
     assertFalse(GeoUtils.within90LonDegrees(150, -150, -120));
   }
+
+  public void testOrient() {
+    double ax = GeoTestUtil.nextLongitude();
+    double ay = GeoTestUtil.nextLatitude();
+    double bx = GeoTestUtil.nextLongitude();
+    double by = GeoTestUtil.nextLatitude();
+    double cx = GeoTestUtil.nextLongitude();
+    double cy = GeoTestUtil.nextLatitude();
+    int orient1 = GeoUtils.orient(ax, ay, bx, by, cx, cy);
+    int orient2 = GeoUtils.orient(cx, cy, ax, ay, bx, by);
+    int orient3 = GeoUtils.orient(bx, by, cx, cy, ax, ay);
+    assertTrue(orient1 == orient2);
+    assertTrue(orient1 == orient3);
+    int inverseOrient1 = GeoUtils.orient(cx, cy, bx, by, ax, ay);
+    int inverseOrient2 = GeoUtils.orient(bx, by, ax, ay, cx, cy);
+    int inverseOrient3 = GeoUtils.orient(ax, ay, cx, cy, bx, by);
+    assertTrue(inverseOrient1 == inverseOrient2);
+    assertTrue(inverseOrient1 == inverseOrient3);
+    if (orient1 != 0) {
+      assertTrue(orient1 == -inverseOrient1);
+    } else {
+      assertTrue(orient1 == inverseOrient1);
+    }
+
+  }
+
+  public void testCrossesLine() {
+    double ax = GeoTestUtil.nextLongitude();
+    double ay = GeoTestUtil.nextLatitude();
+    double bx = GeoTestUtil.nextLongitude();
+    double by = GeoTestUtil.nextLatitude();
+
+    double cx = GeoTestUtil.nextLongitude();
+    double cy = GeoTestUtil.nextLatitude();
+    double dx = GeoTestUtil.nextLongitude();
+    double dy = GeoTestUtil.nextLatitude();
+
+    boolean cross1 = GeoUtils.lineCrossesLine(ax, ay, bx, by, cx, cy, dx, dy);
+    boolean cross2 = GeoUtils.lineCrossesLine(bx, by, ax, ay, cx, cy, dx, dy);
+    boolean cross3 = GeoUtils.lineCrossesLine(ax, ay, bx, by, dx, dy, cx, cy);
+    boolean cross4 = GeoUtils.lineCrossesLine(bx, by, ax, ay, dx, dy, cx, cy);
+
+    assertTrue(cross1 == cross2 == cross3 == cross4);
+
+  }
 }
