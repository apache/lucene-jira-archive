Index: src/java/org/apache/lucene/search/FieldCacheImpl.java
===================================================================
--- src/java/org/apache/lucene/search/FieldCacheImpl.java	(revision 723374)
+++ src/java/org/apache/lucene/search/FieldCacheImpl.java	(working copy)
@@ -88,7 +88,7 @@
   static class Entry {
     final String field;        // which Fieldable
     final int type;            // which SortField type
-    final Object custom;       // which custom comparator
+    final Object custom;       // which custom comparator or parser
     final Locale locale;       // the locale we're sorting (if string)
 
     /** Creates one of these objects. */
@@ -99,7 +99,7 @@
       this.locale = locale;
     }
 
-    /** Creates one of these objects for a custom comparator. */
+    /** Creates one of these objects for a custom comparator/parser. */
     Entry (String field, Object custom) {
       this.field = field.intern();
       this.type = SortField.CUSTOM;
@@ -107,6 +107,14 @@
       this.locale = null;
     }
 
+    /** Creates one of these objects for a custom type with parser, needed by FieldSortedHitQueue. */
+    Entry (String field, Object parser, int type) {
+      this.field = field.intern();
+      this.type = type;
+      this.custom = parser;
+      this.locale = null;
+    }
+
     /** Two of these are equal iff they reference the same field and type. */
     public boolean equals (Object o) {
       if (o instanceof Entry) {
Index: src/java/org/apache/lucene/search/FieldSortedHitQueue.java
===================================================================
--- src/java/org/apache/lucene/search/FieldSortedHitQueue.java	(revision 723374)
+++ src/java/org/apache/lucene/search/FieldSortedHitQueue.java	(working copy)
@@ -52,12 +52,12 @@
     this.fields = new SortField[n];
     for (int i=0; i<n; ++i) {
       String fieldname = fields[i].getField();
-      comparators[i] = getCachedComparator (reader, fieldname, fields[i].getType(), fields[i].getLocale(), fields[i].getFactory());
+      comparators[i] = getCachedComparator (reader, fieldname, fields[i].getType(), fields[i].getParser(), fields[i].getLocale(), fields[i].getFactory());
       
       if (comparators[i].sortType() == SortField.STRING) {
     	  this.fields[i] = new SortField (fieldname, fields[i].getLocale(), fields[i].getReverse());
       } else {
-    	  this.fields[i] = new SortField (fieldname, comparators[i].sortType(), fields[i].getReverse());
+    	  this.fields[i] = new SortField (fieldname, comparators[i].sortType(), fields[i].getParser(), fields[i].getReverse());
       }
     }
     initialize (size);
@@ -157,13 +157,16 @@
     return fields;
   }
   
-  static ScoreDocComparator getCachedComparator (IndexReader reader, String field, int type, Locale locale, SortComparatorSource factory)
+  static ScoreDocComparator getCachedComparator (IndexReader reader, String field, int type, Object parser, Locale locale, SortComparatorSource factory)
   throws IOException {
     if (type == SortField.DOC) return ScoreDocComparator.INDEXORDER;
     if (type == SortField.SCORE) return ScoreDocComparator.RELEVANCE;
     FieldCacheImpl.Entry entry = (factory != null)
       ? new FieldCacheImpl.Entry (field, factory)
-      : new FieldCacheImpl.Entry (field, type, locale);
+      : ( (parser != null)
+		? new FieldCacheImpl.Entry (field, parser, type)
+		: new FieldCacheImpl.Entry (field, type, locale)
+	  );
     return (ScoreDocComparator)Comparators.get(reader, entry);
   }
 
@@ -177,29 +180,35 @@
       String fieldname = entry.field;
       int type = entry.type;
       Locale locale = entry.locale;
-      SortComparatorSource factory = (SortComparatorSource) entry.custom;
+      Object parser = null;
+      SortComparatorSource factory = null;
+      if (entry.custom instanceof SortComparatorSource) {
+        factory = (SortComparatorSource) entry.custom;
+      } else {
+        parser = entry.custom;
+      }
       ScoreDocComparator comparator;
       switch (type) {
         case SortField.AUTO:
           comparator = comparatorAuto (reader, fieldname);
           break;
         case SortField.INT:
-          comparator = comparatorInt (reader, fieldname);
+          comparator = comparatorInt (reader, fieldname, (FieldCache.IntParser)parser);
           break;
         case SortField.FLOAT:
-          comparator = comparatorFloat (reader, fieldname);
+          comparator = comparatorFloat (reader, fieldname, (FieldCache.FloatParser)parser);
           break;
         case SortField.LONG:
-          comparator = comparatorLong(reader, fieldname);
+          comparator = comparatorLong(reader, fieldname, (ExtendedFieldCache.LongParser)parser);
           break;
         case SortField.DOUBLE:
-          comparator = comparatorDouble(reader, fieldname);
+          comparator = comparatorDouble(reader, fieldname, (ExtendedFieldCache.DoubleParser)parser);
           break;
         case SortField.SHORT:
-          comparator = comparatorShort(reader, fieldname);
+          comparator = comparatorShort(reader, fieldname, (FieldCache.ShortParser)parser);
           break;
         case SortField.BYTE:
-          comparator = comparatorByte(reader, fieldname);
+          comparator = comparatorByte(reader, fieldname, (FieldCache.ByteParser)parser);
           break;
         case SortField.STRING:
           if (locale != null) comparator = comparatorStringLocale (reader, fieldname, locale);
@@ -222,10 +231,12 @@
    * @return  Comparator for sorting hits.
    * @throws IOException If an error occurs reading the index.
    */
-  static ScoreDocComparator comparatorByte(final IndexReader reader, final String fieldname)
+  static ScoreDocComparator comparatorByte(final IndexReader reader, final String fieldname, final FieldCache.ByteParser parser)
   throws IOException {
     final String field = fieldname.intern();
-    final byte[] fieldOrder = FieldCache.DEFAULT.getBytes(reader, field);
+    final byte[] fieldOrder = (parser==null)
+	  ? FieldCache.DEFAULT.getBytes(reader, field)
+	  : FieldCache.DEFAULT.getBytes(reader, field, parser);
     return new ScoreDocComparator() {
 
       public final int compare (final ScoreDoc i, final ScoreDoc j) {
@@ -253,10 +264,12 @@
    * @return  Comparator for sorting hits.
    * @throws IOException If an error occurs reading the index.
    */
-  static ScoreDocComparator comparatorShort(final IndexReader reader, final String fieldname)
+  static ScoreDocComparator comparatorShort(final IndexReader reader, final String fieldname, final FieldCache.ShortParser parser)
   throws IOException {
     final String field = fieldname.intern();
-    final short[] fieldOrder = FieldCache.DEFAULT.getShorts(reader, field);
+    final short[] fieldOrder = (parser==null)
+	  ? FieldCache.DEFAULT.getShorts(reader, field)
+	  : FieldCache.DEFAULT.getShorts(reader, field, parser);
     return new ScoreDocComparator() {
 
       public final int compare (final ScoreDoc i, final ScoreDoc j) {
@@ -284,10 +297,12 @@
    * @return  Comparator for sorting hits.
    * @throws IOException If an error occurs reading the index.
    */
-  static ScoreDocComparator comparatorInt (final IndexReader reader, final String fieldname)
+  static ScoreDocComparator comparatorInt (final IndexReader reader, final String fieldname, final FieldCache.IntParser parser)
   throws IOException {
     final String field = fieldname.intern();
-    final int[] fieldOrder = FieldCache.DEFAULT.getInts (reader, field);
+    final int[] fieldOrder = (parser==null)
+	  ? FieldCache.DEFAULT.getInts(reader, field)
+	  : FieldCache.DEFAULT.getInts(reader, field, parser);
     return new ScoreDocComparator() {
 
       public final int compare (final ScoreDoc i, final ScoreDoc j) {
@@ -315,10 +330,12 @@
    * @return  Comparator for sorting hits.
    * @throws IOException If an error occurs reading the index.
    */
-  static ScoreDocComparator comparatorLong (final IndexReader reader, final String fieldname)
+  static ScoreDocComparator comparatorLong (final IndexReader reader, final String fieldname, final ExtendedFieldCache.LongParser parser)
   throws IOException {
     final String field = fieldname.intern();
-    final long[] fieldOrder = ExtendedFieldCache.EXT_DEFAULT.getLongs (reader, field);
+    final long[] fieldOrder = (parser==null)
+	  ? ExtendedFieldCache.EXT_DEFAULT.getLongs (reader, field)
+	  : ExtendedFieldCache.EXT_DEFAULT.getLongs (reader, field, parser);
     return new ScoreDocComparator() {
 
       public final int compare (final ScoreDoc i, final ScoreDoc j) {
@@ -347,10 +364,12 @@
    * @return  Comparator for sorting hits.
    * @throws IOException If an error occurs reading the index.
    */
-  static ScoreDocComparator comparatorFloat (final IndexReader reader, final String fieldname)
+  static ScoreDocComparator comparatorFloat (final IndexReader reader, final String fieldname, final FieldCache.FloatParser parser)
   throws IOException {
     final String field = fieldname.intern();
-    final float[] fieldOrder = FieldCache.DEFAULT.getFloats (reader, field);
+    final float[] fieldOrder = (parser==null)
+	  ? FieldCache.DEFAULT.getFloats (reader, field)
+	  : FieldCache.DEFAULT.getFloats (reader, field, parser);
     return new ScoreDocComparator () {
 
       public final int compare (final ScoreDoc i, final ScoreDoc j) {
@@ -378,10 +397,12 @@
    * @return  Comparator for sorting hits.
    * @throws IOException If an error occurs reading the index.
    */
-  static ScoreDocComparator comparatorDouble(final IndexReader reader, final String fieldname)
+  static ScoreDocComparator comparatorDouble(final IndexReader reader, final String fieldname, final ExtendedFieldCache.DoubleParser parser)
   throws IOException {
     final String field = fieldname.intern();
-    final double[] fieldOrder = ExtendedFieldCache.EXT_DEFAULT.getDoubles (reader, field);
+    final double[] fieldOrder = (parser==null)
+	  ? ExtendedFieldCache.EXT_DEFAULT.getDoubles (reader, field)
+	  : ExtendedFieldCache.EXT_DEFAULT.getDoubles (reader, field, parser);
     return new ScoreDocComparator () {
 
       public final int compare (final ScoreDoc i, final ScoreDoc j) {
@@ -488,11 +509,11 @@
     if (lookupArray instanceof FieldCache.StringIndex) {
       return comparatorString (reader, field);
     } else if (lookupArray instanceof int[]) {
-      return comparatorInt (reader, field);
+      return comparatorInt (reader, field, null);
     } else if (lookupArray instanceof long[]) {
-      return comparatorLong (reader, field);
+      return comparatorLong (reader, field, null);
     } else if (lookupArray instanceof float[]) {
-      return comparatorFloat (reader, field);
+      return comparatorFloat (reader, field, null);
     } else if (lookupArray instanceof String[]) {
       return comparatorString (reader, field);
     } else {
Index: src/java/org/apache/lucene/search/SortField.java
===================================================================
--- src/java/org/apache/lucene/search/SortField.java	(revision 723374)
+++ src/java/org/apache/lucene/search/SortField.java	(working copy)
@@ -99,6 +99,7 @@
   private Locale locale;    // defaults to "natural order" (no Locale)
   boolean reverse = false;  // defaults to natural order
   private SortComparatorSource factory;
+  private Object parser;
 
   /** Creates a sort by terms in the given field where the type of term value
    * is determined dynamically ({@link #AUTO AUTO}).
@@ -142,6 +143,34 @@
     this.reverse = reverse;
   }
 
+  /** Creates a sort by terms in the given field with the type of term
+   * values explicitly given.
+   * @param field  Name of field to sort by.  Can be <code>null</code> if
+   *               <code>type</code> is SCORE or DOC.
+   * @param type   Type of values in the terms.
+   * @param parser   Instance of a {@link FieldCache} parser that fits to the given type.
+   */
+  public SortField (String field, int type, Object parser) {
+    this.field = (field != null) ? field.intern() : field;
+    this.type = type;
+    this.parser = parser;
+  }
+
+  /** Creates a sort, possibly in reverse, by terms in the given field with the
+   * type of term values explicitly given.
+   * @param field  Name of field to sort by.  Can be <code>null</code> if
+   *               <code>type</code> is SCORE or DOC.
+   * @param type   Type of values in the terms.
+   * @param parser   Instance of a {@link FieldCache} parser that fits to the given type.
+   * @param reverse True if natural order should be reversed.
+   */
+  public SortField (String field, int type, Object parser, boolean reverse) {
+    this.field = (field != null) ? field.intern() : field;
+    this.type = type;
+    this.reverse = reverse;
+    this.parser = parser;
+  }
+
   /** Creates a sort by terms in the given field sorted
    * according to the given locale.
    * @param field  Name of field to sort by, cannot be <code>null</code>.
@@ -210,6 +239,14 @@
     return locale;
   }
 
+  /** Returns the instance of a {@link FieldCache} parser that fits to the given sort type.
+   * May return <code>null</code> if no parser was specified. Sorting is using the default parser then.
+   * @return An instance of a {@link FieldCache} parser, or <code>null</code>.
+   */
+  public Object getParser() {
+    return parser;
+  }
+
   /** Returns whether the sort should be reversed.
    * @return  True if natural order should be reversed.
    */
@@ -240,6 +277,7 @@
     }
 
     if (locale != null) buffer.append('(').append(locale).append(')');
+    if (parser != null) buffer.append('(').append(parser).append(')');
     if (reverse) buffer.append('!');
 
     return buffer.toString();
