Index: lucene/join/src/java/org/apache/lucene/search/join/JoinUtil.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/JoinUtil.java	(revision 1716343)
+++ lucene/join/src/java/org/apache/lucene/search/join/JoinUtil.java	(working copy)
@@ -76,7 +76,7 @@
       case None:
         TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);
         fromSearcher.search(fromQuery, termsCollector);
-        return new TermsQuery(toField, fromQuery, termsCollector.getCollectorTerms());
+        return  new TermsQuery(toField, fromQuery, termsCollector.getCollectorTerms());
       case Total:
       case Max:
       case Min:
Index: lucene/join/src/java/org/apache/lucene/search/join/TermsCollector.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/TermsCollector.java	(revision 1716343)
+++ lucene/join/src/java/org/apache/lucene/search/join/TermsCollector.java	(working copy)
@@ -20,12 +20,18 @@
 import java.io.IOException;
 
 import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.BinaryDocValues;
 import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.DocValuesType;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.SortedSetDocValues;
 import org.apache.lucene.search.SimpleCollector;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.BytesRefBuilder;
 import org.apache.lucene.util.BytesRefHash;
+import org.apache.lucene.util.NumericUtils;
 
 /**
  * A collector that collects all terms from a specified field matching the query.
@@ -86,20 +92,38 @@
 
     final BytesRef spare = new BytesRef();
     private BinaryDocValues fromDocTerms;
-
+    private NumericDocValues fromDocTermsNum;
     SV(String field) {
       super(field);
     }
 
     @Override
     public void collect(int doc) throws IOException {
+      if(fromDocTermsNum!= null) {
+        collectorTerms.add(getTermFromNum (fromDocTermsNum.get(doc)));
+      } else {
       final BytesRef term = fromDocTerms.get(doc);
-      collectorTerms.add(term);
+        collectorTerms.add(term);
+      }
+      fromDocTerms = null; fromDocTermsNum = null;
     }
 
+    private BytesRef getTermFromNum(long l) {
+      int i = (int)l;
+      BytesRefBuilder bytes = new BytesRefBuilder();
+      NumericUtils.intToPrefixCoded(i, 0, bytes);
+      return bytes.get();
+    }
+
     @Override
     protected void doSetNextReader(LeafReaderContext context) throws IOException {
-      fromDocTerms = DocValues.getBinary(context.reader(), field);
+      LeafReader reader = context.reader();
+      FieldInfo info = reader.getFieldInfos().fieldInfo(field);
+      if(info != null && DocValuesType.NUMERIC == info.getDocValuesType()) {
+        fromDocTermsNum = DocValues.getNumeric(reader, field);
+      } else {
+        fromDocTerms = DocValues.getBinary(reader, field);
+      }
     }
   }
 
Index: lucene/join/src/java/org/apache/lucene/search/join/TermsQuery.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/TermsQuery.java	(revision 1716343)
+++ lucene/join/src/java/org/apache/lucene/search/join/TermsQuery.java	(working copy)
@@ -28,6 +28,7 @@
 
 import java.io.IOException;
 import java.util.Comparator;
+import java.util.List;
 
 /**
  * A query that has an array of terms from a specific field. This query will match documents have one or more terms in
Index: lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtilInt.java
===================================================================
--- lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtilInt.java	(revision 0)
+++ lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtilInt.java	(working copy)
@@ -0,0 +1,188 @@
+package org.apache.lucene.search.join;
+
+import com.carrotsearch.randomizedtesting.generators.RandomInts;
+import com.carrotsearch.randomizedtesting.generators.RandomPicks;
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.FieldType;
+import org.apache.lucene.document.IntField;
+import org.apache.lucene.document.NumericDocValuesField;
+import org.apache.lucene.document.SortedDocValuesField;
+import org.apache.lucene.document.SortedSetDocValuesField;
+import org.apache.lucene.document.StringField;
+import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.BinaryDocValues;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.DocValuesType;
+import org.apache.lucene.index.IndexOptions;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.MultiDocValues;
+import org.apache.lucene.index.MultiDocValues.OrdinalMap;
+import org.apache.lucene.index.MultiFields;
+import org.apache.lucene.index.NoMergePolicy;
+import org.apache.lucene.index.NumericDocValues;
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.SlowCompositeReaderWrapper;
+import org.apache.lucene.index.SortedDocValues;
+import org.apache.lucene.index.SortedSetDocValues;
+import org.apache.lucene.index.StorableField;
+import org.apache.lucene.index.StoredDocument;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.FieldValueQuery;
+import org.apache.lucene.search.FilterScorer;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.MatchNoDocsQuery;
+import org.apache.lucene.search.MultiCollector;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.SimpleCollector;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.search.TopScoreDocCollector;
+import org.apache.lucene.search.TotalHitCountCollector;
+import org.apache.lucene.search.Weight;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BitSet;
+import org.apache.lucene.util.BitSetIterator;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.FixedBitSet;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+import org.apache.lucene.util.packed.PackedInts;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.SortedSet;
+import java.util.TreeSet;
+public class TestJoinUtilInt  extends LuceneTestCase {
+  private static final FieldType INT_FIELD_TYPE_STORED_SORTED = new FieldType();
+  static {
+    INT_FIELD_TYPE_STORED_SORTED.setTokenized(true);
+    INT_FIELD_TYPE_STORED_SORTED.setOmitNorms(true);
+    INT_FIELD_TYPE_STORED_SORTED.setIndexOptions(IndexOptions.DOCS);
+    INT_FIELD_TYPE_STORED_SORTED
+          .setNumericType(FieldType.NumericType.INT);
+    INT_FIELD_TYPE_STORED_SORTED.setStored(true);
+    INT_FIELD_TYPE_STORED_SORTED.setDocValuesType(DocValuesType.NUMERIC);
+    INT_FIELD_TYPE_STORED_SORTED.freeze();
+  }
+
+  public void testSimpleInt() throws Exception {
+    final String idField = "id";
+    final String toField = "productId";
+    final String productGroup = "productGroup";
+    Directory dir = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(
+        random(),
+        dir,
+        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
+
+    // 0
+    Document doc = new Document();
+    doc.add(new TextField("description", "random text", Field.Store.NO));
+    doc.add(new TextField("name", "name1", Field.Store.NO));
+    doc.add(new IntField(productGroup, 1, INT_FIELD_TYPE_STORED_SORTED));
+    doc.add(new TextField(idField, "1", Field.Store.NO));
+//    doc.add(new SortedDocValuesField(idField, new BytesRef("1")));
+    w.addDocument(doc);
+
+    // 1
+    doc = new Document();
+    doc.add(new TextField("price", "10.0", Field.Store.NO));
+    doc.add(new TextField(idField, "2", Field.Store.NO));
+    doc.add(new SortedDocValuesField(idField, new BytesRef("2")));
+    doc.add(new IntField(toField, 1, INT_FIELD_TYPE_STORED_SORTED));
+//    doc.add(new SortedDocValuesField(toField, new BytesRef("1")));
+    w.addDocument(doc);
+
+    // 2
+    doc = new Document();
+    doc.add(new TextField("price", "20.0", Field.Store.NO));
+    doc.add(new TextField(idField, "3", Field.Store.NO));
+    doc.add(new SortedDocValuesField(idField, new BytesRef("3")));
+    doc.add(new IntField(toField, 1, INT_FIELD_TYPE_STORED_SORTED));
+//    doc.add(new SortedDocValuesField(toField, new BytesRef("1")));
+    w.addDocument(doc);
+
+    // 3
+    doc = new Document();
+    doc.add(new TextField("description", "more random text", Field.Store.NO));
+    doc.add(new TextField("name", "name2", Field.Store.NO));
+    doc.add(new IntField(productGroup, 4, INT_FIELD_TYPE_STORED_SORTED));
+    doc.add(new TextField(idField, "4", Field.Store.NO));
+//    doc.add(new SortedDocValuesField(idField, new BytesRef("4")));
+    w.addDocument(doc);
+    w.commit();
+
+    // 4
+    doc = new Document();
+    doc.add(new TextField("price", "10.0", Field.Store.YES));
+    doc.add(new TextField(idField, "5", Field.Store.YES));
+    doc.add(new SortedDocValuesField(idField, new BytesRef("5")));
+    doc.add(new IntField(toField, 4, INT_FIELD_TYPE_STORED_SORTED));
+//    doc.add(new SortedDocValuesField(toField, new BytesRef("4")));
+    w.addDocument(doc);
+
+    // 5
+    doc = new Document();
+    doc.add(new TextField("price", "20.0", Field.Store.YES));
+    doc.add(new TextField(idField, "6", Field.Store.YES));
+    doc.add(new SortedDocValuesField(idField, new BytesRef("6")));
+    doc.add(new IntField(toField, 4, INT_FIELD_TYPE_STORED_SORTED));
+//    doc.add(new SortedDocValuesField(toField, new BytesRef("4")));
+    w.addDocument(doc);
+
+    IndexSearcher indexSearcher = new IndexSearcher(w.getReader());
+    w.close();
+
+    // Search for product
+    Query joinQuery =
+        JoinUtil.createJoinQuery(productGroup, false, toField, new TermQuery(new Term("name", "name2")), indexSearcher, ScoreMode.None);
+
+    TopDocs result = indexSearcher.search(joinQuery, 10);
+    assertEquals(2, result.totalHits);
+    assertEquals(4, result.scoreDocs[0].doc);
+    assertEquals(5, result.scoreDocs[1].doc); 
+
+    joinQuery = JoinUtil.createJoinQuery(productGroup, false, toField, new TermQuery(new Term("name", "name1")), indexSearcher, ScoreMode.None);
+    result = indexSearcher.search(joinQuery, 10);
+    assertEquals(2, result.totalHits);
+    assertEquals(1, result.scoreDocs[0].doc);
+    assertEquals(2, result.scoreDocs[1].doc);
+
+    // Search for offer
+    joinQuery = JoinUtil.createJoinQuery(toField, false, productGroup, new TermQuery(new Term("id", "5")), indexSearcher, ScoreMode.None);
+    result = indexSearcher.search(joinQuery, 10);
+    assertEquals(1, result.totalHits);
+    assertEquals(3, result.scoreDocs[0].doc);
+
+    indexSearcher.getIndexReader().close();
+    dir.close();
+  }
+
+}
