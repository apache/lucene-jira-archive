Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/ArcDistance.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/ArcDistance.java	(revision 0)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/ArcDistance.java	(working copy)
@@ -0,0 +1,50 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Arc distance computation style.
+ *
+ * @lucene.experimental
+ */
+public class ArcDistance implements DistanceStyle {
+  
+  public final static DistanceStyle INSTANCE = new ArcDistance();
+  
+  @Override
+  public double computeDistance(final GeoPoint point1, final GeoPoint point2) {
+    return point1.arcDistance(point2);
+  }
+  
+  @Override
+  public double computeDistance(final GeoPoint point1, final double x2, final double y2, final double z2) {
+    return point1.arcDistance(x2,y2,z2);
+  }
+
+  @Override
+  public double computeDistance(final PlanetModel planetModel, final Plane plane, final GeoPoint point, final Membership... bounds) {
+    return plane.arcDistance(planetModel, point, bounds);
+  }
+  
+  @Override
+  public double computeDistance(final PlanetModel planetModel, final Plane plane, final double x, final double y, final double z, final Membership... bounds) {
+    return plane.arcDistance(planetModel, x,y,z, bounds);
+  }
+
+}
+

Property changes on: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/ArcDistance.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/BasePlanetObject.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/BasePlanetObject.java	(revision 0)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/BasePlanetObject.java	(working copy)
@@ -0,0 +1,47 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * All bounding box shapes can derive from this base class, which furnishes
+ * some common code
+ *
+ * @lucene.internal
+ */
+public abstract class BasePlanetObject {
+
+  protected final PlanetModel planetModel;
+  
+  public BasePlanetObject(final PlanetModel planetModel) {
+    this.planetModel = planetModel;
+  }
+  
+  @Override
+  public int hashCode() {
+    return planetModel.hashCode();
+  }
+  
+  @Override
+  public boolean equals(final Object o) {
+    if (!(o instanceof BasePlanetObject))
+      return false;
+    return planetModel.equals(((BasePlanetObject)o).planetModel);
+  }
+}
+
+

Property changes on: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/BasePlanetObject.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/DistanceStyle.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/DistanceStyle.java	(revision 0)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/DistanceStyle.java	(working copy)
@@ -0,0 +1,65 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Distance computation styles, supporting various ways of computing
+ * distance to shapes.
+ *
+ * @lucene.experimental
+ */
+public interface DistanceStyle {
+  
+  /** Compute the distance from a point to another point.
+   * @param point1 Starting point
+   * @param point2 Final point
+   * @return the distance
+   */
+  public double computeDistance(final GeoPoint point1, final GeoPoint point2);
+  
+  /** Compute the distance from a point to another point.
+   * @param point1 Starting point
+   * @param x2 Final point x
+   * @param y2 Final point y
+   * @param z2 Final point z
+   * @return the distance
+   */
+  public double computeDistance(final GeoPoint point1, final double x2, final double y2, final double z2);
+
+  /** Compute the distance from a plane to a point.
+   * @param planetModel The planet model
+   * @param plane The plane
+   * @param point The point
+   * @param bounds are the plane bounds
+   * @return the distance
+   */
+  public double computeDistance(final PlanetModel planetModel, final Plane plane, final GeoPoint point, final Membership... bounds);
+  
+  /** Compute the distance from a plane to a point.
+   * @param planetModel The planet model
+   * @param plane The plane
+   * @param x The point x
+   * @param y The point y
+   * @param z The point z
+   * @param bounds are the plane bounds
+   * @return the distance
+   */
+  public double computeDistance(final PlanetModel planetModel, final Plane plane, final double x, final double y, final double z, final Membership... bounds);
+
+}
+

Property changes on: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/DistanceStyle.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseBBox.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseBBox.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseBBox.java	(working copy)
@@ -23,7 +23,7 @@
  *
  * @lucene.internal
  */
-public abstract class GeoBaseBBox extends GeoBaseShape implements GeoBBox {
+public abstract class GeoBaseBBox extends GeoBaseMembershipShape implements GeoBBox {
 
   public GeoBaseBBox(final PlanetModel planetModel) {
     super(planetModel);
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseDistanceShape.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseDistanceShape.java	(revision 0)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseDistanceShape.java	(working copy)
@@ -0,0 +1,57 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Distance shapes have capabilities of both geohashing and distance
+ * computation (which also includes point membership determination).
+ *
+ * @lucene.experimental
+ */
+public abstract class GeoBaseDistanceShape extends GeoBaseMembershipShape implements GeoDistanceShape {
+
+  public GeoBaseDistanceShape(final PlanetModel planetModel) {
+    super(planetModel);
+  }
+
+  @Override
+  public double computeDistance(final DistanceStyle distanceStyle, final GeoPoint point) {
+    return computeDistance(distanceStyle, point.x, point.y, point.z);
+  }
+
+  @Override
+  public double computeDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    if (!isWithin(x,y,z)) {
+      return Double.MAX_VALUE;
+    }
+    return distance(distanceStyle, x, y, z);
+  }
+  
+  protected abstract double distance(final DistanceStyle distanceStyle, final double x, final double y, final double z);
+
+  @Override
+  public int hashCode() {
+    return super.hashCode();
+  }
+  
+  @Override
+  public boolean equals(final Object o) {
+    return super.equals(o);
+  }
+
+}

Property changes on: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseDistanceShape.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseExtendedShape.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseExtendedShape.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseExtendedShape.java	(working copy)
@@ -1,103 +0,0 @@
-package org.apache.lucene.spatial.spatial4j.geo3d;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Base extended shape object.
- *
- * @lucene.internal
- */
-public abstract class GeoBaseExtendedShape extends GeoBaseShape implements GeoShape {
-
-  public GeoBaseExtendedShape(final PlanetModel planetModel) {
-    super(planetModel);
-  }
-
-  /**
-   * Check if a point is within this shape.
-   *
-   * @param point is the point to check.
-   * @return true if the point is within this shape
-   */
-  @Override
-  public abstract boolean isWithin(final Vector point);
-
-  /**
-   * Check if a point is within this shape.
-   *
-   * @param x is x coordinate of point to check.
-   * @param y is y coordinate of point to check.
-   * @param z is z coordinate of point to check.
-   * @return true if the point is within this shape
-   */
-  @Override
-  public abstract boolean isWithin(final double x, final double y, final double z);
-
-  /**
-   * Return a sample point that is on the edge of the shape.
-   *
-   * @return a number of edge points, one for each disconnected edge.
-   */
-  @Override
-  public abstract GeoPoint[] getEdgePoints();
-
-  /**
-   * Assess whether a plane, within the provided bounds, intersects
-   * with the shape.
-   *
-   * @param plane  is the plane to assess for intersection with the shape's edges or
-   *               bounding curves.
-   * @param bounds are a set of bounds that define an area that an
-   *               intersection must be within in order to qualify (provided by a GeoArea).
-   * @return true if there's such an intersection, false if not.
-   */
-  @Override
-  public abstract boolean intersects(final Plane plane, final GeoPoint[] notablePoints, final Membership... bounds);
-
-  /**
-   * Compute longitude/latitude bounds for the shape.
-   *
-   * @param bounds is the optional input bounds object.  If this is null,
-   *               a bounds object will be created.  Otherwise, the input object will be modified.
-   * @return a Bounds object describing the shape's bounds.  If the bounds cannot
-   * be computed, then return a Bounds object with noLongitudeBound,
-   * noTopLatitudeBound, and noBottomLatitudeBound.
-   */
-  @Override
-  public Bounds getBounds(Bounds bounds) {
-    if (bounds == null)
-      bounds = new Bounds();
-    if (isWithin(planetModel.NORTH_POLE)) {
-      bounds.noTopLatitudeBound().noLongitudeBound();
-    }
-    if (isWithin(planetModel.SOUTH_POLE)) {
-      bounds.noBottomLatitudeBound().noLongitudeBound();
-    }
-    return bounds;
-  }
-  
-  @Override
-  public int hashCode() {
-    return super.hashCode();
-  }
-  
-  @Override
-  public boolean equals(final Object o) {
-    return super.equals(o);
-  }
-}
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseMembershipShape.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseMembershipShape.java	(revision 0)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseMembershipShape.java	(working copy)
@@ -0,0 +1,57 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Membership shapes have capabilities of both geohashing and membership
+ * determination.  This is a useful baseclass for them.
+ *
+ * @lucene.experimental
+ */
+public abstract class GeoBaseMembershipShape extends GeoBaseShape implements GeoMembershipShape {
+
+  public GeoBaseMembershipShape(final PlanetModel planetModel) {
+    super(planetModel);
+  }
+
+  @Override
+  public double computeOutsideDistance(final DistanceStyle distanceStyle, final GeoPoint point) {
+    return computeOutsideDistance(distanceStyle, point.x, point.y, point.z);
+  }
+
+  @Override
+  public double computeOutsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    if (isWithin(x,y,z)) {
+      return 0.0;
+    }
+    return outsideDistance(distanceStyle, x,y,z);
+  }
+  
+  protected abstract double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z);
+
+  @Override
+  public int hashCode() {
+    return super.hashCode();
+  }
+  
+  @Override
+  public boolean equals(final Object o) {
+    return super.equals(o);
+  }
+
+}

Property changes on: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseMembershipShape.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseShape.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseShape.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseShape.java	(working copy)
@@ -18,30 +18,86 @@
  */
 
 /**
- * All bounding box shapes can derive from this base class, which furnishes
- * some common code
+ * Base extended shape object.
  *
  * @lucene.internal
  */
-public abstract class GeoBaseShape {
+public abstract class GeoBaseShape extends BasePlanetObject implements GeoShape {
 
-  protected final PlanetModel planetModel;
-  
   public GeoBaseShape(final PlanetModel planetModel) {
-    this.planetModel = planetModel;
+    super(planetModel);
   }
+
+  /**
+   * Check if a point is within this shape.
+   *
+   * @param point is the point to check.
+   * @return true if the point is within this shape
+   */
+  @Override
+  public abstract boolean isWithin(final Vector point);
+
+  /**
+   * Check if a point is within this shape.
+   *
+   * @param x is x coordinate of point to check.
+   * @param y is y coordinate of point to check.
+   * @param z is z coordinate of point to check.
+   * @return true if the point is within this shape
+   */
+  @Override
+  public abstract boolean isWithin(final double x, final double y, final double z);
+
+  /**
+   * Return a sample point that is on the edge of the shape.
+   *
+   * @return a number of edge points, one for each disconnected edge.
+   */
+  @Override
+  public abstract GeoPoint[] getEdgePoints();
+
+  /**
+   * Assess whether a plane, within the provided bounds, intersects
+   * with the shape.
+   *
+   * @param plane  is the plane to assess for intersection with the shape's edges or
+   *               bounding curves.
+   * @param bounds are a set of bounds that define an area that an
+   *               intersection must be within in order to qualify (provided by a GeoArea).
+   * @return true if there's such an intersection, false if not.
+   */
+  @Override
+  public abstract boolean intersects(final Plane plane, final GeoPoint[] notablePoints, final Membership... bounds);
+
+  /**
+   * Compute longitude/latitude bounds for the shape.
+   *
+   * @param bounds is the optional input bounds object.  If this is null,
+   *               a bounds object will be created.  Otherwise, the input object will be modified.
+   * @return a Bounds object describing the shape's bounds.  If the bounds cannot
+   * be computed, then return a Bounds object with noLongitudeBound,
+   * noTopLatitudeBound, and noBottomLatitudeBound.
+   */
+  @Override
+  public Bounds getBounds(Bounds bounds) {
+    if (bounds == null)
+      bounds = new Bounds();
+    if (isWithin(planetModel.NORTH_POLE)) {
+      bounds.noTopLatitudeBound().noLongitudeBound();
+    }
+    if (isWithin(planetModel.SOUTH_POLE)) {
+      bounds.noBottomLatitudeBound().noLongitudeBound();
+    }
+    return bounds;
+  }
   
   @Override
   public int hashCode() {
-    return planetModel.hashCode();
+    return super.hashCode();
   }
   
   @Override
   public boolean equals(final Object o) {
-    if (!(o instanceof GeoBaseShape))
-      return false;
-    return planetModel.equals(((GeoBaseShape)o).planetModel);
+    return super.equals(o);
   }
 }
-
-

Property changes on: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoBaseShape.java
___________________________________________________________________
Added: svn:executable
## -0,0 +1 ##
+*
\ No newline at end of property
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoCircle.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoCircle.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoCircle.java	(working copy)
@@ -22,7 +22,7 @@
  *
  * @lucene.experimental
  */
-public class GeoCircle extends GeoBaseExtendedShape implements GeoDistanceShape, GeoSizeable {
+public class GeoCircle extends GeoBaseDistanceShape implements GeoSizeable {
   public final GeoPoint center;
   public final double cutoffAngle;
   public final SidedPlane circlePlane;
@@ -91,108 +91,17 @@
     return center;
   }
 
-  /**
-   * Compute an estimate of "distance" to the GeoPoint.
-   * A return value of Double.MAX_VALUE should be returned for
-   * points outside of the shape.
-   */
   @Override
-  public double computeNormalDistance(final GeoPoint point) {
-    if (!isWithin(point))
-      return Double.MAX_VALUE;
-    return this.center.normalDistance(point);
+  protected double distance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    return distanceStyle.computeDistance(this.center, x, y, z);
   }
 
-  /**
-   * Compute an estimate of "distance" to the GeoPoint.
-   * A return value of Double.MAX_VALUE should be returned for
-   * points outside of the shape.
-   */
   @Override
-  public double computeNormalDistance(final double x, final double y, final double z) {
-    if (!isWithin(x,y,z))
-      return Double.MAX_VALUE;
-    return this.center.normalDistance(x, y, z);
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    return distanceStyle.computeDistance(planetModel, circlePlane, x, y, z);
   }
 
-  /**
-   * Compute a squared estimate of the "distance" to the
-   * GeoPoint.  Double.MAX_VALUE indicates a point outside of the
-   * shape.
-   */
   @Override
-  public double computeSquaredNormalDistance(final GeoPoint point) {
-    if (!isWithin(point))
-      return Double.MAX_VALUE;
-    return this.center.normalDistanceSquared(point);
-  }
-
-  /**
-   * Compute a squared estimate of the "distance" to the
-   * GeoPoint.  Double.MAX_VALUE indicates a point outside of the
-   * shape.
-   */
-  @Override
-  public double computeSquaredNormalDistance(final double x, final double y, final double z) {
-    if (!isWithin(x,y,z))
-      return Double.MAX_VALUE;
-    return this.center.normalDistanceSquared(x, y, z);
-  }
-
-  /**
-   * Compute a linear distance to the vector.
-   * return Double.MAX_VALUE for points outside the shape.
-   */
-  @Override
-  public double computeLinearDistance(final GeoPoint point) {
-    if (!isWithin(point))
-      return Double.MAX_VALUE;
-    return this.center.linearDistance(point);
-  }
-
-  /**
-   * Compute a linear distance to the vector.
-   * return Double.MAX_VALUE for points outside the shape.
-   */
-  @Override
-  public double computeLinearDistance(final double x, final double y, final double z) {
-    if (!isWithin(x,y,z))
-      return Double.MAX_VALUE;
-    return this.center.linearDistance(x, y, z);
-  }
-
-  /**
-   * Compute a squared linear distance to the vector.
-   */
-  @Override
-  public double computeSquaredLinearDistance(final GeoPoint point) {
-    if (!isWithin(point))
-      return Double.MAX_VALUE;
-    return this.center.linearDistanceSquared(point);
-  }
-
-  /**
-   * Compute a squared linear distance to the vector.
-   */
-  @Override
-  public double computeSquaredLinearDistance(final double x, final double y, final double z) {
-    if (!isWithin(x,y,z))
-      return Double.MAX_VALUE;
-    return this.center.linearDistanceSquared(x, y, z);
-  }
-
-  /**
-   * Compute a true, accurate, great-circle distance.
-   * Double.MAX_VALUE indicates a point is outside of the shape.
-   */
-  @Override
-  public double computeArcDistance(final GeoPoint point) {
-    if (!isWithin(point))
-      return Double.MAX_VALUE;
-    return this.center.arcDistance(point);
-  }
-
-  @Override
   public boolean isWithin(final Vector point) {
     if (circlePlane == null) {
       return true;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoCompositeMembershipShape.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoCompositeMembershipShape.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoCompositeMembershipShape.java	(working copy)
@@ -93,7 +93,37 @@
   }
 
   @Override
+  public double computeOutsideDistance(final DistanceStyle distanceStyle, final GeoPoint point) {
+    if (isWithin(point))
+      return 0.0;
+    double distance = Double.MAX_VALUE;
+    for (GeoMembershipShape shape : shapes) {
+      final double normalDistance = shape.computeOutsideDistance(distanceStyle, point);
+      if (normalDistance < distance) {
+        distance = normalDistance;
+      }
+    }
+    return distance;
+  }
+
+  @Override
+  public double computeOutsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    if (isWithin(x,y,z))
+      return 0.0;
+    double distance = Double.MAX_VALUE;
+    for (GeoMembershipShape shape : shapes) {
+      final double normalDistance = shape.computeOutsideDistance(distanceStyle, x, y, z);
+      if (normalDistance < distance) {
+        distance = normalDistance;
+      }
+    }
+    return distance;
+  }
+
+  @Override
   public boolean equals(Object o) {
+    if (!super.equals(o))
+      return false;
     if (!(o instanceof GeoCompositeMembershipShape))
       return false;
     GeoCompositeMembershipShape other = (GeoCompositeMembershipShape) o;
@@ -109,7 +139,7 @@
 
   @Override
   public int hashCode() {
-    return shapes.hashCode();//TODO cache
+    return super.hashCode() + shapes.hashCode();//TODO cache
   }
 
   @Override
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoConvexPolygon.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoConvexPolygon.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoConvexPolygon.java	(working copy)
@@ -29,7 +29,7 @@
  *
  * @lucene.experimental
  */
-public class GeoConvexPolygon extends GeoBaseExtendedShape implements GeoMembershipShape {
+public class GeoConvexPolygon extends GeoBaseMembershipShape {
   protected final List<GeoPoint> points;
   protected final BitSet isInternalEdges;
 
@@ -241,6 +241,32 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    double minimumDistance = Double.MAX_VALUE;
+    for (final GeoPoint edgePoint : points) {
+      final double newDist = distanceStyle.computeDistance(edgePoint, x,y,z);
+      if (newDist < minimumDistance) {
+        minimumDistance = newDist;
+      }
+    }
+    for (int edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {
+      final Plane edgePlane = edges[edgeIndex];
+      final Membership[] membershipBounds = new Membership[edges.length - 1];
+      int count = 0;
+      for (int otherIndex = 0; otherIndex < edges.length; otherIndex++) {
+        if (otherIndex != edgeIndex) {
+          membershipBounds[count++] = edges[otherIndex];
+        }
+      }
+      final double newDist = distanceStyle.computeDistance(planetModel, edgePlane, x, y, z, membershipBounds);
+      if (newDist < minimumDistance) {
+        minimumDistance = newDist;
+      }
+    }
+    return minimumDistance;
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoConvexPolygon))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateHorizontalLine.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateHorizontalLine.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateHorizontalLine.java	(working copy)
@@ -187,6 +187,18 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    final double distance = distanceStyle.computeDistance(planetModel, plane, x,y,z, leftPlane, rightPlane);
+    
+    final double LHCDistance = distanceStyle.computeDistance(LHC, x,y,z);
+    final double RHCDistance = distanceStyle.computeDistance(RHC, x,y,z);
+    
+    return Math.min(
+      distance,
+      Math.min(LHCDistance, RHCDistance));
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoDegenerateHorizontalLine))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateLatitudeZone.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateLatitudeZone.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateLatitudeZone.java	(working copy)
@@ -122,6 +122,11 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    return distanceStyle.computeDistance(planetModel, plane, x,y,z);
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoDegenerateLatitudeZone))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateLongitudeSlice.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateLongitudeSlice.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateLongitudeSlice.java	(working copy)
@@ -136,6 +136,18 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    final double distance = distanceStyle.computeDistance(planetModel, plane, x,y,z, boundingPlane);
+    
+    final double northDistance = distanceStyle.computeDistance(planetModel.NORTH_POLE, x,y,z);
+    final double southDistance = distanceStyle.computeDistance(planetModel.SOUTH_POLE, x,y,z);
+    
+    return Math.min(
+      distance,
+      Math.min(northDistance, southDistance));
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoDegenerateLongitudeSlice))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegeneratePoint.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegeneratePoint.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegeneratePoint.java	(working copy)
@@ -102,6 +102,16 @@
     return bounds;
   }
 
+  @Override
+  public double computeOutsideDistance(final DistanceStyle distanceStyle, final GeoPoint point) {
+    return distanceStyle.computeDistance(this, point);
+  }
+
+  @Override
+  public double computeOutsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    return distanceStyle.computeDistance(this, x,y,z);
+  }
+
   /**
    * Equals
    */
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateVerticalLine.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateVerticalLine.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDegenerateVerticalLine.java	(working copy)
@@ -184,6 +184,18 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    final double distance = distanceStyle.computeDistance(planetModel, plane, x,y,z, topPlane, bottomPlane, boundingPlane);
+    
+    final double UHCDistance = distanceStyle.computeDistance(UHC, x,y,z);
+    final double LHCDistance = distanceStyle.computeDistance(LHC, x,y,z);
+    
+    return Math.min(
+      distance,
+      Math.min(UHCDistance, LHCDistance));
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoDegenerateVerticalLine))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDistance.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDistance.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoDistance.java	(working copy)
@@ -26,50 +26,24 @@
  * @lucene.experimental
  */
 public interface GeoDistance extends Membership {
-  /**
-   * Compute this shape's normal "distance" to the GeoPoint.
-   * A return value of Double.MAX_VALUE should be returned for
-   * points outside of the shape.
-   *
-   * @param point is the point to compute the distance to.
-   * @return the normal distance, defined as the perpendicular distance from
-   * from the point to one of the shape's bounding plane.  Normal
-   * distances can therefore typically only go up to PI/2, except
-   * when they represent the sum of a sequence of normal distances.
-   */
-  public double computeNormalDistance(GeoPoint point);
+  
+  // The following methods compute distances from the shape to a point
+  // expected to be INSIDE the shape.  Typically a value of Double.MAX_VALUE
+  // is returned for points that happen to be outside the shape.
 
   /**
-   * Compute this shape's normal "distance" to the GeoPoint.
+   * Compute this shape's internal "distance" to the GeoPoint.
    * A return value of Double.MAX_VALUE should be returned for
    * points outside of the shape.
    *
-   * @param x is the point's unit x coordinate (using U.S. convention).
-   * @param y is the point's unit y coordinate (using U.S. convention).
-   * @param z is the point's unit z coordinate (using U.S. convention).
-   * @return the normal distance, defined as the perpendicular distance from
-   * from the point to one of the shape's bounding plane.  Normal
-   * distances can therefore typically only go up to PI/2, except
-   * when they represent the sum of a sequence of normal distances.
-   */
-  public double computeNormalDistance(double x, double y, double z);
-
-  /**
-   * Compute the square of this shape's normal "distance" to the GeoPoint.
-   * A return value of Double.MAX_VALUE should be returned for
-   * points outside of the shape.
-   *
+   * @param distanceStyle is the distance style.
    * @param point is the point to compute the distance to.
-   * @return the square of the normal distance, defined as the perpendicular
-   * distance from
-   * from the point to one of the shape's bounding plane.  Normal
-   * distances can therefore typically only go up to PI/2, except
-   * when they represent the sum of a sequence of normal distances.
+   * @return the distance.
    */
-  public double computeSquaredNormalDistance(GeoPoint point);
+  public double computeDistance(final DistanceStyle distanceStyle, final GeoPoint point);
 
   /**
-   * Compute the square of this shape's normal "distance" to the GeoPoint.
+   * Compute this shape's internal "distance" to the GeoPoint.
    * A return value of Double.MAX_VALUE should be returned for
    * points outside of the shape.
    *
@@ -76,78 +50,8 @@
    * @param x is the point's unit x coordinate (using U.S. convention).
    * @param y is the point's unit y coordinate (using U.S. convention).
    * @param z is the point's unit z coordinate (using U.S. convention).
-   * @return the square of the  normal distance, defined as the perpendicular
-   * distance from
-   * from the point to one of the shape's bounding plane.  Normal
-   * distances can therefore typically only go up to PI/2, except
-   * when they represent the sum of a sequence of normal distances.
-   */
-  public double computeSquaredNormalDistance(double x, double y, double z);
-
-  /**
-   * Compute this shape's linear "distance" to the GeoPoint.
-   * A return value of Double.MAX_VALUE should be returned for
-   * points outside of the shape.
-   *
-   * @param point is the point to compute the distance to.
-   * @return the linear (or chord) distance, defined as the distance from
-   * from the point to the nearest point on the unit sphere and on one of the shape's
-   * bounding planes.  Linear distances can therefore typically go up to PI,
-   * except when they represent the sum of a sequence of linear distances.
-   */
-  public double computeLinearDistance(GeoPoint point);
-
-  /**
-   * Compute this shape's linear "distance" to the GeoPoint.
-   * A return value of Double.MAX_VALUE should be returned for
-   * points outside of the shape.
-   *
-   * @param x is the point's unit x coordinate (using U.S. convention).
-   * @param y is the point's unit y coordinate (using U.S. convention).
-   * @param z is the point's unit z coordinate (using U.S. convention).
-   * @return the linear (or chord) distance, defined as the distance from
-   * from the point to the nearest point on the unit sphere and on one of the shape's
-   * bounding planes.  Linear distances can therefore typically go up to PI,
-   * except when they represent the sum of a sequence of linear distances.
-   */
-  public double computeLinearDistance(double x, double y, double z);
-
-  /**
-   * Compute the square of this shape's linear "distance" to the GeoPoint.
-   * A return value of Double.MAX_VALUE should be returned for
-   * points outside of the shape.
-   *
-   * @param point is the point to compute the distance to.
-   * @return the square of the linear (or chord) distance, defined as the
-   * distance from
-   * from the point to the nearest point on the unit sphere and on one of the shape's
-   * bounding planes.  Linear distances can therefore typically go up to PI,
-   * except when they represent the sum of a sequence of linear distances.
-   */
-  public double computeSquaredLinearDistance(GeoPoint point);
-
-  /**
-   * Compute the square of this shape's linear "distance" to the GeoPoint.
-   * A return value of Double.MAX_VALUE should be returned for
-   * points outside of the shape.
-   *
-   * @param x is the point's unit x coordinate (using U.S. convention).
-   * @param y is the point's unit y coordinate (using U.S. convention).
-   * @param z is the point's unit z coordinate (using U.S. convention).
-   * @return the square of the linear (or chord) distance, defined as the distance from
-   * from the point to the nearest point on the unit sphere and on one of the shape's
-   * bounding planes.  Linear distances can therefore typically go up to PI,
-   * except when they represent the sum of a sequence of linear distances.
-   */
-  public double computeSquaredLinearDistance(double x, double y, double z);
-
-  /**
-   * Compute a true, accurate, great-circle distance to a point.
-   * Double.MAX_VALUE indicates a point is outside of the shape.
-   *
-   * @param point is the point.
    * @return the distance.
    */
-  public double computeArcDistance(GeoPoint point);
+  public double computeDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z);
 
 }
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoLatitudeZone.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoLatitudeZone.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoLatitudeZone.java	(working copy)
@@ -174,6 +174,14 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    final double topDistance = distanceStyle.computeDistance(planetModel, topPlane, x,y,z, bottomPlane);
+    final double bottomDistance = distanceStyle.computeDistance(planetModel, bottomPlane, x,y,z, topPlane);
+
+    return Math.min(topDistance, bottomDistance);
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoLatitudeZone))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoLongitudeSlice.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoLongitudeSlice.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoLongitudeSlice.java	(working copy)
@@ -179,6 +179,20 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    final double leftDistance = distanceStyle.computeDistance(planetModel, leftPlane, x,y,z, rightPlane);
+    final double rightDistance = distanceStyle.computeDistance(planetModel, rightPlane, x,y,z, leftPlane);
+    
+    final double northDistance = distanceStyle.computeDistance(planetModel.NORTH_POLE, x,y,z);
+    final double southDistance = distanceStyle.computeDistance(planetModel.SOUTH_POLE, x,y,z);
+    
+    return
+      Math.min(
+        Math.min(northDistance, southDistance),
+        Math.min(leftDistance, rightDistance));
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoLongitudeSlice))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoMembershipShape.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoMembershipShape.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoMembershipShape.java	(working copy)
@@ -23,6 +23,6 @@
  *
  * @lucene.experimental
  */
-public interface GeoMembershipShape extends GeoShape, Membership {
+public interface GeoMembershipShape extends GeoShape, GeoOutsideDistance, Membership {
 
 }
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoNorthLatitudeZone.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoNorthLatitudeZone.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoNorthLatitudeZone.java	(working copy)
@@ -153,6 +153,11 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    return distanceStyle.computeDistance(planetModel, bottomPlane, x,y,z);
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoNorthLatitudeZone))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoNorthRectangle.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoNorthRectangle.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoNorthRectangle.java	(working copy)
@@ -227,6 +227,23 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    final double bottomDistance = distanceStyle.computeDistance(planetModel, bottomPlane, x,y,z, leftPlane, rightPlane);
+    final double leftDistance = distanceStyle.computeDistance(planetModel, leftPlane, x,y,z, rightPlane, bottomPlane);
+    final double rightDistance = distanceStyle.computeDistance(planetModel, rightPlane, x,y,z, leftPlane, bottomPlane);
+    
+    final double LRHCDistance = distanceStyle.computeDistance(LRHC, x,y,z);
+    final double LLHCDistance = distanceStyle.computeDistance(LLHC, x,y,z);
+    
+    return
+      Math.min(
+        bottomDistance,
+        Math.min(
+          Math.min(leftDistance, rightDistance),
+          Math.min(LRHCDistance, LLHCDistance)));
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoNorthRectangle))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoOutsideDistance.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoOutsideDistance.java	(revision 0)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoOutsideDistance.java	(working copy)
@@ -0,0 +1,56 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Generic geo-distance-capable shape class description.  An implementer
+ * of this interface is capable of computing the described "distance" values,
+ * which are meant to provide both actual distance values, as well as
+ * distance estimates that can be computed more cheaply.
+ *
+ * @lucene.experimental
+ */
+public interface GeoOutsideDistance extends Membership {
+  
+  // The following methods compute distances from the shape to a point
+  // expected to be OUTSIDE the shape.  Typically a value of 0.0
+  // is returned for points that happen to be within the shape.
+  
+  /**
+   * Compute this shape's distance to the GeoPoint.
+   * A return value of 0.0 should be returned for
+   * points inside of the shape.
+   * @param distanceStyle is the distance style.
+   * @param point is the point to compute the distance to.
+   * @return the distance.
+   */
+  public double computeOutsideDistance(final DistanceStyle distanceStyle, final GeoPoint point);
+
+  /**
+   * Compute this shape's distance to the GeoPoint.
+   * A return value of 0.0 should be returned for
+   * points inside of the shape.
+   * @param distanceStyle is the distance style.
+   * @param x is the point's unit x coordinate (using U.S. convention).
+   * @param y is the point's unit y coordinate (using U.S. convention).
+   * @param z is the point's unit z coordinate (using U.S. convention).
+   * @return the distance.
+   */
+  public double computeOutsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z);
+
+}

Property changes on: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoOutsideDistance.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPath.java	(working copy)
@@ -20,6 +20,8 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
+import java.util.HashMap;
 
 /**
  * GeoSearchableShape representing a path across the surface of the globe,
@@ -29,7 +31,7 @@
  *
  * @lucene.experimental
  */
-public class GeoPath extends GeoBaseExtendedShape implements GeoDistanceShape {
+public class GeoPath extends GeoBaseDistanceShape {
   
   public final double cutoffAngle;
 
@@ -83,7 +85,7 @@
     GeoPoint lastPoint = null;
     for (final GeoPoint end : points) {
       if (lastPoint != null) {
-        final Plane normalizedConnectingPlane = new Plane(lastPoint, end).normalize();
+        final Plane normalizedConnectingPlane = new Plane(lastPoint, end);
         if (normalizedConnectingPlane == null) {
           continue;
         }
@@ -166,157 +168,49 @@
 
   }
 
-  /**
-   * Compute an estimate of "distance" to the GeoPoint.
-   * A return value of Double.MAX_VALUE should be returned for
-   * points outside of the shape.
-   */
   @Override
-  public double computeNormalDistance(final GeoPoint point) {
+  protected double distance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
     // Algorithm:
     // (1) If the point is within any of the segments along the path, return that value.
     // (2) If the point is within any of the segment end circles along the path, return that value.
     double currentDistance = 0.0;
     for (PathSegment segment : segments) {
-      double distance = segment.pathNormalDistance(point);
+      double distance = segment.pathDistance(planetModel, distanceStyle, x,y,z);
       if (distance != Double.MAX_VALUE)
         return currentDistance + distance;
-      currentDistance += segment.fullNormalDistance;
+      currentDistance += segment.fullPathDistance(distanceStyle);
     }
 
     int segmentIndex = 0;
     currentDistance = 0.0;
     for (SegmentEndpoint endpoint : endPoints) {
-      double distance = endpoint.pathNormalDistance(point);
+      double distance = endpoint.pathDistance(distanceStyle, x,y,z);
       if (distance != Double.MAX_VALUE)
         return currentDistance + distance;
       if (segmentIndex < segments.size())
-        currentDistance += segments.get(segmentIndex++).fullNormalDistance;
+        currentDistance += segments.get(segmentIndex++).fullPathDistance(distanceStyle);
     }
 
     return Double.MAX_VALUE;
   }
 
-  /**
-   * Compute an estimate of "distance" to the GeoPoint.
-   * A return value of Double.MAX_VALUE should be returned for
-   * points outside of the shape.
-   */
   @Override
-  public double computeNormalDistance(final double x, final double y, final double z) {
-    return computeNormalDistance(new GeoPoint(x, y, z));
-  }
-
-  /**
-   * Compute a squared estimate of the "distance" to the
-   * GeoPoint.  Double.MAX_VALUE indicates a point outside of the
-   * shape.
-   */
-  @Override
-  public double computeSquaredNormalDistance(final GeoPoint point) {
-    double pd = computeNormalDistance(point);
-    if (pd == Double.MAX_VALUE)
-      return pd;
-    return pd * pd;
-  }
-
-  /**
-   * Compute a squared estimate of the "distance" to the
-   * GeoPoint.  Double.MAX_VALUE indicates a point outside of the
-   * shape.
-   */
-  @Override
-  public double computeSquaredNormalDistance(final double x, final double y, final double z) {
-    return computeSquaredNormalDistance(new GeoPoint(x, y, z));
-  }
-
-  /**
-   * Compute a linear distance to the point.
-   */
-  @Override
-  public double computeLinearDistance(final GeoPoint point) {
-    // Algorithm:
-    // (1) If the point is within any of the segments along the path, return that value.
-    // (2) If the point is within any of the segment end circles along the path, return that value.
-    double currentDistance = 0.0;
-    for (PathSegment segment : segments) {
-      double distance = segment.pathLinearDistance(point);
-      if (distance != Double.MAX_VALUE)
-        return currentDistance + distance;
-      currentDistance += segment.fullLinearDistance;
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    double minDistance = Double.MAX_VALUE;
+    for (final SegmentEndpoint endpoint : endPoints) {
+      final double newDistance = endpoint.outsideDistance(distanceStyle, x,y,z);
+      if (newDistance < minDistance)
+        minDistance = newDistance;
     }
-
-    int segmentIndex = 0;
-    currentDistance = 0.0;
-    for (SegmentEndpoint endpoint : endPoints) {
-      double distance = endpoint.pathLinearDistance(point);
-      if (distance != Double.MAX_VALUE)
-        return currentDistance + distance;
-      if (segmentIndex < segments.size())
-        currentDistance += segments.get(segmentIndex++).fullLinearDistance;
+    for (final PathSegment segment : segments) {
+      final double newDistance = segment.outsideDistance(planetModel, distanceStyle, x,y,z);
+      if (newDistance < minDistance)
+        minDistance = newDistance;
     }
-
-    return Double.MAX_VALUE;
+    return minDistance;
   }
 
-  /**
-   * Compute a linear distance to the point.
-   */
   @Override
-  public double computeLinearDistance(final double x, final double y, final double z) {
-    return computeLinearDistance(new GeoPoint(x, y, z));
-  }
-
-  /**
-   * Compute a squared linear distance to the vector.
-   */
-  @Override
-  public double computeSquaredLinearDistance(final GeoPoint point) {
-    double pd = computeLinearDistance(point);
-    if (pd == Double.MAX_VALUE)
-      return pd;
-    return pd * pd;
-  }
-
-  /**
-   * Compute a squared linear distance to the vector.
-   */
-  @Override
-  public double computeSquaredLinearDistance(final double x, final double y, final double z) {
-    return computeSquaredLinearDistance(new GeoPoint(x, y, z));
-  }
-
-  /**
-   * Compute a true, accurate, great-circle distance.
-   * Double.MAX_VALUE indicates a point is outside of the shape.
-   */
-  @Override
-  public double computeArcDistance(final GeoPoint point) {
-    // Algorithm:
-    // (1) If the point is within any of the segments along the path, return that value.
-    // (2) If the point is within any of the segment end circles along the path, return that value.
-    double currentDistance = 0.0;
-    for (PathSegment segment : segments) {
-      double distance = segment.pathDistance(point);
-      if (distance != Double.MAX_VALUE)
-        return currentDistance + distance;
-      currentDistance += segment.fullDistance;
-    }
-
-    int segmentIndex = 0;
-    currentDistance = 0.0;
-    for (SegmentEndpoint endpoint : endPoints) {
-      double distance = endpoint.pathDistance(point);
-      if (distance != Double.MAX_VALUE)
-        return currentDistance + distance;
-      if (segmentIndex < segments.size())
-        currentDistance += segments.get(segmentIndex++).fullDistance;
-    }
-
-    return Double.MAX_VALUE;
-  }
-
-  @Override
   public boolean isWithin(final Vector point) {
     //System.err.println("Assessing whether point "+point+" is within geopath "+this);
     for (SegmentEndpoint pathPoint : endPoints) {
@@ -562,24 +456,16 @@
       return circlePlane.isWithin(x, y, z);
     }
 
-    public double pathDistance(final GeoPoint point) {
-      if (!isWithin(point))
+    public double pathDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+      if (!isWithin(x,y,z))
         return Double.MAX_VALUE;
-      return this.point.arcDistance(point);
+      return distanceStyle.computeDistance(this.point, x,y,z);
     }
 
-    public double pathNormalDistance(final GeoPoint point) {
-      if (!isWithin(point))
-        return Double.MAX_VALUE;
-      return this.point.normalDistance(point);
+    public double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+      return distanceStyle.computeDistance(this.point, x,y,z);
     }
 
-    public double pathLinearDistance(final GeoPoint point) {
-      if (!isWithin(point))
-        return Double.MAX_VALUE;
-      return this.point.linearDistance(point);
-    }
-
     public boolean intersects(final PlanetModel planetModel, final Plane p, final GeoPoint[] notablePoints, final Membership[] bounds) {
       //System.err.println("  looking for intersection between plane "+p+" and circle "+circlePlane+" on proper side of "+cutoffPlanes+" within "+bounds);
       if (circlePlane == null)
@@ -619,9 +505,7 @@
   public static class PathSegment {
     public final GeoPoint start;
     public final GeoPoint end;
-    public final double fullDistance;
-    public final double fullNormalDistance;
-    public final double fullLinearDistance;
+    public final Map<DistanceStyle,Double> fullDistanceCache = new HashMap<DistanceStyle,Double>();
     public final Plane normalizedConnectingPlane;
     public final SidedPlane upperConnectingPlane;
     public final SidedPlane lowerConnectingPlane;
@@ -644,9 +528,6 @@
       this.normalizedConnectingPlane = normalizedConnectingPlane;
       this.planeBoundingOffset = planeBoundingOffset;
 
-      fullDistance = start.arcDistance(end);
-      fullNormalDistance = start.normalDistance(end);
-      fullLinearDistance = start.linearDistance(end);
       // Either start or end should be on the correct side
       upperConnectingPlane = new SidedPlane(start, normalizedConnectingPlane, -planeBoundingOffset);
       lowerConnectingPlane = new SidedPlane(start, normalizedConnectingPlane, planeBoundingOffset);
@@ -684,6 +565,17 @@
       endCutoffPlanePoints = new GeoPoint[]{URHC, LRHC};
     }
 
+    public double fullPathDistance(final DistanceStyle distanceStyle) {
+      synchronized (fullDistanceCache) {
+        Double dist = fullDistanceCache.get(distanceStyle);
+        if (dist == null) {
+          dist = new Double(distanceStyle.computeDistance(start, end.x, end.y, end.z));
+          fullDistanceCache.put(distanceStyle, dist);
+        }
+        return dist.doubleValue();
+      }
+    }
+    
     public boolean isWithin(final Vector point) {
       //System.err.println(" assessing whether point "+point+" is within path segment "+this);
       //System.err.println("  within "+startCutoffPlane+": "+startCutoffPlane.isWithin(point));
@@ -704,74 +596,58 @@
           lowerConnectingPlane.isWithin(x, y, z);
     }
 
-    public double pathDistance(final GeoPoint point) {
-      if (!isWithin(point))
+    public double pathDistance(final PlanetModel planetModel, final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+      if (!isWithin(x,y,z))
         return Double.MAX_VALUE;
 
-      // Compute the distance, filling in both components.
-      final double perpDistance = Math.PI * 0.5 - Tools.safeAcos(Math.abs(normalizedConnectingPlane.evaluate(point)));
-      final Plane normalizedPerpPlane = new Plane(normalizedConnectingPlane, point).normalize();
-      final double pathDistance = Math.PI * 0.5 - Tools.safeAcos(Math.abs(normalizedPerpPlane.evaluate(start)));
-      return perpDistance + pathDistance;
-    }
-
-    public double pathNormalDistance(final GeoPoint point) {
-      if (!isWithin(point))
-        return Double.MAX_VALUE;
-
-      final double pointEval = Math.abs(normalizedConnectingPlane.evaluate(point));
-
+      // (1) Compute normalizedPerpPlane.  If degenerate, then return point distance from start to point.
       // Want no allocations or expensive operations!  so we do this the hard way
-      final double perpX = normalizedConnectingPlane.y * point.z - normalizedConnectingPlane.z * point.y;
-      final double perpY = normalizedConnectingPlane.z * point.x - normalizedConnectingPlane.x * point.z;
-      final double perpZ = normalizedConnectingPlane.x * point.y - normalizedConnectingPlane.y * point.x;
+      final double perpX = normalizedConnectingPlane.y * z - normalizedConnectingPlane.z * y;
+      final double perpY = normalizedConnectingPlane.z * x - normalizedConnectingPlane.x * z;
+      final double perpZ = normalizedConnectingPlane.x * y - normalizedConnectingPlane.y * x;
+      final double magnitude = Math.sqrt(perpX * perpX + perpY * perpY + perpZ * perpZ);
+      if (Math.abs(magnitude) < Vector.MINIMUM_RESOLUTION)
+        return distanceStyle.computeDistance(start, x,y,z);
+      final double normFactor = 1.0/magnitude;
+      final Plane normalizedPerpPlane = new Plane(perpX * normFactor, perpY * normFactor, perpZ * normFactor, 0.0);
+      
+      // Old computation: too expensive, because it calculates the intersection point twice.
+      //return distanceStyle.computeDistance(planetModel, normalizedConnectingPlane, x, y, z, startCutoffPlane, endCutoffPlane) +
+      //  distanceStyle.computeDistance(planetModel, normalizedPerpPlane, start.x, start.y, start.z, upperConnectingPlane, lowerConnectingPlane);
 
-      // If we have a degenerate line, then just compute the normal distance from point x to the start
-      if (Math.abs(perpX) < Vector.MINIMUM_RESOLUTION && Math.abs(perpY) < Vector.MINIMUM_RESOLUTION && Math.abs(perpZ) < Vector.MINIMUM_RESOLUTION)
-        return point.normalDistance(start);
-
-      final double normFactor = 1.0 / Math.sqrt(perpX * perpX + perpY * perpY + perpZ * perpZ);
-      final double perpEval = Math.abs(perpX * start.x + perpY * start.y + perpZ * start.z);
-      return perpEval * normFactor + pointEval;
+      final GeoPoint[] intersectionPoints = normalizedConnectingPlane.findIntersections(planetModel, normalizedPerpPlane);
+      GeoPoint thePoint;
+      if (intersectionPoints.length == 0)
+        throw new RuntimeException("Can't find world intersection for point x="+x+" y="+y+" z="+z);
+      else if (intersectionPoints.length == 1)
+        thePoint = intersectionPoints[0];
+      else {
+        if (startCutoffPlane.isWithin(intersectionPoints[0]) && endCutoffPlane.isWithin(intersectionPoints[0]))
+          thePoint = intersectionPoints[0];
+        else if (startCutoffPlane.isWithin(intersectionPoints[1]) && endCutoffPlane.isWithin(intersectionPoints[1]))
+          thePoint = intersectionPoints[1];
+        else
+          throw new RuntimeException("Can't find world intersection for point x="+x+" y="+y+" z="+z);
+      }
+      return distanceStyle.computeDistance(thePoint, x, y, z) + distanceStyle.computeDistance(start, thePoint.x, thePoint.y, thePoint.z);
     }
 
-    public double pathLinearDistance(final GeoPoint point) {
-      if (!isWithin(point))
-        return Double.MAX_VALUE;
-
-      // We have a normalized connecting plane.
-      // First, compute the perpendicular plane.
-      // Want no allocations or expensive operations!  so we do this the hard way
-      final double perpX = normalizedConnectingPlane.y * point.z - normalizedConnectingPlane.z * point.y;
-      final double perpY = normalizedConnectingPlane.z * point.x - normalizedConnectingPlane.x * point.z;
-      final double perpZ = normalizedConnectingPlane.x * point.y - normalizedConnectingPlane.y * point.x;
-
-      // If we have a degenerate line, then just compute the normal distance from point x to the start
-      if (Math.abs(perpX) < Vector.MINIMUM_RESOLUTION && Math.abs(perpY) < Vector.MINIMUM_RESOLUTION && Math.abs(perpZ) < Vector.MINIMUM_RESOLUTION)
-        return point.linearDistance(start);
-
-      // Next, we need the vector of the line, which is the cross product of the normalized connecting plane
-      // and the perpendicular plane that we just calculated.
-      final double lineX = normalizedConnectingPlane.y * perpZ - normalizedConnectingPlane.z * perpY;
-      final double lineY = normalizedConnectingPlane.z * perpX - normalizedConnectingPlane.x * perpZ;
-      final double lineZ = normalizedConnectingPlane.x * perpY - normalizedConnectingPlane.y * perpX;
-
-      // Now, compute a normalization factor
-      final double normalizer = 1.0 / Math.sqrt(lineX * lineX + lineY * lineY + lineZ * lineZ);
-
-      // Pick which point by using bounding planes
-      double normLineX = lineX * normalizer;
-      double normLineY = lineY * normalizer;
-      double normLineZ = lineZ * normalizer;
-      if (!startCutoffPlane.isWithin(normLineX, normLineY, normLineZ) ||
-          !endCutoffPlane.isWithin(normLineX, normLineY, normLineZ)) {
-        normLineX = -normLineX;
-        normLineY = -normLineY;
-        normLineZ = -normLineZ;
-      }
-
-      // Compute linear distance for the two points
-      return point.linearDistance(normLineX, normLineY, normLineZ) + start.linearDistance(normLineX, normLineY, normLineZ);
+    public double outsideDistance(final PlanetModel planetModel, final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+      final double upperDistance = distanceStyle.computeDistance(planetModel, upperConnectingPlane, x,y,z, lowerConnectingPlane, startCutoffPlane, endCutoffPlane);
+      final double lowerDistance = distanceStyle.computeDistance(planetModel, lowerConnectingPlane, x,y,z, upperConnectingPlane, startCutoffPlane, endCutoffPlane);
+      final double startDistance = distanceStyle.computeDistance(planetModel, startCutoffPlane, x,y,z, endCutoffPlane, lowerConnectingPlane, upperConnectingPlane);
+      final double endDistance = distanceStyle.computeDistance(planetModel, endCutoffPlane, x,y,z, startCutoffPlane, lowerConnectingPlane, upperConnectingPlane);
+      final double ULHCDistance = distanceStyle.computeDistance(ULHC, x,y,z);
+      final double URHCDistance = distanceStyle.computeDistance(URHC, x,y,z);
+      final double LLHCDistance = distanceStyle.computeDistance(LLHC, x,y,z);
+      final double LRHCDistance = distanceStyle.computeDistance(LRHC, x,y,z);
+      return Math.min(
+        Math.min(
+          Math.min(upperDistance,lowerDistance),
+          Math.min(startDistance,endDistance)),
+        Math.min(
+          Math.min(ULHCDistance, URHCDistance),
+          Math.min(LLHCDistance, LRHCDistance)));
     }
 
     public boolean intersects(final PlanetModel planetModel, final Plane p, final GeoPoint[] notablePoints, final Membership[] bounds) {
@@ -790,12 +666,6 @@
       lowerConnectingPlane.recordBounds(planetModel, bounds, upperConnectingPlane, startCutoffPlane, endCutoffPlane);
       startCutoffPlane.recordBounds(planetModel, bounds, endCutoffPlane, upperConnectingPlane, lowerConnectingPlane);
       endCutoffPlane.recordBounds(planetModel, bounds, startCutoffPlane, upperConnectingPlane, lowerConnectingPlane);
-      if (fullDistance >= Math.PI) {
-        // Too large a segment basically means that we can confuse the Bounds object.  Specifically, if our span exceeds 180 degrees
-        // in longitude (which even a segment whose actual length is less than that might if it goes close to a pole).
-        // Unfortunately, we can get arbitrarily close to the pole, so this may still not work in all cases.
-        bounds.noLongitudeBound();
-      }
     }
 
   }
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPoint.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPoint.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoPoint.java	(working copy)
@@ -124,6 +124,16 @@
     return Tools.safeAcos(dotProduct(v)/(magnitude() * v.magnitude()));
   }
 
+  /** Compute an arc distance between two points.
+   * @param x is the x part of the second point.
+   * @param y is the y part of the second point.
+   * @param z is the z part of the second point.
+   * @return the angle, in radians, between the two points.
+   */
+  public double arcDistance(final double x, final double y, final double z) {
+    return Tools.safeAcos(dotProduct(x,y,z)/(magnitude() * Vector.magnitude(x,y,z)));
+  }
+
   /** Compute the latitude for the point.
    * @return the latitude.
    */
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoRectangle.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoRectangle.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoRectangle.java	(working copy)
@@ -243,6 +243,27 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    final double topDistance = distanceStyle.computeDistance(planetModel, topPlane, x,y,z, bottomPlane, leftPlane, rightPlane);
+    final double bottomDistance = distanceStyle.computeDistance(planetModel, bottomPlane, x,y,z, topPlane, leftPlane, rightPlane);
+    final double leftDistance = distanceStyle.computeDistance(planetModel, leftPlane, x,y,z, rightPlane, topPlane, bottomPlane);
+    final double rightDistance = distanceStyle.computeDistance(planetModel, rightPlane, x,y,z, leftPlane, topPlane, bottomPlane);
+    
+    final double ULHCDistance = distanceStyle.computeDistance(ULHC, x,y,z);
+    final double URHCDistance = distanceStyle.computeDistance(URHC, x,y,z);
+    final double LRHCDistance = distanceStyle.computeDistance(LRHC, x,y,z);
+    final double LLHCDistance = distanceStyle.computeDistance(LLHC, x,y,z);
+    
+    return Math.min(
+      Math.min(
+        Math.min(topDistance, bottomDistance),
+        Math.min(leftDistance, rightDistance)),
+      Math.min(
+        Math.min(ULHCDistance, URHCDistance),
+        Math.min(LRHCDistance, LLHCDistance)));
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoRectangle))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoSouthLatitudeZone.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoSouthLatitudeZone.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoSouthLatitudeZone.java	(working copy)
@@ -149,6 +149,11 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    return distanceStyle.computeDistance(planetModel, topPlane, x,y,z);
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoSouthLatitudeZone))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoSouthRectangle.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoSouthRectangle.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoSouthRectangle.java	(working copy)
@@ -224,6 +224,22 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    final double topDistance = distanceStyle.computeDistance(planetModel, topPlane, x,y,z, leftPlane, rightPlane);
+    final double leftDistance = distanceStyle.computeDistance(planetModel, leftPlane, x,y,z, rightPlane, topPlane);
+    final double rightDistance = distanceStyle.computeDistance(planetModel, rightPlane, x,y,z, leftPlane, topPlane);
+    
+    final double ULHCDistance = distanceStyle.computeDistance(ULHC, x,y,z);
+    final double URHCDistance = distanceStyle.computeDistance(URHC, x,y,z);
+    
+    return Math.min(
+      Math.min(
+        topDistance,
+        Math.min(leftDistance, rightDistance)),
+      Math.min(ULHCDistance, URHCDistance));
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoSouthRectangle))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideDegenerateHorizontalLine.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideDegenerateHorizontalLine.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideDegenerateHorizontalLine.java	(working copy)
@@ -196,6 +196,18 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    final double distance = distanceStyle.computeDistance(planetModel, plane, x,y,z, eitherBound);
+    
+    final double LHCDistance = distanceStyle.computeDistance(LHC, x,y,z);
+    final double RHCDistance = distanceStyle.computeDistance(RHC, x,y,z);
+    
+    return Math.min(
+      distance,
+      Math.min(LHCDistance, RHCDistance));
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoWideDegenerateHorizontalLine))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideLongitudeSlice.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideLongitudeSlice.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideLongitudeSlice.java	(working copy)
@@ -178,6 +178,21 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    // Because the rectangle exceeds 180 degrees, it is safe to compute the horizontally 
+    // unbounded distance to both the left and the right and only take the minimum of the two.
+    final double leftDistance = distanceStyle.computeDistance(planetModel, leftPlane, x,y,z);
+    final double rightDistance = distanceStyle.computeDistance(planetModel, rightPlane, x,y,z);
+    
+    final double northDistance = distanceStyle.computeDistance(planetModel.NORTH_POLE, x,y,z);
+    final double southDistance = distanceStyle.computeDistance(planetModel.SOUTH_POLE, x,y,z);
+    
+    return Math.min(
+      Math.min(leftDistance, rightDistance),
+      Math.min(northDistance, southDistance));
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoWideLongitudeSlice))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideNorthRectangle.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideNorthRectangle.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideNorthRectangle.java	(working copy)
@@ -232,6 +232,24 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    final double bottomDistance = distanceStyle.computeDistance(planetModel, bottomPlane, x,y,z, eitherBound);
+    // Because the rectangle exceeds 180 degrees, it is safe to compute the horizontally 
+    // unbounded distance to both the left and the right and only take the minimum of the two.
+    final double leftDistance = distanceStyle.computeDistance(planetModel, leftPlane, x,y,z, bottomPlane);
+    final double rightDistance = distanceStyle.computeDistance(planetModel, rightPlane, x,y,z, bottomPlane);
+    
+    final double LRHCDistance = distanceStyle.computeDistance(LRHC, x,y,z);
+    final double LLHCDistance = distanceStyle.computeDistance(LLHC, x,y,z);
+    
+    return Math.min(
+      Math.min(
+        bottomDistance,
+        Math.min(leftDistance, rightDistance)),
+      Math.min(LRHCDistance, LLHCDistance));
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoWideNorthRectangle))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideRectangle.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideRectangle.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideRectangle.java	(working copy)
@@ -250,6 +250,29 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    final double topDistance = distanceStyle.computeDistance(planetModel, topPlane, x,y,z, bottomPlane, eitherBound);
+    final double bottomDistance = distanceStyle.computeDistance(planetModel, bottomPlane, x,y,z, topPlane, eitherBound);
+    // Because the rectangle exceeds 180 degrees, it is safe to compute the horizontally 
+    // unbounded distance to both the left and the right and only take the minimum of the two.
+    final double leftDistance = distanceStyle.computeDistance(planetModel, leftPlane, x,y,z, topPlane, bottomPlane);
+    final double rightDistance = distanceStyle.computeDistance(planetModel, rightPlane, x,y,z, topPlane, bottomPlane);
+    
+    final double ULHCDistance = distanceStyle.computeDistance(ULHC, x,y,z);
+    final double URHCDistance = distanceStyle.computeDistance(URHC, x,y,z);
+    final double LRHCDistance = distanceStyle.computeDistance(LRHC, x,y,z);
+    final double LLHCDistance = distanceStyle.computeDistance(LLHC, x,y,z);
+    
+    return Math.min(
+      Math.min(
+        Math.min(topDistance, bottomDistance),
+        Math.min(leftDistance, rightDistance)),
+      Math.min(
+        Math.min(ULHCDistance, URHCDistance),
+        Math.min(LRHCDistance, LLHCDistance)));
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoWideRectangle))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideSouthRectangle.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideSouthRectangle.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWideSouthRectangle.java	(working copy)
@@ -229,6 +229,24 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    final double topDistance = distanceStyle.computeDistance(planetModel, topPlane, x,y,z, eitherBound);
+    // Because the rectangle exceeds 180 degrees, it is safe to compute the horizontally 
+    // unbounded distance to both the left and the right and only take the minimum of the two.
+    final double leftDistance = distanceStyle.computeDistance(planetModel, leftPlane, x,y,z, topPlane);
+    final double rightDistance = distanceStyle.computeDistance(planetModel, rightPlane, x,y,z, topPlane);
+    
+    final double ULHCDistance = distanceStyle.computeDistance(ULHC, x,y,z);
+    final double URHCDistance = distanceStyle.computeDistance(URHC, x,y,z);
+    
+    return Math.min(
+      Math.min(
+        topDistance,
+        Math.min(leftDistance, rightDistance)),
+      Math.min(ULHCDistance, URHCDistance));
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoWideSouthRectangle))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWorld.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWorld.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/GeoWorld.java	(working copy)
@@ -99,6 +99,11 @@
   }
 
   @Override
+  protected double outsideDistance(final DistanceStyle distanceStyle, final double x, final double y, final double z) {
+    return 0.0;
+  }
+
+  @Override
   public boolean equals(Object o) {
     if (!(o instanceof GeoWorld))
       return false;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/LinearDistance.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/LinearDistance.java	(revision 0)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/LinearDistance.java	(working copy)
@@ -0,0 +1,50 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Linear distance computation style.
+ *
+ * @lucene.experimental
+ */
+public class LinearDistance implements DistanceStyle {
+  
+  public final static DistanceStyle INSTANCE = new LinearDistance();
+  
+  @Override
+  public double computeDistance(final GeoPoint point1, final GeoPoint point2) {
+    return point1.linearDistance(point2);
+  }
+  
+  @Override
+  public double computeDistance(final GeoPoint point1, final double x2, final double y2, final double z2) {
+    return point1.linearDistance(x2,y2,z2);
+  }
+
+  @Override
+  public double computeDistance(final PlanetModel planetModel, final Plane plane, final GeoPoint point, final Membership... bounds) {
+    return plane.linearDistance(planetModel, point, bounds);
+  }
+  
+  @Override
+  public double computeDistance(final PlanetModel planetModel, final Plane plane, final double x, final double y, final double z, final Membership... bounds) {
+    return plane.linearDistance(planetModel, x,y,z, bounds);
+  }
+
+}
+

Property changes on: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/LinearDistance.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/LinearSquaredDistance.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/LinearSquaredDistance.java	(revision 0)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/LinearSquaredDistance.java	(working copy)
@@ -0,0 +1,50 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Linear squared distance computation style.
+ *
+ * @lucene.experimental
+ */
+public class LinearSquaredDistance implements DistanceStyle {
+  
+  public final static DistanceStyle INSTANCE = new LinearSquaredDistance();
+  
+  @Override
+  public double computeDistance(final GeoPoint point1, final GeoPoint point2) {
+    return point1.linearDistanceSquared(point2);
+  }
+  
+  @Override
+  public double computeDistance(final GeoPoint point1, final double x2, final double y2, final double z2) {
+    return point1.linearDistanceSquared(x2,y2,z2);
+  }
+
+  @Override
+  public double computeDistance(final PlanetModel planetModel, final Plane plane, final GeoPoint point, final Membership... bounds) {
+    return plane.linearDistanceSquared(planetModel, point, bounds);
+  }
+  
+  @Override
+  public double computeDistance(final PlanetModel planetModel, final Plane plane, final double x, final double y, final double z, final Membership... bounds) {
+    return plane.linearDistanceSquared(planetModel, x,y,z, bounds);
+  }
+
+}
+

Property changes on: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/LinearSquaredDistance.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/NormalDistance.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/NormalDistance.java	(revision 0)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/NormalDistance.java	(working copy)
@@ -0,0 +1,50 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Normal distance computation style.
+ *
+ * @lucene.experimental
+ */
+public class NormalDistance implements DistanceStyle {
+  
+  public final static DistanceStyle INSTANCE = new NormalDistance();
+  
+  @Override
+  public double computeDistance(final GeoPoint point1, final GeoPoint point2) {
+    return point1.normalDistance(point2);
+  }
+  
+  @Override
+  public double computeDistance(final GeoPoint point1, final double x2, final double y2, final double z2) {
+    return point1.normalDistance(x2,y2,z2);
+  }
+
+  @Override
+  public double computeDistance(final PlanetModel planetModel, final Plane plane, final GeoPoint point, final Membership... bounds) {
+    return plane.normalDistance(point, bounds);
+  }
+  
+  @Override
+  public double computeDistance(final PlanetModel planetModel, final Plane plane, final double x, final double y, final double z, final Membership... bounds) {
+    return plane.normalDistance(x,y,z, bounds);
+  }
+
+}
+

Property changes on: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/NormalDistance.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/NormalSquaredDistance.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/NormalSquaredDistance.java	(revision 0)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/NormalSquaredDistance.java	(working copy)
@@ -0,0 +1,50 @@
+package org.apache.lucene.spatial.spatial4j.geo3d;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * Normal squared distance computation style.
+ *
+ * @lucene.experimental
+ */
+public class NormalSquaredDistance implements DistanceStyle {
+  
+  public final static DistanceStyle INSTANCE = new NormalSquaredDistance();
+  
+  @Override
+  public double computeDistance(final GeoPoint point1, final GeoPoint point2) {
+    return point1.normalDistanceSquared(point2);
+  }
+  
+  @Override
+  public double computeDistance(final GeoPoint point1, final double x2, final double y2, final double z2) {
+    return point1.normalDistanceSquared(x2,y2,z2);
+  }
+
+  @Override
+  public double computeDistance(final PlanetModel planetModel, final Plane plane, final GeoPoint point, final Membership... bounds) {
+    return plane.normalDistanceSquared(point, bounds);
+  }
+  
+  @Override
+  public double computeDistance(final PlanetModel planetModel, final Plane plane, final double x, final double y, final double z, final Membership... bounds) {
+    return plane.normalDistanceSquared(x,y,z, bounds);
+  }
+
+}
+

Property changes on: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/NormalSquaredDistance.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Plane.java	(working copy)
@@ -143,7 +143,181 @@
     return new Plane(normVect, this.D);
   }
 
+  public double arcDistance(final PlanetModel planetModel, final GeoPoint v, final Membership... bounds) {
+    return arcDistance(planetModel, v.x, v.y, v.z, bounds);
+  }
+    
   /**
+   * Compute arc distance from plane to a vector.
+   * @param x is the x vector value.
+   * @param y is the y vector value.
+   * @param z is the z vector value.
+   * @return the arc distance.
+   */
+  public double arcDistance(final PlanetModel planetModel, final double x, final double y, final double z, final Membership... bounds) {
+
+    if (evaluateIsZero(x,y,z)) {
+      if (meetsAllBounds(x,y,z, bounds))
+        return 0.0;
+      return Double.MAX_VALUE;
+    }
+    
+    // First, compute the perpendicular plane.
+    final Plane perpPlane = new Plane(this.y * z - this.z * y, this.z * x - this.x * z, this.x * y - this.y * x, 0.0);
+
+    // We need to compute the intersection of two planes on the geo surface: this one, and its perpendicular.
+    // Then, we need to choose which of the two points we want to compute the distance to.  We pick the
+    // shorter distance always.
+    
+    final GeoPoint[] intersectionPoints = findIntersections(planetModel, perpPlane);
+    
+    // For each point, compute a linear distance, and take the minimum of them
+    double minDistance = Double.MAX_VALUE;
+    
+    for (final GeoPoint intersectionPoint : intersectionPoints) {
+      if (meetsAllBounds(intersectionPoint, bounds)) {
+        final double theDistance = intersectionPoint.arcDistance(x,y,z);
+        if (theDistance < minDistance) {
+          minDistance = theDistance;
+        }
+      }
+    }
+    return minDistance;
+
+  }
+
+  /**
+   * Compute normal distance from plane to a vector.
+   * @param v is the vector.
+   * @return the normal distance.
+   */
+  public double normalDistance(final Vector v, final Membership... bounds) {
+    return normalDistance(v.x, v.y, v.z, bounds);
+  }
+    
+  /**
+   * Compute normal distance from plane to a vector.
+   * @param x is the vector x.
+   * @param y is the vector y.
+   * @param z is the vector z.
+   * @return the normal distance.
+   */
+  public double normalDistance(final double x, final double y, final double z, final Membership... bounds) {
+
+    final double dist = evaluate(x,y,z);
+    final double perpX = x - dist * this.x;
+    final double perpY = y - dist * this.y;
+    final double perpZ = z - dist * this.z;
+
+    if (!meetsAllBounds(perpX, perpY, perpZ, bounds)) {
+      return Double.MAX_VALUE;
+    }
+    
+    return Math.abs(dist);
+  }
+  
+  /**
+   * Compute normal distance squared from plane to a vector.
+   * @param v is the vector.
+   * @return the normal distance squared.
+   */
+  public double normalDistanceSquared(final Vector v, final Membership... bounds) {
+    return normalDistanceSquared(v.x, v.y, v.z, bounds);
+  }
+  
+  /**
+   * Compute normal distance squared from plane to a vector.
+   * @param x is the vector x.
+   * @param y is the vector y.
+   * @param z is the vector z.
+   * @return the normal distance squared.
+   */
+  public double normalDistanceSquared(final double x, final double y, final double z, final Membership... bounds) {
+
+    final double normal = normalDistance(x,y,z,bounds);
+    if (normal == Double.MAX_VALUE)
+      return normal;
+    return normal * normal;
+  }
+
+  /**
+   * Compute linear distance from plane to a vector.  This is defined
+   * as the distance from the given point to the nearest intersection of 
+   * this plane with the planet surface.
+   * @param v is the vector.
+   * @return the linear distance.
+   */
+  public double linearDistance(final PlanetModel planetModel, final GeoPoint v, final Membership... bounds) {
+    return linearDistance(planetModel, v.x, v.y, v.z, bounds);
+  }
+    
+  /**
+   * Compute linear distance from plane to a vector.  This is defined
+   * as the distance from the given point to the nearest intersection of 
+   * this plane with the planet surface.
+   * @param x is the vector x.
+   * @param y is the vector y.
+   * @param z is the vector z.
+   * @return the linear distance.
+   */
+  public double linearDistance(final PlanetModel planetModel, final double x, final double y, final double z, final Membership... bounds) {
+
+    if (evaluateIsZero(x,y,z)) {
+      if (meetsAllBounds(x,y,z, bounds))
+        return 0.0;
+      return Double.MAX_VALUE;
+    }
+    
+    // First, compute the perpendicular plane.
+    final Plane perpPlane = new Plane(this.y * z - this.z * y, this.z * x - this.x * z, this.x * y - this.y * x, 0.0);
+
+    // We need to compute the intersection of two planes on the geo surface: this one, and its perpendicular.
+    // Then, we need to choose which of the two points we want to compute the distance to.  We pick the
+    // shorter distance always.
+    
+    final GeoPoint[] intersectionPoints = findIntersections(planetModel, perpPlane);
+    
+    // For each point, compute a linear distance, and take the minimum of them
+    double minDistance = Double.MAX_VALUE;
+    
+    for (final GeoPoint intersectionPoint : intersectionPoints) {
+      if (meetsAllBounds(intersectionPoint, bounds)) {
+        final double theDistance = intersectionPoint.linearDistance(x,y,z);
+        if (theDistance < minDistance) {
+          minDistance = theDistance;
+        }
+      }
+    }
+    return minDistance;
+  }
+      
+  /**
+   * Compute linear distance squared from plane to a vector.  This is defined
+   * as the distance from the given point to the nearest intersection of 
+   * this plane with the planet surface.
+   * @param v is the vector.
+   * @return the linear distance squared.
+   */
+  public double linearDistanceSquared(final PlanetModel planetModel, final GeoPoint v, final Membership... bounds) {
+    return linearDistanceSquared(planetModel, v.x, v.y, v.z, bounds);
+  }
+  
+  /**
+   * Compute linear distance squared from plane to a vector.  This is defined
+   * as the distance from the given point to the nearest intersection of 
+   * this plane with the planet surface.
+   * @param x is the vector x.
+   * @param y is the vector y.
+   * @param z is the vector z.
+   * @return the linear distance squared.
+   */
+  public double linearDistanceSquared(final PlanetModel planetModel, final double x, final double y, final double z, final Membership... bounds) {
+
+    final double linearDistance = linearDistance(planetModel, x, y, z, bounds);
+    return linearDistance * linearDistance;
+  }
+
+  /**
    * Find points on the boundary of the intersection of a plane and the unit sphere,
    * given a starting point, and ending point, and a list of proportions of the arc (e.g. 0.25, 0.5, 0.75).
    * The angle between the starting point and ending point is assumed to be less than pi.
@@ -320,7 +494,8 @@
    */
   protected GeoPoint[] findIntersections(final PlanetModel planetModel, final Plane q, final Membership[] bounds, final Membership[] moreBounds) {
     //System.err.println("Looking for intersection between plane "+this+" and plane "+q+" within bounds");
-    final Vector lineVector = new Vector(this, q);
+    // Unnormalized, unchecked...
+    final Vector lineVector = new Vector(y * q.z - z * q.y, z * q.x - x * q.z, x * q.y - y * q.x);
     if (Math.abs(lineVector.x) < MINIMUM_RESOLUTION && Math.abs(lineVector.y) < MINIMUM_RESOLUTION && Math.abs(lineVector.z) < MINIMUM_RESOLUTION) {
       // Degenerate case: parallel planes
       //System.err.println(" planes are parallel - no intersection");
@@ -860,11 +1035,27 @@
     return evaluateIsZero(-p.x * p.D * denom, -p.y * p.D * denom, -p.z * p.D * denom);
   }
 
-  protected static boolean meetsAllBounds(final GeoPoint p, final Membership[] bounds, final Membership[] moreBounds) {
+  protected static boolean meetsAllBounds(final Vector p, final Membership[] bounds) {
     for (final Membership bound : bounds) {
       if (!bound.isWithin(p))
         return false;
     }
+    return true;
+  }
+
+  protected static boolean meetsAllBounds(final double x, final double y, final double z, final Membership[] bounds) {
+    for (final Membership bound : bounds) {
+      if (!bound.isWithin(x,y,z))
+        return false;
+    }
+    return true;
+  }
+
+  protected static boolean meetsAllBounds(final Vector p, final Membership[] bounds, final Membership[] moreBounds) {
+    for (final Membership bound : bounds) {
+      if (!bound.isWithin(p))
+        return false;
+    }
     for (final Membership bound : moreBounds) {
       if (!bound.isWithin(p))
         return false;
@@ -872,6 +1063,18 @@
     return true;
   }
 
+  protected static boolean meetsAllBounds(final double x, final double y, final double z, final Membership[] bounds, final Membership[] moreBounds) {
+    for (final Membership bound : bounds) {
+      if (!bound.isWithin(x,y,z))
+        return false;
+    }
+    for (final Membership bound : moreBounds) {
+      if (!bound.isWithin(x,y,z))
+        return false;
+    }
+    return true;
+  }
+
   /**
    * Find a sample point on the intersection between two planes and the unit sphere.
    */
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/SidedPlane.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/SidedPlane.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/SidedPlane.java	(working copy)
@@ -90,11 +90,13 @@
   public static SidedPlane constructNormalizedPerpendicularSidedPlane(final Vector insidePoint,
     final Vector normalVector, final Vector point1, final Vector point2) {
     final Vector pointsVector = new Vector(point1.x - point2.x, point1.y - point2.y, point1.z - point2.z);
-    final Vector newNormalVector = new Vector(normalVector, pointsVector).normalize();
-    if (newNormalVector == null)
+    final Vector newNormalVector = new Vector(normalVector, pointsVector);
+    try {
+      // To construct the plane, we now just need D, which is simply the negative of the evaluation of the circle normal vector at one of the points.
+      return new SidedPlane(insidePoint, newNormalVector, -newNormalVector.dotProduct(point1));
+    } catch (IllegalArgumentException e) {
       return null;
-    // To construct the plane, we now just need D, which is simply the negative of the evaluation of the circle normal vector at one of the points.
-    return new SidedPlane(insidePoint, newNormalVector, -newNormalVector.dotProduct(point1));
+    }
   }
   
   /** Construct a sided plane from three points.
@@ -101,12 +103,14 @@
    */
   public static SidedPlane constructNormalizedThreePointSidedPlane(final Vector insidePoint,
     final Vector point1, final Vector point2, final Vector point3) {
-    final Vector planeNormal = new Vector(
-      new Vector(point1.x - point2.x, point1.y - point2.y, point1.z - point2.z),
-      new Vector(point2.x - point3.x, point2.y - point3.y, point2.z - point3.z)).normalize();
-    if (planeNormal == null)
+    try {
+      final Vector planeNormal = new Vector(
+        new Vector(point1.x - point2.x, point1.y - point2.y, point1.z - point2.z),
+        new Vector(point2.x - point3.x, point2.y - point3.y, point2.z - point3.z));
+      return new SidedPlane(insidePoint, planeNormal, -planeNormal.dotProduct(point2));
+    } catch (IllegalArgumentException e) {
       return null;
-    return new SidedPlane(insidePoint, planeNormal, -planeNormal.dotProduct(point2));
+    }
   }
 
   /**
Index: lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Vector.java
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Vector.java	(revision 1687904)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/spatial4j/geo3d/Vector.java	(working copy)
@@ -52,7 +52,8 @@
   /**
    * Construct a vector that is perpendicular to
    * two other (non-zero) vectors.  If the vectors are parallel,
-   * the result vector will have magnitude 0.
+   * IllegalArgumentException will be thrown.
+   * Produces a normalized final vector.
    *
    * @param A is the first vector
    * @param B is the second
@@ -61,12 +62,25 @@
     // x = u2v3 - u3v2
     // y = u3v1 - u1v3
     // z = u1v2 - u2v1
+    final double thisX = A.y * B.z - A.z * B.y;
+    final double thisY = A.z * B.x - A.x * B.z;
+    final double thisZ = A.x * B.y - A.y * B.x;
+    final double magnitude = magnitude(thisX, thisY, thisZ);
+    if (Math.abs(magnitude) < MINIMUM_RESOLUTION) {
+      throw new IllegalArgumentException("Degenerate/parallel vector constructed");
+    }
+    final double inverseMagnitude = 1.0 / magnitude;
+    this.x = thisX * inverseMagnitude;
+    this.y = thisY * inverseMagnitude;
+    this.z = thisZ * inverseMagnitude;
+  }
 
-    this(A.y * B.z - A.z * B.y,
-        A.z * B.x - A.x * B.z,
-        A.x * B.y - A.y * B.x);
+  /** Compute a magnitude of an x,y,z value.
+   */
+  public static double magnitude(final double x, final double y, final double z) {
+    return Math.sqrt(x*x + y*y + z*z);
   }
-
+  
   /**
    * Compute a normalized unit vector based on the current vector.
    *
@@ -304,7 +318,7 @@
    * @return the magnitude.
    */
   public double magnitude() {
-    return Math.sqrt(x * x + y * y + z * z);
+    return magnitude(x,y,z);
   }
 
   /** Compute the desired magnitude of a unit vector projected to a given
Index: lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoBBoxTest.java
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoBBoxTest.java	(revision 1687904)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoBBoxTest.java	(working copy)
@@ -66,6 +66,9 @@
     assertFalse(box.isWithin(gp));
     gp = new GeoPoint(PlanetModel.SPHERE, -0.1, -1.1);
     assertFalse(box.isWithin(gp));
+    assertEquals(0.1,box.computeOutsideDistance(ArcDistance.INSTANCE,gp),1e-2);
+    assertEquals(0.1,box.computeOutsideDistance(NormalDistance.INSTANCE,gp),1e-2);
+    assertEquals(0.1,box.computeOutsideDistance(LinearDistance.INSTANCE,gp),1e-2);
 
     // Standard normal Rect box, crossing dateline
     box = GeoBBoxFactory.makeGeoBBox(PlanetModel.SPHERE, 0.0, -Math.PI * 0.25, Math.PI - 1.0, -Math.PI + 1.0);
@@ -77,8 +80,8 @@
     assertFalse(box.isWithin(gp));
     gp = new GeoPoint(PlanetModel.SPHERE, -0.1, -Math.PI + 1.1);
     assertFalse(box.isWithin(gp));
-    //bad lon: gp = new GeoPoint(PlanetModel.SPHERE, -0.1, -Math.PI - 1.1);
-    //assertFalse(box.isWithin(gp));
+    gp = new GeoPoint(PlanetModel.SPHERE, -0.1, (-Math.PI - 1.1) + Math.PI * 2.0);
+    assertFalse(box.isWithin(gp));
 
     // Latitude zone rectangle
     box = GeoBBoxFactory.makeGeoBBox(PlanetModel.SPHERE, 0.0, -Math.PI * 0.25, -Math.PI, Math.PI);
@@ -90,8 +93,8 @@
     assertFalse(box.isWithin(gp));
     gp = new GeoPoint(PlanetModel.SPHERE, -0.1, -Math.PI + 1.1);
     assertTrue(box.isWithin(gp));
-    //bad lon: gp = new GeoPoint(PlanetModel.SPHERE, -0.1, -Math.PI - 1.1);
-    //assertTrue(box.isWithin(gp));
+    gp = new GeoPoint(PlanetModel.SPHERE, -0.1, (-Math.PI - 1.1) + Math.PI * 2.0);
+    assertTrue(box.isWithin(gp));
 
     // World
     box = GeoBBoxFactory.makeGeoBBox(PlanetModel.SPHERE, Math.PI * 0.5, -Math.PI * 0.5, -Math.PI, Math.PI);
@@ -103,8 +106,8 @@
     assertTrue(box.isWithin(gp));
     gp = new GeoPoint(PlanetModel.SPHERE, -0.1, -Math.PI + 1.1);
     assertTrue(box.isWithin(gp));
-    //bad lat: gp = new GeoPoint(PlanetModel.SPHERE, -0.1, -Math.PI - 1.1);
-    //assertTrue(box.isWithin(gp));
+    gp = new GeoPoint(PlanetModel.SPHERE, -0.1, (-Math.PI - 1.1) + Math.PI * 2.0);
+    assertTrue(box.isWithin(gp));
 
   }
 
Index: lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoCircleTest.java
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoCircleTest.java	(revision 1687904)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoCircleTest.java	(working copy)
@@ -32,17 +32,17 @@
     GeoPoint gp;
     c = new GeoCircle(PlanetModel.SPHERE, 0.0, -0.5, 0.1);
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, 0.0);
-    assertEquals(Double.MAX_VALUE, c.computeArcDistance(gp), 0.0);
-    assertEquals(Double.MAX_VALUE, c.computeLinearDistance(gp), 0.0);
-    assertEquals(Double.MAX_VALUE, c.computeNormalDistance(gp), 0.0);
+    assertEquals(Double.MAX_VALUE, c.computeDistance(ArcDistance.INSTANCE,gp), 0.0);
+    assertEquals(Double.MAX_VALUE, c.computeDistance(LinearDistance.INSTANCE,gp), 0.0);
+    assertEquals(Double.MAX_VALUE, c.computeDistance(NormalDistance.INSTANCE,gp), 0.0);
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, -0.5);
-    assertEquals(0.0, c.computeArcDistance(gp), 0.000001);
-    assertEquals(0.0, c.computeLinearDistance(gp), 0.000001);
-    assertEquals(0.0, c.computeNormalDistance(gp), 0.000001);
+    assertEquals(0.0, c.computeDistance(ArcDistance.INSTANCE,gp), 0.000001);
+    assertEquals(0.0, c.computeDistance(LinearDistance.INSTANCE,gp), 0.000001);
+    assertEquals(0.0, c.computeDistance(NormalDistance.INSTANCE,gp), 0.000001);
     gp = new GeoPoint(PlanetModel.SPHERE, 0.05, -0.5);
-    assertEquals(0.05, c.computeArcDistance(gp), 0.000001);
-    assertEquals(0.049995, c.computeLinearDistance(gp), 0.000001);
-    assertEquals(0.049979, c.computeNormalDistance(gp), 0.000001);
+    assertEquals(0.05, c.computeDistance(ArcDistance.INSTANCE,gp), 0.000001);
+    assertEquals(0.049995, c.computeDistance(LinearDistance.INSTANCE,gp), 0.000001);
+    assertEquals(0.049979, c.computeDistance(NormalDistance.INSTANCE,gp), 0.000001);
   }
 
   @Test
@@ -75,6 +75,9 @@
     c = new GeoCircle(PlanetModel.SPHERE, 0.0, -0.5, 0.1);
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, 0.0);
     assertFalse(c.isWithin(gp));
+    assertEquals(0.4,c.computeOutsideDistance(ArcDistance.INSTANCE,gp),1e-12);
+    assertEquals(0.12,c.computeOutsideDistance(NormalDistance.INSTANCE,gp),0.01);
+    assertEquals(0.4,c.computeOutsideDistance(LinearDistance.INSTANCE,gp),0.01);
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, -0.5);
     assertTrue(c.isWithin(gp));
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, -0.55);
Index: lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoConvexPolygonTest.java
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoConvexPolygonTest.java	(revision 1687904)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoConvexPolygonTest.java	(working copy)
@@ -46,9 +46,12 @@
     assertTrue(c.isWithin(gp));
     gp = new GeoPoint(PlanetModel.SPHERE, 0.05, -0.5);
     assertTrue(c.isWithin(gp));
-    // Sample some nearby points outside
+    // Sample some nearby points outside, and compute distance-to-shape for them as well
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, -0.65);
     assertFalse(c.isWithin(gp));
+    assertEquals(0.05,c.computeOutsideDistance(ArcDistance.INSTANCE,gp),1e-12);
+    assertEquals(0.05,c.computeOutsideDistance(NormalDistance.INSTANCE,gp),1e-3);
+    assertEquals(0.05,c.computeOutsideDistance(LinearDistance.INSTANCE,gp),1e-3);
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, -0.35);
     assertFalse(c.isWithin(gp));
     gp = new GeoPoint(PlanetModel.SPHERE, -0.15, -0.5);
Index: lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoPathTest.java
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoPathTest.java	(revision 1687904)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/spatial4j/geo3d/GeoPathTest.java	(working copy)
@@ -37,17 +37,17 @@
     p.addPoint(0.0, 0.2);
     p.done();
     gp = new GeoPoint(PlanetModel.SPHERE, Math.PI * 0.5, 0.15);
-    assertEquals(Double.MAX_VALUE, p.computeArcDistance(gp), 0.0);
+    assertEquals(Double.MAX_VALUE, p.computeDistance(ArcDistance.INSTANCE,gp), 0.0);
     gp = new GeoPoint(PlanetModel.SPHERE, 0.05, 0.15);
-    assertEquals(0.15 + 0.05, p.computeArcDistance(gp), 0.000001);
+    assertEquals(0.15 + 0.05, p.computeDistance(ArcDistance.INSTANCE,gp), 0.000001);
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, 0.12);
-    assertEquals(0.12 + 0.0, p.computeArcDistance(gp), 0.000001);
+    assertEquals(0.12 + 0.0, p.computeDistance(ArcDistance.INSTANCE,gp), 0.000001);
     gp = new GeoPoint(PlanetModel.SPHERE, -0.15, 0.05);
-    assertEquals(Double.MAX_VALUE, p.computeArcDistance(gp), 0.000001);
+    assertEquals(Double.MAX_VALUE, p.computeDistance(ArcDistance.INSTANCE,gp), 0.000001);
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, 0.25);
-    assertEquals(0.20 + 0.05, p.computeArcDistance(gp), 0.000001);
+    assertEquals(0.20 + 0.05, p.computeDistance(ArcDistance.INSTANCE,gp), 0.000001);
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, -0.05);
-    assertEquals(0.0 + 0.05, p.computeArcDistance(gp), 0.000001);
+    assertEquals(0.0 + 0.05, p.computeDistance(ArcDistance.INSTANCE,gp), 0.000001);
 
     // Compute path distances now
     p = new GeoPath(PlanetModel.SPHERE, 0.1);
@@ -56,9 +56,9 @@
     p.addPoint(0.0, 0.2);
     p.done();
     gp = new GeoPoint(PlanetModel.SPHERE, 0.05, 0.15);
-    assertEquals(0.15 + 0.05, p.computeArcDistance(gp), 0.000001);
+    assertEquals(0.15 + 0.05, p.computeDistance(ArcDistance.INSTANCE,gp), 0.000001);
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, 0.12);
-    assertEquals(0.12, p.computeArcDistance(gp), 0.000001);
+    assertEquals(0.12, p.computeDistance(ArcDistance.INSTANCE,gp), 0.000001);
 
     // Now try a vertical path, and make sure distances are as expected
     p = new GeoPath(PlanetModel.SPHERE, 0.1);
@@ -66,13 +66,13 @@
     p.addPoint(Math.PI * 0.25, -0.5);
     p.done();
     gp = new GeoPoint(PlanetModel.SPHERE, 0.0, 0.0);
-    assertEquals(Double.MAX_VALUE, p.computeArcDistance(gp), 0.0);
+    assertEquals(Double.MAX_VALUE, p.computeDistance(ArcDistance.INSTANCE,gp), 0.0);
     gp = new GeoPoint(PlanetModel.SPHERE, -0.1, -1.0);
-    assertEquals(Double.MAX_VALUE, p.computeArcDistance(gp), 0.0);
+    assertEquals(Double.MAX_VALUE, p.computeDistance(ArcDistance.INSTANCE,gp), 0.0);
     gp = new GeoPoint(PlanetModel.SPHERE, Math.PI * 0.25 + 0.05, -0.5);
-    assertEquals(Math.PI * 0.5 + 0.05, p.computeArcDistance(gp), 0.000001);
+    assertEquals(Math.PI * 0.5 + 0.05, p.computeDistance(ArcDistance.INSTANCE,gp), 0.000001);
     gp = new GeoPoint(PlanetModel.SPHERE, -Math.PI * 0.25 - 0.05, -0.5);
-    assertEquals(0.0 + 0.05, p.computeArcDistance(gp), 0.000001);
+    assertEquals(0.0 + 0.05, p.computeDistance(ArcDistance.INSTANCE,gp), 0.000001);
   }
 
   @Test
