Index: solr/contrib/mcf/CHANGES.txt
===================================================================
--- solr/contrib/mcf/CHANGES.txt	(revision 0)
+++ solr/contrib/mcf/CHANGES.txt	(revision 1174245)
@@ -0,0 +1,22 @@
+Apache Solr ManifoldCFSecurityFilter Library
+		Release Notes
+
+This file describes changes to the Solr ManifoldCFSecurityFilter (contrib/auth) module. See SOLR-1895 for details.
+
+Introduction
+------------
+This module is intended to be used to restrict queries based on a user's authorization information.
+It includes a SearchComponent class org.apache.solr.auth.ManifoldCFSecurityFilter.  This search
+component requires the argument "AuthorityServiceBaseURL", which describes the URL needed to reach
+the ManifoldCF Authority Service.  Other optional parameters are:
+
+AllowAttributePrefix - the first part of the 'allow' family of fields, e.g. "allow_token_document" or
+	"allow_token_share", defaulting to "allow_token_".
+DenyAttributePrefix - the first part of the 'deny' family of fields, e.g. "deny_token_document" or
+	"deny_token_share", defaulting to "deny_token_".
+
+$Id$
+
+==================  4.0.0-dev ==============
+
+Initial Release

Property changes on: solr\contrib\mcf\CHANGES.txt
___________________________________________________________________
Added: svn:keywords
   + Id
Added: svn:eol-style
   + native

Index: solr/contrib/mcf/src/test/org/apache/solr/mcf/ManifoldCFSecurityFilterTest.java
===================================================================
--- solr/contrib/mcf/src/test/org/apache/solr/mcf/ManifoldCFSecurityFilterTest.java	(revision 0)
+++ solr/contrib/mcf/src/test/org/apache/solr/mcf/ManifoldCFSecurityFilterTest.java	(revision 1174245)
@@ -0,0 +1,189 @@
+/**
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements. See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License. You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+
+package org.apache.solr.mcf;
+
+import java.io.IOException;
+
+import javax.servlet.http.HttpServlet;
+import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
+
+import org.apache.solr.SolrTestCaseJ4;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.mortbay.jetty.Server;
+import org.mortbay.jetty.servlet.Context;
+import org.mortbay.jetty.servlet.ServletHolder;
+
+public class ManifoldCFSecurityFilterTest extends SolrTestCaseJ4 {
+  
+  static MockMCFAuthorityService service;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    initCore("solrconfig-auth.xml","schema-auth.xml");
+    service = new MockMCFAuthorityService();
+    service.start();
+
+    //             |     share    |   document
+    //             |--------------|--------------
+    //             | allow | deny | allow | deny
+    // ------------+-------+------+-------+------
+    // da12        |       |      | 1, 2  |
+    // ------------+-------+------+-------+------
+    // da13-dd3    |       |      | 1,3   | 3
+    // ------------+-------+------+-------+------
+    // sa123-sd13  | 1,2,3 | 1, 3 |       |
+    // ------------+-------+------+-------+------
+    // sa3-sd1-da23| 3     | 1    | 2,3   |
+    // ------------+-------+------+-------+------
+    // notoken     |       |      |       |
+    // ------------+-------+------+-------+------
+    //
+    assertU(adoc("id", "da12", "allow_token_document", "token1", "allow_token_document", "token2"));
+    assertU(adoc("id", "da13-dd3", "allow_token_document", "token1", "allow_token_document", "token3", "deny_token_document", "token3"));
+    assertU(adoc("id", "sa123-sd13", "allow_token_share", "token1", "allow_token_share", "token2", "allow_token_share", "token3", "deny_token_share", "token1", "deny_token_share", "token3"));
+    assertU(adoc("id", "sa3-sd1-da23", "allow_token_document", "token2", "allow_token_document", "token3", "allow_token_share", "token3", "deny_token_share", "token1"));
+    assertU(adoc("id", "notoken"));
+    assertU(commit());
+  }
+
+  @AfterClass
+  public static void afterClass() throws Exception {
+    service.stop();
+  }
+  
+  @Test
+  public void testParameters() throws Exception {
+    ManifoldCFSecurityFilter mcfFilter = (ManifoldCFSecurityFilter)h.getCore().getSearchComponent("mcf-param");
+    assertEquals("http://localhost:8345/mcf-as", mcfFilter.authorityBaseURL);
+    assertEquals(3000, mcfFilter.socketTimeOut);
+    assertEquals("aap-document", mcfFilter.fieldAllowDocument);
+    assertEquals("dap-document", mcfFilter.fieldDenyDocument);
+    assertEquals("aap-share", mcfFilter.fieldAllowShare);
+    assertEquals("dap-share", mcfFilter.fieldDenyShare);
+  }
+
+  @Test
+  public void testNullUsers() throws Exception {
+    assertQ(req("qt", "/mcf", "q", "*:*", "fl", "id"),
+        "//*[@numFound='1']",
+        "//result/doc[1]/str[@name='id'][.='notoken']");
+    assertQ(req("qt", "/mcf", "q", "*:*", "fl", "id", "AuthenticatedUserName", "anonymous"),
+        "//*[@numFound='1']",
+        "//result/doc[1]/str[@name='id'][.='notoken']");
+  }
+
+  // da12
+  // da13-dd3
+  // sa123-sd13
+  // sa3-sd1-da23
+  // notoken
+  @Test
+  public void testAuthUsers() throws Exception {
+    assertQ(req("qt", "/mcf", "q", "*:*", "fl", "id", "AuthenticatedUserName", "user1"),
+        "//*[@numFound='3']",
+        "//result/doc[1]/str[@name='id'][.='da12']",
+        "//result/doc[2]/str[@name='id'][.='da13-dd3']",
+        "//result/doc[3]/str[@name='id'][.='notoken']");
+
+    assertQ(req("qt", "/mcf", "q", "*:*", "fl", "id", "AuthenticatedUserName", "user2"),
+        "//*[@numFound='3']",
+        "//result/doc[1]/str[@name='id'][.='da12']",
+        "//result/doc[2]/str[@name='id'][.='da13-dd3']",
+        "//result/doc[3]/str[@name='id'][.='notoken']");
+
+    assertQ(req("qt", "/mcf", "q", "*:*", "fl", "id", "AuthenticatedUserName", "user3"),
+        "//*[@numFound='2']",
+        "//result/doc[1]/str[@name='id'][.='da12']",
+        "//result/doc[2]/str[@name='id'][.='notoken']");
+  }
+
+  // da12
+  // da13-dd3
+  // sa123-sd13
+  // sa3-sd1-da23
+  // notoken
+  @Test
+  public void testUserTokens() throws Exception {
+
+    assertQ(req("qt", "/mcf", "q", "*:*", "fl", "id", "UserTokens", "token1"),
+        "//*[@numFound='3']",
+        "//result/doc[1]/str[@name='id'][.='da12']",
+        "//result/doc[2]/str[@name='id'][.='da13-dd3']",
+        "//result/doc[3]/str[@name='id'][.='notoken']");
+
+    assertQ(req("qt", "/mcf", "q", "*:*", "fl", "id", "UserTokens", "token2"),
+        "//*[@numFound='3']",
+        "//result/doc[1]/str[@name='id'][.='da12']",
+        "//result/doc[2]/str[@name='id'][.='sa123-sd13']",
+        "//result/doc[3]/str[@name='id'][.='notoken']");
+
+    assertQ(req("qt", "/mcf", "q", "*:*", "fl", "id", "UserTokens", "token3"),
+        "//*[@numFound='2']",
+        "//result/doc[1]/str[@name='id'][.='sa3-sd1-da23']",
+        "//result/doc[2]/str[@name='id'][.='notoken']");
+
+    assertQ(req("qt", "/mcf", "q", "*:*", "fl", "id", "UserTokens", "token2", "UserTokens", "token3"),
+        "//*[@numFound='3']",
+        "//result/doc[1]/str[@name='id'][.='da12']",
+        "//result/doc[2]/str[@name='id'][.='sa3-sd1-da23']",
+        "//result/doc[3]/str[@name='id'][.='notoken']");
+  }
+  
+  static class MockMCFAuthorityService {
+    
+    Server server;
+    
+    public MockMCFAuthorityService() {
+      server = new Server(8345);
+      Context asContext = new Context(server,"/mcf-authority-service",Context.SESSIONS);
+      asContext.addServlet(new ServletHolder(new UserACLServlet()), "/UserACLs");
+    }
+    
+    public void start() throws Exception {
+      server.start();
+    }
+    
+    public void stop() throws Exception {
+      server.stop();
+    }
+
+    // username | tokens rewarded
+    // ---------+-------------------------------
+    // null     | (no tokens)
+    // user1    | token1
+    // user2    | token1, token2
+    // user3    | token1, token2, token3
+    public static class UserACLServlet extends HttpServlet {
+      @Override
+      public void service(HttpServletRequest req, HttpServletResponse res)
+          throws IOException {
+        String user = req.getParameter("username");
+        res.setStatus(HttpServletResponse.SC_OK);
+        if(user.equals("user1") || user.equals("user2") || user.equals("user3"))
+          res.getWriter().printf("TOKEN:token1\n");
+        if(user.equals("user2") || user.equals("user3"))
+          res.getWriter().printf("TOKEN:token2\n");
+        if(user.equals("user3"))
+          res.getWriter().printf("TOKEN:token3\n");
+      }
+    }
+  }
+}

Property changes on: solr\contrib\mcf\src\test\org\apache\solr\mcf\ManifoldCFSecurityFilterTest.java
___________________________________________________________________
Added: svn:keywords
   + Id
Added: svn:eol-style
   + native

Index: solr/contrib/mcf/src/test-files/solr/conf/solrconfig-auth.xml
===================================================================
--- solr/contrib/mcf/src/test-files/solr/conf/solrconfig-auth.xml	(revision 0)
+++ solr/contrib/mcf/src/test-files/solr/conf/solrconfig-auth.xml	(revision 1174245)
@@ -0,0 +1,63 @@
+<?xml version="1.0" ?>
+
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+
+<!-- $Id$
+     $Source$
+     $Name$
+  -->
+
+<config>
+
+  <luceneMatchVersion>${tests.luceneMatchVersion:LUCENE_CURRENT}</luceneMatchVersion>
+  <jmx />
+
+  <dataDir>${solr.data.dir:}</dataDir>
+
+  <directoryFactory name="DirectoryFactory" class="${solr.directoryFactory:solr.RAMDirectoryFactory}"/>
+
+  <updateHandler class="solr.DirectUpdateHandler2">
+  </updateHandler>
+
+  <requestHandler name="/update"     class="solr.XmlUpdateRequestHandler" />
+
+  <!-- test MCF Security Filter settings -->
+  <searchComponent name="mcf-param" class="org.apache.solr.mcf.ManifoldCFSecurityFilter" >
+    <str name="AuthorityServiceBaseURL">http://localhost:8345/mcf-as</str>
+    <int name="SocketTimeOut">3000</int>
+    <str name="AllowAttributePrefix">aap-</str>
+    <str name="DenyAttributePrefix">dap-</str>
+  </searchComponent>
+
+  <searchComponent name="mcf" class="org.apache.solr.mcf.ManifoldCFSecurityFilter" >
+  </searchComponent>
+
+  <requestHandler name="/mcf" class="solr.SearchHandler" startup="lazy">
+    <lst name="invariants">
+      <bool name="mcf">true</bool>
+    </lst>
+    <lst name="defaults">
+      <str name="echoParams">all</str>
+    </lst>
+    <arr name="components">
+      <str>query</str>
+      <str>mcf</str>
+    </arr>
+  </requestHandler>
+
+</config>

Property changes on: solr\contrib\mcf\src\test-files\solr\conf\solrconfig-auth.xml
___________________________________________________________________
Added: svn:keywords
   + Id
Added: svn:eol-style
   + native

Index: solr/contrib/mcf/src/test-files/solr/conf/schema-auth.xml
===================================================================
--- solr/contrib/mcf/src/test-files/solr/conf/schema-auth.xml	(revision 0)
+++ solr/contrib/mcf/src/test-files/solr/conf/schema-auth.xml	(revision 1174245)
@@ -0,0 +1,32 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+<schema name="auth" version="1.4">
+ <types>
+  <fieldType name="string" class="solr.StrField"/>
+ </types>
+ <fields>
+  <field name="id" type="string" indexed="true" stored="true" required="true"/>
+  <!-- MCF Security fields -->
+  <field name="allow_token_document" type="string" indexed="true" stored="false" multiValued="true"/>
+  <field name="deny_token_document" type="string" indexed="true" stored="false" multiValued="true"/>
+  <field name="allow_token_share" type="string" indexed="true" stored="false" multiValued="true"/>
+  <field name="deny_token_share" type="string" indexed="true" stored="false" multiValued="true"/>
+ </fields>
+ <defaultSearchField>id</defaultSearchField>
+ <uniqueKey>id</uniqueKey>
+</schema>

Property changes on: solr\contrib\mcf\src\test-files\solr\conf\schema-auth.xml
___________________________________________________________________
Added: svn:keywords
   + Id
Added: svn:eol-style
   + native

Index: solr/contrib/mcf/src/java/org/apache/solr/mcf/ManifoldCFSecurityFilter.java
===================================================================
--- solr/contrib/mcf/src/java/org/apache/solr/mcf/ManifoldCFSecurityFilter.java	(revision 0)
+++ solr/contrib/mcf/src/java/org/apache/solr/mcf/ManifoldCFSecurityFilter.java	(revision 1174245)
@@ -0,0 +1,317 @@
+/**
+* Licensed to the Apache Software Foundation (ASF) under one or more
+* contributor license agreements. See the NOTICE file distributed with
+* this work for additional information regarding copyright ownership.
+* The ASF licenses this file to You under the Apache License, Version 2.0
+* (the "License"); you may not use this file except in compliance with
+* the License. You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+*/
+package org.apache.solr.mcf;
+
+import org.apache.lucene.index.*;
+import org.apache.lucene.search.*;
+import org.apache.lucene.queries.*;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.params.CommonParams;
+import org.apache.solr.common.params.ShardParams;
+import org.apache.solr.common.params.SolrParams;
+import org.apache.solr.common.util.NamedList;
+import org.apache.solr.handler.component.ResponseBuilder;
+import org.apache.solr.handler.component.SearchComponent;
+import org.apache.commons.httpclient.*;
+import org.apache.commons.httpclient.methods.*;
+import org.slf4j.*;
+
+import java.io.*;
+import java.util.*;
+import java.net.*;
+
+/**
+* SearchComponent plugin for ManifoldCF-specific document-level access control.
+* Configuration is under the SolrACLSecurity name.
+*/
+public class ManifoldCFSecurityFilter extends SearchComponent
+{
+  /** The component name */
+  static final public String COMPONENT_NAME = "mcf";
+  /** The parameter that is supposed to contain the authenticated user name, possibly including the domain */
+  static final public String AUTHENTICATED_USER_NAME = "AuthenticatedUserName";
+  /** This parameter is an array of strings, which contain the tokens to use if there is no authenticated user name.
+   * It's meant to work with mod_authz_annotate,
+   * running under Apache */
+  static final public String USER_TOKENS = "UserTokens";
+  
+  /** The queries that we will not attempt to interfere with */
+  static final private String[] globalAllowed = { "solrpingquery" };
+  
+  /** A logger we can use */
+  private static final Logger LOG = LoggerFactory.getLogger(ManifoldCFSecurityFilter.class);
+
+  // Member variables
+  String authorityBaseURL = null;
+  String fieldAllowDocument = null;
+  String fieldDenyDocument = null;
+  String fieldAllowShare = null;
+  String fieldDenyShare = null;
+  int socketTimeOut;
+  
+  public ManifoldCFSecurityFilter()
+  {
+    super();
+  }
+
+  @Override
+  public void init(NamedList args)
+  {
+    super.init(args);
+    authorityBaseURL = (String)args.get("AuthorityServiceBaseURL");
+    if (authorityBaseURL == null)
+      authorityBaseURL = "http://localhost:8345/mcf-authority-service";
+    Integer timeOut = (Integer)args.get("SocketTimeOut");
+    socketTimeOut = timeOut == null ? 300000 : timeOut;
+    String allowAttributePrefix = (String)args.get("AllowAttributePrefix");
+    String denyAttributePrefix = (String)args.get("DenyAttributePrefix");
+    if (allowAttributePrefix == null)
+      allowAttributePrefix = "allow_token_";
+    if (denyAttributePrefix == null)
+      denyAttributePrefix = "deny_token_";
+    fieldAllowDocument = allowAttributePrefix+"document";
+    fieldDenyDocument = denyAttributePrefix+"document";
+    fieldAllowShare = allowAttributePrefix+"share";
+    fieldDenyShare = denyAttributePrefix+"share";
+  }
+
+  @Override
+  public void prepare(ResponseBuilder rb) throws IOException
+  {
+    SolrParams params = rb.req.getParams();
+    if (!params.getBool(COMPONENT_NAME, true) || params.getBool(ShardParams.IS_SHARD, false))
+      return;
+
+    // Log that we got here
+    //LOG.info("prepare() entry params:\n" + params + "\ncontext: " + rb.req.getContext());
+		
+    String qry = (String)params.get(CommonParams.Q);
+    if (qry != null)
+    {
+      //Check global allowed searches
+      for (String ga : globalAllowed)
+      {
+        if (qry.equalsIgnoreCase(ga.trim()))
+          // Allow this query through unchanged
+          return;
+      }
+    }
+
+    List<String> userAccessTokens;
+    
+    // Get the authenticated user name from the parameters
+    String authenticatedUserName = params.get(AUTHENTICATED_USER_NAME);
+    
+    // If this parameter is empty or does not exist, we have to presume this is a guest, and treat them accordingly
+    if (authenticatedUserName == null || authenticatedUserName.length() == 0)
+    {
+      // No authenticated user name.
+      // mod_authz_annotate may be in use upstream, so look for tokens from it.
+      userAccessTokens = new ArrayList<String>();
+      String[] passedTokens = params.getParams(USER_TOKENS);
+      if (passedTokens == null)
+      {
+        // Only return 'public' documents (those with no security tokens at all)
+        LOG.info("Default no-user response (open documents only)");
+      }
+      else
+      {
+        // Only return 'public' documents (those with no security tokens at all)
+        LOG.info("Group tokens received from caller");
+        for (String passedToken : passedTokens)
+        {
+          userAccessTokens.add(passedToken);
+        }
+      }
+    }
+    else
+    {
+      LOG.info("Trying to match docs for user '"+authenticatedUserName+"'");
+      // Valid authenticated user name.  Look up access tokens for the user.
+      // Check the configuration arguments for validity
+      if (authorityBaseURL == null)
+      {
+        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Error initializing ManifoldCFSecurityFilter component: 'AuthorityServiceBaseURL' init parameter required");
+      }
+      userAccessTokens = getAccessTokens(authenticatedUserName);
+    }
+
+    BooleanFilter bf = new BooleanFilter();
+    
+    if (userAccessTokens.size() == 0)
+    {
+      // Only open documents can be included.
+      // That query is:
+      // (fieldAllowShare is empty AND fieldDenyShare is empty AND fieldAllowDocument is empty AND fieldDenyDocument is empty)
+      // We're trying to map to:  -(fieldAllowShare:*) , which should be pretty efficient in Solr because it is negated.  If this turns out not to be so, then we should
+      // have the SolrConnector inject a special token into these fields when they otherwise would be empty, and we can trivially match on that token.
+      bf.add(new FilterClause(new QueryWrapperFilter(new WildcardQuery(new Term(fieldAllowShare,"*"))),BooleanClause.Occur.MUST_NOT));
+      bf.add(new FilterClause(new QueryWrapperFilter(new WildcardQuery(new Term(fieldDenyShare,"*"))),BooleanClause.Occur.MUST_NOT));
+      bf.add(new FilterClause(new QueryWrapperFilter(new WildcardQuery(new Term(fieldAllowDocument,"*"))),BooleanClause.Occur.MUST_NOT));
+      bf.add(new FilterClause(new QueryWrapperFilter(new WildcardQuery(new Term(fieldDenyDocument,"*"))),BooleanClause.Occur.MUST_NOT));
+    }
+    else
+    {
+      // Extend the query appropriately for each user access token.
+      bf.add(new FilterClause(calculateCompleteSubfilter(fieldAllowShare,fieldDenyShare,userAccessTokens),BooleanClause.Occur.MUST));
+      bf.add(new FilterClause(calculateCompleteSubfilter(fieldAllowDocument,fieldDenyDocument,userAccessTokens),BooleanClause.Occur.MUST));
+    }
+
+    // Concatenate with the user's original query.
+    //FilteredQuery query = new FilteredQuery(rb.getQuery(),bf);
+    //rb.setQuery(query);
+    List<Query> list = rb.getFilters();
+    if (list == null)
+    {
+      list = new ArrayList<Query>();
+      rb.setFilters(list);
+    }
+    list.add(new ConstantScoreQuery(bf));
+  }
+
+  @Override
+  public void process(ResponseBuilder rb) throws IOException
+  {
+    //LOG.info("process() called");
+  }
+
+  /** Calculate a complete subclause, representing something like:
+  * ((fieldAllowShare is empty AND fieldDenyShare is empty) OR fieldAllowShare HAS token1 OR fieldAllowShare HAS token2 ...)
+  *     AND fieldDenyShare DOESN'T_HAVE token1 AND fieldDenyShare DOESN'T_HAVE token2 ...
+  */
+  protected Filter calculateCompleteSubfilter(String allowField, String denyField, List<String> userAccessTokens)
+  {
+    BooleanFilter bf = new BooleanFilter();
+    
+    // Add a clause for each token.  This will be added directly to the main filter (as a deny test), as well as to an OR's subclause (as an allow test).
+    BooleanFilter orFilter = new BooleanFilter();
+    // Add the empty-acl case
+    BooleanFilter subUnprotectedClause = new BooleanFilter();
+    subUnprotectedClause.add(new FilterClause(new QueryWrapperFilter(new WildcardQuery(new Term(allowField,"*"))),BooleanClause.Occur.MUST_NOT));
+    subUnprotectedClause.add(new FilterClause(new QueryWrapperFilter(new WildcardQuery(new Term(denyField,"*"))),BooleanClause.Occur.MUST_NOT));
+    orFilter.add(new FilterClause(subUnprotectedClause,BooleanClause.Occur.SHOULD));
+    for (String accessToken : userAccessTokens)
+    {
+      TermsFilter tf = new TermsFilter();
+      tf.addTerm(new Term(allowField,accessToken));
+      orFilter.add(new FilterClause(tf,BooleanClause.Occur.SHOULD));
+      tf = new TermsFilter();
+      tf.addTerm(new Term(denyField,accessToken));
+      bf.add(new FilterClause(tf,BooleanClause.Occur.MUST_NOT));
+    }
+    bf.add(new FilterClause(orFilter,BooleanClause.Occur.MUST));
+    return bf;
+  }
+  
+  //---------------------------------------------------------------------------------
+  // SolrInfoMBean
+  //---------------------------------------------------------------------------------
+  @Override
+  public String getDescription()
+  {
+    return "ManifoldCF Solr security enforcement plugin";
+  }
+
+  @Override
+  public String getVersion()
+  {
+    return "$Revision$";
+  }
+
+  @Override
+  public String getSourceId()
+  {
+    return "$Id$";
+  }
+
+  @Override
+  public String getSource()
+  {
+    return "$URL$";
+  }
+	
+  // Protected methods
+  
+  /** Get access tokens given a username */
+  protected List<String> getAccessTokens(String authenticatedUserName)
+    throws IOException
+  {
+    // We can make this more complicated later, with support for https etc., but this is enough to demonstrate how it all should work.
+    HttpClient client = new HttpClient();
+    String theURL = authorityBaseURL + "/UserACLs?username="+URLEncoder.encode(authenticatedUserName,"utf-8");
+      
+    GetMethod method = new GetMethod(theURL);
+    try
+    {
+      method.getParams().setParameter("http.socket.timeout", socketTimeOut);
+      method.setFollowRedirects(true);
+      int rval = client.executeMethod(method);
+      if (rval != 200)
+      {
+        String response = method.getResponseBodyAsString();
+        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,"Couldn't fetch user's access tokens from ManifoldCF authority service: "+Integer.toString(rval)+"; "+response);
+      }
+      InputStream is = method.getResponseBodyAsStream();
+      try
+      {
+        Reader r = new InputStreamReader(is,"utf-8");
+        try
+        {
+          BufferedReader br = new BufferedReader(r);
+          try
+          {
+            // Read the tokens, one line at a time.  If any authorities are down, we have no current way to note that, but someday we will.
+            List<String> tokenList = new ArrayList<String>();
+            while (true)
+            {
+              String line = br.readLine();
+              if (line == null)
+                break;
+              if (line.startsWith("TOKEN:"))
+              {
+                tokenList.add(line.substring("TOKEN:".length()));
+              }
+              else
+              {
+                // It probably says something about the state of the authority(s) involved, so log it
+                LOG.info("For user '"+authenticatedUserName+"', saw authority response "+line);
+              }
+            }
+            return tokenList;
+          }
+          finally
+          {
+            br.close();
+          }
+        }
+        finally
+        {
+          r.close();
+        }
+      }
+      finally
+      {
+        is.close();
+      }
+    }
+    finally
+    {
+      method.releaseConnection();
+    }
+  }
+  
+}
\ No newline at end of file

Property changes on: solr\contrib\mcf\src\java\org\apache\solr\mcf\ManifoldCFSecurityFilter.java
___________________________________________________________________
Added: svn:keywords
   + Id
Added: svn:eol-style
   + native

Index: solr/contrib/mcf/README.txt
===================================================================
--- solr/contrib/mcf/README.txt	(revision 0)
+++ solr/contrib/mcf/README.txt	(revision 1174245)
@@ -0,0 +1,31 @@
+Getting Started
+---------------
+To start using Solr ManifoldCFSecurityFilter, you first need ManifoldCF installed and running.  See:
+http://incubator.apache.org/incubator/connectors/how-to-build-and-deploy.html.
+
+Then, you will need to add fields to your Solr schema.xml file that can be used to contain document
+authorization information.  There will need to be four of these fields, an 'allow' field for both
+documents and shares, and a 'deny' field for both documents and shares.  For example:
+
+  <field name="allow_token_document" type="string" indexed="true" stored="false" multiValued="true" required="false"/>
+  <field name="allow_token_share" type="string" indexed="true" stored="false" multiValued="true" required="false"/>
+  <field name="deny_token_document" type="string" indexed="true" stored="false" multiValued="true" required="false"/>
+  <field name="deny_token_share" type="string" indexed="true" stored="false" multiValued="true" required="false"/>
+
+Next, modify your solrconfig.xml to add the search component:
+
+  <!-- ManifoldCF document security enforcement component -->
+  <searchComponent name="manifoldCFSecurity"
+    class="org.apache.solr.auth.ManifoldCFSecurityFilter">
+    <str name="AuthorityServiceBaseURL">http://localhost:8345/mcf-authority-service</str>
+  </searchComponent>
+
+Hook up the search component in the solrconfig.xml file wherever you want it, e.g.:
+
+<requestHandler name="search" class="solr.SearchHandler" default="true">
+  <arr name="last-components">
+    <str>manifoldCFSecurity</str>
+  </arr>
+  ...
+</requestHandler>
+

Property changes on: solr\contrib\mcf\README.txt
___________________________________________________________________
Added: svn:keywords
   + Id
Added: svn:eol-style
   + native

Index: solr/contrib/mcf/build.xml
===================================================================
--- solr/contrib/mcf/build.xml	(revision 0)
+++ solr/contrib/mcf/build.xml	(revision 1174245)
@@ -0,0 +1,43 @@
+<?xml version="1.0"?>
+
+<!--
+    Licensed to the Apache Software Foundation (ASF) under one or more
+    contributor license agreements.  See the NOTICE file distributed with
+    this work for additional information regarding copyright ownership.
+    The ASF licenses this file to You under the Apache License, Version 2.0
+    the "License"); you may not use this file except in compliance with
+    the License.  You may obtain a copy of the License at
+
+        http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
+ -->
+
+<project name="solr-mcf" default="default">
+
+  <description>
+    Solr Integration with ManifoldCF, for repository document authorization
+  </description>
+
+  <import file="../contrib-build.xml"/>
+
+  <path id="classpath">
+    <pathelement path="${queries.jar}"/>
+    <path refid="solr.base.classpath"/>
+  </path>
+
+  <target name="module-jars-to-solr" depends="jar-queries">
+    <mkdir dir="${build.dir}/lucene-libs"/>
+    <copy todir="${build.dir}/lucene-libs" preservelastmodified="true" flatten="true" failonerror="true" overwrite="true">
+      <fileset file="${queries.jar}"/>
+    </copy>
+  </target>
+
+  <target name="compile-core" depends="jar-queries, solr-contrib-build.compile-core"/>
+  <target name="dist" depends="module-jars-to-solr, common-solr.dist"/>
+
+</project>

Property changes on: solr\contrib\mcf\build.xml
___________________________________________________________________
Added: svn:keywords
   + Id
Added: svn:eol-style
   + native

