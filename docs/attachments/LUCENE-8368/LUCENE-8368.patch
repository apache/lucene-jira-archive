diff --git a/lucene/core/src/java/org/apache/lucene/geo/Polygon2D.java b/lucene/core/src/java/org/apache/lucene/geo/Polygon2D.java
index 699b874..00b8ded 100644
--- a/lucene/core/src/java/org/apache/lucene/geo/Polygon2D.java
+++ b/lucene/core/src/java/org/apache/lucene/geo/Polygon2D.java
@@ -67,7 +67,11 @@ public final class Polygon2D {
   /** root node of edge tree */
   private final Edge tree;
 
-  private Polygon2D(Polygon polygon, Polygon2D holes) {
+  /** polygon's ID */
+  private final int id;
+
+  private Polygon2D(int id, Polygon polygon, Polygon2D holes) {
+    this.id = id;
     this.holes = holes;
     this.minLat = polygon.minLat;
     this.maxLat = polygon.maxLat;
@@ -87,22 +91,34 @@ public final class Polygon2D {
    * https://www.ecse.rpi.edu/~wrf/Research/Short_Notes/pnpoly.html</a> for more information.
    */
   public boolean contains(double latitude, double longitude) {
+    return find(latitude, longitude) >= 0;
+  }
+
+  /**
+   * Returns the index of the polygon passed to {@link #create(Polygon...)} that
+   * contains this point, or {@code -1} if its not found.
+   * <p>
+   * @lucene.experimental
+   */
+  public int find(double latitude, double longitude) {
     if (latitude <= maxY && longitude <= maxX) {
       if (componentContains(latitude, longitude)) {
-        return true;
+        return id;
       }
       if (left != null) {
-        if (left.contains(latitude, longitude)) {
-          return true;
+        int leftID = left.find(latitude, longitude);
+        if (leftID >= 0) {
+          return leftID;
         }
       }
       if (right != null && ((splitX == false && latitude >= minLat) || (splitX && longitude >= minLon))) {
-        if (right.contains(latitude, longitude)) {
-          return true;
+        int rightID = right.find(latitude, longitude);
+        if (rightID >= 0) {
+          return rightID;
         }
       }
     }
-    return false;
+    return -1;
   }
   
   /** Returns true if the point is contained within this polygon component. */
@@ -262,7 +278,7 @@ public final class Polygon2D {
       if (gonHoles.length > 0) {
         holes = create(gonHoles);
       }
-      components[i] = new Polygon2D(gon, holes);
+      components[i] = new Polygon2D(i, gon, holes);
     }
     return createTree(components, 0, components.length - 1, false);
   }
diff --git a/lucene/core/src/test/org/apache/lucene/geo/TestPolygon2D.java b/lucene/core/src/test/org/apache/lucene/geo/TestPolygon2D.java
index 31a42c0..f93a56b 100644
--- a/lucene/core/src/test/org/apache/lucene/geo/TestPolygon2D.java
+++ b/lucene/core/src/test/org/apache/lucene/geo/TestPolygon2D.java
@@ -39,6 +39,12 @@ public class TestPolygon2D extends LuceneTestCase {
     assertTrue(polygon.contains(-25, 25)); // on the mainland
     assertFalse(polygon.contains(-51, 51)); // in the ocean
     
+    // find(point)
+    assertEquals(1, polygon.find(-2, 2));  // on the island
+    assertEquals(-1, polygon.find(-6, 6)); // in the hole
+    assertEquals(0, polygon.find(-25, 25)); // on the mainland
+    assertEquals(-1, polygon.find(-51, 51)); // in the ocean
+
     // relate(box): this can conservatively return CELL_CROSSES_QUERY
     assertEquals(Relation.CELL_INSIDE_QUERY, polygon.relate(-2, 2, -2, 2)); // on the island
     assertEquals(Relation.CELL_OUTSIDE_QUERY, polygon.relate(6, 7, 6, 7)); // in the hole
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/range/PolygonFacetBuilder.java b/lucene/facet/src/java/org/apache/lucene/facet/range/PolygonFacetBuilder.java
new file mode 100644
index 0000000..21179d7
--- /dev/null
+++ b/lucene/facet/src/java/org/apache/lucene/facet/range/PolygonFacetBuilder.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.facet.range;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.apache.lucene.facet.FacetsCollector;
+import org.apache.lucene.geo.Polygon;
+import org.apache.lucene.search.DocIdSet;
+import org.apache.lucene.search.LongValuesSource;
+import org.apache.lucene.search.Query;
+
+/**
+ * Facets a {@code LatLonDocValuesField} by polygon.
+ * <p>
+ * Add a number of (multi)polygons to it, associating each with a label, then call build()
+ * for a facets implementation. Behind the scenes, all the (multi)polygons are arranged
+ * into a datastructure that can bucket points reasonably efficiently.
+ * <p>
+ * This is slower than doing work to compute the labels at index time and indexing them as 
+ * strings, but allows for the set of polygons to be managed at query-time instead. 
+ * @lucene.experimental
+ */
+public class PolygonFacetBuilder {
+  private final ArrayList<Polygon> polygons = new ArrayList<>();
+  private final ArrayList<LongRange> ranges = new ArrayList<>();
+
+  /** Adds a (multi)polygon, associated with a label */
+  public PolygonFacetBuilder add(String label, Polygon... polygon) {
+    int rangeStart = polygons.size();
+    polygons.addAll(Arrays.asList(polygon));
+    int rangeEnd = polygons.size();
+    ranges.add(new LongRange(label, rangeStart, true, rangeEnd, false));
+    return this;
+  }
+
+  /** Builds a facet implementation for the field using the specified collector */
+  public LongRangeFacetCounts build(String field, FacetsCollector hits) throws IOException {
+    return build(field, hits, null);
+  }
+
+  /** 
+   * Builds a facet implementation for the field using the specified collector.
+   * The provided fastMatchQuery must be random access (implement {@link DocIdSet#bits})
+   */
+  public LongRangeFacetCounts build(String field, FacetsCollector hits, Query fastMatchQuery) throws IOException {
+    LongValuesSource source = new PolygonFacetSource(field, polygons.toArray(new Polygon[0]));
+    return new LongRangeFacetCounts(field, source, hits, fastMatchQuery, ranges.toArray(new LongRange[0]));
+  }
+}
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/range/PolygonFacetSource.java b/lucene/facet/src/java/org/apache/lucene/facet/range/PolygonFacetSource.java
new file mode 100644
index 0000000..cc535d6
--- /dev/null
+++ b/lucene/facet/src/java/org/apache/lucene/facet/range/PolygonFacetSource.java
@@ -0,0 +1,112 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.facet.range;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Objects;
+
+import org.apache.lucene.geo.GeoEncodingUtils;
+import org.apache.lucene.geo.Polygon;
+import org.apache.lucene.geo.Polygon2D;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.search.DoubleValues;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.LongValues;
+import org.apache.lucene.search.LongValuesSource;
+
+/** 
+ * ValueSource that returns the index into {@code polygons} that contains the point
+ */
+final class PolygonFacetSource extends LongValuesSource {
+  private final String field;
+  private final Polygon[] polygons;
+  private final LongValuesSource in;
+  private final Polygon2D tree;
+
+  PolygonFacetSource(String field, Polygon[] polygons) {
+    this.field = Objects.requireNonNull(field);
+    this.polygons = Objects.requireNonNull(polygons);
+    this.in = LongValuesSource.fromLongField(field);
+    this.tree = Polygon2D.create(polygons);
+  }
+
+  @Override
+  public boolean isCacheable(LeafReaderContext ctx) {
+    return in.isCacheable(ctx);
+  }
+
+  @Override
+  public LongValues getValues(LeafReaderContext ctx, DoubleValues scores) throws IOException {
+    LongValues raw = in.getValues(ctx, scores);
+    return new LongValues() {
+      @Override
+      public long longValue() throws IOException {
+        long bits = raw.longValue();
+        double latitude = GeoEncodingUtils.decodeLatitude((int)(bits >> 32));
+        double longitude = GeoEncodingUtils.decodeLongitude((int)(bits & 0xFFFFFFFF));
+        int polygonID = tree.find(latitude, longitude);
+        assert polygonID == -1 || polygonID < polygons.length;
+        return polygonID;
+      }
+
+      @Override
+      public boolean advanceExact(int doc) throws IOException {
+        return raw.advanceExact(doc);
+      }
+    };
+  }
+
+  @Override
+  public boolean needsScores() {
+    return false;
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + field.hashCode();
+    result = prime * result + Arrays.hashCode(polygons);
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) return true;
+    if (obj == null) return false;
+    if (getClass() != obj.getClass()) return false;
+    PolygonFacetSource other = (PolygonFacetSource) obj;
+    if (field != other.field) {
+      return false;
+    }
+    if (polygons != other.polygons) {
+      return false;
+    }
+    return true;
+  }
+
+  @Override
+  public String toString() {
+    return "polygonFacet(" + field + ")";
+  }
+
+  @Override
+  public LongValuesSource rewrite(IndexSearcher searcher) throws IOException {
+    return null;
+  }
+}
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java b/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java
index 8a7f913..7208442 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/range/TestRangeFacetCounts.java
@@ -16,6 +16,9 @@
  */
 package org.apache.lucene.facet.range;
 
+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLatitude;
+import static org.apache.lucene.geo.GeoEncodingUtils.encodeLongitude;
+
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.List;
@@ -41,6 +44,7 @@ import org.apache.lucene.facet.MultiFacets;
 import org.apache.lucene.facet.taxonomy.TaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyReader;
 import org.apache.lucene.facet.taxonomy.directory.DirectoryTaxonomyWriter;
+import org.apache.lucene.geo.Polygon;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.LeafReaderContext;
@@ -867,4 +871,61 @@ public class TestRangeFacetCounts extends FacetTestCase {
     writer.close();
     IOUtils.close(r, dir);
   }
+
+  private long encodeLatLon(double latitude, double longitude) {
+    int latitudeEncoded = encodeLatitude(latitude);
+    int longitudeEncoded = encodeLongitude(longitude);
+    return (((long)latitudeEncoded) << 32) | (longitudeEncoded & 0xFFFFFFFFL);
+  }
+
+  public void testBasicPolygons() throws Exception {
+    Directory d = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random(), d);
+    Document doc = new Document();
+    // simulate LatLonDocValues field since we can't use it...
+    NumericDocValuesField field = new NumericDocValuesField("field", 0L);
+    doc.add(field);
+
+    // country1 on the island
+    field.setLongValue(encodeLatLon(-2, 2));
+    w.addDocument(doc);
+    // country1 in the hole, but not the island (not a match)
+    field.setLongValue(encodeLatLon(-6, 6));
+    w.addDocument(doc);
+    // country1 on the mainland
+    field.setLongValue(encodeLatLon(-25, 25));
+    w.addDocument(doc);
+    // country1 in the ocean (not a match)
+    field.setLongValue(encodeLatLon(-51, 51));
+    w.addDocument(doc);
+
+    // country2 
+    field.setLongValue(encodeLatLon(-80, -10));
+    w.addDocument(doc);
+
+    IndexReader r = w.getReader();
+    w.close();
+
+    FacetsCollector fc = new FacetsCollector();
+    IndexSearcher s = newSearcher(r);
+    s.search(new MatchAllDocsQuery(), fc);
+
+    PolygonFacetBuilder builder = new PolygonFacetBuilder();
+    // "country1" multipolygon
+    Polygon hole = new Polygon(new double[] { -10, -10, 10, 10, -10 }, new double[] { -10, 10, 10, -10, -10 });
+    Polygon outer = new Polygon(new double[] { -50, -50, 50, 50, -50 }, new double[] { -50, 50, 50, -50, -50 }, hole);
+    Polygon island = new Polygon(new double[] { -5, -5, 5, 5, -5 }, new double[] { -5, 5, 5, -5, -5 } );
+    builder.add("country1", outer, island);
+
+    // "country2" simple polygon
+    Polygon country2 = new Polygon(new double[] { -90, -90, -70, -70, -90}, new double[] { -11, 7, 7, -11, -11 });
+    builder.add("country2", country2);
+
+    Facets facets = builder.build("field", fc);
+    FacetResult result = facets.getTopChildren(10, "field");
+    assertEquals("dim=field path=[] value=3 childCount=2\n  country1 (2)\n  country2 (1)\n",
+                 result.toString());
+    r.close();
+    d.close();
+  }
 }
