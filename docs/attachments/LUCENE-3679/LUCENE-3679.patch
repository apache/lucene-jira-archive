Index: solr/core/src/test/org/apache/solr/search/TestDocSet.java
===================================================================
--- solr/core/src/test/org/apache/solr/search/TestDocSet.java	(revision 1228924)
+++ solr/core/src/test/org/apache/solr/search/TestDocSet.java	(working copy)
@@ -17,19 +17,20 @@
 
 package org.apache.solr.search;
 
+import java.io.IOException;
+import java.util.Arrays;
 import java.util.Random;
-import java.util.Arrays;
-import java.io.IOException;
 
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.OpenBitSet;
-import org.apache.lucene.util.OpenBitSetIterator;
+import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.FilterIndexReader;
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.FilterIndexReader;
 import org.apache.lucene.index.MultiReader;
-import org.apache.lucene.search.Filter;
 import org.apache.lucene.search.DocIdSet;
 import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.Filter;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.OpenBitSet;
+import org.apache.lucene.util.OpenBitSetIterator;
 
 /**
  * @version $Id$
@@ -350,6 +351,11 @@
       public IndexReader[] getSequentialSubReaders() {
         return null;
       }
+
+      @Override
+      public FieldInfos getFieldInfos() {
+        return new FieldInfos();
+      }
     };
     return r;
   }
Index: solr/core/src/java/org/apache/solr/search/SolrIndexReader.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/SolrIndexReader.java	(revision 1228924)
+++ solr/core/src/java/org/apache/solr/search/SolrIndexReader.java	(working copy)
@@ -18,17 +18,16 @@
 package org.apache.solr.search;
 
 
-import org.apache.lucene.index.*;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.LockObtainFailedException;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.FieldSelector;
-
 import java.io.IOException;
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.FieldSelector;
+import org.apache.lucene.index.*;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.ReaderUtil;
+
 /** Solr wrapper for IndexReader that contains extra context.
  * This is currently experimental, for internal use only, and subject to change.
  */
@@ -340,8 +339,8 @@
   }
 
   @Override
-  public Collection getFieldNames(IndexReader.FieldOption fieldNames) {
-    return in.getFieldNames(fieldNames);
+  public FieldInfos getFieldInfos() {
+    return ReaderUtil.getMergedFieldInfos(in);
   }
 
   @Override
Index: solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java	(revision 1228924)
+++ solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java	(working copy)
@@ -17,7 +17,13 @@
 
 package org.apache.solr.search;
 
+import java.io.IOException;
+import java.net.URL;
+import java.util.*;
+import java.util.concurrent.atomic.AtomicLong;
+
 import org.apache.lucene.document.*;
+import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermDocs;
@@ -25,20 +31,16 @@
 import org.apache.lucene.search.*;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.FSDirectory;
+import org.apache.lucene.util.OpenBitSet;
+import org.apache.lucene.util.ReaderUtil;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
 import org.apache.solr.core.SolrConfig;
 import org.apache.solr.core.SolrCore;
 import org.apache.solr.core.SolrInfoMBean;
+import org.apache.solr.request.UnInvertedField;
 import org.apache.solr.schema.IndexSchema;
 import org.apache.solr.schema.SchemaField;
-import org.apache.solr.request.UnInvertedField;
-import org.apache.lucene.util.OpenBitSet;
-
-import java.io.IOException;
-import java.net.URL;
-import java.util.*;
-import java.util.concurrent.atomic.AtomicLong;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -196,7 +198,10 @@
     }
     optimizer = solrConfig.filtOptEnabled ? new LuceneQueryOptimizer(solrConfig.filtOptCacheSize,solrConfig.filtOptThreshold) : null;
 
-    fieldNames = r.getFieldNames(IndexReader.FieldOption.ALL);
+    fieldNames = new HashSet<String>();
+    for(FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(r)) {
+      fieldNames.add(fieldInfo.name);
+    }
 
     // do this at the end since an exception in the constructor means we won't close    
     numOpens.incrementAndGet();
Index: solr/core/src/java/org/apache/solr/tst/TestRequestHandler.java
===================================================================
--- solr/core/src/java/org/apache/solr/tst/TestRequestHandler.java	(revision 1228924)
+++ solr/core/src/java/org/apache/solr/tst/TestRequestHandler.java	(working copy)
@@ -17,26 +17,25 @@
 
 package org.apache.solr.tst;
 
-import org.apache.lucene.search.*;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexReader;
-
+import java.net.URL;
 import java.util.*;
 import java.util.regex.Pattern;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-import java.net.URL;
 
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.search.*;
 import org.apache.lucene.util.OpenBitSet;
-import org.apache.solr.search.*;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.StrUtils;
 import org.apache.solr.core.SolrCore;
+import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.request.SolrRequestHandler;
-import org.apache.solr.request.SolrQueryRequest;
 import org.apache.solr.response.SolrQueryResponse;
+import org.apache.solr.search.*;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 /**
  * @version $Id$
@@ -156,10 +155,19 @@
         rsp.add("myNamedList", nl);
       } else if (qs.startsWith("fields")) {
         NamedList nl = new NamedList();
-        Collection flst;
-        flst = searcher.getReader().getFieldNames(IndexReader.FieldOption.INDEXED);
+        Collection<String> flst = new HashSet<String>();
+        for(FieldInfo fieldInfo : searcher.getReader().getFieldInfos()) {
+          if (fieldInfo.isIndexed) {
+            flst.add(fieldInfo.name);
+          }
+        }
         nl.add("indexed",flst);
-        flst = searcher.getReader().getFieldNames(IndexReader.FieldOption.UNINDEXED);
+        flst = new HashSet<String>();
+        for(FieldInfo fieldInfo : searcher.getReader().getFieldInfos()) {
+          if (!fieldInfo.isIndexed) {
+            flst.add(fieldInfo.name);
+          }
+        }
         nl.add("unindexed",flst);
         rsp.add("fields", nl);
       }
Index: solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java
===================================================================
--- solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java	(revision 1228924)
+++ solr/core/src/java/org/apache/solr/handler/admin/LukeRequestHandler.java	(working copy)
@@ -292,10 +292,14 @@
 
     IndexReader reader = searcher.getReader();
     IndexSchema schema = searcher.getSchema();
-    
+
+    Set<String> fieldNames = new TreeSet<String>();
+    for(FieldInfo fieldInfo : reader.getFieldInfos()) {
+      fieldNames.add(fieldInfo.name);
+    }
+
     // Walk the term enum and keep a priority queue for each map in our set
     SimpleOrderedMap<Object> finfo = new SimpleOrderedMap<Object>();
-    Set<String> fieldNames = new TreeSet<String>(reader.getFieldNames(IndexReader.FieldOption.ALL));
     for (String fieldName : fieldNames) {
       if( fields != null && !fields.contains( fieldName ) ) {
         continue; // if a field is specified, only them
Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 1228924)
+++ lucene/CHANGES.txt	(working copy)
@@ -37,6 +37,11 @@
   contrib/queryparser. If you have used those classes in your code
   just add the lucene-queryparser.jar file to your classpath.
   (Uwe Schindler)
+
+* LUCENE-3679: The expert IndexReader.getFieldNames(FieldOption) API
+  has been removed and replaced with the experimental getFieldInfos
+  API.  All IndexReader subclasses must implement getFieldInfos.
+  (Mike McCandless)
   
 Security fixes
 
Index: lucene/src/test/org/apache/lucene/index/TestDocumentWriter.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestDocumentWriter.java	(revision 1228924)
+++ lucene/src/test/org/apache/lucene/index/TestDocumentWriter.java	(working copy)
@@ -321,7 +321,7 @@
     _TestUtil.checkIndex(dir);
 
     SegmentReader reader = SegmentReader.getOnlySegmentReader(dir);
-    FieldInfos fi = reader.fieldInfos();
+    FieldInfos fi = reader.getFieldInfos();
     // f1
     assertFalse("f1 should have no norms", reader.hasNorms("f1"));
     assertEquals("omitTermFreqAndPositions field bit should not be set for f1", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo("f1").indexOptions);
Index: lucene/src/test/org/apache/lucene/index/TestOmitTf.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestOmitTf.java	(revision 1228924)
+++ lucene/src/test/org/apache/lucene/index/TestOmitTf.java	(working copy)
@@ -92,7 +92,7 @@
     writer.close();
 
     SegmentReader reader = SegmentReader.getOnlySegmentReader(ram);
-    FieldInfos fi = reader.fieldInfos();
+    FieldInfos fi = reader.getFieldInfos();
     assertEquals("OmitTermFreqAndPositions field bit should be set.", IndexOptions.DOCS_ONLY, fi.fieldInfo("f1").indexOptions);
     assertEquals("OmitTermFreqAndPositions field bit should be set.", IndexOptions.DOCS_ONLY, fi.fieldInfo("f2").indexOptions);
         
@@ -146,7 +146,7 @@
     writer.close();
 
     SegmentReader reader = SegmentReader.getOnlySegmentReader(ram);
-    FieldInfos fi = reader.fieldInfos();
+    FieldInfos fi = reader.getFieldInfos();
     assertEquals("OmitTermFreqAndPositions field bit should be set.", IndexOptions.DOCS_ONLY, fi.fieldInfo("f1").indexOptions);
     assertEquals("OmitTermFreqAndPositions field bit should be set.", IndexOptions.DOCS_ONLY, fi.fieldInfo("f2").indexOptions);
         
@@ -191,7 +191,7 @@
     writer.close();
 
     SegmentReader reader = SegmentReader.getOnlySegmentReader(ram);
-    FieldInfos fi = reader.fieldInfos();
+    FieldInfos fi = reader.getFieldInfos();
     assertEquals("OmitTermFreqAndPositions field bit should not be set.", IndexOptions.DOCS_AND_FREQS_AND_POSITIONS, fi.fieldInfo("f1").indexOptions);
     assertEquals("OmitTermFreqAndPositions field bit should be set.", IndexOptions.DOCS_ONLY, fi.fieldInfo("f2").indexOptions);
         
Index: lucene/src/test/org/apache/lucene/index/TestOmitPositions.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestOmitPositions.java	(revision 1228924)
+++ lucene/src/test/org/apache/lucene/index/TestOmitPositions.java	(working copy)
@@ -162,7 +162,7 @@
     writer.close();
 
     SegmentReader reader = SegmentReader.getOnlySegmentReader(ram);
-    FieldInfos fi = reader.fieldInfos();
+    FieldInfos fi = reader.getFieldInfos();
     // docs + docs = docs
     assertEquals(IndexOptions.DOCS_ONLY, fi.fieldInfo("f1").indexOptions);
     // docs + docs/freqs = docs
Index: lucene/src/test/org/apache/lucene/index/TestSegmentMerger.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestSegmentMerger.java	(revision 1228924)
+++ lucene/src/test/org/apache/lucene/index/TestSegmentMerger.java	(working copy)
@@ -28,7 +28,6 @@
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 
 import java.io.IOException;
-import java.util.Collection;
 
 public class TestSegmentMerger extends LuceneTestCase {
   //The variables for the new merged segment
@@ -102,10 +101,15 @@
     assertTrue(termDocs != null);
     assertTrue(termDocs.next() == true);
     
-    Collection<String> stored = mergedReader.getFieldNames(IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR);
-    assertTrue(stored != null);
+    int tvCount = 0;
+    for(FieldInfo fieldInfo : mergedReader.getFieldInfos()) {
+      if (fieldInfo.storeTermVector) {
+        tvCount++;
+      }
+    }
+    
     //System.out.println("stored size: " + stored.size());
-    assertTrue("We do not have 3 fields that were indexed with term vector",stored.size() == 3);
+    assertEquals("We do not have 3 fields that were indexed with term vector", 3, tvCount);
     
     TermFreqVector vector = mergedReader.getTermFreqVector(0, DocHelper.TEXT_FIELD_2_KEY);
     assertTrue(vector != null);
Index: lucene/src/test/org/apache/lucene/index/TestPayloads.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestPayloads.java	(revision 1228924)
+++ lucene/src/test/org/apache/lucene/index/TestPayloads.java	(working copy)
@@ -115,7 +115,7 @@
         writer.close();        
         
         SegmentReader reader = SegmentReader.getOnlySegmentReader(ram);
-        FieldInfos fi = reader.fieldInfos();
+        FieldInfos fi = reader.getFieldInfos();
         assertFalse("Payload field bit should not be set.", fi.fieldInfo("f1").storePayloads);
         assertTrue("Payload field bit should be set.", fi.fieldInfo("f2").storePayloads);
         assertFalse("Payload field bit should not be set.", fi.fieldInfo("f3").storePayloads);
@@ -140,7 +140,7 @@
         writer.close();
 
         reader = SegmentReader.getOnlySegmentReader(ram);
-        fi = reader.fieldInfos();
+        fi = reader.getFieldInfos();
         assertFalse("Payload field bit should not be set.", fi.fieldInfo("f1").storePayloads);
         assertTrue("Payload field bit should be set.", fi.fieldInfo("f2").storePayloads);
         assertTrue("Payload field bit should be set.", fi.fieldInfo("f3").storePayloads);
Index: lucene/src/test/org/apache/lucene/index/TestIndexReader.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestIndexReader.java	(revision 1228924)
+++ lucene/src/test/org/apache/lucene/index/TestIndexReader.java	(working copy)
@@ -38,7 +38,6 @@
 import org.apache.lucene.document.FieldSelector;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.document.SetBasedFieldSelector;
-import org.apache.lucene.index.IndexReader.FieldOption;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.search.FieldCache;
 import org.apache.lucene.store.AlreadyClosedException;
@@ -47,6 +46,7 @@
 import org.apache.lucene.store.LockReleaseFailedException;
 import org.apache.lucene.store.NoSuchDirectoryException;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util._TestUtil;
 
 public class TestIndexReader extends LuceneTestCase {
@@ -153,11 +153,11 @@
         writer.close();
         // set up reader
         IndexReader reader = IndexReader.open(d, false);
-        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);
-        assertTrue(fieldNames.contains("keyword"));
-        assertTrue(fieldNames.contains("text"));
-        assertTrue(fieldNames.contains("unindexed"));
-        assertTrue(fieldNames.contains("unstored"));
+        FieldInfos fieldInfos = ReaderUtil.getMergedFieldInfos(reader);
+        assertNotNull(fieldInfos.fieldInfo("keyword"));
+        assertNotNull(fieldInfos.fieldInfo("text"));
+        assertNotNull(fieldInfos.fieldInfo("unindexed"));
+        assertNotNull(fieldInfos.fieldInfo("unstored"));
         reader.close();
         // add more documents
         writer = new IndexWriter(
@@ -197,61 +197,66 @@
         }
         
         writer.close();
+
         // verify fields again
         reader = IndexReader.open(d, false);
-        fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);
-        assertEquals(13, fieldNames.size());    // the following fields
-        assertTrue(fieldNames.contains("keyword"));
-        assertTrue(fieldNames.contains("text"));
-        assertTrue(fieldNames.contains("unindexed"));
-        assertTrue(fieldNames.contains("unstored"));
-        assertTrue(fieldNames.contains("keyword2"));
-        assertTrue(fieldNames.contains("text2"));
-        assertTrue(fieldNames.contains("unindexed2"));
-        assertTrue(fieldNames.contains("unstored2"));
-        assertTrue(fieldNames.contains("tvnot"));
-        assertTrue(fieldNames.contains("termvector"));
-        assertTrue(fieldNames.contains("tvposition"));
-        assertTrue(fieldNames.contains("tvoffset"));
-        assertTrue(fieldNames.contains("tvpositionoffset"));
+        fieldInfos = ReaderUtil.getMergedFieldInfos(reader);
+
+        Collection<String> allFieldNames = new HashSet<String>();
+        Collection<String> indexedFieldNames = new HashSet<String>();
+        Collection<String> notIndexedFieldNames = new HashSet<String>();
+        Collection<String> tvFieldNames = new HashSet<String>();
+
+        for(FieldInfo fieldInfo : fieldInfos) {
+          final String name = fieldInfo.name;
+          allFieldNames.add(name);
+          if (fieldInfo.isIndexed) {
+            indexedFieldNames.add(name);
+          } else {
+            notIndexedFieldNames.add(name);
+          }
+          if (fieldInfo.storeTermVector) {
+            tvFieldNames.add(name);
+          }
+        }
+
+        assertTrue(allFieldNames.contains("keyword"));
+        assertTrue(allFieldNames.contains("text"));
+        assertTrue(allFieldNames.contains("unindexed"));
+        assertTrue(allFieldNames.contains("unstored"));
+        assertTrue(allFieldNames.contains("keyword2"));
+        assertTrue(allFieldNames.contains("text2"));
+        assertTrue(allFieldNames.contains("unindexed2"));
+        assertTrue(allFieldNames.contains("unstored2"));
+        assertTrue(allFieldNames.contains("tvnot"));
+        assertTrue(allFieldNames.contains("termvector"));
+        assertTrue(allFieldNames.contains("tvposition"));
+        assertTrue(allFieldNames.contains("tvoffset"));
+        assertTrue(allFieldNames.contains("tvpositionoffset"));
         
         // verify that only indexed fields were returned
-        fieldNames = reader.getFieldNames(IndexReader.FieldOption.INDEXED);
-        assertEquals(11, fieldNames.size());    // 6 original + the 5 termvector fields 
-        assertTrue(fieldNames.contains("keyword"));
-        assertTrue(fieldNames.contains("text"));
-        assertTrue(fieldNames.contains("unstored"));
-        assertTrue(fieldNames.contains("keyword2"));
-        assertTrue(fieldNames.contains("text2"));
-        assertTrue(fieldNames.contains("unstored2"));
-        assertTrue(fieldNames.contains("tvnot"));
-        assertTrue(fieldNames.contains("termvector"));
-        assertTrue(fieldNames.contains("tvposition"));
-        assertTrue(fieldNames.contains("tvoffset"));
-        assertTrue(fieldNames.contains("tvpositionoffset"));
+        assertEquals(11, indexedFieldNames.size());    // 6 original + the 5 termvector fields 
+        assertTrue(indexedFieldNames.contains("keyword"));
+        assertTrue(indexedFieldNames.contains("text"));
+        assertTrue(indexedFieldNames.contains("unstored"));
+        assertTrue(indexedFieldNames.contains("keyword2"));
+        assertTrue(indexedFieldNames.contains("text2"));
+        assertTrue(indexedFieldNames.contains("unstored2"));
+        assertTrue(indexedFieldNames.contains("tvnot"));
+        assertTrue(indexedFieldNames.contains("termvector"));
+        assertTrue(indexedFieldNames.contains("tvposition"));
+        assertTrue(indexedFieldNames.contains("tvoffset"));
+        assertTrue(indexedFieldNames.contains("tvpositionoffset"));
         
         // verify that only unindexed fields were returned
-        fieldNames = reader.getFieldNames(IndexReader.FieldOption.UNINDEXED);
-        assertEquals(2, fieldNames.size());    // the following fields
-        assertTrue(fieldNames.contains("unindexed"));
-        assertTrue(fieldNames.contains("unindexed2"));
+        assertEquals(2, notIndexedFieldNames.size());    // the following fields
+        assertTrue(notIndexedFieldNames.contains("unindexed"));
+        assertTrue(notIndexedFieldNames.contains("unindexed2"));
                 
         // verify index term vector fields  
-        fieldNames = reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR);
-        assertEquals(1, fieldNames.size());    // 1 field has term vector only
-        assertTrue(fieldNames.contains("termvector"));
-        
-        fieldNames = reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION);
-        assertEquals(1, fieldNames.size());    // 4 fields are indexed with term vectors
-        assertTrue(fieldNames.contains("tvposition"));
-        
-        fieldNames = reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET);
-        assertEquals(1, fieldNames.size());    // 4 fields are indexed with term vectors
-        assertTrue(fieldNames.contains("tvoffset"));
-                
-        fieldNames = reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET);
-        assertEquals(1, fieldNames.size());    // 4 fields are indexed with term vectors
-        assertTrue(fieldNames.contains("tvpositionoffset"));
+        assertEquals(tvFieldNames.toString(), 4, tvFieldNames.size());    // 4 field has term vector only
+        assertTrue(tvFieldNames.contains("termvector"));
+
         reader.close();
         d.close();
     }
@@ -826,19 +831,19 @@
       }
       
       // check field names
-      Collection<String> fields1 = index1.getFieldNames(FieldOption.ALL);
-      Collection<String> fields2 = index1.getFieldNames(FieldOption.ALL);
-      assertEquals("IndexReaders have different numbers of fields.", fields1.size(), fields2.size());
-      Iterator<String> it1 = fields1.iterator();
-      Iterator<String> it2 = fields1.iterator();
-      while (it1.hasNext()) {
-        assertEquals("Different field names.", it1.next(), it2.next());
+      FieldInfos fieldInfos1 = ReaderUtil.getMergedFieldInfos(index1);
+      FieldInfos fieldInfos2 = ReaderUtil.getMergedFieldInfos(index2);
+      assertEquals("IndexReaders have different numbers of fields.", fieldInfos1.size(), fieldInfos2.size());
+      final int numFields = fieldInfos1.size();
+      for(int fieldID=0;fieldID<numFields;fieldID++) {
+        final FieldInfo fieldInfo1 = fieldInfos1.fieldInfo(fieldID);
+        final FieldInfo fieldInfo2 = fieldInfos2.fieldInfo(fieldID);
+        assertEquals("Different field names.", fieldInfo1.name, fieldInfo2.name);
       }
       
       // check norms
-      it1 = fields1.iterator();
-      while (it1.hasNext()) {
-        String curField = it1.next();
+      for(FieldInfo fieldInfo : fieldInfos1) {
+        String curField = fieldInfo.name;
         byte[] norms1 = index1.norms(curField);
         byte[] norms2 = index2.norms(curField);
         if (norms1 != null && norms2 != null)
Index: lucene/src/test/org/apache/lucene/index/TestFieldsReader.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestFieldsReader.java	(revision 1228924)
+++ lucene/src/test/org/apache/lucene/index/TestFieldsReader.java	(working copy)
@@ -92,24 +92,18 @@
     assertTrue(field != null);
     assertTrue(field.isTermVectorStored() == true);
 
-    assertTrue(field.isStoreOffsetWithTermVector() == true);
-    assertTrue(field.isStorePositionWithTermVector() == true);
     assertTrue(field.getOmitNorms() == false);
     assertTrue(field.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
 
     field = doc.getField(DocHelper.TEXT_FIELD_3_KEY);
     assertTrue(field != null);
     assertTrue(field.isTermVectorStored() == false);
-    assertTrue(field.isStoreOffsetWithTermVector() == false);
-    assertTrue(field.isStorePositionWithTermVector() == false);
     assertTrue(field.getOmitNorms() == true);
     assertTrue(field.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
 
     field = doc.getField(DocHelper.NO_TF_KEY);
     assertTrue(field != null);
     assertTrue(field.isTermVectorStored() == false);
-    assertTrue(field.isStoreOffsetWithTermVector() == false);
-    assertTrue(field.isStorePositionWithTermVector() == false);
     assertTrue(field.getOmitNorms() == false);
     assertTrue(field.getIndexOptions() == IndexOptions.DOCS_ONLY);
     reader.close();
Index: lucene/src/test/org/apache/lucene/index/TestParallelReader.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestParallelReader.java	(revision 1228924)
+++ lucene/src/test/org/apache/lucene/index/TestParallelReader.java	(working copy)
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.Random;
 
 import org.apache.lucene.analysis.MockAnalyzer;
@@ -82,12 +81,12 @@
     ParallelReader pr = new ParallelReader();
     pr.add(IndexReader.open(dir1, false));
     pr.add(IndexReader.open(dir2, false));
-    Collection<String> fieldNames = pr.getFieldNames(IndexReader.FieldOption.ALL);
-    assertEquals(4, fieldNames.size());
-    assertTrue(fieldNames.contains("f1"));
-    assertTrue(fieldNames.contains("f2"));
-    assertTrue(fieldNames.contains("f3"));
-    assertTrue(fieldNames.contains("f4"));
+    FieldInfos fieldInfos = pr.getFieldInfos();
+    assertEquals(4, fieldInfos.size());
+    assertNotNull(fieldInfos.fieldInfo("f1"));
+    assertNotNull(fieldInfos.fieldInfo("f2"));
+    assertNotNull(fieldInfos.fieldInfo("f3"));
+    assertNotNull(fieldInfos.fieldInfo("f4"));
     pr.close();
     dir1.close();
     dir2.close();
Index: lucene/src/test/org/apache/lucene/index/TestSegmentReader.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestSegmentReader.java	(revision 1228924)
+++ lucene/src/test/org/apache/lucene/index/TestSegmentReader.java	(working copy)
@@ -19,15 +19,14 @@
 
 import java.io.IOException;
 import java.util.Collection;
-import java.util.Iterator;
+import java.util.HashSet;
 import java.util.List;
 
-import org.apache.lucene.util.LuceneTestCase;
-
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.search.Similarity;
 import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
 
 public class TestSegmentReader extends LuceneTestCase {
   private Directory dir;
@@ -88,33 +87,42 @@
   }    
   
   public void testGetFieldNameVariations() {
-    Collection<String> result = reader.getFieldNames(IndexReader.FieldOption.ALL);
-    assertTrue(result != null);
-    assertTrue(result.size() == DocHelper.all.size());
-    for (Iterator<String> iter = result.iterator(); iter.hasNext();) {
-      String s =  iter.next();
-      //System.out.println("Name: " + s);
+    Collection<String> allFieldNames = new HashSet<String>();
+    Collection<String> indexedFieldNames = new HashSet<String>();
+    Collection<String> notIndexedFieldNames = new HashSet<String>();
+    Collection<String> tvFieldNames = new HashSet<String>();
+    Collection<String> noTVFieldNames = new HashSet<String>();
+
+    for(FieldInfo fieldInfo : reader.getFieldInfos()) {
+      final String name = fieldInfo.name;
+      allFieldNames.add(name);
+      if (fieldInfo.isIndexed) {
+        indexedFieldNames.add(name);
+      } else {
+        notIndexedFieldNames.add(name);
+      }
+      if (fieldInfo.storeTermVector) {
+        tvFieldNames.add(name);
+      } else if (fieldInfo.isIndexed) {
+        noTVFieldNames.add(name);
+      }
+    }
+
+    assertTrue(allFieldNames.size() == DocHelper.all.size());
+    for (String s : allFieldNames) {
       assertTrue(DocHelper.nameValues.containsKey(s) == true || s.equals(""));
     }                                                                               
-    result = reader.getFieldNames(IndexReader.FieldOption.INDEXED);
-    assertTrue(result != null);
-    assertTrue(result.size() == DocHelper.indexed.size());
-    for (Iterator<String> iter = result.iterator(); iter.hasNext();) {
-      String s = iter.next();
+
+    assertTrue(indexedFieldNames.size() == DocHelper.indexed.size());
+    for (String s : indexedFieldNames) {
       assertTrue(DocHelper.indexed.containsKey(s) == true || s.equals(""));
     }
     
-    result = reader.getFieldNames(IndexReader.FieldOption.UNINDEXED);
-    assertTrue(result != null);
-    assertTrue(result.size() == DocHelper.unindexed.size());
+    assertTrue(notIndexedFieldNames.size() == DocHelper.unindexed.size());
     //Get all indexed fields that are storing term vectors
-    result = reader.getFieldNames(IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR);
-    assertTrue(result != null);
-    assertTrue(result.size() == DocHelper.termvector.size());
-    
-    result = reader.getFieldNames(IndexReader.FieldOption.INDEXED_NO_TERMVECTOR);
-    assertTrue(result != null);
-    assertTrue(result.size() == DocHelper.notermvector.size());
+    assertTrue(tvFieldNames.size() == DocHelper.termvector.size());
+
+    assertTrue(noTVFieldNames.size() == DocHelper.notermvector.size());
   } 
   
   public void testTerms() throws IOException {
Index: lucene/src/java/org/apache/lucene/index/FieldInfos.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/FieldInfos.java	(revision 1228924)
+++ lucene/src/java/org/apache/lucene/index/FieldInfos.java	(working copy)
@@ -33,8 +33,10 @@
  *  of this class are thread-safe for multiple readers, but only one thread can
  *  be adding documents at a time, with no other reader or writer threads
  *  accessing this object.
+ *
+ * @lucene.experimental
  */
-final class FieldInfos {
+public final class FieldInfos implements Iterable<FieldInfo> {
 
   // Used internally (ie not written to *.fnm files) for pre-2.9 files
   public static final int FORMAT_PRE = -1;
@@ -50,8 +52,6 @@
   
   static final byte IS_INDEXED = 0x1;
   static final byte STORE_TERMVECTOR = 0x2;
-  static final byte STORE_POSITIONS_WITH_TERMVECTOR = 0x4;
-  static final byte STORE_OFFSET_WITH_TERMVECTOR = 0x8;
   static final byte OMIT_NORMS = 0x10;
   static final byte STORE_PAYLOADS = 0x20;
   static final byte OMIT_TERM_FREQ_AND_POSITIONS = 0x40;
@@ -61,7 +61,7 @@
   private final HashMap<String,FieldInfo> byName = new HashMap<String,FieldInfo>();
   private int format;
 
-  FieldInfos() { }
+  public FieldInfos() { }
 
   /**
    * Construct a FieldInfos object using the directory and the name of the file
@@ -70,7 +70,7 @@
    * @param name The name of the file to open the IndexInput from in the Directory
    * @throws IOException
    */
-  FieldInfos(Directory d, String name) throws IOException {
+  public FieldInfos(Directory d, String name) throws IOException {
     IndexInput input = d.openInput(name);
     try {
       try {
@@ -101,6 +101,12 @@
     }
   }
 
+  public void add(FieldInfos other) {
+    for(FieldInfo fieldInfo : other){ 
+      add(fieldInfo);
+    }
+  }
+
   /**
    * Returns a deep clone of this FieldInfos instance.
    */
@@ -120,13 +126,13 @@
   synchronized public void add(Document doc) {
     List<Fieldable> fields = doc.getFields();
     for (Fieldable field : fields) {
-      add(field.name(), field.isIndexed(), field.isTermVectorStored(), field.isStorePositionWithTermVector(),
-              field.isStoreOffsetWithTermVector(), field.getOmitNorms(), false, field.getIndexOptions());
+      add(field.name(), field.isIndexed(), field.isTermVectorStored(),
+          field.getOmitNorms(), false, field.getIndexOptions());
     }
   }
 
   /** Returns true if any fields do not omitTermFreqAndPositions */
-  boolean hasProx() {
+  public boolean hasProx() {
     final int numFields = byNumber.size();
     for(int i=0;i<numFields;i++) {
       final FieldInfo fi = fieldInfo(i);
@@ -138,43 +144,14 @@
   }
   
   /**
-   * Add fields that are indexed. Whether they have termvectors has to be specified.
-   * 
-   * @param names The names of the fields
-   * @param storeTermVectors Whether the fields store term vectors or not
-   * @param storePositionWithTermVector true if positions should be stored.
-   * @param storeOffsetWithTermVector true if offsets should be stored
-   */
-  synchronized public void addIndexed(Collection<String> names, boolean storeTermVectors, boolean storePositionWithTermVector, 
-                         boolean storeOffsetWithTermVector) {
-    for (String name : names) {
-      add(name, true, storeTermVectors, storePositionWithTermVector, storeOffsetWithTermVector);
-    }
-  }
-
-  /**
-   * Assumes the fields are not storing term vectors.
-   * 
-   * @param names The names of the fields
-   * @param isIndexed Whether the fields are indexed or not
-   * 
-   * @see #add(String, boolean)
-   */
-  synchronized public void add(Collection<String> names, boolean isIndexed) {
-    for (String name : names) {
-      add(name, isIndexed);
-    }
-  }
-
-  /**
    * Calls 5 parameter add with false for all TermVector parameters.
    * 
    * @param name The name of the Fieldable
    * @param isIndexed true if the field is indexed
-   * @see #add(String, boolean, boolean, boolean, boolean)
+   * @see #add(String, boolean, boolean)
    */
   synchronized public void add(String name, boolean isIndexed) {
-    add(name, isIndexed, false, false, false, false);
+    add(name, isIndexed, false, false);
   }
 
   /**
@@ -185,42 +162,23 @@
    * @param storeTermVector true if the term vector should be stored
    */
   synchronized public void add(String name, boolean isIndexed, boolean storeTermVector){
-    add(name, isIndexed, storeTermVector, false, false, false);
+    add(name, isIndexed, storeTermVector, false);
   }
   
   /** If the field is not yet known, adds it. If it is known, checks to make
    *  sure that the isIndexed flag is the same as was given previously for this
    *  field. If not - marks it as being indexed.  Same goes for the TermVector
    * parameters.
-   * 
-   * @param name The name of the field
-   * @param isIndexed true if the field is indexed
-   * @param storeTermVector true if the term vector should be stored
-   * @param storePositionWithTermVector true if the term vector with positions should be stored
-   * @param storeOffsetWithTermVector true if the term vector with offsets should be stored
-   */
-  synchronized public void add(String name, boolean isIndexed, boolean storeTermVector,
-                  boolean storePositionWithTermVector, boolean storeOffsetWithTermVector) {
-
-    add(name, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, false);
-  }
-
-    /** If the field is not yet known, adds it. If it is known, checks to make
-   *  sure that the isIndexed flag is the same as was given previously for this
-   *  field. If not - marks it as being indexed.  Same goes for the TermVector
-   * parameters.
    *
    * @param name The name of the field
    * @param isIndexed true if the field is indexed
    * @param storeTermVector true if the term vector should be stored
-   * @param storePositionWithTermVector true if the term vector with positions should be stored
-   * @param storeOffsetWithTermVector true if the term vector with offsets should be stored
    * @param omitNorms true if the norms for the indexed field should be omitted
    */
   synchronized public void add(String name, boolean isIndexed, boolean storeTermVector,
-                  boolean storePositionWithTermVector, boolean storeOffsetWithTermVector, boolean omitNorms) {
-    add(name, isIndexed, storeTermVector, storePositionWithTermVector,
-        storeOffsetWithTermVector, omitNorms, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
+                               boolean omitNorms) {
+    add(name, isIndexed, storeTermVector,
+        omitNorms, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
   }
   
   /** If the field is not yet known, adds it. If it is known, checks to make
@@ -231,20 +189,17 @@
    * @param name The name of the field
    * @param isIndexed true if the field is indexed
    * @param storeTermVector true if the term vector should be stored
-   * @param storePositionWithTermVector true if the term vector with positions should be stored
-   * @param storeOffsetWithTermVector true if the term vector with offsets should be stored
    * @param omitNorms true if the norms for the indexed field should be omitted
    * @param storePayloads true if payloads should be stored for this field
    * @param indexOptions if term freqs should be omitted for this field
    */
   synchronized public FieldInfo add(String name, boolean isIndexed, boolean storeTermVector,
-                       boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,
                        boolean omitNorms, boolean storePayloads, IndexOptions indexOptions) {
     FieldInfo fi = fieldInfo(name);
     if (fi == null) {
-      return addInternal(name, isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, indexOptions);
+      return addInternal(name, isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);
     } else {
-      fi.update(isIndexed, storeTermVector, storePositionWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, indexOptions);
+      fi.update(isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);
     }
     assert fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS || !fi.storePayloads;
     return fi;
@@ -252,17 +207,15 @@
 
   synchronized public FieldInfo add(FieldInfo fi) {
     return add(fi.name, fi.isIndexed, fi.storeTermVector,
-               fi.storePositionWithTermVector, fi.storeOffsetWithTermVector,
                fi.omitNorms, fi.storePayloads,
                fi.indexOptions);
   }
 
   private FieldInfo addInternal(String name, boolean isIndexed,
-                                boolean storeTermVector, boolean storePositionWithTermVector, 
-                                boolean storeOffsetWithTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions) {
+                                boolean storeTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions) {
     name = StringHelper.intern(name);
-    FieldInfo fi = new FieldInfo(name, isIndexed, byNumber.size(), storeTermVector, storePositionWithTermVector,
-                                 storeOffsetWithTermVector, omitNorms, storePayloads, indexOptions);
+    FieldInfo fi = new FieldInfo(name, isIndexed, byNumber.size(), storeTermVector,
+                                 omitNorms, storePayloads, indexOptions);
     byNumber.add(fi);
     byName.put(name, fi);
     return fi;
@@ -274,7 +227,7 @@
   }
 
   public FieldInfo fieldInfo(String fieldName) {
-    return  byName.get(fieldName);
+    return byName.get(fieldName);
   }
 
   /**
@@ -296,9 +249,13 @@
    * doesn't exist.
    */  
   public FieldInfo fieldInfo(int fieldNumber) {
-	return (fieldNumber >= 0) ? byNumber.get(fieldNumber) : null;
+    return (fieldNumber >= 0) ? byNumber.get(fieldNumber) : null;
   }
 
+  public Iterator<FieldInfo> iterator() {
+    return byNumber.iterator();
+  }
+
   public int size() {
     return byNumber.size();
   }
@@ -332,15 +289,13 @@
       byte bits = 0x0;
       if (fi.isIndexed) bits |= IS_INDEXED;
       if (fi.storeTermVector) bits |= STORE_TERMVECTOR;
-      if (fi.storePositionWithTermVector) bits |= STORE_POSITIONS_WITH_TERMVECTOR;
-      if (fi.storeOffsetWithTermVector) bits |= STORE_OFFSET_WITH_TERMVECTOR;
       if (fi.omitNorms) bits |= OMIT_NORMS;
       if (fi.storePayloads) bits |= STORE_PAYLOADS;
-      if (fi.indexOptions == IndexOptions.DOCS_ONLY)
+      if (fi.indexOptions == IndexOptions.DOCS_ONLY) {
         bits |= OMIT_TERM_FREQ_AND_POSITIONS;
-      else if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS)
+      } else if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS) {
         bits |= OMIT_POSITIONS;
-      
+      }
       output.writeString(fi.name);
       output.writeByte(bits);
     }
@@ -372,8 +327,6 @@
       byte bits = input.readByte();
       boolean isIndexed = (bits & IS_INDEXED) != 0;
       boolean storeTermVector = (bits & STORE_TERMVECTOR) != 0;
-      boolean storePositionsWithTermVector = (bits & STORE_POSITIONS_WITH_TERMVECTOR) != 0;
-      boolean storeOffsetWithTermVector = (bits & STORE_OFFSET_WITH_TERMVECTOR) != 0;
       boolean omitNorms = (bits & OMIT_NORMS) != 0;
       boolean storePayloads = (bits & STORE_PAYLOADS) != 0;
       final IndexOptions indexOptions;
@@ -396,7 +349,7 @@
         storePayloads = false;
       }
 
-      addInternal(name, isIndexed, storeTermVector, storePositionsWithTermVector, storeOffsetWithTermVector, omitNorms, storePayloads, indexOptions);
+      addInternal(name, isIndexed, storeTermVector, omitNorms, storePayloads, indexOptions);
     }
 
     if (input.getFilePointer() != input.length()) {
Index: lucene/src/java/org/apache/lucene/index/MultiReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/MultiReader.java	(revision 1228924)
+++ lucene/src/java/org/apache/lucene/index/MultiReader.java	(working copy)
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -78,15 +77,22 @@
     starts = new int[subReaders.length + 1];    // build starts array
     int maxDoc = 0;
     for (int i = 0; i < subReaders.length; i++) {
+      final IndexReader reader = subReaders[i];
       starts[i] = maxDoc;
-      maxDoc += subReaders[i].maxDoc();      // compute maxDocs
-      if (subReaders[i].hasDeletions())
+      maxDoc += reader.maxDoc();      // compute maxDocs
+      if (reader.hasDeletions()) {
         hasDeletions = true;
+      }
     }
     this.maxDoc = starts[subReaders.length] = maxDoc;
   }
 
   @Override
+  public FieldInfos getFieldInfos() {
+    throw new UnsupportedOperationException("call getFieldInfos() on each sub reader, or use ReaderUtil.getMergedFieldInfos, instead");
+  }
+
+  @Override
   protected synchronized IndexReader doOpenIfChanged() throws CorruptIndexException, IOException {
     return doReopen(false);
   }
@@ -426,12 +432,6 @@
     if (ioe != null) throw ioe;
   }
   
-  @Override
-  public Collection<String> getFieldNames (IndexReader.FieldOption fieldNames) {
-    ensureOpen();
-    return DirectoryReader.getFieldNames(fieldNames, this.subReaders);
-  }  
-  
   /**
    * Checks recursively if all subreaders are up to date. 
    */
Index: lucene/src/java/org/apache/lucene/index/FilterIndexReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/FilterIndexReader.java	(revision 1228924)
+++ lucene/src/java/org/apache/lucene/index/FilterIndexReader.java	(working copy)
@@ -22,7 +22,6 @@
 import org.apache.lucene.store.Directory;
 
 import java.io.IOException;
-import java.util.Collection;
 import java.util.Map;
 
 /**  A <code>FilterIndexReader</code> contains another IndexReader, which it
@@ -127,6 +126,11 @@
   }
   
   @Override
+  public FieldInfos getFieldInfos() {
+    return in.getFieldInfos();
+  }
+
+  @Override
   public int getTermInfosIndexDivisor() {
     ensureOpen();
     return in.getTermInfosIndexDivisor();
@@ -274,12 +278,6 @@
   }
 
   @Override
-  public Collection<String> getFieldNames(IndexReader.FieldOption fieldNames) {
-    ensureOpen();
-    return in.getFieldNames(fieldNames);
-  }
-
-  @Override
   public long getVersion() {
     ensureOpen();
     return in.getVersion();
Index: lucene/src/java/org/apache/lucene/index/SegmentMerger.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/SegmentMerger.java	(revision 1228924)
+++ lucene/src/java/org/apache/lucene/index/SegmentMerger.java	(working copy)
@@ -24,7 +24,6 @@
 
 import org.apache.lucene.document.Document;
 import org.apache.lucene.index.FieldInfo.IndexOptions;
-import org.apache.lucene.index.IndexReader.FieldOption;
 import org.apache.lucene.index.MergePolicy.MergeAbortedException;
 import org.apache.lucene.index.PayloadProcessorProvider.PayloadProcessor;
 import org.apache.lucene.store.Directory;
@@ -140,18 +139,6 @@
     return files;
   }
 
-  private static void addIndexed(IndexReader reader, FieldInfos fInfos,
-      Collection<String> names, boolean storeTermVectors,
-      boolean storePositionWithTermVector, boolean storeOffsetWithTermVector,
-      boolean storePayloads, IndexOptions indexOptions)
-      throws IOException {
-    for (String field : names) {
-      fInfos.add(field, true, storeTermVectors,
-          storePositionWithTermVector, storeOffsetWithTermVector, !reader
-              .hasNorms(field), storePayloads, indexOptions);
-    }
-  }
-
   private SegmentReader[] matchingSegmentReaders;
   private int[] rawDocLengths;
   private int[] rawDocLengths2;
@@ -174,10 +161,15 @@
     // stored fields:
     for (int i = 0; i < numReaders; i++) {
       IndexReader reader = readers.get(i);
+      // TODO: we may be able to broaden this to
+      // non-SegmentReaders, since FieldInfos is now
+      // required?  But... this'd also require exposing
+      // bulk-copy (TVs and stored fields) API in foreign
+      // readers..
       if (reader instanceof SegmentReader) {
         SegmentReader segmentReader = (SegmentReader) reader;
         boolean same = true;
-        FieldInfos segmentFieldInfos = segmentReader.fieldInfos();
+        FieldInfos segmentFieldInfos = segmentReader.getFieldInfos();
         int numFieldInfos = segmentFieldInfos.size();
         for (int j = 0; j < numFieldInfos; j++) {
           if (!fieldInfos.fieldName(j).equals(segmentFieldInfos.fieldName(j))) {
@@ -206,24 +198,7 @@
   private int mergeFields() throws CorruptIndexException, IOException {
 
     for (IndexReader reader : readers) {
-      if (reader instanceof SegmentReader) {
-        SegmentReader segmentReader = (SegmentReader) reader;
-        FieldInfos readerFieldInfos = segmentReader.fieldInfos();
-        int numReaderFieldInfos = readerFieldInfos.size();
-        for (int j = 0; j < numReaderFieldInfos; j++) {
-          fieldInfos.add(readerFieldInfos.fieldInfo(j));
-        }
-      } else {
-        addIndexed(reader, fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), true, true, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
-        addIndexed(reader, fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_POSITION), true, true, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
-        addIndexed(reader, fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR_WITH_OFFSET), true, false, true, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
-        addIndexed(reader, fieldInfos, reader.getFieldNames(FieldOption.TERMVECTOR), true, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
-        addIndexed(reader, fieldInfos, reader.getFieldNames(FieldOption.OMIT_POSITIONS), false, false, false, false, IndexOptions.DOCS_AND_FREQS);
-        addIndexed(reader, fieldInfos, reader.getFieldNames(FieldOption.OMIT_TERM_FREQ_AND_POSITIONS), false, false, false, false, IndexOptions.DOCS_ONLY);
-        addIndexed(reader, fieldInfos, reader.getFieldNames(FieldOption.STORES_PAYLOADS), false, false, false, true, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
-        addIndexed(reader, fieldInfos, reader.getFieldNames(FieldOption.INDEXED), false, false, false, false, IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
-        fieldInfos.add(reader.getFieldNames(FieldOption.UNINDEXED), false);
-      }
+      fieldInfos.add(reader.getFieldInfos());
     }
     fieldInfos.write(directory, segment + ".fnm");
 
Index: lucene/src/java/org/apache/lucene/index/FieldsReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/FieldsReader.java	(revision 1228924)
+++ lucene/src/java/org/apache/lucene/index/FieldsReader.java	(working copy)
@@ -364,7 +364,7 @@
     } else {
       Field.Store store = Field.Store.YES;
       Field.Index index = Field.Index.toIndex(fi.isIndexed, tokenize);
-      Field.TermVector termVector = Field.TermVector.toTermVector(fi.storeTermVector, fi.storeOffsetWithTermVector, fi.storePositionWithTermVector);
+      Field.TermVector termVector = Field.TermVector.toTermVector(fi.storeTermVector, false, false);
 
       if (compressed) {
         int toRead = fieldsStream.readVInt();
@@ -408,7 +408,7 @@
     } else {
       Field.Store store = Field.Store.YES;
       Field.Index index = Field.Index.toIndex(fi.isIndexed, tokenize);
-      Field.TermVector termVector = Field.TermVector.toTermVector(fi.storeTermVector, fi.storeOffsetWithTermVector, fi.storePositionWithTermVector);
+      Field.TermVector termVector = Field.TermVector.toTermVector(fi.storeTermVector, false, false);
       if (compressed) {
         int toRead = fieldsStream.readVInt();
         final byte[] b = new byte[toRead];
Index: lucene/src/java/org/apache/lucene/index/ParallelReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/ParallelReader.java	(revision 1228924)
+++ lucene/src/java/org/apache/lucene/index/ParallelReader.java	(working copy)
@@ -17,15 +17,16 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.util.*;
+
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.FieldSelector;
 import org.apache.lucene.document.FieldSelectorResult;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.util.ReaderUtil;
 
-import java.io.IOException;
-import java.util.*;
 
-
 /** An IndexReader which reads multiple, parallel indexes.  Each index added
  * must have the same number of documents, but typically each contains
  * different fields.  Each document contains the union of the fields of all
@@ -54,6 +55,7 @@
   private int maxDoc;
   private int numDocs;
   private boolean hasDeletions;
+  private final FieldInfos fieldInfos;
 
  /** Construct a ParallelReader. 
   * <p>Note that all subreaders are closed if this ParallelReader is closed.</p>
@@ -67,6 +69,7 @@
   public ParallelReader(boolean closeSubReaders) throws IOException {
     super();
     this.incRefReaders = !closeSubReaders;
+    fieldInfos = new FieldInfos();
   }
 
   /** {@inheritDoc} */
@@ -119,11 +122,13 @@
       throw new IllegalArgumentException
         ("All readers must have same numDocs: "+numDocs+"!="+reader.numDocs());
 
-    Collection<String> fields = reader.getFieldNames(IndexReader.FieldOption.ALL);
-    readerToFields.put(reader, fields);
-    for (final String field : fields) {                         // update fieldToReader map
-      if (fieldToReader.get(field) == null)
-        fieldToReader.put(field, reader);
+    final FieldInfos readerFieldInfos = ReaderUtil.getMergedFieldInfos(reader);
+    for(FieldInfo fieldInfo : readerFieldInfos) {   // update fieldToReader map
+      // NOTE: first reader having a given field "wins":
+      if (fieldToReader.get(fieldInfo.name) == null) {
+        fieldInfos.add(fieldInfo);
+        fieldToReader.put(fieldInfo.name, reader);
+      }
     }
 
     if (!ignoreStoredFields)
@@ -135,6 +140,11 @@
     }
     decrefOnClose.add(Boolean.valueOf(incRefReaders));
   }
+
+  @Override
+  public FieldInfos getFieldInfos() {
+    return fieldInfos;
+  }
   
   @Override
   protected synchronized IndexReader doOpenIfChanged() throws CorruptIndexException, IOException {
@@ -292,12 +302,12 @@
 
       boolean include = (fieldSelector==null);
       if (!include) {
-        Collection<String> fields = readerToFields.get(reader);
-        for (final String field : fields)
-          if (fieldSelector.accept(field) != FieldSelectorResult.NO_LOAD) {
+        for(FieldInfo fieldInfo : fieldInfos) {
+          if (fieldSelector.accept(fieldInfo.name) != FieldSelectorResult.NO_LOAD) {
             include = true;
             break;
           }
+        }
       }
       if (include) {
         List<Fieldable> fields = reader.document(n, fieldSelector).getFields();
@@ -486,17 +496,6 @@
     }
   }
 
-  @Override
-  public Collection<String> getFieldNames (IndexReader.FieldOption fieldNames) {
-    ensureOpen();
-    Set<String> fieldSet = new HashSet<String>();
-    for (final IndexReader reader : readers) {
-      Collection<String> names = reader.getFieldNames(fieldNames);
-      fieldSet.addAll(names);
-    }
-    return fieldSet;
-  }
-
   private class ParallelTermEnum extends TermEnum {
     private String field;
     private Iterator<String> fieldIterator;
Index: lucene/src/java/org/apache/lucene/index/SegmentReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/SegmentReader.java	(revision 1228924)
+++ lucene/src/java/org/apache/lucene/index/SegmentReader.java	(working copy)
@@ -20,20 +20,16 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.HashMap;
-import java.util.HashSet;
 
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 
 import java.util.concurrent.atomic.AtomicInteger;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.FieldSelector;
 import org.apache.lucene.search.FieldCache;
 import org.apache.lucene.search.Similarity;
-import org.apache.lucene.index.FieldInfo.IndexOptions;
 import org.apache.lucene.store.BufferedIndexInput;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IndexInput;
@@ -473,6 +469,12 @@
     return core.getTermsReader().terms(t);
   }
 
+  @Override
+  public FieldInfos getFieldInfos() {
+    return core.fieldInfos;
+  }
+
+  // TODO: remove in 4.0
   FieldInfos fieldInfos() {
     return core.fieldInfos;
   }
@@ -537,61 +539,7 @@
     return si.docCount;
   }
 
-  /**
-   * @see IndexReader#getFieldNames(org.apache.lucene.index.IndexReader.FieldOption)
-   */
   @Override
-  public Collection<String> getFieldNames(IndexReader.FieldOption fieldOption) {
-    ensureOpen();
-
-    Set<String> fieldSet = new HashSet<String>();
-    for (int i = 0; i < core.fieldInfos.size(); i++) {
-      FieldInfo fi = core.fieldInfos.fieldInfo(i);
-      if (fieldOption == IndexReader.FieldOption.ALL) {
-        fieldSet.add(fi.name);
-      }
-      else if (!fi.isIndexed && fieldOption == IndexReader.FieldOption.UNINDEXED) {
-        fieldSet.add(fi.name);
-      }
-      else if (fi.indexOptions == IndexOptions.DOCS_ONLY && fieldOption == IndexReader.FieldOption.OMIT_TERM_FREQ_AND_POSITIONS) {
-        fieldSet.add(fi.name);
-      }
-      else if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS && fieldOption == IndexReader.FieldOption.OMIT_POSITIONS) {
-        fieldSet.add(fi.name);
-      }
-      else if (fi.storePayloads && fieldOption == IndexReader.FieldOption.STORES_PAYLOADS) {
-        fieldSet.add(fi.name);
-      }
-      else if (fi.isIndexed && fieldOption == IndexReader.FieldOption.INDEXED) {
-        fieldSet.add(fi.name);
-      }
-      else if (fi.isIndexed && fi.storeTermVector == false && fieldOption == IndexReader.FieldOption.INDEXED_NO_TERMVECTOR) {
-        fieldSet.add(fi.name);
-      }
-      else if (fi.storeTermVector == true &&
-               fi.storePositionWithTermVector == false &&
-               fi.storeOffsetWithTermVector == false &&
-               fieldOption == IndexReader.FieldOption.TERMVECTOR) {
-        fieldSet.add(fi.name);
-      }
-      else if (fi.isIndexed && fi.storeTermVector && fieldOption == IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR) {
-        fieldSet.add(fi.name);
-      }
-      else if (fi.storePositionWithTermVector && fi.storeOffsetWithTermVector == false && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_POSITION) {
-        fieldSet.add(fi.name);
-      }
-      else if (fi.storeOffsetWithTermVector && fi.storePositionWithTermVector == false && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET) {
-        fieldSet.add(fi.name);
-      }
-      else if ((fi.storeOffsetWithTermVector && fi.storePositionWithTermVector) &&
-                fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET) {
-        fieldSet.add(fi.name);
-      }
-    }
-    return fieldSet;
-  }
-
-  @Override
   public boolean hasNorms(String field) {
     ensureOpen();
     return norms.containsKey(field);
Index: lucene/src/java/org/apache/lucene/index/DocFieldProcessorPerThread.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/DocFieldProcessorPerThread.java	(revision 1228924)
+++ lucene/src/java/org/apache/lucene/index/DocFieldProcessorPerThread.java	(working copy)
@@ -222,7 +222,6 @@
         // to have a new "thing" my Fields can do, I can
         // easily add it
         FieldInfo fi = fieldInfos.add(fieldName, field.isIndexed(), field.isTermVectorStored(),
-                                      field.isStorePositionWithTermVector(), field.isStoreOffsetWithTermVector(),
                                       field.getOmitNorms(), false, field.getIndexOptions());
 
         fp = new DocFieldProcessorPerField(this, fi);
@@ -234,7 +233,6 @@
           rehash();
       } else {
         fp.fieldInfo.update(field.isIndexed(), field.isTermVectorStored(),
-                            field.isStorePositionWithTermVector(), field.isStoreOffsetWithTermVector(),
                             field.getOmitNorms(), false, field.getIndexOptions());
       }
 
Index: lucene/src/java/org/apache/lucene/index/CheckIndex.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/CheckIndex.java	(revision 1228924)
+++ lucene/src/java/org/apache/lucene/index/CheckIndex.java	(working copy)
@@ -22,7 +22,6 @@
 import java.io.PrintStream;
 import java.text.NumberFormat;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Comparator;
 import java.util.List;
 import java.util.Map;
@@ -548,16 +547,16 @@
         if (reader.maxDoc() != info.docCount)
           throw new RuntimeException("SegmentReader.maxDoc() " + reader.maxDoc() + " != SegmentInfos.docCount " + info.docCount);
 
-        // Test getFieldNames()
+        // Test getFieldInfos()
         if (infoStream != null) {
           infoStream.print("    test: fields..............");
         }         
-        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);
-        msg("OK [" + fieldNames.size() + " fields]");
-        segInfoStat.numFields = fieldNames.size();
+        FieldInfos fieldInfos = reader.getFieldInfos();
+        msg("OK [" + fieldInfos.size() + " fields]");
+        segInfoStat.numFields = fieldInfos.size();
         
         // Test Field Norms
-        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);
+        segInfoStat.fieldNormStatus = testFieldNorms(fieldInfos, reader);
 
         // Test the Term Index
         segInfoStat.termIndexStatus = testTermIndex(info, reader);
@@ -623,7 +622,7 @@
   /**
    * Test field norms.
    */
-  private Status.FieldNormStatus testFieldNorms(Collection<String> fieldNames, SegmentReader reader) {
+  private Status.FieldNormStatus testFieldNorms(FieldInfos fieldInfos, SegmentReader reader) {
     final Status.FieldNormStatus status = new Status.FieldNormStatus();
 
     try {
@@ -632,9 +631,9 @@
         infoStream.print("    test: field norms.........");
       }
       final byte[] b = new byte[reader.maxDoc()];
-      for (final String fieldName : fieldNames) {
-        if (reader.hasNorms(fieldName)) {
-          reader.norms(fieldName, b, 0);
+      for (FieldInfo fieldInfo : fieldInfos) {
+        if (reader.hasNorms(fieldInfo.name)) {
+          reader.norms(fieldInfo.name, b, 0);
           ++status.totFields;
         }
       }
Index: lucene/src/java/org/apache/lucene/index/DirectoryReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/DirectoryReader.java	(revision 1228924)
+++ lucene/src/java/org/apache/lucene/index/DirectoryReader.java	(working copy)
@@ -24,11 +24,9 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.List;
 
 import java.util.Map;
-import java.util.Set;
 
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.FieldSelector;
@@ -314,15 +312,21 @@
     return buffer.toString();
   }
 
+  @Override
+  public FieldInfos getFieldInfos() {
+    throw new UnsupportedOperationException("call getFieldInfos() on each sub reader, or use ReaderUtil.getMergedFieldInfos, instead");
+  }
+
   private void initialize(SegmentReader[] subReaders) throws IOException {
     this.subReaders = subReaders;
     starts = new int[subReaders.length + 1];    // build starts array
     for (int i = 0; i < subReaders.length; i++) {
+      final SegmentReader reader = subReaders[i];
       starts[i] = maxDoc;
-      maxDoc += subReaders[i].maxDoc();      // compute maxDocs
-
-      if (subReaders[i].hasDeletions())
+      maxDoc += reader.maxDoc();      // compute maxDocs
+      if (reader.hasDeletions()) {
         hasDeletions = true;
+      }
     }
     starts[subReaders.length] = maxDoc;
 
@@ -914,22 +918,6 @@
   }
 
   @Override
-  public Collection<String> getFieldNames (IndexReader.FieldOption fieldNames) {
-    ensureOpen();
-    return getFieldNames(fieldNames, this.subReaders);
-  }
-  
-  static Collection<String> getFieldNames (IndexReader.FieldOption fieldNames, IndexReader[] subReaders) {
-    // maintain a unique set of field names
-    Set<String> fieldSet = new HashSet<String>();
-    for (IndexReader reader : subReaders) {
-      Collection<String> names = reader.getFieldNames(fieldNames);
-      fieldSet.addAll(names);
-    }
-    return fieldSet;
-  } 
-  
-  @Override
   public IndexReader[] getSequentialSubReaders() {
     return subReaders;
   }
Index: lucene/src/java/org/apache/lucene/index/FieldInfo.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/FieldInfo.java	(revision 1228924)
+++ lucene/src/java/org/apache/lucene/index/FieldInfo.java	(working copy)
@@ -19,20 +19,18 @@
 
 /** @lucene.experimental */
 public final class FieldInfo {
-  final String name;
-  final int number;
+  public final String name;
+  public final int number;
 
-  boolean isIndexed;
+  public boolean isIndexed;
 
-  // true if term vector for this field should be stored
-  boolean storeTermVector;
-  boolean storeOffsetWithTermVector;
-  boolean storePositionWithTermVector;
+  // True if any document indexed term vectors
+  public boolean storeTermVector;
 
   public boolean omitNorms; // omit norms associated with indexed fields  
   public IndexOptions indexOptions;
   
-  boolean storePayloads; // whether this field stores payloads together with term positions
+  public boolean storePayloads; // whether this field stores payloads together with term positions
 
   /**
    * Controls how much information is stored in the postings lists.
@@ -48,22 +46,17 @@
   };
 
   FieldInfo(String na, boolean tk, int nu, boolean storeTermVector, 
-            boolean storePositionWithTermVector,  boolean storeOffsetWithTermVector, 
             boolean omitNorms, boolean storePayloads, IndexOptions indexOptions) {
     name = na;
     isIndexed = tk;
     number = nu;
     if (isIndexed) {
       this.storeTermVector = storeTermVector;
-      this.storeOffsetWithTermVector = storeOffsetWithTermVector;
-      this.storePositionWithTermVector = storePositionWithTermVector;
       this.storePayloads = storePayloads;
       this.omitNorms = omitNorms;
       this.indexOptions = indexOptions;
     } else { // for non-indexed fields, leave defaults
       this.storeTermVector = false;
-      this.storeOffsetWithTermVector = false;
-      this.storePositionWithTermVector = false;
       this.storePayloads = false;
       this.omitNorms = true;
       this.indexOptions = IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;
@@ -73,12 +66,12 @@
 
   @Override
   public Object clone() {
-    return new FieldInfo(name, isIndexed, number, storeTermVector, storePositionWithTermVector,
-                         storeOffsetWithTermVector, omitNorms, storePayloads, indexOptions);
+    return new FieldInfo(name, isIndexed, number, storeTermVector,
+                         omitNorms, storePayloads, indexOptions);
   }
 
-  void update(boolean isIndexed, boolean storeTermVector, boolean storePositionWithTermVector, 
-              boolean storeOffsetWithTermVector, boolean omitNorms, boolean storePayloads, IndexOptions indexOptions) {
+  void update(boolean isIndexed, boolean storeTermVector,
+              boolean omitNorms, boolean storePayloads, IndexOptions indexOptions) {
 
     if (this.isIndexed != isIndexed) {
       this.isIndexed = true;                      // once indexed, always index
@@ -87,12 +80,6 @@
       if (this.storeTermVector != storeTermVector) {
         this.storeTermVector = true;                // once vector, always vector
       }
-      if (this.storePositionWithTermVector != storePositionWithTermVector) {
-        this.storePositionWithTermVector = true;                // once vector, always vector
-      }
-      if (this.storeOffsetWithTermVector != storeOffsetWithTermVector) {
-        this.storeOffsetWithTermVector = true;                // once vector, always vector
-      }
       if (this.storePayloads != storePayloads) {
         this.storePayloads = true;
       }
Index: lucene/src/java/org/apache/lucene/index/IndexReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/IndexReader.java	(revision 1228924)
+++ lucene/src/java/org/apache/lucene/index/IndexReader.java	(working copy)
@@ -116,37 +116,6 @@
     }
   }
 
-  /**
-   * Constants describing field properties, for example used for
-   * {@link IndexReader#getFieldNames(FieldOption)}.
-   */
-  public static enum FieldOption {
-    /** All fields */
-    ALL,
-    /** All indexed fields */
-    INDEXED,
-    /** All fields that store payloads */
-    STORES_PAYLOADS,
-    /** All fields that omit tf */
-    OMIT_TERM_FREQ_AND_POSITIONS,
-    /** All fields that omit positions */
-    OMIT_POSITIONS,
-    /** All fields which are not indexed */
-    UNINDEXED,
-    /** All fields which are indexed with termvectors enabled */
-    INDEXED_WITH_TERMVECTOR,
-    /** All fields which are indexed but don't have termvectors enabled */
-    INDEXED_NO_TERMVECTOR,
-    /** All fields with termvectors enabled. Please note that only standard termvector fields are returned */
-    TERMVECTOR,
-    /** All fields with termvectors with position values enabled */
-    TERMVECTOR_WITH_POSITION,
-    /** All fields with termvectors with offset values enabled */
-    TERMVECTOR_WITH_OFFSET,
-    /** All fields with termvectors with offset values and position values enabled */
-    TERMVECTOR_WITH_POSITION_OFFSET,
-  }
-
   private volatile boolean closed;
   protected boolean hasChanges;
   
@@ -1572,15 +1541,14 @@
   /** Implements close. */
   protected abstract void doClose() throws IOException;
 
-
   /**
-   * Get a list of unique field names that exist in this index and have the specified
-   * field option information.
-   * @param fldOption specifies which field option should be available for the returned fields
-   * @return Collection of Strings indicating the names of the fields.
-   * @see IndexReader.FieldOption
+   * Get the {@link FieldInfos} describing all fields in
+   * this reader.  NOTE: do not make any changes to the
+   * returned FieldInfos!
+   *
+   * @lucene.experimental
    */
-  public abstract Collection<String> getFieldNames(FieldOption fldOption);
+  public abstract FieldInfos getFieldInfos();
 
   /**
    * Expert: return the IndexCommit that this reader has
Index: lucene/src/java/org/apache/lucene/util/ReaderUtil.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/ReaderUtil.java	(revision 1228924)
+++ lucene/src/java/org/apache/lucene/util/ReaderUtil.java	(working copy)
@@ -19,8 +19,12 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
 import java.util.List;
 
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexReader;
 
 /**
@@ -151,4 +155,26 @@
     }
     return hi;
   }
+
+  public static Collection<String> getIndexedFields(IndexReader reader) {
+    final Collection<String> fields = new HashSet<String>();
+    for(FieldInfo fieldInfo : getMergedFieldInfos(reader)) {
+      if (fieldInfo.isIndexed) {
+        fields.add(fieldInfo.name);
+      }
+    }
+    return fields;
+  }
+
+  /** Call this to get the (merged) FieldInfos for a
+   *  composite reader */
+  public static FieldInfos getMergedFieldInfos(IndexReader reader) {
+    final List<IndexReader> subReaders = new ArrayList<IndexReader>();
+    ReaderUtil.gatherSubReaders(subReaders, reader);
+    final FieldInfos fieldInfos = new FieldInfos();
+    for(IndexReader subReader : subReaders) {
+      fieldInfos.add(subReader.getFieldInfos());
+    }
+    return fieldInfos;
+  }
 }
Index: lucene/src/site/build/site/fileformats.html
===================================================================
--- lucene/src/site/build/site/fileformats.html	(revision 1228924)
+++ lucene/src/site/build/site/fileformats.html	(working copy)
@@ -1755,10 +1755,6 @@
                             without term vectors.
                         </li>
                         
-<li>If the third lowest-order bit is set (0x04), term positions are stored with the term vectors.</li>
-                        
-<li>If the fourth lowest-order bit is set (0x08), term offsets are stored with the term vectors.</li>
-                        
 <li>If the fifth lowest-order bit is set (0x10), norms are omitted for the indexed field.</li>
                         
 <li>If the sixth lowest-order bit is set (0x20), payloads are stored for the indexed field.</li>
@@ -1923,7 +1919,7 @@
 </li>
                 
 </ol>
-<a name="N106F0"></a><a name="Term Dictionary"></a>
+<a name="N106EA"></a><a name="Term Dictionary"></a>
 <h3 class="boxed">Term Dictionary</h3>
 <p>
                     The term dictionary is represented as two files:
@@ -2115,7 +2111,7 @@
 </li>
                 
 </ol>
-<a name="N10774"></a><a name="Frequencies"></a>
+<a name="N1076E"></a><a name="Frequencies"></a>
 <h3 class="boxed">Frequencies</h3>
 <p>
                     The .frq file contains the lists of documents
@@ -2243,7 +2239,7 @@
                    entry in level-1. In the example has entry 15 on level 1 a pointer to entry 15 on level 0 and entry 31 on level 1 a pointer
                    to entry 31 on level 0.                   
                 </p>
-<a name="N107FC"></a><a name="Positions"></a>
+<a name="N107F6"></a><a name="Positions"></a>
 <h3 class="boxed">Positions</h3>
 <p>
                     The .prx file contains the lists of positions that
@@ -2313,7 +2309,7 @@
                     Payload. If PayloadLength is not stored, then this Payload has the same
                     length as the Payload at the previous position.
                 </p>
-<a name="N10838"></a><a name="Normalization Factors"></a>
+<a name="N10832"></a><a name="Normalization Factors"></a>
 <h3 class="boxed">Normalization Factors</h3>
 <p>There's a single .nrm file containing all norms:
                 </p>
@@ -2393,7 +2389,7 @@
                 </p>
 <p>Separate norm files are created (when adequate) for both compound and non compound segments.
                 </p>
-<a name="N10889"></a><a name="Term Vectors"></a>
+<a name="N10883"></a><a name="Term Vectors"></a>
 <h3 class="boxed">Term Vectors</h3>
 <p>
 		  Term Vector support is an optional on a field by
@@ -2529,7 +2525,7 @@
 </li>
                 
 </ol>
-<a name="N10925"></a><a name="Deleted Documents"></a>
+<a name="N1091F"></a><a name="Deleted Documents"></a>
 <h3 class="boxed">Deleted Documents</h3>
 <p>The .del file is
                     optional, and only exists when a segment contains deletions.
@@ -2593,7 +2589,7 @@
 </div>
 
         
-<a name="N1095F"></a><a name="Limitations"></a>
+<a name="N10959"></a><a name="Limitations"></a>
 <h2 class="boxed">Limitations</h2>
 <div class="section">
 <p>
Index: lucene/src/site/src/documentation/content/xdocs/fileformats.xml
===================================================================
--- lucene/src/site/src/documentation/content/xdocs/fileformats.xml	(revision 1228924)
+++ lucene/src/site/src/documentation/content/xdocs/fileformats.xml	(working copy)
@@ -1216,8 +1216,6 @@
                             bit is one for fields that have term vectors stored, and zero for fields
                             without term vectors.
                         </li>
-                        <li>If the third lowest-order bit is set (0x04), term positions are stored with the term vectors.</li>
-                        <li>If the fourth lowest-order bit is set (0x08), term offsets are stored with the term vectors.</li>
                         <li>If the fifth lowest-order bit is set (0x10), norms are omitted for the indexed field.</li>
                         <li>If the sixth lowest-order bit is set (0x20), payloads are stored for the indexed field.</li>
                         <li>If the seventh lowest-order bit is set (0x40), term frequencies and positions omitted for the indexed field.</li>
Index: lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
===================================================================
--- lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java	(revision 1228924)
+++ lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java	(working copy)
@@ -22,7 +22,6 @@
 import java.io.StringReader;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.Iterator;
@@ -35,6 +34,8 @@
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.FieldSelector;
+import org.apache.lucene.index.FieldInfos;
+import org.apache.lucene.index.FieldInvertState;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermDocs;
@@ -43,12 +44,11 @@
 import org.apache.lucene.index.TermPositionVector;
 import org.apache.lucene.index.TermPositions;
 import org.apache.lucene.index.TermVectorMapper;
-import org.apache.lucene.index.FieldInvertState;
 import org.apache.lucene.search.Collector;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.Searcher;
-import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.Similarity;
 import org.apache.lucene.store.RAMDirectory; // for javadocs
 import org.apache.lucene.util.ArrayUtil;
@@ -192,6 +192,8 @@
   private static final long serialVersionUID = 2782195016849084649L;
 
   private static final boolean DEBUG = false;
+
+  private final FieldInfos fieldInfos;
   
   /**
    * Sorts term entries into ascending order; also works for
@@ -227,6 +229,7 @@
    */
   private MemoryIndex(boolean storeOffsets) {
     this.stride = storeOffsets ? 3 : 1;
+    fieldInfos = new FieldInfos();
   }
   
   /**
@@ -345,6 +348,8 @@
       int numTokens = 0;
       int numOverlapTokens = 0;
       int pos = -1;
+
+      fieldInfos.add(fieldName, true, true);
       
       CharTermAttribute termAtt = stream.addAttribute(CharTermAttribute.class);
       PositionIncrementAttribute posIncrAttribute = stream.addAttribute(PositionIncrementAttribute.class);
@@ -389,7 +394,7 @@
       }
     }
   }
-  
+
   /**
    * Creates and returns a searcher that can be used to execute arbitrary
    * Lucene queries and to collect the resulting query results as hits.
@@ -750,6 +755,11 @@
     }
     
     @Override
+    public FieldInfos getFieldInfos() {
+      return fieldInfos;
+    }
+  
+    @Override
     public int docFreq(Term term) {
       Info info = getInfo(term.field());
       int freq = 0;
@@ -1188,22 +1198,6 @@
     protected void doClose() {
       if (DEBUG) System.err.println("MemoryIndexReader.doClose");
     }
-    
-    // lucene >= 1.9 (remove this method for lucene-1.4.3)
-    @Override
-    public Collection<String> getFieldNames(FieldOption fieldOption) {
-      if (DEBUG) System.err.println("MemoryIndexReader.getFieldNamesOption");
-      if (fieldOption == FieldOption.UNINDEXED) 
-        return Collections.<String>emptySet();
-      if (fieldOption == FieldOption.INDEXED_NO_TERMVECTOR) 
-        return Collections.<String>emptySet();
-      if (fieldOption == FieldOption.TERMVECTOR_WITH_OFFSET && stride == 1) 
-        return Collections.<String>emptySet();
-      if (fieldOption == FieldOption.TERMVECTOR_WITH_POSITION_OFFSET && stride == 1) 
-        return Collections.<String>emptySet();
-      
-      return Collections.unmodifiableSet(fields.keySet());
-    }
   }
 
   
Index: lucene/contrib/analyzers/common/src/java/org/apache/lucene/analysis/query/QueryAutoStopWordAnalyzer.java
===================================================================
--- lucene/contrib/analyzers/common/src/java/org/apache/lucene/analysis/query/QueryAutoStopWordAnalyzer.java	(revision 1228924)
+++ lucene/contrib/analyzers/common/src/java/org/apache/lucene/analysis/query/QueryAutoStopWordAnalyzer.java	(working copy)
@@ -16,19 +16,20 @@
  * limitations under the License.
  */
 
+import java.io.IOException;
+import java.io.Reader;
+import java.util.*;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.StopFilter;
+import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermEnum;
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.analysis.StopFilter;
+import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.Version;
 
-import java.io.IOException;
-import java.io.Reader;
-import java.util.*;
-
 /**
  * An {@link Analyzer} used primarily at query time to wrap another analyzer and provide a layer of protection
  * which prevents very common words from being passed into queries. 
@@ -97,7 +98,7 @@
       Analyzer delegate,
       IndexReader indexReader,
       int maxDocFreq) throws IOException {
-    this(matchVersion, delegate, indexReader, indexReader.getFieldNames(IndexReader.FieldOption.INDEXED), maxDocFreq);
+    this(matchVersion, delegate, indexReader, ReaderUtil.getIndexedFields(indexReader), maxDocFreq);
   }
 
   /**
@@ -117,7 +118,7 @@
       Analyzer delegate,
       IndexReader indexReader,
       float maxPercentDocs) throws IOException {
-    this(matchVersion, delegate, indexReader, indexReader.getFieldNames(IndexReader.FieldOption.INDEXED), maxPercentDocs);
+    this(matchVersion, delegate, indexReader, ReaderUtil.getIndexedFields(indexReader), maxPercentDocs);
   }
 
   /**
@@ -214,7 +215,7 @@
   @Deprecated
   public int addStopWords(IndexReader reader, int maxDocFreq) throws IOException {
     int numStopWords = 0;
-    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.INDEXED);
+    Collection<String> fieldNames = ReaderUtil.getIndexedFields(reader);
     for (Iterator<String> iter = fieldNames.iterator(); iter.hasNext();) {
       String fieldName = iter.next();
       numStopWords += addStopWords(reader, fieldName, maxDocFreq);
@@ -237,7 +238,7 @@
   @Deprecated
   public int addStopWords(IndexReader reader, float maxPercentDocs) throws IOException {
     int numStopWords = 0;
-    Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.INDEXED);
+    Collection<String> fieldNames = ReaderUtil.getIndexedFields(reader);
     for (Iterator<String> iter = fieldNames.iterator(); iter.hasNext();) {
       String fieldName = iter.next();
       numStopWords += addStopWords(reader, fieldName, maxPercentDocs);
Index: lucene/contrib/instantiated/src/test/org/apache/lucene/store/instantiated/TestIndicesEquals.java
===================================================================
--- lucene/contrib/instantiated/src/test/org/apache/lucene/store/instantiated/TestIndicesEquals.java	(revision 1228924)
+++ lucene/contrib/instantiated/src/test/org/apache/lucene/store/instantiated/TestIndicesEquals.java	(working copy)
@@ -29,6 +29,8 @@
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.Payload;
@@ -41,6 +43,7 @@
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.AttributeImpl;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.ReaderUtil;
 
 /**
  * Asserts equality of content and behaviour of two index readers.
@@ -387,18 +390,11 @@
 
     assertEquals(aprioriReader.numDocs(), testReader.numDocs());
 
-    // assert field options
-    assertEquals(aprioriReader.getFieldNames(IndexReader.FieldOption.INDEXED), testReader.getFieldNames(IndexReader.FieldOption.INDEXED));
-    assertEquals(aprioriReader.getFieldNames(IndexReader.FieldOption.INDEXED_NO_TERMVECTOR), testReader.getFieldNames(IndexReader.FieldOption.INDEXED_NO_TERMVECTOR));
-    assertEquals(aprioriReader.getFieldNames(IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR), testReader.getFieldNames(IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR));
-    assertEquals(aprioriReader.getFieldNames(IndexReader.FieldOption.STORES_PAYLOADS), testReader.getFieldNames(IndexReader.FieldOption.STORES_PAYLOADS));
-    assertEquals(aprioriReader.getFieldNames(IndexReader.FieldOption.TERMVECTOR), testReader.getFieldNames(IndexReader.FieldOption.TERMVECTOR));
-    assertEquals(aprioriReader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET), testReader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET));
-    assertEquals(aprioriReader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION), testReader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION));
-    assertEquals(aprioriReader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET), testReader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET));
-    assertEquals(aprioriReader.getFieldNames(IndexReader.FieldOption.UNINDEXED), testReader.getFieldNames(IndexReader.FieldOption.UNINDEXED));
+    final FieldInfos aprioriFieldInfos = ReaderUtil.getMergedFieldInfos(aprioriReader);
 
-    for (Object field : aprioriReader.getFieldNames(IndexReader.FieldOption.ALL)) {
+    for (FieldInfo aprioriFieldInfo : aprioriFieldInfos) {
+      
+      Object field = aprioriFieldInfo.name;
 
       // test norms as used by normal use
 
Index: lucene/contrib/instantiated/src/test/org/apache/lucene/store/instantiated/TestSerialization.java
===================================================================
--- lucene/contrib/instantiated/src/test/org/apache/lucene/store/instantiated/TestSerialization.java	(revision 1228924)
+++ lucene/contrib/instantiated/src/test/org/apache/lucene/store/instantiated/TestSerialization.java	(working copy)
@@ -26,7 +26,9 @@
 import org.apache.lucene.document.Field;
 
 import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
 import java.io.ObjectOutputStream;
+import java.io.ObjectInputStream;
 
 public class TestSerialization extends LuceneTestCase {
 
@@ -49,8 +51,13 @@
     oos.writeObject(ii);
     oos.close();
     baos.close();
+
+    final byte[] bytes = baos.toByteArray();
+    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
+    ObjectInputStream ois = new ObjectInputStream(bais);
+    InstantiatedIndex ii2 = (InstantiatedIndex) ois.readObject();
+    assertNotNull(ii2.getFieldInfos());
     dir.close();
-    
   }
 
 }
Index: lucene/contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedIndexReader.java
===================================================================
--- lucene/contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedIndexReader.java	(revision 1228924)
+++ lucene/contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedIndexReader.java	(working copy)
@@ -18,15 +18,11 @@
 
 import java.io.IOException;
 import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.FieldSelector;
@@ -39,7 +35,11 @@
  * sync with the latest commit to the store!
  * <p>
  * Consider using InstantiatedIndex as if it was immutable.
+ *
+ * @deprecated contrib/instantiated will be removed in 4.0;
+ * you can use the memory codec to hold all postings in RAM
  */
+@Deprecated
 public class InstantiatedIndexReader extends IndexReader {
 
   private final InstantiatedIndex index;
@@ -67,6 +67,11 @@
   }
 
   @Override
+  public FieldInfos getFieldInfos() {
+    return index.getFieldInfos();
+  }
+  
+  @Override
   public Directory directory() {
     throw new UnsupportedOperationException();
   }
@@ -203,39 +208,6 @@
     // todo perhaps release all associated instances?
   }
 
-  @Override
-  public Collection<String> getFieldNames(FieldOption fieldOption) {
-    Set<String> fieldSet = new HashSet<String>();
-    for (FieldSetting fi : index.getFieldSettings().values()) {
-      if (fieldOption == IndexReader.FieldOption.ALL) {
-        fieldSet.add(fi.fieldName);
-      } else if (!fi.indexed && fieldOption == IndexReader.FieldOption.UNINDEXED) {
-        fieldSet.add(fi.fieldName);
-      } else if (fi.storePayloads && fieldOption == IndexReader.FieldOption.STORES_PAYLOADS) {
-        fieldSet.add(fi.fieldName);
-      } else if (fi.indexed && fieldOption == IndexReader.FieldOption.INDEXED) {
-        fieldSet.add(fi.fieldName);
-      } else if (fi.indexed && fi.storeTermVector == false && fieldOption == IndexReader.FieldOption.INDEXED_NO_TERMVECTOR) {
-        fieldSet.add(fi.fieldName);
-      } else if (fi.storeTermVector == true && fi.storePositionWithTermVector == false && fi.storeOffsetWithTermVector == false
-          && fieldOption == IndexReader.FieldOption.TERMVECTOR) {
-        fieldSet.add(fi.fieldName);
-      } else if (fi.indexed && fi.storeTermVector && fieldOption == IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR) {
-        fieldSet.add(fi.fieldName);
-      } else if (fi.storePositionWithTermVector && fi.storeOffsetWithTermVector == false
-          && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_POSITION) {
-        fieldSet.add(fi.fieldName);
-      } else if (fi.storeOffsetWithTermVector && fi.storePositionWithTermVector == false
-          && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET) {
-        fieldSet.add(fi.fieldName);
-      } else if ((fi.storeOffsetWithTermVector && fi.storePositionWithTermVector)
-          && fieldOption == IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET) {
-        fieldSet.add(fi.fieldName);
-      } 
-    }
-    return fieldSet;
-  }
-
   /**
    * Return the {@link org.apache.lucene.document.Document} at the <code>n</code><sup>th</sup>
    * position.
@@ -249,7 +221,7 @@
    * This can also be seen as a feature for live changes of stored values,
    * but be careful! Adding a field with an name unknown to the index
    * or to a field with previously no stored values will make
-   * {@link org.apache.lucene.store.instantiated.InstantiatedIndexReader#getFieldNames(org.apache.lucene.index.IndexReader.FieldOption)}
+   * {@link org.apache.lucene.store.instantiated.InstantiatedIndexReader#getFieldInfos()}
    * out of sync, causing problems for instance when merging the
    * instantiated index to another index.
      <p>
Index: lucene/contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedIndexWriter.java
===================================================================
--- lucene/contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedIndexWriter.java	(revision 1228924)
+++ lucene/contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedIndexWriter.java	(working copy)
@@ -60,7 +60,11 @@
  * Consider using InstantiatedIndex as if it was immutable.
  *
  * @see org.apache.lucene.index.IndexWriter 
+ *
+ * @deprecated contrib/instantiated will be removed in 4.0;
+ * you can use the memory codec to hold all postings in RAM
  */
+@Deprecated
 public class InstantiatedIndexWriter implements Closeable {
 
   private PrintStream infoStream = null;
@@ -382,6 +386,9 @@
     for (FieldSetting fieldSetting : fieldSettingsByFieldName.values()) {
       index.getFieldSettings().merge(fieldSetting);
     }
+
+    index.rebuildFieldInfos();
+
     // set term index
     if (orderedTermsDirty) {
       // todo optimize, only update from start position
Index: lucene/contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedIndex.java
===================================================================
--- lucene/contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedIndex.java	(revision 1228924)
+++ lucene/contrib/instantiated/src/java/org/apache/lucene/store/instantiated/InstantiatedIndex.java	(working copy)
@@ -20,7 +20,6 @@
 import java.io.IOException;
 import java.io.Serializable;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -29,12 +28,15 @@
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Fieldable;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermEnum;
 import org.apache.lucene.index.TermPositionVector;
 import org.apache.lucene.index.TermPositions;
 import org.apache.lucene.util.BitVector;
+import org.apache.lucene.util.ReaderUtil;
 
 /**
  * Represented as a coupled graph of class instances, this
@@ -51,7 +53,11 @@
  * at the same time as a searcher is reading from it.
  *
  * Consider using InstantiatedIndex as if it was immutable.
+ *
+ * @deprecated contrib/instantiated will be removed in 4.0;
+ * you can use the memory codec to hold all postings in RAM
  */
+@Deprecated
 public class InstantiatedIndex
     implements Serializable,Closeable {
 
@@ -69,6 +75,7 @@
   private Map<String, byte[]> normsByFieldNameAndDocumentNumber;
 
   private FieldSettings fieldSettings;
+  private transient FieldInfos fieldInfos;
 
   /**
    * Creates an empty instantiated index for you to fill with data using an {@link org.apache.lucene.store.instantiated.InstantiatedIndexWriter}. 
@@ -84,8 +91,28 @@
     orderedTerms = new InstantiatedTerm[0];
     documentsByNumber = new InstantiatedDocument[0];
     normsByFieldNameAndDocumentNumber = new HashMap<String, byte[]>();
+    rebuildFieldInfos();
   }
 
+  private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
+    in.defaultReadObject();
+    rebuildFieldInfos();
+  }
+
+  void rebuildFieldInfos() {
+    fieldInfos = new FieldInfos();
+    for(FieldSetting fieldSetting : fieldSettings.values()) {
+      fieldInfos.add(fieldSetting.fieldName,
+                     fieldSetting.indexed,
+                     fieldSetting.storeTermVector,
+                     false, fieldSetting.storePayloads,
+                     FieldInfo.IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
+    }
+  }
+
+  public FieldInfos getFieldInfos() {
+    return fieldInfos;
+  }
   
   /**
    * Creates a new instantiated index that looks just like the index in a specific state as represented by a reader.
@@ -113,63 +140,18 @@
       //throw new IOException("Source index has more than one segment.");
     }
 
-
     initialize();
 
-    Collection<String> allFieldNames = sourceIndexReader.getFieldNames(IndexReader.FieldOption.ALL);
-        
-    // load field options
-
-    Collection<String> indexedNames = sourceIndexReader.getFieldNames(IndexReader.FieldOption.INDEXED);
-    for (String name : indexedNames) {
-      FieldSetting setting = fieldSettings.get(name, true);
-      setting.indexed = true;
-    }
-    Collection<String> indexedNoVecNames = sourceIndexReader.getFieldNames(IndexReader.FieldOption.INDEXED_NO_TERMVECTOR);
-    for (String name : indexedNoVecNames) {
-      FieldSetting setting = fieldSettings.get(name, true);
-      setting.storeTermVector = false;
-      setting.indexed = true;
-    }
-    Collection<String> indexedVecNames = sourceIndexReader.getFieldNames(IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR);
-    for (String name : indexedVecNames) {
-      FieldSetting setting = fieldSettings.get(name, true);
-      setting.storeTermVector = true;
-      setting.indexed = true;
-    }
-    Collection<String> payloadNames = sourceIndexReader.getFieldNames(IndexReader.FieldOption.STORES_PAYLOADS);
-    for (String name : payloadNames) {
-      FieldSetting setting = fieldSettings.get(name, true);
-      setting.storePayloads = true;
-    }
-    Collection<String> termVecNames = sourceIndexReader.getFieldNames(IndexReader.FieldOption.TERMVECTOR);
-    for (String name : termVecNames) {
-      FieldSetting setting = fieldSettings.get(name, true);
-      setting.storeTermVector = true;
-    }
-    Collection<String> termVecOffsetNames = sourceIndexReader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET);
-    for (String name : termVecOffsetNames) {
-      FieldSetting setting = fieldSettings.get(name, true);
+    // load field infos
+    for(FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(sourceIndexReader)) {
+      FieldSetting setting = fieldSettings.get(fieldInfo.name, true);
+      setting.indexed = fieldInfo.isIndexed;
+      setting.storeTermVector = fieldInfo.storeTermVector;
       setting.storeOffsetWithTermVector = true;
-    }
-    Collection<String> termVecPosNames = sourceIndexReader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION);
-    for (String name : termVecPosNames) {
-      FieldSetting setting = fieldSettings.get(name, true);
       setting.storePositionWithTermVector = true;
+      setting.storePayloads = fieldInfo.storePayloads;
     }
-    Collection<String> termVecPosOffNames = sourceIndexReader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET);
-    for (String name : termVecPosOffNames) {
-      FieldSetting setting = fieldSettings.get(name, true);
-      setting.storeOffsetWithTermVector = true;
-      setting.storePositionWithTermVector = true;
-    }
-    Collection<String> unindexedNames = sourceIndexReader.getFieldNames(IndexReader.FieldOption.UNINDEXED);
-    for (String name : unindexedNames) {
-      FieldSetting setting = fieldSettings.get(name, true);
-      setting.indexed = false;
-    }
 
-
     documentsByNumber = new InstantiatedDocument[sourceIndexReader.maxDoc()];
 
     if (sourceIndexReader.hasDeletions()) {
@@ -204,17 +186,17 @@
       }
     }
 
-
-
     // create norms
-    for (String fieldName : allFieldNames) {
+    for (FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(sourceIndexReader)) {
+      String fieldName = fieldInfo.name;
       if (fields == null || fields.contains(fieldName)) {
         getNormsByFieldNameAndDocumentNumber().put(fieldName, sourceIndexReader.norms(fieldName));
       }
     }
 
     // create terms
-    for (String fieldName : allFieldNames) {
+    for (FieldInfo fieldInfo : ReaderUtil.getMergedFieldInfos(sourceIndexReader)) {
+      String fieldName = fieldInfo.name;
       if (fields == null || fields.contains(fieldName)) {
         getTermsByFieldAndText().put(fieldName, new HashMap<String, InstantiatedTerm>(5000));
       }
@@ -269,15 +251,13 @@
         continue; // deleted
       }
       for (Fieldable field : document.getDocument().getFields()) {
-        if (field.isTermVectorStored() && field.isStoreOffsetWithTermVector()) {
-          TermPositionVector termPositionVector = (TermPositionVector) sourceIndexReader.getTermFreqVector(document.getDocumentNumber(), field.name());
-          if (termPositionVector != null) {
-            for (int i = 0; i < termPositionVector.getTerms().length; i++) {
-              String token = termPositionVector.getTerms()[i];
-              InstantiatedTerm term = findTerm(field.name(), token);
-              InstantiatedTermDocumentInformation termDocumentInformation = term.getAssociatedDocument(document.getDocumentNumber());
-              termDocumentInformation.setTermOffsets(termPositionVector.getOffsets(i));
-            }
+        TermPositionVector termPositionVector = (TermPositionVector) sourceIndexReader.getTermFreqVector(document.getDocumentNumber(), field.name());
+        if (termPositionVector != null) {
+          for (int i = 0; i < termPositionVector.getTerms().length; i++) {
+            String token = termPositionVector.getTerms()[i];
+            InstantiatedTerm term = findTerm(field.name(), token);
+            InstantiatedTermDocumentInformation termDocumentInformation = term.getAssociatedDocument(document.getDocumentNumber());
+            termDocumentInformation.setTermOffsets(termPositionVector.getOffsets(i));
           }
         }
       }
Index: lucene/contrib/misc/src/java/org/apache/lucene/index/IndexSorter.java
===================================================================
--- lucene/contrib/misc/src/java/org/apache/lucene/index/IndexSorter.java	(revision 1228924)
+++ lucene/contrib/misc/src/java/org/apache/lucene/index/IndexSorter.java	(working copy)
@@ -26,6 +26,7 @@
 import org.apache.lucene.document.*;
 import org.apache.lucene.index.IndexWriter;       // javadocs
 import org.apache.lucene.store.*;
+import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util.Version;
 
 /** Sort an index by document importance factor. Higher scoring documents are
@@ -195,6 +196,11 @@
     }
 
     @Override
+    public FieldInfos getFieldInfos() {
+      return ReaderUtil.getMergedFieldInfos(in);
+    }
+
+    @Override
     public Document document(int n, FieldSelector fieldSelector)
         throws CorruptIndexException, IOException {
       return super.document(newToOld[n], fieldSelector);
Index: lucene/contrib/queries/src/java/org/apache/lucene/search/similar/MoreLikeThis.java
===================================================================
--- lucene/contrib/queries/src/java/org/apache/lucene/search/similar/MoreLikeThis.java	(revision 1228924)
+++ lucene/contrib/queries/src/java/org/apache/lucene/search/similar/MoreLikeThis.java	(working copy)
@@ -19,7 +19,6 @@
 import java.io.FileReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
-import java.io.PrintStream;
 import java.io.Reader;
 import java.io.StringReader;
 import java.net.URL;
@@ -41,14 +40,11 @@
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.DefaultSimilarity;
-import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.Similarity;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.store.FSDirectory;
 import org.apache.lucene.util.PriorityQueue;
+import org.apache.lucene.util.ReaderUtil;
 import org.apache.lucene.util.Version;
 
 /**
@@ -621,8 +617,7 @@
   public Query like(int docNum) throws IOException {
     if (fieldNames == null) {
       // gather list of valid fields from lucene
-      Collection<String> fields = ir
-          .getFieldNames(IndexReader.FieldOption.INDEXED);
+      Collection<String> fields = ReaderUtil.getIndexedFields(ir);
       fieldNames = fields.toArray(new String[fields.size()]);
     }
     
@@ -638,8 +633,7 @@
   public Query like(File f) throws IOException {
     if (fieldNames == null) {
       // gather list of valid fields from lucene
-      Collection<String> fields = ir
-          .getFieldNames(IndexReader.FieldOption.INDEXED);
+      Collection<String> fields = ReaderUtil.getIndexedFields(ir);
       fieldNames = fields.toArray(new String[fields.size()]);
     }
     
Index: lucene/backwards/src/test/org/apache/lucene/index/TestSegmentMerger.java
===================================================================
--- lucene/backwards/src/test/org/apache/lucene/index/TestSegmentMerger.java	(revision 1228924)
+++ lucene/backwards/src/test/org/apache/lucene/index/TestSegmentMerger.java	(working copy)
@@ -28,7 +28,6 @@
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 
 import java.io.IOException;
-import java.util.Collection;
 
 public class TestSegmentMerger extends LuceneTestCase {
   //The variables for the new merged segment
@@ -102,11 +101,6 @@
     assertTrue(termDocs != null);
     assertTrue(termDocs.next() == true);
     
-    Collection<String> stored = mergedReader.getFieldNames(IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR);
-    assertTrue(stored != null);
-    //System.out.println("stored size: " + stored.size());
-    assertTrue("We do not have 3 fields that were indexed with term vector",stored.size() == 3);
-    
     TermFreqVector vector = mergedReader.getTermFreqVector(0, DocHelper.TEXT_FIELD_2_KEY);
     assertTrue(vector != null);
     String [] terms = vector.getTerms();
Index: lucene/backwards/src/test/org/apache/lucene/index/TestIndexReader.java
===================================================================
--- lucene/backwards/src/test/org/apache/lucene/index/TestIndexReader.java	(revision 1228924)
+++ lucene/backwards/src/test/org/apache/lucene/index/TestIndexReader.java	(working copy)
@@ -38,7 +38,6 @@
 import org.apache.lucene.document.FieldSelector;
 import org.apache.lucene.document.Fieldable;
 import org.apache.lucene.document.SetBasedFieldSelector;
-import org.apache.lucene.index.IndexReader.FieldOption;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.search.FieldCache;
 import org.apache.lucene.store.AlreadyClosedException;
@@ -152,13 +151,6 @@
 
         writer.close();
         // set up reader
-        IndexReader reader = IndexReader.open(d, false);
-        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);
-        assertTrue(fieldNames.contains("keyword"));
-        assertTrue(fieldNames.contains("text"));
-        assertTrue(fieldNames.contains("unindexed"));
-        assertTrue(fieldNames.contains("unstored"));
-        reader.close();
         // add more documents
         writer = new IndexWriter(
             d,
@@ -197,62 +189,6 @@
         }
         
         writer.close();
-        // verify fields again
-        reader = IndexReader.open(d, false);
-        fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);
-        assertEquals(13, fieldNames.size());    // the following fields
-        assertTrue(fieldNames.contains("keyword"));
-        assertTrue(fieldNames.contains("text"));
-        assertTrue(fieldNames.contains("unindexed"));
-        assertTrue(fieldNames.contains("unstored"));
-        assertTrue(fieldNames.contains("keyword2"));
-        assertTrue(fieldNames.contains("text2"));
-        assertTrue(fieldNames.contains("unindexed2"));
-        assertTrue(fieldNames.contains("unstored2"));
-        assertTrue(fieldNames.contains("tvnot"));
-        assertTrue(fieldNames.contains("termvector"));
-        assertTrue(fieldNames.contains("tvposition"));
-        assertTrue(fieldNames.contains("tvoffset"));
-        assertTrue(fieldNames.contains("tvpositionoffset"));
-        
-        // verify that only indexed fields were returned
-        fieldNames = reader.getFieldNames(IndexReader.FieldOption.INDEXED);
-        assertEquals(11, fieldNames.size());    // 6 original + the 5 termvector fields 
-        assertTrue(fieldNames.contains("keyword"));
-        assertTrue(fieldNames.contains("text"));
-        assertTrue(fieldNames.contains("unstored"));
-        assertTrue(fieldNames.contains("keyword2"));
-        assertTrue(fieldNames.contains("text2"));
-        assertTrue(fieldNames.contains("unstored2"));
-        assertTrue(fieldNames.contains("tvnot"));
-        assertTrue(fieldNames.contains("termvector"));
-        assertTrue(fieldNames.contains("tvposition"));
-        assertTrue(fieldNames.contains("tvoffset"));
-        assertTrue(fieldNames.contains("tvpositionoffset"));
-        
-        // verify that only unindexed fields were returned
-        fieldNames = reader.getFieldNames(IndexReader.FieldOption.UNINDEXED);
-        assertEquals(2, fieldNames.size());    // the following fields
-        assertTrue(fieldNames.contains("unindexed"));
-        assertTrue(fieldNames.contains("unindexed2"));
-                
-        // verify index term vector fields  
-        fieldNames = reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR);
-        assertEquals(1, fieldNames.size());    // 1 field has term vector only
-        assertTrue(fieldNames.contains("termvector"));
-        
-        fieldNames = reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION);
-        assertEquals(1, fieldNames.size());    // 4 fields are indexed with term vectors
-        assertTrue(fieldNames.contains("tvposition"));
-        
-        fieldNames = reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET);
-        assertEquals(1, fieldNames.size());    // 4 fields are indexed with term vectors
-        assertTrue(fieldNames.contains("tvoffset"));
-                
-        fieldNames = reader.getFieldNames(IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET);
-        assertEquals(1, fieldNames.size());    // 4 fields are indexed with term vectors
-        assertTrue(fieldNames.contains("tvpositionoffset"));
-        reader.close();
         d.close();
     }
 
@@ -825,35 +761,6 @@
         assertEquals("Single segment test differs.", index1.getSequentialSubReaders().length == 1, index2.getSequentialSubReaders().length == 1);
       }
       
-      // check field names
-      Collection<String> fields1 = index1.getFieldNames(FieldOption.ALL);
-      Collection<String> fields2 = index1.getFieldNames(FieldOption.ALL);
-      assertEquals("IndexReaders have different numbers of fields.", fields1.size(), fields2.size());
-      Iterator<String> it1 = fields1.iterator();
-      Iterator<String> it2 = fields1.iterator();
-      while (it1.hasNext()) {
-        assertEquals("Different field names.", it1.next(), it2.next());
-      }
-      
-      // check norms
-      it1 = fields1.iterator();
-      while (it1.hasNext()) {
-        String curField = it1.next();
-        byte[] norms1 = index1.norms(curField);
-        byte[] norms2 = index2.norms(curField);
-        if (norms1 != null && norms2 != null)
-        {
-          assertEquals(norms1.length, norms2.length);
-	        for (int i = 0; i < norms1.length; i++) {
-	          assertEquals("Norm different for doc " + i + " and field '" + curField + "'.", norms1[i], norms2[i]);
-	        }
-        }
-        else
-        {
-          assertSame(norms1, norms2);
-        }
-      }
-      
       // check deletions
       for (int i = 0; i < index1.maxDoc(); i++) {
         assertEquals("Doc " + i + " only deleted in one index.", index1.isDeleted(i), index2.isDeleted(i));
Index: lucene/backwards/src/test/org/apache/lucene/index/TestFieldsReader.java
===================================================================
--- lucene/backwards/src/test/org/apache/lucene/index/TestFieldsReader.java	(revision 1228924)
+++ lucene/backwards/src/test/org/apache/lucene/index/TestFieldsReader.java	(working copy)
@@ -91,24 +91,18 @@
     assertTrue(field != null);
     assertTrue(field.isTermVectorStored() == true);
 
-    assertTrue(field.isStoreOffsetWithTermVector() == true);
-    assertTrue(field.isStorePositionWithTermVector() == true);
     assertTrue(field.getOmitNorms() == false);
     assertTrue(field.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
 
     field = doc.getField(DocHelper.TEXT_FIELD_3_KEY);
     assertTrue(field != null);
     assertTrue(field.isTermVectorStored() == false);
-    assertTrue(field.isStoreOffsetWithTermVector() == false);
-    assertTrue(field.isStorePositionWithTermVector() == false);
     assertTrue(field.getOmitNorms() == true);
     assertTrue(field.getIndexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
 
     field = doc.getField(DocHelper.NO_TF_KEY);
     assertTrue(field != null);
     assertTrue(field.isTermVectorStored() == false);
-    assertTrue(field.isStoreOffsetWithTermVector() == false);
-    assertTrue(field.isStorePositionWithTermVector() == false);
     assertTrue(field.getOmitNorms() == false);
     assertTrue(field.getIndexOptions() == IndexOptions.DOCS_ONLY);
     reader.close();
Index: lucene/backwards/src/test/org/apache/lucene/index/TestParallelReader.java
===================================================================
--- lucene/backwards/src/test/org/apache/lucene/index/TestParallelReader.java	(revision 1228924)
+++ lucene/backwards/src/test/org/apache/lucene/index/TestParallelReader.java	(working copy)
@@ -19,7 +19,6 @@
 
 import java.io.IOException;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.Random;
 
 import org.apache.lucene.analysis.MockAnalyzer;
@@ -76,23 +75,6 @@
     queryTest(bq1);
   }
 
-  public void testFieldNames() throws Exception {
-    Directory dir1 = getDir1(random);
-    Directory dir2 = getDir2(random);
-    ParallelReader pr = new ParallelReader();
-    pr.add(IndexReader.open(dir1, false));
-    pr.add(IndexReader.open(dir2, false));
-    Collection<String> fieldNames = pr.getFieldNames(IndexReader.FieldOption.ALL);
-    assertEquals(4, fieldNames.size());
-    assertTrue(fieldNames.contains("f1"));
-    assertTrue(fieldNames.contains("f2"));
-    assertTrue(fieldNames.contains("f3"));
-    assertTrue(fieldNames.contains("f4"));
-    pr.close();
-    dir1.close();
-    dir2.close();
-  }
-  
   public void testDocument() throws IOException {
     Directory dir1 = getDir1(random);
     Directory dir2 = getDir2(random);
Index: lucene/backwards/src/test/org/apache/lucene/index/TestSegmentReader.java
===================================================================
--- lucene/backwards/src/test/org/apache/lucene/index/TestSegmentReader.java	(revision 1228924)
+++ lucene/backwards/src/test/org/apache/lucene/index/TestSegmentReader.java	(working copy)
@@ -18,8 +18,6 @@
  */
 
 import java.io.IOException;
-import java.util.Collection;
-import java.util.Iterator;
 import java.util.List;
 
 import org.apache.lucene.util.LuceneTestCase;
@@ -87,36 +85,6 @@
     deleteReader.close();
   }    
   
-  public void testGetFieldNameVariations() {
-    Collection<String> result = reader.getFieldNames(IndexReader.FieldOption.ALL);
-    assertTrue(result != null);
-    assertTrue(result.size() == DocHelper.all.size());
-    for (Iterator<String> iter = result.iterator(); iter.hasNext();) {
-      String s =  iter.next();
-      //System.out.println("Name: " + s);
-      assertTrue(DocHelper.nameValues.containsKey(s) == true || s.equals(""));
-    }                                                                               
-    result = reader.getFieldNames(IndexReader.FieldOption.INDEXED);
-    assertTrue(result != null);
-    assertTrue(result.size() == DocHelper.indexed.size());
-    for (Iterator<String> iter = result.iterator(); iter.hasNext();) {
-      String s = iter.next();
-      assertTrue(DocHelper.indexed.containsKey(s) == true || s.equals(""));
-    }
-    
-    result = reader.getFieldNames(IndexReader.FieldOption.UNINDEXED);
-    assertTrue(result != null);
-    assertTrue(result.size() == DocHelper.unindexed.size());
-    //Get all indexed fields that are storing term vectors
-    result = reader.getFieldNames(IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR);
-    assertTrue(result != null);
-    assertTrue(result.size() == DocHelper.termvector.size());
-    
-    result = reader.getFieldNames(IndexReader.FieldOption.INDEXED_NO_TERMVECTOR);
-    assertTrue(result != null);
-    assertTrue(result.size() == DocHelper.notermvector.size());
-  } 
-  
   public void testTerms() throws IOException {
     TermEnum terms = reader.terms();
     assertTrue(terms != null);
