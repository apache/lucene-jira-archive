diff --git a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java
index 97bc230bb5..4c1850ec06 100755
--- a/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java
+++ b/lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java
@@ -49,6 +49,34 @@ public class GeoPolygonFactory {
     return makeGeoPolygon(planetModel, pointList, null);
   }
 
+  /** Create a GeoConcavePolygon using the specified points. The polygon must have
+   * a maximum extent larger than PI. The siding of the polygon is chosen so that any
+   * adjacent point to a segment provides an exterior measurement and therefore,
+   * the polygon is a truly concave polygon. Note that this method should only be used when there is certainty
+   * that we are dealing with a concave polygon, e.g. the polygon has been serialized.
+   * If there is not such certainty, please refer to @{@link GeoPolygonFactory#makeGeoPolygon(PlanetModel, List)}.
+   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.
+   * @return a GeoConcavePolygon corresponding to what was specified.
+   */
+  public static GeoConcavePolygon makeGeoConcavePolygon(final PlanetModel planetModel,
+                                                        final List<GeoPoint> pointList) {
+    return new GeoConcavePolygon(planetModel, pointList);
+  }
+
+  /** Create a GeoConvexPolygon using the specified points. The polygon must have
+   * a maximum extent no larger than PI. The siding of the polygon is chosen so that any  adjacent
+   * point to a segment provides an interior measurement and therefore
+   * the polygon is a truly convex polygon. Note that this method should only be used when
+   * there is certainty that we are dealing with a convex polygon, e.g. the polygon has been serialized.
+   * If there is not such certainty, please refer to @{@link GeoPolygonFactory#makeGeoPolygon(PlanetModel, List)}.
+   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.
+   * @return a GeoConvexPolygon corresponding to what was specified.
+   */
+  public static GeoConvexPolygon makeGeoConvexPolygon(final PlanetModel planetModel,
+                                                      final List<GeoPoint> pointList) {
+    return new GeoConvexPolygon(planetModel, pointList);
+  }
+
   /** Create a GeoPolygon using the specified points and holes, using order to determine 
    * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space
    * on the same side of the shape as being inside, and counter-clockwise to indicate the
@@ -66,6 +94,41 @@ public class GeoPolygonFactory {
     final List<GeoPolygon> holes) {
     return makeGeoPolygon(planetModel, pointList, holes, 0.0);
   }
+
+
+  /** Create a GeoConcavePolygon using the specified points and holes. The polygon must have
+   * a maximum extent larger than PI. The siding of the polygon is chosen so that any  adjacent
+   * point to a segment provides an exterior measurement and therefore
+   * the polygon is a truly concave polygon. Note that this method should only be used when
+   * there is certainty that we are dealing with a concave polygon, e.g. the polygon has been serialized.
+   * If there is not such certainty, please refer to {@link GeoPolygonFactory#makeGeoPolygon(PlanetModel, List, List)}.
+   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.
+   * @param holes is a list of polygons representing "holes" in the outside polygon.  Holes describe the area outside
+   *  each hole as being "in set".  Null == none.
+   * @return a GeoConcavePolygon corresponding to what was specified.
+   */
+  public static GeoConcavePolygon makeGeoConcavePolygon(final PlanetModel planetModel,
+                                                        final List<GeoPoint> pointList,
+                                                        final List<GeoPolygon> holes) {
+    return new GeoConcavePolygon(planetModel,pointList, holes);
+  }
+
+  /** Create a GeoConvexPolygon using the specified points and holes. The polygon must have
+   * a maximum extent no larger than PI. The siding of the polygon is chosen so that any adjacent
+   * point to a segment provides an interior measurement and therefore
+   * the polygon is a truly convex polygon. Note that this method should only be used when
+   * there is certainty that we are dealing with a convex polygon, e.g. the polygon has been serialized.
+   * If there is not such certainty, please refer to {@link GeoPolygonFactory#makeGeoPolygon(PlanetModel, List, List)}.
+   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.
+   * @param holes is a list of polygons representing "holes" in the outside polygon.  Holes describe the area outside
+   *  each hole as being "in set".  Null == none.
+   * @return a GeoConvexPolygon corresponding to what was specified.
+   */
+  public static GeoConvexPolygon makeGeoConvexPolygon(final PlanetModel planetModel,
+                                                      final List<GeoPoint> pointList,
+                                                      final List<GeoPolygon> holes) {
+    return new GeoConvexPolygon(planetModel,pointList, holes);
+  }
   
   /** Create a GeoPolygon using the specified points and holes, using order to determine 
    * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space
diff --git a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPolygonTest.java b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPolygonTest.java
index 8527e99afc..f3ac52bb35 100755
--- a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPolygonTest.java
+++ b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPolygonTest.java
@@ -19,6 +19,7 @@ package org.apache.lucene.spatial3d.geom;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.BitSet;
+import java.util.Collections;
 
 import org.junit.Test;
 import static org.junit.Assert.assertEquals;
@@ -966,5 +967,67 @@ shape:
 
     assertTrue(solid.isWithin(point));
   }
+
+  @Test
+  public void testConcavePolygon() {
+    ArrayList<GeoPoint> points = new ArrayList<>();
+    points.add(new GeoPoint(PlanetModel.SPHERE, -0.1, -0.5));
+    points.add(new GeoPoint(PlanetModel.SPHERE, 0.0, -0.6));
+    points.add(new GeoPoint(PlanetModel.SPHERE, 0.1, -0.5));
+    points.add(new GeoPoint(PlanetModel.SPHERE, 0.0, -0.4));
+    GeoPolygon polygon = (GeoPolygon)((GeoCompositePolygon)GeoPolygonFactory.makeGeoPolygon(PlanetModel.SPHERE, points)).shapes.get(0);
+    GeoPolygon polygonConcave = GeoPolygonFactory.makeGeoConcavePolygon(PlanetModel.SPHERE,points);
+    assertEquals(polygon,polygonConcave);
+  }
+
+  @Test
+  public void testConcavePolygonWithHole() {
+    ArrayList<GeoPoint> points = new ArrayList<>();
+    points.add(new GeoPoint(PlanetModel.SPHERE, -1.1, -1.5));
+    points.add(new GeoPoint(PlanetModel.SPHERE, 1.0, -1.6));
+    points.add(new GeoPoint(PlanetModel.SPHERE, 1.1, -1.5));
+    points.add(new GeoPoint(PlanetModel.SPHERE, 1.0, -1.4));
+    ArrayList<GeoPoint> hole_points = new ArrayList<>();
+    hole_points.add(new GeoPoint(PlanetModel.SPHERE, -0.1, -0.5));
+    hole_points.add(new GeoPoint(PlanetModel.SPHERE, 0.0, -0.6));
+    hole_points.add(new GeoPoint(PlanetModel.SPHERE, 0.1, -0.5));
+    hole_points.add(new GeoPoint(PlanetModel.SPHERE, 0.0, -0.4));
+    GeoPolygon hole = GeoPolygonFactory.makeGeoPolygon(PlanetModel.SPHERE,hole_points);
+
+    GeoPolygon polygon = (GeoPolygon)((GeoCompositePolygon)GeoPolygonFactory.makeGeoPolygon(PlanetModel.SPHERE, points,Collections.singletonList(hole))).shapes.get(0);
+    GeoPolygon polygon2 = GeoPolygonFactory.makeGeoConcavePolygon(PlanetModel.SPHERE,points,Collections.singletonList(hole));
+    assertEquals(polygon,polygon2);
+  }
+
+  @Test
+  public void testConvexPolygon() {
+    ArrayList<GeoPoint> points = new ArrayList<>();
+    points.add(new GeoPoint(PlanetModel.SPHERE, 0, 0));
+    points.add(new GeoPoint(PlanetModel.SPHERE, 0.0, 0.5));
+    points.add(new GeoPoint(PlanetModel.SPHERE, 0.5, 0.5));
+    points.add(new GeoPoint(PlanetModel.SPHERE, 0.5, 0));
+    GeoPolygon polygon = (GeoPolygon)((GeoCompositePolygon)GeoPolygonFactory.makeGeoPolygon(PlanetModel.SPHERE, points)).shapes.get(0);
+    GeoPolygon polygon2 = GeoPolygonFactory.makeGeoConvexPolygon(PlanetModel.SPHERE,points);
+    assertEquals(polygon,polygon2);
+  }
+
+  @Test
+  public void testConvexPolygonWithHole() {
+    ArrayList<GeoPoint> points = new ArrayList<>();
+    points.add(new GeoPoint(PlanetModel.SPHERE, -1, -1));
+    points.add(new GeoPoint(PlanetModel.SPHERE, -1, 1));
+    points.add(new GeoPoint(PlanetModel.SPHERE, 1, 1));
+    points.add(new GeoPoint(PlanetModel.SPHERE, 1, -1));
+    ArrayList<GeoPoint> hole_points = new ArrayList<>();
+    hole_points.add(new GeoPoint(PlanetModel.SPHERE, -0.1, -0.5));
+    hole_points.add(new GeoPoint(PlanetModel.SPHERE, 0.0, -0.6));
+    hole_points.add(new GeoPoint(PlanetModel.SPHERE, 0.1, -0.5));
+    hole_points.add(new GeoPoint(PlanetModel.SPHERE, 0.0, -0.4));
+    GeoPolygon hole = GeoPolygonFactory.makeGeoPolygon(PlanetModel.SPHERE,hole_points);
+
+    GeoPolygon polygon = (GeoPolygon)((GeoCompositePolygon)GeoPolygonFactory.makeGeoPolygon(PlanetModel.SPHERE, points,Collections.singletonList(hole))).shapes.get(0);
+    GeoPolygon polygon2 = GeoPolygonFactory.makeGeoConvexPolygon(PlanetModel.SPHERE,points,Collections.singletonList(hole));
+    assertEquals(polygon,polygon2);
+  }
   
 }
