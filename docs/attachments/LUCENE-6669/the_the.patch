Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 1690113)
+++ lucene/CHANGES.txt	(working copy)
@@ -2824,7 +2824,7 @@
 
 Optimizations
 
-* LUCENE-5225: The ToParentBlockJoinQuery only keeps tracks of the the child
+* LUCENE-5225: The ToParentBlockJoinQuery only keeps tracks of the child
   doc ids and child scores if the ToParentBlockJoinCollector is used.
   (Martijn van Groningen)
 
Index: lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/hyphenation/HyphenationTree.java
===================================================================
--- lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/hyphenation/HyphenationTree.java	(revision 1690113)
+++ lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/hyphenation/HyphenationTree.java	(working copy)
@@ -187,7 +187,7 @@
    * patterns for languages such as English range from 4000 to 10000. Thus,
    * doing thousands of string comparisons for each word to hyphenate would be
    * really slow without the tree. The tradeoff is memory, but using a ternary
-   * tree instead of a trie, almost halves the the memory used by Lout or TeX.
+   * tree instead of a trie, almost halves the memory used by Lout or TeX.
    * It's also faster than using a hash table
    * </p>
    * 
Index: lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java	(revision 1690113)
+++ lucene/core/src/java/org/apache/lucene/index/DocumentsWriterFlushControl.java	(working copy)
@@ -125,7 +125,7 @@
          * several DWPT in flight indexing large documents (compared to the ram
          * buffer). This means that those DWPT and their threads will not hit
          * the stall control before asserting the memory which would in turn
-         * fail. To prevent this we only assert if the the largest document seen
+         * fail. To prevent this we only assert if the largest document seen
          * is smaller than the 1/2 of the maxRamBufferMB
          */
         assert ram <= expected : "actual mem: " + ram + " byte, expected mem: " + expected
Index: lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java	(revision 1690113)
+++ lucene/core/src/java/org/apache/lucene/index/MultiDocValues.java	(working copy)
@@ -488,7 +488,7 @@
 
     // cache key of whoever asked for this awful thing
     final Object owner;
-    // globalOrd -> (globalOrd - segmentOrd) where segmentOrd is the the ordinal in the first segment that contains this term
+    // globalOrd -> (globalOrd - segmentOrd) where segmentOrd is the ordinal in the first segment that contains this term
     final PackedLongValues globalOrdDeltas;
     // globalOrd -> first segment container
     final PackedLongValues firstSegments;
Index: lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java	(revision 1690113)
+++ lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java	(working copy)
@@ -20,7 +20,7 @@
 import java.util.List;
 
 /**
- * The Scorer for DisjunctionMaxQuery.  The union of all documents generated by the the subquery scorers
+ * The Scorer for DisjunctionMaxQuery.  The union of all documents generated by the subquery scorers
  * is generated in document number order.  The score for each document is the maximum of the scores computed
  * by the subquery scorers that generate that document, plus tieBreakerMultiplier times the sum of the scores
  * for the other subqueries that generate the document.
Index: lucene/core/src/java/org/apache/lucene/search/package-info.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/package-info.java	(revision 1690113)
+++ lucene/core/src/java/org/apache/lucene/search/package-info.java	(working copy)
@@ -396,7 +396,7 @@
  *                 document's score. For example, a TermQuery that is wrapped within a BooleanQuery with a boost of <code>5</code> would
  *                 receive this value at this time. This allows the TermQuery (the leaf node in this case) to compute this up-front
  *                 a single time (e.g. by multiplying into the IDF), rather than for every document.</li> 
- *                 <li><code>norm</code>: Passes in a a normalization factor which may
+ *                 <li><code>norm</code>: Passes in a normalization factor which may
  *                 allow for comparing scores between queries.</li>
  *                 </ul>
  *                 Typically a weight such as TermWeight
Index: lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyReader.java
===================================================================
--- lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyReader.java	(revision 1690113)
+++ lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyReader.java	(working copy)
@@ -55,7 +55,7 @@
  * <P>
  * This order is important, otherwise it would be possible for the main index
  * to refer to a category which is not yet visible in the old snapshot of
- * the taxonomy. Note that it is indeed fine for the the taxonomy to be opened
+ * the taxonomy. Note that it is indeed fine for the taxonomy to be opened
  * after the main index - even a long time after. The reason is that once
  * a category is added to the taxonomy, it can never be changed or deleted,
  * so there is no danger that a "too new" taxonomy not being consistent with
Index: lucene/join/src/java/org/apache/lucene/search/join/TermsQuery.java
===================================================================
--- lucene/join/src/java/org/apache/lucene/search/join/TermsQuery.java	(revision 1690113)
+++ lucene/join/src/java/org/apache/lucene/search/join/TermsQuery.java	(working copy)
@@ -140,7 +140,7 @@
       } else {
         if (upto == lastElement) {
           return AcceptStatus.NO;
-        } else { // Our current term doesn't match the the given term.
+        } else { // Our current term doesn't match the given term.
           int cmp;
           do { // We maybe are behind the given term by more than one step. Keep incrementing till we're the same or higher.
             if (upto == lastElement) {
Index: lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiFunction.java
===================================================================
--- lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiFunction.java	(revision 1690113)
+++ lucene/queries/src/java/org/apache/lucene/queries/function/valuesource/MultiFunction.java	(working copy)
@@ -74,7 +74,7 @@
   }
   
   /**
-   * Equivilent the the {@code FunctionValues[]} method with the same name, but optimized for 
+   * Equivalent of the {@code FunctionValues[]} method with the same name, but optimized for 
    * dealing with exactly 2 arguments.
    *
    * @return true if <em>both</em> of the specified <code>values</code>
@@ -86,7 +86,7 @@
   }
   
   /**
-   * Equivilent the the {@code FunctionValues[]} method with the same name, but optimized for 
+   * Equivalent of the {@code FunctionValues[]} method with the same name, but optimized for 
    * dealing with exactly 2 arguments.
    *
    * @return true if <em>either</em> of the specified <code>values</code>
Index: lucene/queryparser/docs/xml/LuceneCoreQuery.dtd.html
===================================================================
--- lucene/queryparser/docs/xml/LuceneCoreQuery.dtd.html	(revision 1690113)
+++ lucene/queryparser/docs/xml/LuceneCoreQuery.dtd.html	(working copy)
@@ -32,7 +32,7 @@
 Unlike Queries, <i>Filters</i> are not used to select or score content - they are simply used to filter <i>Query</i> output (see <a href="#FilteredQuery">FilteredQuery</a> for an example use of query filtering).
 Because Filters simply offer a yes/no decision for each document in the index their output can be efficiently cached in memory as a <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/BitSet.html">Bitset</a> for
 subsequent reuse (see <a href="#CachedFilter">CachedFilter</a> tag).</p><p><h4>Nesting elements</h4>
-Many of the the elements can nest other elements to produce queries/filters of an arbitrary depth and complexity.
+Many of the elements can nest other elements to produce queries/filters of an arbitrary depth and complexity.
 The <a href="#BooleanQuery">BooleanQuery</a> element is one such example which provides a means for combining other queries (including other BooleanQueries) using Boolean
 logic to determine mandatory or optional elements.</p><p><h3>Advanced topics</h3>
 <h4>Advanced positional testing - span queries</h4>
Index: lucene/queryparser/docs/xml/LuceneCoreQuery.dtd.org.html
===================================================================
--- lucene/queryparser/docs/xml/LuceneCoreQuery.dtd.org.html	(revision 1690113)
+++ lucene/queryparser/docs/xml/LuceneCoreQuery.dtd.org.html	(working copy)
@@ -41,7 +41,7 @@
 <span class="dtd_comment">    subsequent reuse (see &lt;a href=&quot;#CachedFilter&quot;&gt;CachedFilter&lt;/a&gt; tag).</span>
 
 <span class="dtd_comment">    &lt;h4&gt;Nesting elements&lt;/h4&gt;</span>
-<span class="dtd_comment">    Many of the the elements can nest other elements to produce queries/filters of an arbitrary depth and complexity. </span>
+<span class="dtd_comment">    Many of the elements can nest other elements to produce queries/filters of an arbitrary depth and complexity. </span>
 <span class="dtd_comment">    The &lt;a href=&quot;#BooleanQuery&quot;&gt;BooleanQuery&lt;/a&gt; element is one such example which provides a means for combining other queries (including other BooleanQueries) using Boolean </span>
 <span class="dtd_comment">    logic to determine mandatory or optional elements. </span>
 
Index: lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNodeImpl.java
===================================================================
--- lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNodeImpl.java	(revision 1690113)
+++ lucene/queryparser/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNodeImpl.java	(working copy)
@@ -199,7 +199,7 @@
   }
 
   /**
-   * If set to true the the method toQueryString will not write field names
+   * If set to true the method toQueryString will not write field names
    */
   protected boolean toQueryStringIgnoreFields = false;
 
Index: lucene/queryparser/src/resources/org/apache/lucene/queryparser/xml/LuceneCoreQuery.dtd
===================================================================
--- lucene/queryparser/src/resources/org/apache/lucene/queryparser/xml/LuceneCoreQuery.dtd	(revision 1690113)
+++ lucene/queryparser/src/resources/org/apache/lucene/queryparser/xml/LuceneCoreQuery.dtd	(working copy)
@@ -35,7 +35,7 @@
 	subsequent reuse (see <a href="#CachedFilter">CachedFilter</a> tag).
 
 	<h4>Nesting elements</h4>
-	Many of the the elements can nest other elements to produce queries/filters of an arbitrary depth and complexity. 
+	Many of the elements can nest other elements to produce queries/filters of an arbitrary depth and complexity. 
 	The <a href="#BooleanQuery">BooleanQuery</a> element is one such example which provides a means for combining other queries (including other BooleanQueries) using Boolean 
 	logic to determine mandatory or optional elements. 
 
Index: lucene/site/changes/changes2html.pl
===================================================================
--- lucene/site/changes/changes2html.pl	(revision 1690113)
+++ lucene/site/changes/changes2html.pl	(working copy)
@@ -622,7 +622,7 @@
 #
 # Returns one scalar:
 #
-#   - text with the the trailing attribution, if any, marked up with the color green
+#   - text with the trailing attribution, if any, marked up with the color green
 #
 sub markup_trailing_attribution {
   my $item = shift;
Index: lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FreeTextSuggester.java
===================================================================
--- lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FreeTextSuggester.java	(revision 1690113)
+++ lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FreeTextSuggester.java	(working copy)
@@ -116,10 +116,10 @@
   /** Codec name used in the header for the saved model. */
   public final static String CODEC_NAME = "freetextsuggest";
 
-  /** Initial version of the the saved model file format. */
+  /** Initial version of the saved model file format. */
   public final static int VERSION_START = 0;
 
-  /** Current version of the the saved model file format. */
+  /** Current version of the saved model file format. */
   public final static int VERSION_CURRENT = VERSION_START;
 
   /** By default we use a bigram model. */
Index: solr/CHANGES.txt
===================================================================
--- solr/CHANGES.txt	(revision 1690113)
+++ solr/CHANGES.txt	(working copy)
@@ -6831,7 +6831,7 @@
 
 * SOLR-2605: fixed tracking of the 'defaultCoreName' in CoreContainer so that
   CoreAdminHandler could return consistent information regardless of whether
-  there is a a default core name or not. (steffkes, hossman)
+  there is a default core name or not. (steffkes, hossman)
 
 * SOLR-3370: fixed CSVResponseWriter to respect globs in the 'fl' param
   (Keith Fligg via hossman)
@@ -10082,7 +10082,7 @@
 have been affected by indexing inconsistent formats of equivilent
 dates (ie: 1995-12-31T23:59:59Z vs 1995-12-31T23:59:59.000Z) may want
 to consider reindexing to correct these inconsistencies.  Users who
-depend on some of the the "broken" behavior of DateField in Solr 1.2
+depend on some of the "broken" behavior of DateField in Solr 1.2
 (specificly: accepting any input that ends in a 'Z') should consider
 using the LegacyDateField class as a possible alternative.  Users that
 desire 100% backwards compatibility should consider using the Solr 1.2
@@ -11052,7 +11052,7 @@
     possible for path based request handlers.  (ryan)
 
 14. SOLR-214: Some servlet containers (including Tomcat and Resin) do not
-    obey the specified charset.  Rather then letting the the container handle 
+    obey the specified charset.  Rather then letting the container handle 
     it solr now uses the charset from the header contentType to decode posted
     content.  Using the contentType: "text/xml; charset=utf-8" will force
     utf-8 encoding.  If you do not specify a contentType, it will use the 
Index: solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImporter.java
===================================================================
--- solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImporter.java	(revision 1690113)
+++ solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DataImporter.java	(working copy)
@@ -192,7 +192,7 @@
     try {
       DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
       
-      // only enable xinclude, if a a SolrCore and SystemId is present (makes no sense otherwise)
+      // only enable xinclude, if a SolrCore and SystemId is present (makes no sense otherwise)
       if (core != null && configFile.getSystemId() != null) {
         try {
           dbf.setXIncludeAware(true);
Index: solr/contrib/map-reduce/src/java/org/apache/solr/hadoop/HeartBeater.java
===================================================================
--- solr/contrib/map-reduce/src/java/org/apache/solr/hadoop/HeartBeater.java	(revision 1690113)
+++ solr/contrib/map-reduce/src/java/org/apache/solr/hadoop/HeartBeater.java	(working copy)
@@ -121,7 +121,7 @@
   public synchronized void needHeartBeat() {
     threadsNeedingHeartBeat++;
     // Issue a progress report right away,
-    // just in case the the cancel comes before the background thread issues a
+    // just in case the cancel comes before the background thread issues a
     // report.
     // If enough cases like this happen the 600 second timeout can occur
     progress.progress();
Index: solr/contrib/map-reduce/src/java/org/apache/solr/hadoop/SolrOutputFormat.java
===================================================================
--- solr/contrib/map-reduce/src/java/org/apache/solr/hadoop/SolrOutputFormat.java	(revision 1690113)
+++ solr/contrib/map-reduce/src/java/org/apache/solr/hadoop/SolrOutputFormat.java	(working copy)
@@ -99,7 +99,7 @@
   }
 
   /**
-   * Set the maximum size of the the queue for documents to be written to the
+   * Set the maximum size of the queue for documents to be written to the
    * index.
    */
   public static void setSolrWriterQueueSize(int count, Configuration conf) {
Index: solr/core/src/java/org/apache/solr/core/SolrConfig.java
===================================================================
--- solr/core/src/java/org/apache/solr/core/SolrConfig.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/core/SolrConfig.java	(working copy)
@@ -94,7 +94,7 @@
 
 /**
  * Provides a static reference to a Config object modeling the main
- * configuration data for a a Solr instance -- typically found in
+ * configuration data for a Solr instance -- typically found in
  * "solrconfig.xml".
  */
 public class SolrConfig extends Config implements MapSerializable {
Index: solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java
===================================================================
--- solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/handler/ReplicationHandler.java	(working copy)
@@ -1670,7 +1670,7 @@
    * Boolean param for tests that can be specified when using
    * {@link #CMD_FETCH_INDEX} to force the current request to block until
    * the fetch is complete.  <b>NOTE:</b> This param is not advised for
-   * non-test code, since the the duration of the fetch for non-trivial
+   * non-test code, since the duration of the fetch for non-trivial
    * indexes will likeley cause the request to time out.
    *
    * @lucene.internal
Index: solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java
===================================================================
--- solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java	(working copy)
@@ -262,7 +262,7 @@
   }
   
   /**
-   * Subclasses could modify the Response based on the the shard
+   * Subclasses could modify the Response based on the shard
    */
   protected ShardResponse transfomResponse(final ShardRequest sreq, ShardResponse rsp, String shard)
   {
Index: solr/core/src/java/org/apache/solr/handler/component/PivotFacetFieldValueCollection.java
===================================================================
--- solr/core/src/java/org/apache/solr/handler/component/PivotFacetFieldValueCollection.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/handler/component/PivotFacetFieldValueCollection.java	(working copy)
@@ -72,7 +72,7 @@
   }
 
   /**
-   * The {@link PivotFacetValue} with corisponding to a a value of 
+   * The {@link PivotFacetValue} with corresponding to a value of 
    * <code>null</code> when {@link FacetParams#FACET_MISSING} is used.
    * 
    * @return the appropriate <code>PivotFacetValue</code> object, may be null 
Index: solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.java
===================================================================
--- solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/handler/component/StatsValuesFactory.java	(working copy)
@@ -261,7 +261,7 @@
   public void accumulate(BytesRef value, int count) {
     if (null == ft) {
       throw new IllegalStateException(
-          "Can't collect & convert BytesRefs on stats that do't use a a FieldType: "
+          "Can't collect & convert BytesRefs on stats that don't use a FieldType: "
               + statsField);
     }
     T typedValue = (T) ft.toObject(sf, value);
Index: solr/core/src/java/org/apache/solr/internal/csv/writer/CSVConfig.java
===================================================================
--- solr/core/src/java/org/apache/solr/internal/csv/writer/CSVConfig.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/internal/csv/writer/CSVConfig.java	(working copy)
@@ -37,7 +37,7 @@
 
     /** Do no do any filling **/
     public static final int FILLNONE = 0;
-    /** Fill content the the left. Mainly usable together with fixedWidth **/
+    /** Fill content to the left. Mainly usable together with fixedWidth **/
     public static final int FILLLEFT = 1;
     /** Fill content to the right. Mainly usable together with fixedWidth **/
     public static final int FILLRIGHT = 2;
Index: solr/core/src/java/org/apache/solr/schema/CurrencyField.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/CurrencyField.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/schema/CurrencyField.java	(working copy)
@@ -263,7 +263,7 @@
    * after converting each document's native currency to USD -- because the 
    * default fractional digits for <code>USD</code> is "<code>2</code>".  
    * So for a document whose indexed value was currently equivilent to 
-   * "<code>5.43,USD</code>" using the the exchange provider for this field, 
+   * "<code>5.43,USD</code>" using the exchange provider for this field, 
    * this ValueSource would return a value of "<code>543</code>"
    * </p>
    *
@@ -291,7 +291,7 @@
    * represent the equivilent number of dollars after converting each 
    * document's raw value to <code>USD</code>.  So for a document whose 
    * indexed value was currently equivilent to "<code>5.43,USD</code>" 
-   * using the the exchange provider for this field, this ValueSource would 
+   * using the exchange provider for this field, this ValueSource would 
    * return a value of "<code>5.43</code>"
    * </p>
    *
Index: solr/core/src/java/org/apache/solr/servlet/DirectSolrConnection.java
===================================================================
--- solr/core/src/java/org/apache/solr/servlet/DirectSolrConnection.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/servlet/DirectSolrConnection.java	(working copy)
@@ -43,7 +43,7 @@
 
 /**
  * DirectSolrConnection provides an interface to Solr that is similar to
- * the the HTTP interface, but does not require an HTTP connection.
+ * the HTTP interface, but does not require an HTTP connection.
  * 
  * This class is designed to be as simple as possible and allow for more flexibility
  * in how you interface to Solr.
Index: solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java
===================================================================
--- solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java	(working copy)
@@ -465,7 +465,7 @@
       }
     } catch (Throwable ex) {
       sendError(ex);
-      // walk the the entire cause chain to search for an Error
+      // walk the entire cause chain to search for an Error
       Throwable t = ex;
       while (t != null) {
         if (t instanceof Error) {
Index: solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2.java
===================================================================
--- solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2.java	(working copy)
@@ -251,7 +251,7 @@
             // Add to the transaction log *after* successfully adding to the
             // index, if there was no error.
             // This ordering ensures that if we log it, it's definitely been
-            // added to the the index.
+            // added to the index.
             // This also ensures that if a commit sneaks in-between, that we
             // know everything in a particular
             // log version was definitely committed.
Index: solr/core/src/java/org/apache/solr/update/processor/CountFieldValuesUpdateProcessorFactory.java
===================================================================
--- solr/core/src/java/org/apache/solr/update/processor/CountFieldValuesUpdateProcessorFactory.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/update/processor/CountFieldValuesUpdateProcessorFactory.java	(working copy)
@@ -34,7 +34,7 @@
 /**
  * <p>
  * Replaces any list of values for a field matching the specified 
- * conditions with the the count of the number of values for that field.
+ * conditions with the count of the number of values for that field.
  * </p>
  * <p>
  * By default, this processor matches no fields.
Index: solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.java
===================================================================
--- solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/update/processor/DocBasedVersionConstraintsProcessorFactory.java	(working copy)
@@ -241,7 +241,7 @@
 
 
     /**
-     * Returns true if the specified new version value is greater the the one
+     * Returns true if the specified new version value is greater than one
      * already known to exist for the document, or the document does not already
      * exist.
      * Returns false if the specified new version is not high enough but the
Index: solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.java
===================================================================
--- solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.java	(working copy)
@@ -97,7 +97,7 @@
  *  </li>
  *  <li><code>ttlParamName</code> - Name of an update request param this process should 
  *      look for in each request when processing document additions, defaulting to  
- *      <code>_ttl_</code>. If the the specified param name exists in an update request, 
+ *      <code>_ttl_</code>. If the specified param name exists in an update request, 
  *      the param value will be parsed as a {@linkplain DateMathParser Date Math Expression}
  *      relative to <code>NOW</code> and the result will be used as a default for any 
  *      document included in that request that does not already have a value in the 
@@ -348,7 +348,7 @@
 
   /**
    * <p>
-   * Runnable that uses the the <code>deleteChainName</code> configured for 
+   * Runnable that uses the <code>deleteChainName</code> configured for 
    * this factory to execute a delete by query (using the configured 
    * <code>expireField</code>) followed by a soft commit to re-open searchers (if needed)
    * </p>
Index: solr/core/src/java/org/apache/solr/update/processor/MaxFieldValueUpdateProcessorFactory.java
===================================================================
--- solr/core/src/java/org/apache/solr/update/processor/MaxFieldValueUpdateProcessorFactory.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/update/processor/MaxFieldValueUpdateProcessorFactory.java	(working copy)
@@ -28,7 +28,7 @@
 import java.util.Iterator;
 
 /**
- * An update processor that keeps only the the maximum value from any selected 
+ * An update processor that keeps only the maximum value from any selected 
  * fields where multiple values are found.  Correct behavior requires tha all 
  * of the values in the SolrInputFields being mutated are mutually comparable; 
  * If this is not the case, then a SolrException will br thrown. 
Index: solr/core/src/java/org/apache/solr/update/processor/MinFieldValueUpdateProcessorFactory.java
===================================================================
--- solr/core/src/java/org/apache/solr/update/processor/MinFieldValueUpdateProcessorFactory.java	(revision 1690113)
+++ solr/core/src/java/org/apache/solr/update/processor/MinFieldValueUpdateProcessorFactory.java	(working copy)
@@ -28,7 +28,7 @@
 import java.util.Iterator;
 
 /**
- * An update processor that keeps only the the minimum value from any selected 
+ * An update processor that keeps only the minimum value from any selected 
  * fields where multiple values are found.   Correct behavior requires tha all 
  * of the values in the SolrInputFields being mutated are mutually comparable; 
  * If this is not the case, then a SolrException will br thrown. 
Index: solr/licenses/jackson-jaxrs-LICENSE-ASL.txt
===================================================================
--- solr/licenses/jackson-jaxrs-LICENSE-ASL.txt	(revision 1690113)
+++ solr/licenses/jackson-jaxrs-LICENSE-ASL.txt	(working copy)
@@ -7,7 +7,7 @@
 
 http://www.apache.org/licenses/
 
-A copy is also included with both the the downloadable source code package
+A copy is also included with both the downloadable source code package
 and jar that contains class bytecodes, as file "ASL 2.0". In both cases,
 that file should be located next to this file: in source distribution
-the location should be "release-notes/asl"; and in jar "META-INF/"
\ No newline at end of file
+the location should be "release-notes/asl"; and in jar "META-INF/"
Index: solr/licenses/woodstox-core-asl-NOTICE.txt
===================================================================
--- solr/licenses/woodstox-core-asl-NOTICE.txt	(revision 1690113)
+++ solr/licenses/woodstox-core-asl-NOTICE.txt	(working copy)
@@ -30,7 +30,7 @@
 
 http://www.apache.org/licenses/
 
-A copy is also included with both the the downloadable source code package
+A copy is also included with both the downloadable source code package
 and jar that contains class bytecodes, as file "ASL 2.0". In both cases,
 that file should be located next to this file: in source distribution
 the location should be "release-notes/asl"; and in jar "META-INF/"
Index: solr/server/solr/configsets/sample_techproducts_configs/conf/velocity/jquery.autocomplete.js
===================================================================
--- solr/server/solr/configsets/sample_techproducts_configs/conf/velocity/jquery.autocomplete.js	(revision 1690113)
+++ solr/server/solr/configsets/sample_techproducts_configs/conf/velocity/jquery.autocomplete.js	(working copy)
@@ -357,7 +357,7 @@
 				}
 			});
 		} else {
-			// if we have a failure, we need to empty the list -- this prevents the the [TAB] key from selecting the last successful match
+			// if we have a failure, we need to empty the list -- this prevents the [TAB] key from selecting the last successful match
 			select.emptyList();
 			failure(term);
 		}
@@ -760,4 +760,4 @@
 	field.focus();
 };
 
-})(jQuery);
\ No newline at end of file
+})(jQuery);
Index: solr/solrj/src/java/org/apache/solr/client/solrj/response/AnalysisResponseBase.java
===================================================================
--- solr/solrj/src/java/org/apache/solr/client/solrj/response/AnalysisResponseBase.java	(revision 1690113)
+++ solr/solrj/src/java/org/apache/solr/client/solrj/response/AnalysisResponseBase.java	(working copy)
@@ -171,7 +171,7 @@
      * @param start    The start position of the token in the original text where it was extracted from.
      * @param end      The end position of the token in the original text where it was extracted from.
      * @param position The position of the token within the token stream.
-     * @param match    Indicates whether this token matches one of the the query tokens.
+     * @param match    Indicates whether this token matches one of the query tokens.
      */
     TokenInfo(String text, String rawText, String type, int start, int end, int position, boolean match) {
       this.text = text;
Index: solr/solrj/src/java/org/apache/solr/common/params/FacetParams.java
===================================================================
--- solr/solrj/src/java/org/apache/solr/common/params/FacetParams.java	(revision 1690113)
+++ solr/solrj/src/java/org/apache/solr/common/params/FacetParams.java	(working copy)
@@ -210,7 +210,7 @@
   /**
    * <p>
    * Multivalued string indicating what rules should be applied to determine 
-   * when the the ranges generated for date faceting should be inclusive or 
+   * when the ranges generated for date faceting should be inclusive or 
    * exclusive of their end points.
    * </p>
    * <p>
@@ -269,7 +269,7 @@
   /**
    * <p>
    * Multivalued string indicating what rules should be applied to determine 
-   * when the the ranges generated for numeric faceting should be inclusive or 
+   * when the ranges generated for numeric faceting should be inclusive or 
    * exclusive of their end points.
    * </p>
    * <p>
Index: solr/solrj/src/java/org/apache/solr/common/util/NamedList.java
===================================================================
--- solr/solrj/src/java/org/apache/solr/common/util/NamedList.java	(revision 1690113)
+++ solr/solrj/src/java/org/apache/solr/common/util/NamedList.java	(working copy)
@@ -278,7 +278,7 @@
   }
 
   /**
-   * Gets the values for the the specified name
+   * Gets the values for the specified name
    *
    * @param name Name
    * @return List of values
