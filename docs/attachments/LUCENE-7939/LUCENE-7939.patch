diff --git a/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java b/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java
index b6edac4..7ada1ed 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java
@@ -128,7 +128,12 @@ final class MinShouldMatchSumScorer extends Scorer {
 
   @Override
   public DocIdSetIterator iterator() {
-    return new DocIdSetIterator() {
+    return TwoPhaseIterator.asDocIdSetIterator(twoPhaseIterator());
+  }
+
+  @Override
+  public TwoPhaseIterator twoPhaseIterator() {
+    DocIdSetIterator approximation = new DocIdSetIterator() {
 
       @Override
       public int docID() {
@@ -154,6 +159,12 @@ final class MinShouldMatchSumScorer extends Scorer {
         }
 
         setDocAndFreq();
+        // It would be correct to return doNextCandidate() at this point but if you
+        // call nextDoc as opposed to advance, it probably means that you really
+        // need the next match. Returning 'doc' here would lead to a similar
+        // iteration over sub postings overall except that the decision making would
+        // happen at a higher level where more abstractions are involved and
+        // benchmarks suggested it causes a significant performance hit.
         return doNext();
       }
 
@@ -181,7 +192,7 @@ final class MinShouldMatchSumScorer extends Scorer {
         }
 
         setDocAndFreq();
-        return doNext();
+        return doNextCandidate();
       }
 
       @Override
@@ -189,6 +200,30 @@ final class MinShouldMatchSumScorer extends Scorer {
         return cost;
       }
     };
+    return new TwoPhaseIterator(approximation) {
+
+      @Override
+      public boolean matches() throws IOException {
+        while (freq < minShouldMatch) {
+          assert freq > 0;
+          if (freq + tailSize >= minShouldMatch) {
+            // a match on doc is still possible, try to
+            // advance scorers from the tail
+            advanceTail();
+          } else {
+            return false;
+          }
+        }
+        return true;
+      }
+
+      @Override
+      public float matchCost() {
+        // maximum number of scorer that matches() might advance
+        return tail.length;
+      }
+
+    };
   }
 
   private void addLead(DisiWrapper lead) {
@@ -250,6 +285,17 @@ final class MinShouldMatchSumScorer extends Scorer {
     return doc;
   }
 
+  /** Advance tail to the lead until there is a match. */
+  private int doNextCandidate() throws IOException {
+    while (freq + tailSize < minShouldMatch) {
+      // no match on doc is possible, move to the next potential match
+      pushBackLeads();
+      setDocAndFreq();
+    }
+
+    return doc;
+  }
+
   /** Advance all entries from the tail to know about all matches on the
    *  current doc. */
   private void updateFreq() throws IOException {
