Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.java	(revision 1665952)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/ContainsPrefixTreeFilter.java	(revision )
@@ -93,10 +93,6 @@
       }
     }
 
-    BytesRef seekTerm = new BytesRef();//temp; see seek()
-    BytesRef thisTerm;//current term in termsEnum
-    Cell indexedCell;//the cell wrapper around thisTerm
-
     /** This is the primary algorithm; recursive.  Returns null if finds none. */
     private SmallDocSet visit(Cell cell, Bits acceptContains) throws IOException {
 
@@ -114,16 +110,17 @@
       CellIterator subCells = cell.getNextLevelCells(subCellsFilter);
       while (subCells.hasNext()) {
         Cell subCell = subCells.next();
-        if (!seek(subCell)) {
+        if (!leapFrog(subCell)) {
           combinedSubResults = null;
         } else if (subCell.getLevel() == detailLevel) {
-          combinedSubResults = getDocs(subCell, acceptContains);
+          combinedSubResults = getPrefixAndLeafDocs(subCell, acceptContains);
         } else if (!multiOverlappingIndexedShapes &&
             subCell.getShapeRel() == SpatialRelation.WITHIN) {
           combinedSubResults = getLeafDocs(subCell, acceptContains);
         } else {
           //OR the leaf docs with all child results
           SmallDocSet leafDocs = getLeafDocs(subCell, acceptContains);
+          // TODO opt: if we don't have a prefix then there will be no sub-cells to visit
           SmallDocSet subDocs = visit(subCell, acceptContains); //recursion
           combinedSubResults = union(leafDocs, subDocs);
         }
@@ -136,7 +133,8 @@
       return combinedSubResults;
     }
 
-    private boolean seek(Cell cell) throws IOException {
+    /** Return true if we're at the desired prefix; seek forward if we need to. */
+    private boolean leapFrog(Cell cell) throws IOException {
       if (thisTerm == null)
         return false;
       final int compare = indexedCell.compareToNoLeaf(cell);
@@ -146,14 +144,10 @@
         return true; // already there!
       } else {//compare > 0
         //seek!
-        seekTerm = cell.getTokenBytesNoLeaf(seekTerm);
-        final TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(seekTerm);
+        final TermsEnum.SeekStatus seekStatus = seek(cell);
         if (seekStatus == TermsEnum.SeekStatus.END) {
-          thisTerm = null;//all done
           return false;
         }
-        thisTerm = termsEnum.term();
-        indexedCell = grid.readCell(thisTerm, indexedCell);
         if (seekStatus == TermsEnum.SeekStatus.FOUND) {
           return true;
         }
@@ -161,51 +155,53 @@
       }
     }
 
-    /** Get prefix & leaf docs at this cell. */
-    private SmallDocSet getDocs(Cell cell, Bits acceptContains) throws IOException {
+    /** Get prefix & leaf docs at this cell. Called when we've reached detailLevel. */
+    private SmallDocSet getPrefixAndLeafDocs(Cell cell, Bits acceptContains) throws IOException {
       assert indexedCell.compareToNoLeaf(cell) == 0;
-      //called when we've reached detailLevel.
-      if (indexedCell.isLeaf()) {//only a leaf
-        SmallDocSet result = collectDocs(acceptContains);
-        nextTerm();
-        return result;
-      } else {
-        SmallDocSet docsAtPrefix = collectDocs(acceptContains);
+
+      final boolean hadPrefix = !indexedCell.isLeaf();
+      //collect prefix
+      SmallDocSet result = null;
+      if (hadPrefix) {
+        result = collectDocs(result, acceptContains);
         if (!nextTerm()) {
-          return docsAtPrefix;
+          return result;
         }
-        //collect leaf too
-        if (indexedCell.isLeaf() && indexedCell.compareToNoLeaf(cell) == 0) {
-          SmallDocSet docsAtLeaf = collectDocs(acceptContains);
-          nextTerm();
-          return union(docsAtPrefix, docsAtLeaf);
-        } else {
-          return docsAtPrefix;
-        }
+      }
+
+      return collectLeaf(cell, acceptContains, hadPrefix, result);
-      }
+    }
-    }
 
     /** Gets docs on the leaf of the given cell, _if_ there is a leaf cell, otherwise null. */
     private SmallDocSet getLeafDocs(Cell cell, Bits acceptContains) throws IOException {
       assert indexedCell.compareToNoLeaf(cell) == 0;
+
+      final boolean hadPrefix = !indexedCell.isLeaf();
       //Advance past prefix if we're at a prefix; return null if no leaf
-      if (!indexedCell.isLeaf()) {
-        if (!nextTerm() || !indexedCell.isLeaf() || indexedCell.getLevel() != cell.getLevel()) {
+      if (hadPrefix) {
+        if (!nextTerm()) {
           return null;
         }
       }
-      SmallDocSet result = collectDocs(acceptContains);
+
+      return collectLeaf(cell, acceptContains, hadPrefix, null);
+    }
+
+    private SmallDocSet collectLeaf(Cell cell, Bits acceptContains, boolean assumePrefix, SmallDocSet result)
+        throws IOException {
+      if (isIndexedLeafOfQueryCellPrefix(cell, assumePrefix)) {
+        result = collectDocs(null, acceptContains);
+        if (nextTerm()) {
+          //collect secondary leaf
+          if (isIndexedLeafOfQueryCellPrefix(cell, assumePrefix)) {
+            result = collectDocs(result, acceptContains);
-      nextTerm();
+            nextTerm();
+          }
+        }
+      }
       return result;
     }
 
-    private boolean nextTerm() throws IOException {
-      if ((thisTerm = termsEnum.next()) == null)
-        return false;
-      indexedCell = grid.readCell(thisTerm, indexedCell);
-      return true;
-    }
-
     private SmallDocSet union(SmallDocSet aSet, SmallDocSet bSet) {
       if (bSet != null) {
         if (aSet == null)
@@ -215,21 +211,19 @@
       return aSet;
     }
 
-    private SmallDocSet collectDocs(Bits acceptContains) throws IOException {
-      SmallDocSet set = null;
-
+    private SmallDocSet collectDocs(SmallDocSet result, Bits acceptContains) throws IOException {
       postingsEnum = termsEnum.postings(acceptContains, postingsEnum, PostingsEnum.NONE);
       int docid;
       while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
-        if (set == null) {
+        if (result == null) {
           int size = termsEnum.docFreq();
           if (size <= 0)
             size = 16;
-          set = new SmallDocSet(size);
+          result = new SmallDocSet(size);
         }
-        set.set(docid);
+        result.set(docid);
       }
-      return set;
+      return result;
     }
 
   }//class ContainsVisitor
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree.java	(revision 1665952)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/NumberRangePrefixTree.java	(revision )
@@ -600,6 +600,11 @@
     }
 
     @Override
+    public boolean mightHaveAdjacentLeaf() {
+      return !isLeaf();//we only have one leaf type
+    }
+
+    @Override
     public UnitNRShape getShape() {
       ensureDecoded();
       return this;
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/LegacyCell.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/LegacyCell.java	(revision 1665952)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/LegacyCell.java	(revision )
@@ -33,7 +33,11 @@
   // Important: A LegacyCell doesn't share state for getNextLevelCells(), and
   //  LegacySpatialPrefixTree assumes this in its simplify tree logic.
 
-  private static final byte LEAF_BYTE = '+';//NOTE: must sort before letters & numbers
+  /** The leaf byte that is within (contained by) the shape it was generated from. */
+  private static final byte LEAF_COVERED_BYTE = '*';
+  /** The leaf byte for an approximated / edge that is partially overlapping the shape it was
+   * generated from. */
+  private static final byte LEAF_OVERLAP_BYTE = '+';//NOTE: must sort before letters & numbers
 
   //Arguably we could simply use a BytesRef, using an extra Object.
   private byte[] bytes;//generally bigger to potentially hold a leaf
@@ -64,17 +68,27 @@
     shape = null;
     this.bytes = bytes.bytes;
     this.b_off = bytes.offset;
-    this.b_len = (short) bytes.length;
+    this.b_len = bytes.length;
     readLeafAdjust();
   }
 
   private void readLeafAdjust() {
-    isLeaf = (b_len > 0 && bytes[b_off + b_len - 1] == LEAF_BYTE);
-    if (isLeaf)
+    isLeaf = false;
+    if (b_len == 0) {
+      return; // only for world cell (which isn't leaf)
+    }
+    final byte tailByte = bytes[b_off + b_len - 1];
+    if (tailByte == LEAF_COVERED_BYTE) {
+      isLeaf = true;
       b_len--;
-    if (getLevel() == getMaxLevels())
+      setShapeRel(SpatialRelation.WITHIN);
+    } else if (tailByte == LEAF_OVERLAP_BYTE) {
       isLeaf = true;
+      b_len--;
+    } else if (getLevel() == getMaxLevels()) {
+      isLeaf = true;
-  }
+    }
+  }
 
 //  @Override
 //  public void copyFrom(Cell source) {
@@ -112,11 +126,29 @@
     isLeaf = true;
   }
 
+  /** Returns whether this cell is covered by the shape from which it was generated from, as opposed to overlapping.
+   * Precondition: isLeaf is true.
+   */
+  public boolean isLeafCovered() {
+    assert isLeaf;
+    return getShapeRel() == SpatialRelation.WITHIN;
+  }
+
   @Override
+  public boolean mightHaveAdjacentLeaf() {
+    if (!isLeaf()) {
+      return true;//unless points-only?
+    }
+    assert LEAF_COVERED_BYTE < LEAF_OVERLAP_BYTE;
+    return shapeRel == SpatialRelation.WITHIN;
+  }
+
+  @Override
   public BytesRef getTokenBytesWithLeaf(BytesRef result) {
     result = getTokenBytesNoLeaf(result);
-    if (!isLeaf || getLevel() == getMaxLevels())
+    if (!isLeaf || (getLevel() == getMaxLevels()) && !isLeafCovered()) {
       return result;
+    }
     if (result.bytes.length < result.offset + result.length + 1) {
       assert false : "Not supposed to happen; performance bug";
       byte[] copy = new byte[result.length + 1];
@@ -124,7 +156,8 @@
       result.bytes = copy;
       result.offset = 0;
     }
-    result.bytes[result.offset + result.length++] = LEAF_BYTE;
+    result.bytes[result.offset + result.length++] =
+        (isLeafCovered() ? LEAF_COVERED_BYTE : LEAF_OVERLAP_BYTE);
     return result;
   }
 
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.java	(revision 1665952)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractVisitingPrefixTreeFilter.java	(revision )
@@ -29,7 +29,6 @@
 import org.apache.lucene.spatial.prefix.tree.CellIterator;
 import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
 import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.BytesRef;
 
 /**
  * Traverses a {@link SpatialPrefixTree} indexed field, using the template and
@@ -120,11 +119,7 @@
     //
 
     private VNode curVNode;//current pointer, derived from query shape
-    private BytesRef curVNodeTerm = new BytesRef();//curVNode.cell's term, without leaf. in main loop only
 
-    private BytesRef thisTerm;//the result of termsEnum.term()
-    private Cell indexedCell;//Cell wrapper of thisTerm. Always updated when thisTerm is.
-
     public VisitorTemplate(LeafReaderContext context, Bits acceptDocs) throws IOException {
       super(context, acceptDocs);
     }
@@ -180,36 +175,52 @@
         if (compare < 0) {
           // The indexed cell is before; seek ahead to query cell:
           //      Seek !
-          curVNode.cell.getTokenBytesNoLeaf(curVNodeTerm);
-          TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(curVNodeTerm);
+          TermsEnum.SeekStatus seekStatus = seek(curVNode.cell);
           if (seekStatus == TermsEnum.SeekStatus.END)
             break; // all done
-          thisTerm = termsEnum.term();
-          indexedCell = grid.readCell(thisTerm, indexedCell);
           if (seekStatus == TermsEnum.SeekStatus.NOT_FOUND) {
             // Did we find a leaf of the cell we were looking for or something after?
-            if (!indexedCell.isLeaf() || indexedCell.compareToNoLeaf(curVNode.cell) != 0)
+            if (!isIndexedLeafOfQueryCellPrefix(curVNode.cell, false))
               continue; // The indexed cell is after; continue loop to next query cell
           }
         }
         // indexedCell == queryCell (disregarding leaf).
 
+        //TODO should rel to query shape be passed as a param to visit methods?  Would disambiguate
+        // what cell.getShapeRel is -- it could always be the indexed one.
+
         // If indexedCell is a leaf then there's no prefix (prefix sorts before) -- just visit and continue
         if (indexedCell.isLeaf()) {
-          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.
+          visitLeaf(indexedCell);
+          boolean checkAdjLeaf = indexedCell.mightHaveAdjacentLeaf();
           if (!nextTerm()) break;
+
+          //another leaf (leaf type differentiation)
+          if (checkAdjLeaf && isIndexedLeafOfQueryCellPrefix(curVNode.cell, false)) {
+            visitLeaf(indexedCell);
+            if (!nextTerm()) break;
+          }
           continue;
         }
-        // If a prefix (non-leaf) then visit; see if we descend.
+
+        // If a prefix (non-leaf) then visit; returns true if we should descend.
         final boolean descend = visitPrefix(curVNode.cell);//need to use curVNode.cell not indexedCell
+        boolean checkAdjLeaf = indexedCell.mightHaveAdjacentLeaf();
         if (!nextTerm()) break;
+
         // Check for adjacent leaf with the same prefix
-        if (indexedCell.isLeaf() && indexedCell.getLevel() == curVNode.cell.getLevel()) {
-          visitLeaf(indexedCell);//TODO or query cell? Though shouldn't matter.
+        if (checkAdjLeaf && isIndexedLeafOfQueryCellPrefix(curVNode.cell, true)) {//true: can assume same prefix
+          visitLeaf(indexedCell);
+          checkAdjLeaf = indexedCell.mightHaveAdjacentLeaf();
           if (!nextTerm()) break;
+
+          //another leaf (leaf type differentiation)
+          if (checkAdjLeaf && isIndexedLeafOfQueryCellPrefix(curVNode.cell, true)) {//true: can assume same prefix
+            visitLeaf(indexedCell);
+            if (!nextTerm()) break;
-        }
+          }
+        }
 
-
         if (descend) {
           addIntersectingChildren();
         }
@@ -277,13 +288,6 @@
       }
     }
 
-    private boolean nextTerm() throws IOException {
-      if ((thisTerm = termsEnum.next()) == null)
-        return false;
-      indexedCell = grid.readCell(thisTerm, indexedCell);
-      return true;
-    }
-
     /** Used for {@link VNode#children}. */
     private class VNodeCellIterator implements Iterator<VNode> {
 
@@ -334,6 +338,10 @@
      * indexed leaf cell usually means associated documents won't be found at
      * further detail levels.  However, if a document has
      * multiple overlapping shapes at different resolutions, then this isn't true.
+     * {@link org.apache.lucene.spatial.prefix.tree.Cell#getShapeRel()} will
+     * be {@link com.spatial4j.core.shape.SpatialRelation#WITHIN} if this leaf cell
+     * was covered by the indexed shape from which it was generated. It's not the
+     * query shape relation.
      */
     protected abstract void visitLeaf(Cell cell) throws IOException;
 
@@ -347,10 +355,10 @@
     protected void visitScanned(Cell cell) throws IOException {
       final SpatialRelation relate = cell.getShape().relate(queryShape);
       if (relate.intersects()) {
-        cell.setShapeRel(relate);//just being pedantic
         if (cell.isLeaf()) {
           visitLeaf(cell);
         } else {
+          cell.setShapeRel(relate);//just being pedantic
           visitPrefix(cell);
         }
       }
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategy.java	(revision 1665952)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/RecursivePrefixTreeStrategy.java	(revision )
@@ -52,9 +52,12 @@
 
   protected int prefixGridScanLevel;
 
-  //Formerly known as simplifyIndexedCells. Eventually will be removed. Only compatible with RPT
-  // and a LegacyPrefixTree.
+  //Formerly known as simplifyIndexedCells. Only compatible with LegacyPrefixTree at this time.
   protected boolean pruneLeafyBranches = true;
+  /** If more than this ratio of covered leaves are found at detailLevel for the indexed shapes, then we don't prune it.
+   * At courser levels, this is effectively always 0.
+   */
+  protected float pruneCoveredLeafRatio = 1f;//1f effectively disables.
 
   protected boolean multiOverlappingIndexedShapes = true;
 
@@ -143,14 +146,22 @@
       result.add(cell);
 
     int leaves = 0;
+    int coveredLeaves = 0;
     CellIterator subCells = cell.getNextLevelCells(shape);
     while (subCells.hasNext()) {
       Cell subCell = subCells.next();
-      if (recursiveTraverseAndPrune(subCell, shape, detailLevel, result))
+      if (recursiveTraverseAndPrune(subCell, shape, detailLevel, result)) {
         leaves++;
+        if (((LegacyCell)result.get(result.size() - 1)).isLeafCovered()) {
+          coveredLeaves++;
-    }
+        }
+      }
+    }
     //can we prune?
-    if (leaves == ((LegacyCell)cell).getSubCellsSize() && cell.getLevel() != 0) {
+    final int subCellsSize = ((LegacyCell) cell).getSubCellsSize();
+    final int coveredThreshold = (cell.getLevel() == detailLevel - 1) ? (int) (subCellsSize * pruneCoveredLeafRatio) : 0;
+    if (cell.getLevel() != 0 && leaves == subCellsSize
+        && coveredLeaves <= coveredThreshold) {
       //Optimization: substitute the parent as a leaf instead of adding all
       // children as leaves
 
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/GeohashPrefixTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/GeohashPrefixTree.java	(revision 1665952)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/GeohashPrefixTree.java	(revision )
@@ -104,8 +104,7 @@
     GhCell(String geohash) {
       super(stringToBytesPlus1(geohash), 0, geohash.length());
       this.geohash = geohash;
-      if (isLeaf() && getLevel() < getMaxLevels())//we don't have a leaf byte at max levels (an opt)
-        this.geohash = geohash.substring(0, geohash.length() - 1);
+      assert ! isLeaf() || getLevel() == getMaxLevels() : "this constructor isn't for leaves";
     }
 
     GhCell(byte[] bytes, int off, int len) {
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractPrefixTreeFilter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractPrefixTreeFilter.java	(revision 1665952)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/AbstractPrefixTreeFilter.java	(revision )
@@ -26,9 +26,11 @@
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.Filter;
+import org.apache.lucene.spatial.prefix.tree.Cell;
 import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
 import org.apache.lucene.util.BitSet;
 import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
 
 /**
  * Base class for Lucene Filters on SpatialPrefixTree fields.
@@ -82,6 +84,10 @@
     protected TermsEnum termsEnum;//remember to check for null!
     protected PostingsEnum postingsEnum;
 
+    protected BytesRef thisTerm;//the result of termsEnum.term()
+    protected Cell indexedCell;//Cell wrapper of thisTerm. Always updated when thisTerm is.
+    BytesRef seekTerm = new BytesRef();//temp; see seek()
+
     public BaseTermsEnumTraverser(LeafReaderContext context, Bits acceptDocs) throws IOException {
       this.context = context;
       LeafReader reader = context.reader();
@@ -98,6 +104,37 @@
       bitSet.or(postingsEnum);
     }
 
+    /** Advanced the terms to the next term and updated {@link #indexedCell}. Returns false if at the end. */
+    protected boolean nextTerm() throws IOException {
+      if ((thisTerm = termsEnum.next()) == null)
+        return false;
+      indexedCell = grid.readCell(thisTerm, indexedCell);
+      return true;
+    }
+
+    /** Seeks terms to the specified cell, ignoring leaf flag. Updates {@link #indexedCell}. */
+    protected TermsEnum.SeekStatus seek(Cell cell) throws IOException {
+      seekTerm = cell.getTokenBytesNoLeaf(seekTerm);
+      final TermsEnum.SeekStatus seekStatus = termsEnum.seekCeil(seekTerm);
+      if (seekStatus == TermsEnum.SeekStatus.END) {
+        thisTerm = null;//all done
+        indexedCell = null;
+      } else {
+        thisTerm = termsEnum.term();
+        indexedCell = grid.readCell(thisTerm, indexedCell);
+      }
+      return seekStatus;
+    }
+
+    /** Returns true if indexedCell is a leaf with the same prefix bytes as curVNode.cell. */
+    protected boolean isIndexedLeafOfQueryCellPrefix(Cell queryCell, boolean assumePrefix) {
+      //TODO should cell have equalsNoLeaf()
+      final boolean result = indexedCell.isLeaf()
+          && indexedCell.getLevel() == queryCell.getLevel()
+          && (assumePrefix || indexedCell.compareToNoLeaf(queryCell) == 0);
+      assert !result || !assumePrefix || indexedCell.compareToNoLeaf(queryCell) == 0 : "assumePrefix should be false";
+      return result;
+    }
   }
 
 }
Index: lucene/spatial/src/test/org/apache/lucene/spatial/prefix/RandomSpatialOpFuzzyPrefixTreeTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/prefix/RandomSpatialOpFuzzyPrefixTreeTest.java	(revision 1665952)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/prefix/RandomSpatialOpFuzzyPrefixTreeTest.java	(revision )
@@ -422,7 +422,10 @@
         continue;
       cellShapes.add(cell.getShape());
     }
-    return new ShapeCollection<>(cellShapes, ctx).getBoundingBox();
+    // Due to Spatial4j bug in geo longitude world-wrap, we use ctx2D knowing that our test data doesn't cross the
+    // dateline.
+    assert !snapMe.getBoundingBox().getCrossesDateLine();
+    return new ShapeCollection<>(cellShapes, ctx2D).getBoundingBox();
   }
 
   /**
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/Cell.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/Cell.java	(revision 1665952)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/Cell.java	(revision )
@@ -40,7 +40,9 @@
 //  void copyFrom(Cell source);
 
   /** Gets the relationship this cell has with the shape from which it was filtered from, assuming it came from a
-   * {@link CellIterator}. Arguably it belongs there but it's very convenient here. */
+   * {@link CellIterator}. Arguably it belongs there but it's very convenient here. If The Cell came from an indexed
+   * term then the result will be {@link com.spatial4j.core.shape.SpatialRelation#WITHIN} if the leaf was covered by
+   * the shape from which it was generated. */
   SpatialRelation getShapeRel();
 
   /** See {@link #getShapeRel()}.
@@ -59,6 +61,9 @@
    * Note: not supported at level 0.
    * @lucene.internal */
   void setLeaf();
+
+  /** nocommit */
+  boolean mightHaveAdjacentLeaf();
 
   /**
    * Returns the bytes for this cell, with a leaf byte <em>if this is a leaf cell</em>.
