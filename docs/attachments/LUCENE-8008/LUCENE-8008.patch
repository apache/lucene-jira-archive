diff --git a/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java b/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java
index dbe3d17..ed729c7 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java
@@ -71,7 +71,6 @@ final class BooleanWeight extends Weight {
   public Explanation explain(LeafReaderContext context, int doc) throws IOException {
     final int minShouldMatch = query.getMinimumNumberShouldMatch();
     List<Explanation> subs = new ArrayList<>();
-    float sum = 0.0f;
     boolean fail = false;
     int matchCount = 0;
     int shouldMatchCount = 0;
@@ -83,7 +82,6 @@ final class BooleanWeight extends Weight {
       if (e.isMatch()) {
         if (c.isScoring()) {
           subs.add(e);
-          sum += e.getValue();
         } else if (c.isRequired()) {
           subs.add(Explanation.match(0f, "match on required clause, product of:",
               Explanation.match(0f, Occur.FILTER + " clause"), e));
@@ -109,8 +107,15 @@ final class BooleanWeight extends Weight {
     } else if (shouldMatchCount < minShouldMatch) {
       return Explanation.noMatch("Failure to match minimum number of optional clauses: " + minShouldMatch, subs);
     } else {
-      // we have a match
-      return Explanation.match(sum, "sum of:", subs);
+      // Replicating the same floating-point errors as the scorer does is quite
+      // complex (essentially because of how ReqOptSumScorer casts intermediate
+      // contributions to the score to floats), so in order to make sure that
+      // explanations have the same value as the score, we pull a scorer and
+      // use it to compute the score.
+      Scorer scorer = scorer(context);
+      int advanced = scorer.iterator().advance(doc);
+      assert advanced == doc;
+      return Explanation.match(scorer.score(), "sum of:", subs);
     }
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
index 13237a2..d3fee9d 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
@@ -156,7 +156,8 @@ public final class DisjunctionMaxQuery extends Query implements Iterable<Query>
     @Override
     public Explanation explain(LeafReaderContext context, int doc) throws IOException {
       boolean match = false;
-      float max = Float.NEGATIVE_INFINITY, sum = 0.0f;
+      float max = Float.NEGATIVE_INFINITY;
+      double sum = 0;
       List<Explanation> subs = new ArrayList<>();
       for (Weight wt : weights) {
         Explanation e = wt.explain(context, doc);
@@ -168,7 +169,7 @@ public final class DisjunctionMaxQuery extends Query implements Iterable<Query>
         }
       }
       if (match) {
-        final float score = max + (sum - max) * tieBreakerMultiplier;
+        final float score = (float) (max + (sum - max) * tieBreakerMultiplier);
         final String desc = tieBreakerMultiplier == 0.0f ? "max of:" : "max plus " + tieBreakerMultiplier + " times others of:";
         return Explanation.match(score, desc, subs);
       } else {
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
index 2356f5e..961fd43 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
@@ -47,7 +47,7 @@ final class DisjunctionMaxScorer extends DisjunctionScorer {
 
   @Override
   protected float score(DisiWrapper topList) throws IOException {
-    float scoreSum = 0;
+    double scoreSum = 0;
     float scoreMax = Float.NEGATIVE_INFINITY;
     for (DisiWrapper w = topList; w != null; w = w.next) {
       final float subScore = w.scorer.score();
@@ -56,6 +56,6 @@ final class DisjunctionMaxScorer extends DisjunctionScorer {
         scoreMax = subScore;
       }
     }
-    return scoreMax + (scoreSum - scoreMax) * tieBreakerMultiplier; 
+    return (float) (scoreMax + (scoreSum - scoreMax) * tieBreakerMultiplier); 
   }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java b/lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java
index 1264b58..26ce9c7 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBooleanMinShouldMatch.java
@@ -380,7 +380,7 @@ public class TestBooleanMinShouldMatch extends LuceneTestCase {
                 + CheckHits.topdocsString(top1,0,0)
                 + CheckHits.topdocsString(top2,0,0)
                 + "for query:" + q.toString(),
-                score, otherScore, CheckHits.explainToleranceDelta(score, otherScore));
+                score, otherScore, 0d);
           }
         }
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestMinShouldMatch2.java b/lucene/core/src/test/org/apache/lucene/search/TestMinShouldMatch2.java
index 4d690ce..81ae187 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestMinShouldMatch2.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestMinShouldMatch2.java
@@ -152,7 +152,7 @@ public class TestMinShouldMatch2 extends LuceneTestCase {
       assertEquals(doc, actualIt.nextDoc());
       float expectedScore = expected.score();
       float actualScore = actual.score();
-      assertEquals(expectedScore, actualScore, CheckHits.explainToleranceDelta(expectedScore, actualScore));
+      assertEquals(expectedScore, actualScore, 0d);
     }
     assertEquals(DocIdSetIterator.NO_MORE_DOCS, actualIt.nextDoc());
   }
@@ -170,7 +170,7 @@ public class TestMinShouldMatch2 extends LuceneTestCase {
       assertEquals(doc, actualIt.advance(prevDoc+amount));
       float expectedScore = expected.score();
       float actualScore = actual.score();
-      assertEquals(expectedScore, actualScore, CheckHits.explainToleranceDelta(expectedScore, actualScore));
+      assertEquals(expectedScore, actualScore, 0d);
       prevDoc = doc;
     }
     assertEquals(DocIdSetIterator.NO_MORE_DOCS, actualIt.advance(prevDoc+amount));
diff --git a/lucene/expressions/src/test/org/apache/lucene/expressions/TestDemoExpressions.java b/lucene/expressions/src/test/org/apache/lucene/expressions/TestDemoExpressions.java
index f597626..b84b7ad 100644
--- a/lucene/expressions/src/test/org/apache/lucene/expressions/TestDemoExpressions.java
+++ b/lucene/expressions/src/test/org/apache/lucene/expressions/TestDemoExpressions.java
@@ -24,7 +24,6 @@ import org.apache.lucene.expressions.js.VariableContext;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.CheckHits;
 import org.apache.lucene.search.DoubleValuesSource;
 import org.apache.lucene.search.FieldDoc;
 import org.apache.lucene.search.IndexSearcher;
@@ -120,7 +119,7 @@ public class  TestDemoExpressions extends LuceneTestCase {
       FieldDoc d = (FieldDoc) td.scoreDocs[i];
       float expected = (float) Math.sqrt(d.score);
       float actual = ((Double)d.fields[0]).floatValue();
-      assertEquals(expected, actual, CheckHits.explainToleranceDelta(expected, actual));
+      assertEquals(expected, actual, 0d);
     }
   }
   
@@ -138,7 +137,7 @@ public class  TestDemoExpressions extends LuceneTestCase {
       FieldDoc d = (FieldDoc) td.scoreDocs[i];
       float expected = 2*d.score;
       float actual = ((Double)d.fields[0]).floatValue();
-      assertEquals(expected, actual, CheckHits.explainToleranceDelta(expected, actual));
+      assertEquals(expected, actual, 0d);
     }
   }
   
@@ -157,7 +156,7 @@ public class  TestDemoExpressions extends LuceneTestCase {
       FieldDoc d = (FieldDoc) td.scoreDocs[i];
       float expected = 2*d.score;
       float actual = ((Double)d.fields[0]).floatValue();
-      assertEquals(expected, actual, CheckHits.explainToleranceDelta(expected, actual));
+      assertEquals(expected, actual, 0d);
     }
   }
   
@@ -177,7 +176,7 @@ public class  TestDemoExpressions extends LuceneTestCase {
       FieldDoc d = (FieldDoc) td.scoreDocs[i];
       float expected = 2*d.score;
       float actual = ((Double)d.fields[0]).floatValue();
-      assertEquals(expected, actual, CheckHits.explainToleranceDelta(expected, actual));
+      assertEquals(expected, actual, 0d);
     }
   }
   
@@ -209,7 +208,7 @@ public class  TestDemoExpressions extends LuceneTestCase {
       FieldDoc d = (FieldDoc) td.scoreDocs[i];
       float expected = n*d.score;
       float actual = ((Double)d.fields[0]).floatValue();
-      assertEquals(expected, actual, CheckHits.explainToleranceDelta(expected, actual));
+      assertEquals(expected, actual, 0d);
     }
   }
   
diff --git a/lucene/queries/src/test/org/apache/lucene/queries/TestCustomScoreQuery.java b/lucene/queries/src/test/org/apache/lucene/queries/TestCustomScoreQuery.java
index d001cc8..3578864 100644
--- a/lucene/queries/src/test/org/apache/lucene/queries/TestCustomScoreQuery.java
+++ b/lucene/queries/src/test/org/apache/lucene/queries/TestCustomScoreQuery.java
@@ -34,7 +34,6 @@ import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.BoostQuery;
-import org.apache.lucene.search.CheckHits;
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
@@ -60,8 +59,8 @@ public class TestCustomScoreQuery extends FunctionTestSetup {
    */
   @Test
   public void testCustomScoreInt() throws Exception {
-    doTestCustomScore(INT_VALUESOURCE, 1.0);
-    doTestCustomScore(INT_VALUESOURCE, 4.0);
+    doTestCustomScore(INT_VALUESOURCE, 1f);
+    doTestCustomScore(INT_VALUESOURCE, 4f);
   }
 
   /**
@@ -69,8 +68,8 @@ public class TestCustomScoreQuery extends FunctionTestSetup {
    */
   @Test
   public void testCustomScoreFloat() throws Exception {
-    doTestCustomScore(FLOAT_VALUESOURCE, 1.0);
-    doTestCustomScore(FLOAT_VALUESOURCE, 6.0);
+    doTestCustomScore(FLOAT_VALUESOURCE, 1f);
+    doTestCustomScore(FLOAT_VALUESOURCE, 6f);
   }
 
   // must have static class otherwise serialization tests fail
@@ -225,8 +224,7 @@ public class TestCustomScoreQuery extends FunctionTestSetup {
   }
   
   // Test that FieldScoreQuery returns docs with expected score.
-  private void doTestCustomScore(ValueSource valueSource, double dboost) throws Exception {
-    float boost = (float) dboost;
+  private void doTestCustomScore(ValueSource valueSource, float boost) throws Exception {
     FunctionQuery functionQuery = new FunctionQuery(valueSource);
     IndexReader r = DirectoryReader.open(dir);
     IndexSearcher s = newSearcher(r);
@@ -242,11 +240,11 @@ public class TestCustomScoreQuery extends FunctionTestSetup {
     // custom query, that should score the same as q1.
     BooleanQuery.Builder q2CustomNeutralB = new BooleanQuery.Builder();
     Query q2CustomNeutralInner = new CustomScoreQuery(q1);
-    q2CustomNeutralB.add(new BoostQuery(q2CustomNeutralInner, (float)Math.sqrt(dboost)), BooleanClause.Occur.SHOULD);
+    q2CustomNeutralB.add(new BoostQuery(q2CustomNeutralInner, (float)Math.sqrt(boost)), BooleanClause.Occur.SHOULD);
     // a little tricky: we split the boost across an outer BQ and CustomScoreQuery
     // this ensures boosting is correct across all these functions (see LUCENE-4935)
     Query q2CustomNeutral = q2CustomNeutralB.build();
-    q2CustomNeutral = new BoostQuery(q2CustomNeutral, (float)Math.sqrt(dboost));
+    q2CustomNeutral = new BoostQuery(q2CustomNeutral, (float)Math.sqrt(boost));
     log(q2CustomNeutral);
 
     // custom query, that should (by default) multiply the scores of q1 by that of the field
@@ -328,19 +326,19 @@ public class TestCustomScoreQuery extends FunctionTestSetup {
       
       float score2 = h2customNeutral.get(doc);
       logResult("score2=", s, q2, doc, score2);
-      assertEquals("same score (just boosted) for neutral", boost * score1, score2, CheckHits.explainToleranceDelta(boost * score1, score2));
+      assertEquals("same score (just boosted) for neutral", boost * score1, score2, Math.scalb(score2, -15));
 
       float score3 = h3CustomMul.get(doc);
       logResult("score3=", s, q3, doc, score3);
-      assertEquals("new score for custom mul", boost * fieldScore * score1, score3, CheckHits.explainToleranceDelta(boost * fieldScore * score1, score3));
+      assertEquals("new score for custom mul", boost * fieldScore * score1, score3, Math.scalb(score2, -15));
       
       float score4 = h4CustomAdd.get(doc);
       logResult("score4=", s, q4, doc, score4);
-      assertEquals("new score for custom add", boost * (fieldScore + score1), score4, CheckHits.explainToleranceDelta(boost * (fieldScore + score1), score4));
+      assertEquals("new score for custom add", boost * (fieldScore + score1), score4, Math.scalb(score2, -15));
       
       float score5 = h5CustomMulAdd.get(doc);
       logResult("score5=", s, q5, doc, score5);
-      assertEquals("new score for custom mul add", boost * fieldScore * (score1 + fieldScore), score5, CheckHits.explainToleranceDelta(boost * fieldScore * (score1 + fieldScore), score5));
+      assertEquals("new score for custom mul add", boost * fieldScore * (score1 + fieldScore), score5, Math.scalb(score2, -15));
     }
   }
 
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/CheckHits.java b/lucene/test-framework/src/java/org/apache/lucene/search/CheckHits.java
index 7696a63..3e25c0f 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/CheckHits.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/CheckHits.java
@@ -33,21 +33,6 @@ import org.apache.lucene.util.LuceneTestCase;
  * Utility class for asserting expected hits in tests.
  */
 public class CheckHits {
-  
-  /**
-   * Some explains methods calculate their values though a slightly
-   * different  order of operations from the actual scoring method ...
-   * this allows for a small amount of relative variation
-   */
-  public static float EXPLAIN_SCORE_TOLERANCE_DELTA = 0.001f;
-  
-  /**
-   * In general we use a relative epsilon, but some tests do crazy things
-   * like boost documents with 0, creating tiny tiny scores where the
-   * relative difference is large but the absolute difference is tiny.
-   * we ensure the the epsilon is always at least this big.
-   */
-  public static float EXPLAIN_SCORE_TOLERANCE_MINIMUM = 1e-6f;
     
   /**
    * Tests that all documents up to maxDoc which are *not* in the
@@ -313,12 +298,6 @@ public class CheckHits {
                     (query, defaultFieldName, searcher, deep));
 
   }
-
-  /** returns a reasonable epsilon for comparing two floats,
-   *  where minor differences are acceptable such as score vs. explain */
-  public static float explainToleranceDelta(float f1, float f2) {
-    return Math.max(EXPLAIN_SCORE_TOLERANCE_MINIMUM, Math.max(Math.abs(f1), Math.abs(f2)) * EXPLAIN_SCORE_TOLERANCE_DELTA);
-  }
   
   private static final Pattern COMPUTED_FROM_PATTERN = Pattern.compile(".*, computed as .* from:");
 
@@ -340,7 +319,7 @@ public class CheckHits {
     float value = expl.getValue();
     // TODO: clean this up if we use junit 5 (the assert message is costly)
     try {
-      Assert.assertEquals(score, value, explainToleranceDelta(score, value));
+      Assert.assertEquals(score, value, 0d);
     } catch (Exception e) {
       Assert.fail(q+": score(doc="+doc+")="+score+" != explanationScore="+value+" Explanation: "+expl);
     }
@@ -398,32 +377,42 @@ public class CheckHits {
               +"\" must be 'max of plus x times others', 'computed as x from:' or end with 'product of'"
               +" or 'sum of:' or 'max of:' - "+expl);
         }
-        float sum = 0;
+        double sum = 0;
         float product = 1;
-        float max = 0;
+        float max = Float.NEGATIVE_INFINITY;
+        double maxError = 0;
         for (int i=0; i<detail.length; i++) {
           float dval = detail[i].getValue();
           verifyExplanation(q,doc,dval,deep,detail[i]);
           product *= dval;
           sum += dval;
           max = Math.max(max,dval);
+
+          if (sumOf) {
+            // "sum of" is used by BooleanQuery. Making it accurate is not
+            // easy since ReqOptSumScorer casts some intermediate
+            // contributions to the score to a float before doing another sum.
+            // So we introduce some (reasonable) leniency.
+            // TODO: remove this leniency
+            maxError += Math.ulp(dval) * 2;
+          }
         }
-        float combined = 0;
+        float combined;
         if (productOf) {
           combined = product;
         } else if (sumOf) {
-          combined = sum;
+          combined = (float) sum;
         } else if (maxOf) {
           combined = max;
         } else if (maxTimesOthers) {
-          combined = max + x * (sum - max);
+          combined = (float) (max + x * (sum - max));
         } else {
           Assert.assertTrue("should never get here!", computedOf);
           combined = value;
         }
         // TODO: clean this up if we use junit 5 (the assert message is costly)
         try {
-          Assert.assertEquals(combined, value, explainToleranceDelta(combined, value));
+          Assert.assertEquals(combined, value, maxError);
         } catch (Exception e) {
           Assert.fail(q+": actual subDetails combined=="+combined+
               " != value="+value+" Explanation: "+expl);
