Index: lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/OffsetsEnum.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/OffsetsEnum.java	(revision e3cdb395a4009f118900397c8a2086620b436455)
+++ lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/OffsetsEnum.java	(date 1533328612000)
@@ -46,6 +46,10 @@
       if (cmp != 0) {
         return cmp; // vast majority of the time we return here.
       }
+      cmp = Integer.compare(endOffset(), other.endOffset());
+      if (cmp != 0) {
+        return cmp;
+      }
       final BytesRef thisTerm = this.getTerm();
       final BytesRef otherTerm = other.getTerm();
       if (thisTerm == null || otherTerm == null) {
Index: lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/DefaultPassageFormatter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/DefaultPassageFormatter.java	(revision e3cdb395a4009f118900397c8a2086620b436455)
+++ lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/DefaultPassageFormatter.java	(date 1533328660000)
@@ -70,17 +70,24 @@
       pos = passage.getStartOffset();
       for (int i = 0; i < passage.getNumMatches(); i++) {
         int start = passage.getMatchStarts()[i];
-        int end = passage.getMatchEnds()[i];
-        // its possible to have overlapping terms
-        if (start > pos) {
-          append(sb, content, pos, start);
+        assert start >= pos && start < passage.getEndOffset();
+        //append content before this start
+        append(sb, content, pos, start);
+
+        int end = passage.getMatchEnds()[i];
+        assert end > start;
+        // its possible to have overlapping terms.
+        //   Look ahead to expand 'end' past all overlapping:
+        while (i + 1 < passage.getNumMatches() && passage.getMatchStarts()[i+1] < end) {
+          end = passage.getMatchEnds()[++i];
         }
-        if (end > pos) {
-          sb.append(preTag);
-          append(sb, content, Math.max(pos, start), end);
-          sb.append(postTag);
-          pos = end;
-        }
+        end = Math.min(end, passage.getEndOffset()); // in case match straddles past passage
+
+        sb.append(preTag);
+        append(sb, content, start, end);
+        sb.append(postTag);
+
+        pos = end;
       }
       // its possible a "term" from the analyzer could span a sentence boundary.
       append(sb, content, pos, Math.max(pos, passage.getEndOffset()));
