diff --git a/lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java b/lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java
index 6e0d39e..98d18cc 100644
--- a/lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java
+++ b/lucene/join/src/java/org/apache/lucene/search/join/ToChildBlockJoinQuery.java
@@ -137,6 +137,8 @@ public class ToChildBlockJoinQuery extends Query {
         return null;
       }
 
+      ToParentBlockJoinQuery.BlockJoinWeight.checkParentFilterBits(readerContext, parentsFilter, parents);
+      
       return new ToChildBlockJoinScorer(this, parentScorer, parents, doScores);
     }
 
diff --git a/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java b/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java
index fd6256b..592f77e 100644
--- a/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java
+++ b/lucene/join/src/java/org/apache/lucene/search/join/ToParentBlockJoinQuery.java
@@ -125,7 +125,7 @@ public class ToParentBlockJoinQuery extends Query {
     return childQuery;
   }
 
-  private static class BlockJoinWeight extends Weight {
+  static class BlockJoinWeight extends Weight {
     private final Query joinQuery;
     private final Weight childWeight;
     private final BitSetProducer parentsFilter;
@@ -178,7 +178,16 @@ public class ToParentBlockJoinQuery extends Query {
         return null;
       }
 
-      return new BlockJoinScorer(this, childScorer, parents, firstChildDoc, scoreMode);
+      checkParentFilterBits(readerContext, parentsFilter, parents);
+      
+      return new BlockJoinScorer(this, readerContext, childScorer, parents, firstChildDoc, scoreMode);
+    }
+
+    static void checkParentFilterBits( LeafReaderContext readerContext, BitSetProducer parentsFilter, final BitSet parents) {
+      if (!parents.get(readerContext.reader().maxDoc()-1)) {
+        throw new IllegalStateException("the given parent filter: "+ parentsFilter +
+            " doesn't match the last document in the segment: " + readerContext);
+      }
     }
 
     @Override
@@ -203,14 +212,16 @@ public class ToParentBlockJoinQuery extends Query {
     private int[] pendingChildDocs;
     private float[] pendingChildScores;
     private int childDocUpto;
+    private LeafReaderContext readerContext;
 
-    public BlockJoinScorer(Weight weight, Scorer childScorer, BitSet parentBits, int firstChildDoc, ScoreMode scoreMode) {
+    public BlockJoinScorer(Weight weight, LeafReaderContext readerContext, Scorer childScorer, BitSet parentBits, int firstChildDoc, ScoreMode scoreMode) {
       super(weight);
       //System.out.println("Q.init firstChildDoc=" + firstChildDoc);
       this.parentBits = parentBits;
       this.childScorer = childScorer;
       this.scoreMode = scoreMode;
-      nextChildDoc = firstChildDoc;
+      this.nextChildDoc = firstChildDoc;
+      this.readerContext = readerContext;
     }
 
     @Override
@@ -265,7 +276,7 @@ public class ToParentBlockJoinQuery extends Query {
       // Parent & child docs are supposed to be
       // orthogonal:
       if (nextChildDoc == parentDoc) {
-        throw new IllegalStateException("child query must only match non-parent docs, but parent docID=" + nextChildDoc + " matched childScorer=" + childScorer.getClass());
+        throwNonOrthogonal(nextChildDoc);
       }
 
       //System.out.println("  parentDoc=" + parentDoc);
@@ -308,7 +319,7 @@ public class ToParentBlockJoinQuery extends Query {
       // Parent & child docs are supposed to be
       // orthogonal:
       if (nextChildDoc == parentDoc) {
-        throw new IllegalStateException("child query must only match non-parent docs, but parent docID=" + nextChildDoc + " matched childScorer=" + childScorer.getClass());
+        throwNonOrthogonal(nextChildDoc);
       }
 
       switch(scoreMode) {
@@ -332,6 +343,11 @@ public class ToParentBlockJoinQuery extends Query {
       return parentDoc;
     }
 
+    private void throwNonOrthogonal(int localChildDoc) {
+      throw new IllegalStateException("child query must only match non-parent docs, but parent docID=" + 
+          readerContext.docBase+localChildDoc + " is matched by " + childScorer.getWeight().getQuery());
+    }
+
     @Override
     public int docID() {
       return parentDoc;
@@ -378,7 +394,7 @@ public class ToParentBlockJoinQuery extends Query {
 
       // Parent & child docs are supposed to be orthogonal:
       if (nextChildDoc == prevParentDoc) {
-        throw new IllegalStateException("child query must only match non-parent docs, but parent docID=" + nextChildDoc + " matched childScorer=" + childScorer.getClass());
+        throwNonOrthogonal(nextChildDoc);
       }
 
       final int nd = nextDoc();
diff --git a/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinValidation.java b/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinValidation.java
index c868a12..cbea1af 100644
--- a/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinValidation.java
+++ b/lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoinValidation.java
@@ -30,18 +30,23 @@ import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.Scorer;
 import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.Weight;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
+import org.junit.Test;
+
+import com.carrotsearch.randomizedtesting.annotations.Seed;
 
 public class TestBlockJoinValidation extends LuceneTestCase {
 
@@ -79,6 +84,60 @@ public class TestBlockJoinValidation extends LuceneTestCase {
     super.tearDown();
   }
 
+  public void testAbsentLastParentInSegment() throws Exception {
+    // find a parent in a segment
+    final List<LeafReaderContext> leaves = indexReader.leaves();
+    final LeafReaderContext leaf = leaves.get(random().nextInt(leaves.size()));
+    // let's find a parent
+    assumeTrue("isn't empty", leaf.reader().maxDoc()>1);
+    final String parentId = leaf.reader().document(leaf.reader().maxDoc()-1).get("id");
+    final String childId = leaf.reader().document(leaf.reader().maxDoc()-2).get("id");
+    
+    // let's remove last parent from bitset 
+    
+    
+      final BitSetProducer brokenParents = new QueryBitSetProducer(
+          new BooleanQuery.Builder().
+            add(new WildcardQuery(new Term("parent", "*")), Occur.MUST).
+            add(new TermQuery(new Term("id", parentId)), Occur.MUST_NOT)
+          .build()          );
+      
+     
+      try {
+        
+        if(random().nextBoolean()){
+          final ToParentBlockJoinQuery toPbjq = new ToParentBlockJoinQuery(new TermQuery(new Term("id", childId)),
+              brokenParents, anyScoreMode());
+          
+          indexSearcher.search(
+              rarely() ?  filterParents(toPbjq) : toPbjq , 1);
+        }else{
+          final ToChildBlockJoinQuery toChildBlockJoinQuery = new ToChildBlockJoinQuery(new TermQuery(new Term("id", parentId)), brokenParents);
+          indexSearcher.search(
+              rarely() ?  filterChildren(toChildBlockJoinQuery) : toChildBlockJoinQuery , 1);
+        }
+        fail("didn't get expected exception");
+      } catch (IllegalStateException expected) {
+        assertTrue(expected.getMessage()!=null);
+        assertTrue(expected.getMessage(), expected.getMessage().contains("the given parent filter"));
+        assertTrue(expected.getMessage(), expected.getMessage().contains("doesn't match the last document in the segment"));
+      }
+  }
+
+  private Query filterChildren(ToChildBlockJoinQuery toChildBlockJoinQuery) {
+    return new BooleanQuery.Builder().add(toChildBlockJoinQuery, Occur.SHOULD)
+        .add(new WildcardQuery(new Term("child", "*")),Occur.FILTER).build();
+  }
+
+  private ScoreMode anyScoreMode() {
+    return ScoreMode.values()[random().nextInt(ScoreMode.values().length)];
+  }
+
+  BooleanQuery filterParents(final ToParentBlockJoinQuery toPbjq) {
+    return new BooleanQuery.Builder().add(toPbjq, Occur.SHOULD)
+                              .add(new WildcardQuery(new Term("parent", "*")),Occur.FILTER).build();
+  }
+  
   public void testNextDocValidationForToParentBjq() throws Exception {
     Query parentQueryWithRandomChild = createChildrenQueryWithOneParent(getRandomChildNumber(0));
     ToParentBlockJoinQuery blockJoinQuery = new ToParentBlockJoinQuery(parentQueryWithRandomChild, parentsFilter, ScoreMode.None);
