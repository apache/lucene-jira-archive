Index: src/java/org/apache/lucene/index/SegmentReader.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentReader.java	(revision 887673)
+++ src/java/org/apache/lucene/index/SegmentReader.java	(working copy)
@@ -38,6 +38,7 @@
 import org.apache.lucene.util.BitVector;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.CloseableThreadLocal;
+import org.apache.lucene.util.UnicodeUtil;
 import org.apache.lucene.index.codecs.Codecs;
 import org.apache.lucene.index.codecs.Codec;
 import org.apache.lucene.index.codecs.preflex.PreFlexFields;
@@ -1356,19 +1357,12 @@
             // We found exactly the requested field; now
             // seek the term text:
             String text = t.text();
-            TermRef tr;
-
-            // this is a hack only for backwards compatibility.
-            // previously you could supply a term ending with a lead surrogate,
+            // this is only for backwards compatibility.
+            // previously you could supply a term with unpaired surrogates,
             // and it would return the next Term.
             // if someone does this, tack on the lowest possible trail surrogate.
             // this emulates the old behavior, and forms "valid UTF-8" unicode.
-            if (text.length() > 0 
-                && Character.isHighSurrogate(text.charAt(text.length() - 1))) {
-              tr = new TermRef(t.text() + "\uDC00");
-            } else {
-              tr = new TermRef(t.text());
-            }
+            TermRef tr = new TermRef(UnicodeUtil.nextValidUTF16String(text));
             TermsEnum.SeekStatus status = terms.seek(tr);
             if (status == TermsEnum.SeekStatus.END) {
               // Rollover to the next field
Index: src/java/org/apache/lucene/util/UnicodeUtil.java
===================================================================
--- src/java/org/apache/lucene/util/UnicodeUtil.java	(revision 887673)
+++ src/java/org/apache/lucene/util/UnicodeUtil.java	(working copy)
@@ -364,6 +364,48 @@
     result.length = outUpto;
   }
 
+  /**
+   * Get the next valid UTF-16 String in UTF-16 order.
+   * <p>
+   * If the input String is already valid, it is returned.
+   * Otherwise the next String in code unit order is returned.
+   * </p>
+   * @param s input String (possibly with unpaired surrogates)
+   * @return next valid UTF-16 String in UTF-16 order
+   */
+  public static String nextValidUTF16String(String s) {
+    final int size = s.length();
+    for (int i = 0; i < size; i++) {
+      char ch = s.charAt(i);
+      if (ch >= UnicodeUtil.UNI_SUR_HIGH_START
+          && ch <= UnicodeUtil.UNI_SUR_HIGH_END) {
+        if (i < size - 1) {
+          i++;
+          char nextCH = s.charAt(i);
+          if (nextCH >= UnicodeUtil.UNI_SUR_LOW_START
+              && nextCH <= UnicodeUtil.UNI_SUR_LOW_END) {
+            // Valid surrogate pair
+          } else
+          // Unmatched high surrogate
+            if (nextCH < UnicodeUtil.UNI_SUR_LOW_START) // SMP not enumerated 
+              return s.substring(0, i) + 
+                (char) UnicodeUtil.UNI_SUR_LOW_START;
+            else // SMP already enumerated
+              return s.substring(0, i - 1) + 
+                (char) (UnicodeUtil.UNI_SUR_LOW_END + 1);
+        } else
+        // Unmatched high surrogate in final position, SMP not yet enumerated
+        return s + (char) UnicodeUtil.UNI_SUR_LOW_START;
+      } else if (ch >= UnicodeUtil.UNI_SUR_LOW_START
+          && ch <= UnicodeUtil.UNI_SUR_LOW_END)
+      // Unmatched low surrogate, SMP already enumerated
+      return s.substring(0, i) + 
+        (char) (UnicodeUtil.UNI_SUR_LOW_END + 1);
+    }
+    
+    return s;
+  }
+  
   // Only called from assert
   /*
   private static boolean matches(char[] source, int offset, int length, byte[] result, int upto) {
Index: src/test/org/apache/lucene/util/TestUnicodeUtil.java
===================================================================
--- src/test/org/apache/lucene/util/TestUnicodeUtil.java	(revision 0)
+++ src/test/org/apache/lucene/util/TestUnicodeUtil.java	(revision 0)
@@ -0,0 +1,80 @@
+package org.apache.lucene.util;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/*
+ * Some of this code came from the excellent Unicode
+ * conversion examples from:
+ *
+ *   http://www.unicode.org/Public/PROGRAMS/CVTUTF
+ *
+ * Full Copyright for that code follows:
+*/
+
+/*
+ * Copyright 2001-2004 Unicode, Inc.
+ * 
+ * Disclaimer
+ * 
+ * This source code is provided as is by Unicode, Inc. No claims are
+ * made as to fitness for any particular purpose. No warranties of any
+ * kind are expressed or implied. The recipient agrees to determine
+ * applicability of information provided. If this file has been
+ * purchased on magnetic or optical media from Unicode, Inc., the
+ * sole remedy for any claim will be exchange of defective media
+ * within 90 days of receipt.
+ * 
+ * Limitations on Rights to Redistribute This Code
+ * 
+ * Unicode, Inc. hereby grants the right to freely use the information
+ * supplied in this file in the creation of products supporting the
+ * Unicode Standard, and to make copies of this file in any form
+ * for internal or external distribution as long as this notice
+ * remains attached.
+ */
+
+public class TestUnicodeUtil extends LuceneTestCase {
+  public void testNextValidUTF16String() {
+    // valid UTF-16
+    assertEquals("dogs", UnicodeUtil.nextValidUTF16String("dogs"));
+    assertEquals("dogs\uD802\uDC02", UnicodeUtil
+        .nextValidUTF16String("dogs\uD802\uDC02"));
+    
+    // an illegal combination, where we have not yet enumerated into the supp
+    // plane so we increment to H + \uDC00 (the lowest possible trail surrogate)
+    assertEquals("dogs\uD801\uDC00", UnicodeUtil
+        .nextValidUTF16String("dogs\uD801"));
+    assertEquals("dogs\uD801\uDC00", UnicodeUtil
+        .nextValidUTF16String("dogs\uD801b"));
+    assertEquals("dogs\uD801\uDC00", UnicodeUtil
+        .nextValidUTF16String("dogs\uD801\uD800"));
+    
+    // an illegal combination where we have already enumerated the supp plane
+    // we must replace both H and Z with \uE000 (the lowest possible
+    // "upper BMP")
+    assertEquals("dogs\uE000", UnicodeUtil
+        .nextValidUTF16String("dogs\uD801\uE001"));
+    
+    // an unpaired trail surrogate. this is invalid when not preceded by a lead
+    // surrogate. in this case we have to bump to \uE000 (the lowest possible
+    // "upper BMP")
+    assertEquals("dogs\uE000", UnicodeUtil.nextValidUTF16String("dogs\uDC00"));
+    assertEquals("\uE000", UnicodeUtil.nextValidUTF16String("\uDC00dogs"));
+  }
+}

Property changes on: src\test\org\apache\lucene\util\TestUnicodeUtil.java
___________________________________________________________________
Added: svn:eol-style
   + native

