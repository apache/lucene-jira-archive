Index: lucene/src/java/org/apache/lucene/index/SegmentReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/SegmentReader.java	(revision 1209666)
+++ lucene/src/java/org/apache/lucene/index/SegmentReader.java	(working copy)
@@ -572,6 +572,7 @@
   }
 
   private void openNorms(Directory cfsDir, IOContext context) throws IOException {
+    boolean normsInitiallyEmpty = norms.isEmpty(); // only used for assert
     long nextNormSeek = SegmentNorms.NORMS_HEADER.length; //skip header (header unused for now)
     int maxDoc = maxDoc();
     for (FieldInfo fi : core.fieldInfos) {
@@ -625,6 +626,7 @@
         nextNormSeek += maxDoc; // increment also if some norms are separate
       }
     }
+    assert singleNormStream == null || !normsInitiallyEmpty || nextNormSeek == singleNormStream.length();
   }
 
   // for testing only
Index: lucene/src/java/org/apache/lucene/index/NormsWriter.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/NormsWriter.java	(revision 1209666)
+++ lucene/src/java/org/apache/lucene/index/NormsWriter.java	(working copy)
@@ -60,7 +60,9 @@
       for (FieldInfo fi : state.fieldInfos) {
         final NormsWriterPerField toWrite = (NormsWriterPerField) fieldsToFlush.get(fi);
         int upto = 0;
-        if (toWrite != null && toWrite.upto > 0) {
+        // we must check the final value of omitNorms for the fieldinfo, it could have 
+        // changed for this field since the first time we added it.
+        if (!fi.omitNorms && toWrite != null && toWrite.upto > 0) {
           normCount++;
 
           int docID = 0;
