diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/BreakIteratorPassageBreaker.java b/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/BreakIteratorPassageBreaker.java
new file mode 100644
index 0000000000..a8bada62b3
--- /dev/null
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/BreakIteratorPassageBreaker.java
@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.search.matchhighlight;
+
+import java.text.BreakIterator;
+
+/**
+ * A {@link PassageBreaker} that uses a {@link BreakIterator} to find boundaries
+ * in the source text
+ */
+public class BreakIteratorPassageBreaker implements PassageBreaker {
+
+  private final BreakIterator breakIterator;
+  private final int maxPassageLength;
+
+  private int textLength;
+
+  /**
+   * Create a new breaker
+   * @param breakIterator     the {@link BreakIterator} to use to find boundaries
+   * @param maxPassageLength  the maximum length of a passage
+   */
+  public BreakIteratorPassageBreaker(BreakIterator breakIterator, int maxPassageLength) {
+    this.breakIterator = breakIterator;
+    this.maxPassageLength = maxPassageLength;
+  }
+
+  @Override
+  public void setText(String text) {
+    breakIterator.setText(text);
+    this.textLength = text.length();
+  }
+
+  @Override
+  public int findPassageStart(int previousPassageEnd, int firstHitStart, int nextHitEnd) {
+    if (firstHitStart == 0) {
+      return 0;
+    }
+    return breakIterator.preceding(firstHitStart);
+  }
+
+  @Override
+  public int findPassageEnd(int finalHitEnd, int nextHitEnd) {
+    int end = breakIterator.following(finalHitEnd);
+    return end == BreakIterator.DONE ? textLength : end;
+  }
+
+  @Override
+  public boolean shouldExtendPassage(int passageStart, int previousHitEnd, int currentHitStart, int currentHitEnd, int nextHitEnd) {
+    int maxOffset = passageStart + maxPassageLength;
+    if (currentHitEnd > maxOffset) {
+      // passage would be too long
+      return false;
+    }
+    if (maxOffset > nextHitEnd) {
+      return true;
+    }
+    if (nextHitEnd - currentHitEnd < currentHitStart - previousHitEnd) {
+      // the next hit is closer to the current hit than the the current hit is
+      // to its predecessor, so it makes more sense to add the current hit to the
+      // next passage
+      return false;
+    }
+    return true;
+  }
+}
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/Passage.java b/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/Passage.java
new file mode 100644
index 0000000000..01a0ad5c26
--- /dev/null
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/Passage.java
@@ -0,0 +1,107 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.search.matchhighlight;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.List;
+
+import org.apache.lucene.search.MatchesIterator;
+import org.apache.lucene.search.Query;
+
+/**
+ * Representation of a passage of text continaing highlights
+ */
+public class Passage {
+
+  private final List<Hit> hits;
+  private final int startOffset;
+  private final int endOffset;
+  private final String sourceText;
+
+  /**
+   * Create a new highlight passage
+   */
+  public Passage(List<Hit> hits, int startOffset, int endOffset, String sourceText) {
+    this.hits = new ArrayList<>(hits);
+    this.hits.sort(Comparator.comparingInt(Hit::getStart).thenComparingInt(Hit::getEnd));
+    this.startOffset = startOffset;
+    this.endOffset = endOffset;
+    this.sourceText = sourceText;
+  }
+
+  /**
+   * The starting offset of the passage
+   */
+  public int startOffset() {
+    return startOffset;
+  }
+
+  /**
+   * The ending offset of the passage
+   */
+  public int endOffset() {
+    return endOffset;
+  }
+
+  /**
+   * The text of the passage
+   */
+  public String getText() {
+    return sourceText.substring(startOffset, endOffset);
+  }
+
+  /**
+   * A list of the matching hits within this passage
+   *
+   * Note that hit offsets are relative to the start of the source text
+   */
+  public List<Hit> getHits() {
+    return hits;
+  }
+
+  /**
+   * Representation of an individual matching hit
+   */
+  public static class Hit {
+
+    final Query query;
+    final int pos;
+    final int start;
+    final int end;
+
+    public Hit(Query query, int pos, int start, int end) {
+      this.query = query;
+      this.pos = pos;
+      this.start = start;
+      this.end = end;
+    }
+
+    public int getStart() {
+      return start;
+    }
+
+    public int getEnd() { return end; }
+
+    public int getPosition() { return pos; }
+
+    public Query getSourceQuery() { return query; }
+  }
+
+}
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/PassageBreaker.java b/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/PassageBreaker.java
new file mode 100644
index 0000000000..4cc3f5c325
--- /dev/null
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/PassageBreaker.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.search.matchhighlight;
+
+/**
+ * Defines how a piece of text should be broken up into passages
+ */
+public interface PassageBreaker {
+
+  /**
+   * Sets the source text to be broken up
+   * @param text          the text
+   */
+  void setText(String text);
+
+  /**
+   * Return the start offset of the current passage
+   * @param lastPassageEnd the end offset of the previous passage
+   * @param firstHitStart  the start offset of the first hit in this passage
+   * @param nextHitEnd     the end offset of the subsequent hit
+   */
+  int findPassageStart(int lastPassageEnd, int firstHitStart, int nextHitEnd);
+
+  /**
+   * Return {@code true} if the passage should be extended to contain the current hit
+   * @param passageStart      the starting offset of the current passage
+   * @param previousHitEnd    the end offset of the previous hit
+   * @param currentHitStart   the start offset of the current hit
+   * @param currentHitEnd     the end offset of the current hit
+   * @param nextHitEnd        the end offset of the next hit
+   */
+  boolean shouldExtendPassage(int passageStart, int previousHitEnd, int currentHitStart, int currentHitEnd, int nextHitEnd);
+
+  /**
+   * Return the end offset of the current passage
+   * @param finalHitEnd   the end offset of the last hit in this passage
+   * @param nextHitStart  the start offset of the next hit
+   */
+  int findPassageEnd(int finalHitEnd, int nextHitStart);
+}
diff --git a/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/PassageBuilder.java b/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/PassageBuilder.java
new file mode 100644
index 0000000000..65d575ca5d
--- /dev/null
+++ b/lucene/highlighter/src/java/org/apache/lucene/search/matchhighlight/PassageBuilder.java
@@ -0,0 +1,259 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.search.matchhighlight;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.search.MatchesIterator;
+import org.apache.lucene.search.Query;
+
+/**
+ * Builds passages containing matching hits over a source text
+ *
+ * Users should call {@link #setText(String, int)} with the source text, and
+ * then {@link #nextPassage()} to retrieve passages.  Once {@link #nextPassage()}} has returned
+ * {@code null}, {@link #setText(String, int)} may be called again to add further text (for
+ * example, from a multivalued field), the offset parameter being incremented each time appropriately
+ */
+public class PassageBuilder {
+
+  private final PeekableMatchesIterator iterator;
+  private final PassageBreaker breaker;
+
+  private int textOffset;
+  private String text;
+
+  private boolean more;
+  private int lastPassageEnd = -1;
+
+  /**
+   * Creates a new PassageBuilder
+   * @param iterator      an unpositioned {@link MatchesIterator} over the source text
+   * @param breaker       a {@link PassageBreaker} defining how to break the source text into passages
+   */
+  public PassageBuilder(MatchesIterator iterator, PassageBreaker breaker) throws IOException {
+    this.iterator = new PeekableMatchesIterator(iterator);
+    this.breaker = breaker;
+    this.more = iterator.next();
+  }
+
+  /**
+   * Set the source text to extract passages from
+   * @param text    the source text
+   * @param offset  the text offset of the source text
+   */
+  public void setText(String text, int offset) {
+    this.text = text;
+    this.textOffset = offset;
+    this.breaker.setText(text);
+  }
+
+  /**
+   * Return the next {@link Passage} extracted from the text
+   * @return a {@link Passage}, or {@code null} if no more passages can be found
+   */
+  public final Passage nextPassage() throws IOException {
+    if (more == false) {    // iterator is exhausted
+      return null;
+    }
+    if (iterator.startOffset() > (this.text.length() + this.textOffset)) {
+      // iterator is positioned past the end of the current text segment
+      return null;
+    }
+    while (iterator.startOffset() < this.textOffset) {
+      if ((more = iterator.next()) == false) {
+        return null;
+      }
+    }
+    List<Passage.Hit> hits = new ArrayList<>();
+    int passageStart = breaker.findPassageStart(lastPassageEnd, iterator.startOffset() - this.textOffset, iterator.peekNextEndOffset() - this.textOffset);
+    int previousHitEnd;
+    do {
+      collectHits(iterator, hits);
+      previousHitEnd = iterator.endOffset() - this.textOffset;
+      more = iterator.next();
+    }
+    while (more
+        && breaker.shouldExtendPassage(passageStart, previousHitEnd,
+        iterator.startOffset() - this.textOffset, iterator.endOffset() - this.textOffset, iterator.peekNextEndOffset() - this.textOffset));
+    lastPassageEnd = breaker.findPassageEnd(previousHitEnd, iterator.peekNextEndOffset() - this.textOffset);
+    return new Passage(hits, passageStart, lastPassageEnd, text);
+  }
+
+  private void collectHits(MatchesIterator it, List<Passage.Hit> hits) throws IOException {
+    MatchesIterator subIt = it.getSubMatches();
+    if (subIt == null) {
+      hits.add(new Passage.Hit(it.getQuery(), it.startPosition(), it.startOffset() - textOffset, it.endOffset() - textOffset));
+    }
+    else {
+      while (subIt.next()) {
+        hits.add(new Passage.Hit(subIt.getQuery(), subIt.startPosition(), subIt.startOffset() - textOffset, subIt.endOffset() - textOffset));
+      }
+    }
+  }
+
+  private static class TermMatch {
+    int pos;
+    int startOffset;
+    int endOffset;
+    Query query;
+  }
+
+  private static class PeekableMatchesIterator implements MatchesIterator {
+
+    final MatchesIterator in;
+
+    int startPosition = -1;
+    int endPosition;
+    int startOffset;
+    int endOffset;
+    Query query;
+    TermMatch[] subMatches = new TermMatch[0];
+    int subMatchesCount = 0;
+
+    boolean more = true;
+
+    PeekableMatchesIterator(MatchesIterator in) {
+      this.in = in;
+    }
+
+    int peekNextEndOffset() throws IOException {
+      if (more == false) {
+        return Integer.MAX_VALUE;
+      }
+      if (startPosition != -1) {
+        return endOffset;
+      }
+      startPosition = in.startPosition();
+      endPosition = in.endPosition();
+      startOffset = in.startOffset();
+      endOffset = in.endOffset();
+      query = in.getQuery();
+
+      MatchesIterator subs = in.getSubMatches();
+      subMatchesCount = 0;
+      if (subs != null) {
+        while (subs.next()) {
+          subMatchesCount++;
+          if (subMatchesCount >= subMatches.length) {
+            TermMatch[] temp = new TermMatch[subMatchesCount];
+            System.arraycopy(subMatches, 0, temp, 0, subMatchesCount - 1);
+            subMatches = temp;
+            subMatches[subMatchesCount - 1] = new TermMatch();
+          }
+          subMatches[subMatchesCount - 1].pos = subs.startPosition();
+          subMatches[subMatchesCount - 1].startOffset = subs.startOffset();
+          subMatches[subMatchesCount - 1].endOffset = subs.endOffset();
+          subMatches[subMatchesCount - 1].query = subs.getQuery();
+        }
+      }
+
+      if (in.next()) {
+        return in.endOffset();
+      }
+      more = false;
+      return Integer.MAX_VALUE;
+    }
+
+    @Override
+    public boolean next() throws IOException {
+      if (startPosition == -1) {
+        return more = in.next();
+      }
+      startPosition = -1;
+      return more;
+    }
+
+    @Override
+    public int startPosition() {
+      return startPosition != -1 ? startPosition : in.startPosition();
+    }
+
+    @Override
+    public int endPosition() {
+      return startPosition != -1 ? endPosition : in.endPosition();
+    }
+
+    @Override
+    public int startOffset() throws IOException {
+      return startPosition != -1 ? startOffset : in.startOffset();
+    }
+
+    @Override
+    public int endOffset() throws IOException {
+      return startPosition != -1 ? endOffset : in.endOffset();
+    }
+
+    @Override
+    public Query getQuery() {
+      return startPosition != -1 ? query : in.getQuery();
+    }
+
+    @Override
+    public MatchesIterator getSubMatches() throws IOException {
+      if (startPosition == -1) {
+        return in.getSubMatches();
+      }
+      if (subMatchesCount == 0) {
+        return null;
+      }
+      return new MatchesIterator() {
+
+        int upto = -1;
+
+        @Override
+        public boolean next() {
+          upto++;
+          return upto < subMatchesCount;
+        }
+
+        @Override
+        public int startPosition() {
+          return subMatches[upto].pos;
+        }
+
+        @Override
+        public int endPosition() {
+          return subMatches[upto].pos;
+        }
+
+        @Override
+        public int startOffset() {
+          return subMatches[upto].startOffset;
+        }
+
+        @Override
+        public int endOffset() {
+          return subMatches[upto].endOffset;
+        }
+
+        @Override
+        public MatchesIterator getSubMatches() {
+          return null;
+        }
+
+        @Override
+        public Query getQuery() {
+          return subMatches[upto].query;
+        }
+      };
+    }
+  }
+}
diff --git a/lucene/highlighter/src/test/org/apache/lucene/search/matchhighlight/TestPassageBuilder.java b/lucene/highlighter/src/test/org/apache/lucene/search/matchhighlight/TestPassageBuilder.java
new file mode 100644
index 0000000000..87ae24812e
--- /dev/null
+++ b/lucene/highlighter/src/test/org/apache/lucene/search/matchhighlight/TestPassageBuilder.java
@@ -0,0 +1,307 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.search.matchhighlight;
+
+import java.io.IOException;
+import java.text.BreakIterator;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.MatchesIterator;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestPassageBuilder extends LuceneTestCase {
+
+  public void testSimpleHighlighting() throws IOException {
+    //             0         1         2         3         4         5
+    //             012345678901234567890123456789012345678901234567890
+    String text = "This is a sentence.  And this is another sentence";
+    TermQuery tq = new TermQuery(new Term("field", "sentence"));
+    MatchesIterator mi = new MatchesIteratorBuilder()
+        .addTermMatch(tq, 3, 10, 18)
+        .addTermMatch(tq, 8, 41, 49)
+        .build();
+
+    PassageBuilder builder = new PassageBuilder(mi, new BreakIteratorPassageBreaker(BreakIterator.getSentenceInstance(Locale.ROOT), 20));
+    builder.setText(text, 0);
+
+    Passage passage = builder.nextPassage();
+    assertEquals(1, passage.getHits().size());
+    assertEquals("This is a sentence.  ", passage.getText());
+    assertEquals(0, passage.startOffset());
+    assertEquals(21, passage.endOffset());
+    passage = builder.nextPassage();
+    assertEquals(1, passage.getHits().size());
+    assertEquals("And this is another sentence", passage.getText());
+    assertEquals(21, passage.startOffset());
+    assertEquals(49, passage.endOffset());
+    assertNull(builder.nextPassage());
+
+  }
+
+  public void testWithOffset() throws IOException {
+    //             0         1         2         3         4         5
+    //             012345678901234567890123456789012345678901234567890
+    String text = "This is a sentence.  And this is another sentence";
+    TermQuery tq = new TermQuery(new Term("field", "sentence"));
+    MatchesIterator mi = new MatchesIteratorBuilder()
+        .addTermMatch(tq, 3, 110, 118)
+        .addTermMatch(tq, 8, 141, 149)
+        .build();
+
+    PassageBuilder builder = new PassageBuilder(mi, new BreakIteratorPassageBreaker(BreakIterator.getSentenceInstance(Locale.ROOT), 20));
+    builder.setText(text, 100);
+
+    Passage passage = builder.nextPassage();
+    assertNotNull(passage);
+    assertEquals(1, passage.getHits().size());
+    assertEquals(10, passage.getHits().get(0).start);   // offsets are relative to source text
+    assertEquals(18, passage.getHits().get(0).end);
+    assertEquals("This is a sentence.  ", passage.getText());
+    passage = builder.nextPassage();
+    assertNotNull(passage);
+    assertEquals(1, passage.getHits().size());
+    assertNull(builder.nextPassage());
+  }
+
+  public void testPeeking() throws IOException {
+    //             0         1         2         3         4         5         6         7         8
+    //             012345678901234567890123456789012345678901234567890123456789012345678901234567890
+    String text = "This is a sentence.  And this is another sentence. And another sentence";
+    TermQuery tq = new TermQuery(new Term("field", "sentence"));
+    MatchesIterator mi = new MatchesIteratorBuilder()
+        .addTermMatch(tq, 3, 10, 18)
+        .addTermMatch(tq, 8, 41, 49)
+        .addTermMatch(tq, 12, 63, 70)
+        .build();
+
+    PassageBuilder builder = new PassageBuilder(mi, new BreakIteratorPassageBreaker(BreakIterator.getSentenceInstance(Locale.ROOT), 60));
+    builder.setText(text, 0);
+
+    Passage passage = builder.nextPassage();
+    assertNotNull(passage);
+    assertEquals(1, passage.getHits().size());
+    passage = builder.nextPassage();
+    assertNotNull(passage);
+    assertEquals(2, passage.getHits().size());
+    assertNull(builder.nextPassage());
+  }
+
+  public void testSubmatches() throws IOException {
+    //             0         1         2         3         4         5         6         7         8
+    //             012345678901234567890123456789012345678901234567890123456789012345678901234567890
+    String text = "This is a sentence.  And this is another sentence. And another sentence";
+    Query q = new TermQuery(new Term("field", "term"));
+    MatchesIterator mi = new MatchesIteratorBuilder()
+        .addMultiMatch()
+          .addSubMatch(q, 0, 0, 4)
+          .addSubMatch(q, 3, 10, 18)
+          .build()
+        .addMultiMatch()
+          .addSubMatch(q, 5, 25, 29)
+          .addSubMatch(q, 8, 41, 49)
+          .build()
+        .build();
+
+    PassageBuilder builder = new PassageBuilder(mi, new BreakIteratorPassageBreaker(BreakIterator.getSentenceInstance(Locale.ROOT), 30));
+    builder.setText(text, 0);
+
+    Passage passage = builder.nextPassage();
+    assertNotNull(passage);
+    assertEquals(2, passage.getHits().size());
+    assertEquals("This is a sentence.  ", passage.getText());
+    assertEquals(0, passage.getHits().get(0).start);
+    passage = builder.nextPassage();
+    assertNotNull(passage);
+    assertEquals(2, passage.getHits().size());
+    assertEquals("And this is another sentence. ", passage.getText());
+
+  }
+
+  public void testMultivaluedText() throws IOException {
+    //              0         1         2         3
+    //              0123456789012345678901234567890
+    String text1 = "This is a sentence. ";
+    String text2 = "This is a wibble. ";
+    String text3 = "And yet another sentence here!";
+    Query q = new TermQuery(new Term("field", "sentence"));
+    MatchesIterator mi = new MatchesIteratorBuilder()
+        .addTermMatch(q, 3, 10, 18)
+        .addTermMatch(q, 11, 254, 262)
+        .build();
+
+    PassageBuilder builder = new PassageBuilder(mi, new BreakIteratorPassageBreaker(BreakIterator.getSentenceInstance(Locale.ROOT), 30));
+    builder.setText(text1, 0);
+
+    Passage passage = builder.nextPassage();
+    assertNotNull(passage);
+    assertNull(builder.nextPassage());
+
+    int offset = text1.length() + 100;
+    builder.setText(text2, offset);
+    assertNull(builder.nextPassage());
+
+    offset += text2.length() + 100;
+    builder.setText(text3, offset);
+    passage = builder.nextPassage();
+    assertEquals(1, passage.getHits().size());
+    assertEquals(16, passage.getHits().get(0).start);
+    assertEquals(24, passage.getHits().get(0).end);
+    assertEquals(0, passage.startOffset());
+    assertEquals(30, passage.endOffset());
+    assertEquals("And yet another sentence here!", passage.getText());
+    assertNull(builder.nextPassage());
+  }
+
+  private class SubMatchesIteratorBuilder {
+
+    final MatchesIteratorBuilder parent;
+    List<Passage.Hit> matches = new ArrayList<>();
+
+    private SubMatchesIteratorBuilder(MatchesIteratorBuilder parent) {
+      this.parent = parent;
+    }
+
+    SubMatchesIteratorBuilder addSubMatch(Query query, int pos, int startOffset, int endOffset) {
+      matches.add(new Passage.Hit(query, pos, startOffset, endOffset));
+      return this;
+    }
+
+    MatchesIteratorBuilder build() {
+      this.parent.matches.add(matches);
+      return parent;
+    }
+  }
+
+  private class MatchesIteratorBuilder {
+
+    List<List<Passage.Hit>> matches = new ArrayList<>();
+
+    MatchesIteratorBuilder addTermMatch(Query query, int pos, int startOffset, int endOffset) {
+      List<Passage.Hit> match = new ArrayList<>();
+      match.add(new Passage.Hit(query, pos, startOffset, endOffset));
+      matches.add(match);
+      return this;
+    }
+
+    SubMatchesIteratorBuilder addMultiMatch() {
+      return new SubMatchesIteratorBuilder(this);
+    }
+
+    MatchesIterator build() {
+      return new MatchesIterator() {
+        int upto = -1;
+        int submatchCount = 0;
+        @Override
+        public boolean next() throws IOException {
+          upto++;
+          if (upto < matches.size()) {
+            submatchCount = matches.get(upto).size();
+            return true;
+          }
+          return false;
+        }
+
+        @Override
+        public int startPosition() {
+          return matches.get(upto).get(0).pos;
+        }
+
+        @Override
+        public int endPosition() {
+          return matches.get(upto).get(submatchCount - 1).pos;
+        }
+
+        @Override
+        public int startOffset() throws IOException {
+          return matches.get(upto).get(0).start;
+        }
+
+        @Override
+        public int endOffset() throws IOException {
+          return matches.get(upto).get(submatchCount - 1).end;
+        }
+
+        @Override
+        public MatchesIterator getSubMatches() throws IOException {
+          if (matches.size() < 2) {
+            return null;
+          }
+          return new MatchesIterator() {
+
+            int subUpto = -1;
+
+            @Override
+            public boolean next() throws IOException {
+              subUpto++;
+              return subUpto < matches.get(upto).size();
+            }
+
+            @Override
+            public int startPosition() {
+              return matches.get(upto).get(subUpto).pos;
+            }
+
+            @Override
+            public int endPosition() {
+              return matches.get(upto).get(subUpto).pos;
+            }
+
+            @Override
+            public int startOffset() throws IOException {
+              return matches.get(upto).get(subUpto).start;
+            }
+
+            @Override
+            public int endOffset() throws IOException {
+              return matches.get(upto).get(subUpto).end;
+            }
+
+            @Override
+            public MatchesIterator getSubMatches() throws IOException {
+              return null;
+            }
+
+            @Override
+            public Query getQuery() {
+              return matches.get(upto).get(subUpto).query;
+            }
+          };
+        }
+
+        @Override
+        public Query getQuery() {
+          BooleanQuery.Builder builder = new BooleanQuery.Builder();
+          for (Passage.Hit hit : matches.get(upto)) {
+            builder.add(hit.query, BooleanClause.Occur.MUST);
+          }
+          return builder.build();
+        }
+
+      };
+    }
+
+  }
+
+}
