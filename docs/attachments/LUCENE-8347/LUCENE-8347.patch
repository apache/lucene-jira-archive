diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester.java
index 413d401b6a..0b61876c1d 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester.java
@@ -18,6 +18,7 @@ package org.apache.lucene.search.suggest.analyzing;
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Comparator;
 import java.util.List;
 import java.util.Map;
@@ -83,7 +84,7 @@ public class BlendedInfixSuggester extends AnalyzingInfixSuggester {
    */
   public static enum BlenderType {
     /** Application dependent; override {@link
-     *  #calculateCoefficient} to compute it. */
+     *  #calculatePositionalCoefficient} to compute it. */
     CUSTOM,
     /** weight*(1 - 0.10*position) */
     POSITION_LINEAR,
@@ -217,15 +218,18 @@ public class BlendedInfixSuggester extends AnalyzingInfixSuggester {
         payload = null;
       }
 
-      double coefficient;
-      if (text.startsWith(key.toString())) {
-        // if hit starts with the key, we don't change the score
-        coefficient = 1;
-      } else {
-        coefficient = createCoefficient(searcher, fd.doc, matchedTokens, prefixToken);
+      int matchedTokensCount = matchedTokens.size();
+      if (prefixToken != null) {
+        matchedTokensCount++;
       }
 
-      long score = (long) (weight * coefficient);
+      double positionalCoefficient = calculatePositionalCoefficient(searcher, fd.doc, matchedTokens, prefixToken, matchedTokensCount);
+      double tokenCountCoefficient = getMatchedTokenCountCoefficient(searcher, matchedTokensCount, fd.doc);
+      
+      if (weight == 0) {
+        weight = 1;
+      }
+      long score = (long) (weight * (97 * positionalCoefficient) + (3 * tokenCountCoefficient));
 
       LookupResult result;
       if (doHighlight) {
@@ -260,6 +264,22 @@ public class BlendedInfixSuggester extends AnalyzingInfixSuggester {
     results.add(result);
   }
 
+  /**
+   * Calculate a coefficient that is affected by the length of the content of the field under evaluation.
+   * It measures the intersection of terms between the query terms and the field content.
+   * A value of 1 means the field content contains exactly the same number of query terms.
+   *
+   * @param doc                id of the document
+   * @param matchedTokensCount number of tokens found in the query
+   * @return the coefficient
+   * @throws IOException If there are problems reading term vectors from the underlying Lucene index.
+   */
+  protected double getMatchedTokenCountCoefficient(IndexSearcher searcher, int matchedTokensCount, int doc) throws IOException {
+    Terms tv = searcher.getIndexReader().getTermVector(doc, TEXT_FIELD_NAME);
+    double tokenCount = tv.getSumTotalTermFreq();
+    return matchedTokensCount / tokenCount;
+  }
+  
   /**
    * Create the coefficient to transform the weight.
    *
@@ -269,33 +289,27 @@ public class BlendedInfixSuggester extends AnalyzingInfixSuggester {
    * @return the coefficient
    * @throws IOException If there are problems reading term vectors from the underlying Lucene index.
    */
-  private double createCoefficient(IndexSearcher searcher, int doc, Set<String> matchedTokens, String prefixToken) throws IOException {
-
+  protected double calculatePositionalCoefficient(IndexSearcher searcher, int doc, Set<String> matchedTokens, String prefixToken, int matchedTokensCount) throws IOException {
     Terms tv = searcher.getIndexReader().getTermVector(doc, TEXT_FIELD_NAME);
     TermsEnum it = tv.iterator();
-
-    Integer position = Integer.MAX_VALUE;
     BytesRef term;
+    int[] matchedTokensPositions;
+    matchedTokensPositions = new int[matchedTokensCount];
+    int positionIndex = 0;
     // find the closest token position
     while ((term = it.next()) != null) {
-
       String docTerm = term.utf8ToString();
-
       if (matchedTokens.contains(docTerm) || (prefixToken != null && docTerm.startsWith(prefixToken))) {
- 
         PostingsEnum docPosEnum = it.postings(null, PostingsEnum.OFFSETS);
         docPosEnum.nextDoc();
-
         // use the first occurrence of the term
-        int p = docPosEnum.nextPosition();
-        if (p < position) {
-          position = p;
-        }
+        int matchedTermFirstPosition = docPosEnum.nextPosition();
+        matchedTokensPositions[positionIndex] = matchedTermFirstPosition;
+        positionIndex++;
       }
     }
-
-    // create corresponding coefficient based on position
-    return calculateCoefficient(position);
+    Arrays.sort(matchedTokensPositions);
+    return calculateProductPositionalCoefficient(matchedTokensPositions);
   }
 
   /**
@@ -304,7 +318,7 @@ public class BlendedInfixSuggester extends AnalyzingInfixSuggester {
    * @param position of the first matching word in text
    * @return the coefficient
    */
-  protected double calculateCoefficient(int position) {
+  protected double calculatePositionalCoefficient(int position) {
 
     double coefficient;
     switch (blenderType) {
@@ -327,6 +341,29 @@ public class BlendedInfixSuggester extends AnalyzingInfixSuggester {
     return coefficient;
   }
 
+  /**
+   * Calculate the weight coefficient based on the position of all the matching words.
+   * It is just the product of the discontinued positions.
+   *
+   * @param positions of all the matching words in text
+   * @return the coefficient
+   */
+  protected double calculateProductPositionalCoefficient(int[] positions) {
+    double coefficient = 1;
+    int lastPosition = -1;
+    for (int i = 0; i < positions.length; i++) {
+      if (positions[i] != lastPosition + 1) {
+        double tokenPositionalCoefficient = calculatePositionalCoefficient(positions[i]);
+        double idealPositionalCoefficient = calculatePositionalCoefficient(i);
+        double normalizedPositionalCoefficient = tokenPositionalCoefficient / idealPositionalCoefficient;// how much the matched token position differs from the ideal position
+        double positionalWeightDecay = Math.min(1.0, 1 - calculatePositionalCoefficient(i + 1));// closer the misposition is to the beginning, stronger the decay of the coefficient
+        coefficient = coefficient * normalizedPositionalCoefficient * positionalWeightDecay;
+      }
+      lastPosition = positions[i];
+    }
+    return coefficient;
+  }
+
   private static Comparator<Lookup.LookupResult> LOOKUP_COMP = new LookUpComparator();
 
   private static class LookUpComparator implements Comparator<Lookup.LookupResult> {
diff --git a/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest.java b/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest.java
index ace4467895..c3ccc32ddf 100644
--- a/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest.java
+++ b/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest.java
@@ -36,96 +36,236 @@ import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
 
+import static org.hamcrest.core.Is.is;
+
 public class BlendedInfixSuggesterTest extends LuceneTestCase {
 
+  public void testSinglePositionalCoefficient_linearBlendingType_shouldCalculateLinearCoefficient() throws IOException {
+    BlendedInfixSuggester linearSuggester = this.getBlendedInfixSuggester(new Input[]{}, BlendedInfixSuggester.BlenderType.POSITION_LINEAR);
+    int inputPosition = 5;
+
+    double positionalCoefficient = linearSuggester.calculatePositionalCoefficient(inputPosition);
+
+    assertEquals(1 - 0.1 * inputPosition, positionalCoefficient, 0.01);
+
+    linearSuggester.close();
+  }
+
+  public void testSinglePositionalCoefficient_reciprocalBlendingType_shouldCalculateLinearCoefficient() throws IOException {
+    BlendedInfixSuggester reciprocalSuggester = this.getBlendedInfixSuggester(new Input[]{}, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL);
+    int inputPosition = 5;
+
+    double positionalCoefficient = reciprocalSuggester.calculatePositionalCoefficient(inputPosition);
+
+    assertEquals(1. / (inputPosition + 1.0), positionalCoefficient, 0.01);
+
+    reciprocalSuggester.close();
+  }
+
+  public void testSinglePositionalCoefficient_exponentialBlendingType_shouldCalculateLinearCoefficient() throws IOException {
+    BlendedInfixSuggester exponentialReciprocalSuggester = this.getBlendedInfixSuggester(new Input[]{}, BlendedInfixSuggester.BlenderType.POSITION_EXPONENTIAL_RECIPROCAL);
+    int inputPosition = 5;
+
+    double positionalCoefficient = exponentialReciprocalSuggester.calculatePositionalCoefficient(inputPosition);
+
+    assertEquals(1. / Math.pow((inputPosition + 1.0), 2), positionalCoefficient, 0.01);
+
+    exponentialReciprocalSuggester.close();
+  }
+
+  public void testProductDiscontinuedPositionalCoefficient_linearBlendingType_shouldCalculateLinearCoefficient() throws IOException {
+    BlendedInfixSuggester linearSuggester = this.getBlendedInfixSuggester(new Input[]{}, BlendedInfixSuggester.BlenderType.POSITION_LINEAR);
+    int[] inputPosition1 = new int[]{0, 1, 2};
+    int[] inputPosition2 = new int[]{0, 1, 3};
+    int[] inputPosition3 = new int[]{0, 1, 4};
+    int[] inputPosition4 = new int[]{0, 2, 3};
+    int[] inputPosition5 = new int[]{1, 2, 3};
+
+    double positionalCoefficient1 = linearSuggester.calculateProductPositionalCoefficient(inputPosition1);
+    double positionalCoefficient2 = linearSuggester.calculateProductPositionalCoefficient(inputPosition2);
+    double positionalCoefficient3 = linearSuggester.calculateProductPositionalCoefficient(inputPosition3);
+    double positionalCoefficient4 = linearSuggester.calculateProductPositionalCoefficient(inputPosition4);
+    double positionalCoefficient5 = linearSuggester.calculateProductPositionalCoefficient(inputPosition5);
+
+    assertTrue(positionalCoefficient1 > positionalCoefficient2);
+    assertTrue(positionalCoefficient2 > positionalCoefficient3);
+    assertTrue(positionalCoefficient3 > positionalCoefficient4);
+    assertTrue(positionalCoefficient4 > positionalCoefficient5);
+
+    linearSuggester.close();
+  }
+
+  public void testProductDiscontinuedPositionalCoefficient_reciprocalBlendingType_shouldCalculateLinearCoefficient() throws IOException {
+    BlendedInfixSuggester reciprocalSuggester = this.getBlendedInfixSuggester(new Input[]{}, BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL);
+    int[] inputPosition1 = new int[]{0, 1, 2};
+    int[] inputPosition2 = new int[]{0, 1, 3};
+    int[] inputPosition3 = new int[]{0, 1, 4};
+    int[] inputPosition4 = new int[]{0, 2, 3};
+    int[] inputPosition5 = new int[]{1, 2, 3};
+
+    double positionalCoefficient1 = reciprocalSuggester.calculateProductPositionalCoefficient(inputPosition1);
+    double positionalCoefficient2 = reciprocalSuggester.calculateProductPositionalCoefficient(inputPosition2);
+    double positionalCoefficient3 = reciprocalSuggester.calculateProductPositionalCoefficient(inputPosition3);
+    double positionalCoefficient4 = reciprocalSuggester.calculateProductPositionalCoefficient(inputPosition4);
+    double positionalCoefficient5 = reciprocalSuggester.calculateProductPositionalCoefficient(inputPosition5);
+
+    assertTrue(positionalCoefficient1 > positionalCoefficient2);
+    assertTrue(positionalCoefficient2 > positionalCoefficient3);
+    assertTrue(positionalCoefficient3 > positionalCoefficient4);
+    assertTrue(positionalCoefficient4 > positionalCoefficient5);
+
+    reciprocalSuggester.close();
+  }
 
+  /**
+   * An exponential reciprocal approach will penalise less based on the first position of the first mismatched, favouring consecutive matches that happen
+   * a little bit later on the field content.
+   *
+   */
+  public void testProductDiscontinuedPositionalCoefficient_exponentialBlendingType_shouldCalculateLinearCoefficient() throws IOException {
+    BlendedInfixSuggester exponentialReciprocalSuggester = this.getBlendedInfixSuggester(new Input[]{}, BlendedInfixSuggester.BlenderType.POSITION_EXPONENTIAL_RECIPROCAL);
+    int[] inputPosition1 = new int[]{0, 1, 2};
+    int[] inputPosition2 = new int[]{0, 1, 3};
+    int[] inputPosition3 = new int[]{0, 2, 3};
+    int[] inputPosition4 = new int[]{0, 1, 4};
+    int[] inputPosition5 = new int[]{1, 2, 3};
+    int[] inputPosition6 = new int[]{0, 2, 4};
+    int[] inputPosition7 = new int[]{2, 3, 4};
+
+    double positionalCoefficient1 = exponentialReciprocalSuggester.calculateProductPositionalCoefficient(inputPosition1);
+    double positionalCoefficient2 = exponentialReciprocalSuggester.calculateProductPositionalCoefficient(inputPosition2);
+    double positionalCoefficient3 = exponentialReciprocalSuggester.calculateProductPositionalCoefficient(inputPosition3);
+    double positionalCoefficient4 = exponentialReciprocalSuggester.calculateProductPositionalCoefficient(inputPosition4);
+    double positionalCoefficient5 = exponentialReciprocalSuggester.calculateProductPositionalCoefficient(inputPosition5);
+    double positionalCoefficient6 = exponentialReciprocalSuggester.calculateProductPositionalCoefficient(inputPosition6);
+    double positionalCoefficient7 = exponentialReciprocalSuggester.calculateProductPositionalCoefficient(inputPosition7);
+
+    assertTrue(positionalCoefficient1 > positionalCoefficient2);
+    assertTrue(positionalCoefficient2 > positionalCoefficient3);
+    assertTrue(positionalCoefficient3 > positionalCoefficient4);
+    assertTrue(positionalCoefficient4 > positionalCoefficient5);
+    assertTrue(positionalCoefficient5 > positionalCoefficient6);
+    assertTrue(positionalCoefficient6 > positionalCoefficient7);
+
+    exponentialReciprocalSuggester.close();
+  }
+  
   /**
    * Test the weight transformation depending on the position
    * of the matching term.
    */
   public void testBlendedSort() throws IOException {
-
     BytesRef payload = new BytesRef("star");
-
     Input keys[] = new Input[]{
         new Input("star wars: episode v - the empire strikes back", 8, payload)
     };
+    BlendedInfixSuggester suggester = getBlendedInfixSuggester(keys, BlendedInfixSuggester.BlenderType.POSITION_LINEAR);
 
-    Path tempDir = createTempDir("BlendedInfixSuggesterTest");
-
-    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);
-    BlendedInfixSuggester suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,
-                                                                AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,
-                                                                BlendedInfixSuggester.BlenderType.POSITION_LINEAR,
-                                                                BlendedInfixSuggester.DEFAULT_NUM_FACTOR, false);
-    suggester.build(new InputArrayIterator(keys));
-
-    // we query for star wars and check that the weight
-    // is smaller when we search for tokens that are far from the beginning
+    assertSuggestionsRanking(payload, suggester);
+  }
 
-    long w0 = getInResults(suggester, "star ", payload, 1);
-    long w1 = getInResults(suggester, "war", payload, 1);
-    long w2 = getInResults(suggester, "empire ba", payload, 1);
-    long w3 = getInResults(suggester, "back", payload, 1);
-    long w4 = getInResults(suggester, "bacc", payload, 1);
+  /**
+   * Test to validate the suggestions ranking according to the position coefficient,
+   * even if the weight associated to the suggestion is unitary.
+   */
+  public void testBlendedSort_fieldWeightUnitary_shouldRankSuggestionsByPositionMatch() throws IOException {
+    BytesRef payload = new BytesRef("star");
+    Input keys[] = new Input[]{
+        new Input("star wars: episode v - the empire strikes back", 1, payload)
+    };
+    BlendedInfixSuggester suggester = getBlendedInfixSuggester(keys, BlendedInfixSuggester.BlenderType.POSITION_LINEAR);
 
-    assertTrue(w0 > w1);
-    assertTrue(w1 > w2);
-    assertTrue(w2 > w3);
+    assertSuggestionsRanking(payload, suggester);
+  }
 
-    assertTrue(w4 < 0);
+  /**
+   * Test to validate the suggestions ranking according to the position coefficient,
+   * even if the weight associated to the suggestion is zero.
+   */
+  public void testBlendedSort_fieldWeightZero_shouldRankSuggestionsByPositionMatch() throws IOException {
+    BytesRef payload = new BytesRef("star");
+    Input keys[] = new Input[]{
+        new Input("star wars: episode v - the empire strikes back", 0, payload)
+    };
+    BlendedInfixSuggester suggester = getBlendedInfixSuggester(keys, BlendedInfixSuggester.BlenderType.POSITION_LINEAR);
 
-    suggester.close();
+    assertSuggestionsRanking(payload, suggester);
   }
 
   /**
-   * Verify the different flavours of the blender types
+   * Test the weight transformation depending on the position
+   * of the matching term.
    */
-  public void testBlendingType() throws IOException {
+  public void testBlendedSort_multiTermQuery_shouldRankSuggestionsAccordinEachTermPosition() throws IOException {
 
-    BytesRef pl = new BytesRef("lake");
-    long w = 20;
+    BytesRef payload = new BytesRef("star");
 
     Input keys[] = new Input[]{
-        new Input("top of the lake", w, pl)
+        new Input("Mini Bar something Fridge", 1, payload),
+        new Input("Mini Bar Fridge something", 1, payload),
+        new Input("Mini Bar something else Fridge", 1, payload),
+        new Input("something Mini Bar Fridge", 1, payload),
+        new Input("something else Mini Bar Fridge", 1, payload),
+        new Input("Mini Bar Fridge something else", 1, payload),
+        new Input("Mini something Bar Fridge", 1, payload),
+        new Input("Mini Bar Fridge a a a a a a a a a a a a a a a a a a a a a a", 1, payload)
     };
 
-    Path tempDir = createTempDir("BlendedInfixSuggesterTest");
-    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);
+    BlendedInfixSuggester linearSuggester = getBlendedInfixSuggester(keys, BlendedInfixSuggester.BlenderType.POSITION_LINEAR);
 
-    // BlenderType.LINEAR is used by default (remove position*10%)
-    BlendedInfixSuggester suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a);
-    suggester.build(new InputArrayIterator(keys));
+    // we query for star wars and check that the weight
+    // is smaller when we search for tokens that are far from the beginning
 
-    assertEquals(w, getInResults(suggester, "top", pl, 1));
-    assertEquals((int) (w * (1 - 0.10 * 2)), getInResults(suggester, "the", pl, 1));
-    assertEquals((int) (w * (1 - 0.10 * 3)), getInResults(suggester, "lake", pl, 1));
+    List<Lookup.LookupResult> responses = linearSuggester.lookup("Mini Bar Fridge", 8, true, false);
+    assertThat(responses.get(0).key, is("Mini Bar Fridge something"));
+    assertThat(responses.get(1).key, is("Mini Bar Fridge something else"));
+    assertThat(responses.get(2).key, is("Mini Bar Fridge a a a a a a a a a a a a a a a a a a a a a a"));
+    assertThat(responses.get(3).key, is("Mini Bar something Fridge"));
+    assertThat(responses.get(4).key, is("Mini Bar something else Fridge"));
+    assertThat(responses.get(5).key, is("Mini something Bar Fridge"));
+    assertThat(responses.get(6).key, is("something Mini Bar Fridge"));
+    assertThat(responses.get(7).key, is("something else Mini Bar Fridge"));
+
+    assertTrue(responses.get(1).value < responses.get(0).value);
+    assertTrue(responses.get(2).value < responses.get(1).value);
+    assertTrue(responses.get(3).value < responses.get(2).value);
+    assertTrue(responses.get(4).value < responses.get(3).value);
+    assertTrue(responses.get(5).value < responses.get(4).value);
+    assertTrue(responses.get(6).value < responses.get(5).value);
+    assertTrue(responses.get(7).value < responses.get(6).value);
+    linearSuggester.close();
+  }
 
-    suggester.close();
+  private void assertSuggestionsRanking(BytesRef payload, BlendedInfixSuggester suggester) throws IOException {
+    // we query for star wars and check that the weight
+    // is smaller when we search for tokens that are far from the beginning
 
-    // BlenderType.RECIPROCAL is using 1/(1+p) * w where w is weight and p the position of the word
-    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,
-                                          AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,
-                                          BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL, 1, false);
-    suggester.build(new InputArrayIterator(keys));
+    long w0 = getInResults(suggester, "star ", payload, 1);
+    long w1 = getInResults(suggester, "war", payload, 1);
+    long w2 = getInResults(suggester, "empire stri", payload, 1);
+    long w3 = getInResults(suggester, "back", payload, 1);
+    long w4 = getInResults(suggester, "empire bac", payload, 1);
+    long w5 = getInResults(suggester, "bacc", payload, 1);
+
+    assertTrue(w0 > w1);
+    assertTrue(w1 > w2);
+    assertTrue(w2 > w3); // consecutive terms "empire stri" with first mach position better than "back"
+    assertTrue(w3 > w4); // "empire" is occurring before "back", but "stri" is also not positioned correctly
+    assertTrue(w5 < 0);
 
-    assertEquals(w, getInResults(suggester, "top", pl, 1));
-    assertEquals((int) (w * 1 / (1 + 2)), getInResults(suggester, "the", pl, 1));
-    assertEquals((int) (w * 1 / (1 + 3)), getInResults(suggester, "lake", pl, 1));
     suggester.close();
+  }
 
-    // BlenderType.EXPONENTIAL_RECIPROCAL is using 1/(pow(1+p, exponent)) * w where w is weight and p the position of the word
-    suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,
-        AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,
-        BlendedInfixSuggester.BlenderType.POSITION_EXPONENTIAL_RECIPROCAL, 1, 4.0, false, true, false);
+  private BlendedInfixSuggester getBlendedInfixSuggester(Input[] keys, BlendedInfixSuggester.BlenderType type) throws IOException {
+    Path tempDir = createTempDir("BlendedInfixSuggesterTest");
 
+    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);
+    BlendedInfixSuggester suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,
+        AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,
+        type,
+        BlendedInfixSuggester.DEFAULT_NUM_FACTOR, false);
     suggester.build(new InputArrayIterator(keys));
-
-    assertEquals(w, getInResults(suggester, "top", pl, 1));
-    assertEquals((int) (w * 1 / (Math.pow(1 + 2, 4.0))), getInResults(suggester, "the", pl, 1));
-    assertEquals((int) (w * 1 / (Math.pow(1 + 3, 4.0))), getInResults(suggester, "lake", pl, 1));
-
-    suggester.close();
+    return suggester;
   }
 
   /**
@@ -195,14 +335,7 @@ public class BlendedInfixSuggesterTest extends LuceneTestCase {
         new Input("top of the lake", 8, payload)
     };
 
-    Path tempDir = createTempDir("BlendedInfixSuggesterTest");
-
-    Analyzer a = new StandardAnalyzer(CharArraySet.EMPTY_SET);
-    BlendedInfixSuggester suggester = new BlendedInfixSuggester(newFSDirectory(tempDir), a, a,
-                                                                AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,
-                                                                BlendedInfixSuggester.BlenderType.POSITION_LINEAR,
-                                                                BlendedInfixSuggester.DEFAULT_NUM_FACTOR, false);
-    suggester.build(new InputArrayIterator(keys));
+    BlendedInfixSuggester suggester = getBlendedInfixSuggester(keys, BlendedInfixSuggester.BlenderType.POSITION_LINEAR);
 
     getInResults(suggester, "of ", payload, 1);
     getInResults(suggester, "the ", payload, 1);
