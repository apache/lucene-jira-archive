Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 1697001)
+++ lucene/CHANGES.txt	(working copy)
@@ -79,8 +79,6 @@
   test data.  In addition, the performance of those filters was improved
   significantly.  (Uwe Schindler, Robert Muir)
 
-* LUCENE-6745: RAMInputStream.clone was not thread safe (Mike McCandless)
-
 * LUCENE-6748: UsageTrackingQueryCachingPolicy no longer caches trivial queries
   like MatchAllDocsQuery. (Adrien Grand)
 
Index: lucene/core/src/java/org/apache/lucene/store/RAMInputStream.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/RAMInputStream.java	(revision 1697001)
+++ lucene/core/src/java/org/apache/lucene/store/RAMInputStream.java	(working copy)
@@ -116,7 +116,7 @@
 
   @Override
   public void seek(long pos) throws IOException {
-    if (currentBuffer == null || pos < bufferStart || pos >= bufferStart + BUFFER_SIZE) {
+    if (currentBuffer==null || pos < bufferStart || pos >= bufferStart + BUFFER_SIZE) {
       currentBufferIndex = (int) (pos / BUFFER_SIZE);
       switchCurrentBuffer(false);
     }
@@ -157,19 +157,4 @@
       }
     };
   }
-
-  @Override
-  public RAMInputStream clone() {
-    RAMInputStream clone = (RAMInputStream) super.clone();
-    // If another thread was using our instance, this new clone could have a mismatched currentBuffer and currentBufferIndex, so we do
-    // a "fresh seek" here:
-    clone.currentBuffer = null;
-    try {
-      clone.seek(getFilePointer());
-    } catch (IOException ioe) {
-      // Should not happen!
-      throw new AssertionError(ioe);
-    }
-    return clone;
-  }
 }
Index: lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeDocValuesProducer.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeDocValuesProducer.java	(revision 1697001)
+++ lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeDocValuesProducer.java	(working copy)
@@ -99,9 +99,14 @@
       if (fp == null) {
         throw new IllegalArgumentException("this field was not indexed as a BKDPointField");
       }
-      datIn.seek(fp);
-      treeReader = new BKDTreeReader(datIn, maxDoc);
 
+      // LUCENE-6697: never do real IOPs with the original IndexInput because search
+      // threads can be concurrently cloning it:
+      IndexInput clone = datIn.clone();
+
+      clone.seek(fp);
+      treeReader = new BKDTreeReader(clone, maxDoc);
+
       // Only hang onto the reader when we are not merging:
       if (merging == false) {
         treeReaders.put(field.name, treeReader);
Index: lucene/sandbox/src/java/org/apache/lucene/rangetree/RangeTreeDocValuesProducer.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/rangetree/RangeTreeDocValuesProducer.java	(revision 1697001)
+++ lucene/sandbox/src/java/org/apache/lucene/rangetree/RangeTreeDocValuesProducer.java	(working copy)
@@ -99,9 +99,13 @@
       // FieldInfos checks has already ensured we are a DV field of this type, and Codec ensures
       // this DVFormat was used at write time:
       assert fp != null;
-      datIn.seek(fp);
-      treeReader = new RangeTreeReader(datIn);
 
+      // LUCENE-6697: never do real IOPs with the original IndexInput because search
+      // threads can be concurrently cloning it:
+      IndexInput clone = datIn.clone();
+      clone.seek(fp);
+      treeReader = new RangeTreeReader(clone);
+
       // Only hang onto the reader when we are not merging:
       if (merging == false) {
         treeReaders.put(field.name, treeReader);
@@ -148,9 +152,11 @@
       // this DVFormat was used at write time:
       assert fp != null;
 
-      datIn.seek(fp);
-      //System.out.println("load field=" + field.name);
-      treeReader = new RangeTreeReader(datIn);
+      // LUCENE-6697: never do real IOPs with the original IndexInput because search
+      // threads can be concurrently cloning it:
+      IndexInput clone = datIn.clone();
+      clone.seek(fp);
+      treeReader = new RangeTreeReader(clone);
 
       // Only hang onto the reader when we are not merging:
       if (merging == false) {
Index: lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase.java	(revision 1697001)
+++ lucene/test-framework/src/java/org/apache/lucene/store/BaseDirectoryTestCase.java	(working copy)
@@ -1167,59 +1167,5 @@
     in.close(); // close again
     dir.close();
   }
+}
 
-  public void testCloneThreadSafety() throws Exception {
-    Directory dir = getDirectory(createTempDir());
-    IndexOutput out = dir.createOutput("randombytes", IOContext.DEFAULT);
-
-    // Write file with at least 20 K random bytes:
-    final int numBytes = atLeast(20*1024);
-    final byte[] bytes = new byte[numBytes];
-    random().nextBytes(bytes);
-    out.writeBytes(bytes, 0, bytes.length);
-    out.close();
-
-    // Then read the bytes back at random seek points from multiple threads:
-    final IndexInput in = dir.openInput("randombytes", IOContext.DEFAULT);
-
-    int numThreads = 4;
-    Thread[] threads = new Thread[numThreads];
-    for(int i=0;i<numThreads;i++) {
-      int finalI = i;
-      threads[i] = new Thread() {
-          @Override
-          public void run() {
-            int numIters = atLeast(1000);
-            byte[] scratch = new byte[numBytes];
-            for(int iter=0;iter<numIters;iter++) {
-              // First thread uses the original IndexInput, all other threads use clone:
-              IndexInput myIn;
-              if (finalI == 0) {
-                myIn = in;
-              } else {
-                myIn = in.clone();
-              }
-              int spot = random().nextInt(numBytes/2);
-              try {
-                myIn.seek(spot);
-                int length = numBytes-spot;
-                myIn.readBytes(scratch, 0, length);
-                for(int i=0;i<length;i++) {
-                  assertEquals(bytes[spot+i], scratch[i]);
-                }
-              } catch (IOException ioe) {
-                throw new RuntimeException(ioe);
-              }
-            }
-          }
-        };
-      threads[i].start();
-    }
-
-    for(Thread thread : threads) {
-      thread.join();
-    }
-    in.close();
-    dir.close();
-  }
-}
