--- \dev\backup\sfdc\java\src\org\apache\lucene\search\TermScorer.java	2006-02-20 10:20:00.000000000 -0800
+++ \dev\sfdc\java\src\org\apache\lucene\search\TermScorer.java	2006-02-28 21:29:55.397500000 -0800
@@ -23,19 +23,12 @@
 /** Expert: A <code>Scorer</code> for documents matching a <code>Term</code>.
  */
 final class TermScorer extends Scorer {
+
   private Weight weight;
   private TermDocs termDocs;
   private byte[] norms;
   private float weightValue;
-  private int doc;
-
-  private final int[] docs = new int[32];         // buffered doc numbers
-  private final int[] freqs = new int[32];        // buffered term freqs
-  private int pointer;
-  private int pointerMax;
-
-  private static final int SCORE_CACHE_SIZE = 32;
-  private float[] scoreCache = new float[SCORE_CACHE_SIZE];
+  private boolean atEnd = false;  // If going next provides nothing.
 
   /** Construct a <code>TermScorer</code>.
    * @param weight The weight of the <code>Term</code> in the query.
@@ -50,9 +43,6 @@
     this.termDocs = td;
     this.norms = norms;
     this.weightValue = weight.getValue();
-
-    for (int i = 0; i < SCORE_CACHE_SIZE; i++)
-      scoreCache[i] = getSimilarity().tf(i) * weightValue;
   }
 
   public void score(HitCollector hc) throws IOException {
@@ -62,29 +52,18 @@
 
   protected boolean score(HitCollector c, int end) throws IOException {
     Similarity similarity = getSimilarity();      // cache sim in local
-    float[] normDecoder = Similarity.getNormDecoder();
-    while (doc < end) {                           // for docs in window
-      int f = freqs[pointer];
-      float score =                               // compute tf(f)*weight
-        f < SCORE_CACHE_SIZE                      // check cache
-         ? scoreCache[f]                          // cache hit
-         : similarity.tf(f)*weightValue;          // cache miss
-
-      score *= normDecoder[norms[doc] & 0xFF];    // normalize for field
-
-      c.collect(doc, score);                      // collect score
-
-      if (++pointer >= pointerMax) {
-        pointerMax = termDocs.read(docs, freqs);  // refill buffers
-        if (pointerMax != 0) {
-          pointer = 0;
-        } else {
-          termDocs.close();                       // close stream
-          doc = Integer.MAX_VALUE;                // set to sentinel value
+    while (doc() < end) {                           // for docs in window
+      float score = similarity.tf(termDocs.freq())*weightValue;          // cache miss
+
+      score *= Similarity.decodeNorm(norms[doc()]);    // normalize for field
+
+      c.collect(doc(), score);                      // collect score
+
+      if (!next()) {
+          atEnd = true;
+          termDocs.close();
           return false;
-        }
-      } 
-      doc = docs[pointer];
+      }
     }
     return true;
   }
@@ -92,7 +71,7 @@
   /** Returns the current document number matching the query.
    * Initially invalid, until {@link #next()} is called the first time.
    */
-  public int doc() { return doc; }
+  public int doc() { return atEnd ? Integer.MAX_VALUE : termDocs.doc(); }
 
   /** Advances to the next document matching the query.
    * <br>The iterator over the matching documents is buffered using
@@ -100,57 +79,28 @@
    * @return true iff there is another document matching the query.
    */
   public boolean next() throws IOException {
-    pointer++;
-    if (pointer >= pointerMax) {
-      pointerMax = termDocs.read(docs, freqs);    // refill buffer
-      if (pointerMax != 0) {
-        pointer = 0;
-      } else {
-        termDocs.close();                         // close stream
-        doc = Integer.MAX_VALUE;                  // set to sentinel value
-        return false;
-      }
-    } 
-    doc = docs[pointer];
-    return true;
+    boolean result = termDocs.next();
+    if (!result) {
+        atEnd = true;
+        termDocs.close();
+    }
+    return result;
   }
 
   public float score() {
-    int f = freqs[pointer];
-    float raw =                                   // compute tf(f)*weight
-      f < SCORE_CACHE_SIZE                        // check cache
-      ? scoreCache[f]                             // cache hit
-      : getSimilarity().tf(f)*weightValue;        // cache miss
+    float raw = getSimilarity().tf(termDocs.freq())*weightValue;        // compute tf(f)*weight
 
-    return raw * Similarity.decodeNorm(norms[doc]); // normalize for field
+    return raw * Similarity.decodeNorm(norms[doc()]); // normalize for field
   }
 
   /** Skips to the first match beyond the current whose document number is
-   * greater than or equal to a given target. 
+   * greater than or equal to a given target.
    * <br>The implementation uses {@link TermDocs#skipTo(int)}.
    * @param target The target document number.
    * @return true iff there is such a match.
    */
   public boolean skipTo(int target) throws IOException {
-    // first scan in cache
-    for (pointer++; pointer < pointerMax; pointer++) {
-      if (docs[pointer] >= target) {
-        doc = docs[pointer];
-        return true;
-      }
-    }
-
-    // not found in cache, seek underlying stream
-    boolean result = termDocs.skipTo(target);
-    if (result) {
-      pointerMax = 1;
-      pointer = 0;
-      docs[pointer] = doc = termDocs.doc();
-      freqs[pointer] = termDocs.freq();
-    } else {
-      doc = Integer.MAX_VALUE;
-    }
-    return result;
+    return termDocs.skipTo(target);
   }
 
   /** Returns an explanation of the score for a document.
@@ -163,22 +113,15 @@
     TermQuery query = (TermQuery)weight.getQuery();
     Explanation tfExplanation = new Explanation();
     int tf = 0;
-    while (pointer < pointerMax) {
-      if (docs[pointer] == doc)
-        tf = freqs[pointer];
-      pointer++;
-    }
-    if (tf == 0) {
       while (termDocs.next()) {
         if (termDocs.doc() == doc) {
           tf = termDocs.freq();
         }
       }
-    }
     termDocs.close();
     tfExplanation.setValue(getSimilarity().tf(tf));
     tfExplanation.setDescription("tf(termFreq("+query.getTerm()+")="+tf+")");
-    
+
     return tfExplanation;
   }
 
