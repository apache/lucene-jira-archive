Index: src/java/org/apache/lucene/search/LowFreqTermScorer.java
===================================================================
--- src/java/org/apache/lucene/search/LowFreqTermScorer.java	(revision 0)
+++ src/java/org/apache/lucene/search/LowFreqTermScorer.java	(revision 0)
@@ -0,0 +1,134 @@
+package org.apache.lucene.search;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.TermDocs;
+
+/** Expert: A <code>Scorer</code> for documents matching a <code>Term</code>.
+ */
+final class LowFreqTermScorer extends Scorer {
+
+  private Weight weight;
+  private TermDocs termDocs;
+  private byte[] norms;
+  private float weightValue;
+  private boolean atEnd = false;  // If going next provides nothing.
+
+  /** Construct a <code>LowFreqTermScorer</code>.
+   * @param weight The weight of the <code>Term</code> in the query.
+   * @param td An iterator over the documents matching the <code>Term</code>.
+   * @param similarity The </code>Similarity</code> implementation to be used for score computations.
+   * @param norms The field norms of the document fields for the <code>Term</code>.
+   */
+  LowFreqTermScorer(Weight weight, TermDocs td, Similarity similarity,
+             byte[] norms) {
+    super(similarity);
+    this.weight = weight;
+    this.termDocs = td;
+    this.norms = norms;
+    this.weightValue = weight.getValue();
+  }
+
+  public void score(HitCollector hc) throws IOException {
+    next();
+    score(hc, Integer.MAX_VALUE);
+  }
+
+  protected boolean score(HitCollector c, int end) throws IOException {
+    Similarity similarity = getSimilarity();      // cache sim in local
+    while (doc() < end) {                           // for docs in window
+      float score = similarity.tf(termDocs.freq())*weightValue;          // cache miss
+
+      score *= Similarity.decodeNorm(norms[doc()]);    // normalize for field
+
+      c.collect(doc(), score);                      // collect score
+
+      if (!next()) {
+          atEnd = true;
+          termDocs.close();
+          return false;
+      }
+    }
+    return true;
+  }
+
+  /** Returns the current document number matching the query.
+   * Initially invalid, until {@link #next()} is called the first time.
+   */
+  public int doc() { return atEnd ? Integer.MAX_VALUE : termDocs.doc(); }
+
+  /** Advances to the next document matching the query.
+   * <br>The iterator over the matching documents is buffered using
+   * {@link TermDocs#read(int[],int[])}.
+   * @return true iff there is another document matching the query.
+   */
+  public boolean next() throws IOException {
+    boolean result = termDocs.next();
+    if (!result) {
+        atEnd = true;
+        termDocs.close();
+    }
+    return result;
+  }
+
+  public float score() {
+    float raw = getSimilarity().tf(termDocs.freq())*weightValue;        // compute tf(f)*weight
+
+    return raw * Similarity.decodeNorm(norms[doc()]); // normalize for field
+  }
+
+  /** Skips to the first match beyond the current whose document number is
+   * greater than or equal to a given target.
+   * <br>The implementation uses {@link TermDocs#skipTo(int)}.
+   * @param target The target document number.
+   * @return true iff there is such a match.
+   */
+  public boolean skipTo(int target) throws IOException {
+    return termDocs.skipTo(target);
+  }
+
+  /** Returns an explanation of the score for a document.
+   * <br>When this method is used, the {@link #next()} method
+   * and the {@link #score(HitCollector)} method should not be used.
+   * @param doc The document number for the explanation.
+   */
+  public Explanation explain(int doc) throws IOException {
+    TermQuery query = (TermQuery)weight.getQuery();
+    Explanation tfExplanation = new Explanation();
+    int tf = 0;
+
+        if (termDocs.skipTo(doc))
+        {
+            if (termDocs.doc() == doc)
+            {
+                tf = termDocs.freq();
+            }
+        }
+    
+    termDocs.close();
+    tfExplanation.setValue(getSimilarity().tf(tf));
+    tfExplanation.setDescription("tf(termFreq("+query.getTerm()+")="+tf+")");
+    
+    return tfExplanation;
+  }
+
+  /** Returns a string representation of this <code>TermScorer</code>. */
+  public String toString() { return "scorer(" + weight + ")"; }
+}
Index: src/java/org/apache/lucene/search/TermQuery.java
===================================================================
--- src/java/org/apache/lucene/search/TermQuery.java	(revision 713621)
+++ src/java/org/apache/lucene/search/TermQuery.java	(working copy)
@@ -66,8 +66,13 @@
       if (termDocs == null)
         return null;
 
-      return new TermScorer(this, termDocs, similarity,
+      if(reader.docFreq(term) > 10) {
+        return new TermScorer(this, termDocs, similarity,
                             reader.norms(term.field()));
+      } else {
+        return new LowFreqTermScorer(this, termDocs, similarity,
+            reader.norms(term.field()));
+      }
     }
 
     public Explanation explain(IndexReader reader, int doc)

