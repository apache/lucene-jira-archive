diff --git a/lucene/join/src/java/org/apache/lucene/search/join/DocValuesScanQuery.java b/lucene/join/src/java/org/apache/lucene/search/join/DocValuesScanQuery.java
new file mode 100644
index 0000000..a11fc9f
--- /dev/null
+++ b/lucene/join/src/java/org/apache/lucene/search/join/DocValuesScanQuery.java
@@ -0,0 +1,156 @@
+package org.apache.lucene.search.join;
+
+import java.io.IOException;
+
+import org.apache.lucene.index.BinaryDocValues;
+import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.SortedNumericDocValues;
+import org.apache.lucene.search.ConstantScoreQuery;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.Weight;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.BytesRefHash;
+import org.apache.lucene.util.Bits.MatchNoBits;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class DocValuesScanQuery extends Query {
+  
+  final private String toField;
+  final private BytesRefHash collectorTerms;
+  
+  public DocValuesScanQuery(String toField,
+      BytesRefHash collectorTerms) {
+    this.toField = toField;
+    this. collectorTerms = collectorTerms;
+  }
+
+  @Override
+  public String toString(String field) {
+    return null;
+  }
+ 
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    if(collectorTerms.size()==0){
+      return null;
+    }
+    return super.rewrite(reader);
+  }
+  
+  @Override
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores)
+      throws IOException {
+    return new Weight(this) {
+      
+      @Override
+      public Scorer scorer(LeafReaderContext context, Bits acceptDocs)
+          throws IOException {
+        
+        final Bits docsWithField = context.reader().getDocsWithField(toField);
+        if (docsWithField == null || docsWithField instanceof MatchNoBits) {
+          return null;
+        }
+
+        final DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());
+
+        final BinaryDocValues values = DocValues.getBinary(context.reader(), toField);
+
+        final TwoPhaseIterator twoPhaseRange = new TwoPhaseIterator(){
+          @Override
+          public DocIdSetIterator approximation() {
+            return approximation;
+          }
+
+          @Override
+          public boolean matches() throws IOException {
+            final int doc = approximation.docID();
+            if (acceptDocs == null || acceptDocs.get(doc)) {
+              final BytesRef toFieldVal = values.get(doc);
+              return toFieldVal.length>0 && collectorTerms.find(toFieldVal)>=0;
+            }
+            return false;
+          }
+        };
+        
+        final DocIdSetIterator disi = TwoPhaseIterator.asDocIdSetIterator(twoPhaseRange);
+        
+        return new Scorer(this){
+
+          @Override
+          public TwoPhaseIterator asTwoPhaseIterator() {
+            return twoPhaseRange;
+          }
+
+          @Override
+          public float score() throws IOException {
+            return 0;
+          }
+
+          @Override
+          public int freq() throws IOException {
+            return 1;
+          }
+
+          @Override
+          public int docID() {
+            return disi.docID();
+          }
+
+          @Override
+          public int nextDoc() throws IOException {
+            return disi.nextDoc();
+          }
+
+          @Override
+          public int advance(int target) throws IOException {
+            return disi.advance(target);
+          }
+
+          @Override
+          public long cost() {
+            return disi.cost();
+          }
+
+        };
+      }
+      
+      @Override
+      public void normalize(float norm, float topLevelBoost) {}
+      
+      @Override
+      public float getValueForNormalization() throws IOException {
+        return 0;
+      }
+      
+      @Override
+      public Explanation explain(LeafReaderContext context, int doc)
+          throws IOException {
+        return null;
+      }
+    };
+  }
+}
diff --git a/lucene/join/src/java/org/apache/lucene/search/join/JoinUtil.java b/lucene/join/src/java/org/apache/lucene/search/join/JoinUtil.java
index 44abe7b..6e7aa2d 100644
--- a/lucene/join/src/java/org/apache/lucene/search/join/JoinUtil.java
+++ b/lucene/join/src/java/org/apache/lucene/search/join/JoinUtil.java
@@ -89,5 +89,15 @@ public final class JoinUtil {
         throw new IllegalArgumentException(String.format(Locale.ROOT, "Score mode %s isn't supported.", scoreMode));
     }
   }
-
+  
+  public static Query createLazyJoinQuery(String fromField,
+          boolean multipleValuesPerDocument,
+          String toField,
+          Query fromQuery,
+          IndexSearcher fromSearcher) throws IOException {
+      TermsCollector termsCollector = TermsCollector.create(fromField, multipleValuesPerDocument);
+      fromSearcher.search(fromQuery, termsCollector);
+      
+      return new DocValuesScanQuery(toField, termsCollector.getCollectorTerms());
+  }
 }
diff --git a/lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java b/lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java
index 46fa0c1..bce3a7f 100644
--- a/lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java
+++ b/lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil.java
@@ -32,10 +32,12 @@ import java.util.TreeSet;
 
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.document.BinaryDocValuesField;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.SortedDocValuesField;
 import org.apache.lucene.document.SortedSetDocValuesField;
+import org.apache.lucene.document.StringField;
 import org.apache.lucene.document.TextField;
 import org.apache.lucene.index.BinaryDocValues;
 import org.apache.lucene.index.DocValues;
@@ -169,6 +171,92 @@ public class TestJoinUtil extends LuceneTestCase {
     dir.close();
   }
 
+  public void testSimpleScanBinaryDV() throws Exception {
+    final String idField = "id";
+    final String toField = "productId";
+
+    Directory dir = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(
+        random(),
+        dir,
+        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
+
+    // 0
+    Document doc = new Document();
+    doc.add(new TextField("description", "random text", Field.Store.NO));
+    doc.add(new TextField("name", "name1", Field.Store.NO));
+   // doc.add(new TextField(idField, "1", Field.Store.NO));
+    doc.add(new BinaryDocValuesField(idField, new BytesRef("1")));
+    w.addDocument(doc);
+    
+    final String fromField = "fromField";
+    // 1
+    doc = new Document();
+    doc.add(new TextField("price", "10.0", Field.Store.NO));
+    doc.add(new StringField(idField, "2", Field.Store.NO));
+    //doc.add(new SortedDocValuesField(idField, new BytesRef("2")));
+    //doc.add(new TextField(toField, "1", Field.Store.NO));
+    doc.add(new BinaryDocValuesField(fromField, new BytesRef("1")));
+    w.addDocument(doc);
+
+    // 2
+    doc = new Document();
+    doc.add(new TextField("price", "20.0", Field.Store.NO));
+    doc.add(new StringField(idField, "3", Field.Store.NO));
+    //doc.add(new SortedDocValuesField(idField, new BytesRef("3")));
+    //doc.add(new TextField(toField, "1", Field.Store.NO));
+    doc.add(new BinaryDocValuesField(fromField, new BytesRef("1")));
+    w.addDocument(doc);
+
+    // 3
+    doc = new Document();
+    doc.add(new TextField("description", "more random text", Field.Store.NO));
+    doc.add(new TextField("name", "name2", Field.Store.NO));
+    doc.add(new TextField(idField, "4", Field.Store.NO));
+    //doc.add(new SortedDocValuesField(idField, new BytesRef("4")));
+    doc.add(new BinaryDocValuesField(idField, new BytesRef("4")));
+    w.addDocument(doc);
+    w.commit();
+
+    // 4
+    doc = new Document();
+    doc.add(new TextField("price", "10.0", Field.Store.NO));
+    doc.add(new StringField(idField, "5", Field.Store.NO));
+    //doc.add(new SortedDocValuesField(idField, new BytesRef("5")));
+    //doc.add(new TextField(toField, "4", Field.Store.NO));
+    doc.add(new BinaryDocValuesField(fromField, new BytesRef("4")));
+    w.addDocument(doc);
+
+    // 5
+    doc = new Document();
+    doc.add(new TextField("price", "20.0", Field.Store.NO));
+    doc.add(new StringField(idField, "6", Field.Store.NO));
+    //doc.add(new SortedDocValuesField(idField, new BytesRef("6")));
+    //doc.add(new TextField(toField, "4", Field.Store.NO));
+    doc.add(new BinaryDocValuesField(fromField, new BytesRef("4")));
+    w.addDocument(doc);
+
+    IndexSearcher indexSearcher = new IndexSearcher(w.getReader());
+    w.close();
+
+    // Search for product
+    Query joinQuery =
+        JoinUtil.createLazyJoinQuery(fromField, false, idField, 
+            new TermQuery(new Term(idField, random().nextBoolean() ? "6":"5")), indexSearcher);
+    TopDocs result = indexSearcher.search(joinQuery, 10);
+    assertEquals(1, result.totalHits);
+    assertEquals(3, result.scoreDocs[0].doc);
+
+    joinQuery = JoinUtil.createLazyJoinQuery(fromField, false, idField, 
+        new TermQuery(new Term(idField, random().nextBoolean() ? "2":"3")), indexSearcher);
+    result = indexSearcher.search(joinQuery, 10);
+    assertEquals(1, result.totalHits);
+    assertEquals(0, result.scoreDocs[0].doc);
+
+    indexSearcher.getIndexReader().close();
+    dir.close();
+  }
+  
   // TermsWithScoreCollector.MV.Avg forgets to grow beyond TermsWithScoreCollector.INITIAL_ARRAY_SIZE
   public void testOverflowTermsWithScoreCollector() throws Exception {
     test300spartans(true, ScoreMode.Avg);
