Index: lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester.java	(revision 1437814)
+++ lucene/test-framework/src/java/org/apache/lucene/util/fst/FSTTester.java	(working copy)
@@ -735,8 +735,8 @@
           keep = true;
         } else if (prefix.length > 0) {
           // consult our parent
+          scratch.copyInts(prefix);
           scratch.length = prefix.length-1;
-          System.arraycopy(prefix.ints, prefix.offset, scratch.ints, 0, scratch.length);
           final CountMinOutput<T> cmo2 = prefixes.get(scratch);
           //System.out.println("    parent count = " + (cmo2 == null ? -1 : cmo2.count));
           keep = cmo2 != null && ((prune2 > 1 && cmo2.count >= prune2) || (prune2 == 1 && (cmo2.count >= 2 || prefix.length <= 1)));
Index: lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil.java
===================================================================
--- lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil.java	(revision 1437814)
+++ lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil.java	(working copy)
@@ -97,9 +97,9 @@
               path.fstNode, scratchArc, fstReader);
           if (nextArc != null) {
             final IntsRef newInput = new IntsRef(currentInput.length + 1);
+            newInput.length = currentInput.length + 1;
             newInput.copyInts(currentInput);
             newInput.ints[currentInput.length] = t.getMin();
-            newInput.length = currentInput.length + 1;
             queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()
                 .copyFrom(nextArc), fst.outputs
                 .add(path.output, nextArc.output), newInput));
@@ -119,9 +119,9 @@
             assert nextArc.label >= min : nextArc.label + " "
                 + min;
             final IntsRef newInput = new IntsRef(currentInput.length + 1);
+            newInput.length = currentInput.length + 1;
             newInput.copyInts(currentInput);
             newInput.ints[currentInput.length] = nextArc.label;
-            newInput.length = currentInput.length + 1;
             queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()
                 .copyFrom(nextArc), fst.outputs
                 .add(path.output, nextArc.output), newInput));
Index: lucene/core/src/test/org/apache/lucene/util/TestIntsRef.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/util/TestIntsRef.java	(revision 1437814)
+++ lucene/core/src/test/org/apache/lucene/util/TestIntsRef.java	(working copy)
@@ -37,4 +37,14 @@
     
     assertFalse(i.equals(i2));
   }
+  
+  // LUCENE-4714, clobbering if you copy to a intsref with offset != 0
+  public void testCopyInts2() {
+    int ints[] = new int[] { 1, 2, 3, 4 };
+    IntsRef b1 = new IntsRef(ints, 0, 2); // 12
+    IntsRef b2 = new IntsRef(ints, 2, 2); // 34
+    b1.copyInts(new IntsRef(new int[] { 6, 7, 8, 9 }, 0, 4));
+    assertEquals(new IntsRef(new int[] { 6, 7, 8, 9 }, 0, 4), b1);
+    assertEquals(new IntsRef(new int[] { 3, 4 }, 0, 2), b2);
+  }
 }
Index: lucene/core/src/test/org/apache/lucene/util/TestLongsRef.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/util/TestLongsRef.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/util/TestLongsRef.java	(working copy)
@@ -0,0 +1,50 @@
+package org.apache.lucene.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public class TestLongsRef extends LuceneTestCase {
+  public void testEmpty() {
+    LongsRef i = new LongsRef();
+    assertEquals(LongsRef.EMPTY_LONGS, i.longs);
+    assertEquals(0, i.offset);
+    assertEquals(0, i.length);
+  }
+  
+  public void testFromLongs() {
+    long longs[] = new long[] { 1, 2, 3, 4 };
+    LongsRef i = new LongsRef(longs, 0, 4);
+    assertEquals(longs, i.longs);
+    assertEquals(0, i.offset);
+    assertEquals(4, i.length);
+    
+    LongsRef i2 = new LongsRef(longs, 1, 3);
+    assertEquals(new LongsRef(new long[] { 2, 3, 4 }, 0, 3), i2);
+    
+    assertFalse(i.equals(i2));
+  }
+  
+  // LUCENE-4714, clobbering if you copy to a longsref with offset != 0
+  public void testCopyLongs2() {
+    long longs[] = new long[] { 1, 2, 3, 4 };
+    LongsRef b1 = new LongsRef(longs, 0, 2); // 12
+    LongsRef b2 = new LongsRef(longs, 2, 2); // 34
+    b1.copyLongs(new LongsRef(new long[] { 6, 7, 8, 9 }, 0, 4));
+    assertEquals(new LongsRef(new long[] { 6, 7, 8, 9 }, 0, 4), b1);
+    assertEquals(new LongsRef(new long[] { 3, 4 }, 0, 2), b2);
+  }
+}

Property changes on: lucene/core/src/test/org/apache/lucene/util/TestLongsRef.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
Index: lucene/core/src/test/org/apache/lucene/util/TestBytesRef.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/util/TestBytesRef.java	(revision 1437814)
+++ lucene/core/src/test/org/apache/lucene/util/TestBytesRef.java	(working copy)
@@ -64,4 +64,24 @@
     b.copyBytes(new BytesRef("bcde"));
     assertEquals("bcde", b.utf8ToString());
   }
+  
+  // LUCENE-4714, clobbering if you append to a bytesref with offset != 0
+  public void testAppend2() {
+    byte bytes[] = new byte[] { (byte)'a', (byte)'b', (byte)'c', (byte)'d' };
+    BytesRef b1 = new BytesRef(bytes, 0, 2); // ab
+    BytesRef b2 = new BytesRef(bytes, 2, 2); // cd
+    b1.append(new BytesRef("YO"));
+    assertEquals("abYO", b1.utf8ToString());
+    assertEquals("cd", b2.utf8ToString());
+  }
+  
+  // LUCENE-4714, clobbering if you copy to a bytesref with offset != 0
+  public void testCopyBytes2() {
+    byte bytes[] = new byte[] { (byte)'a', (byte)'b', (byte)'c', (byte)'d' };
+    BytesRef b1 = new BytesRef(bytes, 0, 2); // ab
+    BytesRef b2 = new BytesRef(bytes, 2, 2); // cd
+    b1.copyBytes(new BytesRef("BOOM"));
+    assertEquals("BOOM", b1.utf8ToString());
+    assertEquals("cd", b2.utf8ToString());
+  }
 }
Index: lucene/core/src/test/org/apache/lucene/util/TestCharsRef.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/util/TestCharsRef.java	(revision 1437814)
+++ lucene/core/src/test/org/apache/lucene/util/TestCharsRef.java	(working copy)
@@ -169,4 +169,24 @@
       // expected exception
     }
   }
+  
+  // LUCENE-4714, clobbering if you copy to a charsref with offset != 0
+  public void testAppend2() {
+    char chars[] = new char[] { 'a', 'b', 'c', 'd' };
+    CharsRef b1 = new CharsRef(chars, 0, 2); // ab
+    CharsRef b2 = new CharsRef(chars, 2, 2); // cd
+    b1.append(new char[] { 'Y', 'O' }, 0, 2);
+    assertEquals("abYO", b1.toString());
+    assertEquals("cd", b2.toString());
+  }
+  
+  // LUCENE-4714, clobbering if you copy to a charsref with offset != 0
+  public void testCopyChars2() {
+    char chars[] = new char[] { 'a', 'b', 'c', 'd' };
+    CharsRef b1 = new CharsRef(chars, 0, 2); // ab
+    CharsRef b2 = new CharsRef(chars, 2, 2); // cd
+    b1.copyChars(new CharsRef("BOOM"));
+    assertEquals("BOOM", b1.toString());
+    assertEquals("cd", b2.toString());
+  }
 }
Index: lucene/core/src/java/org/apache/lucene/util/IntsRef.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/IntsRef.java	(revision 1437814)
+++ lucene/core/src/java/org/apache/lucene/util/IntsRef.java	(working copy)
@@ -129,7 +129,7 @@
   }
 
   public void copyInts(IntsRef other) {
-    if (ints.length - offset < other.length) {
+    if (length < other.length) {
       ints = new int[other.length];
       offset = 0;
     }
Index: lucene/core/src/java/org/apache/lucene/util/CharsRef.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/CharsRef.java	(revision 1437814)
+++ lucene/core/src/java/org/apache/lucene/util/CharsRef.java	(working copy)
@@ -170,7 +170,7 @@
    * Copies the given array into this CharsRef.
    */
   public void copyChars(char[] otherChars, int otherOffset, int otherLength) {
-    if (chars.length - offset < otherLength) {
+    if (length < otherLength) {
       chars = new char[otherLength];
       offset = 0;
     }
@@ -183,7 +183,7 @@
    */
   public void append(char[] otherChars, int otherOffset, int otherLength) {
     int newLen = length + otherLength;
-    if (chars.length - offset < newLen) {
+    if (length < newLen) {
       char[] newChars = new char[newLen];
       System.arraycopy(chars, offset, newChars, 0, length);
       offset = 0;
Index: lucene/core/src/java/org/apache/lucene/util/LongsRef.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/LongsRef.java	(revision 1437814)
+++ lucene/core/src/java/org/apache/lucene/util/LongsRef.java	(working copy)
@@ -128,7 +128,7 @@
   }
 
   public void copyLongs(LongsRef other) {
-    if (longs.length - offset < other.length) {
+    if (length < other.length) {
       longs = new long[other.length];
       offset = 0;
     }
Index: lucene/core/src/java/org/apache/lucene/util/BytesRef.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/BytesRef.java	(revision 1437814)
+++ lucene/core/src/java/org/apache/lucene/util/BytesRef.java	(working copy)
@@ -189,7 +189,7 @@
    * new reference array.
    */
   public void copyBytes(BytesRef other) {
-    if (bytes.length - offset < other.length) {
+    if (length < other.length) {
       bytes = new byte[other.length];
       offset = 0;
     }
@@ -205,7 +205,7 @@
    */
   public void append(BytesRef other) {
     int newLen = length + other.length;
-    if (bytes.length - offset < newLen) {
+    if (length < newLen) {
       byte[] newBytes = new byte[newLen];
       System.arraycopy(bytes, offset, newBytes, 0, length);
       offset = 0;
