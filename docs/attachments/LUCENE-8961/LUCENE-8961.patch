diff --git a/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java b/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
index ffbd7e5ef53..379d790cc8f 100644
--- a/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
+++ b/lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
@@ -23,6 +23,8 @@ import java.io.PrintStream;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.text.NumberFormat;
+import java.util.function.BiConsumer;
+import java.util.function.Predicate;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
@@ -82,7 +84,7 @@ import static org.apache.lucene.search.DocIdSetIterator.NO_MORE_DOCS;
  * @lucene.experimental Please make a complete backup of your
  * index before using this to exorcise corrupted documents from your index!
  */
-public final class CheckIndex implements Closeable {
+public class CheckIndex implements Closeable {
 
   private PrintStream infoStream;
   private Directory dir;
@@ -683,7 +685,7 @@ public final class CheckIndex implements Closeable {
         long startIntegrityNS = System.nanoTime();
         if (infoStream != null)
           infoStream.print("    test: check integrity.....");
-        reader.checkIntegrity();
+        checkIntegrity(reader);
         msg(infoStream, String.format(Locale.ROOT, "OK [took %.3f sec]", nsToSec(System.nanoTime()-startIntegrityNS)));
 
         if (reader.maxDoc() != info.info.maxDoc()) {
@@ -720,7 +722,7 @@ public final class CheckIndex implements Closeable {
           segInfoStat.fieldNormStatus = testFieldNorms(reader, infoStream, failFast);
 
           // Test the Term Index
-          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast);
+          segInfoStat.termIndexStatus = testPostings(reader, infoStream, verbose, doSlowChecks, failFast, getTestPostingsFieldFilter(), getTestPostingsFieldTermConsumer());
 
           // Test Stored Fields
           segInfoStat.storedFieldStatus = testStoredFields(reader, infoStream, failFast);
@@ -811,6 +813,30 @@ public final class CheckIndex implements Closeable {
     return result;
   }
 
+  /**
+   * Checks the reader's integrity.
+   * @lucene.experimental
+   */
+  protected void checkIntegrity(CodecReader reader) throws IOException {
+    reader.checkIntegrity();
+  }
+
+  /**
+   * Predicate for filtering fields.
+   * @lucene.experimental
+   */
+  protected Predicate<String> getTestPostingsFieldFilter() {
+    return null;
+  }
+
+  /**
+   * Consumer for (field,term) pairs.
+   * @lucene.experimental
+   */
+  protected BiConsumer<String, BytesRef> getTestPostingsFieldTermConsumer() {
+    return null;
+  }
+
   /**
    * Tests index sort order.
    * @lucene.experimental
@@ -1122,7 +1148,8 @@ public final class CheckIndex implements Closeable {
    * searcher is optional, to verify with queries. Can be null.
    */
   private static Status.TermIndexStatus checkFields(Fields fields, Bits liveDocs, int maxDoc, FieldInfos fieldInfos,
-      NormsProducer normsProducer, boolean doPrint, boolean isVectors, PrintStream infoStream, boolean verbose, boolean doSlowChecks) throws IOException {
+      NormsProducer normsProducer, boolean doPrint, boolean isVectors, PrintStream infoStream, boolean verbose, boolean doSlowChecks,
+      Predicate<String> fieldsFilter, BiConsumer<String, BytesRef> fieldTermConsumer) throws IOException {
     // TODO: we should probably return our own stats thing...?!
     long startNS;
     if (doPrint) {
@@ -1139,6 +1166,11 @@ public final class CheckIndex implements Closeable {
     String lastField = null;
     for (String field : fields) {
 
+      if (fieldsFilter != null && !fieldsFilter.test(field)) {
+        computedFieldCount++;
+        continue;
+      }
+
       // MultiFieldsEnum relies upon this order...
       if (lastField != null && field.compareTo(lastField) <= 0) {
         throw new RuntimeException("fields out of order: lastField=" + lastField + " field=" + field);
@@ -1249,6 +1281,10 @@ public final class CheckIndex implements Closeable {
         
         assert term.isValid();
         
+        if (fieldTermConsumer != null) {
+          fieldTermConsumer.accept(field, term);
+        }
+
         // make sure terms arrive in order according to
         // the comp
         if (lastTerm == null) {
@@ -1849,6 +1885,14 @@ public final class CheckIndex implements Closeable {
    * @lucene.experimental
    */
   public static Status.TermIndexStatus testPostings(CodecReader reader, PrintStream infoStream, boolean verbose, boolean doSlowChecks, boolean failFast) throws IOException {
+    return testPostings(reader, infoStream, verbose, doSlowChecks, failFast, null, null);
+  }
+
+  /**
+   * Test the term index.
+   * @lucene.experimental
+   */
+  public static Status.TermIndexStatus testPostings(CodecReader reader, PrintStream infoStream, boolean verbose, boolean doSlowChecks, boolean failFast, Predicate<String> fieldsFilter, BiConsumer<String, BytesRef> fieldTermConsumer) throws IOException {
 
     // TODO: we should go and verify term vectors match, if
     // doSlowChecks is on...
@@ -1867,7 +1911,7 @@ public final class CheckIndex implements Closeable {
       if (normsProducer != null) {
         normsProducer = normsProducer.getMergeInstance();
       }
-      status = checkFields(fields, reader.getLiveDocs(), maxDoc, fieldInfos, normsProducer, true, false, infoStream, verbose, doSlowChecks);
+      status = checkFields(fields, reader.getLiveDocs(), maxDoc, fieldInfos, normsProducer, true, false, infoStream, verbose, doSlowChecks, fieldsFilter, fieldTermConsumer);
     } catch (Throwable e) {
       if (failFast) {
         throw IOUtils.rethrowAlways(e);
@@ -2568,7 +2612,7 @@ public final class CheckIndex implements Closeable {
           
           if (tfv != null) {
             // First run with no deletions:
-            checkFields(tfv, null, 1, fieldInfos, null, false, true, infoStream, verbose, doSlowChecks);
+            checkFields(tfv, null, 1, fieldInfos, null, false, true, infoStream, verbose, doSlowChecks, null, null);
             
             // Only agg stats if the doc is live:
             final boolean doStats = liveDocs == null || liveDocs.get(j);
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestCustomCheckIndex.java b/lucene/core/src/test/org/apache/lucene/index/TestCustomCheckIndex.java
new file mode 100644
index 00000000000..c8723a1e5b7
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/index/TestCustomCheckIndex.java
@@ -0,0 +1,86 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.index;
+
+import java.io.IOException;
+import java.util.function.BiConsumer;
+import java.util.function.Predicate;
+
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BytesRef;
+import org.junit.Test;
+
+public class TestCustomCheckIndex extends BaseTestCheckIndex {
+
+  private Directory directory;
+
+  @Override
+  public void setUp() throws Exception {
+    super.setUp();
+    directory = newDirectory();
+  }
+
+  @Override
+  public void tearDown() throws Exception {
+    directory.close();
+    super.tearDown();
+  }
+
+  protected CheckIndex newCheckIndex(Directory dir) throws IOException {
+    return new CheckIndex(dir) {
+
+      @Override
+      protected void checkIntegrity(CodecReader reader) throws IOException {
+        // no-op
+      }
+
+      @Override
+      protected Predicate<String> getTestPostingsFieldFilter() {
+        return field -> field.equals("docid");
+      }
+
+      @Override
+      protected BiConsumer<String, BytesRef> getTestPostingsFieldTermConsumer() {
+        return new BiConsumer<>() {
+          @Override
+          public void accept(String field, BytesRef term) {
+            if (VERBOSE) {
+              System.out.println("field="+field+" term="+term.utf8ToString());
+            }
+          }
+        };
+      }
+
+    };
+  }
+
+  @Test
+  public void testChecksumsOnly() throws IOException {
+    testChecksumsOnly(directory);
+  }
+
+  @Test
+  public void testChecksumsOnlyVerbose() throws IOException {
+    testChecksumsOnlyVerbose(directory);
+  }
+
+  @Test
+  public void testObtainsLock() throws IOException {
+    testObtainsLock(directory);
+  }
+
+}
diff --git a/lucene/test-framework/src/java/org/apache/lucene/index/BaseTestCheckIndex.java b/lucene/test-framework/src/java/org/apache/lucene/index/BaseTestCheckIndex.java
index 21ccf3b777f..f29719920b5 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/index/BaseTestCheckIndex.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/index/BaseTestCheckIndex.java
@@ -38,6 +38,10 @@ import org.apache.lucene.util.TestUtil;
  */
 public class BaseTestCheckIndex extends LuceneTestCase {
 
+  protected CheckIndex newCheckIndex(Directory dir) throws IOException {
+    return new CheckIndex(dir);
+  }
+
   public void testDeletedDocs(Directory dir) throws IOException {
     IndexWriter writer  = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))
                                                  .setMaxBufferedDocs(2));
@@ -56,7 +60,7 @@ public class BaseTestCheckIndex extends LuceneTestCase {
     writer.close();
 
     ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);
-    CheckIndex checker = new CheckIndex(dir);
+    CheckIndex checker = newCheckIndex(dir);
     checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));
     if (VERBOSE) checker.setInfoStream(System.out);
     CheckIndex.Status indexStatus = checker.checkIndex();
@@ -116,7 +120,7 @@ public class BaseTestCheckIndex extends LuceneTestCase {
     lf.close();
     
     ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);
-    CheckIndex checker = new CheckIndex(dir);
+    CheckIndex checker = newCheckIndex(dir);
     checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8));
     if (VERBOSE) checker.setInfoStream(System.out);
     CheckIndex.Status indexStatus = checker.checkIndex();
@@ -139,7 +143,7 @@ public class BaseTestCheckIndex extends LuceneTestCase {
     lf.close();
     
     ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);
-    CheckIndex checker = new CheckIndex(dir);
+    CheckIndex checker = newCheckIndex(dir);
     checker.setInfoStream(new PrintStream(bos, true, IOUtils.UTF_8));
     if (VERBOSE) checker.setInfoStream(System.out);
     CheckIndex.Status indexStatus = checker.checkIndex();
@@ -155,7 +159,7 @@ public class BaseTestCheckIndex extends LuceneTestCase {
     
     // keep IW open... should not be able to obtain write lock
     expectThrows(LockObtainFailedException.class, () -> {
-      new CheckIndex(dir);
+      newCheckIndex(dir);
     });
     
     iw.close();
