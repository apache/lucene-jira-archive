diff --git a/lucene/monitor/src/java/org/apache/lucene/monitor/RejectUnconstrainedQueriesPresearcherWrapper.java b/lucene/monitor/src/java/org/apache/lucene/monitor/RejectUnconstrainedQueriesPresearcherWrapper.java
new file mode 100644
index 00000000000..cdacf61c2a1
--- /dev/null
+++ b/lucene/monitor/src/java/org/apache/lucene/monitor/RejectUnconstrainedQueriesPresearcherWrapper.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.monitor;
+
+import java.util.Map;
+import java.util.function.BiPredicate;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * Presearcher implementation that wraps another Presearcher, providing an {@link #indexQuery} impl
+ * that will throw a {@link IllegalArgumentException} if the <code>ANYTOKEN_FIELD</code> is used.
+ *
+ * <p>This allows the creation of Monitor instances that will reject the registration of queries
+ * that require a "forward searched" test against all documents.
+ */
+public class RejectUnconstrainedQueriesPresearcherWrapper extends Presearcher {
+
+  static final String ANYTOKEN_FIELD = TermFilteredPresearcher.ANYTOKEN_FIELD;
+  private final String msg;
+  private final Presearcher inner;
+
+  /**
+   * Creates a new RejectUnconstrainedQueriesPresearcherWrapper
+   *
+   * @param inner presearcher to wrap.
+   * @param msg exception message to use.
+   */
+  public RejectUnconstrainedQueriesPresearcherWrapper(final Presearcher inner, final String msg) {
+    assert null != inner;
+    assert null != msg;
+
+    this.inner = inner;
+    this.msg = msg;
+  }
+
+  @Override
+  public Query buildQuery(LeafReader reader, BiPredicate<String, BytesRef> termAcceptor) {
+    return inner.buildQuery(reader, termAcceptor);
+  }
+
+  @Override
+  public Document indexQuery(Query query, Map<String, String> metadata) {
+    final Document doc = inner.indexQuery(query, metadata);
+    if (null != doc.getField(ANYTOKEN_FIELD)) {
+      throw new IllegalArgumentException(msg);
+    }
+    return doc;
+  }
+}
diff --git a/lucene/monitor/src/test/org/apache/lucene/monitor/TestRejectUnconstrainedQueriesPresearcherWrapper.java b/lucene/monitor/src/test/org/apache/lucene/monitor/TestRejectUnconstrainedQueriesPresearcherWrapper.java
new file mode 100644
index 00000000000..bb944da7c5a
--- /dev/null
+++ b/lucene/monitor/src/test/org/apache/lucene/monitor/TestRejectUnconstrainedQueriesPresearcherWrapper.java
@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.monitor;
+
+import java.io.IOException;
+import java.util.Collections;
+import org.apache.lucene.analysis.core.WhitespaceAnalyzer;
+
+public class TestRejectUnconstrainedQueriesPresearcherWrapper extends MonitorTestBase {
+
+  @Override
+  public Monitor newMonitor() throws IOException {
+    return new Monitor(new WhitespaceAnalyzer(), createPresearcher());
+  }
+
+  protected Presearcher createPresearcher() {
+    return new RejectUnconstrainedQueriesPresearcherWrapper(
+        new MultipassTermFilteredPresearcher(
+            4, 0, TermWeightor.DEFAULT, Collections.emptyList(), Collections.singleton("language")),
+        "bad dog, no biscut");
+  }
+
+  public void testReject() throws IOException {
+    Presearcher presearcher = createPresearcher();
+    IllegalArgumentException e =
+        expectThrows(
+            IllegalArgumentException.class,
+            () -> {
+              presearcher.indexQuery(parse("*:*"), Collections.emptyMap());
+            });
+    assertEquals("bad dog, no biscut", e.getMessage());
+  }
+
+  public void testEmptyMonitorHandling() throws IOException {
+    try (Monitor monitor = newMonitor()) {
+      MatchingQueries<QueryMatch> matches =
+          monitor.match(PresearcherTestBase.buildDoc("field_2", "test"), QueryMatch.SIMPLE_MATCHER);
+      assertEquals(0, matches.getMatchCount());
+      assertEquals(0, matches.getQueriesRun());
+    }
+  }
+
+  public void testSimple() throws IOException {
+
+    try (Monitor monitor = newMonitor()) {
+      monitor.register(new MonitorQuery("1", parse("field:xxxx")));
+      monitor.register(new MonitorQuery("2", parse("field:yyyy")));
+
+      MatchingQueries<QueryMatch> matches =
+          monitor.match(PresearcherTestBase.buildDoc("field", "xxxx"), QueryMatch.SIMPLE_MATCHER);
+      assertEquals(1, matches.getQueriesRun());
+      assertNotNull(matches.matches("1"));
+    }
+  }
+
+  public void testSimpleBoolean() throws IOException {
+
+    try (Monitor monitor = newMonitor()) {
+      monitor.register(
+          new MonitorQuery("1", parse("field:\"hello world\"")),
+          new MonitorQuery("2", parse("field:world")),
+          new MonitorQuery("3", parse("field:\"hello there world\"")),
+          new MonitorQuery("4", parse("field:\"this and that\"")));
+
+      MatchingQueries<QueryMatch> matches =
+          monitor.match(
+              PresearcherTestBase.buildDoc("field", "hello world and goodbye"),
+              QueryMatch.SIMPLE_MATCHER);
+      assertEquals(2, matches.getQueriesRun());
+      assertNotNull(matches.matches("1"));
+    }
+  }
+
+  public void testRejectRegisterMatchAllQueriesWithMetadataFilterFields() throws IOException {
+    try (Monitor monitor = newMonitor()) {
+      IllegalArgumentException e =
+          expectThrows(
+              IllegalArgumentException.class,
+              () -> {
+                monitor.register(
+                    new MonitorQuery(
+                        "1", parse("*:*"), null, Collections.singletonMap("language", "de")));
+              });
+      assertEquals("bad dog, no biscut", e.getMessage());
+    }
+  }
+}
