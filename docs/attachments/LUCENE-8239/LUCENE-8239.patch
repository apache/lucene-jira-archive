Index: lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPolygonTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPolygonTest.java	(revision 60ae7be40786d6f8a5c5c8393875bf986d2b8877)
+++ lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPolygonTest.java	(revision )
@@ -1427,5 +1427,66 @@
     int largeIntersection = solid.getRelationship(largeShape);
     assertTrue(intersection == largeIntersection);
   }
-  
+
+  @Test
+  public void testComplexPolygonPlaneOutsideWorld() {
+    List<GeoPoint> points = new ArrayList<>();
+    points.add(new GeoPoint(PlanetModel.SPHERE, -0.5, -0.5));
+    points.add(new GeoPoint(PlanetModel.SPHERE, -0.5, 0.5));
+    points.add(new GeoPoint(PlanetModel.SPHERE, 0.5, 0.5));
+    points.add(new GeoPoint(PlanetModel.SPHERE,0.5, -0.5));
+    GeoPolygon polygon = GeoPolygonFactory.makeGeoPolygon(PlanetModel.SPHERE, points);
+    GeoPolygon largePolygon = new GeoComplexPolygon(PlanetModel.SPHERE, Collections.singletonList(points), new GeoPoint(PlanetModel.SPHERE, 0.25, 0), true);
+    GeoPoint point1 = new GeoPoint(PlanetModel.SPHERE, 0, 1e-8);
+    assertTrue(polygon.isWithin(point1) == largePolygon.isWithin(point1));
+    point1 = new GeoPoint(PlanetModel.SPHERE, 0, 1e-5);
+    assertTrue(polygon.isWithin(point1) == largePolygon.isWithin(point1));
+    point1 = new GeoPoint(PlanetModel.SPHERE, 0, 1e-7);
+    assertTrue(polygon.isWithin(point1) == largePolygon.isWithin(point1));
+    point1 = new GeoPoint(PlanetModel.SPHERE, 4.0E-323, -1.6670933394714538E-6);
+    assertTrue(polygon.isWithin(point1) == largePolygon.isWithin(point1));
+  }
+
+  @Test
+  public void testComplexPolygonDegeneratedVector() {
+    List<GeoPoint> points = new ArrayList<>();
+    points.add(new GeoPoint(PlanetModel.SPHERE, -0.5, -0.5));
+    points.add(new GeoPoint(PlanetModel.SPHERE, -0.5, 0.5));
+    points.add(new GeoPoint(PlanetModel.SPHERE, 0.5, 0.5));
+    points.add(new GeoPoint(PlanetModel.SPHERE,0.5, -0.5));
+    GeoPolygon polygon = GeoPolygonFactory.makeGeoPolygon(PlanetModel.SPHERE, points);
+    GeoPolygon largePolygon = new GeoComplexPolygon(PlanetModel.SPHERE, Collections.singletonList(points), new GeoPoint(PlanetModel.SPHERE, 0.0, 0), true);
+    GeoPoint point1 = new GeoPoint(PlanetModel.SPHERE, 0, 1e-8);
+    assertTrue(polygon.isWithin(point1) == largePolygon.isWithin(point1));
+    point1 = new GeoPoint(PlanetModel.SPHERE, 0, 1e-5);
+    assertTrue(polygon.isWithin(point1) == largePolygon.isWithin(point1));
+    point1 = new GeoPoint(PlanetModel.SPHERE, 0, 1e-7);
+    assertTrue(polygon.isWithin(point1) == largePolygon.isWithin(point1));
+
+    point1 = new GeoPoint(PlanetModel.SPHERE, 4.0E-323, -1.6670933394714538E-6);
+    assertTrue(polygon.isWithin(point1) == largePolygon.isWithin(point1));
+  }
+
+  @Test
+  public void testFail() {
+    //WKT: POLYGON((16.849706509709005 -50.89115929594581,25.189324454972887 -51.39358128421525,55.409286172889395 -1.3053002955884723,0.0 -1.8645516940399963E-7,-1.7453964879228958 55.6286759606979,-53.97300159482691 15.33327794992165, -55.411318529509465 -1.166333470709099,-31.511990002070064 -48.50297619023733, 16.849706509709005 -50.89115929594581))
+    List<GeoPoint> points = new ArrayList<>();
+    points.add(new GeoPoint(PlanetModel.SPHERE, Geo3DUtil.fromDegrees(-50.89115929594581), Geo3DUtil.fromDegrees(16.849706509709005)));
+    points.add(new GeoPoint(PlanetModel.SPHERE, Geo3DUtil.fromDegrees(-51.39358128421525), Geo3DUtil.fromDegrees(25.189324454972887)));
+    points.add(new GeoPoint(PlanetModel.SPHERE, Geo3DUtil.fromDegrees(-1.3053002955884723), Geo3DUtil.fromDegrees(55.409286172889395)));
+    points.add(new GeoPoint(PlanetModel.SPHERE, Geo3DUtil.fromDegrees(-1.8645516940399963E-7), Geo3DUtil.fromDegrees(0.0)));
+    points.add(new GeoPoint(PlanetModel.SPHERE, Geo3DUtil.fromDegrees(55.6286759606979), Geo3DUtil.fromDegrees(-1.7453964879228958)));
+    points.add(new GeoPoint(PlanetModel.SPHERE, Geo3DUtil.fromDegrees(15.33327794992165), Geo3DUtil.fromDegrees(-53.9730015948269)));
+    points.add(new GeoPoint(PlanetModel.SPHERE, Geo3DUtil.fromDegrees(-1.166333470709099), Geo3DUtil.fromDegrees(-55.411318529509465)));
+    points.add(new GeoPoint(PlanetModel.SPHERE, Geo3DUtil.fromDegrees(-48.50297619023733), Geo3DUtil.fromDegrees(-31.511990002070064)));
+    GeoPolygonFactory.PolygonDescription description = new GeoPolygonFactory.PolygonDescription(points);
+    GeoPolygon polygon = GeoPolygonFactory.makeGeoPolygon(PlanetModel.SPHERE, description);
+    GeoPolygon largePolygon = GeoPolygonFactory.makeLargeGeoPolygon(PlanetModel.SPHERE, Collections.singletonList(description));
+    //WKT: POINT(1.6952835757373162E-11 -8.5E-322)
+    GeoPoint point1 = new GeoPoint(PlanetModel.SPHERE, Geo3DUtil.fromDegrees(-8.5E-322), Geo3DUtil.fromDegrees(1.6952835757373162E-11));
+    assertTrue(polygon.isWithin(point1) == largePolygon.isWithin(point1));
+  }
+
+
+
 }
Index: lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.java	(revision 60ae7be40786d6f8a5c5c8393875bf986d2b8877)
+++ lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.java	(revision )
@@ -75,17 +75,36 @@
     this.pointsList = pointsList;  // For serialization
     this.testPointInSet = testPointInSet;
     this.testPoint = testPoint;
-    
-    this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);
-    this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);
-    this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);
-    
-    this.testPointFixedYAbovePlane = new Plane(testPointFixedYPlane, true);
-    this.testPointFixedYBelowPlane = new Plane(testPointFixedYPlane, false);
-    this.testPointFixedXAbovePlane = new Plane(testPointFixedXPlane, true);
-    this.testPointFixedXBelowPlane = new Plane(testPointFixedXPlane, false);
-    this.testPointFixedZAbovePlane = new Plane(testPointFixedZPlane, true);
-    this.testPointFixedZBelowPlane = new Plane(testPointFixedZPlane, false);
+
+    if (Math.abs(testPoint.y) +  Plane.MINIMUM_PLANE_OFFSET < planetModel.ab) {
+      this.testPointFixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint.y);
+      this.testPointFixedYAbovePlane = new Plane(testPointFixedYPlane, true);
+      this.testPointFixedYBelowPlane = new Plane(testPointFixedYPlane, false);
+    } else {
+      this.testPointFixedYPlane = null;
+      this.testPointFixedYAbovePlane = null;
+      this.testPointFixedYBelowPlane = null;
+    }
+
+    if (Math.abs(testPoint.x) +  Plane.MINIMUM_PLANE_OFFSET < planetModel.ab) {
+      this.testPointFixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint.x);
+      this.testPointFixedXAbovePlane = new Plane(testPointFixedXPlane, true);
+      this.testPointFixedXBelowPlane = new Plane(testPointFixedXPlane, false);
+    } else {
+      this.testPointFixedXPlane = null;
+      this.testPointFixedXAbovePlane = null;
+      this.testPointFixedXBelowPlane = null;
+    }
+
+    if (Math.abs(testPoint.z) +  Plane.MINIMUM_PLANE_OFFSET < planetModel.c) {
+      this.testPointFixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint.z);
+      this.testPointFixedZAbovePlane = new Plane(testPointFixedZPlane, true);
+      this.testPointFixedZBelowPlane = new Plane(testPointFixedZPlane, false);
+    } else {
+      this.testPointFixedZPlane = null;
+      this.testPointFixedZAbovePlane = null;
+      this.testPointFixedZBelowPlane = null;
+    }
 
     this.edgePoints = new GeoPoint[pointsList.size()];
     this.shapeStartEdges = new Edge[pointsList.size()];
@@ -166,7 +185,7 @@
     }
     
     // If we're right on top of any of the test planes, we navigate solely on that plane.
-    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {
+    if (testPointFixedYPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {
       // Use the XZ plane exclusively.
       final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);
       // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.
@@ -175,7 +194,7 @@
         return true;
       }
       return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;
-    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {
+    } else if (testPointFixedXPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {
       // Use the YZ plane exclusively.
       final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);
       // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.
@@ -184,7 +203,7 @@
         return true;
       }
       return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;
-    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {
+    } else if (testPointFixedZPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {
       final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);
       // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.
       if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {
@@ -196,19 +215,7 @@
       
       // This is the expensive part!!
       // Changing the code below has an enormous impact on the queries per second we see with the benchmark.
-      
-      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.
-      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);
-      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);
-      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);
 
-      // Find the intersection points for each one of these and the complementary test point planes.
-      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);
-      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);
-      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);
-      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);
-      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);
-      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);
 
       // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.
       double bestDistance = Double.POSITIVE_INFINITY;
@@ -221,144 +228,164 @@
       Tree firstLegTree = null;
       Tree secondLegTree = null;
       GeoPoint intersectionPoint = null;
-      
-      for (final GeoPoint p : XIntersectionsY) {
-        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)
-        // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.
-        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
-        final double tpDelta1 = testPoint.x - p.x;
-        final double tpDelta2 = testPoint.z - p.z;
-        final double cpDelta1 = y - p.y;
-        final double cpDelta2 = z - p.z;
-        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
-        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);
-        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);
-        if (newDistance < bestDistance) {
-          bestDistance = newDistance;
-          firstLegValue = testPoint.y;
-          secondLegValue = x;
-          firstLegPlane = testPointFixedYPlane;
-          firstLegAbovePlane = testPointFixedYAbovePlane;
-          firstLegBelowPlane = testPointFixedYBelowPlane;
-          secondLegPlane = travelPlaneFixedX;
-          firstLegTree = yTree;
-          secondLegTree = xTree;
-          intersectionPoint = p;
-        }
-      }
-      for (final GeoPoint p : XIntersectionsZ) {
-        // Travel would be in YZ plane (fixed x) then in XY (fixed z)
-        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
-        final double tpDelta1 = testPoint.x - p.x;
-        final double tpDelta2 = testPoint.y - p.y;
-        final double cpDelta1 = y - p.y;
-        final double cpDelta2 = z - p.z;
-        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
-        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);
-        //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);
-        if (newDistance < bestDistance) {
-          bestDistance = newDistance;
-          firstLegValue = testPoint.z;
-          secondLegValue = x;
-          firstLegPlane = testPointFixedZPlane;
-          firstLegAbovePlane = testPointFixedZAbovePlane;
-          firstLegBelowPlane = testPointFixedZBelowPlane;
-          secondLegPlane = travelPlaneFixedX;
-          firstLegTree = zTree;
-          secondLegTree = xTree;
-          intersectionPoint = p;
+
+      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.
+
+      final Plane travelPlaneFixedX = (Math.abs(x) + Plane.MINIMUM_PLANE_OFFSET < planetModel.ab) ? new Plane(1.0, 0.0, 0.0, -x) : null;
+      final Plane travelPlaneFixedY = (Math.abs(y) + Plane.MINIMUM_PLANE_OFFSET < planetModel.ab) ? new Plane(0.0, 1.0, 0.0, -y) : null;
+      final Plane travelPlaneFixedZ = (Math.abs(z) + Plane.MINIMUM_PLANE_OFFSET < planetModel.c) ? new Plane(0.0, 0.0, 1.0, -z) : null;
+
+      // Find the intersection points for each one of these and the complementary test point planes.
+      final GeoPoint[] XIntersectionsY = testPointFixedYPlane != null && travelPlaneFixedX!= null ? travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane) : new GeoPoint[0];
+      final GeoPoint[] XIntersectionsZ = testPointFixedZPlane != null && travelPlaneFixedX != null ? travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane) : new GeoPoint[0];
+      final GeoPoint[] YIntersectionsX = testPointFixedXPlane!= null && travelPlaneFixedY != null ? travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane) : new GeoPoint[0];
+      final GeoPoint[] YIntersectionsZ = testPointFixedZPlane != null && travelPlaneFixedY != null ? travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane) : new GeoPoint[0];
+      final GeoPoint[] ZIntersectionsX = testPointFixedXPlane != null && travelPlaneFixedZ != null ? travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane) : new GeoPoint[0];
+      final GeoPoint[] ZIntersectionsY = testPointFixedYPlane != null && travelPlaneFixedZ != null ? travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane) : new GeoPoint[0];
+
+      if (travelPlaneFixedX != null) {
+        for (final GeoPoint p : XIntersectionsY) {
+          // Travel would be in YZ plane (fixed x) then in XZ (fixed y)
+          // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.
+          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
+          final double tpDelta1 = testPoint.x - p.x;
+          final double tpDelta2 = testPoint.z - p.z;
+          final double cpDelta1 = y - p.y;
+          final double cpDelta2 = z - p.z;
+          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
+          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);
+          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);
+          if (newDistance < bestDistance) {
+            bestDistance = newDistance;
+            firstLegValue = testPoint.y;
+            secondLegValue = x;
+            firstLegPlane = testPointFixedYPlane;
+            firstLegAbovePlane = testPointFixedYAbovePlane;
+            firstLegBelowPlane = testPointFixedYBelowPlane;
+            secondLegPlane = travelPlaneFixedX;
+            firstLegTree = yTree;
+            secondLegTree = xTree;
+            intersectionPoint = p;
+          }
+        }
+        for (final GeoPoint p : XIntersectionsZ) {
+          // Travel would be in YZ plane (fixed x) then in XY (fixed z)
+          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
+          final double tpDelta1 = testPoint.x - p.x;
+          final double tpDelta2 = testPoint.y - p.y;
+          final double cpDelta1 = y - p.y;
+          final double cpDelta2 = z - p.z;
+          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
+          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);
+          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);
+          if (newDistance < bestDistance) {
+            bestDistance = newDistance;
+            firstLegValue = testPoint.z;
+            secondLegValue = x;
+            firstLegPlane = testPointFixedZPlane;
+            firstLegAbovePlane = testPointFixedZAbovePlane;
+            firstLegBelowPlane = testPointFixedZBelowPlane;
+            secondLegPlane = travelPlaneFixedX;
+            firstLegTree = zTree;
+            secondLegTree = xTree;
+            intersectionPoint = p;
+          }
         }
       }
-      for (final GeoPoint p : YIntersectionsX) {
-        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)
-        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
-        final double tpDelta1 = testPoint.y - p.y;
-        final double tpDelta2 = testPoint.z - p.z;
-        final double cpDelta1 = x - p.x;
-        final double cpDelta2 = z - p.z;
-        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
-        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);
-        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);
-        if (newDistance < bestDistance) {
-          bestDistance = newDistance;
-          firstLegValue = testPoint.x;
-          secondLegValue = y;
-          firstLegPlane = testPointFixedXPlane;
-          firstLegAbovePlane = testPointFixedXAbovePlane;
-          firstLegBelowPlane = testPointFixedXBelowPlane;
-          secondLegPlane = travelPlaneFixedY;
-          firstLegTree = xTree;
-          secondLegTree = yTree;
-          intersectionPoint = p;
-        }
-      }
-      for (final GeoPoint p : YIntersectionsZ) {
-        // Travel would be in XZ plane (fixed y) then in XY (fixed z)
-        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
-        final double tpDelta1 = testPoint.x - p.x;
-        final double tpDelta2 = testPoint.y - p.y;
-        final double cpDelta1 = x - p.x;
-        final double cpDelta2 = z - p.z;
-        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
-        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);
-        //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);
-        if (newDistance < bestDistance) {
-          bestDistance = newDistance;
-          firstLegValue = testPoint.z;
-          secondLegValue = y;
-          firstLegPlane = testPointFixedZPlane;
-          firstLegAbovePlane = testPointFixedZAbovePlane;
-          firstLegBelowPlane = testPointFixedZBelowPlane;
-          secondLegPlane = travelPlaneFixedY;
-          firstLegTree = zTree;
-          secondLegTree = yTree;
-          intersectionPoint = p;
+      if (travelPlaneFixedY != null) {
+        for (final GeoPoint p : YIntersectionsX) {
+          // Travel would be in XZ plane (fixed y) then in YZ (fixed x)
+          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
+          final double tpDelta1 = testPoint.y - p.y;
+          final double tpDelta2 = testPoint.z - p.z;
+          final double cpDelta1 = x - p.x;
+          final double cpDelta2 = z - p.z;
+          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
+          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);
+          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);
+          if (newDistance < bestDistance) {
+            bestDistance = newDistance;
+            firstLegValue = testPoint.x;
+            secondLegValue = y;
+            firstLegPlane = testPointFixedXPlane;
+            firstLegAbovePlane = testPointFixedXAbovePlane;
+            firstLegBelowPlane = testPointFixedXBelowPlane;
+            secondLegPlane = travelPlaneFixedY;
+            firstLegTree = xTree;
+            secondLegTree = yTree;
+            intersectionPoint = p;
+          }
+        }
+        for (final GeoPoint p : YIntersectionsZ) {
+          // Travel would be in XZ plane (fixed y) then in XY (fixed z)
+          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
+          final double tpDelta1 = testPoint.x - p.x;
+          final double tpDelta2 = testPoint.y - p.y;
+          final double cpDelta1 = x - p.x;
+          final double cpDelta2 = z - p.z;
+          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
+          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);
+          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);
+          if (newDistance < bestDistance) {
+            bestDistance = newDistance;
+            firstLegValue = testPoint.z;
+            secondLegValue = y;
+            firstLegPlane = testPointFixedZPlane;
+            firstLegAbovePlane = testPointFixedZAbovePlane;
+            firstLegBelowPlane = testPointFixedZBelowPlane;
+            secondLegPlane = travelPlaneFixedY;
+            firstLegTree = zTree;
+            secondLegTree = yTree;
+            intersectionPoint = p;
+          }
         }
       }
-      for (final GeoPoint p : ZIntersectionsX) {
-        // Travel would be in XY plane (fixed z) then in YZ (fixed x)
-        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
-        final double tpDelta1 = testPoint.y - p.y;
-        final double tpDelta2 = testPoint.z - p.z;
-        final double cpDelta1 = y - p.y;
-        final double cpDelta2 = x - p.x;
-        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
-        //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);
-        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);
-        if (newDistance < bestDistance) {
-          bestDistance = newDistance;
-          firstLegValue = testPoint.x;
-          secondLegValue = z;
-          firstLegPlane = testPointFixedXPlane;
-          firstLegAbovePlane = testPointFixedXAbovePlane;
-          firstLegBelowPlane = testPointFixedXBelowPlane;
-          secondLegPlane = travelPlaneFixedZ;
-          firstLegTree = xTree;
-          secondLegTree = zTree;
-          intersectionPoint = p;
-        }
-      }
-      for (final GeoPoint p : ZIntersectionsY) {
-        // Travel would be in XY plane (fixed z) then in XZ (fixed y)
-        //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
-        final double tpDelta1 = testPoint.x - p.x;
-        final double tpDelta2 = testPoint.z - p.z;
-        final double cpDelta1 = y - p.y;
-        final double cpDelta2 = x - p.x;
-        final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
-        //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);
-        //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);
-        if (newDistance < bestDistance) {
-          bestDistance = newDistance;
-          firstLegValue = testPoint.y;
-          secondLegValue = z;
-          firstLegPlane = testPointFixedYPlane;
-          firstLegAbovePlane = testPointFixedYAbovePlane;
-          firstLegBelowPlane = testPointFixedYBelowPlane;
-          secondLegPlane = travelPlaneFixedZ;
-          firstLegTree = yTree;
-          secondLegTree = zTree;
-          intersectionPoint = p;
+      if (travelPlaneFixedZ != null) {
+        for (final GeoPoint p : ZIntersectionsX) {
+          // Travel would be in XY plane (fixed z) then in YZ (fixed x)
+          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
+          final double tpDelta1 = testPoint.y - p.y;
+          final double tpDelta2 = testPoint.z - p.z;
+          final double cpDelta1 = y - p.y;
+          final double cpDelta2 = x - p.x;
+          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
+          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);
+          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);
+          if (newDistance < bestDistance) {
+            bestDistance = newDistance;
+            firstLegValue = testPoint.x;
+            secondLegValue = z;
+            firstLegPlane = testPointFixedXPlane;
+            firstLegAbovePlane = testPointFixedXAbovePlane;
+            firstLegBelowPlane = testPointFixedXBelowPlane;
+            secondLegPlane = travelPlaneFixedZ;
+            firstLegTree = xTree;
+            secondLegTree = zTree;
+            intersectionPoint = p;
+          }
+        }
+        for (final GeoPoint p : ZIntersectionsY) {
+          // Travel would be in XY plane (fixed z) then in XZ (fixed y)
+          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
+          final double tpDelta1 = testPoint.x - p.x;
+          final double tpDelta2 = testPoint.z - p.z;
+          final double cpDelta1 = y - p.y;
+          final double cpDelta2 = x - p.x;
+          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
+          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);
+          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);
+          if (newDistance < bestDistance) {
+            bestDistance = newDistance;
+            firstLegValue = testPoint.y;
+            secondLegValue = z;
+            firstLegPlane = testPointFixedYPlane;
+            firstLegAbovePlane = testPointFixedYAbovePlane;
+            firstLegBelowPlane = testPointFixedYBelowPlane;
+            secondLegPlane = travelPlaneFixedZ;
+            firstLegTree = yTree;
+            secondLegTree = zTree;
+            intersectionPoint = p;
+          }
         }
       }
 
