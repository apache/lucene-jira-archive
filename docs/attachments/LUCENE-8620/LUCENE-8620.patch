Index: lucene/sandbox/src/java/org/apache/lucene/geo/Rectangle2D.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/geo/Rectangle2D.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/sandbox/src/java/org/apache/lucene/geo/Rectangle2D.java	(date 1547734852000)
@@ -97,6 +97,15 @@
     return bboxContainsPoint(x, y, this.minX, this.maxX, this.minY, this.maxY);
   }
 
+  /** Checks if the rectangle is disjoint the provided point **/
+  public boolean queryContainsPointNotInEdge(int x, int y) {
+    if (this.crossesDateline() == true) {
+      return bboxContainsPointNotInEdge(x, y, MIN_LON_ENCODED, this.maxX, this.minY, this.maxY)
+          || bboxContainsPointNotInEdge(x, y, this.minX, MAX_LON_ENCODED, this.minY, this.maxY);
+    }
+    return bboxContainsPointNotInEdge(x, y, this.minX, this.maxX, this.minY, this.maxY);
+  }
+
   /** compare this to a provided rangle bounding box **/
   public PointValues.Relation relateRangeBBox(int minXOffset, int minYOffset, byte[] minTriangle,
                                               int maxXOffset, int maxYOffset, byte[] maxTriangle) {
@@ -147,6 +156,87 @@
     }
     return false;
   }
+
+  /**
+   *  Checks if the shape is within the provided triangle.
+   *
+   * @param ax longitude of point a of the triangle
+   * @param ay latitude of point a of the triangle
+   * @param ab if edge ab belongs to the original shape
+   * @param bx longitude of point b of the triangle
+   * @param by latitude of point b of the triangle
+   * @param bc if edge bc belongs to the original shape
+   * @param cx longitude of point c of the triangle
+   * @param cy latitude of point c of the triangle
+   * @param ca if edge ca belongs to the original shape
+   * @return
+   *  <ul>
+   *  <li> Boolean.True: If the shape is within the provided triangle or crosses only edges that do not belong
+   *  to the original shape.</li>
+   *  <li> Boolean.False: If the shape crosses an edge that belongs to the original shape.</li>
+   *  <li> null: If the shape is disjoint with the provided triangle.</li>
+   *  </ul>
+   */
+  public Boolean withinTriangle(int ax, int ay, boolean ab, int bx, int by, boolean bc, int cx, int cy, boolean ca) {
+    if (this.crossesDateline() == true) {
+      //Triangles cannot cross the date line so it is always false
+      return false;
+    }
+    return bboxWithinTriangle(ax, ay, ab, bx, by, bc, cx, cy, ca, minX, maxX, minY, maxY);
+  }
+  public Boolean bboxWithinTriangle(int ax, int ay, boolean ab, int bx, int by, boolean bc, int cx, int cy, boolean ca, int minLon, int maxLon, int minLat, int maxLat) {
+    //points belong to the shape so if points are inside the rectangle then it cannot be within. It is valid if the point
+    //is on the edge.
+    if (bboxContainsPointNotInEdge(ax, ay, minLon, maxLon, minLat, maxLat) ||
+        bboxContainsPointNotInEdge(bx, by, minLon, maxLon, minLat, maxLat) ||
+        bboxContainsPointNotInEdge(cx, cy, minLon, maxLon, minLat, maxLat)) {
+      return false;
+    }
+    //if any of the edges crosses and edge belonging to the polygon then it cannot be within.
+    //Note that crosses is different to intersects as it needs to have points at both sides.
+    boolean inside = false;
+    if  (edgeCrossesBox(ax, ay, bx, by, minLon, maxLon, minLat, maxLat) == true) {
+      if (ab == true) {
+        return false;
+      } else {
+        inside = true;
+      }
+    }
+    if (edgeCrossesBox(bx, by, cx, cy, minLon, maxLon, minLat, maxLat) == true) {
+      if (bc == true) {
+        return false;
+      } else {
+        inside = true;
+      }
+    }
+    if (edgeCrossesBox(cx, cy, ax, ay, minLon, maxLon, minLat, maxLat) == true) {
+      if (ca == true) {
+        return false;
+      } else {
+        inside = true;
+      }
+    }
+    //if any of the edges crosses and edge that does not belong to the polygon
+    // then it is a candidate for within
+    if (inside == true) {
+      return true;
+    }
+
+    // Check if the rectangle is fully within the triangle, if not then the relationship is undefined.
+    // compute bounding box of triangle
+    int tMinX = StrictMath.min(StrictMath.min(ax, bx), cx);
+    int tMaxX = StrictMath.max(StrictMath.max(ax, bx), cx);
+    int tMinY = StrictMath.min(StrictMath.min(ay, by), cy);
+    int tMaxY = StrictMath.max(StrictMath.max(ay, by), cy);
+    if ((tMinX <= minLon && tMaxX >= maxLon && tMinY <= minLat && tMaxY >= maxLat) == false) {
+      return null;
+    }
+    //We check the min and max points, if true it is inside
+    if ((Tessellator.pointInTriangle(minLon, minLat, ax, ay, bx, by, cx, cy))) {
+      return true;
+    }
+    return null;
+  }
 
   /** Checks if the rectangle contains the provided triangle **/
   public boolean containsTriangle(int ax, int ay, int bx, int by, int cx, int cy) {
@@ -216,6 +306,11 @@
     return (x < minX || x > maxX || y < minY || y > maxY) == false;
   }
 
+  /** static utility method to check if a bounding box is disjoint with a point */
+  private static boolean bboxContainsPointNotInEdge(int x, int y, int minX, int maxX, int minY, int maxY) {
+    return (x <= minX || x >= maxX || y <= minY || y >= maxY) == false;
+  }
+
   /** static utility method to check if a bounding box contains a triangle */
   private static boolean bboxContainsTriangle(int ax, int ay, int bx, int by, int cx, int cy,
                                              int minX, int maxX, int minY, int maxY) {
@@ -274,6 +369,46 @@
     }
     return false;
   }
+
+  /** returns true if the edge (defined by (ax, ay) (bx, by)) crosses the query */
+  private static boolean edgeCrossesBox(int ax, int ay, int bx, int by,
+                                           int minX, int maxX, int minY, int maxY) {
+    // shortcut: if edge is a point (occurs w/ Line shapes); simply check bbox w/ point
+    if (ax == bx && ay == by) {
+      return false;
+    }
+
+    // shortcut: check bboxes of edges are disjoint
+    if (boxesAreDisjoint(Math.min(ax, bx), Math.max(ax, bx), Math.min(ay, by), Math.max(ay, by),
+        minX, maxX, minY, maxY)) {
+      return false;
+    }
+
+    // top
+    if (orient(ax, ay, bx, by, minX, maxY) * orient(ax, ay, bx, by, maxX, maxY) < 0 &&
+        orient(minX, maxY, maxX, maxY, ax, ay) * orient(minX, maxY, maxX, maxY, bx, by) < 0) {
+      return true;
+    }
+
+    // right
+    if (orient(ax, ay, bx, by, maxX, maxY) * orient(ax, ay, bx, by, maxX, minY) < 0 &&
+        orient(maxX, maxY, maxX, minY, ax, ay) * orient(maxX, maxY, maxX, minY, bx, by) < 0) {
+      return true;
+    }
+
+    // bottom
+    if (orient(ax, ay, bx, by, maxX, minY) * orient(ax, ay, bx, by, minX, minY) < 0 &&
+        orient(maxX, minY, minX, minY, ax, ay) * orient(maxX, minY, minX, minY, bx, by) < 0) {
+      return true;
+    }
+
+    // left
+    if (orient(ax, ay, bx, by, minX, minY) * orient(ax, ay, bx, by, minX, maxY) < 0 &&
+        orient(minX, minY, minX, maxY, ax, ay) * orient(minX, minY, minX, maxY, bx, by) < 0) {
+      return true;
+    }
+    return false;
+  }
 
   /** utility method to check if two boxes are disjoint */
   private static boolean boxesAreDisjoint(final int aMinX, final int aMaxX, final int aMinY, final int aMaxY,
Index: lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java	(date 1547734852000)
@@ -195,7 +195,7 @@
   }
 
   /** uses orient method to compute whether two line segments cross */
-  public static boolean lineCrossesLine(double a1x, double a1y, double b1x, double b1y, double a2x, double a2y, double b2x, double b2y) {
+  public static boolean lineIntersectsLine(double a1x, double a1y, double b1x, double b1y, double a2x, double a2y, double b2x, double b2y) {
     // shortcut: either "line" is actually a point
     if ((a1x == b1x && a1y == b1y) || (a2x == b2x && a2y == b2y)) {
       return false;
@@ -207,6 +207,20 @@
     }
     return false;
   }
+
+  /** uses orient method to compute whether two line segments cross */
+  public static boolean lineCrossessLine(double a1x, double a1y, double b1x, double b1y, double a2x, double a2y, double b2x, double b2y) {
+    // shortcut: either "line" is actually a point
+    if ((a1x == b1x && a1y == b1y) || (a2x == b2x && a2y == b2y)) {
+      return false;
+    }
+
+    if (orient(a2x, a2y, b2x, b2y, a1x, a1y) * orient(a2x, a2y, b2x, b2y, b1x, b1y) < 0 &&
+        orient(a1x, a1y, b1x, b1y, a2x, a2y) * orient(a1x, a1y, b1x, b1y, b2x, b2y) < 0) {
+      return true;
+    }
+    return false;
+  }
 
   /**
    * used to define the orientation of 3 points
Index: lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointShapeQueries.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointShapeQueries.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointShapeQueries.java	(date 1547734852000)
@@ -75,6 +75,9 @@
   protected class PointValidator extends Validator {
     @Override
     public boolean testBBoxQuery(double minLat, double maxLat, double minLon, double maxLon, Object shape) {
+      if (queryRelation == QueryRelation.CONTAINS) {
+        return false;
+      }
       Point p = (Point)shape;
       double lat = quantizeLat(p.lat);
       double lon = quantizeLon(p.lon);
@@ -100,6 +103,9 @@
     }
 
     private boolean testPoint(EdgeTree tree, Point p) {
+      if (queryRelation == QueryRelation.CONTAINS) {
+        return false;
+      }
       double lat = quantizeLat(p.lat);
       double lon = quantizeLon(p.lon);
       // for consistency w/ the query we test the point as a triangle
Index: lucene/core/src/test/org/apache/lucene/geo/TestPolygon2D.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/core/src/test/org/apache/lucene/geo/TestPolygon2D.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/core/src/test/org/apache/lucene/geo/TestPolygon2D.java	(date 1547734852000)
@@ -332,4 +332,51 @@
       }
     }
   }
+
+  // targets the polygon directly
+  public void testWithinTriangle() {
+    Polygon polygon = new Polygon(new double[]{0, 0, 1, 1, 0}, new double[]{0, 1, 1, 0, 0});
+    Polygon2D impl = Polygon2D.create(polygon);
+    assertEquals(Relation.CELL_CROSSES_QUERY, impl.relateTriangle(-10, -1, 2, -1, 2, 5));
+    assertEquals(Boolean.TRUE, impl.withinTriangle(-10, -1, true, 2, -1, true, 2, 5, true));
+    assertEquals(Boolean.FALSE, impl.withinTriangle(-10, -10, true, 0.5, -10, true, 0.5, 30, true));
+    assertEquals(Boolean.TRUE, impl.withinTriangle(-10, -10, true, 1, -10, false, 1, 30, true));
+    assertEquals(null, impl.withinTriangle(80, 0, true, 81, 0, true, 81, 1, true));
+  }
+
+  // targets the polygon directly
+  public void testRandomWithinTriangle() {
+    for (int i = 0; i < 100; ++i) {
+      // random radius between 1Km and 10Km
+      int randomRadius = RandomNumbers.randomIntBetween(random(), 10000, 10000);
+      // random number of vertices
+      int numVertices = RandomNumbers.randomIntBetween(random(), 100, 1000);
+      Polygon polygon = createRegularPolygon(0, 0, randomRadius, numVertices);
+      Polygon2D impl = Polygon2D.create(polygon);
+      assertEquals(Relation.CELL_CROSSES_QUERY, impl.relateTriangle(-90, -90, 10, -90, 10, 90));
+      assertEquals(Boolean.TRUE, impl.withinTriangle(-90, -90, true,10, -90, true,10, 90, true));
+      assertEquals(Boolean.FALSE, impl.withinTriangle(-10, -10, true,0, -10, true,0, 30, true));
+      assertEquals(Boolean.TRUE, impl.withinTriangle(-10, -10, true,0, -10, false,0, 30, true));
+      assertEquals(Boolean.FALSE, impl.withinTriangle(0, 0, true,1e-6, 0, true,1e-6, 1e-6, true));
+      assertEquals(null, impl.withinTriangle(80, 0, true,81, 0, true,81, 1, true));
+    }
+  }
+
+  public void testWithinEdgeCase() {
+    Polygon polygon = new Polygon(new double[] {0, 0, 1, 0}, new double[] {0, 1, 1, 0});
+    Polygon2D impl = Polygon2D.create(polygon);
+    assertEquals(Boolean.TRUE, impl.withinTriangle(0, 0, true,1, 0, true,1, 1, true));
+  }
+
+  public void testWithinPointEdgeCase() {
+    Polygon polygon = new Polygon(new double[] {0, 0, 1, 0}, new double[] {0, 1, 1, 0});
+    Polygon2D impl = Polygon2D.create(polygon);
+    assertEquals(Boolean.FALSE, impl.withinTriangle(0, 0, true,0, 0, true,0, 0, true));
+  }
+
+  public void testWithinLineEdgeCase() {
+    Polygon polygon = new Polygon(new double[] {0, 0, 1, 0}, new double[] {0, 1, 1, 0});
+    Polygon2D impl = Polygon2D.create(polygon);
+    assertEquals(null, impl.withinTriangle(0, 0, true,1, 0, true,1, 0, true));
+  }
 }
Index: lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonLineShapeQueries.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonLineShapeQueries.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonLineShapeQueries.java	(date 1547734852000)
@@ -81,35 +81,52 @@
     public boolean testBBoxQuery(double minLat, double maxLat, double minLon, double maxLon, Object shape) {
       Line line = (Line)shape;
       Rectangle2D rectangle2D = Rectangle2D.create(new Rectangle(minLat, maxLat, minLon, maxLon));
+      Boolean answer = null;
       for (int i = 0, j = 1; j < line.numPoints(); ++i, ++j) {
-        int[] decoded = encodeDecodeTriangle(line.getLon(i), line.getLat(i), line.getLon(j), line.getLat(j), line.getLon(i), line.getLat(i));
+        LatLonShape.Triangle decoded = encodeDecodeTriangle(line.getLon(i), line.getLat(i), true, line.getLon(j), line.getLat(j), true, line.getLon(i), line.getLat(i), true);
         if (queryRelation == QueryRelation.WITHIN) {
-          if (rectangle2D.containsTriangle(decoded[1], decoded[0], decoded[3], decoded[2], decoded[5], decoded[4]) == false) {
+          if (rectangle2D.containsTriangle(decoded.aX, decoded.aY, decoded.bX, decoded.bY, decoded.cX, decoded.cY) == false) {
+            return false;
+          }
+        } else if(queryRelation == QueryRelation.CONTAINS) {
+          Boolean b = rectangle2D.withinTriangle(decoded.aX, decoded.aY, decoded.ab, decoded.bX, decoded.bY, decoded.bc, decoded.cX, decoded.cY, decoded.ca);
+          if  (b== Boolean.FALSE) {
             return false;
+          } else if (b == Boolean.TRUE) {
+            answer = b;
           }
         } else {
-          if (rectangle2D.intersectsTriangle(decoded[1], decoded[0], decoded[3], decoded[2], decoded[5], decoded[4]) == true) {
+          if (rectangle2D.intersectsTriangle(decoded.aX, decoded.aY, decoded.bX, decoded.bY, decoded.cX, decoded.cY) == true) {
             return queryRelation == QueryRelation.INTERSECTS;
           }
         }
       }
+      if (queryRelation == QueryRelation.CONTAINS) {
+        return answer == null ? false : true;
+      }
       return queryRelation != QueryRelation.INTERSECTS;
     }
 
     @Override
     public boolean testLineQuery(Line2D line2d, Object shape) {
+      if (queryRelation == QueryRelation.CONTAINS) {
+        return testWithInLine(line2d, (Line) shape);
+      }
       return testLine(line2d, (Line) shape);
     }
 
     @Override
     public boolean testPolygonQuery(Polygon2D poly2d, Object shape) {
+      if (queryRelation == QueryRelation.CONTAINS) {
+        return testWithInLine(poly2d, (Line) shape);
+      }
       return testLine(poly2d, (Line) shape);
     }
 
     private boolean testLine(EdgeTree queryPoly, Line line) {
 
       for (int i = 0, j = 1; j < line.numPoints(); ++i, ++j) {
-        double[] qTriangle = quantizeTriangle(line.getLon(i), line.getLat(i), line.getLon(j), line.getLat(j), line.getLon(i), line.getLat(i));
+        double[] qTriangle = quantizeTriangle(line.getLon(i), line.getLat(i), true, line.getLon(j), line.getLat(j), true, line.getLon(i), line.getLat(i), true);
         Relation r = queryPoly.relateTriangle(qTriangle[1], qTriangle[0], qTriangle[3], qTriangle[2], qTriangle[5], qTriangle[4]);
         if (queryRelation == QueryRelation.DISJOINT) {
           if (r != Relation.CELL_OUTSIDE_QUERY) return false;
@@ -121,5 +138,19 @@
       }
       return queryRelation == QueryRelation.INTERSECTS ? false : true;
     }
+
+    private boolean testWithInLine(EdgeTree tree, Line line) {
+      Boolean answer = null;
+      for (int i = 0, j = 1; j < line.numPoints(); ++i, ++j) {
+        double[] qTriangle = quantizeTriangle(line.getLon(i), line.getLat(i), true, line.getLon(j), line.getLat(j), true, line.getLon(i), line.getLat(i), true);
+        Boolean b = tree.withinTriangle(qTriangle[1], qTriangle[0], true, qTriangle[3], qTriangle[2], true, qTriangle[5], qTriangle[4], true);
+        if (b == Boolean.FALSE) {
+          return false;
+        } else if (b == Boolean.TRUE) {
+          answer = b;
+        }
+      }
+      return answer == null ? false : true;
+    }
   }
 }
Index: lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPolygonShapeQueries.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPolygonShapeQueries.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPolygonShapeQueries.java	(date 1547734852000)
@@ -20,6 +20,7 @@
 
 import org.apache.lucene.document.LatLonShape.QueryRelation;
 import org.apache.lucene.geo.EdgeTree;
+import org.apache.lucene.geo.GeoEncodingUtils;
 import org.apache.lucene.geo.Line2D;
 import org.apache.lucene.geo.Polygon;
 import org.apache.lucene.geo.Polygon2D;
@@ -70,35 +71,56 @@
       Polygon p = (Polygon)shape;
       Rectangle2D rectangle2D = Rectangle2D.create(new Rectangle(minLat, maxLat, minLon, maxLon));
       List<Tessellator.Triangle> tessellation = Tessellator.tessellate(p);
+      Boolean answer = null;
       for (Tessellator.Triangle t : tessellation) {
-        int[] decoded = encodeDecodeTriangle(t.getLon(0), t.getLat(0), t.getLon(1), t.getLat(1), t.getLon(2), t.getLat(2));
+        LatLonShape.Triangle decoded = encodeDecodeTriangle(t.getLon(0), t.getLat(0), t.fromPolygon(0),
+                                             t.getLon(1), t.getLat(1), t.fromPolygon(1),
+                                             t.getLon(2), t.getLat(2), t.fromPolygon(2));
         if (queryRelation == QueryRelation.WITHIN) {
-          if (rectangle2D.containsTriangle(decoded[1], decoded[0], decoded[3], decoded[2], decoded[5], decoded[4]) == false) {
+          if (rectangle2D.containsTriangle(decoded.aX, decoded.aY, decoded.bX, decoded.bY, decoded.cX, decoded.cY) == false) {
+            return false;
+          }
+        } else if(queryRelation == QueryRelation.CONTAINS) {
+          Boolean b = rectangle2D.withinTriangle(decoded.aX, decoded.aY, decoded.ab, decoded.bX, decoded.bY, decoded.bc, decoded.cX, decoded.cY, decoded.ca);
+          if  (b == Boolean.FALSE) {
             return false;
+          } else if (b == Boolean.TRUE) {
+            answer = b;
           }
         } else {
-          if (rectangle2D.intersectsTriangle(decoded[1], decoded[0], decoded[3], decoded[2], decoded[5], decoded[4]) == true) {
+          if (rectangle2D.intersectsTriangle(decoded.aX, decoded.aY, decoded.bX, decoded.bY, decoded.cX, decoded.cY) == true) {
             return queryRelation == QueryRelation.INTERSECTS;
           }
         }
       }
+      if (queryRelation == QueryRelation.CONTAINS) {
+        return answer == null ? false : true;
+      }
       return queryRelation != QueryRelation.INTERSECTS;
     }
 
     @Override
     public boolean testLineQuery(Line2D query, Object shape) {
+      if (queryRelation == QueryRelation.CONTAINS) {
+        return testWithInPolygon(query, (Polygon) shape);
+      }
       return testPolygon(query, (Polygon) shape);
     }
 
     @Override
     public boolean testPolygonQuery(Polygon2D query, Object shape) {
+      if (queryRelation == QueryRelation.CONTAINS) {
+        return testWithInPolygon(query, (Polygon) shape);
+      }
       return testPolygon(query, (Polygon) shape);
     }
 
     private boolean testPolygon(EdgeTree tree, Polygon shape) {
       List<Tessellator.Triangle> tessellation = Tessellator.tessellate(shape);
       for (Tessellator.Triangle t : tessellation) {
-        double[] qTriangle = quantizeTriangle(t.getLon(0), t.getLat(0), t.getLon(1), t.getLat(1), t.getLon(2), t.getLat(2));
+        double[] qTriangle = quantizeTriangle(t.getLon(0), t.getLat(0), t.fromPolygon(0),
+                                              t.getLon(1), t.getLat(1), t.fromPolygon(1),
+                                              t.getLon(2), t.getLat(2), t.fromPolygon(2));
         Relation r = tree.relateTriangle(qTriangle[1], qTriangle[0], qTriangle[3], qTriangle[2], qTriangle[5], qTriangle[4]);
         if (queryRelation == QueryRelation.DISJOINT) {
           if (r != Relation.CELL_OUTSIDE_QUERY) return false;
@@ -110,6 +132,25 @@
       }
       return queryRelation == QueryRelation.INTERSECTS ? false : true;
     }
+
+    private boolean testWithInPolygon(EdgeTree tree, Polygon shape) {
+      List<Tessellator.Triangle> tessellation = Tessellator.tessellate(shape);
+      Boolean answer = null;
+      for (Tessellator.Triangle t : tessellation) {
+        LatLonShape.Triangle qTriangle = encodeDecodeTriangle(t.getLon(0), t.getLat(0), t.fromPolygon(0),
+            t.getLon(1), t.getLat(1), t.fromPolygon(1),
+            t.getLon(2), t.getLat(2), t.fromPolygon(2));
+        Boolean b = tree.withinTriangle(GeoEncodingUtils.decodeLongitude(qTriangle.aX), GeoEncodingUtils.decodeLatitude(qTriangle.aY), qTriangle.ab,
+            GeoEncodingUtils.decodeLongitude(qTriangle.bX), GeoEncodingUtils.decodeLatitude(qTriangle.bY), qTriangle.bc,
+            GeoEncodingUtils.decodeLongitude(qTriangle.cX), GeoEncodingUtils.decodeLatitude(qTriangle.cY), qTriangle.ca);
+        if (b == Boolean.FALSE) {
+          return false;
+        } else if (b == Boolean.TRUE) {
+          answer = b;
+        }
+      }
+      return answer == null ? false : true;
+    }
   }
 
   @Nightly
Index: lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapeBoundingBoxQuery.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapeBoundingBoxQuery.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapeBoundingBoxQuery.java	(date 1547734852000)
@@ -45,16 +45,16 @@
 
   /** returns true if the query matches the encoded triangle */
   @Override
-  protected boolean queryMatches(byte[] t, int[] scratchTriangle) {
+  protected boolean queryMatches(byte[] t, LatLonShape.Triangle scratchTriangle) {
     // decode indexed triangle
     LatLonShape.decodeTriangle(t, scratchTriangle);
 
-    int aY = scratchTriangle[0];
-    int aX = scratchTriangle[1];
-    int bY = scratchTriangle[2];
-    int bX = scratchTriangle[3];
-    int cY = scratchTriangle[4];
-    int cX = scratchTriangle[5];
+    int aY = scratchTriangle.aY;
+    int aX = scratchTriangle.aX;
+    int bY = scratchTriangle.bY;
+    int bX = scratchTriangle.bX;
+    int cY = scratchTriangle.cY;
+    int cX = scratchTriangle.cX;
 
     if (queryRelation == LatLonShape.QueryRelation.WITHIN) {
       return rectangle2D.containsTriangle(aX, aY, bX, bY, cX, cY);
@@ -62,6 +62,21 @@
     return rectangle2D.intersectsTriangle(aX, aY, bX, bY, cX, cY);
   }
 
+  @Override
+  protected Boolean queryWithin(byte[] t, LatLonShape.Triangle scratchTriangle) {
+    // decode indexed triangle
+    LatLonShape.decodeTriangle(t, scratchTriangle);
+
+    int aY = scratchTriangle.aY;
+    int aX = scratchTriangle.aX;
+    int bY = scratchTriangle.bY;
+    int bX = scratchTriangle.bX;
+    int cY = scratchTriangle.cY;
+    int cX = scratchTriangle.cX;
+
+    return rectangle2D.withinTriangle(aX, aY, scratchTriangle.ab, bX, bY, scratchTriangle.bc, cX, cY, scratchTriangle.ca);
+  }
+
   @Override
   public boolean equals(Object o) {
     return sameClassAs(o) && equalsTo(getClass().cast(o));
Index: lucene/sandbox/src/test/org/apache/lucene/document/BaseLatLonShapeTestCase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/document/BaseLatLonShapeTestCase.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/sandbox/src/test/org/apache/lucene/document/BaseLatLonShapeTestCase.java	(date 1547734852000)
@@ -95,22 +95,22 @@
   }
 
   /** quantizes a triangle to be consistent with index encoding */
-  protected double[] quantizeTriangle(double ax, double ay, double bx, double by, double cx, double cy) {
-    int[] decoded = encodeDecodeTriangle(ax, ay, bx, by, cx, cy);
-    return new double[]{decodeLatitude(decoded[0]), decodeLongitude(decoded[1]), decodeLatitude(decoded[2]), decodeLongitude(decoded[3]), decodeLatitude(decoded[4]), decodeLongitude(decoded[5])};
+  protected double[] quantizeTriangle(double ax, double ay, boolean ab, double bx, double by, boolean bc, double cx, double cy, boolean ca) {
+    LatLonShape.Triangle decoded = encodeDecodeTriangle(ax, ay, ab, bx, by, bc, cx, cy, ca);
+    return new double[]{decodeLatitude(decoded.aY), decodeLongitude(decoded.aX), decodeLatitude(decoded.bY), decodeLongitude(decoded.bX), decodeLatitude(decoded.cY), decodeLongitude(decoded.cX)};
   }
 
   /** encode/decode a triangle */
-  protected int[] encodeDecodeTriangle(double ax, double ay, double bx, double by, double cx, double cy) {
+  protected LatLonShape.Triangle encodeDecodeTriangle(double ax, double ay, boolean ab, double bx, double by, boolean bc, double cx, double cy, boolean ca) {
     byte[] encoded = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(encoded, encodeLatitude(ay), encodeLongitude(ax), encodeLatitude(by), encodeLongitude(bx), encodeLatitude(cy), encodeLongitude(cx));
-    int[] decoded = new int[6];
+    LatLonShape.encodeTriangle(encoded, encodeLatitude(ay), encodeLongitude(ax), ab, encodeLatitude(by), encodeLongitude(bx), bc, encodeLatitude(cy), encodeLongitude(cx), ca);
+    LatLonShape.Triangle decoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(encoded, decoded);
     return decoded;
   }
 
   /** use {@link GeoTestUtil#nextPolygon()} to create a random line; TODO: move to GeoTestUtil */
-  public Line nextLine() {
+  public static Line nextLine() {
     Polygon poly = GeoTestUtil.nextPolygon();
     double[] lats = new double[poly.numPoints() - 1];
     double[] lons = new double[lats.length];
@@ -229,6 +229,7 @@
     // query testing
     final IndexReader reader = DirectoryReader.open(w);
 
+
     // test random bbox queries
     verifyRandomBBoxQueries(reader, shapes);
     // test random line queries
@@ -391,7 +392,6 @@
 
       // line
       Line queryLine = randomQueryLine(shapes);
-      Line2D queryLine2D = Line2D.create(queryLine);
       QueryRelation queryRelation = RandomPicks.randomFrom(random(), POINT_LINE_RELATIONS);
       Query query = newLineQuery(FIELD_NAME, queryRelation, queryLine);
 
@@ -432,7 +432,7 @@
         } else if (shapes[id] == null) {
           expected = false;
         } else {
-          expected = getValidator(queryRelation).testLineQuery(queryLine2D, shapes[id]);
+          expected = getValidator(queryRelation).testLineQuery(Line2D.create(queryLine), shapes[id]);
         }
 
         if (hits.get(docID) != expected) {
@@ -478,7 +478,6 @@
 
       // Polygon
       Polygon queryPolygon = GeoTestUtil.nextPolygon();
-      Polygon2D queryPoly2D = Polygon2D.create(queryPolygon);
       QueryRelation queryRelation = RandomPicks.randomFrom(random(), QueryRelation.values());
       Query query = newPolygonQuery(FIELD_NAME, queryRelation, queryPolygon);
 
@@ -519,7 +518,7 @@
         } else if (shapes[id] == null) {
           expected = false;
         } else {
-          expected = getValidator(queryRelation).testPolygonQuery(queryPoly2D, shapes[id]);
+          expected = getValidator(queryRelation).testPolygonQuery(Polygon2D.create(queryPolygon), shapes[id]);
         }
 
         if (hits.get(docID) != expected) {
Index: lucene/sandbox/src/test/org/apache/lucene/geo/TestRectangle2D.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/geo/TestRectangle2D.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/sandbox/src/test/org/apache/lucene/geo/TestRectangle2D.java	(date 1547734852000)
@@ -36,6 +36,7 @@
     int cy = GeoEncodingUtils.encodeLatitude(4);
     assertFalse(rectangle2D.intersectsTriangle(ax, ay, bx, by , cx, cy));
     assertFalse(rectangle2D.containsTriangle(ax, ay, bx, by , cx, cy));
+    assertNull(rectangle2D.withinTriangle(ax, ay, true, bx, by , true, cx, cy, true));
   }
 
   public void testTriangleIntersects() {
@@ -49,6 +50,7 @@
     int cy = GeoEncodingUtils.encodeLatitude(2);
     assertTrue(rectangle2D.intersectsTriangle(ax, ay, bx, by , cx, cy));
     assertFalse(rectangle2D.containsTriangle(ax, ay, bx, by , cx, cy));
+    assertFalse(rectangle2D.withinTriangle(ax, ay, true, bx, by, true, cx, cy, true));
   }
 
   public void testTriangleContains() {
@@ -62,10 +64,84 @@
     int cy = GeoEncodingUtils.encodeLatitude(0.25);
     assertTrue(rectangle2D.intersectsTriangle(ax, ay, bx, by , cx, cy));
     assertTrue(rectangle2D.containsTriangle(ax, ay, bx, by , cx, cy));
+    assertFalse(rectangle2D.withinTriangle(ax, ay, true, bx, by, true, cx, cy, true));
+  }
+
+  public void testTriangleContainsEdgeCase() {
+    Rectangle rectangle = new Rectangle(0, 1, 0, 1);
+    Rectangle2D rectangle2D =  Rectangle2D.create(rectangle);
+    int ax = GeoEncodingUtils.encodeLongitude(0.0);
+    int ay = GeoEncodingUtils.encodeLatitude(0.0);
+    int bx = GeoEncodingUtils.encodeLongitude(0.0);
+    int by = GeoEncodingUtils.encodeLatitude(0.5);
+    int cx = GeoEncodingUtils.encodeLongitude(0.5);
+    int cy = GeoEncodingUtils.encodeLatitude(0.25);
+    assertTrue(rectangle2D.intersectsTriangle(ax, ay, bx, by , cx, cy));
+    assertTrue(rectangle2D.containsTriangle(ax, ay, bx, by , cx, cy));
+    assertFalse(rectangle2D.withinTriangle(ax, ay, true, bx, by, true, cx, cy, true));
+  }
+
+  public void testTriangleWithin() {
+    Rectangle rectangle = new Rectangle(0, 1, 0, 1);
+    Rectangle2D rectangle2D =  Rectangle2D.create(rectangle);
+    int ax = GeoEncodingUtils.encodeLongitude(-10);
+    int ay = GeoEncodingUtils.encodeLatitude(-10);
+    int bx = GeoEncodingUtils.encodeLongitude(10);
+    int by = GeoEncodingUtils.encodeLatitude(-10);
+    int cx = GeoEncodingUtils.encodeLongitude(10);
+    int cy = GeoEncodingUtils.encodeLatitude(20);
+    assertTrue(rectangle2D.intersectsTriangle(ax, ay, bx, by , cx, cy));
+    assertFalse(rectangle2D.containsTriangle(ax, ay, bx, by , cx, cy));
+    assertTrue(rectangle2D.withinTriangle(ax, ay, true, bx, by, true, cx, cy, true));
+  }
+
+  public void testTriangleWithinEdgeCase() {
+    Rectangle rectangle = new Rectangle(0, 1, 0, 1);
+    Rectangle2D rectangle2D =  Rectangle2D.create(rectangle);
+    int ax = GeoEncodingUtils.encodeLongitude(0);
+    int ay = GeoEncodingUtils.encodeLatitude(0);
+    int bx = GeoEncodingUtils.encodeLongitude(20);
+    int by = GeoEncodingUtils.encodeLatitude(0);
+    int cx = GeoEncodingUtils.encodeLongitude(0);
+    int cy = GeoEncodingUtils.encodeLatitude(20);
+    assertTrue(rectangle2D.intersectsTriangle(ax, ay, bx, by , cx, cy));
+    assertFalse(rectangle2D.containsTriangle(ax, ay, bx, by , cx, cy));
+    assertTrue(rectangle2D.withinTriangle(ax, ay, true, bx, by, true, cx, cy, true));
+  }
+
+  public void testTriangleWithinPointEdgeCase() {
+    Rectangle rectangle = new Rectangle(-90, 0, 0, 0);
+    Rectangle2D rectangle2D =  Rectangle2D.create(rectangle);
+    int ax = GeoEncodingUtils.encodeLongitude(1.401298464324817E-45);
+    int ay = GeoEncodingUtils.encodeLatitude(-90);
+    int bx = GeoEncodingUtils.encodeLongitude(1.401298464324817E-45);
+    int by = GeoEncodingUtils.encodeLatitude(-90);
+    int cx = GeoEncodingUtils.encodeLongitude(1.401298464324817E-45);
+    int cy = GeoEncodingUtils.encodeLatitude(-90);
+    assertTrue(rectangle2D.intersectsTriangle(ax, ay, bx, by , cx, cy));
+    assertTrue(rectangle2D.containsTriangle(ax, ay, bx, by , cx, cy));
+    assertNull(rectangle2D.withinTriangle(ax, ay, true, bx, by, true, cx, cy, true));
+  }
+
+  public void testTriangleWithinCrossingDateLine() {
+    Rectangle rectangle = new Rectangle(0,  2, 179, -179);
+    Rectangle2D rectangle2D =  Rectangle2D.create(rectangle);
+    int ax = GeoEncodingUtils.encodeLongitude(169);
+    int ay = GeoEncodingUtils.encodeLatitude(-10);
+    int bx = GeoEncodingUtils.encodeLongitude(180);
+    int by = GeoEncodingUtils.encodeLatitude(-10);
+    int cx = GeoEncodingUtils.encodeLongitude(180);
+    int cy = GeoEncodingUtils.encodeLatitude(30);
+    assertTrue(rectangle2D.intersectsTriangle(ax, ay, bx, by , cx, cy));
+    assertFalse(rectangle2D.containsTriangle(ax, ay, bx, by , cx, cy));
+    assertFalse(rectangle2D.withinTriangle(ax, ay, true, bx, by, true, cx, cy, true));
   }
 
   public void testRandomTriangles() {
     Rectangle rectangle = GeoTestUtil.nextBox();
+    while(rectangle.crossesDateline()) {
+      rectangle = GeoTestUtil.nextBox();
+    }
     Rectangle2D rectangle2D = Rectangle2D.create(rectangle);
 
     for (int i =0; i < 100; i++) {
@@ -91,9 +167,13 @@
       if (r == PointValues.Relation.CELL_OUTSIDE_QUERY) {
         assertFalse(rectangle2D.intersectsTriangle(ax, ay, bx, by , cx, cy));
         assertFalse(rectangle2D.containsTriangle(ax, ay, bx, by , cx, cy));
-      }
-      else if (rectangle2D.containsTriangle(ax, ay, bx, by , cx, cy)) {
+        assertNull(rectangle2D.withinTriangle(ax, ay, true, bx, by, true, cx, cy, true));
+      } else if (rectangle2D.containsTriangle(ax, ay, bx, by , cx, cy)) {
         assertTrue(rectangle2D.intersectsTriangle(ax, ay, bx, by , cx, cy));
+        assertFalse(rectangle2D.withinTriangle(ax, ay, true, bx, by, true, cx, cy, true));
+      } else if (rectangle2D.withinTriangle(ax, ay, true, bx, by , true, cx, cy, true) == Boolean.TRUE) {
+        assertTrue(rectangle2D.intersectsTriangle(ax, ay, bx, by , cx, cy));
+        assertFalse(rectangle2D.containsTriangle(ax, ay, bx, by , cx, cy));
       }
     }
   }
Index: lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapeQuery.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapeQuery.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapeQuery.java	(date 1547734852000)
@@ -24,8 +24,8 @@
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.PointValues;
-import org.apache.lucene.index.PointValues.IntersectVisitor;
 import org.apache.lucene.index.PointValues.Relation;
+import org.apache.lucene.index.PointValues.IntersectVisitor;
 import org.apache.lucene.search.ConstantScoreScorer;
 import org.apache.lucene.search.ConstantScoreWeight;
 import org.apache.lucene.search.DocIdSetIterator;
@@ -39,6 +39,7 @@
 import org.apache.lucene.util.DocIdSetBuilder;
 import org.apache.lucene.util.FixedBitSet;
 
+
 /**
  * Base LatLonShape Query class providing common query logic for
  * {@link LatLonShapeBoundingBoxQuery} and {@link LatLonShapePolygonQuery}
@@ -70,10 +71,24 @@
    *   see {@link LatLonShapeBoundingBoxQuery#relateRangeToQuery} and {@link LatLonShapePolygonQuery#relateRangeToQuery}
    */
   protected abstract Relation relateRangeBBoxToQuery(int minXOffset, int minYOffset, byte[] minTriangle,
-                                                     int maxXOffset, int maxYOffset, byte[] maxTriangle);
+                                                                 int maxXOffset, int maxYOffset, byte[] maxTriangle);
 
   /** returns true if the provided triangle matches the query */
-  protected abstract boolean queryMatches(byte[] triangle, int[] scratchTriangle);
+  protected abstract boolean queryMatches(byte[] triangle, LatLonShape.Triangle scratchTriangle);
+
+  /**
+   * Checks if the query shape is within the provided triangle.
+   * @param triangle the encoded triangle to check
+   * @param scratchTriangle triangle helper to be used for decoding the provided encoded triangle.
+   * @return
+   *  <ul>
+   *  <li> Boolean.True: If the shape is a candidate for within.</li>
+   *  <li> Boolean.False The shape cannot be within the triangle.</li>
+   *  <li> null: Relationship is undefined.</li>
+   *  </ul>
+   */
+  //TODO: use an enum when this class is moved to final package
+  protected abstract Boolean queryWithin(byte[] triangle, LatLonShape.Triangle scratchTriangle);
 
   /** relates a range of triangles (internal node) to the query */
   protected Relation relateRangeToQuery(byte[] minTriangle, byte[] maxTriangle) {
@@ -81,6 +96,8 @@
     Relation r = relateRangeBBoxToQuery(LatLonShape.BYTES, 0, minTriangle, 3 * LatLonShape.BYTES, 2 * LatLonShape.BYTES, maxTriangle);
     if (queryRelation == QueryRelation.DISJOINT) {
       return transposeRelation(r);
+    } else if (queryRelation == QueryRelation.CONTAINS && r == Relation.CELL_INSIDE_QUERY) {
+      return Relation.CELL_OUTSIDE_QUERY;
     }
     return r;
   }
@@ -93,7 +110,7 @@
       /** create a visitor that adds documents that match the query using a sparse bitset. (Used by INTERSECT) */
       protected IntersectVisitor getSparseIntersectVisitor(DocIdSetBuilder result) {
         return new IntersectVisitor() {
-          final int[] scratchTriangle = new int[6];
+          final LatLonShape.Triangle scratchTriangle = new LatLonShape.Triangle();
           DocIdSetBuilder.BulkAdder adder;
 
           @Override
@@ -123,11 +140,12 @@
       /** create a visitor that adds documents that match the query using a dense bitset. (Used by WITHIN, DISJOINT) */
       protected IntersectVisitor getDenseIntersectVisitor(FixedBitSet intersect, FixedBitSet disjoint) {
         return new IntersectVisitor() {
-          final int[] scratchTriangle = new int[6];
+          final LatLonShape.Triangle scratchTriangle = new LatLonShape.Triangle();
           @Override
           public void visit(int docID) throws IOException {
-            if (queryRelation == QueryRelation.DISJOINT) {
-              // if DISJOINT query set the doc in the disjoint bitset
+            if (queryRelation == QueryRelation.DISJOINT || queryRelation == QueryRelation.CONTAINS) {
+              // if DISJOINT or CONTAINS query set the doc in the disjoint bitset
+              //For contains we assumen that points on the triangle belongs to the polygon
               disjoint.set(docID);
             } else {
               // for INTERSECT, and WITHIN queries we set the intersect bitset
@@ -137,10 +155,20 @@
 
           @Override
           public void visit(int docID, byte[] t) throws IOException {
-            if (queryMatches(t, scratchTriangle)) {
-              intersect.set(docID);
-            } else {
-              disjoint.set(docID);
+            if (queryRelation == QueryRelation.CONTAINS) {
+              //If null, the relationship is undefined
+              Boolean within = queryWithin(t, scratchTriangle);
+              if (within == Boolean.TRUE) {
+                intersect.set(docID);
+              } else if (within == Boolean.FALSE) {
+                disjoint.set(docID);
+              }
+            } else {
+              if (queryMatches(t, scratchTriangle)) {
+                intersect.set(docID);
+              } else {
+                disjoint.set(docID);
+              }
             }
           }
 
@@ -163,7 +191,7 @@
         };
       }
 
-      /** get a scorer supplier for all other queries (DISJOINT, WITHIN) */
+      /** get a scorer supplier for all other queries (DISJOINT, WITHIN, CONTAINS) */
       protected ScorerSupplier getScorerSupplier(LeafReader reader, PointValues values, Weight weight, ScoreMode scoreMode) throws IOException {
         if (queryRelation == QueryRelation.INTERSECTS) {
           return getIntersectScorerSupplier(reader, values, weight, scoreMode);
@@ -285,7 +313,7 @@
     /** create a visitor that clears documents that do NOT match the polygon query; used with INTERSECTS */
     private IntersectVisitor getInverseIntersectVisitor(LatLonShapeQuery query, FixedBitSet result, int[] cost) {
       return new IntersectVisitor() {
-        int[] scratchTriangle = new int[6];
+        LatLonShape.Triangle scratchTriangle = new LatLonShape.Triangle();
         @Override
         public void visit(int docID) {
           result.clear(docID);
@@ -337,7 +365,7 @@
       if (query.queryRelation == QueryRelation.DISJOINT) {
         disjoint.andNot(intersect);
         iterator = new BitSetIterator(disjoint, cost());
-      } else if (query.queryRelation == QueryRelation.WITHIN) {
+      } else if (query.queryRelation == QueryRelation.WITHIN || query.queryRelation == QueryRelation.CONTAINS) {
         intersect.andNot(disjoint);
         iterator = new BitSetIterator(intersect, cost());
       } else {
Index: lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/sandbox/src/java/org/apache/lucene/geo/Tessellator.java	(date 1547734852000)
@@ -134,6 +134,7 @@
     if (lastNode != null && isVertexEquals(lastNode, lastNode.next)) {
       removeNode(lastNode);
       lastNode = lastNode.next;
+      lastNode.previous.nextEdgeFromPolygon = true;
     }
 
     // Return the last node in the Doubly-Linked List
@@ -290,7 +291,10 @@
         final boolean isReflex = area(prevNode.getX(), prevNode.getY(), currEar.getX(), currEar.getY(), nextNode.getX(), nextNode.getY()) >= 0;
         if (isReflex == false && isEar(currEar, mortonOptimized) == true) {
           // Return the triangulated data
-          tessellation.add(new Triangle(prevNode, currEar, nextNode));
+          boolean abFromPolygon = (prevNode.next == currEar) ? prevNode.nextEdgeFromPolygon : false;
+          boolean bcFromPolygon = (currEar.next == nextNode) ? currEar.nextEdgeFromPolygon : false;
+          boolean caFromPolygon = (nextNode.next == prevNode) ? nextNode.nextEdgeFromPolygon : false;
+          tessellation.add(new Triangle(prevNode, abFromPolygon, currEar, bcFromPolygon, nextNode, caFromPolygon));
           // Remove the ear node.
           removeNode(currEar);
 
@@ -417,7 +421,10 @@
           && linesIntersect(a.getX(), a.getY(), node.getX(), node.getY(), nextNode.getX(), nextNode.getY(), b.getX(), b.getY())
           && isLocallyInside(a, b) && isLocallyInside(b, a)) {
         // Return the triangulated vertices to the tessellation
-        tessellation.add(new Triangle(a, node, b));
+        boolean abFromPolygon = (a.next == node) ? a.nextEdgeFromPolygon : false;
+        boolean bcFromPolygon = (node.next == b) ? node.nextEdgeFromPolygon : false;
+        boolean caFromPolygon = (b.next == a) ? b.nextEdgeFromPolygon : false;
+        tessellation.add(new Triangle(a, abFromPolygon, node, bcFromPolygon,  b, caFromPolygon));
 
         // remove two nodes involved
         removeNode(node);
@@ -470,6 +477,7 @@
     final Node bp = b.previous;
 
     a.next = b;
+    a.nextEdgeFromPolygon = false;
     a.nextZ = b;
     b.previous = a;
     b.previousZ = a;
@@ -478,6 +486,7 @@
     an.previous = a2;
     an.previousZ = a2;
     b2.next = a2;
+    b2.nextEdgeFromPolygon = false;
     b2.nextZ = a2;
     a2.previous = b2;
     a2.previousZ = b2;
@@ -646,10 +655,12 @@
       continueIteration = false;
       nextNode = node.next;
       prevNode = node.previous;
-      if (node.isSteiner == false && isVertexEquals(node, nextNode)
-          || area(prevNode.getX(), prevNode.getY(), node.getX(), node.getY(), nextNode.getX(), nextNode.getY()) == 0) {
+      if (prevNode.nextEdgeFromPolygon == node.nextEdgeFromPolygon &&
+          (node.isSteiner == false && isVertexEquals(node, nextNode)
+          || area(prevNode.getX(), prevNode.getY(), node.getX(), node.getY(), nextNode.getX(), nextNode.getY()) == 0)) {
         // Remove the node
         removeNode(node);
+        prevNode.nextEdgeFromPolygon = true;
         node = end = prevNode;
 
         if (node == nextNode) {
@@ -688,6 +699,7 @@
   private static final void removeNode(Node node) {
     node.next.previous = node.previous;
     node.previous.next = node.next;
+    node.previous.nextEdgeFromPolygon = false;
 
     if (node.previousZ != null) {
       node.previousZ.nextZ = node.nextZ;
@@ -723,13 +735,23 @@
 
   /** compute whether the given x, y point is in a triangle; uses the winding order method */
   public static boolean pointInTriangle (double x, double y, double ax, double ay, double bx, double by, double cx, double cy) {
-    int a = orient(x, y, ax, ay, bx, by);
-    int b = orient(x, y, bx, by, cx, cy);
-    if (a == 0 || b == 0 || a < 0 == b < 0) {
-      int c = orient(x, y, cx, cy, ax, ay);
-      return c == 0 || (c < 0 == (b < 0 || a < 0));
-    }
-    return false;
+    double minX = StrictMath.min(ax, StrictMath.min(bx, cx));
+    double minY = StrictMath.min(ay, StrictMath.min(by, cy));
+    double maxX = StrictMath.max(ax, StrictMath.max(bx, cx));
+    double maxY = StrictMath.max(ay, StrictMath.max(by, cy));
+    //check the bounding box because if the triangle is degenerated, e.g points and lines, we need to filter out
+    //coplanar points that are not part of the triangle.
+    if (x >= minX && x <= maxX && y >= minY && y <= maxY ) {
+      int a = orient(x, y, ax, ay, bx, by);
+      int b = orient(x, y, bx, by, cx, cy);
+      if (a == 0 || b == 0 || a < 0 == b < 0) {
+        int c = orient(x, y, cx, cy, ax, ay);
+        return c == 0 || (c < 0 == (b < 0 || a < 0));
+      }
+      return false;
+    } else {
+      return false;
+    }
   }
 
   /** Brute force compute if a point is in the polygon by traversing entire triangulation
@@ -770,6 +792,8 @@
     private Node nextZ;
     // triangle center
     private boolean isSteiner = false;
+    // if the edge from this node to the next node is part of the polygon edges
+    private boolean nextEdgeFromPolygon;
 
     protected Node(final Polygon polygon, final int index, final int vertexIndex) {
       this.idx = index;
@@ -782,6 +806,7 @@
       this.next = null;
       this.previousZ = null;
       this.nextZ = null;
+      this.nextEdgeFromPolygon = true;
     }
 
     /** simple deep copy constructor */
@@ -797,6 +822,7 @@
       this.previousZ = other.previousZ;
       this.nextZ = other.nextZ;
       this.isSteiner = other.isSteiner;
+      this.nextEdgeFromPolygon = other.nextEdgeFromPolygon;
     }
 
     /** get the x value */
@@ -838,9 +864,11 @@
   /** Triangle in the tessellated mesh */
   public final static class Triangle {
     Node[] vertex;
+    boolean[] edgeFromPolygon;
 
-    protected Triangle(Node a, Node b, Node c) {
+    protected Triangle(Node a, boolean abFromPolygon, Node b, boolean bcFromPolygon, Node c, boolean caFromPolygon) {
       this.vertex = new Node[] {a, b, c};
+      edgeFromPolygon = new boolean[] {abFromPolygon, bcFromPolygon, caFromPolygon};
     }
 
     /** get quantized x value for the given vertex */
@@ -863,6 +891,11 @@
       return this.vertex[vertex].getLon();
     }
 
+    /** get if edge is shared with the polygon for the given edge */
+    public boolean fromPolygon(int vertex) {
+      return edgeFromPolygon[vertex];
+    }
+
     /** utility method to compute whether the point is in the triangle */
     protected boolean containsPoint(double lat, double lon) {
       return pointInTriangle(lon, lat,
@@ -873,9 +906,9 @@
 
     /** pretty print the triangle vertices */
     public String toString() {
-      String result = vertex[0].x + ", " + vertex[0].y + " " +
-                      vertex[1].x + ", " + vertex[1].y + " " +
-                      vertex[2].x + ", " + vertex[2].y;
+      String result = vertex[0].x + ", " + vertex[0].y + " [" + edgeFromPolygon[0] + "] " +
+                      vertex[1].x + ", " + vertex[1].y + " [" + edgeFromPolygon[1] + "] " +
+                      vertex[2].x + ", " + vertex[2].y + " [" + edgeFromPolygon[2] + "]";
       return result;
     }
   }
Index: lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonShape.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonShape.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonShape.java	(date 1547734852000)
@@ -16,8 +16,6 @@
  */
 package org.apache.lucene.document;
 
-import java.util.Arrays;
-
 import com.carrotsearch.randomizedtesting.generators.RandomNumbers;
 import org.apache.lucene.document.LatLonShape.QueryRelation;
 import org.apache.lucene.geo.GeoEncodingUtils;
@@ -137,6 +135,49 @@
     q = newRectQuery(FIELDNAME, p.minLat-1d, p.minLat+1, p.minLon-1d, p.minLon+1d);
     assertEquals(0, searcher.count(q));
 
+    IOUtils.close(reader, dir);
+  }
+
+  public void testBasicContains() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);
+
+    // add a random polygon document
+    double[] polyLats = new double[] {-10, -10, 10, 10, -10};
+    double[] polyLons = new double[] {-10, 10, 10, -10, -10};
+    Polygon p = new Polygon(polyLats, polyLons);
+    Document document = new Document();
+    addPolygonsToDoc(FIELDNAME, document, p);
+    writer.addDocument(document);
+
+    // add a line document
+    document = new Document();
+    // add a line string
+    double lats[] = new double[p.numPoints() - 1];
+    double lons[] = new double[p.numPoints() - 1];
+    for (int i = 0; i < lats.length; ++i) {
+      lats[i] = p.getPolyLat(i);
+      lons[i] = p.getPolyLon(i);
+    }
+    Line l = new Line(lats, lons);
+    addLineToDoc(FIELDNAME, document, l);
+    writer.addDocument(document);
+
+    ////// search /////
+    // search a Polygon
+    IndexReader reader = writer.getReader();
+    writer.close();
+    IndexSearcher searcher = newSearcher(reader);
+    polyLats = new double[] {-5, -5, 5, 5, -5};
+    polyLons = new double[] {-5, 5, 5, -5, -5};
+    Polygon query =  new Polygon(polyLats, polyLons);
+    Query q = LatLonShape.newPolygonQuery(FIELDNAME, QueryRelation.CONTAINS, query);
+    assertEquals(1, searcher.count(q));
+
+    // search a bounding box
+    searcher = newSearcher(reader);
+    q = new LatLonShapeBoundingBoxQuery(FIELDNAME, QueryRelation.CONTAINS,0, 0, 0, 0);
+    assertEquals(1, searcher.count(q));
     IOUtils.close(reader, dir);
   }
 
@@ -226,12 +267,13 @@
     Tessellator.Triangle t = Tessellator.tessellate(poly).get(0);
 
     byte[] encoded = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(encoded, encodeLatitude(t.getLat(0)), encodeLongitude(t.getLon(0)),
-        encodeLatitude(t.getLat(1)), encodeLongitude(t.getLon(1)), encodeLatitude(t.getLat(2)), encodeLongitude(t.getLon(2)));
-    int[] decoded = new int[6];
+    LatLonShape.encodeTriangle(encoded, encodeLatitude(t.getLat(0)), encodeLongitude(t.getLon(0)), t.fromPolygon(0),
+        encodeLatitude(t.getLat(1)), encodeLongitude(t.getLon(1)), t.fromPolygon(1),
+        encodeLatitude(t.getLat(2)), encodeLongitude(t.getLon(2)), t.fromPolygon(2));
+    LatLonShape.Triangle decoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(encoded, decoded);
 
-    int expected =rectangle2D.intersectsTriangle(decoded[1], decoded[0], decoded[3], decoded[2], decoded[5], decoded[4]) ? 0 : 1;
+    int expected =rectangle2D.intersectsTriangle(decoded.aX, decoded.aY, decoded.bX, decoded.bY, decoded.cX, decoded.cY) ? 0 : 1;
 
     Document document = new Document();
     addPolygonsToDoc(FIELDNAME, document, poly);
@@ -287,15 +329,15 @@
     int clonEnc = GeoEncodingUtils.encodeLongitude(clon);
     verifyEncodingPermutations(alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, true, blatEnc, blonEnc, true, clatEnc, clonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == blatEnc);
-    assertTrue(encoded[3] == blonEnc);
-    assertTrue(encoded[4] == clatEnc);
-    assertTrue(encoded[5] == clonEnc);
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, blatEnc);
+    assertEquals(encoded.bX, blonEnc);
+    assertEquals(encoded.cY, clatEnc);
+    assertEquals(encoded.cX, clonEnc);
   }
 
   //One shared point with MBR -> MinLat, MaxLon
@@ -314,15 +356,15 @@
     int clonEnc = GeoEncodingUtils.encodeLongitude(clon);
     verifyEncodingPermutations(alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, true, blatEnc, blonEnc, true, clatEnc, clonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == blatEnc);
-    assertTrue(encoded[3] == blonEnc);
-    assertTrue(encoded[4] == clatEnc);
-    assertTrue(encoded[5] == clonEnc);
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, blatEnc);
+    assertEquals(encoded.bX, blonEnc);
+    assertEquals(encoded.cY, clatEnc);
+    assertEquals(encoded.cX, clonEnc);
   }
 
   //One shared point with MBR -> MaxLat, MaxLon
@@ -341,15 +383,15 @@
     int clonEnc = GeoEncodingUtils.encodeLongitude(blon);
     verifyEncodingPermutations(alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, true, blatEnc, blonEnc, true, clatEnc, clonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == blatEnc);
-    assertTrue(encoded[3] == blonEnc);
-    assertTrue(encoded[4] == clatEnc);
-    assertTrue(encoded[5] == clonEnc);
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, blatEnc);
+    assertEquals(encoded.bX, blonEnc);
+    assertEquals(encoded.cY, clatEnc);
+    assertEquals(encoded.cX, clonEnc);
   }
 
   //One shared point with MBR -> MaxLat, MinLon
@@ -368,15 +410,15 @@
     int clonEnc = GeoEncodingUtils.encodeLongitude(blon);
     verifyEncodingPermutations(alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, true, blatEnc, blonEnc, true, clatEnc, clonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == blatEnc);
-    assertTrue(encoded[3] == blonEnc);
-    assertTrue(encoded[4] == clatEnc);
-    assertTrue(encoded[5] == clonEnc);
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, blatEnc);
+    assertEquals(encoded.bX, blonEnc);
+    assertEquals(encoded.cY, clatEnc);
+    assertEquals(encoded.cX, clonEnc);
   }
 
   //Two shared point with MBR -> [MinLat, MinLon], [MaxLat, MaxLon], third point below
@@ -395,15 +437,15 @@
     int clonEnc = GeoEncodingUtils.encodeLongitude(clon);
     verifyEncodingPermutations(alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, true, blatEnc, blonEnc, true, clatEnc, clonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == blatEnc);
-    assertTrue(encoded[3] == blonEnc);
-    assertTrue(encoded[4] == clatEnc);
-    assertTrue(encoded[5] == clonEnc);
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, blatEnc);
+    assertEquals(encoded.bX, blonEnc);
+    assertEquals(encoded.cY, clatEnc);
+    assertEquals(encoded.cX, clonEnc);
   }
 
   //Two shared point with MBR -> [MinLat, MinLon], [MaxLat, MaxLon], third point above
@@ -422,15 +464,15 @@
     int clonEnc = GeoEncodingUtils.encodeLongitude(clon);
     verifyEncodingPermutations(alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, true, blatEnc, blonEnc, true, clatEnc, clonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == blatEnc);
-    assertTrue(encoded[3] == blonEnc);
-    assertTrue(encoded[4] == clatEnc);
-    assertTrue(encoded[5] == clonEnc);
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, blatEnc);
+    assertEquals(encoded.bX, blonEnc);
+    assertEquals(encoded.cY, clatEnc);
+    assertEquals(encoded.cX, clonEnc);
   }
 
   //Two shared point with MBR -> [MinLat, MaxLon], [MaxLat, MinLon], third point below
@@ -449,15 +491,15 @@
     int clonEnc = GeoEncodingUtils.encodeLongitude(clon);
     verifyEncodingPermutations(alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, true, blatEnc, blonEnc, true, clatEnc, clonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == blatEnc);
-    assertTrue(encoded[3] == blonEnc);
-    assertTrue(encoded[4] == clatEnc);
-    assertTrue(encoded[5] == clonEnc);
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, blatEnc);
+    assertEquals(encoded.bX, blonEnc);
+    assertEquals(encoded.cY, clatEnc);
+    assertEquals(encoded.cX, clonEnc);
   }
 
   //Two shared point with MBR -> [MinLat, MaxLon], [MaxLat, MinLon], third point above
@@ -476,15 +518,15 @@
     int clonEnc = GeoEncodingUtils.encodeLongitude(clon);
     verifyEncodingPermutations(alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, true, blatEnc, blonEnc, true, clatEnc, clonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == blatEnc);
-    assertTrue(encoded[3] == blonEnc);
-    assertTrue(encoded[4] == clatEnc);
-    assertTrue(encoded[5] == clonEnc);
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, blatEnc);
+    assertEquals(encoded.bX, blonEnc);
+    assertEquals(encoded.cY, clatEnc);
+    assertEquals(encoded.cX, clonEnc);
   }
 
   //all points shared with MBR
@@ -503,15 +545,15 @@
     int clonEnc = GeoEncodingUtils.encodeLongitude(clon);
     verifyEncodingPermutations(alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, true, blatEnc, blonEnc, true, clatEnc, clonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == blatEnc);
-    assertTrue(encoded[3] == blonEnc);
-    assertTrue(encoded[4] == clatEnc);
-    assertTrue(encoded[5] == clonEnc);
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, blatEnc);
+    assertEquals(encoded.bX, blonEnc);
+    assertEquals(encoded.cY, clatEnc);
+    assertEquals(encoded.cX, clonEnc);
   }
 
   //all points shared with MBR
@@ -529,15 +571,15 @@
     int clatEnc = GeoEncodingUtils.encodeLatitude(clat);
     int clonEnc = GeoEncodingUtils.encodeLongitude(clon);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, true, blatEnc, blonEnc, true, clatEnc, clonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == blatEnc);
-    assertTrue(encoded[3] == blonEnc);
-    assertTrue(encoded[4] == clatEnc);
-    assertTrue(encoded[5] == clonEnc);
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, blatEnc);
+    assertEquals(encoded.bX, blonEnc);
+    assertEquals(encoded.cY, clatEnc);
+    assertEquals(encoded.cX, clonEnc);
   }
 
   //[a,b,c] == [c,a,b] == [b,c,a] == [c,b,a] == [b,a,c] == [a,c,b]
@@ -546,34 +588,34 @@
     assertTrue(GeoUtils.orient(alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc) != 0);
     byte[] b = new byte[7 * LatLonShape.BYTES];
     //[a,b,c]
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
-    int[] encodedABC = new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, true, blatEnc, blonEnc, true, clatEnc, clonEnc, false);
+    LatLonShape.Triangle encodedABC = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encodedABC);
     //[c,a,b]
-    LatLonShape.encodeTriangle(b, clatEnc, clonEnc, alatEnc, alonEnc, blatEnc, blonEnc);
-    int[] encodedCAB = new int[6];
+    LatLonShape.encodeTriangle(b, clatEnc, clonEnc, false, alatEnc, alonEnc, true, blatEnc, blonEnc, true);
+    LatLonShape.Triangle encodedCAB = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encodedCAB);
-    assertTrue(Arrays.equals(encodedABC, encodedCAB));
+    assertEquals(encodedABC, encodedCAB);
     //[b,c,a]
-    LatLonShape.encodeTriangle(b, blatEnc, blonEnc, clatEnc, clonEnc, alatEnc, alonEnc);
-    int[] encodedBCA = new int[6];
+    LatLonShape.encodeTriangle(b, blatEnc, blonEnc, true, clatEnc, clonEnc, false, alatEnc, alonEnc, true);
+    LatLonShape.Triangle encodedBCA = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encodedBCA);
-    assertTrue(Arrays.equals(encodedABC, encodedBCA));
+    assertEquals(encodedABC, encodedBCA);
     //[c,b,a]
-    LatLonShape.encodeTriangle(b, clatEnc, clonEnc, blatEnc, blonEnc, alatEnc, alonEnc);
-    int[] encodedCBA= new int[6];
+    LatLonShape.encodeTriangle(b, clatEnc, clonEnc, true, blatEnc, blonEnc, true, alatEnc, alonEnc, false);
+    LatLonShape.Triangle encodedCBA= new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encodedCBA);
-    assertTrue(Arrays.equals(encodedABC, encodedCBA));
+    assertEquals(encodedABC, encodedCBA);
     //[b,a,c]
-    LatLonShape.encodeTriangle(b, blatEnc, blonEnc, alatEnc, alonEnc, clatEnc, clonEnc);
-    int[] encodedBAC= new int[6];
+    LatLonShape.encodeTriangle(b, blatEnc, blonEnc, true, alatEnc, alonEnc, false, clatEnc, clonEnc, true);
+    LatLonShape.Triangle encodedBAC= new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encodedBAC);
-    assertTrue(Arrays.equals(encodedABC, encodedBAC));
+    assertEquals(encodedABC, encodedBAC);
     //[a,c,b]
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, clatEnc, clonEnc, blatEnc, blonEnc);
-    int[] encodedACB= new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, false, clatEnc, clonEnc, true, blatEnc, blonEnc, true);
+    LatLonShape.Triangle encodedACB= new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encodedACB);
-    assertTrue(Arrays.equals(encodedABC, encodedACB));
+    assertEquals(encodedABC, encodedACB);
   }
 
   public void testPointEncoding() {
@@ -582,11 +624,15 @@
     int latEnc = GeoEncodingUtils.encodeLatitude(lat);
     int lonEnc = GeoEncodingUtils.encodeLongitude(lon);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, latEnc, lonEnc, latEnc, lonEnc, latEnc, lonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, latEnc, lonEnc, true, latEnc, lonEnc, true, latEnc, lonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == latEnc && encoded[2] == latEnc && encoded[4] == latEnc);
-    assertTrue(encoded[1] == lonEnc && encoded[3] == lonEnc && encoded[5] == lonEnc);
+    assertEquals(encoded.aY, latEnc);
+    assertEquals(encoded.aX, lonEnc);
+    assertEquals(encoded.bY, latEnc);
+    assertEquals(encoded.bX, lonEnc);
+    assertEquals(encoded.cY, latEnc);
+    assertEquals(encoded.cX, lonEnc);
   }
 
   public void testLineEncodingSameLat() {
@@ -597,33 +643,31 @@
     int alonEnc = GeoEncodingUtils.encodeLongitude(alon);
     int blonEnc = GeoEncodingUtils.encodeLongitude(blon);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, latEnc, alonEnc, latEnc, blonEnc, latEnc, alonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, latEnc, alonEnc, true, latEnc, blonEnc, true, latEnc, alonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == latEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == latEnc);
-    assertTrue(encoded[3] == blonEnc);
-    assertTrue(encoded[4] == latEnc);
-    assertTrue(encoded[5] == alonEnc);
-    LatLonShape.encodeTriangle(b, latEnc, alonEnc, latEnc, alonEnc, latEnc, blonEnc);
-    encoded = new int[6];
+    assertEquals(encoded.aY, latEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, latEnc);
+    assertEquals(encoded.bX, blonEnc);
+    assertEquals(encoded.cY, latEnc);
+    assertEquals(encoded.cX, alonEnc);
+    LatLonShape.encodeTriangle(b, latEnc, alonEnc, true, latEnc, alonEnc, true, latEnc, blonEnc, true);
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == latEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == latEnc);
-    assertTrue(encoded[3] == alonEnc);
-    assertTrue(encoded[4] == latEnc);
-    assertTrue(encoded[5] == blonEnc);
-    LatLonShape.encodeTriangle(b, latEnc, blonEnc, latEnc, alonEnc, latEnc, alonEnc);
-    encoded = new int[6];
+    assertEquals(encoded.aY, latEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, latEnc);
+    assertEquals(encoded.bX, alonEnc);
+    assertEquals(encoded.cY, latEnc);
+    assertEquals(encoded.cX, blonEnc);
+    LatLonShape.encodeTriangle(b, latEnc, blonEnc, true, latEnc, alonEnc, true, latEnc, alonEnc, true);
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == latEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == latEnc);
-    assertTrue(encoded[3] == blonEnc);
-    assertTrue(encoded[4] == latEnc);
-    assertTrue(encoded[5] == alonEnc);
+    assertEquals(encoded.aY, latEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, latEnc);
+    assertEquals(encoded.bX, blonEnc);
+    assertEquals(encoded.cY, latEnc);
+    assertEquals(encoded.cX, alonEnc);
   }
 
   public void testLineEncodingSameLon() {
@@ -634,33 +678,31 @@
     int blatEnc = GeoEncodingUtils.encodeLatitude(blat);
     int lonEnc = GeoEncodingUtils.encodeLongitude(lon);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, alatEnc, lonEnc, blatEnc, lonEnc, alatEnc, lonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, lonEnc, true, blatEnc, lonEnc, true, alatEnc, lonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == lonEnc);
-    assertTrue(encoded[2] == blatEnc);
-    assertTrue(encoded[3] == lonEnc);
-    assertTrue(encoded[4] == alatEnc);
-    assertTrue(encoded[5] == lonEnc);
-    LatLonShape.encodeTriangle(b, alatEnc, lonEnc, alatEnc, lonEnc, blatEnc, lonEnc);
-    encoded = new int[6];
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, lonEnc);
+    assertEquals(encoded.bY, blatEnc);
+    assertEquals(encoded.bX, lonEnc);
+    assertEquals(encoded.cY, alatEnc);
+    assertEquals(encoded.cX, lonEnc);
+    LatLonShape.encodeTriangle(b, alatEnc, lonEnc, true, alatEnc, lonEnc, true, blatEnc, lonEnc, true);
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == lonEnc);
-    assertTrue(encoded[2] == alatEnc);
-    assertTrue(encoded[3] == lonEnc);
-    assertTrue(encoded[4] == blatEnc);
-    assertTrue(encoded[5] == lonEnc);
-    LatLonShape.encodeTriangle(b, blatEnc, lonEnc, alatEnc, lonEnc, alatEnc, lonEnc);
-    encoded = new int[6];
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, lonEnc);
+    assertEquals(encoded.bY, alatEnc);
+    assertEquals(encoded.bX, lonEnc);
+    assertEquals(encoded.cY, blatEnc);
+    assertEquals(encoded.cX, lonEnc);
+    LatLonShape.encodeTriangle(b, blatEnc, lonEnc, true, alatEnc, lonEnc, true, alatEnc, lonEnc, true);
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == lonEnc);
-    assertTrue(encoded[2] == blatEnc);
-    assertTrue(encoded[3] == lonEnc);
-    assertTrue(encoded[4] == alatEnc);
-    assertTrue(encoded[5] == lonEnc);
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, lonEnc);
+    assertEquals(encoded.bY, blatEnc);
+    assertEquals(encoded.bX, lonEnc);
+    assertEquals(encoded.cY, alatEnc);
+    assertEquals(encoded.cX, lonEnc);
   }
 
   public void testLineEncoding() {
@@ -673,33 +715,31 @@
     int alonEnc = GeoEncodingUtils.encodeLongitude(alon);
     int blonEnc = GeoEncodingUtils.encodeLongitude(blon);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, blatEnc, blonEnc, alatEnc, alonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, true, blatEnc, blonEnc, true, alatEnc, alonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == blatEnc);
-    assertTrue(encoded[3] == blonEnc);
-    assertTrue(encoded[4] == alatEnc);
-    assertTrue(encoded[5] == alonEnc);
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, alatEnc, alonEnc, blatEnc, blonEnc);
-    encoded = new int[6];
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, blatEnc);
+    assertEquals(encoded.bX, blonEnc);
+    assertEquals(encoded.cY, alatEnc);
+    assertEquals(encoded.cX, alonEnc);
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, true, alatEnc, alonEnc, true, blatEnc, blonEnc, true);
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == alatEnc);
-    assertTrue(encoded[3] == alonEnc);
-    assertTrue(encoded[4] == blatEnc);
-    assertTrue(encoded[5] == blonEnc);
-    LatLonShape.encodeTriangle(b, blatEnc, blonEnc, alatEnc, alonEnc, alatEnc, alonEnc);
-    encoded = new int[6];
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, alatEnc);
+    assertEquals(encoded.bX, alonEnc);
+    assertEquals(encoded.cY, blatEnc);
+    assertEquals(encoded.cX, blonEnc);
+    LatLonShape.encodeTriangle(b, blatEnc, blonEnc, true, alatEnc, alonEnc, true, alatEnc, alonEnc, true);
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == alatEnc);
-    assertTrue(encoded[1] == alonEnc);
-    assertTrue(encoded[2] == blatEnc);
-    assertTrue(encoded[3] == blonEnc);
-    assertTrue(encoded[4] == alatEnc);
-    assertTrue(encoded[5] == alonEnc);
+    assertEquals(encoded.aY, alatEnc);
+    assertEquals(encoded.aX, alonEnc);
+    assertEquals(encoded.bY, blatEnc);
+    assertEquals(encoded.bX, blonEnc);
+    assertEquals(encoded.cY, alatEnc);
+    assertEquals(encoded.cX, alonEnc);
   }
 
   public void testRandomPointEncoding() {
@@ -736,15 +776,15 @@
 
     //quantize the triangle
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, original[0], original[1], original[2], original[3], original[4], original[5]);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, original[0], original[1], true, original[2], original[3], true, original[4], original[5], true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    double[] encodedQuantize = new double[] {GeoEncodingUtils.decodeLatitude(encoded[0]),
-        GeoEncodingUtils.decodeLongitude(encoded[1]),
-        GeoEncodingUtils.decodeLatitude(encoded[2]),
-        GeoEncodingUtils.decodeLongitude(encoded[3]),
-        GeoEncodingUtils.decodeLatitude(encoded[4]),
-        GeoEncodingUtils.decodeLongitude(encoded[5])};
+    double[] encodedQuantize = new double[] {GeoEncodingUtils.decodeLatitude(encoded.aY),
+        GeoEncodingUtils.decodeLongitude(encoded.aX),
+        GeoEncodingUtils.decodeLatitude(encoded.bY),
+        GeoEncodingUtils.decodeLongitude(encoded.bX),
+        GeoEncodingUtils.decodeLatitude(encoded.cY),
+        GeoEncodingUtils.decodeLongitude(encoded.cX)};
 
     int orientation = GeoUtils.orient(original[1], original[0], original[3], original[2], original[5], original[4]);
     //quantize original
@@ -771,7 +811,7 @@
       Polygon2D polygon2D = Polygon2D.create(polygon);
       PointValues.Relation originalRelation = polygon2D.relateTriangle(originalQuantize[1], originalQuantize[0], originalQuantize[3], originalQuantize[2], originalQuantize[5], originalQuantize[4]);
       PointValues.Relation encodedRelation = polygon2D.relateTriangle(encodedQuantize[1], encodedQuantize[0], encodedQuantize[3], encodedQuantize[2], encodedQuantize[5], encodedQuantize[4]);
-      assertTrue(originalRelation == encodedRelation);
+      assertEquals(originalRelation, encodedRelation);
     }
   }
 
@@ -789,15 +829,15 @@
     int clatEnc = GeoEncodingUtils.encodeLatitude(clat);
     int clonEnc = GeoEncodingUtils.encodeLongitude(clon);
     byte[] b = new byte[7 * LatLonShape.BYTES];
-    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, blatEnc, blonEnc, clatEnc, clonEnc);
-    int[] encoded = new int[6];
+    LatLonShape.encodeTriangle(b, alatEnc, alonEnc, true, blatEnc, blonEnc, true, clatEnc, clonEnc, true);
+    LatLonShape.Triangle encoded = new LatLonShape.Triangle();
     LatLonShape.decodeTriangle(b, encoded);
-    assertTrue(encoded[0] == blatEnc);
-    assertTrue(encoded[1] == blonEnc);
-    assertTrue(encoded[2] == clatEnc);
-    assertTrue(encoded[3] == clonEnc);
-    assertTrue(encoded[4] == alatEnc);
-    assertTrue(encoded[5] == alonEnc);
+    assertEquals(encoded.aY, blatEnc);
+    assertEquals(encoded.aX, blonEnc);
+    assertEquals(encoded.bY, clatEnc);
+    assertEquals(encoded.bX, clonEnc);
+    assertEquals(encoded.cY, alatEnc);
+    assertEquals(encoded.cX, alonEnc);
   }
 
 }
Index: lucene/core/src/java/org/apache/lucene/geo/EdgeTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/core/src/java/org/apache/lucene/geo/EdgeTree.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/core/src/java/org/apache/lucene/geo/EdgeTree.java	(date 1547734852000)
@@ -22,7 +22,8 @@
 import org.apache.lucene.index.PointValues.Relation;
 import org.apache.lucene.util.ArrayUtil;
 
-import static org.apache.lucene.geo.GeoUtils.lineCrossesLine;
+import static org.apache.lucene.geo.GeoUtils.lineCrossessLine;
+import static org.apache.lucene.geo.GeoUtils.lineIntersectsLine;
 import static org.apache.lucene.geo.GeoUtils.orient;
 
 /**
@@ -101,6 +102,54 @@
     return Relation.CELL_OUTSIDE_QUERY;
   }
 
+  /**
+   *  Checks if the shape is within the provided triangle.
+   *
+   * @param ax longitude of point a of the triangle
+   * @param ay latitude of point a of the triangle
+   * @param ab if edge ab belongs to the original shape
+   * @param bx longitude of point b of the triangle
+   * @param by latitude of point b of the triangle
+   * @param bc if edge bc belongs to the original shape
+   * @param cx longitude of point c of the triangle
+   * @param cy latitude of point c of the triangle
+   * @param ca if edge ca belongs to the original shape
+   * @return
+   *  <ul>
+   *  <li> Boolean.True: If the shape is within the provided triangle or crosses only edges that do not belong
+   *  to the original shape.</li>
+   *  <li> Boolean.False: If the shape crosses an edge that belongs to the original shape.</li>
+   *  <li> null: If the shape is disjoint with the provided triangle.</li>
+   *  </ul>
+   */
+  public Boolean withinTriangle(double ax, double ay, boolean ab, double bx, double by, boolean bc, double cx, double cy, boolean ca) {
+    // compute bounding box of triangle
+    double minLat = StrictMath.min(StrictMath.min(ay, by), cy);
+    double minLon = StrictMath.min(StrictMath.min(ax, bx), cx);
+    double maxLat = StrictMath.max(StrictMath.max(ay, by), cy);
+    double maxLon = StrictMath.max(StrictMath.max(ax, bx), cx);
+
+    if (minLat <= maxY && minLon <= maxX) {
+      Boolean relation = internalWithinTriangle(ax, ay, ab, bx, by, bc, cx, cy, ca);
+      if (relation != null) {
+        return relation;
+      }
+      if (left != null) {
+        relation = left.withinTriangle(ax, ay, ab, bx, by, bc, cx, cy, ca);
+        if (relation != null) {
+          return relation;
+        }
+      }
+      if (right != null && ((splitX == false && maxLat >= this.minLat) || (splitX && maxLon >= this.minLon))) {
+        relation = right.withinTriangle(ax, ay, ab, bx, by, bc, cx, cy, ca);
+        if (relation != null) {
+          return relation;
+        }
+      }
+    }
+    return null;
+  }
+
   /** Returns relation to the provided rectangle */
   public Relation relate(double minLat, double maxLat, double minLon, double maxLon) {
     if (minLat <= maxY && minLon <= maxX) {
@@ -147,12 +196,91 @@
     }
 
     // we cross
-    if (tree.crossesTriangle(ax, ay, bx, by, cx, cy)) {
+    if (tree.intersectsTriangle(ax, ay, bx, by, cx, cy)) {
+      return Relation.CELL_CROSSES_QUERY;
+    }
+    if (pointInTriangle(tree.lon1, tree.lat1, ax, ay, bx, by, cx, cy) == true) {
       return Relation.CELL_CROSSES_QUERY;
     }
     return Relation.CELL_OUTSIDE_QUERY;
   }
 
+  private Boolean internalWithinTriangle(double ax, double ay, boolean ab, double bx, double by, boolean bc, double cx, double cy, boolean ca) {
+    // compute bounding box of triangle
+    double minLat = StrictMath.min(StrictMath.min(ay, by), cy);
+    double minLon = StrictMath.min(StrictMath.min(ax, bx), cx);
+    double maxLat = StrictMath.max(StrictMath.max(ay, by), cy);
+    double maxLon = StrictMath.max(StrictMath.max(ax, bx), cx);
+
+    //disjoint then we return null
+    if (maxLon < this.minLon || minLon > this.maxLon || maxLat < this.minLat || minLat > this.maxLat) {
+      return null;
+    }
+
+    Relation shapeRelation = componentRelateTriangle(ax, ay, bx, by, cx, cy);
+    if (shapeRelation == Relation.CELL_OUTSIDE_QUERY) {
+      return null;
+    } else if (shapeRelation == Relation.CELL_INSIDE_QUERY) {
+      return false;
+    }
+
+    boolean inside = false;
+
+    // we cross
+    if (tree.crossesEdge(ax, ay, bx, by)) {
+      if (ab == true) {
+        return false;
+      } else {
+        inside = true;
+      }
+    }
+    if (tree.crossesEdge(bx, by, cx, cy)) {
+      if (bc == true) {
+        return false;
+      } else {
+        inside = true;
+      }
+    }
+    if (tree.crossesEdge(cx, cy, ax, ay)) {
+      if (ca == true) {
+        return false;
+      } else {
+        inside = true;
+      }
+    }
+    if (inside) {
+      return true;
+    }
+    if (minLon > this.minLon || maxLon < this.maxLon || minLat > this.minLat || maxLat < this.maxLat) {
+      return null;
+    }
+
+    if (inside || pointInTriangle(tree.lon1, tree.lat1, ax, ay, bx, by, cx, cy) == true) {
+      return true;
+    }
+    return null;
+  }
+
+  /** This should be moved when LatLonShape is moved from sandbox!
+   * compute whether the given x, y point is in a triangle; uses the winding order method */
+  private static boolean pointInTriangle (double x, double y, double ax, double ay, double bx, double by, double cx, double cy) {
+    double minX = StrictMath.min(ax, StrictMath.min(bx, cx));
+    double minY = StrictMath.min(ay, StrictMath.min(by, cy));
+    double maxX = StrictMath.max(ax, StrictMath.max(bx, cx));
+    double maxY = StrictMath.max(ay, StrictMath.max(by, cy));
+    if (x >= minX && x <= maxX && y >= minY && y <= maxY ) {
+      int a = orient(x, y, ax, ay, bx, by);
+      int b = orient(x, y, bx, by, cx, cy);
+      if (a == 0 || b == 0 || a < 0 == b < 0) {
+        int c = orient(x, y, cx, cy, ax, ay);
+        return c == 0 || (c < 0 == (b < 0 || a < 0));
+      }
+      return false;
+    } else {
+      return false;
+    }
+  }
+
 
   /** Returns relation to the provided rectangle for this component */
   protected Relation internalComponentRelate(double minLat, double maxLat, double minLon, double maxLon) {
@@ -171,7 +299,7 @@
     }
 
     // we cross
-    if (tree.crosses(minLat, maxLat, minLon, maxLon)) {
+    if (tree.intersects(minLat, maxLat, minLon, maxLon)) {
       return Relation.CELL_CROSSES_QUERY;
     }
 
@@ -252,7 +380,7 @@
     }
 
     /** Returns true if the triangle crosses any edge in this edge subtree */
-    boolean crossesTriangle(double ax, double ay, double bx, double by, double cx, double cy) {
+    boolean intersectsTriangle(double ax, double ay, double bx, double by, double cx, double cy) {
       // compute bounding box of triangle
       double minLat = StrictMath.min(StrictMath.min(ay, by), cy);
       double minLon = StrictMath.min(StrictMath.min(ax, bx), cx);
@@ -275,31 +403,75 @@
         if (outside == false) {
           // does triangle's first edge intersect polyline?
           // ax, ay -> bx, by
-          if (lineCrossesLine(ax, ay, bx, by, dx, dy, ex, ey)) {
+          if (lineIntersectsLine(ax, ay, bx, by, dx, dy, ex, ey)) {
             return true;
           }
 
           // does triangle's second edge intersect polyline?
           // bx, by -> cx, cy
-          if (lineCrossesLine(bx, by, cx, cy, dx, dy, ex, ey)) {
+          if (lineIntersectsLine(bx, by, cx, cy, dx, dy, ex, ey)) {
             return true;
           }
 
           // does triangle's third edge intersect polyline?
           // cx, cy -> ax, ay
-          if (lineCrossesLine(cx, cy, ax, ay, dx, dy, ex, ey)) {
+          if (lineIntersectsLine(cx, cy, ax, ay, dx, dy, ex, ey)) {
             return true;
           }
         }
 
         if (left != null) {
-          if (left.crossesTriangle(ax, ay, bx, by, cx, cy)) {
+          if (left.intersectsTriangle(ax, ay, bx, by, cx, cy)) {
             return true;
           }
         }
 
         if (right != null && maxLat >= low) {
-          if (right.crossesTriangle(ax, ay, bx, by, cx, cy)) {
+          if (right.intersectsTriangle(ax, ay, bx, by, cx, cy)) {
+            return true;
+          }
+        }
+      }
+      return false;
+    }
+
+    /** Returns true if the triangle crosses any edge in this edge subtree */
+    boolean crossesEdge(double ax, double ay, double bx, double by) {
+      // compute bounding box of triangle
+      double minLat = StrictMath.min(ay, by);
+      double minLon = StrictMath.min(ax, bx);
+      double maxLat = StrictMath.max(ay, by);
+      double maxLon = StrictMath.max(ax, bx);
+
+      if (minLat <= max) {
+        double dy = lat1;
+        double ey = lat2;
+        double dx = lon1;
+        double ex = lon2;
+
+        // optimization: see if the rectangle is outside of the "bounding box" of the polyline at all
+        // if not, don't waste our time trying more complicated stuff
+        boolean outside = (dy < minLat && ey < minLat) ||
+            (dy > maxLat && ey > maxLat) ||
+            (dx < minLon && ex < minLon) ||
+            (dx > maxLon && ex > maxLon);
+
+        if (outside == false) {
+          // does triangle's first edge intersect polyline?
+          // ax, ay -> bx, by
+          if (lineCrossessLine(ax, ay, bx, by, dx, dy, ex, ey)) {
+            return true;
+          }
+        }
+
+        if (left != null) {
+          if (left.crossesEdge(ax, ay, bx, by)) {
+            return true;
+          }
+        }
+
+        if (right != null && maxLat >= low) {
+          if (right.crossesEdge(ax, ay, bx, by)) {
             return true;
           }
         }
@@ -308,7 +480,7 @@
     }
 
     /** Returns true if the box crosses any edge in this edge subtree */
-    boolean crosses(double minLat, double maxLat, double minLon, double maxLon) {
+    boolean intersects(double minLat, double maxLat, double minLon, double maxLon) {
       // we just have to cross one edge to answer the question, so we descend the tree and return when we do.
       if (minLat <= max) {
         // we compute line intersections of every polygon edge with every box line.
@@ -364,13 +536,13 @@
         }
 
         if (left != null) {
-          if (left.crosses(minLat, maxLat, minLon, maxLon)) {
+          if (left.intersects(minLat, maxLat, minLon, maxLon)) {
             return true;
           }
         }
 
         if (right != null && maxLat >= low) {
-          if (right.crosses(minLat, maxLat, minLon, maxLon)) {
+          if (right.intersects(minLat, maxLat, minLon, maxLon)) {
             return true;
           }
         }
Index: lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapeLineQuery.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapeLineQuery.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapeLineQuery.java	(date 1547734852000)
@@ -84,15 +84,15 @@
   }
 
   @Override
-  protected boolean queryMatches(byte[] t, int[] scratchTriangle) {
+  protected boolean queryMatches(byte[] t, LatLonShape.Triangle scratchTriangle) {
     LatLonShape.decodeTriangle(t, scratchTriangle);
 
-    double alat = GeoEncodingUtils.decodeLatitude(scratchTriangle[0]);
-    double alon = GeoEncodingUtils.decodeLongitude(scratchTriangle[1]);
-    double blat = GeoEncodingUtils.decodeLatitude(scratchTriangle[2]);
-    double blon = GeoEncodingUtils.decodeLongitude(scratchTriangle[3]);
-    double clat = GeoEncodingUtils.decodeLatitude(scratchTriangle[4]);
-    double clon = GeoEncodingUtils.decodeLongitude(scratchTriangle[5]);
+    double alat = GeoEncodingUtils.decodeLatitude(scratchTriangle.aY);
+    double alon = GeoEncodingUtils.decodeLongitude(scratchTriangle.aX);
+    double blat = GeoEncodingUtils.decodeLatitude(scratchTriangle.bY);
+    double blon = GeoEncodingUtils.decodeLongitude(scratchTriangle.bX);
+    double clat = GeoEncodingUtils.decodeLatitude(scratchTriangle.cY);
+    double clon = GeoEncodingUtils.decodeLongitude(scratchTriangle.cX);
 
     if (queryRelation == LatLonShape.QueryRelation.WITHIN) {
       return line2D.relateTriangle(alon, alat, blon, blat, clon, clat) == Relation.CELL_INSIDE_QUERY;
@@ -101,6 +101,20 @@
     return line2D.relateTriangle(alon, alat, blon, blat, clon, clat) != Relation.CELL_OUTSIDE_QUERY;
   }
 
+  @Override
+  protected Boolean queryWithin(byte[] t, LatLonShape.Triangle scratchTriangle) {
+    LatLonShape.decodeTriangle(t, scratchTriangle);
+
+    double alat = GeoEncodingUtils.decodeLatitude(scratchTriangle.aY);
+    double alon = GeoEncodingUtils.decodeLongitude(scratchTriangle.aX);
+    double blat = GeoEncodingUtils.decodeLatitude(scratchTriangle.bY);
+    double blon = GeoEncodingUtils.decodeLongitude(scratchTriangle.bX);
+    double clat = GeoEncodingUtils.decodeLatitude(scratchTriangle.cY);
+    double clon = GeoEncodingUtils.decodeLongitude(scratchTriangle.cX);
+
+    return line2D.withinTriangle(alon, alat, scratchTriangle.ab, blon, blat, scratchTriangle.bc, clon, clat, scratchTriangle.ca);
+  }
+
   @Override
   public String toString(String field) {
     final StringBuilder sb = new StringBuilder();
Index: lucene/sandbox/src/test/org/apache/lucene/geo/TestTessellator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/geo/TestTessellator.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/sandbox/src/test/org/apache/lucene/geo/TestTessellator.java	(date 1547734852000)
@@ -61,8 +61,11 @@
         "[[168.1652103335658, -29.3030088541673], [168.16605788758287, -29.446580625201833], [168.16556735186845, -29.303245228857072], [168.165381, -29.303246], [168.16537977124085, -29.303008170411644], [168.1652103335658, -29.3030088541673]], " +
         "[[168.02088551865063, -29.647294313012004], [168.02133932508806, -29.811843292379823], [168.02135614030843, -29.811843274349446], [168.021356, -29.811809], [168.02162340579383, -29.811807949652078], [168.02088551865063, -29.647294313012004]]]}";
     Polygon[] polygons =Polygon.fromGeoJSON(geoJson);
-    List<Tessellator.Triangle> result = Tessellator.tessellate(polygons[0]);
-    assertEquals(result.size(), 84);
+    List<Tessellator.Triangle> tessellation = Tessellator.tessellate(polygons[0]);
+    assertEquals(tessellation.size(), 84);
+    for (Tessellator.Triangle t : tessellation) {
+      checkTriangleEdgesFromPolygon(polygons[0], t);
+    }
   }
 
   public void testLUCENE8534() throws ParseException {
@@ -81,8 +84,11 @@
         "[[168.71121460687698,-31.795031659971823],[168.71136127361123,-31.79503081865431],[168.71038567290682,-31.657182838382653],[168.71121460687698,-31.795031659971823]]," +
         "[[167.81624041598312,-31.53023516975434],[167.81634270442586,-31.530235525706665],[167.81676369867318,-31.434841665952604],[167.81624041598312,-31.53023516975434]]]}";
     Polygon[] polygons =Polygon.fromGeoJSON(geoJson);
-    List<Tessellator.Triangle> result = Tessellator.tessellate(polygons[0]);
-    assertEquals(113, result.size());
+    List<Tessellator.Triangle> tessellation = Tessellator.tessellate(polygons[0]);
+    assertEquals(113, tessellation.size());
+    for (Tessellator.Triangle t : tessellation) {
+      checkTriangleEdgesFromPolygon(polygons[0], t);
+    }
   }
 
   public void testInvalidPolygon()  throws Exception {
@@ -94,14 +100,22 @@
   public void testLUCENE8550()  throws Exception {
     String wkt = "POLYGON((24.04725 59.942,24.04825 59.94125,24.04875 59.94125,24.04875 59.94175,24.048 59.9425,24.0475 59.94275,24.0465 59.94225,24.046 59.94225,24.04575 59.9425,24.04525 59.94225,24.04725 59.942))";
     Polygon polygon = (Polygon)SimpleWKTShapeParser.parse(wkt);
-    assertTrue(Tessellator.tessellate(polygon).size() == 8);
+    List<Tessellator.Triangle> tessellation = Tessellator.tessellate(polygon);
+    assertTrue(tessellation.size() == 8);
+    for (Tessellator.Triangle t : tessellation) {
+      checkTriangleEdgesFromPolygon(polygon, t);
+    }
   }
 
   public void testLUCENE8559()  throws Exception {
     String wkt = "POLYGON((-0.1348674 51.7458255,-0.1345884 51.7455067,-0.1329898 51.745314,-0.1326358 51.745314,-0.1324105 51.744404,-0.131981 51.7444423,-0.1312196 51.7445102,-0.1310908 51.7456794,-0.1319706 51.7460713,-0.1343095 51.7465828,-0.1348674 51.7458255)," +
         "(-0.1322388 51.7447959,-0.1322388 51.7454336,-0.1318633 51.7457126,-0.1313912 51.7456262,-0.1318985 51.7448032,-0.1322388 51.7447959))";
     Polygon polygon = (Polygon)SimpleWKTShapeParser.parse(wkt);
-    assertTrue(Tessellator.tessellate(polygon).size() > 0);
+    List<Tessellator.Triangle> tessellation = Tessellator.tessellate(polygon);
+    assertTrue(tessellation.size() > 0);
+    for (Tessellator.Triangle t : tessellation) {
+      checkTriangleEdgesFromPolygon(polygon, t);
+    }
   }
 
   public void testLUCENE8556()  throws Exception {
@@ -115,6 +129,109 @@
         "-111.5025 68.32375,-111.50275 68.3235,-111.504 68.32375,-111.50425 68.3235,-111.50525 68.32325,-111.5055 68.3235,-111.506 68.3235,-111.50625 68.32325,-111.5065 68.3225,-111.5075 68.3225,-111.50775 68.32275,-111.50825 68.32275," +
         "-111.5085 68.3225,-111.50875 68.3225,-111.509 68.32275,-111.5125 68.32275,-111.51325 68.32225,-111.4765 68.321))";
     Polygon polygon = (Polygon) SimpleWKTShapeParser.parse(wkt);
-    assertTrue(Tessellator.tessellate(polygon).size() > 0);
+    List<Tessellator.Triangle> tessellation = Tessellator.tessellate(polygon);
+    assertTrue(tessellation.size() > 0);
+    for (Tessellator.Triangle t : tessellation) {
+      checkTriangleEdgesFromPolygon(polygon, t);
+    }
+  }
+
+  public void testTriangle() throws Exception {
+    String wkt = "POLYGON((0 0, 1 0, 1 1, 0 0))";
+    Polygon polygon = (Polygon) SimpleWKTShapeParser.parse(wkt);
+    List<Tessellator.Triangle> tessellation = Tessellator.tessellate(polygon);
+    assertTrue(tessellation.size() == 1);
+    for (Tessellator.Triangle t : tessellation) {
+      checkTriangleEdgesFromPolygon(polygon, t);
+    }
+  }
+
+  public void testTriangleWithHole() throws Exception {
+    String wkt = "POLYGON((0 0, 1 0, 1 1, 0 0 ),(0.35 0.25, 0.85 0.75, 0.65 0.35, 0.35 0.25))";
+    Polygon polygon = (Polygon) SimpleWKTShapeParser.parse(wkt);
+    List<Tessellator.Triangle> tessellation = Tessellator.tessellate(polygon);
+    assertTrue(tessellation.size() == 6);
+    for (Tessellator.Triangle t : tessellation) {
+      checkTriangleEdgesFromPolygon(polygon, t);
+    }
+  }
+
+  public void testSquare() throws Exception {
+    String wkt = "POLYGON((0 0, 0 1, 1 1, 1 0, 0 0))";
+    Polygon polygon = (Polygon) SimpleWKTShapeParser.parse(wkt);
+    List<Tessellator.Triangle> tessellation = Tessellator.tessellate(polygon);
+    assertTrue(tessellation.size() == 2);
+    for (Tessellator.Triangle t : tessellation) {
+      checkTriangleEdgesFromPolygon(polygon, t);
+    }
+  }
+
+  public void testSquareWithHole() throws Exception {
+    String wkt = "POLYGON((0 0, 0 1, 1 1, 1 0, 0 0), (0.25 0.25, 0.25 0.75, 0.75 0.75, 0.75 0.25, 0.25 0.25))";
+    Polygon polygon = (Polygon) SimpleWKTShapeParser.parse(wkt);
+    List<Tessellator.Triangle> tessellation = Tessellator.tessellate(polygon);
+    assertTrue(tessellation.size() == 8);
+    for (Tessellator.Triangle t : tessellation) {
+      checkTriangleEdgesFromPolygon(polygon, t);
+    }
+  }
+
+  public void testEdgesFromPolygon() {
+    Polygon poly = GeoTestUtil.nextPolygon();
+    List<Tessellator.Triangle> tessellation = Tessellator.tessellate(poly);
+    assertTrue(tessellation.size() > 0);
+    for (Tessellator.Triangle t : tessellation) {
+      checkTriangleEdgesFromPolygon(poly, t);
+    }
+  }
+
+  public void testEdgesFromPolygonWithHoles() {
+    Polygon poly = GeoTestUtil.createRegularPolygon(0.0, 0.0, 1000000, 500);
+    Polygon inner = GeoTestUtil.createRegularPolygon(0.0, 0.0, 10000, 200);
+    poly = new Polygon(poly.getPolyLats(), poly.getPolyLons(), inner);
+    List<Tessellator.Triangle> tessellation = Tessellator.tessellate(poly);
+    assertTrue(tessellation.size() > 0);
+    for (Tessellator.Triangle t : tessellation) {
+      checkTriangleEdgesFromPolygon(poly, t);
+    }
+  }
+
+  public void testPolygonWithCoplanarPoints() {
+    Polygon poly = GeoTestUtil.createRegularPolygon(0.0, 0.0, 1000000, 50);
+    Polygon inner = new Polygon(new double[] {-1.0, -1.0, 0.5, 1.0, 1.0, 0.5, -1.0},
+        new double[]{1.0, -1.0, -0.5, -1.0, 1.0, 0.5, 1.0});
+    Polygon inner2 = new Polygon(new double[] {-1.0, -1.0, 0.5, 1.0, 1.0, 0.5, -1.0},
+        new double[]{-2.0, -4.0, -3.5, -4.0, -2.0, -2.5, -2.0});
+    poly = new Polygon(poly.getPolyLats(), poly.getPolyLons(), inner, inner2);
+    List<Tessellator.Triangle> tessellation = Tessellator.tessellate(poly);
+    assertTrue(tessellation.size() > 0);
+    for (Tessellator.Triangle t : tessellation) {
+      checkTriangleEdgesFromPolygon(poly, t);
+    }
+  }
+
+  private void checkTriangleEdgesFromPolygon(Polygon p, Tessellator.Triangle t) {
+    assertEquals(t.fromPolygon(0), edgeFromPolygon(p, t.getLon(0), t.getLat(0), t.getLon(1), t.getLat(1)));
+    assertEquals(t.fromPolygon(1), edgeFromPolygon(p, t.getLon(1), t.getLat(1), t.getLon(2), t.getLat(2)));
+    assertEquals(t.fromPolygon(2), edgeFromPolygon(p, t.getLon(2), t.getLat(2), t.getLon(0), t.getLat(0)));
+  }
+
+  private boolean edgeFromPolygon(Polygon p, double aLon, double aLat, double bLon, double bLat) {
+    for (int i =0; i < p.getPolyLats().length - 1; i++) {
+      if (p.getPolyLon(i) == aLon && p.getPolyLat(i) == aLat && p.getPolyLon(i + 1) == bLon && p.getPolyLat(i + 1) == bLat) {
+        return true;
+      }
+      if (p.getPolyLon(i) == bLon && p.getPolyLat(i) == bLat && p.getPolyLon(i + 1) == aLon && p.getPolyLat(i + 1) == aLat) {
+        return true;
+      }
+    }
+    if (p.getHoles() != null && p.getHoles().length > 0) {
+      for (Polygon hole : p.getHoles()) {
+        if (edgeFromPolygon(hole, aLon, aLat, bLon, bLat)) {
+          return true;
+        }
+      }
+    }
+    return false;
   }
 }
\ No newline at end of file
Index: lucene/core/src/java/org/apache/lucene/geo/Polygon2D.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/core/src/java/org/apache/lucene/geo/Polygon2D.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/core/src/java/org/apache/lucene/geo/Polygon2D.java	(date 1547734852000)
@@ -92,7 +92,7 @@
     // check each corner: if < 3 are present, its cheaper than crossesSlowly
     int numCorners = numberOfTriangleCorners(ax, ay, bx, by, cx, cy);
     if (numCorners == 3) {
-      if (tree.crossesTriangle(ax, ay, bx, by, cx, cy)) {
+      if (tree.intersectsTriangle(ax, ay, bx, by, cx, cy)) {
         return Relation.CELL_CROSSES_QUERY;
       }
       return Relation.CELL_INSIDE_QUERY;
@@ -117,7 +117,7 @@
     // check each corner: if < 4 are present, its cheaper than crossesSlowly
     int numCorners = numberOfCorners(minLat, maxLat, minLon, maxLon);
     if (numCorners == 4) {
-      if (tree.crosses(minLat, maxLat, minLon, maxLon)) {
+      if (tree.intersects(minLat, maxLat, minLon, maxLon)) {
         return Relation.CELL_CROSSES_QUERY;
       }
       return Relation.CELL_INSIDE_QUERY;
Index: lucene/sandbox/src/java/org/apache/lucene/document/LatLonShape.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/document/LatLonShape.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/sandbox/src/java/org/apache/lucene/document/LatLonShape.java	(date 1547734852000)
@@ -18,12 +18,12 @@
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Objects;
 
 import org.apache.lucene.geo.GeoUtils;
 import org.apache.lucene.geo.Line;
 import org.apache.lucene.geo.Polygon;
 import org.apache.lucene.geo.Tessellator;
-import org.apache.lucene.geo.Tessellator.Triangle;
 import org.apache.lucene.index.PointValues;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.util.BytesRef;
@@ -70,9 +70,9 @@
   /** create indexable fields for polygon geometry */
   public static Field[] createIndexableFields(String fieldName, Polygon polygon) {
     // the lionshare of the indexing is done by the tessellator
-    List<Triangle> tessellation = Tessellator.tessellate(polygon);
+    List<Tessellator.Triangle> tessellation = Tessellator.tessellate(polygon);
     List<LatLonTriangle> fields = new ArrayList<>();
-    for (Triangle t : tessellation) {
+    for (Tessellator.Triangle t : tessellation) {
       fields.add(new LatLonTriangle(fieldName, t));
     }
     return fields.toArray(new Field[fields.size()]);
@@ -118,19 +118,21 @@
    * these triangles are encoded and inserted as separate indexed POINT fields
    */
   private static class LatLonTriangle extends Field {
-
+    //Constructor for points and lines
     LatLonTriangle(String name, double aLat, double aLon, double bLat, double bLon, double cLat, double cLon) {
       super(name, TYPE);
-      setTriangleValue(encodeLongitude(aLon), encodeLatitude(aLat), encodeLongitude(bLon), encodeLatitude(bLat), encodeLongitude(cLon), encodeLatitude(cLat));
+      setTriangleValue(encodeLongitude(aLon), encodeLatitude(aLat), true, encodeLongitude(bLon), encodeLatitude(bLat), true, encodeLongitude(cLon), encodeLatitude(cLat), true);
     }
 
-    LatLonTriangle(String name, Triangle t) {
+    LatLonTriangle(String name, Tessellator.Triangle t) {
       super(name, TYPE);
-      setTriangleValue(t.getEncodedX(0), t.getEncodedY(0), t.getEncodedX(1), t.getEncodedY(1), t.getEncodedX(2), t.getEncodedY(2));
+      setTriangleValue(t.getEncodedX(0), t.getEncodedY(0), t.fromPolygon(0),
+                       t.getEncodedX(1), t.getEncodedY(1), t.fromPolygon(1),
+                       t.getEncodedX(2), t.getEncodedY(2), t.fromPolygon(2));
     }
 
 
-    public void setTriangleValue(int aX, int aY, int bX, int bY, int cX, int cY) {
+    public void setTriangleValue(int aX, int aY, boolean abFromShape, int bX, int bY, boolean bcFromShape, int cX, int cY, boolean caFromShape) {
       final byte[] bytes;
 
       if (fieldsData == null) {
@@ -139,13 +141,13 @@
       } else {
         bytes = ((BytesRef) fieldsData).bytes;
       }
-      encodeTriangle(bytes, aY, aX, bY, bX, cY, cX);
+      encodeTriangle(bytes, aY, aX, abFromShape, bY, bX, bcFromShape, cY, cX, caFromShape);
     }
   }
 
   /** Query Relation Types **/
   public enum QueryRelation {
-    INTERSECTS, WITHIN, DISJOINT
+    INTERSECTS, WITHIN, DISJOINT, CONTAINS
   }
 
   private static final int MINY_MINX_MAXY_MAXX_Y_X = 0;
@@ -162,7 +164,7 @@
    * Triangles are encoded with CCW orientation and might be rotated to limit the number of possible reconstructions to 2^3.
    * Reconstruction always happens from west to east.
    */
-  public static void encodeTriangle(byte[] bytes, int aLat, int aLon, int bLat, int bLon, int cLat, int cLon) {
+  public static void encodeTriangle(byte[] bytes, int aLat, int aLon, boolean abFromShape, int bLat, int bLon, boolean bcFromShape, int cLat, int cLon, boolean caFromShape) {
     assert bytes.length == 7 * BYTES;
     int aX;
     int bX;
@@ -170,6 +172,7 @@
     int aY;
     int bY;
     int cY;
+    boolean ab, bc, ca;
     //change orientation if CW
     if (GeoUtils.orient(aLon, aLat, bLon, bLat, cLon, cLat) == -1) {
       aX = cLon;
@@ -178,6 +181,9 @@
       aY = cLat;
       bY = bLat;
       cY = aLat;
+      ab = bcFromShape;
+      bc = abFromShape;
+      ca = caFromShape;
     } else {
       aX = aLon;
       bX = bLon;
@@ -185,27 +191,38 @@
       aY = aLat;
       bY = bLat;
       cY = cLat;
+      ab = abFromShape;
+      bc = bcFromShape;
+      ca = caFromShape;
     }
     //rotate edges and place minX at the beginning
     if (bX < aX || cX < aX) {
       if (bX < cX) {
         int tempX = aX;
         int tempY = aY;
+        boolean tempBool = ab;
         aX = bX;
         aY = bY;
+        ab = bc;
         bX = cX;
         bY = cY;
+        bc = ca;
         cX = tempX;
         cY = tempY;
+        ca = tempBool;
       } else if (cX < aX) {
         int tempX = aX;
         int tempY = aY;
+        boolean tempBool = ab;
         aX = cX;
         aY = cY;
+        ab = ca;
         cX = bX;
         cY = bY;
+        ca = bc;
         bX = tempX;
         bY = tempY;
+        bc = tempBool;
       }
     } else if (aX == bX && aX == cX) {
       //degenerated case, all points with same longitude
@@ -214,21 +231,29 @@
         if (bY < cY) {
           int tempX = aX;
           int tempY = aY;
+          boolean tempBool = ab;
           aX = bX;
           aY = bY;
+          ab = bc;
           bX = cX;
           bY = cY;
+          bc = ca;
           cX = tempX;
           cY = tempY;
+          ca = tempBool;
         } else if (cY < aY) {
           int tempX = aX;
           int tempY = aY;
+          boolean tempBool = ab;
           aX = cX;
           aY = cY;
+          ab = ca;
           cX = bX;
           cY = bY;
+          ca = bc;
           bX = tempX;
           bY = tempY;
+          bc = tempBool;
         }
       }
     }
@@ -278,6 +303,9 @@
     } else {
       throw new IllegalArgumentException("Could not encode the provided triangle");
     }
+    bits |= (ab) ? (1 << 3) : 0;
+    bits |= (bc) ? (1 << 4) : 0;
+    bits |= (ca) ? (1 << 5) : 0;
     NumericUtils.intToSortableBytes(minY, bytes, 0);
     NumericUtils.intToSortableBytes(minX, bytes, BYTES);
     NumericUtils.intToSortableBytes(maxY, bytes, 2 * BYTES);
@@ -288,82 +316,133 @@
   }
 
   /**
-   * Decode a triangle encoded by {@link LatLonShape#encodeTriangle(byte[], int, int, int, int, int, int)}.
+   * Decode a triangle encoded by {@link LatLonShape#encodeTriangle(byte[], int, int, boolean, int, int, boolean, int, int, boolean)}.
    */
-  public static void decodeTriangle(byte[] t, int[] triangle) {
-    assert triangle.length == 6;
-    int bits = NumericUtils.sortableBytesToInt(t, 6 * LatLonShape.BYTES);
+  public static void decodeTriangle(byte[] t, Triangle triangle) {
+    final int aX, aY, bX, bY, cX, cY;
+    final boolean ab, bc, ca;
+    final int bits = NumericUtils.sortableBytesToInt(t, 6 * LatLonShape.BYTES);
     //extract the first three bits
     int tCode = (((1 << 3) - 1) & (bits >> 0));
     switch (tCode) {
       case MINY_MINX_MAXY_MAXX_Y_X:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
+        aY = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
+        aX = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
+        bY = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
+        bX = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
+        cY = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
+        cX = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
         break;
       case MINY_MINX_Y_X_MAXY_MAXX:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
+        aY = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
+        aX = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
+        bY = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
+        bX = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
+        cY = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
+        cX = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
         break;
       case MAXY_MINX_Y_X_MINY_MAXX:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
+        aY = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
+        aX = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
+        bY = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
+        bX = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
+        cY = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
+        cX = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
         break;
       case MAXY_MINX_MINY_MAXX_Y_X:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
+        aY = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
+        aX = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
+        bY = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
+        bX = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
+        cY = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
+        cX = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
         break;
       case Y_MINX_MINY_X_MAXY_MAXX:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
+        aY = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
+        aX = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
+        bY = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
+        bX = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
+        cY = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
+        cX = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
         break;
       case Y_MINX_MINY_MAXX_MAXY_X:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
+        aY = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
+        aX = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
+        bY = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
+        bX = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
+        cY = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
+        cX = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
         break;
       case MAXY_MINX_MINY_X_Y_MAXX:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
+        aY = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
+        aX = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
+        bY = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
+        bX = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
+        cY = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
+        cX = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
         break;
       case MINY_MINX_Y_MAXX_MAXY_X:
-        triangle[0] = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
-        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
-        triangle[2] = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
-        triangle[3] = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
-        triangle[4] = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
-        triangle[5] = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
+        aY = NumericUtils.sortableBytesToInt(t, 0 * LatLonShape.BYTES);
+        aX = NumericUtils.sortableBytesToInt(t, 1 * LatLonShape.BYTES);
+        bY = NumericUtils.sortableBytesToInt(t, 4 * LatLonShape.BYTES);
+        bX = NumericUtils.sortableBytesToInt(t, 3 * LatLonShape.BYTES);
+        cY = NumericUtils.sortableBytesToInt(t, 2 * LatLonShape.BYTES);
+        cX = NumericUtils.sortableBytesToInt(t, 5 * LatLonShape.BYTES);
         break;
       default:
         throw new IllegalArgumentException("Could not decode the provided triangle");
     }
     //Points of the decoded triangle must be co-planar or CCW oriented
-    assert GeoUtils.orient(triangle[1], triangle[0], triangle[3], triangle[2], triangle[5], triangle[4]) >= 0;
+    assert GeoUtils.orient(aX, aY, bX, bY, cX, cY) >= 0;
+    ab = (bits & 1 << 3) == 1 << 3;
+    bc = (bits & 1 << 4) == 1 << 4;
+    ca = (bits & 1 << 5) == 1 << 5;
+    triangle.setValues(aX, aY, ab, bX, bY, bc, cX, cY, ca);
+  }
+
+  /**
+   * Represents a decoded triangle using {@link LatLonShape#decodeTriangle(byte[], Triangle)}.
+   */
+  public static class Triangle {
+    //Triangle vertices
+    public int aX, aY, bX, bY, cX, cY;
+    //Represent if edges belongs to original shape
+    public boolean ab, bc, ca;
+
+    public Triangle() {
+    }
+
+    private void setValues(int aX, int aY, boolean ab, int bX, int bY, boolean bc, int cX, int cY, boolean ca) {
+      this.aX = aX;
+      this.aY = aY;
+      this.ab = ab;
+      this.bX = bX;
+      this.bY = bY;
+      this.bc = bc;
+      this.cX = cX;
+      this.cY = cY;
+      this.ca = ca;
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(aX, aY, bX, bY, cX, cY, ab, bc, ca);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      Triangle other  = (Triangle) o;
+      return aX == other.aX && bX == other.bX && cX == other.cX
+          && aY == other.aY && bY == other.bY && cY == other.cY
+          && ab == other.ab && bc == other.bc && ca == other.ca;
+    }
+
+    /** pretty print the triangle vertices */
+    public String toString() {
+      String result = aX + ", " + aY + " " +
+          bX + ", " + bY + " " +
+          cX + ", " + cY + " " + "[" + ab + "," +bc + "," + ca + "]";
+      return result;
+    }
   }
 }
Index: lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapePolygonQuery.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapePolygonQuery.java	(revision 70dd3ee06a49261da1c9d2c220f59ac9e73fc4c8)
+++ lucene/sandbox/src/java/org/apache/lucene/document/LatLonShapePolygonQuery.java	(date 1547734852000)
@@ -73,15 +73,15 @@
   }
 
   @Override
-  protected boolean queryMatches(byte[] t, int[] scratchTriangle) {
+  protected boolean queryMatches(byte[] t, LatLonShape.Triangle scratchTriangle) {
     LatLonShape.decodeTriangle(t, scratchTriangle);
 
-    double alat = GeoEncodingUtils.decodeLatitude(scratchTriangle[0]);
-    double alon = GeoEncodingUtils.decodeLongitude(scratchTriangle[1]);
-    double blat = GeoEncodingUtils.decodeLatitude(scratchTriangle[2]);
-    double blon = GeoEncodingUtils.decodeLongitude(scratchTriangle[3]);
-    double clat = GeoEncodingUtils.decodeLatitude(scratchTriangle[4]);
-    double clon = GeoEncodingUtils.decodeLongitude(scratchTriangle[5]);
+    double alat = GeoEncodingUtils.decodeLatitude(scratchTriangle.aY);
+    double alon = GeoEncodingUtils.decodeLongitude(scratchTriangle.aX);
+    double blat = GeoEncodingUtils.decodeLatitude(scratchTriangle.bY);
+    double blon = GeoEncodingUtils.decodeLongitude(scratchTriangle.bX);
+    double clat = GeoEncodingUtils.decodeLatitude(scratchTriangle.cY);
+    double clon = GeoEncodingUtils.decodeLongitude(scratchTriangle.cX);
 
     if (queryRelation == QueryRelation.WITHIN) {
       return poly2D.relateTriangle(alon, alat, blon, blat, clon, clat) == Relation.CELL_INSIDE_QUERY;
@@ -90,6 +90,21 @@
     return poly2D.relateTriangle(alon, alat, blon, blat, clon, clat) != Relation.CELL_OUTSIDE_QUERY;
   }
 
+  @Override
+  protected Boolean queryWithin(byte[] t, LatLonShape.Triangle scratchTriangle) {
+    LatLonShape.decodeTriangle(t, scratchTriangle);
+
+    double alat = GeoEncodingUtils.decodeLatitude(scratchTriangle.aY);
+    double alon = GeoEncodingUtils.decodeLongitude(scratchTriangle.aX);
+    double blat = GeoEncodingUtils.decodeLatitude(scratchTriangle.bY);
+    double blon = GeoEncodingUtils.decodeLongitude(scratchTriangle.bX);
+    double clat = GeoEncodingUtils.decodeLatitude(scratchTriangle.cY);
+    double clon = GeoEncodingUtils.decodeLongitude(scratchTriangle.cX);
+
+    return poly2D.withinTriangle(alon, alat, scratchTriangle.ab, blon, blat, scratchTriangle.bc, clon, clat, scratchTriangle.ca);
+
+  }
+
   @Override
   public String toString(String field) {
     final StringBuilder sb = new StringBuilder();
