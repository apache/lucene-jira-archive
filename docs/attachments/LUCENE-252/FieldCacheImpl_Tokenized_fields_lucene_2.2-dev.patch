Index: src/java/org/apache/lucene/search/FieldCacheImpl.java
===================================================================
--- src/java/org/apache/lucene/search/FieldCacheImpl.java	(revision 515083)
+++ src/java/org/apache/lucene/search/FieldCacheImpl.java	(working copy)
@@ -21,12 +21,14 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermDocs;
 import org.apache.lucene.index.TermEnum;
+import org.apache.lucene.document.Field;
 
 import java.io.IOException;
 import java.util.Locale;
 import java.util.Map;
 import java.util.WeakHashMap;
 import java.util.HashMap;
+import java.util.Arrays;
 
 /**
  * Expert: The default cache implementation, storing all values in memory.
@@ -131,6 +133,28 @@
     }
   }
 
+  class FieldEntry implements Comparable {
+    String val;
+    int ind;
+    FieldEntry(int ind, String val)
+    {
+        this.ind = ind;
+        this.val = val;
+    }
+    public String getVal()
+    {
+        return val;
+    }
+    public int getInd()
+    {
+        return ind;
+    }
+    public int compareTo(Object obj)
+    {
+        return val.compareToIgnoreCase(((FieldEntry)obj).getVal());
+    }
+  }
+
   private static final IntParser INT_PARSER = new IntParser() {
       public int parseInt(String value) {
         return Integer.parseInt(value);
@@ -234,22 +258,35 @@
         throws IOException {
       String field = ((String) fieldKey).intern();
       final String[] retArray = new String[reader.maxDoc()];
-      TermDocs termDocs = reader.termDocs();
-      TermEnum termEnum = reader.terms (new Term (field, ""));
-      try {
-        do {
-          Term term = termEnum.term();
-          if (term==null || term.field() != field) break;
-          String termval = term.text();
-          termDocs.seek (termEnum);
-          while (termDocs.next()) {
-            retArray[termDocs.doc()] = termval;
-          }
-        } while (termEnum.next());
-      } finally {
-        termDocs.close();
-        termEnum.close();
+      Field docField = getField(reader, field);
+      if (docField != null && docField.isStored() && docField.isTokenized()) {
+        for (int i=0; i<reader.maxDoc(); i++) {
+          String fieldValue = null;
+          if (!reader.isDeleted(i))
+            fieldValue = reader.document(i).get(field);
+          else
+            fieldValue = "";
+          retArray[i] = fieldValue;     
+        }
       }
+      else {
+        TermDocs termDocs = reader.termDocs();
+        TermEnum termEnum = reader.terms (new Term (field, ""));
+        try {
+          do {
+            Term term = termEnum.term();
+            if (term==null || term.field() != field) break;
+            String termval = term.text();
+            termDocs.seek (termEnum);
+            while (termDocs.next()) {
+              retArray[termDocs.doc()] = termval;
+            }
+          } while (termEnum.next());
+        } finally {
+          termDocs.close();
+          termEnum.close();
+        }
+      }
       return retArray;
     }
   };
@@ -267,52 +304,93 @@
       String field = ((String) fieldKey).intern();
       final int[] retArray = new int[reader.maxDoc()];
       String[] mterms = new String[reader.maxDoc()+1];
-      TermDocs termDocs = reader.termDocs();
-      TermEnum termEnum = reader.terms (new Term (field, ""));
-      int t = 0;  // current term number
 
-      // an entry for documents that have no terms in this field
-      // should a document with no terms be at top or bottom?
-      // this puts them at the top - if it is changed, FieldDocSortedHitQueue
-      // needs to change as well.
-      mterms[t++] = null;
+      Field docField = getField(reader, field);
+      if (docField != null && docField.isStored() && docField.isTokenized()) {
+        // Fill entries
+        FieldEntry[] entries = new FieldEntry[reader.maxDoc()];
+        for (int i=0; i<reader.maxDoc(); i++) {
+          String fieldValue;
+          if (!reader.isDeleted(i))
+            fieldValue = reader.document(i).get(field);
+          else
+            fieldValue = "";
+          entries[i] = new FieldEntry (i,fieldValue);     
+        }
 
-      try {
-        do {
-          Term term = termEnum.term();
-          if (term==null || term.field() != field) break;
+        Arrays.sort(entries);
+        for (int i=0;i<reader.maxDoc();i++)
+        {
+          int ind = entries[i].getInd();
+          retArray[ind] = i;
+          mterms[ind]=entries[i].getVal();
+        }
+      }
+      else
+      {
+        if (retArray.length > 0)
+        {
+          TermDocs termDocs = reader.termDocs();
+          TermEnum termEnum = reader.terms(new Term(field, ""));
+          int t = 0; // current term number
 
-          // store term text
-          // we expect that there is at most one term per document
-          if (t >= mterms.length) throw new RuntimeException ("there are more terms than " +
-                  "documents in field \"" + field + "\", but it's impossible to sort on " +
-                  "tokenized fields");
-          mterms[t] = term.text();
+          // an entry for documents that have no terms in this field
+          // should a document with no terms be at top or bottom?
+          // this puts them at the top - if it is changed, FieldDocSortedHitQueue
+          // needs to change as well.
+          mterms[t++] = null;
 
-          termDocs.seek (termEnum);
-          while (termDocs.next()) {
-            retArray[termDocs.doc()] = t;
+          try
+          {
+            if (termEnum.term() == null)
+            {
+              throw new RuntimeException("no terms in field " + field);
+            }
+            do
+            {
+              Term term = termEnum.term();
+              if (term.field() != field)
+                break;
+
+              // store term text
+              // we expect that there is at most one term per document
+              if (t >= mterms.length)
+                throw new RuntimeException("there are more terms than documents in field \"" + field +
+                "\"");
+              mterms[t] = term.text();
+              termDocs.seek(termEnum);
+              while (termDocs.next())
+              {
+                retArray[termDocs.doc()] = t;
+              }
+
+              t++;
+            }
+            while (termEnum.next());
           }
+          finally
+          {
+            termDocs.close();
+            termEnum.close();
+          }
 
-          t++;
-        } while (termEnum.next());
-      } finally {
-        termDocs.close();
-        termEnum.close();
-      }
+          if (t == 0)
+          {
+            // if there are no terms, make the term array
+            // have a single null entry
+            mterms = new String[1];
+          }
+          else if (t < mterms.length)
+          {
+            // if there are less terms than documents,
+            // trim off the dead array space
+            String[] terms = new String[t];
+            System.arraycopy(mterms, 0, terms, 0, t);
+            mterms = terms;
+          }
+        }
 
-      if (t == 0) {
-        // if there are no terms, make the term array
-        // have a single null entry
-        mterms = new String[1];
-      } else if (t < mterms.length) {
-        // if there are less terms than documents,
-        // trim off the dead array space
-        String[] terms = new String[t];
-        System.arraycopy (mterms, 0, terms, 0, t);
-        mterms = terms;
       }
-
       StringIndex value = new StringIndex (retArray, mterms);
       return value;
     }
@@ -414,6 +492,19 @@
       return retArray;
     }
   };
-  
+
+ /**
+  * Returns the field in the first not-deleted document
+  * @return a Field object or null of the field is not found
+  */
+  private Field getField(IndexReader reader, String field) throws IOException{
+    for (int i=0; i<reader.maxDoc(); i++) {
+      if (!reader.isDeleted(i)) {
+        return reader.document(i).getField(field);
+      }
+    }
+    return null; 
+  }
+ 
 }
 
