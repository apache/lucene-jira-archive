diff --git a/lucene/core/src/java/org/apache/lucene/search/LongValuesSource.java b/lucene/core/src/java/org/apache/lucene/search/LongValuesSource.java
index 4443b056824..b72c5a7652a 100644
--- a/lucene/core/src/java/org/apache/lucene/search/LongValuesSource.java
+++ b/lucene/core/src/java/org/apache/lucene/search/LongValuesSource.java
@@ -157,7 +157,8 @@ public abstract class LongValuesSource implements SegmentCacheable {
     return new ConstantLongValuesSource(value);
   }
 
-  private static class ConstantLongValuesSource extends LongValuesSource {
+  /** A ConstantLongValuesSource that always returns a constant value */
+  public static class ConstantLongValuesSource extends LongValuesSource {
 
     private final long value;
 
@@ -212,6 +213,10 @@ public abstract class LongValuesSource implements SegmentCacheable {
     public LongValuesSource rewrite(IndexSearcher searcher) throws IOException {
       return this;
     }
+
+    public long getValue() {
+      return value;
+    }
   }
 
   private static class FieldValuesSource extends LongValuesSource {
diff --git a/lucene/sandbox/src/java/org/apache/lucene/sandbox/search/CoveringQuery.java b/lucene/sandbox/src/java/org/apache/lucene/sandbox/search/CoveringQuery.java
index c9968989ed8..ea548f9532c 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/sandbox/search/CoveringQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/sandbox/search/CoveringQuery.java
@@ -25,6 +25,7 @@ import java.util.stream.Collectors;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.LongValues;
@@ -54,7 +55,7 @@ public final class CoveringQuery extends Query implements Accountable {
   private final LongValuesSource minimumNumberMatch;
   private final int hashCode;
   private final long ramBytesUsed;
-
+  private final long constantMin;
   /**
    * Sole constructor.
    *
@@ -81,6 +82,12 @@ public final class CoveringQuery extends Query implements Accountable {
         BASE_RAM_BYTES
             + RamUsageEstimator.sizeOfObject(
                 this.queries, RamUsageEstimator.QUERY_DEFAULT_RAM_BYTES_USED);
+
+    if (minimumNumberMatch instanceof LongValuesSource.ConstantLongValuesSource) {
+      constantMin = ((LongValuesSource.ConstantLongValuesSource)minimumNumberMatch).getValue();
+    } else {
+      constantMin = -1L;
+    }
   }
 
   @Override
@@ -124,6 +131,14 @@ public final class CoveringQuery extends Query implements Accountable {
 
   @Override
   public Query rewrite(IndexReader reader) throws IOException {
+    if (constantMin <= queries.size() && constantMin >= 0L) {
+      BooleanQuery.Builder builder = new BooleanQuery.Builder().setMinimumNumberShouldMatch((int) constantMin);
+      for (Query query : queries) {
+        Query r = query.rewrite(reader);
+        builder.add(r, BooleanClause.Occur.SHOULD);
+      }
+      return builder.build();
+    }
     Multiset<Query> rewritten = new Multiset<>();
     boolean actuallyRewritten = false;
     for (Query query : queries) {
@@ -159,7 +174,6 @@ public final class CoveringQuery extends Query implements Accountable {
 
     private final Collection<Weight> weights;
     private final LongValuesSource minimumNumberMatch;
-
     CoveringWeight(Query query, Collection<Weight> weights, LongValuesSource minimumNumberMatch) {
       super(query);
       this.weights = weights;
diff --git a/lucene/sandbox/src/test/org/apache/lucene/sandbox/search/TestCoveringQuery.java b/lucene/sandbox/src/test/org/apache/lucene/sandbox/search/TestCoveringQuery.java
index 4627ce2c264..3cef4c156ed 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/sandbox/search/TestCoveringQuery.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/sandbox/search/TestCoveringQuery.java
@@ -36,7 +36,10 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.LongValuesSource;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Sort;
 import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.TopDocs;
+import org.apache.lucene.search.TopScoreDocCollector;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.tests.search.QueryUtils;
 import org.apache.lucene.tests.util.LuceneTestCase;
@@ -147,6 +150,7 @@ public class TestCoveringQuery extends LuceneTestCase {
         }
         Query q1 = builder.build();
         Query q2 = new CoveringQuery(queries, LongValuesSource.constant(i));
+        assertSameMatches(searcher, q1, q2, true);
         assertEquals(searcher.count(q1), searcher.count(q2));
       }
 
@@ -161,4 +165,103 @@ public class TestCoveringQuery extends LuceneTestCase {
     r.close();
     dir.close();
   }
+
+  public void testRandomWand() throws IOException {
+    Directory dir = newDirectory();
+    IndexWriter w = new IndexWriter(dir, newIndexWriterConfig());
+    int numDocs = atLeast(50);
+    for (int i = 0; i < numDocs; ++i) {
+      Document doc = new Document();
+      if (random().nextBoolean()) {
+        doc.add(new StringField("field", "A", Store.NO));
+      }
+      if (random().nextBoolean()) {
+        doc.add(new StringField("field", "B", Store.NO));
+      }
+      if (random().nextDouble() > 0.9) {
+        doc.add(new StringField("field", "C", Store.NO));
+      }
+      if (random().nextDouble() > 0.1) {
+        doc.add(new StringField("field", "D", Store.NO));
+      }
+      doc.add(new NumericDocValuesField("min_match", 1));
+      w.addDocument(doc);
+    }
+
+    IndexReader r = DirectoryReader.open(w);
+    IndexSearcher searcher = new IndexSearcher(r);
+    w.close();
+
+    int iters = atLeast(10);
+    for (int iter = 0; iter < iters; ++iter) {
+      List<Query> queries = new ArrayList<>();
+      if (random().nextBoolean()) {
+        queries.add(new TermQuery(new Term("field", "A")));
+      }
+      if (random().nextBoolean()) {
+        queries.add(new TermQuery(new Term("field", "B")));
+      }
+      if (random().nextBoolean()) {
+        queries.add(new TermQuery(new Term("field", "C")));
+      }
+      if (random().nextBoolean()) {
+        queries.add(new TermQuery(new Term("field", "D")));
+      }
+      if (random().nextBoolean()) {
+        queries.add(new TermQuery(new Term("field", "E")));
+      }
+
+      Query q = new CoveringQuery(queries, LongValuesSource.fromLongField("min_match"));
+      QueryUtils.check(random(), q, searcher);
+
+      for (int i = 1; i < 4; ++i) {
+        BooleanQuery.Builder builder = new BooleanQuery.Builder().setMinimumNumberShouldMatch(i);
+        for (Query query : queries) {
+          builder.add(query, Occur.SHOULD);
+        }
+        Query q1 = builder.build();
+        Query q2 = new CoveringQuery(queries, LongValuesSource.constant(i));
+        assertSameMatches(searcher, q1, q2, true);
+        assertEquals(searcher.count(q1), searcher.count(q2));
+      }
+
+      Query filtered =
+              new BooleanQuery.Builder()
+                      .add(q, Occur.MUST)
+                      .add(new TermQuery(new Term("field", "A")), Occur.MUST)
+                      .build();
+      QueryUtils.check(random(), filtered, searcher);
+    }
+
+    r.close();
+    dir.close();
+  }
+  private void assertSameMatches(IndexSearcher searcher, Query q1, Query q2)
+          throws IOException {
+    final int maxDoc = searcher.getIndexReader().maxDoc();
+    TopScoreDocCollector collector1 = TopScoreDocCollector.create(maxDoc,maxDoc);
+    TopScoreDocCollector collector2 = TopScoreDocCollector.create(maxDoc,maxDoc);
+
+    searcher.search(q1, collector1);
+    searcher.search(q2, collector2);
+    assertEquals(collector1.topDocs().totalHits.value, collector2.topDocs().totalHits.value);
+    for (int i = 0; i < collector1.topDocs().scoreDocs.length; ++i) {
+      assertEquals(collector1.topDocs().scoreDocs[i].doc, collector2.topDocs().scoreDocs[i].doc);
+      assertEquals(collector1.topDocs().scoreDocs[i].score, collector2.topDocs().scoreDocs[i].score, 10e-7);
+
+    }
+  }
+  private void assertSameMatches(IndexSearcher searcher, Query q1, Query q2, boolean scores)
+          throws IOException {
+    final int maxDoc = searcher.getIndexReader().maxDoc();
+    final TopDocs td1 = searcher.search(q1, maxDoc, scores ? Sort.RELEVANCE : Sort.INDEXORDER);
+    final TopDocs td2 = searcher.search(q2, maxDoc, scores ? Sort.RELEVANCE : Sort.INDEXORDER);
+    assertEquals(td1.totalHits.value, td2.totalHits.value);
+    for (int i = 0; i < td1.scoreDocs.length; ++i) {
+      assertEquals(td1.scoreDocs[i].doc, td2.scoreDocs[i].doc);
+      if (scores) {
+        assertEquals(td1.scoreDocs[i].score, td2.scoreDocs[i].score, 10e-7);
+      }
+    }
+  }
 }
