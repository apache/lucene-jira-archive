diff --git a/lucene/core/src/java/org/apache/lucene/search/AutomatonQuery.java b/lucene/core/src/java/org/apache/lucene/search/AutomatonQuery.java
index 77b46a5..1a5ccf7 100644
--- a/lucene/core/src/java/org/apache/lucene/search/AutomatonQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/AutomatonQuery.java
@@ -18,6 +18,7 @@ package org.apache.lucene.search;
  */
 
 import java.io.IOException;
+import java.util.Objects;
 
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.Terms;
@@ -80,7 +81,7 @@ public class AutomatonQuery extends MultiTermQuery {
   public AutomatonQuery(final Term term, Automaton automaton, int maxDeterminizedStates) {
     super(term.field());
     this.term = term;
-    this.automaton = automaton;
+    this.automaton = Objects.requireNonNull(automaton, "Automaton must not be null");
     this.compiled = new CompiledAutomaton(automaton, null, true, maxDeterminizedStates);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/BitsFilteredDocIdSet.java b/lucene/core/src/java/org/apache/lucene/search/BitsFilteredDocIdSet.java
index 9177c72..77829ae 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BitsFilteredDocIdSet.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BitsFilteredDocIdSet.java
@@ -17,6 +17,8 @@ package org.apache.lucene.search;
  * limitations under the License.
  */
 
+import java.util.Objects;
+
 import org.apache.lucene.util.Bits;
 
 /**
@@ -50,9 +52,7 @@ public final class BitsFilteredDocIdSet extends FilteredDocIdSet {
    */
   public BitsFilteredDocIdSet(DocIdSet innerSet, Bits acceptDocs) {
     super(innerSet);
-    if (acceptDocs == null)
-      throw new NullPointerException("acceptDocs is null");
-    this.acceptDocs = acceptDocs;
+    this.acceptDocs = Objects.requireNonNull(acceptDocs, "Bits must not be null");
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/BooleanClause.java b/lucene/core/src/java/org/apache/lucene/search/BooleanClause.java
index 69ee3f8..07df580 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BooleanClause.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BooleanClause.java
@@ -17,6 +17,8 @@ package org.apache.lucene.search;
  * limitations under the License.
  */
 
+import java.util.Objects;
+
 /** A clause in a BooleanQuery. */
 public class BooleanClause {
   
@@ -55,8 +57,8 @@ public class BooleanClause {
   /** Constructs a BooleanClause.
   */ 
   public BooleanClause(Query query, Occur occur) {
-    this.query = query;
-    this.occur = occur;
+    this.query = Objects.requireNonNull(query, "Query must not be null");
+    this.occur = Objects.requireNonNull(occur, "Occur must not be null");
     
   }
 
@@ -65,7 +67,7 @@ public class BooleanClause {
   }
 
   public void setOccur(Occur occur) {
-    this.occur = occur;
+    this.occur = Objects.requireNonNull(occur, "Occur must not be null");
 
   }
 
@@ -74,7 +76,7 @@ public class BooleanClause {
   }
 
   public void setQuery(Query query) {
-    this.query = query;
+    this.query = Objects.requireNonNull(query, "Query must not be null");
   }
   
   public boolean isProhibited() {
diff --git a/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java b/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
index c3d2f56..454323b 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BooleanQuery.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Objects;
 import java.util.Set;
 
 import org.apache.lucene.index.IndexReader;
@@ -137,6 +138,7 @@ public class BooleanQuery extends Query implements Iterable<BooleanClause> {
    * @see #getMaxClauseCount()
    */
   public void add(BooleanClause clause) {
+    Objects.requireNonNull("BooleanClause must not be null");
     if (clauses.size() >= maxClauseCount) {
       throw new TooManyClauses();
     }
diff --git a/lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery.java b/lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery.java
index 77b4660..fface87 100644
--- a/lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery.java
@@ -23,6 +23,7 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.WeakHashMap;
 
 import org.apache.lucene.index.IndexReader;
@@ -48,8 +49,8 @@ public class CachingWrapperQuery extends Query implements Accountable {
    * @param policy policy defining which filters should be cached on which segments
    */
   public CachingWrapperQuery(Query query, QueryCachingPolicy policy) {
-    this.query = query;
-    this.policy = policy;
+    this.query = Objects.requireNonNull(query, "Query must not be null");
+    this.policy = Objects.requireNonNull(policy, "QueryCachingPolicy must not be null");
   }
 
   /** Same as {@link CachingWrapperQuery#CachingWrapperQuery(Query, QueryCachingPolicy)}
diff --git a/lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java b/lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java
index e8241ac..81df5ce 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java
@@ -20,6 +20,7 @@ package org.apache.lucene.search;
 import java.io.IOException;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Objects;
 import java.util.Set;
 
 import org.apache.lucene.index.IndexReader;
@@ -39,7 +40,7 @@ public class ConstantScoreQuery extends Query {
   /** Strips off scores from the passed in Query. The hits will get a constant score
    * dependent on the boost factor of this query. */
   public ConstantScoreQuery(Query query) {
-    this.query = query;
+    this.query = Objects.requireNonNull(query, "Query must not be null");
   }
 
   /** Returns the encapsulated query. */
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
index c931d92..24c8175 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
@@ -21,6 +21,7 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Objects;
 import java.util.Set;
 
 import org.apache.lucene.index.LeafReaderContext;
@@ -66,6 +67,7 @@ public class DisjunctionMaxQuery extends Query implements Iterable<Query> {
    * @param tieBreakerMultiplier   the weight to give to each matching non-maximum disjunct
    */
   public DisjunctionMaxQuery(Collection<Query> disjuncts, float tieBreakerMultiplier) {
+    Objects.requireNonNull(disjuncts, "Collection of Querys must not be null");
     this.tieBreakerMultiplier = tieBreakerMultiplier;
     add(disjuncts);
   }
@@ -74,7 +76,7 @@ public class DisjunctionMaxQuery extends Query implements Iterable<Query> {
    * @param query the disjunct added
    */
   public void add(Query query) {
-    disjuncts.add(query);
+    disjuncts.add(Objects.requireNonNull(query, "Query must not be null"));
   }
 
   /** Add a collection of disjuncts to this disjunction
@@ -82,7 +84,7 @@ public class DisjunctionMaxQuery extends Query implements Iterable<Query> {
    * @param disjuncts a collection of queries to add as disjuncts.
    */
   public void add(Collection<Query> disjuncts) {
-    this.disjuncts.addAll(disjuncts);
+    this.disjuncts.addAll(Objects.requireNonNull(disjuncts, "Query connection must not be null"));
   }
 
   /** @return An {@code Iterator<Query>} over the disjuncts */
diff --git a/lucene/core/src/java/org/apache/lucene/search/DocValuesTermsQuery.java b/lucene/core/src/java/org/apache/lucene/search/DocValuesTermsQuery.java
index 4875b16..b7a5951 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DocValuesTermsQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DocValuesTermsQuery.java
@@ -90,6 +90,7 @@ public class DocValuesTermsQuery extends Query {
 
   public DocValuesTermsQuery(String field, Collection<BytesRef> terms) {
     this.field = Objects.requireNonNull(field);
+    Objects.requireNonNull(terms, "Collection of terms must not be null");
     this.terms = terms.toArray(new BytesRef[terms.size()]);
     ArrayUtil.timSort(this.terms, BytesRef.getUTF8SortedAsUnicodeComparator());
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java b/lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java
index 38cf257..901e718 100644
--- a/lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/FilteredQuery.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Objects;
 import java.util.Set;
 
 import org.apache.lucene.index.IndexReader;
@@ -66,18 +67,9 @@ public class FilteredQuery extends Query {
    * @see FilterStrategy
    */
   public FilteredQuery(Query query, Filter filter, FilterStrategy strategy) {
-    if (query == null) {
-      throw new IllegalArgumentException("Query must not be be null.");
-    }
-    if (filter == null) {
-      throw new IllegalArgumentException("Filter must not be be null.");
-    }
-    if (strategy == null) {
-      throw new IllegalArgumentException("FilterStrategy must not be null");
-    }
-    this.strategy = strategy;
-    this.query = query;
-    this.filter = filter;
+    this.strategy = Objects.requireNonNull(strategy, "FilterStrategy must not be null");
+    this.query = Objects.requireNonNull(query, "Query must not be null");
+    this.filter = Objects.requireNonNull(filter, "Filter must not be null");
   }
   
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java b/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
index f6b9ff5..b3bbfa9 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
@@ -93,6 +93,7 @@ public class MultiPhraseQuery extends Query {
    * @see PhraseQuery#add(Term, int)
    */
   public void add(Term[] terms, int position) {
+    Objects.requireNonNull(terms, "Term array must not be null");
     if (termArrays.size() == 0)
       field = terms[0].field();
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java
index b475394..d98167b 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MultiTermQuery.java
@@ -18,6 +18,7 @@ package org.apache.lucene.search;
  */
 
 import java.io.IOException;
+import java.util.Objects;
 
 import org.apache.lucene.index.FilteredTermsEnum; // javadocs
 import org.apache.lucene.index.IndexReader;
@@ -214,10 +215,7 @@ public abstract class MultiTermQuery extends Query {
    * Term.
    */
   public MultiTermQuery(final String field) {
-    if (field == null) {
-      throw new IllegalArgumentException("field must not be null");
-    }
-    this.field = field;
+    this.field = Objects.requireNonNull(field, "field must not be null");
   }
 
   /** Returns the field name for this query */
diff --git a/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java b/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
index 0a1973e..9fc8efe 100644
--- a/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/NumericRangeQuery.java
@@ -19,6 +19,7 @@ package org.apache.lucene.search;
 
 import java.io.IOException;
 import java.util.LinkedList;
+import java.util.Objects;
 
 import org.apache.lucene.analysis.NumericTokenStream; // for javadocs
 import org.apache.lucene.document.DoubleField; // for javadocs
@@ -172,7 +173,7 @@ public final class NumericRangeQuery<T extends Number> extends MultiTermQuery {
     if (precisionStep < 1)
       throw new IllegalArgumentException("precisionStep must be >=1");
     this.precisionStep = precisionStep;
-    this.dataType = dataType;
+    this.dataType = Objects.requireNonNull(dataType, "NumericType must not be null");
     this.min = min;
     this.max = max;
     this.minInclusive = minInclusive;
diff --git a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
index 20d2551..9fa8016 100644
--- a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
@@ -20,6 +20,7 @@ package org.apache.lucene.search;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Objects;
 import java.util.Set;
 
 import org.apache.lucene.index.PostingsEnum;
@@ -110,6 +111,7 @@ public class PhraseQuery extends Query {
    * 
    */
   public void add(Term term, int position) {
+    Objects.requireNonNull(term, "Term must not be null");
     if (positions.size() > 0) {
       final int previousPosition = positions.get(positions.size()-1);
       if (position < previousPosition) {
diff --git a/lucene/core/src/java/org/apache/lucene/search/TermQuery.java b/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
index 46b96ef..9269676 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
@@ -18,6 +18,7 @@ package org.apache.lucene.search;
  */
 
 import java.io.IOException;
+import java.util.Objects;
 import java.util.Set;
 
 import org.apache.lucene.index.IndexReaderContext;
@@ -146,7 +147,7 @@ public class TermQuery extends Query {
    * of looking up the docFreq against the searcher.
    */
   public TermQuery(Term t, int docFreq) {
-    term = t;
+    term = Objects.requireNonNull(t, "Term must not be null");
     this.docFreq = docFreq;
     perReaderTermState = null;
   }
@@ -156,10 +157,9 @@ public class TermQuery extends Query {
    * of looking up the docFreq against the searcher.
    */
   public TermQuery(Term t, TermContext states) {
-    assert states != null;
-    term = t;
+    term = Objects.requireNonNull(t, "Term must not be null");
     docFreq = states.docFreq();
-    perReaderTermState = states;
+    perReaderTermState = Objects.requireNonNull(states, "TermContext must not be null");
   }
   
   /** Returns the term of this query. */
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery.java b/lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery.java
index 21c6332..a570df7 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestFilteredQuery.java
@@ -362,20 +362,20 @@ public class TestFilteredQuery extends LuceneTestCase {
   public void testInvalidArguments() throws Exception {
     try {
       new FilteredQuery(null, null);
-      fail("Should throw IllegalArgumentException");
-    } catch (IllegalArgumentException iae) {
+      fail("Should throw NullPointerException");
+    } catch (NullPointerException npe) {
       // pass
     }
     try {
       new FilteredQuery(new TermQuery(new Term("field", "one")), null);
-      fail("Should throw IllegalArgumentException");
-    } catch (IllegalArgumentException iae) {
+      fail("Should throw NullPointerException");
+    } catch (NullPointerException npe) {
       // pass
     }
     try {
       new FilteredQuery(null, new QueryWrapperFilter(new PrefixQuery(new Term("field", "o"))));
-      fail("Should throw IllegalArgumentException");
-    } catch (IllegalArgumentException iae) {
+      fail("Should throw NullPointerException");
+    } catch (NullPointerException npe) {
       // pass
     }
   }
