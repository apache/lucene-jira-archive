From 4f6ea51f013b7b7295512c2666bf2f2c8b66bcae Mon Sep 17 00:00:00 2001
From: Namgyu Kim <kng0828@gmail.com>
Date: Mon, 10 Sep 2018 02:25:03 +0900
Subject: [PATCH] LUCENE-8489: Provide List type constructors for
 BaseCompositeReader based Readers

Signed-off-by: Namgyu Kim <kng0828@gmail.com>
---
 .../lucene/index/BaseCompositeReader.java     | 14 ++++++
 .../apache/lucene/index/DirectoryReader.java  | 14 ++++++
 .../org/apache/lucene/index/MultiReader.java  | 20 ++++++++
 .../lucene/index/ParallelCompositeReader.java | 19 ++++++++
 .../index/TestParallelCompositeReader.java    | 46 ++++++++++++++++++-
 5 files changed, 111 insertions(+), 2 deletions(-)

diff --git a/lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader.java b/lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader.java
index 8a19fe1412..ab18b328fe 100644
--- a/lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader.java
+++ b/lucene/core/src/java/org/apache/lucene/index/BaseCompositeReader.java
@@ -18,6 +18,7 @@ package org.apache.lucene.index;
 
 
 import java.io.IOException;
+import java.lang.reflect.Array;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
@@ -56,6 +57,19 @@ public abstract class BaseCompositeReader<R extends IndexReader> extends Composi
    * for effectiveness the array is used internally. */
   private final List<R> subReadersList;
 
+  /**
+   * Constructs a {@code BaseCompositeReader} on the given subReaders.
+   * @param subReaders the wrapped sub-readers. This List is returned by
+   * {@link #getSequentialSubReaders} and used to resolve the correct
+   * subreader for docID-based methods. <b>Please note:</b> This List is <b>not</b>
+   * cloned and not protected for modification, the subclass is responsible
+   * to do this.
+   */
+  @SuppressWarnings("unchecked")
+  protected BaseCompositeReader(List<R> subReaders) throws IOException {
+    this(subReaders.toArray((R[]) new IndexReader[subReaders.size()]));
+  }
+
   /**
    * Constructs a {@code BaseCompositeReader} on the given subReaders.
    * @param subReaders the wrapped sub-readers. This array is returned by
diff --git a/lucene/core/src/java/org/apache/lucene/index/DirectoryReader.java b/lucene/core/src/java/org/apache/lucene/index/DirectoryReader.java
index 7f65d15c27..cab99218de 100644
--- a/lucene/core/src/java/org/apache/lucene/index/DirectoryReader.java
+++ b/lucene/core/src/java/org/apache/lucene/index/DirectoryReader.java
@@ -329,6 +329,20 @@ public abstract class DirectoryReader extends BaseCompositeReader<LeafReader> {
     return false;
   }
 
+  /**
+   * Expert: Constructs a {@code DirectoryReader} on the given subReaders.
+   * @param segmentReaders the wrapped atomic index segment readers. This List is
+   * returned by {@link #getSequentialSubReaders} and used to resolve the correct
+   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>
+   * cloned and not protected for modification outside of this reader.
+   * Subclasses of {@code DirectoryReader} should take care to not allow
+   * modification of this internal array, e.g. {@link #doOpenIfChanged()}.
+   */
+  protected DirectoryReader(Directory directory, List<LeafReader> segmentReaders) throws IOException {
+    super(segmentReaders);
+    this.directory = directory;
+  }
+
   /**
    * Expert: Constructs a {@code DirectoryReader} on the given subReaders.
    * @param segmentReaders the wrapped atomic index segment readers. This array is
diff --git a/lucene/core/src/java/org/apache/lucene/index/MultiReader.java b/lucene/core/src/java/org/apache/lucene/index/MultiReader.java
index 4d4238290f..fb318d4509 100644
--- a/lucene/core/src/java/org/apache/lucene/index/MultiReader.java
+++ b/lucene/core/src/java/org/apache/lucene/index/MultiReader.java
@@ -18,6 +18,7 @@ package org.apache.lucene.index;
 
 
 import java.io.IOException;
+import java.util.List;
 
 /** A {@link CompositeReader} which reads multiple indexes, appending
  *  their content. It can be used to create a view on several
@@ -49,6 +50,25 @@ public class MultiReader extends BaseCompositeReader<IndexReader> {
     this(subReaders, true);
   }
 
+  /**
+   * <p>Construct a MultiReader aggregating the named set of (sub)readers.
+   * <p>Note that all subreaders are closed if this Multireader is closed.</p>
+   * @param subReaders set of (sub)readers
+   */
+  public MultiReader(List<IndexReader> subReaders) throws IOException {
+    this(subReaders, true);
+  }
+
+  /**
+   * <p>Construct a MultiReader aggregating the named set of (sub)readers.
+   * @param subReaders set of (sub)readers; the data in the list will be cloned.
+   * @param closeSubReaders indicates whether the subreaders should be closed
+   * when this MultiReader is closed
+   */
+  public MultiReader(List<IndexReader> subReaders, boolean closeSubReaders) throws IOException {
+    this(subReaders.toArray(new IndexReader[0]), closeSubReaders);
+  }
+
   /**
    * <p>Construct a MultiReader aggregating the named set of (sub)readers.
    * @param subReaders set of (sub)readers; this array will be cloned.
diff --git a/lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader.java b/lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader.java
index 4fc8a20458..64c7ea3914 100644
--- a/lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader.java
+++ b/lucene/core/src/java/org/apache/lucene/index/ParallelCompositeReader.java
@@ -59,12 +59,31 @@ public class ParallelCompositeReader extends BaseCompositeReader<LeafReader> {
     this(true, readers);
   }
 
+  /** Create a ParallelCompositeReader based on the provided
+   *  readers; auto-closes the given readers on {@link #close()}. */
+  public ParallelCompositeReader(List<CompositeReader> readers) throws IOException {
+    this(true, readers);
+  }
+
+  /** Create a ParallelCompositeReader based on the provided
+   *  readers. */
+  public ParallelCompositeReader(boolean closeSubReaders, List<CompositeReader> readers) throws IOException {
+    this(closeSubReaders, readers, readers);
+  }
+
   /** Create a ParallelCompositeReader based on the provided
    *  readers. */
   public ParallelCompositeReader(boolean closeSubReaders, CompositeReader... readers) throws IOException {
     this(closeSubReaders, readers, readers);
   }
 
+  /** Expert: create a ParallelCompositeReader based on the provided
+   *  readers and storedFieldReaders; when a document is
+   *  loaded, only storedFieldsReaders will be used. */
+  public ParallelCompositeReader(boolean closeSubReaders, List<CompositeReader> readers, List<CompositeReader> storedFieldReaders) throws IOException {
+    this(closeSubReaders, readers.toArray(new CompositeReader[0]), storedFieldReaders.toArray(new CompositeReader[0]));
+  }
+
   /** Expert: create a ParallelCompositeReader based on the provided
    *  readers and storedFieldReaders; when a document is
    *  loaded, only storedFieldsReaders will be used. */
diff --git a/lucene/core/src/test/org/apache/lucene/index/TestParallelCompositeReader.java b/lucene/core/src/test/org/apache/lucene/index/TestParallelCompositeReader.java
index d45230687b..82f6a54b6d 100644
--- a/lucene/core/src/test/org/apache/lucene/index/TestParallelCompositeReader.java
+++ b/lucene/core/src/test/org/apache/lucene/index/TestParallelCompositeReader.java
@@ -18,6 +18,8 @@ package org.apache.lucene.index;
 
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Random;
 
 import org.apache.lucene.analysis.MockAnalyzer;
@@ -35,17 +37,19 @@ import org.apache.lucene.util.LuceneTestCase;
 
 public class TestParallelCompositeReader extends LuceneTestCase {
 
-  private IndexSearcher parallel, single;
+  private IndexSearcher parallel, single, listAPI;
   private Directory dir, dir1, dir2;
 
   public void testQueries() throws Exception {
     single = single(random(), false);
     parallel = parallel(random(), false);
-    
+    listAPI = list(random(), false);
+
     queries();
     
     single.getIndexReader().close(); single = null;
     parallel.getIndexReader().close(); parallel = null;
+    listAPI.getIndexReader().close(); listAPI = null;
     dir.close(); dir = null;
     dir1.close(); dir1 = null;
     dir2.close(); dir2 = null;
@@ -54,11 +58,13 @@ public class TestParallelCompositeReader extends LuceneTestCase {
   public void testQueriesCompositeComposite() throws Exception {
     single = single(random(), true);
     parallel = parallel(random(), true);
+    listAPI = list(random(), true);
     
     queries();
     
     single.getIndexReader().close(); single = null;
     parallel.getIndexReader().close(); parallel = null;
+    listAPI.getIndexReader().close(); listAPI = null;
     dir.close(); dir = null;
     dir1.close(); dir1 = null;
     dir2.close(); dir2 = null;
@@ -357,15 +363,24 @@ public class TestParallelCompositeReader extends LuceneTestCase {
   private void queryTest(Query query) throws IOException {
     ScoreDoc[] parallelHits = parallel.search(query, 1000).scoreDocs;
     ScoreDoc[] singleHits = single.search(query, 1000).scoreDocs;
+    ScoreDoc[] listHits = listAPI.search(query, 1000).scoreDocs;
     assertEquals(parallelHits.length, singleHits.length);
+    assertEquals(parallelHits.length, listHits.length);
     for(int i = 0; i < parallelHits.length; i++) {
       assertEquals(parallelHits[i].score, singleHits[i].score, 0.001f);
+      assertEquals(parallelHits[i].score, listHits[i].score, 0.001f);
       Document docParallel = parallel.doc(parallelHits[i].doc);
       Document docSingle = single.doc(singleHits[i].doc);
+      Document docList = listAPI.doc(listHits[i].doc);
       assertEquals(docParallel.get("f1"), docSingle.get("f1"));
       assertEquals(docParallel.get("f2"), docSingle.get("f2"));
       assertEquals(docParallel.get("f3"), docSingle.get("f3"));
       assertEquals(docParallel.get("f4"), docSingle.get("f4"));
+
+      assertEquals(docParallel.get("f1"), docList.get("f1"));
+      assertEquals(docParallel.get("f2"), docList.get("f2"));
+      assertEquals(docParallel.get("f3"), docList.get("f3"));
+      assertEquals(docParallel.get("f4"), docList.get("f4"));
     }
   }
 
@@ -428,6 +443,33 @@ public class TestParallelCompositeReader extends LuceneTestCase {
     return newSearcher(pr);
   }
 
+  // Fields 1 & 2 in one index, 3 & 4 in other, with ParallelReader (using List):
+  private IndexSearcher list(Random random, boolean compositeComposite) throws IOException {
+    List<IndexReader> dirReaderList = new ArrayList<>();
+    List<IndexReader> dirReaderList2 = new ArrayList<>();
+    final CompositeReader rd1, rd2;
+    if (compositeComposite) {
+      dirReaderList.add(DirectoryReader.open(dir1));
+      dirReaderList.add(DirectoryReader.open(dir1));
+      dirReaderList2.add(DirectoryReader.open(dir2));
+      dirReaderList2.add(DirectoryReader.open(dir2));
+      rd1 = new MultiReader(dirReaderList);
+      rd2 = new MultiReader(dirReaderList2);
+      assertEquals(2, rd1.getContext().children().size());
+      assertEquals(2, rd2.getContext().children().size());
+    } else {
+      rd1 = DirectoryReader.open(dir1);
+      rd2 = DirectoryReader.open(dir2);
+      assertEquals(3, rd1.getContext().children().size());
+      assertEquals(3, rd2.getContext().children().size());
+    }
+    List<CompositeReader> compReaderList = new ArrayList<>();
+    compReaderList.add(rd1);
+    compReaderList.add(rd2);
+    ParallelCompositeReader pr = new ParallelCompositeReader(compReaderList);
+    return newSearcher(pr);
+  }
+
   // subreader structure: (1,2,1) 
   private Directory getDir1(Random random) throws IOException {
     Directory dir1 = newDirectory();
-- 
2.18.0.windows.1

