diff --git a/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java b/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
index 1cc6053..5e06eaa 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
@@ -23,8 +23,14 @@ import java.util.Comparator;
 import java.util.List;
 
 import org.apache.lucene.util.CollectionUtil;
+import org.apache.lucene.search.spans.SpansEnum;
 
-class ConjunctionDISI extends DocIdSetIterator {
+/** A conjunction of DocIdSetIterators.
+ * This iterates over the doc ids that are present in each given DocIdSetIterator.
+ * <br>Public only for use in {@link org.apache.lucene.search.spans}.
+ * @lucene.internal
+ */
+public class ConjunctionDISI extends DocIdSetIterator {
 
   /** Create a conjunction over the provided iterators, taking advantage of
    *  {@link TwoPhaseIterator}. */
@@ -32,18 +38,16 @@ class ConjunctionDISI extends DocIdSetIterator {
     final List<DocIdSetIterator> allIterators = new ArrayList<>();
     final List<TwoPhaseIterator> twoPhaseIterators = new ArrayList<>();
     for (DocIdSetIterator iterator : iterators) {
-      if (iterator instanceof Scorer) {
-        // if we have a scorer, check if it supports two-phase iteration
-        TwoPhaseIterator twoPhaseIterator = ((Scorer) iterator).asTwoPhaseIterator();
-        if (twoPhaseIterator != null) {
-          // Note: 
-          allIterators.add(twoPhaseIterator.approximation());
-          twoPhaseIterators.add(twoPhaseIterator);
-        } else {
-          allIterators.add(iterator);
-        }
-      } else {
-        // no approximation support, use the iterator as-is
+      TwoPhaseIterator twoPhaseIterator = null;
+      if (iterator instanceof Scorer) { 
+        twoPhaseIterator = ((Scorer) iterator).asTwoPhaseIterator();
+      } else if (iterator instanceof SpansEnum) {
+        twoPhaseIterator = ((SpansEnum) iterator).asTwoPhaseIterator();
+      }
+      if (twoPhaseIterator != null) {
+        allIterators.add(twoPhaseIterator.approximation());
+        twoPhaseIterators.add(twoPhaseIterator);
+      } else { // no approximation support, use the iterator as-is
         allIterators.add(iterator);
       }
     }
diff --git a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java
index e46bb45..0ecd738 100644
--- a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java
@@ -54,7 +54,10 @@ import org.apache.lucene.util.ToStringUtils;
  * Payload scores are aggregated using a pluggable {@link PayloadFunction}.
  * 
  * @see org.apache.lucene.search.similarities.Similarity.SimScorer#computePayloadFactor(int, int, int, BytesRef)
+ *
+ * @deprecated Use {@link PayloadSpansEnumNearQuery} instead.
  */
+@Deprecated
 public class PayloadNearQuery extends SpanNearQuery {
   protected String fieldName;
   protected PayloadFunction function;
diff --git a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
index 0329acc..4e1f110 100644
--- a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
+++ b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
@@ -52,7 +52,9 @@ import org.apache.lucene.search.spans.Spans;
  *
  * @lucene.experimental
  * 
+ * @deprecated Use {@link PayloadSpansEnumUtil} instead.
  */
+@Deprecated
 public class PayloadSpanUtil {
   private IndexReaderContext context;
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpansEnumNearQuery.java b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpansEnumNearQuery.java
new file mode 100644
index 0000000..1145c4c
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpansEnumNearQuery.java
@@ -0,0 +1,269 @@
+package org.apache.lucene.search.payloads;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Iterator;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.search.ComplexExplanation;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.search.similarities.Similarity.SimScorer;
+import org.apache.lucene.search.spans.NearSpansEnumOrdered;
+import org.apache.lucene.search.spans.NearSpansEnumUnordered;
+import org.apache.lucene.search.spans.SpansEnumNearQuery;
+import org.apache.lucene.search.spans.SpansEnumQuery;
+import org.apache.lucene.search.spans.SpansEnumScorer;
+import org.apache.lucene.search.spans.SpansEnumWeight;
+import org.apache.lucene.search.spans.SpansEnum;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.ToStringUtils;
+
+/**
+ * This class is very similar to
+ * {@link org.apache.lucene.search.spans.SpansEnumNearQuery} except that it factors
+ * in the value of the payloads located at each of the positions where the
+ * {@link org.apache.lucene.search.spans.TermSpansEnum} occurs.
+ * <p>
+ * NOTE: In order to take advantage of this with the default scoring implementation
+ * ({@link DefaultSimilarity}), you must override {@link DefaultSimilarity#scorePayload(int, int, int, BytesRef)},
+ * which returns 1 by default.
+ * <p>
+ * Payload scores are aggregated using a pluggable {@link PayloadFunction}.
+ * 
+ * @see org.apache.lucene.search.similarities.Similarity.SimScorer#computePayloadFactor(int, int, int, BytesRef)
+ */
+public class PayloadSpansEnumNearQuery extends SpansEnumNearQuery {
+  protected String fieldName;
+  protected PayloadFunction function;
+
+  public PayloadSpansEnumNearQuery(SpansEnumQuery[] clauses, int slop, boolean inOrder) {
+    this(clauses, slop, inOrder, new AveragePayloadFunction());
+  }
+
+  public PayloadSpansEnumNearQuery(SpansEnumQuery[] clauses, int slop, boolean inOrder,
+      PayloadFunction function) {
+    super(clauses, slop, inOrder);
+    fieldName = clauses[0].getField(); // all clauses must have same field
+    this.function = function;
+  }
+
+  @Override
+  public SpansEnumWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    return new PayloadNearSpansEnumWeight(this, searcher);
+  }
+
+  @Override
+  public PayloadSpansEnumNearQuery clone() {
+    int sz = clauses.size();
+    SpansEnumQuery[] newClauses = new SpansEnumQuery[sz];
+
+    for (int i = 0; i < sz; i++) {
+      newClauses[i] = (SpansEnumQuery) clauses.get(i).clone();
+    }
+    PayloadSpansEnumNearQuery boostingNearQuery = new PayloadSpansEnumNearQuery(newClauses, slop,
+        inOrder, function);
+    boostingNearQuery.setBoost(getBoost());
+    return boostingNearQuery;
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("payloadNearSpansEnum([");
+    Iterator<SpansEnumQuery> i = clauses.iterator();
+    while (i.hasNext()) {
+      SpansEnumQuery clause = i.next();
+      buffer.append(clause.toString(field));
+      if (i.hasNext()) {
+        buffer.append(", ");
+      }
+    }
+    buffer.append("], ");
+    buffer.append(slop);
+    buffer.append(", ");
+    buffer.append(inOrder);
+    buffer.append(")");
+    buffer.append(ToStringUtils.boost(getBoost()));
+    return buffer.toString();
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = super.hashCode() ^ getClass().hashCode();
+    result = prime * result + ((fieldName == null) ? 0 : fieldName.hashCode());
+    result = prime * result + ((function == null) ? 0 : function.hashCode());
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj)
+      return true;
+    if (!super.equals(obj))
+      return false;
+    if (getClass() != obj.getClass())
+      return false;
+    PayloadSpansEnumNearQuery other = (PayloadSpansEnumNearQuery) obj;
+    if (fieldName == null) {
+      if (other.fieldName != null)
+        return false;
+    } else if (!fieldName.equals(other.fieldName))
+      return false;
+    if (function == null) {
+      if (other.function != null)
+        return false;
+    } else if (!function.equals(other.function))
+      return false;
+    return true;
+  }
+
+  public class PayloadNearSpansEnumWeight extends SpansEnumWeight {
+    public PayloadNearSpansEnumWeight(SpansEnumQuery query, IndexSearcher searcher)
+        throws IOException {
+      super(query, searcher);
+    }
+
+    @Override
+    public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
+      SpansEnum spans = query.getSpans(context, acceptDocs, termContexts);
+      return (spans == null)
+              ? null
+              : new PayloadNearSpansEnumScorer(spans, this, similarity, similarity.simScorer(stats, context));
+    }
+    
+    @Override
+    public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+      PayloadNearSpansEnumScorer scorer = (PayloadNearSpansEnumScorer) scorer(context, context.reader().getLiveDocs());
+      if (scorer != null) {
+        int newDoc = scorer.advance(doc);
+        if (newDoc == doc) {
+          float freq = scorer.freq();
+          SimScorer docScorer = similarity.simScorer(stats, context);
+          Explanation expl = new Explanation();
+          expl.setDescription("weight("+getQuery()+" in "+doc+") [" + similarity.getClass().getSimpleName() + "], result of:");
+          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, "phraseFreq=" + freq));
+          expl.addDetail(scoreExplanation);
+          expl.setValue(scoreExplanation.getValue());
+          String field = ((SpansEnumQuery)getQuery()).getField();
+          // now the payloads part
+          Explanation payloadExpl = function.explain(doc, field, scorer.payloadsSeen, scorer.payloadScore);
+          // combined
+          ComplexExplanation result = new ComplexExplanation();
+          result.addDetail(expl);
+          result.addDetail(payloadExpl);
+          result.setValue(expl.getValue() * payloadExpl.getValue());
+          result.setDescription("PayloadNearSpansEnumQuery, product of:");
+          return result;
+        }
+      }
+      
+      return new ComplexExplanation(false, 0.0f, "no matching term");
+    }
+  }
+
+  public class PayloadNearSpansEnumScorer extends SpansEnumScorer {
+    SpansEnum spans;
+    protected float payloadScore;
+    private int payloadsSeen;
+
+    protected PayloadNearSpansEnumScorer(SpansEnum spans, SpansEnumWeight weight,
+        Similarity similarity, Similarity.SimScorer docScorer) throws IOException {
+      super(spans, weight, docScorer);
+      this.spans = spans;
+    }
+
+    // Get the payloads associated with all underlying subspans
+    public void getPayloads(SpansEnum[] subSpans) throws IOException {
+      for (int i = 0; i < subSpans.length; i++) {
+        if (subSpans[i] instanceof NearSpansEnumOrdered) {
+          if (((NearSpansEnumOrdered) subSpans[i]).isPayloadAvailable()) {
+            processPayloads(((NearSpansEnumOrdered) subSpans[i]).getPayload(),
+                subSpans[i].startPosition(), subSpans[i].endPosition());
+          }
+          getPayloads(((NearSpansEnumOrdered) subSpans[i]).getSubSpans());
+        } else if (subSpans[i] instanceof NearSpansEnumUnordered) {
+          if (((NearSpansEnumUnordered) subSpans[i]).isPayloadAvailable()) {
+            processPayloads(((NearSpansEnumUnordered) subSpans[i]).getPayload(),
+                subSpans[i].startPosition(), subSpans[i].endPosition());
+          }
+          getPayloads(((NearSpansEnumUnordered) subSpans[i]).getSubSpans());
+        }
+      }
+    }
+
+    // TODO change the whole spans api to use bytesRef, or nuke spans
+    BytesRef scratch = new BytesRef();
+
+    /**
+     * By default, uses the {@link PayloadFunction} to score the payloads, but
+     * can be overridden to do other things.
+     * 
+     * @param payLoads The payloads
+     * @param start The start position of the span being scored
+     * @param end The end position of the span being scored
+     * 
+     * @see SpansEnum
+     */
+    protected void processPayloads(Collection<byte[]> payLoads, int start, int end) {
+      for (final byte[] thePayload : payLoads) {
+        scratch.bytes = thePayload;
+        scratch.offset = 0;
+        scratch.length = thePayload.length;
+        payloadScore = function.currentScore(doc, fieldName, start, end,
+            payloadsSeen, payloadScore, docScorer.computePayloadFactor(doc,
+                spans.startPosition(), spans.endPosition(), scratch));
+        ++payloadsSeen;
+      }
+    }
+
+    //
+    @Override
+    protected boolean setFreqCurrentDoc() throws IOException {
+      freq = 0.0f;
+      payloadScore = 0;
+      payloadsSeen = 0;
+      int startPos = spans.nextStartPosition();
+      assert startPos != SpansEnum.NO_MORE_POSITIONS : "initial startPos NO_MORE_POSITIONS, spans="+spans;
+      do {
+        int matchLength = spans.endPosition() - startPos;
+        freq += docScorer.computeSlopFactor(matchLength);
+        SpansEnum[] spansArr = new SpansEnum[1];
+        spansArr[0] = spans;
+        getPayloads(spansArr);            
+        startPos = spans.nextStartPosition();
+      } while (startPos != SpansEnum.NO_MORE_POSITIONS);
+      return true;
+    }
+
+    @Override
+    public float score() throws IOException {
+
+      return super.score()
+          * function.docScore(doc, fieldName, payloadsSeen, payloadScore);
+    }
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpansEnumTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpansEnumTermQuery.java
new file mode 100644
index 0000000..a7fa8d7
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpansEnumTermQuery.java
@@ -0,0 +1,246 @@
+package org.apache.lucene.search.payloads;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.ComplexExplanation;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.search.similarities.Similarity.SimScorer;
+import org.apache.lucene.search.spans.SpansEnum;
+import org.apache.lucene.search.spans.SpansEnumQuery;
+import org.apache.lucene.search.spans.SpansEnumScorer;
+import org.apache.lucene.search.spans.SpansEnumTermQuery;
+import org.apache.lucene.search.spans.SpansEnumWeight;
+import org.apache.lucene.search.spans.TermSpansEnum;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * This class is very similar to
+ * {@link org.apache.lucene.search.spans.SpansEnumTermQuery} except that it factors
+ * in the value of the payload located at each of the positions where the
+ * {@link org.apache.lucene.index.Term} occurs.
+ * <p>
+ * NOTE: In order to take advantage of this with the default scoring implementation
+ * ({@link DefaultSimilarity}), you must override {@link DefaultSimilarity#scorePayload(int, int, int, BytesRef)},
+ * which returns 1 by default.
+ * <p>
+ * Payload scores are aggregated using a pluggable {@link PayloadFunction}.
+ * @see org.apache.lucene.search.similarities.Similarity.SimScorer#computePayloadFactor(int, int, int, BytesRef)
+ **/
+public class PayloadSpansEnumTermQuery extends SpansEnumTermQuery {
+  protected PayloadFunction function;
+  private boolean includeSpanScore;
+
+  public PayloadSpansEnumTermQuery(Term term, PayloadFunction function) {
+    this(term, function, true);
+  }
+
+  public PayloadSpansEnumTermQuery(Term term, PayloadFunction function,
+                                    boolean includeSpanScore) {
+    super(term);
+    this.function = function;
+    this.includeSpanScore = includeSpanScore;
+  }
+
+  @Override
+  public SpansEnumWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    return new PayloadSpansEnumTermWeight(this, searcher);
+  }
+
+  protected class PayloadSpansEnumTermWeight extends SpansEnumWeight {
+
+    public PayloadSpansEnumTermWeight(PayloadSpansEnumTermQuery query, IndexSearcher searcher)
+        throws IOException {
+      super(query, searcher);
+    }
+
+    @Override
+    public PayloadTermSpansEnumScorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
+      TermSpansEnum spans = (TermSpansEnum) query.getSpans(context, acceptDocs, termContexts);
+      return (spans == null)
+              ? null
+              : new PayloadTermSpansEnumScorer(spans, this, similarity.simScorer(stats, context));
+    }
+
+    protected class PayloadTermSpansEnumScorer extends SpansEnumScorer {
+      protected BytesRef payload;
+      protected float payloadScore;
+      protected int payloadsSeen;
+      private final TermSpansEnum termSpans;
+
+      public PayloadTermSpansEnumScorer(TermSpansEnum spans, SpansEnumWeight weight, Similarity.SimScorer docScorer) throws IOException {
+        super(spans, weight, docScorer);
+        termSpans = spans;
+      }
+
+      @Override
+      protected boolean setFreqCurrentDoc() throws IOException {
+        freq = 0.0f;
+        numMatches = 0;
+        payloadScore = 0;
+        payloadsSeen = 0;
+        int startPos = spans.nextStartPosition();
+        assert startPos != SpansEnum.NO_MORE_POSITIONS : "initial startPos NO_MORE_POSITIONS, spans="+spans;
+        do {
+          int matchLength = spans.endPosition() - startPos;
+
+          freq += docScorer.computeSlopFactor(matchLength);
+          numMatches++;
+          processPayload(similarity);
+
+          startPos = spans.nextStartPosition();
+        } while (startPos != SpansEnum.NO_MORE_POSITIONS);
+        return freq != 0;
+      }
+
+      protected void processPayload(Similarity similarity) throws IOException {
+        if (termSpans.isPayloadAvailable()) {
+          final PostingsEnum postings = termSpans.getPostings();
+          payload = postings.getPayload();
+          if (payload != null) {
+            payloadScore = function.currentScore(doc, term.field(),
+                                                 spans.startPosition(), spans.endPosition(), payloadsSeen, payloadScore,
+                                                 docScorer.computePayloadFactor(doc, spans.startPosition(), spans.endPosition(), payload));
+          } else {
+            payloadScore = function.currentScore(doc, term.field(),
+                                                 spans.startPosition(), spans.endPosition(), payloadsSeen, payloadScore, 1F);
+          }
+          payloadsSeen++;
+
+        } else {
+          // zero out the payload?
+        }
+      }
+
+      /**
+       * 
+       * @return {@link #getSpanScore()} * {@link #getPayloadScore()}
+       * @throws IOException if there is a low-level I/O error
+       */
+      @Override
+      public float score() throws IOException {
+
+        return includeSpanScore ? getSpanScore() * getPayloadScore()
+            : getPayloadScore();
+      }
+
+      /**
+       * Returns the SpanScorer score only.
+       * <p>
+       * Should not be overridden without good cause!
+       * 
+       * @return the score for just the Span part w/o the payload
+       * @throws IOException if there is a low-level I/O error
+       * 
+       * @see #score()
+       */
+      protected float getSpanScore() throws IOException {
+        return super.score();
+      }
+
+      /**
+       * The score for the payload
+       * 
+       * @return The score, as calculated by
+       *         {@link PayloadFunction#docScore(int, String, int, float)}
+       */
+      protected float getPayloadScore() {
+        return function.docScore(doc, term.field(), payloadsSeen, payloadScore);
+      }
+    }
+    
+    @Override
+    public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+      PayloadTermSpansEnumScorer scorer = scorer(context, context.reader().getLiveDocs());
+      if (scorer != null) {
+        int newDoc = scorer.advance(doc);
+        if (newDoc == doc) {
+          float freq = scorer.sloppyFreq();
+          SimScorer docScorer = similarity.simScorer(stats, context);
+          Explanation expl = new Explanation();
+          expl.setDescription("weight("+getQuery()+" in "+doc+") [" + similarity.getClass().getSimpleName() + "], result of:");
+          Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, "phraseFreq=" + freq));
+          expl.addDetail(scoreExplanation);
+          expl.setValue(scoreExplanation.getValue());
+          // now the payloads part
+          // QUESTION: Is there a way to avoid this skipTo call? We need to know
+          // whether to load the payload or not
+          // GSI: I suppose we could toString the payload, but I don't think that
+          // would be a good idea
+          String field = ((SpansEnumQuery)getQuery()).getField();
+          Explanation payloadExpl = function.explain(doc, field, scorer.payloadsSeen, scorer.payloadScore);
+          payloadExpl.setValue(scorer.getPayloadScore());
+          // combined
+          ComplexExplanation result = new ComplexExplanation();
+          if (includeSpanScore) {
+            result.addDetail(expl);
+            result.addDetail(payloadExpl);
+            result.setValue(expl.getValue() * payloadExpl.getValue());
+            result.setDescription("btq, product of:");
+          } else {
+            result.addDetail(payloadExpl);
+            result.setValue(payloadExpl.getValue());
+            result.setDescription("btq(includeSpanScore=false), result of:");
+          }
+          result.setMatch(true); // LUCENE-1303
+          return result;
+        }
+      }
+      
+      return new ComplexExplanation(false, 0.0f, "no matching term");
+    }
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = super.hashCode();
+    result = prime * result + ((function == null) ? 0 : function.hashCode());
+    result = prime * result + (includeSpanScore ? 1231 : 1237);
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj)
+      return true;
+    if (!super.equals(obj))
+      return false;
+    if (getClass() != obj.getClass())
+      return false;
+    PayloadSpansEnumTermQuery other = (PayloadSpansEnumTermQuery) obj;
+    if (function == null) {
+      if (other.function != null)
+        return false;
+    } else if (!function.equals(other.function))
+      return false;
+    if (includeSpanScore != other.includeSpanScore)
+      return false;
+    return true;
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpansEnumUtil.java b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpansEnumUtil.java
new file mode 100644
index 0000000..dc75399
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadSpansEnumUtil.java
@@ -0,0 +1,203 @@
+package org.apache.lucene.search.payloads;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeSet;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.DisjunctionMaxQuery;
+import org.apache.lucene.search.FilteredQuery;
+import org.apache.lucene.search.MultiPhraseQuery;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.spans.SpansEnumNearQuery;
+import org.apache.lucene.search.spans.SpansEnumOrQuery;
+import org.apache.lucene.search.spans.SpansEnumQuery;
+import org.apache.lucene.search.spans.SpansEnumTermQuery;
+import org.apache.lucene.search.spans.SpansEnum;
+
+/**
+ * Experimental class to get set of payloads for most standard Lucene queries.
+ * Operates like Highlighter - IndexReader should only contain doc of interest,
+ * best to use MemoryIndex.
+ *
+ * @lucene.experimental
+ * 
+ */
+public class PayloadSpansEnumUtil {
+  private IndexReaderContext context;
+
+  /**
+   * @param context
+   *          that contains doc with payloads to extract
+   *          
+   * @see IndexReader#getContext()
+   */
+  public PayloadSpansEnumUtil(IndexReaderContext context) {
+    this.context = context;
+  }
+
+  /**
+   * Query should be rewritten for wild/fuzzy support.
+   * 
+   * @param query rewritten query
+   * @return payloads Collection
+   * @throws IOException if there is a low-level I/O error
+   */
+  public Collection<byte[]> getPayloadsForQuery(Query query) throws IOException {
+    Collection<byte[]> payloads = new ArrayList<>();
+    queryToSpansEnumQuery(query, payloads);
+    return payloads;
+  }
+
+  private void queryToSpansEnumQuery(Query query, Collection<byte[]> payloads)
+      throws IOException {
+    if (query instanceof BooleanQuery) {
+      BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();
+
+      for (int i = 0; i < queryClauses.length; i++) {
+        if (!queryClauses[i].isProhibited()) {
+          queryToSpansEnumQuery(queryClauses[i].getQuery(), payloads);
+        }
+      }
+
+    } else if (query instanceof PhraseQuery) {
+      Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();
+      SpansEnumQuery[] clauses = new SpansEnumQuery[phraseQueryTerms.length];
+      for (int i = 0; i < phraseQueryTerms.length; i++) {
+        clauses[i] = new SpansEnumTermQuery(phraseQueryTerms[i]);
+      }
+
+      int slop = ((PhraseQuery) query).getSlop();
+      boolean inorder = false;
+
+      if (slop == 0) {
+        inorder = true;
+      }
+
+      SpansEnumNearQuery sp = new SpansEnumNearQuery(clauses, slop, inorder);
+      sp.setBoost(query.getBoost());
+      getPayloads(payloads, sp);
+    } else if (query instanceof TermQuery) {
+      SpansEnumTermQuery stq = new SpansEnumTermQuery(((TermQuery) query).getTerm());
+      stq.setBoost(query.getBoost());
+      getPayloads(payloads, stq);
+    } else if (query instanceof SpansEnumQuery) {
+      getPayloads(payloads, (SpansEnumQuery) query);
+    } else if (query instanceof FilteredQuery) {
+      queryToSpansEnumQuery(((FilteredQuery) query).getQuery(), payloads);
+    } else if (query instanceof DisjunctionMaxQuery) {
+
+      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator
+          .hasNext();) {
+        queryToSpansEnumQuery(iterator.next(), payloads);
+      }
+
+    } else if (query instanceof MultiPhraseQuery) {
+      final MultiPhraseQuery mpq = (MultiPhraseQuery) query;
+      final List<Term[]> termArrays = mpq.getTermArrays();
+      final int[] positions = mpq.getPositions();
+      if (positions.length > 0) {
+
+        int maxPosition = positions[positions.length - 1];
+        for (int i = 0; i < positions.length - 1; ++i) {
+          if (positions[i] > maxPosition) {
+            maxPosition = positions[i];
+          }
+        }
+
+        @SuppressWarnings({"rawtypes","unchecked"}) final List<Query>[] disjunctLists =
+            new List[maxPosition + 1];
+        int distinctPositions = 0;
+
+        for (int i = 0; i < termArrays.size(); ++i) {
+          final Term[] termArray = termArrays.get(i);
+          List<Query> disjuncts = disjunctLists[positions[i]];
+          if (disjuncts == null) {
+            disjuncts = (disjunctLists[positions[i]] = new ArrayList<>(
+                termArray.length));
+            ++distinctPositions;
+          }
+          for (final Term term : termArray) {
+            disjuncts.add(new SpansEnumTermQuery(term));
+          }
+        }
+
+        int positionGaps = 0;
+        int position = 0;
+        final SpansEnumQuery[] clauses = new SpansEnumQuery[distinctPositions];
+        for (int i = 0; i < disjunctLists.length; ++i) {
+          List<Query> disjuncts = disjunctLists[i];
+          if (disjuncts != null) {
+            clauses[position++] = new SpansEnumOrQuery(disjuncts
+                .toArray(new SpansEnumQuery[disjuncts.size()]));
+          } else {
+            ++positionGaps;
+          }
+        }
+
+        final int slop = mpq.getSlop();
+        final boolean inorder = (slop == 0);
+
+        SpansEnumNearQuery sp = new SpansEnumNearQuery(clauses, slop + positionGaps,
+                                                      inorder);
+        sp.setBoost(query.getBoost());
+        getPayloads(payloads, sp);
+      }
+    }
+  }
+
+  private void getPayloads(Collection<byte []> payloads, SpansEnumQuery query)
+      throws IOException {
+    Map<Term,TermContext> termContexts = new HashMap<>();
+    TreeSet<Term> terms = new TreeSet<>();
+    query.extractTerms(terms);
+    for (Term term : terms) {
+      termContexts.put(term, TermContext.build(context, term));
+    }
+    for (LeafReaderContext leafReaderContext : context.leaves()) {
+      final SpansEnum spans = query.getSpans(leafReaderContext, leafReaderContext.reader().getLiveDocs(), termContexts);
+      if (spans != null) {
+        while (spans.nextDoc() != SpansEnum.NO_MORE_DOCS) {
+          while (spans.nextStartPosition() != SpansEnum.NO_MORE_POSITIONS) {
+            if (spans.isPayloadAvailable()) {
+              Collection<byte[]> payload = spans.getPayload();
+              for (byte [] bytes : payload) {
+                payloads.add(bytes);
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java
index 463a6a0..9918edd 100644
--- a/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java
@@ -50,7 +50,9 @@ import org.apache.lucene.util.BytesRef;
  * <p>
  * Payload scores are aggregated using a pluggable {@link PayloadFunction}.
  * @see org.apache.lucene.search.similarities.Similarity.SimScorer#computePayloadFactor(int, int, int, BytesRef)
+ * @deprecated Use {@link PayloadSpansEnumTermQuery} instead.
  **/
+@Deprecated
 public class PayloadTermQuery extends SpanTermQuery {
   protected PayloadFunction function;
   private boolean includeSpanScore;
diff --git a/lucene/core/src/java/org/apache/lucene/search/payloads/package-info.java b/lucene/core/src/java/org/apache/lucene/search/payloads/package-info.java
index 51bd982..c2ca55a 100644
--- a/lucene/core/src/java/org/apache/lucene/search/payloads/package-info.java
+++ b/lucene/core/src/java/org/apache/lucene/search/payloads/package-info.java
@@ -20,9 +20,12 @@
  * <p>
  *   The following Query implementations are provided:
  *   <ol>
- *    <li>{@link org.apache.lucene.search.payloads.PayloadTermQuery PayloadTermQuery} -- Boost a term's score based on the value of the payload located at that term.</li>
- *    <li>{@link org.apache.lucene.search.payloads.PayloadNearQuery PayloadNearQuery} -- A {@link org.apache.lucene.search.spans.SpanNearQuery SpanNearQuery} that factors in the value of the payloads located 
- *        at each of the positions where the spans occur.</li>
+ *    <li>{@link org.apache.lucene.search.payloads.PayloadSpansEnumTermQuery PayloadSpansEnumTermQuery} 
+ *         -- Boost a term's score based on the value of the payload located at that term.</li>
+ *    <li> {@link org.apache.lucene.search.payloads.PayloadSpansEnumNearQuery PayloadSpansEnumNearQuery} 
+ *         -- A {@link org.apache.lucene.search.spans.SpansEnumNearQuery SpansEnumNearQuery}
+ *            that factors in the value of the payloads located 
+ *            at each of the positions where the spans occur.</li>
  *   </ol>
  */
 package org.apache.lucene.search.payloads;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
index 9b740f6..736d061 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
@@ -73,7 +73,9 @@ import org.apache.lucene.util.ToStringUtils;
  * done using the Similarity and collection statistics of the field name supplied,
  * but with the term statistics of the real field. This may lead to exceptions,
  * poor performance, and unexpected scoring behaviour.
+ * @deprecated Use {@link FieldMaskingSpansEnumQuery} instead.
  */
+@Deprecated
 public class FieldMaskingSpanQuery extends SpanQuery {
   private SpanQuery maskedQuery;
   private String field;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpansEnumQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpansEnumQuery.java
new file mode 100644
index 0000000..01ead19
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/FieldMaskingSpansEnumQuery.java
@@ -0,0 +1,158 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.ToStringUtils;
+
+/**
+ * <p>Wrapper to allow {@link SpansEnumQuery} objects participate in composite
+ * single-field SpansEnumQueries by 'lying' about their search field. That is,
+ * the masked SpansEnumQuery will function as normal,
+ * but {@link SpansEnumQuery#getField()} simply hands back the value supplied
+ * in this class's constructor.</p>
+ *
+ * <p>This can be used to support Queries like {@link SpansEnumNearQuery} or
+ * {@link SpansEnumOrQuery} across different fields, which is not ordinarily
+ * permitted.</p>
+ *
+ * <p>This can be useful for denormalized relational data: for example, when
+ * indexing a document with conceptually many 'children': </p>
+ *
+ * <pre>
+ *  teacherid: 1
+ *  studentfirstname: james
+ *  studentsurname: jones
+ *
+ *  teacherid: 2
+ *  studenfirstname: james
+ *  studentsurname: smith
+ *  studentfirstname: sally
+ *  studentsurname: jones
+ * </pre>
+ *
+ * <p>a SpansEnumNearQuery with a slop of 0 can be applied across two
+ * {@link SpansEnumTermQuery} objects as follows:
+ * <pre class="prettyprint">
+ *    SpansEnumQuery q1  = new SpansEnumTermQuery(new Term("studentfirstname", "james"));
+ *    SpansEnumQuery q2  = new SpansEnumTermQuery(new Term("studentsurname", "jones"));
+ *    SpansEnumQuery q2m = new FieldMaskingSpansEnumQuery(q2, "studentfirstname");
+ *    Query q = new SpansEnumNearQuery(new SpansEnumQuery[]{q1, q2m}, -1, false);
+ * </pre>
+ * to search for 'studentfirstname:james studentsurname:jones' and find
+ * teacherid 1 without matching teacherid 2 (which has a 'james' in position 0
+ * and 'jones' in position 1).
+ *
+ * <p>Note: as {@link #getField()} returns the masked field, scoring will be
+ * done using the Similarity and collection statistics of the field name supplied,
+ * but with the term statistics of the real field. This may lead to exceptions,
+ * poor performance, and unexpected scoring behaviour.
+ */
+public class FieldMaskingSpansEnumQuery extends SpansEnumQuery {
+  private SpansEnumQuery maskedQuery;
+  private String field;
+
+  public FieldMaskingSpansEnumQuery(SpansEnumQuery maskedQuery, String maskedField) {
+    this.maskedQuery = maskedQuery;
+    this.field = maskedField;
+  }
+
+  @Override
+  public String getField() {
+    return field;
+  }
+
+  public SpansEnumQuery getMaskedQuery() {
+    return maskedQuery;
+  }
+
+  // :NOTE: getBoost and setBoost are not proxied to the maskedQuery
+  // ...this is done to be more consistent with things like SpansEnumFirstQuery
+
+  @Override
+  public SpansEnum getSpans(LeafReaderContext context, Bits acceptDocs, Map<Term,TermContext> termContexts) throws IOException {
+    return maskedQuery.getSpans(context, acceptDocs, termContexts);
+  }
+
+  @Override
+  public void extractTerms(Set<Term> terms) {
+    maskedQuery.extractTerms(terms);
+  }
+
+  @Override
+  public SpansEnumWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    return maskedQuery.createWeight(searcher, needsScores);
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    FieldMaskingSpansEnumQuery clone = null;
+
+    SpansEnumQuery rewritten = (SpansEnumQuery) maskedQuery.rewrite(reader);
+    if (rewritten != maskedQuery) {
+      clone = (FieldMaskingSpansEnumQuery) this.clone();
+      clone.maskedQuery = rewritten;
+    }
+
+    if (clone != null) {
+      return clone;
+    } else {
+      return this;
+    }
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("mask(");
+    buffer.append(maskedQuery.toString(field));
+    buffer.append(")");
+    buffer.append(ToStringUtils.boost(getBoost()));
+    buffer.append(" as ");
+    buffer.append(this.field);
+    return buffer.toString();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (!(o instanceof FieldMaskingSpansEnumQuery))
+      return false;
+    FieldMaskingSpansEnumQuery other = (FieldMaskingSpansEnumQuery) o;
+    return (this.getField().equals(other.getField())
+            && (this.getBoost() == other.getBoost())
+            && this.getMaskedQuery().equals(other.getMaskedQuery()));
+
+  }
+
+  @Override
+  public int hashCode() {
+    return getMaskedQuery().hashCode()
+      ^ getField().hashCode()
+      ^ Float.floatToRawIntBits(getBoost());
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java
index d269651..1addaa2 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java
@@ -23,7 +23,9 @@ import java.util.Collection;
 /**
  * A {@link Spans} implementation which allows wrapping another spans instance
  * and override some selected methods.
+ * @deprecated Use {@link FilterSpansEnum} instead.
  */
+@Deprecated
 public class FilterSpans extends Spans {
  
   /** The wrapped spans instance. */
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpansEnum.java b/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpansEnum.java
new file mode 100644
index 0000000..83f4210
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/FilterSpansEnum.java
@@ -0,0 +1,94 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Collection;
+
+import org.apache.lucene.search.TwoPhaseIterator;
+
+/**
+ * A {@link SpansEnum} implementation wrapping another spans instance,
+ * allowing to override selected methods in a subclass.
+ */
+public class FilterSpansEnum extends SpansEnum {
+
+  /** The wrapped spans instance. */
+  protected final SpansEnum in;
+
+  /** Wrap the given {@link SpansEnum}. */
+  public FilterSpansEnum(SpansEnum in) {
+    this.in = in;
+    assert in != null;
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    return in.nextDoc();
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    return in.advance(target);
+  }
+
+  @Override
+  public int docID() {
+    return in.docID();
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    return in.nextStartPosition();
+  }
+
+  @Override
+  public int startPosition() {
+    return in.startPosition();
+  }
+
+  @Override
+  public int endPosition() {
+    return in.endPosition();
+  }
+
+  @Override
+  public Collection<byte[]> getPayload() throws IOException {
+    return in.getPayload();
+  }
+
+  @Override
+  public boolean isPayloadAvailable() throws IOException {
+    return in.isPayloadAvailable();
+  }
+
+  @Override
+  public long cost() {
+    return in.cost();
+  }
+
+  @Override
+  public String toString() {
+    return "FilterSpansEnum(" + in.toString() + ")";
+  }
+
+  @Override
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    return in.asTwoPhaseIterator();
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansEnum.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansEnum.java
new file mode 100644
index 0000000..d68252d
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansEnum.java
@@ -0,0 +1,118 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.PriorityQueue;
+
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.ConjunctionDISI;
+import org.apache.lucene.search.TwoPhaseIterator;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.HashSet;
+
+/**
+ * Common super class for un/ordered SpansEnum
+ */
+abstract class NearSpansEnum extends SpansEnum {
+  SpansEnumNearQuery query;
+  int allowedSlop;
+
+  List<SpansEnum> subSpans; // in query order
+  private SpansEnum[] subSpansArray;  
+  DocIdSetIterator conjunction; // use to move to next doc with all clauses
+  boolean atFirstInCurrentDoc;
+  boolean oneExhaustedInCurrentDoc; // no more results possbile in current doc
+
+  NearSpansEnum(SpansEnumNearQuery query, List<SpansEnum> subSpans)
+  throws IOException {
+    this.query = query;
+    this.allowedSlop = query.getSlop();
+    if (subSpans.size() < 2) {
+      throw new IllegalArgumentException("Less than 2 subSpans: " + query);
+    }
+    this.subSpans = subSpans; // in query order
+    this.subSpansArray = null; // init only when needed.
+    this.conjunction = ConjunctionDISI.intersect(subSpans);
+  }
+
+  @Override
+  public int docID() {
+    return conjunction.docID();
+  }
+
+  @Override
+  public long cost() {
+    return 3 * conjunction.cost(); // low estimation
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    return (conjunction.nextDoc() == NO_MORE_DOCS)
+            ? NO_MORE_DOCS
+            : toMatchDoc();
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    return (conjunction.advance(target) == NO_MORE_DOCS)
+            ? NO_MORE_DOCS
+            : toMatchDoc();
+  }
+
+  abstract int toMatchDoc() throws IOException;
+
+  abstract boolean twoPhaseCurrentDocMatches() throws IOException;
+
+  /**
+   * Return a {@link TwoPhaseIterator} view of this {@link NearSpansEnum}.
+   */
+  @Override
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    TwoPhaseIterator res = new TwoPhaseIterator() {
+
+      @Override
+      public DocIdSetIterator approximation() {
+        return conjunction;
+      }
+
+      @Override
+      public boolean matches() throws IOException {
+        return twoPhaseCurrentDocMatches();
+      }
+    };
+    return res;
+  }
+
+  public SpansEnum[] getSubSpans() {
+    if (subSpansArray == null) {
+      subSpansArray = subSpans.toArray(new SpansEnum[subSpans.size()]);
+    }
+    return subSpansArray;
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansEnumOrdered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansEnumOrdered.java
new file mode 100644
index 0000000..683cd4d
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansEnumOrdered.java
@@ -0,0 +1,304 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.util.ArrayUtil;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.InPlaceMergeSorter;
+
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.ConjunctionDISI;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+
+/** A SpansEnum that is formed from the ordered subspans of a SpansEnumNearQuery
+ * where the subspans do not overlap and have a maximum slop between them.
+ * <p>
+ * The formed spans only contains minimum slop matches.<br>
+ * The matching slop is computed from the distance(s) between
+ * the non overlapping matching Spans.<br>
+ * Successive matches are always formed from the successive SpansEnum
+ * of the SpansEnumNearQuery.
+ * <p>
+ * The formed spans may contain overlaps when the slop is at least 1.
+ * For example, when querying using
+ * <pre>t1 t2 t3</pre>
+ * with slop at least 1, the fragment:
+ * <pre>t1 t2 t1 t3 t2 t3</pre>
+ * matches twice:
+ * <pre>t1 t2 .. t3      </pre>
+ * <pre>      t1 .. t2 t3</pre>
+ *
+ *
+ * Expert:
+ * Only public for subclassing.  Most implementations should not need this class
+ */
+public class NearSpansEnumOrdered extends NearSpansEnum {
+
+  private int matchDoc = -1;
+  private int matchStart = -1;
+  private int matchEnd = -1;
+
+  private List<byte[]> matchPayload;
+
+  private boolean collectPayloads = true;
+
+  public NearSpansEnumOrdered(SpansEnumNearQuery query, List<SpansEnum> subSpans) throws IOException {
+    this(query, subSpans, true);
+  }
+
+  public NearSpansEnumOrdered(SpansEnumNearQuery query, List<SpansEnum> subSpans, boolean collectPayloads)
+  throws IOException {
+    super(query, subSpans);
+
+    this.collectPayloads = collectPayloads;
+    if (this.collectPayloads) {
+      this.matchPayload = new LinkedList<>();
+    }
+  }
+
+  /** Advances the subSpans to just after an ordered match with a minimum slop
+   * that is smaller than the slop allowed by the SpanNearQuery.
+   * @return true iff there is such a match.
+   */
+  @Override
+  int toMatchDoc() throws IOException {
+    subSpansToFirstStartPosition();
+    while (true) {
+      if (! stretchToOrder()) {
+        if (conjunction.nextDoc() == NO_MORE_DOCS) {
+          return NO_MORE_DOCS;
+        }
+        subSpansToFirstStartPosition();
+      } else {
+        if (shrinkToAfterShortestMatch()) {
+          atFirstInCurrentDoc = true;
+          return conjunction.docID();
+        }
+        // not a match, after shortest ordered spans, not at beginning of doc.
+        if (oneExhaustedInCurrentDoc) {
+          if (conjunction.nextDoc() == NO_MORE_DOCS) {
+            return NO_MORE_DOCS;
+          }
+          subSpansToFirstStartPosition();
+        }
+      }
+    }
+  }
+
+  @Override
+  boolean twoPhaseCurrentDocMatches() throws IOException {
+    subSpansToFirstStartPosition();
+    while (true) {
+      if (! stretchToOrder()) {
+        return false;
+      }
+      if (shrinkToAfterShortestMatch()) {
+        atFirstInCurrentDoc = true;
+        return true;
+      }
+      // not a match, after shortest ordered spans
+      if (oneExhaustedInCurrentDoc) {
+        return false;
+      }
+    }
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    if (atFirstInCurrentDoc) {
+      atFirstInCurrentDoc = false;
+      return matchStart;
+    }
+    while (true) {
+      if (oneExhaustedInCurrentDoc) {
+        matchStart = NO_MORE_POSITIONS;
+        matchEnd = NO_MORE_POSITIONS;
+        return NO_MORE_POSITIONS;
+      }
+      if (! stretchToOrder()) {
+        matchStart = NO_MORE_POSITIONS;
+        matchEnd = NO_MORE_POSITIONS;
+        return NO_MORE_POSITIONS;
+      }
+      if (shrinkToAfterShortestMatch()) { // may also leave oneExhaustedInCurrentDoc
+        return matchStart;
+      }
+      // after shortest ordered spans, or oneExhaustedInCurrentDoc
+    }
+  }
+
+  private void subSpansToFirstStartPosition() throws IOException {
+    for (SpansEnum spans : subSpans) {
+      assert spans.startPosition() == -1 : "spans="+spans;
+      spans.nextStartPosition();
+      assert spans.startPosition() != NO_MORE_POSITIONS;
+    }
+    oneExhaustedInCurrentDoc = false;
+  }
+
+  /** Order the subSpans within the same document by using nextStartPosition on all subSpans
+   * after the first as little as necessary.
+   * Return true when the subSpans could be ordered in this way,
+   * otherwise at least one is exhausted in the current doc.
+   */
+  private boolean stretchToOrder() throws IOException {
+    SpansEnum prevSpans = subSpans.get(0);
+    assert prevSpans.startPosition() != NO_MORE_POSITIONS : "prevSpans no start position "+prevSpans;
+    assert prevSpans.endPosition() != NO_MORE_POSITIONS;
+    for (int i = 1; i < subSpans.size(); i++) {
+      SpansEnum spans = subSpans.get(i);
+      assert spans.startPosition() != NO_MORE_POSITIONS;
+      assert spans.endPosition() != NO_MORE_POSITIONS;
+
+      while (prevSpans.endPosition() > spans.startPosition()) { // while overlapping spans
+        if (spans.nextStartPosition() == NO_MORE_POSITIONS) {
+          return false;
+        }
+      }
+      prevSpans = spans;
+    }
+    return true; // all subSpans ordered and non overlapping
+  }
+
+  /** The subSpans are ordered in the same doc, so there is a possible match.
+   * Compute the slop while making the match as short as possible by using nextStartPosition
+   * on all subSpans, except the last one, in reverse order.
+   */
+  private boolean shrinkToAfterShortestMatch() throws IOException {
+    SpansEnum lastSubSpans = subSpans.get(subSpans.size() - 1);
+    matchStart = lastSubSpans.startPosition();
+    matchEnd = lastSubSpans.endPosition();
+
+    Set<byte[]> possibleMatchPayloads = null;
+    if (collectPayloads) {
+      matchPayload.clear();
+      if (possibleMatchPayloads == null) {
+        possibleMatchPayloads = new HashSet<>();
+      } else {
+        possibleMatchPayloads.clear();
+      }
+      if (lastSubSpans.isPayloadAvailable()) {
+        possibleMatchPayloads.addAll(lastSubSpans.getPayload());
+      }
+    }
+
+    Collection<byte[]> possiblePayload = null;
+
+    int matchSlop = 0;
+    int lastStart = matchStart;
+    int lastEnd = matchEnd;
+    for (int i = subSpans.size() - 2; i >= 0; i--) {
+      SpansEnum prevSpans = subSpans.get(i);
+
+      if (collectPayloads && prevSpans.isPayloadAvailable()) {
+        Collection<byte[]> payload = prevSpans.getPayload();
+        possiblePayload = new ArrayList<>(payload.size());
+        possiblePayload.addAll(payload);
+      }
+
+      int prevStart = prevSpans.startPosition();
+      int prevEnd = prevSpans.endPosition();
+      while (true) { // prevSpans nextStartPosition until after (lastStart, lastEnd)
+        if (prevSpans.nextStartPosition() == NO_MORE_POSITIONS) {
+          oneExhaustedInCurrentDoc = true;
+          break; // Check remaining subSpans for match.
+        }
+        int ppStart = prevSpans.startPosition();
+        int ppEnd = prevSpans.endPosition();
+        if (ppEnd > lastStart) { // if overlapping spans
+          break; // Check remaining subSpans.
+        }
+        // prevSpans still before (lastStart, lastEnd)
+        prevStart = ppStart;
+        prevEnd = ppEnd;
+        if (collectPayloads && prevSpans.isPayloadAvailable()) {
+          Collection<byte[]> payload = prevSpans.getPayload();
+          if (possiblePayload == null) {
+            possiblePayload = new ArrayList<>(payload.size());
+          } else {
+            possiblePayload.clear();
+          }
+          possiblePayload.addAll(payload);
+        }
+      }
+
+      if (collectPayloads && possiblePayload != null) {
+        possibleMatchPayloads.addAll(possiblePayload);
+      }
+
+      assert prevStart <= matchStart;
+      if (matchStart > prevEnd) { // Only non overlapping spans add to slop.
+        matchSlop += (matchStart - prevEnd);
+      }
+
+      /* Do not break on (matchSlop > allowedSlop) here to make sure
+       * that on return the first subSpans has nextStartPosition called.
+       */
+      matchStart = prevStart;
+      lastStart = prevStart;
+      lastEnd = prevEnd;
+    }
+
+    boolean match = matchSlop <= allowedSlop;
+
+    if (collectPayloads && match && possibleMatchPayloads.size() > 0) {
+      matchPayload.addAll(possibleMatchPayloads);
+    }
+
+    return match; // ordered and allowed slop
+  }
+
+  @Override
+  public int startPosition() {
+    return atFirstInCurrentDoc ? -1 : matchStart;
+  }
+
+  @Override
+  public int endPosition() {
+    return atFirstInCurrentDoc ? -1 : matchEnd;
+  }
+
+  // TODO: Remove warning after API has been finalized
+  // TODO: Would be nice to be able to lazy load payloads
+  @Override
+  public Collection<byte[]> getPayload() throws IOException {
+    return matchPayload;
+  }
+
+  @Override
+  public boolean isPayloadAvailable() {
+    return collectPayloads && ! matchPayload.isEmpty();
+  }
+
+  @Override
+  public String toString() {
+    return "NearSpansEnumOrdered("+query.toString()+")@"+docID()+": "+startPosition()+" - "+endPosition();
+  }
+}
+
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansEnumUnordered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansEnumUnordered.java
new file mode 100644
index 0000000..d76d7de
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansEnumUnordered.java
@@ -0,0 +1,267 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.PriorityQueue;
+
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.ConjunctionDISI;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.HashSet;
+
+/**
+ * Similar to {@link NearSpansEnumOrdered}, but for the unordered case.
+ *
+ * Expert:
+ * Only public for subclassing.  Most implementations should not need this class
+ */
+public class NearSpansEnumUnordered extends NearSpansEnum {
+
+  private List<SpansCell> subSpanCells; // in query order
+
+  private SpanPositionQueue spanPositionQueue;
+
+  public NearSpansEnumUnordered(SpansEnumNearQuery query, List<SpansEnum> subSpans)
+  throws IOException {
+    super(query, subSpans);
+
+    this.subSpanCells = new ArrayList<>(subSpans.size());
+    for (SpansEnum subSpan : subSpans) { // sub spans in query order
+      this.subSpanCells.add(new SpansCell(subSpan));
+    }
+
+    this.spanPositionQueue = new SpanPositionQueue(subSpans.size()); // fill when all cells are at the same doc
+  }
+
+  private void subSpanCellsToPositionQueue() throws IOException { // used when all subSpanCells arrived at the same doc.
+    spanPositionQueue.clear();
+    for (SpansCell cell : subSpanCells) {
+      assert cell.startPosition() == -1;
+      cell.nextStartPosition();
+      assert cell.startPosition() != NO_MORE_POSITIONS;
+      spanPositionQueue.add(cell);
+    }
+  }
+
+  /** SpansCell wraps a sub SpansEnum to maintain totalSpanLength and maxEndPositionCell */
+  private int totalSpanLength;
+  private SpansCell maxEndPositionCell;
+
+  private class SpansCell extends FilterSpansEnum {
+    private int spanLength = -1;
+
+    public SpansCell(SpansEnum spans) {
+      super(spans);
+    }
+
+    @Override
+    public int nextStartPosition() throws IOException {
+      int res = in.nextStartPosition();
+      if (res != NO_MORE_POSITIONS) {
+        adjustLength();
+      }
+      adjustMax(); // also after last end position in current doc.
+      return res;
+    }
+
+    private void adjustLength() {
+      if (spanLength != -1) {
+        totalSpanLength -= spanLength;  // subtract old, possibly from a previous doc
+      }
+      assert in.startPosition() != NO_MORE_POSITIONS;
+      spanLength = endPosition() - startPosition();
+      assert spanLength >= 0;
+      totalSpanLength += spanLength; // add new
+    }
+
+    private void adjustMax() {
+      if (maxEndPositionCell == null) {
+        maxEndPositionCell = this;
+      } else {
+        assert docID() == maxEndPositionCell.docID();
+        if (endPosition() > maxEndPositionCell.endPosition()) {
+          maxEndPositionCell = this;
+        }
+      }
+    }
+
+    @Override
+    public String toString() { return "NearSpansEnumUnordered.SpansCell(" + in.toString() + ")"; }
+  }
+
+
+  private static class SpanPositionQueue extends PriorityQueue<SpansCell> {
+    public SpanPositionQueue(int size) {
+      super(size);
+    }
+
+    @Override
+    protected final boolean lessThan(SpansCell spans1, SpansCell spans2) {
+      return positionsOrdered(spans1, spans2);
+    }
+  }
+
+  /** Check whether two Spans in the same document are ordered with possible overlap.
+   * @return true iff spans1 starts before spans2
+   *              or the spans start at the same position,
+   *              and spans1 ends before spans2.
+   */
+  static final boolean positionsOrdered(SpansEnum spans1, SpansEnum spans2) {
+    assert spans1.docID() == spans2.docID() : "doc1 " + spans1.docID() + " != doc2 " + spans2.docID();
+    int start1 = spans1.startPosition();
+    int start2 = spans2.startPosition();
+    return (start1 == start2) ? (spans1.endPosition() < spans2.endPosition()) : (start1 < start2);
+  }
+
+  private SpansCell minPositionCell() {
+    return spanPositionQueue.top();
+  }
+
+  private boolean atMatch() {
+    assert minPositionCell().docID() == maxEndPositionCell.docID();
+    return (maxEndPositionCell.endPosition() - minPositionCell().startPosition() - totalSpanLength) <= allowedSlop;
+  }
+
+  @Override
+  int toMatchDoc() throws IOException {
+    // at doc with all subSpans
+    subSpanCellsToPositionQueue();
+    while (true) {
+      if (atMatch()) {
+        atFirstInCurrentDoc = true;
+        oneExhaustedInCurrentDoc = false;
+        return conjunction.docID();
+      }
+      assert minPositionCell().startPosition() != NO_MORE_POSITIONS;
+      if (minPositionCell().nextStartPosition() != NO_MORE_POSITIONS) {
+        spanPositionQueue.updateTop();
+      }
+      else { // exhausted a subSpan in current doc
+        if (conjunction.nextDoc() == NO_MORE_DOCS) {
+          return NO_MORE_DOCS;
+        }
+        // at doc with all subSpans
+        subSpanCellsToPositionQueue();
+      }
+    }
+  }
+
+  @Override
+  boolean twoPhaseCurrentDocMatches() throws IOException {
+    // at doc with all subSpans
+    subSpanCellsToPositionQueue();
+    while (true) {
+      if (atMatch()) {
+        atFirstInCurrentDoc = true;
+        oneExhaustedInCurrentDoc = false;
+        return true;
+      }
+      assert minPositionCell().startPosition() != NO_MORE_POSITIONS;
+      if (minPositionCell().nextStartPosition() != NO_MORE_POSITIONS) {
+        spanPositionQueue.updateTop();
+      }
+      else { // exhausted a subSpan in current doc
+        return false;
+      }
+    }
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    if (atFirstInCurrentDoc) {
+      atFirstInCurrentDoc = false;
+      return minPositionCell().startPosition();
+    }
+    while (minPositionCell().startPosition() == -1) { // initially at current doc
+      minPositionCell().nextStartPosition();
+      spanPositionQueue.updateTop();
+    }
+    assert minPositionCell().startPosition() != NO_MORE_POSITIONS;
+    while (true) {
+      if (minPositionCell().nextStartPosition() == NO_MORE_POSITIONS) {
+        oneExhaustedInCurrentDoc = true;
+        return NO_MORE_POSITIONS;
+      }
+      spanPositionQueue.updateTop();
+      if (atMatch()) {
+        return minPositionCell().startPosition();
+      }
+    }
+  }
+
+  @Override
+  public int startPosition() {
+    return atFirstInCurrentDoc ? -1
+          : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
+          : minPositionCell().startPosition();
+  }
+
+  @Override
+  public int endPosition() {
+    return atFirstInCurrentDoc ? -1
+          : oneExhaustedInCurrentDoc ? NO_MORE_POSITIONS
+          : maxEndPositionCell.endPosition();
+  }
+
+
+  /**
+   * WARNING: The List is not necessarily in order of the positions.
+   * @return Collection of <code>byte[]</code> payloads
+   * @throws IOException if there is a low-level I/O error
+   */
+  @Override
+  public Collection<byte[]> getPayload() throws IOException {
+    Set<byte[]> matchPayload = new HashSet<>();
+    for (SpansCell cell : subSpanCells) {
+      if (cell.isPayloadAvailable()) {
+        matchPayload.addAll(cell.getPayload());
+      }
+    }
+    return matchPayload;
+  }
+
+  @Override
+  public boolean isPayloadAvailable() throws IOException {
+    for (SpansCell cell : subSpanCells) {
+      if (cell.isPayloadAvailable()) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  @Override
+  public String toString() {
+    if (minPositionCell() != null) {
+      return getClass().getName() + "("+query.toString()+")@"+
+        (docID()+":"+startPosition()+"-"+endPosition());
+    } else {
+      return getClass().getName() + "("+query.toString()+")@ ?START?";
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
index 508c966..a843c6b 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
@@ -54,7 +54,9 @@ import java.util.Set;
  *
  * Expert:
  * Only public for subclassing.  Most implementations should not need this class
+ * @deprecated Use {@link NearSpansEnumOrdered} instead.
  */
+@Deprecated
 public class NearSpansOrdered extends Spans {
   private final int allowedSlop;
   private boolean firstTime = true;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
index 168e52d..80208aa 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
@@ -36,7 +36,9 @@ import java.util.HashSet;
  * 
  * Expert:
  * Only public for subclassing.  Most implementations should not need this class
+ * @deprecated Use {@link NearSpansEnumUnordered} instead.
  */
+@Deprecated
 public class NearSpansUnordered extends Spans {
   private SpanNearQuery query;
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java
index 7bcaa2c..7ca180d 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanFirstQuery.java
@@ -26,7 +26,9 @@ import java.io.IOException;
  * <p> 
  * This class is a simple extension of {@link SpanPositionRangeQuery} in that it assumes the
  * start to be zero and only checks the end boundary.
+ * @deprecated Use {@link SpansEnumFirstQuery} instead.
  */
+@Deprecated
 public class SpanFirstQuery extends SpanPositionRangeQuery {
 
   /** Construct a SpanFirstQuery matching spans in <code>match</code> whose end
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
index 36326bb..00fd341 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
@@ -46,7 +46,9 @@ import org.apache.lucene.util.Bits;
  * // do something with spanWildcard, such as use it in a SpanFirstQuery
  * }
  * </pre></blockquote>
+ * @deprecated Use {@link SpansEnumMultiTermQueryWrapper} instead.
  */
+@Deprecated
 public class SpanMultiTermQueryWrapper<Q extends MultiTermQuery> extends SpanQuery {
   protected final Q query;
 
@@ -150,6 +152,7 @@ public class SpanMultiTermQueryWrapper<Q extends MultiTermQuery> extends SpanQue
   }
 
   /** Abstract class that defines how the query is rewritten. */
+  @Deprecated
   public static abstract class SpanRewriteMethod extends MultiTermQuery.RewriteMethod {
     @Override
     public abstract SpanQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException;
@@ -202,6 +205,7 @@ public class SpanMultiTermQueryWrapper<Q extends MultiTermQuery> extends SpanQue
    * 
    * @see #setRewriteMethod
    */
+  @Deprecated
   public static final class TopTermsSpanBooleanQueryRewrite extends SpanRewriteMethod  {
     private final TopTermsRewrite<SpanOrQuery> delegate;
   
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearPayloadCheckQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearPayloadCheckQuery.java
index aa69146..46fcd45 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearPayloadCheckQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearPayloadCheckQuery.java
@@ -26,7 +26,9 @@ import java.util.Collection;
 /**
  * Only return those matches that have a specific payload at
  * the given position.
+ * @deprecated Use {@link SpansEnumNearPayloadCheckQuery} instead.
  */
+@Deprecated
 public class SpanNearPayloadCheckQuery extends SpanPositionCheckQuery {
   protected final Collection<byte[]> payloadToMatch;
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
index 1e1d083..638e460 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
@@ -37,7 +37,10 @@ import org.apache.lucene.util.ToStringUtils;
 
 /** Matches spans which are near one another.  One can specify <i>slop</i>, the
  * maximum number of intervening unmatched positions, as well as whether
- * matches are required to be in-order. */
+ * matches are required to be in-order.
+ * @deprecated Use {@link SpansEnumNearQuery} instead.
+ */
+@Deprecated
 public class SpanNearQuery extends SpanQuery implements Cloneable {
   protected List<SpanQuery> clauses;
   protected int slop;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
index 88c439d..cf3a037 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNotQuery.java
@@ -31,8 +31,11 @@ import java.util.Collection;
 import java.util.Map;
 import java.util.Set;
 
-/** Removes matches which overlap with another SpanQuery or 
- * within a x tokens before or y tokens after another SpanQuery. */
+/** Removes matches which overlap with another SpanQuery or which are
+ * within x tokens before or y tokens after another SpanQuery.
+ * @deprecated Use {@link SpansEnumNotQuery} instead.
+ */
+@Deprecated
 public class SpanNotQuery extends SpanQuery implements Cloneable {
   private SpanQuery include;
   private SpanQuery exclude;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
index 2b617e4..d778f77 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
@@ -35,7 +35,10 @@ import org.apache.lucene.util.PriorityQueue;
 import org.apache.lucene.util.ToStringUtils;
 import org.apache.lucene.search.Query;
 
-/** Matches the union of its clauses.*/
+/** Matches the union of its clauses.
+ * @deprecated Use {@link SpansEnumOrQuery} instead.
+ */
+@Deprecated
 public class SpanOrQuery extends SpanQuery implements Cloneable {
   private List<SpanQuery> clauses;
   private String field;
@@ -170,15 +173,19 @@ public class SpanOrQuery extends SpanQuery implements Cloneable {
       return (clauses.get(0)).getSpans(context, acceptDocs, termContexts);
 
     return new Spans() {
+        private Spans[] subSpans = new Spans[clauses.size()];
+        {
+          int ind = 0;
+          for (SpanQuery sq: clauses) {
+            subSpans[ind++] = sq.getSpans(context, acceptDocs, termContexts);
+          }
+        }
+
         private SpanQueue queue = null;
-        private long cost;
 
         private boolean initSpanQueue(int target) throws IOException {
           queue = new SpanQueue(clauses.size());
-          Iterator<SpanQuery> i = clauses.iterator();
-          while (i.hasNext()) {
-            Spans spans = i.next().getSpans(context, acceptDocs, termContexts);
-            cost += spans.cost();
+          for (Spans spans: subSpans) {
             if (   ((target == -1) && spans.next())
                 || ((target != -1) && spans.skipTo(target))) {
               queue.add(spans);
@@ -262,6 +269,10 @@ public class SpanOrQuery extends SpanQuery implements Cloneable {
 
       @Override
       public long cost() {
+        long cost = 0;
+        for (Spans spans: subSpans) {
+          cost += spans.cost();
+        }
         return cost;
       }
       
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPayloadCheckQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPayloadCheckQuery.java
index dda6009..355dc4e 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPayloadCheckQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPayloadCheckQuery.java
@@ -31,7 +31,10 @@ import java.util.Iterator;
  * Do not use this with an SpanQuery that contains a {@link org.apache.lucene.search.spans.SpanNearQuery}.  Instead, use
  * {@link SpanNearPayloadCheckQuery} since it properly handles the fact that payloads
  * aren't ordered by {@link org.apache.lucene.search.spans.SpanNearQuery}.
+ *
+ * @deprecated Use {@link SpansEnumPayloadCheckQuery} instead.
  */
+@Deprecated
 public class SpanPayloadCheckQuery extends SpanPositionCheckQuery{
   protected final Collection<byte[]> payloadToMatch;
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
index a41442d..ef8860b 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
@@ -33,7 +33,9 @@ import java.util.Set;
 
 /**
  * Base class for filtering a SpanQuery based on the position of a match.
+ * @deprecated Use {@link SpansEnumPositionCheckQuery} instead.
  **/
+@Deprecated
 public abstract class SpanPositionCheckQuery extends SpanQuery implements Cloneable {
   protected SpanQuery match;
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java
index f588d28..2c1defc 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionRangeQuery.java
@@ -26,7 +26,10 @@ import java.io.IOException;
  * Checks to see if the {@link #getMatch()} lies between a start and end position
  *
  * @see org.apache.lucene.search.spans.SpanFirstQuery for a derivation that is optimized for the case where start position is 0
+ *
+ * @deprecated Use {@link SpansEnumPositionRangeQuery} instead.
  */
+@Deprecated
 public class SpanPositionRangeQuery extends SpanPositionCheckQuery {
   protected int start = 0;
   protected int end;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java
index 00bed75..5e165db 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanQuery.java
@@ -28,7 +28,10 @@ import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Weight;
 import org.apache.lucene.util.Bits;
 
-/** Base class for span-based queries. */
+/** Base class for span-based queries.
+ * @deprecated Use {@link SpansEnumQuery} instead.
+ */
+@Deprecated
 public abstract class SpanQuery extends Query {
   /** Expert: Returns the matches for this query in an index.  Used internally
    * to search for spans. */
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java
index 56b2571..a945c88 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanScorer.java
@@ -25,7 +25,9 @@ import org.apache.lucene.search.similarities.Similarity;
 
 /**
  * Public for extension only.
+ * @deprecated Use {@link SpansEnumScorer} instead.
  */
+@Deprecated
 public class SpanScorer extends Scorer {
   protected Spans spans;
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
index 820363a..c63542b 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
@@ -31,7 +31,10 @@ import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.ToStringUtils;
 
-/** Matches spans containing a term. */
+/** Matches spans containing a term.
+ * @deprecated Use {@link SpansEnumTermQuery} instead.
+ */
+@Deprecated
 public class SpanTermQuery extends SpanQuery {
   protected Term term;
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
index c172243..a697c01 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanWeight.java
@@ -39,7 +39,9 @@ import org.apache.lucene.util.Bits;
 
 /**
  * Expert-only.  Public for use by other weight implementations
+ * @deprecated Use {@link SpansEnumWeight} instead.
  */
+@Deprecated
 public class SpanWeight extends Weight {
   protected final Similarity similarity;
   protected final Map<Term,TermContext> termContexts;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java b/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
index 32aff3b..3009706 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/Spans.java
@@ -23,7 +23,11 @@ import java.util.Collection;
 /** Expert: an enumeration of span matches.  Used to implement span searching.
  * Each span represents a range of term positions within a document.  Matches
  * are enumerated in order, by increasing document number, within that by
- * increasing start position and finally by increasing end position. */
+ * increasing start position and finally by increasing end position.
+ *
+ * @deprecated Use {@link SpansEnum} instead.
+ */
+@Deprecated
 public abstract class Spans {
   /** Move to the next match, returning true iff any such exists. */
   public abstract boolean next() throws IOException;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnum.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnum.java
new file mode 100644
index 0000000..a61a9c6
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnum.java
@@ -0,0 +1,100 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Collection;
+
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.TwoPhaseIterator;
+
+/** Iterates through combinations of start/end positions per-doc.
+ *  Each start/end position represents a range of term positions within the current document.
+ *  These are enumerated in order, by increasing document number, within that by
+ *  increasing start position and finally by increasing end position.
+ */
+public abstract class SpansEnum extends DocIdSetIterator {
+  public static final int NO_MORE_POSITIONS = Integer.MAX_VALUE;
+
+  /**
+   * Returns the next start position for the current doc.
+   * There is always at least one start/end position per doc.
+   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
+   */
+  public abstract int nextStartPosition() throws IOException;
+
+  /**
+   * Returns the start position in the current doc, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
+   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
+   */
+  public abstract int startPosition();
+
+  /**
+   * Returns the end position for the current start position, or -1 when {@link #nextStartPosition} was not yet called on the current doc.
+   * After the last start/end position at the current doc this returns {@link #NO_MORE_POSITIONS}.
+   */
+  public abstract int endPosition();
+
+  /**
+   * Returns the payload data for the current start/end position.
+   * This is only valid after {@link #nextStartPosition()}
+   * returned an available start position.
+   * This method must not be called more than once after each call
+   * of {@link #nextStartPosition()}. However, most payloads are loaded lazily,
+   * so if the payload data for the current position is not needed,
+   * this method may not be called at all for performance reasons.
+   * <br>
+   * Note that the return type is a collection, thus the ordering should not be relied upon.
+   * <br>
+   * @lucene.experimental
+   *
+   * @return a List of byte arrays containing the data of this payload, otherwise null if isPayloadAvailable is false
+   * @throws IOException if there is a low-level I/O error
+   */
+  public abstract Collection<byte[]> getPayload() throws IOException;
+
+  /**
+   * Checks if a payload can be loaded at the current start/end position.
+   * <p>
+   * Payloads can only be loaded once per call to
+   * {@link #nextStartPosition()}.
+   *
+   * @return true if there is a payload available at this start/end position
+   *              that can be loaded
+   */
+  public abstract boolean isPayloadAvailable() throws IOException;
+
+  /**
+   * Optional method: Return a {@link TwoPhaseIterator} view of this
+   * {@link SpansEnum}. A return value of {@code null} indicates that
+   * two-phase iteration is not supported.
+   *
+   * Note that the returned {@link TwoPhaseIterator}'s
+   * {@link TwoPhaseIterator#approximation() approximation} must
+   * advance synchronously with this iterator: advancing the approximation must
+   * advance this iterator and vice-versa.
+   *
+   * Implementing this method is typically useful on {@link SpansEnum}s
+   * that have a high per-document overhead in order to confirm matches.
+   *
+   * The default implementation returns {@code null}.
+   */
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    return null;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumFirstQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumFirstQuery.java
new file mode 100644
index 0000000..ccd805b
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumFirstQuery.java
@@ -0,0 +1,89 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.util.ToStringUtils;
+
+import java.io.IOException;
+
+/**
+ * Matches spans near the beginning of a field.
+ * <p>
+ * This class is a simple extension of {@link SpansEnumPositionRangeQuery} in that it assumes the
+ * start to be zero and only checks the end boundary.
+ */
+public class SpansEnumFirstQuery extends SpansEnumPositionRangeQuery {
+
+  /** Construct a SpansEnumFirstQuery matching spans in <code>match</code> whose end
+   * position is less than or equal to <code>end</code>. */
+  public SpansEnumFirstQuery(SpansEnumQuery match, int end) {
+    super(match, 0, end);
+  }
+
+  @Override
+  protected AcceptStatus acceptPosition(SpansEnum spans) throws IOException {
+    assert spans.startPosition() != spans.endPosition() : "start equals end: " + spans.startPosition();
+    if (spans.startPosition() >= end)
+      return AcceptStatus.NO_MORE_IN_CURRENT_DOC;
+    else if (spans.endPosition() <= end)
+      return AcceptStatus.YES;
+    else
+      return AcceptStatus.NO;
+  }
+
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("spanFirst(");
+    buffer.append(match.toString(field));
+    buffer.append(", ");
+    buffer.append(end);
+    buffer.append(")");
+    buffer.append(ToStringUtils.boost(getBoost()));
+    return buffer.toString();
+  }
+
+  @Override
+  public SpansEnumFirstQuery clone() {
+    SpansEnumFirstQuery spanFirstQuery = new SpansEnumFirstQuery((SpansEnumQuery) match.clone(), end);
+    spanFirstQuery.setBoost(getBoost());
+    return spanFirstQuery;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof SpansEnumFirstQuery)) return false;
+
+    SpansEnumFirstQuery other = (SpansEnumFirstQuery)o;
+    return this.end == other.end
+         && this.match.equals(other.match)
+         && this.getBoost() == other.getBoost();
+  }
+
+  @Override
+  public int hashCode() {
+    int h = match.hashCode();
+    h ^= (h << 8) | (h >>> 25);  // reversible
+    h ^= Float.floatToRawIntBits(getBoost()) ^ end;
+    return h;
+  }
+
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumMultiTermQueryWrapper.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumMultiTermQueryWrapper.java
new file mode 100644
index 0000000..7c97105
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumMultiTermQueryWrapper.java
@@ -0,0 +1,259 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Map;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TopTermsRewrite;
+import org.apache.lucene.search.ScoringRewrite;
+import org.apache.lucene.search.BooleanClause.Occur; // javadocs only
+import org.apache.lucene.util.Bits;
+
+/**
+ * Wraps any {@link MultiTermQuery} as a {@link SpansEnumQuery},
+ * so it can be nested within other SpanQuery classes.
+ * <p>
+ * The query is rewritten by default to a {@link SpansEnumOrQuery} containing
+ * the expanded terms, but this can be customized.
+ * <p>
+ * Example:
+ * <blockquote><pre class="prettyprint">
+ * {@code
+ * WildcardQuery wildcard = new WildcardQuery(new Term("field", "bro?n"));
+ * SpansEnumQuery spanWildcard = new SpansEnumMultiTermQueryWrapper<WildcardQuery>(wildcard);
+ * // do something with spanWildcard, such as use it in a SpansEnumFirstQuery
+ * }
+ * </pre></blockquote>
+ */
+public class SpansEnumMultiTermQueryWrapper<Q extends MultiTermQuery> extends SpansEnumQuery {
+  protected final Q query;
+
+  /**
+   * Create a new SpansEnumMultiTermQueryWrapper.
+   *
+   * @param query Query to wrap.
+   * <p>
+   * NOTE: This will call {@link MultiTermQuery#setRewriteMethod(MultiTermQuery.RewriteMethod)}
+   * on the wrapped <code>query</code>, changing its rewrite method to a suitable one for spans.
+   * Be sure to not change the rewrite method on the wrapped query afterwards! Doing so will
+   * throw {@link UnsupportedOperationException} on rewriting this query!
+   */
+  @SuppressWarnings({"rawtypes","unchecked"})
+  public SpansEnumMultiTermQueryWrapper(Q query) {
+    this.query = query;
+
+    MultiTermQuery.RewriteMethod method = query.getRewriteMethod();
+    if (method instanceof TopTermsRewrite) {
+      final int pqsize = ((TopTermsRewrite) method).getSize();
+      setRewriteMethod(new TopTermsSpanBooleanQueryRewrite(pqsize));
+    } else {
+      setRewriteMethod(SCORING_SPAN_QUERY_REWRITE);
+    }
+  }
+
+  /**
+   * Expert: returns the rewriteMethod
+   */
+  public final SpanRewriteMethod getRewriteMethod() {
+    final MultiTermQuery.RewriteMethod m = query.getRewriteMethod();
+    if (!(m instanceof SpanRewriteMethod))
+      throw new UnsupportedOperationException("You can only use SpanMultiTermQueryWrapper with a suitable SpanRewriteMethod.");
+    return (SpanRewriteMethod) m;
+  }
+
+  /**
+   * Expert: sets the rewrite method. This only makes sense
+   * to be a span rewrite method.
+   */
+  public final void setRewriteMethod(SpanRewriteMethod rewriteMethod) {
+    query.setRewriteMethod(rewriteMethod);
+  }
+
+  @Override
+  public SpansEnum getSpans(LeafReaderContext context, Bits acceptDocs, Map<Term,TermContext> termContexts) throws IOException {
+    throw new UnsupportedOperationException("Query should have been rewritten");
+  }
+
+  @Override
+  public String getField() {
+    return query.getField();
+  }
+
+  /** Returns the wrapped query */
+  public Query getWrappedQuery() {
+    return query;
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder builder = new StringBuilder();
+    builder.append("SpanMultiTermQueryWrapper(");
+    // NOTE: query.toString must be placed in a temp local to avoid compile errors on Java 8u20
+    // see https://bugs.openjdk.java.net/browse/JDK-8056984?page=com.atlassian.streams.streams-jira-plugin:activity-stream-issue-tab
+    String queryStr = query.toString(field);
+    builder.append(queryStr);
+    builder.append(")");
+    if (getBoost() != 1F) {
+      builder.append('^');
+      builder.append(getBoost());
+    }
+    return builder.toString();
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    final Query q = query.rewrite(reader);
+    if (!(q instanceof SpansEnumQuery))
+      throw new UnsupportedOperationException("You can only use SpanMultiTermQueryWrapper with a suitable SpanRewriteMethod.");
+    q.setBoost(q.getBoost() * getBoost()); // multiply boost
+    return q;
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = super.hashCode();
+    result = prime * result + query.hashCode();
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) return true;
+    if (!super.equals(obj)) return false;
+    if (getClass() != obj.getClass()) return false;
+    SpansEnumMultiTermQueryWrapper<?> other = (SpansEnumMultiTermQueryWrapper<?>) obj;
+    if (!query.equals(other.query)) return false;
+    return true;
+  }
+
+  /** Abstract class that defines how the query is rewritten. */
+  public static abstract class SpanRewriteMethod extends MultiTermQuery.RewriteMethod {
+    @Override
+    public abstract SpansEnumQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException;
+  }
+
+  /**
+   * A rewrite method that first translates each term into a SpansEnumTermQuery in a
+   * {@link Occur#SHOULD} clause in a BooleanQuery, and keeps the
+   * scores as computed by the query.
+   *
+   * @see #setRewriteMethod
+   */
+  public final static SpanRewriteMethod SCORING_SPAN_QUERY_REWRITE = new SpanRewriteMethod() {
+    private final ScoringRewrite<SpansEnumOrQuery> delegate = new ScoringRewrite<SpansEnumOrQuery>() {
+      @Override
+      protected SpansEnumOrQuery getTopLevelQuery() {
+        return new SpansEnumOrQuery();
+      }
+
+      @Override
+      protected void checkMaxClauseCount(int count) {
+        // we accept all terms as SpansEnumOrQuery has no limits
+      }
+
+      @Override
+      protected void addClause(SpansEnumOrQuery topLevel, Term term, int docCount, float boost, TermContext states) {
+        // TODO: would be nice to not lose term-state here.
+        // we could add a hack option to SpanOrQuery, but the hack would only work if this is the top-level Span
+        // (if you put this thing in another span query, it would extractTerms/double-seek anyway)
+        final SpansEnumTermQuery q = new SpansEnumTermQuery(term);
+        q.setBoost(boost);
+        topLevel.addClause(q);
+      }
+    };
+
+    @Override
+    public SpansEnumQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException {
+      return delegate.rewrite(reader, query);
+    }
+  };
+
+  /**
+   * A rewrite method that first translates each term into a SpanTermQuery in a
+   * {@link Occur#SHOULD} clause in a BooleanQuery, and keeps the
+   * scores as computed by the query.
+   *
+   * <p>
+   * This rewrite method only uses the top scoring terms so it will not overflow
+   * the boolean max clause count.
+   *
+   * @see #setRewriteMethod
+   */
+  public static final class TopTermsSpanBooleanQueryRewrite extends SpanRewriteMethod  {
+    private final TopTermsRewrite<SpansEnumOrQuery> delegate;
+
+    /**
+     * Create a TopTermsSpanBooleanQueryRewrite for
+     * at most <code>size</code> terms.
+     */
+    public TopTermsSpanBooleanQueryRewrite(int size) {
+      delegate = new TopTermsRewrite<SpansEnumOrQuery>(size) {
+        @Override
+        protected int getMaxSize() {
+          return Integer.MAX_VALUE;
+        }
+
+        @Override
+        protected SpansEnumOrQuery getTopLevelQuery() {
+          return new SpansEnumOrQuery();
+        }
+
+        @Override
+        protected void addClause(SpansEnumOrQuery topLevel, Term term, int docFreq, float boost, TermContext states) {
+          final SpansEnumTermQuery q = new SpansEnumTermQuery(term);
+          q.setBoost(boost);
+          topLevel.addClause(q);
+        }
+      };
+    }
+
+    /** return the maximum priority queue size */
+    public int getSize() {
+      return delegate.getSize();
+    }
+
+    @Override
+    public SpansEnumQuery rewrite(IndexReader reader, MultiTermQuery query) throws IOException {
+      return delegate.rewrite(reader, query);
+    }
+
+    @Override
+    public int hashCode() {
+      return 31 * delegate.hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (this == obj) return true;
+      if (obj == null) return false;
+      if (getClass() != obj.getClass()) return false;
+      final TopTermsSpanBooleanQueryRewrite other = (TopTermsSpanBooleanQueryRewrite) obj;
+      return delegate.equals(other.delegate);
+    }
+
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumNearPayloadCheckQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumNearPayloadCheckQuery.java
new file mode 100644
index 0000000..9d8c6ad
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumNearPayloadCheckQuery.java
@@ -0,0 +1,115 @@
+package org.apache.lucene.search.spans;
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.util.ToStringUtils;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collection;
+
+
+/**
+ * Only return those matches that have a specific payload at
+ * the given position.
+ */
+public class SpansEnumNearPayloadCheckQuery extends SpansEnumPositionCheckQuery {
+  protected final Collection<byte[]> payloadToMatch;
+
+  /**
+   * @param match          The underlying {@link SpanQuery} to check
+   * @param payloadToMatch The {@link java.util.Collection} of payloads to match
+   */
+  public SpansEnumNearPayloadCheckQuery(SpansEnumNearQuery match, Collection<byte[]> payloadToMatch) {
+    super(match);
+    this.payloadToMatch = payloadToMatch;
+  }
+
+  @Override
+  protected AcceptStatus acceptPosition(SpansEnum spans) throws IOException {
+    boolean result = spans.isPayloadAvailable();
+    if (result == true) {
+      Collection<byte[]> candidate = spans.getPayload();
+      if (candidate.size() == payloadToMatch.size()) {
+        //TODO: check the byte arrays are the same
+        //hmm, can't rely on order here
+        int matches = 0;
+        for (byte[] candBytes : candidate) {
+          //Unfortunately, we can't rely on order, so we need to compare all
+          for (byte[] payBytes : payloadToMatch) {
+            if (Arrays.equals(candBytes, payBytes) == true) {
+              matches++;
+              break;
+            }
+          }
+        }
+        if (matches == payloadToMatch.size()){
+          //we've verified all the bytes
+          return AcceptStatus.YES;
+        } else {
+          return AcceptStatus.NO;
+        }
+      } else {
+        return AcceptStatus.NO;
+      }
+    }
+    return AcceptStatus.NO;
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("spansEnumPayCheck(");
+    buffer.append(match.toString(field));
+    buffer.append(", payloadRef: ");
+    for (byte[] bytes : payloadToMatch) {
+      ToStringUtils.byteArray(buffer, bytes);
+      buffer.append(';');
+    }
+    buffer.append(")");
+    buffer.append(ToStringUtils.boost(getBoost()));
+    return buffer.toString();
+  }
+
+  @Override
+  public SpansEnumNearPayloadCheckQuery clone() {
+    SpansEnumNearPayloadCheckQuery result = new SpansEnumNearPayloadCheckQuery((SpansEnumNearQuery) match.clone(), payloadToMatch);
+    result.setBoost(getBoost());
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof SpansEnumNearPayloadCheckQuery)) return false;
+
+    SpansEnumNearPayloadCheckQuery other = (SpansEnumNearPayloadCheckQuery) o;
+    return this.payloadToMatch.equals(other.payloadToMatch)
+            && this.match.equals(other.match)
+            && this.getBoost() == other.getBoost();
+  }
+
+  @Override
+  public int hashCode() {
+    int h = match.hashCode() ^ getClass().hashCode();
+    h ^= (h << 8) | (h >>> 25);  // reversible
+    //TODO: is this right?
+    h ^= payloadToMatch.hashCode();
+    h ^= Float.floatToRawIntBits(getBoost());
+    return h;
+  }
+}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumNearQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumNearQuery.java
new file mode 100644
index 0000000..7b5abc3
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumNearQuery.java
@@ -0,0 +1,200 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+
+import java.util.List;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.ToStringUtils;
+
+/** Matches spans which are near one another.  One can specify <i>slop</i>, the
+ * maximum number of intervening unmatched positions, as well as whether
+ * matches are required to be in-order.
+ */
+public class SpansEnumNearQuery extends SpansEnumQuery implements Cloneable {
+  protected List<SpansEnumQuery> clauses;
+  protected int slop;
+  protected boolean inOrder;
+
+  protected String field;
+  private boolean collectPayloads;
+
+  /** Construct a SpanNearQuery.  Matches spans matching a span from each
+   * clause, with up to <code>slop</code> total unmatched positions between
+   * them.
+   * <br>When <code>inOrder</code> is true, the spans from each clause
+   * must be in the same order as in <code>clauses</code> and must be non-overlapping.
+   * <br>When <code>inOrder</code> is false, the spans from each clause
+   * need not be ordered and may overlap.
+   * @param clauses the clauses to find near each other
+   * @param slop The slop value
+   * @param inOrder true if order is important
+   */
+  public SpansEnumNearQuery(SpansEnumQuery[] clauses, int slop, boolean inOrder) {
+    this(clauses, slop, inOrder, true);
+  }
+
+  public SpansEnumNearQuery(SpansEnumQuery[] clausesIn, int slop, boolean inOrder, boolean collectPayloads) {
+    this.clauses = new ArrayList<>(clausesIn.length);
+    for (SpansEnumQuery clause : clausesIn) {
+      if (this.field == null) {                               // check field
+        this.field = clause.getField();
+      } else if (clause.getField() != null && !clause.getField().equals(field)) {
+        throw new IllegalArgumentException("Clauses must have same field.");
+      }
+      this.clauses.add(clause);
+    }
+    this.collectPayloads = collectPayloads;
+    this.slop = slop;
+    this.inOrder = inOrder;
+  }
+
+  /** Return the clauses whose spans are matched. */
+  public SpansEnumQuery[] getClauses() {
+    return clauses.toArray(new SpansEnumQuery[clauses.size()]);
+  }
+
+  /** Return the maximum number of intervening unmatched positions permitted.*/
+  public int getSlop() { return slop; }
+
+  /** Return true if matches are required to be in-order.*/
+  public boolean isInOrder() { return inOrder; }
+
+  @Override
+  public String getField() { return field; }
+
+  @Override
+  public void extractTerms(Set<Term> terms) {
+    for (final SpansEnumQuery clause : clauses) {
+      clause.extractTerms(terms);
+    }
+  }
+
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("spanNear([");
+    Iterator<SpansEnumQuery> i = clauses.iterator();
+    while (i.hasNext()) {
+      SpansEnumQuery clause = i.next();
+      buffer.append(clause.toString(field));
+      if (i.hasNext()) {
+        buffer.append(", ");
+      }
+    }
+    buffer.append("], ");
+    buffer.append(slop);
+    buffer.append(", ");
+    buffer.append(inOrder);
+    buffer.append(")");
+    buffer.append(ToStringUtils.boost(getBoost()));
+    return buffer.toString();
+  }
+
+  @Override
+  public SpansEnum getSpans(final LeafReaderContext context, Bits acceptDocs, Map<Term,TermContext> termContexts) throws IOException {
+    ArrayList<SpansEnum> subSpans = new ArrayList<>(clauses.size());
+
+    for (SpansEnumQuery seq : clauses) {
+      SpansEnum subSpan = seq.getSpans(context, acceptDocs, termContexts);
+      if (subSpan != null) {
+        subSpans.add(subSpan);
+      } else {
+        return null; // all required
+      }
+    }
+
+    return inOrder ? new NearSpansEnumOrdered(this, subSpans)
+                   : new NearSpansEnumUnordered(this, subSpans);
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    SpansEnumNearQuery clone = null;
+    for (int i = 0 ; i < clauses.size(); i++) {
+      SpansEnumQuery c = clauses.get(i);
+      SpansEnumQuery query = (SpansEnumQuery) c.rewrite(reader);
+      if (query != c) {                     // clause rewrote: must clone
+        if (clone == null)
+          clone = this.clone();
+        clone.clauses.set(i,query);
+      }
+    }
+    if (clone != null) {
+      return clone; // some clauses rewrote
+    } else {
+      return this; // no clauses rewrote
+    }
+  }
+
+  @Override
+  public SpansEnumNearQuery clone() {
+    int sz = clauses.size();
+    SpansEnumQuery[] newClauses = new SpansEnumQuery[sz];
+
+    for (int i = 0; i < sz; i++) {
+      newClauses[i] = (SpansEnumQuery) clauses.get(i).clone();
+    }
+    SpansEnumNearQuery spanNearQuery = new SpansEnumNearQuery(newClauses, slop, inOrder);
+    spanNearQuery.setBoost(getBoost());
+    return spanNearQuery;
+  }
+
+  /** Returns true iff <code>o</code> is equal to this. */
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof SpansEnumNearQuery)) return false;
+
+    final SpansEnumNearQuery spanNearQuery = (SpansEnumNearQuery) o;
+
+    if (inOrder != spanNearQuery.inOrder) return false;
+    if (slop != spanNearQuery.slop) return false;
+    if (!clauses.equals(spanNearQuery.clauses)) return false;
+
+    return getBoost() == spanNearQuery.getBoost();
+  }
+
+  @Override
+  public int hashCode() {
+    int result;
+    result = clauses.hashCode();
+    // Mix bits before folding in things like boost, since it could cancel the
+    // last element of clauses.  This particular mix also serves to
+    // differentiate SpanNearQuery hashcodes from others.
+    result ^= (result << 14) | (result >>> 19);  // reversible
+    result += Float.floatToRawIntBits(getBoost());
+    result += slop;
+    result ^= (inOrder ? 0x99AFD3BD : 0);
+    return result;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumNotQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumNotQuery.java
new file mode 100644
index 0000000..d30a62a
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumNotQuery.java
@@ -0,0 +1,322 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.ToStringUtils;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+
+/** Removes matches which overlap with another SpansEnumQuery or which are
+ * within x tokens before or y tokens after another SpansEnumQuery.
+ */
+public class SpansEnumNotQuery extends SpansEnumQuery implements Cloneable {
+  private SpansEnumQuery include;
+  private SpansEnumQuery exclude;
+  private final int pre;
+  private final int post;
+
+  /** Construct a SpansEnumNotQuery matching spans from <code>include</code> which
+   * have no overlap with spans from <code>exclude</code>.*/
+  public SpansEnumNotQuery(SpansEnumQuery include, SpansEnumQuery exclude) {
+     this(include, exclude, 0, 0);
+  }
+
+
+  /** Construct a SpansEnumNotQuery matching spans from <code>include</code> which
+   * have no overlap with spans from <code>exclude</code> within
+   * <code>dist</code> tokens of <code>include</code>. */
+  public SpansEnumNotQuery(SpansEnumQuery include, SpansEnumQuery exclude, int dist) {
+     this(include, exclude, dist, dist);
+  }
+
+  /** Construct a SpansEnumNotQuery matching spans from <code>include</code> which
+   * have no overlap with spans from <code>exclude</code> within
+   * <code>pre</code> tokens before or <code>post</code> tokens of <code>include</code>. */
+  public SpansEnumNotQuery(SpansEnumQuery include, SpansEnumQuery exclude, int pre, int post) {
+    this.include = include;
+    this.exclude = exclude;
+    this.pre = (pre >=0) ? pre : 0;
+    this.post = (post >= 0) ? post : 0;
+
+    if (include.getField() != null && exclude.getField() != null && !include.getField().equals(exclude.getField()))
+      throw new IllegalArgumentException("Clauses must have same field.");
+  }
+
+  /** Return the SpansEnumQuery whose matches are filtered. */
+  public SpansEnumQuery getInclude() { return include; }
+
+  /** Return the SpansEnumQuery whose matches must not overlap those returned. */
+  public SpansEnumQuery getExclude() { return exclude; }
+
+  @Override
+  public String getField() { return include.getField(); }
+
+  @Override
+  public void extractTerms(Set<Term> terms) { include.extractTerms(terms); }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("spansEnumNot(");
+    buffer.append(include.toString(field));
+    buffer.append(", ");
+    buffer.append(exclude.toString(field));
+    buffer.append(", ");
+    buffer.append(Integer.toString(pre));
+    buffer.append(", ");
+    buffer.append(Integer.toString(post));
+    buffer.append(")");
+    buffer.append(ToStringUtils.boost(getBoost()));
+    return buffer.toString();
+  }
+
+  @Override
+  public SpansEnumNotQuery clone() {
+    SpansEnumNotQuery spansEnumNotQuery = new SpansEnumNotQuery((SpansEnumQuery) include.clone(),
+                                                                (SpansEnumQuery) exclude.clone(), pre, post);
+    spansEnumNotQuery.setBoost(getBoost());
+    return spansEnumNotQuery;
+  }
+
+  @Override
+  public SpansEnum getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {
+    SpansEnum includeSpans = include.getSpans(context, acceptDocs, termContexts);
+    if (includeSpans == null) {
+      return null;
+    }
+
+    SpansEnum excludeSpans = exclude.getSpans(context, acceptDocs, termContexts);
+    if (excludeSpans == null) {
+      return includeSpans;
+    }
+
+    return new SpansEnum() {
+      private boolean moreInclude = true;
+      private int includeStart = -1;
+      private int includeEnd = -1;
+      private boolean atFirstInCurrentDoc = false;
+
+      private boolean moreExclude = excludeSpans.nextDoc() != NO_MORE_DOCS;
+      private int excludeStart = moreExclude ? excludeSpans.nextStartPosition() : NO_MORE_POSITIONS;
+
+
+      @Override
+      public int nextDoc() throws IOException {
+        if (moreInclude) {
+          moreInclude = includeSpans.nextDoc() != NO_MORE_DOCS;
+          if (moreInclude) {
+            atFirstInCurrentDoc = true;
+            includeStart = includeSpans.nextStartPosition();
+            assert includeStart != NO_MORE_POSITIONS;
+          }
+        }
+        toNextIncluded();
+        int res = moreInclude ? includeSpans.docID() : NO_MORE_DOCS;
+        return res;
+      }
+
+      private void toNextIncluded() throws IOException {
+        while (moreInclude && moreExclude) {
+          if (includeSpans.docID() > excludeSpans.docID()) {
+            moreExclude = excludeSpans.advance(includeSpans.docID()) != NO_MORE_DOCS;
+            if (moreExclude) {
+              excludeStart = -1; // only use exclude positions at same doc
+            }
+          }
+          if (excludeForwardInCurrentDocAndAtMatch()) {
+            break; // at match.
+          }
+
+          // else intersected: keep scanning, to next doc if needed
+          includeStart = includeSpans.nextStartPosition();
+          if (includeStart == NO_MORE_POSITIONS) {
+            moreInclude = includeSpans.nextDoc() != NO_MORE_DOCS;
+            if (moreInclude) {
+              atFirstInCurrentDoc = true;
+              includeStart = includeSpans.nextStartPosition();
+              assert includeStart != NO_MORE_POSITIONS;
+            }
+          }
+        }
+      }
+
+      private boolean excludeForwardInCurrentDocAndAtMatch() throws IOException {
+        assert moreInclude;
+        assert includeStart != NO_MORE_POSITIONS;
+        if (! moreExclude) {
+          return true;
+        }
+        if (includeSpans.docID() != excludeSpans.docID()) {
+          return true;
+        }
+        // at same doc
+        if (excludeStart == -1) { // init exclude start position if needed
+          excludeStart = excludeSpans.nextStartPosition();
+          assert excludeStart != NO_MORE_POSITIONS;
+        }
+        while (excludeSpans.endPosition() <= includeStart - pre) {
+          // exclude end position is before a possible exclusion
+          excludeStart = excludeSpans.nextStartPosition();
+          if (excludeStart == NO_MORE_POSITIONS) {
+            return true; // no more exclude at current doc.
+          }
+        }
+        // exclude end position far enough in current doc, check start position:
+        boolean res = includeSpans.endPosition() + post <= excludeStart;
+        return res;
+      }
+
+      @Override
+      public int advance(int target) throws IOException {
+        if (moreInclude) {
+          assert target > includeSpans.docID() : "target="+target+", includeSpans.docID()="+includeSpans.docID();
+          moreInclude = includeSpans.advance(target) != NO_MORE_DOCS;
+          if (moreInclude) {
+            atFirstInCurrentDoc = true;
+            includeStart = includeSpans.nextStartPosition();
+            assert includeStart != NO_MORE_POSITIONS;
+          }
+        }
+        toNextIncluded();
+        int res = moreInclude ? includeSpans.docID() : NO_MORE_DOCS;
+        return res;
+      }
+
+      @Override
+      public int docID() {
+        int res = includeSpans.docID();
+        return res;
+      }
+
+      @Override
+      public int nextStartPosition() throws IOException {
+        assert moreInclude;
+
+        if (atFirstInCurrentDoc) {
+          atFirstInCurrentDoc = false;
+          assert includeStart != NO_MORE_POSITIONS;
+          return includeStart;
+        }
+
+        includeStart = includeSpans.nextStartPosition();
+        while ((includeStart != NO_MORE_POSITIONS)
+            && (! excludeForwardInCurrentDocAndAtMatch()))
+        {
+          includeStart = includeSpans.nextStartPosition();
+        }
+
+        return includeStart;
+      }
+
+      @Override
+      public int startPosition() {
+        assert includeStart == includeSpans.startPosition();
+        return atFirstInCurrentDoc ? -1 : includeStart;
+      }
+
+      @Override
+      public int endPosition() {
+        return atFirstInCurrentDoc ? -1 : includeSpans.endPosition();
+      }
+
+      @Override
+      public Collection<byte[]> getPayload() throws IOException {
+        ArrayList<byte[]> result = null;
+        if (includeSpans.isPayloadAvailable()) {
+          result = new ArrayList<>(includeSpans.getPayload());
+        }
+        return result;
+      }
+
+      @Override
+      public boolean isPayloadAvailable() throws IOException {
+        return includeSpans.isPayloadAvailable();
+      }
+
+      @Override
+      public long cost() {
+        return 2 * includeSpans.cost();
+      }
+
+      @Override
+      public String toString() {
+        return "spansEnum(" + SpansEnumNotQuery.this.toString() + ")";
+      }
+    };
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    SpansEnumNotQuery clone = null;
+
+    SpansEnumQuery rewrittenInclude = (SpansEnumQuery) include.rewrite(reader);
+    if (rewrittenInclude != include) {
+      clone = this.clone();
+      clone.include = rewrittenInclude;
+    }
+    SpansEnumQuery rewrittenExclude = (SpansEnumQuery) exclude.rewrite(reader);
+    if (rewrittenExclude != exclude) {
+      if (clone == null) clone = this.clone();
+      clone.exclude = rewrittenExclude;
+    }
+
+    if (clone != null) {
+      return clone;                        // some clauses rewrote
+    } else {
+      return this;                         // no clauses rewrote
+    }
+  }
+
+    /** Returns true iff <code>o</code> is equal to this. */
+  @Override
+  public boolean equals(Object o) {
+    if (!super.equals(o))
+      return false;
+
+    SpansEnumNotQuery other = (SpansEnumNotQuery)o;
+    return this.include.equals(other.include)
+            && this.exclude.equals(other.exclude)
+            && this.pre == other.pre
+            && this.post == other.post;
+  }
+
+  @Override
+  public int hashCode() {
+    int h = super.hashCode();
+    h = Integer.rotateLeft(h, 1);
+    h ^= include.hashCode();
+    h = Integer.rotateLeft(h, 1);
+    h ^= exclude.hashCode();
+    h = Integer.rotateLeft(h, 1);
+    h ^= pre;
+    h = Integer.rotateLeft(h, 1);
+    h ^= post;
+    return h;
+  }
+
+}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumOrQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumOrQuery.java
new file mode 100644
index 0000000..d83b089
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumOrQuery.java
@@ -0,0 +1,304 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import java.util.List;
+import java.util.Collection;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.PriorityQueue;
+import org.apache.lucene.util.ToStringUtils;
+import org.apache.lucene.search.Query;
+
+/** Matches the union of its clauses.
+ */
+public class SpansEnumOrQuery extends SpansEnumQuery implements Cloneable {
+  private List<SpansEnumQuery> clauses;
+  private String field;
+
+  /** Construct a SpansEnumOrQuery merging the provided clauses. */
+  public SpansEnumOrQuery(SpansEnumQuery... clauses) {
+    this.clauses = new ArrayList<>(clauses.length);
+    for (SpansEnumQuery seq : clauses) {
+      addClause(seq);
+    }
+  }
+
+  /** Adds a clause to this query */
+  public final void addClause(SpansEnumQuery clause) {
+    if (field == null) {
+      field = clause.getField();
+    } else if (clause.getField() != null && !clause.getField().equals(field)) {
+      throw new IllegalArgumentException("Clauses must have same field.");
+    }
+    this.clauses.add(clause);
+  }
+
+  /** Return the clauses whose spans are matched. */
+  public SpansEnumQuery[] getClauses() {
+    return clauses.toArray(new SpansEnumQuery[clauses.size()]);
+  }
+
+  @Override
+  public String getField() { return field; }
+
+  @Override
+  public void extractTerms(Set<Term> terms) {
+    for(final SpansEnumQuery clause: clauses) {
+      clause.extractTerms(terms);
+    }
+  }
+
+  @Override
+  public SpansEnumOrQuery clone() {
+    int sz = clauses.size();
+    SpansEnumQuery[] newClauses = new SpansEnumQuery[sz];
+
+    for (int i = 0; i < sz; i++) {
+      newClauses[i] = (SpansEnumQuery) clauses.get(i).clone();
+    }
+    SpansEnumOrQuery soq = new SpansEnumOrQuery(newClauses);
+    soq.setBoost(getBoost());
+    return soq;
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    SpansEnumOrQuery clone = null;
+    for (int i = 0 ; i < clauses.size(); i++) {
+      SpansEnumQuery c = clauses.get(i);
+      SpansEnumQuery query = (SpansEnumQuery) c.rewrite(reader);
+      if (query != c) {                     // clause rewrote: must clone
+        if (clone == null)
+          clone = this.clone();
+        clone.clauses.set(i,query);
+      }
+    }
+    if (clone != null) {
+      return clone;                        // some clauses rewrote
+    } else {
+      return this;                         // no clauses rewrote
+    }
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("SpansEnumOrQuery([");
+    Iterator<SpansEnumQuery> i = clauses.iterator();
+    while (i.hasNext()) {
+      SpansEnumQuery clause = i.next();
+      buffer.append(clause.toString(field));
+      if (i.hasNext()) {
+        buffer.append(", ");
+      }
+    }
+    buffer.append("])");
+    buffer.append(ToStringUtils.boost(getBoost()));
+    return buffer.toString();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+
+    final SpansEnumOrQuery that = (SpansEnumOrQuery) o;
+
+    if (!clauses.equals(that.clauses)) return false;
+
+    return getBoost() == that.getBoost();
+  }
+
+  @Override
+  public int hashCode() {
+    int h = clauses.hashCode();
+    h ^= (h << 10) | (h >>> 23);
+    h ^= Float.floatToRawIntBits(getBoost());
+    return h;
+  }
+
+
+  private class SpanQueue extends PriorityQueue<SpansEnum> {
+    public SpanQueue(int size) {
+      super(size);
+    }
+
+    @Override
+    protected final boolean lessThan(SpansEnum spans1, SpansEnum spans2) {
+      if (spans1.docID() == spans2.docID()) {
+        if (spans1.startPosition() == spans2.startPosition()) {
+          return spans1.endPosition() < spans2.endPosition();
+        } else {
+          return spans1.startPosition() < spans2.startPosition();
+        }
+      } else {
+        return spans1.docID() < spans2.docID();
+      }
+    }
+  }
+
+  @Override
+  public SpansEnum getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts)
+  throws IOException {
+
+    ArrayList<SpansEnum> subSpans = new ArrayList<>(clauses.size());
+
+    for (SpansEnumQuery seq : clauses) {
+      SpansEnum subSpan = seq.getSpans(context, acceptDocs, termContexts);
+      if (subSpan != null) {
+        subSpans.add(subSpan);
+      }
+    }
+
+    if (subSpans.size() == 0) {
+      return null;
+    } else if (subSpans.size() == 1) {
+      return subSpans.get(0);
+    }
+
+    SpanQueue queue = new SpanQueue(clauses.size());
+    for (SpansEnum spans : subSpans) {
+      queue.add(spans);
+    }
+
+    return new SpansEnum() {
+
+      @Override
+      public int nextDoc() throws IOException {
+        if (queue.size() == 0) { // all done
+          return NO_MORE_DOCS;
+        }
+
+        int currentDoc = top().docID();
+
+        if (currentDoc == -1) { // initially
+          return advance(0);
+        }
+
+        do {
+          if (top().nextDoc() != NO_MORE_DOCS) { // move top to next doc
+            queue.updateTop();
+          } else {
+            queue.pop(); // exhausted a clause
+            if (queue.size() == 0) {
+              return NO_MORE_DOCS;
+            }
+          }
+          // assert queue.size() > 0;
+          int doc = top().docID();
+          if (doc > currentDoc) {
+            return doc;
+          }
+        } while (true);
+      }
+
+      private SpansEnum top() {
+        return queue.top();
+      }
+
+      @Override
+      public int advance(int target) throws IOException {
+
+        while ((queue.size() > 0) && (top().docID() < target)) {
+          if (top().advance(target) != NO_MORE_DOCS) {
+            queue.updateTop();
+          } else {
+            queue.pop();
+          }
+        }
+
+        return (queue.size() > 0) ? top().docID() : NO_MORE_DOCS;
+      }
+
+      @Override
+      public int docID() {
+        return (queue == null) ? -1
+              : (queue.size() > 0) ? top().docID()
+              : NO_MORE_DOCS;
+      }
+
+      @Override
+      public int nextStartPosition() throws IOException {
+        top().nextStartPosition();
+        queue.updateTop();
+        int startPos = top().startPosition();
+        while (startPos == -1) { // initially at this doc
+          top().nextStartPosition();
+          queue.updateTop();
+          startPos = top().startPosition();
+        }
+        return startPos;
+      }
+
+      @Override
+      public int startPosition() {
+        return top().startPosition();
+      }
+
+      @Override
+      public int endPosition() {
+        return top().endPosition();
+      }
+
+      @Override
+      public Collection<byte[]> getPayload() throws IOException {
+        ArrayList<byte[]> result = null;
+        SpansEnum theTop = top();
+        if (theTop != null && theTop.isPayloadAvailable()) {
+          result = new ArrayList<>(theTop.getPayload());
+        }
+        return result;
+      }
+
+      @Override
+      public boolean isPayloadAvailable() throws IOException {
+        SpansEnum top = top();
+        return top != null && top.isPayloadAvailable();
+      }
+
+      @Override
+      public String toString() {
+          return "SpansEnum("+SpansEnumOrQuery.this+")@"+
+            ((queue == null)?"START"
+             :(queue.size()>0?(docID()+": "+top().startPosition()+" - "+top().endPosition()):"END"));
+      }
+
+      @Override
+      public long cost() {
+        long cost = 0;
+        for (SpansEnum spans : subSpans) {
+          cost += spans.cost();
+        }
+        return cost;
+      }
+
+    };
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumPayloadCheckQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumPayloadCheckQuery.java
new file mode 100644
index 0000000..2d53863
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumPayloadCheckQuery.java
@@ -0,0 +1,117 @@
+package org.apache.lucene.search.spans;
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.util.ToStringUtils;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+
+
+/**
+ * Only return those matches that have a specific payload at
+ * the given position.
+ * <p>
+ * Do not use this with a SpansEnumQuery that contains a {@link org.apache.lucene.search.spans.SpansEnumNearQuery}.
+ * Instead, use {@link SpansEnumNearPayloadCheckQuery} since it properly handles the fact that payloads
+ * aren't ordered by {@link org.apache.lucene.search.spans.SpansEnumNearQuery}.
+ */
+public class SpansEnumPayloadCheckQuery extends SpansEnumPositionCheckQuery {
+  protected final Collection<byte[]> payloadToMatch;
+
+  /**
+   * @param match The underlying {@link org.apache.lucene.search.spans.SpansEnumQuery} to check
+   * @param payloadToMatch The {@link java.util.Collection} of payloads to match
+   */
+  public SpansEnumPayloadCheckQuery(SpansEnumQuery match, Collection<byte[]> payloadToMatch) {
+    super(match);
+    if (match instanceof SpansEnumNearQuery){
+      throw new IllegalArgumentException("SpansEnumNearQuery not allowed");
+    }
+    this.payloadToMatch = payloadToMatch;
+  }
+
+  @Override
+  protected AcceptStatus acceptPosition(SpansEnum spans) throws IOException {
+    boolean result = spans.isPayloadAvailable();
+    if (result == true){
+      Collection<byte[]> candidate = spans.getPayload();
+      if (candidate.size() == payloadToMatch.size()){
+        //TODO: check the byte arrays are the same
+        Iterator<byte[]> toMatchIter = payloadToMatch.iterator();
+        //check each of the byte arrays, in order
+        //hmm, can't rely on order here
+        for (byte[] candBytes : candidate) {
+          //if one is a mismatch, then return false
+          if (Arrays.equals(candBytes, toMatchIter.next()) == false){
+            return AcceptStatus.NO;
+          }
+        }
+        //we've verified all the bytes
+        return AcceptStatus.YES;
+      } else {
+        return AcceptStatus.NO;
+      }
+    }
+    return AcceptStatus.YES;
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("spanPayCheck(");
+    buffer.append(match.toString(field));
+    buffer.append(", payloadRef: ");
+    for (byte[] bytes : payloadToMatch) {
+      ToStringUtils.byteArray(buffer, bytes);
+      buffer.append(';');
+    }
+    buffer.append(")");
+    buffer.append(ToStringUtils.boost(getBoost()));
+    return buffer.toString();
+  }
+
+  @Override
+  public SpansEnumPayloadCheckQuery clone() {
+    SpansEnumPayloadCheckQuery result = new SpansEnumPayloadCheckQuery((SpansEnumQuery) match.clone(), payloadToMatch);
+    result.setBoost(getBoost());
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof SpansEnumPayloadCheckQuery)) return false;
+
+    SpansEnumPayloadCheckQuery other = (SpansEnumPayloadCheckQuery)o;
+    return this.payloadToMatch.equals(other.payloadToMatch)
+         && this.match.equals(other.match)
+         && this.getBoost() == other.getBoost();
+  }
+
+  @Override
+  public int hashCode() {
+    int h = match.hashCode() ^ getClass().hashCode();
+    h ^= (h << 8) | (h >>> 25);  // reversible
+    //TODO: is this right?
+    h ^= payloadToMatch.hashCode();
+    h ^= Float.floatToRawIntBits(getBoost()) ;
+    return h;
+  }
+}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumPositionCheckQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumPositionCheckQuery.java
new file mode 100644
index 0000000..6664391
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumPositionCheckQuery.java
@@ -0,0 +1,212 @@
+package org.apache.lucene.search.spans;
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.util.Bits;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+
+
+/**
+ * Base class for filtering a SpansEnumQuery based on the position of a match.
+ **/
+public abstract class SpansEnumPositionCheckQuery extends SpansEnumQuery implements Cloneable {
+  protected SpansEnumQuery match;
+
+
+  public SpansEnumPositionCheckQuery(SpansEnumQuery match) {
+    this.match = match;
+  }
+
+  /**
+   * @return the SpansEnumQuery whose matches are filtered.
+   *
+   * */
+  public SpansEnumQuery getMatch() { return match; }
+
+
+
+  @Override
+  public String getField() { return match.getField(); }
+
+
+
+  @Override
+  public void extractTerms(Set<Term> terms) {
+    match.extractTerms(terms);
+  }
+
+  /**
+   * Return value for {@link SpansEnumPositionCheckQuery#acceptPosition(SpansEnum)}.
+   */
+  protected static enum AcceptStatus {
+    /** Indicates the match should be accepted */
+    YES,
+
+    /** Indicates the match should be rejected */
+    NO,
+
+    /**
+     * Indicates the match should be rejected, and the enumeration may continue
+     * with the next document.
+     */
+    NO_MORE_IN_CURRENT_DOC
+  };
+
+  /**
+   * Implementing classes are required to return whether the current position is a match for the passed in
+   * "match" {@link SpansEnumQuery}.
+   *
+   * This is only called if the underlying last {@link SpansEnum#nextStartPosition()} for the
+   * match indicated a valid start position.
+   *
+   *
+   * @param spans The {@link SpansEnum} instance, positioned at the spot to check
+   *
+   * @return whether the match is accepted, rejected, or rejected and should move to the next doc.
+   *
+   * @see SpansEnum#nextDoc()
+   *
+   */
+  protected abstract AcceptStatus acceptPosition(SpansEnum spans) throws IOException;
+
+  @Override
+  public SpansEnum getSpans(final LeafReaderContext context, Bits acceptDocs, Map<Term,TermContext> termContexts) throws IOException {
+    SpansEnum matchSpans = match.getSpans(context, acceptDocs, termContexts);
+    return (matchSpans == null) ? null : new PositionCheckSpansEnum(matchSpans);
+  }
+
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    SpansEnumPositionCheckQuery clone = null;
+
+    SpansEnumQuery rewritten = (SpansEnumQuery) match.rewrite(reader);
+    if (rewritten != match) {
+      clone = (SpansEnumPositionCheckQuery) this.clone();
+      clone.match = rewritten;
+    }
+
+    if (clone != null) {
+      return clone;                        // some clauses rewrote
+    } else {
+      return this;                         // no clauses rewrote
+    }
+  }
+
+  protected class PositionCheckSpansEnum extends FilterSpansEnum {
+
+    private boolean atFirstInCurrentDoc = false;
+    private int startPos = -1;
+
+    public PositionCheckSpansEnum(SpansEnum matchSpans) throws IOException {
+      super(matchSpans);
+    }
+
+    @Override
+    public int nextDoc() throws IOException {
+      if (in.nextDoc() == NO_MORE_DOCS)
+        return NO_MORE_DOCS;
+
+      return toNextDocWithAllowedPosition();
+    }
+
+    @Override
+    public int advance(int target) throws IOException {
+      if (in.advance(target) == NO_MORE_DOCS)
+        return NO_MORE_DOCS;
+
+      return toNextDocWithAllowedPosition();
+    }
+
+    @SuppressWarnings("fallthrough")
+    protected int toNextDocWithAllowedPosition() throws IOException {
+      startPos = in.nextStartPosition();
+      assert startPos != NO_MORE_POSITIONS;
+      for (;;) {
+        switch(acceptPosition(this)) {
+          case YES:
+            atFirstInCurrentDoc = true;
+            return in.docID();
+          case NO:
+            startPos = in.nextStartPosition();
+            if (startPos != NO_MORE_POSITIONS) {
+              break;
+            }
+            // else fallthrough
+          case NO_MORE_IN_CURRENT_DOC:
+            if (in.nextDoc() == NO_MORE_DOCS) {
+              startPos = -1;
+              return NO_MORE_DOCS;
+            }
+            startPos = in.nextStartPosition();
+            assert startPos != NO_MORE_POSITIONS : "no start position at doc="+in.docID();
+            break;
+        }
+      }
+    }
+
+    @Override
+    public int nextStartPosition() throws IOException {
+      if (atFirstInCurrentDoc) {
+        atFirstInCurrentDoc = false;
+        return startPos;
+      }
+
+      for (;;) {
+        startPos = in.nextStartPosition();
+        if (startPos == NO_MORE_POSITIONS) {
+          return NO_MORE_POSITIONS;
+        }
+        switch(acceptPosition(this)) {
+          case YES:
+            return startPos;
+          case NO:
+            break;
+          case NO_MORE_IN_CURRENT_DOC:
+            return startPos = NO_MORE_POSITIONS; // startPos ahead for the current doc.
+        }
+      }
+    }
+
+    @Override
+    public int startPosition() {
+      return atFirstInCurrentDoc ? -1 : startPos;
+    }
+
+    @Override
+    public int endPosition() {
+      return atFirstInCurrentDoc ? -1
+            : (startPos != NO_MORE_POSITIONS) ? in.endPosition() : NO_MORE_POSITIONS;
+    }
+
+    @Override
+    public String toString() {
+      return "SpansEnum(" + SpansEnumPositionCheckQuery.this.toString() + ")";
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumPositionRangeQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumPositionRangeQuery.java
new file mode 100644
index 0000000..8ae1818
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumPositionRangeQuery.java
@@ -0,0 +1,104 @@
+package org.apache.lucene.search.spans;
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import org.apache.lucene.util.ToStringUtils;
+
+import java.io.IOException;
+
+
+/**
+ * Checks to see if the {@link #getMatch()} lies between a start and end position
+ *
+ * See {@link SpansEnumFirstQuery} for a derivation that is optimized for the case where start position is 0.
+ */
+public class SpansEnumPositionRangeQuery extends SpansEnumPositionCheckQuery {
+  protected int start;
+  protected int end;
+
+  public SpansEnumPositionRangeQuery(SpansEnumQuery match, int start, int end) {
+    super(match);
+    this.start = start;
+    this.end = end;
+  }
+
+
+  @Override
+  protected AcceptStatus acceptPosition(SpansEnum spans) throws IOException {
+    assert spans.startPosition() != spans.endPosition();
+    AcceptStatus res = (spans.startPosition() >= end)
+                      ? AcceptStatus.NO_MORE_IN_CURRENT_DOC
+                      : (spans.startPosition() >= start && spans.endPosition() <= end)
+                      ? AcceptStatus.YES : AcceptStatus.NO;
+    return res;
+  }
+
+
+  /**
+   * @return The minimum position permitted in a match
+   */
+  public int getStart() {
+    return start;
+  }
+
+  /**
+   * @return the maximum end position permitted in a match.
+   */
+  public int getEnd() {
+    return end;
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("SpansEnumPosRange(");
+    buffer.append(match.toString(field));
+    buffer.append(", ").append(start).append(", ");
+    buffer.append(end);
+    buffer.append(")");
+    buffer.append(ToStringUtils.boost(getBoost()));
+    return buffer.toString();
+  }
+
+  @Override
+  public SpansEnumPositionRangeQuery clone() {
+    SpansEnumPositionRangeQuery result = new SpansEnumPositionRangeQuery((SpansEnumQuery) match.clone(), start, end);
+    result.setBoost(getBoost());
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof SpansEnumPositionRangeQuery)) return false;
+
+    SpansEnumPositionRangeQuery other = (SpansEnumPositionRangeQuery)o;
+    return this.end == other.end && this.start == other.start
+         && this.match.equals(other.match)
+         && this.getBoost() == other.getBoost();
+  }
+
+  @Override
+  public int hashCode() {
+    int h = match.hashCode() ^ getClass().hashCode();
+    h ^= (h << 8) | (h >>> 25);  // reversible
+    h ^= Float.floatToRawIntBits(getBoost()) ^ end ^ start;
+    return h;
+  }
+
+}
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumQuery.java
new file mode 100644
index 0000000..64c3b05
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumQuery.java
@@ -0,0 +1,50 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Map;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.util.Bits;
+
+/** Base class for span-based queries. */
+public abstract class SpansEnumQuery extends Query {
+  /** Expert: Returns the matches for this query in an index.  
+   *  Used internally to search for spans.
+   *  This may return null to indicate that the SpansEnumQuery has no results.
+   */
+  public abstract SpansEnum getSpans(LeafReaderContext context, Bits acceptDocs, Map<Term,TermContext> termContexts) throws IOException;
+
+  /**
+   * Returns the name of the field matched by this query.
+   * <p>
+   * Note that this may return null if the query matches no terms.
+   */
+  public abstract String getField();
+
+  @Override
+  public SpansEnumWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    return new SpansEnumWeight(this, searcher);
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumScorer.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumScorer.java
new file mode 100644
index 0000000..2032638
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumScorer.java
@@ -0,0 +1,123 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.similarities.Similarity;
+
+/**
+ * Public for extension only.
+ */
+public class SpansEnumScorer extends Scorer {
+  protected SpansEnum spans;
+
+  protected int doc;
+  protected float freq;
+  protected int numMatches;
+  protected final Similarity.SimScorer docScorer;
+
+  protected SpansEnumScorer(SpansEnum spans, SpansEnumWeight weight, Similarity.SimScorer docScorer)
+  throws IOException {
+    super(weight);
+    this.docScorer = docScorer;
+    assert spans != null;
+    this.spans = spans;
+    this.doc = -1;
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    int prevDoc = doc;
+    doc = spans.nextDoc();
+    if (doc != NO_MORE_DOCS) {
+      setFreqCurrentDoc();
+    }
+    return doc;
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    int prevDoc = doc;
+    doc = spans.advance(target);
+    if (doc != NO_MORE_DOCS) {
+      setFreqCurrentDoc();
+    }
+    return doc;
+  }
+
+  protected boolean setFreqCurrentDoc() throws IOException {
+    freq = 0.0f;
+    numMatches = 0;
+
+    assert spans.startPosition() == -1 : "incorrect initial start position, spans="+spans;
+    assert spans.endPosition() == -1 : "incorrect initial end position, spans="+spans;
+    int prevStartPos = -1;
+    int prevEndPos = -1;
+
+    int startPos = spans.nextStartPosition();
+    assert startPos != SpansEnum.NO_MORE_POSITIONS : "initial startPos NO_MORE_POSITIONS, spans="+spans;
+    do {
+      assert startPos >= prevStartPos;
+      int endPos = spans.endPosition();
+      assert endPos != SpansEnum.NO_MORE_POSITIONS;
+      // This assertion can fail for Or spans on the same term:
+      // assert (startPos != prevStartPos) || (endPos > prevEndPos) : "non increased endPos="+endPos;
+      assert (startPos != prevStartPos) || (endPos >= prevEndPos) : "decreased endPos="+endPos;
+      numMatches++;
+      int matchLength = endPos - startPos;
+      freq += docScorer.computeSlopFactor(matchLength);
+      prevStartPos = startPos;
+      prevEndPos = endPos;
+      startPos = spans.nextStartPosition();
+    } while (startPos != SpansEnum.NO_MORE_POSITIONS);
+
+    assert spans.startPosition() == SpansEnum.NO_MORE_POSITIONS : "incorrect final start position, spans="+spans;
+    assert spans.endPosition() == SpansEnum.NO_MORE_POSITIONS : "incorrect final end position, spans="+spans;
+
+    return true;
+  }
+
+  @Override
+  public int docID() { return doc; }
+
+  @Override
+  public float score() throws IOException {
+    float s = docScorer.score(doc, freq);
+    return s;
+  }
+
+  @Override
+  public int freq() throws IOException {
+    return numMatches;
+  }
+
+  /** Returns the intermediate "sloppy freq" adjusted for edit distance
+   *  @lucene.internal */
+  // only public so .payloads can see it.
+  public float sloppyFreq() throws IOException {
+    return freq;
+  }
+
+  @Override
+  public long cost() {
+    return spans.cost();
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumTermQuery.java
new file mode 100644
index 0000000..0124451
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumTermQuery.java
@@ -0,0 +1,126 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.index.TermState;
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.ToStringUtils;
+
+/** Matches spans containing a term. */
+public class SpansEnumTermQuery extends SpansEnumQuery {
+  protected Term term;
+
+  /** Construct a SpansEnumTermQuery matching the named term's spans. */
+  public SpansEnumTermQuery(Term term) { this.term = term; }
+
+  /** Return the term whose spans are matched. */
+  public Term getTerm() { return term; }
+
+  @Override
+  public String getField() { return term.field(); }
+
+  @Override
+  public void extractTerms(Set<Term> terms) {
+    terms.add(term);
+  }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    if (term.field().equals(field))
+      buffer.append(term.text());
+    else
+      buffer.append(term.toString());
+    buffer.append(ToStringUtils.boost(getBoost()));
+    return buffer.toString();
+  }
+
+  @Override
+  public int hashCode() {
+    final int prime = 31;
+    int result = super.hashCode();
+    result = prime * result + ((term == null) ? 0 : term.hashCode());
+    return result;
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj)
+      return true;
+    if (!super.equals(obj))
+      return false;
+    if (getClass() != obj.getClass())
+      return false;
+    SpansEnumTermQuery other = (SpansEnumTermQuery) obj;
+    if (term == null) {
+      if (other.term != null)
+        return false;
+    } else if (!term.equals(other.term))
+      return false;
+    return true;
+  }
+
+  @Override
+  public SpansEnum getSpans(final LeafReaderContext context, Bits acceptDocs, Map<Term,TermContext> termContexts) throws IOException {
+    TermContext termContext = termContexts.get(term);
+    final TermState state;
+    if (termContext == null) {
+      // this happens with span-not query, as it doesn't include the NOT side in extractTerms()
+      // so we seek to the term now in this segment..., this sucks because it's ugly mostly!
+      final Terms terms = context.reader().terms(term.field());
+      if (terms != null) {
+        final TermsEnum termsEnum = terms.iterator(null);
+        if (termsEnum.seekExact(term.bytes())) {
+          state = termsEnum.termState();
+        } else {
+          state = null;
+        }
+      } else {
+        state = null;
+      }
+    } else {
+      state = termContext.get(context.ord);
+    }
+
+    if (state == null) { // term is not present in that reader
+      return null;
+    }
+
+    final TermsEnum termsEnum = context.reader().terms(term.field()).iterator(null);
+    termsEnum.seekExact(term.bytes(), state);
+
+    final PostingsEnum postings = termsEnum.postings(acceptDocs, null, PostingsEnum.PAYLOADS);
+
+    if (postings != null) {
+      return new TermSpansEnum(postings, term);
+    } else {
+      // term does exist, but has no positions
+      throw new IllegalStateException("field \"" + term.field() + "\" was indexed without position data; cannot run SpanTermQuery (term=" + term.text() + ")");
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumWeight.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumWeight.java
new file mode 100644
index 0000000..f81a510
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpansEnumWeight.java
@@ -0,0 +1,116 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.TreeSet;
+
+import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.ComplexExplanation;
+import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.TermStatistics;
+import org.apache.lucene.search.Weight;
+import org.apache.lucene.search.similarities.Similarity;
+import org.apache.lucene.search.similarities.Similarity.SimScorer;
+import org.apache.lucene.util.Bits;
+
+/**
+ * Expert-only.  Public for use by other weight implementations
+ */
+public class SpansEnumWeight extends Weight {
+  protected final Similarity similarity;
+  protected final Map<Term,TermContext> termContexts;
+  protected final SpansEnumQuery query;
+  protected Similarity.SimWeight stats;
+
+  public SpansEnumWeight(SpansEnumQuery query, IndexSearcher searcher)
+    throws IOException {
+    super(query);
+    this.similarity = searcher.getSimilarity();
+    this.query = query;
+
+    termContexts = new HashMap<>();
+    TreeSet<Term> terms = new TreeSet<>();
+    query.extractTerms(terms);
+    final IndexReaderContext context = searcher.getTopReaderContext();
+    final TermStatistics termStats[] = new TermStatistics[terms.size()];
+    int i = 0;
+    for (Term term : terms) {
+      TermContext state = TermContext.build(context, term);
+      termStats[i] = searcher.termStatistics(term, state);
+      termContexts.put(term, state);
+      i++;
+    }
+    final String field = query.getField();
+    if (field != null) {
+      stats = similarity.computeWeight(query.getBoost(),
+                                       searcher.collectionStatistics(query.getField()),
+                                       termStats);
+    }
+  }
+
+  @Override
+  public float getValueForNormalization() throws IOException {
+    return stats == null ? 1.0f : stats.getValueForNormalization();
+  }
+
+  @Override
+  public void normalize(float queryNorm, float topLevelBoost) {
+    if (stats != null) {
+      stats.normalize(queryNorm, topLevelBoost);
+    }
+  }
+
+  @Override
+  public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
+    if (stats == null) {
+      return null;
+    }
+    SpansEnum spans = query.getSpans(context, acceptDocs, termContexts);
+    return (spans == null) ? null : new SpansEnumScorer(spans, this, similarity.simScorer(stats, context));
+  }
+
+  @Override
+  public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+    SpansEnumScorer scorer = (SpansEnumScorer) scorer(context, context.reader().getLiveDocs());
+    if (scorer != null) {
+      int newDoc = scorer.advance(doc);
+      if (newDoc == doc) {
+        float freq = scorer.sloppyFreq();
+        SimScorer docScorer = similarity.simScorer(stats, context);
+        ComplexExplanation result = new ComplexExplanation();
+        result.setDescription("weight("+getQuery()+" in "+doc+") [" + similarity.getClass().getSimpleName() + "], result of:");
+        Explanation scoreExplanation = docScorer.explain(doc, new Explanation(freq, "phraseFreq=" + freq));
+        result.addDetail(scoreExplanation);
+        result.setValue(scoreExplanation.getValue());
+        result.setMatch(true);
+        return result;
+      }
+    }
+
+    return new ComplexExplanation(false, 0.0f, "no matching term");
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
index bca88de..8de3fb5 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/TermSpans.java
@@ -28,7 +28,9 @@ import java.util.Collection;
 /**
  * Expert:
  * Public for extension only
+ * @deprecated Use {@link TermSpansEnum} instead.
  */
+@Deprecated
 public class TermSpans extends Spans {
   protected final PostingsEnum postings;
   protected final Term term;
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/TermSpansEnum.java b/lucene/core/src/java/org/apache/lucene/search/spans/TermSpansEnum.java
new file mode 100644
index 0000000..3fc12e8
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/TermSpansEnum.java
@@ -0,0 +1,139 @@
+package org.apache.lucene.search.spans;
+/**
+ * Copyright 2005 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.util.BytesRef;
+
+import java.io.IOException;
+import java.util.Collections;
+import java.util.Collection;
+
+/**
+ * Expert:
+ * Public for extension only
+ */
+public class TermSpansEnum extends SpansEnum {
+  protected final PostingsEnum postings;
+  protected final Term term;
+  protected int doc;
+  protected int freq;
+  protected int count;
+  protected int position;
+  protected boolean readPayload;
+
+  public TermSpansEnum(PostingsEnum postings, Term term) {
+    this.postings = postings;
+    this.term = term;
+    this.doc = -1;
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    doc = postings.nextDoc();
+    if (doc != DocIdSetIterator.NO_MORE_DOCS) {
+      freq = postings.freq();
+      assert freq >= 1;
+      count = 0;
+    }
+    position = -1;
+    return doc;
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    assert target > doc;
+    doc = postings.advance(target);
+    if (doc != DocIdSetIterator.NO_MORE_DOCS) {
+      freq = postings.freq();
+      assert freq >= 1;
+      count = 0;
+    }
+    position = -1;
+    return doc;
+  }
+
+  @Override
+  public int docID() {
+    return doc;
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    if (count == freq) {
+      assert position != NO_MORE_POSITIONS;
+      return position = NO_MORE_POSITIONS;
+    }
+    int prevPosition = position;
+    position = postings.nextPosition();
+    assert position >= prevPosition : "prevPosition="+prevPosition+" > position="+position;
+    count++;
+    readPayload = false;
+    return position;
+  }
+
+  @Override
+  public int startPosition() {
+    return position;
+  }
+
+  @Override
+  public int endPosition() {
+    return (position == -1) ? -1
+          : (position != NO_MORE_POSITIONS) ? position + 1
+          : NO_MORE_POSITIONS;
+  }
+
+  @Override
+  public long cost() {
+    return postings.cost();
+  }
+
+  @Override
+  public Collection<byte[]> getPayload() throws IOException {
+    final BytesRef payload = postings.getPayload();
+    readPayload = true;
+    final byte[] bytes;
+    if (payload != null) {
+      bytes = new byte[payload.length];
+      System.arraycopy(payload.bytes, payload.offset, bytes, 0, payload.length);
+    } else {
+      bytes = null;
+    }
+    return Collections.singletonList(bytes);
+  }
+
+  @Override
+  public boolean isPayloadAvailable() throws IOException {
+    return readPayload == false && postings.getPayload() != null;
+  }
+
+  @Override
+  public String toString() {
+    assert term != null;
+    return "TermSpansEnum(" + term.toString() + ")@" +
+            (doc == -1 ? "START" : (doc == NO_MORE_DOCS) ? "ENDDOC"
+              : doc + " - " + (position == NO_MORE_POSITIONS ? "ENDPOS" : position));
+  }
+
+  public PostingsEnum getPostings() {
+    return postings;
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/package-info.java b/lucene/core/src/java/org/apache/lucene/search/spans/package-info.java
index 20f20b0..7ef8314 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/package-info.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/package-info.java
@@ -18,35 +18,36 @@
 /**
  * The calculus of spans.
  * 
- * <p>A span is a <code>&lt;doc,startPosition,endPosition&gt;</code> tuple.</p>
+ * <p>A span is a <code>&lt;doc,startPosition,endPosition&gt;</code> tuple  that is enumerated by
+ *    class {@link org.apache.lucene.search.spans.SpansEnum SpansEnum}.</p>
  * 
  * <p>The following span query operators are implemented:
  * 
  * <ul>
  * 
- * <li>A {@link org.apache.lucene.search.spans.SpanTermQuery SpanTermQuery} matches all spans
+ * <li>A {@link org.apache.lucene.search.spans.SpansEnumTermQuery SpansEnumTermQuery} matches all spans
  * containing a particular {@link org.apache.lucene.index.Term Term}.</li>
  * 
- * <li> A {@link org.apache.lucene.search.spans.SpanNearQuery SpanNearQuery} matches spans
+ * <li> A {@link org.apache.lucene.search.spans.SpansEnumNearQuery SpansEnumNearQuery} matches spans
  * which occur near one another, and can be used to implement things like
- * phrase search (when constructed from {@link org.apache.lucene.search.spans.SpanTermQuery}s)
- * and inter-phrase proximity (when constructed from other {@link org.apache.lucene.search.spans.SpanNearQuery}s).</li>
+ * phrase search (when constructed from {@link org.apache.lucene.search.spans.SpansEnumTermQuery}s)
+ * and inter-phrase proximity (when constructed from other {@link org.apache.lucene.search.spans.SpansEnumNearQuery}s).</li>
  * 
- * <li>A {@link org.apache.lucene.search.spans.SpanOrQuery SpanOrQuery} merges spans from a
- * number of other {@link org.apache.lucene.search.spans.SpanQuery}s.</li>
+ * <li>A {@link org.apache.lucene.search.spans.SpansEnumOrQuery SpansEnumOrQuery} merges spans from a
+ * number of other {@link org.apache.lucene.search.spans.SpansEnumQuery}s.</li>
  * 
- * <li>A {@link org.apache.lucene.search.spans.SpanNotQuery SpanNotQuery} removes spans
- * matching one {@link org.apache.lucene.search.spans.SpanQuery SpanQuery} which overlap (or comes
+ * <li>A {@link org.apache.lucene.search.spans.SpansEnumNotQuery SpansEnumNotQuery} removes spans
+ * matching one {@link org.apache.lucene.search.spans.SpansEnumQuery SpansEnumQuery} which overlap (or comes
  * near) another.  This can be used, e.g., to implement within-paragraph
  * search.</li>
  * 
- * <li>A {@link org.apache.lucene.search.spans.SpanFirstQuery SpanFirstQuery} matches spans
+ * <li>A {@link org.apache.lucene.search.spans.SpansEnumFirstQuery SpansEnumFirstQuery} matches spans
  * matching <code>q</code> whose end position is less than
  * <code>n</code>.  This can be used to constrain matches to the first
  * part of the document.</li>
  * 
- * <li>A {@link org.apache.lucene.search.spans.SpanPositionRangeQuery SpanPositionRangeQuery} is
- * a more general form of SpanFirstQuery that can constrain matches to arbitrary portions of the document.</li>
+ * <li>A {@link org.apache.lucene.search.spans.SpansEnumPositionRangeQuery SpansEnumPositionRangeQuery} is
+ * a more general form of SpansEnumFirstQuery that can constrain matches to arbitrary portions of the document.</li>
  * 
  * </ul>
  * 
@@ -58,22 +59,22 @@
  * words of "George Bush" within the first 100 words of the document
  * could be constructed with:
  * <pre class="prettyprint">
- * SpanQuery john   = new SpanTermQuery(new Term("content", "john"));
- * SpanQuery kerry  = new SpanTermQuery(new Term("content", "kerry"));
- * SpanQuery george = new SpanTermQuery(new Term("content", "george"));
- * SpanQuery bush   = new SpanTermQuery(new Term("content", "bush"));
+ * SpansEnumQuery john   = new SpansEnumTermQuery(new Term("content", "john"));
+ * SpansEnumQuery kerry  = new SpansEnumTermQuery(new Term("content", "kerry"));
+ * SpansEnumQuery george = new SpansEnumTermQuery(new Term("content", "george"));
+ * SpansEnumQuery bush   = new SpansEnumTermQuery(new Term("content", "bush"));
  * 
- * SpanQuery johnKerry =
- *    new SpanNearQuery(new SpanQuery[] {john, kerry}, 0, true);
+ * SpansEnumQuery johnKerry =
+ *    new SpansEnumNearQuery(new SpanQuery[] {john, kerry}, 0, true);
  * 
- * SpanQuery georgeBush =
- *    new SpanNearQuery(new SpanQuery[] {george, bush}, 0, true);
+ * SpansEnumQuery georgeBush =
+ *    new SpansEnumNearQuery(new SpanQuery[] {george, bush}, 0, true);
  * 
- * SpanQuery johnKerryNearGeorgeBush =
- *    new SpanNearQuery(new SpanQuery[] {johnKerry, georgeBush}, 10, false);
+ * SpansEnumQuery johnKerryNearGeorgeBush =
+ *    new SpansEnumNearQuery(new SpanQuery[] {johnKerry, georgeBush}, 10, false);
  * 
- * SpanQuery johnKerryNearGeorgeBushAtStart =
- *    new SpanFirstQuery(johnKerryNearGeorgeBush, 100);
+ * SpansEnumQuery johnKerryNearGeorgeBushAtStart =
+ *    new SpansEnumFirstQuery(johnKerryNearGeorgeBush, 100);
  * </pre>
  * 
  * <p>Span queries may be freely intermixed with other Lucene queries.
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java b/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java
index 7108273..201f6a0 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestPositionIncrement.java
@@ -43,6 +43,12 @@ import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.search.payloads.PayloadSpansEnumUtil;
+import org.apache.lucene.search.spans.TestSpans;
+import org.apache.lucene.search.spans.SpansEnumNearQuery;
+import org.apache.lucene.search.spans.SpansEnumQuery;
+import org.apache.lucene.search.spans.SpansEnumTermQuery;
+import org.apache.lucene.search.spans.SpansEnum;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.BytesRef;
 
@@ -286,4 +292,94 @@ public class TestPositionIncrement extends LuceneTestCase {
     is.getIndexReader().close();
     dir.close();
   }
+
+  public void testPayloadsPos0SpansEnum() throws Exception {
+    Directory dir = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, new MockPayloadAnalyzer());
+    Document doc = new Document();
+    doc.add(new TextField("content", new StringReader(
+        "a a b c d e a f g h i j a b k k")));
+    writer.addDocument(doc);
+
+    final IndexReader readerFromWriter = writer.getReader();
+    LeafReader r = SlowCompositeReaderWrapper.wrap(readerFromWriter);
+
+    PostingsEnum tp = r.postings(new Term("content", "a"), PostingsEnum.ALL);
+    
+    int count = 0;
+    assertTrue(tp.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);
+    // "a" occurs 4 times
+    assertEquals(4, tp.freq());
+    assertEquals(0, tp.nextPosition());
+    assertEquals(1, tp.nextPosition());
+    assertEquals(3, tp.nextPosition());
+    assertEquals(6, tp.nextPosition());
+
+    // only one doc has "a"
+    assertEquals(DocIdSetIterator.NO_MORE_DOCS, tp.nextDoc());
+
+    IndexSearcher is = newSearcher(readerFromWriter);
+  
+    SpansEnumTermQuery stq1 = new SpansEnumTermQuery(new Term("content", "a"));
+    SpansEnumTermQuery stq2 = new SpansEnumTermQuery(new Term("content", "k"));
+    SpansEnumQuery[] sqs = { stq1, stq2 };
+    SpansEnumNearQuery snq = new SpansEnumNearQuery(sqs, 30, false);
+
+    count = 0;
+    boolean sawZero = false;
+    if (VERBOSE) {
+      System.out.println("\ngetPayloadSpans test");
+    }
+    SpansEnum pspans = TestSpans.getSpansEnumFromQuery(snq, is.getIndexReader());
+    while (pspans.nextDoc() != SpansEnum.NO_MORE_DOCS) {
+      while (pspans.nextStartPosition() != SpansEnum.NO_MORE_POSITIONS) {
+        if (VERBOSE) {
+          System.out.println("doc " + pspans.docID() + ": span " + pspans.startPosition()
+              + " to " + pspans.endPosition());
+        }
+        Collection<byte[]> payloads = pspans.getPayload();
+        sawZero |= pspans.startPosition() == 0;
+        for (byte[] bytes : payloads) {
+          count++;
+          if (VERBOSE) {
+            System.out.println("  payload: " + new String(bytes, StandardCharsets.UTF_8));
+          }
+        }
+      }
+    }
+    assertTrue(sawZero);
+    assertEquals(5, count);
+
+    // System.out.println("\ngetSpans test");
+    SpansEnum spans = TestSpans.getSpansEnumFromQuery(snq, is.getIndexReader());
+    count = 0;
+    sawZero = false;
+    while (spans.nextDoc() != SpansEnum.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != SpansEnum.NO_MORE_POSITIONS) {
+        count++;
+        sawZero |= spans.startPosition() == 0;
+        // System.out.println(spans.doc() + " - " + spans.start() + " - " +
+        // spans.end());
+      }
+    }
+    assertEquals(4, count);
+    assertTrue(sawZero);
+
+    // System.out.println("\nPayloadSpansEnumUtil test");
+
+    sawZero = false;
+    PayloadSpansEnumUtil psu = new PayloadSpansEnumUtil(is.getTopReaderContext());
+    Collection<byte[]> pls = psu.getPayloadsForQuery(snq);
+    count = pls.size();
+    for (byte[] bytes : pls) {
+      String s = new String(bytes, StandardCharsets.UTF_8);
+      //System.out.println(s);
+      sawZero |= s.equals("pos: 0");
+    }
+    assertEquals(5, count);
+    assertTrue(sawZero);
+    writer.close();
+    is.getIndexReader().close();
+    dir.close();
+  }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadExplanations.java b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadExplanations.java
index 91a62de..5beaf78 100644
--- a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadExplanations.java
+++ b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadExplanations.java
@@ -22,6 +22,7 @@ import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.BaseExplanationTestCase;
 import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpansEnumQuery;
 import org.apache.lucene.util.BytesRef;
 
 /**
@@ -50,6 +51,11 @@ public class TestPayloadExplanations extends BaseExplanationTestCase {
     return new PayloadTermQuery(new Term(FIELD,s), fn, includeSpanScore);
   }
   
+  /** macro for payloadtermquery */
+  private SpansEnumQuery pset(String s, PayloadFunction fn, boolean includeSpanScore) {
+    return new PayloadSpansEnumTermQuery(new Term(FIELD,s), fn, includeSpanScore);
+  }
+  
   /* simple PayloadTermQueries */
   
   public void testPT1() throws Exception {
@@ -59,6 +65,13 @@ public class TestPayloadExplanations extends BaseExplanationTestCase {
     }
   }
 
+  public void testPSET1() throws Exception {
+    for (PayloadFunction fn : functions) {
+      qtest(pset("w1", fn, false), new int[] {0,1,2,3});
+      qtest(pset("w1", fn, true), new int[] {0,1,2,3});
+    }
+  }
+
   public void testPT2() throws Exception {
     for (PayloadFunction fn : functions) {
       SpanQuery q = pt("w1", fn, false);
@@ -70,6 +83,17 @@ public class TestPayloadExplanations extends BaseExplanationTestCase {
     }
   }
 
+  public void testPSET2() throws Exception {
+    for (PayloadFunction fn : functions) {
+      SpansEnumQuery q = pset("w1", fn, false);
+      q.setBoost(1000);
+      qtest(q, new int[] {0,1,2,3});
+      q = pset("w1", fn, true);
+      q.setBoost(1000);
+      qtest(q, new int[] {0,1,2,3});
+    }
+  }
+
   public void testPT4() throws Exception {
     for (PayloadFunction fn : functions) {
       qtest(pt("xx", fn, false), new int[] {2,3});
@@ -77,6 +101,13 @@ public class TestPayloadExplanations extends BaseExplanationTestCase {
     }
   }
 
+  public void testPSET4() throws Exception {
+    for (PayloadFunction fn : functions) {
+      qtest(pset("xx", fn, false), new int[] {2,3});
+      qtest(pset("xx", fn, true), new int[] {2,3});
+    }
+  }
+
   public void testPT5() throws Exception {
     for (PayloadFunction fn : functions) {
       SpanQuery q = pt("xx", fn, false);
@@ -88,5 +119,16 @@ public class TestPayloadExplanations extends BaseExplanationTestCase {
     }
   }
 
+  public void testPSET5() throws Exception {
+    for (PayloadFunction fn : functions) {
+      SpansEnumQuery q = pset("xx", fn, false);
+      q.setBoost(1000);
+      qtest(q, new int[] {2,3});
+      q = pset("xx", fn, true);
+      q.setBoost(1000);
+      qtest(q, new int[] {2,3});
+    }
+  }
+
   // TODO: test the payloadnear query too!
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadNearQuery.java b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadNearQuery.java
index fe977a6..ab1de3d 100644
--- a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadNearQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadNearQuery.java
@@ -36,6 +36,9 @@ import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.spans.SpansEnumQuery;
+import org.apache.lucene.search.spans.SpansEnumNearQuery;
+import org.apache.lucene.search.spans.SpansEnumTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.English;
@@ -101,6 +104,15 @@ public class TestPayloadNearQuery extends LuceneTestCase {
     } 
     return new PayloadNearQuery(clauses, 0, inOrder, function);
   }
+  
+  private PayloadSpansEnumNearQuery newSpansEnumPhraseQuery(String fieldName, String phrase, boolean inOrder, PayloadFunction function ) {
+    String[] words = phrase.split("[\\s]+");
+    SpansEnumQuery clauses[] = new SpansEnumQuery[words.length];
+    for (int i=0;i<clauses.length;i++) {
+      clauses[i] = new SpansEnumTermQuery(new Term(fieldName, words[i]));  
+    } 
+    return new PayloadSpansEnumNearQuery(clauses, 0, inOrder, function);
+  }
 
   @BeforeClass
   public static void beforeClass() throws Exception {
@@ -132,7 +144,7 @@ public class TestPayloadNearQuery extends LuceneTestCase {
     directory = null;
   }
 
-  public void test() throws IOException {
+  public void testPayloadNear1() throws IOException {
     PayloadNearQuery query;
     TopDocs hits;
 
@@ -167,8 +179,42 @@ public class TestPayloadNearQuery extends LuceneTestCase {
     }
   }
 
+  public void testPayloadSpansEnumNear1() throws IOException {
+    PayloadSpansEnumNearQuery query;
+    TopDocs hits;
+
+    query = newSpansEnumPhraseQuery("field", "twenty two", true, new AveragePayloadFunction());
+    QueryUtils.check(query);
+
+    // all 10 hits should have score = 3 because adjacent terms have payloads of 2,4
+    // and all the similarity factors are set to 1
+    hits = searcher.search(query, 100);
+    assertTrue("hits is null and it shouldn't be", hits != null);
+    assertTrue("should be 10 hits", hits.totalHits == 10);
+    for (int j = 0; j < hits.scoreDocs.length; j++) {
+      ScoreDoc doc = hits.scoreDocs[j];
+      assertTrue(doc.score + " does not equal: " + 3, doc.score == 3);
+    }
+    for (int i=1;i<10;i++) {
+      query = newSpansEnumPhraseQuery("field", English.intToEnglish(i)+" hundred", true, new AveragePayloadFunction());
+      if (VERBOSE) {
+        System.out.println("TEST: run query=" + query);
+      }
+      // all should have score = 3 because adjacent terms have payloads of 2,4
+      // and all the similarity factors are set to 1
+      hits = searcher.search(query, 100);
+      assertTrue("hits is null and it shouldn't be", hits != null);
+      assertEquals("should be 100 hits", 100, hits.totalHits);
+      for (int j = 0; j < hits.scoreDocs.length; j++) {
+        ScoreDoc doc = hits.scoreDocs[j];
+        //        System.out.println("Doc: " + doc.toString());
+        //        System.out.println("Explain: " + searcher.explain(query, doc.doc));
+        assertTrue(doc.score + " does not equal: " + 3, doc.score == 3);
+      }
+    }
+  }
 
-  public void testPayloadNear() throws IOException {
+  public void testPayloadNear2() throws IOException {
     SpanNearQuery q1, q2;
     PayloadNearQuery query;
     //SpanNearQuery(clauses, 10000, false)
@@ -189,6 +235,27 @@ public class TestPayloadNearQuery extends LuceneTestCase {
     */
   }
   
+  public void testPayloadSpansEnumNear2() throws IOException {
+    SpansEnumNearQuery q1, q2;
+    PayloadSpansEnumNearQuery query;
+    //SpanNearQuery(clauses, 10000, false)
+    q1 = spansEnumNearQuery("field2", "twenty two");
+    q2 = spansEnumNearQuery("field2", "twenty three");
+    SpansEnumQuery[] clauses = new SpansEnumQuery[2];
+    clauses[0] = q1;
+    clauses[1] = q2;
+    query = new PayloadSpansEnumNearQuery(clauses, 10, false); 
+    //System.out.println(query.toString());
+    assertEquals(12, searcher.search(query, 100).totalHits);
+    /*
+    System.out.println(hits.totalHits);
+    for (int j = 0; j < hits.scoreDocs.length; j++) {
+      ScoreDoc doc = hits.scoreDocs[j];
+      System.out.println("doc: "+doc.doc+", score: "+doc.score);
+    }
+    */
+  }
+  
   public void testAverageFunction() throws IOException {
     PayloadNearQuery query;
     TopDocs hits;
@@ -209,6 +276,28 @@ public class TestPayloadNearQuery extends LuceneTestCase {
       assertTrue(hits.scoreDocs[j].score + " explain value does not equal: " + 3, explain.getValue() == 3f);
     }
   }
+
+  public void testAverageFunctionSpansEnum() throws IOException {
+    PayloadSpansEnumNearQuery query;
+    TopDocs hits;
+
+    query = newSpansEnumPhraseQuery("field", "twenty two", true, new AveragePayloadFunction());
+    QueryUtils.check(query);
+    // all 10 hits should have score = 3 because adjacent terms have payloads of 2,4
+    // and all the similarity factors are set to 1
+    hits = searcher.search(query, 100);
+    assertTrue("hits is null and it shouldn't be", hits != null);
+    assertTrue("should be 10 hits", hits.totalHits == 10);
+    for (int j = 0; j < hits.scoreDocs.length; j++) {
+      ScoreDoc doc = hits.scoreDocs[j];
+      assertTrue(doc.score + " does not equal: " + 3, doc.score == 3);
+      Explanation explain = searcher.explain(query, hits.scoreDocs[j].doc);
+      String exp = explain.toString();
+      assertTrue(exp, exp.indexOf("AveragePayloadFunction") > -1);
+      assertTrue(hits.scoreDocs[j].score + " explain value does not equal: " + 3, explain.getValue() == 3f);
+    }
+  }
+
   public void testMaxFunction() throws IOException {
     PayloadNearQuery query;
     TopDocs hits;
@@ -228,6 +317,27 @@ public class TestPayloadNearQuery extends LuceneTestCase {
       assertTrue(hits.scoreDocs[j].score + " explain value does not equal: " + 4, explain.getValue() == 4f);
     }
   }  
+
+  public void testMaxFunctionSpansEnum() throws IOException {
+    PayloadSpansEnumNearQuery query;
+    TopDocs hits;
+
+    query = newSpansEnumPhraseQuery("field", "twenty two", true, new MaxPayloadFunction());
+    QueryUtils.check(query);
+    // all 10 hits should have score = 4 (max payload value)
+    hits = searcher.search(query, 100);
+    assertTrue("hits is null and it shouldn't be", hits != null);
+    assertTrue("should be 10 hits", hits.totalHits == 10);
+    for (int j = 0; j < hits.scoreDocs.length; j++) {
+      ScoreDoc doc = hits.scoreDocs[j];
+      assertTrue(doc.score + " does not equal: " + 4, doc.score == 4);
+      Explanation explain = searcher.explain(query, hits.scoreDocs[j].doc);
+      String exp = explain.toString();
+      assertTrue(exp, exp.indexOf("MaxPayloadFunction") > -1);
+      assertTrue(hits.scoreDocs[j].score + " explain value does not equal: " + 4, explain.getValue() == 4f);
+    }
+  }  
+
   public void testMinFunction() throws IOException {
     PayloadNearQuery query;
     TopDocs hits;
@@ -247,6 +357,27 @@ public class TestPayloadNearQuery extends LuceneTestCase {
       assertTrue(hits.scoreDocs[j].score + " explain value does not equal: " + 2, explain.getValue() == 2f);
     }
   }  
+
+  public void testMinFunctionSpansEnum() throws IOException {
+    PayloadSpansEnumNearQuery query;
+    TopDocs hits;
+
+    query = newSpansEnumPhraseQuery("field", "twenty two", true, new MinPayloadFunction());
+    QueryUtils.check(query);
+    // all 10 hits should have score = 2 (min payload value)
+    hits = searcher.search(query, 100);
+    assertTrue("hits is null and it shouldn't be", hits != null);
+    assertTrue("should be 10 hits", hits.totalHits == 10);
+    for (int j = 0; j < hits.scoreDocs.length; j++) {
+      ScoreDoc doc = hits.scoreDocs[j];
+      assertTrue(doc.score + " does not equal: " + 2, doc.score == 2);
+      Explanation explain = searcher.explain(query, hits.scoreDocs[j].doc);
+      String exp = explain.toString();
+      assertTrue(exp, exp.indexOf("MinPayloadFunction") > -1);
+      assertTrue(hits.scoreDocs[j].score + " explain value does not equal: " + 2, explain.getValue() == 2f);
+    }
+  }  
+
   private SpanQuery[] getClauses() {
       SpanNearQuery q1, q2;
       q1 = spanNearQuery("field2", "twenty two");
@@ -256,6 +387,7 @@ public class TestPayloadNearQuery extends LuceneTestCase {
       clauses[1] = q2;
       return clauses;
   }
+
   private SpanNearQuery spanNearQuery(String fieldName, String words) {
     String[] wordList = words.split("[\\s]+");
     SpanQuery clauses[] = new SpanQuery[wordList.length];
@@ -265,6 +397,15 @@ public class TestPayloadNearQuery extends LuceneTestCase {
     return new SpanNearQuery(clauses, 10000, false);
   }
 
+  private SpansEnumNearQuery spansEnumNearQuery(String fieldName, String words) {
+    String[] wordList = words.split("[\\s]+");
+    SpansEnumQuery clauses[] = new SpansEnumQuery[wordList.length];
+    for (int i=0;i<clauses.length;i++) {
+      clauses[i] = new PayloadSpansEnumTermQuery(new Term(fieldName, wordList[i]), new AveragePayloadFunction());  
+    } 
+    return new SpansEnumNearQuery(clauses, 10000, false);
+  }
+
   public void testLongerSpan() throws IOException {
     PayloadNearQuery query;
     TopDocs hits;
@@ -279,6 +420,20 @@ public class TestPayloadNearQuery extends LuceneTestCase {
     assertTrue(doc.score + " does not equal: " + 3, doc.score == 3); 
   }
 
+  public void testLongerSpansEnum() throws IOException {
+    PayloadSpansEnumNearQuery query;
+    TopDocs hits;
+    query = newSpansEnumPhraseQuery("field", "nine hundred ninety nine", true, new AveragePayloadFunction());
+    hits = searcher.search(query, 100);
+    assertTrue("hits is null and it shouldn't be", hits != null);
+    ScoreDoc doc = hits.scoreDocs[0];
+    //    System.out.println("Doc: " + doc.toString());
+    //    System.out.println("Explain: " + searcher.explain(query, doc.doc));
+    assertTrue("there should only be one hit", hits.totalHits == 1);
+    // should have score = 3 because adjacent terms have payloads of 2,4
+    assertTrue(doc.score + " does not equal: " + 3, doc.score == 3); 
+  }
+
   public void testComplexNested() throws IOException {
     PayloadNearQuery query;
     TopDocs hits;
@@ -302,6 +457,32 @@ public class TestPayloadNearQuery extends LuceneTestCase {
     assertTrue(doc.score + " does not equal: " + 3, doc.score == 3);  
   }
 
+  public void testComplexNestedSpansEnum() throws IOException {
+    PayloadSpansEnumNearQuery query;
+    TopDocs hits;
+
+    // combine ordered and unordered spans with some nesting to make sure all payloads are counted
+
+    SpansEnumQuery q1 = newSpansEnumPhraseQuery("field", "nine hundred", true, new AveragePayloadFunction());
+    SpansEnumQuery q2 = newSpansEnumPhraseQuery("field", "ninety nine", true, new AveragePayloadFunction());
+    SpansEnumQuery q3 = newSpansEnumPhraseQuery("field", "nine ninety", false, new AveragePayloadFunction());
+    SpansEnumQuery q4 = newSpansEnumPhraseQuery("field", "hundred nine", false, new AveragePayloadFunction());
+    SpansEnumQuery[] clauses = new SpansEnumQuery[] {
+                                  new PayloadSpansEnumNearQuery(new SpansEnumQuery[] {q1,q2}, 0, true),
+                                  new PayloadSpansEnumNearQuery(new SpansEnumQuery[] {q3,q4}, 0, false)
+    };
+    query = new PayloadSpansEnumNearQuery(clauses, 0, false);
+    hits = searcher.search(query, 100);
+    assertTrue("hits is null and it shouldn't be", hits != null);
+    // should be only 1 hit - doc 999
+    assertTrue("should only be one hit", hits.scoreDocs.length == 1);
+    // the score should be 3 - the average of all the underlying payloads
+    ScoreDoc doc = hits.scoreDocs[0];
+    //    System.out.println("Doc: " + doc.toString());
+    //    System.out.println("Explain: " + searcher.explain(query, doc.doc));
+    assertTrue(doc.score + " does not equal: " + 3, doc.score == 3);  
+  }
+
   static class BoostingSimilarity extends DefaultSimilarity {
 
     @Override
diff --git a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java
index 80fe83f..d445cb5 100644
--- a/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java
@@ -29,9 +29,13 @@ import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
-import org.apache.lucene.search.spans.MultiSpansWrapper;
+
+import org.apache.lucene.search.spans.TestSpans;
 import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.search.spans.SpansEnumTermQuery;
+import org.apache.lucene.search.spans.SpansEnum;
+
 import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.FieldInvertState;
@@ -144,7 +148,7 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     directory = null;
   }
 
-  public void test() throws IOException {
+  public void testPayloadTermQuery() throws IOException {
     PayloadTermQuery query = new PayloadTermQuery(new Term("field", "seventy"),
             new MaxPayloadFunction());
     TopDocs hits = searcher.search(query, 100);
@@ -160,7 +164,7 @@ public class TestPayloadTermQuery extends LuceneTestCase {
       assertTrue(doc.score + " does not equal: " + 1, doc.score == 1);
     }
     CheckHits.checkExplanations(query, PayloadHelper.FIELD, searcher, true);
-    Spans spans = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), query);
+    Spans spans = TestSpans.getSpansFromQuery(query, searcher.getIndexReader());
     assertTrue("spans is null and it shouldn't be", spans != null);
     /*float score = hits.score(0);
     for (int i =1; i < hits.length(); i++)
@@ -170,7 +174,48 @@ public class TestPayloadTermQuery extends LuceneTestCase {
 
   }
   
-  public void testQuery() {
+  public void testPayloadSpansEnumTermQuery() throws IOException {
+    PayloadSpansEnumTermQuery query = new PayloadSpansEnumTermQuery(new Term("field", "seventy"),
+                                                                    new MaxPayloadFunction());
+    TopDocs hits = searcher.search(query, 100);
+    assertTrue("hits is null and it shouldn't be", hits != null);
+    assertTrue("hits Size: " + hits.totalHits + " is not: " + 100, hits.totalHits == 100);
+
+    //they should all have the exact same score, because they all contain seventy once, and we set
+    //all the other similarity factors to be 1
+
+    assertTrue(hits.getMaxScore() + " does not equal: " + 1, hits.getMaxScore() == 1);
+    for (int i = 0; i < hits.scoreDocs.length; i++) {
+      ScoreDoc doc = hits.scoreDocs[i];
+      assertTrue(doc.score + " does not equal: " + 1, doc.score == 1);
+    }
+    CheckHits.checkExplanations(query, PayloadHelper.FIELD, searcher, true);
+    SpansEnum spans = TestSpans.getSpansEnumFromQuery(query, searcher.getIndexReader());
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    /*float score = hits.score(0);
+    for (int i =1; i < hits.length(); i++)
+    {
+      assertTrue("scores are not equal and they should be", score == hits.score(i));
+    }*/
+
+  }
+  
+  public void testPayloadSpansEnumTermQueryEquals() {
+    PayloadSpansEnumTermQuery boostingFuncTermQuery = new PayloadSpansEnumTermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"),
+                                                                                    new MaxPayloadFunction());
+    QueryUtils.check(boostingFuncTermQuery);
+    
+    SpansEnumTermQuery spanTermQuery = new SpansEnumTermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"));
+
+    assertTrue(boostingFuncTermQuery.equals(spanTermQuery) == spanTermQuery.equals(boostingFuncTermQuery));
+    
+    PayloadSpansEnumTermQuery boostingFuncTermQuery2 = new PayloadSpansEnumTermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"),
+                                                                                    new AveragePayloadFunction());
+    
+    QueryUtils.checkUnequal(boostingFuncTermQuery, boostingFuncTermQuery2);
+  }
+
+  public void testPayloadTermQueryEquals2() {
     PayloadTermQuery boostingFuncTermQuery = new PayloadTermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"),
         new MaxPayloadFunction());
     QueryUtils.check(boostingFuncTermQuery);
@@ -185,6 +230,21 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     QueryUtils.checkUnequal(boostingFuncTermQuery, boostingFuncTermQuery2);
   }
 
+  public void testPayloadSpansEnumTermQueryEquals2() {
+    PayloadSpansEnumTermQuery boostingFuncTermQuery = new PayloadSpansEnumTermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"),
+                                                                                    new MaxPayloadFunction());
+    QueryUtils.check(boostingFuncTermQuery);
+    
+    SpansEnumTermQuery spanTermQuery = new SpansEnumTermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"));
+
+    assertTrue(boostingFuncTermQuery.equals(spanTermQuery) == spanTermQuery.equals(boostingFuncTermQuery));
+    
+    PayloadSpansEnumTermQuery boostingFuncTermQuery2 = new PayloadSpansEnumTermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"),
+                                                                                    new AveragePayloadFunction());
+    
+    QueryUtils.checkUnequal(boostingFuncTermQuery, boostingFuncTermQuery2);
+  }
+
   public void testMultipleMatchesPerDoc() throws Exception {
     PayloadTermQuery query = new PayloadTermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"),
             new MaxPayloadFunction());
@@ -211,7 +271,7 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     }
     assertTrue(numTens + " does not equal: " + 10, numTens == 10);
     CheckHits.checkExplanations(query, "field", searcher, true);
-    Spans spans = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), query);
+    Spans spans = TestSpans.getSpansFromQuery(query, searcher.getIndexReader());
     assertTrue("spans is null and it shouldn't be", spans != null);
     //should be two matches per document
     int count = 0;
@@ -222,6 +282,45 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     assertTrue(count + " does not equal: " + 200, count == 200);
   }
 
+  public void testMultipleMatchesPerDocSpansEnum() throws Exception {
+    PayloadSpansEnumTermQuery query = new PayloadSpansEnumTermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"),
+                                                                    new MaxPayloadFunction());
+    TopDocs hits = searcher.search(query, 100);
+    assertTrue("hits is null and it shouldn't be", hits != null);
+    assertTrue("hits Size: " + hits.totalHits + " is not: " + 100, hits.totalHits == 100);
+
+    //they should all have the exact same score, because they all contain seventy once, and we set
+    //all the other similarity factors to be 1
+
+    //System.out.println("Hash: " + seventyHash + " Twice Hash: " + 2*seventyHash);
+    assertTrue(hits.getMaxScore() + " does not equal: " + 4.0, hits.getMaxScore() == 4.0);
+    //there should be exactly 10 items that score a 4, all the rest should score a 2
+    //The 10 items are: 70 + i*100 where i in [0-9]
+    int numTens = 0;
+    for (int i = 0; i < hits.scoreDocs.length; i++) {
+      ScoreDoc doc = hits.scoreDocs[i];
+      if (doc.doc % 10 == 0) {
+        numTens++;
+        assertTrue(doc.score + " does not equal: " + 4.0, doc.score == 4.0);
+      } else {
+        assertTrue(doc.score + " does not equal: " + 2, doc.score == 2);
+      }
+    }
+    assertTrue(numTens + " does not equal: " + 10, numTens == 10);
+    CheckHits.checkExplanations(query, "field", searcher, true);
+    SpansEnum spans = TestSpans.getSpansEnumFromQuery(query, searcher.getIndexReader());
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    //should be two matches per document
+    int count = 0;
+    //100 hits times 2 matches per hit, we should have 200 in count
+    while (spans.nextDoc() != SpansEnum.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != SpansEnum.NO_MORE_POSITIONS) {
+        count++;
+      }
+    }
+    assertTrue(count + " does not equal: " + 200, count == 200);
+  }
+
   //Set includeSpanScore to false, in which case just the payload score comes through.
   public void testIgnoreSpanScorer() throws Exception {
     PayloadTermQuery query = new PayloadTermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"),
@@ -253,7 +352,7 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     }
     assertTrue(numTens + " does not equal: " + 10, numTens == 10);
     CheckHits.checkExplanations(query, "field", searcher, true);
-    Spans spans = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), query);
+    Spans spans = TestSpans.getSpansFromQuery(query, searcher.getIndexReader());
     assertTrue("spans is null and it shouldn't be", spans != null);
     //should be two matches per document
     int count = 0;
@@ -264,6 +363,50 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     reader.close();
   }
 
+  //Set includeSpanScore to false, in which case just the payload score comes through.
+  public void testIgnoreSpansEnumScorer() throws Exception {
+    PayloadSpansEnumTermQuery query = new PayloadSpansEnumTermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"),
+                                                                    new MaxPayloadFunction(), false);
+
+    IndexReader reader = DirectoryReader.open(directory);
+    IndexSearcher theSearcher = newSearcher(reader);
+    theSearcher.setSimilarity(new FullSimilarity());
+    TopDocs hits = searcher.search(query, 100);
+    assertTrue("hits is null and it shouldn't be", hits != null);
+    assertTrue("hits Size: " + hits.totalHits + " is not: " + 100, hits.totalHits == 100);
+
+    //they should all have the exact same score, because they all contain seventy once, and we set
+    //all the other similarity factors to be 1
+
+    //System.out.println("Hash: " + seventyHash + " Twice Hash: " + 2*seventyHash);
+    assertTrue(hits.getMaxScore() + " does not equal: " + 4.0, hits.getMaxScore() == 4.0);
+    //there should be exactly 10 items that score a 4, all the rest should score a 2
+    //The 10 items are: 70 + i*100 where i in [0-9]
+    int numTens = 0;
+    for (int i = 0; i < hits.scoreDocs.length; i++) {
+      ScoreDoc doc = hits.scoreDocs[i];
+      if (doc.doc % 10 == 0) {
+        numTens++;
+        assertTrue(doc.score + " does not equal: " + 4.0, doc.score == 4.0);
+      } else {
+        assertTrue(doc.score + " does not equal: " + 2, doc.score == 2);
+      }
+    }
+    assertTrue(numTens + " does not equal: " + 10, numTens == 10);
+    CheckHits.checkExplanations(query, "field", searcher, true);
+    SpansEnum spans = TestSpans.getSpansEnumFromQuery(query, searcher.getIndexReader());
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    //should be two matches per document
+    int count = 0;
+    //100 hits times 2 matches per hit, we should have 200 in count
+    while (spans.nextDoc() != SpansEnum.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != SpansEnum.NO_MORE_POSITIONS) {
+        count++;
+      }
+    }
+    reader.close();
+  }
+
   public void testNoMatch() throws Exception {
     PayloadTermQuery query = new PayloadTermQuery(new Term(PayloadHelper.FIELD, "junk"),
             new MaxPayloadFunction());
@@ -273,6 +416,15 @@ public class TestPayloadTermQuery extends LuceneTestCase {
 
   }
 
+  public void testNoMatchSpansEnum() throws Exception {
+    PayloadSpansEnumTermQuery query = new PayloadSpansEnumTermQuery(new Term(PayloadHelper.FIELD, "junk"),
+                                                                    new MaxPayloadFunction());
+    TopDocs hits = searcher.search(query, 100);
+    assertTrue("hits is null and it shouldn't be", hits != null);
+    assertTrue("hits Size: " + hits.totalHits + " is not: " + 0, hits.totalHits == 0);
+
+  }
+
   public void testNoPayload() throws Exception {
     PayloadTermQuery q1 = new PayloadTermQuery(new Term(PayloadHelper.NO_PAYLOAD_FIELD, "zero"),
             new MaxPayloadFunction());
@@ -291,6 +443,24 @@ public class TestPayloadTermQuery extends LuceneTestCase {
     CheckHits.checkHitCollector(random(), query, PayloadHelper.NO_PAYLOAD_FIELD, searcher, results);
   }
 
+  public void testNoPayloadSpansEnum() throws Exception {
+    PayloadSpansEnumTermQuery q1 = new PayloadSpansEnumTermQuery(new Term(PayloadHelper.NO_PAYLOAD_FIELD, "zero"),
+                                                                new MaxPayloadFunction());
+    PayloadSpansEnumTermQuery q2 = new PayloadSpansEnumTermQuery(new Term(PayloadHelper.NO_PAYLOAD_FIELD, "foo"),
+                                                                new MaxPayloadFunction());
+    BooleanClause c1 = new BooleanClause(q1, BooleanClause.Occur.MUST);
+    BooleanClause c2 = new BooleanClause(q2, BooleanClause.Occur.MUST_NOT);
+    BooleanQuery query = new BooleanQuery();
+    query.add(c1);
+    query.add(c2);
+    TopDocs hits = searcher.search(query, 100);
+    assertTrue("hits is null and it shouldn't be", hits != null);
+    assertTrue("hits Size: " + hits.totalHits + " is not: " + 1, hits.totalHits == 1);
+    int[] results = new int[1];
+    results[0] = 0;//hits.scoreDocs[0].doc;
+    CheckHits.checkHitCollector(random(), query, PayloadHelper.NO_PAYLOAD_FIELD, searcher, results);
+  }
+
   static class BoostingSimilarity extends DefaultSimilarity {
 
     @Override
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/MultiSpansWrapper.java b/lucene/core/src/test/org/apache/lucene/search/spans/MultiSpansWrapper.java
index 7490c61..d57c1ec 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/MultiSpansWrapper.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/MultiSpansWrapper.java
@@ -38,7 +38,9 @@ import org.apache.lucene.search.DocIdSetIterator;
  * <p>
  * NOTE: This should be used for testing purposes only
  * @lucene.internal
+ * @deprecated Use {@link TestSpans#getSpansEnumFromQuery} instead.
  */
+@Deprecated
 public class MultiSpansWrapper extends Spans { // can't be package private due to payloads
 
   private SpanQuery query;
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestBasics.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestBasics.java
deleted file mode 100644
index 068964a..0000000
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestBasics.java
+++ /dev/null
@@ -1,698 +0,0 @@
-package org.apache.lucene.search.spans;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-
-import org.apache.lucene.analysis.*;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.CheckHits;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.PhraseQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.QueryUtils;
-import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.English;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.TestUtil;
-import org.junit.AfterClass;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-/**
- * Tests basic search capabilities.
- *
- * <p>Uses a collection of 1000 documents, each the english rendition of their
- * document number.  For example, the document numbered 333 has text "three
- * hundred thirty three".
- *
- * <p>Tests are each a single query, and its hits are checked to ensure that
- * all and only the correct documents are returned, thus providing end-to-end
- * testing of the indexing and search code.
- *
- */
-public class TestBasics extends LuceneTestCase {
-  private static IndexSearcher searcher;
-  private static IndexReader reader;
-  private static Directory directory;
-
-  static final class SimplePayloadFilter extends TokenFilter {
-    int pos;
-    final PayloadAttribute payloadAttr;
-    final CharTermAttribute termAttr;
-
-    public SimplePayloadFilter(TokenStream input) {
-      super(input);
-      pos = 0;
-      payloadAttr = input.addAttribute(PayloadAttribute.class);
-      termAttr = input.addAttribute(CharTermAttribute.class);
-    }
-
-    @Override
-    public boolean incrementToken() throws IOException {
-      if (input.incrementToken()) {
-        payloadAttr.setPayload(new BytesRef(("pos: " + pos).getBytes(StandardCharsets.UTF_8)));
-        pos++;
-        return true;
-      } else {
-        return false;
-      }
-    }
-
-    @Override
-    public void reset() throws IOException {
-      super.reset();
-      pos = 0;
-    }
-  }
-  
-  static Analyzer simplePayloadAnalyzer;
-
-  @BeforeClass
-  public static void beforeClass() throws Exception {
-    simplePayloadAnalyzer = new Analyzer() {
-        @Override
-        public TokenStreamComponents createComponents(String fieldName) {
-          Tokenizer tokenizer = new MockTokenizer(MockTokenizer.SIMPLE, true);
-          return new TokenStreamComponents(tokenizer, new SimplePayloadFilter(tokenizer));
-        }
-    };
-  
-    directory = newDirectory();
-    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
-        newIndexWriterConfig(simplePayloadAnalyzer)
-            .setMaxBufferedDocs(TestUtil.nextInt(random(), 100, 1000)).setMergePolicy(newLogMergePolicy()));
-    //writer.infoStream = System.out;
-    for (int i = 0; i < 2000; i++) {
-      Document doc = new Document();
-      doc.add(newTextField("field", English.intToEnglish(i), Field.Store.YES));
-      writer.addDocument(doc);
-    }
-    reader = writer.getReader();
-    searcher = newSearcher(reader);
-    writer.close();
-  }
-
-  @AfterClass
-  public static void afterClass() throws Exception {
-    reader.close();
-    directory.close();
-    searcher = null;
-    reader = null;
-    directory = null;
-    simplePayloadAnalyzer = null;
-  }
-
-  @Test
-  public void testTerm() throws Exception {
-    Query query = new TermQuery(new Term("field", "seventy"));
-    checkHits(query, new int[]
-      {70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 170, 171, 172, 173, 174, 175,
-              176, 177, 178, 179, 270, 271, 272, 273, 274, 275, 276, 277, 278,
-              279, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 470, 471,
-              472, 473, 474, 475, 476, 477, 478, 479, 570, 571, 572, 573, 574,
-              575, 576, 577, 578, 579, 670, 671, 672, 673, 674, 675, 676, 677,
-              678, 679, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 870,
-              871, 872, 873, 874, 875, 876, 877, 878, 879, 970, 971, 972, 973,
-              974, 975, 976, 977, 978, 979, 1070, 1071, 1072, 1073, 1074, 1075,
-              1076, 1077, 1078, 1079, 1170, 1171, 1172, 1173, 1174, 1175, 1176,
-              1177, 1178, 1179, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277,
-              1278, 1279, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378,
-              1379, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479,
-              1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1670,
-              1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1770, 1771,
-              1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1870, 1871, 1872,
-              1873, 1874, 1875, 1876, 1877,
-              1878, 1879, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978,
-              1979});
-    }
-
-  @Test
-  public void testTerm2() throws Exception {
-    Query query = new TermQuery(new Term("field", "seventish"));
-    checkHits(query, new int[] {});
-  }
-
-  @Test
-  public void testPhrase() throws Exception {
-    PhraseQuery query = new PhraseQuery();
-    query.add(new Term("field", "seventy"));
-    query.add(new Term("field", "seven"));
-    checkHits(query, new int[]
-      {77, 177, 277, 377, 477, 577, 677, 777, 877,
-              977, 1077, 1177, 1277, 1377, 1477, 1577, 1677, 1777, 1877, 1977});
-  }
-
-  @Test
-  public void testPhrase2() throws Exception {
-    PhraseQuery query = new PhraseQuery();
-    query.add(new Term("field", "seventish"));
-    query.add(new Term("field", "sevenon"));
-    checkHits(query, new int[] {});
-  }
-
-  @Test
-  public void testBoolean() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term("field", "seventy")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term("field", "seven")), BooleanClause.Occur.MUST);
-    checkHits(query, new int[]
-      {77, 177, 277, 377, 477, 577, 677, 770, 771, 772, 773, 774, 775, 776, 777,
-              778, 779, 877, 977, 1077, 1177, 1277, 1377, 1477, 1577, 1677,
-              1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1877,
-              1977});
-  }
-
-  @Test
-  public void testBoolean2() throws Exception {
-    BooleanQuery query = new BooleanQuery();
-    query.add(new TermQuery(new Term("field", "sevento")), BooleanClause.Occur.MUST);
-    query.add(new TermQuery(new Term("field", "sevenly")), BooleanClause.Occur.MUST);
-    checkHits(query, new int[] {});
-  }
-
-  @Test
-  public void testSpanNearExact() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "seventy"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "seven"));
-    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                            0, true);
-    checkHits(query, new int[]
-      {77, 177, 277, 377, 477, 577, 677, 777, 877, 977, 1077, 1177, 1277, 1377, 1477, 1577, 1677, 1777, 1877, 1977});
-
-    assertTrue(searcher.explain(query, 77).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 977).getValue() > 0.0f);
-
-    QueryUtils.check(term1);
-    QueryUtils.check(term2);
-    QueryUtils.checkUnequal(term1,term2);
-  }
-  
-  public void testSpanTermQuery() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "seventy"));
-    checkHits(term1, new int[]
-                             { 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 170,
-        171, 172, 173, 174, 175, 176, 177, 178, 179, 270, 271, 272, 273, 274,
-        275, 276, 277, 278, 279, 370, 371, 372, 373, 374, 375, 376, 377, 378,
-        379, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 570, 571, 572,
-        573, 574, 575, 576, 577, 578, 579, 670, 671, 672, 673, 674, 675, 676,
-        677, 678, 679, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 870,
-        871, 872, 873, 874, 875, 876, 877, 878, 879, 970, 971, 972, 973, 974,
-        975, 976, 977, 978, 979, 1070, 1071, 1072, 1073, 1074, 1075, 1076,
-        1077, 1078, 1079, 1170, 1270, 1370, 1470, 1570, 1670, 1770, 1870, 1970,
-        1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1271, 1272, 1273,
-        1274, 1275, 1276, 1277, 1278, 1279, 1371, 1372, 1373, 1374, 1375, 1376,
-        1377, 1378, 1379, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479,
-        1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1671, 1672, 1673,
-        1674, 1675, 1676, 1677, 1678, 1679, 1771, 1772, 1773, 1774, 1775, 1776,
-        1777, 1778, 1779, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879,
-        1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979 });
-  }
-
-  @Test
-  public void testSpanNearUnordered() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "nine"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "six"));
-    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                            4, false);
-
-    checkHits(query, new int[]
-      {609, 629, 639, 649, 659, 669, 679, 689, 699, 906, 926, 936, 946, 956,
-              966, 976, 986, 996, 1609, 1629, 1639, 1649, 1659, 1669,
-              1679, 1689, 1699, 1906, 1926, 1936, 1946, 1956, 1966, 1976, 1986,
-              1996});
-  }
-
-  @Test
-  public void testSpanNearOrdered() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "nine"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "six"));
-    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                            4, true);
-    checkHits(query, new int[]
-      {906, 926, 936, 946, 956, 966, 976, 986, 996, 1906, 1926, 1936, 1946, 1956, 1966, 1976, 1986, 1996});
-  }
-
-  @Test
-  public void testSpanNot() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
-    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                           4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
-    SpanNotQuery query = new SpanNotQuery(near, term3);
-
-    checkHits(query, new int[]
-      {801, 821, 831, 851, 861, 871, 881, 891, 1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
-
-    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
-  }
-  
-  @Test
-  public void testSpanWithMultipleNotSingle() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
-    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                           4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
-
-    SpanOrQuery or = new SpanOrQuery(term3);
-
-    SpanNotQuery query = new SpanNotQuery(near, or);
-
-    checkHits(query, new int[]
-      {801, 821, 831, 851, 861, 871, 881, 891,
-              1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
-
-    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
-  }
-
-  @Test
-  public void testSpanWithMultipleNotMany() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
-    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                           4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
-    SpanTermQuery term4 = new SpanTermQuery(new Term("field", "sixty"));
-    SpanTermQuery term5 = new SpanTermQuery(new Term("field", "eighty"));
-
-    SpanOrQuery or = new SpanOrQuery(term3, term4, term5);
-
-    SpanNotQuery query = new SpanNotQuery(near, or);
-
-    checkHits(query, new int[]
-      {801, 821, 831, 851, 871, 891, 1801, 1821, 1831, 1851, 1871, 1891});
-
-    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
-  }
-
-  @Test
-  public void testNpeInSpanNearWithSpanNot() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
-    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                           4, true);
-    SpanTermQuery hun = new SpanTermQuery(new Term("field", "hundred"));
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
-    SpanNearQuery exclude = new SpanNearQuery(new SpanQuery[] {hun, term3},
-                                              1, true);
-    
-    SpanNotQuery query = new SpanNotQuery(near, exclude);
-
-    checkHits(query, new int[]
-      {801, 821, 831, 851, 861, 871, 881, 891,
-              1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
-
-    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
-  }
-
-  @Test
-  public void testNpeInSpanNearInSpanFirstInSpanNot() throws Exception {
-    int n = 5;
-    SpanTermQuery hun = new SpanTermQuery(new Term("field", "hundred"));
-    SpanTermQuery term40 = new SpanTermQuery(new Term("field", "forty"));
-    SpanTermQuery term40c = (SpanTermQuery)term40.clone();
-
-    SpanFirstQuery include = new SpanFirstQuery(term40, n);
-    SpanNearQuery near = new SpanNearQuery(new SpanQuery[]{hun, term40c},
-                                           n-1, true);
-    SpanFirstQuery exclude = new SpanFirstQuery(near, n-1);
-    SpanNotQuery q = new SpanNotQuery(include, exclude);
-    
-    checkHits(q, new int[]{40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048,
-            1049, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1240, 1241, 1242, 1243, 1244,
-            1245, 1246, 1247, 1248, 1249, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1440, 1441, 1442,
-            1443, 1444, 1445, 1446, 1447, 1448, 1449, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1640,
-            1641, 1642, 1643, 1644, 1645, 1646, 1647,
-            1648, 1649, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1840, 1841, 1842, 1843, 1844, 1845, 1846,
-            1847, 1848, 1849, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949});
-  }
-  
-  @Test
-  public void testSpanNotWindowOne() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "forty"));
-    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                           4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "one"));
-    SpanNotQuery query = new SpanNotQuery(near, term3, 1, 1);
-
-    checkHits(query, new int[]
-      {840, 842, 843, 844, 845, 846, 847, 848, 849,
-          1840, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849});
-
-    assertTrue(searcher.explain(query, 840).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 1842).getValue() > 0.0f);
-  }
-  
-  @Test
-  public void testSpanNotWindowTwoBefore() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "forty"));
-    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                           4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "one"));
-    SpanNotQuery query = new SpanNotQuery(near, term3, 2, 0);
-
-    checkHits(query, new int[]
-      {840, 841, 842, 843, 844, 845, 846, 847, 848, 849});
-
-    assertTrue(searcher.explain(query, 840).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 849).getValue() > 0.0f);
-  }
-
-  @Test
-  public void testSpanNotWindowNeg() throws Exception {
-     //test handling of invalid window < 0
-     SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-     SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
-     SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                            4, true);
-     SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
-
-     SpanOrQuery or = new SpanOrQuery(term3);
-
-     SpanNotQuery query = new SpanNotQuery(near, or);
-
-     checkHits(query, new int[]
-       {801, 821, 831, 851, 861, 871, 881, 891,
-               1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
-
-     assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
-     assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
-  }
-  
-  @Test
-  public void testSpanNotWindowDoubleExcludesBefore() throws Exception {
-     //test hitting two excludes before an include
-     SpanTermQuery term1 = new SpanTermQuery(new Term("field", "forty"));
-     SpanTermQuery term2 = new SpanTermQuery(new Term("field", "two"));
-     SpanNearQuery near = new SpanNearQuery(new SpanTermQuery[]{term1, term2}, 2, true);
-     SpanTermQuery exclude = new SpanTermQuery(new Term("field", "one"));
-
-     SpanNotQuery query = new SpanNotQuery(near, exclude, 4, 1);
-
-     checkHits(query, new int[]
-       {42, 242, 342, 442, 542, 642, 742, 842, 942});
-
-     assertTrue(searcher.explain(query, 242).getValue() > 0.0f);
-     assertTrue(searcher.explain(query, 942).getValue() > 0.0f);
-  }
-  
-  @Test
-  public void testSpanFirst() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "five"));
-    SpanFirstQuery query = new SpanFirstQuery(term1, 1);
-
-    checkHits(query, new int[]
-      {5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513,
-       514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527,
-       528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541,
-       542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555,
-       556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569,
-       570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583,
-       584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597,
-       598, 599});
-
-    assertTrue(searcher.explain(query, 5).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 599).getValue() > 0.0f);
-
-  }
-
-  @Test
-  public void testSpanPositionRange() throws Exception {
-    SpanPositionRangeQuery query;
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "five"));
-    query = new SpanPositionRangeQuery(term1, 1, 2);
-    checkHits(query, new int[]
-      {25,35, 45, 55, 65, 75, 85, 95});
-    assertTrue(searcher.explain(query, 25).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 95).getValue() > 0.0f);
-
-    query = new SpanPositionRangeQuery(term1, 0, 1);
-    checkHits(query, new int[]
-      {5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512,
-              513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525,
-              526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538,
-              539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551,
-              552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564,
-              565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577,
-              578, 579, 580, 581, 582, 583, 584,
-              585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597,
-              598, 599});
-
-    query = new SpanPositionRangeQuery(term1, 6, 7);
-    checkHits(query, new int[]{});
-  }
-
-  @Test
-  public void testSpanPayloadCheck() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "five"));
-    BytesRef pay = new BytesRef(("pos: " + 5).getBytes(StandardCharsets.UTF_8));
-    SpanQuery query = new SpanPayloadCheckQuery(term1, Collections.singletonList(pay.bytes));
-    checkHits(query, new int[]
-      {1125, 1135, 1145, 1155, 1165, 1175, 1185, 1195, 1225, 1235, 1245, 1255, 1265, 1275, 1285, 1295, 1325, 1335, 1345, 1355, 1365, 1375, 1385, 1395, 1425, 1435, 1445, 1455, 1465, 1475, 1485, 1495, 1525, 1535, 1545, 1555, 1565, 1575, 1585, 1595, 1625, 1635, 1645, 1655, 1665, 1675, 1685, 1695, 1725, 1735, 1745, 1755, 1765, 1775, 1785, 1795, 1825, 1835, 1845, 1855, 1865, 1875, 1885, 1895, 1925, 1935, 1945, 1955, 1965, 1975, 1985, 1995});
-    assertTrue(searcher.explain(query, 1125).getValue() > 0.0f);
-
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "hundred"));
-    SpanNearQuery snq;
-    SpanQuery[] clauses;
-    List<byte[]> list;
-    BytesRef pay2;
-    clauses = new SpanQuery[2];
-    clauses[0] = term1;
-    clauses[1] = term2;
-    snq = new SpanNearQuery(clauses, 0, true);
-    pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
-    pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
-    list = new ArrayList<>();
-    list.add(pay.bytes);
-    list.add(pay2.bytes);
-    query = new SpanNearPayloadCheckQuery(snq, list);
-    checkHits(query, new int[]
-      {500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599});
-    clauses = new SpanQuery[3];
-    clauses[0] = term1;
-    clauses[1] = term2;
-    clauses[2] = new SpanTermQuery(new Term("field", "five"));
-    snq = new SpanNearQuery(clauses, 0, true);
-    pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
-    pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
-    BytesRef pay3 = new BytesRef(("pos: " + 2).getBytes(StandardCharsets.UTF_8));
-    list = new ArrayList<>();
-    list.add(pay.bytes);
-    list.add(pay2.bytes);
-    list.add(pay3.bytes);
-    query = new SpanNearPayloadCheckQuery(snq, list);
-    checkHits(query, new int[]
-      {505});
-  }
-
-  public void testComplexSpanChecks() throws Exception {
-    SpanTermQuery one = new SpanTermQuery(new Term("field", "one"));
-    SpanTermQuery thous = new SpanTermQuery(new Term("field", "thousand"));
-    //should be one position in between
-    SpanTermQuery hundred = new SpanTermQuery(new Term("field", "hundred"));
-    SpanTermQuery three = new SpanTermQuery(new Term("field", "three"));
-
-    SpanNearQuery oneThous = new SpanNearQuery(new SpanQuery[]{one, thous}, 0, true);
-    SpanNearQuery hundredThree = new SpanNearQuery(new SpanQuery[]{hundred, three}, 0, true);
-    SpanNearQuery oneThousHunThree = new SpanNearQuery(new SpanQuery[]{oneThous, hundredThree}, 1, true);
-    SpanQuery query;
-    //this one's too small
-    query = new SpanPositionRangeQuery(oneThousHunThree, 1, 2);
-    checkHits(query, new int[]{});
-    //this one's just right
-    query = new SpanPositionRangeQuery(oneThousHunThree, 0, 6);
-    checkHits(query, new int[]{1103, 1203,1303,1403,1503,1603,1703,1803,1903});
-
-    Collection<byte[]> payloads = new ArrayList<>();
-    BytesRef pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
-    BytesRef pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
-    BytesRef pay3 = new BytesRef(("pos: " + 3).getBytes(StandardCharsets.UTF_8));
-    BytesRef pay4 = new BytesRef(("pos: " + 4).getBytes(StandardCharsets.UTF_8));
-    payloads.add(pay.bytes);
-    payloads.add(pay2.bytes);
-    payloads.add(pay3.bytes);
-    payloads.add(pay4.bytes);
-    query = new SpanNearPayloadCheckQuery(oneThousHunThree, payloads);
-    checkHits(query, new int[]{1103, 1203,1303,1403,1503,1603,1703,1803,1903});
-
-  }
-
-
-  @Test
-  public void testSpanOr() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "thirty"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "three"));
-    SpanNearQuery near1 = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                            0, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
-    SpanTermQuery term4 = new SpanTermQuery(new Term("field", "seven"));
-    SpanNearQuery near2 = new SpanNearQuery(new SpanQuery[] {term3, term4},
-                                            0, true);
-
-    SpanOrQuery query = new SpanOrQuery(near1, near2);
-
-    checkHits(query, new int[]
-      {33, 47, 133, 147, 233, 247, 333, 347, 433, 447, 533, 547, 633, 647, 733,
-              747, 833, 847, 933, 947, 1033, 1047, 1133, 1147, 1233, 1247, 1333,
-              1347, 1433, 1447, 1533, 1547, 1633, 1647, 1733, 1747, 1833, 1847, 1933, 1947});
-
-    assertTrue(searcher.explain(query, 33).getValue() > 0.0f);
-    assertTrue(searcher.explain(query, 947).getValue() > 0.0f);
-  }
-
-  @Test
-  public void testSpanExactNested() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "three"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "hundred"));
-    SpanNearQuery near1 = new SpanNearQuery(new SpanQuery[] {term1, term2},
-                                            0, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "thirty"));
-    SpanTermQuery term4 = new SpanTermQuery(new Term("field", "three"));
-    SpanNearQuery near2 = new SpanNearQuery(new SpanQuery[] {term3, term4},
-                                            0, true);
-
-    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {near1, near2},
-                                            0, true);
-
-    checkHits(query, new int[] {333, 1333});
-
-    assertTrue(searcher.explain(query, 333).getValue() > 0.0f);
-  }
-
-  @Test
-  public void testSpanNearOr() throws Exception {
-
-    SpanTermQuery t1 = new SpanTermQuery(new Term("field","six"));
-    SpanTermQuery t3 = new SpanTermQuery(new Term("field","seven"));
-    
-    SpanTermQuery t5 = new SpanTermQuery(new Term("field","seven"));
-    SpanTermQuery t6 = new SpanTermQuery(new Term("field","six"));
-
-    SpanOrQuery to1 = new SpanOrQuery(t1, t3);
-    SpanOrQuery to2 = new SpanOrQuery(t5, t6);
-    
-    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {to1, to2},
-                                            10, true);
-
-    checkHits(query, new int[]
-      {606, 607, 626, 627, 636, 637, 646, 647, 656, 657, 666, 667, 676, 677,
-              686, 687, 696, 697, 706, 707, 726, 727, 736, 737, 746, 747, 756,
-              757, 766, 767, 776, 777, 786, 787, 796, 797, 1606, 1607, 1626,
-              1627, 1636, 1637, 1646, 1647, 1656, 1657, 1666, 1667, 1676, 1677,
-              1686, 1687, 1696, 1697, 1706, 1707, 1726, 1727, 1736, 1737,
-              1746, 1747, 1756, 1757, 1766, 1767, 1776, 1777, 1786, 1787, 1796,
-              1797});
-  }
-
-  @Test
-  public void testSpanComplex1() throws Exception {
-      
-    SpanTermQuery t1 = new SpanTermQuery(new Term("field","six"));
-    SpanTermQuery t2 = new SpanTermQuery(new Term("field","hundred"));
-    SpanNearQuery tt1 = new SpanNearQuery(new SpanQuery[] {t1, t2}, 0,true);
-
-    SpanTermQuery t3 = new SpanTermQuery(new Term("field","seven"));
-    SpanTermQuery t4 = new SpanTermQuery(new Term("field","hundred"));
-    SpanNearQuery tt2 = new SpanNearQuery(new SpanQuery[] {t3, t4}, 0,true);
-    
-    SpanTermQuery t5 = new SpanTermQuery(new Term("field","seven"));
-    SpanTermQuery t6 = new SpanTermQuery(new Term("field","six"));
-
-    SpanOrQuery to1 = new SpanOrQuery(tt1, tt2);
-    SpanOrQuery to2 = new SpanOrQuery(t5, t6);
-    
-    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {to1, to2},
-                                            100, true);
-    
-    checkHits(query, new int[]
-      {606, 607, 626, 627, 636, 637, 646, 647, 656, 657, 666, 667, 676, 677, 686, 687, 696,
-              697, 706, 707, 726, 727, 736, 737, 746, 747, 756, 757,
-              766, 767, 776, 777, 786, 787, 796, 797, 1606, 1607, 1626, 1627, 1636, 1637, 1646,
-              1647, 1656, 1657,
-              1666, 1667, 1676, 1677, 1686, 1687, 1696, 1697, 1706, 1707, 1726, 1727, 1736, 1737,
-              1746, 1747, 1756, 1757, 1766, 1767, 1776, 1777, 1786, 1787, 1796, 1797});
-  }
-  
-  @Test
-  public void testSpansSkipTo() throws Exception {
-    SpanTermQuery t1 = new SpanTermQuery(new Term("field", "seventy"));
-    SpanTermQuery t2 = new SpanTermQuery(new Term("field", "seventy"));
-    Spans s1 = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), t1);
-    Spans s2 = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), t2);
-
-    assertTrue(s1.next());
-    assertTrue(s2.next());
-
-    boolean hasMore = true;
-
-    do {
-      hasMore = skipToAccordingToJavaDocs(s1, s1.doc() + 1);
-      assertEquals(hasMore, s2.skipTo(s2.doc() + 1));
-      assertEquals(s1.doc(), s2.doc());
-    } while (hasMore);
-  }
-
-  /** Skips to the first match beyond the current, whose document number is
-   * greater than or equal to <i>target</i>. <p>Returns true iff there is such
-   * a match.  <p>Behaves as if written: <pre>
-   *   boolean skipTo(int target) {
-   *     do {
-   *       if (!next())
-   *       return false;
-   *     } while (target &gt; doc());
-   *     return true;
-   *   }
-   * </pre>
-   */
-  private boolean skipToAccordingToJavaDocs(Spans s, int target)
-      throws Exception {
-    do {
-      if (!s.next())
-        return false;
-    } while (target > s.doc());
-    return true;
-
-  }
-
-  private void checkHits(Query query, int[] results) throws IOException {
-    CheckHits.checkHits(random(), query, "field", searcher, results);
-  }
-}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpansEnumQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpansEnumQuery.java
new file mode 100644
index 0000000..315008c
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpansEnumQuery.java
@@ -0,0 +1,329 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.search.similarities.TFIDFSimilarity;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+
+public class TestFieldMaskingSpansEnumQuery extends LuceneTestCase {
+
+  protected static Document doc(Field[] fields) {
+    Document doc = new Document();
+    for (int i = 0; i < fields.length; i++) {
+      doc.add(fields[i]);
+    }
+    return doc;
+  }
+
+  protected static Field field(String name, String value) {
+    return newTextField(name, value, Field.Store.NO);
+  }
+
+  protected static IndexSearcher searcher;
+  protected static Directory directory;
+  protected static IndexReader reader;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    directory = newDirectory();
+    RandomIndexWriter writer= new RandomIndexWriter(random(), directory, newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));
+
+    writer.addDocument(doc(new Field[] { field("id", "0")
+                                         ,
+                                         field("gender", "male"),
+                                         field("first",  "james"),
+                                         field("last",   "jones")     }));
+
+    writer.addDocument(doc(new Field[] { field("id", "1")
+                                         ,
+                                         field("gender", "male"),
+                                         field("first",  "james"),
+                                         field("last",   "smith")
+                                         ,
+                                         field("gender", "female"),
+                                         field("first",  "sally"),
+                                         field("last",   "jones")     }));
+
+    writer.addDocument(doc(new Field[] { field("id", "2")
+                                         ,
+                                         field("gender", "female"),
+                                         field("first",  "greta"),
+                                         field("last",   "jones")
+                                         ,
+                                         field("gender", "female"),
+                                         field("first",  "sally"),
+                                         field("last",   "smith")
+                                         ,
+                                         field("gender", "male"),
+                                         field("first",  "james"),
+                                         field("last",   "jones")     }));
+
+    writer.addDocument(doc(new Field[] { field("id", "3")
+                                         ,
+                                         field("gender", "female"),
+                                         field("first",  "lisa"),
+                                         field("last",   "jones")
+                                         ,
+                                         field("gender", "male"),
+                                         field("first",  "bob"),
+                                         field("last",   "costas")     }));
+
+    writer.addDocument(doc(new Field[] { field("id", "4")
+                                         ,
+                                         field("gender", "female"),
+                                         field("first",  "sally"),
+                                         field("last",   "smith")
+                                         ,
+                                         field("gender", "female"),
+                                         field("first",  "linda"),
+                                         field("last",   "dixit")
+                                         ,
+                                         field("gender", "male"),
+                                         field("first",  "bubba"),
+                                         field("last",   "jones")     }));
+    reader = writer.getReader();
+    writer.close();
+    searcher = newSearcher(reader);
+  }
+
+  @AfterClass
+  public static void afterClass() throws Exception {
+    searcher = null;
+    reader.close();
+    reader = null;
+    directory.close();
+    directory = null;
+  }
+
+  protected void check(SpansEnumQuery q, int[] docs) throws Exception {
+    CheckHits.checkHitCollector(random(), q, null, searcher, docs);
+  }
+
+  public void testRewrite0SpansEnum() throws Exception {
+    SpansEnumQuery q = new FieldMaskingSpansEnumQuery
+      (new SpansEnumTermQuery(new Term("last", "sally")) , "first");
+    q.setBoost(8.7654321f);
+    SpansEnumQuery qr = (SpansEnumQuery) searcher.rewrite(q);
+
+    QueryUtils.checkEqual(q, qr);
+
+    Set<Term> terms = new HashSet<>();
+    qr.extractTerms(terms);
+    assertEquals(1, terms.size());
+  }
+
+  public void testRewrite1SpansEnum() throws Exception {
+    // mask an anon SpanQuery class that rewrites to something else.
+    SpansEnumQuery q = new FieldMaskingSpansEnumQuery
+      (new SpansEnumTermQuery(new Term("last", "sally")) {
+          @Override
+          public Query rewrite(IndexReader reader) {
+            return new SpansEnumOrQuery(new SpansEnumTermQuery(new Term("first", "sally")),
+                new SpansEnumTermQuery(new Term("first", "james")));
+          }
+        }, "first");
+
+    SpansEnumQuery qr = (SpansEnumQuery) searcher.rewrite(q);
+
+    QueryUtils.checkUnequal(q, qr);
+
+    Set<Term> terms = new HashSet<>();
+    qr.extractTerms(terms);
+    assertEquals(2, terms.size());
+  }
+
+  public void testRewrite2SpansEnum() throws Exception {
+    SpansEnumQuery q1 = new SpansEnumTermQuery(new Term("last", "smith"));
+    SpansEnumQuery q2 = new SpansEnumTermQuery(new Term("last", "jones"));
+    SpansEnumQuery q = new SpansEnumNearQuery(new SpansEnumQuery[]
+      { q1, new FieldMaskingSpansEnumQuery(q2, "last")}, 1, true );
+    Query qr = searcher.rewrite(q);
+
+    QueryUtils.checkEqual(q, qr);
+
+    HashSet<Term> set = new HashSet<>();
+    qr.extractTerms(set);
+    assertEquals(2, set.size());
+  }
+
+  public void testEquality1SpansEnum() {
+    SpansEnumQuery q1 = new FieldMaskingSpansEnumQuery
+      (new SpansEnumTermQuery(new Term("last", "sally")) , "first");
+    SpansEnumQuery q2 = new FieldMaskingSpansEnumQuery
+      (new SpansEnumTermQuery(new Term("last", "sally")) , "first");
+    SpansEnumQuery q3 = new FieldMaskingSpansEnumQuery
+      (new SpansEnumTermQuery(new Term("last", "sally")) , "XXXXX");
+    SpansEnumQuery q4 = new FieldMaskingSpansEnumQuery
+      (new SpansEnumTermQuery(new Term("last", "XXXXX")) , "first");
+    SpansEnumQuery q5 = new FieldMaskingSpansEnumQuery
+      (new SpansEnumTermQuery(new Term("xXXX", "sally")) , "first");
+    QueryUtils.checkEqual(q1, q2);
+    QueryUtils.checkUnequal(q1, q3);
+    QueryUtils.checkUnequal(q1, q4);
+    QueryUtils.checkUnequal(q1, q5);
+
+    SpansEnumQuery qA = new FieldMaskingSpansEnumQuery
+      (new SpansEnumTermQuery(new Term("last", "sally")) , "first");
+    qA.setBoost(9f);
+    SpansEnumQuery qB = new FieldMaskingSpansEnumQuery
+      (new SpansEnumTermQuery(new Term("last", "sally")) , "first");
+    QueryUtils.checkUnequal(qA, qB);
+    qB.setBoost(9f);
+    QueryUtils.checkEqual(qA, qB);
+
+  }
+
+  public void testNoop0SpansEnum() throws Exception {
+    SpansEnumQuery q1 = new SpansEnumTermQuery(new Term("last", "sally"));
+    SpansEnumQuery q = new FieldMaskingSpansEnumQuery(q1, "first");
+    check(q, new int[] { /* :EMPTY: */ });
+  }
+  public void testNoop1SpansEnum() throws Exception {
+    SpansEnumQuery q1 = new SpansEnumTermQuery(new Term("last", "smith"));
+    SpansEnumQuery q2 = new SpansEnumTermQuery(new Term("last", "jones"));
+    SpansEnumQuery q = new SpansEnumNearQuery(new SpansEnumQuery[]
+      { q1, new FieldMaskingSpansEnumQuery(q2, "last")}, 0, true );
+    check(q, new int[] { 1, 2 });
+    q = new SpansEnumNearQuery(new SpansEnumQuery[]
+      { new FieldMaskingSpansEnumQuery(q1, "last"),
+        new FieldMaskingSpansEnumQuery(q2, "last")}, 0, true );
+    check(q, new int[] { 1, 2 });
+  }
+
+  public void testSimple1SpansEnum() throws Exception {
+    SpansEnumQuery q1 = new SpansEnumTermQuery(new Term("first", "james"));
+    SpansEnumQuery q2 = new SpansEnumTermQuery(new Term("last", "jones"));
+    SpansEnumQuery q = new SpansEnumNearQuery(new SpansEnumQuery[]
+      { q1, new FieldMaskingSpansEnumQuery(q2, "first")}, -1, false );
+    check(q, new int[] { 0, 2 });
+    q = new SpansEnumNearQuery(new SpansEnumQuery[]
+      { new FieldMaskingSpansEnumQuery(q2, "first"), q1}, -1, false );
+    check(q, new int[] { 0, 2 });
+    q = new SpansEnumNearQuery(new SpansEnumQuery[]
+      { q2, new FieldMaskingSpansEnumQuery(q1, "last")}, -1, false );
+    check(q, new int[] { 0, 2 });
+    q = new SpansEnumNearQuery(new SpansEnumQuery[]
+      { new FieldMaskingSpansEnumQuery(q1, "last"), q2}, -1, false );
+    check(q, new int[] { 0, 2 });
+
+  }
+
+  public void testSimple2SpansEnum() throws Exception {
+    assumeTrue("Broken scoring: LUCENE-3723",
+        searcher.getSimilarity() instanceof TFIDFSimilarity);
+    SpansEnumQuery q1 = new SpansEnumTermQuery(new Term("gender", "female"));
+    SpansEnumQuery q2 = new SpansEnumTermQuery(new Term("last", "smith"));
+    SpansEnumQuery q = new SpansEnumNearQuery(new SpansEnumQuery[]
+      { q1, new FieldMaskingSpansEnumQuery(q2, "gender")}, -1, false );
+    check(q, new int[] { 2, 4 });
+    q = new SpansEnumNearQuery(new SpansEnumQuery[]
+      { new FieldMaskingSpansEnumQuery(q1, "id"),
+        new FieldMaskingSpansEnumQuery(q2, "id") }, -1, false );
+    check(q, new int[] { 2, 4 });
+  }
+
+  public void testSpansEnum0() throws Exception {
+    SpansEnumQuery q1 = new SpansEnumTermQuery(new Term("gender", "female"));
+    SpansEnumQuery q2 = new SpansEnumTermQuery(new Term("first",  "james"));
+    SpansEnumQuery q  = new SpansEnumOrQuery(q1, new FieldMaskingSpansEnumQuery(q2, "gender"));
+    check(q, new int[] { 0, 1, 2, 3, 4 });
+
+    SpansEnum span = TestSpans.getSpansEnumFromQuery(q, searcher.getIndexReader());
+
+    TestSpans.tstNextSpansEnum(span, 0,0,1);
+    TestSpans.tstNextSpansEnum(span, 1,0,1);
+    TestSpans.tstNextSpansEnum(span, 1,1,2);
+    TestSpans.tstNextSpansEnum(span, 2,0,1);
+    TestSpans.tstNextSpansEnum(span, 2,1,2);
+    TestSpans.tstNextSpansEnum(span, 2,2,3);
+    TestSpans.tstNextSpansEnum(span, 3,0,1);
+    TestSpans.tstNextSpansEnum(span, 4,0,1);
+    TestSpans.tstNextSpansEnum(span, 4,1,2);
+    TestSpans.tstEndSpansEnum(span);
+  }
+
+  public void testSpansEnum1() throws Exception {
+    SpansEnumQuery q1 = new SpansEnumTermQuery(new Term("first", "sally"));
+    SpansEnumQuery q2 = new SpansEnumTermQuery(new Term("first", "james"));
+    SpansEnumQuery qA = new SpansEnumOrQuery(q1, q2);
+    SpansEnumQuery qB = new FieldMaskingSpansEnumQuery(qA, "id");
+
+    check(qA, new int[] { 0, 1, 2, 4 });
+    check(qB, new int[] { 0, 1, 2, 4 });
+
+    SpansEnum spanA = TestSpans.getSpansEnumFromQuery(qA, searcher.getIndexReader());
+    SpansEnum spanB = TestSpans.getSpansEnumFromQuery(qB, searcher.getIndexReader());
+
+    while (spanA.nextDoc() != SpansEnum.NO_MORE_DOCS) {
+      assertNotSame("spanB not still going", SpansEnum.NO_MORE_DOCS, spanB.nextDoc());
+      while (spanA.nextStartPosition() != SpansEnum.NO_MORE_POSITIONS) {
+        assertEquals("spanB start position", spanA.startPosition(), spanB.nextStartPosition());
+        assertEquals("spanB end position", spanA.endPosition(), spanB.endPosition());
+      }
+      assertEquals("spanB start position", SpansEnum.NO_MORE_POSITIONS, spanB.nextStartPosition());
+    }
+    assertEquals("spanB end doc", SpansEnum.NO_MORE_DOCS, spanB.nextDoc());
+
+  }
+
+  public void testSpansEnum2() throws Exception {
+    assumeTrue("Broken scoring: LUCENE-3723",
+        searcher.getSimilarity() instanceof TFIDFSimilarity);
+    SpansEnumQuery qA1 = new SpansEnumTermQuery(new Term("gender", "female"));
+    SpansEnumQuery qA2 = new SpansEnumTermQuery(new Term("first",  "james"));
+    SpansEnumQuery qA  = new SpansEnumOrQuery(qA1, new FieldMaskingSpansEnumQuery(qA2, "gender"));
+    SpansEnumQuery qB  = new SpansEnumTermQuery(new Term("last",   "jones"));
+    SpansEnumQuery q   = new SpansEnumNearQuery(new SpansEnumQuery[]
+      { new FieldMaskingSpansEnumQuery(qA, "id"),
+        new FieldMaskingSpansEnumQuery(qB, "id") }, -1, false );
+    check(q, new int[] { 0, 1, 2, 3 });
+
+    SpansEnum span = TestSpans.getSpansEnumFromQuery(q, searcher.getIndexReader());
+
+    TestSpans.tstNextSpansEnum(span, 0,0,1);
+    TestSpans.tstNextSpansEnum(span, 1,1,2);
+    TestSpans.tstNextSpansEnum(span, 2,0,1);
+    TestSpans.tstNextSpansEnum(span, 2,2,3);
+    TestSpans.tstNextSpansEnum(span, 3,0,1);
+    TestSpans.tstEndSpansEnum(span);
+  }
+
+  public String s(Spans span) {
+    return s(span.doc(), span.start(), span.end());
+  }
+  public String s(int doc, int start, int end) {
+    return "s(" + doc + "," + start + "," + end +")";
+  }
+
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
index 5eb29cf..ff9ffd6 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
@@ -80,10 +80,26 @@ public class TestNearSpansOrdered extends LuceneTestCase {
        slop,
        inOrder);
   }
+
+  protected SpansEnumNearQuery makeSEQuery(String s1, String s2, String s3,
+                                            int slop, boolean inOrder) {
+    return new SpansEnumNearQuery
+      (new SpansEnumQuery[] {
+        new SpansEnumTermQuery(new Term(FIELD, s1)),
+        new SpansEnumTermQuery(new Term(FIELD, s2)),
+        new SpansEnumTermQuery(new Term(FIELD, s3)) },
+       slop,
+       inOrder);
+  }
+
   protected SpanNearQuery makeQuery() {
     return makeQuery("w1","w2","w3",1,true);
   }
 
+  protected SpansEnumNearQuery makeSEQuery() {
+    return makeSEQuery("w1","w2","w3",1,true);
+  }
+
   protected SpanNearQuery makeOverlappedQuery(
       String sqt1, String sqt2, boolean sqOrdered,
       String t3, boolean ordered) {
@@ -100,28 +116,58 @@ public class TestNearSpansOrdered extends LuceneTestCase {
           ordered);
   }
   
+  protected SpansEnumNearQuery makeOverlappedSEQuery(
+      String sqt1, String sqt2, boolean sqOrdered,
+      String t3, boolean ordered) {
+    return new SpansEnumNearQuery(
+      new SpansEnumQuery[] {
+        new SpansEnumNearQuery(new SpansEnumQuery[] {
+          new SpansEnumTermQuery(new Term(FIELD, sqt1)),
+            new SpansEnumTermQuery(new Term(FIELD, sqt2)) },
+            1,
+            sqOrdered
+          ),
+          new SpansEnumTermQuery(new Term(FIELD, t3)) },
+          0,
+          ordered);
+  }
+  
   public void testSpanNearQuery() throws Exception {
     SpanNearQuery q = makeQuery();
     CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {0,1});
   }
 
+  public void testSpansEnumNearQuery() throws Exception {
+    SpansEnumNearQuery q = makeSEQuery();
+    CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {0,1});
+  }
+
   public String s(Spans span) {
     return s(span.doc(), span.start(), span.end());
   }
+  public String s(SpansEnum span) {
+    return s(span.docID(), span.startPosition(), span.endPosition());
+  }
   public String s(int doc, int start, int end) {
     return "s(" + doc + "," + start + "," + end +")";
   }
   
   public void testNearSpansNext() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), q);
-    assertEquals(true, span.next());
-    assertEquals(s(0,0,3), s(span));
-    assertEquals(true, span.next());
-    assertEquals(s(1,0,4), s(span));
+    Spans span = TestSpans.getSpansFromQuery(q, reader);
+    TestSpans.tstNextSpans(span,0,0,3);
+    TestSpans.tstNextSpans(span,1,0,4);
     assertEquals(false, span.next());
   }
 
+  public void testNearSpansEnumNext() throws Exception {
+    SpansEnumNearQuery q = makeSEQuery();
+    SpansEnum span = TestSpans.getSpansEnumFromQuery(q, reader);
+    TestSpans.tstNextSpansEnum(span,0,0,3);
+    TestSpans.tstNextSpansEnum(span,1,0,4);
+    TestSpans.tstEndSpansEnum(span);
+  }
+
   /**
    * test does not imply that skipTo(doc+1) should work exactly the
    * same as next -- it's only applicable in this case since we know doc
@@ -129,7 +175,7 @@ public class TestNearSpansOrdered extends LuceneTestCase {
    */
   public void testNearSpansSkipToLikeNext() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span =  MultiSpansWrapper.wrap(searcher.getTopReaderContext(), q);
+    Spans span = TestSpans.getSpansFromQuery(q, reader);
     assertEquals(true, span.skipTo(0));
     assertEquals(s(0,0,3), s(span));
     assertEquals(true, span.skipTo(1));
@@ -137,44 +183,70 @@ public class TestNearSpansOrdered extends LuceneTestCase {
     assertEquals(false, span.skipTo(2));
   }
   
-  public void testNearSpansNextThenSkipTo() throws Exception {
-    SpanNearQuery q = makeQuery();
-    Spans span =  MultiSpansWrapper.wrap(searcher.getTopReaderContext(), q);
-    assertEquals(true, span.next());
+  public void testNearSpansEnumNextDocThenAdvance() throws Exception {
+    SpansEnumNearQuery q = makeSEQuery();
+    SpansEnum span = TestSpans.getSpansEnumFromQuery(q, reader);
+    assertNotSame(SpansEnum.NO_MORE_DOCS, span.nextDoc());
+    assertEquals(0, span.nextStartPosition());
     assertEquals(s(0,0,3), s(span));
-    assertEquals(true, span.skipTo(1));
+    assertNotSame(SpansEnum.NO_MORE_DOCS, span.advance(1));
+    assertEquals(0, span.nextStartPosition());
     assertEquals(s(1,0,4), s(span));
-    assertEquals(false, span.next());
+    assertEquals(SpansEnum.NO_MORE_DOCS, span.nextDoc());
   }
   
   public void testNearSpansNextThenSkipPast() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span =  MultiSpansWrapper.wrap(searcher.getTopReaderContext(), q);
+    Spans span = TestSpans.getSpansFromQuery(q, reader);
     assertEquals(true, span.next());
     assertEquals(s(0,0,3), s(span));
     assertEquals(false, span.skipTo(2));
   }
   
+  public void testNearSpansEnumNextThenAdvancePast() throws Exception {
+    SpansEnumNearQuery q = makeSEQuery();
+    SpansEnum span = TestSpans.getSpansEnumFromQuery(q, reader);
+    assertNotSame(SpansEnum.NO_MORE_DOCS, span.nextDoc());
+    assertEquals(0, span.nextStartPosition());
+    assertEquals(s(0,0,3), s(span));
+    assertEquals(SpansEnum.NO_MORE_DOCS, span.advance(2));
+  }
+
   public void testNearSpansSkipPast() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span =  MultiSpansWrapper.wrap(searcher.getTopReaderContext(), q);
+    Spans span = TestSpans.getSpansFromQuery(q, reader);
     assertEquals(false, span.skipTo(2));
   }
+
+  public void testNearSpansEnumAdvancePast() throws Exception {
+    SpansEnumNearQuery q = makeSEQuery();
+    SpansEnum span = TestSpans.getSpansEnumFromQuery(q, reader);
+    assertEquals(SpansEnum.NO_MORE_DOCS, span.advance(2));
+  }
+
   
   public void testNearSpansSkipTo0() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), q);
+    Spans span = TestSpans.getSpansFromQuery(q, reader);
     assertEquals(true, span.skipTo(0));
     assertEquals(s(0,0,3), s(span));
   }
 
   public void testNearSpansSkipTo1() throws Exception {
     SpanNearQuery q = makeQuery();
-    Spans span =  MultiSpansWrapper.wrap(searcher.getTopReaderContext(), q);
+    Spans span = TestSpans.getSpansFromQuery(q, reader);
     assertEquals(true, span.skipTo(1));
     assertEquals(s(1,0,4), s(span));
   }
 
+  public void testNearSpansEnumAdvanceTo1() throws Exception {
+    SpansEnumNearQuery q = makeSEQuery();
+    SpansEnum span = TestSpans.getSpansEnumFromQuery(q, reader);
+    assertNotSame(SpansEnum.NO_MORE_DOCS, span.advance(1));
+    assertEquals(0, span.nextStartPosition());
+    assertEquals(s(1,0,4), s(span));
+  }
+
   /**
    * not a direct test of NearSpans, but a demonstration of how/when
    * this causes problems
@@ -188,21 +260,45 @@ public class TestNearSpansOrdered extends LuceneTestCase {
     assertEquals(1, s.advance(1));
   }
 
+  public void testSpansEnumNearScorerSkipTo1() throws Exception {
+    SpansEnumNearQuery q = makeSEQuery();
+    Weight w = searcher.createNormalizedWeight(q, true);
+    IndexReaderContext topReaderContext = searcher.getTopReaderContext();
+    LeafReaderContext leave = topReaderContext.leaves().get(0);
+    Scorer s = w.scorer(leave, leave.reader().getLiveDocs());
+    assertEquals(1, s.advance(1));
+  }
+
   public void testOverlappedOrderedSpan() throws Exception {
     SpanNearQuery q = makeOverlappedQuery("w5", "w3", false, "w4", true);
     CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {});
   }
   
+  public void testOverlappedOrderedSpansEnum() throws Exception {
+    SpansEnumNearQuery q = makeOverlappedSEQuery("w5", "w3", false, "w4", true);
+    CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {});
+  }
+  
   public void testOverlappedNonOrderedSpan() throws Exception {
     SpanNearQuery q = makeOverlappedQuery("w3", "w5", true, "w4", false);
     CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {0});
   }
 
+  public void testOverlappedNonOrderedSpansEnum() throws Exception {
+    SpansEnumNearQuery q = makeOverlappedSEQuery("w3", "w5", true, "w4", false);
+    CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {0});
+  }
+
   public void testNonOverlappedOrderedSpan() throws Exception {
     SpanNearQuery q = makeOverlappedQuery("w3", "w4", true, "w5", true);
     CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {0});
   }
   
+  public void testNonOverlappedOrderedSpansEnum() throws Exception {
+    SpansEnumNearQuery q = makeOverlappedSEQuery("w3", "w4", true, "w5", true);
+    CheckHits.checkHits(random(), q, FIELD, searcher, new int[] {0});
+  }
+  
   
   /**
    * not a direct test of NearSpans, but a demonstration of how/when
@@ -215,4 +311,12 @@ public class TestNearSpansOrdered extends LuceneTestCase {
                + e.toString(),
                0.0f < e.getValue());
   }
+
+  public void testSpansEnumNearScorerExplain() throws Exception {
+    SpansEnumNearQuery q = makeSEQuery();
+    Explanation e = searcher.explain(q, 1);
+    assertTrue("Scorer explanation value for doc#1 isn't positive: "
+               + e.toString(),
+               0.0f < e.getValue());
+  }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestPayloadSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestPayloadSpans.java
index 3d02ea5..2544643 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestPayloadSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestPayloadSpans.java
@@ -42,6 +42,7 @@ import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.payloads.PayloadHelper;
 import org.apache.lucene.search.payloads.PayloadSpanUtil;
+import org.apache.lucene.search.payloads.PayloadSpansEnumUtil;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.store.Directory;
@@ -67,23 +68,34 @@ public class TestPayloadSpans extends LuceneTestCase {
     SpanTermQuery stq;
     Spans spans;
     stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "seventy"));
-    spans = MultiSpansWrapper.wrap(indexReader.getContext(), stq);
+    spans = TestSpans.getSpansFromQuery(stq, indexReader);
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, 100, 1, 1, 1);
 
     stq = new SpanTermQuery(new Term(PayloadHelper.NO_PAYLOAD_FIELD, "seventy"));  
-    spans = MultiSpansWrapper.wrap(indexReader.getContext(), stq);
+    spans = TestSpans.getSpansFromQuery(stq, indexReader);
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, 100, 0, 0, 0);
   }
 
-  public void testSpanFirst() throws IOException {
+  public void testSpansEnumTermQuery() throws Exception {
+    SpansEnumTermQuery setq = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "seventy"));
+    SpansEnum spans = TestSpans.getSpansEnumFromQuery(setq, indexReader);
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    checkSpansEnum(spans, 100, 1, 1, 1);
 
+    setq = new SpansEnumTermQuery(new Term(PayloadHelper.NO_PAYLOAD_FIELD, "seventy"));  
+    spans = TestSpans.getSpansEnumFromQuery(setq, indexReader);
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    checkSpansEnum(spans, 100, 0, 0, 0);
+  }
+
+  public void testSpanFirst() throws IOException {
     SpanQuery match;
     SpanFirstQuery sfq;
     match = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
     sfq = new SpanFirstQuery(match, 2);
-    Spans spans = MultiSpansWrapper.wrap(indexReader.getContext(), sfq);
+    Spans spans = TestSpans.getSpansFromQuery(sfq, indexReader);
     checkSpans(spans, 109, 1, 1, 1);
     //Test more complicated subclause
     SpanQuery[] clauses = new SpanQuery[2];
@@ -91,12 +103,31 @@ public class TestPayloadSpans extends LuceneTestCase {
     clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "hundred"));
     match = new SpanNearQuery(clauses, 0, true);
     sfq = new SpanFirstQuery(match, 2);
-    checkSpans(MultiSpansWrapper.wrap(indexReader.getContext(), sfq), 100, 2, 1, 1);
+    checkSpans(TestSpans.getSpansFromQuery(sfq, indexReader), 100, 2, 1, 1);
 
     match = new SpanNearQuery(clauses, 0, false);
     sfq = new SpanFirstQuery(match, 2);
-    checkSpans(MultiSpansWrapper.wrap(indexReader.getContext(), sfq), 100, 2, 1, 1);
-    
+    checkSpans(TestSpans.getSpansFromQuery(sfq, indexReader), 100, 2, 1, 1);
+  }
+  
+  public void testSpansEnumFirst() throws IOException {
+    SpansEnumQuery match;
+    SpansEnumFirstQuery sefq;
+    match = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "one"));
+    sefq = new SpansEnumFirstQuery(match, 2);
+    SpansEnum spans = TestSpans.getSpansEnumFromQuery(sefq, indexReader);
+    checkSpansEnum(spans, 109, 1, 1, 1);
+    //Test more complicated subclause
+    SpansEnumQuery[] clauses = new SpansEnumQuery[2];
+    clauses[0] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "one"));
+    clauses[1] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "hundred"));
+    match = new SpansEnumNearQuery(clauses, 0, true);
+    sefq = new SpansEnumFirstQuery(match, 2);
+    checkSpansEnum(TestSpans.getSpansEnumFromQuery(sefq, indexReader), 100, 2, 1, 1);
+
+    match = new SpansEnumNearQuery(clauses, 0, false);
+    sefq = new SpansEnumFirstQuery(match, 2);
+    checkSpansEnum(TestSpans.getSpansEnumFromQuery(sefq, indexReader), 100, 2, 1, 1);
   }
   
   public void testSpanNot() throws Exception {
@@ -106,7 +137,27 @@ public class TestPayloadSpans extends LuceneTestCase {
     SpanQuery spq = new SpanNearQuery(clauses, 5, true);
     SpanNotQuery snq = new SpanNotQuery(spq, new SpanTermQuery(new Term(PayloadHelper.FIELD, "two")));
 
+    Directory directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+                                                     newIndexWriterConfig(new PayloadAnalyzer()).setSimilarity(similarity));
+
+    Document doc = new Document();
+    doc.add(newTextField(PayloadHelper.FIELD, "one two three one four three", Field.Store.YES));
+    writer.addDocument(doc);
+    IndexReader reader = writer.getReader();
+    writer.close();
 
+    checkSpans(TestSpans.getSpansFromQuery(snq, reader), 1,new int[]{2});
+    reader.close();
+    directory.close();
+  }
+  
+  public void testSpansEnumNot() throws Exception {
+    SpansEnumQuery[] clauses = new SpansEnumQuery[2];
+    clauses[0] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "one"));
+    clauses[1] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "three"));
+    SpansEnumQuery sepq = new SpansEnumNearQuery(clauses, 5, true);
+    SpansEnumNotQuery senq = new SpansEnumNotQuery(sepq, new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "two")));
 
     Directory directory = newDirectory();
     RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
@@ -117,9 +168,8 @@ public class TestPayloadSpans extends LuceneTestCase {
     writer.addDocument(doc);
     IndexReader reader = writer.getReader();
     writer.close();
-    
 
-    checkSpans(MultiSpansWrapper.wrap(reader.getContext(), snq), 1,new int[]{2});
+    checkSpansEnum(TestSpans.getSpansEnumFromQuery(senq, reader), 1,new int[]{2});
     reader.close();
     directory.close();
   }
@@ -129,21 +179,19 @@ public class TestPayloadSpans extends LuceneTestCase {
     Spans spans;
     IndexSearcher searcher = getSearcher();
     stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "mark"));
-    spans = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), stq);
+    spans = TestSpans.getSpansFromQuery(stq, searcher.getIndexReader());
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, 0, null);
 
-
     SpanQuery[] clauses = new SpanQuery[3];
     clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "rr"));
     clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "yy"));
     clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
     SpanNearQuery spanNearQuery = new SpanNearQuery(clauses, 12, false);
 
-    spans = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), spanNearQuery);
+    spans = TestSpans.getSpansFromQuery(spanNearQuery, searcher.getIndexReader());
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, 2, new int[]{3,3});
-
      
     clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
     clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "rr"));
@@ -151,7 +199,7 @@ public class TestPayloadSpans extends LuceneTestCase {
 
     spanNearQuery = new SpanNearQuery(clauses, 6, true);
    
-    spans = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), spanNearQuery);
+    spans = TestSpans.getSpansFromQuery(spanNearQuery, searcher.getIndexReader());
 
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, 1, new int[]{3});
@@ -174,13 +222,67 @@ public class TestPayloadSpans extends LuceneTestCase {
     
     // yy within 6 of xx within 6 of rr
 
-    spans = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), nestedSpanNearQuery);
+    spans = TestSpans.getSpansFromQuery(nestedSpanNearQuery, searcher.getIndexReader());
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, 2, new int[]{3,3});
     closeIndexReader.close();
     directory.close();
   }
   
+  public void testNestedSpansEnum() throws Exception {
+    SpansEnumTermQuery setq;
+    SpansEnum spans;
+    IndexSearcher searcher = getSearcher();
+    setq = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "mark"));
+    spans = TestSpans.getSpansEnumFromQuery(setq, searcher.getIndexReader());
+    assertEquals("spans", null, spans);
+
+    SpansEnumQuery[] clauses = new SpansEnumQuery[3];
+    clauses[0] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "rr"));
+    clauses[1] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "yy"));
+    clauses[2] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "xx"));
+    SpansEnumNearQuery spanNearQuery = new SpansEnumNearQuery(clauses, 12, false);
+
+    spans = TestSpans.getSpansEnumFromQuery(spanNearQuery, searcher.getIndexReader());
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    checkSpansEnum(spans, 2, new int[]{3,3});
+     
+    clauses[0] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "xx"));
+    clauses[1] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "rr"));
+    clauses[2] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "yy"));
+
+    spanNearQuery = new SpansEnumNearQuery(clauses, 6, true);
+   
+    spans = TestSpans.getSpansEnumFromQuery(spanNearQuery, searcher.getIndexReader());
+
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    checkSpansEnum(spans, 1, new int[]{3});
+     
+    clauses = new SpansEnumQuery[2];
+     
+    clauses[0] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "xx"));
+    clauses[1] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "rr"));
+
+    spanNearQuery = new SpansEnumNearQuery(clauses, 6, true);
+     
+    // xx within 6 of rr
+    
+    SpansEnumQuery[] clauses2 = new SpansEnumQuery[2];
+     
+    clauses2[0] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "yy"));
+    clauses2[1] = spanNearQuery;
+     
+    SpansEnumNearQuery nestedSpanNearQuery = new SpansEnumNearQuery(clauses2, 6, false);
+    
+    // yy within 6 of xx within 6 of rr
+
+    spans = TestSpans.getSpansEnumFromQuery(nestedSpanNearQuery, searcher.getIndexReader());
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    checkSpansEnum(spans, 2, new int[]{3,3});
+    closeIndexReader.close();
+    directory.close();
+  }
+  
   public void testFirstClauseWithoutPayload() throws Exception {
     Spans spans;
     IndexSearcher searcher = getSearcher();
@@ -205,7 +307,7 @@ public class TestPayloadSpans extends LuceneTestCase {
     clauses3[1] = snq;
      
     SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses3, 6, false);
-    spans = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), nestedSpanNearQuery);
+    spans = TestSpans.getSpansFromQuery(nestedSpanNearQuery, searcher.getIndexReader());
 
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, 1, new int[]{3});
@@ -213,6 +315,38 @@ public class TestPayloadSpans extends LuceneTestCase {
     directory.close();
   }
   
+  public void testFirstClauseWithoutPayloadSpansEnum() throws Exception {
+    SpansEnum spans;
+    IndexSearcher searcher = getSearcher();
+
+    SpansEnumQuery[] clauses = new SpansEnumQuery[3];
+    clauses[0] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "nopayload"));
+    clauses[1] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "qq"));
+    clauses[2] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "ss"));
+
+    SpansEnumNearQuery spanNearQuery = new SpansEnumNearQuery(clauses, 6, true);
+    
+    SpansEnumQuery[] clauses2 = new SpansEnumQuery[2];
+     
+    clauses2[0] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "pp"));
+    clauses2[1] = spanNearQuery;
+
+    SpansEnumNearQuery snq = new SpansEnumNearQuery(clauses2, 6, false);
+    
+    SpansEnumQuery[] clauses3 = new SpansEnumQuery[2];
+     
+    clauses3[0] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "np"));
+    clauses3[1] = snq;
+     
+    SpansEnumNearQuery nestedSpanNearQuery = new SpansEnumNearQuery(clauses3, 6, false);
+    spans = TestSpans.getSpansEnumFromQuery(nestedSpanNearQuery, searcher.getIndexReader());
+
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    checkSpansEnum(spans, 1, new int[]{3});
+    closeIndexReader.close();
+    directory.close();
+  }
+  
   public void testHeavilyNestedSpanQuery() throws Exception {
     Spans spans;
     IndexSearcher searcher = getSearcher();
@@ -243,14 +377,51 @@ public class TestPayloadSpans extends LuceneTestCase {
      
     SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses3, 6, false);
 
-    spans = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), nestedSpanNearQuery);
+    spans = TestSpans.getSpansFromQuery(nestedSpanNearQuery, searcher.getIndexReader());
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, 2, new int[]{8, 8});
     closeIndexReader.close();
     directory.close();
   }
   
-  public void testShrinkToAfterShortestMatch() throws IOException {
+  public void testHeavilyNestedSpansEnumQuery() throws Exception {
+    SpansEnum spans;
+    IndexSearcher searcher = getSearcher();
+
+    SpansEnumQuery[] clauses = new SpansEnumQuery[3];
+    clauses[0] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "one"));
+    clauses[1] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "two"));
+    clauses[2] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "three"));
+
+    SpansEnumNearQuery spanNearQuery = new SpansEnumNearQuery(clauses, 5, true);
+   
+    clauses = new SpansEnumQuery[3];
+    clauses[0] = spanNearQuery; 
+    clauses[1] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "five"));
+    clauses[2] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "six"));
+
+    SpansEnumNearQuery spanNearQuery2 = new SpansEnumNearQuery(clauses, 6, true);
+     
+    SpansEnumQuery[] clauses2 = new SpansEnumQuery[2];
+    clauses2[0] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "eleven"));
+    clauses2[1] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "ten"));
+    SpansEnumNearQuery spanNearQuery3 = new SpansEnumNearQuery(clauses2, 2, false);
+    
+    SpansEnumQuery[] clauses3 = new SpansEnumQuery[3];
+    clauses3[0] = new SpansEnumTermQuery(new Term(PayloadHelper.FIELD, "nine"));
+    clauses3[1] = spanNearQuery2;
+    clauses3[2] = spanNearQuery3;
+     
+    SpansEnumNearQuery nestedSpanNearQuery = new SpansEnumNearQuery(clauses3, 6, false);
+
+    spans = TestSpans.getSpansEnumFromQuery(nestedSpanNearQuery, searcher.getIndexReader());
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    checkSpansEnum(spans, 2, new int[]{8, 8});
+    closeIndexReader.close();
+    directory.close();
+  }
+
+  public void testShrinkToAfterShortestMatch1() throws IOException {
     Directory directory = newDirectory();
     RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
                                                      newIndexWriterConfig(new TestPayloadAnalyzer()));
@@ -267,7 +438,7 @@ public class TestPayloadSpans extends LuceneTestCase {
     SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 1, true);
-    Spans spans = MultiSpansWrapper.wrap(is.getTopReaderContext(), snq);
+    Spans spans = TestSpans.getSpansFromQuery(snq, reader);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
@@ -287,6 +458,45 @@ public class TestPayloadSpans extends LuceneTestCase {
     directory.close();
   }
   
+  public void testShrinkToAfterShortestMatch1SpansEnum() throws IOException {
+    Directory directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+                                                     newIndexWriterConfig(new TestPayloadAnalyzer()));
+
+    Document doc = new Document();
+    doc.add(new TextField("content", new StringReader("a b c d e f g h i j a k")));
+    writer.addDocument(doc);
+
+    IndexReader reader = writer.getReader();
+    IndexSearcher is = newSearcher(reader);
+    writer.close();
+
+    SpansEnumTermQuery stq1 = new SpansEnumTermQuery(new Term("content", "a"));
+    SpansEnumTermQuery stq2 = new SpansEnumTermQuery(new Term("content", "k"));
+    SpansEnumQuery[] sqs = { stq1, stq2 };
+    SpansEnumNearQuery snq = new SpansEnumNearQuery(sqs, 1, true);
+    SpansEnum spans = TestSpans.getSpansEnumFromQuery(snq, reader);
+
+    TopDocs topDocs = is.search(snq, 1);
+    Set<String> payloadSet = new HashSet<>();
+    for (int i = 0; i < topDocs.scoreDocs.length; i++) {
+      while (spans.nextDoc() != SpansEnum.NO_MORE_DOCS) {
+        while (spans.nextStartPosition() != SpansEnum.NO_MORE_POSITIONS) {
+          Collection<byte[]> payloads = spans.getPayload();
+  
+          for (final byte [] payload : payloads) {
+            payloadSet.add(new String(payload, StandardCharsets.UTF_8));
+          }
+        }
+      }
+    }
+    assertEquals(2, payloadSet.size());
+    assertTrue(payloadSet.contains("a:Noise:10"));
+    assertTrue(payloadSet.contains("k:Noise:11"));
+    reader.close();
+    directory.close();
+  }
+  
   public void testShrinkToAfterShortestMatch2() throws IOException {
     Directory directory = newDirectory();
     RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
@@ -303,7 +513,7 @@ public class TestPayloadSpans extends LuceneTestCase {
     SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
-    Spans spans =  MultiSpansWrapper.wrap(is.getTopReaderContext(), snq);
+    Spans spans =  TestSpans.getSpansFromQuery(snq, reader);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
@@ -322,6 +532,44 @@ public class TestPayloadSpans extends LuceneTestCase {
     directory.close();
   }
   
+  public void testShrinkToAfterShortestMatch2SpansEnum() throws IOException {
+    Directory directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+                                                     newIndexWriterConfig(new TestPayloadAnalyzer()));
+
+    Document doc = new Document();
+    doc.add(new TextField("content", new StringReader("a b a d k f a h i k a k")));
+    writer.addDocument(doc);
+    IndexReader reader = writer.getReader();
+    IndexSearcher is = newSearcher(reader);
+    writer.close();
+
+    SpansEnumTermQuery stq1 = new SpansEnumTermQuery(new Term("content", "a"));
+    SpansEnumTermQuery stq2 = new SpansEnumTermQuery(new Term("content", "k"));
+    SpansEnumQuery[] sqs = { stq1, stq2 };
+    SpansEnumNearQuery snq = new SpansEnumNearQuery(sqs, 0, true);
+    SpansEnum spans =  TestSpans.getSpansEnumFromQuery(snq, reader);
+
+    TopDocs topDocs = is.search(snq, 1);
+    Set<String> payloadSet = new HashSet<>();
+    for (int i = 0; i < topDocs.scoreDocs.length; i++) {
+      while (spans.nextDoc() != SpansEnum.NO_MORE_DOCS) {
+        while (spans.nextStartPosition() != SpansEnum.NO_MORE_POSITIONS) {
+          Collection<byte[]> payloads = spans.getPayload();
+  
+          for (final byte [] payload : payloads) {
+            payloadSet.add(new String(payload, StandardCharsets.UTF_8));
+          }
+        }
+      }
+    }
+    assertEquals(2, payloadSet.size());
+    assertTrue(payloadSet.contains("a:Noise:10"));
+    assertTrue(payloadSet.contains("k:Noise:11"));
+    reader.close();
+    directory.close();
+  }
+  
   public void testShrinkToAfterShortestMatch3() throws IOException {
     Directory directory = newDirectory();
     RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
@@ -338,7 +586,7 @@ public class TestPayloadSpans extends LuceneTestCase {
     SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
-    Spans spans =  MultiSpansWrapper.wrap(is.getTopReaderContext(), snq);
+    Spans spans =  TestSpans.getSpansFromQuery(snq, reader);
 
     TopDocs topDocs = is.search(snq, 1);
     Set<String> payloadSet = new HashSet<>();
@@ -363,6 +611,50 @@ public class TestPayloadSpans extends LuceneTestCase {
     directory.close();
   }
   
+  public void testShrinkToAfterShortestMatch3SpansEnum() throws IOException {
+    Directory directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+                                                     newIndexWriterConfig(new TestPayloadAnalyzer()));
+
+    Document doc = new Document();
+    doc.add(new TextField("content", new StringReader("j k a l f k k p a t a k l k t a")));
+    writer.addDocument(doc);
+    IndexReader reader = writer.getReader();
+    IndexSearcher is = newSearcher(reader);
+    writer.close();
+
+    SpansEnumTermQuery stq1 = new SpansEnumTermQuery(new Term("content", "a"));
+    SpansEnumTermQuery stq2 = new SpansEnumTermQuery(new Term("content", "k"));
+    SpansEnumQuery[] sqs = { stq1, stq2 };
+    SpansEnumNearQuery snq = new SpansEnumNearQuery(sqs, 0, true);
+    SpansEnum spans = TestSpans.getSpansEnumFromQuery(snq, reader);
+
+    TopDocs topDocs = is.search(snq, 1);
+    Set<String> payloadSet = new HashSet<>();
+    for (int i = 0; i < topDocs.scoreDocs.length; i++) {
+      while (spans.nextDoc() != SpansEnum.NO_MORE_DOCS) {
+        while (spans.nextStartPosition() != SpansEnum.NO_MORE_POSITIONS) {
+          Collection<byte[]> payloads = spans.getPayload();
+  
+          for (final byte [] payload : payloads) {
+            payloadSet.add(new String(payload, StandardCharsets.UTF_8));
+          }
+        }
+      }
+    }
+    assertEquals(2, payloadSet.size());
+    if(VERBOSE) {
+      for (final String payload : payloadSet)
+        System.out.println("match:" +  payload);
+      
+    }
+    assertTrue(payloadSet.contains("a:Noise:10"));
+    assertTrue(payloadSet.contains("k:Noise:11"));
+    reader.close();
+    directory.close();
+  }
+
+// FIXME: add SpansEnum test cases from here:  
   public void testPayloadSpanUtil() throws Exception {
     Directory directory = newDirectory();
     RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
@@ -389,6 +681,32 @@ public class TestPayloadSpans extends LuceneTestCase {
     directory.close();
   }
 
+  public void testPayloadSpansEnumUtil() throws Exception {
+    Directory directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+                                                     newIndexWriterConfig(new PayloadAnalyzer()).setSimilarity(similarity));
+
+    Document doc = new Document();
+    doc.add(newTextField(PayloadHelper.FIELD, "xx rr yy mm  pp", Field.Store.YES));
+    writer.addDocument(doc);
+  
+    IndexReader reader = writer.getReader();
+    writer.close();
+    IndexSearcher searcher = newSearcher(reader);
+
+    PayloadSpanUtil psu = new PayloadSpanUtil(searcher.getTopReaderContext());
+    
+    Collection<byte[]> payloads = psu.getPayloadsForQuery(new TermQuery(new Term(PayloadHelper.FIELD, "rr")));
+    if(VERBOSE) {
+      System.out.println("Num payloads:" + payloads.size());
+      for (final byte [] bytes : payloads) {
+        System.out.println(new String(bytes, StandardCharsets.UTF_8));
+      }
+    }
+    reader.close();
+    directory.close();
+  }
+
   private void checkSpans(Spans spans, int expectedNumSpans, int expectedNumPayloads,
                           int expectedPayloadLength, int expectedFirstByte) throws IOException {
     assertTrue("spans is null and it shouldn't be", spans != null);
@@ -422,6 +740,30 @@ public class TestPayloadSpans extends LuceneTestCase {
     assertTrue(seen + " does not equal: " + expectedNumSpans, seen == expectedNumSpans);
   }
   
+  private void checkSpansEnum(SpansEnum spans, int expectedNumSpans, int expectedNumPayloads,
+                              int expectedPayloadLength, int expectedFirstByte) throws IOException {
+    assertTrue("spans is null and it shouldn't be", spans != null);
+    //each position match should have a span associated with it, since there is just one underlying term query, there should
+    //only be one entry in the span
+    int seen = 0;
+    while (spans.nextDoc() != SpansEnum.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != SpansEnum.NO_MORE_POSITIONS) {
+        assertEquals("isPayloadAvailable should return true/false as payloads are expected", expectedNumPayloads > 0, spans.isPayloadAvailable());
+        //See payload helper, for the PayloadHelper.FIELD field, there is a single byte payload at every token
+        if (spans.isPayloadAvailable()) {
+          Collection<byte[]> payload = spans.getPayload();
+          assertEquals("payload size", expectedNumPayloads, payload.size());
+          for (final byte [] thePayload : payload) {
+            assertEquals("payload length", expectedPayloadLength, thePayload.length);
+            assertEquals("payload first byte", expectedFirstByte, thePayload[0]);
+          }
+        }
+        seen++;
+      }
+    }
+    assertEquals("expectedNumSpans", expectedNumSpans, seen);
+  }
+  
   private IndexSearcher getSearcher() throws Exception {
     directory = newDirectory();
     String[] docs = new String[]{"xx rr yy mm  pp","xx yy mm rr pp", "nopayload qq ss pp np", "one two three four five six seven eight nine ten eleven", "nine one two three four five six seven eight eleven ten"};
@@ -468,6 +810,33 @@ public class TestPayloadSpans extends LuceneTestCase {
 
     assertEquals(numSpans, cnt);
   }
+  
+  private void checkSpansEnum(SpansEnum spans, int numSpans, int[] numPayloads) throws IOException {
+    int cnt = 0;
+
+    while (spans.nextDoc() != SpansEnum.NO_MORE_DOCS) {
+      while (spans.nextStartPosition() != SpansEnum.NO_MORE_POSITIONS) {
+        if(VERBOSE)
+          System.out.println("\nSpans Dump --");
+        if (spans.isPayloadAvailable()) {
+          Collection<byte[]> payload = spans.getPayload();
+          if(VERBOSE) {
+            System.out.println("payloads for span:" + payload.size());
+            for (final byte [] bytes : payload) {
+              System.out.println("doc:" + spans.docID() + " s:" + spans.startPosition() + " e:" + spans.endPosition() + " "
+                + new String(bytes, StandardCharsets.UTF_8));
+            }
+          }
+          assertEquals("payload size", numPayloads[cnt], payload.size());
+        } else { // no payload available
+          assertFalse("Expected spans:" + numPayloads[cnt] + " found: 0", numPayloads.length > 0 && numPayloads[cnt] > 0 );
+        }
+        cnt++;
+      }
+    }
+
+    assertEquals("expected numSpans", numSpans, cnt);
+  }
 
   final class PayloadAnalyzer extends Analyzer {
 
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanBasics.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanBasics.java
new file mode 100644
index 0000000..b54e8a7
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanBasics.java
@@ -0,0 +1,1216 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+import org.apache.lucene.analysis.*;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.English;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ * Tests basic search capabilities.
+ *
+ * <p>Uses a collection of 1000 documents, each the english rendition of their
+ * document number.  For example, the document numbered 333 has text "three
+ * hundred thirty three".
+ *
+ * <p>Tests are each a single query, and its hits are checked to ensure that
+ * all and only the correct documents are returned, thus providing end-to-end
+ * testing of the indexing and search code.
+ *
+ */
+public class TestSpanBasics extends LuceneTestCase {
+  private static IndexSearcher searcher;
+  private static IndexReader reader;
+  private static Directory directory;
+
+  static final class SimplePayloadFilter extends TokenFilter {
+    int pos;
+    final PayloadAttribute payloadAttr;
+    final CharTermAttribute termAttr;
+
+    public SimplePayloadFilter(TokenStream input) {
+      super(input);
+      pos = 0;
+      payloadAttr = input.addAttribute(PayloadAttribute.class);
+      termAttr = input.addAttribute(CharTermAttribute.class);
+    }
+
+    @Override
+    public boolean incrementToken() throws IOException {
+      if (input.incrementToken()) {
+        payloadAttr.setPayload(new BytesRef(("pos: " + pos).getBytes(StandardCharsets.UTF_8)));
+        pos++;
+        return true;
+      } else {
+        return false;
+      }
+    }
+
+    @Override
+    public void reset() throws IOException {
+      super.reset();
+      pos = 0;
+    }
+  }
+  
+  static Analyzer simplePayloadAnalyzer;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    simplePayloadAnalyzer = new Analyzer() {
+        @Override
+        public TokenStreamComponents createComponents(String fieldName) {
+          Tokenizer tokenizer = new MockTokenizer(MockTokenizer.SIMPLE, true);
+          return new TokenStreamComponents(tokenizer, new SimplePayloadFilter(tokenizer));
+        }
+    };
+  
+    directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+        newIndexWriterConfig(simplePayloadAnalyzer)
+            .setMaxBufferedDocs(TestUtil.nextInt(random(), 100, 1000)).setMergePolicy(newLogMergePolicy()));
+    //writer.infoStream = System.out;
+    for (int i = 0; i < 2000; i++) {
+      Document doc = new Document();
+      doc.add(newTextField("field", English.intToEnglish(i), Field.Store.YES));
+      writer.addDocument(doc);
+    }
+    reader = writer.getReader();
+    searcher = newSearcher(reader);
+    writer.close();
+  }
+
+  @AfterClass
+  public static void afterClass() throws Exception {
+    reader.close();
+    directory.close();
+    searcher = null;
+    reader = null;
+    directory = null;
+    simplePayloadAnalyzer = null;
+  }
+  
+  Term fieldTerm(String w) {
+    return new Term("field", w);
+  }
+
+  TermQuery tq(String w) {
+    return new TermQuery( fieldTerm(w));
+  }
+
+  SpanTermQuery stq(String w) {
+    return new SpanTermQuery( fieldTerm(w));
+  }
+
+  SpansEnumTermQuery setq(String w) {
+    return new SpansEnumTermQuery( fieldTerm(w));
+  }
+
+  @Test
+  public void testTerm() throws Exception {
+    Query query = tq("seventy");
+    checkHits(query, new int[]
+      {70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 170, 171, 172, 173, 174, 175,
+              176, 177, 178, 179, 270, 271, 272, 273, 274, 275, 276, 277, 278,
+              279, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 470, 471,
+              472, 473, 474, 475, 476, 477, 478, 479, 570, 571, 572, 573, 574,
+              575, 576, 577, 578, 579, 670, 671, 672, 673, 674, 675, 676, 677,
+              678, 679, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 870,
+              871, 872, 873, 874, 875, 876, 877, 878, 879, 970, 971, 972, 973,
+              974, 975, 976, 977, 978, 979, 1070, 1071, 1072, 1073, 1074, 1075,
+              1076, 1077, 1078, 1079, 1170, 1171, 1172, 1173, 1174, 1175, 1176,
+              1177, 1178, 1179, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277,
+              1278, 1279, 1370, 1371, 1372, 1373, 1374, 1375, 1376, 1377, 1378,
+              1379, 1470, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479,
+              1570, 1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1670,
+              1671, 1672, 1673, 1674, 1675, 1676, 1677, 1678, 1679, 1770, 1771,
+              1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1870, 1871, 1872,
+              1873, 1874, 1875, 1876, 1877,
+              1878, 1879, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978,
+              1979});
+    }
+
+  @Test
+  public void testTerm2() throws Exception {
+    Query query = tq("seventish");
+    checkHits(query, new int[] {});
+  }
+
+  @Test
+  public void testPhrase() throws Exception {
+    PhraseQuery query = new PhraseQuery();
+    query.add(fieldTerm("seventy"));
+    query.add(fieldTerm("seven"));
+    checkHits(query, new int[]
+      {77, 177, 277, 377, 477, 577, 677, 777, 877,
+              977, 1077, 1177, 1277, 1377, 1477, 1577, 1677, 1777, 1877, 1977});
+  }
+
+  @Test
+  public void testPhrase2() throws Exception {
+    PhraseQuery query = new PhraseQuery();
+    query.add(fieldTerm("seventish"));
+    query.add(fieldTerm("sevenon"));
+    checkHits(query, new int[] {});
+  }
+
+  void addRequiredClause(BooleanQuery bq, Query q) {
+    bq.add(q, BooleanClause.Occur.MUST);
+  }
+
+  @Test
+  public void testBoolean() throws Exception {
+    BooleanQuery query = new BooleanQuery();
+    addRequiredClause(query, tq("seventy"));
+    addRequiredClause(query, tq("seven"));
+    checkHits(query, new int[]
+      {77, 177, 277, 377, 477, 577, 677, 770, 771, 772, 773, 774, 775, 776, 777,
+              778, 779, 877, 977, 1077, 1177, 1277, 1377, 1477, 1577, 1677,
+              1770, 1771, 1772, 1773, 1774, 1775, 1776, 1777, 1778, 1779, 1877,
+              1977});
+  }
+
+  @Test
+  public void testBoolean2() throws Exception {
+    BooleanQuery query = new BooleanQuery();
+    addRequiredClause(query, tq("sevento"));
+    addRequiredClause(query, tq("sevenly"));
+    checkHits(query, new int[] {});
+  }
+
+  @Test
+  public void testSpanNearExact() throws Exception {
+    SpanTermQuery term1 = stq("seventy");
+    SpanTermQuery term2 = stq("seven");
+    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {term1, term2},
+                                            0, true); // ordered
+    checkHits(query, new int[]
+      {77, 177, 277, 377, 477, 577, 677, 777, 877, 977, 1077, 1177, 1277, 1377, 1477, 1577, 1677, 1777, 1877, 1977});
+
+    assertTrue(searcher.explain(query, 77).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 977).getValue() > 0.0f);
+
+    QueryUtils.check(term1);
+    QueryUtils.check(term2);
+    QueryUtils.checkUnequal(term1,term2);
+  }
+  
+  @Test
+  public void testSpansEnumNearExact() throws Exception {
+    SpansEnumTermQuery term1 = setq("seventy");
+    SpansEnumTermQuery term2 = setq("seven");
+    SpansEnumNearQuery query = new SpansEnumNearQuery(new SpansEnumQuery[] {term1, term2},
+                                                      0, true); // ordered
+    checkHits(query, new int[]
+      {77, 177, 277, 377, 477, 577, 677, 777, 877, 977, 1077, 1177, 1277, 1377, 1477, 1577, 1677, 1777, 1877, 1977});
+
+    assertTrue(searcher.explain(query, 77).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 977).getValue() > 0.0f);
+
+    QueryUtils.check(term1);
+    QueryUtils.check(term2);
+    QueryUtils.checkUnequal(term1,term2);
+  }
+  
+  public void testSpanTermQuery() throws Exception {
+    SpanTermQuery term1 = stq("seventy");
+    checkHits(term1, new int[]
+                             { 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 170,
+        171, 172, 173, 174, 175, 176, 177, 178, 179, 270, 271, 272, 273, 274,
+        275, 276, 277, 278, 279, 370, 371, 372, 373, 374, 375, 376, 377, 378,
+        379, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 570, 571, 572,
+        573, 574, 575, 576, 577, 578, 579, 670, 671, 672, 673, 674, 675, 676,
+        677, 678, 679, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 870,
+        871, 872, 873, 874, 875, 876, 877, 878, 879, 970, 971, 972, 973, 974,
+        975, 976, 977, 978, 979, 1070, 1071, 1072, 1073, 1074, 1075, 1076,
+        1077, 1078, 1079, 1170, 1270, 1370, 1470, 1570, 1670, 1770, 1870, 1970,
+        1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1271, 1272, 1273,
+        1274, 1275, 1276, 1277, 1278, 1279, 1371, 1372, 1373, 1374, 1375, 1376,
+        1377, 1378, 1379, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479,
+        1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1671, 1672, 1673,
+        1674, 1675, 1676, 1677, 1678, 1679, 1771, 1772, 1773, 1774, 1775, 1776,
+        1777, 1778, 1779, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879,
+        1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979 });
+  }
+
+  public void testSpansEnumTermQuery() throws Exception {
+    SpansEnumTermQuery term1 = setq("seventy");
+    checkHits(term1, new int[]
+                             { 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 170,
+        171, 172, 173, 174, 175, 176, 177, 178, 179, 270, 271, 272, 273, 274,
+        275, 276, 277, 278, 279, 370, 371, 372, 373, 374, 375, 376, 377, 378,
+        379, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 570, 571, 572,
+        573, 574, 575, 576, 577, 578, 579, 670, 671, 672, 673, 674, 675, 676,
+        677, 678, 679, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 870,
+        871, 872, 873, 874, 875, 876, 877, 878, 879, 970, 971, 972, 973, 974,
+        975, 976, 977, 978, 979, 1070, 1071, 1072, 1073, 1074, 1075, 1076,
+        1077, 1078, 1079, 1170, 1270, 1370, 1470, 1570, 1670, 1770, 1870, 1970,
+        1171, 1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1271, 1272, 1273,
+        1274, 1275, 1276, 1277, 1278, 1279, 1371, 1372, 1373, 1374, 1375, 1376,
+        1377, 1378, 1379, 1471, 1472, 1473, 1474, 1475, 1476, 1477, 1478, 1479,
+        1571, 1572, 1573, 1574, 1575, 1576, 1577, 1578, 1579, 1671, 1672, 1673,
+        1674, 1675, 1676, 1677, 1678, 1679, 1771, 1772, 1773, 1774, 1775, 1776,
+        1777, 1778, 1779, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879,
+        1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979 });
+  }
+
+  @Test
+  public void testSpanNearUnordered() throws Exception {
+    SpanTermQuery term1 = stq("nine");
+    SpanTermQuery term2 = stq("six");
+    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {term1, term2},
+                                            4, false);
+
+    checkHits(query, new int[]
+      {609, 629, 639, 649, 659, 669, 679, 689, 699, 906, 926, 936, 946, 956,
+              966, 976, 986, 996, 1609, 1629, 1639, 1649, 1659, 1669,
+              1679, 1689, 1699, 1906, 1926, 1936, 1946, 1956, 1966, 1976, 1986,
+              1996});
+  }
+
+  @Test
+  public void testSpansEnumNearUnordered() throws Exception {
+    SpansEnumTermQuery term1 = setq("nine");
+    SpansEnumTermQuery term2 = setq("six");
+    SpansEnumNearQuery query = new SpansEnumNearQuery(new SpansEnumQuery[] {term1, term2},
+                                            4, false);
+
+    checkHits(query, new int[]
+      {609, 629, 639, 649, 659, 669, 679, 689, 699, 906, 926, 936, 946, 956,
+              966, 976, 986, 996, 1609, 1629, 1639, 1649, 1659, 1669,
+              1679, 1689, 1699, 1906, 1926, 1936, 1946, 1956, 1966, 1976, 1986,
+              1996});
+  }
+
+  @Test
+  public void testSpanNearOrdered() throws Exception {
+    SpanTermQuery term1 = stq("nine");
+    SpanTermQuery term2 = stq("six");
+    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {term1, term2},
+                                            4, true);
+    checkHits(query, new int[]
+      {906, 926, 936, 946, 956, 966, 976, 986, 996, 1906, 1926, 1936, 1946, 1956, 1966, 1976, 1986, 1996});
+  }
+
+  @Test
+  public void testSpansEnumNearOrdered() throws Exception {
+    SpansEnumTermQuery term1 = setq("nine");
+    SpansEnumTermQuery term2 = setq("six");
+    SpansEnumNearQuery query = new SpansEnumNearQuery(new SpansEnumQuery[] {term1, term2},
+                                                      4, true);
+    checkHits(query, new int[]
+      {906, 926, 936, 946, 956, 966, 976, 986, 996, 1906, 1926, 1936, 1946, 1956, 1966, 1976, 1986, 1996});
+  }
+
+  @Test
+  public void testSpanNot1() throws Exception {
+    SpanTermQuery term1 = stq("eight");
+    SpanTermQuery term2 = stq("one");
+    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
+                                           4, true); // ordered
+    SpanTermQuery term3 = stq("forty");
+    SpanNotQuery query = new SpanNotQuery(near, term3);
+
+    checkHits(query, new int[]
+      {801, 821, 831, 851, 861, 871, 881, 891, 1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
+
+    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+  
+  @Test
+  public void testSpansEnumNot1() throws Exception {
+    SpansEnumTermQuery term1 = setq("eight");
+    SpansEnumTermQuery term2 = setq("one");
+    SpansEnumNearQuery near = new SpansEnumNearQuery(new SpansEnumQuery[] {term1, term2},
+                                                     4, true); // ordered
+    SpansEnumTermQuery term3 = setq("forty");
+    SpansEnumNotQuery query = new SpansEnumNotQuery(near, term3);
+
+    checkHits(query, new int[]
+      {801, 821, 831, 851, 861, 871, 881, 891, 1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
+
+    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+  
+  @Test
+  public void testSpanNot2() throws Exception {
+    SpanTermQuery term1 = stq("one");
+    SpanTermQuery term2 = stq("hundred");
+    SpanTermQuery term3 = stq("thousand");
+    SpanOrQuery soq = new SpanOrQuery(new SpanQuery[]{term2, term3});
+    SpanNotQuery query = new SpanNotQuery(term1, soq, 2, 1);
+
+    checkHits(query, new int[] {1, 21, 31, 41, 51, 61, 71, 81, 91});
+
+    assertTrue(searcher.explain(query, 81).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 91).getValue() > 0.0f);
+  }
+  
+  @Test
+  public void testSpansEnumNot2() throws Exception {
+    SpansEnumTermQuery term1 = setq("one");
+    SpansEnumTermQuery term2 = setq("hundred");
+    SpansEnumTermQuery term3 = setq("thousand");
+    SpansEnumOrQuery soq = new SpansEnumOrQuery(term2, term3);
+    SpansEnumNotQuery query = new SpansEnumNotQuery(term1, soq, 2, 1);
+
+    checkHits(query, new int[] {1, 21, 31, 41, 51, 61, 71, 81, 91});
+
+    assertTrue(searcher.explain(query, 81).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 91).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testSpanWithMultipleNotSingle() throws Exception {
+    SpanTermQuery term1 = stq("eight");
+    SpanTermQuery term2 = stq("one");
+    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
+                                           4, true); // ordered
+    SpanTermQuery term3 = stq("forty");
+
+    SpanOrQuery or = new SpanOrQuery(term3);
+
+    SpanNotQuery query = new SpanNotQuery(near, or);
+
+    checkHits(query, new int[]
+      {801, 821, 831, 851, 861, 871, 881, 891,
+              1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
+
+    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testSpansEnumWithMultipleNotSingle() throws Exception { 
+    SpansEnumTermQuery term1 = setq("eight");
+    SpansEnumTermQuery term2 = setq("one");
+    SpansEnumNearQuery near = new SpansEnumNearQuery(new SpansEnumQuery[] {term1, term2},
+                                                     4, true); // ordered
+    SpansEnumTermQuery term3 = setq("forty");
+
+    SpansEnumOrQuery or = new SpansEnumOrQuery(term3);
+
+    SpansEnumNotQuery query = new SpansEnumNotQuery(near, or);
+
+    checkHits(query, new int[]
+      {801, 821, 831, 851, 861, 871, 881, 891,
+              1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
+
+    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testSpansWithMultipleNotMany() throws Exception {
+    SpanTermQuery term1 = stq("eight");
+    SpanTermQuery term2 = stq("one");
+    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
+                                           4, true);
+    SpanTermQuery term3 = stq("forty");
+    SpanTermQuery term4 = stq("sixty");
+    SpanTermQuery term5 = stq("eighty");
+
+    SpanOrQuery or = new SpanOrQuery(term3, term4, term5);
+
+    SpanNotQuery query = new SpanNotQuery(near, or);
+
+    checkHits(query, new int[]
+      {801, 821, 831, 851, 871, 891, 1801, 1821, 1831, 1851, 1871, 1891});
+
+    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testSpansEnumWithMultipleNotMany() throws Exception {
+    SpansEnumTermQuery term1 = setq("eight");
+    SpansEnumTermQuery term2 = setq("one");
+    SpansEnumNearQuery near = new SpansEnumNearQuery(new SpansEnumQuery[] {term1, term2},
+                                                     4, true);
+    SpansEnumTermQuery term3 = setq("forty");
+    SpansEnumTermQuery term4 = setq("sixty");
+    SpansEnumTermQuery term5 = setq("eighty");
+
+    SpansEnumOrQuery or = new SpansEnumOrQuery(term3, term4, term5);
+
+    SpansEnumNotQuery query = new SpansEnumNotQuery(near, or);
+
+    checkHits(query, new int[]
+      {801, 821, 831, 851, 871, 891, 1801, 1821, 1831, 1851, 1871, 1891});
+
+    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testNpeInSpanNearWithSpanNot() throws Exception {
+    SpanTermQuery term1 = stq("eight");
+    SpanTermQuery term2 = stq("one");
+    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
+                                           4, true);
+    SpanTermQuery hun = stq("hundred");
+    SpanTermQuery term3 = stq("forty");
+    SpanNearQuery exclude = new SpanNearQuery(new SpanQuery[] {hun, term3},
+                                              1, true);
+    
+    SpanNotQuery query = new SpanNotQuery(near, exclude);
+
+    checkHits(query, new int[]
+      {801, 821, 831, 851, 861, 871, 881, 891,
+              1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
+
+    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testNpeInSpansEnumNearWithSpansEnumNot() throws Exception {
+    SpansEnumTermQuery term1 = setq("eight");
+    SpansEnumTermQuery term2 = setq("one");
+    SpansEnumNearQuery near = new SpansEnumNearQuery(new SpansEnumQuery[] {term1, term2},
+                                                     4, true);
+    SpansEnumTermQuery hun = setq("hundred");
+    SpansEnumTermQuery term3 = setq("forty");
+    SpansEnumNearQuery exclude = new SpansEnumNearQuery(new SpansEnumQuery[] {hun, term3},
+                                                        1, true);
+    
+    SpansEnumNotQuery query = new SpansEnumNotQuery(near, exclude);
+
+    checkHits(query, new int[]
+      {801, 821, 831, 851, 861, 871, 881, 891,
+              1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
+
+    assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testNpeInSpanNearInSpanFirstInSpanNot() throws Exception {
+    int n = 5;
+    SpanTermQuery hun = stq("hundred");
+    SpanTermQuery term40 = stq("forty");
+    SpanTermQuery term40c = (SpanTermQuery)term40.clone();
+
+    SpanFirstQuery include = new SpanFirstQuery(term40, n);
+    SpanNearQuery near = new SpanNearQuery(new SpanQuery[]{hun, term40c},
+                                           n-1, true);
+    SpanFirstQuery exclude = new SpanFirstQuery(near, n-1);
+    SpanNotQuery q = new SpanNotQuery(include, exclude);
+    
+    checkHits(q, new int[]{40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048,
+            1049, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1240, 1241, 1242, 1243, 1244,
+            1245, 1246, 1247, 1248, 1249, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1440, 1441, 1442,
+            1443, 1444, 1445, 1446, 1447, 1448, 1449, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1640,
+            1641, 1642, 1643, 1644, 1645, 1646, 1647,
+            1648, 1649, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1840, 1841, 1842, 1843, 1844, 1845, 1846,
+            1847, 1848, 1849, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949});
+  }
+
+  @Test
+  public void testNpeInSpansEnumNearInSpansEnumFirstInSpansEnumNot() throws Exception {
+    int n = 5;
+    SpansEnumTermQuery hun = setq("hundred");
+    SpansEnumTermQuery term40 = setq("forty");
+    SpansEnumTermQuery term40c = (SpansEnumTermQuery) term40.clone();
+
+    SpansEnumFirstQuery include = new SpansEnumFirstQuery(term40, n);
+    SpansEnumNearQuery near = new SpansEnumNearQuery(new SpansEnumQuery[]{hun, term40c},
+                                                     n-1, true);
+    SpansEnumFirstQuery exclude = new SpansEnumFirstQuery(near, n-1);
+    SpansEnumNotQuery q = new SpansEnumNotQuery(include, exclude);
+    
+    checkHits(q, new int[]{40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048,
+            1049, 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1240, 1241, 1242, 1243, 1244,
+            1245, 1246, 1247, 1248, 1249, 1340, 1341, 1342, 1343, 1344, 1345, 1346, 1347, 1348, 1349, 1440, 1441, 1442,
+            1443, 1444, 1445, 1446, 1447, 1448, 1449, 1540, 1541, 1542, 1543, 1544, 1545, 1546, 1547, 1548, 1549, 1640,
+            1641, 1642, 1643, 1644, 1645, 1646, 1647,
+            1648, 1649, 1740, 1741, 1742, 1743, 1744, 1745, 1746, 1747, 1748, 1749, 1840, 1841, 1842, 1843, 1844, 1845, 1846,
+            1847, 1848, 1849, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949});
+  }
+
+  @Test
+  public void testSpanNotWindowOne() throws Exception {
+    SpanTermQuery term1 = stq("eight");
+    SpanTermQuery term2 = stq("forty");
+    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
+                                           4, true);
+    SpanTermQuery term3 = stq("one");
+    SpanNotQuery query = new SpanNotQuery(near, term3, 1, 1);
+
+    checkHits(query, new int[]
+      {840, 842, 843, 844, 845, 846, 847, 848, 849,
+          1840, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849});
+
+    assertTrue(searcher.explain(query, 840).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 1842).getValue() > 0.0f);
+  }
+  
+  @Test
+  public void testSpansEnumNotWindowOne() throws Exception {
+    SpansEnumTermQuery term1 = setq("eight");
+    SpansEnumTermQuery term2 = setq("forty");
+    SpansEnumNearQuery near = new SpansEnumNearQuery(new SpansEnumQuery[] {term1, term2},
+                                                     4, true);
+    SpansEnumTermQuery term3 = setq("one");
+    SpansEnumNotQuery query = new SpansEnumNotQuery(near, term3, 1, 1);
+
+    checkHits(query, new int[]
+      {840, 842, 843, 844, 845, 846, 847, 848, 849,
+          1840, 1842, 1843, 1844, 1845, 1846, 1847, 1848, 1849});
+
+    assertTrue(searcher.explain(query, 840).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 1842).getValue() > 0.0f);
+  }
+  
+  @Test
+  public void testSpanNotWindowTwoBefore() throws Exception {
+    SpanTermQuery term1 = stq("eight");
+    SpanTermQuery term2 = stq("forty");
+    SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
+                                           4, true);
+    SpanTermQuery term3 = stq("one");
+    SpanNotQuery query = new SpanNotQuery(near, term3, 2, 0);
+
+    checkHits(query, new int[]
+      {840, 841, 842, 843, 844, 845, 846, 847, 848, 849});
+
+    assertTrue(searcher.explain(query, 840).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 849).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testSpansEnumNotWindowTwoBefore() throws Exception {
+    SpansEnumTermQuery term1 = setq("eight");
+    SpansEnumTermQuery term2 = setq("forty");
+    SpansEnumNearQuery near = new SpansEnumNearQuery(new SpansEnumQuery[] {term1, term2},
+                                                     4, true);
+    SpansEnumTermQuery term3 = setq("one");
+    SpansEnumNotQuery query = new SpansEnumNotQuery(near, term3, 2, 0);
+
+    checkHits(query, new int[]
+      {840, 841, 842, 843, 844, 845, 846, 847, 848, 849});
+
+    assertTrue(searcher.explain(query, 840).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 849).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testSpanNotWindowNeg() throws Exception {
+     //test handling of invalid window < 0
+     SpanTermQuery term1 = stq("eight");
+     SpanTermQuery term2 = stq("one");
+     SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
+                                            4, true);
+     SpanTermQuery term3 = stq("forty");
+
+     SpanOrQuery or = new SpanOrQuery(term3);
+
+     SpanNotQuery query = new SpanNotQuery(near, or);
+
+     checkHits(query, new int[]
+       {801, 821, 831, 851, 861, 871, 881, 891,
+               1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
+
+     assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+     assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+  
+  @Test
+  public void testSpansEnumNotWindowNeg() throws Exception {
+     //test handling of invalid window < 0
+     SpansEnumTermQuery term1 = setq("eight");
+     SpansEnumTermQuery term2 = setq("one");
+     SpansEnumNearQuery near = new SpansEnumNearQuery(new SpansEnumQuery[] {term1, term2},
+                                                      4, true);
+     SpansEnumTermQuery term3 = setq("forty");
+
+     SpansEnumOrQuery or = new SpansEnumOrQuery(term3);
+
+     SpansEnumNotQuery query = new SpansEnumNotQuery(near, or);
+
+     checkHits(query, new int[]
+       {801, 821, 831, 851, 861, 871, 881, 891,
+               1801, 1821, 1831, 1851, 1861, 1871, 1881, 1891});
+
+     assertTrue(searcher.explain(query, 801).getValue() > 0.0f);
+     assertTrue(searcher.explain(query, 891).getValue() > 0.0f);
+  }
+  
+  @Test
+  public void testSpanNotWindowDoubleExcludesBefore() throws Exception {
+     //test hitting two excludes before an include
+     SpanTermQuery term1 = stq("forty");
+     SpanTermQuery term2 = stq("two");
+     SpanNearQuery near = new SpanNearQuery(new SpanTermQuery[]{term1, term2}, 2, true);
+     SpanTermQuery exclude = stq("one");
+
+     SpanNotQuery query = new SpanNotQuery(near, exclude, 4, 1);
+
+     checkHits(query, new int[]
+       {42, 242, 342, 442, 542, 642, 742, 842, 942});
+
+     assertTrue(searcher.explain(query, 242).getValue() > 0.0f);
+     assertTrue(searcher.explain(query, 942).getValue() > 0.0f);
+  }
+  
+  @Test
+  public void testSpansEnumNotWindowDoubleExcludesBefore() throws Exception {
+     //test hitting two excludes before an include
+     SpansEnumTermQuery term1 = setq("forty");
+     SpansEnumTermQuery term2 = setq("two");
+     SpansEnumNearQuery near = new SpansEnumNearQuery(new SpansEnumTermQuery[]{term1, term2}, 2, true);
+     SpansEnumTermQuery exclude = setq("one");
+
+     SpansEnumNotQuery query = new SpansEnumNotQuery(near, exclude, 4, 1);
+
+     checkHits(query, new int[]
+       {42, 242, 342, 442, 542, 642, 742, 842, 942});
+
+     assertTrue(searcher.explain(query, 242).getValue() > 0.0f);
+     assertTrue(searcher.explain(query, 942).getValue() > 0.0f);
+  }
+  
+  @Test
+  public void testSpanFirst() throws Exception {
+    SpanTermQuery term1 = stq("five");
+    SpanFirstQuery query = new SpanFirstQuery(term1, 1);
+
+    checkHits(query, new int[]
+      {5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513,
+       514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527,
+       528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541,
+       542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555,
+       556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569,
+       570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583,
+       584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597,
+       598, 599});
+
+    assertTrue(searcher.explain(query, 5).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 599).getValue() > 0.0f);
+
+  }
+  
+  @Test
+  public void testSpansEnumFirst() throws Exception {
+    SpansEnumTermQuery term1 = setq("five");
+    SpansEnumFirstQuery query = new SpansEnumFirstQuery(term1, 1);
+
+    checkHits(query, new int[]
+      {5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513,
+       514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527,
+       528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541,
+       542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555,
+       556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569,
+       570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583,
+       584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597,
+       598, 599});
+
+    assertTrue(searcher.explain(query, 5).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 599).getValue() > 0.0f);
+
+  }
+
+  @Test
+  public void testSpanPositionRange() throws Exception {
+    SpanPositionRangeQuery query;
+    SpanTermQuery term1 = stq("five");
+    query = new SpanPositionRangeQuery(term1, 1, 2);
+    checkHits(query, new int[]
+      {25,35, 45, 55, 65, 75, 85, 95});
+    assertTrue(searcher.explain(query, 25).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 95).getValue() > 0.0f);
+
+    query = new SpanPositionRangeQuery(term1, 0, 1);
+    checkHits(query, new int[]
+      {5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512,
+              513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525,
+              526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538,
+              539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551,
+              552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564,
+              565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577,
+              578, 579, 580, 581, 582, 583, 584,
+              585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597,
+              598, 599});
+
+    query = new SpanPositionRangeQuery(term1, 6, 7);
+    checkHits(query, new int[]{});
+  }
+
+
+  @Test
+  public void testSpansEnumPositionRange() throws Exception {
+    SpansEnumPositionRangeQuery query;
+    SpansEnumTermQuery term1 = setq("five");
+    query = new SpansEnumPositionRangeQuery(term1, 1, 2);
+    checkHits(query, new int[]
+      {25,35, 45, 55, 65, 75, 85, 95});
+    assertTrue(searcher.explain(query, 25).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 95).getValue() > 0.0f);
+
+    query = new SpansEnumPositionRangeQuery(term1, 0, 1);
+    checkHits(query, new int[]
+      {5, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512,
+              513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525,
+              526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538,
+              539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551,
+              552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564,
+              565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577,
+              578, 579, 580, 581, 582, 583, 584,
+              585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597,
+              598, 599});
+
+    query = new SpansEnumPositionRangeQuery(term1, 6, 7);
+    checkHits(query, new int[]{});
+  }
+
+  @Test
+  public void testSpanPayloadCheck() throws Exception {
+    SpanTermQuery term1 = stq("five");
+    BytesRef pay = new BytesRef(("pos: " + 5).getBytes(StandardCharsets.UTF_8));
+    SpanQuery query = new SpanPayloadCheckQuery(term1, Collections.singletonList(pay.bytes));
+    checkHits(query, new int[]
+      {1125, 1135, 1145, 1155, 1165, 1175, 1185, 1195, 1225, 1235, 1245, 1255, 1265, 1275, 1285, 1295, 1325, 1335, 1345, 1355, 1365, 1375, 1385, 1395, 1425, 1435, 1445, 1455, 1465, 1475, 1485, 1495, 1525, 1535, 1545, 1555, 1565, 1575, 1585, 1595, 1625, 1635, 1645, 1655, 1665, 1675, 1685, 1695, 1725, 1735, 1745, 1755, 1765, 1775, 1785, 1795, 1825, 1835, 1845, 1855, 1865, 1875, 1885, 1895, 1925, 1935, 1945, 1955, 1965, 1975, 1985, 1995});
+    assertTrue(searcher.explain(query, 1125).getValue() > 0.0f);
+
+    SpanTermQuery term2 = stq("hundred");
+    SpanNearQuery snq;
+    SpanQuery[] clauses;
+    List<byte[]> list;
+    BytesRef pay2;
+    clauses = new SpanQuery[2];
+    clauses[0] = term1;
+    clauses[1] = term2;
+    snq = new SpanNearQuery(clauses, 0, true);
+    pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
+    pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
+    list = new ArrayList<>();
+    list.add(pay.bytes);
+    list.add(pay2.bytes);
+    query = new SpanNearPayloadCheckQuery(snq, list);
+    checkHits(query, new int[]
+      {500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599});
+    clauses = new SpanQuery[3];
+    clauses[0] = term1;
+    clauses[1] = term2;
+    clauses[2] = stq("five");
+    snq = new SpanNearQuery(clauses, 0, true);
+    pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
+    pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
+    BytesRef pay3 = new BytesRef(("pos: " + 2).getBytes(StandardCharsets.UTF_8));
+    list = new ArrayList<>();
+    list.add(pay.bytes);
+    list.add(pay2.bytes);
+    list.add(pay3.bytes);
+    query = new SpanNearPayloadCheckQuery(snq, list);
+    checkHits(query, new int[]
+      {505});
+  }
+
+  @Test
+  public void testSpansEnumPayloadCheck() throws Exception {
+    SpansEnumTermQuery term1 = setq("five");
+    BytesRef pay = new BytesRef(("pos: " + 5).getBytes(StandardCharsets.UTF_8));
+    SpansEnumQuery query = new SpansEnumPayloadCheckQuery(term1, Collections.singletonList(pay.bytes));
+    checkHits(query, new int[]
+      {1125, 1135, 1145, 1155, 1165, 1175, 1185, 1195, 1225, 1235, 1245, 1255, 1265, 1275, 1285, 1295, 1325, 1335, 1345, 1355, 1365, 1375, 1385, 1395, 1425, 1435, 1445, 1455, 1465, 1475, 1485, 1495, 1525, 1535, 1545, 1555, 1565, 1575, 1585, 1595, 1625, 1635, 1645, 1655, 1665, 1675, 1685, 1695, 1725, 1735, 1745, 1755, 1765, 1775, 1785, 1795, 1825, 1835, 1845, 1855, 1865, 1875, 1885, 1895, 1925, 1935, 1945, 1955, 1965, 1975, 1985, 1995});
+    assertTrue(searcher.explain(query, 1125).getValue() > 0.0f);
+
+    SpansEnumTermQuery term2 = setq("hundred");
+    SpansEnumNearQuery snq;
+    SpansEnumQuery[] clauses;
+    List<byte[]> list;
+    BytesRef pay2;
+    clauses = new SpansEnumQuery[2];
+    clauses[0] = term1;
+    clauses[1] = term2;
+    snq = new SpansEnumNearQuery(clauses, 0, true);
+    pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
+    pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
+    list = new ArrayList<>();
+    list.add(pay.bytes);
+    list.add(pay2.bytes);
+    query = new SpansEnumNearPayloadCheckQuery(snq, list);
+    checkHits(query, new int[]
+      {500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599});
+    clauses = new SpansEnumQuery[3];
+    clauses[0] = term1;
+    clauses[1] = term2;
+    clauses[2] = setq("five");
+    snq = new SpansEnumNearQuery(clauses, 0, true);
+    pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
+    pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
+    BytesRef pay3 = new BytesRef(("pos: " + 2).getBytes(StandardCharsets.UTF_8));
+    list = new ArrayList<>();
+    list.add(pay.bytes);
+    list.add(pay2.bytes);
+    list.add(pay3.bytes);
+    query = new SpansEnumNearPayloadCheckQuery(snq, list);
+    checkHits(query, new int[]
+      {505});
+  }
+
+  public void testComplexSpanChecks() throws Exception {
+    SpanTermQuery one = stq("one");
+    SpanTermQuery thous = stq("thousand");
+    //should be one position in between
+    SpanTermQuery hundred = stq("hundred");
+    SpanTermQuery three = stq("three");
+
+    SpanNearQuery oneThous = new SpanNearQuery(new SpanQuery[]{one, thous}, 0, true);
+    SpanNearQuery hundredThree = new SpanNearQuery(new SpanQuery[]{hundred, three}, 0, true);
+    SpanNearQuery oneThousHunThree = new SpanNearQuery(new SpanQuery[]{oneThous, hundredThree}, 1, true);
+    SpanQuery query;
+    //this one's too small
+    query = new SpanPositionRangeQuery(oneThousHunThree, 1, 2);
+    checkHits(query, new int[]{});
+    //this one's just right
+    query = new SpanPositionRangeQuery(oneThousHunThree, 0, 6);
+    checkHits(query, new int[]{1103, 1203,1303,1403,1503,1603,1703,1803,1903});
+
+    Collection<byte[]> payloads = new ArrayList<>();
+    BytesRef pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
+    BytesRef pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
+    BytesRef pay3 = new BytesRef(("pos: " + 3).getBytes(StandardCharsets.UTF_8));
+    BytesRef pay4 = new BytesRef(("pos: " + 4).getBytes(StandardCharsets.UTF_8));
+    payloads.add(pay.bytes);
+    payloads.add(pay2.bytes);
+    payloads.add(pay3.bytes);
+    payloads.add(pay4.bytes);
+    query = new SpanNearPayloadCheckQuery(oneThousHunThree, payloads);
+    checkHits(query, new int[]{1103, 1203,1303,1403,1503,1603,1703,1803,1903});
+
+  }
+
+  public void testComplexSpansEnumChecks() throws Exception {
+    SpansEnumTermQuery one = setq("one");
+    SpansEnumTermQuery thous = setq("thousand");
+    //should be one position in between
+    SpansEnumTermQuery hundred = setq("hundred");
+    SpansEnumTermQuery three = setq("three");
+
+    SpansEnumNearQuery oneThous = new SpansEnumNearQuery(new SpansEnumQuery[]{one, thous}, 0, true);
+    SpansEnumNearQuery hundredThree = new SpansEnumNearQuery(new SpansEnumQuery[]{hundred, three}, 0, true);
+    SpansEnumNearQuery oneThousHunThree = new SpansEnumNearQuery(new SpansEnumQuery[]{oneThous, hundredThree}, 1, true);
+    SpansEnumQuery query;
+    //this one's too small
+    query = new SpansEnumPositionRangeQuery(oneThousHunThree, 1, 2);
+    checkHits(query, new int[]{});
+    //this one's just right
+    query = new SpansEnumPositionRangeQuery(oneThousHunThree, 0, 6);
+    checkHits(query, new int[]{1103, 1203,1303,1403,1503,1603,1703,1803,1903});
+
+    Collection<byte[]> payloads = new ArrayList<>();
+    BytesRef pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
+    BytesRef pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
+    BytesRef pay3 = new BytesRef(("pos: " + 3).getBytes(StandardCharsets.UTF_8));
+    BytesRef pay4 = new BytesRef(("pos: " + 4).getBytes(StandardCharsets.UTF_8));
+    payloads.add(pay.bytes);
+    payloads.add(pay2.bytes);
+    payloads.add(pay3.bytes);
+    payloads.add(pay4.bytes);
+    query = new SpansEnumNearPayloadCheckQuery(oneThousHunThree, payloads);
+    checkHits(query, new int[]{1103, 1203,1303,1403,1503,1603,1703,1803,1903});
+
+  }
+
+  @Test
+  public void testSpanNear() throws Exception {
+    SpanTermQuery term1 = stq("thirty");
+    SpanTermQuery term2 = stq("three");
+    SpanNearQuery near1 = new SpanNearQuery(new SpanQuery[] {term1, term2},
+                                            0, true);
+    SpanTermQuery term3 = stq("forty");
+    SpanTermQuery term4 = stq("seven");
+    SpanNearQuery near2 = new SpanNearQuery(new SpanQuery[] {term3, term4},
+                                            0, true);
+
+    SpanOrQuery query = new SpanOrQuery(near1, near2);
+
+    checkHits(query, new int[]
+      {33, 47, 133, 147, 233, 247, 333, 347, 433, 447, 533, 547, 633, 647, 733,
+              747, 833, 847, 933, 947, 1033, 1047, 1133, 1147, 1233, 1247, 1333,
+              1347, 1433, 1447, 1533, 1547, 1633, 1647, 1733, 1747, 1833, 1847, 1933, 1947});
+
+    assertTrue(searcher.explain(query, 33).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 947).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testSpansEnumNear() throws Exception {
+    SpansEnumTermQuery term1 = setq("thirty");
+    SpansEnumTermQuery term2 = setq("three");
+    SpansEnumNearQuery near1 = new SpansEnumNearQuery(new SpansEnumQuery[] {term1, term2},
+                                                      0, true);
+    SpansEnumTermQuery term3 = setq("forty");
+    SpansEnumTermQuery term4 = setq("seven");
+    SpansEnumNearQuery near2 = new SpansEnumNearQuery(new SpansEnumQuery[] {term3, term4},
+                                                      0, true);
+
+    SpansEnumOrQuery query = new SpansEnumOrQuery(near1, near2);
+
+    checkHits(query, new int[]
+      {33, 47, 133, 147, 233, 247, 333, 347, 433, 447, 533, 547, 633, 647, 733,
+              747, 833, 847, 933, 947, 1033, 1047, 1133, 1147, 1233, 1247, 1333,
+              1347, 1433, 1447, 1533, 1547, 1633, 1647, 1733, 1747, 1833, 1847, 1933, 1947});
+
+    assertTrue(searcher.explain(query, 33).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 947).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testSpanOr() throws Exception {
+    SpanOrQuery query = new SpanOrQuery(stq("zero"), stq("sixteen"));
+
+    checkHits(query, new int[]{0, 16, 116, 216, 316, 416, 516, 616, 716, 816, 916, 1016, 1116, 1216, 1316, 1416, 1516, 1616, 1716, 1816, 1916});
+
+    assertTrue(searcher.explain(query, 0).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 116).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testSpansEnumOr() throws Exception {
+    SpansEnumOrQuery query = new SpansEnumOrQuery(setq("zero"), setq("sixteen"));
+
+    checkHits(query, new int[]{0, 16, 116, 216, 316, 416, 516, 616, 716, 816, 916, 1016, 1116, 1216, 1316, 1416, 1516, 1616, 1716, 1816, 1916});
+
+    assertTrue(searcher.explain(query, 0).getValue() > 0.0f);
+    assertTrue(searcher.explain(query, 116).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testSpanExactNested() throws Exception {
+    SpanNearQuery near1 = new SpanNearQuery(new SpanQuery[] {stq("three"), stq("hundred")},
+                                            0, true);
+    SpanNearQuery near2 = new SpanNearQuery(new SpanQuery[] {stq("thirty"), stq("three")},
+                                            0, true);
+
+    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {near1, near2},
+                                            0, true);
+
+    checkHits(query, new int[] {333, 1333});
+
+    assertTrue(searcher.explain(query, 333).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testSpansEnumExactNested() throws Exception {
+    SpansEnumNearQuery near1 = new SpansEnumNearQuery(new SpansEnumQuery[] {setq("three"), setq("hundred")},
+                                                      0, true);
+    SpansEnumNearQuery near2 = new SpansEnumNearQuery(new SpansEnumQuery[] {setq("thirty"), setq("three")},
+                                                      0, true);
+
+    SpansEnumNearQuery query = new SpansEnumNearQuery(new SpansEnumQuery[] {near1, near2},
+                                                      0, true);
+
+    checkHits(query, new int[] {333, 1333});
+
+    assertTrue(searcher.explain(query, 333).getValue() > 0.0f);
+  }
+
+  @Test
+  public void testSpanNearOr() throws Exception {
+
+    SpanTermQuery t1 = stq("six");
+    SpanTermQuery t3 = stq("seven");
+    
+    SpanTermQuery t5 = stq("seven");
+    SpanTermQuery t6 = stq("six");
+
+    SpanOrQuery to1 = new SpanOrQuery(t1, t3);
+    SpanOrQuery to2 = new SpanOrQuery(t5, t6);
+    
+    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {to1, to2},
+                                            10, true);
+
+    checkHits(query, new int[]
+      {606, 607, 626, 627, 636, 637, 646, 647, 656, 657, 666, 667, 676, 677,
+              686, 687, 696, 697, 706, 707, 726, 727, 736, 737, 746, 747, 756,
+              757, 766, 767, 776, 777, 786, 787, 796, 797, 1606, 1607, 1626,
+              1627, 1636, 1637, 1646, 1647, 1656, 1657, 1666, 1667, 1676, 1677,
+              1686, 1687, 1696, 1697, 1706, 1707, 1726, 1727, 1736, 1737,
+              1746, 1747, 1756, 1757, 1766, 1767, 1776, 1777, 1786, 1787, 1796,
+              1797});
+  }
+
+  @Test
+  public void testSpansEnumNearOr() throws Exception {
+
+    SpansEnumTermQuery t1 = setq("six");
+    SpansEnumTermQuery t3 = setq("seven");
+    
+    SpansEnumTermQuery t5 = setq("seven");
+    SpansEnumTermQuery t6 = setq("six");
+
+    SpansEnumOrQuery to1 = new SpansEnumOrQuery(t1, t3);
+    SpansEnumOrQuery to2 = new SpansEnumOrQuery(t5, t6);
+    
+    SpansEnumNearQuery query = new SpansEnumNearQuery(new SpansEnumQuery[] {to1, to2},
+                                                      10, true);
+
+    checkHits(query, new int[]
+      {606, 607, 626, 627, 636, 637, 646, 647, 656, 657, 666, 667, 676, 677,
+              686, 687, 696, 697, 706, 707, 726, 727, 736, 737, 746, 747, 756,
+              757, 766, 767, 776, 777, 786, 787, 796, 797, 1606, 1607, 1626,
+              1627, 1636, 1637, 1646, 1647, 1656, 1657, 1666, 1667, 1676, 1677,
+              1686, 1687, 1696, 1697, 1706, 1707, 1726, 1727, 1736, 1737,
+              1746, 1747, 1756, 1757, 1766, 1767, 1776, 1777, 1786, 1787, 1796,
+              1797});
+  }
+
+  @Test
+  public void testSpanComplex1() throws Exception {
+      
+    SpanNearQuery tt1 = new SpanNearQuery(new SpanQuery[] {stq("six"), stq("hundred")}, 0,true);
+    SpanNearQuery tt2 = new SpanNearQuery(new SpanQuery[] {stq("seven"), stq("hundred")}, 0,true);
+    
+
+    SpanOrQuery to1 = new SpanOrQuery(tt1, tt2);
+    SpanOrQuery to2 = new SpanOrQuery(stq("seven"), stq("six"));
+    
+    SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {to1, to2},
+                                            100, true);
+    
+    checkHits(query, new int[]
+      {606, 607, 626, 627, 636, 637, 646, 647, 656, 657, 666, 667, 676, 677, 686, 687, 696,
+              697, 706, 707, 726, 727, 736, 737, 746, 747, 756, 757,
+              766, 767, 776, 777, 786, 787, 796, 797, 1606, 1607, 1626, 1627, 1636, 1637, 1646,
+              1647, 1656, 1657,
+              1666, 1667, 1676, 1677, 1686, 1687, 1696, 1697, 1706, 1707, 1726, 1727, 1736, 1737,
+              1746, 1747, 1756, 1757, 1766, 1767, 1776, 1777, 1786, 1787, 1796, 1797});
+  }
+  
+  @Test
+  public void testSpansEnumComplex1() throws Exception {
+      
+    SpansEnumNearQuery tt1 = new SpansEnumNearQuery(new SpansEnumQuery[] {setq("six"), setq("hundred")}, 0,true);
+    SpansEnumNearQuery tt2 = new SpansEnumNearQuery(new SpansEnumQuery[] {setq("seven"), setq("hundred")}, 0,true);
+    
+
+    SpansEnumOrQuery to1 = new SpansEnumOrQuery(tt1, tt2);
+    SpansEnumOrQuery to2 = new SpansEnumOrQuery(setq("seven"), setq("six"));
+    
+    SpansEnumNearQuery query = new SpansEnumNearQuery(new SpansEnumQuery[] {to1, to2},
+                                            100, true);
+    
+    checkHits(query, new int[]
+      {606, 607, 626, 627, 636, 637, 646, 647, 656, 657, 666, 667, 676, 677, 686, 687, 696,
+              697, 706, 707, 726, 727, 736, 737, 746, 747, 756, 757,
+              766, 767, 776, 777, 786, 787, 796, 797, 1606, 1607, 1626, 1627, 1636, 1637, 1646,
+              1647, 1656, 1657,
+              1666, 1667, 1676, 1677, 1686, 1687, 1696, 1697, 1706, 1707, 1726, 1727, 1736, 1737,
+              1746, 1747, 1756, 1757, 1766, 1767, 1776, 1777, 1786, 1787, 1796, 1797});
+  }
+  
+  @Test
+  public void testSpansSkipTo() throws Exception {
+    SpanTermQuery t1 = stq("seventy");
+    SpanTermQuery t2 = stq("seventy");
+    Spans s1 = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), t1);
+    Spans s2 = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), t2);
+
+    assertTrue(s1.next());
+    assertTrue(s2.next());
+
+    boolean hasMore = true;
+
+    do {
+      hasMore = skipToAccordingToJavaDocs(s1, s1.doc() + 1);
+      assertEquals(hasMore, s2.skipTo(s2.doc() + 1));
+      assertEquals(s1.doc(), s2.doc());
+    } while (hasMore);
+  }
+
+  /** Skips to the first match beyond the current, whose document number is
+   * greater than or equal to <i>target</i>. <p>Returns true iff there is such
+   * a match.  <p>Behaves as if written: <pre>
+   *   boolean skipTo(int target) {
+   *     do {
+   *       if (!next())
+   *       return false;
+   *     } while (target &gt; doc());
+   *     return true;
+   *   }
+   * </pre>
+   */
+  private boolean skipToAccordingToJavaDocs(Spans s, int target)
+      throws Exception {
+    do {
+      if (!s.next())
+        return false;
+    } while (target > s.doc());
+    return true;
+
+  }
+  
+  @Test
+  public void testSpanRequired5() throws Exception {
+    BooleanQuery bq = new BooleanQuery();
+    addRequiredClause(bq, stq("one"));
+    addRequiredClause(bq, stq("four"));
+    addRequiredClause(bq, stq("five"));
+    addRequiredClause(bq, stq("twenty"));
+    addRequiredClause(bq, stq("hundred"));
+    checkHits(bq, new int[] {1425, 1524});
+  }
+
+  @Test
+  public void testSpansEnumRequired5() throws Exception {
+    BooleanQuery bq = new BooleanQuery();
+    addRequiredClause(bq, setq("one"));
+    addRequiredClause(bq, setq("four"));
+    addRequiredClause(bq, setq("five"));
+    addRequiredClause(bq, setq("twenty"));
+    addRequiredClause(bq, setq("hundred"));
+    checkHits(bq, new int[] {1425, 1524});
+  }
+
+
+  private void checkHits(Query query, int[] results) throws IOException {
+    CheckHits.checkHits(random(), query, "field", searcher, results);
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanations.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanations.java
index aab5a9e..4b54865 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanations.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanExplanations.java
@@ -46,6 +46,27 @@ public class TestSpanExplanations extends BaseExplanationTestCase {
     qtest(q, new int[] {2,3});
   }
 
+  /* simple SpansEnumTermQueries */
+  
+  public void testSET1() throws Exception {
+    SpansEnumQuery q = set("w1");
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testSET2() throws Exception {
+    SpansEnumQuery q = set("w1");
+    q.setBoost(1000);
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testSET4() throws Exception {
+    SpansEnumQuery q = set("xx");
+    qtest(q, new int[] {2,3});
+  }
+  public void testSET5() throws Exception {
+    SpansEnumQuery q = set("xx");
+    q.setBoost(1000);
+    qtest(q, new int[] {2,3});
+  }
+
   /* some SpanFirstQueries */
   
   public void testSF1() throws Exception {
@@ -71,6 +92,31 @@ public class TestSpanExplanations extends BaseExplanationTestCase {
     qtest(q, new int[] {2});
   }
   
+  /* some SpansEnumFirstQueries */
+  
+  public void testSEF1() throws Exception {
+    SpansEnumQuery q = sef(("w1"),1);
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testSEF2() throws Exception {
+    SpansEnumQuery q = sef(("w1"),1);
+    q.setBoost(1000);
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testSEF4() throws Exception {
+    SpansEnumQuery q = sef(("xx"),2);
+    qtest(q, new int[] {2});
+  }
+  public void testSEF5() throws Exception {
+    SpansEnumQuery q = sef(("yy"),2);
+    qtest(q, new int[] { });
+  }
+  public void testSEF6() throws Exception {
+    SpansEnumQuery q = sef(("yy"),4);
+    q.setBoost(1000);
+    qtest(q, new int[] {2});
+  }
+  
   /* some SpanOrQueries */
 
   public void testSO1() throws Exception {
@@ -90,8 +136,25 @@ public class TestSpanExplanations extends BaseExplanationTestCase {
     qtest(q, new int[] {0,2,3});
   }
 
-  
-  
+  /* some SpansEnumOrQueries */
+
+  public void testSEO1() throws Exception {
+    SpansEnumQuery q = seor("w1","QQ");
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testSEO2() throws Exception {
+    SpansEnumQuery q = seor("w1","w3","zz");
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testSEO3() throws Exception {
+    SpansEnumQuery q = seor("w5","QQ","yy");
+    qtest(q, new int[] {0,2,3});
+  }
+  public void testSEO4() throws Exception {
+    SpansEnumQuery q = seor("w5","QQ","yy");
+    qtest(q, new int[] {0,2,3});
+  }
+
   /* some SpanNearQueries */
   
   public void testSNear1() throws Exception {
@@ -140,6 +203,54 @@ public class TestSpanExplanations extends BaseExplanationTestCase {
     qtest(q, new int[] {0,1});
   }
 
+  /* some SpansEnumNearQueries */
+
+  public void testSENear1() throws Exception {
+    SpansEnumQuery q = senear("w1","QQ",100,true);
+    qtest(q, new int[] {});
+  }
+  public void testSENear2() throws Exception {
+    SpansEnumQuery q = senear("w1","xx",100,true);
+    qtest(q, new int[] {2,3});
+  }
+  public void testSENear3() throws Exception {
+    SpansEnumQuery q = senear("w1","xx",0,true);
+    qtest(q, new int[] {2});
+  }
+  public void testSENear4() throws Exception {
+    SpansEnumQuery q = senear("w1","xx",1,true);
+    qtest(q, new int[] {2,3});
+  }
+
+  public void testSENear5() throws Exception {
+    SpansEnumQuery q = senear("xx","w1",0,false);
+    qtest(q, new int[] {2});
+  }
+
+  public void testSENear6() throws Exception {
+    SpansEnumQuery q = senear("w1","w2","QQ",100,true);
+    qtest(q, new int[] {});
+  }
+  public void testSENear7() throws Exception {
+    SpansEnumQuery q = senear("w1","xx","w2",100,true);
+    qtest(q, new int[] {2,3});
+  }
+  public void testSENear8() throws Exception {
+    SpansEnumQuery q = senear("w1","xx","w2",0,true);
+    qtest(q, new int[] {2});
+  }
+  public void testSENear9() throws Exception {
+    SpansEnumQuery q = senear("w1","xx","w2",1,true);
+    qtest(q, new int[] {2,3});
+  }
+  public void testSENear10() throws Exception {
+    SpansEnumQuery q = senear("xx","w1","w2",0,false);
+    qtest(q, new int[] {2});
+  }
+  public void testSENear11() throws Exception {
+    SpansEnumQuery q = senear("w1","w2","w3",1,true);
+    qtest(q, new int[] {0,1});
+  }
   
   /* some SpanNotQueries */
 
@@ -174,4 +285,39 @@ public class TestSpanExplanations extends BaseExplanationTestCase {
     qtest(q, new int[] {0,1,3});
   }
 
+  /* some SpansEnumNotQueries */
+
+  public void testSENot1() throws Exception {
+    SpansEnumQuery q = senot(sef("w1",10),set("QQ"));
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testSENot2() throws Exception {
+    SpansEnumQuery q = senot(sef("w1",10),set("QQ"));
+    q.setBoost(1000);
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testSENot4() throws Exception {
+    SpansEnumQuery q = senot(sef("w1",10),set("xx"));
+    qtest(q, new int[] {0,1,2,3});
+  }
+  public void testSENot5() throws Exception {
+    SpansEnumQuery q = senot(sef("w1",10),set("xx"));
+    q.setBoost(1000);
+    qtest(q, new int[] {0,1,2,3});
+  }
+
+  public void testSENot7() throws Exception {
+    SpansEnumQuery f = senear("w1","w3",10,true);
+    f.setBoost(1000);
+    SpansEnumQuery q = senot(f, set("xx"));
+    qtest(q, new int[] {0,1,3});
+  }
+
+  public void testSENot10() throws Exception {
+    SpansEnumQuery t = set("xx");
+    t.setBoost(10000);
+    SpansEnumQuery q = senot(senear("w1","w3",10,true), t);
+    qtest(q, new int[] {0,1,3});
+  }
+
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java
index 3567285..6bc06e9 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java
@@ -63,4 +63,35 @@ public class TestSpanFirstQuery extends LuceneTestCase {
     reader.close();
     dir.close();
   }
+  public void testStartPositionsSpansEnum() throws Exception {
+    Directory dir = newDirectory();
+    
+    // mimic StopAnalyzer
+    CharacterRunAutomaton stopSet = new CharacterRunAutomaton(new RegExp("the|a|of").toAutomaton());
+    Analyzer analyzer = new MockAnalyzer(random(), MockTokenizer.SIMPLE, true, stopSet);
+    
+    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, analyzer);
+    Document doc = new Document();
+    doc.add(newTextField("field", "the quick brown fox", Field.Store.NO));
+    writer.addDocument(doc);
+    Document doc2 = new Document();
+    doc2.add(newTextField("field", "quick brown fox", Field.Store.NO));
+    writer.addDocument(doc2);
+    
+    IndexReader reader = writer.getReader();
+    IndexSearcher searcher = newSearcher(reader);
+    
+    // user queries on "starts-with quick"
+    SpansEnumQuery sefq = new SpansEnumFirstQuery(new SpansEnumTermQuery(new Term("field", "quick")), 1);
+    assertEquals(1, searcher.search(sefq, 10).totalHits);
+    
+    // user queries on "starts-with the quick"
+    SpansEnumQuery include = new SpansEnumFirstQuery(new SpansEnumTermQuery(new Term("field", "quick")), 2);
+    sefq = new SpansEnumNotQuery(include, sefq);
+    assertEquals(1, searcher.search(sefq, 10).totalHits);
+    
+    writer.close();
+    reader.close();
+    dir.close();
+  }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanMultiTermQueryWrapper.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanMultiTermQueryWrapper.java
index c5023c7..9972d10 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanMultiTermQueryWrapper.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanMultiTermQueryWrapper.java
@@ -32,6 +32,7 @@ import org.apache.lucene.util.LuceneTestCase;
 
 /**
  * Tests for {@link SpanMultiTermQueryWrapper}, wrapping a few MultiTermQueries.
+ * Tests for {@link SpansEnumMultiTermQueryWrapper}, wrapping a few MultiTermQueries.
  */
 public class TestSpanMultiTermQueryWrapper extends LuceneTestCase {
   private Directory directory;
@@ -73,6 +74,14 @@ public class TestSpanMultiTermQueryWrapper extends LuceneTestCase {
     assertEquals(1, searcher.search(sfq, 10).totalHits);
   }
   
+  public void testWildcardSpansEnum() throws Exception {
+    WildcardQuery wq = new WildcardQuery(new Term("field", "bro?n"));
+    SpansEnumQuery swq = new SpansEnumMultiTermQueryWrapper<>(wq);
+    // will only match quick brown fox
+    SpansEnumFirstQuery sfq = new SpansEnumFirstQuery(swq, 2);
+    assertEquals(1, searcher.search(sfq, 10).totalHits);
+  }
+  
   public void testPrefix() throws Exception {
     WildcardQuery wq = new WildcardQuery(new Term("field", "extrem*"));
     SpanQuery swq = new SpanMultiTermQueryWrapper<>(wq);
@@ -81,7 +90,15 @@ public class TestSpanMultiTermQueryWrapper extends LuceneTestCase {
     assertEquals(1, searcher.search(sfq, 10).totalHits);
   }
   
-  public void testFuzzy() throws Exception {
+  public void testPrefixSpansEnum() throws Exception {
+    WildcardQuery wq = new WildcardQuery(new Term("field", "extrem*"));
+    SpansEnumQuery swq = new SpansEnumMultiTermQueryWrapper<>(wq);
+    // will only match "jumps over extremely very lazy broxn dog"
+    SpansEnumFirstQuery sfq = new SpansEnumFirstQuery(swq, 3);
+    assertEquals(1, searcher.search(sfq, 10).totalHits);
+  }
+  
+  public void testFuzzy1() throws Exception {
     FuzzyQuery fq = new FuzzyQuery(new Term("field", "broan"));
     SpanQuery sfq = new SpanMultiTermQueryWrapper<>(fq);
     // will not match quick brown fox
@@ -89,6 +106,14 @@ public class TestSpanMultiTermQueryWrapper extends LuceneTestCase {
     assertEquals(2, searcher.search(sprq, 10).totalHits);
   }
   
+  public void testFuzzy1SpansEnum() throws Exception {
+    FuzzyQuery fq = new FuzzyQuery(new Term("field", "broan"));
+    SpansEnumQuery sfq = new SpansEnumMultiTermQueryWrapper<>(fq);
+    // will not match quick brown fox
+    SpansEnumPositionRangeQuery sprq = new SpansEnumPositionRangeQuery(sfq, 3, 6);
+    assertEquals(2, searcher.search(sprq, 10).totalHits);
+  }
+  
   public void testFuzzy2() throws Exception {
     // maximum of 1 term expansion
     FuzzyQuery fq = new FuzzyQuery(new Term("field", "broan"), 1, 0, 1, false);
@@ -97,6 +122,16 @@ public class TestSpanMultiTermQueryWrapper extends LuceneTestCase {
     SpanPositionRangeQuery sprq = new SpanPositionRangeQuery(sfq, 0, 100);
     assertEquals(1, searcher.search(sprq, 10).totalHits);
   }
+
+  public void testFuzzy2SpansEnum() throws Exception {
+    // maximum of 1 term expansion
+    FuzzyQuery fq = new FuzzyQuery(new Term("field", "broan"), 1, 0, 1, false);
+    SpansEnumQuery sfq = new SpansEnumMultiTermQueryWrapper<>(fq);
+    // will only match jumps over lazy broun dog
+    SpansEnumPositionRangeQuery sprq = new SpansEnumPositionRangeQuery(sfq, 0, 100);
+    assertEquals(1, searcher.search(sprq, 10).totalHits);
+  }
+
   public void testNoSuchMultiTermsInNear() throws Exception {
     //test to make sure non existent multiterms aren't throwing null pointer exceptions  
     FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
@@ -133,6 +168,42 @@ public class TestSpanMultiTermQueryWrapper extends LuceneTestCase {
 
   }
   
+  public void testNoSuchMultiTermsInNearSpansEnum() throws Exception {
+    //test to make sure non existent multiterms aren't throwing null pointer exceptions  
+    FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
+    SpansEnumQuery spanNoSuch = new SpansEnumMultiTermQueryWrapper<>(fuzzyNoSuch);
+    SpansEnumQuery term = new SpansEnumTermQuery(new Term("field", "brown"));
+    SpansEnumQuery near = new SpansEnumNearQuery(new SpansEnumQuery[]{term, spanNoSuch}, 1, true);
+    assertEquals(0, searcher.search(near, 10).totalHits);
+    //flip order
+    near = new SpansEnumNearQuery(new SpansEnumQuery[]{spanNoSuch, term}, 1, true);
+    assertEquals(0, searcher.search(near, 10).totalHits);
+    
+    WildcardQuery wcNoSuch = new WildcardQuery(new Term("field", "noSuch*"));
+    SpansEnumQuery spanWCNoSuch = new SpansEnumMultiTermQueryWrapper<>(wcNoSuch);
+    near = new SpansEnumNearQuery(new SpansEnumQuery[]{term, spanWCNoSuch}, 1, true);
+    assertEquals(0, searcher.search(near, 10).totalHits);
+  
+    RegexpQuery rgxNoSuch = new RegexpQuery(new Term("field", "noSuch"));
+    SpansEnumQuery spanRgxNoSuch = new SpansEnumMultiTermQueryWrapper<>(rgxNoSuch);
+    near = new SpansEnumNearQuery(new SpansEnumQuery[]{term, spanRgxNoSuch}, 1, true);
+    assertEquals(0, searcher.search(near, 10).totalHits);
+    
+    PrefixQuery prfxNoSuch = new PrefixQuery(new Term("field", "noSuch"));
+    SpansEnumQuery spanPrfxNoSuch = new SpansEnumMultiTermQueryWrapper<>(prfxNoSuch);
+    near = new SpansEnumNearQuery(new SpansEnumQuery[]{term, spanPrfxNoSuch}, 1, true);
+    assertEquals(0, searcher.search(near, 10).totalHits);
+
+    //test single noSuch
+    near = new SpansEnumNearQuery(new SpansEnumQuery[]{spanPrfxNoSuch}, 1, true);
+    assertEquals(0, searcher.search(near, 10).totalHits);
+    
+    //test double noSuch
+    near = new SpansEnumNearQuery(new SpansEnumQuery[]{spanPrfxNoSuch, spanPrfxNoSuch}, 1, true);
+    assertEquals(0, searcher.search(near, 10).totalHits);
+
+  }
+
   public void testNoSuchMultiTermsInNotNear() throws Exception {
     //test to make sure non existent multiterms aren't throwing non-matching field exceptions  
     FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
@@ -163,9 +234,40 @@ public class TestSpanMultiTermQueryWrapper extends LuceneTestCase {
     SpanQuery spanPrfxNoSuch = new SpanMultiTermQueryWrapper<>(prfxNoSuch);
     notNear = new SpanNotQuery(term, spanPrfxNoSuch, 1, 1);
     assertEquals(1, searcher.search(notNear, 10).totalHits);
-    
   }
   
+  public void testNoSuchMultiTermsInSpansEnumNotNear() throws Exception {
+    //test to make sure non existent multiterms aren't throwing non-matching field exceptions  
+    FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
+    SpansEnumQuery spanNoSuch = new SpansEnumMultiTermQueryWrapper<>(fuzzyNoSuch);
+    SpansEnumQuery term = new SpansEnumTermQuery(new Term("field", "brown"));
+    SpansEnumNotQuery notNear = new SpansEnumNotQuery(term, spanNoSuch, 0,0);
+    assertEquals(1, searcher.search(notNear, 10).totalHits);
+
+    //flip
+    notNear = new SpansEnumNotQuery(spanNoSuch, term, 0,0);
+    assertEquals(0, searcher.search(notNear, 10).totalHits);
+    
+    //both noSuch
+    notNear = new SpansEnumNotQuery(spanNoSuch, spanNoSuch, 0,0);
+    assertEquals(0, searcher.search(notNear, 10).totalHits);
+
+    WildcardQuery wcNoSuch = new WildcardQuery(new Term("field", "noSuch*"));
+    SpansEnumQuery spanWCNoSuch = new SpansEnumMultiTermQueryWrapper<>(wcNoSuch);
+    notNear = new SpansEnumNotQuery(term, spanWCNoSuch, 0,0);
+    assertEquals(1, searcher.search(notNear, 10).totalHits);
+  
+    RegexpQuery rgxNoSuch = new RegexpQuery(new Term("field", "noSuch"));
+    SpansEnumQuery spanRgxNoSuch = new SpansEnumMultiTermQueryWrapper<>(rgxNoSuch);
+    notNear = new SpansEnumNotQuery(term, spanRgxNoSuch, 1, 1);
+    assertEquals(1, searcher.search(notNear, 10).totalHits);
+    
+    PrefixQuery prfxNoSuch = new PrefixQuery(new Term("field", "noSuch"));
+    SpansEnumQuery spanPrfxNoSuch = new SpansEnumMultiTermQueryWrapper<>(prfxNoSuch);
+    notNear = new SpansEnumNotQuery(term, spanPrfxNoSuch, 1, 1);
+    assertEquals(1, searcher.search(notNear, 10).totalHits);
+  }
+
   public void testNoSuchMultiTermsInOr() throws Exception {
     //test to make sure non existent multiterms aren't throwing null pointer exceptions  
     FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
@@ -199,9 +301,42 @@ public class TestSpanMultiTermQueryWrapper extends LuceneTestCase {
     
     near = new SpanOrQuery(new SpanQuery[]{spanPrfxNoSuch, spanPrfxNoSuch});
     assertEquals(0, searcher.search(near, 10).totalHits);
-
   }
   
+  public void testNoSuchMultiTermsInSpansEnumOr() throws Exception {
+    //test to make sure non existent multiterms aren't throwing null pointer exceptions  
+    FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
+    SpansEnumQuery spanNoSuch = new SpansEnumMultiTermQueryWrapper<>(fuzzyNoSuch);
+    SpansEnumQuery term = new SpansEnumTermQuery(new Term("field", "brown"));
+    SpansEnumOrQuery near = new SpansEnumOrQuery(new SpansEnumQuery[]{term, spanNoSuch});
+    assertEquals(1, searcher.search(near, 10).totalHits);
+    
+    //flip
+    near = new SpansEnumOrQuery(new SpansEnumQuery[]{spanNoSuch, term});
+    assertEquals(1, searcher.search(near, 10).totalHits);
+
+    
+    WildcardQuery wcNoSuch = new WildcardQuery(new Term("field", "noSuch*"));
+    SpansEnumQuery spanWCNoSuch = new SpansEnumMultiTermQueryWrapper<>(wcNoSuch);
+    near = new SpansEnumOrQuery(new SpansEnumQuery[]{term, spanWCNoSuch});
+    assertEquals(1, searcher.search(near, 10).totalHits);
+  
+    RegexpQuery rgxNoSuch = new RegexpQuery(new Term("field", "noSuch"));
+    SpansEnumQuery spanRgxNoSuch = new SpansEnumMultiTermQueryWrapper<>(rgxNoSuch);
+    near = new SpansEnumOrQuery(new SpansEnumQuery[]{term, spanRgxNoSuch});
+    assertEquals(1, searcher.search(near, 10).totalHits);
+    
+    PrefixQuery prfxNoSuch = new PrefixQuery(new Term("field", "noSuch"));
+    SpansEnumQuery spanPrfxNoSuch = new SpansEnumMultiTermQueryWrapper<>(prfxNoSuch);
+    near = new SpansEnumOrQuery(new SpansEnumQuery[]{term, spanPrfxNoSuch});
+    assertEquals(1, searcher.search(near, 10).totalHits);
+    
+    near = new SpansEnumOrQuery(new SpansEnumQuery[]{spanPrfxNoSuch});
+    assertEquals(0, searcher.search(near, 10).totalHits);
+    
+    near = new SpansEnumOrQuery(new SpansEnumQuery[]{spanPrfxNoSuch, spanPrfxNoSuch});
+    assertEquals(0, searcher.search(near, 10).totalHits);
+  }
   
   public void testNoSuchMultiTermsInSpanFirst() throws Exception {
     //this hasn't been a problem  
@@ -226,4 +361,28 @@ public class TestSpanMultiTermQueryWrapper extends LuceneTestCase {
     spanFirst = new SpanFirstQuery(spanPrfxNoSuch, 10);
     assertEquals(0, searcher.search(spanFirst, 10).totalHits);
   }
+  
+  public void testNoSuchMultiTermsInSpansEnumFirst() throws Exception {
+    //this hasn't been a problem  
+    FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
+    SpansEnumQuery spanNoSuch = new SpansEnumMultiTermQueryWrapper<>(fuzzyNoSuch);
+    SpansEnumQuery spanFirst = new SpansEnumFirstQuery(spanNoSuch, 10);
+ 
+    assertEquals(0, searcher.search(spanFirst, 10).totalHits);
+    
+    WildcardQuery wcNoSuch = new WildcardQuery(new Term("field", "noSuch*"));
+    SpansEnumQuery spanWCNoSuch = new SpansEnumMultiTermQueryWrapper<>(wcNoSuch);
+    spanFirst = new SpansEnumFirstQuery(spanWCNoSuch, 10);
+    assertEquals(0, searcher.search(spanFirst, 10).totalHits);
+  
+    RegexpQuery rgxNoSuch = new RegexpQuery(new Term("field", "noSuch"));
+    SpansEnumQuery spanRgxNoSuch = new SpansEnumMultiTermQueryWrapper<>(rgxNoSuch);
+    spanFirst = new SpansEnumFirstQuery(spanRgxNoSuch, 10);
+    assertEquals(0, searcher.search(spanFirst, 10).totalHits);
+    
+    PrefixQuery prfxNoSuch = new PrefixQuery(new Term("field", "noSuch"));
+    SpansEnumQuery spanPrfxNoSuch = new SpansEnumMultiTermQueryWrapper<>(prfxNoSuch);
+    spanFirst = new SpansEnumFirstQuery(spanPrfxNoSuch, 10);
+    assertEquals(0, searcher.search(spanFirst, 10).totalHits);
+  }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java
index 94c5db3..938477e 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java
@@ -28,9 +28,9 @@ import org.apache.lucene.search.TermQuery;
  * Basic equivalence tests for span queries
  */
 public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
-  
+
   // TODO: we could go a little crazy for a lot of these,
-  // but these are just simple minimal cases in case something 
+  // but these are just simple minimal cases in case something
   // goes horribly wrong. Put more intense tests elsewhere.
 
   /** SpanTermQuery(A) = TermQuery(A) */
@@ -38,7 +38,13 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     Term t1 = randomTerm();
     assertSameSet(new TermQuery(t1), new SpanTermQuery(t1));
   }
-  
+
+  /** SpansEnumTermQuery(A) = TermQuery(A) */
+  public void testSpansEnumTermVersusTerm() throws Exception {
+    Term t1 = randomTerm();
+    assertSameSet(new TermQuery(t1), new SpansEnumTermQuery(t1));
+  }
+
   /** SpanOrQuery(A, B) = (A B) */
   public void testSpanOrVersusBoolean() throws Exception {
     Term t1 = randomTerm();
@@ -49,20 +55,44 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     SpanOrQuery q2 = new SpanOrQuery(new SpanTermQuery(t1), new SpanTermQuery(t2));
     assertSameSet(q1, q2);
   }
-  
+
+  /** SpansEnumOrQuery(A, B) = (A B) */
+  public void testSpansEnumOrVersusBoolean() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    BooleanQuery q1 = new BooleanQuery();
+    q1.add(new TermQuery(t1), Occur.SHOULD);
+    q1.add(new TermQuery(t2), Occur.SHOULD);
+    SpansEnumOrQuery q2 = new SpansEnumOrQuery(new SpansEnumTermQuery(t1), new SpansEnumTermQuery(t2));
+    assertSameSet(q1, q2);
+  }
+
   /** SpanNotQuery(A, B) ⊆ SpanTermQuery(A) */
   public void testSpanNotVersusSpanTerm() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     assertSubsetOf(new SpanNotQuery(new SpanTermQuery(t1), new SpanTermQuery(t2)), new SpanTermQuery(t1));
   }
-  
+
+  /** SpansEnumNotQuery(A, B) ⊆ SpansEnumTermQuery(A) */
+  public void testSpansEnumNotVersusSpanTerm() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    assertSubsetOf(new SpansEnumNotQuery(new SpansEnumTermQuery(t1), new SpansEnumTermQuery(t2)), new SpansEnumTermQuery(t1));
+  }
+
   /** SpanFirstQuery(A, 10) ⊆ SpanTermQuery(A) */
   public void testSpanFirstVersusSpanTerm() throws Exception {
     Term t1 = randomTerm();
     assertSubsetOf(new SpanFirstQuery(new SpanTermQuery(t1), 10), new SpanTermQuery(t1));
   }
-  
+
+  /** SpansEnumFirstQuery(A, 10) ⊆ SpansEnumTermQuery(A) */
+  public void testSpansEnumFirstVersusSpansEnumTerm() throws Exception {
+    Term t1 = randomTerm();
+    assertSubsetOf(new SpansEnumFirstQuery(new SpansEnumTermQuery(t1), 10), new SpansEnumTermQuery(t1));
+  }
+
   /** SpanNearQuery([A, B], 0, true) = "A B" */
   public void testSpanNearVersusPhrase() throws Exception {
     Term t1 = randomTerm();
@@ -74,7 +104,19 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     q2.add(t2);
     assertSameSet(q1, q2);
   }
-  
+
+  /** SpanNearQuery([A, B], 0, true) = "A B" */
+  public void testSpansEnumNearVersusPhrase() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpansEnumQuery subquery[] = new SpansEnumQuery[] { new SpansEnumTermQuery(t1), new SpansEnumTermQuery(t2) };
+    SpansEnumNearQuery q1 = new SpansEnumNearQuery(subquery, 0, true);
+    PhraseQuery q2 = new PhraseQuery();
+    q2.add(t1);
+    q2.add(t2);
+    assertSameSet(q1, q2);
+  }
+
   /** SpanNearQuery([A, B], ∞, false) = +A +B */
   public void testSpanNearVersusBooleanAnd() throws Exception {
     Term t1 = randomTerm();
@@ -86,7 +128,19 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     q2.add(new TermQuery(t2), Occur.MUST);
     assertSameSet(q1, q2);
   }
-  
+
+  /** SpansEnumNearQuery([A, B], ∞, false) = +A +B */
+  public void testSpansEnumNearVersusBooleanAnd() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpansEnumQuery subquery[] = new SpansEnumQuery[] { new SpansEnumTermQuery(t1), new SpansEnumTermQuery(t2) };
+    SpansEnumNearQuery q1 = new SpansEnumNearQuery(subquery, Integer.MAX_VALUE, false);
+    BooleanQuery q2 = new BooleanQuery();
+    q2.add(new TermQuery(t1), Occur.MUST);
+    q2.add(new TermQuery(t2), Occur.MUST);
+    assertSameSet(q1, q2);
+  }
+
   /** SpanNearQuery([A B], 0, false) ⊆ SpanNearQuery([A B], 1, false) */
   public void testSpanNearVersusSloppySpanNear() throws Exception {
     Term t1 = randomTerm();
@@ -96,7 +150,17 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     SpanNearQuery q2 = new SpanNearQuery(subquery, 1, false);
     assertSubsetOf(q1, q2);
   }
-  
+
+  /** SpansEnumNearQuery([A B], 0, false) ⊆ SpansEnumNearQuery([A B], 1, false) */
+  public void testSpansEnumNearVersusSloppySpansEnumNear() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpansEnumQuery subquery[] = new SpansEnumQuery[] { new SpansEnumTermQuery(t1), new SpansEnumTermQuery(t2) };
+    SpansEnumNearQuery q1 = new SpansEnumNearQuery(subquery, 0, false);
+    SpansEnumNearQuery q2 = new SpansEnumNearQuery(subquery, 1, false);
+    assertSubsetOf(q1, q2);
+  }
+
   /** SpanNearQuery([A B], 3, true) ⊆ SpanNearQuery([A B], 3, false) */
   public void testSpanNearInOrderVersusOutOfOrder() throws Exception {
     Term t1 = randomTerm();
@@ -106,4 +170,15 @@ public class TestSpanSearchEquivalence extends SearchEquivalenceTestBase {
     SpanNearQuery q2 = new SpanNearQuery(subquery, 3, false);
     assertSubsetOf(q1, q2);
   }
+
+  /** SpanNearQuery([A B], 3, true) ⊆ SpanNearQuery([A B], 3, false) */
+  public void testSpansEnumNearInOrderVersusOutOfOrder() throws Exception {
+    Term t1 = randomTerm();
+    Term t2 = randomTerm();
+    SpansEnumQuery subquery[] = new SpansEnumQuery[] { new SpansEnumTermQuery(t1), new SpansEnumTermQuery(t2) };
+    SpansEnumNearQuery q1 = new SpansEnumNearQuery(subquery, 3, true);
+    SpansEnumNearQuery q2 = new SpansEnumNearQuery(subquery, 3, false);
+    assertSubsetOf(q1, q2);
+  }
+
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
index 577679d..5c1dc87 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpans.java
@@ -20,7 +20,12 @@ package org.apache.lucene.search.spans;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
+
+import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.index.SlowCompositeReaderWrapper;
+
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.IndexReader;
@@ -41,8 +46,14 @@ import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 
+import org.apache.lucene.util.Bits;
+
 import java.io.IOException;
 import java.util.List;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.HashMap;
+
 
 public class TestSpans extends LuceneTestCase {
   private IndexSearcher searcher;
@@ -73,6 +84,36 @@ public class TestSpans extends LuceneTestCase {
     super.tearDown();
   }
   
+  public static Spans getSpansFromQuery(SpanQuery spanQuery, IndexReader reader) throws IOException {
+    LeafReader lr = SlowCompositeReaderWrapper.wrap(reader); // slow, but ok for testing
+    LeafReaderContext lrContext = lr.getContext();
+    Query rewrittenQuery = spanQuery.rewrite(lr); // get the term contexts so getSpans can be called directly
+    HashSet<Term> termSet = new HashSet<>();
+    rewrittenQuery.extractTerms(termSet);
+    Map<Term,TermContext> termContexts = new HashMap<>();
+    for (Term term: termSet) {
+      TermContext termContext = TermContext.build(lrContext, term);
+      termContexts.put(term, termContext);
+    }
+    Spans actSpans = spanQuery.getSpans(lrContext, new Bits.MatchAllBits(lr.numDocs()), termContexts);
+    return actSpans;
+  }
+
+  public static SpansEnum getSpansEnumFromQuery(SpansEnumQuery spanQuery, IndexReader reader) throws IOException {
+    LeafReader lr = SlowCompositeReaderWrapper.wrap(reader); // slow, but ok for testing
+    LeafReaderContext lrContext = lr.getContext();
+    Query rewrittenQuery = spanQuery.rewrite(lr); // get the term contexts so getSpans can be called directly
+    HashSet<Term> termSet = new HashSet<>();
+    rewrittenQuery.extractTerms(termSet);
+    Map<Term,TermContext> termContexts = new HashMap<>();
+    for (Term term: termSet) {
+      TermContext termContext = TermContext.build(lrContext, term);
+      termContexts.put(term, termContext);
+    }
+    SpansEnum actSpans = spanQuery.getSpans(lrContext, new Bits.MatchAllBits(lr.numDocs()), termContexts);
+    return actSpans;
+  }
+
   private String[] docFields = {
     "w1 w2 w3 w4 w5",
     "w1 w3 w2 w3",
@@ -93,6 +134,10 @@ public class TestSpans extends LuceneTestCase {
     return new SpanTermQuery(new Term(field, text));
   }
   
+  public SpansEnumTermQuery makeSpansEnumTermQuery(String text) {
+    return new SpansEnumTermQuery(new Term(field, text));
+  }
+  
   private void checkHits(Query query, int[] results) throws IOException {
     CheckHits.checkHits(random(), query, field, searcher, results);
   }
@@ -107,6 +152,17 @@ public class TestSpans extends LuceneTestCase {
     SpanNearQuery snq = new SpanNearQuery( new SpanQuery[]{q1,q2,q3}, slop, ordered);
     checkHits(snq, expectedDocs);
   }
+
+  private void orderedSpansEnumSlopTest3SQ(
+        SpansEnumQuery q1,
+        SpansEnumQuery q2,
+        SpansEnumQuery q3,
+        int slop,
+        int[] expectedDocs) throws IOException {
+    boolean ordered = true;
+    SpansEnumNearQuery senq = new SpansEnumNearQuery( new SpansEnumQuery[]{q1,q2,q3}, slop, ordered);
+    checkHits(senq, expectedDocs);
+  }
   
   public void orderedSlopTest3(int slop, int[] expectedDocs) throws IOException {
     orderedSlopTest3SQ(
@@ -117,10 +173,19 @@ public class TestSpans extends LuceneTestCase {
        expectedDocs);
   }
   
+  public void orderedSpansEnumSlopTest3(int slop, int[] expectedDocs) throws IOException {
+    orderedSpansEnumSlopTest3SQ(
+       makeSpansEnumTermQuery("w1"),
+       makeSpansEnumTermQuery("w2"),
+       makeSpansEnumTermQuery("w3"),
+       slop,
+       expectedDocs);
+  }
+  
   public void orderedSlopTest3Equal(int slop, int[] expectedDocs) throws IOException {
     orderedSlopTest3SQ(
        makeSpanTermQuery("w1"),
-       makeSpanTermQuery("w3"),
+       makeSpanTermQuery("w3"), // w3 instead of w2
        makeSpanTermQuery("w3"),
        slop,
        expectedDocs);
@@ -139,20 +204,24 @@ public class TestSpans extends LuceneTestCase {
     orderedSlopTest3(0, new int[] {0});
   }
 
+  public void testSpansEnumNearOrdered01() throws Exception {
+    orderedSpansEnumSlopTest3(0, new int[] {0});
+  }
+
   public void testSpanNearOrdered02() throws Exception {
-    orderedSlopTest3(1, new int[] {0,1});
+    orderedSlopTest3(1, new int[] {0,1}); //+enum
   }
 
   public void testSpanNearOrdered03() throws Exception {
-    orderedSlopTest3(2, new int[] {0,1,2});
+    orderedSlopTest3(2, new int[] {0,1,2});//+enum
   }
 
   public void testSpanNearOrdered04() throws Exception {
-    orderedSlopTest3(3, new int[] {0,1,2,3});
+    orderedSlopTest3(3, new int[] {0,1,2,3});//+enum
   }
 
   public void testSpanNearOrdered05() throws Exception {
-    orderedSlopTest3(4, new int[] {0,1,2,3});
+    orderedSlopTest3(4, new int[] {0,1,2,3});//+enum
   }
   
   public void testSpanNearOrderedEqual01() throws Exception {
@@ -201,7 +270,7 @@ public class TestSpans extends LuceneTestCase {
                                 makeSpanTermQuery("t3") },
                               slop,
                               ordered);
-    Spans spans = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), snq);
+    Spans spans = getSpansFromQuery(snq, reader);
 
     assertTrue("first range", spans.next());
     assertEquals("first doc", 11, spans.doc());
@@ -216,9 +285,7 @@ public class TestSpans extends LuceneTestCase {
     assertFalse("third range", spans.next());
   }
 
-
-  public void testSpanNearUnOrdered() throws Exception {
-
+  public void testSpanNearUnordered() throws Exception {
     //See http://www.gossamer-threads.com/lists/lucene/java-dev/52270 for discussion about this test
     SpanNearQuery snq;
     snq = new SpanNearQuery(
@@ -227,31 +294,12 @@ public class TestSpans extends LuceneTestCase {
                                 makeSpanTermQuery("u2") },
                               0,
                               false);
-    Spans spans =  MultiSpansWrapper.wrap(searcher.getTopReaderContext(), snq);
-    assertTrue("Does not have next and it should", spans.next());
-    assertEquals("doc", 4, spans.doc());
-    assertEquals("start", 1, spans.start());
-    assertEquals("end", 3, spans.end());
-
-    assertTrue("Does not have next and it should", spans.next());
-    assertEquals("doc", 5, spans.doc());
-    assertEquals("start", 2, spans.start());
-    assertEquals("end", 4, spans.end());
-
-    assertTrue("Does not have next and it should", spans.next());
-    assertEquals("doc", 8, spans.doc());
-    assertEquals("start", 2, spans.start());
-    assertEquals("end", 4, spans.end());
-
-    assertTrue("Does not have next and it should", spans.next());
-    assertEquals("doc", 9, spans.doc());
-    assertEquals("start", 0, spans.start());
-    assertEquals("end", 2, spans.end());
-
-    assertTrue("Does not have next and it should", spans.next());
-    assertEquals("doc", 10, spans.doc());
-    assertEquals("start", 0, spans.start());
-    assertEquals("end", 2, spans.end());
+    Spans spans = getSpansFromQuery(snq, reader);
+    tstNextSpans(spans, 4, 1, 3);
+    tstNextSpans(spans, 5, 2, 4);
+    tstNextSpans(spans, 8, 2, 4);
+    tstNextSpans(spans, 9, 0, 2);
+    tstNextSpans(spans, 10, 0, 2);
     assertTrue("Has next and it shouldn't: " + spans.doc(), spans.next() == false);
 
     SpanNearQuery u1u2 = new SpanNearQuery(new SpanQuery[]{makeSpanTermQuery("u1"),
@@ -263,57 +311,58 @@ public class TestSpans extends LuceneTestCase {
                               },
                               1,
                               false);
-    spans =  MultiSpansWrapper.wrap(searcher.getTopReaderContext(), snq);
-    assertTrue("Does not have next and it should", spans.next());
-    assertEquals("doc", 4, spans.doc());
-    assertEquals("start", 0, spans.start());
-    assertEquals("end", 3, spans.end());
-
-    assertTrue("Does not have next and it should", spans.next());
-    //unordered spans can be subsets
-    assertEquals("doc", 4, spans.doc());
-    assertEquals("start", 1, spans.start());
-    assertEquals("end", 3, spans.end());
-
-    assertTrue("Does not have next and it should", spans.next());
-    assertEquals("doc", 5, spans.doc());
-    assertEquals("start", 0, spans.start());
-    assertEquals("end", 4, spans.end());
-
-    assertTrue("Does not have next and it should", spans.next());
-    assertEquals("doc", 5, spans.doc());
-    assertEquals("start", 2, spans.start());
-    assertEquals("end", 4, spans.end());
-
-    assertTrue("Does not have next and it should", spans.next());
-    assertEquals("doc", 8, spans.doc());
-    assertEquals("start", 0, spans.start());
-    assertEquals("end", 4, spans.end());
-
-
-    assertTrue("Does not have next and it should", spans.next());
-    assertEquals("doc", 8, spans.doc());
-    assertEquals("start", 2, spans.start());
-    assertEquals("end", 4, spans.end());
-
-    assertTrue("Does not have next and it should", spans.next());
-    assertEquals("doc", 9, spans.doc());
-    assertEquals("start", 0, spans.start());
-    assertEquals("end", 2, spans.end());
-
-    assertTrue("Does not have next and it should", spans.next());
-    assertEquals("doc", 9, spans.doc());
-    assertEquals("start", 0, spans.start());
-    assertEquals("end", 4, spans.end());
-
-    assertTrue("Does not have next and it should", spans.next());
-    assertEquals("doc", 10, spans.doc());
-    assertEquals("start", 0, spans.start());
-    assertEquals("end", 2, spans.end());
 
+    spans = getSpansFromQuery(snq, reader);
+    tstNextSpans(spans, 4, 0, 3);
+    tstNextSpans(spans, 4, 1, 3); // unordered spans can be subsets
+    tstNextSpans(spans, 5, 0, 4);
+    tstNextSpans(spans, 5, 2, 4);
+    tstNextSpans(spans, 8, 0, 4);
+    tstNextSpans(spans, 8, 2, 4);
+    tstNextSpans(spans, 9, 0, 2);
+    tstNextSpans(spans, 9, 0, 4);
+    tstNextSpans(spans, 10, 0, 2);
     assertTrue("Has next and it shouldn't", spans.next() == false);
   }
 
+  public void testSpansEnumNearUnordered() throws Exception {
+    //See http://www.gossamer-threads.com/lists/lucene/java-dev/52270 for discussion about this test
+    SpansEnumNearQuery senq;
+    senq = new SpansEnumNearQuery(
+                              new SpansEnumQuery[] {
+                                makeSpansEnumTermQuery("u1"),
+                                makeSpansEnumTermQuery("u2") },
+                              0,
+                              false);
+    SpansEnum spans = getSpansEnumFromQuery(senq, reader);
+    tstNextSpansEnum(spans, 4, 1, 3);
+    tstNextSpansEnum(spans, 5, 2, 4);
+    tstNextSpansEnum(spans, 8, 2, 4);
+    tstNextSpansEnum(spans, 9, 0, 2);
+    tstNextSpansEnum(spans, 10, 0, 2);
+    tstEndSpansEnum(spans);
+
+    SpansEnumNearQuery u1u2 = new SpansEnumNearQuery(new SpansEnumQuery[]{makeSpansEnumTermQuery("u1"),
+                                makeSpansEnumTermQuery("u2")}, 0, false);
+    senq = new SpansEnumNearQuery(
+                              new SpansEnumQuery[] {
+                                u1u2,
+                                makeSpansEnumTermQuery("u2")
+                              },
+                              1,
+                              false);
+    spans = getSpansEnumFromQuery(senq, reader);
+    tstNextSpansEnum(spans, 4, 0, 3);
+    tstNextSpansEnum(spans, 4, 1, 3); // unordered spans can be subsets
+    tstNextSpansEnum(spans, 5, 0, 4);
+    tstNextSpansEnum(spans, 5, 2, 4);
+    tstNextSpansEnum(spans, 8, 0, 4);
+    tstNextSpansEnum(spans, 8, 2, 4);
+    tstNextSpansEnum(spans, 9, 0, 2);
+    tstNextSpansEnum(spans, 9, 0, 4);
+    tstNextSpansEnum(spans, 10, 0, 2);
+    tstEndSpansEnum(spans);
+  }
 
 
   private Spans orSpans(String[] terms) throws Exception {
@@ -321,10 +370,18 @@ public class TestSpans extends LuceneTestCase {
     for (int i = 0; i < terms.length; i++) {
       sqa[i] = makeSpanTermQuery(terms[i]);
     }
-    return  MultiSpansWrapper.wrap(searcher.getTopReaderContext(), new SpanOrQuery(sqa));
+    return getSpansFromQuery(new SpanOrQuery(sqa), reader);
   }
 
-  private void tstNextSpans(Spans spans, int doc, int start, int end)
+  private SpansEnum orSpansEnum(String[] terms) throws Exception {
+    SpansEnumQuery[] sqa = new SpansEnumQuery[terms.length];
+    for (int i = 0; i < terms.length; i++) {
+      sqa[i] = makeSpansEnumTermQuery(terms[i]);
+    }
+    return getSpansEnumFromQuery(new SpansEnumOrQuery(sqa), reader);
+  }
+
+  public static void tstNextSpans(Spans spans, int doc, int start, int end)
   throws Exception {
     assertTrue("next", spans.next());
     assertEquals("doc", doc, spans.doc());
@@ -332,6 +389,35 @@ public class TestSpans extends LuceneTestCase {
     assertEquals("end", end, spans.end());
   }
 
+  public static void tstNextSpansEnum(SpansEnum spans, int doc, int start, int end)
+  throws Exception {
+    if (spans.docID() >= doc) {
+      assertEquals("docId", doc, spans.docID());
+    } else { // nextDoc needed before testing start/end
+      if (spans.docID() >= 0) {
+        assertEquals("nextStartPosition of previous doc", SpansEnum.NO_MORE_POSITIONS, spans.nextStartPosition());
+        assertEquals("endPosition of previous doc", SpansEnum.NO_MORE_POSITIONS, spans.endPosition());
+      }
+      assertEquals("nextDoc", doc, spans.nextDoc());
+      if (doc != SpansEnum.NO_MORE_DOCS) {
+        assertEquals("first startPosition", -1, spans.startPosition());
+        assertEquals("first endPosition", -1, spans.endPosition());
+      }
+    }
+    if (doc != SpansEnum.NO_MORE_DOCS) {
+      assertEquals("nextStartPosition", start, spans.nextStartPosition());
+      assertEquals("startPosition", start, spans.startPosition());
+      assertEquals("endPosition", end, spans.endPosition());
+    }
+  }
+
+  public static  void tstEndSpansEnum(SpansEnum spans)
+  throws Exception {
+    if (spans != null) { // null SpansEnum is empty
+      tstNextSpansEnum(spans, SpansEnum.NO_MORE_DOCS, -2, -2); // start and end positions will be ignored
+    }
+  }
+
   public void testSpanOrEmpty() throws Exception {
     Spans spans = orSpans(new String[0]);
     assertFalse("empty next", spans.next());
@@ -341,13 +427,28 @@ public class TestSpans extends LuceneTestCase {
     assertTrue("empty should equal", a.equals(b));
   }
 
+  public void testSpansEnumOrEmpty() throws Exception {
+    SpansEnum spans = orSpansEnum(new String[0]);
+    tstEndSpansEnum(spans);
+
+    SpansEnumOrQuery a = new SpansEnumOrQuery();
+    SpansEnumOrQuery b = new SpansEnumOrQuery();
+    assertTrue("empty should equal", a.equals(b));
+  }
+
   public void testSpanOrSingle() throws Exception {
     Spans spans = orSpans(new String[] {"w5"});
     tstNextSpans(spans, 0, 4, 5);
     assertFalse("final next", spans.next());
   }
   
-  public void testSpanOrMovesForward() throws Exception {
+  public void testSpansEnumOrSingle() throws Exception {
+    SpansEnum spans = orSpansEnum(new String[] {"w5"});
+    tstNextSpansEnum(spans, 0, 4, 5);
+    tstEndSpansEnum(spans);
+  }
+  
+  public void testSpanOrMovesForward() throws Exception { // no SpansEnum test needed for this
     Spans spans = orSpans(new String[] {"w1", "xx"});
 
     spans.next();
@@ -373,6 +474,15 @@ public class TestSpans extends LuceneTestCase {
     assertFalse("final next", spans.next());
   }
 
+  public void testSpansEnumOrDouble() throws Exception {
+    SpansEnum spans = orSpansEnum(new String[] {"w5", "yy"});
+    tstNextSpansEnum(spans, 0, 4, 5);
+    tstNextSpansEnum(spans, 2, 3, 4);
+    tstNextSpansEnum(spans, 3, 4, 5);
+    tstNextSpansEnum(spans, 7, 3, 4);
+    tstEndSpansEnum(spans);
+  }
+
   public void testSpanOrDoubleSkip() throws Exception {
     Spans spans = orSpans(new String[] {"w5", "yy"});
     assertTrue("initial skipTo", spans.skipTo(3));
@@ -383,6 +493,14 @@ public class TestSpans extends LuceneTestCase {
     assertFalse("final next", spans.next());
   }
 
+  public void testSpansEnumOrDoubleAdvance() throws Exception {
+    SpansEnum spans = orSpansEnum(new String[] {"w5", "yy"});
+    assertEquals("initial advance", 3, spans.advance(3));
+    tstNextSpansEnum(spans, 3, 4, 5);
+    tstNextSpansEnum(spans, 7, 3, 4);
+    tstEndSpansEnum(spans);
+  }
+
   public void testSpanOrUnused() throws Exception {
     Spans spans = orSpans(new String[] {"w5", "unusedTerm", "yy"});
     tstNextSpans(spans, 0, 4, 5);
@@ -392,6 +510,15 @@ public class TestSpans extends LuceneTestCase {
     assertFalse("final next", spans.next());
   }
 
+  public void testSpansEnumOrUnused() throws Exception {
+    SpansEnum spans = orSpansEnum(new String[] {"w5", "unusedTerm", "yy"});
+    tstNextSpansEnum(spans, 0, 4, 5);
+    tstNextSpansEnum(spans, 2, 3, 4);
+    tstNextSpansEnum(spans, 3, 4, 5);
+    tstNextSpansEnum(spans, 7, 3, 4);
+    tstEndSpansEnum(spans);
+  }
+
   public void testSpanOrTripleSameDoc() throws Exception {
     Spans spans = orSpans(new String[] {"t1", "t2", "t3"});
     tstNextSpans(spans, 11, 0, 1);
@@ -403,6 +530,17 @@ public class TestSpans extends LuceneTestCase {
     assertFalse("final next", spans.next());
   }
 
+  public void testSpansEnumOrTripleSameDoc() throws Exception {
+    SpansEnum spans = orSpansEnum(new String[] {"t1", "t2", "t3"});
+    tstNextSpansEnum(spans, 11, 0, 1);
+    tstNextSpansEnum(spans, 11, 1, 2);
+    tstNextSpansEnum(spans, 11, 2, 3);
+    tstNextSpansEnum(spans, 11, 3, 4);
+    tstNextSpansEnum(spans, 11, 4, 5);
+    tstNextSpansEnum(spans, 11, 5, 6);
+    tstEndSpansEnum(spans);
+  }
+
   public void testSpanScorerZeroSloppyFreq() throws Exception {
     boolean ordered = true;
     int slop = 1;
@@ -445,6 +583,48 @@ public class TestSpans extends LuceneTestCase {
     }
   }
 
+  public void testSpansEnumScorerZeroSloppyFreq() throws Exception {
+    boolean ordered = true;
+    int slop = 1;
+    IndexReaderContext topReaderContext = searcher.getTopReaderContext();
+    List<LeafReaderContext> leaves = topReaderContext.leaves();
+    int subIndex = ReaderUtil.subIndex(11, leaves);
+    for (int i = 0, c = leaves.size(); i < c; i++) {
+      final LeafReaderContext ctx = leaves.get(i);
+     
+      final Similarity sim = new DefaultSimilarity() {
+        @Override
+        public float sloppyFreq(int distance) {
+          return 0.0f;
+        }
+      };
+  
+      final Similarity oldSim = searcher.getSimilarity();
+      Scorer spanScorer;
+      try {
+        searcher.setSimilarity(sim);
+        SpansEnumNearQuery senq = new SpansEnumNearQuery(
+                                      new SpansEnumQuery[] {
+                                        makeSpansEnumTermQuery("t1"),
+                                        makeSpansEnumTermQuery("t2") },
+                                      slop,
+                                      ordered);
+  
+        spanScorer = searcher.createNormalizedWeight(senq, true).scorer(ctx, ctx.reader().getLiveDocs());
+      } finally {
+        searcher.setSimilarity(oldSim);
+      }
+      if (i == subIndex) {
+        assertTrue("first doc", spanScorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS);
+        assertEquals("first doc number", spanScorer.docID() + ctx.docBase, 11);
+        float score = spanScorer.score();
+        assertTrue("first doc score should be zero, " + score, score == 0.0f);
+      }  else {
+        assertTrue("no second doc", spanScorer.nextDoc() == DocIdSetIterator.NO_MORE_DOCS);
+      }
+    }
+  }
+
   // LUCENE-1404
   private void addDoc(IndexWriter writer, String id, String text) throws IOException {
     final Document doc = new Document();
@@ -463,16 +643,28 @@ public class TestSpans extends LuceneTestCase {
     return new SpanTermQuery(new Term("text", value));
   }                     
   
+  private SpansEnumQuery createSpansEnum(String value) {
+    return new SpansEnumTermQuery(new Term("text", value));
+  }                     
+  
   // LUCENE-1404
   private SpanQuery createSpan(int slop, boolean ordered, SpanQuery[] clauses) {
     return new SpanNearQuery(clauses, slop, ordered);
   }
 
+  private SpansEnumQuery createSpansEnum(int slop, boolean ordered, SpansEnumQuery[] clauses) {
+    return new SpansEnumNearQuery(clauses, slop, ordered);
+  }
+
   // LUCENE-1404
   private SpanQuery createSpan(int slop, boolean ordered, String term1, String term2) {
     return createSpan(slop, ordered, new SpanQuery[] {createSpan(term1), createSpan(term2)});
   }
 
+  private SpansEnumQuery createSpansEnum(int slop, boolean ordered, String term1, String term2) {
+    return createSpansEnum(slop, ordered, new SpansEnumQuery[] {createSpansEnum(term1), createSpansEnum(term2)});
+  }
+
   // LUCENE-1404
   public void testNPESpanQuery() throws Throwable {
     final Directory dir = newDirectory();
@@ -497,15 +689,45 @@ public class TestSpans extends LuceneTestCase {
 
     // This throws exception (it shouldn't)
     assertEquals(1,
-                 searcher.search(createSpan(0, true,                                 
+                 searcher.search(createSpan(0, true,                           
                                             new SpanQuery[] {createSpan(4, false, "chased", "cat"),
                                                              createSpan("ate")}), 10).totalHits);
     reader.close();
     dir.close();
   }
   
+  public void testNPESpansEnumQuery() throws Throwable {
+    final Directory dir = newDirectory();
+    final IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(new MockAnalyzer(random())));
+
+    // Add documents
+    addDoc(writer, "1", "the big dogs went running to the market");
+    addDoc(writer, "2", "the cat chased the mouse, then the cat ate the mouse quickly");
+    
+    // Commit
+    writer.close();
+
+    // Get searcher
+    final IndexReader reader = DirectoryReader.open(dir);
+    final IndexSearcher searcher = newSearcher(reader);
+
+    // Control (make sure docs indexed)
+    assertEquals(2, hitCount(searcher, "the"));
+    assertEquals(1, hitCount(searcher, "cat"));
+    assertEquals(1, hitCount(searcher, "dogs"));
+    assertEquals(0, hitCount(searcher, "rabbit"));
+
+    // This throws exception (it shouldn't)
+    assertEquals(1,
+                 searcher.search(createSpansEnum(0, true,                           
+                                            new SpansEnumQuery[] {createSpansEnum(4, false, "chased", "cat"),
+                                                                   createSpansEnum("ate")}), 10).totalHits);
+    reader.close();
+    dir.close();
+  }
   
-  public void testSpanNots() throws Throwable{
+  
+  public void testSpanNots() throws Throwable {
      assertEquals("SpanNotIncludeExcludeSame1", 0, spanCount("s2", "s2", 0, 0), 0);
      assertEquals("SpanNotIncludeExcludeSame2", 0, spanCount("s2", "s2", 10, 10), 0);
      
@@ -537,18 +759,68 @@ public class TestSpans extends LuceneTestCase {
      assertEquals("SpanNotS3NotS1_8_8", 0, spanCount("s3", "s1", 8, 8));
 
   }
+ 
+  public void testSpansEnumNots() throws Throwable {
+     assertEquals("SpanNotIncludeExcludeSame1", 0, spansEnumCount("s2", "s2", 0, 0), 0);
+     assertEquals("SpanNotIncludeExcludeSame2", 0, spansEnumCount("s2", "s2", 10, 10), 0);
+     
+     //focus on behind
+     assertEquals("SpanNotS2NotS1_6_0", 1, spansEnumCount("s2", "s1", 6, 0));
+     assertEquals("SpanNotS2NotS1_5_0", 2, spansEnumCount("s2", "s1", 5, 0));
+     assertEquals("SpanNotS2NotS1_3_0", 3, spansEnumCount("s2", "s1", 3, 0));
+     assertEquals("SpanNotS2NotS1_2_0", 4, spansEnumCount("s2", "s1", 2, 0));
+     assertEquals("SpanNotS2NotS1_0_0", 4, spansEnumCount("s2", "s1", 0, 0));
+     
+     //focus on both
+     assertEquals("SpanNotS2NotS1_3_1", 2, spansEnumCount("s2", "s1", 3, 1));
+     assertEquals("SpanNotS2NotS1_2_1", 3, spansEnumCount("s2", "s1", 2, 1));
+     assertEquals("SpanNotS2NotS1_1_1", 3, spansEnumCount("s2", "s1", 1, 1));
+     assertEquals("SpanNotS2NotS1_10_10", 0, spansEnumCount("s2", "s1", 10, 10));
+     
+     //focus on ahead
+     assertEquals("SpanNotS1NotS2_10_10", 0, spansEnumCount("s1", "s2", 10, 10));  
+     assertEquals("SpanNotS1NotS2_0_1", 3, spansEnumCount("s1", "s2", 0, 1));  
+     assertEquals("SpanNotS1NotS2_0_2", 3, spansEnumCount("s1", "s2", 0, 2));  
+     assertEquals("SpanNotS1NotS2_0_3", 2, spansEnumCount("s1", "s2", 0, 3));  
+     assertEquals("SpanNotS1NotS2_0_4", 1, spansEnumCount("s1", "s2", 0, 4));
+     assertEquals("SpanNotS1NotS2_0_8", 0, spansEnumCount("s1", "s2", 0, 8));
+     
+     //exclude doesn't exist
+     assertEquals("SpanNotS1NotS3_8_8", 3, spansEnumCount("s1", "s3", 8, 8));
+
+     //include doesn't exist
+     assertEquals("SpanNotS3NotS1_8_8", 0, spansEnumCount("s3", "s1", 8, 8));
+
+  }
+ 
+  private int spanCount(String include, String exclude, int pre, int post) throws IOException {
+    SpanTermQuery iq = new SpanTermQuery(new Term(field, include));
+    SpanTermQuery eq = new SpanTermQuery(new Term(field, exclude));
+    SpanNotQuery snq = new SpanNotQuery(iq, eq, pre, post);
+    Spans spans = getSpansFromQuery(snq, reader);
+    
+    int i = 0;
+    while (spans.next()){
+      i++;
+    }
+    return i;
+  }
   
-  private int spanCount(String include, String exclude, int pre, int post) throws IOException{
-     SpanTermQuery iq = new SpanTermQuery(new Term(field, include));
-     SpanTermQuery eq = new SpanTermQuery(new Term(field, exclude));
-     SpanNotQuery snq = new SpanNotQuery(iq, eq, pre, post);
-     Spans spans = MultiSpansWrapper.wrap(searcher.getTopReaderContext(), snq);
-
-     int i = 0;
-     while (spans.next()){
-        i++;
-     }
-     return i;
+  private int spansEnumCount(String include, String exclude, int pre, int post) throws IOException {
+    SpansEnumTermQuery iq = new SpansEnumTermQuery(new Term(field, include));
+    SpansEnumTermQuery eq = new SpansEnumTermQuery(new Term(field, exclude));
+    SpansEnumNotQuery senq = new SpansEnumNotQuery(iq, eq, pre, post);
+    SpansEnum spans = getSpansEnumFromQuery(senq, reader);
+    
+    int i = 0;
+    if (spans != null) {
+      while (spans.nextDoc() != SpansEnum.NO_MORE_DOCS){
+        while (spans.nextStartPosition() != SpansEnum.NO_MORE_POSITIONS) {
+          i++;
+        }
+      }
+    }
+    return i;
   }
   
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced.java
index ac456fd..0320f66 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced.java
@@ -120,6 +120,22 @@ public class TestSpansAdvanced extends LuceneTestCase {
   }
   
   /**
+   * Tests two SpansEnum queries.
+   */
+  protected void doTestBooleanQueryWithSpansEnumQueries(IndexSearcher s,
+      final float expectedScore) throws IOException {
+    
+    final Query spanQuery = new SpansEnumTermQuery(new Term(FIELD_TEXT, "work"));
+    final BooleanQuery query = new BooleanQuery();
+    query.add(spanQuery, BooleanClause.Occur.MUST);
+    query.add(spanQuery, BooleanClause.Occur.MUST);
+    final String[] expectedIds = new String[] {"1", "2", "3", "4"};
+    final float[] expectedScores = new float[] {expectedScore, expectedScore,
+        expectedScore, expectedScore};
+    assertHits(s, query, "two span queries", expectedIds, expectedScores);
+  }
+  
+  /**
    * Checks to see if the hits are what we expected.
    * 
    * @param query the query to execute
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced2.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced2.java
index 6658907..6f1d772 100644
--- a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced2.java
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced2.java
@@ -93,6 +93,20 @@ public class TestSpansAdvanced2 extends TestSpansAdvanced {
   }
   
   /**
+   * Tests a single SpansEnum query that matches multiple documents.
+   */
+  public void testSingleSpansEnumQuery() throws IOException {
+    
+    final Query spanQuery = new SpansEnumTermQuery(new Term(FIELD_TEXT, "should"));
+    final String[] expectedIds = new String[] {"B", "D", "1", "2", "3", "4",
+        "A"};
+    final float[] expectedScores = new float[] {0.625f, 0.45927936f,
+        0.35355338f, 0.35355338f, 0.35355338f, 0.35355338f, 0.26516503f,};
+    assertHits(searcher2, spanQuery, "single span query", expectedIds,
+        expectedScores);
+  }
+  
+  /**
    * Tests a single span query that matches multiple documents.
    */
   public void testMultipleDifferentSpanQueries() throws IOException {
@@ -111,6 +125,25 @@ public class TestSpansAdvanced2 extends TestSpansAdvanced {
   }
   
   /**
+   * Tests a single SpansEnum query that matches multiple documents.
+   * Derived from testMultipleDifferentSpanQueries.
+   */
+  public void testMultipleDifferentSpansEnumQueries() throws IOException {
+    
+    final Query spanQuery1 = new SpansEnumTermQuery(new Term(FIELD_TEXT, "should"));
+    final Query spanQuery2 = new SpansEnumTermQuery(new Term(FIELD_TEXT, "we"));
+    final BooleanQuery query = new BooleanQuery();
+    query.add(spanQuery1, BooleanClause.Occur.MUST);
+    query.add(spanQuery2, BooleanClause.Occur.MUST);
+    final String[] expectedIds = new String[] {"D", "A"};
+    // these values were pre LUCENE-413
+    // final float[] expectedScores = new float[] { 0.93163157f, 0.20698164f };
+    final float[] expectedScores = new float[] {1.0191123f, 0.93163157f};
+    assertHits(searcher2, query, "multiple different span queries",
+        expectedIds, expectedScores);
+  }
+  
+  /**
    * Tests two span queries.
    */
   @Override
@@ -118,4 +151,14 @@ public class TestSpansAdvanced2 extends TestSpansAdvanced {
     
     doTestBooleanQueryWithSpanQueries(searcher2, 0.73500174f);
   }
+  
+  /**
+   * Tests two SpansEnum queries.
+   */
+  public void testBooleanQueryWithSpansEnumQueries() throws IOException {
+    
+    doTestBooleanQueryWithSpansEnumQueries(searcher2, 0.73500174f);
+  }
+  
+  
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java
new file mode 100644
index 0000000..42cf357
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java
@@ -0,0 +1,196 @@
+package org.apache.lucene.search.spans;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+import org.apache.lucene.analysis.*;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.CheckHits;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.PhraseQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.English;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ * Tests SpansEnumOrQuery
+ *
+ */
+public class TestSpansEnum extends LuceneTestCase {
+  private static IndexSearcher searcher;
+  private static IndexReader reader;
+  private static Directory directory;
+
+  static final class SimplePayloadFilter extends TokenFilter {
+    int pos;
+    final PayloadAttribute payloadAttr;
+    final CharTermAttribute termAttr;
+
+    public SimplePayloadFilter(TokenStream input) {
+      super(input);
+      pos = 0;
+      payloadAttr = input.addAttribute(PayloadAttribute.class);
+      termAttr = input.addAttribute(CharTermAttribute.class);
+    }
+
+    @Override
+    public boolean incrementToken() throws IOException {
+      if (input.incrementToken()) {
+        payloadAttr.setPayload(new BytesRef(("pos: " + pos).getBytes(StandardCharsets.UTF_8)));
+        pos++;
+        return true;
+      } else {
+        return false;
+      }
+    }
+
+    @Override
+    public void reset() throws IOException {
+      super.reset();
+      pos = 0;
+    }
+  }
+
+  static Analyzer simplePayloadAnalyzer;
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    simplePayloadAnalyzer = new Analyzer() {
+        @Override
+        public TokenStreamComponents createComponents(String fieldName) {
+          Tokenizer tokenizer = new MockTokenizer(MockTokenizer.SIMPLE, true);
+          return new TokenStreamComponents(tokenizer, new SimplePayloadFilter(tokenizer));
+        }
+    };
+
+    directory = newDirectory();
+    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,
+        newIndexWriterConfig(simplePayloadAnalyzer)
+            .setMaxBufferedDocs(TestUtil.nextInt(random(), 100, 1000)).setMergePolicy(newLogMergePolicy()));
+    //writer.infoStream = System.out;
+    for (int i = 0; i < 10; i++) {
+      Document doc = new Document();
+      doc.add(newTextField("field", English.intToEnglish(i), Field.Store.YES));
+      writer.addDocument(doc);
+    }
+    for (int i = 100; i < 110; i++) {
+      Document doc = new Document(); // doc id 10-19 have 100-109
+      doc.add(newTextField("field", English.intToEnglish(i), Field.Store.YES));
+      writer.addDocument(doc);
+    }
+    reader = writer.getReader();
+    searcher = newSearcher(reader);
+    writer.close();
+  }
+
+  @AfterClass
+  public static void afterClass() throws Exception {
+    reader.close();
+    directory.close();
+    searcher = null;
+    reader = null;
+    directory = null;
+    simplePayloadAnalyzer = null;
+  }
+
+  private void checkHits(Query query, int[] results) throws IOException {
+    CheckHits.checkHits(random(), query, "field", searcher, results);
+  }
+
+  SpansEnumTermQuery spansEnumTQ(String term) {
+    return new SpansEnumTermQuery(new Term("field", term));
+  }
+
+  @Test
+  public void testSpansEnumOr1() throws Exception {
+    SpansEnumTermQuery t1 = spansEnumTQ("one");
+    SpansEnumTermQuery t2 = spansEnumTQ("two");
+    SpansEnumOrQuery soq = new SpansEnumOrQuery(t1, t2);
+    checkHits(soq, new int[] {1, 2, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
+  }
+
+  @Test
+  public void testSpansEnumOr2() throws Exception {
+    SpansEnumTermQuery t1 = spansEnumTQ("one");
+    SpansEnumTermQuery t11 = spansEnumTQ("eleven");
+    SpansEnumOrQuery soq = new SpansEnumOrQuery(t1, t11);
+    checkHits(soq, new int[] {1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
+  }
+
+  @Test
+  public void testSpansEnumOr3() throws Exception {
+    SpansEnumTermQuery t12 = spansEnumTQ("twelve");
+    SpansEnumTermQuery t11 = spansEnumTQ("eleven");
+    SpansEnumOrQuery soq = new SpansEnumOrQuery(t12, t11);
+    checkHits(soq, new int[] {});
+  }
+
+  @Test
+  public void testSpansEnumOrNot1() throws Exception {
+    SpansEnumTermQuery t1 = spansEnumTQ("one");
+    SpansEnumTermQuery t2 = spansEnumTQ("two");
+    SpansEnumOrQuery soq = new SpansEnumOrQuery(t1, t2);
+    SpansEnumNotQuery snq = new SpansEnumNotQuery(soq, t1);
+    checkHits(snq, new int[] {2,12});
+  }
+
+  @Test
+  public void testSpansEnumNotBeforeAfter1() throws Exception {
+    SpansEnumTermQuery t1 = spansEnumTQ("one");
+    SpansEnumTermQuery t100 = spansEnumTQ("hundred");
+    SpansEnumNotQuery snq = new SpansEnumNotQuery(t100, t1, 0, 0);
+    checkHits(snq, new int[] {10, 11, 12, 13, 14, 15, 16, 17, 18, 19}); // include all "one hundred ..."
+  }
+
+  @Test
+  public void testSpansEnumNotBeforeAfter2() throws Exception {
+    SpansEnumTermQuery t1 = spansEnumTQ("one");
+    SpansEnumTermQuery t100 = spansEnumTQ("hundred");
+    SpansEnumNotQuery snq = new SpansEnumNotQuery(t100, t1, 1, 0);
+    checkHits(snq, new int[] {}); // exclude all "one hundred ..."
+  }
+
+  @Test
+  public void testSpansEnumNotBeforeAfter3() throws Exception {
+    SpansEnumTermQuery t1 = spansEnumTQ("one");
+    SpansEnumTermQuery t100 = spansEnumTQ("hundred");
+    SpansEnumNotQuery snq = new SpansEnumNotQuery(t100, t1, 0, 1);
+    checkHits(snq, new int[] {10, 12, 13, 14, 15, 16, 17, 18, 19}); // exclude "one hundred one"
+  }
+}
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java b/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
index ee6c390..0ec2047 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
@@ -31,6 +31,12 @@ import org.apache.lucene.search.spans.SpanNotQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.spans.SpansEnumFirstQuery;
+import org.apache.lucene.search.spans.SpansEnumNearQuery;
+import org.apache.lucene.search.spans.SpansEnumNotQuery;
+import org.apache.lucene.search.spans.SpansEnumOrQuery;
+import org.apache.lucene.search.spans.SpansEnumQuery;
+import org.apache.lucene.search.spans.SpansEnumTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
@@ -144,56 +150,117 @@ public abstract class BaseExplanationTestCase extends LuceneTestCase {
     return new SpanTermQuery(new Term(FIELD,s));
   }
   
+  /** MACRO for SpansEnumTermQuery */
+  public SpansEnumTermQuery set(String s) { // CHECKME: need better name?
+    return new SpansEnumTermQuery(new Term(FIELD,s));
+  }
+  
   /** MACRO for SpanNotQuery */
   public SpanNotQuery snot(SpanQuery i, SpanQuery e) {
     return new SpanNotQuery(i,e);
   }
 
+  /** MACRO for SpansEnumNotQuery */
+  public SpansEnumNotQuery senot(SpansEnumQuery i, SpansEnumQuery e) {
+    return new SpansEnumNotQuery(i,e);
+  }
+
   /** MACRO for SpanOrQuery containing two SpanTerm queries */
   public SpanOrQuery sor(String s, String e) {
     return sor(st(s), st(e));
   }
+
+  /** MACRO for SpansEnumOrQuery containing two SpansEnumTerm queries */
+  public SpansEnumOrQuery seor(String s, String e) {
+    return seor(set(s), set(e));
+  }
+
   /** MACRO for SpanOrQuery containing two SpanQueries */
   public SpanOrQuery sor(SpanQuery s, SpanQuery e) {
     return new SpanOrQuery(s, e);
   }
   
+  /** MACRO for SpansEnumOrQuery containing two SpansEnumQueries */
+  public SpansEnumOrQuery seor(SpansEnumQuery s, SpansEnumQuery e) {
+    return new SpansEnumOrQuery(s, e);
+  }
+  
   /** MACRO for SpanOrQuery containing three SpanTerm queries */
   public SpanOrQuery sor(String s, String m, String e) {
     return sor(st(s), st(m), st(e));
   }
-  /** MACRO for SpanOrQuery containing two SpanQueries */
+
+  /** MACRO for SpansEnumOrQuery containing three SpansEnumTerm queries */
+  public SpansEnumOrQuery seor(String s, String m, String e) {
+    return seor(set(s), set(m), set(e));
+  }
+
+  /** MACRO for SpanOrQuery containing three SpanQueries */
   public SpanOrQuery sor(SpanQuery s, SpanQuery m, SpanQuery e) {
     return new SpanOrQuery(s, m, e);
   }
   
+  /** MACRO for SpansEnumOrQuery containing three SpanQueries */
+  public SpansEnumOrQuery seor(SpansEnumQuery s, SpansEnumQuery m, SpansEnumQuery e) {
+    return new SpansEnumOrQuery(s, m, e);
+  }
+  
   /** MACRO for SpanNearQuery containing two SpanTerm queries */
   public SpanNearQuery snear(String s, String e, int slop, boolean inOrder) {
     return snear(st(s), st(e), slop, inOrder);
   }
+
+  /** MACRO for SpansEnumNearQuery containing two SpanTerm queries */
+  public SpansEnumNearQuery senear(String s, String e, int slop, boolean inOrder) {
+    return senear(set(s), set(e), slop, inOrder);
+  }
+
   /** MACRO for SpanNearQuery containing two SpanQueries */
   public SpanNearQuery snear(SpanQuery s, SpanQuery e,
                              int slop, boolean inOrder) {
     return new SpanNearQuery(new SpanQuery[] { s, e }, slop, inOrder);
   }
   
-  
+  /** MACRO for SpansEnumNearQuery containing two SpansEnumQueries */
+  public SpansEnumNearQuery senear(SpansEnumQuery s, SpansEnumQuery e,
+                             int slop, boolean inOrder) {
+    return new SpansEnumNearQuery(new SpansEnumQuery[] { s, e }, slop, inOrder);
+  }
+
   /** MACRO for SpanNearQuery containing three SpanTerm queries */
   public SpanNearQuery snear(String s, String m, String e,
                              int slop, boolean inOrder) {
     return snear(st(s), st(m), st(e), slop, inOrder);
   }
+
+  /** MACRO for SpanNearQuery containing three SpanTerm queries */
+  public SpansEnumNearQuery senear(String s, String m, String e,
+                             int slop, boolean inOrder) {
+    return senear(set(s), set(m), set(e), slop, inOrder);
+  }
+
   /** MACRO for SpanNearQuery containing three SpanQueries */
   public SpanNearQuery snear(SpanQuery s, SpanQuery m, SpanQuery e,
                              int slop, boolean inOrder) {
     return new SpanNearQuery(new SpanQuery[] { s, m, e }, slop, inOrder);
   }
   
+  /** MACRO for SpanNearQuery containing three SpanQueries */
+  public SpansEnumNearQuery senear(SpansEnumQuery s, SpansEnumQuery m, SpansEnumQuery e,
+                             int slop, boolean inOrder) {
+    return new SpansEnumNearQuery(new SpansEnumQuery[] { s, m, e }, slop, inOrder);
+  }
+  
   /** MACRO for SpanFirst(SpanTermQuery) */
   public SpanFirstQuery sf(String s, int b) {
     return new SpanFirstQuery(st(s), b);
   }
 
+  /** MACRO for SpansEnumFirst(SpansEnumTermQuery) */
+  public SpansEnumFirstQuery sef(String s, int b) {
+    return new SpansEnumFirstQuery(set(s), b);
+  }
+
   /**
    * MACRO: Wraps a Query in a BooleanQuery so that it is optional, along
    * with a second prohibited clause which will never match anything
