diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java
index 2f142ba..e818e1d 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java
@@ -83,7 +83,7 @@ class LatLonPointDistanceComparator extends FieldComparator<Double> implements L
     // sampling if we get called way too much: don't make gobs of bounding
     // boxes if comparator hits a worst case order (e.g. backwards distance order)
     if (setBottomCounter < 1024 || (setBottomCounter & 0x3F) == 0x3F) {
-      GeoRect box = GeoUtils.circleToBBox(longitude, latitude, haversin2(bottom));
+      GeoRect box = GeoUtils.circleToBBox(latitude, longitude, haversin2(bottom));
       // pre-encode our box to our integer encoding, so we don't have to decode 
       // to double values for uncompetitive hits. This has some cost!
       minLat = LatLonPoint.encodeLatitude(box.minLat);
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
index 8f4b347..5e7a04e 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
@@ -75,7 +75,7 @@ final class LatLonPointDistanceQuery extends Query {
 
   @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
-    GeoRect box = GeoUtils.circleToBBox(longitude, latitude, radiusMeters);
+    GeoRect box = GeoUtils.circleToBBox(latitude, longitude, radiusMeters);
     // create bounding box(es) for the distance range
     // these are pre-encoded with LatLonPoint's encoding
     final byte minLat[] = new byte[Integer.BYTES];
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
index cb98895..7ce3a26 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
@@ -169,13 +169,13 @@ final class LatLonPointInPolygonQuery extends Query {
                              if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {
                                // Cell fully encloses the query
                                return Relation.CELL_CROSSES_QUERY;
-                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,
-                                                                 polyLons, polyLats,
-                                                                 minLon, minLat, maxLon, maxLat)) {
+                             } else  if (GeoRelationUtils.rectWithinPolyPreciseX(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon,
+                                                                                 polyLats, polyLons,
+                                                                                 minLat, maxLat, minLon, maxLon)) {
                                return Relation.CELL_INSIDE_QUERY;
-                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,
-                                                                 polyLons, polyLats,
-                                                                 minLon, minLat, maxLon, maxLat)) {
+                             } else if (GeoRelationUtils.rectCrossesPolyPreciseX(cellMinLat, cellMaxLat, cellMinLon, cellMaxLon,
+                                                                                 polyLats, polyLons,
+                                                                                 minLat, maxLat, minLon, maxLon)) {
                                return Relation.CELL_CROSSES_QUERY;
                              } else {
                                return Relation.CELL_OUTSIDE_QUERY;
@@ -204,7 +204,7 @@ final class LatLonPointInPolygonQuery extends Query {
                 long encoded = docValues.valueAt(i);
                 double docLatitude = LatLonPoint.decodeLatitude((int)(encoded >> 32));
                 double docLongitude = LatLonPoint.decodeLongitude((int)(encoded & 0xFFFFFFFF));
-                if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, docLatitude, docLongitude)) {
+                if (GeoRelationUtils.pointInPolygonX(polyLats, polyLons, docLatitude, docLongitude)) {
                   return true;
                 }
               }
@@ -289,9 +289,9 @@ final class LatLonPointInPolygonQuery extends Query {
     sb.append(" Points: ");
     for (int i=0; i<polyLons.length; ++i) {
       sb.append("[")
-        .append(polyLons[i])
-        .append(", ")
         .append(polyLats[i])
+        .append(", ")
+        .append(polyLons[i])
         .append("] ");
     }
     return sb.toString();
diff --git a/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceQuery.java b/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceQuery.java
index 193c2a3..3570ec2 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceQuery.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceQuery.java
@@ -195,12 +195,12 @@ public class TestLatLonPointDistanceQuery extends LuceneTestCase {
       double lat = -90 + 180.0 * random().nextDouble();
       double lon = -180 + 360.0 * random().nextDouble();
       double radius = 50000000 * random().nextDouble();
-      GeoRect box = GeoUtils.circleToBBox(lon, lat, radius);
+      GeoRect box = GeoUtils.circleToBBox(lat, lon, radius);
       final GeoRect box1;
       final GeoRect box2;
       if (box.crossesDateline()) {
-        box1 = new GeoRect(-180, box.maxLon, box.minLat, box.maxLat);
-        box2 = new GeoRect(box.minLon, 180, box.minLat, box.maxLat);
+        box1 = new GeoRect(box.minLat, box.maxLat, -180, box.maxLon);
+        box2 = new GeoRect(box.minLat, box.maxLat, box.minLon, 180);
       } else {
         box1 = box;
         box2 = null;
@@ -223,7 +223,7 @@ public class TestLatLonPointDistanceQuery extends LuceneTestCase {
       double lat = -90 + 180.0 * random().nextDouble();
       double lon = -180 + 360.0 * random().nextDouble();
       double radius = 50000000 * random().nextDouble();
-      GeoRect box = GeoUtils.circleToBBox(lon, lat, radius);
+      GeoRect box = GeoUtils.circleToBBox(lat, lon, radius);
 
       if (box.maxLon - lon < 90 && lon - box.minLon < 90) {
         double minPartialDistance = Math.max(SloppyMath.haversinSortKey(lat, lon, lat, box.maxLon),
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries.java b/lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries.java
index 90502f9..df026e2 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries.java
@@ -174,7 +174,7 @@ public class TestLatLonPointQueries extends BaseGeoPointTestCase {
 
       // TODO: randomly quantize radius too, to provoke exact math errors?
 
-      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);
+      GeoRect bbox = GeoUtils.circleToBBox(centerLat, centerLon, radiusMeters);
 
       int numPointsToTry = 1000;
       for(int i=0;i<numPointsToTry;i++) {
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointField.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointField.java
deleted file mode 100644
index 39f12df..0000000
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointField.java
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.geopoint.document;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.document.FieldType;
-import org.apache.lucene.index.DocValuesType;
-import org.apache.lucene.index.IndexOptions;
-import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.TokenStream;
-import org.apache.lucene.spatial.util.GeoEncodingUtils;
-
-/**
- * <p>
- * Field that indexes <code>latitude</code> <code>longitude</code> decimal-degree values
- * for efficient encoding, sorting, and querying. This Geo capability is intended
- * to provide a basic and efficient out of the box field type for indexing and
- * querying 2 dimensional points in WGS-84 decimal degrees. An example usage is as follows:
- *
- * <pre class="prettyprint">
- *  document.add(new GeoPointField(name, -96.33, 32.66, Field.Store.NO));
- * </pre>
- *
- * <p>To perform simple geospatial queries against a <code>GeoPointField</code>,
- * see {@link org.apache.lucene.spatial.geopoint.search.GeoPointInBBoxQuery}, {@link org.apache.lucene.spatial.geopoint.search.GeoPointInPolygonQuery},
- * or {@link org.apache.lucene.spatial.geopoint.search.GeoPointDistanceQuery}
- *
- * NOTE: This indexes only high precision encoded terms which may result in visiting a high number
- * of terms for large queries. See LUCENE-6481 for a future improvement.
- *
- * @lucene.experimental
- */
-public final class GeoPointField extends Field {
-  /** encoding step value for GeoPoint prefix terms */
-  public static final int PRECISION_STEP = 9;
-
-  /**
-   * <b>Expert:</b> Optional flag to select term encoding for GeoPointField types
-   */
-  public enum TermEncoding {
-    /**
-     * encodes prefix terms only resulting in a small index and faster queries - use with
-     * {@code GeoPointTokenStream}
-     */
-    PREFIX,
-    /**
-     * @deprecated encodes prefix and full resolution terms - use with
-     * {@link org.apache.lucene.analysis.LegacyNumericTokenStream}
-     */
-    @Deprecated
-    NUMERIC
-  }
-
-  /**
-   * @deprecated Type for a GeoPointField that is not stored:
-   * normalization factors, frequencies, and positions are omitted.
-   */
-  @Deprecated
-  public static final FieldType NUMERIC_TYPE_NOT_STORED = new FieldType();
-  static {
-    NUMERIC_TYPE_NOT_STORED.setTokenized(false);
-    NUMERIC_TYPE_NOT_STORED.setOmitNorms(true);
-    NUMERIC_TYPE_NOT_STORED.setIndexOptions(IndexOptions.DOCS);
-    NUMERIC_TYPE_NOT_STORED.setDocValuesType(DocValuesType.SORTED_NUMERIC);
-    NUMERIC_TYPE_NOT_STORED.setNumericType(FieldType.LegacyNumericType.LONG);
-    NUMERIC_TYPE_NOT_STORED.setNumericPrecisionStep(PRECISION_STEP);
-    NUMERIC_TYPE_NOT_STORED.freeze();
-  }
-
-  /**
-   * @deprecated Type for a stored GeoPointField:
-   * normalization factors, frequencies, and positions are omitted.
-   */
-  @Deprecated
-  public static final FieldType NUMERIC_TYPE_STORED = new FieldType();
-  static {
-    NUMERIC_TYPE_STORED.setTokenized(false);
-    NUMERIC_TYPE_STORED.setOmitNorms(true);
-    NUMERIC_TYPE_STORED.setIndexOptions(IndexOptions.DOCS);
-    NUMERIC_TYPE_STORED.setDocValuesType(DocValuesType.SORTED_NUMERIC);
-    NUMERIC_TYPE_STORED.setNumericType(FieldType.LegacyNumericType.LONG);
-    NUMERIC_TYPE_STORED.setNumericPrecisionStep(PRECISION_STEP);
-    NUMERIC_TYPE_STORED.setStored(true);
-    NUMERIC_TYPE_STORED.freeze();
-  }
-
-  /**
-   * Type for a GeoPointField that is not stored:
-   * normalization factors, frequencies, and positions are omitted.
-   */
-  public static final FieldType PREFIX_TYPE_NOT_STORED = new FieldType();
-  static {
-    PREFIX_TYPE_NOT_STORED.setTokenized(false);
-    PREFIX_TYPE_NOT_STORED.setOmitNorms(true);
-    PREFIX_TYPE_NOT_STORED.setIndexOptions(IndexOptions.DOCS);
-    PREFIX_TYPE_NOT_STORED.setDocValuesType(DocValuesType.SORTED_NUMERIC);
-    PREFIX_TYPE_NOT_STORED.freeze();
-  }
-
-  /**
-   * Type for a stored GeoPointField:
-   * normalization factors, frequencies, and positions are omitted.
-   */
-  public static final FieldType PREFIX_TYPE_STORED = new FieldType();
-  static {
-    PREFIX_TYPE_STORED.setTokenized(false);
-    PREFIX_TYPE_STORED.setOmitNorms(true);
-    PREFIX_TYPE_STORED.setIndexOptions(IndexOptions.DOCS);
-    PREFIX_TYPE_STORED.setDocValuesType(DocValuesType.SORTED_NUMERIC);
-    PREFIX_TYPE_STORED.setStored(true);
-    PREFIX_TYPE_STORED.freeze();
-  }
-
-  /** Creates a stored or un-stored GeoPointField
-   *  @param name field name
-   *  @param lon longitude double value [-180.0 : 180.0]
-   *  @param lat latitude double value [-90.0 : 90.0]
-   *  @param stored Store.YES if the content should also be stored
-   *  @throws IllegalArgumentException if the field name is null.
-   */
-  public GeoPointField(String name, double lon, double lat, Store stored) {
-    this(name, lon, lat, getFieldType(stored));
-  }
-
-  /** Creates a stored or un-stored GeoPointField using the specified {@link TermEncoding} method
-   *  @param name field name
-   *  @param lon longitude double value [-180.0 : 180.0]
-   *  @param lat latitude double value [-90.0 : 90.0]
-   *  @param termEncoding encoding type to use ({@link TermEncoding#NUMERIC} Terms, or {@link TermEncoding#PREFIX} only Terms)
-   *  @param stored Store.YES if the content should also be stored
-   *  @throws IllegalArgumentException if the field name is null.
-   */
-  @Deprecated
-  public GeoPointField(String name, double lon, double lat, TermEncoding termEncoding, Store stored) {
-    this(name, lon, lat, getFieldType(termEncoding, stored));
-  }
-
-  /** Expert: allows you to customize the {@link
-   *  FieldType}.
-   *  @param name field name
-   *  @param lon longitude double value [-180.0 : 180.0]
-   *  @param lat latitude double value [-90.0 : 90.0]
-   *  @param type customized field type: must have {@link FieldType#numericType()}
-   *         of {@link org.apache.lucene.document.FieldType.LegacyNumericType#LONG}.
-   *  @throws IllegalArgumentException if the field name or type is null, or
-   *          if the field type does not have a LONG numericType()
-   */
-  public GeoPointField(String name, double lon, double lat, FieldType type) {
-    super(name, type);
-
-    // field must be indexed
-    // todo does it make sense here to provide the ability to store a GeoPointField but not index?
-    if (type.indexOptions() == IndexOptions.NONE && type.stored() == false) {
-      throw new IllegalArgumentException("type.indexOptions() is set to NONE but type.stored() is false");
-    } else if (type.indexOptions() == IndexOptions.DOCS) {
-      if (type.docValuesType() != DocValuesType.SORTED_NUMERIC) {
-        throw new IllegalArgumentException("type.docValuesType() must be SORTED_NUMERIC but got " + type.docValuesType());
-      }
-      if (type.numericType() != null) {
-        // make sure numericType is a LONG
-        if (type.numericType() != FieldType.LegacyNumericType.LONG) {
-          throw new IllegalArgumentException("type.numericType() must be LONG but got " + type.numericType());
-        }
-      }
-    } else {
-      throw new IllegalArgumentException("type.indexOptions() must be one of NONE or DOCS but got " + type.indexOptions());
-    }
-
-    // set field data
-    fieldsData = GeoEncodingUtils.mortonHash(lon, lat);
-  }
-
-  private static FieldType getFieldType(Store stored) {
-    return getFieldType(TermEncoding.PREFIX, stored);
-  }
-
-  /**
-   * @deprecated
-   * Static helper method for returning a valid FieldType based on termEncoding and stored options
-   */
-  @Deprecated
-  private static FieldType getFieldType(TermEncoding termEncoding, Store stored) {
-    if (stored == Store.YES) {
-      return termEncoding == TermEncoding.PREFIX ? PREFIX_TYPE_STORED : NUMERIC_TYPE_STORED;
-    } else if (stored == Store.NO) {
-      return termEncoding == TermEncoding.PREFIX ? PREFIX_TYPE_NOT_STORED : NUMERIC_TYPE_NOT_STORED;
-    } else {
-      throw new IllegalArgumentException("stored option must be NO or YES but got " + stored);
-    }
-  }
-
-  @Override
-  public TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) {
-    if (fieldType().indexOptions() == IndexOptions.NONE) {
-      // not indexed
-      return null;
-    }
-
-    // if numericType is set
-    if (type.numericType() != null) {
-      // return numeric encoding
-      return super.tokenStream(analyzer, reuse);
-    }
-
-    if (reuse instanceof GeoPointTokenStream == false) {
-      reuse = new GeoPointTokenStream();
-    }
-
-    final GeoPointTokenStream gpts = (GeoPointTokenStream)reuse;
-    gpts.setGeoCode(((Number) fieldsData).longValue());
-
-    return reuse;
-  }
-
-  /** access longitude value */
-  public double getLon() {
-    return GeoEncodingUtils.mortonUnhashLon((long) fieldsData);
-  }
-
-  /** access latitude value */
-  public double getLat() {
-    return GeoEncodingUtils.mortonUnhashLat((long) fieldsData);
-  }
-
-  @Override
-  public String toString() {
-    if (fieldsData == null) {
-      return null;
-    }
-    StringBuilder sb = new StringBuilder();
-    sb.append(GeoEncodingUtils.mortonUnhashLon((long) fieldsData));
-    sb.append(',');
-    sb.append(GeoEncodingUtils.mortonUnhashLat((long) fieldsData));
-    return sb.toString();
-  }
-}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointFieldX.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointFieldX.java
new file mode 100644
index 0000000..e4a2d84
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointFieldX.java
@@ -0,0 +1,250 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.geopoint.document;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.document.FieldType;
+import org.apache.lucene.index.DocValuesType;
+import org.apache.lucene.index.IndexOptions;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.spatial.util.GeoEncodingUtils;
+
+/**
+ * <p>
+ * Field that indexes <code>latitude</code> <code>longitude</code> decimal-degree values
+ * for efficient encoding, sorting, and querying. This Geo capability is intended
+ * to provide a basic and efficient out of the box field type for indexing and
+ * querying 2 dimensional points in WGS-84 decimal degrees. An example usage is as follows:
+ *
+ * <pre class="prettyprint">
+ *  document.add(new GeoPointField(name, -96.33, 32.66, Field.Store.NO));
+ * </pre>
+ *
+ * <p>To perform simple geospatial queries against a <code>GeoPointField</code>,
+ * see {@link org.apache.lucene.spatial.geopoint.search.GeoPointInBBoxQueryX}, {@link org.apache.lucene.spatial.geopoint.search.GeoPointInPolygonQueryX},
+ * or {@link org.apache.lucene.spatial.geopoint.search.GeoPointDistanceQueryX}
+ *
+ * NOTE: This indexes only high precision encoded terms which may result in visiting a high number
+ * of terms for large queries. See LUCENE-6481 for a future improvement.
+ *
+ * @lucene.experimental
+ */
+public final class GeoPointFieldX extends Field {
+  /** encoding step value for GeoPoint prefix terms */
+  public static final int PRECISION_STEP = 9;
+
+  /**
+   * <b>Expert:</b> Optional flag to select term encoding for GeoPointField types
+   */
+  public enum TermEncoding {
+    /**
+     * encodes prefix terms only resulting in a small index and faster queries - use with
+     * {@code GeoPointTokenStream}
+     */
+    PREFIX,
+    /**
+     * @deprecated encodes prefix and full resolution terms - use with
+     * {@link org.apache.lucene.analysis.LegacyNumericTokenStream}
+     */
+    @Deprecated
+    NUMERIC
+  }
+
+  /**
+   * @deprecated Type for a GeoPointField that is not stored:
+   * normalization factors, frequencies, and positions are omitted.
+   */
+  @Deprecated
+  public static final FieldType NUMERIC_TYPE_NOT_STORED = new FieldType();
+  static {
+    NUMERIC_TYPE_NOT_STORED.setTokenized(false);
+    NUMERIC_TYPE_NOT_STORED.setOmitNorms(true);
+    NUMERIC_TYPE_NOT_STORED.setIndexOptions(IndexOptions.DOCS);
+    NUMERIC_TYPE_NOT_STORED.setDocValuesType(DocValuesType.SORTED_NUMERIC);
+    NUMERIC_TYPE_NOT_STORED.setNumericType(FieldType.LegacyNumericType.LONG);
+    NUMERIC_TYPE_NOT_STORED.setNumericPrecisionStep(PRECISION_STEP);
+    NUMERIC_TYPE_NOT_STORED.freeze();
+  }
+
+  /**
+   * @deprecated Type for a stored GeoPointField:
+   * normalization factors, frequencies, and positions are omitted.
+   */
+  @Deprecated
+  public static final FieldType NUMERIC_TYPE_STORED = new FieldType();
+  static {
+    NUMERIC_TYPE_STORED.setTokenized(false);
+    NUMERIC_TYPE_STORED.setOmitNorms(true);
+    NUMERIC_TYPE_STORED.setIndexOptions(IndexOptions.DOCS);
+    NUMERIC_TYPE_STORED.setDocValuesType(DocValuesType.SORTED_NUMERIC);
+    NUMERIC_TYPE_STORED.setNumericType(FieldType.LegacyNumericType.LONG);
+    NUMERIC_TYPE_STORED.setNumericPrecisionStep(PRECISION_STEP);
+    NUMERIC_TYPE_STORED.setStored(true);
+    NUMERIC_TYPE_STORED.freeze();
+  }
+
+  /**
+   * Type for a GeoPointField that is not stored:
+   * normalization factors, frequencies, and positions are omitted.
+   */
+  public static final FieldType PREFIX_TYPE_NOT_STORED = new FieldType();
+  static {
+    PREFIX_TYPE_NOT_STORED.setTokenized(false);
+    PREFIX_TYPE_NOT_STORED.setOmitNorms(true);
+    PREFIX_TYPE_NOT_STORED.setIndexOptions(IndexOptions.DOCS);
+    PREFIX_TYPE_NOT_STORED.setDocValuesType(DocValuesType.SORTED_NUMERIC);
+    PREFIX_TYPE_NOT_STORED.freeze();
+  }
+
+  /**
+   * Type for a stored GeoPointField:
+   * normalization factors, frequencies, and positions are omitted.
+   */
+  public static final FieldType PREFIX_TYPE_STORED = new FieldType();
+  static {
+    PREFIX_TYPE_STORED.setTokenized(false);
+    PREFIX_TYPE_STORED.setOmitNorms(true);
+    PREFIX_TYPE_STORED.setIndexOptions(IndexOptions.DOCS);
+    PREFIX_TYPE_STORED.setDocValuesType(DocValuesType.SORTED_NUMERIC);
+    PREFIX_TYPE_STORED.setStored(true);
+    PREFIX_TYPE_STORED.freeze();
+  }
+
+  /** Creates a stored or un-stored GeoPointField
+   *  @param name field name
+   *  @param lat latitude double value [-90.0 : 90.0]
+   *  @param lon longitude double value [-180.0 : 180.0]
+   *  @param stored Store.YES if the content should also be stored
+   *  @throws IllegalArgumentException if the field name is null.
+   */
+  public GeoPointFieldX(String name, double lat, double lon, Store stored) {
+    this(name, lat, lon, getFieldType(stored));
+  }
+
+  /** Creates a stored or un-stored GeoPointField using the specified {@link TermEncoding} method
+   *  @param name field name
+   *  @param lat latitude double value [-90.0 : 90.0]
+   *  @param lon longitude double value [-180.0 : 180.0]
+   *  @param termEncoding encoding type to use ({@link TermEncoding#NUMERIC} Terms, or {@link TermEncoding#PREFIX} only Terms)
+   *  @param stored Store.YES if the content should also be stored
+   *  @throws IllegalArgumentException if the field name is null.
+   */
+  @Deprecated
+  public GeoPointFieldX(String name, double lat, double lon, TermEncoding termEncoding, Store stored) {
+    this(name, lat, lon, getFieldType(termEncoding, stored));
+  }
+
+  /** Expert: allows you to customize the {@link
+   *  FieldType}.
+   *  @param name field name
+   *  @param lat latitude double value [-90.0 : 90.0]
+   *  @param lon longitude double value [-180.0 : 180.0]
+   *  @param type customized field type: must have {@link FieldType#numericType()}
+   *         of {@link org.apache.lucene.document.FieldType.LegacyNumericType#LONG}.
+   *  @throws IllegalArgumentException if the field name or type is null, or
+   *          if the field type does not have a LONG numericType()
+   */
+  public GeoPointFieldX(String name, double lat, double lon, FieldType type) {
+    super(name, type);
+
+    // field must be indexed
+    // todo does it make sense here to provide the ability to store a GeoPointField but not index?
+    if (type.indexOptions() == IndexOptions.NONE && type.stored() == false) {
+      throw new IllegalArgumentException("type.indexOptions() is set to NONE but type.stored() is false");
+    } else if (type.indexOptions() == IndexOptions.DOCS) {
+      if (type.docValuesType() != DocValuesType.SORTED_NUMERIC) {
+        throw new IllegalArgumentException("type.docValuesType() must be SORTED_NUMERIC but got " + type.docValuesType());
+      }
+      if (type.numericType() != null) {
+        // make sure numericType is a LONG
+        if (type.numericType() != FieldType.LegacyNumericType.LONG) {
+          throw new IllegalArgumentException("type.numericType() must be LONG but got " + type.numericType());
+        }
+      }
+    } else {
+      throw new IllegalArgumentException("type.indexOptions() must be one of NONE or DOCS but got " + type.indexOptions());
+    }
+
+    // set field data
+    fieldsData = GeoEncodingUtils.mortonHashX(lat, lon);
+  }
+
+  private static FieldType getFieldType(Store stored) {
+    return getFieldType(TermEncoding.PREFIX, stored);
+  }
+
+  /**
+   * @deprecated
+   * Static helper method for returning a valid FieldType based on termEncoding and stored options
+   */
+  @Deprecated
+  private static FieldType getFieldType(TermEncoding termEncoding, Store stored) {
+    if (stored == Store.YES) {
+      return termEncoding == TermEncoding.PREFIX ? PREFIX_TYPE_STORED : NUMERIC_TYPE_STORED;
+    } else if (stored == Store.NO) {
+      return termEncoding == TermEncoding.PREFIX ? PREFIX_TYPE_NOT_STORED : NUMERIC_TYPE_NOT_STORED;
+    } else {
+      throw new IllegalArgumentException("stored option must be NO or YES but got " + stored);
+    }
+  }
+
+  @Override
+  public TokenStream tokenStream(Analyzer analyzer, TokenStream reuse) {
+    if (fieldType().indexOptions() == IndexOptions.NONE) {
+      // not indexed
+      return null;
+    }
+
+    // if numericType is set
+    if (type.numericType() != null) {
+      // return numeric encoding
+      return super.tokenStream(analyzer, reuse);
+    }
+
+    if (reuse instanceof GeoPointTokenStream == false) {
+      reuse = new GeoPointTokenStream();
+    }
+
+    final GeoPointTokenStream gpts = (GeoPointTokenStream)reuse;
+    gpts.setGeoCode(((Number) fieldsData).longValue());
+
+    return reuse;
+  }
+
+  /** access latitude value */
+  public double getLat() {
+    return GeoEncodingUtils.mortonUnhashLat((long) fieldsData);
+  }
+
+  /** access longitude value */
+  public double getLon() {
+    return GeoEncodingUtils.mortonUnhashLon((long) fieldsData);
+  }
+
+  @Override
+  public String toString() {
+    if (fieldsData == null) {
+      return null;
+    }
+    StringBuilder sb = new StringBuilder();
+    sb.append(GeoEncodingUtils.mortonUnhashLat((long) fieldsData));
+    sb.append(',');
+    sb.append(GeoEncodingUtils.mortonUnhashLon((long) fieldsData));
+    return sb.toString();
+  }
+}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointTokenStream.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointTokenStream.java
index 4a70ea3..ea9ed82 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointTokenStream.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/document/GeoPointTokenStream.java
@@ -31,7 +31,7 @@ import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefBuilder;
 import org.apache.lucene.spatial.util.GeoEncodingUtils;
 
-import static org.apache.lucene.spatial.geopoint.document.GeoPointField.PRECISION_STEP;
+import static org.apache.lucene.spatial.geopoint.document.GeoPointFieldX.PRECISION_STEP;
 
 /**
  * <b>Expert:</b> This class provides a {@link TokenStream} used by {@link GeoPointField}
@@ -56,18 +56,18 @@ import static org.apache.lucene.spatial.geopoint.document.GeoPointField.PRECISIO
  *
  * <pre class="prettyprint">
  *   // using prefix terms
- *   GeoPointField geoPointField = new GeoPointField(fieldName1, lon, lat, GeoPointField.PREFIX_TYPE_NOT_STORED);
+ *   GeoPointField geoPointField = new GeoPointField(fieldName1, lat, lon, GeoPointField.PREFIX_TYPE_NOT_STORED);
  *   document.add(geoPointField);
  *
  *   // query by bounding box (default uses TermEncoding.PREFIX)
  *   Query q = new GeoPointInBBoxQuery(fieldName1, minLon, minLat, maxLon, maxLat);
  *
  *   // using numeric terms
- *   geoPointField = new GeoPointField(fieldName2, lon, lat, GeoPointField.NUMERIC_TYPE_NOT_STORED);
+ *   geoPointField = new GeoPointField(fieldName2, lat, lon, GeoPointField.NUMERIC_TYPE_NOT_STORED);
  *   document.add(geoPointField);
  *
  *   // query by distance (requires TermEncoding.NUMERIC)
- *   q = new GeoPointDistanceQuery(fieldName2, TermEncoding.NUMERIC, centerLon, centerLat, radiusMeters);
+ *   q = new GeoPointDistanceQuery(fieldName2, TermEncoding.NUMERIC, centerLat, centerLon, radiusMeters);
  * </pre>
  *
  * @lucene.experimental
@@ -230,4 +230,4 @@ final class GeoPointTokenStream extends TokenStream {
   public String toString() {
     return getClass().getSimpleName() + "(precisionStep=" + PRECISION_STEP + " shift=" + geoPointTermAtt.getShift() + ")";
   }
-}
\ No newline at end of file
+}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQuery.java
deleted file mode 100644
index a513b3d..0000000
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQuery.java
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.geopoint.search;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
-import org.apache.lucene.spatial.util.GeoDistanceUtils;
-import org.apache.lucene.spatial.util.GeoRect;
-import org.apache.lucene.spatial.util.GeoUtils;
-
-/** Implements a simple point distance query on a GeoPoint field. This is based on
- * {@link GeoPointInBBoxQuery} and is implemented using a two phase approach. First,
- * like {@code GeoPointInBBoxQueryImpl} candidate terms are queried using the numeric ranges based on
- * the morton codes of the min and max lat/lon pairs that intersect the boundary of the point-radius
- * circle. Terms
- * passing this initial filter are then passed to a secondary {@code postFilter} method that verifies whether the
- * decoded lat/lon point fall within the specified query distance (see {@link org.apache.lucene.util.SloppyMath#haversinMeters(double, double, double, double)}.
- * All morton value comparisons are subject to the same precision tolerance defined in
- * {@value org.apache.lucene.spatial.util.GeoEncodingUtils#TOLERANCE} and distance comparisons are subject to the accuracy of the
- * haversine formula (from R.W. Sinnott, "Virtues of the Haversine", Sky and Telescope, vol. 68, no. 2, 1984, p. 159)
- *
- * <p>Note: This query currently uses haversine which is a sloppy distance calculation (see above reference). For large
- * queries one can expect upwards of 400m error. Vincenty shrinks this to ~40m error but pays a penalty for computing
- * using the spheroid
- *
- * @lucene.experimental */
-public class GeoPointDistanceQuery extends GeoPointInBBoxQuery {
-  /** longitude value (in degrees) for query location */
-  protected final double centerLon;
-  /** latitude value (in degrees) for query location */
-  protected final double centerLat;
-  /** distance (in meters) from lon, lat center location */
-  protected final double radiusMeters;
-
-  /**
-   * Constructs a Query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointField} types within a
-   * distance (in meters) from a given point
-   **/
-  public GeoPointDistanceQuery(final String field, final double centerLon, final double centerLat, final double radiusMeters) {
-    this(field, TermEncoding.PREFIX, centerLon, centerLat, radiusMeters);
-  }
-
-  /**
-   * Constructs a Query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointField} types within a
-   * distance (in meters) from a given point. Accepts optional
-   * {@link org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding} parameter
-   **/
-  public GeoPointDistanceQuery(final String field, final TermEncoding termEncoding, final double centerLon, final double centerLat, final double radiusMeters) {
-    this(field, termEncoding, GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters), centerLon, centerLat, radiusMeters);
-  }
-
-  private GeoPointDistanceQuery(final String field, final TermEncoding termEncoding, final GeoRect bbox, final double centerLon,
-                                final double centerLat, final double radiusMeters) {
-    super(field, termEncoding, bbox.minLon, bbox.minLat, bbox.maxLon, bbox.maxLat);
-    {
-      // check longitudinal overlap (restrict distance to maximum longitudinal radius)
-      // todo this restriction technically shouldn't be needed,
-      // its only purpose is to ensure the bounding box doesn't self overlap.
-      final double maxRadius = GeoDistanceUtils.maxRadialDistanceMeters(centerLon, centerLat);
-      if (radiusMeters > maxRadius) {
-        throw new IllegalArgumentException("radiusMeters " + radiusMeters + " exceeds maxRadius [" + maxRadius
-            + "] at location [" + centerLon + " " + centerLat + "]");
-      }
-    }
-
-    if (GeoUtils.isValidLon(centerLon) == false) {
-      throw new IllegalArgumentException("invalid centerLon " + centerLon);
-    }
-
-    if (GeoUtils.isValidLat(centerLat) == false) {
-      throw new IllegalArgumentException("invalid centerLat " + centerLat);
-    }
-
-    if (radiusMeters <= 0.0) {
-      throw new IllegalArgumentException("invalid radiusMeters " + radiusMeters);
-    }
-
-    this.centerLon = centerLon;
-    this.centerLat = centerLat;
-    this.radiusMeters = radiusMeters;
-  }
-
-  @Override
-  public Query rewrite(IndexReader reader) {
-    // query crosses dateline; split into left and right queries
-    if (maxLon < minLon) {
-      BooleanQuery.Builder bqb = new BooleanQuery.Builder();
-
-      // unwrap the longitude iff outside the specified min/max lon range
-      double unwrappedLon = centerLon;
-      if (unwrappedLon > maxLon) {
-        // unwrap left
-        unwrappedLon += -360.0D;
-      }
-      GeoPointDistanceQueryImpl left = new GeoPointDistanceQueryImpl(field, termEncoding, this, unwrappedLon,
-          new GeoRect(GeoUtils.MIN_LON_INCL, maxLon, minLat, maxLat));
-      bqb.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));
-
-      if (unwrappedLon < maxLon) {
-        // unwrap right
-        unwrappedLon += 360.0D;
-      }
-      GeoPointDistanceQueryImpl right = new GeoPointDistanceQueryImpl(field, termEncoding, this, unwrappedLon,
-          new GeoRect(minLon, GeoUtils.MAX_LON_INCL, minLat, maxLat));
-      bqb.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));
-
-      return bqb.build();
-    }
-    return new GeoPointDistanceQueryImpl(field, termEncoding, this, centerLon,
-        new GeoRect(this.minLon, this.maxLon, this.minLat, this.maxLat));
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (!(o instanceof GeoPointDistanceQuery)) return false;
-    if (!super.equals(o)) return false;
-
-    GeoPointDistanceQuery that = (GeoPointDistanceQuery) o;
-
-    if (Double.compare(that.centerLat, centerLat) != 0) return false;
-    if (Double.compare(that.centerLon, centerLon) != 0) return false;
-    if (Double.compare(that.radiusMeters, radiusMeters) != 0) return false;
-
-    return true;
-  }
-
-  @Override
-  public int hashCode() {
-    int result = super.hashCode();
-    long temp;
-    temp = Double.doubleToLongBits(centerLon);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(centerLat);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(radiusMeters);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
-    return result;
-  }
-
-  @Override
-  public String toString(String field) {
-    final StringBuilder sb = new StringBuilder();
-    sb.append(getClass().getSimpleName());
-    sb.append(':');
-    if (!this.field.equals(field)) {
-      sb.append(" field=");
-      sb.append(this.field);
-      sb.append(':');
-    }
-    return sb.append( " Center: [")
-        .append(centerLon)
-        .append(',')
-        .append(centerLat)
-        .append(']')
-        .append(" Distance: ")
-        .append(radiusMeters)
-        .append(" meters")
-        .append("]")
-        .toString();
-  }
-
-  /** getter method for center longitude value */
-  public double getCenterLon() {
-    return this.centerLon;
-  }
-
-  /** getter method for center latitude value */
-  public double getCenterLat() {
-    return this.centerLat;
-  }
-
-  /** getter method for distance value (in meters) */
-  public double getRadiusMeters() {
-    return this.radiusMeters;
-  }
-}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryImpl.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryImpl.java
index 6a54e23..a744e6c 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryImpl.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryImpl.java
@@ -17,7 +17,7 @@
 package org.apache.lucene.spatial.geopoint.search;
 
 import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX.TermEncoding;
 import org.apache.lucene.spatial.util.GeoRect;
 import org.apache.lucene.spatial.util.GeoRelationUtils;
 import org.apache.lucene.util.SloppyMath;
@@ -26,13 +26,13 @@ import org.apache.lucene.util.SloppyMath;
  *
  *    @lucene.experimental
  */
-final class GeoPointDistanceQueryImpl extends GeoPointInBBoxQueryImpl {
-  private final GeoPointDistanceQuery distanceQuery;
+final class GeoPointDistanceQueryImpl extends GeoPointInBBoxQueryImplX {
+  private final GeoPointDistanceQueryX distanceQuery;
   private final double centerLon;
 
-  GeoPointDistanceQueryImpl(final String field, final TermEncoding termEncoding, final GeoPointDistanceQuery q,
+  GeoPointDistanceQueryImpl(final String field, final TermEncoding termEncoding, final GeoPointDistanceQueryX q,
                             final double centerLonUnwrapped, final GeoRect bbox) {
-    super(field, termEncoding, bbox.minLon, bbox.minLat, bbox.maxLon, bbox.maxLat);
+    super(field, termEncoding, bbox.minLat, bbox.maxLat, bbox.minLon, bbox.maxLon);
     distanceQuery = q;
     centerLon = centerLonUnwrapped;
   }
@@ -53,20 +53,21 @@ final class GeoPointDistanceQueryImpl extends GeoPointInBBoxQueryImpl {
     }
 
     @Override
-    protected boolean cellCrosses(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectCrossesCircle(minLon, minLat, maxLon, maxLat,
-          centerLon, distanceQuery.centerLat, distanceQuery.radiusMeters, true);
+    protected boolean cellCrossesX(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectCrossesCircle(minLat, maxLat, minLon, maxLon,
+                                                distanceQuery.centerLat, centerLon, distanceQuery.radiusMeters, true);
     }
 
     @Override
-    protected boolean cellWithin(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectWithinCircle(minLon, minLat, maxLon, maxLat,
-          centerLon, distanceQuery.centerLat, distanceQuery.radiusMeters, true);
+    protected boolean cellWithinX(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectWithinCircle(minLat, maxLat, minLon, maxLon,
+                                               distanceQuery.centerLat, centerLon,
+                                               distanceQuery.radiusMeters, true);
     }
 
     @Override
-    protected boolean cellIntersectsShape(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return cellCrosses(minLon, minLat, maxLon, maxLat);
+    protected boolean cellIntersectsShapeX(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return cellCrossesX(minLat, maxLat, minLon, maxLon);
     }
 
     /**
@@ -76,7 +77,7 @@ final class GeoPointDistanceQueryImpl extends GeoPointInBBoxQueryImpl {
      * {@link org.apache.lucene.util.SloppyMath#haversinMeters(double, double, double, double)} method.
      */
     @Override
-    protected boolean postFilter(final double lon, final double lat) {
+    protected boolean postFilterX(final double lat, final double lon) {
       return SloppyMath.haversinMeters(distanceQuery.centerLat, centerLon, lat, lon) <= distanceQuery.radiusMeters;
     }
   }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryX.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryX.java
new file mode 100644
index 0000000..6365813
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceQueryX.java
@@ -0,0 +1,194 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.geopoint.search;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX.TermEncoding;
+import org.apache.lucene.spatial.util.GeoDistanceUtils;
+import org.apache.lucene.spatial.util.GeoRect;
+import org.apache.lucene.spatial.util.GeoUtils;
+
+/** Implements a simple point distance query on a GeoPoint field. This is based on
+ * {@link GeoPointInBBoxQueryX} and is implemented using a two phase approach. First,
+ * like {@code GeoPointInBBoxQueryImpl} candidate terms are queried using the numeric ranges based on
+ * the morton codes of the min and max lat/lon pairs that intersect the boundary of the point-radius
+ * circle. Terms
+ * passing this initial filter are then passed to a secondary {@code postFilter} method that verifies whether the
+ * decoded lat/lon point fall within the specified query distance (see {@link org.apache.lucene.util.SloppyMath#haversinMeters(double, double, double, double)}.
+ * All morton value comparisons are subject to the same precision tolerance defined in
+ * {@value org.apache.lucene.spatial.util.GeoEncodingUtils#TOLERANCE} and distance comparisons are subject to the accuracy of the
+ * haversine formula (from R.W. Sinnott, "Virtues of the Haversine", Sky and Telescope, vol. 68, no. 2, 1984, p. 159)
+ *
+ * <p>Note: This query currently uses haversine which is a sloppy distance calculation (see above reference). For large
+ * queries one can expect upwards of 400m error. Vincenty shrinks this to ~40m error but pays a penalty for computing
+ * using the spheroid
+ *
+ * @lucene.experimental */
+public class GeoPointDistanceQueryX extends GeoPointInBBoxQueryX {
+  /** latitude value (in degrees) for query location */
+  protected final double centerLat;
+  /** longitude value (in degrees) for query location */
+  protected final double centerLon;
+  /** distance (in meters) from lat, lon center location */
+  protected final double radiusMeters;
+
+  /**
+   * Constructs a Query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointFieldX} types within a
+   * distance (in meters) from a given point
+   **/
+  public GeoPointDistanceQueryX(final String field, final double centerLat, final double centerLon, final double radiusMeters) {
+    this(field, TermEncoding.PREFIX, centerLat, centerLon, radiusMeters);
+  }
+
+  /**
+   * Constructs a Query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointFieldX} types within a
+   * distance (in meters) from a given point. Accepts optional
+   * {@link org.apache.lucene.spatial.geopoint.document.GeoPointFieldX.TermEncoding} parameter
+   **/
+  public GeoPointDistanceQueryX(final String field, final TermEncoding termEncoding, final double centerLat, final double centerLon, final double radiusMeters) {
+    this(field, termEncoding, GeoUtils.circleToBBox(centerLat, centerLon, radiusMeters), centerLat, centerLon, radiusMeters);
+  }
+
+  private GeoPointDistanceQueryX(final String field, final TermEncoding termEncoding, final GeoRect bbox,
+                                 final double centerLat, final double centerLon, final double radiusMeters) {
+    super(field, termEncoding, bbox.minLat, bbox.maxLat, bbox.minLon, bbox.maxLon);
+    {
+      // check longitudinal overlap (restrict distance to maximum longitudinal radius)
+      // todo this restriction technically shouldn't be needed,
+      // its only purpose is to ensure the bounding box doesn't self overlap.
+      final double maxRadius = GeoDistanceUtils.maxRadialDistanceMeters(centerLat, centerLon);
+      if (radiusMeters > maxRadius) {
+        throw new IllegalArgumentException("radiusMeters " + radiusMeters + " exceeds maxRadius [" + maxRadius
+            + "] at location [" + centerLat + " " + centerLon + "]");
+      }
+    }
+
+    if (GeoUtils.isValidLat(centerLat) == false) {
+      throw new IllegalArgumentException("invalid centerLat " + centerLat);
+    }
+
+    if (GeoUtils.isValidLon(centerLon) == false) {
+      throw new IllegalArgumentException("invalid centerLon " + centerLon);
+    }
+
+    if (radiusMeters <= 0.0) {
+      throw new IllegalArgumentException("invalid radiusMeters " + radiusMeters);
+    }
+
+    this.centerLat = centerLat;
+    this.centerLon = centerLon;
+    this.radiusMeters = radiusMeters;
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) {
+    // query crosses dateline; split into left and right queries
+    if (maxLon < minLon) {
+      BooleanQuery.Builder bqb = new BooleanQuery.Builder();
+
+      // unwrap the longitude iff outside the specified min/max lon range
+      double unwrappedLon = centerLon;
+      if (unwrappedLon > maxLon) {
+        // unwrap left
+        unwrappedLon += -360.0D;
+      }
+      GeoPointDistanceQueryImpl left = new GeoPointDistanceQueryImpl(field, termEncoding, this, unwrappedLon,
+                                                                     new GeoRect(minLat, maxLat, GeoUtils.MIN_LON_INCL, maxLon));
+      bqb.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));
+
+      if (unwrappedLon < maxLon) {
+        // unwrap right
+        unwrappedLon += 360.0D;
+      }
+      GeoPointDistanceQueryImpl right = new GeoPointDistanceQueryImpl(field, termEncoding, this, unwrappedLon,
+                                                                      new GeoRect(minLat, maxLat, minLon, GeoUtils.MAX_LON_INCL));
+      bqb.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));
+
+      return bqb.build();
+    }
+    return new GeoPointDistanceQueryImpl(field, termEncoding, this, centerLon,
+                                         new GeoRect(this.minLat, this.maxLat, this.minLon, this.maxLon));
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof GeoPointDistanceQueryX)) return false;
+    if (!super.equals(o)) return false;
+
+    GeoPointDistanceQueryX that = (GeoPointDistanceQueryX) o;
+
+    if (Double.compare(that.centerLat, centerLat) != 0) return false;
+    if (Double.compare(that.centerLon, centerLon) != 0) return false;
+    if (Double.compare(that.radiusMeters, radiusMeters) != 0) return false;
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = super.hashCode();
+    long temp;
+    temp = Double.doubleToLongBits(centerLon);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(centerLat);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(radiusMeters);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    return result;
+  }
+
+  @Override
+  public String toString(String field) {
+    final StringBuilder sb = new StringBuilder();
+    sb.append(getClass().getSimpleName());
+    sb.append(':');
+    if (!this.field.equals(field)) {
+      sb.append(" field=");
+      sb.append(this.field);
+      sb.append(':');
+    }
+    return sb.append( " Center: [")
+        .append(centerLat)
+        .append(',')
+        .append(centerLon)
+        .append(']')
+        .append(" Distance: ")
+        .append(radiusMeters)
+        .append(" meters")
+        .append("]")
+        .toString();
+  }
+
+  /** getter method for center longitude value */
+  public double getCenterLon() {
+    return this.centerLon;
+  }
+
+  /** getter method for center latitude value */
+  public double getCenterLat() {
+    return this.centerLat;
+  }
+
+  /** getter method for distance value (in meters) */
+  public double getRadiusMeters() {
+    return this.radiusMeters;
+  }
+}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceRangeQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceRangeQuery.java
deleted file mode 100644
index f24aa6a..0000000
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceRangeQuery.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.geopoint.search;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
-
-/** Implements a point distance range query on a GeoPoint field. This is based on
- * {@code org.apache.lucene.spatial.geopoint.search.GeoPointDistanceQuery} and is implemented using a
- * {@code org.apache.lucene.search.BooleanClause.MUST_NOT} clause to exclude any points that fall within
- * minRadiusMeters from the provided point.
- *
- *    @lucene.experimental
- */
-public final class GeoPointDistanceRangeQuery extends GeoPointDistanceQuery {
-  /** minimum distance range (in meters) from lon, lat center location, maximum is inherited */
-  protected final double minRadiusMeters;
-
-  /**
-   * Constructs a query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointField} types within a minimum / maximum
-   * distance (in meters) range from a given point
-   */
-  public GeoPointDistanceRangeQuery(final String field, final double centerLon, final double centerLat,
-                                    final double minRadiusMeters, final double maxRadiusMeters) {
-    this(field, TermEncoding.PREFIX, centerLon, centerLat, minRadiusMeters, maxRadiusMeters);
-  }
-
-  /**
-   * Constructs a query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointField} types within a minimum / maximum
-   * distance (in meters) range from a given point. Accepts an optional
-   * {@link org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding}
-   */
-  public GeoPointDistanceRangeQuery(final String field, final TermEncoding termEncoding, final double centerLon, final double centerLat,
-                                    final double minRadiusMeters, final double maxRadius) {
-    super(field, termEncoding, centerLon, centerLat, maxRadius);
-    this.minRadiusMeters = minRadiusMeters;
-  }
-
-  @Override
-  public Query rewrite(IndexReader reader) {
-    Query q = super.rewrite(reader);
-    if (minRadiusMeters == 0.0) {
-      return q;
-    }
-
-    // add an exclusion query
-    BooleanQuery.Builder bqb = new BooleanQuery.Builder();
-
-    // create a new exclusion query
-    GeoPointDistanceQuery exclude = new GeoPointDistanceQuery(field, termEncoding, centerLon, centerLat, minRadiusMeters);
-    // full map search
-//    if (radiusMeters >= GeoProjectionUtils.SEMIMINOR_AXIS) {
-//      bqb.add(new BooleanClause(new GeoPointInBBoxQuery(this.field, -180.0, -90.0, 180.0, 90.0), BooleanClause.Occur.MUST));
-//    } else {
-      bqb.add(new BooleanClause(q, BooleanClause.Occur.MUST));
-//    }
-    bqb.add(new BooleanClause(exclude, BooleanClause.Occur.MUST_NOT));
-
-    return bqb.build();
-  }
-
-  @Override
-  public String toString(String field) {
-    final StringBuilder sb = new StringBuilder();
-    sb.append(getClass().getSimpleName());
-    sb.append(':');
-    if (!this.field.equals(field)) {
-      sb.append(" field=");
-      sb.append(this.field);
-      sb.append(':');
-    }
-    return sb.append( " Center: [")
-        .append(centerLon)
-        .append(',')
-        .append(centerLat)
-        .append(']')
-        .append(" From Distance: ")
-        .append(minRadiusMeters)
-        .append(" m")
-        .append(" To Distance: ")
-        .append(radiusMeters)
-        .append(" m")
-        .append(" Lower Left: [")
-        .append(minLon)
-        .append(',')
-        .append(minLat)
-        .append(']')
-        .append(" Upper Right: [")
-        .append(maxLon)
-        .append(',')
-        .append(maxLat)
-        .append("]")
-        .toString();
-  }
-
-  /** getter method for minimum distance */
-  public double getMinRadiusMeters() {
-    return this.minRadiusMeters;
-  }
-
-  /** getter method for maximum distance */
-  public double getMaxRadiusMeters() {
-    return this.radiusMeters;
-  }
-}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceRangeQueryX.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceRangeQueryX.java
new file mode 100644
index 0000000..23f08c4
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointDistanceRangeQueryX.java
@@ -0,0 +1,122 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.geopoint.search;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX.TermEncoding;
+
+/** Implements a point distance range query on a GeoPoint field. This is based on
+ * {@code org.apache.lucene.spatial.geopoint.search.GeoPointDistanceQuery} and is implemented using a
+ * {@code org.apache.lucene.search.BooleanClause.MUST_NOT} clause to exclude any points that fall within
+ * minRadiusMeters from the provided point.
+ *
+ *    @lucene.experimental
+ */
+public final class GeoPointDistanceRangeQueryX extends GeoPointDistanceQueryX {
+  /** minimum distance range (in meters) from lon, lat center location, maximum is inherited */
+  protected final double minRadiusMeters;
+
+  /**
+   * Constructs a query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointFieldX} types within a minimum / maximum
+   * distance (in meters) range from a given point
+   */
+  public GeoPointDistanceRangeQueryX(final String field, final double centerLat, final double centerLon,
+                                     final double minRadiusMeters, final double maxRadiusMeters) {
+    this(field, TermEncoding.PREFIX, centerLat, centerLon, minRadiusMeters, maxRadiusMeters);
+  }
+
+  /**
+   * Constructs a query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointFieldX} types within a minimum / maximum
+   * distance (in meters) range from a given point. Accepts an optional
+   * {@link org.apache.lucene.spatial.geopoint.document.GeoPointFieldX.TermEncoding}
+   */
+  public GeoPointDistanceRangeQueryX(final String field, final TermEncoding termEncoding, final double centerLat, final double centerLon,
+                                     final double minRadiusMeters, final double maxRadius) {
+    super(field, termEncoding, centerLat, centerLon, maxRadius);
+    this.minRadiusMeters = minRadiusMeters;
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) {
+    Query q = super.rewrite(reader);
+    if (minRadiusMeters == 0.0) {
+      return q;
+    }
+
+    // add an exclusion query
+    BooleanQuery.Builder bqb = new BooleanQuery.Builder();
+
+    // create a new exclusion query
+    GeoPointDistanceQueryX exclude = new GeoPointDistanceQueryX(field, termEncoding, centerLat, centerLon, minRadiusMeters);
+    // full map search
+//    if (radiusMeters >= GeoProjectionUtils.SEMIMINOR_AXIS) {
+//      bqb.add(new BooleanClause(new GeoPointInBBoxQuery(this.field, -180.0, -90.0, 180.0, 90.0), BooleanClause.Occur.MUST));
+//    } else {
+      bqb.add(new BooleanClause(q, BooleanClause.Occur.MUST));
+//    }
+    bqb.add(new BooleanClause(exclude, BooleanClause.Occur.MUST_NOT));
+
+    return bqb.build();
+  }
+
+  @Override
+  public String toString(String field) {
+    final StringBuilder sb = new StringBuilder();
+    sb.append(getClass().getSimpleName());
+    sb.append(':');
+    if (!this.field.equals(field)) {
+      sb.append(" field=");
+      sb.append(this.field);
+      sb.append(':');
+    }
+    return sb.append( " Center: [")
+        .append(centerLat)
+        .append(',')
+        .append(centerLon)
+        .append(']')
+        .append(" From Distance: ")
+        .append(minRadiusMeters)
+        .append(" m")
+        .append(" To Distance: ")
+        .append(radiusMeters)
+        .append(" m")
+        .append(" Lower Left: [")
+        .append(minLat)
+        .append(',')
+        .append(minLon)
+        .append(']')
+        .append(" Upper Right: [")
+        .append(maxLat)
+        .append(',')
+        .append(maxLon)
+        .append("]")
+        .toString();
+  }
+
+  /** getter method for minimum distance */
+  public double getMinRadiusMeters() {
+    return this.minRadiusMeters;
+  }
+
+  /** getter method for maximum distance */
+  public double getMaxRadiusMeters() {
+    return this.radiusMeters;
+  }
+}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQuery.java
deleted file mode 100644
index 32c0aec..0000000
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQuery.java
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.geopoint.search;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.FieldValueQuery;
-import org.apache.lucene.search.LegacyNumericRangeQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
-import org.apache.lucene.spatial.util.GeoUtils;
-
-/** Implements a simple bounding box query on a GeoPoint field. This is inspired by
- * {@link LegacyNumericRangeQuery} and is implemented using a
- * two phase approach. First, candidate terms are queried using a numeric
- * range based on the morton codes of the min and max lat/lon pairs. Terms
- * passing this initial filter are passed to a final check that verifies whether
- * the decoded lat/lon falls within (or on the boundary) of the query bounding box.
- * The value comparisons are subject to a precision tolerance defined in
- * {@value org.apache.lucene.spatial.util.GeoEncodingUtils#TOLERANCE}
- *
- * NOTES:
- *    1.  All latitude/longitude values must be in decimal degrees.
- *    2.  Complex computational geometry (e.g., dateline wrapping) is not supported
- *    3.  For more advanced GeoSpatial indexing and query operations see spatial module
- *    4.  This is well suited for small rectangles, large bounding boxes may result
- *        in many terms, depending whether the bounding box falls on the boundary of
- *        many cells (degenerate case)
- *
- * @lucene.experimental
- */
-public class GeoPointInBBoxQuery extends Query {
-  /** field name */
-  protected final String field;
-  /** minimum longitude value (in degrees) */
-  protected final double minLon;
-  /** minimum latitude value (in degrees) */
-  protected final double minLat;
-  /** maximum longitude value (in degrees) */
-  protected final double maxLon;
-  /** maximum latitude value (in degrees) */
-  protected final double maxLat;
-  /** term encoding enum to define how the points are encoded (PREFIX or NUMERIC) */
-  protected final TermEncoding termEncoding;
-
-  /**
-   * Constructs a query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointField} types that fall within a
-   * defined bounding box
-   */
-  public GeoPointInBBoxQuery(final String field, final double minLon, final double minLat, final double maxLon, final double maxLat) {
-    this(field, TermEncoding.PREFIX, minLon, minLat, maxLon, maxLat);
-  }
-
-  /**
-   * Constructs a query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointField} types that fall within a
-   * defined bounding box. Accepts optional {@link org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding} parameter
-   */
-  public GeoPointInBBoxQuery(final String field, final TermEncoding termEncoding, final double minLon, final double minLat, final double maxLon, final double maxLat) {
-    this.field = field;
-    this.minLon = minLon;
-    this.minLat = minLat;
-    this.maxLon = maxLon;
-    this.maxLat = maxLat;
-    this.termEncoding = termEncoding;
-  }
-
-  @Override
-  public Query rewrite(IndexReader reader) {
-    // short-circuit to match all if specifying the whole map
-    if (minLon == GeoUtils.MIN_LON_INCL && maxLon == GeoUtils.MAX_LON_INCL
-        && minLat == GeoUtils.MIN_LAT_INCL && maxLat == GeoUtils.MAX_LAT_INCL) {
-      // FieldValueQuery is valid since DocValues are *required* for GeoPointField
-      return new FieldValueQuery(field);
-    }
-
-    if (maxLon < minLon) {
-      BooleanQuery.Builder bqb = new BooleanQuery.Builder();
-
-      GeoPointInBBoxQueryImpl left = new GeoPointInBBoxQueryImpl(field, termEncoding, -180.0D, minLat, maxLon, maxLat);
-      bqb.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));
-      GeoPointInBBoxQueryImpl right = new GeoPointInBBoxQueryImpl(field, termEncoding, minLon, minLat, 180.0D, maxLat);
-      bqb.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));
-      return bqb.build();
-    }
-    return new GeoPointInBBoxQueryImpl(field, termEncoding, minLon, minLat, maxLon, maxLat);
-  }
-
-  @Override
-  public String toString(String field) {
-    final StringBuilder sb = new StringBuilder();
-    sb.append(getClass().getSimpleName());
-    sb.append(':');
-    if (!this.field.equals(field)) {
-      sb.append(" field=");
-      sb.append(this.field);
-      sb.append(':');
-    }
-    return sb.append(" Lower Left: [")
-        .append(minLon)
-        .append(',')
-        .append(minLat)
-        .append(']')
-        .append(" Upper Right: [")
-        .append(maxLon)
-        .append(',')
-        .append(maxLat)
-        .append("]")
-        .toString();
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (!(o instanceof GeoPointInBBoxQuery)) return false;
-    if (!super.equals(o)) return false;
-
-    GeoPointInBBoxQuery that = (GeoPointInBBoxQuery) o;
-
-    if (Double.compare(that.maxLat, maxLat) != 0) return false;
-    if (Double.compare(that.maxLon, maxLon) != 0) return false;
-    if (Double.compare(that.minLat, minLat) != 0) return false;
-    if (Double.compare(that.minLon, minLon) != 0) return false;
-    if (!field.equals(that.field)) return false;
-
-    return true;
-  }
-
-  @Override
-  public int hashCode() {
-    int result = super.hashCode();
-    long temp;
-    result = 31 * result + field.hashCode();
-    temp = Double.doubleToLongBits(minLon);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(minLat);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(maxLon);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(maxLat);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
-    return result;
-  }
-
-  /** getter method for retrieving the field name */
-  public final String getField() {
-    return this.field;
-  }
-
-  /** getter method for retrieving the minimum longitude (in degrees) */
-  public final double getMinLon() {
-    return this.minLon;
-  }
-
-  /** getter method for retrieving the minimum latitude (in degrees) */
-  public final double getMinLat() {
-    return this.minLat;
-  }
-
-  /** getter method for retrieving the maximum longitude (in degrees) */
-  public final double getMaxLon() {
-    return this.maxLon;
-  }
-
-  /** getter method for retrieving the maximum latitude (in degrees) */
-  public final double getMaxLat() {
-    return this.maxLat;
-  }
-}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryImpl.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryImpl.java
deleted file mode 100644
index 107b136..0000000
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryImpl.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.geopoint.search;
-
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.util.SloppyMath;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
-import org.apache.lucene.spatial.util.GeoRelationUtils;
-
-/** Package private implementation for the public facing GeoPointInBBoxQuery delegate class.
- *
- *    @lucene.experimental
- */
-class GeoPointInBBoxQueryImpl extends GeoPointMultiTermQuery {
-  /**
-   * Constructs a new GeoBBoxQuery that will match encoded GeoPoint terms that fall within or on the boundary
-   * of the bounding box defined by the input parameters
-   * @param field the field name
-   * @param minLon lower longitude (x) value of the bounding box
-   * @param minLat lower latitude (y) value of the bounding box
-   * @param maxLon upper longitude (x) value of the bounding box
-   * @param maxLat upper latitude (y) value of the bounding box
-   */
-  GeoPointInBBoxQueryImpl(final String field, final TermEncoding termEncoding, final double minLon, final double minLat, final double maxLon, final double maxLat) {
-    super(field, termEncoding, minLon, minLat, maxLon, maxLat);
-  }
-
-  @Override
-  public void setRewriteMethod(MultiTermQuery.RewriteMethod method) {
-    throw new UnsupportedOperationException("cannot change rewrite method");
-  }
-
-  @Override
-  protected short computeMaxShift() {
-    final short shiftFactor;
-
-    // compute diagonal radius
-    double midLon = (minLon + maxLon) * 0.5;
-    double midLat = (minLat + maxLat) * 0.5;
-
-    if (SloppyMath.haversinMeters(minLat, minLon, midLat, midLon) > 1000000) {
-      shiftFactor = 5;
-    } else {
-      shiftFactor = 4;
-    }
-
-    return (short)(GeoPointField.PRECISION_STEP * shiftFactor);
-  }
-
-  @Override
-  protected CellComparator newCellComparator() {
-    return new GeoPointInBBoxCellComparator(this);
-  }
-
-  private final class GeoPointInBBoxCellComparator extends CellComparator {
-    GeoPointInBBoxCellComparator(GeoPointMultiTermQuery query) {
-      super(query);
-    }
-
-    /**
-     * Determine whether the quad-cell crosses the shape
-     */
-    @Override
-    protected boolean cellCrosses(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectCrosses(minLon, minLat, maxLon, maxLat, GeoPointInBBoxQueryImpl.this.minLon,
-          GeoPointInBBoxQueryImpl.this.minLat, GeoPointInBBoxQueryImpl.this.maxLon, GeoPointInBBoxQueryImpl.this.maxLat);    }
-
-    /**
-     * Determine whether quad-cell is within the shape
-     */
-    @Override
-    protected boolean cellWithin(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectWithin(minLon, minLat, maxLon, maxLat, GeoPointInBBoxQueryImpl.this.minLon,
-          GeoPointInBBoxQueryImpl.this.minLat, GeoPointInBBoxQueryImpl.this.maxLon, GeoPointInBBoxQueryImpl.this.maxLat);    }
-
-    @Override
-    protected boolean cellIntersectsShape(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return cellIntersectsMBR(minLon, minLat, maxLon, maxLat);
-    }
-
-    @Override
-    protected boolean postFilter(final double lon, final double lat) {
-      return GeoRelationUtils.pointInRectPrecise(lon, lat, minLon, minLat, maxLon, maxLat);
-    }
-  }
-
-  @Override
-  @SuppressWarnings({"unchecked","rawtypes"})
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-    if (!super.equals(o)) return false;
-
-    GeoPointInBBoxQueryImpl that = (GeoPointInBBoxQueryImpl) o;
-
-    if (Double.compare(that.maxLat, maxLat) != 0) return false;
-    if (Double.compare(that.maxLon, maxLon) != 0) return false;
-    if (Double.compare(that.minLat, minLat) != 0) return false;
-    if (Double.compare(that.minLon, minLon) != 0) return false;
-
-    return true;
-  }
-
-  @Override
-  public int hashCode() {
-    int result = super.hashCode();
-    long temp;
-    temp = Double.doubleToLongBits(minLon);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(minLat);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(maxLon);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(maxLat);
-    result = 31 * result + (int) (temp ^ (temp >>> 32));
-    return result;
-  }
-
-  @Override
-  public String toString(String field) {
-    final StringBuilder sb = new StringBuilder();
-    sb.append(getClass().getSimpleName());
-    sb.append(':');
-    if (!getField().equals(field)) {
-      sb.append(" field=");
-      sb.append(getField());
-      sb.append(':');
-    }
-    return sb.append(" Lower Left: [")
-        .append(minLon)
-        .append(',')
-        .append(minLat)
-        .append(']')
-        .append(" Upper Right: [")
-        .append(maxLon)
-        .append(',')
-        .append(maxLat)
-        .append("]")
-        .toString();
-  }
-}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryImplX.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryImplX.java
new file mode 100644
index 0000000..194e912
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryImplX.java
@@ -0,0 +1,159 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.geopoint.search;
+
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.util.SloppyMath;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX.TermEncoding;
+import org.apache.lucene.spatial.util.GeoRelationUtils;
+
+/** Package private implementation for the public facing GeoPointInBBoxQuery delegate class.
+ *
+ *    @lucene.experimental
+ */
+class GeoPointInBBoxQueryImplX extends GeoPointMultiTermQueryX {
+  /**
+   * Constructs a new GeoBBoxQuery that will match encoded GeoPoint terms that fall within or on the boundary
+   * of the bounding box defined by the input parameters
+   * @param field the field name
+   * @param minLon lower longitude (x) value of the bounding box
+   * @param minLat lower latitude (y) value of the bounding box
+   * @param maxLon upper longitude (x) value of the bounding box
+   * @param maxLat upper latitude (y) value of the bounding box
+   */
+  GeoPointInBBoxQueryImplX(final String field, final TermEncoding termEncoding, final double minLat, final double maxLat, final double minLon, final double maxLon) {
+    super(field, termEncoding, minLat, maxLat, minLon, maxLon);
+  }
+
+  @Override
+  public void setRewriteMethod(MultiTermQuery.RewriteMethod method) {
+    throw new UnsupportedOperationException("cannot change rewrite method");
+  }
+
+  @Override
+  protected short computeMaxShift() {
+    final short shiftFactor;
+
+    // compute diagonal radius
+    double midLat = (minLat + maxLat) * 0.5;
+    double midLon = (minLon + maxLon) * 0.5;
+
+    if (SloppyMath.haversinMeters(minLat, minLon, midLat, midLon) > 1000000) {
+      shiftFactor = 5;
+    } else {
+      shiftFactor = 4;
+    }
+
+    return (short)(GeoPointFieldX.PRECISION_STEP * shiftFactor);
+  }
+
+  @Override
+  protected CellComparator newCellComparator() {
+    return new GeoPointInBBoxCellComparator(this);
+  }
+
+  private final class GeoPointInBBoxCellComparator extends CellComparator {
+    GeoPointInBBoxCellComparator(GeoPointMultiTermQueryX query) {
+      super(query);
+    }
+
+    /**
+     * Determine whether the quad-cell crosses the shape
+     */
+    @Override
+    protected boolean cellCrossesX(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectCrossesX(minLat, maxLat, minLon, maxLon, GeoPointInBBoxQueryImplX.this.minLat,
+                                           GeoPointInBBoxQueryImplX.this.maxLat, GeoPointInBBoxQueryImplX.this.minLon, GeoPointInBBoxQueryImplX.this.maxLon);
+    }
+
+    /**
+     * Determine whether quad-cell is within the shape
+     */
+    @Override
+    protected boolean cellWithinX(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectWithinX(minLat, maxLat, minLon, maxLon, GeoPointInBBoxQueryImplX.this.minLat,
+                                          GeoPointInBBoxQueryImplX.this.maxLat,
+                                          GeoPointInBBoxQueryImplX.this.minLon, GeoPointInBBoxQueryImplX.this.maxLon);
+    }
+
+    @Override
+    protected boolean cellIntersectsShapeX(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return cellIntersectsMBRX(minLat, maxLat, minLon, maxLon);
+    }
+
+    @Override
+    protected boolean postFilterX(final double lat, final double lon) {
+      return GeoRelationUtils.pointInRectPreciseX(lat, lon, minLat, maxLat, minLon, maxLon);
+    }
+  }
+
+  @Override
+  @SuppressWarnings({"unchecked","rawtypes"})
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+    if (!super.equals(o)) return false;
+
+    GeoPointInBBoxQueryImplX that = (GeoPointInBBoxQueryImplX) o;
+
+    if (Double.compare(that.minLat, minLat) != 0) return false;
+    if (Double.compare(that.maxLat, maxLat) != 0) return false;
+    if (Double.compare(that.minLon, minLon) != 0) return false;
+    if (Double.compare(that.maxLon, maxLon) != 0) return false;
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = super.hashCode();
+    long temp;
+    temp = Double.doubleToLongBits(minLat);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(maxLat);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(minLon);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(maxLon);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    return result;
+  }
+
+  @Override
+  public String toString(String field) {
+    final StringBuilder sb = new StringBuilder();
+    sb.append(getClass().getSimpleName());
+    sb.append(':');
+    if (!getField().equals(field)) {
+      sb.append(" field=");
+      sb.append(getField());
+      sb.append(':');
+    }
+    return sb.append(" Lower Left: [")
+        .append(minLat)
+        .append(',')
+        .append(minLon)
+        .append(']')
+        .append(" Upper Right: [")
+        .append(maxLat)
+        .append(',')
+        .append(maxLon)
+        .append("]")
+        .toString();
+  }
+}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryX.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryX.java
new file mode 100644
index 0000000..e6d2a48
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInBBoxQueryX.java
@@ -0,0 +1,183 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.geopoint.search;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.FieldValueQuery;
+import org.apache.lucene.search.LegacyNumericRangeQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX.TermEncoding;
+import org.apache.lucene.spatial.util.GeoUtils;
+
+/** Implements a simple bounding box query on a GeoPoint field. This is inspired by
+ * {@link LegacyNumericRangeQuery} and is implemented using a
+ * two phase approach. First, candidate terms are queried using a numeric
+ * range based on the morton codes of the min and max lat/lon pairs. Terms
+ * passing this initial filter are passed to a final check that verifies whether
+ * the decoded lat/lon falls within (or on the boundary) of the query bounding box.
+ * The value comparisons are subject to a precision tolerance defined in
+ * {@value org.apache.lucene.spatial.util.GeoEncodingUtils#TOLERANCE}
+ *
+ * NOTES:
+ *    1.  All latitude/longitude values must be in decimal degrees.
+ *    2.  Complex computational geometry (e.g., dateline wrapping) is not supported
+ *    3.  For more advanced GeoSpatial indexing and query operations see spatial module
+ *    4.  This is well suited for small rectangles, large bounding boxes may result
+ *        in many terms, depending whether the bounding box falls on the boundary of
+ *        many cells (degenerate case)
+ *
+ * @lucene.experimental
+ */
+public class GeoPointInBBoxQueryX extends Query {
+  /** field name */
+  protected final String field;
+  /** minimum latitude value (in degrees) */
+  protected final double minLat;
+  /** minimum longitude value (in degrees) */
+  protected final double minLon;
+  /** maximum latitude value (in degrees) */
+  protected final double maxLat;
+  /** maximum longitude value (in degrees) */
+  protected final double maxLon;
+  /** term encoding enum to define how the points are encoded (PREFIX or NUMERIC) */
+  protected final TermEncoding termEncoding;
+
+  /**
+   * Constructs a query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointFieldX} types that fall within a
+   * defined bounding box
+   */
+  public GeoPointInBBoxQueryX(final String field, final double minLat, final double maxLat, final double minLon, final double maxLon) {
+    this(field, TermEncoding.PREFIX, minLat, maxLat, minLon, maxLon);
+  }
+
+  /**
+   * Constructs a query for all {@link org.apache.lucene.spatial.geopoint.document.GeoPointFieldX} types that fall within a
+   * defined bounding box. Accepts optional {@link org.apache.lucene.spatial.geopoint.document.GeoPointFieldX.TermEncoding} parameter
+   */
+  public GeoPointInBBoxQueryX(final String field, final TermEncoding termEncoding, final double minLat, final double maxLat, final double minLon, final double maxLon) {
+    this.field = field;
+    this.minLat = minLat;
+    this.maxLat = maxLat;
+    this.minLon = minLon;
+    this.maxLon = maxLon;
+    this.termEncoding = termEncoding;
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) {
+    // short-circuit to match all if specifying the whole map
+    if (minLat == GeoUtils.MIN_LAT_INCL && maxLat == GeoUtils.MAX_LAT_INCL &&
+        minLon == GeoUtils.MIN_LON_INCL && maxLon == GeoUtils.MAX_LON_INCL) {
+      // FieldValueQuery is valid since DocValues are *required* for GeoPointField
+      return new FieldValueQuery(field);
+    }
+
+    if (maxLon < minLon) {
+      BooleanQuery.Builder bqb = new BooleanQuery.Builder();
+
+      GeoPointInBBoxQueryImplX left = new GeoPointInBBoxQueryImplX(field, termEncoding, minLat, maxLat, -180.0D, maxLon);
+      bqb.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));
+      GeoPointInBBoxQueryImplX right = new GeoPointInBBoxQueryImplX(field, termEncoding, minLat, maxLat, minLon, 180.0D);
+      bqb.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));
+      return bqb.build();
+    }
+    return new GeoPointInBBoxQueryImplX(field, termEncoding, minLat, maxLat, minLon, maxLon);
+  }
+
+  @Override
+  public String toString(String field) {
+    final StringBuilder sb = new StringBuilder();
+    sb.append(getClass().getSimpleName());
+    sb.append(':');
+    if (!this.field.equals(field)) {
+      sb.append(" field=");
+      sb.append(this.field);
+      sb.append(':');
+    }
+    return sb.append(" Lower Left: [")
+        .append(minLat)
+        .append(',')
+        .append(minLon)
+        .append(']')
+        .append(" Upper Right: [")
+        .append(maxLat)
+        .append(',')
+        .append(maxLon)
+        .append("]")
+        .toString();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof GeoPointInBBoxQueryX)) return false;
+    if (!super.equals(o)) return false;
+
+    GeoPointInBBoxQueryX that = (GeoPointInBBoxQueryX) o;
+
+    if (Double.compare(that.minLat, minLat) != 0) return false;
+    if (Double.compare(that.maxLat, maxLat) != 0) return false;
+    if (Double.compare(that.minLon, minLon) != 0) return false;
+    if (Double.compare(that.maxLon, maxLon) != 0) return false;
+    if (!field.equals(that.field)) return false;
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = super.hashCode();
+    long temp;
+    result = 31 * result + field.hashCode();
+    temp = Double.doubleToLongBits(minLat);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(maxLat);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(minLon);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    temp = Double.doubleToLongBits(maxLon);
+    result = 31 * result + (int) (temp ^ (temp >>> 32));
+    return result;
+  }
+
+  /** getter method for retrieving the field name */
+  public final String getField() {
+    return this.field;
+  }
+
+  /** getter method for retrieving the minimum latitude (in degrees) */
+  public final double getMinLat() {
+    return this.minLat;
+  }
+
+  /** getter method for retrieving the maximum latitude (in degrees) */
+  public final double getMaxLat() {
+    return this.maxLat;
+  }
+
+  /** getter method for retrieving the minimum longitude (in degrees) */
+  public final double getMinLon() {
+    return this.minLon;
+  }
+
+  /** getter method for retrieving the maximum longitude (in degrees) */
+  public final double getMaxLon() {
+    return this.maxLon;
+  }
+}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java
deleted file mode 100644
index ef8c2ff..0000000
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQuery.java
+++ /dev/null
@@ -1,159 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.geopoint.search;
-
-import java.util.Arrays;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
-import org.apache.lucene.spatial.util.GeoEncodingUtils;
-import org.apache.lucene.spatial.util.GeoRect;
-import org.apache.lucene.spatial.util.GeoUtils;
-
-/** Implements a simple point in polygon query on a GeoPoint field. This is based on
- * {@code GeoPointInBBoxQueryImpl} and is implemented using a
- * three phase approach. First, like {@code GeoPointInBBoxQueryImpl}
- * candidate terms are queried using a numeric range based on the morton codes
- * of the min and max lat/lon pairs. Terms passing this initial filter are passed
- * to a secondary filter that verifies whether the decoded lat/lon point falls within
- * (or on the boundary) of the bounding box query. Finally, the remaining candidate
- * term is passed to the final point in polygon check. All value comparisons are subject
- * to the same precision tolerance defined in {@value GeoEncodingUtils#TOLERANCE}
- *
- * <p>NOTES:
- *    1.  The polygon coordinates need to be in either clockwise or counter-clockwise order.
- *    2.  The polygon must not be self-crossing, otherwise the query may result in unexpected behavior
- *    3.  All latitude/longitude values must be in decimal degrees.
- *    4.  Complex computational geometry (e.g., dateline wrapping, polygon with holes) is not supported
- *    5.  For more advanced GeoSpatial indexing and query operations see spatial module
- *
- * @lucene.experimental
- */
-public final class GeoPointInPolygonQuery extends GeoPointInBBoxQuery {
-  // polygon position arrays - this avoids the use of any objects or
-  // or geo library dependencies
-  /** array of x (longitude) values (in degrees) */
-  protected final double[] x;
-  /** array of y (latitude) values (in degrees) */
-  protected final double[] y;
-
-  /**
-   * Constructs a new GeoPolygonQuery that will match encoded {@link org.apache.lucene.spatial.geopoint.document.GeoPointField} terms
-   * that fall within or on the boundary of the polygon defined by the input parameters.
-   */
-  public GeoPointInPolygonQuery(final String field, final double[] polyLons, final double[] polyLats) {
-    this(field, TermEncoding.PREFIX, GeoUtils.polyToBBox(polyLons, polyLats), polyLons, polyLats);
-  }
-
-  /**
-   * Constructs a new GeoPolygonQuery that will match encoded {@link org.apache.lucene.spatial.geopoint.document.GeoPointField} terms
-   * that fall within or on the boundary of the polygon defined by the input parameters.
-   */
-  public GeoPointInPolygonQuery(final String field, final TermEncoding termEncoding, final double[] polyLons, final double[] polyLats) {
-    this(field, termEncoding, GeoUtils.polyToBBox(polyLons, polyLats), polyLons, polyLats);
-  }
-
-  /** Common constructor, used only internally. */
-  private GeoPointInPolygonQuery(final String field, TermEncoding termEncoding, GeoRect bbox, final double[] polyLons, final double[] polyLats) {
-    super(field, termEncoding, bbox.minLon, bbox.minLat, bbox.maxLon, bbox.maxLat);
-    if (polyLats.length != polyLons.length) {
-      throw new IllegalArgumentException("polyLats and polyLons must be equal length");
-    }
-    if (polyLats.length < 4) {
-      throw new IllegalArgumentException("at least 4 polygon points required");
-    }
-    if (polyLats[0] != polyLats[polyLats.length-1]) {
-      throw new IllegalArgumentException("first and last points of the polygon must be the same (it must close itself): polyLats[0]=" + polyLats[0] + " polyLats[" + (polyLats.length-1) + "]=" + polyLats[polyLats.length-1]);
-    }
-    if (polyLons[0] != polyLons[polyLons.length-1]) {
-      throw new IllegalArgumentException("first and last points of the polygon must be the same (it must close itself): polyLons[0]=" + polyLons[0] + " polyLons[" + (polyLons.length-1) + "]=" + polyLons[polyLons.length-1]);
-    }
-
-    this.x = polyLons;
-    this.y = polyLats;
-  }
-
-  /** throw exception if trying to change rewrite method */
-  @Override
-  public Query rewrite(IndexReader reader) {
-    return new GeoPointInPolygonQueryImpl(field, termEncoding, this, this.minLon, this.minLat, this.maxLon, this.maxLat);
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-    if (!super.equals(o)) return false;
-
-    GeoPointInPolygonQuery that = (GeoPointInPolygonQuery) o;
-
-    if (!Arrays.equals(x, that.x)) return false;
-    if (!Arrays.equals(y, that.y)) return false;
-
-    return true;
-  }
-
-  @Override
-  public int hashCode() {
-    int result = super.hashCode();
-    result = 31 * result + (x != null ? Arrays.hashCode(x) : 0);
-    result = 31 * result + (y != null ? Arrays.hashCode(y) : 0);
-    return result;
-  }
-
-  /** print out this polygon query */
-  @Override
-  public String toString(String field) {
-    assert x.length == y.length;
-
-    final StringBuilder sb = new StringBuilder();
-    sb.append(getClass().getSimpleName());
-    sb.append(':');
-    if (!getField().equals(field)) {
-      sb.append(" field=");
-      sb.append(getField());
-      sb.append(':');
-    }
-    sb.append(" Points: ");
-    for (int i=0; i<x.length; ++i) {
-      sb.append("[")
-          .append(x[i])
-          .append(", ")
-          .append(y[i])
-          .append("] ");
-    }
-
-    return sb.toString();
-  }
-
-  /**
-   * API utility method for returning the array of longitudinal values for this GeoPolygon
-   * The returned array is not a copy so do not change it!
-   */
-  public double[] getLons() {
-    return this.x;
-  }
-
-  /**
-   * API utility method for returning the array of latitudinal values for this GeoPolygon
-   * The returned array is not a copy so do not change it!
-   */
-  public double[] getLats() {
-    return this.y;
-  }
-}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryImpl.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryImpl.java
deleted file mode 100644
index 35a3950..0000000
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryImpl.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.geopoint.search;
-
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
-import org.apache.lucene.spatial.util.GeoRelationUtils;
-
-/** Package private implementation for the public facing GeoPointInPolygonQuery delegate class.
- *
- *    @lucene.experimental
- */
-final class GeoPointInPolygonQueryImpl extends GeoPointInBBoxQueryImpl {
-  private final GeoPointInPolygonQuery polygonQuery;
-
-  GeoPointInPolygonQueryImpl(final String field, final TermEncoding termEncoding, final GeoPointInPolygonQuery q,
-                             final double minLon, final double minLat, final double maxLon, final double maxLat) {
-    super(field, termEncoding, minLon, minLat, maxLon, maxLat);
-    polygonQuery = q;
-  }
-
-  @Override
-  public void setRewriteMethod(MultiTermQuery.RewriteMethod method) {
-    throw new UnsupportedOperationException("cannot change rewrite method");
-  }
-
-  @Override
-  protected CellComparator newCellComparator() {
-    return new GeoPolygonCellComparator(this);
-  }
-
-  /**
-   * Custom {@code org.apache.lucene.spatial.geopoint.search.GeoPointMultiTermQuery.CellComparator} that computes morton hash
-   * ranges based on the defined edges of the provided polygon.
-   */
-  private final class GeoPolygonCellComparator extends CellComparator {
-    GeoPolygonCellComparator(GeoPointMultiTermQuery query) {
-      super(query);
-    }
-
-    @Override
-    protected boolean cellCrosses(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectCrossesPolyApprox(minLon, minLat, maxLon, maxLat, polygonQuery.x, polygonQuery.y,
-          polygonQuery.minLon, polygonQuery.minLat, polygonQuery.maxLon, polygonQuery.maxLat);
-    }
-
-    @Override
-    protected boolean cellWithin(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectWithinPolyApprox(minLon, minLat, maxLon, maxLat, polygonQuery.x, polygonQuery.y,
-          polygonQuery.minLon, polygonQuery.minLat, polygonQuery.maxLon, polygonQuery.maxLat);
-    }
-
-    @Override
-    protected boolean cellIntersectsShape(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return cellContains(minLon, minLat, maxLon, maxLat) || cellWithin(minLon, minLat, maxLon, maxLat)
-          || cellCrosses(minLon, minLat, maxLon, maxLat);
-    }
-
-    /**
-     * The two-phase query approach. The parent
-     * {@link org.apache.lucene.spatial.geopoint.search.GeoPointTermsEnum#accept} method is called to match
-     * encoded terms that fall within the bounding box of the polygon. Those documents that pass the initial
-     * bounding box filter are then compared to the provided polygon using the
-     * {@link org.apache.lucene.spatial.util.GeoRelationUtils#pointInPolygon} method.
-     */
-    @Override
-    protected boolean postFilter(final double lon, final double lat) {
-      return GeoRelationUtils.pointInPolygon(polygonQuery.x, polygonQuery.y, lat, lon);
-    }
-  }
-
-  @Override
-  public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null || getClass() != o.getClass()) return false;
-    if (!super.equals(o)) return false;
-
-    GeoPointInPolygonQueryImpl that = (GeoPointInPolygonQueryImpl) o;
-
-    return !(polygonQuery != null ? !polygonQuery.equals(that.polygonQuery) : that.polygonQuery != null);
-  }
-
-  @Override
-  public int hashCode() {
-    int result = super.hashCode();
-    result = 31 * result + (polygonQuery != null ? polygonQuery.hashCode() : 0);
-    return result;
-  }
-}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryImplX.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryImplX.java
new file mode 100644
index 0000000..4b9de3b
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryImplX.java
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.geopoint.search;
+
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX.TermEncoding;
+import org.apache.lucene.spatial.util.GeoRelationUtils;
+
+/** Package private implementation for the public facing GeoPointInPolygonQuery delegate class.
+ *
+ *    @lucene.experimental
+ */
+final class GeoPointInPolygonQueryImplX extends GeoPointInBBoxQueryImplX {
+  private final GeoPointInPolygonQueryX polygonQuery;
+
+  GeoPointInPolygonQueryImplX(final String field, final TermEncoding termEncoding, final GeoPointInPolygonQueryX q,
+                              final double minLat, final double maxLat, final double minLon, final double maxLon) {
+    super(field, termEncoding, minLat, maxLat, minLon, maxLon);
+    polygonQuery = q;
+  }
+
+  @Override
+  public void setRewriteMethod(MultiTermQuery.RewriteMethod method) {
+    throw new UnsupportedOperationException("cannot change rewrite method");
+  }
+
+  @Override
+  protected CellComparator newCellComparator() {
+    return new GeoPolygonCellComparator(this);
+  }
+
+  /**
+   * Custom {@code org.apache.lucene.spatial.geopoint.search.GeoPointMultiTermQuery.CellComparator} that computes morton hash
+   * ranges based on the defined edges of the provided polygon.
+   */
+  private final class GeoPolygonCellComparator extends CellComparator {
+    GeoPolygonCellComparator(GeoPointMultiTermQueryX query) {
+      super(query);
+    }
+
+    @Override
+    protected boolean cellCrossesX(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectCrossesPolyApproxX(minLat, maxLat, minLon, maxLon, polygonQuery.polyLats, polygonQuery.polyLons,
+                                                     polygonQuery.minLat, polygonQuery.maxLat, polygonQuery.minLon, polygonQuery.maxLon);
+    }
+
+    @Override
+    protected boolean cellWithinX(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectWithinPolyApproxX(minLat, maxLat, minLon, maxLon, polygonQuery.polyLats, polygonQuery.polyLons,
+                                                    polygonQuery.minLat, polygonQuery.maxLat, polygonQuery.minLon, polygonQuery.maxLon);
+    }
+
+    @Override
+    protected boolean cellIntersectsShapeX(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return cellContainsX(minLat, maxLat, minLon, maxLon) || cellWithinX(minLat, maxLat, minLon, maxLon)
+          || cellCrossesX(minLat, maxLat, minLon, maxLon);
+    }
+
+    /**
+     * The two-phase query approach. The parent
+     * {@link org.apache.lucene.spatial.geopoint.search.GeoPointTermsEnum#accept} method is called to match
+     * encoded terms that fall within the bounding box of the polygon. Those documents that pass the initial
+     * bounding box filter are then compared to the provided polygon using the
+     * {@link org.apache.lucene.spatial.util.GeoRelationUtils#pointInPolygon} method.
+     */
+    @Override
+    protected boolean postFilterX(final double lat, final double lon) {
+      return GeoRelationUtils.pointInPolygonX(polygonQuery.polyLats, polygonQuery.polyLons, lat, lon);
+    }
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+    if (!super.equals(o)) return false;
+
+    GeoPointInPolygonQueryImplX that = (GeoPointInPolygonQueryImplX) o;
+
+    return !(polygonQuery != null ? !polygonQuery.equals(that.polygonQuery) : that.polygonQuery != null);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = super.hashCode();
+    result = 31 * result + (polygonQuery != null ? polygonQuery.hashCode() : 0);
+    return result;
+  }
+}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryX.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryX.java
new file mode 100644
index 0000000..73d2e08
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointInPolygonQueryX.java
@@ -0,0 +1,159 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.geopoint.search;
+
+import java.util.Arrays;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX.TermEncoding;
+import org.apache.lucene.spatial.util.GeoEncodingUtils;
+import org.apache.lucene.spatial.util.GeoRect;
+import org.apache.lucene.spatial.util.GeoUtils;
+
+/** Implements a simple point in polygon query on a GeoPoint field. This is based on
+ * {@code GeoPointInBBoxQueryImpl} and is implemented using a
+ * three phase approach. First, like {@code GeoPointInBBoxQueryImpl}
+ * candidate terms are queried using a numeric range based on the morton codes
+ * of the min and max lat/lon pairs. Terms passing this initial filter are passed
+ * to a secondary filter that verifies whether the decoded lat/lon point falls within
+ * (or on the boundary) of the bounding box query. Finally, the remaining candidate
+ * term is passed to the final point in polygon check. All value comparisons are subject
+ * to the same precision tolerance defined in {@value GeoEncodingUtils#TOLERANCE}
+ *
+ * <p>NOTES:
+ *    1.  The polygon coordinates need to be in either clockwise or counter-clockwise order.
+ *    2.  The polygon must not be self-crossing, otherwise the query may result in unexpected behavior
+ *    3.  All latitude/longitude values must be in decimal degrees.
+ *    4.  Complex computational geometry (e.g., dateline wrapping, polygon with holes) is not supported
+ *    5.  For more advanced GeoSpatial indexing and query operations see spatial module
+ *
+ * @lucene.experimental
+ */
+public final class GeoPointInPolygonQueryX extends GeoPointInBBoxQueryX {
+  // polygon position arrays - this avoids the use of any objects or
+  // or geo library dependencies
+  /** array of y (latitude) values (in degrees) */
+  protected final double[] polyLats;
+  /** array of x (longitude) values (in degrees) */
+  protected final double[] polyLons;
+
+  /**
+   * Constructs a new GeoPolygonQuery that will match encoded {@link org.apache.lucene.spatial.geopoint.document.GeoPointFieldX} terms
+   * that fall within or on the boundary of the polygon defined by the input parameters.
+   */
+  public GeoPointInPolygonQueryX(final String field, final double[] polyLats, final double[] polyLons) {
+    this(field, TermEncoding.PREFIX, GeoUtils.polyToBBox(polyLats, polyLons), polyLats, polyLons);
+  }
+
+  /**
+   * Constructs a new GeoPolygonQuery that will match encoded {@link org.apache.lucene.spatial.geopoint.document.GeoPointFieldX} terms
+   * that fall within or on the boundary of the polygon defined by the input parameters.
+   */
+  public GeoPointInPolygonQueryX(final String field, final TermEncoding termEncoding, final double[] polyLats, final double[] polyLons) {
+    this(field, termEncoding, GeoUtils.polyToBBox(polyLats, polyLons), polyLats, polyLons);
+  }
+
+  /** Common constructor, used only internally. */
+  private GeoPointInPolygonQueryX(final String field, TermEncoding termEncoding, GeoRect bbox, final double[] polyLats, final double[] polyLons) {
+    super(field, termEncoding, bbox.minLat, bbox.maxLat, bbox.minLon, bbox.maxLon);
+    if (polyLats.length != polyLons.length) {
+      throw new IllegalArgumentException("polyLats and polyLons must be equal length");
+    }
+    if (polyLats.length < 4) {
+      throw new IllegalArgumentException("at least 4 polygon points required");
+    }
+    if (polyLats[0] != polyLats[polyLats.length-1]) {
+      throw new IllegalArgumentException("first and last points of the polygon must be the same (it must close itself): polyLats[0]=" + polyLats[0] + " polyLats[" + (polyLats.length-1) + "]=" + polyLats[polyLats.length-1]);
+    }
+    if (polyLons[0] != polyLons[polyLons.length-1]) {
+      throw new IllegalArgumentException("first and last points of the polygon must be the same (it must close itself): polyLons[0]=" + polyLons[0] + " polyLons[" + (polyLons.length-1) + "]=" + polyLons[polyLons.length-1]);
+    }
+
+    this.polyLons = polyLons;
+    this.polyLats = polyLats;
+  }
+
+  /** throw exception if trying to change rewrite method */
+  @Override
+  public Query rewrite(IndexReader reader) {
+    return new GeoPointInPolygonQueryImplX(field, termEncoding, this, this.minLat, this.maxLat, this.minLon, this.maxLon);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+    if (!super.equals(o)) return false;
+
+    GeoPointInPolygonQueryX that = (GeoPointInPolygonQueryX) o;
+
+    if (!Arrays.equals(polyLats, that.polyLats)) return false;
+    if (!Arrays.equals(polyLons, that.polyLons)) return false;
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    int result = super.hashCode();
+    result = 31 * result + (polyLats != null ? Arrays.hashCode(polyLats) : 0);
+    result = 31 * result + (polyLons != null ? Arrays.hashCode(polyLons) : 0);
+    return result;
+  }
+
+  /** print out this polygon query */
+  @Override
+  public String toString(String field) {
+    assert polyLats.length == polyLons.length;
+
+    final StringBuilder sb = new StringBuilder();
+    sb.append(getClass().getSimpleName());
+    sb.append(':');
+    if (!getField().equals(field)) {
+      sb.append(" field=");
+      sb.append(getField());
+      sb.append(':');
+    }
+    sb.append(" Points: ");
+    for (int i=0; i<polyLats.length; ++i) {
+      sb.append("[")
+          .append(polyLats[i])
+          .append(", ")
+          .append(polyLons[i])
+          .append("] ");
+    }
+
+    return sb.toString();
+  }
+
+  /**
+   * API utility method for returning the array of longitudinal values for this GeoPolygon
+   * The returned array is not a copy so do not change it!
+   */
+  public double[] getLons() {
+    return this.polyLons;
+  }
+
+  /**
+   * API utility method for returning the array of latitudinal values for this GeoPolygon
+   * The returned array is not a copy so do not change it!
+   */
+  public double[] getLats() {
+    return this.polyLats;
+  }
+}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointMultiTermQuery.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointMultiTermQuery.java
deleted file mode 100644
index edbd53d..0000000
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointMultiTermQuery.java
+++ /dev/null
@@ -1,166 +0,0 @@
-package org.apache.lucene.spatial.geopoint.search;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.io.IOException;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Terms;
-import org.apache.lucene.index.TermsEnum;
-import org.apache.lucene.search.MultiTermQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.util.AttributeSource;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
-import org.apache.lucene.spatial.util.GeoEncodingUtils;
-import org.apache.lucene.spatial.util.GeoRelationUtils;
-import org.apache.lucene.spatial.util.GeoUtils;
-import org.apache.lucene.util.SloppyMath;
-
-/**
- * TermQuery for GeoPointField for overriding {@link org.apache.lucene.search.MultiTermQuery} methods specific to
- * Geospatial operations
- *
- * @lucene.experimental
- */
-abstract class GeoPointMultiTermQuery extends MultiTermQuery {
-  // simple bounding box optimization - no objects used to avoid dependencies
-  protected final double minLon;
-  protected final double minLat;
-  protected final double maxLon;
-  protected final double maxLat;
-  protected final short maxShift;
-  protected final TermEncoding termEncoding;
-  protected final CellComparator cellComparator;
-
-  /**
-   * Constructs a query matching terms that cannot be represented with a single
-   * Term.
-   */
-  public GeoPointMultiTermQuery(String field, final TermEncoding termEncoding, final double minLon, final double minLat, final double maxLon, final double maxLat) {
-    super(field);
-
-    if (GeoUtils.isValidLon(minLon) == false) {
-      throw new IllegalArgumentException("invalid minLon " + minLon);
-    }
-    if (GeoUtils.isValidLon(maxLon) == false) {
-      throw new IllegalArgumentException("invalid maxLon " + maxLon);
-    }
-    if (GeoUtils.isValidLat(minLat) == false) {
-      throw new IllegalArgumentException("invalid minLat " + minLat);
-    }
-    if (GeoUtils.isValidLat(maxLat) == false) {
-      throw new IllegalArgumentException("invalid maxLat " + maxLat);
-    }
-
-    final long minHash = GeoEncodingUtils.mortonHash(minLon, minLat);
-    final long maxHash = GeoEncodingUtils.mortonHash(maxLon, maxLat);
-    this.minLon = GeoEncodingUtils.mortonUnhashLon(minHash);
-    this.minLat = GeoEncodingUtils.mortonUnhashLat(minHash);
-    this.maxLon = GeoEncodingUtils.mortonUnhashLon(maxHash);
-    this.maxLat = GeoEncodingUtils.mortonUnhashLat(maxHash);
-
-    this.maxShift = computeMaxShift();
-    this.termEncoding = termEncoding;
-    this.cellComparator = newCellComparator();
-
-    this.rewriteMethod = GEO_CONSTANT_SCORE_REWRITE;
-  }
-
-  public static final RewriteMethod GEO_CONSTANT_SCORE_REWRITE = new RewriteMethod() {
-    @Override
-    public Query rewrite(IndexReader reader, MultiTermQuery query) {
-      return new GeoPointTermQueryConstantScoreWrapper<>((GeoPointMultiTermQuery)query);
-    }
-  };
-
-  @Override @SuppressWarnings("unchecked")
-  protected TermsEnum getTermsEnum(final Terms terms, AttributeSource atts) throws IOException {
-    return GeoPointTermsEnum.newInstance(terms.iterator(), this);
-  }
-
-  /**
-   * Computes the maximum shift based on the diagonal distance of the bounding box
-   */
-  protected short computeMaxShift() {
-    // in this case a factor of 4 brings the detail level to ~0.002/0.001 degrees lon/lat respectively (or ~222m/111m)
-    final short shiftFactor;
-
-    // compute diagonal distance
-    double midLon = (minLon + maxLon) * 0.5;
-    double midLat = (minLat + maxLat) * 0.5;
-
-    if (SloppyMath.haversinMeters(minLat, minLon, midLat, midLon) > 1000000) {
-      shiftFactor = 5;
-    } else {
-      shiftFactor = 4;
-    }
-
-    return (short)(GeoPointField.PRECISION_STEP * shiftFactor);
-  }
-
-  /**
-   * Abstract method to construct the class that handles all geo point relations
-   * (e.g., GeoPointInPolygon)
-   */
-  abstract protected CellComparator newCellComparator();
-
-  /**
-   * Base class for all geo point relation comparators
-   */
-  static abstract class CellComparator {
-    protected final GeoPointMultiTermQuery geoPointQuery;
-
-    CellComparator(GeoPointMultiTermQuery query) {
-      this.geoPointQuery = query;
-    }
-
-    /**
-     * Primary driver for cells intersecting shape boundaries
-     */
-    protected boolean cellIntersectsMBR(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectIntersects(minLon, minLat, maxLon, maxLat, geoPointQuery.minLon, geoPointQuery.minLat,
-          geoPointQuery.maxLon, geoPointQuery.maxLat);
-    }
-
-    /**
-     * Return whether quad-cell contains the bounding box of this shape
-     */
-    protected boolean cellContains(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-      return GeoRelationUtils.rectWithin(geoPointQuery.minLon, geoPointQuery.minLat, geoPointQuery.maxLon,
-          geoPointQuery.maxLat, minLon, minLat, maxLon, maxLat);
-    }
-
-    /**
-     * Determine whether the quad-cell crosses the shape
-     */
-    abstract protected boolean cellCrosses(final double minLon, final double minLat, final double maxLon, final double maxLat);
-
-    /**
-     * Determine whether quad-cell is within the shape
-     */
-    abstract protected boolean cellWithin(final double minLon, final double minLat, final double maxLon, final double maxLat);
-
-    /**
-     * Default shape is a rectangle, so this returns the same as {@code cellIntersectsMBR}
-     */
-    abstract protected boolean cellIntersectsShape(final double minLon, final double minLat, final double maxLon, final double maxLat);
-
-    abstract protected boolean postFilter(final double lon, final double lat);
-  }
-}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointMultiTermQueryX.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointMultiTermQueryX.java
new file mode 100644
index 0000000..bf0d32a
--- /dev/null
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointMultiTermQueryX.java
@@ -0,0 +1,166 @@
+package org.apache.lucene.spatial.geopoint.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.util.AttributeSource;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX.TermEncoding;
+import org.apache.lucene.spatial.util.GeoEncodingUtils;
+import org.apache.lucene.spatial.util.GeoRelationUtils;
+import org.apache.lucene.spatial.util.GeoUtils;
+import org.apache.lucene.util.SloppyMath;
+
+/**
+ * TermQuery for GeoPointField for overriding {@link org.apache.lucene.search.MultiTermQuery} methods specific to
+ * Geospatial operations
+ *
+ * @lucene.experimental
+ */
+abstract class GeoPointMultiTermQueryX extends MultiTermQuery {
+  // simple bounding box optimization - no objects used to avoid dependencies
+  protected final double minLon;
+  protected final double minLat;
+  protected final double maxLon;
+  protected final double maxLat;
+  protected final short maxShift;
+  protected final TermEncoding termEncoding;
+  protected final CellComparator cellComparator;
+
+  /**
+   * Constructs a query matching terms that cannot be represented with a single
+   * Term.
+   */
+  public GeoPointMultiTermQueryX(String field, final TermEncoding termEncoding, final double minLat, final double maxLat, final double minLon, final double maxLon) {
+    super(field);
+
+    if (GeoUtils.isValidLat(minLat) == false) {
+      throw new IllegalArgumentException("invalid minLat " + minLat);
+    }
+    if (GeoUtils.isValidLat(maxLat) == false) {
+      throw new IllegalArgumentException("invalid maxLat " + maxLat);
+    }
+    if (GeoUtils.isValidLon(minLon) == false) {
+      throw new IllegalArgumentException("invalid minLon " + minLon);
+    }
+    if (GeoUtils.isValidLon(maxLon) == false) {
+      throw new IllegalArgumentException("invalid maxLon " + maxLon);
+    }
+
+    final long minHash = GeoEncodingUtils.mortonHashX(minLat, minLon);
+    final long maxHash = GeoEncodingUtils.mortonHashX(maxLat, maxLon);
+    this.minLat = GeoEncodingUtils.mortonUnhashLat(minHash);
+    this.maxLat = GeoEncodingUtils.mortonUnhashLat(maxHash);
+    this.minLon = GeoEncodingUtils.mortonUnhashLon(minHash);
+    this.maxLon = GeoEncodingUtils.mortonUnhashLon(maxHash);
+
+    this.maxShift = computeMaxShift();
+    this.termEncoding = termEncoding;
+    this.cellComparator = newCellComparator();
+
+    this.rewriteMethod = GEO_CONSTANT_SCORE_REWRITE;
+  }
+
+  public static final RewriteMethod GEO_CONSTANT_SCORE_REWRITE = new RewriteMethod() {
+    @Override
+    public Query rewrite(IndexReader reader, MultiTermQuery query) {
+      return new GeoPointTermQueryConstantScoreWrapper<>((GeoPointMultiTermQueryX)query);
+    }
+  };
+
+  @Override @SuppressWarnings("unchecked")
+  protected TermsEnum getTermsEnum(final Terms terms, AttributeSource atts) throws IOException {
+    return GeoPointTermsEnum.newInstance(terms.iterator(), this);
+  }
+
+  /**
+   * Computes the maximum shift based on the diagonal distance of the bounding box
+   */
+  protected short computeMaxShift() {
+    // in this case a factor of 4 brings the detail level to ~0.002/0.001 degrees lon/lat respectively (or ~222m/111m)
+    final short shiftFactor;
+
+    // compute diagonal distance
+    double midLon = (minLon + maxLon) * 0.5;
+    double midLat = (minLat + maxLat) * 0.5;
+
+    if (SloppyMath.haversinMeters(minLat, minLon, midLat, midLon) > 1000000) {
+      shiftFactor = 5;
+    } else {
+      shiftFactor = 4;
+    }
+
+    return (short)(GeoPointFieldX.PRECISION_STEP * shiftFactor);
+  }
+
+  /**
+   * Abstract method to construct the class that handles all geo point relations
+   * (e.g., GeoPointInPolygon)
+   */
+  abstract protected CellComparator newCellComparator();
+
+  /**
+   * Base class for all geo point relation comparators
+   */
+  static abstract class CellComparator {
+    protected final GeoPointMultiTermQueryX geoPointQuery;
+
+    CellComparator(GeoPointMultiTermQueryX query) {
+      this.geoPointQuery = query;
+    }
+
+    /**
+     * Primary driver for cells intersecting shape boundaries
+     */
+    protected boolean cellIntersectsMBRX(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectIntersectsX(minLat, maxLat, minLon, maxLon, geoPointQuery.minLat, geoPointQuery.maxLat,
+                                              geoPointQuery.minLon, geoPointQuery.maxLon);
+    }
+
+    /**
+     * Return whether quad-cell contains the bounding box of this shape
+     */
+    protected boolean cellContainsX(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+      return GeoRelationUtils.rectWithinX(geoPointQuery.minLat, geoPointQuery.maxLat, geoPointQuery.minLon,
+                                          geoPointQuery.maxLon, minLat, maxLat, minLon, maxLon);
+    }
+
+    /**
+     * Determine whether the quad-cell crosses the shape
+     */
+    abstract protected boolean cellCrossesX(final double minLat, final double maxLat, final double minLon, final double maxLon);
+
+    /**
+     * Determine whether quad-cell is within the shape
+     */
+    abstract protected boolean cellWithinX(final double minLat, final double maxLat, final double minLon, final double maxLon);
+
+    /**
+     * Default shape is a rectangle, so this returns the same as {@code cellIntersectsMBR}
+     */
+    abstract protected boolean cellIntersectsShapeX(final double minLat, final double maxLat, final double minLon, final double maxLon);
+
+    abstract protected boolean postFilterX(final double lat, final double lon);
+  }
+}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointNumericTermsEnum.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointNumericTermsEnum.java
index 120df7d..a905b20 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointNumericTermsEnum.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointNumericTermsEnum.java
@@ -22,7 +22,7 @@ import java.util.LinkedList;
 import java.util.List;
 
 import org.apache.lucene.index.TermsEnum;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX;
 import org.apache.lucene.spatial.util.GeoEncodingUtils;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefBuilder;
@@ -44,7 +44,7 @@ final class GeoPointNumericTermsEnum extends GeoPointTermsEnum {
   // detail level should be a factor of PRECISION_STEP limiting the depth of recursion (and number of ranges)
   private final short DETAIL_LEVEL;
 
-  GeoPointNumericTermsEnum(final TermsEnum tenum, final GeoPointMultiTermQuery query) {
+  GeoPointNumericTermsEnum(final TermsEnum tenum, final GeoPointMultiTermQueryX query) {
     super(tenum, query);
     DETAIL_LEVEL = (short)(((GeoEncodingUtils.BITS<<1)-this.maxShift)/2);
     computeRange(0L, (short) (((GeoEncodingUtils.BITS) << 1) - 1));
@@ -87,16 +87,16 @@ final class GeoPointNumericTermsEnum extends GeoPointTermsEnum {
     final short level = (short)((GeoEncodingUtils.BITS<<1)-res>>>1);
 
     // if cell is within and a factor of the precision step, or it crosses the edge of the shape add the range
-    final boolean within = res % GeoPointField.PRECISION_STEP == 0 && relationImpl.cellWithin(minLon, minLat, maxLon, maxLat);
-    if (within || (level == DETAIL_LEVEL && relationImpl.cellIntersectsShape(minLon, minLat, maxLon, maxLat))) {
+    final boolean within = res % GeoPointFieldX.PRECISION_STEP == 0 && relationImpl.cellWithinX(minLat, maxLat, minLon, maxLon);
+    if (within || (level == DETAIL_LEVEL && relationImpl.cellIntersectsShapeX(minLat, maxLat, minLon, maxLon))) {
       final short nextRes = (short)(res-1);
-      if (nextRes % GeoPointField.PRECISION_STEP == 0) {
+      if (nextRes % GeoPointFieldX.PRECISION_STEP == 0) {
         rangeBounds.add(new Range(start, nextRes, !within));
         rangeBounds.add(new Range(start|(1L<<nextRes), nextRes, !within));
       } else {
         rangeBounds.add(new Range(start, res, !within));
       }
-    } else if (level < DETAIL_LEVEL && relationImpl.cellIntersectsMBR(minLon, minLat, maxLon, maxLat)) {
+    } else if (level < DETAIL_LEVEL && relationImpl.cellIntersectsMBRX(minLat, maxLat, minLon, maxLon)) {
       computeRange(start, (short) (res - 1));
     }
   }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java
index fbaf68e..3d6e699 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointPrefixTermsEnum.java
@@ -20,10 +20,10 @@ package org.apache.lucene.spatial.geopoint.search;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefBuilder;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX;
 import org.apache.lucene.spatial.util.GeoEncodingUtils;
 
-import static org.apache.lucene.spatial.util.GeoEncodingUtils.mortonHash;
+import static org.apache.lucene.spatial.util.GeoEncodingUtils.mortonHashX;
 import static org.apache.lucene.spatial.util.GeoEncodingUtils.mortonUnhashLat;
 import static org.apache.lucene.spatial.util.GeoEncodingUtils.mortonUnhashLon;
 import static org.apache.lucene.spatial.util.GeoEncodingUtils.geoCodedToPrefixCoded;
@@ -56,9 +56,9 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
   private boolean withinOnly = false;
   private long lastWithin;
 
-  public GeoPointPrefixTermsEnum(final TermsEnum tenum, final GeoPointMultiTermQuery query) {
+  public GeoPointPrefixTermsEnum(final TermsEnum tenum, final GeoPointMultiTermQueryX query) {
     super(tenum, query);
-    this.start = mortonHash(query.minLon, query.minLat);
+    this.start = mortonHashX(query.minLat, query.minLon);
     this.currentRange = new Range(0, shift, true);
     // start shift at maxShift value (from computeMaxShift)
     this.shift = maxShift;
@@ -67,12 +67,12 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
     this.currEnd = currStart | mask;
   }
 
-  private boolean within(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-    return relationImpl.cellWithin(minLon, minLat, maxLon, maxLat);
+  private boolean withinX(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+    return relationImpl.cellWithinX(minLat, maxLat, minLon, maxLon);
   }
 
-  private boolean boundary(final double minLon, final double minLat, final double maxLon, final double maxLat) {
-    return shift == maxShift && relationImpl.cellIntersectsShape(minLon, minLat, maxLon, maxLat);
+  private boolean boundaryX(final double minLat, final double maxLat, final double minLon, final double maxLon) {
+    return shift == maxShift && relationImpl.cellIntersectsShapeX(minLat, maxLat, minLon, maxLon);
   }
 
   private boolean nextWithin() {
@@ -100,9 +100,9 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
       maxLat = mortonUnhashLat(currEnd);
 
       // within or a boundary
-      if ((isWithin = within(minLon, minLat, maxLon, maxLat) == true) || boundary(minLon, minLat, maxLon, maxLat) == true) {
+      if ((isWithin = withinX(minLat, maxLat, minLon, maxLon) == true) || boundaryX(minLat, maxLat, minLon, maxLon) == true) {
         final int m;
-        if (isWithin == false || (m = shift % GeoPointField.PRECISION_STEP) == 0) {
+        if (isWithin == false || (m = shift % GeoPointFieldX.PRECISION_STEP) == 0) {
           setNextRange(isWithin == false);
           advanceVariables();
           break;
@@ -116,7 +116,7 @@ final class GeoPointPrefixTermsEnum extends GeoPointTermsEnum {
       }
 
       // within cell but not at a depth factor of PRECISION_STEP
-      if (isWithin == true || (relationImpl.cellIntersectsMBR(minLon, minLat, maxLon , maxLat) == true && shift != maxShift)) {
+      if (isWithin == true || (relationImpl.cellIntersectsMBRX(minLat, maxLat, minLon, maxLon) == true && shift != maxShift)) {
         // descend: currStart need not change since shift handles end of range
         currEnd = currStart | (1L<<--shift) - 1;
       } else {
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermQueryConstantScoreWrapper.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermQueryConstantScoreWrapper.java
index 6eea8df..17e10de 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermQueryConstantScoreWrapper.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermQueryConstantScoreWrapper.java
@@ -47,7 +47,7 @@ import static org.apache.lucene.spatial.util.GeoEncodingUtils.mortonUnhashLon;
  *
  * @lucene.experimental
  */
-final class GeoPointTermQueryConstantScoreWrapper <Q extends GeoPointMultiTermQuery> extends Query {
+final class GeoPointTermQueryConstantScoreWrapper <Q extends GeoPointMultiTermQueryX> extends Query {
   protected final Q query;
 
   protected GeoPointTermQueryConstantScoreWrapper(Q query) {
@@ -140,7 +140,7 @@ final class GeoPointTermQueryConstantScoreWrapper <Q extends GeoPointMultiTermQu
               int count = sdv.count();
               for (int i = 0; i < count; i++) {
                 long hash = sdv.valueAt(i);
-                if (termsEnum.postFilter(mortonUnhashLon(hash), mortonUnhashLat(hash))) {
+                if (termsEnum.postFilterX(mortonUnhashLat(hash), mortonUnhashLon(hash))) {
                   return true;
                 }
               }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermsEnum.java b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermsEnum.java
index 9f9e251..dfd54d3 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermsEnum.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/geopoint/search/GeoPointTermsEnum.java
@@ -20,8 +20,8 @@ import org.apache.lucene.index.FilteredTermsEnum;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefBuilder;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
-import org.apache.lucene.spatial.geopoint.search.GeoPointMultiTermQuery.CellComparator;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX.TermEncoding;
+import org.apache.lucene.spatial.geopoint.search.GeoPointMultiTermQueryX.CellComparator;
 
 /**
  * Base class for {@link GeoPointNumericTermsEnum} and {@link GeoPointPrefixTermsEnum} which compares
@@ -39,13 +39,13 @@ abstract class GeoPointTermsEnum extends FilteredTermsEnum {
 
   protected final CellComparator relationImpl;
 
-  GeoPointTermsEnum(final TermsEnum tenum, final GeoPointMultiTermQuery query) {
+  GeoPointTermsEnum(final TermsEnum tenum, final GeoPointMultiTermQueryX query) {
     super(tenum);
     this.maxShift = query.maxShift;
     this.relationImpl = query.cellComparator;
   }
 
-  static GeoPointTermsEnum newInstance(final TermsEnum terms, final GeoPointMultiTermQuery query) {
+  static GeoPointTermsEnum newInstance(final TermsEnum terms, final GeoPointMultiTermQueryX query) {
     if (query.termEncoding == TermEncoding.PREFIX) {
       return new GeoPointPrefixTermsEnum(terms, query);
     } else if (query.termEncoding == TermEncoding.NUMERIC) {
@@ -98,8 +98,8 @@ abstract class GeoPointTermsEnum extends FilteredTermsEnum {
     return AcceptStatus.YES;
   }
 
-  protected boolean postFilter(final double lon, final double lat) {
-    return relationImpl.postFilter(lon, lat);
+  protected boolean postFilterX(final double lat, final double lon) {
+    return relationImpl.postFilterX(lat, lon);
   }
 
   /**
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoDistanceUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoDistanceUtils.java
index 482ed0f..69f633f 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoDistanceUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoDistanceUtils.java
@@ -34,68 +34,6 @@ public class GeoDistanceUtils {
   }
 
   /**
-   * Compute the distance between two geo-points using vincenty distance formula
-   * Vincenty uses the oblate spheroid whereas haversine uses unit sphere, this will give roughly
-   * 22m better accuracy (in worst case) than haversine
-   *
-   * @param lonA longitudinal coordinate of point A (in degrees)
-   * @param latA latitudinal coordinate of point A (in degrees)
-   * @param lonB longitudinal coordinate of point B (in degrees)
-   * @param latB latitudinal coordinate of point B (in degrees)
-   * @return distance (in meters) between point A and point B
-   */
-  public static final double vincentyDistance(final double lonA, final double latA, final double lonB, final double latB) {
-    final double L = StrictMath.toRadians(lonB - lonA);
-    final double oF = 1 - GeoProjectionUtils.FLATTENING;
-    final double U1 = StrictMath.atan(oF * StrictMath.tan(StrictMath.toRadians(latA)));
-    final double U2 = StrictMath.atan(oF * StrictMath.tan(StrictMath.toRadians(latB)));
-    final double sU1 = StrictMath.sin(U1);
-    final double cU1 = StrictMath.cos(U1);
-    final double sU2 = StrictMath.sin(U2);
-    final double cU2 = StrictMath.cos(U2);
-
-    double sigma, sinSigma, cosSigma;
-    double sinAlpha, cos2Alpha, cos2SigmaM;
-    double lambda = L;
-    double lambdaP;
-    double iters = 100;
-    double sinLambda, cosLambda, c;
-
-    do {
-      sinLambda = StrictMath.sin(lambda);
-      cosLambda = Math.cos(lambda);
-      sinSigma = Math.sqrt((cU2 * sinLambda) * (cU2 * sinLambda) + (cU1 * sU2 - sU1 * cU2 * cosLambda)
-          * (cU1 * sU2 - sU1 * cU2 * cosLambda));
-      if (sinSigma == 0) {
-        return 0;
-      }
-
-      cosSigma = sU1 * sU2 + cU1 * cU2 * cosLambda;
-      sigma = Math.atan2(sinSigma, cosSigma);
-      sinAlpha = cU1 * cU2 * sinLambda / sinSigma;
-      cos2Alpha = 1 - sinAlpha * sinAlpha;
-      cos2SigmaM = cosSigma - 2 * sU1 * sU2 / cos2Alpha;
-
-      c = GeoProjectionUtils.FLATTENING/16 * cos2Alpha * (4 + GeoProjectionUtils.FLATTENING * (4 - 3 * cos2Alpha));
-      lambdaP = lambda;
-      lambda = L + (1 - c) * GeoProjectionUtils.FLATTENING * sinAlpha * (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma *
-          (-1 + 2 * cos2SigmaM * cos2SigmaM)));
-    } while (StrictMath.abs(lambda - lambdaP) > 1E-12 && --iters > 0);
-
-    if (iters == 0) {
-      return 0;
-    }
-
-    final double uSq = cos2Alpha * (GeoProjectionUtils.SEMIMAJOR_AXIS2 - GeoProjectionUtils.SEMIMINOR_AXIS2) / (GeoProjectionUtils.SEMIMINOR_AXIS2);
-    final double A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
-    final double B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
-    final double deltaSigma = B * sinSigma * (cos2SigmaM + B/4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B/6 * cos2SigmaM
-        * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
-
-    return (GeoProjectionUtils.SEMIMINOR_AXIS * A * (sigma - deltaSigma));
-  }
-
-  /**
    * Computes distance between two points in a cartesian (x, y, {z - optional}) coordinate system
    */
   public static double linearDistance(double[] pt1, double[] pt2) {
@@ -133,11 +71,11 @@ public class GeoDistanceUtils {
 
   /**
    *  Finds the closest point within a rectangle (defined by rMinX, rMinY, rMaxX, rMaxY) to the given (lon, lat) point
-   *  the result is provided in closestPt.  When the point is outside the rectangle, the closest point is on an edge
+   *  the result is provided in closestPt (lat, lon).  When the point is outside the rectangle, the closest point is on an edge
    *  or corner of the rectangle; else, the closest point is the point itself.
    */
-  public static void closestPointOnBBox(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                        final double lon, final double lat, double[] closestPt) {
+  public static void closestPointOnBBoxX(final double rMinY, final double rMaxY, final double rMinX, final double rMaxX,
+                                         final double lat, final double lon, double[] closestPt) {
     assert closestPt != null && closestPt.length == 2;
 
     closestPt[0] = 0;
@@ -147,32 +85,32 @@ public class GeoDistanceUtils {
     boolean ySet = true;
 
     if (lon > rMaxX) {
-      closestPt[0] = rMaxX;
+      closestPt[1] = rMaxX;
     } else if (lon < rMinX) {
-      closestPt[0] = rMinX;
+      closestPt[1] = rMinX;
     } else {
       xSet = false;
     }
 
     if (lat > rMaxY) {
-      closestPt[1] = rMaxY;
+      closestPt[0] = rMaxY;
     } else if (lat < rMinY) {
-      closestPt[1] = rMinY;
+      closestPt[0] = rMinY;
     } else {
       ySet = false;
     }
 
-    if (closestPt[0] == 0 && xSet == false) {
-      closestPt[0] = lon;
+    if (closestPt[0] == 0 && ySet == false) {
+      closestPt[0] = lat;
     }
 
-    if (closestPt[1] == 0 && ySet == false) {
-      closestPt[1] = lat;
+    if (closestPt[1] == 0 && xSet == false) {
+      closestPt[1] = lon;
     }
   }
 
   /** Returns the maximum distance/radius (in meters) from the point 'center' before overlapping */
-  public static double maxRadialDistanceMeters(final double centerLon, final double centerLat) {
+  public static double maxRadialDistanceMeters(final double centerLat, final double centerLon) {
     if (Math.abs(centerLat) == GeoUtils.MAX_LAT_INCL) {
       return SloppyMath.haversinMeters(centerLat, centerLon, 0, centerLon);
     }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java
index 451688d..ac3e412 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoEncodingUtils.java
@@ -32,8 +32,9 @@ import static org.apache.lucene.spatial.util.GeoUtils.MIN_LAT_INCL;
 public final class GeoEncodingUtils {
   /** number of bits used for quantizing latitude and longitude values */
   public static final short BITS = 31;
-  private static final double LON_SCALE = (0x1L<<BITS)/360.0D;
+
   private static final double LAT_SCALE = (0x1L<<BITS)/180.0D;
+  private static final double LON_SCALE = (0x1L<<BITS)/360.0D;
 
   /**
    * The maximum term length (used for <code>byte[]</code> buffer size)
@@ -50,10 +51,10 @@ public final class GeoEncodingUtils {
   }
 
   /**
-   * encode longitude, latitude geopoint values using morton encoding method
+   * encode latitude, longitude geopoint values using morton encoding method
    * https://en.wikipedia.org/wiki/Z-order_curve
    */
-  public static final Long mortonHash(final double lon, final double lat) {
+  public static final Long mortonHashX(final double lat, final double lon) {
     return BitUtil.interleave(scaleLon(lon), scaleLat(lat));
   }
 
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoHashUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoHashUtils.java
deleted file mode 100644
index 49a7571..0000000
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoHashUtils.java
+++ /dev/null
@@ -1,283 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.spatial.util;
-
-import java.util.ArrayList;
-import java.util.Collection;
-
-import org.apache.lucene.util.BitUtil;
-
-/**
- * Utilities for converting to/from the GeoHash standard
- *
- * The geohash long format is represented as lon/lat (x/y) interleaved with the 4 least significant bits
- * representing the level (1-12) [xyxy...xyxyllll]
- *
- * This differs from a morton encoded value which interleaves lat/lon (y/x).
- *
- * @lucene.experimental
- */
-public class GeoHashUtils {
-  private static final char[] BASE_32 = {'0', '1', '2', '3', '4', '5', '6',
-      '7', '8', '9', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'n',
-      'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
-
-  private static final String BASE_32_STRING = new String(BASE_32);
-
-  /** maximum precision for geohash strings */
-  public static final int PRECISION = 12;
-  private static final short MORTON_OFFSET = (GeoEncodingUtils.BITS<<1) - (PRECISION*5);
-
-  // No instance:
-  private GeoHashUtils() {
-  }
-
-  /**
-   * Encode lon/lat to the geohash based long format (lon/lat interleaved, 4 least significant bits = level)
-   */
-  public static final long longEncode(final double lon, final double lat, final int level) {
-    // shift to appropriate level
-    final short msf = (short)(((12 - level) * 5) + MORTON_OFFSET);
-    return ((BitUtil.flipFlop(GeoEncodingUtils.mortonHash(lon, lat)) >>> msf) << 4) | level;
-  }
-
-  /**
-   * Encode from geohash string to the geohash based long format (lon/lat interleaved, 4 least significant bits = level)
-   */
-  public static final long longEncode(final String hash) {
-    int level = hash.length()-1;
-    long b;
-    long l = 0L;
-    for(char c : hash.toCharArray()) {
-      b = (long)(BASE_32_STRING.indexOf(c));
-      l |= (b<<(level--*5));
-    }
-    return (l<<4)|hash.length();
-  }
-
-  /**
-   * Encode an existing geohash long to the provided precision
-   */
-  public static long longEncode(long geohash, int level) {
-    final short precision = (short)(geohash & 15);
-    if (precision == level) {
-      return geohash;
-    } else if (precision > level) {
-      return ((geohash >>> (((precision - level) * 5) + 4)) << 4) | level;
-    }
-    return ((geohash >>> 4) << (((level - precision) * 5) + 4) | level);
-  }
-
-  /**
-   * Convert from a morton encoded long from a geohash encoded long
-   */
-  public static long fromMorton(long morton, int level) {
-    long mFlipped = BitUtil.flipFlop(morton);
-    mFlipped >>>= (((GeoHashUtils.PRECISION - level) * 5) + MORTON_OFFSET);
-    return (mFlipped << 4) | level;
-  }
-
-  /**
-   * Encode to a geohash string from the geohash based long format
-   */
-  public static final String stringEncode(long geoHashLong) {
-    int level = (int)geoHashLong&15;
-    geoHashLong >>>= 4;
-    char[] chars = new char[level];
-    do {
-      chars[--level] = BASE_32[(int) (geoHashLong&31L)];
-      geoHashLong>>>=5;
-    } while(level > 0);
-
-    return new String(chars);
-  }
-
-  /**
-   * Encode to a geohash string from full resolution longitude, latitude)
-   */
-  public static final String stringEncode(final double lon, final double lat) {
-    return stringEncode(lon, lat, 12);
-  }
-
-  /**
-   * Encode to a level specific geohash string from full resolution longitude, latitude
-   */
-  public static final String stringEncode(final double lon, final double lat, final int level) {
-    // convert to geohashlong
-    final long ghLong = fromMorton(GeoEncodingUtils.mortonHash(lon, lat), level);
-    return stringEncode(ghLong);
-
-  }
-
-  /**
-   * Encode to a full precision geohash string from a given morton encoded long value
-   */
-  public static final String stringEncodeFromMortonLong(final long hashedVal) throws Exception {
-    return stringEncode(hashedVal, PRECISION);
-  }
-
-  /**
-   * Encode to a geohash string at a given level from a morton long
-   */
-  public static final String stringEncodeFromMortonLong(long hashedVal, final int level) {
-    // bit twiddle to geohash (since geohash is a swapped (lon/lat) encoding)
-    hashedVal = BitUtil.flipFlop(hashedVal);
-
-    StringBuilder geoHash = new StringBuilder();
-    short precision = 0;
-    final short msf = (GeoEncodingUtils.BITS<<1)-5;
-    long mask = 31L<<msf;
-    do {
-      geoHash.append(BASE_32[(int)((mask & hashedVal)>>>(msf-(precision*5)))]);
-      // next 5 bits
-      mask >>>= 5;
-    } while (++precision < level);
-    return geoHash.toString();
-  }
-
-  /**
-   * Encode to a morton long value from a given geohash string
-   */
-  public static final long mortonEncode(final String hash) {
-    int level = 11;
-    long b;
-    long l = 0L;
-    for(char c : hash.toCharArray()) {
-      b = (long)(BASE_32_STRING.indexOf(c));
-      l |= (b<<((level--*5) + MORTON_OFFSET));
-    }
-    return BitUtil.flipFlop(l);
-  }
-
-  /**
-   * Encode to a morton long value from a given geohash long value
-   */
-  public static final long mortonEncode(final long geoHashLong) {
-    final int level = (int)(geoHashLong&15);
-    final short odd = (short)(level & 1);
-
-    return BitUtil.flipFlop(((geoHashLong >>> 4) << odd) << (((12 - level) * 5) + (MORTON_OFFSET - odd)));
-  }
-
-  private static final char encode(int x, int y) {
-    return BASE_32[((x & 1) + ((y & 1) * 2) + ((x & 2) * 2) + ((y & 2) * 4) + ((x & 4) * 4)) % 32];
-  }
-
-  /**
-   * Calculate all neighbors of a given geohash cell.
-   *
-   * @param geohash Geohash of the defined cell
-   * @return geohashes of all neighbor cells
-   */
-  public static Collection<? extends CharSequence> neighbors(String geohash) {
-    return addNeighbors(geohash, geohash.length(), new ArrayList<CharSequence>(8));
-  }
-
-  /**
-   * Calculate the geohash of a neighbor of a geohash
-   *
-   * @param geohash the geohash of a cell
-   * @param level   level of the geohash
-   * @param dx      delta of the first grid coordinate (must be -1, 0 or +1)
-   * @param dy      delta of the second grid coordinate (must be -1, 0 or +1)
-   * @return geohash of the defined cell
-   */
-  public final static String neighbor(String geohash, int level, int dx, int dy) {
-    int cell = BASE_32_STRING.indexOf(geohash.charAt(level -1));
-
-    // Decoding the Geohash bit pattern to determine grid coordinates
-    int x0 = cell & 1;  // first bit of x
-    int y0 = cell & 2;  // first bit of y
-    int x1 = cell & 4;  // second bit of x
-    int y1 = cell & 8;  // second bit of y
-    int x2 = cell & 16; // third bit of x
-
-    // combine the bitpattern to grid coordinates.
-    // note that the semantics of x and y are swapping
-    // on each level
-    int x = x0 + (x1 / 2) + (x2 / 4);
-    int y = (y0 / 2) + (y1 / 4);
-
-    if (level == 1) {
-      // Root cells at north (namely "bcfguvyz") or at
-      // south (namely "0145hjnp") do not have neighbors
-      // in north/south direction
-      if ((dy < 0 && y == 0) || (dy > 0 && y == 3)) {
-        return null;
-      } else {
-        return Character.toString(encode(x + dx, y + dy));
-      }
-    } else {
-      // define grid coordinates for next level
-      final int nx = ((level % 2) == 1) ? (x + dx) : (x + dy);
-      final int ny = ((level % 2) == 1) ? (y + dy) : (y + dx);
-
-      // if the defined neighbor has the same parent a the current cell
-      // encode the cell directly. Otherwise find the cell next to this
-      // cell recursively. Since encoding wraps around within a cell
-      // it can be encoded here.
-      // xLimit and YLimit must always be respectively 7 and 3
-      // since x and y semantics are swapping on each level.
-      if (nx >= 0 && nx <= 7 && ny >= 0 && ny <= 3) {
-        return geohash.substring(0, level - 1) + encode(nx, ny);
-      } else {
-        String neighbor = neighbor(geohash, level - 1, dx, dy);
-        return (neighbor != null) ? neighbor + encode(nx, ny) : neighbor;
-      }
-    }
-  }
-
-  /**
-   * Add all geohashes of the cells next to a given geohash to a list.
-   *
-   * @param geohash   Geohash of a specified cell
-   * @param neighbors list to add the neighbors to
-   * @return the given list
-   */
-  public static final <E extends Collection<? super String>> E addNeighbors(String geohash, E neighbors) {
-    return addNeighbors(geohash, geohash.length(), neighbors);
-  }
-
-  /**
-   * Add all geohashes of the cells next to a given geohash to a list.
-   *
-   * @param geohash   Geohash of a specified cell
-   * @param length    level of the given geohash
-   * @param neighbors list to add the neighbors to
-   * @return the given list
-   */
-  public static final <E extends Collection<? super String>> E addNeighbors(String geohash, int length, E neighbors) {
-    String south = neighbor(geohash, length, 0, -1);
-    String north = neighbor(geohash, length, 0, +1);
-    if (north != null) {
-      neighbors.add(neighbor(north, length, -1, 0));
-      neighbors.add(north);
-      neighbors.add(neighbor(north, length, +1, 0));
-    }
-
-    neighbors.add(neighbor(geohash, length, -1, 0));
-    neighbors.add(neighbor(geohash, length, +1, 0));
-
-    if (south != null) {
-      neighbors.add(neighbor(south, length, -1, 0));
-      neighbors.add(south);
-      neighbors.add(neighbor(south, length, +1, 0));
-    }
-
-    return neighbors;
-  }
-}
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoProjectionUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoProjectionUtils.java
index 12d1350..0acff32 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoProjectionUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoProjectionUtils.java
@@ -69,83 +69,14 @@ public class GeoProjectionUtils {
   }
 
   /**
-   * Converts from geocentric earth-centered earth-fixed to geodesic lat/lon/alt
-   * @param x Cartesian x coordinate
-   * @param y Cartesian y coordinate
-   * @param z Cartesian z coordinate
-   * @param lla 0: longitude 1: latitude: 2: altitude
-   * @return double array as 0: longitude 1: latitude 2: altitude
-   */
-  public static final double[] ecfToLLA(final double x, final double y, final double z, double[] lla) {
-    boolean atPole = false;
-    final double ad_c = 1.0026000D;
-    final double cos67P5 = 0.38268343236508977D;
-
-    if (lla == null) {
-      lla = new double[3];
-    }
-
-    if (x != 0.0) {
-      lla[0] = StrictMath.atan2(y,x);
-    } else {
-      if (y > 0) {
-        lla[0] = PIO2;
-      } else if (y < 0) {
-        lla[0] = -PIO2;
-      } else {
-        atPole = true;
-        lla[0] = 0.0D;
-        if (z > 0.0) {
-          lla[1] = PIO2;
-        } else if (z < 0.0) {
-          lla[1] = -PIO2;
-        } else {
-          lla[1] = PIO2;
-          lla[2] = -SEMIMINOR_AXIS;
-          return lla;
-        }
-      }
-    }
-
-    final double w2 = x*x + y*y;
-    final double w = StrictMath.sqrt(w2);
-    final double t0 = z * ad_c;
-    final double s0 = StrictMath.sqrt(t0 * t0 + w2);
-    final double sinB0 = t0 / s0;
-    final double cosB0 = w / s0;
-    final double sin3B0 = sinB0 * sinB0 * sinB0;
-    final double t1 = z + SEMIMINOR_AXIS * EP2 * sin3B0;
-    final double sum = w - SEMIMAJOR_AXIS * E2 * cosB0 * cosB0 * cosB0;
-    final double s1 = StrictMath.sqrt(t1 * t1 + sum * sum);
-    final double sinP1 = t1 / s1;
-    final double cosP1 = sum / s1;
-    final double rn = SEMIMAJOR_AXIS / StrictMath.sqrt(1.0D - E2 * sinP1 * sinP1);
-
-    if (cosP1 >= cos67P5) {
-      lla[2] = w / cosP1 - rn;
-    } else if (cosP1 <= -cos67P5) {
-      lla[2] = w / -cosP1 - rn;
-    } else {
-      lla[2] = z / sinP1 + rn * (E2 - 1.0);
-    }
-    if (!atPole) {
-      lla[1] = StrictMath.atan(sinP1/cosP1);
-    }
-    lla[0] = TO_DEGREES * lla[0];
-    lla[1] = TO_DEGREES * lla[1];
-
-    return lla;
-  }
-
-  /**
-   * Converts from geodesic lon lat alt to geocentric earth-centered earth-fixed
-   * @param lon geodesic longitude
+   * Converts from geodesic lat lon alt to geocentric earth-centered earth-fixed
    * @param lat geodesic latitude
+   * @param lon geodesic longitude
    * @param alt geodesic altitude
    * @param ecf reusable earth-centered earth-fixed result
    * @return either a new ecef array or the reusable ecf parameter
    */
-  public static final double[] llaToECF(double lon, double lat, double alt, double[] ecf) {
+  public static final double[] llaToECFX(double lat, double lon, double alt, double[] ecf) {
     lon = TO_RADIANS * lon;
     lat = TO_RADIANS * lat;
 
@@ -177,261 +108,23 @@ public class GeoProjectionUtils {
   }
 
   /**
-   * Converts from lat lon alt (in degrees) to East North Up right-hand coordinate system
-   * @param lon longitude in degrees
-   * @param lat latitude in degrees
-   * @param alt altitude in meters
-   * @param centerLon reference point longitude in degrees
-   * @param centerLat reference point latitude in degrees
-   * @param centerAlt reference point altitude in meters
-   * @param enu result east, north, up coordinate
-   * @return east, north, up coordinate
-   */
-  public static double[] llaToENU(final double lon, final double lat, final double alt, double centerLon,
-                                  double centerLat, final double centerAlt, double[] enu) {
-    if (enu == null) {
-      enu = new double[3];
-    }
-
-    // convert point to ecf coordinates
-    final double[] ecf = llaToECF(lon, lat, alt, null);
-
-    // convert from ecf to enu
-    return ecfToENU(ecf[0], ecf[1], ecf[2], centerLon, centerLat, centerAlt, enu);
-  }
-
-  /**
-   * Converts from East North Up right-hand rule to lat lon alt in degrees
-   * @param x easting (in meters)
-   * @param y northing (in meters)
-   * @param z up (in meters)
-   * @param centerLon reference point longitude (in degrees)
-   * @param centerLat reference point latitude (in degrees)
-   * @param centerAlt reference point altitude (in meters)
-   * @param lla resulting lat, lon, alt point (in degrees)
-   * @return lat, lon, alt point (in degrees)
-   */
-  public static double[] enuToLLA(final double x, final double y, final double z, final double centerLon,
-                                  final double centerLat, final double centerAlt, double[] lla) {
-    // convert enuToECF
-    if (lla == null) {
-      lla = new double[3];
-    }
-
-    // convert enuToECF, storing intermediate result in lla
-    lla = enuToECF(x, y, z, centerLon, centerLat, centerAlt, lla);
-
-    // convert ecf to LLA
-    return ecfToLLA(lla[0], lla[1], lla[2], lla);
-  }
-
-  /**
-   * Convert from Earth-Centered-Fixed to Easting, Northing, Up Right Hand System
-   * @param x ECF X coordinate (in meters)
-   * @param y ECF Y coordinate (in meters)
-   * @param z ECF Z coordinate (in meters)
-   * @param centerLon ENU origin longitude (in degrees)
-   * @param centerLat ENU origin latitude (in degrees)
-   * @param centerAlt ENU altitude (in meters)
-   * @param enu reusable enu result
-   * @return Easting, Northing, Up coordinate
-   */
-  public static double[] ecfToENU(double x, double y, double z, final double centerLon,
-                                  final double centerLat, final double centerAlt, double[] enu) {
-    if (enu == null) {
-      enu = new double[3];
-    }
-
-    // create rotation matrix and rotate to enu orientation
-    final double[][] phi = createPhiTransform(centerLon, centerLat, null);
-
-    // convert origin to ENU
-    final double[] originECF = llaToECF(centerLon, centerLat, centerAlt, null);
-    final double[] originENU = new double[3];
-    originENU[0] = ((phi[0][0] * originECF[0]) + (phi[0][1] * originECF[1]) + (phi[0][2] * originECF[2]));
-    originENU[1] = ((phi[1][0] * originECF[0]) + (phi[1][1] * originECF[1]) + (phi[1][2] * originECF[2]));
-    originENU[2] = ((phi[2][0] * originECF[0]) + (phi[2][1] * originECF[1]) + (phi[2][2] * originECF[2]));
-
-    // rotate then translate
-    enu[0] = ((phi[0][0] * x) + (phi[0][1] * y) + (phi[0][2] * z)) - originENU[0];
-    enu[1] = ((phi[1][0] * x) + (phi[1][1] * y) + (phi[1][2] * z)) - originENU[1];
-    enu[2] = ((phi[2][0] * x) + (phi[2][1] * y) + (phi[2][2] * z)) - originENU[2];
-
-    return enu;
-  }
-
-  /**
-   * Convert from Easting, Northing, Up Right-Handed system to Earth Centered Fixed system
-   * @param x ENU x coordinate (in meters)
-   * @param y ENU y coordinate (in meters)
-   * @param z ENU z coordinate (in meters)
-   * @param centerLon ENU origin longitude (in degrees)
-   * @param centerLat ENU origin latitude (in degrees)
-   * @param centerAlt ENU origin altitude (in meters)
-   * @param ecf reusable ecf result
-   * @return ecf result coordinate
-   */
-  public static double[] enuToECF(final double x, final double y, final double z, double centerLon,
-                                  double centerLat, final double centerAlt, double[] ecf) {
-    if (ecf == null) {
-      ecf = new double[3];
-    }
-
-    double[][] phi = createTransposedPhiTransform(centerLon, centerLat, null);
-    double[] ecfOrigin = llaToECF(centerLon, centerLat, centerAlt, null);
-
-    // rotate and translate
-    ecf[0] = (phi[0][0]*x + phi[0][1]*y + phi[0][2]*z) + ecfOrigin[0];
-    ecf[1] = (phi[1][0]*x + phi[1][1]*y + phi[1][2]*z) + ecfOrigin[1];
-    ecf[2] = (phi[2][0]*x + phi[2][1]*y + phi[2][2]*z) + ecfOrigin[2];
-
-    return ecf;
-  }
-
-  /**
-   * Create the rotation matrix for converting Earth Centered Fixed to Easting Northing Up
-   * @param originLon ENU origin longitude (in degrees)
-   * @param originLat ENU origin latitude (in degrees)
-   * @param phiMatrix reusable phi matrix result
-   * @return phi rotation matrix
-   */
-  private static double[][] createPhiTransform(double originLon, double originLat, double[][] phiMatrix) {
-
-    if (phiMatrix == null) {
-      phiMatrix = new double[3][3];
-    }
-
-    originLon = TO_RADIANS * originLon;
-    originLat = TO_RADIANS * originLat;
-
-    final double sLon = sloppySin(originLon);
-    final double cLon = cos(originLon);
-    final double sLat = sloppySin(originLat);
-    final double cLat = cos(originLat);
-
-    phiMatrix[0][0] = -sLon;
-    phiMatrix[0][1] = cLon;
-    phiMatrix[0][2] = 0.0D;
-    phiMatrix[1][0] = -sLat * cLon;
-    phiMatrix[1][1] = -sLat * sLon;
-    phiMatrix[1][2] = cLat;
-    phiMatrix[2][0] = cLat * cLon;
-    phiMatrix[2][1] = cLat * sLon;
-    phiMatrix[2][2] = sLat;
-
-    return phiMatrix;
-  }
-
-  /**
-   * Create the transposed rotation matrix for converting Easting Northing Up coordinates to Earth Centered Fixed
-   * @param originLon ENU origin longitude (in degrees)
-   * @param originLat ENU origin latitude (in degrees)
-   * @param phiMatrix reusable phi rotation matrix result
-   * @return transposed phi rotation matrix
-   */
-  private static double[][] createTransposedPhiTransform(double originLon, double originLat, double[][] phiMatrix) {
-
-    if (phiMatrix == null) {
-      phiMatrix = new double[3][3];
-    }
-
-    originLon = TO_RADIANS * originLon;
-    originLat = TO_RADIANS * originLat;
-
-    final double sLat = sloppySin(originLat);
-    final double cLat = cos(originLat);
-    final double sLon = sloppySin(originLon);
-    final double cLon = cos(originLon);
-
-    phiMatrix[0][0] = -sLon;
-    phiMatrix[1][0] = cLon;
-    phiMatrix[2][0] = 0.0D;
-    phiMatrix[0][1] = -sLat * cLon;
-    phiMatrix[1][1] = -sLat * sLon;
-    phiMatrix[2][1] = cLat;
-    phiMatrix[0][2] = cLat * cLon;
-    phiMatrix[1][2] = cLat * sLon;
-    phiMatrix[2][2] = sLat;
-
-    return phiMatrix;
-  }
-
-  /**
-   * Finds a point along a bearing from a given lon,lat geolocation using vincenty's distance formula
+   * Finds a point along a bearing from a given lat,lon geolocation using great circle arc
    *
-   * @param lon origin longitude in degrees
    * @param lat origin latitude in degrees
-   * @param bearing azimuthal bearing in degrees
-   * @param dist distance in meters
-   * @param pt resulting point
-   * @return the point along a bearing at a given distance in meters
-   */
-  public static final double[] pointFromLonLatBearingVincenty(double lon, double lat, double bearing, double dist, double[] pt) {
-
-    if (pt == null) {
-      pt = new double[2];
-    }
-
-    final double alpha1 = TO_RADIANS * bearing;
-    final double cosA1 = cos(alpha1);
-    final double sinA1 = sloppySin(alpha1);
-    final double tanU1 = (1-FLATTENING) * sloppyTan(TO_RADIANS * lat);
-    final double cosU1 = 1 / StrictMath.sqrt((1+tanU1*tanU1));
-    final double sinU1 = tanU1*cosU1;
-    final double sig1 = StrictMath.atan2(tanU1, cosA1);
-    final double sinAlpha = cosU1 * sinA1;
-    final double cosSqAlpha = 1 - sinAlpha*sinAlpha;
-    final double uSq = cosSqAlpha * EP2;
-    final double A = 1 + uSq/16384D*(4096D + uSq * (-768D + uSq * (320D - 175D*uSq)));
-    final double B = uSq/1024D * (256D + uSq * (-128D + uSq * (74D - 47D * uSq)));
-
-    double sigma = dist / (SEMIMINOR_AXIS*A);
-    double sigmaP;
-    double sinSigma, cosSigma, cos2SigmaM, deltaSigma;
-
-    do {
-      cos2SigmaM = cos(2*sig1 + sigma);
-      sinSigma = sloppySin(sigma);
-      cosSigma = cos(sigma);
-
-      deltaSigma = B * sinSigma * (cos2SigmaM + (B/4D) * (cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-
-          (B/6) * cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));
-      sigmaP = sigma;
-      sigma = dist / (SEMIMINOR_AXIS*A) + deltaSigma;
-    } while (StrictMath.abs(sigma-sigmaP) > 1E-12);
-
-    final double tmp = sinU1*sinSigma - cosU1*cosSigma*cosA1;
-    final double lat2 = StrictMath.atan2(sinU1*cosSigma + cosU1*sinSigma*cosA1,
-        (1-FLATTENING) * StrictMath.sqrt(sinAlpha*sinAlpha + tmp*tmp));
-    final double lambda = StrictMath.atan2(sinSigma*sinA1, cosU1*cosSigma - sinU1*sinSigma*cosA1);
-    final double c = FLATTENING/16 * cosSqAlpha * (4 + FLATTENING * (4 - 3 * cosSqAlpha));
-
-    final double lam = lambda - (1-c) * FLATTENING * sinAlpha *
-        (sigma + c * sinSigma * (cos2SigmaM + c * cosSigma * (-1 + 2* cos2SigmaM*cos2SigmaM)));
-    pt[0] = normalizeLon(lon + TO_DEGREES * lam);
-    pt[1] = normalizeLat(TO_DEGREES * lat2);
-
-    return pt;
-  }
-
-  /**
-   * Finds a point along a bearing from a given lon,lat geolocation using great circle arc
-   *
    * @param lon origin longitude in degrees
-   * @param lat origin latitude in degrees
    * @param bearing azimuthal bearing in degrees
    * @param dist distance in meters
    * @param pt resulting point
    * @return the point along a bearing at a given distance in meters
    */
-  public static final double[] pointFromLonLatBearingGreatCircle(double lon, double lat, double bearing, double dist, double[] pt) {
+  public static final double[] pointFromLonLatBearingGreatCircleX(double lat, double lon, double bearing, double dist, double[] pt) {
 
     if (pt == null) {
       pt = new double[2];
     }
 
-    lon *= TO_RADIANS;
     lat *= TO_RADIANS;
+    lon *= TO_RADIANS;
     bearing *= TO_RADIANS;
 
     final double cLat = cos(lat);
@@ -447,14 +140,14 @@ public class GeoProjectionUtils {
   }
 
   /**
-   * Finds the bearing (in degrees) between 2 geo points (lon, lat) using great circle arc
-   * @param lon1 first point longitude in degrees
+   * Finds the bearing (in degrees) between 2 geo points (lat, lon) using great circle arc
    * @param lat1 first point latitude in degrees
-   * @param lon2 second point longitude in degrees
+   * @param lon1 first point longitude in degrees
    * @param lat2 second point latitude in degrees
+   * @param lon2 second point longitude in degrees
    * @return the bearing (in degrees) between the two provided points
    */
-  public static double bearingGreatCircle(double lon1, double lat1, double lon2, double lat2) {
+  public static double bearingGreatCircleX(double lat1, double lon1, double lat2, double lon2) {
     double dLon = (lon2 - lon1) * TO_RADIANS;
     lat2 *= TO_RADIANS;
     lat1 *= TO_RADIANS;
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRect.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRect.java
index e147351..8d947b4 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRect.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRect.java
@@ -18,19 +18,19 @@ package org.apache.lucene.spatial.util;
 
 /** Represents a lat/lon rectangle. */
 public class GeoRect {
-  /** minimum longitude value (in degrees) */
-  public final double minLon;
-  /** minimum latitude value (in degrees) */
-  public final double maxLon;
   /** maximum longitude value (in degrees) */
   public final double minLat;
+  /** minimum longitude value (in degrees) */
+  public final double minLon;
   /** maximum latitude value (in degrees) */
   public final double maxLat;
+  /** minimum latitude value (in degrees) */
+  public final double maxLon;
 
   /**
    * Constructs a bounding box by first validating the provided latitude and longitude coordinates
    */
-  public GeoRect(double minLon, double maxLon, double minLat, double maxLat) {
+  public GeoRect(double minLat, double maxLat, double minLon, double maxLon) {
     if (GeoUtils.isValidLon(minLon) == false) {
       throw new IllegalArgumentException("invalid minLon " + minLon);
     }
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRelationUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRelationUtils.java
index e40b91a..d45c0bb 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRelationUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoRelationUtils.java
@@ -28,13 +28,14 @@ public class GeoRelationUtils {
   }
 
   /**
-   * Determine if a bbox (defined by minLon, minLat, maxLon, maxLat) contains the provided point (defined by lon, lat)
+   * Determine if a bbox (defined by minLat, maxLat, minLon, maxLon) contains the provided point (defined by lat, lon)
    * NOTE: this is a basic method that does not handle dateline or pole crossing. Unwrapping must be done before
    * calling this method.
    */
-  public static boolean pointInRectPrecise(final double lon, final double lat, final double minLon,
-                                           final double minLat, final double maxLon, final double maxLat) {
-    return lon >= minLon && lon <= maxLon && lat >= minLat && lat <= maxLat;
+  public static boolean pointInRectPreciseX(final double lat, final double lon,
+                                            final double minLat, final double maxLat,
+                                            final double minLon, final double maxLon) {
+    return lat >= minLat && lat <= maxLat && lon >= minLon && lon <= maxLon;
   }
 
   /**
@@ -46,17 +47,17 @@ public class GeoRelationUtils {
    *
    * NOTE: Requires polygon point (x,y) order either clockwise or counter-clockwise
    */
-  public static boolean pointInPolygon(double[] x, double[] y, double lat, double lon) {
-    assert x.length == y.length;
+  public static boolean pointInPolygonX(double[] polyLats, double[] polyLons, double lat, double lon) {
+    assert polyLats.length == polyLons.length;
     boolean inPoly = false;
     /**
      * Note: This is using a euclidean coordinate system which could result in
      * upwards of 110KM error at the equator.
      * TODO convert coordinates to cylindrical projection (e.g. mercator)
      */
-    for (int i = 1; i < x.length; i++) {
-      if (x[i] <= lon && x[i-1] >= lon || x[i-1] <= lon && x[i] >= lon) {
-        if (y[i] + (lon - x[i]) / (x[i-1] - x[i]) * (y[i-1] - y[i]) <= lat) {
+    for (int i = 1; i < polyLats.length; i++) {
+      if (polyLons[i] <= lon && polyLons[i-1] >= lon || polyLons[i-1] <= lon && polyLons[i] >= lon) {
+        if (polyLats[i] + (lon - polyLons[i]) / (polyLons[i-1] - polyLons[i]) * (polyLats[i-1] - polyLats[i]) <= lat) {
           inPoly = !inPoly;
         }
       }
@@ -71,42 +72,34 @@ public class GeoRelationUtils {
   /**
    * Computes whether two rectangles are disjoint
    */
-  public static boolean rectDisjoint(final double aMinX, final double aMinY, final double aMaxX, final double aMaxY,
-                                     final double bMinX, final double bMinY, final double bMaxX, final double bMaxY) {
-    return (aMaxX < bMinX || aMinX > bMaxX || aMaxY < bMinY || aMinY > bMaxY);
+  private static boolean rectDisjointX(final double aMinLat, final double aMaxLat, final double aMinLon, final double aMaxLon,
+                                       final double bMinLat, final double bMaxLat, final double bMinLon, final double bMaxLon) {
+    return (aMaxLon < bMinLon || aMinLon > bMaxLon || aMaxLat < bMinLat || aMinLat > bMaxLat);
   }
 
   /**
    * Computes whether the first (a) rectangle is wholly within another (b) rectangle (shared boundaries allowed)
    */
-  public static boolean rectWithin(final double aMinX, final double aMinY, final double aMaxX, final double aMaxY,
-                                   final double bMinX, final double bMinY, final double bMaxX, final double bMaxY) {
-    return !(aMinX < bMinX || aMinY < bMinY || aMaxX > bMaxX || aMaxY > bMaxY);
+  public static boolean rectWithinX(final double aMinLat, final double aMaxLat, final double aMinLon, final double aMaxLon,
+                                    final double bMinLat, final double bMaxLat, final double bMinLon, final double bMaxLon) {
+    return !(aMinLon < bMinLon || aMinLat < bMinLat || aMaxLon > bMaxLon || aMaxLat > bMaxLat);
   }
 
   /**
    * Computes whether two rectangles cross
    */
-  public static boolean rectCrosses(final double aMinX, final double aMinY, final double aMaxX, final double aMaxY,
-                                    final double bMinX, final double bMinY, final double bMaxX, final double bMaxY) {
-    return !(rectDisjoint(aMinX, aMinY, aMaxX, aMaxY, bMinX, bMinY, bMaxX, bMaxY) ||
-        rectWithin(aMinX, aMinY, aMaxX, aMaxY, bMinX, bMinY, bMaxX, bMaxY));
-  }
-
-  /**
-   * Computes whether rectangle a contains rectangle b (touching allowed)
-   */
-  public static boolean rectContains(final double aMinX, final double aMinY, final double aMaxX, final double aMaxY,
-                                     final double bMinX, final double bMinY, final double bMaxX, final double bMaxY) {
-    return !(bMinX < aMinX || bMinY < aMinY || bMaxX > aMaxX || bMaxY > aMaxY);
+  public static boolean rectCrossesX(final double aMinLat, final double aMaxLat, final double aMinLon, final double aMaxLon,
+                                     final double bMinLat, final double bMaxLat, final double bMinLon, final double bMaxLon) {
+    return !(rectDisjointX(aMinLat, aMaxLat, aMinLon, aMaxLon, bMinLat, bMaxLat, bMinLon, bMaxLon) ||
+             rectWithinX(aMinLat, aMaxLat, aMinLon, aMaxLon, bMinLat, bMaxLat, bMinLon, bMaxLon));
   }
 
   /**
    * Computes whether a rectangle intersects another rectangle (crosses, within, touching, etc)
    */
-  public static boolean rectIntersects(final double aMinX, final double aMinY, final double aMaxX, final double aMaxY,
-                                       final double bMinX, final double bMinY, final double bMaxX, final double bMaxY) {
-    return !((aMaxX < bMinX || aMinX > bMaxX || aMaxY < bMinY || aMinY > bMaxY) );
+  public static boolean rectIntersectsX(final double aMinLat, final double aMaxLat, final double aMinLon, final double aMaxLon,
+                                        final double bMinLat, final double bMaxLat, final double bMinLon, final double bMaxLon) {
+    return !((aMaxLon < bMinLon || aMinLon > bMaxLon || aMaxLat < bMinLat || aMinLat > bMaxLat));
   }
 
   /////////////////////////
@@ -116,33 +109,35 @@ public class GeoRelationUtils {
   /**
    * Convenience method for accurately computing whether a rectangle crosses a poly
    */
-  public static boolean rectCrossesPolyPrecise(final double rMinX, final double rMinY, final double rMaxX,
-                                        final double rMaxY, final double[] shapeX, final double[] shapeY,
-                                        final double sMinX, final double sMinY, final double sMaxX,
-                                        final double sMaxY) {
+  public static boolean rectCrossesPolyPreciseX(final double rMinLat, final double rMaxLat,
+                                                final double rMinLon, final double rMaxLon,
+                                                final double[] shapeLat, final double[] shapeLon,
+                                                final double sMinLat, final double sMaxLat,
+                                                final double sMinLon, final double sMaxLon) {
     // short-circuit: if the bounding boxes are disjoint then the shape does not cross
-    if (rectDisjoint(rMinX, rMinY, rMaxX, rMaxY, sMinX, sMinY, sMaxX, sMaxY)) {
+    if (rectDisjointX(rMinLat, rMaxLat, rMinLon, rMaxLon, sMinLat, sMaxLat, sMinLon, sMaxLon)) {
       return false;
     }
-    return rectCrossesPoly(rMinX, rMinY, rMaxX, rMaxY, shapeX, shapeY);
+    return rectCrossesPolyX(rMinLat, rMaxLat, rMinLon, rMaxLon, shapeLat, shapeLon);
   }
 
   /**
    * Compute whether a rectangle crosses a shape. (touching not allowed) Includes a flag for approximating the
    * relation.
    */
-  public static boolean rectCrossesPolyApprox(final double rMinX, final double rMinY, final double rMaxX,
-                                              final double rMaxY, final double[] shapeX, final double[] shapeY,
-                                              final double sMinX, final double sMinY, final double sMaxX,
-                                              final double sMaxY) {
+  public static boolean rectCrossesPolyApproxX(final double rMinLat, final double rMaxLat,
+                                               final double rMinLon, final double rMaxLon,
+                                               final double[] shapeLat, final double[] shapeLon,
+                                               final double sMinLat, final double sMaxLat,
+                                               final double sMinLon, final double sMaxLon) {
     // short-circuit: if the bounding boxes are disjoint then the shape does not cross
-    if (rectDisjoint(rMinX, rMinY, rMaxX, rMaxY, sMinX, sMinY, sMaxX, sMaxY)) {
+    if (rectDisjointX(rMinLat, rMaxLat, rMinLon, rMaxLon, sMinLat, sMaxLat, sMinLon, sMaxLon)) {
       return false;
     }
 
-    final int polyLength = shapeX.length-1;
+    final int polyLength = shapeLon.length-1;
     for (short p=0; p<polyLength; ++p) {
-      if (lineCrossesRect(shapeX[p], shapeY[p], shapeX[p+1], shapeY[p+1], rMinX, rMinY, rMaxX, rMaxY) == true) {
+      if (lineCrossesRectX(shapeLat[p], shapeLon[p], shapeLat[p+1], shapeLon[p+1], rMinLat, rMaxLat, rMinLon, rMaxLon) == true) {
         return true;
       }
     }
@@ -152,10 +147,11 @@ public class GeoRelationUtils {
   /**
    * Accurately compute (within restrictions of cartesian decimal degrees) whether a rectangle crosses a polygon
    */
-  private static boolean rectCrossesPoly(final double rMinX, final double rMinY, final double rMaxX,
-                                         final double rMaxY, final double[] shapeX, final double[] shapeY) {
-    final double[][] bbox = new double[][] { {rMinX, rMinY}, {rMaxX, rMinY}, {rMaxX, rMaxY}, {rMinX, rMaxY}, {rMinX, rMinY} };
-    final int polyLength = shapeX.length-1;
+  private static boolean rectCrossesPolyX(final double rMinLat, final double rMaxLat,
+                                          final double rMinLon, final double rMaxLon,
+                                          final double[] shapeLats, final double[] shapeLons) {
+    final double[][] bbox = new double[][] { {rMinLon, rMinLat}, {rMaxLon, rMinLat}, {rMaxLon, rMaxLat}, {rMinLon, rMaxLat}, {rMinLon, rMinLat} };
+    final int polyLength = shapeLons.length-1;
     double d, s, t, a1, b1, c1, a2, b2, c2;
     double x00, y00, x01, y01, x10, y10, x11, y11;
 
@@ -165,23 +161,23 @@ public class GeoRelationUtils {
       b1 = bbox[b][0]-bbox[b+1][0];
       c1 = a1*bbox[b+1][0] + b1*bbox[b+1][1];
       for (int p=0; p<polyLength; ++p) {
-        a2 = shapeY[p+1]-shapeY[p];
-        b2 = shapeX[p]-shapeX[p+1];
+        a2 = shapeLats[p+1]-shapeLats[p];
+        b2 = shapeLons[p]-shapeLons[p+1];
         // compute determinant
         d = a1*b2 - a2*b1;
         if (d != 0) {
           // lines are not parallel, check intersecting points
-          c2 = a2*shapeX[p+1] + b2*shapeY[p+1];
+          c2 = a2*shapeLons[p+1] + b2*shapeLats[p+1];
           s = (1/d)*(b2*c1 - b1*c2);
           t = (1/d)*(a1*c2 - a2*c1);
           x00 = StrictMath.min(bbox[b][0], bbox[b+1][0]) - GeoEncodingUtils.TOLERANCE;
           x01 = StrictMath.max(bbox[b][0], bbox[b+1][0]) + GeoEncodingUtils.TOLERANCE;
           y00 = StrictMath.min(bbox[b][1], bbox[b+1][1]) - GeoEncodingUtils.TOLERANCE;
           y01 = StrictMath.max(bbox[b][1], bbox[b+1][1]) + GeoEncodingUtils.TOLERANCE;
-          x10 = StrictMath.min(shapeX[p], shapeX[p+1]) - GeoEncodingUtils.TOLERANCE;
-          x11 = StrictMath.max(shapeX[p], shapeX[p+1]) + GeoEncodingUtils.TOLERANCE;
-          y10 = StrictMath.min(shapeY[p], shapeY[p+1]) - GeoEncodingUtils.TOLERANCE;
-          y11 = StrictMath.max(shapeY[p], shapeY[p+1]) + GeoEncodingUtils.TOLERANCE;
+          x10 = StrictMath.min(shapeLons[p], shapeLons[p+1]) - GeoEncodingUtils.TOLERANCE;
+          x11 = StrictMath.max(shapeLons[p], shapeLons[p+1]) + GeoEncodingUtils.TOLERANCE;
+          y10 = StrictMath.min(shapeLats[p], shapeLats[p+1]) - GeoEncodingUtils.TOLERANCE;
+          y11 = StrictMath.max(shapeLats[p], shapeLats[p+1]) + GeoEncodingUtils.TOLERANCE;
           // check whether the intersection point is touching one of the line segments
           boolean touching = ((x00 == s && y00 == t) || (x01 == s && y01 == t))
               || ((x10 == s && y10 == t) || (x11 == s && y11 == t));
@@ -195,30 +191,35 @@ public class GeoRelationUtils {
     return false;
   }
 
-  private static boolean lineCrossesRect(double aX1, double aY1, double aX2, double aY2,
-                                         final double rMinX, final double rMinY, final double rMaxX, final double rMaxY) {
+  private static boolean lineCrossesRectX(double aLat1, double aLon1,
+                                          double aLat2, double aLon2,
+                                          final double rMinLat, final double rMaxLat,
+                                          final double rMinLon, final double rMaxLon) {
     // short-circuit: if one point inside rect, other outside
-    if (pointInRectPrecise(aX1, aY1, rMinX, rMinY, rMaxX, rMaxY) ?
-        !pointInRectPrecise(aX2, aY2, rMinX, rMinY, rMaxX, rMaxY) : pointInRectPrecise(aX2, aY2, rMinX, rMinY, rMaxX, rMaxY)) {
+    if (pointInRectPreciseX(aLat1, aLon1, rMinLat, rMaxLat, rMinLon, rMaxLon)) {
+      if (pointInRectPreciseX(aLat2, aLon2, rMinLat, rMaxLat, rMinLon, rMaxLon) == false) {
+        return true;
+      }
+    } else if (pointInRectPreciseX(aLat2, aLon2, rMinLat, rMaxLat, rMinLon, rMaxLon)) {
       return true;
     }
 
-    return lineCrossesLine(aX1, aY1, aX2, aY2, rMinX, rMinY, rMaxX, rMaxY)
-        || lineCrossesLine(aX1, aY1, aX2, aY2, rMaxX, rMinY, rMinX, rMaxY);
+    return lineCrossesLineX(aLat1, aLon1, aLat2, aLon2, rMinLat, rMinLon, rMaxLat, rMaxLon)
+        || lineCrossesLineX(aLat1, aLon1, aLat2, aLon2, rMaxLat, rMinLon, rMinLat, rMaxLon);
   }
 
-  private static boolean lineCrossesLine(final double aX1, final double aY1, final double aX2, final double aY2,
-                                         final double bX1, final double bY1, final double bX2, final double bY2) {
+  private static boolean lineCrossesLineX(final double aLat1, final double aLon1, final double aLat2, final double aLon2,
+                                          final double bLat1, final double bLon1, final double bLat2, final double bLon2) {
     // determine if three points are ccw (right-hand rule) by computing the determinate
-    final double aX2X1d = aX2 - aX1;
-    final double aY2Y1d = aY2 - aY1;
-    final double bX2X1d = bX2 - bX1;
-    final double bY2Y1d = bY2 - bY1;
+    final double aX2X1d = aLon2 - aLon1;
+    final double aY2Y1d = aLat2 - aLat1;
+    final double bX2X1d = bLon2 - bLon1;
+    final double bY2Y1d = bLat2 - bLat1;
 
-    final double t1B = aX2X1d * (bY2 - aY1) - aY2Y1d * (bX2 - aX1);
-    final double test1 = (aX2X1d * (bY1 - aY1) - aY2Y1d * (bX1 - aX1)) * t1B;
-    final double t2B = bX2X1d * (aY2 - bY1) - bY2Y1d * (aX2 - bX1);
-    final double test2 = (bX2X1d * (aY1 - bY1) - bY2Y1d * (aX1 - bX1)) * t2B;
+    final double t1B = aX2X1d * (bLat2 - aLat1) - aY2Y1d * (bLon2 - aLon1);
+    final double test1 = (aX2X1d * (bLat1 - aLat1) - aY2Y1d * (bLon1 - aLon1)) * t1B;
+    final double t2B = bX2X1d * (aLat2 - bLat1) - bY2Y1d * (aLon2 - bLon1);
+    final double test2 = (bX2X1d * (aLat1 - bLat1) - bY2Y1d * (aLon1 - bLon1)) * t2B;
 
     if (test1 < 0 && test2 < 0) {
       return true;
@@ -226,19 +227,19 @@ public class GeoRelationUtils {
 
     if (test1 == 0 || test2 == 0) {
       // vertically collinear
-      if (aX1 == aX2 || bX1 == bX2) {
-        final double minAy = Math.min(aY1, aY2);
-        final double maxAy = Math.max(aY1, aY2);
-        final double minBy = Math.min(bY1, bY2);
-        final double maxBy = Math.max(bY1, bY2);
+      if (aLon1 == aLon2 || bLon1 == bLon2) {
+        final double minAy = Math.min(aLat1, aLat2);
+        final double maxAy = Math.max(aLat1, aLat2);
+        final double minBy = Math.min(bLat1, bLat2);
+        final double maxBy = Math.max(bLat1, bLat2);
 
         return !(minBy >= maxAy || maxBy <= minAy);
       }
       // horizontally collinear
-      final double minAx = Math.min(aX1, aX2);
-      final double maxAx = Math.max(aX1, aX2);
-      final double minBx = Math.min(bX1, bX2);
-      final double maxBx = Math.max(bX1, bX2);
+      final double minAx = Math.min(aLon1, aLon2);
+      final double maxAx = Math.max(aLon1, aLon2);
+      final double minBx = Math.min(bLon1, bLon2);
+      final double maxBx = Math.max(bLon1, bLon2);
 
       return !(minBx >= maxAx || maxBx <= minAx);
     }
@@ -247,109 +248,115 @@ public class GeoRelationUtils {
 
   /**
    * Computes whether a rectangle is within a polygon (shared boundaries not allowed) with more rigor than the
-   * {@link GeoRelationUtils#rectWithinPolyApprox} counterpart
+   * {@link GeoRelationUtils#rectWithinPolyApproxX} counterpart
    */
-  public static boolean rectWithinPolyPrecise(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                       final double[] shapeX, final double[] shapeY, final double sMinX,
-                                       final double sMinY, final double sMaxX, final double sMaxY) {
+  public static boolean rectWithinPolyPreciseX(final double rMinLat, final double rMaxLat, final double rMinLon, final double rMaxLon,
+                                               final double[] shapeLats, final double[] shapeLons, final double sMinLat,
+                                               final double sMaxLat, final double sMinLon, final double sMaxLon) {
     // check if rectangle crosses poly (to handle concave/pacman polys), then check that all 4 corners
     // are contained
-    return !(rectCrossesPolyPrecise(rMinX, rMinY, rMaxX, rMaxY, shapeX, shapeY, sMinX, sMinY, sMaxX, sMaxY) ||
-        !pointInPolygon(shapeX, shapeY, rMinY, rMinX) || !pointInPolygon(shapeX, shapeY, rMinY, rMaxX) ||
-        !pointInPolygon(shapeX, shapeY, rMaxY, rMaxX) || !pointInPolygon(shapeX, shapeY, rMaxY, rMinX));
+    return !(rectCrossesPolyPreciseX(rMinLat, rMaxLat, rMinLon, rMaxLon, shapeLats, shapeLons, sMinLat, sMaxLat, sMinLon, sMaxLon) ||
+        !pointInPolygonX(shapeLats, shapeLons, rMinLat, rMinLon) || !pointInPolygonX(shapeLats, shapeLons, rMinLat, rMaxLon) ||
+        !pointInPolygonX(shapeLats, shapeLons, rMaxLat, rMaxLon) || !pointInPolygonX(shapeLats, shapeLons, rMaxLat, rMinLon));
   }
 
   /**
    * Computes whether a rectangle is within a given polygon (shared boundaries allowed)
    */
-  public static boolean rectWithinPolyApprox(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                       final double[] shapeX, final double[] shapeY, final double sMinX,
-                                       final double sMinY, final double sMaxX, final double sMaxY) {
+  public static boolean rectWithinPolyApproxX(final double rMinLat, final double rMaxLat, final double rMinLon, final double rMaxLon,
+                                              final double[] shapeLats, final double[] shapeLons, final double sMinLat,
+                                              final double sMaxLat, final double sMinLon, final double sMaxLon) {
     // approximation: check if rectangle crosses poly (to handle concave/pacman polys), then check one of the corners
     // are contained
 
     // short-cut: if bounding boxes cross, rect is not within
-     if (rectCrosses(rMinX, rMinY, rMaxX, rMaxY, sMinX, sMinY, sMaxX, sMaxY) == true) {
+    if (rectCrossesX(rMinLat, rMaxLat, rMinLon, rMaxLon, sMinLat, sMaxLat, sMinLon, sMaxLon) == true) {
        return false;
      }
 
-     return !(rectCrossesPolyApprox(rMinX, rMinY, rMaxX, rMaxY, shapeX, shapeY, sMinX, sMinY, sMaxX, sMaxY)
-         || !pointInPolygon(shapeX, shapeY, rMinY, rMinX));
+     return !(rectCrossesPolyApproxX(rMinLat, rMaxLat, rMinLon, rMaxLon, shapeLats, shapeLons, sMinLat, sMaxLat, sMinLon, sMaxLon)
+         || !pointInPolygonX(shapeLats, shapeLons, rMinLat, rMinLon));
   }
 
   /////////////////////////
   // Circle relations
   /////////////////////////
 
-  private static boolean rectAnyCornersInCircle(final double rMinX, final double rMinY, final double rMaxX,
-                                                final double rMaxY, final double centerLon, final double centerLat,
-                                                final double radiusMeters, final boolean approx) {
+  private static boolean rectAnyCornersInCircleX(final double rMinLat, final double rMaxLat, final double rMinLon,
+                                                 final double rMaxLon, final double centerLat, final double centerLon,
+                                                 final double radiusMeters, final boolean approx) {
     if (approx == true) {
-      return rectAnyCornersInCircleSloppy(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters);
+      return rectAnyCornersInCircleSloppyX(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, radiusMeters);
     }
-    double w = Math.abs(rMaxX - rMinX);
+    double w = Math.abs(rMaxLon - rMinLon);
     if (w <= 90.0) {
-      return SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMinX) <= radiusMeters
-          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMinX) <= radiusMeters
-          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMaxX) <= radiusMeters
-          || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMaxX) <= radiusMeters;
+      return SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMinLon) <= radiusMeters
+          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMinLon) <= radiusMeters
+          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMaxLon) <= radiusMeters
+          || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMaxLon) <= radiusMeters;
     }
     // partition
     w /= 4;
-    final double p1 = rMinX + w;
+    final double p1 = rMinLon + w;
     final double p2 = p1 + w;
     final double p3 = p2 + w;
 
-    return SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMinX) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMinX) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, p1) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, p1) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, p2) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, p2) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, p3) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, p3) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMaxX) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMaxX) <= radiusMeters;
+    return SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMinLon) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMinLon) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, p1) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, p1) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, p2) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, p2) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, p3) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, p3) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMaxLon) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMaxLon) <= radiusMeters;
   }
 
-  private static boolean rectAnyCornersInCircleSloppy(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                                      final double centerLon, final double centerLat, final double radiusMeters) {
-    return SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMinX) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMinX) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMaxX) <= radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMaxX) <= radiusMeters;
+  private static boolean rectAnyCornersInCircleSloppyX(final double rMinLat, final double rMaxLat, final double rMinLon, final double rMaxLon,
+                                                       final double centerLat, final double centerLon, final double radiusMeters) {
+    return SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMinLon) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMinLon) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMaxLon) <= radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMaxLon) <= radiusMeters;
   }
 
   /**
    * Compute whether any of the 4 corners of the rectangle (defined by min/max X/Y) are outside the circle (defined
    * by centerLon, centerLat, radiusMeters)
    *
-   * Note: exotic rectangles at the poles (e.g., those whose lon/lat distance ratios greatly deviate from 1) can not
+   * Note: exotic rectangles at the poles (e.g., those whose lat/lon distance ratios greatly deviate from 1) can not
    * be determined by using distance alone. For this reason the approx flag may be set to false, in which case the
    * space will be further divided to more accurately compute whether the rectangle crosses the circle
    */
-  private static boolean rectAnyCornersOutsideCircle(final double rMinX, final double rMinY, final double rMaxX,
-                                                     final double rMaxY, final double centerLon, final double centerLat,
-                                                     final double radiusMeters, final boolean approx) {
+  private static boolean rectAnyCornersOutsideCircleX(final double rMinLat, final double rMaxLat, final double rMinLon,
+                                                      final double rMaxLon, final double centerLat, final double centerLon,
+                                                      final double radiusMeters, final boolean approx) {
     if (approx == true) {
-      return rectAnyCornersOutsideCircleSloppy(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters);
+      return rectAnyCornersOutsideCircleSloppy(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, radiusMeters);
     }
     // if span is less than 70 degrees we can approximate using distance alone
-    if (Math.abs(rMaxX - rMinX) <= 70.0) {
-      return SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMinX) > radiusMeters
-          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMinX) > radiusMeters
-          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMaxX) > radiusMeters
-          || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMaxX) > radiusMeters;
+    if (Math.abs(rMaxLon - rMinLon) <= 70.0) {
+      return SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMinLon) > radiusMeters
+          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMinLon) > radiusMeters
+          || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMaxLon) > radiusMeters
+          || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMaxLon) > radiusMeters;
     }
-    return rectCrossesOblateCircle(centerLon, centerLat, radiusMeters, rMinX, rMinY, rMaxX, rMaxY);
+    return rectCrossesOblateCircle(centerLat, centerLon,
+                                   radiusMeters,
+                                   rMinLat, rMaxLat,
+                                   rMinLon, rMaxLon);
   }
 
   /**
-   * Compute whether the rectangle (defined by min/max Lon/Lat) crosses a potentially oblate circle
+   * Compute whether the rectangle (defined by min/max Lat/Lon) crosses a potentially oblate circle
    *
    * TODO benchmark for replacing existing rectCrossesCircle.
    */
-  public static boolean rectCrossesOblateCircle(double centerLon, double centerLat, double radiusMeters, double rMinLon, double rMinLat, double  rMaxLon, double rMaxLat) {
+  private static boolean rectCrossesOblateCircle(double centerLat, double centerLon,
+                                                 double radiusMeters,
+                                                 double rMinLat, double rMaxLat,
+                                                 double rMinLon, double rMaxLon) {
     double w = Math.abs(rMaxLon - rMinLon);
     final int segs = (int)Math.ceil(w / 45.0);
     w /= segs;
@@ -373,14 +380,14 @@ public class GeoRelationUtils {
       // else we treat as an oblate circle by slicing the longitude space and checking the azimuthal range
       // OPTIMIZATION: this is only executed for latitude values "closeTo" the poles (e.g., 88.0 > lat < -88.0)
       if ( (rMaxLat > 88.0 || rMinLat < -88.0)
-          && (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(p1, rMinLat,
-          GeoProjectionUtils.bearingGreatCircle(p1, rMinLat, p1, rMaxLat), radiusMeters - d1, pt))[1] < rMinLat || pt[1] < rMaxLat
-          || (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(maxLon, rMinLat,
-          GeoProjectionUtils.bearingGreatCircle(maxLon, rMinLat, maxLon, rMaxLat), radiusMeters - d2, pt))[1] < rMinLat || pt[1] < rMaxLat
-          || (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(maxLon, rMinLat,
-          GeoProjectionUtils.bearingGreatCircle(maxLon, rMinLat, (midLon = p1 + 0.5*(maxLon - p1)), rMaxLat),
-          radiusMeters - SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, midLon), pt))[1] < rMinLat
-          || pt[1] < rMaxLat == false ) {
+           && (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircleX(rMinLat, p1,
+                                                                          GeoProjectionUtils.bearingGreatCircleX(rMinLat, p1, rMaxLat, p1), radiusMeters - d1, pt))[1] < rMinLat || pt[1] < rMaxLat
+           || (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircleX(rMinLat, maxLon,
+                                                                          GeoProjectionUtils.bearingGreatCircleX(rMinLat, maxLon, rMaxLat, maxLon), radiusMeters - d2, pt))[1] < rMinLat || pt[1] < rMaxLat
+           || (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircleX(rMinLat, maxLon,
+                                                                          GeoProjectionUtils.bearingGreatCircleX(rMinLat, maxLon, rMaxLat, (midLon = p1 + 0.5*(maxLon - p1))),
+                                                                          radiusMeters - SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, midLon), pt))[1] < rMinLat
+           || pt[1] < rMaxLat == false ) {
         return true;
       }
       p1 += w;
@@ -388,81 +395,77 @@ public class GeoRelationUtils {
     return false;
   }
 
-  private static boolean rectAnyCornersOutsideCircleSloppy(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                                           final double centerLon, final double centerLat, final double radiusMeters) {
-    return SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMinX) > radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMinX) > radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxY, rMaxX) > radiusMeters
-        || SloppyMath.haversinMeters(centerLat, centerLon, rMinY, rMaxX) > radiusMeters;
-  }
-
-  /**
-   * Convenience method for computing whether a rectangle is within a circle using additional precision checks
-   */
-  public static boolean rectWithinCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                         final double centerLon, final double centerLat, final double radiusMeters) {
-    return rectWithinCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, false);
+  private static boolean rectAnyCornersOutsideCircleSloppy(final double rMinLat, final double rMaxLat, final double rMinLon, final double rMaxLon,
+                                                           final double centerLat, final double centerLon, final double radiusMeters) {
+    return SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMinLon) > radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMinLon) > radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMaxLat, rMaxLon) > radiusMeters
+        || SloppyMath.haversinMeters(centerLat, centerLon, rMinLat, rMaxLon) > radiusMeters;
   }
 
   /**
    * Computes whether a rectangle is within a circle. Note: approx == true will be faster but less precise and may
    * fail on large rectangles
    */
-  public static boolean rectWithinCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                         final double centerLon, final double centerLat, final double radiusMeters,
+  public static boolean rectWithinCircle(final double rMinLat, final double rMaxLat, final double rMinLon, final double rMaxLon,
+                                         final double centerLat, final double centerLon, final double radiusMeters,
                                          final boolean approx) {
-    return rectAnyCornersOutsideCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, approx) == false;
-  }
-
-  /**
-   * Determine if a bbox (defined by minLon, minLat, maxLon, maxLat) contains the provided point (defined by lon, lat)
-   * NOTE: this is basic method that does not handle dateline or pole crossing. Unwrapping must be done before
-   * calling this method.
-   */
-  public static boolean rectCrossesCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                          final double centerLon, final double centerLat, final double radiusMeters) {
-    return rectCrossesCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, false);
+    return rectAnyCornersOutsideCircleX(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, radiusMeters, approx) == false;
   }
 
   /**
    * Computes whether a rectangle crosses a circle. Note: approx == true will be faster but less precise and may
    * fail on large rectangles
+   *
+   * <p>NOTE: this is basic method that does not handle dateline or pole crossing. Unwrapping must be done before
+   * calling this method.
    */
-  public static boolean rectCrossesCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                          final double centerLon, final double centerLat, final double radiusMeters,
+  public static boolean rectCrossesCircle(final double rMinLat, final double rMaxLat, final double rMinLon, final double rMaxLon,
+                                          final double centerLat, final double centerLon, final double radiusMeters,
                                           final boolean approx) {
     if (approx == true) {
-      return rectAnyCornersInCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, approx)
-          || isClosestPointOnRectWithinRange(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, approx);
+      if (rectAnyCornersInCircleX(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, radiusMeters, approx)) {
+        return true;
+      }
+    } else {
+      if (rectAnyCornersInCircleX(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, radiusMeters, approx) &&
+          rectAnyCornersOutsideCircleX(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, radiusMeters, approx)) {
+        return true;
+      }
     }
-
-    return (rectAnyCornersInCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, approx) &&
-        rectAnyCornersOutsideCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, approx))
-        || isClosestPointOnRectWithinRange(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radiusMeters, approx);
+    if (isClosestPointOnRectWithinRange(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, radiusMeters, approx)) {
+      return true;
+    }
+    return false;
   }
 
-  private static boolean isClosestPointOnRectWithinRange(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                                         final double centerLon, final double centerLat, final double radiusMeters,
+  private static boolean isClosestPointOnRectWithinRange(final double rMinLat, final double rMaxLat,
+                                                         final double rMinLon, final double rMaxLon,
+                                                         final double centerLat, final double centerLon,
+                                                         final double radiusMeters,
                                                          final boolean approx) {
     double[] closestPt = {0, 0};
-    GeoDistanceUtils.closestPointOnBBox(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, closestPt);
-    boolean haverShortCut = SloppyMath.haversinMeters(centerLat, centerLon, closestPt[1], closestPt[0]) <= radiusMeters;
+    GeoDistanceUtils.closestPointOnBBoxX(rMinLat, rMaxLat, rMinLon, rMaxLon, centerLat, centerLon, closestPt);
+    boolean haverShortCut = SloppyMath.haversinMeters(centerLat, centerLon, closestPt[0], closestPt[1]) <= radiusMeters;
     if (approx == true || haverShortCut == true) {
       return haverShortCut;
     }
-    double lon1 = rMinX;
-    double lon2 = rMaxX;
-    double lat1 = rMinY;
-    double lat2 = rMaxY;
-    if (closestPt[0] == rMinX || closestPt[0] == rMaxX) {
-      lon1 = closestPt[0];
+    double lon1 = rMinLon;
+    double lon2 = rMaxLon;
+    double lat1 = rMinLat;
+    double lat2 = rMaxLat;
+    if (closestPt[1] == rMinLon || closestPt[1] == rMaxLon) {
+      lon1 = closestPt[1];
       lon2 = lon1;
-    } else if (closestPt[1] == rMinY || closestPt[1] == rMaxY) {
-      lat1 = closestPt[1];
+    } else if (closestPt[0] == rMinLat || closestPt[0] == rMaxLat) {
+      lat1 = closestPt[0];
       lat2 = lat1;
     }
 
-    return lineCrossesSphere(lon1, lat1, 0, lon2, lat2, 0, centerLon, centerLat, 0, radiusMeters);
+    return lineCrossesSphere(lat1, lon1, 0,
+                             lat2, lon2, 0,
+                             centerLat, centerLon, 0,
+                             radiusMeters);
   }
 
   /**
@@ -480,17 +483,18 @@ public class GeoRelationUtils {
    * @param radiusMeters search sphere radius (in meters)
    * @return whether the provided line segment is a secant of the
    */
-  private static boolean lineCrossesSphere(double lon1, double lat1, double alt1, double lon2,
-                                           double lat2, double alt2, double centerLon, double centerLat,
-                                           double centerAlt, double radiusMeters) {
+  private static boolean lineCrossesSphere(double lat1, double lon1, double alt1,
+                                           double lat2, double lon2, double alt2,
+                                           double centerLat, double centerLon, double centerAlt,
+                                           double radiusMeters) {
     // convert to cartesian 3d (in meters)
-    double[] ecf1 = GeoProjectionUtils.llaToECF(lon1, lat1, alt1, null);
-    double[] ecf2 = GeoProjectionUtils.llaToECF(lon2, lat2, alt2, null);
-    double[] cntr = GeoProjectionUtils.llaToECF(centerLon, centerLat, centerAlt, null);
+    double[] ecf1 = GeoProjectionUtils.llaToECFX(lat1, lon1, alt1, null);
+    double[] ecf2 = GeoProjectionUtils.llaToECFX(lat2, lon2, alt2, null);
+    double[] cntr = GeoProjectionUtils.llaToECFX(centerLat, centerLon, centerAlt, null);
 
     // convert radius from arc radius to cartesian radius
-    double[] oneEighty = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(centerLon, centerLat, 180.0d, radiusMeters, new double[3]);
-    GeoProjectionUtils.llaToECF(oneEighty[0], oneEighty[1], 0, oneEighty);
+    double[] oneEighty = GeoProjectionUtils.pointFromLonLatBearingGreatCircleX(centerLat, centerLon, 180.0d, radiusMeters, new double[3]);
+    GeoProjectionUtils.llaToECFX(oneEighty[1], oneEighty[0], 0, oneEighty);
 
     radiusMeters = GeoDistanceUtils.linearDistance(oneEighty, cntr);//   Math.sqrt(oneEighty[0]*cntr[0] + oneEighty[1]*cntr[1] + oneEighty[2]*cntr[2]);
 
diff --git a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java
index 6d755ce..935da60 100644
--- a/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java
+++ b/lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoUtils.java
@@ -34,7 +34,6 @@ import static org.apache.lucene.spatial.util.GeoProjectionUtils.MAX_LAT_RADIANS;
 import static org.apache.lucene.spatial.util.GeoProjectionUtils.MAX_LON_RADIANS;
 import static org.apache.lucene.spatial.util.GeoProjectionUtils.MIN_LAT_RADIANS;
 import static org.apache.lucene.spatial.util.GeoProjectionUtils.MIN_LON_RADIANS;
-import static org.apache.lucene.spatial.util.GeoProjectionUtils.pointFromLonLatBearingGreatCircle;
 import static org.apache.lucene.spatial.util.GeoProjectionUtils.SEMIMAJOR_AXIS;
 
 /**
@@ -93,42 +92,8 @@ public final class GeoUtils {
     return (off <= 180 ? off : 360-off) - 90;
   }
 
-  /**
-   * Converts a given circle (defined as a point/radius) to an approximated line-segment polygon
-   *
-   * @param lon          longitudinal center of circle (in degrees)
-   * @param lat          latitudinal center of circle (in degrees)
-   * @param radiusMeters distance radius of circle (in meters)
-   * @return a list of lon/lat points representing the circle
-   */
-  @SuppressWarnings({"unchecked", "rawtypes"})
-  public static ArrayList<double[]> circleToPoly(final double lon, final double lat, final double radiusMeters) {
-    double angle;
-    // a little under-sampling (to limit the number of polygonal points): using archimedes estimation of pi
-    final int sides = 25;
-    ArrayList<double[]> geometry = new ArrayList();
-    double[] lons = new double[sides];
-    double[] lats = new double[sides];
-
-    double[] pt = new double[2];
-    final int sidesLen = sides - 1;
-    for (int i = 0; i < sidesLen; ++i) {
-      angle = (i * 360 / sides);
-      pt = pointFromLonLatBearingGreatCircle(lon, lat, angle, radiusMeters, pt);
-      lons[i] = pt[0];
-      lats[i] = pt[1];
-    }
-    // close the poly
-    lons[sidesLen] = lons[0];
-    lats[sidesLen] = lats[0];
-    geometry.add(lons);
-    geometry.add(lats);
-
-    return geometry;
-  }
-
   /** Compute Bounding Box for a circle using WGS-84 parameters */
-  public static GeoRect circleToBBox(final double centerLon, final double centerLat, final double radiusMeters) {
+  public static GeoRect circleToBBox(final double centerLat, final double centerLon, final double radiusMeters) {
     final double radLat = TO_RADIANS * centerLat;
     final double radLon = TO_RADIANS * centerLon;
     double radDistance = radiusMeters / SEMIMAJOR_AXIS;
@@ -155,11 +120,11 @@ public final class GeoUtils {
       maxLon = MAX_LON_RADIANS;
     }
 
-    return new GeoRect(TO_DEGREES * minLon, TO_DEGREES * maxLon, TO_DEGREES * minLat, TO_DEGREES * maxLat);
+    return new GeoRect(TO_DEGREES * minLat, TO_DEGREES * maxLat, TO_DEGREES * minLon, TO_DEGREES * maxLon);
   }
 
   /** Compute Bounding Box for a polygon using WGS-84 parameters */
-  public static GeoRect polyToBBox(double[] polyLons, double[] polyLats) {
+  public static GeoRect polyToBBox(double[] polyLats, double[] polyLons) {
     if (polyLons.length != polyLats.length) {
       throw new IllegalArgumentException("polyLons and polyLats must be equal length");
     }
@@ -182,14 +147,14 @@ public final class GeoUtils {
       maxLat = max(polyLats[i], maxLat);
     }
     // expand bounding box by TOLERANCE factor to handle round-off error
-    return new GeoRect(max(minLon - TOLERANCE, MIN_LON_INCL), min(maxLon + TOLERANCE, MAX_LON_INCL),
-        max(minLat - TOLERANCE, MIN_LAT_INCL), min(maxLat + TOLERANCE, MAX_LAT_INCL));
+    return new GeoRect(max(minLat - TOLERANCE, MIN_LAT_INCL), min(maxLat + TOLERANCE, MAX_LAT_INCL),
+                       max(minLon - TOLERANCE, MIN_LON_INCL), min(maxLon + TOLERANCE, MAX_LON_INCL));
   }
   
-
   // some sloppyish stuff, do we really need this to be done in a sloppy way?
   // unless it is performance sensitive, we should try to remove.
   static final double PIO2 = Math.PI / 2D;
+
   /**
    * Returns the trigonometric sine of an angle converted as a cos operation.
    * <p>
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointQuery.java b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointQuery.java
index 2fd64bd..90d0cd9 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointQuery.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/geopoint/search/TestGeoPointQuery.java
@@ -16,6 +16,8 @@
  */
 package org.apache.lucene.spatial.geopoint.search;
 
+import java.util.Arrays;
+
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
@@ -26,14 +28,14 @@ import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.spatial.util.GeoEncodingUtils;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField;
-import org.apache.lucene.spatial.geopoint.document.GeoPointField.TermEncoding;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX.TermEncoding;
+import org.apache.lucene.spatial.geopoint.document.GeoPointFieldX;
 import org.apache.lucene.spatial.util.BaseGeoPointTestCase;
+import org.apache.lucene.spatial.util.GeoEncodingUtils;
 import org.apache.lucene.spatial.util.GeoRect;
 import org.apache.lucene.spatial.util.GeoRelationUtils;
 import org.apache.lucene.spatial.util.GeoUtils;
+import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.SloppyMath;
 import org.apache.lucene.util.TestUtil;
 import org.junit.AfterClass;
@@ -62,27 +64,27 @@ public class TestGeoPointQuery extends BaseGeoPointTestCase {
 
   @Override
   protected void addPointToDoc(String field, Document doc, double lat, double lon) {
-    doc.add(new GeoPointField(field, lon, lat, fieldType));
+    doc.add(new GeoPointFieldX(field, lat, lon, fieldType));
   }
 
   @Override
   protected Query newRectQuery(String field, GeoRect rect) {
-    return new GeoPointInBBoxQuery(field, termEncoding, rect.minLon, rect.minLat, rect.maxLon, rect.maxLat);
+    return new GeoPointInBBoxQueryX(field, termEncoding, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);
   }
 
   @Override
   protected Query newDistanceQuery(String field, double centerLat, double centerLon, double radiusMeters) {
-    return new GeoPointDistanceQuery(field, termEncoding, centerLon, centerLat, radiusMeters);
+    return new GeoPointDistanceQueryX(field, termEncoding, centerLat, centerLon, radiusMeters);
   }
 
   @Override
   protected Query newDistanceRangeQuery(String field, double centerLat, double centerLon, double minRadiusMeters, double radiusMeters) {
-    return new GeoPointDistanceRangeQuery(field, termEncoding, centerLon, centerLat, minRadiusMeters, radiusMeters);
+    return new GeoPointDistanceRangeQueryX(field, termEncoding, centerLat, centerLon, minRadiusMeters, radiusMeters);
   }
 
   @Override
   protected Query newPolygonQuery(String field, double[] lats, double[] lons) {
-    return new GeoPointInPolygonQuery(field, termEncoding, lons, lats);
+    return new GeoPointInPolygonQueryX(field, termEncoding, lats, lons);
   }
 
   @BeforeClass
@@ -97,25 +99,25 @@ public class TestGeoPointQuery extends BaseGeoPointTestCase {
                     .setMergePolicy(newLogMergePolicy()));
 
     // this is a simple systematic test
-    GeoPointField[] pts = new GeoPointField[] {
-        new GeoPointField(FIELD_NAME, -96.774, 32.763420, fieldType),
-        new GeoPointField(FIELD_NAME, -96.7759895324707, 32.7559529921407, fieldType),
-        new GeoPointField(FIELD_NAME, -96.77701950073242, 32.77866942010977, fieldType),
-        new GeoPointField(FIELD_NAME, -96.7706036567688, 32.7756745755423, fieldType),
-        new GeoPointField(FIELD_NAME, -139.73458170890808, 27.703618681345585, fieldType),
-        new GeoPointField(FIELD_NAME, -96.4538113027811, 32.94823588839368, fieldType),
-        new GeoPointField(FIELD_NAME, -96.65084838867188, 33.06047141970814, fieldType),
-        new GeoPointField(FIELD_NAME, -96.7772, 32.778650, fieldType),
-        new GeoPointField(FIELD_NAME, -177.23537676036358, -88.56029371730983, fieldType),
-        new GeoPointField(FIELD_NAME, -26.779373834241003, 33.541429799076354, fieldType),
-        new GeoPointField(FIELD_NAME, -77.35379276106497, 26.774024500421728, fieldType),
-        new GeoPointField(FIELD_NAME, -14.796283808944777, -90.0, fieldType),
-        new GeoPointField(FIELD_NAME, -178.8538113027811, 32.94823588839368, fieldType),
-        new GeoPointField(FIELD_NAME, 178.8538113027811, 32.94823588839368, fieldType),
-        new GeoPointField(FIELD_NAME, -73.998776, 40.720611, fieldType),
-        new GeoPointField(FIELD_NAME, -179.5, -44.5, fieldType)};
-
-    for (GeoPointField p : pts) {
+    GeoPointFieldX[] pts = new GeoPointFieldX[] {
+        new GeoPointFieldX(FIELD_NAME, 32.763420, -96.774, fieldType),
+        new GeoPointFieldX(FIELD_NAME, 32.7559529921407, -96.7759895324707, fieldType),
+        new GeoPointFieldX(FIELD_NAME, 32.77866942010977, -96.77701950073242, fieldType),
+        new GeoPointFieldX(FIELD_NAME, 32.7756745755423, -96.7706036567688, fieldType),
+        new GeoPointFieldX(FIELD_NAME, 27.703618681345585, -139.73458170890808, fieldType),
+        new GeoPointFieldX(FIELD_NAME, 32.94823588839368, -96.4538113027811, fieldType),
+        new GeoPointFieldX(FIELD_NAME, 33.06047141970814, -96.65084838867188, fieldType),
+        new GeoPointFieldX(FIELD_NAME, 32.778650, -96.7772, fieldType),
+        new GeoPointFieldX(FIELD_NAME, -88.56029371730983, -177.23537676036358, fieldType),
+        new GeoPointFieldX(FIELD_NAME, 33.541429799076354, -26.779373834241003, fieldType),
+        new GeoPointFieldX(FIELD_NAME, 26.774024500421728, -77.35379276106497, fieldType),
+        new GeoPointFieldX(FIELD_NAME, -90.0, -14.796283808944777, fieldType),
+        new GeoPointFieldX(FIELD_NAME, 32.94823588839368, -178.8538113027811, fieldType),
+        new GeoPointFieldX(FIELD_NAME, 32.94823588839368, 178.8538113027811, fieldType),
+        new GeoPointFieldX(FIELD_NAME, 40.720611, -73.998776, fieldType),
+        new GeoPointFieldX(FIELD_NAME, -44.5, -179.5, fieldType)};
+
+    for (GeoPointFieldX p : pts) {
         Document doc = new Document();
         doc.add(p);
         writer.addDocument(doc);
@@ -156,23 +158,23 @@ public class TestGeoPointQuery extends BaseGeoPointTestCase {
 
   private static FieldType randomFieldType() {
     if (termEncoding == TermEncoding.PREFIX) {
-      return GeoPointField.PREFIX_TYPE_NOT_STORED;
+      return GeoPointFieldX.PREFIX_TYPE_NOT_STORED;
     }
-    return GeoPointField.NUMERIC_TYPE_NOT_STORED;
+    return GeoPointFieldX.NUMERIC_TYPE_NOT_STORED;
   }
 
-  private TopDocs bboxQuery(double minLon, double minLat, double maxLon, double maxLat, int limit) throws Exception {
-    GeoPointInBBoxQuery q = new GeoPointInBBoxQuery(FIELD_NAME, termEncoding, minLon, minLat, maxLon, maxLat);
+  private TopDocs bboxQueryX(double minLat, double maxLat, double minLon, double maxLon, int limit) throws Exception {
+    GeoPointInBBoxQueryX q = new GeoPointInBBoxQueryX(FIELD_NAME, termEncoding, minLat, maxLat, minLon, maxLon);
     return searcher.search(q, limit);
   }
 
-  private TopDocs polygonQuery(double[] lon, double[] lat, int limit) throws Exception {
-    GeoPointInPolygonQuery q = new GeoPointInPolygonQuery(FIELD_NAME, termEncoding, lon, lat);
+  private TopDocs polygonQueryX(double[] polyLats, double[] polyLons, int limit) throws Exception {
+    GeoPointInPolygonQueryX q = new GeoPointInPolygonQueryX(FIELD_NAME, termEncoding, polyLats, polyLons);
     return searcher.search(q, limit);
   }
 
-  private TopDocs geoDistanceQuery(double lon, double lat, double radius, int limit) throws Exception {
-    GeoPointDistanceQuery q = new GeoPointDistanceQuery(FIELD_NAME, termEncoding, lon, lat, radius);
+  private TopDocs geoDistanceQueryX(double lat, double lon, double radius, int limit) throws Exception {
+    GeoPointDistanceQueryX q = new GeoPointDistanceQueryX(FIELD_NAME, termEncoding, lat, lon, radius);
     return searcher.search(q, limit);
   }
 
@@ -187,11 +189,11 @@ public class TestGeoPointQuery extends BaseGeoPointTestCase {
     }
 
     if (rect.minLon < rect.maxLon) {
-      return GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, rect.minLon, rect.minLat, rect.maxLon, rect.maxLat);
+      return GeoRelationUtils.pointInRectPreciseX(pointLat, pointLon, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);
     } else {
       // Rect crosses dateline:
-      return GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, -180.0, rect.minLat, rect.maxLon, rect.maxLat)
-          || GeoRelationUtils.pointInRectPrecise(pointLon, pointLat, rect.minLon, rect.minLat, 180.0, rect.maxLat);
+      return GeoRelationUtils.pointInRectPreciseX(pointLat, pointLon, rect.minLat, rect.maxLat, -180.0, rect.maxLon)
+        || GeoRelationUtils.pointInRectPreciseX(pointLat, pointLon, rect.minLat, rect.maxLat, rect.minLon, 180.0);
     }
   }
 
@@ -222,10 +224,10 @@ public class TestGeoPointQuery extends BaseGeoPointTestCase {
 
   private static boolean radiusQueryCanBeWrong(double centerLat, double centerLon, double ptLon, double ptLat,
                                                final double radius) {
-    final long hashedCntr = GeoEncodingUtils.mortonHash(centerLon, centerLat);
+    final long hashedCntr = GeoEncodingUtils.mortonHashX(centerLat, centerLon);
     centerLon = GeoEncodingUtils.mortonUnhashLon(hashedCntr);
     centerLat = GeoEncodingUtils.mortonUnhashLat(hashedCntr);
-    final long hashedPt = GeoEncodingUtils.mortonHash(ptLon, ptLat);
+    final long hashedPt = GeoEncodingUtils.mortonHashX(ptLat, ptLon);
     ptLon = GeoEncodingUtils.mortonUnhashLon(hashedPt);
     ptLat = GeoEncodingUtils.mortonUnhashLat(hashedPt);
 
@@ -237,25 +239,27 @@ public class TestGeoPointQuery extends BaseGeoPointTestCase {
   }
 
   public void testRectCrossesCircle() throws Exception {
-    assertTrue(GeoRelationUtils.rectCrossesCircle(-180, -90, 180, 0.0, 0.667, 0.0, 88000.0));
+    assertTrue(GeoRelationUtils.rectCrossesCircle(-90, 0.0, -180, 180, 0.0, 0.667, 88000.0, false));
   }
 
-  private TopDocs geoDistanceRangeQuery(double lon, double lat, double minRadius, double maxRadius, int limit)
+  private TopDocs geoDistanceRangeQueryX(double lat, double lon, double minRadius, double maxRadius, int limit)
       throws Exception {
-    GeoPointDistanceRangeQuery q = new GeoPointDistanceRangeQuery(FIELD_NAME, termEncoding, lon, lat, minRadius, maxRadius);
+    GeoPointDistanceRangeQueryX q = new GeoPointDistanceRangeQueryX(FIELD_NAME, termEncoding, lat, lon, minRadius, maxRadius);
     return searcher.search(q, limit);
   }
 
   public void testBBoxQuery() throws Exception {
-    TopDocs td = bboxQuery(-96.7772, 32.778650, -96.77690000, 32.778950, 5);
+    TopDocs td = bboxQueryX(32.778650, 32.778950, -96.7772, -96.77690000, 5);
     assertEquals("GeoBoundingBoxQuery failed", 4, td.totalHits);
   }
 
   public void testPolyQuery() throws Exception {
-    TopDocs td = polygonQuery(new double[]{-96.7682647, -96.8280029, -96.6288757, -96.4929199,
-            -96.6041564, -96.7449188, -96.76826477, -96.7682647},
+    TopDocs td = polygonQueryX(
         new double[]{33.073130, 32.9942669, 32.938386, 33.0374494,
-            33.1369762, 33.1162747, 33.073130, 33.073130}, 5);
+            33.1369762, 33.1162747, 33.073130, 33.073130},
+        new double[]{-96.7682647, -96.8280029, -96.6288757, -96.4929199,
+                     -96.6041564, -96.7449188, -96.76826477, -96.7682647},
+        5);
     assertEquals("GeoPolygonQuery failed", 2, td.totalHits);
   }
 
@@ -277,56 +281,57 @@ public class TestGeoPointQuery extends BaseGeoPointTestCase {
     double yMax = 1;//5;
 
     // test cell crossing poly
-    assertTrue(GeoRelationUtils.rectCrossesPolyApprox(xMin, yMin, xMax, yMax, px, py, xMinA, yMinA, xMaxA, yMaxA));
-    assertFalse(GeoRelationUtils.rectCrossesPolyApprox(-5, 0,  0.000001, 5, px, py, xMin, yMin, xMax, yMax));
-    assertTrue(GeoRelationUtils.rectWithinPolyApprox(-5, 0, -2, 5, px, py, xMin, yMin, xMax, yMax));
+    assertTrue(GeoRelationUtils.rectCrossesPolyApproxX(yMin, yMax, xMin, yMax, py, px, yMinA, yMaxA, xMinA, xMaxA));
+    assertFalse(GeoRelationUtils.rectCrossesPolyApproxX(0, 5, -5, 0.000001, py, px, yMin, yMax, xMin, xMax));
+    assertTrue(GeoRelationUtils.rectWithinPolyApproxX(0, 5, -5, -2, py, px, yMin, yMax, xMin, xMax));
   }
 
   public void testBBoxCrossDateline() throws Exception {
-    TopDocs td = bboxQuery(179.0, -45.0, -179.0, -44.0, 20);
+    TopDocs td = bboxQueryX(-45.0, -44.0, 179.0, -179.0, 20);
     assertEquals("BBoxCrossDateline query failed", 2, td.totalHits);
   }
 
   public void testWholeMap() throws Exception {
-    TopDocs td = bboxQuery(GeoUtils.MIN_LON_INCL, GeoUtils.MIN_LAT_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MAX_LAT_INCL, 20);
+    TopDocs td = bboxQueryX(GeoUtils.MIN_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MIN_LON_INCL, GeoUtils.MAX_LON_INCL, 20);
     assertEquals("testWholeMap failed", 24, td.totalHits);
-    td = polygonQuery(new double[] {GeoUtils.MIN_LON_INCL, GeoUtils.MIN_LON_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MIN_LON_INCL},
-        new double[] {GeoUtils.MIN_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MIN_LAT_INCL, GeoUtils.MIN_LAT_INCL}, 20);
+    td = polygonQueryX(new double[] {GeoUtils.MIN_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MAX_LAT_INCL, GeoUtils.MIN_LAT_INCL, GeoUtils.MIN_LAT_INCL},
+                       new double[] {GeoUtils.MIN_LON_INCL, GeoUtils.MIN_LON_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MAX_LON_INCL, GeoUtils.MIN_LON_INCL},
+                       20);
     assertEquals("testWholeMap failed", 24, td.totalHits);
   }
 
   public void smallTest() throws Exception {
-    TopDocs td = geoDistanceQuery(-73.998776, 40.720611, 1, 20);
+    TopDocs td = geoDistanceQueryX(40.720611, -73.998776, 1, 20);
     assertEquals("smallTest failed", 2, td.totalHits);
   }
 
   // GeoBoundingBox should not accept invalid lat/lon
   public void testInvalidBBox() throws Exception {
     expectThrows(Exception.class, () -> {
-      bboxQuery(179.0, -92.0, 181.0, -91.0, 20);
+      bboxQueryX(-92.0, -91.0, 179.0, 181.0, 20);
     });
   }
 
   public void testGeoDistanceQuery() throws Exception {
-    TopDocs td = geoDistanceQuery(-96.4538113027811, 32.94823588839368, 6000, 20);
+    TopDocs td = geoDistanceQueryX(32.94823588839368, -96.4538113027811, 6000, 20);
     assertEquals("GeoDistanceQuery failed", 2, td.totalHits);
   }
 
   /** see https://issues.apache.org/jira/browse/LUCENE-6905 */
   public void testNonEmptyTermsEnum() throws Exception {
-    TopDocs td = geoDistanceQuery(-177.23537676036358, -88.56029371730983, 7757.999232959935, 20);
+    TopDocs td = geoDistanceQueryX(-88.56029371730983, -177.23537676036358, 7757.999232959935, 20);
     assertEquals("GeoDistanceQuery failed", 2, td.totalHits);
   }
 
   public void testMultiValuedQuery() throws Exception {
-    TopDocs td = bboxQuery(-96.4538113027811, 32.7559529921407, -96.7706036567688, 32.7756745755423, 20);
+    TopDocs td = bboxQueryX(32.7559529921407, 32.7756745755423, -96.4538113027811, -96.7706036567688, 20);
     // 3 single valued docs + 2 multi-valued docs
     assertEquals("testMultiValuedQuery failed", 5, td.totalHits);
   }
 
   public void testTooBigRadius() throws Exception {
     IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
-      geoDistanceQuery(0.0, 85.0, 4000000, 20);
+      geoDistanceQueryX(85.0, 0.0, 4000000, 20);
     });
     assertTrue(expected.getMessage().contains("exceeds maxRadius"));
   }
@@ -335,29 +340,29 @@ public class TestGeoPointQuery extends BaseGeoPointTestCase {
    * Explicitly large
    */
   public void testGeoDistanceQueryHuge() throws Exception {
-    TopDocs td = geoDistanceQuery(-96.4538113027811, 32.94823588839368, 6000000, 20);
+    TopDocs td = geoDistanceQueryX(32.94823588839368, -96.4538113027811, 6000000, 20);
     assertEquals("GeoDistanceQuery failed", 16, td.totalHits);
   }
 
   public void testGeoDistanceQueryCrossDateline() throws Exception {
-    TopDocs td = geoDistanceQuery(-179.9538113027811, 32.94823588839368, 120000, 20);
+    TopDocs td = geoDistanceQueryX(32.94823588839368, -179.9538113027811, 120000, 20);
     assertEquals("GeoDistanceQuery failed", 3, td.totalHits);
   }
 
   // GeoDistanceQuery should not accept invalid lat/lon as origin
   public void testInvalidGeoDistanceQuery() throws Exception {
     expectThrows(Exception.class, () -> {
-      geoDistanceQuery(181.0, 92.0, 120000, 20);
+      geoDistanceQueryX(92.0, 181.0, 120000, 20);
     });
   }
 
   public void testMaxDistanceRangeQuery() throws Exception {
-    TopDocs td = geoDistanceRangeQuery(0.0, 0.0, 10, 20000000, 20);
+    TopDocs td = geoDistanceRangeQueryX(0.0, 0.0, 10, 20000000, 20);
     assertEquals("GeoDistanceRangeQuery failed", 24, td.totalHits);
   }
 
   public void testMortonEncoding() throws Exception {
-    long hash = GeoEncodingUtils.mortonHash(180, 90);
+    long hash = GeoEncodingUtils.mortonHashX(90, 180);
     assertEquals(180.0, GeoEncodingUtils.mortonUnhashLon(hash), 0);
     assertEquals(90.0, GeoEncodingUtils.mortonUnhashLat(hash), 0);
   }
@@ -369,7 +374,7 @@ public class TestGeoPointQuery extends BaseGeoPointTestCase {
       double lat = randomLat(small);
       double lon = randomLon(small);
 
-      long enc = GeoEncodingUtils.mortonHash(lon, lat);
+      long enc = GeoEncodingUtils.mortonHashX(lat, lon);
       double latEnc = GeoEncodingUtils.mortonUnhashLat(enc);
       double lonEnc = GeoEncodingUtils.mortonUnhashLon(enc);
 
@@ -385,11 +390,11 @@ public class TestGeoPointQuery extends BaseGeoPointTestCase {
       double lat = randomLat(small);
       double lon = randomLon(small);
 
-      long enc = GeoEncodingUtils.mortonHash(lon, lat);
+      long enc = GeoEncodingUtils.mortonHashX(lat, lon);
       double latEnc = GeoEncodingUtils.mortonUnhashLat(enc);
       double lonEnc = GeoEncodingUtils.mortonUnhashLon(enc);
 
-      long enc2 = GeoEncodingUtils.mortonHash(lon, lat);
+      long enc2 = GeoEncodingUtils.mortonHashX(lat, lon);
       double latEnc2 = GeoEncodingUtils.mortonUnhashLat(enc2);
       double lonEnc2 = GeoEncodingUtils.mortonUnhashLon(enc2);
       assertEquals(latEnc, latEnc2, 0.0);
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java b/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java
index e14ffbd..a4f70d9 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase.java
@@ -466,7 +466,7 @@ public abstract class BaseGeoPointTestCase extends LuceneTestCase {
       lon1 = x;
     }
 
-    return new GeoRect(lon0, lon1, lat0, lat1);
+    return new GeoRect(lat0, lat1, lon0, lon1);
   }
 
   protected void initIndexWriterConfig(String field, IndexWriterConfig iwc) {
diff --git a/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java b/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java
index bc76852..63b0a9a 100644
--- a/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java
+++ b/lucene/spatial/src/test/org/apache/lucene/spatial/util/TestGeoUtils.java
@@ -66,154 +66,13 @@ public class TestGeoUtils extends LuceneTestCase {
     }
   }
 
-  public void testGeoHash() {
-    int numPoints = atLeast(100);
-    String randomGeoHashString;
-    String mortonGeoHash;
-    long mortonLongFromGHLong, geoHashLong, mortonLongFromGHString;
-    int randomLevel;
-    for (int i = 0; i < numPoints; ++i) {
-      // random point
-      double lat = randomLat(false);
-      double lon = randomLon(false);
-
-      // compute geohash straight from lat/lon and from morton encoded value to ensure they're the same
-      randomGeoHashString = GeoHashUtils.stringEncode(lon, lat, randomLevel = random().nextInt(12 - 1) + 1);
-      mortonGeoHash = GeoHashUtils.stringEncodeFromMortonLong(GeoEncodingUtils.mortonHash(lon, lat), randomLevel);
-      assertEquals(randomGeoHashString, mortonGeoHash);
-
-      // v&v conversion from lat/lon or geohashstring to geohash long and back to geohash string
-      geoHashLong = (random().nextBoolean()) ? GeoHashUtils.longEncode(lon, lat, randomLevel) : GeoHashUtils.longEncode(randomGeoHashString);
-      assertEquals(randomGeoHashString, GeoHashUtils.stringEncode(geoHashLong));
-
-      // v&v conversion from geohash long to morton long
-      mortonLongFromGHString = GeoHashUtils.mortonEncode(randomGeoHashString);
-      mortonLongFromGHLong = GeoHashUtils.mortonEncode(geoHashLong);
-      assertEquals(mortonLongFromGHLong, mortonLongFromGHString);
-
-      // v&v lat/lon from geohash string and geohash long
-      assertEquals(GeoEncodingUtils.mortonUnhashLat(mortonLongFromGHString), GeoEncodingUtils.mortonUnhashLat(mortonLongFromGHLong), 0);
-      assertEquals(GeoEncodingUtils.mortonUnhashLon(mortonLongFromGHString), GeoEncodingUtils.mortonUnhashLon(mortonLongFromGHLong), 0);
-    }
-  }
-
-  /**
-   * Pass condition: lat=42.6, lng=-5.6 should be encoded as "ezs42e44yx96",
-   * lat=57.64911 lng=10.40744 should be encoded as "u4pruydqqvj8"
-   */
-  public void testEncode() {
-    String hash = GeoHashUtils.stringEncode(-5.6, 42.6, 12);
-    assertEquals("ezs42e44yx96", hash);
-
-    hash = GeoHashUtils.stringEncode(10.40744, 57.64911, 12);
-    assertEquals("u4pruydqqvj8", hash);
-  }
-
-  /**
-   * Pass condition: lat=52.3738007, lng=4.8909347 should be encoded and then
-   * decoded within 0.00001 of the original value
-   */
-  public void testDecodePreciseLongitudeLatitude() {
-    final String geohash = GeoHashUtils.stringEncode(4.8909347, 52.3738007);
-    final long hash = GeoHashUtils.mortonEncode(geohash);
-
-    assertEquals(52.3738007, GeoEncodingUtils.mortonUnhashLat(hash), 0.00001D);
-    assertEquals(4.8909347, GeoEncodingUtils.mortonUnhashLon(hash), 0.00001D);
-  }
-
-  /**
-   * Pass condition: lat=84.6, lng=10.5 should be encoded and then decoded
-   * within 0.00001 of the original value
-   */
-  public void testDecodeImpreciseLongitudeLatitude() {
-    final String geohash = GeoHashUtils.stringEncode(10.5, 84.6);
-
-    final long hash = GeoHashUtils.mortonEncode(geohash);
-
-    assertEquals(84.6, GeoEncodingUtils.mortonUnhashLat(hash), 0.00001D);
-    assertEquals(10.5, GeoEncodingUtils.mortonUnhashLon(hash), 0.00001D);
-  }
-
-  public void testDecodeEncode() {
-    final String geoHash = "u173zq37x014";
-    assertEquals(geoHash, GeoHashUtils.stringEncode(4.8909347, 52.3738007));
-    final long mortonHash = GeoHashUtils.mortonEncode(geoHash);
-    final double lon = GeoEncodingUtils.mortonUnhashLon(mortonHash);
-    final double lat = GeoEncodingUtils.mortonUnhashLat(mortonHash);
-    assertEquals(52.37380061d, GeoEncodingUtils.mortonUnhashLat(mortonHash), 0.000001d);
-    assertEquals(4.8909343d, GeoEncodingUtils.mortonUnhashLon(mortonHash), 0.000001d);
-
-    assertEquals(geoHash, GeoHashUtils.stringEncode(lon, lat));
-  }
-
-  public void testNeighbors() {
-    String geohash = "gcpv";
-    List<String> expectedNeighbors = new ArrayList<>();
-    expectedNeighbors.add("gcpw");
-    expectedNeighbors.add("gcpy");
-    expectedNeighbors.add("u10n");
-    expectedNeighbors.add("gcpt");
-    expectedNeighbors.add("u10j");
-    expectedNeighbors.add("gcps");
-    expectedNeighbors.add("gcpu");
-    expectedNeighbors.add("u10h");
-    Collection<? super String> neighbors = new ArrayList<>();
-    GeoHashUtils.addNeighbors(geohash, neighbors );
-    assertEquals(expectedNeighbors, neighbors);
-
-    // Border odd geohash
-    geohash = "u09x";
-    expectedNeighbors = new ArrayList<>();
-    expectedNeighbors.add("u0c2");
-    expectedNeighbors.add("u0c8");
-    expectedNeighbors.add("u0cb");
-    expectedNeighbors.add("u09r");
-    expectedNeighbors.add("u09z");
-    expectedNeighbors.add("u09q");
-    expectedNeighbors.add("u09w");
-    expectedNeighbors.add("u09y");
-    neighbors = new ArrayList<>();
-    GeoHashUtils.addNeighbors(geohash, neighbors);
-    assertEquals(expectedNeighbors, neighbors);
-
-    // Border even geohash
-    geohash = "u09tv";
-    expectedNeighbors = new ArrayList<>();
-    expectedNeighbors.add("u09wh");
-    expectedNeighbors.add("u09wj");
-    expectedNeighbors.add("u09wn");
-    expectedNeighbors.add("u09tu");
-    expectedNeighbors.add("u09ty");
-    expectedNeighbors.add("u09ts");
-    expectedNeighbors.add("u09tt");
-    expectedNeighbors.add("u09tw");
-    neighbors = new ArrayList<>();
-    GeoHashUtils.addNeighbors(geohash, neighbors );
-    assertEquals(expectedNeighbors, neighbors);
-
-    // Border even and odd geohash
-    geohash = "ezzzz";
-    expectedNeighbors = new ArrayList<>();
-    expectedNeighbors.add("gbpbn");
-    expectedNeighbors.add("gbpbp");
-    expectedNeighbors.add("u0000");
-    expectedNeighbors.add("ezzzy");
-    expectedNeighbors.add("spbpb");
-    expectedNeighbors.add("ezzzw");
-    expectedNeighbors.add("ezzzx");
-    expectedNeighbors.add("spbp8");
-    neighbors = new ArrayList<>();
-    GeoHashUtils.addNeighbors(geohash, neighbors );
-    assertEquals(expectedNeighbors, neighbors);
-  }
-
   public void testClosestPointOnBBox() {
     double[] result = new double[2];
-    GeoDistanceUtils.closestPointOnBBox(20, 30, 40, 50, 70, 70, result);
-    assertEquals(40.0, result[0], 0.0);
-    assertEquals(50.0, result[1], 0.0);
+    GeoDistanceUtils.closestPointOnBBoxX(30, 50, 20, 40, 70, 70, result);
+    assertEquals(50.0, result[0], 0.0);
+    assertEquals(40.0, result[1], 0.0);
 
-    GeoDistanceUtils.closestPointOnBBox(-20, -20, 0, 0, 70, 70, result);
+    GeoDistanceUtils.closestPointOnBBoxX(-20, 0, -20, 0, 70, 70, result);
     assertEquals(0.0, result[0], 0.0);
     assertEquals(0.0, result[1], 0.0);
   }
@@ -331,7 +190,7 @@ public class TestGeoUtils extends LuceneTestCase {
         }
       } else {
 
-        if (GeoRelationUtils.rectWithinCircle(cell.minLon, cell.minLat, cell.maxLon, cell.maxLat, centerLon, centerLat, radiusMeters)) {
+        if (GeoRelationUtils.rectWithinCircle(cell.minLat, cell.maxLat, cell.minLon, cell.maxLon, centerLat, centerLon, radiusMeters, false)) {
           // Query circle fully contains this cell, just addAll:
           if (VERBOSE) {
             log.println("    circle fully contains cell: now addAll");
@@ -345,14 +204,14 @@ public class TestGeoUtils extends LuceneTestCase {
             }
           }
           continue;
-        } else if (GeoRelationUtils.rectWithin(root.minLon, root.minLat, root.maxLon, root.maxLat,
-                                       cell.minLon, cell.minLat, cell.maxLon, cell.maxLat)) {
+        } else if (GeoRelationUtils.rectWithinX(root.minLat, root.maxLat, root.minLon, root.maxLon,
+                                                cell.minLat, cell.maxLat, cell.minLon, cell.maxLon)) {
           // Fall through below to "recurse"
           if (VERBOSE) {
             log.println("    cell fully contains circle: keep splitting");
           }
-        } else if (GeoRelationUtils.rectCrossesCircle(cell.minLon, cell.minLat, cell.maxLon, cell.maxLat,
-                                              centerLon, centerLat, radiusMeters)) {
+        } else if (GeoRelationUtils.rectCrossesCircle(cell.minLat, cell.maxLat, cell.minLon, cell.maxLon,
+                                                      centerLat, centerLon, radiusMeters, false)) {
           // Fall through below to "recurse"
           if (VERBOSE) {
             log.println("    cell overlaps circle: keep splitting");
@@ -470,7 +329,7 @@ public class TestGeoUtils extends LuceneTestCase {
         log.println("\nTEST: iter=" + iter + " radiusMeters=" + radiusMeters + " centerLon=" + centerLon + " centerLat=" + centerLat);
       }
 
-      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);
+      GeoRect bbox = GeoUtils.circleToBBox(centerLat, centerLon, radiusMeters);
       
       Set<Integer> hits = new HashSet<>();
 
@@ -555,7 +414,7 @@ public class TestGeoUtils extends LuceneTestCase {
     long decodedHash;
     BytesRefBuilder brb = new BytesRefBuilder();
     while (numIters-- >= 0) {
-      hash = GeoEncodingUtils.mortonHash(randomLon(false), randomLat(false));
+      hash = GeoEncodingUtils.mortonHashX(randomLat(false), randomLon(false));
       for (int i=32; i<64; ++i) {
         GeoEncodingUtils.geoCodedToPrefixCoded(hash, i, brb);
         decodedHash = GeoEncodingUtils.prefixCodedToGeoCoded(brb.get());
