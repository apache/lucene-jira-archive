Index: lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldDocValuesFormat.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldDocValuesFormat.java	(revision 1635803)
+++ lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldDocValuesFormat.java	(working copy)
@@ -30,6 +30,7 @@
 import org.apache.lucene.codecs.DocValuesProducer;
 import org.apache.lucene.codecs.PostingsFormat;
 import org.apache.lucene.index.BinaryDocValues;
+import org.apache.lucene.index.DocValuesType;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.SegmentReadState;
@@ -251,7 +252,7 @@
       try {
         // Read field name -> format name
         for (FieldInfo fi : readState.fieldInfos) {
-          if (fi.hasDocValues()) {
+          if (fi.getDocValuesType() != DocValuesType.NO) {
             final String fieldName = fi.name;
             final String formatName = fi.getAttribute(PER_FIELD_FORMAT_KEY);
             if (formatName != null) {
Index: lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.java	(revision 1635803)
+++ lucene/core/src/java/org/apache/lucene/codecs/perfield/PerFieldPostingsFormat.java	(working copy)
@@ -36,6 +36,7 @@
 import org.apache.lucene.codecs.PostingsFormat;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.Fields;
+import org.apache.lucene.index.IndexOptions;
 import org.apache.lucene.index.SegmentReadState;
 import org.apache.lucene.index.SegmentWriteState;
 import org.apache.lucene.index.Terms;
@@ -242,7 +243,7 @@
       try {
         // Read field name -> format name
         for (FieldInfo fi : readState.fieldInfos) {
-          if (fi.isIndexed()) {
+          if (fi.getIndexOptions() != IndexOptions.NO) {
             final String fieldName = fi.name;
             final String formatName = fi.getAttribute(PER_FIELD_FORMAT_KEY);
             if (formatName != null) {
Index: lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/CheckIndex.java	(revision 1635803)
+++ lucene/core/src/java/org/apache/lucene/index/CheckIndex.java	(working copy)
@@ -906,7 +906,7 @@
       if (fieldInfo == null) {
         throw new RuntimeException("fieldsEnum inconsistent with fieldInfos, no fieldInfos for: " + field);
       }
-      if (!fieldInfo.isIndexed()) {
+      if (fieldInfo.getIndexOptions() == IndexOptions.NO) {
         throw new RuntimeException("fieldsEnum inconsistent with fieldInfos, isIndexed == false for: " + field);
       }
       
@@ -1535,7 +1535,7 @@
         infoStream.print("    test: docvalues...........");
       }
       for (FieldInfo fieldInfo : reader.getFieldInfos()) {
-        if (fieldInfo.hasDocValues()) {
+        if (fieldInfo.getDocValuesType() != DocValuesType.NO) {
           status.totalValueFields++;
           checkDocValues(fieldInfo, reader, infoStream, status);
         } else {
Index: lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java	(revision 1635803)
+++ lucene/core/src/java/org/apache/lucene/index/DefaultIndexingChain.java	(working copy)
@@ -128,7 +128,7 @@
         PerField perField = fieldHash[i];
         while (perField != null) {
           if (perField.docValuesWriter != null) {
-            if (perField.fieldInfo.hasDocValues() == false) {
+            if (perField.fieldInfo.getDocValuesType() == DocValuesType.NO) {
               // BUG
               throw new AssertionError("segment=" + state.segmentInfo + ": field=\"" + perField.fieldInfo.name + "\" has no docValues but wrote them");
             }
@@ -141,7 +141,7 @@
             perField.docValuesWriter.finish(docCount);
             perField.docValuesWriter.flush(state, dvConsumer);
             perField.docValuesWriter = null;
-          } else if (perField.fieldInfo.hasDocValues()) {
+          } else if (perField.fieldInfo.getDocValuesType() != DocValuesType.NO) {
             // BUG
             throw new AssertionError("segment=" + state.segmentInfo + ": field=\"" + perField.fieldInfo.name + "\" has docValues but did not write them");
           }
@@ -198,7 +198,7 @@
 
           // we must check the final value of omitNorms for the fieldinfo: it could have 
           // changed for this field since the first time we added it.
-          if (fi.omitsNorms() == false && fi.isIndexed()) {
+          if (fi.omitsNorms() == false && fi.getIndexOptions() != IndexOptions.NO) {
             assert perField.norms != null: "field=" + fi.name;
             perField.norms.finish(state.segmentInfo.getDocCount());
             perField.norms.flush(state, normsConsumer);
@@ -403,9 +403,7 @@
    *  value */
   private void indexDocValue(PerField fp, DocValuesType dvType, StorableField field) throws IOException {
 
-    boolean hasDocValues = fp.fieldInfo.hasDocValues();
-
-    if (hasDocValues == false) {
+    if (fp.fieldInfo.getDocValuesType() == DocValuesType.NO) {
       // This will throw an exc if the caller tried to
       // change the DV type for the field:
       fieldInfos.globalFieldNumbers.setDocValuesType(fp.fieldInfo.number, fp.fieldInfo.name, dvType);
Index: lucene/core/src/java/org/apache/lucene/index/FieldInfo.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/FieldInfo.java	(revision 1635803)
+++ lucene/core/src/java/org/apache/lucene/index/FieldInfo.java	(working copy)
@@ -157,13 +157,6 @@
   }
   
   /**
-   * Returns true if this field has any docValues.
-   */
-  public boolean hasDocValues() {
-    return docValueType != DocValuesType.NO;
-  }
-
-  /**
    * Returns {@link DocValuesType} of the docValues; this is
    * {@code DocValuesType.NO} if the field has no docvalues.
    */
@@ -208,17 +201,10 @@
    * Returns true if this field actually has any norms.
    */
   public boolean hasNorms() {
-    return isIndexed() && omitNorms == false;
+    return indexOptions != IndexOptions.NO && omitNorms == false;
   }
   
   /**
-   * Returns true if this field is indexed ({@link #getIndexOptions} is not IndexOptions.NO).
-   */
-  public boolean isIndexed() {
-    return indexOptions != IndexOptions.NO;
-  }
-  
-  /**
    * Returns true if any payloads exist for this field.
    */
   public boolean hasPayloads() {
Index: lucene/core/src/java/org/apache/lucene/index/FieldInfos.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/FieldInfos.java	(revision 1635803)
+++ lucene/core/src/java/org/apache/lucene/index/FieldInfos.java	(working copy)
@@ -68,11 +68,11 @@
       }
       
       hasVectors |= info.hasVectors();
-      hasProx |= info.isIndexed() && info.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
-      hasFreq |= info.isIndexed() && info.getIndexOptions() != IndexOptions.DOCS;
-      hasOffsets |= info.isIndexed() && info.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
+      hasProx |= info.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
+      hasFreq |= info.getIndexOptions() != IndexOptions.DOCS;
+      hasOffsets |= info.getIndexOptions().compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
       hasNorms |= info.hasNorms();
-      hasDocValues |= info.hasDocValues();
+      hasDocValues |= info.getDocValuesType() != DocValuesType.NO;
       hasPayloads |= info.hasPayloads();
     }
     
@@ -314,7 +314,7 @@
 
         if (docValues != DocValuesType.NO) {
           // Only pay the synchronization cost if fi does not already have a DVType
-          boolean updateGlobal = !fi.hasDocValues();
+          boolean updateGlobal = fi.getDocValuesType() == DocValuesType.NO;
           if (updateGlobal) {
             // Must also update docValuesType map so it's
             // aware of this field's DocValueType.  This will throw IllegalArgumentException if
Index: lucene/core/src/java/org/apache/lucene/index/FreqProxTermsWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/FreqProxTermsWriter.java	(revision 1635803)
+++ lucene/core/src/java/org/apache/lucene/index/FreqProxTermsWriter.java	(working copy)
@@ -89,7 +89,7 @@
       final FreqProxTermsWriterPerField perField = (FreqProxTermsWriterPerField) f;
       if (perField.bytesHash.size() > 0) {
         perField.sortPostings();
-        assert perField.fieldInfo.isIndexed();
+        assert perField.fieldInfo.getIndexOptions() != IndexOptions.NO;
         allFields.add(perField);
       }
     }
Index: lucene/core/src/java/org/apache/lucene/index/MultiFields.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/MultiFields.java	(revision 1635803)
+++ lucene/core/src/java/org/apache/lucene/index/MultiFields.java	(working copy)
@@ -271,7 +271,7 @@
   public static Collection<String> getIndexedFields(IndexReader reader) {
     final Collection<String> fields = new HashSet<>();
     for(final FieldInfo fieldInfo : getMergedFieldInfos(reader)) {
-      if (fieldInfo.isIndexed()) {
+      if (fieldInfo.getIndexOptions() != IndexOptions.NO) {
         fields.add(fieldInfo.name);
       }
     }
Index: lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer.java	(revision 1635803)
+++ lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer.java	(working copy)
@@ -53,7 +53,7 @@
     try {
       DocValuesProducer baseProducer = null;
       for (FieldInfo fi : fieldInfos) {
-        if (!fi.hasDocValues()) {
+        if (fi.getDocValuesType() == DocValuesType.NO) {
           continue;
         }
         long docValuesGen = fi.getDocValuesGen();
Index: lucene/core/src/java/org/apache/lucene/index/SimpleMergedSegmentWarmer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/SimpleMergedSegmentWarmer.java	(revision 1635803)
+++ lucene/core/src/java/org/apache/lucene/index/SimpleMergedSegmentWarmer.java	(working copy)
@@ -44,7 +44,7 @@
     int docValuesCount = 0;
     int normsCount = 0;
     for (FieldInfo info : reader.getFieldInfos()) {
-      if (info.isIndexed()) {
+      if (info.getIndexOptions() != IndexOptions.NO) {
         reader.terms(info.name); 
         indexedCount++;
         
@@ -54,7 +54,7 @@
         }
       }
       
-      if (info.hasDocValues()) {
+      if (info.getDocValuesType() != DocValuesType.NO) {
         switch(info.getDocValuesType()) {
           case NUMERIC:
             reader.getNumericDocValues(info.name);
Index: lucene/core/src/test/org/apache/lucene/index/TestDirectoryReader.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestDirectoryReader.java	(revision 1635803)
+++ lucene/core/src/test/org/apache/lucene/index/TestDirectoryReader.java	(working copy)
@@ -255,7 +255,7 @@
       for(FieldInfo fieldInfo : fieldInfos) {
         final String name = fieldInfo.name;
         allFieldNames.add(name);
-        if (fieldInfo.isIndexed()) {
+        if (fieldInfo.getIndexOptions() != IndexOptions.NO) {
           indexedFieldNames.add(name);
         } else {
           notIndexedFieldNames.add(name);
Index: lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing.java	(revision 1635803)
+++ lucene/core/src/test/org/apache/lucene/index/TestDocValuesIndexing.java	(working copy)
@@ -206,7 +206,7 @@
     LeafReader slow = SlowCompositeReaderWrapper.wrap(r);
     FieldInfos fi = slow.getFieldInfos();
     FieldInfo dvInfo = fi.fieldInfo("dv");
-    assertTrue(dvInfo.hasDocValues());
+    assertTrue(dvInfo.getDocValuesType() != DocValuesType.NO);
     NumericDocValues dv = slow.getNumericDocValues("dv");
     for (int i = 0; i < 50; i++) {
       assertEquals(i, dv.get(i));
Index: lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter.java	(revision 1635803)
+++ lucene/core/src/test/org/apache/lucene/index/TestDocumentWriter.java	(working copy)
@@ -93,7 +93,7 @@
     // test that the norms are not present in the segment if
     // omitNorms is true
     for (FieldInfo fi : reader.getFieldInfos()) {
-      if (fi.isIndexed()) {
+      if (fi.getIndexOptions() != IndexOptions.NO) {
         assertTrue(fi.omitsNorms() == (reader.getNormValues(fi.name) == null));
       }
     }
Index: lucene/core/src/test/org/apache/lucene/index/TestSegmentReader.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/index/TestSegmentReader.java	(revision 1635803)
+++ lucene/core/src/test/org/apache/lucene/index/TestSegmentReader.java	(working copy)
@@ -84,7 +84,7 @@
     for(FieldInfo fieldInfo : reader.getFieldInfos()) {
       final String name = fieldInfo.name;
       allFieldNames.add(name);
-      if (fieldInfo.isIndexed()) {
+      if (fieldInfo.getIndexOptions() != IndexOptions.NO) {
         indexedFieldNames.add(name);
       } else {
         notIndexedFieldNames.add(name);
@@ -91,7 +91,7 @@
       }
       if (fieldInfo.hasVectors()) {
         tvFieldNames.add(name);
-      } else if (fieldInfo.isIndexed()) {
+      } else if (fieldInfo.getIndexOptions() != IndexOptions.NO) {
         noTVFieldNames.add(name);
       }
     }
Index: lucene/misc/src/java/org/apache/lucene/uninverting/DocTermOrds.java
===================================================================
--- lucene/misc/src/java/org/apache/lucene/uninverting/DocTermOrds.java	(revision 1635803)
+++ lucene/misc/src/java/org/apache/lucene/uninverting/DocTermOrds.java	(working copy)
@@ -24,12 +24,13 @@
 import java.util.List;
 
 import org.apache.lucene.codecs.PostingsFormat; // javadocs
-import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.DocValuesType;
 import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.Fields;
+import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.SortedSetDocValues;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
@@ -282,7 +283,7 @@
   /** Call this only once (if you subclass!) */
   protected void uninvert(final LeafReader reader, Bits liveDocs, final BytesRef termPrefix) throws IOException {
     final FieldInfo info = reader.getFieldInfos().fieldInfo(field);
-    if (info != null && info.hasDocValues()) {
+    if (info != null && info.getDocValuesType() != DocValuesType.NO) {
       throw new IllegalStateException("Type mismatch: " + field + " was indexed as " + info.getDocValuesType());
     }
     //System.out.println("DTO uninvert field=" + field + " prefix=" + termPrefix);
Index: lucene/misc/src/java/org/apache/lucene/uninverting/FieldCacheImpl.java
===================================================================
--- lucene/misc/src/java/org/apache/lucene/uninverting/FieldCacheImpl.java	(revision 1635803)
+++ lucene/misc/src/java/org/apache/lucene/uninverting/FieldCacheImpl.java	(working copy)
@@ -26,11 +26,13 @@
 import java.util.Map;
 import java.util.WeakHashMap;
 
-import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.BinaryDocValues;
 import org.apache.lucene.index.DocValues;
+import org.apache.lucene.index.DocValuesType;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.IndexOptions;
+import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.SegmentReader;
 import org.apache.lucene.index.SortedDocValues;
@@ -356,9 +358,9 @@
     if (fieldInfo == null) {
       // field does not exist or has no value
       return new Bits.MatchNoBits(reader.maxDoc());
-    } else if (fieldInfo.hasDocValues()) {
+    } else if (fieldInfo.getDocValuesType() != DocValuesType.NO) {
       return reader.getDocsWithField(field);
-    } else if (!fieldInfo.isIndexed()) {
+    } else if (fieldInfo.getIndexOptions() == IndexOptions.NO) {
       return new Bits.MatchNoBits(reader.maxDoc());
     }
     BitsEntry bitsEntry = (BitsEntry) caches.get(DocsWithFieldCache.class).get(reader, new CacheKey(field, null), false);
@@ -459,9 +461,9 @@
       final FieldInfo info = reader.getFieldInfos().fieldInfo(field);
       if (info == null) {
         return DocValues.emptyNumeric();
-      } else if (info.hasDocValues()) {
+      } else if (info.getDocValuesType() != DocValuesType.NO) {
         throw new IllegalStateException("Type mismatch: " + field + " was indexed as " + info.getDocValuesType());
-      } else if (!info.isIndexed()) {
+      } else if (info.getIndexOptions() == IndexOptions.NO) {
         return DocValues.emptyNumeric();
       }
       return (NumericDocValues) caches.get(Long.TYPE).get(reader, new CacheKey(field, parser), setDocsWithField);
@@ -634,11 +636,11 @@
       final FieldInfo info = reader.getFieldInfos().fieldInfo(field);
       if (info == null) {
         return DocValues.emptySorted();
-      } else if (info.hasDocValues()) {
+      } else if (info.getDocValuesType() != DocValuesType.NO) {
         // we don't try to build a sorted instance from numeric/binary doc
         // values because dedup can be very costly
         throw new IllegalStateException("Type mismatch: " + field + " was indexed as " + info.getDocValuesType());
-      } else if (!info.isIndexed()) {
+      } else if (info.getIndexOptions() == IndexOptions.NO) {
         return DocValues.emptySorted();
       }
       SortedDocValuesImpl impl = (SortedDocValuesImpl) caches.get(SortedDocValues.class).get(reader, new CacheKey(field, acceptableOverheadRatio), false);
@@ -783,9 +785,9 @@
     final FieldInfo info = reader.getFieldInfos().fieldInfo(field);
     if (info == null) {
       return DocValues.emptyBinary();
-    } else if (info.hasDocValues()) {
+    } else if (info.getDocValuesType() != DocValuesType.NO) {
       throw new IllegalStateException("Type mismatch: " + field + " was indexed as " + info.getDocValuesType());
-    } else if (!info.isIndexed()) {
+    } else if (info.getIndexOptions() == IndexOptions.NO) {
       return DocValues.emptyBinary();
     }
 
@@ -906,9 +908,9 @@
     final FieldInfo info = reader.getFieldInfos().fieldInfo(field);
     if (info == null) {
       return DocValues.emptySortedSet();
-    } else if (info.hasDocValues()) {
+    } else if (info.getDocValuesType() != DocValuesType.NO) {
       throw new IllegalStateException("Type mismatch: " + field + " was indexed as " + info.getDocValuesType());
-    } else if (!info.isIndexed()) {
+    } else if (info.getIndexOptions() == IndexOptions.NO) {
       return DocValues.emptySortedSet();
     }
     
Index: lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader.java
===================================================================
--- lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader.java	(revision 1635803)
+++ lucene/misc/src/java/org/apache/lucene/uninverting/UninvertingReader.java	(working copy)
@@ -37,6 +37,7 @@
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.FilterDirectoryReader;
 import org.apache.lucene.index.FilterLeafReader;
+import org.apache.lucene.index.IndexOptions;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.SortedDocValues;
@@ -185,7 +186,7 @@
     ArrayList<FieldInfo> filteredInfos = new ArrayList<>();
     for (FieldInfo fi : in.getFieldInfos()) {
       DocValuesType type = fi.getDocValuesType();
-      if (fi.isIndexed() && !fi.hasDocValues()) {
+      if (fi.getIndexOptions() != IndexOptions.NO && fi.getDocValuesType() == DocValuesType.NO) {
         Type t = mapping.get(fi.name);
         if (t != null) {
           switch(t) {
@@ -291,7 +292,7 @@
    */
   private Type getType(String field) {
     FieldInfo info = fieldInfos.fieldInfo(field);
-    if (info == null || info.hasDocValues() == false) {
+    if (info == null || info.getDocValuesType() == DocValuesType.NO) {
       return null;
     }
     return mapping.get(field);
Index: lucene/test-framework/src/java/org/apache/lucene/index/AssertingLeafReader.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/index/AssertingLeafReader.java	(revision 1635803)
+++ lucene/test-framework/src/java/org/apache/lucene/index/AssertingLeafReader.java	(working copy)
@@ -800,11 +800,11 @@
     FieldInfo fi = getFieldInfos().fieldInfo(field);
     if (docsWithField != null) {
       assert fi != null;
-      assert fi.hasDocValues();
+      assert fi.getDocValuesType() != DocValuesType.NO;
       assert maxDoc() == docsWithField.length();
       docsWithField = new AssertingBits(docsWithField);
     } else {
-      assert fi == null || fi.hasDocValues() == false;
+      assert fi == null || fi.getDocValuesType() == DocValuesType.NO;
     }
     return docsWithField;
   }
Index: lucene/test-framework/src/java/org/apache/lucene/index/BaseFieldInfoFormatTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/index/BaseFieldInfoFormatTestCase.java	(revision 1635803)
+++ lucene/test-framework/src/java/org/apache/lucene/index/BaseFieldInfoFormatTestCase.java	(working copy)
@@ -56,8 +56,8 @@
     FieldInfos infos2 = codec.fieldInfosFormat().read(dir, segmentInfo, "", IOContext.DEFAULT);
     assertEquals(1, infos2.size());
     assertNotNull(infos2.fieldInfo("field"));
-    assertTrue(infos2.fieldInfo("field").isIndexed());
-    assertFalse(infos2.fieldInfo("field").hasDocValues());
+    assertTrue(infos2.fieldInfo("field").getIndexOptions() != IndexOptions.NO);
+    assertFalse(infos2.fieldInfo("field").getDocValuesType() != DocValuesType.NO);
     assertFalse(infos2.fieldInfo("field").omitsNorms());
     assertFalse(infos2.fieldInfo("field").hasPayloads());
     assertFalse(infos2.fieldInfo("field").hasVectors());
@@ -157,11 +157,9 @@
     assertEquals(expected.name, actual.name);
     assertEquals(expected.getDocValuesType(), actual.getDocValuesType());
     assertEquals(expected.getIndexOptions(), actual.getIndexOptions());
-    assertEquals(expected.hasDocValues(), actual.hasDocValues());
     assertEquals(expected.hasNorms(), actual.hasNorms());
     assertEquals(expected.hasPayloads(), actual.hasPayloads());
     assertEquals(expected.hasVectors(), actual.hasVectors());
-    assertEquals(expected.isIndexed(), actual.isIndexed());
     assertEquals(expected.omitsNorms(), actual.omitsNorms());
     assertEquals(expected.getDocValuesGen(), actual.getDocValuesGen());
   }
Index: lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(revision 1635803)
+++ lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java	(working copy)
@@ -68,6 +68,7 @@
 import org.apache.lucene.index.CompositeReader;
 import org.apache.lucene.index.ConcurrentMergeScheduler;
 import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.DocValuesType;
 import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.FieldFilterLeafReader;
@@ -2218,7 +2219,7 @@
   private static Set<String> getDVFields(IndexReader reader) {
     Set<String> fields = new HashSet<>();
     for(FieldInfo fi : MultiFields.getMergedFieldInfos(reader)) {
-      if (fi.hasDocValues()) {
+      if (fi.getDocValuesType() != DocValuesType.NO) {
         fields.add(fi.name);
       }
     }
Index: solr/core/src/java/org/apache/solr/schema/IndexSchema.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/IndexSchema.java	(revision 1635803)
+++ solr/core/src/java/org/apache/solr/schema/IndexSchema.java	(working copy)
@@ -17,9 +17,33 @@
 
 package org.apache.solr.schema;
 
+import java.io.IOException;
+import java.io.Writer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Set;
+import java.util.SortedMap;
+import java.util.SortedSet;
+import java.util.TreeMap;
+import java.util.TreeSet;
+import java.util.regex.Pattern;
+import javax.xml.xpath.XPath;
+import javax.xml.xpath.XPathConstants;
+import javax.xml.xpath.XPathExpressionException;
+
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.DelegatingAnalyzerWrapper;
+import org.apache.lucene.index.DocValuesType;
 import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.IndexOptions;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.MultiFields;
@@ -29,19 +53,19 @@
 import org.apache.lucene.uninverting.UninvertingReader;
 import org.apache.lucene.util.Version;
 import org.apache.solr.cloud.CloudUtil;
+import org.apache.solr.common.SolrException.ErrorCode;
 import org.apache.solr.common.SolrException;
-import org.apache.solr.common.SolrException.ErrorCode;
 import org.apache.solr.common.params.SolrParams;
 import org.apache.solr.common.util.NamedList;
 import org.apache.solr.common.util.SimpleOrderedMap;
+import org.apache.solr.core.Config;
+import org.apache.solr.core.SolrConfig;
+import org.apache.solr.core.SolrResourceLoader;
 import org.apache.solr.request.LocalSolrQueryRequest;
 import org.apache.solr.response.SchemaXmlWriter;
 import org.apache.solr.response.SolrQueryResponse;
+import org.apache.solr.search.similarities.DefaultSimilarityFactory;
 import org.apache.solr.util.DOMUtil;
-import org.apache.solr.core.SolrConfig;
-import org.apache.solr.core.Config;
-import org.apache.solr.core.SolrResourceLoader;
-import org.apache.solr.search.similarities.DefaultSimilarityFactory;
 import org.apache.solr.util.plugin.SolrCoreAware;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -52,29 +76,6 @@
 import org.w3c.dom.NodeList;
 import org.xml.sax.InputSource;
 
-import javax.xml.xpath.XPath;
-import javax.xml.xpath.XPathConstants;
-import javax.xml.xpath.XPathExpressionException;
-
-import java.io.IOException;
-import java.io.Writer;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Set;
-import java.util.SortedMap;
-import java.util.SortedSet;
-import java.util.TreeMap;
-import java.util.TreeSet;
-import java.util.regex.Pattern;
-
 import static java.util.Collections.singletonList;
 import static java.util.Collections.singletonMap;
 
@@ -369,7 +370,7 @@
   public Map<String,UninvertingReader.Type> getUninversionMap(IndexReader reader) {
     Map<String,UninvertingReader.Type> map = new HashMap<>();
     for (FieldInfo f : MultiFields.getMergedFieldInfos(reader)) {
-      if (f.hasDocValues() == false && f.isIndexed()) {
+      if (f.getDocValuesType() == DocValuesType.NO && f.getIndexOptions() != IndexOptions.NO) {
         SchemaField sf = getFieldOrNull(f.name);
         if (sf != null) {
           UninvertingReader.Type type = sf.getType().getUninversionType(sf);
