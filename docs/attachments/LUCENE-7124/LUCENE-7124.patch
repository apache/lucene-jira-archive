diff --git a/lucene/core/src/java/org/apache/lucene/util/SloppyMath.java b/lucene/core/src/java/org/apache/lucene/util/SloppyMath.java
index e3ba489..9858cdd 100644
--- a/lucene/core/src/java/org/apache/lucene/util/SloppyMath.java
+++ b/lucene/core/src/java/org/apache/lucene/util/SloppyMath.java
@@ -37,7 +37,7 @@ public class SloppyMath {
    * specified in decimal degrees (latitude/longitude).  This works correctly
    * even if the dateline is between the two points.
    * <p>
-   * Error is around 1E-5 (0.01mm) from the actual haversine distance.
+   * Error is at most 1E-1 (.1m) from the actual haversine distance.
    *
    * @param lat1 Latitude of the first point.
    * @param lon1 Longitude of the first point.
@@ -93,7 +93,7 @@ public class SloppyMath {
   /**
    * Returns the trigonometric cosine of an angle.
    * <p>
-   * Error is around 1E-15.
+   * Error is around 1E-10.
    * <p>
    * Special cases:
    * <ul>
@@ -118,7 +118,7 @@ public class SloppyMath {
     index &= (SIN_COS_TABS_SIZE-2); // index % (SIN_COS_TABS_SIZE-1)
     double indexCos = cosTab[index];
     double indexSin = sinTab[index];
-    return indexCos + delta * (-indexSin + delta * (-indexCos * ONE_DIV_F2 + delta * (indexSin * ONE_DIV_F3 + delta * indexCos * ONE_DIV_F4)));
+    return indexCos + delta * (-indexSin + delta * (-indexCos * ONE_DIV_F2 + delta * (indexSin * ONE_DIV_F3)));
   }
 
   /**
@@ -150,7 +150,7 @@ public class SloppyMath {
     if (a <= ASIN_MAX_VALUE_FOR_TABS) {
       int index = (int)(a * ASIN_INDEXER + 0.5);
       double delta = a - index * ASIN_DELTA;
-      double result = asinTab[index] + delta * (asinDer1DivF1Tab[index] + delta * (asinDer2DivF2Tab[index] + delta * (asinDer3DivF3Tab[index] + delta * asinDer4DivF4Tab[index])));
+      double result = asinTab[index] + delta * (asinDer1DivF1Tab[index] + delta * asinDer2DivF2Tab[index]);
       return negateResult ? -result : result;
     } else { // value > ASIN_MAX_VALUE_FOR_TABS, or value is NaN
       // This part is derived from fdlibm.
@@ -182,13 +182,12 @@ public class SloppyMath {
   // cos/asin
   private static final double ONE_DIV_F2 = 1/2.0;
   private static final double ONE_DIV_F3 = 1/6.0;
-  private static final double ONE_DIV_F4 = 1/24.0;
 
   private static final double PIO2_HI = Double.longBitsToDouble(0x3FF921FB54400000L); // 1.57079632673412561417e+00 first 33 bits of pi/2
   private static final double PIO2_LO = Double.longBitsToDouble(0x3DD0B4611A626331L); // 6.07710050650619224932e-11 pi/2 - PIO2_HI
   private static final double TWOPI_HI = 4*PIO2_HI;
   private static final double TWOPI_LO = 4*PIO2_LO;
-  private static final int SIN_COS_TABS_SIZE = (1<<11) + 1;
+  private static final int SIN_COS_TABS_SIZE = (1<<10) + 1;
   private static final double SIN_COS_DELTA_HI = TWOPI_HI/(SIN_COS_TABS_SIZE-1);
   private static final double SIN_COS_DELTA_LO = TWOPI_LO/(SIN_COS_TABS_SIZE-1);
   private static final double SIN_COS_INDEXER = 1/(SIN_COS_DELTA_HI+SIN_COS_DELTA_LO);
@@ -205,14 +204,12 @@ public class SloppyMath {
   // but seems to work well enough as long as value >= sin(25deg).
   private static final double ASIN_MAX_VALUE_FOR_TABS = StrictMath.sin(Math.toRadians(73.0));
   
-  private static final int ASIN_TABS_SIZE = (1<<13) + 1;
+  private static final int ASIN_TABS_SIZE = (1<<11) + 1;
   private static final double ASIN_DELTA = ASIN_MAX_VALUE_FOR_TABS/(ASIN_TABS_SIZE - 1);
   private static final double ASIN_INDEXER = 1/ASIN_DELTA;
   private static final double[] asinTab = new double[ASIN_TABS_SIZE];
   private static final double[] asinDer1DivF1Tab = new double[ASIN_TABS_SIZE];
   private static final double[] asinDer2DivF2Tab = new double[ASIN_TABS_SIZE];
-  private static final double[] asinDer3DivF3Tab = new double[ASIN_TABS_SIZE];
-  private static final double[] asinDer4DivF4Tab = new double[ASIN_TABS_SIZE];
   
   private static final double ASIN_PIO2_HI = Double.longBitsToDouble(0x3FF921FB54442D18L); // 1.57079632679489655800e+00
   private static final double ASIN_PIO2_LO = Double.longBitsToDouble(0x3C91A62633145C07L); // 6.12323399573676603587e-17
@@ -262,12 +259,8 @@ public class SloppyMath {
       double oneMinusXSqInv = 1.0/(1-x*x);
       double oneMinusXSqInv0_5 = StrictMath.sqrt(oneMinusXSqInv);
       double oneMinusXSqInv1_5 = oneMinusXSqInv0_5*oneMinusXSqInv;
-      double oneMinusXSqInv2_5 = oneMinusXSqInv1_5*oneMinusXSqInv;
-      double oneMinusXSqInv3_5 = oneMinusXSqInv2_5*oneMinusXSqInv;
       asinDer1DivF1Tab[i] = oneMinusXSqInv0_5;
       asinDer2DivF2Tab[i] = (x*oneMinusXSqInv1_5) * ONE_DIV_F2;
-      asinDer3DivF3Tab[i] = ((1+2*x*x)*oneMinusXSqInv2_5) * ONE_DIV_F3;
-      asinDer4DivF4Tab[i] = ((5+2*x*(2+x*(5-2*x)))*oneMinusXSqInv3_5) * ONE_DIV_F4;
     }
   }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestSloppyMath.java b/lucene/core/src/test/org/apache/lucene/util/TestSloppyMath.java
index 2ccf619..d19245d 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestSloppyMath.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestSloppyMath.java
@@ -27,11 +27,11 @@ import java.util.Random;
 
 public class TestSloppyMath extends LuceneTestCase {
   // accuracy for cos()
-  static double COS_DELTA = 1E-15;
+  static double COS_DELTA = 1E-10;
   // accuracy for asin()
   static double ASIN_DELTA = 1E-7;
   // accuracy for haversinMeters()
-  static double HAVERSIN_DELTA = 1E-5;
+  static double HAVERSIN_DELTA = 1E-1;
   
   public void testCos() {
     assertTrue(Double.isNaN(cos(Double.NaN)));
@@ -50,7 +50,7 @@ public class TestSloppyMath extends LuceneTestCase {
     
     // testing purely random longs is inefficent, as for stupid parameters we just 
     // pass thru to Math.cos() instead of doing some huperduper arg reduction
-    for (int i = 0; i < 10000; i++) {
+    for (int i = 0; i < 1000; i++) {
       double d = random().nextDouble() * SloppyMath.SIN_COS_MAX_VALUE_FOR_INT_MODULO;
       if (random().nextBoolean()) {
         d = -d;
@@ -73,7 +73,7 @@ public class TestSloppyMath extends LuceneTestCase {
     assertEquals(Math.PI/3, asin(0.8660254), ASIN_DELTA);
     assertEquals(Math.PI/2, asin(1), ASIN_DELTA);
     // only values -1..1 are useful
-    for (int i = 0; i < 10000; i++) {
+    for (int i = 0; i < 100000; i++) {
       double d = random().nextDouble();
       if (random().nextBoolean()) {
         d = -d;
diff --git a/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestJavascriptFunction.java b/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestJavascriptFunction.java
index ce38acd..09aec4a 100644
--- a/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestJavascriptFunction.java
+++ b/lucene/expressions/src/test/org/apache/lucene/expressions/js/TestJavascriptFunction.java
@@ -158,7 +158,7 @@ public class TestJavascriptFunction extends LuceneTestCase {
   }
   
   public void testHaversinMethod() throws Exception {
-    assertEvaluatesTo("haversin(40.7143528,-74.0059731,40.759011,-73.9844722)", 5.291799723323441);
+    assertEvaluatesTo("haversin(40.7143528,-74.0059731,40.759011,-73.9844722)", 5.2917998456883275);
   }
   
   public void testLnMethod() throws Exception {
diff --git a/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java b/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java
index 8e8b03d..74fca29 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java
@@ -63,13 +63,13 @@ public class TestLatLonPointDistanceSort extends LuceneTestCase {
     TopDocs td = searcher.search(new MatchAllDocsQuery(), 3, sort);
     
     FieldDoc d = (FieldDoc) td.scoreDocs[0];
-    assertEquals(462.6174876948475D, (Double)d.fields[0], 0.0D);
+    assertEquals(462.61748759343243D, (Double)d.fields[0], 0.0D);
     
     d = (FieldDoc) td.scoreDocs[1];
-    assertEquals(1056.163041670945D, (Double)d.fields[0], 0.0D);
+    assertEquals(1056.1630447405387D, (Double)d.fields[0], 0.0D);
     
     d = (FieldDoc) td.scoreDocs[2];
-    assertEquals(5291.798081190281D, (Double)d.fields[0], 0.0D);
+    assertEquals(5291.798203555208D, (Double)d.fields[0], 0.0D);
     
     reader.close();
     dir.close();
@@ -100,10 +100,10 @@ public class TestLatLonPointDistanceSort extends LuceneTestCase {
     TopDocs td = searcher.search(new MatchAllDocsQuery(), 3, sort);
     
     FieldDoc d = (FieldDoc) td.scoreDocs[0];
-    assertEquals(462.6174876948475D, (Double)d.fields[0], 0.0D);
+    assertEquals(462.61748759343243D, (Double)d.fields[0], 0.0D);
     
     d = (FieldDoc) td.scoreDocs[1];
-    assertEquals(1056.163041670945D, (Double)d.fields[0], 0.0D);
+    assertEquals(1056.1630447405387D, (Double)d.fields[0], 0.0D);
     
     d = (FieldDoc) td.scoreDocs[2];
     assertEquals(Double.POSITIVE_INFINITY, (Double)d.fields[0], 0.0D);
