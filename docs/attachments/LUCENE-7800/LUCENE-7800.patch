diff --git a/lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram.java b/lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram.java
index bfc8ec0..7561bd2 100644
--- a/lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram.java
+++ b/lucene/analysis/common/src/java/org/tartarus/snowball/SnowballProgram.java
@@ -313,8 +313,10 @@ public abstract class SnowballProgram {
           boolean res = false;
           try {
             res = (boolean) w.method.invokeExact(this);
+          } catch (Error | RuntimeException e) {
+            throw e;
           } catch (Throwable e) {
-            rethrow(e);
+            throw new AssertionError(e);
           }
           cursor = c + w.s_size;
           if (res) return w.result;
@@ -376,8 +378,10 @@ public abstract class SnowballProgram {
           boolean res = false;
           try {
             res = (boolean) w.method.invokeExact(this);
+          } catch (Error | RuntimeException e) {
+            throw e;
           } catch (Throwable e) {
-            rethrow(e);
+            throw new AssertionError(e);
           }
           cursor = c - w.s_size;
           if (res) return w.result;
@@ -485,15 +489,5 @@ extern void debug(struct SN_env * z, int number, int line_count)
     printf("'\n");
 }
 */
-
-    // Hack to rethrow unknown Exceptions from {@link MethodHandle#invoke}:
-    private static void rethrow(Throwable t) {
-      SnowballProgram.<Error>rethrow0(t);
-    }
-    
-    @SuppressWarnings("unchecked")
-    private static <T extends Throwable> void rethrow0(Throwable t) throws T {
-      throw (T) t;
-    }
 };
 
diff --git a/lucene/core/src/java/org/apache/lucene/util/AttributeFactory.java b/lucene/core/src/java/org/apache/lucene/util/AttributeFactory.java
index 6c3d6db..8b70d6d 100644
--- a/lucene/core/src/java/org/apache/lucene/util/AttributeFactory.java
+++ b/lucene/core/src/java/org/apache/lucene/util/AttributeFactory.java
@@ -52,6 +52,17 @@ public abstract class AttributeFactory {
    */
   public static final AttributeFactory DEFAULT_ATTRIBUTE_FACTORY = new DefaultAttributeFactory();
   
+  /**
+   * A subclass of {@code RuntimeException} propagated from {@link AttributeFactory#createAttributeInstance(Class)}
+   * if the attribute class being instantiated throws an unchecked exception.
+   */
+  @SuppressWarnings("serial")
+  public static final class AttributeInstantiationException extends RuntimeException {
+    private AttributeInstantiationException(Throwable cause) {
+      super(cause);
+    }
+  }
+  
   private static final class DefaultAttributeFactory extends AttributeFactory {
     private final ClassValue<MethodHandle> constructors = new ClassValue<MethodHandle>() {
       @Override
@@ -66,9 +77,10 @@ public abstract class AttributeFactory {
     public AttributeImpl createAttributeInstance(Class<? extends Attribute> attClass) {
       try {
         return (AttributeImpl) constructors.get(attClass).invokeExact();
-      } catch (Throwable t) {
-        rethrow(t);
-        throw new AssertionError();
+      } catch (Error | RuntimeException e) {
+        throw e;
+      } catch (Throwable e) {
+        throw new AttributeInstantiationException(e);
       }
     }
     
@@ -138,23 +150,12 @@ public abstract class AttributeFactory {
       protected A createInstance() {
         try {
           return (A) constr.invokeExact();
-        } catch (Throwable t) {
-          rethrow(t);
-          throw new AssertionError();
+        } catch (Error | RuntimeException e) {
+          throw e;
+        } catch (Throwable e) {
+          throw new AttributeInstantiationException(e);
         }
       }
     };
   }
-  
-  // Hack to rethrow unknown Exceptions from {@link MethodHandle#invoke}:
-  // TODO: remove the impl in test-framework, this one is more elegant :-)
-  static void rethrow(Throwable t) {
-    AttributeFactory.<Error>rethrow0(t);
-  }
-  
-  @SuppressWarnings("unchecked")
-  private static <T extends Throwable> void rethrow0(Throwable t) throws T {
-    throw (T) t;
-  }
-  
 }
\ No newline at end of file
diff --git a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler.java b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler.java
index 87e41c0..465d43c 100644
--- a/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler.java
+++ b/lucene/expressions/src/java/org/apache/lucene/expressions/js/JavascriptCompiler.java
@@ -188,15 +188,20 @@ public final class JavascriptCompiler {
   private Expression compileExpression(ClassLoader parent) throws ParseException {
     final Map<String, Integer> externalsMap = new LinkedHashMap<>();
     final ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
-    
-    generateClass(getAntlrParseTree(), classWriter, externalsMap);
-    
+
     try {
+      generateClass(getAntlrParseTree(), classWriter, externalsMap);
+
       final Class<? extends Expression> evaluatorClass = new Loader(parent)
         .define(COMPILED_EXPRESSION_CLASS, classWriter.toByteArray());
       final Constructor<? extends Expression> constructor = evaluatorClass.getConstructor(String.class, String[].class);
 
       return constructor.newInstance(sourceText, externalsMap.keySet().toArray(new String[externalsMap.size()]));
+    } catch (RuntimeException re) {
+      if (re.getCause() instanceof ParseException) {
+        throw (ParseException)re.getCause();
+      }
+      throw re;
     } catch (ReflectiveOperationException exception) {
       throw new IllegalStateException("An internal error occurred attempting to compile the expression (" + sourceText + ").", exception);
     }
@@ -209,20 +214,13 @@ public final class JavascriptCompiler {
    * @throws ParseException on failure to parse
    */
   private ParseTree getAntlrParseTree() throws ParseException {
-    try {
-      final ANTLRInputStream antlrInputStream = new ANTLRInputStream(sourceText);
-      final JavascriptErrorHandlingLexer javascriptLexer = new JavascriptErrorHandlingLexer(antlrInputStream);
-      javascriptLexer.removeErrorListeners();
-      final JavascriptParser javascriptParser = new JavascriptParser(new CommonTokenStream(javascriptLexer));
-      javascriptParser.removeErrorListeners();
-      javascriptParser.setErrorHandler(new JavascriptParserErrorStrategy());
-      return javascriptParser.compile();
-    } catch (RuntimeException re) {
-      if (re.getCause() instanceof ParseException) {
-        throw (ParseException)re.getCause();
-      }
-      throw re;
-    }
+    final ANTLRInputStream antlrInputStream = new ANTLRInputStream(sourceText);
+    final JavascriptErrorHandlingLexer javascriptLexer = new JavascriptErrorHandlingLexer(antlrInputStream);
+    javascriptLexer.removeErrorListeners();
+    final JavascriptParser javascriptParser = new JavascriptParser(new CommonTokenStream(javascriptLexer));
+    javascriptParser.removeErrorListeners();
+    javascriptParser.setErrorHandler(new JavascriptParserErrorStrategy());
+    return javascriptParser.compile();
   }
 
   /**
@@ -291,51 +289,56 @@ public final class JavascriptCompiler {
         boolean parens = ctx.LP() != null && ctx.RP() != null;
         Method method = parens ? functions.get(text) : null;
 
-        if (method != null) {
-          int arity = method.getParameterTypes().length;
-
-          if (arguments != arity) {
-            throwChecked(new ParseException(
-                "Invalid expression '" + sourceText + "': Expected (" + 
-                arity + ") arguments for function call (" + text + "), but found (" + arguments + ").", 
-                ctx.start.getStartIndex()));
-          }
-
-          typeStack.push(Type.DOUBLE_TYPE);
-
-          for (int argument = 0; argument < arguments; ++argument) {
-            visit(ctx.expression(argument));
-          }
-
-          typeStack.pop();
-
-          gen.invokeStatic(Type.getType(method.getDeclaringClass()),
-              org.objectweb.asm.commons.Method.getMethod(method));
-
-          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());
-        } else if (!parens || arguments == 0 && text.contains(".")) {
-          int index;
-
-          text = normalizeQuotes(ctx.getText());
-
-          if (externalsMap.containsKey(text)) {
-            index = externalsMap.get(text);
+        try {
+          if (method != null) {
+            int arity = method.getParameterTypes().length;
+  
+            if (arguments != arity) {
+              throw new ParseException(
+                  "Invalid expression '" + sourceText + "': Expected (" + 
+                  arity + ") arguments for function call (" + text + "), but found (" + arguments + ").", 
+                  ctx.start.getStartIndex());
+            }
+  
+            typeStack.push(Type.DOUBLE_TYPE);
+  
+            for (int argument = 0; argument < arguments; ++argument) {
+              visit(ctx.expression(argument));
+            }
+  
+            typeStack.pop();
+  
+            gen.invokeStatic(Type.getType(method.getDeclaringClass()),
+                org.objectweb.asm.commons.Method.getMethod(method));
+  
+            gen.cast(Type.DOUBLE_TYPE, typeStack.peek());
+          } else if (!parens || arguments == 0 && text.contains(".")) {
+            int index;
+  
+            text = normalizeQuotes(ctx.getText());
+  
+            if (externalsMap.containsKey(text)) {
+              index = externalsMap.get(text);
+            } else {
+              index = externalsMap.size();
+              externalsMap.put(text, index);
+            }
+  
+            gen.loadArg(0);
+            gen.push(index);
+            gen.arrayLoad(FUNCTION_VALUES_TYPE);
+            gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);
+            gen.cast(Type.DOUBLE_TYPE, typeStack.peek());
           } else {
-            index = externalsMap.size();
-            externalsMap.put(text, index);
+            throw new ParseException("Invalid expression '" + sourceText + "': Unrecognized function call (" +
+                text + ").", ctx.start.getStartIndex());
           }
-
-          gen.loadArg(0);
-          gen.push(index);
-          gen.arrayLoad(FUNCTION_VALUES_TYPE);
-          gen.invokeVirtual(FUNCTION_VALUES_TYPE, DOUBLE_VAL_METHOD);
-          gen.cast(Type.DOUBLE_TYPE, typeStack.peek());
-        } else {
-          throwChecked(new ParseException("Invalid expression '" + sourceText + "': Unrecognized function call (" +
-              text + ").", ctx.start.getStartIndex()));
+          return null;
+        } catch (ParseException e) {
+          // The API doesn't allow checked exceptions here, so propagate up the stack. This is unwrapped
+          // in getAntlrParseTree. 
+          throw new RuntimeException(e);
         }
-
-        return null;
       }
 
       @Override
@@ -623,16 +626,6 @@ public final class JavascriptCompiler {
             throw new IllegalStateException("Invalid expected type: " + typeStack.peek());
         }
       }
-      
-      /** Needed to throw checked ParseException in this visitor (that does not allow it). */
-      private void throwChecked(Throwable t) {
-        this.<Error>throwChecked0(t);
-      }
-      
-      @SuppressWarnings("unchecked")
-      private <T extends Throwable> void throwChecked0(Throwable t) throws T {
-        throw (T) t;
-      }
     }.visit(parseTree);
     
     gen.returnValue();
