Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTreeFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTreeFactory.java	(revision 1673328)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/SpatialPrefixTreeFactory.java	(revision )
@@ -52,6 +52,8 @@
       instance = new GeohashPrefixTree.Factory();
     else if ("quad".equalsIgnoreCase(cname))
       instance = new QuadPrefixTree.Factory();
+    else if ("packedQuad".equalsIgnoreCase(cname))
+      instance = new PackedQuadPrefixTree.Factory();
     else {
       try {
         Class<?> c = classLoader.loadClass(cname);
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/StreamingPrefixTreeStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/StreamingPrefixTreeStrategy.java	(revision )
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/StreamingPrefixTreeStrategy.java	(revision )
@@ -0,0 +1,120 @@
+package org.apache.lucene.spatial.prefix;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.Shape;
+import com.spatial4j.core.shape.SpatialRelation;
+import org.apache.lucene.spatial.prefix.tree.Cell;
+import org.apache.lucene.spatial.prefix.tree.PackedQuadPrefixTree.PackedQuadCell;
+import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
+
+/**
+ * Subclassing RecursivePrefixTreeStrategy only for filter code reuse, the StreamingPrefixTreeStrategy improves memory
+ * consumption in the following 2 ways:
+ *   1. Changes the cell encoding from a wasteful string to a compact bit encoding using 8 bytes in the following
+ *      representation:
+ *
+ *       CCCCCCCC...DDDDDL  where: C = Cell bits, D = Depth bits, L = leaf bit
+ *
+ *   2. Eliminates the intermediate ArrayList.Iterator and traverses the tree in hasNext() using bit manipulation of the
+ *     above encoding scheme
+ *
+ *  Caveats: this strategy is only compatible with PackedQuadPrefixTree (progress not perfection)
+ */
+public class StreamingPrefixTreeStrategy extends RecursivePrefixTreeStrategy {
+
+  public StreamingPrefixTreeStrategy(SpatialPrefixTree grid, String fieldName) {
+    super(grid, fieldName);
+  }
+
+  @Override
+  protected Iterator<Cell> createCellIteratorToIndex(Shape shape, int detailLevel, Iterator<Cell> reuse) {
+    return new PrefixTreeIterator(shape);
+  }
+
+  protected class PrefixTreeIterator implements Iterator<Cell> {
+    private Shape shape;
+    private Cell current;
+    private Cell next;
+
+    PrefixTreeIterator(Shape shape) {
+      super();
+      this.shape = shape;
+      this.current = ((PackedQuadCell)(grid.getWorldCell())).nextCell(true);
+      this.next = null;
+    }
+
+    @Override
+    public boolean hasNext() {
+      if (next != null) {
+        return true;
+      }
+      SpatialRelation rel;
+      // loop until we're at the end of the quad tree or we hit a relation
+      while (current != null) {
+        rel = current.getShape().relate(shape);
+        if (rel == SpatialRelation.DISJOINT) {
+          current = ((PackedQuadCell) current).nextCell(false);
+        } else if (rel == SpatialRelation.INTERSECTS || rel == SpatialRelation.CONTAINS) {
+          current.setShapeRel(rel);
+          next = current;
+          if (current.getLevel() == grid.getMaxLevels()) {
+            current.setLeaf();
+            if (shape instanceof Point) {
+              current.setShapeRel(SpatialRelation.WITHIN);
+              current = null;
+              break;
+            }
+          }
+          current = ((PackedQuadCell) current).nextCell(true);
+          break;
+        } else if (rel == SpatialRelation.WITHIN ) {
+          current.setLeaf();
+          current.setShapeRel(rel);
+          next = current;
+          current = ((PackedQuadCell) current).nextCell(false);
+          break;
+        }
+      }
+      return next != null;
+    }
+
+    @Override
+    public Cell next() {
+      if (next == null) {
+        if (!hasNext()) {
+          throw new NoSuchElementException();
+        }
+      }
+      Cell temp = next;
+      next = null;
+      return temp;
+    }
+
+    @Override
+    public void remove() {
+      //no-op
+    }
+  }
+
+
+}
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/QuadPrefixTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/QuadPrefixTree.java	(revision 1673328)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/QuadPrefixTree.java	(revision )
@@ -62,14 +62,14 @@
   public static final int MAX_LEVELS_POSSIBLE = 50;//not really sure how big this should be
 
   public static final int DEFAULT_MAX_LEVELS = 12;
-  private final double xmin;
-  private final double xmax;
-  private final double ymin;
-  private final double ymax;
-  private final double xmid;
-  private final double ymid;
+  protected final double xmin;
+  protected final double xmax;
+  protected final double ymin;
+  protected final double ymax;
+  protected final double xmid;
+  protected final double ymid;
 
-  private final double gridW;
+  protected final double gridW;
   public final double gridH;
 
   final double[] levelW;
@@ -178,7 +178,7 @@
     // if we actually use the range property in the query, this could be useful
   }
 
-  private void checkBattenberg(
+  protected void checkBattenberg(
       char c,
       double cx,
       double cy,
@@ -215,7 +215,7 @@
     str.length = strlen;
   }
 
-  private class QuadCell extends LegacyCell {
+  protected class QuadCell extends LegacyCell {
 
     QuadCell(byte[] bytes, int off, int len) {
       super(bytes, off, len);
@@ -244,7 +244,7 @@
       return cells;
     }
 
-    private BytesRef concat(BytesRef source, byte b) {
+    protected BytesRef concat(BytesRef source, byte b) {
       //+2 for new char + potential leaf
       final byte[] buffer = Arrays.copyOfRange(source.bytes, source.offset, source.offset + source.length + 2);
       BytesRef target = new BytesRef(buffer);
@@ -270,7 +270,7 @@
       return shape;
     }
 
-    private Rectangle makeShape() {
+    protected Rectangle makeShape() {
       BytesRef token = getTokenBytesNoLeaf(null);
       double xmin = QuadPrefixTree.this.xmin;
       double ymin = QuadPrefixTree.this.ymin;
Index: lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SpatialDocMaker.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SpatialDocMaker.java	(revision 1673328)
+++ lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/SpatialDocMaker.java	(revision )
@@ -33,6 +33,8 @@
 import org.apache.lucene.spatial.SpatialStrategy;
 import org.apache.lucene.spatial.composite.CompositeSpatialStrategy;
 import org.apache.lucene.spatial.prefix.RecursivePrefixTreeStrategy;
+import org.apache.lucene.spatial.prefix.StreamingPrefixTreeStrategy;
+import org.apache.lucene.spatial.prefix.tree.PackedQuadPrefixTree;
 import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
 import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTreeFactory;
 import org.apache.lucene.spatial.serialized.SerializedDVStrategy;
@@ -109,7 +111,13 @@
     //A factory for the prefix tree grid
     SpatialPrefixTree grid = SpatialPrefixTreeFactory.makeSPT(configMap, null, ctx);
 
-    RecursivePrefixTreeStrategy strategy = new RecursivePrefixTreeStrategy(grid, spatialField);
+    RecursivePrefixTreeStrategy strategy;
+    if (grid instanceof PackedQuadPrefixTree) {
+      strategy = new StreamingPrefixTreeStrategy(grid, spatialField);
+    } else {
+      strategy = new RecursivePrefixTreeStrategy(grid, spatialField);
+    }
+
     strategy.setPointsOnly(config.get("spatial.docPointsOnly", false));
     strategy.setPruneLeafyBranches(config.get("spatial.pruneLeafyBranches", true));
 
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree.java	(revision )
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree.java	(revision )
@@ -0,0 +1,335 @@
+package org.apache.lucene.spatial.prefix.tree;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.Rectangle;
+import com.spatial4j.core.shape.Shape;
+import com.spatial4j.core.shape.SpatialRelation;
+import com.spatial4j.core.shape.impl.RectangleImpl;
+import org.apache.lucene.util.BytesRef;
+
+/**
+ * Subclassing QuadPrefixTree this {@link SpatialPrefixTree} uses the compact QuadCell encoding described in
+ * {@link org.apache.lucene.spatial.prefix.StreamingPrefixTreeStrategy}
+ */
+public class PackedQuadPrefixTree extends QuadPrefixTree {
+  public static final byte[] QUAD = new byte[] {0x00, 0x01, 0x02, 0x03};
+  public static final int MAX_LEVELS_POSSIBLE = 29;
+
+  public static class Factory extends QuadPrefixTree.Factory {
+    @Override
+    protected SpatialPrefixTree newSPT() {
+      if (maxLevels > MAX_LEVELS_POSSIBLE) {
+        throw new IllegalArgumentException("maxLevels");//nocommit
+      }
+      return new PackedQuadPrefixTree(ctx, maxLevels);
+    }
+  }
+
+  public PackedQuadPrefixTree(SpatialContext ctx, int maxLevels) {
+    super(ctx, maxLevels);
+  }
+
+  @Override
+  public Cell getWorldCell() {
+    return new PackedQuadCell(0x0L);
+  }
+  @Override
+  public Cell getCell(Point p, int level) {
+    List<Cell> cells = new ArrayList<>(1);
+    build(xmid, ymid, 0, cells, 0x0L, ctx.makePoint(p.getX(),p.getY()), level);
+    return cells.get(0);//note cells could be longer if p on edge
+  }
+
+  protected void build(double x, double y, int level, List<Cell> matches, long term, Shape shape, int maxLevel) {
+    double w = levelW[level] / 2;
+    double h = levelH[level] / 2;
+
+    // Z-Order
+    // http://en.wikipedia.org/wiki/Z-order_%28curve%29
+    checkBattenberg(QUAD[0], x - w, y + h, level, matches, term, shape, maxLevel);
+    checkBattenberg(QUAD[1], x + w, y + h, level, matches, term, shape, maxLevel);
+    checkBattenberg(QUAD[2], x - w, y - h, level, matches, term, shape, maxLevel);
+    checkBattenberg(QUAD[3], x + w, y - h, level, matches, term, shape, maxLevel);
+  }
+
+  protected void checkBattenberg(byte quad, double cx, double cy, int level, List<Cell> matches,
+                               long term, Shape shape, int maxLevel) {
+    // short-circuit if we find a match for the point (no need to continue recursion)
+    if (shape instanceof Point && !matches.isEmpty())
+      return;
+    double w = levelW[level] / 2;
+    double h = levelH[level] / 2;
+
+    SpatialRelation v = shape.relate(ctx.makeRectangle(cx - w, cx + w, cy - h, cy + h));
+
+    if (SpatialRelation.DISJOINT == v) {
+      return;
+    }
+
+    // set bits for next level
+    term |= (((long)(quad))<<(64-(++level<<1)));
+    // increment level
+    term = ((term>>>1)+1)<<1;
+
+    if (SpatialRelation.CONTAINS == v || (level >= maxLevel)) {
+      matches.add(new PackedQuadCell(term, v.transpose()));
+    } else {// SpatialRelation.WITHIN, SpatialRelation.INTERSECTS
+      build(cx, cy, level, matches, term, shape, maxLevel);
+    }
+  }
+
+  @Override
+  public Cell readCell(BytesRef term, Cell scratch) {
+    PackedQuadCell cell = (PackedQuadCell) scratch;
+    if (cell == null)
+      cell = (PackedQuadCell) getWorldCell();
+    cell.readCell(term);
+    return cell;
+  }
+
+  /**
+   * PackedQuadCell Binary Representation is as follows
+   * CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDL
+   *
+   * Where C = Cell bits (2 per quad)
+   *       D = Depth bits (5 with max of 29 levels)
+   *       L = isLeaf bit
+   */
+  public class PackedQuadCell extends QuadCell {
+    private long term;
+
+    PackedQuadCell(long term) {
+      super(null, 0, 0);
+      this.term = term;
+      this.b_off = 0;
+      this.bytes = longToByteArray(this.term);
+      this.b_len = 8;
+      readLeafAdjust();
+    }
+
+    PackedQuadCell(long term, SpatialRelation shapeRel) {
+      this(term);
+      this.shapeRel = shapeRel;
+    }
+
+    @Override
+    protected void readCell(BytesRef bytes) {
+      shapeRel = null;
+      shape = null;
+      this.bytes = bytes.bytes;
+      this.b_off = bytes.offset;
+      this.b_len = (short) bytes.length;
+      this.term = longFromByteArray(this.bytes, bytes.offset);
+      readLeafAdjust();
+    }
+
+    private final int getShiftForLevel(final int level) {
+      return 64 - (level<<1);
+    }
+
+    public boolean isEnd(final int level, final int shift) {
+      return (term != 0x0L && ((((0x1L<<(level<<1))-1)-(term>>>shift)) == 0x0L));
+    }
+
+    /**
+     * Get the next cell in the tree without using recursion. descend parameter requests traversal to the child nodes,
+     * setting this to false will step to the next sibling.
+     * Note: This complies with lexicographical ordering, once you've moved to the next sibling there is no backtracking.
+     */
+    public Cell nextCell(boolean descend) {
+      final int level = getLevel();
+      final int shift = getShiftForLevel(level);
+      // base case: can't go further
+      if ( (!descend && isEnd(level, shift)) || isEnd(maxLevels, getShiftForLevel(maxLevels))) {
+        return null;
+      }
+      long newTerm;
+      final boolean isLeaf = (term&0x1L)==0x1L;
+      // if descend requested && we're not at the maxLevel
+      if ((descend && !isLeaf && (level != maxLevels)) || level == 0) {
+        // simple case: increment level bits (next level)
+        newTerm = ((term>>>1)+0x1L)<<1;
+      } else {  // we're not descending or we can't descend
+        newTerm = term + (0x1L<<shift);
+        // we're at the last sibling...force descend
+        if (((term>>>shift)&0x3L) == 0x3L) {
+          // adjust level for number popping up
+          newTerm = ((newTerm>>>1) - (Long.numberOfTrailingZeros(newTerm>>>shift)>>>1))<<1;
+        }
+      }
+      return new PackedQuadCell(newTerm);
+    }
+
+    @Override
+    protected void readLeafAdjust() {
+      isLeaf = ((0x1L)&term) == 0x1L;
+      if (getLevel() == getMaxLevels()) {
+        isLeaf = true;
+      }
+    }
+
+    @Override
+    public BytesRef getTokenBytesWithLeaf(BytesRef result) {
+      if (isLeaf) {
+        term |= 0x1L;
+      }
+      return getTokenBytesNoLeaf(result);
+    }
+
+    @Override
+    public BytesRef getTokenBytesNoLeaf(BytesRef result) {
+      if (result == null)
+        return new BytesRef(bytes, b_off, b_len);
+      result.bytes = longToByteArray(this.term);
+      result.offset = 0;
+      result.length = result.bytes.length;
+      return result;
+    }
+
+    @Override
+    public int compareToNoLeaf(Cell fromCell) {
+      PackedQuadCell b = (PackedQuadCell) fromCell;
+      final long thisTerm = (((0x1L)&term) == 0x1L) ? term-1 : term;
+      final long fromTerm = (((0x1L)&b.term) == 0x1L) ? b.term-1 : b.term;
+      final int result = compare(longToByteArray(thisTerm), b_off, b_len, longToByteArray(fromTerm), b.b_off, b.b_len);
+      return result;
+    }
+
+    @Override
+    public int getLevel() {
+      int l = (int)((term >>> 1)&0x1FL);
+      return l;
+    }
+
+    @Override
+    protected Collection<Cell> getSubCells() {
+      List<Cell> cells = new ArrayList<>(4);
+      PackedQuadCell pqc = (PackedQuadCell)(this.nextCell(true));
+      cells.add(pqc);
+      cells.add((pqc = (PackedQuadCell)(pqc.nextCell(false))));
+      cells.add((pqc = (PackedQuadCell)(pqc.nextCell(false))));
+      cells.add(pqc.nextCell(false));
+      return cells;
+    }
+
+    @Override
+    protected QuadCell getSubCell(Point p) {
+      return (PackedQuadCell) PackedQuadPrefixTree.this.getCell(p, getLevel() + 1);//not performant!
+    }
+
+    @Override
+    public boolean isPrefixOf(Cell c) {
+      PackedQuadCell cell = (PackedQuadCell)c;
+      return (this.term==0x0L) ? true : isInternalPrefix(cell);
+    }
+
+    protected boolean isInternalPrefix(PackedQuadCell c) {
+      final int shift = 64 - (getLevel()<<1);
+      return ((term>>>shift)-(c.term>>>shift)) == 0x0L;
+    }
+
+    protected long concat(byte postfix) {
+      // extra leaf bit
+      return this.term | (((long)(postfix))<<((getMaxLevels()-getLevel()<<1)+6));
+    }
+
+    /**
+     * Constructs a bounding box shape out of the encoded cell
+     */
+    @Override
+    protected Rectangle makeShape() {
+      double xmin = PackedQuadPrefixTree.this.xmin;
+      double ymin = PackedQuadPrefixTree.this.ymin;
+      int level = getLevel();
+
+      byte b;
+      for (short l=0, i=1; l<level; ++l, ++i) {
+        b = (byte) ((term>>>(64-(i<<1))) & 0x3L);
+
+        switch (b) {
+          case 0x00:
+            ymin += levelH[l];
+            break;
+          case 0x01:
+            xmin += levelW[l];
+            ymin += levelH[l];
+            break;
+          case 0x02:
+            break;//nothing really
+          case 0x03:
+            xmin += levelW[l];
+            break;
+          default:
+            throw new RuntimeException("unexpected quadrant");
+        }
+      }
+
+      double width, height;
+      if (level > 0) {
+        width = levelW[level - 1];
+        height = levelH[level - 1];
+      } else {
+        width = gridW;
+        height = gridH;
+      }
+      return new RectangleImpl(xmin, xmin + width, ymin, ymin + height, ctx);
+    }
+
+    private long fromBytes(byte b1, byte b2, byte b3, byte b4, byte b5, byte b6, byte b7, byte b8) {
+      return ((long)b1 & 255L) << 56 | ((long)b2 & 255L) << 48 | ((long)b3 & 255L) << 40
+          | ((long)b4 & 255L) << 32 | ((long)b5 & 255L) << 24 | ((long)b6 & 255L) << 16
+          | ((long)b7 & 255L) << 8 | (long)b8 & 255L;
+    }
+
+    private byte[] longToByteArray(long value) {
+      byte[] result = new byte[8];
+      for(int i = 7; i >= 0; --i) {
+        result[i] = (byte)((int)(value & 255L));
+        value >>= 8;
+      }
+      return result;
+    }
+
+    private long longFromByteArray(byte[] bytes, int ofs) {
+      assert bytes.length >= 8;
+      return fromBytes(bytes[0+ofs], bytes[1+ofs], bytes[2+ofs], bytes[3+ofs],
+          bytes[4+ofs], bytes[5+ofs], bytes[6+ofs], bytes[7+ofs]);
+    }
+
+    /**
+     * Used for debugging, this will print the bits of the cell
+     */
+    @Override
+    public String toString() {
+      String s = "";
+      for(int i = 0; i < Long.numberOfLeadingZeros(term); i++) {
+        s+='0';
+      }
+      if (term != 0)
+        s += Long.toBinaryString(term);
+      return s;
+    }
+  } // PackedQuadCell
+}
Index: lucene/spatial/src/test/org/apache/lucene/spatial/prefix/RandomSpatialOpFuzzyPrefixTreeTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/prefix/RandomSpatialOpFuzzyPrefixTreeTest.java	(revision 1673328)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/prefix/RandomSpatialOpFuzzyPrefixTreeTest.java	(revision )
@@ -47,6 +47,7 @@
 import org.apache.lucene.spatial.prefix.tree.Cell;
 import org.apache.lucene.spatial.prefix.tree.CellIterator;
 import org.apache.lucene.spatial.prefix.tree.GeohashPrefixTree;
+import org.apache.lucene.spatial.prefix.tree.PackedQuadPrefixTree;
 import org.apache.lucene.spatial.prefix.tree.QuadPrefixTree;
 import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
 import org.apache.lucene.spatial.query.SpatialArgs;
@@ -72,7 +73,7 @@
 
   public void setupGrid(int maxLevels) throws IOException {
     if (randomBoolean())
-      setupQuadGrid(maxLevels);
+      setupQuadGrid(maxLevels, randomBoolean());
     else
       setupGeohashGrid(maxLevels);
     setupCtx2D(ctx);
@@ -97,7 +98,7 @@
     ctx2D = ctxFactory.newSpatialContext();
   }
 
-  private void setupQuadGrid(int maxLevels) {
+  private void setupQuadGrid(int maxLevels, boolean streamingQuadTree) {
     //non-geospatial makes this test a little easier (in gridSnap), and using boundary values 2^X raises
     // the prospect of edge conditions we want to test, plus makes for simpler numbers (no decimals).
     SpatialContextFactory factory = new SpatialContextFactory();
@@ -107,9 +108,14 @@
     //A fairly shallow grid, and default 2.5% distErrPct
     if (maxLevels == -1)
       maxLevels = randomIntBetween(1, 8);//max 64k cells (4^8), also 256*256
+    if (streamingQuadTree) {
+      this.grid = new PackedQuadPrefixTree(ctx, maxLevels);
+      this.strategy = newSPT();
+    } else {
-    this.grid = new QuadPrefixTree(ctx, maxLevels);
-    this.strategy = newRPT();
-  }
+      this.grid = new QuadPrefixTree(ctx, maxLevels);
+      this.strategy = newRPT();
+    }
+  }
 
   public void setupGeohashGrid(int maxLevels) {
     this.ctx = SpatialContext.GEO;
@@ -124,6 +130,10 @@
     return new RecursivePrefixTreeStrategy(this.grid, getClass().getSimpleName());
   }
 
+  protected StreamingPrefixTreeStrategy newSPT() {
+    return new StreamingPrefixTreeStrategy(this.grid, getClass().getSimpleName());
+  }
+
   @Test
   @Repeat(iterations = ITERATIONS)
   public void testIntersects() throws IOException {
@@ -148,7 +158,7 @@
   /** See LUCENE-5062, {@link ContainsPrefixTreeFilter#multiOverlappingIndexedShapes}. */
   @Test
   public void testContainsPairOverlap() throws IOException {
-    setupQuadGrid(3);
+    setupQuadGrid(3, randomBoolean());
     adoc("0", new ShapePair(ctx.makeRectangle(0, 33, -128, 128), ctx.makeRectangle(33, 128, -128, 128), true));
     commit();
     Query query = strategy.makeQuery(new SpatialArgs(SpatialOperation.Contains,
@@ -159,7 +169,7 @@
 
   @Test
   public void testWithinDisjointParts() throws IOException {
-    setupQuadGrid(7);
+    setupQuadGrid(7, randomBoolean());
     //one shape comprised of two parts, quite separated apart
     adoc("0", new ShapePair(ctx.makeRectangle(0, 10, -120, -100), ctx.makeRectangle(220, 240, 110, 125), false));
     commit();
@@ -173,7 +183,7 @@
 
   @Test /** LUCENE-4916 */
   public void testWithinLeafApproxRule() throws IOException {
-    setupQuadGrid(2);//4x4 grid
+    setupQuadGrid(2, randomBoolean());//4x4 grid
     //indexed shape will simplify to entire right half (2 top cells)
     adoc("0", ctx.makeRectangle(192, 204, -128, 128));
     commit();
@@ -522,5 +532,4 @@
       return "ShapePair(" + shape1 + " , " + shape2 + ")";
     }
   }
-
 }
Index: lucene/benchmark/conf/spatial.alg
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/benchmark/conf/spatial.alg	(revision 1673328)
+++ lucene/benchmark/conf/spatial.alg	(revision )
@@ -33,12 +33,12 @@
 #spatial.prefixTree=geohash  (or quad)
 spatial.prefixTree=quad
 #27 quad or 11 geohash are very close
-spatial.maxLevels=27
+spatial.maxLevels=20
 #spatial.maxDistErr (in degrees) to compute maxLevels -- defaults to 1 meter's worth
 #  RecursivePrefixTreeStrategy:
 #spatial.docPointsOnly=true
-#spatial.distErrPct=0.025
-#spatial.pruneLeafyBranches=true
+spatial.distErrPct=0.0
+spatial.pruneLeafyBranches=false
 
 #codec.postingsFormat=Memory or (Direct)
 
@@ -48,8 +48,8 @@
 docs.file=work/geonames/allCountries.txt
 doc.tokenized=false
 #  Next 3 props convert doc points to circles with a random radius and then optionally bbox'es
-#doc.spatial.radiusDegrees=0.0
-#doc.spatial.radiusDegreesRandPlusMinus=0.0
+doc.spatial.radiusDegrees=0.0
+doc.spatial.radiusDegreesRandPlusMinus=3.0
 #doc.spatial.bbox=false
 
 ### Directory
@@ -79,7 +79,7 @@
 
 ### Misc
 
-log.step.AddDoc = 100000
+log.step.AddDoc = 100
 task.max.depth.log=1
 
 # -------------------------------------------------------------------------------------
@@ -88,7 +88,7 @@
   ResetSystemErase
   CreateIndex
   #1 million docs
-  [{ "MAddDocs" AddDoc} : 250000] : 4
+  [{ "MAddDocs" AddDoc} : 1000] : 1
   ForceMerge(1)
   CommitIndex
   CloseIndex
@@ -110,7 +110,7 @@
   CloseReader
   
   NewRound
-} : 1
+} : 0
 
 
 #RepSumByName
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/LegacyCell.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/LegacyCell.java	(revision 1673328)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/tree/LegacyCell.java	(revision )
@@ -36,9 +36,9 @@
   private static final byte LEAF_BYTE = '+';//NOTE: must sort before letters & numbers
 
   //Arguably we could simply use a BytesRef, using an extra Object.
-  private byte[] bytes;//generally bigger to potentially hold a leaf
-  private int b_off;
-  private int b_len;//doesn't reflect leaf; same as getLevel()
+  protected byte[] bytes;//generally bigger to potentially hold a leaf
+  protected int b_off;
+  protected int b_len;//doesn't reflect leaf; same as getLevel()
 
   protected boolean isLeaf;
 
@@ -68,7 +68,7 @@
     readLeafAdjust();
   }
 
-  private void readLeafAdjust() {
+  protected void readLeafAdjust() {
     isLeaf = (b_len > 0 && bytes[b_off + b_len - 1] == LEAF_BYTE);
     if (isLeaf)
       b_len--;
@@ -76,18 +76,6 @@
       isLeaf = true;
   }
 
-//  @Override
-//  public void copyFrom(Cell source) {
-//    LegacyCell src = (LegacyCell) source;
-//    shapeRel = src.shapeRel;
-//    shape = src.shape;
-//    isLeaf = src.isLeaf;
-//    //we don't actually copy the bytes because in LegacyCell the bytes aren't modified. (leaf byte doesn't count)
-//    bytes = src.bytes;
-//    b_off = src.b_off;
-//    b_len = src.b_len;
-//  }
-
   protected abstract SpatialPrefixTree getGrid();
 
   protected abstract int getMaxLevels();
@@ -214,7 +202,7 @@
 
   /** Copied from {@link BytesRef#compareTo(BytesRef)}.
    * This is to avoid creating a BytesRef. */
-  private static int compare(byte[] aBytes, int aUpto, int a_length, byte[] bBytes, int bUpto, int b_length) {
+  protected static int compare(byte[] aBytes, int aUpto, int a_length, byte[] bBytes, int bUpto, int b_length) {
     final int aStop = aUpto + Math.min(a_length, b_length);
     while(aUpto < aStop) {
       int aByte = aBytes[aUpto++] & 0xff;
Index: lucene/spatial/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java	(revision 1673328)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java	(revision )
@@ -26,8 +26,10 @@
 import org.apache.lucene.index.IndexOptions;
 import org.apache.lucene.spatial.bbox.BBoxStrategy;
 import org.apache.lucene.spatial.prefix.RecursivePrefixTreeStrategy;
+import org.apache.lucene.spatial.prefix.StreamingPrefixTreeStrategy;
 import org.apache.lucene.spatial.prefix.TermQueryPrefixTreeStrategy;
 import org.apache.lucene.spatial.prefix.tree.GeohashPrefixTree;
+import org.apache.lucene.spatial.prefix.tree.PackedQuadPrefixTree;
 import org.apache.lucene.spatial.prefix.tree.QuadPrefixTree;
 import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
 import org.apache.lucene.spatial.serialized.SerializedDVStrategy;
@@ -55,6 +57,10 @@
 
     grid = new GeohashPrefixTree(ctx,12);
     strategy = new TermQueryPrefixTreeStrategy(grid, "termquery_geohash");
+    ctorArgs.add(new Object[]{new Param(strategy)});
+
+    grid = new PackedQuadPrefixTree(ctx,25);
+    strategy = new StreamingPrefixTreeStrategy(grid, "streaming_quad");
     ctorArgs.add(new Object[]{new Param(strategy)});
 
     strategy = new PointVectorStrategy(ctx, "pointvector");
