diff --git a/lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java b/lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java
index 52ef59baf5f..a62d5366a28 100644
--- a/lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java
+++ b/lucene/core/src/java/org/apache/lucene/geo/GeoUtils.java
@@ -16,7 +16,6 @@
  */
 package org.apache.lucene.geo;
 
-import static org.apache.lucene.util.SloppyMath.TO_RADIANS;
 import static org.apache.lucene.util.SloppyMath.cos;
 import static org.apache.lucene.util.SloppyMath.haversinMeters;
 
@@ -43,13 +42,13 @@ public final class GeoUtils {
   public static final double MAX_LAT_INCL = 90.0D;
 
   /** min longitude value in radians */
-  public static final double MIN_LON_RADIANS = TO_RADIANS * MIN_LON_INCL;
+  public static final double MIN_LON_RADIANS = Math.toRadians(MIN_LON_INCL);
   /** min latitude value in radians */
-  public static final double MIN_LAT_RADIANS = TO_RADIANS * MIN_LAT_INCL;
+  public static final double MIN_LAT_RADIANS = Math.toRadians(MIN_LAT_INCL);
   /** max longitude value in radians */
-  public static final double MAX_LON_RADIANS = TO_RADIANS * MAX_LON_INCL;
+  public static final double MAX_LON_RADIANS = Math.toRadians(MAX_LON_INCL);
   /** max latitude value in radians */
-  public static final double MAX_LAT_RADIANS = TO_RADIANS * MAX_LAT_INCL;
+  public static final double MAX_LAT_RADIANS = Math.toRadians(MAX_LAT_INCL);
 
   // WGS84 earth-ellipsoid parameters
   /** mean earth axis in meters */
diff --git a/lucene/core/src/java/org/apache/lucene/geo/Rectangle.java b/lucene/core/src/java/org/apache/lucene/geo/Rectangle.java
index 45d437df1bc..ab9c2c38d6e 100644
--- a/lucene/core/src/java/org/apache/lucene/geo/Rectangle.java
+++ b/lucene/core/src/java/org/apache/lucene/geo/Rectangle.java
@@ -29,11 +29,8 @@ import static org.apache.lucene.geo.GeoUtils.MIN_LAT_RADIANS;
 import static org.apache.lucene.geo.GeoUtils.MIN_LON_RADIANS;
 import static org.apache.lucene.geo.GeoUtils.EARTH_MEAN_RADIUS_METERS;
 import static org.apache.lucene.geo.GeoUtils.sloppySin;
-import static org.apache.lucene.util.SloppyMath.TO_DEGREES;
 import static org.apache.lucene.util.SloppyMath.asin;
 import static org.apache.lucene.util.SloppyMath.cos;
-import static org.apache.lucene.util.SloppyMath.toDegrees;
-import static org.apache.lucene.util.SloppyMath.toRadians;
 
 /** Represents a lat/lon rectangle. */
 public class Rectangle {
@@ -98,8 +95,8 @@ public class Rectangle {
   public static Rectangle fromPointDistance(final double centerLat, final double centerLon, final double radiusMeters) {
     checkLatitude(centerLat);
     checkLongitude(centerLon);
-    final double radLat = toRadians(centerLat);
-    final double radLon = toRadians(centerLon);
+    final double radLat = Math.toRadians(centerLat);
+    final double radLon = Math.toRadians(centerLon);
     // LUCENE-7143
     double radDistance = (radiusMeters + 7E-2) / EARTH_MEAN_RADIUS_METERS;
     double minLat = radLat - radDistance;
@@ -125,11 +122,11 @@ public class Rectangle {
       maxLon = MAX_LON_RADIANS;
     }
 
-    return new Rectangle(toDegrees(minLat), toDegrees(maxLat), toDegrees(minLon), toDegrees(maxLon));
+    return new Rectangle(Math.toDegrees(minLat), Math.toDegrees(maxLat), Math.toDegrees(minLon), Math.toDegrees(maxLon));
   }
 
   /** maximum error from {@link #axisLat(double, double)}. logic must be prepared to handle this */
-  public static final double AXISLAT_ERROR = 0.1D / EARTH_MEAN_RADIUS_METERS * TO_DEGREES;
+  public static final double AXISLAT_ERROR = Math.toDegrees(0.1D / EARTH_MEAN_RADIUS_METERS);
 
   /**
    * Calculate the latitude of a circle's intersections with its bbox meridians.
@@ -155,7 +152,7 @@ public class Rectangle {
     // cannot divide by 0, and we will always get a positive value in the range [0, 1) as
     // the argument to arc cosine, resulting in a range (0, PI/2].
     final double PIO2 = Math.PI / 2D;
-    double l1 = toRadians(centerLat);
+    double l1 = Math.toRadians(centerLat);
     double r = (radiusMeters + 7E-2) / EARTH_MEAN_RADIUS_METERS;
 
     // if we are within radius range of a pole, the lat is the pole itself
@@ -173,7 +170,7 @@ public class Rectangle {
     // now adjust back to range [-pi/2, pi/2], ie latitude in radians
     l2 = centerLat >= 0 ? PIO2 - l2 : l2 - PIO2;
 
-    return toDegrees(l2);
+    return Math.toDegrees(l2);
   }
 
   /** Returns the bounding box over an array of polygons */
diff --git a/lucene/core/src/java/org/apache/lucene/util/SloppyMath.java b/lucene/core/src/java/org/apache/lucene/util/SloppyMath.java
index 44f2c3bfd84..0c7e942c848 100644
--- a/lucene/core/src/java/org/apache/lucene/util/SloppyMath.java
+++ b/lucene/core/src/java/org/apache/lucene/util/SloppyMath.java
@@ -85,10 +85,10 @@ public class SloppyMath {
    * effectively does the second half of the computation.
    */
   public static double haversinSortKey(double lat1, double lon1, double lat2, double lon2) {
-    double x1 = lat1 * TO_RADIANS;
-    double x2 = lat2 * TO_RADIANS;
+    double x1 = Math.toRadians(lat1);
+    double x2 = Math.toRadians(lat2);
     double h1 = 1 - cos(x1 - x2);
-    double h2 = 1 - cos((lon1 - lon2) * TO_RADIANS);
+    double h2 = 1 - cos(Math.toRadians(lon1 - lon2));
     double h = h1 + cos(x1) * cos(x2) * h2;
     // clobber crazy precision so subsequent rounding does not create ties.
     return Double.longBitsToDouble(Double.doubleToRawLongBits(h) & 0xFFFFFFFFFFFFFFF8L);
@@ -176,29 +176,6 @@ public class SloppyMath {
     }
   }
 
-  /**
-   * Convert to degrees.
-   * @param radians radians to convert to degrees
-   * @return degrees
-   */
-  public static double toDegrees(final double radians) {
-    return radians * TO_DEGREES;
-  }
-  
-  /**
-   * Convert to radians.
-   * @param degrees degrees to convert to radians
-   * @return radians
-   */
-  public static double toRadians(final double degrees) {
-    return degrees * TO_RADIANS;
-  }
-  
-  // haversin
-  // TODO: remove these for java 9, they fixed Math.toDegrees()/toRadians() to work just like this.
-  public static final double TO_RADIANS = Math.PI / 180D;
-  public static final double TO_DEGREES = 180D / Math.PI;
-
   // Earth's mean radius, in meters and kilometers; see http://earth-info.nga.mil/GandG/publications/tr8350.2/wgs84fin.pdf
   private static final double TO_METERS = 6_371_008.7714D; // equatorial radius
   private static final double TO_KILOMETERS = 6_371.0087714D; // equatorial radius
@@ -227,7 +204,7 @@ public class SloppyMath {
     
   // Supposed to be >= sin(77.2deg), as fdlibm code is supposed to work with values > 0.975,
   // but seems to work well enough as long as value >= sin(25deg).
-  private static final double ASIN_MAX_VALUE_FOR_TABS = StrictMath.sin(toRadians(73.0));
+  private static final double ASIN_MAX_VALUE_FOR_TABS = StrictMath.sin(Math.toRadians(73.0));
   
   private static final int ASIN_TABS_SIZE = (1<<13) + 1;
   private static final double ASIN_DELTA = ASIN_MAX_VALUE_FOR_TABS/(ASIN_TABS_SIZE - 1);
diff --git a/lucene/demo/src/java/org/apache/lucene/demo/facet/DistanceFacetsExample.java b/lucene/demo/src/java/org/apache/lucene/demo/facet/DistanceFacetsExample.java
index 7c033ce4c9a..2b9b485de7b 100644
--- a/lucene/demo/src/java/org/apache/lucene/demo/facet/DistanceFacetsExample.java
+++ b/lucene/demo/src/java/org/apache/lucene/demo/facet/DistanceFacetsExample.java
@@ -50,7 +50,6 @@ import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.store.ByteBuffersDirectory;
 import org.apache.lucene.store.Directory;
-import org.apache.lucene.util.SloppyMath;
 
 /** Shows simple usage of dynamic range faceting, using the
  *  expressions module to calculate distance. */
@@ -149,8 +148,8 @@ public class DistanceFacetsExample implements Closeable {
     // since it's a 2D trie...
 
     // Degrees -> Radians:
-    double originLatRadians = SloppyMath.toRadians(originLat);
-    double originLngRadians = SloppyMath.toRadians(originLng);
+    double originLatRadians = Math.toRadians(originLat);
+    double originLngRadians = Math.toRadians(originLng);
 
     double angle = maxDistanceKM / EARTH_RADIUS_KM;
 
@@ -159,28 +158,28 @@ public class DistanceFacetsExample implements Closeable {
 
     double minLng;
     double maxLng;
-    if (minLat > SloppyMath.toRadians(-90) && maxLat < SloppyMath.toRadians(90)) {
+    if (minLat > Math.toRadians(-90) && maxLat < Math.toRadians(90)) {
       double delta = Math.asin(Math.sin(angle)/Math.cos(originLatRadians));
       minLng = originLngRadians - delta;
-      if (minLng < SloppyMath.toRadians(-180)) {
+      if (minLng < Math.toRadians(-180)) {
         minLng += 2 * Math.PI;
       }
       maxLng = originLngRadians + delta;
-      if (maxLng > SloppyMath.toRadians(180)) {
+      if (maxLng > Math.toRadians(180)) {
         maxLng -= 2 * Math.PI;
       }
     } else {
       // The query includes a pole!
-      minLat = Math.max(minLat, SloppyMath.toRadians(-90));
-      maxLat = Math.min(maxLat, SloppyMath.toRadians(90));
-      minLng = SloppyMath.toRadians(-180);
-      maxLng = SloppyMath.toRadians(180);
+      minLat = Math.max(minLat, Math.toRadians(-90));
+      maxLat = Math.min(maxLat, Math.toRadians(90));
+      minLng = Math.toRadians(-180);
+      maxLng = Math.toRadians(180);
     }
 
     BooleanQuery.Builder f = new BooleanQuery.Builder();
 
     // Add latitude range filter:
-    f.add(DoublePoint.newRangeQuery("latitude", SloppyMath.toDegrees(minLat), SloppyMath.toDegrees(maxLat)),
+    f.add(DoublePoint.newRangeQuery("latitude", Math.toDegrees(minLat), Math.toDegrees(maxLat)),
           BooleanClause.Occur.FILTER);
 
     // Add longitude range filter:
@@ -188,13 +187,13 @@ public class DistanceFacetsExample implements Closeable {
       // The bounding box crosses the international date
       // line:
       BooleanQuery.Builder lonF = new BooleanQuery.Builder();
-      lonF.add(DoublePoint.newRangeQuery("longitude", SloppyMath.toDegrees(minLng), Double.POSITIVE_INFINITY),
+      lonF.add(DoublePoint.newRangeQuery("longitude", Math.toDegrees(minLng), Double.POSITIVE_INFINITY),
                BooleanClause.Occur.SHOULD);
-      lonF.add(DoublePoint.newRangeQuery("longitude", Double.NEGATIVE_INFINITY, SloppyMath.toDegrees(maxLng)),
+      lonF.add(DoublePoint.newRangeQuery("longitude", Double.NEGATIVE_INFINITY, Math.toDegrees(maxLng)),
                BooleanClause.Occur.SHOULD);
       f.add(lonF.build(), BooleanClause.Occur.MUST);
     } else {
-      f.add(DoublePoint.newRangeQuery("longitude", SloppyMath.toDegrees(minLng), SloppyMath.toDegrees(maxLng)),
+      f.add(DoublePoint.newRangeQuery("longitude", Math.toDegrees(minLng), Math.toDegrees(maxLng)),
             BooleanClause.Occur.FILTER);
     }
 
diff --git a/lucene/sandbox/src/test/org/apache/lucene/geo/ShapeTestUtil.java b/lucene/sandbox/src/test/org/apache/lucene/geo/ShapeTestUtil.java
index f7e304bc520..097bb109c57 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/geo/ShapeTestUtil.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/geo/ShapeTestUtil.java
@@ -21,7 +21,6 @@ import java.util.Random;
 
 import com.carrotsearch.randomizedtesting.RandomizedContext;
 import com.carrotsearch.randomizedtesting.generators.BiasedNumbers;
-import org.apache.lucene.util.SloppyMath;
 import org.apache.lucene.util.TestUtil;
 
 /** generates random cartesian geometry; heavy reuse of {@link GeoTestUtil} */
@@ -143,8 +142,8 @@ public class ShapeTestUtil {
         len = StrictMath.min(len, StrictMath.min(maxX, maxY));
 
         //System.out.println("    len=" + len);
-        float x = (float)(centerX + len * Math.cos(SloppyMath.toRadians(angle)));
-        float y = (float)(centerY + len * Math.sin(SloppyMath.toRadians(angle)));
+        float x = (float)(centerX + len * Math.cos(Math.toRadians(angle)));
+        float y = (float)(centerY + len * Math.sin(Math.toRadians(angle)));
 
         xList.add(x);
         yList.add(y);
diff --git a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPathTest.java b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPathTest.java
index 05f5f3eac0a..5b52dea4b79 100755
--- a/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPathTest.java
+++ b/lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/GeoPathTest.java
@@ -18,8 +18,6 @@ package org.apache.lucene.spatial3d.geom;
 
 import org.junit.Test;
 
-import static org.apache.lucene.util.SloppyMath.toRadians;
-
 import org.apache.lucene.util.LuceneTestCase;
 
 public class GeoPathTest extends LuceneTestCase {
@@ -264,9 +262,9 @@ public class GeoPathTest extends LuceneTestCase {
   public void testCoLinear() {
     // p1: (12,-90), p2: (11, -55), (129, -90)
     GeoStandardPath p = new GeoStandardPath(PlanetModel.SPHERE, 0.1);
-    p.addPoint(toRadians(-90), toRadians(12));//south pole
-    p.addPoint(toRadians(-55), toRadians(11));
-    p.addPoint(toRadians(-90), toRadians(129));//south pole again
+    p.addPoint(Math.toRadians(-90), Math.toRadians(12));//south pole
+    p.addPoint(Math.toRadians(-55), Math.toRadians(11));
+    p.addPoint(Math.toRadians(-90), Math.toRadians(129));//south pole again
     p.done();//at least test this doesn't bomb like it used too -- LUCENE-6520
   }
 
@@ -313,11 +311,11 @@ public class GeoPathTest extends LuceneTestCase {
     final double[] pathLons = new double[] {13.3634,13.3704,13.3307,13.3076,13.2806,13.2484,13.2406,13.241,13.1926};
 
     // Set up a point in the right way
-    final GeoPoint carPoint = new GeoPoint(PlanetModel.SPHERE, toRadians(lat), toRadians(lon));
+    final GeoPoint carPoint = new GeoPoint(PlanetModel.SPHERE, Math.toRadians(lat), Math.toRadians(lon));
     // Create the path, but use a tiny width (e.g. zero)
     final GeoPoint[] pathPoints = new GeoPoint[pathLats.length];
     for (int i = 0; i < pathPoints.length; i++) {
-      pathPoints[i] = new GeoPoint(PlanetModel.SPHERE, toRadians(pathLats[i]), toRadians(pathLons[i]));
+      pathPoints[i] = new GeoPoint(PlanetModel.SPHERE, Math.toRadians(pathLats[i]), Math.toRadians(pathLons[i]));
     }
     // Construct a path with no width
     final GeoPath thisPath = GeoPathFactory.makeGeoPath(PlanetModel.SPHERE, 0.0, pathPoints);
@@ -347,10 +345,10 @@ public class GeoPathTest extends LuceneTestCase {
     final double[] pathLats = new double[] {52.5355,52.54,52.5626,52.5665,52.6007,52.6135,52.6303,52.6651,52.7074};
     final double[] pathLons = new double[] {13.3634,13.3704,13.3307,13.3076,13.2806,13.2484,13.2406,13.241,13.1926};
 
-    final GeoPoint carPoint = new GeoPoint(PlanetModel.SPHERE, toRadians(lat), toRadians(lon));
+    final GeoPoint carPoint = new GeoPoint(PlanetModel.SPHERE, Math.toRadians(lat), Math.toRadians(lon));
     final GeoPoint[] pathPoints = new GeoPoint[pathLats.length];
     for (int i = 0; i < pathPoints.length; i++) {
-      pathPoints[i] = new GeoPoint(PlanetModel.SPHERE, toRadians(pathLats[i]), toRadians(pathLons[i]));
+      pathPoints[i] = new GeoPoint(PlanetModel.SPHERE, Math.toRadians(pathLats[i]), Math.toRadians(pathLons[i]));
     }
     
     // Construct a path with no width
diff --git a/lucene/test-framework/src/java/org/apache/lucene/geo/EarthDebugger.java b/lucene/test-framework/src/java/org/apache/lucene/geo/EarthDebugger.java
index 59beb398b3e..a5d4f7a5ace 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/geo/EarthDebugger.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/geo/EarthDebugger.java
@@ -207,8 +207,8 @@ public class EarthDebugger {
 
     newAngle:
     while (angle < 360) {
-      double x = Math.cos(SloppyMath.toRadians(angle));
-      double y = Math.sin(SloppyMath.toRadians(angle));
+      double x = Math.cos(Math.toRadians(angle));
+      double y = Math.sin(Math.toRadians(angle));
       double factor = 2.0;
       double step = 1.0;
       int last = 0;
diff --git a/lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil.java b/lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil.java
index aec09789190..243e2f12010 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/geo/GeoTestUtil.java
@@ -327,8 +327,8 @@ public class GeoTestUtil {
     for(int i=0;i<gons;i++) {
       double angle = 360.0-i*(360.0/gons);
       //System.out.println("  angle " + angle);
-      double x = Math.cos(SloppyMath.toRadians(angle));
-      double y = Math.sin(SloppyMath.toRadians(angle));
+      double x = Math.cos(Math.toRadians(angle));
+      double y = Math.sin(Math.toRadians(angle));
       double factor = 2.0;
       double step = 1.0;
       int last = 0;
@@ -494,8 +494,8 @@ public class GeoTestUtil {
         }
         double len = radius * (1.0 - radiusDelta + radiusDelta * random().nextDouble());
         //System.out.println("    len=" + len);
-        double lat = centerLat + len * Math.cos(SloppyMath.toRadians(angle));
-        double lon = centerLon + len * Math.sin(SloppyMath.toRadians(angle));
+        double lat = centerLat + len * Math.cos(Math.toRadians(angle));
+        double lon = centerLon + len * Math.sin(Math.toRadians(angle));
         if (lon <= GeoUtils.MIN_LON_INCL || lon >= GeoUtils.MAX_LON_INCL ||
             lat > 90 || lat < -90) {
           // cannot cross dateline or pole: try again!
diff --git a/lucene/tools/forbiddenApis/lucene.txt b/lucene/tools/forbiddenApis/lucene.txt
index 2a1d88390bf..0cc4edda6bd 100644
--- a/lucene/tools/forbiddenApis/lucene.txt
+++ b/lucene/tools/forbiddenApis/lucene.txt
@@ -24,10 +24,6 @@ java.io.RandomAccessFile
 java.nio.file.Path#toFile()
 java.util.jar.JarFile
 java.util.zip.ZipFile
-@defaultMessage Use home-grown methods instead
-java.lang.Math#toRadians(double)
-java.lang.Math#toDegrees(double)
-
 @defaultMessage Prefer using ArrayUtil as Arrays#copyOfRange fills zeros for bad bounds
 java.util.Arrays#copyOfRange(byte[],int,int)
 java.util.Arrays#copyOfRange(char[],int,int)
