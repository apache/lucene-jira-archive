Index: lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java	(revision 1634505)
+++ lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java	(working copy)
@@ -50,11 +50,13 @@
   
   @Override
   protected void reset() {
+    super.reset();
     scoreSum = scoreMax = 0;
   }
   
   @Override
   protected void accum(Scorer subScorer) throws IOException {
+    super.accum(subScorer);
     float subScore = subScorer.score();
     scoreSum += subScore;
     if (subScore > scoreMax) {
Index: lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java	(revision 1634505)
+++ lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java	(working copy)
@@ -19,97 +19,150 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
 
+import org.apache.lucene.util.PriorityQueue;
+
 /**
  * Base class for Scorers that score disjunctions.
  */
 abstract class DisjunctionScorer extends Scorer {
-  private final Scorer subScorers[];
-  private int numScorers;
 
+  /** A stack over integer elements. */
+  private static class IntStack {
+
+    final int[] array;
+    int size;
+
+    IntStack(int capacity) {
+      array = new int[capacity];
+      size = 0;
+    }
+
+    public boolean isEmpty() {
+      return size == 0;
+    }
+
+    public void push(int i) {
+      array[size++] = i;
+    }
+
+    public int pop() {
+      return array[--size];
+    }
+
+  }
+
+  private static class ScorerPriorityQueue extends PriorityQueue<Scorer> implements Iterable<Scorer> {
+
+    private final IntStack stack;
+
+    ScorerPriorityQueue(Scorer[] scorers) {
+      super(scorers.length);
+      for (Scorer scorer : scorers) {
+        add(scorer);
+      }
+      stack = new IntStack(scorers.length);
+    }
+
+    @Override
+    protected boolean lessThan(Scorer a, Scorer b) {
+      return a.docID() < b.docID();
+    }
+
+    /** push the children of <code>node</code> to <code>stack</code> if they exist. */
+    private static void pushChildren(int node, IntStack stack, int size) {
+      final int left = node << 1;
+      final int right = left + 1;
+      if (right <= size) {
+        stack.push(left);
+        stack.push(right);
+      } else if (left <= size) {
+        stack.push(left);
+      }
+    }
+
+    void visitScorers(DisjunctionScorer disjunction) throws IOException {
+      assert stack.isEmpty();
+      disjunction.reset();
+
+      final Object[] scorers = getHeapArray();
+
+      final Scorer top = top();
+      final int doc = top.docID();
+      disjunction.accum(top);
+
+      final int size = size();
+      assert top == scorers[1];
+      pushChildren(1, stack, size); // 1 is the top node
+
+      while (!stack.isEmpty()) {
+        final int node = stack.pop();
+        final Scorer scorer = (Scorer) scorers[node];
+        if (scorer.docID() == doc) {
+          disjunction.accum(scorer);
+          pushChildren(node, stack, size);
+        }
+      };
+    }
+
+    @Override
+    public Iterator<Scorer> iterator() {
+      final Object[] scorers = getHeapArray();
+      final int size = size();
+      return new Iterator<Scorer>() {
+
+        int i = 1;
+
+        @Override
+        public boolean hasNext() {
+          return i <= size;
+        }
+
+        @Override
+        public Scorer next() {
+          if (!hasNext()) {
+            throw new NoSuchElementException();
+          }
+          return (Scorer) scorers[i++];
+        }
+
+        @Override
+        public void remove() {
+          throw new UnsupportedOperationException();
+        }
+
+      };
+    }
+
+  }
+
+  private final ScorerPriorityQueue subScorers;
+  private Scorer top;
+
   /** The document number of the current match. */
   protected int doc = -1;
   /** Number of matching scorers for the current match. */
   protected int freq = -1;
-  
+
   protected DisjunctionScorer(Weight weight, Scorer subScorers[]) {
     super(weight);
-    this.subScorers = subScorers;
-    this.numScorers = subScorers.length;
-    if (numScorers <= 1) {
+    if (subScorers.length <= 1) {
       throw new IllegalArgumentException("There must be at least 2 subScorers");
     }
-    heapify();
+    this.subScorers = new ScorerPriorityQueue(subScorers);
+    top = this.subScorers.top();
   }
-  
-  /** 
-   * Organize subScorers into a min heap with scorers generating the earliest document on top.
-   */
-  private void heapify() {
-    for (int i = (numScorers >>> 1) - 1; i >= 0; i--) {
-      heapAdjust(i);
-    }
-  }
-  
-  /** 
-   * The subtree of subScorers at root is a min heap except possibly for its root element.
-   * Bubble the root down as required to make the subtree a heap.
-   */
-  private void heapAdjust(int root) {
-    Scorer scorer = subScorers[root];
-    int doc = scorer.docID();
-    int i = root;
-    while (i <= (numScorers >>> 1) - 1) {
-      int lchild = (i << 1) + 1;
-      Scorer lscorer = subScorers[lchild];
-      int ldoc = lscorer.docID();
-      int rdoc = Integer.MAX_VALUE, rchild = (i << 1) + 2;
-      Scorer rscorer = null;
-      if (rchild < numScorers) {
-        rscorer = subScorers[rchild];
-        rdoc = rscorer.docID();
-      }
-      if (ldoc < doc) {
-        if (rdoc < ldoc) {
-          subScorers[i] = rscorer;
-          subScorers[rchild] = scorer;
-          i = rchild;
-        } else {
-          subScorers[i] = lscorer;
-          subScorers[lchild] = scorer;
-          i = lchild;
-        }
-      } else if (rdoc < doc) {
-        subScorers[i] = rscorer;
-        subScorers[rchild] = scorer;
-        i = rchild;
-      } else {
-        return;
-      }
-    }
-  }
 
-  /** 
-   * Remove the root Scorer from subScorers and re-establish it as a heap
-   */
-  private void heapRemoveRoot() {
-    if (numScorers == 1) {
-      subScorers[0] = null;
-      numScorers = 0;
-    } else {
-      subScorers[0] = subScorers[numScorers - 1];
-      subScorers[numScorers - 1] = null;
-      --numScorers;
-      heapAdjust(0);
-    }
-  }
-  
+
   @Override
   public final Collection<ChildScorer> getChildren() {
-    ArrayList<ChildScorer> children = new ArrayList<>(numScorers);
-    for (int i = 0; i < numScorers; i++) {
-      children.add(new ChildScorer(subScorers[i], "SHOULD"));
+    ArrayList<ChildScorer> children = new ArrayList<>(subScorers.size());
+    for (Scorer scorer : subScorers) {
+      children.add(new ChildScorer(scorer, "SHOULD"));
     }
     return children;
   }
@@ -117,30 +170,31 @@
   @Override
   public final long cost() {
     long sum = 0;
-    for (int i = 0; i < numScorers; i++) {
-      sum += subScorers[i].cost();
+    for (Scorer scorer : subScorers) {
+      sum += scorer.cost();
     }
     return sum;
-  } 
-  
+  }
+
   @Override
   public final int docID() {
    return doc;
   }
- 
+
   @Override
   public final int nextDoc() throws IOException {
     assert doc != NO_MORE_DOCS;
     while(true) {
-      if (subScorers[0].nextDoc() != NO_MORE_DOCS) {
-        heapAdjust(0);
+      if (top.nextDoc() != NO_MORE_DOCS) {
+        top = subScorers.updateTop();
       } else {
-        heapRemoveRoot();
-        if (numScorers == 0) {
+        subScorers.pop();
+        if (subScorers.size() == 0) {
           return doc = NO_MORE_DOCS;
         }
+        top = subScorers.top();
       }
-      int docID = subScorers[0].docID();
+      int docID = top.docID();
       if (docID != doc) {
         freq = -1;
         return doc = docID;
@@ -147,20 +201,21 @@
       }
     }
   }
-  
+
   @Override
   public final int advance(int target) throws IOException {
     assert doc != NO_MORE_DOCS;
     while(true) {
-      if (subScorers[0].advance(target) != NO_MORE_DOCS) {
-        heapAdjust(0);
+      if (top.advance(target) != NO_MORE_DOCS) {
+        top = subScorers.updateTop();
       } else {
-        heapRemoveRoot();
-        if (numScorers == 0) {
+        subScorers.pop();
+        if (subScorers.size() == 0) {
           return doc = NO_MORE_DOCS;
         }
+        top = subScorers.top();
       }
-      int docID = subScorers[0].docID();
+      int docID = top.docID();
       if (docID >= target) {
         freq = -1;
         return doc = docID;
@@ -167,29 +222,12 @@
       }
     }
   }
-  
-  // if we haven't already computed freq + score, do so
-  private void visitScorers() throws IOException {
-    reset();
-    freq = 1;
-    accum(subScorers[0]);
-    visit(1);
-    visit(2);
-  }
-  
-  // TODO: remove recursion.
-  private void visit(int root) throws IOException {
-    if (root < numScorers && subScorers[root].docID() == doc) {
-      freq++;
-      accum(subScorers[root]);
-      visit((root<<1)+1);
-      visit((root<<1)+2);
-    }
-  }
-  
+
   @Override
   public final float score() throws IOException {
-    visitScorers();
+    if (freq < 0) {
+      subScorers.visitScorers(this);
+    }
     return getFinal();
   }
 
@@ -196,17 +234,21 @@
   @Override
   public final int freq() throws IOException {
     if (freq < 0) {
-      visitScorers();
+      subScorers.visitScorers(this);
     }
     return freq;
   }
-  
+
   /** Reset score state for a new match */
-  protected abstract void reset();
-  
+  protected void reset() {
+    freq = 0;
+  }
+
   /** Factor in sub-scorer match */
-  protected abstract void accum(Scorer subScorer) throws IOException;
-  
+  protected void accum(Scorer subScorer) throws IOException {
+    freq += 1;
+  }
+
   /** Return final score */
   protected abstract float getFinal();
 }
Index: lucene/core/src/java/org/apache/lucene/search/DisjunctionSumScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/DisjunctionSumScorer.java	(revision 1634505)
+++ lucene/core/src/java/org/apache/lucene/search/DisjunctionSumScorer.java	(working copy)
@@ -38,11 +38,13 @@
   
   @Override
   protected void reset() {
+    super.reset();
     score = 0;
   }
   
   @Override
   protected void accum(Scorer subScorer) throws IOException {
+    super.accum(subScorer);
     score += subScorer.score();
   }
   
