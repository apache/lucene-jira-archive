Index: lucene/core/src/java/org/apache/lucene/geo/EdgeTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/core/src/java/org/apache/lucene/geo/EdgeTree.java	(revision fd8d9d51999a58f86b5474d28bc7e9320aceeee4)
+++ lucene/core/src/java/org/apache/lucene/geo/EdgeTree.java	(date 1552382868000)
@@ -81,18 +81,21 @@
     double maxLat = StrictMath.max(StrictMath.max(ay, by), cy);
     double maxLon = StrictMath.max(StrictMath.max(ax, bx), cx);
     if (minLat <= maxY && minLon <= maxX) {
-      Relation relation = internalComponentRelateTriangle(ax, ay, bx, by, cx, cy);
-      if (relation != Relation.CELL_OUTSIDE_QUERY) {
-        return relation;
+      // if the bounding boxes are disjoint then the shapes are disjoint so no need to call the component
+      if ((maxLon < this.minLon || minLon > this.maxLon || maxLat < this.minLat || minLat > this.maxLat) == false) {
+        Relation relation = componentRelateTriangle(ax, ay, bx, by, cx, cy);
+        if (relation != Relation.CELL_OUTSIDE_QUERY) {
+          return relation;
+        }
       }
       if (left != null) {
-        relation = left.relateTriangle(ax, ay, bx, by, cx, cy);
+        Relation relation = left.relateTriangle(ax, ay, bx, by, cx, cy);
         if (relation != Relation.CELL_OUTSIDE_QUERY) {
           return relation;
         }
       }
       if (right != null && ((splitX == false && maxLat >= this.minLat) || (splitX && maxLon >= this.minLon))) {
-        relation = right.relateTriangle(ax, ay, bx, by, cx, cy);
+        Relation relation = right.relateTriangle(ax, ay, bx, by, cx, cy);
         if (relation != Relation.CELL_OUTSIDE_QUERY) {
           return relation;
         }
@@ -104,18 +107,25 @@
   /** Returns relation to the provided rectangle */
   public Relation relate(double minLat, double maxLat, double minLon, double maxLon) {
     if (minLat <= maxY && minLon <= maxX) {
-      Relation relation = internalComponentRelate(minLat, maxLat, minLon, maxLon);
-      if (relation != Relation.CELL_OUTSIDE_QUERY) {
-        return relation;
+      // if the rectangle fully encloses us, we cross.
+      if (minLat <= this.minLat && maxLat >= this.maxLat && minLon <= this.minLon && maxLon >= this.maxLon) {
+        return Relation.CELL_CROSSES_QUERY;
+      }
+      // if the bounding boxes are disjoint then the shapes are disjoint so no need to call the component
+      if ((maxLon < this.minLon || minLon > this.maxLon || maxLat < this.minLat || minLat > this.maxLat) == false) {
+        Relation relation = componentRelate(minLat, maxLat, minLon, maxLon);
+        if (relation != Relation.CELL_OUTSIDE_QUERY) {
+          return relation;
+        }
       }
       if (left != null) {
-        relation = left.relate(minLat, maxLat, minLon, maxLon);
+        Relation relation = left.relate(minLat, maxLat, minLon, maxLon);
         if (relation != Relation.CELL_OUTSIDE_QUERY) {
           return relation;
         }
       }
       if (right != null && ((splitX == false && maxLat >= this.minLat) || (splitX && maxLon >= this.minLon))) {
-        relation = right.relate(minLat, maxLat, minLon, maxLon);
+        Relation relation = right.relate(minLat, maxLat, minLon, maxLon);
         if (relation != Relation.CELL_OUTSIDE_QUERY) {
           return relation;
         }
@@ -130,33 +140,6 @@
   /** Returns relation to the provided triangle for this component */
   protected abstract Relation componentRelateTriangle(double ax, double ay, double bx, double by, double cx, double cy);
 
-
-  private Relation internalComponentRelateTriangle(double ax, double ay, double bx, double by, double cx, double cy) {
-    // compute bounding box of triangle
-    double minLat = StrictMath.min(StrictMath.min(ay, by), cy);
-    double minLon = StrictMath.min(StrictMath.min(ax, bx), cx);
-    double maxLat = StrictMath.max(StrictMath.max(ay, by), cy);
-    double maxLon = StrictMath.max(StrictMath.max(ax, bx), cx);
-    if (maxLon < this.minLon || minLon > this.maxLon || maxLat < this.minLat || minLat > this.maxLat) {
-      return Relation.CELL_OUTSIDE_QUERY;
-    }
-    return componentRelateTriangle(ax, ay, bx, by, cx, cy);
-  }
-
-
-  /** Returns relation to the provided rectangle for this component */
-  protected Relation internalComponentRelate(double minLat, double maxLat, double minLon, double maxLon) {
-    // if the bounding boxes are disjoint then the shape does not cross
-    if (maxLon < this.minLon || minLon > this.maxLon || maxLat < this.minLat || minLat > this.maxLat) {
-      return Relation.CELL_OUTSIDE_QUERY;
-    }
-    // if the rectangle fully encloses us, we cross.
-    if (minLat <= this.minLat && maxLat >= this.maxLat && minLon <= this.minLon && maxLon >= this.maxLon) {
-      return Relation.CELL_CROSSES_QUERY;
-    }
-    return componentRelate(minLat, maxLat, minLon, maxLon);
-  }
-
   /** Creates tree from sorted components (with range low and high inclusive) */
   protected static EdgeTree createTree(EdgeTree components[], int low, int high, boolean splitX) {
     if (low > high) {
