Index: lucene/spatial/src/test/org/apache/lucene/spatial/PortedSolr3Test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/PortedSolr3Test.java	(revision 1357451)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/PortedSolr3Test.java	(revision )
@@ -175,9 +175,11 @@
   private Document newDoc(String id, Shape shape) {
     Document doc = new Document();
     doc.add(new StringField("id", id, Field.Store.YES));
-    for (IndexableField f : strategy.createFields(shape, true, storeShape)) {
+    for (IndexableField f : strategy.createFields(shape)) {
       doc.add(f);
     }
+    if (storeShape)
+      doc.add(strategy.createStoredField(shape));
     return doc;
   }
 
Index: lucene/spatial/src/java/org/apache/lucene/spatial/SpatialStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/SpatialStrategy.java	(revision 1357451)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/SpatialStrategy.java	(revision )
@@ -19,6 +19,7 @@
 
 import com.spatial4j.core.context.SpatialContext;
 import com.spatial4j.core.shape.Shape;
+import org.apache.lucene.document.StoredField;
 import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.queries.function.FunctionQuery;
 import org.apache.lucene.queries.function.ValueSource;
@@ -75,11 +76,21 @@
    * This is reasonable behavior if 'ignoreIncompatibleGeometry=true' and the
    * geometry is incompatible
    */
-  public abstract IndexableField createField(Shape shape, boolean index, boolean store);
+  public abstract IndexableField createField(Shape shape);
 
   /** Corresponds with Solr's FieldType.createFields(). */
-  public IndexableField[] createFields(Shape shape, boolean index, boolean store) {
-    return new IndexableField[] { createField(shape, index, store) };
+  public IndexableField[] createFields(Shape shape) {
+    return new IndexableField[] { createField(shape) };
+  }
+
+  /**
+   * A convenience method for storing the shape in Lucene for retrieval in search results.
+   * After calling this, add it to the document: {@link org.apache.lucene.document.Document#add(org.apache.lucene.index.IndexableField)}.
+   * All this does is:
+   * <pre>return new StoredField(getFieldName(),ctx.toString(shape));</pre>
+   */
+  public StoredField createStoredField(Shape shape) {
+    return new StoredField(getFieldName(), ctx.toString(shape));
   }
 
   /**
Index: lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestTermQueryPrefixGridStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestTermQueryPrefixGridStrategy.java	(revision 1357451)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestTermQueryPrefixGridStrategy.java	(revision )
@@ -44,7 +44,8 @@
 
     Document losAngeles = new Document();
     losAngeles.add(new StringField("name", "Los Angeles", Field.Store.YES));
-    losAngeles.add(prefixGridStrategy.createField(point, true, true));
+    losAngeles.add(prefixGridStrategy.createField(point));
+    losAngeles.add(prefixGridStrategy.createStoredField(point));
 
     addDocumentsAndCommit(Arrays.asList(losAngeles));
 
Index: lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy.java	(revision 1357451)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/prefix/TestRecursivePrefixTreeStrategy.java	(revision )
@@ -153,9 +153,11 @@
   private Document newDoc(String id, Shape shape) {
     Document doc = new Document();
     doc.add(new StringField("id", id, Field.Store.YES));
-    for (IndexableField f : strategy.createFields(shape, true, storeShape)) {
+    for (IndexableField f : strategy.createFields(shape)) {
       doc.add(f);
     }
+    if (storeShape)
+      doc.add(strategy.createStoredField(shape));
     return doc;
   }
 
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy.java	(revision 1357451)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy.java	(revision )
@@ -24,7 +24,6 @@
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.document.StoredField;
 import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.queries.function.ValueSource;
 import org.apache.lucene.spatial.SpatialStrategy;
@@ -63,7 +62,7 @@
   }
 
   @Override
-  public IndexableField createField(Shape shape, boolean index, boolean store) {
+  public IndexableField createField(Shape shape) {
     int detailLevel = grid.getMaxLevelForPrecision(shape,distErrPct);
     List<Node> cells = grid.getNodes(shape, detailLevel, true);//true=intermediates cells
     //If shape isn't a point, add a full-resolution center-point so that
@@ -78,42 +77,17 @@
     //TODO is CellTokenStream supposed to be re-used somehow? see Uwe's comments:
     //  http://code.google.com/p/lucene-spatial-playground/issues/detail?id=4
 
-    String fname = getFieldName();
-    if( store ) {
-      //TODO figure out how to re-use original string instead of reconstituting it.
-      String wkt = grid.getSpatialContext().toString(shape);
-      if( index ) {
-        Field f = new Field(fname,wkt,TYPE_STORED);
-        f.setTokenStream(new CellTokenStream(cells.iterator()));
-        return f;
+    return new Field(getFieldName(),new CellTokenStream(cells.iterator()), FIELD_TYPE);
-      }
+  }
-      return new StoredField(fname,wkt);
-    }
-    
+
-    if( index ) {
-      return new Field(fname,new CellTokenStream(cells.iterator()),TYPE_NOT_STORED);
-    }
-    
-    throw new UnsupportedOperationException("Fields need to be indexed or store ["+fname+"]");
-  }
-
   /* Indexed, tokenized, not stored. */
-  public static final FieldType TYPE_NOT_STORED = new FieldType();
+  public static final FieldType FIELD_TYPE = new FieldType();
 
-  /* Indexed, tokenized, stored. */
-  public static final FieldType TYPE_STORED = new FieldType();
-
   static {
-    TYPE_NOT_STORED.setIndexed(true);
-    TYPE_NOT_STORED.setTokenized(true);
-    TYPE_NOT_STORED.setOmitNorms(true);
-    TYPE_NOT_STORED.freeze();
-
-    TYPE_STORED.setStored(true);
-    TYPE_STORED.setIndexed(true);
-    TYPE_STORED.setTokenized(true);
-    TYPE_STORED.setOmitNorms(true);
-    TYPE_STORED.freeze();
+    FIELD_TYPE.setIndexed(true);
+    FIELD_TYPE.setTokenized(true);
+    FIELD_TYPE.setOmitNorms(true);
+    FIELD_TYPE.freeze();
   }
 
   /** Outputs the tokenString of a cell, and if its a leaf, outputs it again with the leaf byte. */
Index: lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxStrategy.java	(revision 1357451)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxStrategy.java	(revision )
@@ -23,7 +23,7 @@
 import org.apache.lucene.document.DoubleField;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.index.FieldInfo.IndexOptions;
+import org.apache.lucene.document.StringField;
 import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queries.function.FunctionQuery;
@@ -41,10 +41,7 @@
 import org.apache.lucene.spatial.query.SpatialOperation;
 import org.apache.lucene.spatial.query.UnsupportedSpatialOperation;
 
-import java.text.NumberFormat;
-import java.util.Locale;
 
-
 /**
  * Based on GeoPortal's
  * <a href="http://geoportal.svn.sourceforge.net/svnroot/geoportal/Geoportal/trunk/src/com/esri/gpt/catalog/lucene/SpatialClauseAdapter.java">SpatialClauseAdapter</a>.
@@ -95,61 +92,21 @@
   //---------------------------------
 
   @Override
-  public IndexableField[] createFields(Shape shape, boolean index, boolean store) {
-
+  public IndexableField[] createFields(Shape shape) {
     Rectangle bbox = shape.getBoundingBox();
-    IndexableField[] fields = new IndexableField[store?6:5];
-    fields[0] = createDouble(field_minX, bbox.getMinX(), index, store);
-    fields[1] = createDouble(field_maxX, bbox.getMaxX(), index, store);
-    fields[2] = createDouble(field_minY, bbox.getMinY(), index, store);
-    fields[3] = createDouble(field_maxY, bbox.getMaxY(), index, store);
-
-    FieldType ft = new FieldType();
-    ft.setIndexed(index);
-    ft.setStored(store);
-    ft.setTokenized(false);
-    ft.setOmitNorms(true);
-    ft.setIndexOptions(IndexOptions.DOCS_ONLY);
-    ft.freeze();
-
-    Field xdl = new Field( field_xdl, bbox.getCrossesDateLine()?"T":"F", ft );
-    fields[4] = xdl;
-    if( store ) {
-      FieldType ff = new FieldType();
-      ff.setIndexed(false);
-      ff.setStored(true);
-      ff.setOmitNorms(true);
-      ff.setIndexOptions(IndexOptions.DOCS_ONLY);
-      ff.freeze();
-
-      NumberFormat nf = NumberFormat.getInstance( Locale.US );
-      nf.setMaximumFractionDigits( 5 );
-      nf.setMinimumFractionDigits( 5 );
-      nf.setGroupingUsed(false);
-      String ext =
-        nf.format( bbox.getMinX() ) + ' ' +
-        nf.format( bbox.getMinY() ) + ' ' +
-        nf.format( bbox.getMaxX() ) + ' ' +
-        nf.format( bbox.getMaxY() ) + ' ';
-      fields[5] = new Field( field_bbox, ext, ff );
-    }
+    FieldType doubleFieldType = new FieldType(DoubleField.TYPE_NOT_STORED);
+    doubleFieldType.setNumericPrecisionStep(precisionStep);
+    IndexableField[] fields = new IndexableField[5];
+    fields[0] = new DoubleField(field_minX, bbox.getMinX(), doubleFieldType);
+    fields[1] = new DoubleField(field_maxX, bbox.getMaxX(), doubleFieldType);
+    fields[2] = new DoubleField(field_minY, bbox.getMinY(), doubleFieldType);
+    fields[3] = new DoubleField(field_maxY, bbox.getMaxY(), doubleFieldType);
+    fields[4] = new Field( field_xdl, bbox.getCrossesDateLine()?"T":"F", StringField.TYPE_NOT_STORED);
     return fields;
   }
 
-  private IndexableField createDouble(String name, double v, boolean index, boolean store) {
-    if (!store && !index)
-      throw new IllegalArgumentException("field must be indexed or stored");
-
-    FieldType fieldType = new FieldType(DoubleField.TYPE_NOT_STORED);
-    fieldType.setStored(store);
-    fieldType.setIndexed(index);
-    fieldType.setNumericPrecisionStep(precisionStep);
-    return new DoubleField(name,v,fieldType);
-  }
-
   @Override
-  public IndexableField createField(Shape shape,
-                                    boolean index, boolean store) {
+  public IndexableField createField(Shape shape) {
     throw new UnsupportedOperationException("BBOX is poly field");
   }
 
Index: lucene/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesStrategy.java	(revision 1357451)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/vector/TwoDoublesStrategy.java	(revision )
@@ -24,7 +24,6 @@
 import com.spatial4j.core.shape.Rectangle;
 import com.spatial4j.core.shape.Shape;
 import org.apache.lucene.document.DoubleField;
-import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
 import org.apache.lucene.index.IndexableField;
 import org.apache.lucene.queries.function.FunctionQuery;
@@ -83,20 +82,14 @@
   }
 
   @Override
-  public IndexableField[] createFields(Shape shape, boolean index, boolean store) {
+  public IndexableField[] createFields(Shape shape) {
     if( shape instanceof Point ) {
       Point point = (Point)shape;
-
-      IndexableField[] f = new IndexableField[(index ? 2 : 0) + (store ? 1 : 0)];
-      if (index) {
-        f[0] = createDouble(fieldNameX, point.getX(), index, store);
-        f[1] = createDouble(fieldNameY, point.getY(), index, store);
-      }
-      if(store) {
-        FieldType customType = new FieldType();
-        customType.setStored(true);
-        f[f.length-1] = new Field( getFieldName(), ctx.toString( shape ), customType );
-      }
+      FieldType doubleFieldType = new FieldType(DoubleField.TYPE_NOT_STORED);
+      doubleFieldType.setNumericPrecisionStep(precisionStep);
+      IndexableField[] f = new IndexableField[2];
+      f[0] = new DoubleField(fieldNameX, point.getX(), doubleFieldType);
+      f[1] = new DoubleField(fieldNameY, point.getY(), doubleFieldType);
       return f;
     }
     if( !ignoreIncompatibleGeometry ) {
@@ -105,20 +98,8 @@
     return new IndexableField[0]; // nothing (solr does not support null)
   }
 
-  private IndexableField createDouble(String name, double v, boolean index, boolean store) {
-    if (!store && !index)
-      throw new IllegalArgumentException("field must be indexed or stored");
-
-    FieldType fieldType = new FieldType(DoubleField.TYPE_NOT_STORED);
-    fieldType.setStored(store);
-    fieldType.setIndexed(index);
-    fieldType.setNumericPrecisionStep(precisionStep);
-    return new DoubleField(name,v,fieldType);
-  }
-
   @Override
-  public IndexableField createField(Shape shape,
-                                    boolean index, boolean store) {
+  public IndexableField createField(Shape shape) {
     throw new UnsupportedOperationException("Point is poly field");
   }
 
Index: lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase.java	(revision 1357451)
+++ lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase.java	(revision )
@@ -84,11 +84,14 @@
       document.add(new StringField("id", data.id, Field.Store.YES));
       document.add(new StringField("name", data.name, Field.Store.YES));
       Shape shape = ctx.readShape(data.shape);
-      for (IndexableField f : strategy.createFields(shape, true, storeShape)) {
+      for (IndexableField f : strategy.createFields(shape)) {
         if( f != null ) { // null if incompatibleGeometry && ignore
           document.add(f);
         }
       }
+      if (storeShape)
+        document.add(strategy.createStoredField(shape));
+
       documents.add(document);
     }
     return documents;
@@ -113,6 +116,10 @@
 
       String msg = q.line; //"Query: " + q.args.toString(ctx);
       SearchResults got = executeQuery(strategy.makeQuery(q.args), 100);
+      if (storeShape && got.numFound > 0) {
+        //check stored value is there & parses
+        assertNotNull(ctx.readShape(got.results.get(0).document.get(strategy.getFieldName())));
+      }
       if (concern.orderIsImportant) {
         Iterator<String> ids = q.ids.iterator();
         for (SearchResult r : got.results) {
