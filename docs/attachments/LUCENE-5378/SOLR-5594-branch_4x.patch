Index: solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java
===================================================================
--- solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java	(revision 1554960)
+++ solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase.java	(working copy)
@@ -415,18 +415,6 @@
   }
 
   /**
-   * Builds a new PrefixQuery instance
-   * @param prefix Prefix term
-   * @return new PrefixQuery instance
-   */
-  protected Query newPrefixQuery(Term prefix){
-    PrefixQuery query = new PrefixQuery(prefix);
-    SchemaField sf = schema.getField(prefix.field());
-    query.setRewriteMethod(sf.getType().getRewriteMethod(parser, sf));
-    return query;
-  }
-
-  /**
    * Builds a new RegexpQuery instance
    * @param regexp Regexp term
    * @return new RegexpQuery instance
@@ -761,7 +749,8 @@
     termStr = analyzeIfMultitermTermText(field, termStr, schema.getFieldType(field));
 
     // Solr has always used constant scoring for prefix queries.  This should return constant scoring by default.
-    return newPrefixQuery(new Term(field, termStr));
+    SchemaField sf = schema.getField(field);
+    return sf.getType().getPrefixQuery(parser, sf, termStr);
   }
 
   // called from parser
Index: solr/core/src/java/org/apache/solr/schema/FieldType.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/FieldType.java	(revision 1554960)
+++ solr/core/src/java/org/apache/solr/schema/FieldType.java	(working copy)
@@ -35,6 +35,7 @@
 import org.apache.lucene.search.FieldCacheRangeFilter;
 import org.apache.lucene.search.FieldCacheRewriteMethod;
 import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SortField;
 import org.apache.lucene.search.TermQuery;
@@ -427,7 +428,32 @@
     return getClass().getName();
   }
 
+
   /**
+   * Returns a Query instance for doing range searches on this field type. {@link org.apache.solr.search.SolrQueryParser}
+   * currently passes part1 and part2 as null if they are '*' respectively. minInclusive and maxInclusive are both true
+   * currently by SolrQueryParser but that may change in the future. Also, other QueryParser implementations may have
+   * different semantics.
+   * <p/>
+   * Sub-classes should override this method to provide their own range query implementation. They should strive to
+   * handle nulls in part1 and/or part2 as well as unequal minInclusive and maxInclusive parameters gracefully.
+   *
+   * @param parser       the {@link org.apache.solr.search.QParser} calling the method
+   * @param sf           the schema field
+   * @param termStr      the term string for prefix query
+   * @return a Query instance to perform prefix search
+   *
+   */
+  public Query getPrefixQuery(QParser parser, SchemaField sf, String termStr) {
+    BytesRef br = new BytesRef();
+    readableToIndexed(termStr, br);
+
+    PrefixQuery query = new PrefixQuery(new Term(sf.getName(), br));
+    query.setRewriteMethod(sf.getType().getRewriteMethod(parser, sf));
+    return query;
+  }
+
+  /**
    * Default analyzer for types that only produce 1 verbatim token...
    * A maximum size of chars to be read must be specified
    */
Index: solr/core/src/test/org/apache/solr/schema/MyIndexedBinaryField.java
===================================================================
--- solr/core/src/test/org/apache/solr/schema/MyIndexedBinaryField.java	(revision 0)
+++ solr/core/src/test/org/apache/solr/schema/MyIndexedBinaryField.java	(working copy)
@@ -0,0 +1,156 @@
+package org.apache.solr.schema;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.document.*;
+import org.apache.lucene.index.FieldInfo;
+import org.apache.lucene.index.IndexableField;
+import org.apache.lucene.search.FieldComparator;
+import org.apache.lucene.search.FieldComparatorSource;
+import org.apache.lucene.search.MultiTermQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.SortField;
+import org.apache.lucene.search.TermRangeQuery;
+import org.apache.lucene.util.BytesRef;
+import org.apache.solr.common.util.Base64;
+import org.apache.solr.response.TextResponseWriter;
+import org.apache.solr.search.QParser;
+import org.apache.solr.util.BinaryTokenStream;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+
+public class MyIndexedBinaryField extends FieldType {
+
+  @Override
+  public void write(final TextResponseWriter writer, final String name, final IndexableField f)
+      throws IOException {
+    writer.writeStr(name, toBase64String(toObject(f)), false);
+  }
+
+  @Override
+  public ByteBuffer toObject(final IndexableField f) {
+    final BytesRef bytes = f.binaryValue();
+    return ByteBuffer.wrap(bytes.bytes, bytes.offset, bytes.length);
+  }
+
+
+  @Override
+  public Query getRangeQuery(final QParser parser, final SchemaField field, final String min, final String max,
+                             final boolean minInclusive, final boolean maxInclusive) {
+    BytesRef minBytes = null, maxBytes = null;
+    if (min != null) {
+      minBytes = new BytesRef();
+      readableToIndexed(min, minBytes);
+    }
+    if (max != null) {
+      maxBytes = new BytesRef();
+      readableToIndexed(max, maxBytes);
+    }
+
+    final TermRangeQuery query = new TermRangeQuery(
+        field.getName(), minBytes, maxBytes, minInclusive, maxInclusive);
+    query.setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE);
+
+    return query;
+  }
+
+  @Override
+  public void readableToIndexed(final CharSequence val, final BytesRef result) {
+    result.bytes = Base64.base64ToByteArray(val.toString());
+    result.offset = 0;
+    result.length = result.bytes.length;
+  }
+
+  private String toBase64String(final ByteBuffer buf) {
+    return Base64.byteArrayToBase64(buf.array(), buf.position(), buf.limit() - buf.position());
+  }
+
+  @Override
+  public IndexableField createField(final SchemaField field, final Object val, final float boost) {
+    if (val == null) {
+      return null;
+    }
+    final byte[] buf;
+    final int len;
+    int offset = 0;
+    if (val instanceof byte[]) {
+      buf = (byte[]) val;
+      len = buf.length;
+    } else if (val instanceof ByteBuffer && ((ByteBuffer) val).hasArray()) {
+      final ByteBuffer byteBuf = (ByteBuffer) val;
+      buf = byteBuf.array();
+      offset = byteBuf.position();
+      len = byteBuf.limit() - byteBuf.position();
+    } else {
+      final String strVal = val.toString();
+      //the string has to be a base64 encoded string
+      buf = Base64.base64ToByteArray(strVal);
+      offset = 0;
+      len = buf.length;
+    }
+
+    return createIndexedBinaryField(field.getName(), new BytesRef(buf, offset, len));
+  }
+
+  @Override
+  public Object marshalSortValue(final Object value) {
+    final BytesRef val = (BytesRef) value;
+    return Base64.byteArrayToBase64(val.bytes, val.offset, val.length);
+  }
+
+  @Override
+  public Object unmarshalSortValue(final Object value) {
+    final String val = (String) value;
+    final byte[] bytes = Base64.base64ToByteArray(val);
+    return new BytesRef(bytes);
+  }
+
+  private Field createIndexedBinaryField(final String fieldName, final BytesRef bytes) {
+    // Normally you can't create indexed binary fields, but BinaryTokenStream allows us to do this
+    final BinaryTokenStream tokenStream = new BinaryTokenStream(bytes);
+
+    final org.apache.lucene.document.FieldType type =
+        new org.apache.lucene.document.FieldType(org.apache.lucene.document.TextField.TYPE_NOT_STORED);
+    type.setOmitNorms(true);
+    type.setIndexOptions(FieldInfo.IndexOptions.DOCS_ONLY);
+    type.freeze();
+
+    final Field field = new Field(fieldName, tokenStream, type);
+    return field;
+  }
+
+  @Override
+  public SortField getSortField(final SchemaField field, final boolean reverse) {
+    field.checkSortability();
+    return new IndexedBinarySortField(field.getName(), reverse);
+  }
+
+  static class IndexedBinarySortField extends SortField {
+    public IndexedBinarySortField(final String field, final boolean reverse) {
+      super(field, new FieldComparatorSource() {
+        @Override
+        public FieldComparator<?> newComparator(
+            final String fieldname, final int numHits, final int sortPos, final boolean reversed)
+            throws IOException {
+          return new FieldComparator.TermOrdValComparator(numHits, fieldname);
+        }
+      }, reverse);
+    }
+  }
+}
Index: solr/core/src/test/org/apache/solr/search/TestPrefixQueryForCustomFieldType.java
===================================================================
--- solr/core/src/test/org/apache/solr/search/TestPrefixQueryForCustomFieldType.java	(revision 0)
+++ solr/core/src/test/org/apache/solr/search/TestPrefixQueryForCustomFieldType.java	(working copy)
@@ -0,0 +1,67 @@
+package org.apache.solr.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.solr.SolrTestCaseJ4;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.util.Base64;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+public class TestPrefixQueryForCustomFieldType extends SolrTestCaseJ4 {
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    initCore("solrconfig-basic.xml", "schema-customfield.xml");
+  }
+
+  @Override
+  @Before
+  public void setUp() throws Exception {
+    // if you override setUp or tearDown, you better call
+    // the super classes version
+    super.setUp();
+    clearIndex();
+    assertU(commit());
+  }
+
+  public void createIndex(int nDocs) {
+    for (int i=0; i<nDocs; i++) {
+      SolrInputDocument doc = new SolrInputDocument();
+      doc.addField("id", ""+i);
+      byte[] temp = ("dummydata" + i).getBytes();
+      doc.addField("customfield", Base64.byteArrayToBase64(temp, 0, temp.length));
+      assertU(adoc(doc));
+    }
+    assertU(commit());
+  }
+
+  @Test
+  public void testPrefixQueries() throws Exception {
+    createIndex(100);
+    assertQ(req("fl", "id", "q", "*:*"), "//*[@numFound='100']");
+
+    //Let's try a Prefix query with a Base64 encoded query string
+    String q = "dummydata" + 2;
+    byte[] temp = q.getBytes();
+    assertQ(req("q", "customfield:" + Base64.byteArrayToBase64(temp, 0, temp.length) + "*"), "//*[@numFound='11']");
+
+  }
+
+}
Index: solr/core/src/test/org/apache/solr/util/BinaryTokenStream.java
===================================================================
--- solr/core/src/test/org/apache/solr/util/BinaryTokenStream.java	(revision 0)
+++ solr/core/src/test/org/apache/solr/util/BinaryTokenStream.java	(working copy)
@@ -0,0 +1,88 @@
+package org.apache.solr.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
+import org.apache.lucene.util.AttributeImpl;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.analysis.CannedBinaryTokenStream; // javadocs
+
+/**
+ * A binary tokenstream that lets you index a single
+ * binary token (BytesRef value).
+ *
+ * @see CannedBinaryTokenStream
+ */
+public final class BinaryTokenStream extends TokenStream {
+  private final ByteTermAttribute bytesAtt = addAttribute(ByteTermAttribute.class);
+  private final BytesRef bytes;
+  private boolean available = true;
+
+  public BinaryTokenStream(BytesRef bytes) {
+    this.bytes = bytes;
+  }
+
+  @Override
+  public boolean incrementToken() {
+    if (available) {
+      clearAttributes();
+      available = false;
+      bytesAtt.setBytesRef(bytes);
+      return true;
+    }
+    return false;
+  }
+
+  @Override
+  public void reset() {
+    available = true;
+  }
+
+  public interface ByteTermAttribute extends TermToBytesRefAttribute {
+    public void setBytesRef(BytesRef bytes);
+  }
+
+  public static class ByteTermAttributeImpl extends AttributeImpl implements ByteTermAttribute,TermToBytesRefAttribute {
+    private BytesRef bytes;
+
+    @Override
+    public int fillBytesRef() {
+      return bytes.hashCode();
+    }
+
+    @Override
+    public BytesRef getBytesRef() {
+      return bytes;
+    }
+
+    @Override
+    public void setBytesRef(BytesRef bytes) {
+      this.bytes = bytes;
+    }
+
+    @Override
+    public void clear() {}
+
+    @Override
+    public void copyTo(AttributeImpl target) {
+      ByteTermAttributeImpl other = (ByteTermAttributeImpl) target;
+      other.bytes = bytes;
+    }
+  }
+}
Index: solr/core/src/test-files/solr/collection1/conf/schema-customfield.xml
===================================================================
--- solr/core/src/test-files/solr/collection1/conf/schema-customfield.xml	(working copy)
+++ solr/core/src/test-files/solr/collection1/conf/schema-customfield.xml	(working copy)
@@ -43,6 +43,7 @@
     <fieldType name="long" class="solr.LongField"/>
     <fieldtype name="float" class="solr.FloatField"/>
     <fieldType name="double" class="solr.DoubleField"/>
+    <fieldType name="customfield" class="org.apache.solr.schema.MyIndexedBinaryField"/>
 
     <!-- numeric field types that manipulate the value into
        a string value that isn't human readable in it's internal form,
@@ -87,8 +88,10 @@
 
  <fields>
    <field name="id" type="integer" indexed="true" stored="true" multiValued="false" required="true"/>
-   <field name="data" type="binary" stored="true"/>
+   <field name="customfield" type="customfield" indexed="true"/>
 
+   <field name="_version_" type="long" indexed="true" stored="true" multiValued="false" />
+
  </fields>
 
  <uniqueKey>id</uniqueKey>
