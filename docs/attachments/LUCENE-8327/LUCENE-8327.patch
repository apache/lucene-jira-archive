diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/MultiplexTokenFilter.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/MultiplexTokenFilter.java
new file mode 100644
index 0000000000..9c76507cd8
--- /dev/null
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/MultiplexTokenFilter.java
@@ -0,0 +1,145 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.analysis.miscellaneous;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.function.Function;
+
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.util.Attribute;
+import org.apache.lucene.util.AttributeImpl;
+import org.apache.lucene.util.AttributeReflector;
+
+/**
+ * Repeats the tokens of a TokenStream and applies a different filter to each
+ * repetition.
+ */
+public final class MultiplexTokenFilter extends TokenFilter {
+
+  private final TokenStream source;
+  private final int filterCount;
+
+  protected MultiplexTokenFilter(TokenStream input, List<Function<TokenStream, TokenStream>> filters) {
+    super(input);
+    TokenStream source = new MultiplexerFilter(input);
+    for (int i = 0; i < filters.size(); i++) {
+      source = new Selector(source, i, filters.get(i));
+    }
+    this.source = source;
+    this.filterCount = filters.size();
+  }
+
+  @Override
+  public boolean incrementToken() throws IOException {
+    return source.incrementToken();
+  }
+
+  private static final class Selector extends ConditionalTokenFilter {
+
+    final int slot;
+    MultiplexAttribute att = addAttribute(MultiplexAttribute.class);
+
+    private Selector(TokenStream input, int slot, Function<TokenStream, TokenStream> inputFactory) {
+      super(input, inputFactory);
+      this.slot = slot;
+    }
+
+    @Override
+    protected boolean shouldFilter() throws IOException {
+      return att.getSelector() == slot;
+    }
+  }
+
+  private final class MultiplexerFilter extends TokenFilter {
+
+    MultiplexAttribute att = addAttribute(MultiplexAttribute.class);
+    State state;
+    int slot;
+
+    private MultiplexerFilter(TokenStream input) {
+      super(input);
+    }
+
+    @Override
+    public boolean incrementToken() throws IOException {
+      if (slot >= filterCount - 1) {
+        state = null;
+        slot = 0;
+        att.setSelector(0);
+      }
+      if (state == null) {
+        if (input.incrementToken() == false) {
+          return false;
+        }
+        state = captureState();
+        return true;
+      }
+      restoreState(state);
+      slot++;
+      att.setSelector(slot);
+      return true;
+    }
+
+    @Override
+    public void reset() throws IOException {
+      super.reset();
+      this.slot = 0;
+      this.state = null;
+    }
+  }
+
+  public interface MultiplexAttribute extends Attribute {
+
+    int getSelector();
+
+    void setSelector(int selector);
+
+  }
+
+  public static class MultiplexAttributeImpl extends AttributeImpl implements MultiplexAttribute {
+
+    private int selector;
+
+    @Override
+    public void clear() {
+      selector = 0;
+    }
+
+    @Override
+    public void reflectWith(AttributeReflector reflector) {
+      reflector.reflect(MultiplexAttribute.class, "selector", selector);
+    }
+
+    @Override
+    public void copyTo(AttributeImpl target) {
+      ((MultiplexAttribute)target).setSelector(selector);
+    }
+
+    @Override
+    public int getSelector() {
+      return selector;
+    }
+
+    @Override
+    public void setSelector(int selector) {
+      this.selector = selector;
+    }
+  }
+}
diff --git a/lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestMultiplexTokenFilter.java b/lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestMultiplexTokenFilter.java
new file mode 100644
index 0000000000..f6917f8331
--- /dev/null
+++ b/lucene/analysis/common/src/test/org/apache/lucene/analysis/miscellaneous/TestMultiplexTokenFilter.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.analysis.miscellaneous;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import org.apache.lucene.analysis.BaseTokenStreamTestCase;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.core.LowerCaseFilter;
+import org.apache.lucene.analysis.core.UpperCaseFilter;
+import org.apache.lucene.analysis.en.PorterStemFilter;
+import org.apache.lucene.analysis.ngram.EdgeNGramTokenFilter;
+
+public class TestMultiplexTokenFilter extends BaseTokenStreamTestCase {
+
+  public void testMultiplexer() throws IOException {
+
+    TokenStream input = whitespaceMockTokenizer("one Two thRee four");
+
+    // keep original, uppercase it, lowercase it
+    input = new MultiplexTokenFilter(input, Arrays.asList(in -> in, UpperCaseFilter::new, LowerCaseFilter::new));
+    assertTokenStreamContents(input, new String[]{
+        "one", "ONE", "one", "Two", "TWO", "two", "thRee", "THREE", "three", "four", "FOUR", "four"
+    });
+
+  }
+
+  public void testMultipleOutputs() throws IOException {
+
+    TokenStream input = whitespaceMockTokenizer("rabbits going running");
+    input = new MultiplexTokenFilter(input, Arrays.asList(
+        in -> in,
+        in -> new EdgeNGramTokenFilter(in, 3, 4),
+        PorterStemFilter::new
+    ));
+
+    assertTokenStreamContents(input, new String[]{
+        "rabbits", "rab", "rabb", "rabbit",
+        "going", "goi", "goin", "go",
+        "running", "run", "runn", "run"
+    });
+  }
+
+}
