diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java
index ffe0066ed1..ebaccdc016 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java
@@ -257,9 +257,10 @@ public class ComplexPhraseQueryParser extends QueryParser {
     public Query rewrite(IndexReader reader) throws IOException {
       final Query contents = this.contents[0];
       // ArrayList spanClauses = new ArrayList();
-      if (contents instanceof TermQuery 
+      if (contents instanceof TermQuery
           || contents instanceof MultiTermQuery
           || contents instanceof SynonymQuery
+          || contents instanceof NestedComplexPhraseQuery
           ) {
         return contents;
       }
@@ -405,6 +406,9 @@ public class ComplexPhraseQueryParser extends QueryParser {
           SpanQuery stq = new SpanTermQuery(new Term(field,
                                                      "Dummy clause because no terms found - must match nothing"));
           chosenList.add(stq);
+        } else if (childQuery instanceof SpanQuery) {
+          SpanQuery sq = (SpanQuery) childQuery;
+          chosenList.add(sq);
         } else {
           // TODO alternatively could call extract terms here?
           throw new IllegalArgumentException("Unknown query type:"
@@ -458,4 +462,42 @@ public class ComplexPhraseQueryParser extends QueryParser {
              inOrder == other.inOrder;
     }
   }
+
+  public static class NestedComplexPhraseQuery extends Query {
+
+    private Query m_inner;
+
+    public NestedComplexPhraseQuery(Query inner) {
+      m_inner = inner;
+    }
+
+    @Override
+    public String toString(String field) {
+      return "netsted(" + m_inner.toString(field) + ")";
+    }
+
+    @Override
+    public Query rewrite(IndexReader reader) throws IOException {
+      return m_inner.rewrite(reader);
+    }
+
+    @Override
+    public boolean equals(Object other) {
+      return sameClassAs(other) &&
+             equalsTo(getClass().cast(other));
+    }
+
+    private boolean equalsTo(NestedComplexPhraseQuery other) {
+      return m_inner.equals(other.m_inner);
+    }
+
+    @Override
+    public int hashCode() {
+      final int prime = 31;
+      int result = classHash();
+      result = prime * result + m_inner.hashCode();
+      return result;
+    }
+
+  }
 }
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/complexPhrase/TestComplexPhraseQuery.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/complexPhrase/TestComplexPhraseQuery.java
index 5935da9604..1ba50a076a 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/complexPhrase/TestComplexPhraseQuery.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/complexPhrase/TestComplexPhraseQuery.java
@@ -26,6 +26,10 @@ import org.apache.lucene.document.Field;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.queryparser.classic.ParseException;
+import org.apache.lucene.queryparser.classic.QueryParser;
+import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.ScoreDoc;
@@ -88,6 +92,24 @@ public class TestComplexPhraseQuery extends LuceneTestCase {
     checkMatches("+\"j*hn\" +\"sm*h\"", "1,3"); 
   }
 
+  public void testNestedBooleanComplexQuery() throws Exception {
+    ComplexPhraseQueryParser qp = new ComplexPhraseQueryParser(defaultFieldName, analyzer) {
+      @Override
+      protected org.apache.lucene.search.Query getWildcardQuery(String field, String termStr) throws ParseException {
+        ComplexPhraseQueryParser nestedQp = new ComplexPhraseQueryParser(defaultFieldName, TestComplexPhraseQuery.this.analyzer);
+        nestedQp.setAllowLeadingWildcard(true);
+        //assume a real implementation generates a query like
+        // "waits*tom*" OR "waits* tom*"
+        BooleanQuery.Builder nestedQuery = new BooleanQuery.Builder();
+        nestedQuery.add(nestedQp.parse(defaultFieldName + ": \"waits* tom*\""), Occur.SHOULD);
+        nestedQuery.add(nestedQp.parse(defaultFieldName + ": \"waits*tom*\""), Occur.SHOULD);
+        nestedQuery.setMinimumNumberShouldMatch(1);
+        return new NestedComplexPhraseQuery(nestedQuery.build());
+      }
+    };
+    checkMatches("\"jackson waits*tom*\"", "4", analyzer, qp);
+  }
+
   public void testSynonyms() throws Exception {
     checkMatches("\"dogs\"","8");
     MockSynonymAnalyzer synonym = new MockSynonymAnalyzer();
@@ -132,6 +154,11 @@ public class TestComplexPhraseQuery extends LuceneTestCase {
     ComplexPhraseQueryParser qp = new ComplexPhraseQueryParser(defaultFieldName, anAnalyzer);
     qp.setInOrder(inOrder);
     qp.setFuzzyPrefixLength(1); // usually a good idea
+    checkMatches(qString, expectedVals, analyzer, qp);
+  }
+
+  private void checkMatches(String qString, String expectedVals, Analyzer anAnalyzer, QueryParser qp)
+      throws Exception {
 
     Query q = qp.parse(qString);
 
