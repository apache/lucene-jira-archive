Index: lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.java	(revision d53de2a385c094109cad864b8c25439439c6e04b)
+++ lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.java	(revision )
@@ -16,14 +16,12 @@
  */
 package org.apache.lucene.spatial3d.geom;
 
-import java.util.Arrays;
-import java.util.List;
-import java.util.ArrayList;
-import java.util.Set;
-import java.util.HashSet;
+import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
 
 /**
  * GeoComplexPolygon objects are structures designed to handle very large numbers of edges.
@@ -73,7 +71,7 @@
   private final GeoPoint[] edgePoints;
   private final Edge[] shapeStartEdges;
   
-  private final static double NEAR_EDGE_CUTOFF = 0.0;
+  private final static double NEAR_EDGE_CUTOFF =  0.75;
   
   /**
    * Create a complex polygon from multiple lists of points, and a single point which is known to be in or out of
@@ -132,86 +130,66 @@
     this.testPoint2 = new GeoPoint(-testPoint.x, -testPoint.y, -testPoint.z);
 
     // Construct fixed planes for testPoint1
-    this.testPoint1FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint1.y);
-    this.testPoint1FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint1.x);
-    this.testPoint1FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint1.z);
-    
-    Plane testPoint1FixedYAbovePlane = new Plane(testPoint1FixedYPlane, true);
-    if (testPoint1FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - testPoint1FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {
-        testPoint1FixedYAbovePlane = null;
+    if (Math.abs(testPoint.y) / planetModel.ab < NEAR_EDGE_CUTOFF) {
+      this.testPoint1FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint1.y);
+      this.testPoint1FixedYAbovePlane = new Plane(testPoint1FixedYPlane, true);
+      this.testPoint1FixedYBelowPlane =  new Plane(testPoint1FixedYPlane, false);
+    } else {
+      this.testPoint1FixedYPlane = null;
+      this.testPoint1FixedYAbovePlane = null;
+      this.testPoint1FixedYBelowPlane =  null;
+    }
+
+    if (Math.abs(testPoint.x) / planetModel.ab < NEAR_EDGE_CUTOFF) {
+      this.testPoint1FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint1.x);
+      this.testPoint1FixedXAbovePlane = new Plane(testPoint1FixedXPlane, true);
+      this.testPoint1FixedXBelowPlane =  new Plane(testPoint1FixedXPlane, false);
+    } else {
+      this.testPoint1FixedXPlane = null;
+      this.testPoint1FixedXAbovePlane = null;
+      this.testPoint1FixedXBelowPlane =  null;
+    }
+
+    if (Math.abs(testPoint.z) / planetModel.c < NEAR_EDGE_CUTOFF) {
+      this.testPoint1FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint1.z);
+      this.testPoint1FixedZAbovePlane = new Plane(testPoint1FixedZPlane, true);
+      this.testPoint1FixedZBelowPlane =  new Plane(testPoint1FixedZPlane, false);
+    } else {
+      this.testPoint1FixedZPlane = null;
+      this.testPoint1FixedZAbovePlane = null;
+      this.testPoint1FixedZBelowPlane =  null;
     }
-    this.testPoint1FixedYAbovePlane = testPoint1FixedYAbovePlane;
-    
-    Plane testPoint1FixedYBelowPlane = new Plane(testPoint1FixedYPlane, false);
-    if (testPoint1FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() - testPoint1FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {
-        testPoint1FixedYBelowPlane = null;
-    }
-    this.testPoint1FixedYBelowPlane = testPoint1FixedYBelowPlane;
-    
-    Plane testPoint1FixedXAbovePlane = new Plane(testPoint1FixedXPlane, true);
-    if (testPoint1FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint1FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {
-        testPoint1FixedXAbovePlane = null;
-    }
-    this.testPoint1FixedXAbovePlane = testPoint1FixedXAbovePlane;
-    
-    Plane testPoint1FixedXBelowPlane = new Plane(testPoint1FixedXPlane, false);
-    if (testPoint1FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint1FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {
-        testPoint1FixedXBelowPlane = null;
-    }
-    this.testPoint1FixedXBelowPlane = testPoint1FixedXBelowPlane;
-    
-    Plane testPoint1FixedZAbovePlane = new Plane(testPoint1FixedZPlane, true);
-    if (testPoint1FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() - testPoint1FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {
-        testPoint1FixedZAbovePlane = null;
-    }
-    this.testPoint1FixedZAbovePlane = testPoint1FixedZAbovePlane;
-    
-    Plane testPoint1FixedZBelowPlane = new Plane(testPoint1FixedZPlane, false);
-    if (testPoint1FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - testPoint1FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {
-        testPoint1FixedZBelowPlane = null;
-    }
-    this.testPoint1FixedZBelowPlane = testPoint1FixedZBelowPlane;
 
     // Construct fixed planes for testPoint2
-    this.testPoint2FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint2.y);
-    this.testPoint2FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint2.x);
-    this.testPoint2FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint2.z);
-    
-    Plane testPoint2FixedYAbovePlane = new Plane(testPoint2FixedYPlane, true);
-    if (testPoint2FixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - testPoint2FixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {
-        testPoint2FixedYAbovePlane = null;
+    if (Math.abs(testPoint2.y) / planetModel.ab < NEAR_EDGE_CUTOFF) {
+      this.testPoint2FixedYPlane = new Plane(0.0, 1.0, 0.0, -testPoint2.y);
+      this.testPoint2FixedYAbovePlane = new Plane(testPoint2FixedYPlane, true);
+      this.testPoint2FixedYBelowPlane =  new Plane(testPoint2FixedYPlane, false);
+    } else {
+      this.testPoint2FixedYPlane = null;
+      this.testPoint2FixedYAbovePlane = null;
+      this.testPoint2FixedYBelowPlane =  null;
+    }
+
+    if (Math.abs(testPoint2.x) / planetModel.ab < NEAR_EDGE_CUTOFF) {
+      this.testPoint2FixedXPlane = new Plane(1.0, 0.0, 0.0, -testPoint2.x);
+      this.testPoint2FixedXAbovePlane = new Plane(testPoint2FixedXPlane, true);
+      this.testPoint2FixedXBelowPlane =  new Plane(testPoint2FixedXPlane, false);
+    } else {
+      this.testPoint2FixedXPlane = null;
+      this.testPoint2FixedXAbovePlane = null;
+      this.testPoint2FixedXBelowPlane =  null;
+    }
+
+    if (Math.abs(testPoint2.z) / planetModel.c < NEAR_EDGE_CUTOFF) {
+      this.testPoint2FixedZPlane = new Plane(0.0, 0.0, 1.0, -testPoint2.z);
+      this.testPoint2FixedZAbovePlane = new Plane(testPoint2FixedZPlane, true);
+      this.testPoint2FixedZBelowPlane =  new Plane(testPoint2FixedZPlane, false);
+    } else {
+      this.testPoint2FixedZPlane = null;
+      this.testPoint2FixedZAbovePlane = null;
+      this.testPoint2FixedZBelowPlane =  null;
     }
-    this.testPoint2FixedYAbovePlane = testPoint2FixedYAbovePlane;
-    
-    Plane testPoint2FixedYBelowPlane = new Plane(testPoint2FixedYPlane, false);
-    if (testPoint2FixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF ||  planetModel.getMinimumYValue() - testPoint2FixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {
-        testPoint2FixedYBelowPlane = null;
-    }
-    this.testPoint2FixedYBelowPlane = testPoint2FixedYBelowPlane;
-    
-    Plane testPoint2FixedXAbovePlane = new Plane(testPoint2FixedXPlane, true);
-    if (testPoint2FixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint2FixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {
-        testPoint2FixedXAbovePlane = null;
-    }
-    this.testPoint2FixedXAbovePlane = testPoint2FixedXAbovePlane;
-    
-    Plane testPoint2FixedXBelowPlane = new Plane(testPoint2FixedXPlane, false);
-    if (testPoint2FixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - testPoint2FixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {
-        testPoint2FixedXBelowPlane = null;
-    }
-    this.testPoint2FixedXBelowPlane = testPoint2FixedXBelowPlane;
-    
-    Plane testPoint2FixedZAbovePlane = new Plane(testPoint2FixedZPlane, true);
-    if (testPoint2FixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF ||planetModel.getMinimumZValue() - testPoint2FixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {
-        testPoint2FixedZAbovePlane = null;
-    }
-    this.testPoint2FixedZAbovePlane = testPoint2FixedZAbovePlane;
-    
-    Plane testPoint2FixedZBelowPlane = new Plane(testPoint2FixedZPlane, false);
-    if (testPoint2FixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - testPoint2FixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {
-        testPoint2FixedZBelowPlane = null;
-    }
-    this.testPoint2FixedZBelowPlane = testPoint2FixedZBelowPlane;
 
     // We know inset/out-of-set for testPoint1 only right now
     this.testPoint1InSet = testPointInSet;
@@ -298,7 +276,7 @@
     }
     
     // If we're right on top of any of the test planes, we navigate solely on that plane.
-    if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {
+    if (testPointFixedYPlane != null && testPointFixedYPlane.evaluateIsZero(x, y, z)) {
       // Use the XZ plane exclusively.
       final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);
       // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.
@@ -307,7 +285,7 @@
         return true;
       }
       return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;
-    } else if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {
+    } else if (testPointFixedXPlane != null && testPointFixedXPlane.evaluateIsZero(x, y, z)) {
       // Use the YZ plane exclusively.
       final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);
       // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.
@@ -316,7 +294,7 @@
         return true;
       }
       return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;
-    } else if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {
+    } else if (testPointFixedZPlane != null && testPointFixedZPlane.evaluateIsZero(x, y, z)) {
       final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPoint, testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);
       // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.
       if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {
@@ -324,46 +302,47 @@
         return true;
       }
       return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;
-    } else if (testPointFixedYPlane.evaluateIsZero(x, y, z) || testPointFixedXPlane.evaluateIsZero(x, y, z) || testPointFixedZPlane.evaluateIsZero(x, y, z)) {
-      throw new IllegalArgumentException("Can't compute isWithin for specified point");
     } else {
 
       // This is the expensive part!!
       // Changing the code below has an enormous impact on the queries per second we see with the benchmark.
       
       // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.
-      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);
-      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);
-      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);
-
-      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);
-      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYAbovePlane.D > NEAR_EDGE_CUTOFF) {
-          fixedYAbovePlane = null;
-      }
-      
-      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);
-      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumYValue() - fixedYBelowPlane.D > NEAR_EDGE_CUTOFF) {
-          fixedYBelowPlane = null;
+      final Plane travelPlaneFixedY;
+      final Plane fixedYAbovePlane;
+      final Plane fixedYBelowPlane;
+      if (Math.abs(y) / planetModel.ab < NEAR_EDGE_CUTOFF) {
+        travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);
+        fixedYAbovePlane = new Plane(travelPlaneFixedY, true);
+        fixedYBelowPlane =  new Plane(travelPlaneFixedY, false);
+      } else {
+        travelPlaneFixedY = null;
+        fixedYAbovePlane = null;
+        fixedYBelowPlane =  null;
       }
-      
-      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);
-      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXAbovePlane.D > NEAR_EDGE_CUTOFF) {
-          fixedXAbovePlane = null;
-      }
-      
-      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);
-      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumXValue() - fixedXBelowPlane.D > NEAR_EDGE_CUTOFF) {
-          fixedXBelowPlane = null;
+      final Plane travelPlaneFixedX;
+      final Plane fixedXAbovePlane;
+      final Plane fixedXBelowPlane;
+      if (Math.abs(x) / planetModel.ab < NEAR_EDGE_CUTOFF) {
+        travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);
+        fixedXAbovePlane = new Plane(travelPlaneFixedX, true);
+        fixedXBelowPlane =  new Plane(travelPlaneFixedX, false);
+      } else {
+        travelPlaneFixedX = null;
+        fixedXAbovePlane = null;
+        fixedXBelowPlane =  null;
       }
-      
-      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);
-      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZAbovePlane.D > NEAR_EDGE_CUTOFF) {
-          fixedZAbovePlane = null;
-      }
-      
-      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);
-      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() > NEAR_EDGE_CUTOFF || planetModel.getMinimumZValue() - fixedZBelowPlane.D > NEAR_EDGE_CUTOFF) {
-          fixedZBelowPlane = null;
+      final Plane travelPlaneFixedZ;
+      final Plane fixedZAbovePlane;
+      final Plane fixedZBelowPlane;
+      if (Math.abs(z) / planetModel.c < NEAR_EDGE_CUTOFF) {
+        travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);
+        fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);
+        fixedZBelowPlane =  new Plane(travelPlaneFixedZ, false);
+      } else {
+        travelPlaneFixedZ = null;
+        fixedZAbovePlane = null;
+        fixedZBelowPlane =  null;
       }
 
       // Find the intersection points for each one of these and the complementary test point planes.
@@ -382,202 +361,172 @@
       Tree secondLegTree = null;
       GeoPoint intersectionPoint = null;
 
-      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {
-        //check if planes intersects  inside world
-        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);
-        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);
-        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {
-          final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);
-          for (final GeoPoint p : XIntersectionsY) {
-            // Travel would be in YZ plane (fixed x) then in XZ (fixed y)
-            // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.
-            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
-            final double tpDelta1 = testPoint.x - p.x;
-            final double tpDelta2 = testPoint.z - p.z;
-            final double cpDelta1 = y - p.y;
-            final double cpDelta2 = z - p.z;
-            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
-            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);
-            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);
-            if (newDistance < bestDistance) {
-              bestDistance = newDistance;
-              firstLegValue = testPoint.y;
-              secondLegValue = x;
-              firstLegPlane = testPointFixedYPlane;
-              firstLegAbovePlane = testPointFixedYAbovePlane;
-              firstLegBelowPlane = testPointFixedYBelowPlane;
-              secondLegPlane = travelPlaneFixedX;
-              secondLegAbovePlane = fixedXAbovePlane;
-              secondLegBelowPlane = fixedXBelowPlane;
-              firstLegTree = yTree;
-              secondLegTree = xTree;
-              intersectionPoint = p;
-            }
+      if (testPointFixedYPlane != null && travelPlaneFixedX != null) {
+        final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);
+        for (final GeoPoint p : XIntersectionsY) {
+          // Travel would be in YZ plane (fixed x) then in XZ (fixed y)
+          // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.
+          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
+          final double tpDelta1 = testPoint.x - p.x;
+          final double tpDelta2 = testPoint.z - p.z;
+          final double cpDelta1 = y - p.y;
+          final double cpDelta2 = z - p.z;
+          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
+          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);
+          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);
+          if (newDistance < bestDistance) {
+            bestDistance = newDistance;
+            firstLegValue = testPoint.y;
+            secondLegValue = x;
+            firstLegPlane = testPointFixedYPlane;
+            firstLegAbovePlane = testPointFixedYAbovePlane;
+            firstLegBelowPlane = testPointFixedYBelowPlane;
+            secondLegPlane = travelPlaneFixedX;
+            secondLegAbovePlane = fixedXAbovePlane;
+            secondLegBelowPlane = fixedXBelowPlane;
+            firstLegTree = yTree;
+            secondLegTree = xTree;
+            intersectionPoint = p;
           }
         }
       }
-      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {
-        //check if planes intersects  inside world
-        final double checkAbove = 4.0 * (fixedXAbovePlane.D * fixedXAbovePlane.D * planetModel.inverseAbSquared + testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);
-        final double checkBelow = 4.0 * (fixedXBelowPlane.D * fixedXBelowPlane.D * planetModel.inverseAbSquared + testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);
-        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {
-          final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);
-          for (final GeoPoint p : XIntersectionsZ) {
-            // Travel would be in YZ plane (fixed x) then in XY (fixed z)
-            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
-            final double tpDelta1 = testPoint.x - p.x;
-            final double tpDelta2 = testPoint.y - p.y;
-            final double cpDelta1 = y - p.y;
-            final double cpDelta2 = z - p.z;
-            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
-            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);
-            //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);
-            if (newDistance < bestDistance) {
-              bestDistance = newDistance;
-              firstLegValue = testPoint.z;
-              secondLegValue = x;
-              firstLegPlane = testPointFixedZPlane;
-              firstLegAbovePlane = testPointFixedZAbovePlane;
-              firstLegBelowPlane = testPointFixedZBelowPlane;
-              secondLegPlane = travelPlaneFixedX;
-              secondLegAbovePlane = fixedXAbovePlane;
-              secondLegBelowPlane = fixedXBelowPlane;
-              firstLegTree = zTree;
-              secondLegTree = xTree;
-              intersectionPoint = p;
-            }
+      if (testPointFixedZPlane != null && travelPlaneFixedX != null) {
+        final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);
+        for (final GeoPoint p : XIntersectionsZ) {
+          // Travel would be in YZ plane (fixed x) then in XY (fixed z)
+          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
+          final double tpDelta1 = testPoint.x - p.x;
+          final double tpDelta2 = testPoint.y - p.y;
+          final double cpDelta1 = y - p.y;
+          final double cpDelta2 = z - p.z;
+          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
+          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);
+          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);
+          if (newDistance < bestDistance) {
+            bestDistance = newDistance;
+            firstLegValue = testPoint.z;
+            secondLegValue = x;
+            firstLegPlane = testPointFixedZPlane;
+            firstLegAbovePlane = testPointFixedZAbovePlane;
+            firstLegBelowPlane = testPointFixedZBelowPlane;
+            secondLegPlane = travelPlaneFixedX;
+            secondLegAbovePlane = fixedXAbovePlane;
+            secondLegBelowPlane = fixedXBelowPlane;
+            firstLegTree = zTree;
+            secondLegTree = xTree;
+            intersectionPoint = p;
           }
         }
       }
-      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {
-        //check if planes intersects inside world
-        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);
-        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);
-        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {
-          final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);
-          for (final GeoPoint p : YIntersectionsX) {
-            // Travel would be in XZ plane (fixed y) then in YZ (fixed x)
-            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
-            final double tpDelta1 = testPoint.y - p.y;
-            final double tpDelta2 = testPoint.z - p.z;
-            final double cpDelta1 = x - p.x;
-            final double cpDelta2 = z - p.z;
-            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
-            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);
-            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);
-            if (newDistance < bestDistance) {
-              bestDistance = newDistance;
-              firstLegValue = testPoint.x;
-              secondLegValue = y;
-              firstLegPlane = testPointFixedXPlane;
-              firstLegAbovePlane = testPointFixedXAbovePlane;
-              firstLegBelowPlane = testPointFixedXBelowPlane;
-              secondLegPlane = travelPlaneFixedY;
-              secondLegAbovePlane = fixedYAbovePlane;
-              secondLegBelowPlane = fixedYBelowPlane;
-              firstLegTree = xTree;
-              secondLegTree = yTree;
-              intersectionPoint = p;
-            }
+      if (testPointFixedXPlane != null && travelPlaneFixedY != null) {
+        final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);
+        for (final GeoPoint p : YIntersectionsX) {
+          // Travel would be in XZ plane (fixed y) then in YZ (fixed x)
+          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
+          final double tpDelta1 = testPoint.y - p.y;
+          final double tpDelta2 = testPoint.z - p.z;
+          final double cpDelta1 = x - p.x;
+          final double cpDelta2 = z - p.z;
+          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
+          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);
+          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);
+          if (newDistance < bestDistance) {
+            bestDistance = newDistance;
+            firstLegValue = testPoint.x;
+            secondLegValue = y;
+            firstLegPlane = testPointFixedXPlane;
+            firstLegAbovePlane = testPointFixedXAbovePlane;
+            firstLegBelowPlane = testPointFixedXBelowPlane;
+            secondLegPlane = travelPlaneFixedY;
+            secondLegAbovePlane = fixedYAbovePlane;
+            secondLegBelowPlane = fixedYBelowPlane;
+            firstLegTree = xTree;
+            secondLegTree = yTree;
+            intersectionPoint = p;
           }
         }
       }
-      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {
-        //check if planes intersects inside world
-        final double checkAbove = 4.0 * (testPointFixedZAbovePlane.D * testPointFixedZAbovePlane.D * planetModel.inverseCSquared + fixedYAbovePlane.D * fixedYAbovePlane.D * planetModel.inverseAbSquared - 1.0);
-        final double checkBelow = 4.0 * (testPointFixedZBelowPlane.D * testPointFixedZBelowPlane.D * planetModel.inverseCSquared + fixedYBelowPlane.D * fixedYBelowPlane.D * planetModel.inverseAbSquared - 1.0);
-        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {
-          final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);
-          for (final GeoPoint p : YIntersectionsZ) {
-            // Travel would be in XZ plane (fixed y) then in XY (fixed z)
-            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
-            final double tpDelta1 = testPoint.x - p.x;
-            final double tpDelta2 = testPoint.y - p.y;
-            final double cpDelta1 = x - p.x;
-            final double cpDelta2 = z - p.z;
-            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
-            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);
-            //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);
-            if (newDistance < bestDistance) {
-              bestDistance = newDistance;
-              firstLegValue = testPoint.z;
-              secondLegValue = y;
-              firstLegPlane = testPointFixedZPlane;
-              firstLegAbovePlane = testPointFixedZAbovePlane;
-              firstLegBelowPlane = testPointFixedZBelowPlane;
-              secondLegPlane = travelPlaneFixedY;
-              secondLegAbovePlane = fixedYAbovePlane;
-              secondLegBelowPlane = fixedYBelowPlane;
-              firstLegTree = zTree;
-              secondLegTree = yTree;
-              intersectionPoint = p;
-            }
+      if (testPointFixedZPlane != null && travelPlaneFixedY != null) {
+        final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);
+        for (final GeoPoint p : YIntersectionsZ) {
+          // Travel would be in XZ plane (fixed y) then in XY (fixed z)
+          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
+          final double tpDelta1 = testPoint.x - p.x;
+          final double tpDelta2 = testPoint.y - p.y;
+          final double cpDelta1 = x - p.x;
+          final double cpDelta2 = z - p.z;
+          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
+          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);
+          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);
+          if (newDistance < bestDistance) {
+            bestDistance = newDistance;
+            firstLegValue = testPoint.z;
+            secondLegValue = y;
+            firstLegPlane = testPointFixedZPlane;
+            firstLegAbovePlane = testPointFixedZAbovePlane;
+            firstLegBelowPlane = testPointFixedZBelowPlane;
+            secondLegPlane = travelPlaneFixedY;
+            secondLegAbovePlane = fixedYAbovePlane;
+            secondLegBelowPlane = fixedYBelowPlane;
+            firstLegTree = zTree;
+            secondLegTree = yTree;
+            intersectionPoint = p;
           }
         }
       }
-      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {
-        //check if planes intersects inside world
-        final double checkAbove = 4.0 * (testPointFixedXAbovePlane.D * testPointFixedXAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);
-        final double checkBelow = 4.0 * (testPointFixedXBelowPlane.D * testPointFixedXBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);
-        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {
-          final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);
-          for (final GeoPoint p : ZIntersectionsX) {
-            // Travel would be in XY plane (fixed z) then in YZ (fixed x)
-            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
-            final double tpDelta1 = testPoint.y - p.y;
-            final double tpDelta2 = testPoint.z - p.z;
-            final double cpDelta1 = y - p.y;
-            final double cpDelta2 = x - p.x;
-            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
-            //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);
-            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);
-            if (newDistance < bestDistance) {
-              bestDistance = newDistance;
-              firstLegValue = testPoint.x;
-              secondLegValue = z;
-              firstLegPlane = testPointFixedXPlane;
-              firstLegAbovePlane = testPointFixedXAbovePlane;
-              firstLegBelowPlane = testPointFixedXBelowPlane;
-              secondLegPlane = travelPlaneFixedZ;
-              secondLegAbovePlane = fixedZAbovePlane;
-              secondLegBelowPlane = fixedZBelowPlane;
-              firstLegTree = xTree;
-              secondLegTree = zTree;
-              intersectionPoint = p;
-            }
+      if (testPointFixedXPlane != null && travelPlaneFixedZ != null) {
+        final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);
+        for (final GeoPoint p : ZIntersectionsX) {
+          // Travel would be in XY plane (fixed z) then in YZ (fixed x)
+          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
+          final double tpDelta1 = testPoint.y - p.y;
+          final double tpDelta2 = testPoint.z - p.z;
+          final double cpDelta1 = y - p.y;
+          final double cpDelta2 = x - p.x;
+          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
+          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);
+          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);
+          if (newDistance < bestDistance) {
+            bestDistance = newDistance;
+            firstLegValue = testPoint.x;
+            secondLegValue = z;
+            firstLegPlane = testPointFixedXPlane;
+            firstLegAbovePlane = testPointFixedXAbovePlane;
+            firstLegBelowPlane = testPointFixedXBelowPlane;
+            secondLegPlane = travelPlaneFixedZ;
+            secondLegAbovePlane = fixedZAbovePlane;
+            secondLegBelowPlane = fixedZBelowPlane;
+            firstLegTree = xTree;
+            secondLegTree = zTree;
+            intersectionPoint = p;
           }
         }
       }
-      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {
-        //check if planes intersects inside world
-        final double checkAbove = 4.0 * (testPointFixedYAbovePlane.D * testPointFixedYAbovePlane.D * planetModel.inverseAbSquared + fixedZAbovePlane.D * fixedZAbovePlane.D * planetModel.inverseCSquared - 1.0);
-        final double checkBelow = 4.0 * (testPointFixedYBelowPlane.D * testPointFixedYBelowPlane.D * planetModel.inverseAbSquared + fixedZBelowPlane.D * fixedZBelowPlane.D * planetModel.inverseCSquared - 1.0);
-        if (checkAbove < Vector.MINIMUM_RESOLUTION_SQUARED && checkBelow < Vector.MINIMUM_RESOLUTION_SQUARED) {
-          final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);
-          for (final GeoPoint p : ZIntersectionsY) {
-            // Travel would be in XY plane (fixed z) then in XZ (fixed y)
-            //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
-            final double tpDelta1 = testPoint.x - p.x;
-            final double tpDelta2 = testPoint.z - p.z;
-            final double cpDelta1 = y - p.y;
-            final double cpDelta2 = x - p.x;
-            final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
-            //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);
-            //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);
-            if (newDistance < bestDistance) {
-              bestDistance = newDistance;
-              firstLegValue = testPoint.y;
-              secondLegValue = z;
-              firstLegPlane = testPointFixedYPlane;
-              firstLegAbovePlane = testPointFixedYAbovePlane;
-              firstLegBelowPlane = testPointFixedYBelowPlane;
-              secondLegPlane = travelPlaneFixedZ;
-              secondLegAbovePlane = fixedZAbovePlane;
-              secondLegBelowPlane = fixedZBelowPlane;
-              firstLegTree = yTree;
-              secondLegTree = zTree;
-              intersectionPoint = p;
-            }
+      if (testPointFixedYPlane != null && travelPlaneFixedZ != null) {
+        final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);
+        for (final GeoPoint p : ZIntersectionsY) {
+          // Travel would be in XY plane (fixed z) then in XZ (fixed y)
+          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
+          final double tpDelta1 = testPoint.x - p.x;
+          final double tpDelta2 = testPoint.z - p.z;
+          final double cpDelta1 = y - p.y;
+          final double cpDelta2 = x - p.x;
+          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
+          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);
+          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);
+          if (newDistance < bestDistance) {
+            bestDistance = newDistance;
+            firstLegValue = testPoint.y;
+            secondLegValue = z;
+            firstLegPlane = testPointFixedYPlane;
+            firstLegAbovePlane = testPointFixedYAbovePlane;
+            firstLegBelowPlane = testPointFixedYBelowPlane;
+            secondLegPlane = travelPlaneFixedZ;
+            secondLegAbovePlane = fixedZAbovePlane;
+            secondLegBelowPlane = fixedZBelowPlane;
+            firstLegTree = yTree;
+            secondLegTree = zTree;
+            intersectionPoint = p;
           }
         }
       }
