Index: src/java/org/apache/lucene/index/DirectoryIndexReader.java
===================================================================
--- src/java/org/apache/lucene/index/DirectoryIndexReader.java	(revision 637037)
+++ src/java/org/apache/lucene/index/DirectoryIndexReader.java	(working copy)
@@ -164,7 +164,7 @@
    */
   public boolean isCurrent() throws CorruptIndexException, IOException {
     ensureOpen();
-    return SegmentInfos.readCurrentVersion(directory) == segmentInfos.getVersion();
+    return SegmentInfos.getCurrentSegmentGeneration(directory) == segmentInfos.getGeneration();
   }
 
   /**
@@ -285,7 +285,7 @@
   
         // we have to check whether index has changed since this reader was opened.
         // if so, this reader is no longer valid for deletion
-        if (SegmentInfos.readCurrentVersion(directory) > segmentInfos.getVersion()) {
+        if (SegmentInfos.getCurrentSegmentGeneration(directory) > segmentInfos.getGeneration()) {
           stale = true;
           this.writeLock.release();
           this.writeLock = null;
Index: src/java/org/apache/lucene/index/IndexReader.java
===================================================================
--- src/java/org/apache/lucene/index/IndexReader.java	(revision 637037)
+++ src/java/org/apache/lucene/index/IndexReader.java	(working copy)
@@ -337,9 +337,9 @@
   }
 
   /**
-   * Reads version number from segments files. The version number is
-   * initialized with a timestamp and then increased by one for each change of
-   * the index.
+   * Reads version number from segments files. The version
+   * number is the generation (the N in segments_N filename)
+   * and then increased by one for each commit to the index
    * 
    * @param directory where the index resides.
    * @return version number.
@@ -347,7 +347,7 @@
    * @throws IOException if there is a low-level IO error
    */
   public static long getCurrentVersion(Directory directory) throws CorruptIndexException, IOException {
-    return SegmentInfos.readCurrentVersion(directory);
+    return SegmentInfos.getCurrentSegmentGeneration(directory);
   }
 
   /**
Index: src/java/org/apache/lucene/index/SegmentInfos.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentInfos.java	(revision 637041)
+++ src/java/org/apache/lucene/index/SegmentInfos.java	(working copy)
@@ -65,16 +65,17 @@
   private static final int CURRENT_FORMAT = FORMAT_CHECKSUM;
   
   public int counter = 0;    // used to name new segments
+  
   /**
-   * counts how often the index has been changed by adding or deleting docs.
-   * starting with the current time in milliseconds forces to create unique version numbers.
+   * Counts how often the index has been changed by adding or deleting docs, starting with 1.
+   * This number is written to the Segments file, for historic reasons (this is where 'version' was maintained.)
+   * In addition, this number is used to name the segments files: "segments_1", "segments_2" and so on.  
    */
-  private long version = System.currentTimeMillis();
+  private long generation = 0;
 
-  private long generation = 0;     // generation of the "segments_N" for the next commit
   private long lastGeneration = 0; // generation of the "segments_N" file we last successfully read
                                    // or wrote; this is normally the same as generation except if
-                                   // there was an IOException that had interrupted a commit
+                                   // there was an exception that had interrupted a commit
 
   /**
    * If non-null, information about loading segments_N files
@@ -215,7 +216,7 @@
         // check that it is a format we can understand
         if (format < CURRENT_FORMAT)
           throw new CorruptIndexException("Unknown format version: " + format);
-        version = input.readLong(); // read version
+        input.readLong(); // just skip it, not in use anymore (used to be 'version')
         counter = input.readInt(); // read counter
       }
       else{     // file is in old format without explicit format info
@@ -226,13 +227,6 @@
         addElement(new SegmentInfo(directory, format, input));
       }
       
-      if(format >= 0){    // in old format the version number may be at the end of the file
-        if (input.getFilePointer() >= input.length())
-          version = System.currentTimeMillis(); // old file format without version number
-        else
-          version = input.readLong(); // read version
-      }
-
       if (format <= FORMAT_CHECKSUM) {
         final long checksumNow = input.getChecksum();
         final long checksumThen = input.readLong();
@@ -287,8 +281,7 @@
 
     try {
       output.writeInt(CURRENT_FORMAT); // write FORMAT
-      output.writeLong(++version); // every write changes
-                                   // the index
+      output.writeLong(0); // just for backwards compatibility, not in use anymore (used to be 'version')
       output.writeInt(counter); // write counter
       output.writeInt(size()); // write infos
       for (int i = 0; i < size(); i++) {
@@ -358,9 +351,10 @@
 
   /**
    * version number when this SegmentInfos was generated.
+   * @deprecated Please call {@link #getGeneration} instead
    */
   public long getVersion() {
-    return version;
+    return getGeneration();
   }
   public long getGeneration() {
     return generation;
@@ -373,39 +367,12 @@
    * Current version number from segments file.
    * @throws CorruptIndexException if the index is corrupt
    * @throws IOException if there is a low-level IO error
+   * @deprecated Please call {@link
+   * #getCurrentSegmentGeneration(Directory)} instead
    */
   public static long readCurrentVersion(Directory directory)
     throws CorruptIndexException, IOException {
-
-    return ((Long) new FindSegmentsFile(directory) {
-        protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {
-
-          IndexInput input = directory.openInput(segmentFileName);
-
-          int format = 0;
-          long version = 0;
-          try {
-            format = input.readInt();
-            if(format < 0){
-              if (format < CURRENT_FORMAT)
-                throw new CorruptIndexException("Unknown format version: " + format);
-              version = input.readLong(); // read version
-            }
-          }
-          finally {
-            input.close();
-          }
-     
-          if(format < 0)
-            return new Long(version);
-
-          // We cannot be sure about the format of the file.
-          // Therefore we have to read the whole file and cannot simply seek to the version entry.
-          SegmentInfos sis = new SegmentInfos();
-          sis.read(directory, segmentFileName);
-          return new Long(sis.getVersion());
-        }
-      }.run()).longValue();
+    return getCurrentSegmentGeneration(directory);
   }
 
   /** If non-null, information about retries when loading
@@ -738,7 +705,6 @@
     assert other.generation > generation;
     lastGeneration = other.lastGeneration;
     generation = other.generation;
-    version = other.version;
   }
 
   /** Writes & syncs to the Directory dir, taking care to
