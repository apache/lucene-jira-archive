Index: lucene/core/src/java/org/apache/lucene/store/MMapDirectory.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/store/MMapDirectory.java	(revision 1458241)
+++ lucene/core/src/java/org/apache/lucene/store/MMapDirectory.java	(working copy)
@@ -19,11 +19,11 @@
  
 import java.io.IOException;
 import java.io.File;
-import java.io.RandomAccessFile;
 import java.nio.ByteBuffer;
 import java.nio.channels.ClosedChannelException; // javadoc @link
 import java.nio.channels.FileChannel;
 import java.nio.channels.FileChannel.MapMode;
+import java.nio.file.StandardOpenOption;
 
 import java.security.AccessController;
 import java.security.PrivilegedExceptionAction;
@@ -190,11 +190,11 @@
   public IndexInput openInput(String name, IOContext context) throws IOException {
     ensureOpen();
     File f = new File(getDirectory(), name);
-    RandomAccessFile raf = new RandomAccessFile(f, "r");
+    FileChannel channel = FileChannel.open(f.toPath(), StandardOpenOption.READ);
     try {
-      return new MMapIndexInput("MMapIndexInput(path=\"" + f + "\")", raf);
+      return new MMapIndexInput("MMapIndexInput(path=\"" + f + "\")", channel);
     } finally {
-      raf.close();
+      channel.close();
     }
   }
   
@@ -218,8 +218,8 @@
   private final class MMapIndexInput extends ByteBufferIndexInput {
     private final boolean useUnmapHack;
     
-    MMapIndexInput(String resourceDescription, RandomAccessFile raf) throws IOException {
-      super(resourceDescription, map(raf, 0, raf.length()), raf.length(), chunkSizePower, getUseUnmap());
+    MMapIndexInput(String resourceDescription, FileChannel channel) throws IOException {
+      super(resourceDescription, map(channel, 0, channel.size()), channel.size(), chunkSizePower, getUseUnmap());
       this.useUnmapHack = getUseUnmap();
     }
     
@@ -256,9 +256,9 @@
   }
   
   /** Maps a file into a set of buffers */
-  ByteBuffer[] map(RandomAccessFile raf, long offset, long length) throws IOException {
+  ByteBuffer[] map(FileChannel channel, long offset, long length) throws IOException {
     if ((length >>> chunkSizePower) >= Integer.MAX_VALUE)
-      throw new IllegalArgumentException("RandomAccessFile too big for chunk size: " + raf.toString());
+      throw new IllegalArgumentException("RandomAccessFile too big for chunk size: " + channel.toString());
     
     final long chunkSize = 1L << chunkSizePower;
     
@@ -268,13 +268,12 @@
     ByteBuffer buffers[] = new ByteBuffer[nrBuffers];
     
     long bufferStart = 0L;
-    FileChannel rafc = raf.getChannel();
     for (int bufNr = 0; bufNr < nrBuffers; bufNr++) { 
       int bufSize = (int) ( (length > (bufferStart + chunkSize))
           ? chunkSize
               : (length - bufferStart)
           );
-      buffers[bufNr] = rafc.map(MapMode.READ_ONLY, offset + bufferStart, bufSize);
+      buffers[bufNr] = channel.map(MapMode.READ_ONLY, offset + bufferStart, bufSize);
       bufferStart += bufSize;
     }
     
