Index: modules/queryparser/src/test/org/apache/lucene/queryparser/complexPhrase/TestComplexPhraseQuery.java
===================================================================
--- modules/queryparser/src/test/org/apache/lucene/queryparser/complexPhrase/TestComplexPhraseQuery.java	(revision 1241874)
+++ modules/queryparser/src/test/org/apache/lucene/queryparser/complexPhrase/TestComplexPhraseQuery.java	(revision )
@@ -37,10 +37,11 @@
   Directory rd;
   Analyzer analyzer = new MockAnalyzer(random);
 
-  DocData docsContent[] = { new DocData("john smith", "1"),
-      new DocData("johathon smith", "2"),
-      new DocData("john percival smith", "3"),
-      new DocData("jackson waits tom", "4") };
+  DocData docsContent[] = { new DocData("john smith", "1", "developer"),
+      new DocData("johathon smith", "2", "developer"),
+      new DocData("john percival smith", "3", "designer"),
+      new DocData("jackson waits tom", "4", "project manager")
+  };
 
   private IndexSearcher searcher;
   private IndexReader reader;
@@ -57,8 +58,7 @@
     checkMatches("\"john\"", "1,3"); // Simple single-term still works
     checkMatches("\"(john OR johathon)  smith\"", "1,2"); // boolean logic with
     // brackets works.
-    checkMatches("\"(jo* -john) smyth~\"", "2"); // boolean logic with
-    // brackets works.
+    checkMatches("\"(jo* -john) smyth~\"", "2"); // boolean logic with brackets works
 
     // checkMatches("\"john -percival\"", "1"); // not logic doesn't work
     // currently :(.
@@ -106,10 +106,23 @@
       expecteds.remove(id);
     }
 
-    assertEquals(qString + " missing some matches ", 0, expecteds.size());
+    assertEquals(qString + " missing some matches ", expecteds.size(), 0);
 
   }
-
+  
+  public void testFieldedQuery() throws Exception {
+    checkMatches("name:\"john smith\"", "1"); 
+    checkMatches("name:\"j*   smyth~\"", "1,2");
+    checkMatches("role:\"developer\"", "1,2");
+    checkMatches("role:\"p* manager\"", "4");
+    checkMatches("role:\"de*\"", "1,2,3");
+    checkMatches("role:de*", "1,2,3");
+    checkMatches("name:\"j*   smyth~\"~5", "1,2,3");
+    checkMatches("role:\"p* manager\" AND name:\"jack*\"", "4");
+    checkMatches("role:\"developer\" AND name:\"jack*\"", "");
+    checkMatches("name:\"john smith\"~2 AND role:designer AND id:3", "3");
+  }
+  
   @Override
   public void setUp() throws Exception {
     super.setUp();
@@ -119,6 +132,7 @@
       Document doc = new Document();
       doc.add(newField("name", docsContent[i].name, TextField.TYPE_STORED));
       doc.add(newField("id", docsContent[i].id, TextField.TYPE_STORED));
+      doc.add(newField("role", docsContent[i].role, TextField.TYPE_STORED));
       w.addDocument(doc);
     }
     w.close();
@@ -137,11 +151,14 @@
     String name;
 
     String id;
-
+    
-    public DocData(String name, String id) {
+    String role;
+
+    public DocData(String name, String id, String role) {
       super();
       this.name = name;
       this.id = id;
+      this.role = role;
     }
   }
 
Index: modules/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
===================================================================
--- modules/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java	(revision 1241874)
+++ modules/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java	(revision )
@@ -66,7 +66,7 @@
   boolean enablePositionIncrements = true;
 
   Analyzer analyzer;
-  String field;
+  protected String field;
   int phraseSlop = 0;
   float fuzzyMinSim = FuzzyQuery.defaultMinSimilarity;
   int fuzzyPrefixLength = FuzzyQuery.defaultPrefixLength;
Index: modules/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java
===================================================================
--- modules/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java	(revision 1241874)
+++ modules/queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java	(revision )
@@ -215,31 +215,33 @@
     // Called by ComplexPhraseQueryParser for each phrase after the main
     // parse
     // thread is through
-    protected void parsePhraseElements(QueryParser qp) throws ParseException {
+    protected void parsePhraseElements(ComplexPhraseQueryParser qp) throws ParseException {
       // TODO ensure that field-sensitivity is preserved ie the query
       // string below is parsed as
       // field+":("+phrasedQueryStringContents+")"
       // but this will need code in rewrite to unwrap the first layer of
       // boolean query
+
+      String oldDefaultParserField = qp.field;
+      try {
+        //temporarily set the QueryParser to be parsing the default field for this phrase e.g author:"fred* smith"
+        qp.field = this.field;
-      contents = qp.parse(phrasedQueryStringContents);
-    }
+        contents = qp.parse(phrasedQueryStringContents);
+      }
+      finally {
+        qp.field = oldDefaultParserField;
+      }
+    }
 
     @Override
     public Query rewrite(IndexReader reader) throws IOException {
-      // ArrayList spanClauses = new ArrayList();
-      if (contents instanceof TermQuery) {
+      if (!(contents instanceof BooleanQuery)) {
         return contents;
       }
       // Build a sequence of Span clauses arranged in a SpanNear - child
       // clauses can be complex
       // Booleans e.g. nots and ors etc
       int numNegatives = 0;
-      if (!(contents instanceof BooleanQuery)) {
-        throw new IllegalArgumentException("Unknown query type \""
-            + contents.getClass().getName()
-            + "\" found in phrase query string \"" + phrasedQueryStringContents
-            + "\"");
-      }
       BooleanQuery bq = (BooleanQuery) contents;
       BooleanClause[] bclauses = bq.getClauses();
       SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];
