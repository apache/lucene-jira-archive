Index: lucene/CHANGES.txt
===================================================================
--- lucene/CHANGES.txt	(revision 1701804)
+++ lucene/CHANGES.txt	(working copy)
@@ -96,6 +96,9 @@
 * LUCENE-6754: Optimized IndexSearcher.count for the cases when it can use
   index statistics instead of collecting all matches. (Adrien Grand)
 
+* LUCENE-6773: Nested conjunctions now iterate over documents as if clauses
+  were all at the same level. (Adrien Grand)
+
 Bug Fixes
 
 * LUCENE-6730: Hyper-parameter c is ignored in term frequency NormalizationH1.
Index: lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java	(revision 1701804)
+++ lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java	(working copy)
@@ -54,7 +54,9 @@
   /** Adds the iterator, possibly splitting up into two phases or collapsing if it is another conjunction */
   private static void addIterator(DocIdSetIterator disi, List<DocIdSetIterator> allIterators, List<TwoPhaseIterator> twoPhaseIterators) {
     // Check for exactly this class for collapsing. Subclasses can do their own optimizations.
-    if (disi.getClass() == ConjunctionDISI.class || disi.getClass() == TwoPhase.class) {
+    if (disi.getClass() == ConjunctionScorer.class) {
+      addIterator(((ConjunctionScorer) disi).disi, allIterators, twoPhaseIterators);
+    } else if (disi.getClass() == ConjunctionDISI.class || disi.getClass() == TwoPhase.class) {
       ConjunctionDISI conjunction = (ConjunctionDISI) disi;
       // subconjuctions have already split themselves into two phase iterators and others, so we can take those
       // iterators as they are and move them up to this conjunction
Index: lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java	(revision 1701804)
+++ lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java	(working copy)
@@ -25,9 +25,9 @@
 /** Scorer for conjunctions, sets of queries, all of which are required. */
 class ConjunctionScorer extends Scorer {
 
-  private final ConjunctionDISI disi;
-  private final Scorer[] scorers;
-  private final float coord;
+  final ConjunctionDISI disi;
+  final Scorer[] scorers;
+  final float coord;
 
   ConjunctionScorer(Weight weight, List<? extends DocIdSetIterator> required, List<Scorer> scorers) {
     this(weight, required, scorers, 1f);
Index: lucene/core/src/test/org/apache/lucene/search/TestConjunctionDISI.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/TestConjunctionDISI.java	(revision 1701804)
+++ lucene/core/src/test/org/apache/lucene/search/TestConjunctionDISI.java	(working copy)
@@ -19,6 +19,7 @@
 
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
 
@@ -246,7 +247,7 @@
     }
   }
 
-  public void testCollapseSubConjunctions() throws IOException {
+  public void testCollapseSubConjunctions(boolean wrapWithScorer) throws IOException {
     final int iters = atLeast(100);
     for (int iter = 0; iter < iters; ++iter) {
       final int maxDoc = TestUtil.nextInt(random(), 100, 10000);
@@ -273,7 +274,13 @@
       for (int subIter = 0; subIter < subIters && iterators.size() > 3; ++subIter) {
         final int subSeqStart = TestUtil.nextInt(random(), 0, iterators.size() - 2);
         final int subSeqEnd = TestUtil.nextInt(random(), subSeqStart + 2, iterators.size());
-        final ConjunctionDISI subConjunction = ConjunctionDISI.intersect(iterators.subList(subSeqStart, subSeqEnd));
+        List<DocIdSetIterator> subIterators = iterators.subList(subSeqStart, subSeqEnd);
+        DocIdSetIterator subConjunction;
+        if (wrapWithScorer) {
+          subConjunction = new ConjunctionScorer(null, subIterators, Collections.emptyList());
+        } else {
+          subConjunction = ConjunctionDISI.intersect(subIterators);
+        }
         iterators.set(subSeqStart, subConjunction);
         int toRemove = subSeqEnd - subSeqStart - 1;
         while (toRemove-- > 0) {
@@ -291,4 +298,11 @@
     }
   }
 
+  public void testCollapseSubConjunctionDISIs() throws IOException {
+    testCollapseSubConjunctions(false);
+  }
+
+  public void testCollapseSubConjunctionScorers() throws IOException {
+    testCollapseSubConjunctions(true);
+  }
 }
