Index: src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java	(date 1517520254000)
+++ src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java	(revision )
@@ -494,8 +494,7 @@
           //all coplanar
           return null;
         }
-        Plane nextPlane = new Plane(startPoint, nextPoint);
-        if (Math.abs(nextPlane.evaluate(endPoint)) > Vector.MINIMUM_RESOLUTION + leniencyValue) {
+        if (!pointsCoplanar(startPoint, endPoint, nextPoint)) {
           //no coplanar.
           break;
         }
@@ -521,6 +520,21 @@
     return safePath;
   }
 
+  /**
+   * Checks if three points are coplanar in any of the three planes they can describe.
+   *
+   * @param A The first point.
+   * @param B The second point.
+   * @param C The third point
+   * @return true if provided points are coplanar in any of the three planes they can describe.
+   */
+  static boolean pointsCoplanar(GeoPoint A, GeoPoint B, GeoPoint C) {
+    Plane AB = new Plane(A, B);
+    Plane AC = new Plane(A, C);
+    Plane BC = new Plane(B, C);
+    return AB.evaluateIsZero(C) ||  AC.evaluateIsZero(B) || BC.evaluateIsZero(A);
+  }
+
 
   /** Pick a random pole that has a good chance of being inside the polygon described by the points.
    * @param generator is the random number generator to use.
@@ -1079,12 +1093,19 @@
         break;
       }
       final Edge newLastEdge = edgeBuffer.getNext(lastEdge);
+      if (pointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newLastEdge.endPoint)) {
+        break;
+      }
       if (isWithin(newLastEdge.endPoint, includedEdges)) {
         //System.out.println(" maybe can extend to next edge");
         // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon
         // here will overlap with other remaining points?
         final SidedPlane returnBoundary;
         if (firstEdge.startPoint != newLastEdge.endPoint) {
+          if (pointsCoplanar(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint)
+              || pointsCoplanar(firstEdge.startPoint, newLastEdge.endPoint, newLastEdge.startPoint)) {
+            break;
+          }
           returnBoundary = new SidedPlane(firstEdge.endPoint, firstEdge.startPoint, newLastEdge.endPoint);
         } else {
           returnBoundary = null;
@@ -1135,12 +1156,19 @@
         break;
       }
       final Edge newFirstEdge = edgeBuffer.getPrevious(firstEdge);
+      if (pointsCoplanar(newFirstEdge.startPoint, newFirstEdge.endPoint, firstEdge.endPoint)) {
+        break;
+      }
       if (isWithin(newFirstEdge.startPoint, includedEdges)) {
         //System.out.println(" maybe can extend to previous edge");
         // Found a candidate for extension.  But do some other checks first.  Basically, we need to know if we construct a polygon
         // here will overlap with other remaining points?
         final SidedPlane returnBoundary;
         if (newFirstEdge.startPoint != lastEdge.endPoint) {
+          if(pointsCoplanar(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint)
+              || pointsCoplanar(lastEdge.endPoint, newFirstEdge.startPoint, newFirstEdge.endPoint)) {
+            break;
+          }
           returnBoundary = new SidedPlane(lastEdge.startPoint, lastEdge.endPoint, newFirstEdge.startPoint);
         } else {
           returnBoundary = null;
@@ -1225,27 +1253,6 @@
         edge = edgeBuffer.getNext(edge);
       }
       returnIsInternal = lastEdge.isInternal;
-      
-      // Look for coplanarity; abort if so
-      for (int i = 0; i < points.size(); i++) {
-        final GeoPoint start = points.get(i);
-        final GeoPoint end = points.get(getLegalIndex(i + 1, points.size()));
-        // We have to find the next point that is not on the plane between start and end.
-        // If there is no such point, it's an error.
-        final Plane planeToFind = new Plane(start, end);
-        int endPointIndex = -1;
-        for (int j = 0; j < points.size(); j++) {
-          final int index = getLegalIndex(j + i + 2, points.size());
-          if (!planeToFind.evaluateIsZero(points.get(index))) {
-            endPointIndex = index;
-            break;
-          }
-        }
-        if (endPointIndex == -1) {
-          return false;
-        }
-      }
-
       edgeBuffer.clear();
     } else {
       // Build the return edge (internal, of course)
@@ -1270,27 +1277,6 @@
         }
         edge = edgeBuffer.getNext(edge);
       }
-      
-      // Look for coplanarity; abort if so
-      for (int i = 0; i < points.size(); i++) {
-        final GeoPoint start = points.get(i);
-        final GeoPoint end = points.get(getLegalIndex(i + 1, points.size()));
-        // We have to find the next point that is not on the plane between start and end.
-        // If there is no such point, it's an error.
-        final Plane planeToFind = new Plane(start, end);
-        int endPointIndex = -1;
-        for (int j = 0; j < points.size(); j++) {
-          final int index = getLegalIndex(j + i + 2, points.size());
-          if (!planeToFind.evaluateIsZero(points.get(index))) {
-            endPointIndex = index;
-            break;
-          }
-        }
-        if (endPointIndex == -1) {
-          return false;
-        }
-      }
-
       // Modify the edge buffer
       edgeBuffer.replace(edges, returnEdge);
     }
