diff --git lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/DictionaryCompoundWordTokenFilterFactory.java lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/DictionaryCompoundWordTokenFilterFactory.java
index 8c88c08..d84a530 100644
--- lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/DictionaryCompoundWordTokenFilterFactory.java
+++ lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/DictionaryCompoundWordTokenFilterFactory.java
@@ -71,7 +71,7 @@ public class DictionaryCompoundWordTokenFilterFactory extends TokenFilterFactory
     if (dictionary == null) {
       return input;
     }
-    if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_4)) {
+    if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_4_0)) {
       return new DictionaryCompoundWordTokenFilter(input, dictionary, minWordSize, minSubwordSize, maxSubwordSize, onlyLongestMatch);
     }
     return new Lucene43DictionaryCompoundWordTokenFilter(input, dictionary, minWordSize, minSubwordSize, maxSubwordSize, onlyLongestMatch);
diff --git lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/HyphenationCompoundWordTokenFilterFactory.java lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/HyphenationCompoundWordTokenFilterFactory.java
index d7e9b33..0f587b6 100644
--- lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/HyphenationCompoundWordTokenFilterFactory.java
+++ lucene/analysis/common/src/java/org/apache/lucene/analysis/compound/HyphenationCompoundWordTokenFilterFactory.java
@@ -99,7 +99,7 @@ public class HyphenationCompoundWordTokenFilterFactory extends TokenFilterFactor
       final InputSource is = new InputSource(stream);
       is.setEncoding(encoding); // if it's null let xml parser decide
       is.setSystemId(hypFile);
-      if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_4)) {
+      if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_4_0)) {
         hyphenator = HyphenationCompoundWordTokenFilter.getHyphenationTree(is);
       } else {
         hyphenator = Lucene43HyphenationCompoundWordTokenFilter.getHyphenationTree(is);
@@ -111,7 +111,7 @@ public class HyphenationCompoundWordTokenFilterFactory extends TokenFilterFactor
   
   @Override
   public TokenFilter create(TokenStream input) {
-    if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_4)) {
+    if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_4_0)) {
       return new HyphenationCompoundWordTokenFilter(input, hyphenator, dictionary, minWordSize, minSubwordSize, maxSubwordSize, onlyLongestMatch);
     }
     return new Lucene43HyphenationCompoundWordTokenFilter(input, hyphenator, dictionary, minWordSize, minSubwordSize, maxSubwordSize, onlyLongestMatch);
diff --git lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/WordDelimiterFilterFactory.java lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/WordDelimiterFilterFactory.java
index 780b68e..123ed9e 100644
--- lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/WordDelimiterFilterFactory.java
+++ lucene/analysis/common/src/java/org/apache/lucene/analysis/miscellaneous/WordDelimiterFilterFactory.java
@@ -118,7 +118,7 @@ public class WordDelimiterFilterFactory extends TokenFilterFactory implements Re
 
   @Override
   public TokenFilter create(TokenStream input) {
-    if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_8)) {
+    if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_8_0)) {
       return new WordDelimiterFilter(input, typeTable == null ? WordDelimiterIterator.DEFAULT_WORD_DELIM_TABLE : typeTable,
                                    flags, protectedWords);
     } else {
diff --git lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramFilterFactory.java lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramFilterFactory.java
index 7e4a063..131dc57 100644
--- lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramFilterFactory.java
+++ lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramFilterFactory.java
@@ -50,7 +50,7 @@ public class EdgeNGramFilterFactory extends TokenFilterFactory {
 
   @Override
   public TokenFilter create(TokenStream input) {
-    if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_4)) {
+    if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_4_0)) {
       return new EdgeNGramTokenFilter(input, minGramSize, maxGramSize);
     }
     return new Lucene43EdgeNGramTokenFilter(input, minGramSize, maxGramSize);
diff --git lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramTokenizerFactory.java lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramTokenizerFactory.java
index 9772d3c..6931026 100644
--- lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramTokenizerFactory.java
+++ lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/EdgeNGramTokenizerFactory.java
@@ -22,7 +22,6 @@ import org.apache.lucene.analysis.util.TokenizerFactory;
 import org.apache.lucene.util.AttributeFactory;
 import org.apache.lucene.util.Version;
 
-import java.io.Reader;
 import java.util.Map;
 
 /**
@@ -50,7 +49,7 @@ public class EdgeNGramTokenizerFactory extends TokenizerFactory {
   
   @Override
   public Tokenizer create(AttributeFactory factory) {
-    if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_4)) {
+    if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_4_0)) {
       return new EdgeNGramTokenizer(factory, minGramSize, maxGramSize);
     }
     return new Lucene43NGramTokenizer(factory, minGramSize, maxGramSize);
diff --git lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/NGramFilterFactory.java lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/NGramFilterFactory.java
index 70e802b..99d2a11 100644
--- lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/NGramFilterFactory.java
+++ lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/NGramFilterFactory.java
@@ -50,7 +50,7 @@ public class NGramFilterFactory extends TokenFilterFactory {
 
   @Override
   public TokenFilter create(TokenStream input) {
-    if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_4)) {
+    if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_4_0)) {
       return new NGramTokenFilter(input, minGramSize, maxGramSize);
     }
     return new Lucene43NGramTokenFilter(input, minGramSize, maxGramSize);
diff --git lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/NGramTokenizerFactory.java lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/NGramTokenizerFactory.java
index de9a010..f096a4b 100644
--- lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/NGramTokenizerFactory.java
+++ lucene/analysis/common/src/java/org/apache/lucene/analysis/ngram/NGramTokenizerFactory.java
@@ -52,7 +52,7 @@ public class NGramTokenizerFactory extends TokenizerFactory {
   /** Creates the {@link TokenStream} of n-grams from the given {@link Reader} and {@link AttributeFactory}. */
   @Override
   public Tokenizer create(AttributeFactory factory) {
-    if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_4)) {
+    if (luceneMatchVersion.onOrAfter(Version.LUCENE_4_4_0)) {
       return new NGramTokenizer(factory, minGramSize, maxGramSize);
     } else {
       return new Lucene43NGramTokenizer(factory, minGramSize, maxGramSize);
diff --git lucene/analysis/common/src/java/org/apache/lucene/analysis/th/ThaiAnalyzer.java lucene/analysis/common/src/java/org/apache/lucene/analysis/th/ThaiAnalyzer.java
index b08e784..2ed72f4 100644
--- lucene/analysis/common/src/java/org/apache/lucene/analysis/th/ThaiAnalyzer.java
+++ lucene/analysis/common/src/java/org/apache/lucene/analysis/th/ThaiAnalyzer.java
@@ -98,7 +98,7 @@ public final class ThaiAnalyzer extends StopwordAnalyzerBase {
    */
   @Override
   protected TokenStreamComponents createComponents(String fieldName) {
-    if (getVersion().onOrAfter(Version.LUCENE_4_8)) {
+    if (getVersion().onOrAfter(Version.LUCENE_4_8_0)) {
       final Tokenizer source = new ThaiTokenizer();
       TokenStream result = new LowerCaseFilter(source);
       result = new StopFilter(result, stopwords);
diff --git lucene/analysis/common/src/java/org/apache/lucene/analysis/tr/TurkishAnalyzer.java lucene/analysis/common/src/java/org/apache/lucene/analysis/tr/TurkishAnalyzer.java
index 60e08a0..d74d3c9 100644
--- lucene/analysis/common/src/java/org/apache/lucene/analysis/tr/TurkishAnalyzer.java
+++ lucene/analysis/common/src/java/org/apache/lucene/analysis/tr/TurkishAnalyzer.java
@@ -119,7 +119,7 @@ public final class TurkishAnalyzer extends StopwordAnalyzerBase {
   protected TokenStreamComponents createComponents(String fieldName) {
     final Tokenizer source = new StandardTokenizer();
     TokenStream result = new StandardFilter(source);
-    if (getVersion().onOrAfter(Version.LUCENE_4_8)) {
+    if (getVersion().onOrAfter(Version.LUCENE_4_8_0)) {
       result = new ApostropheFilter(result);
     }
     result = new TurkishLowerCaseFilter(result);
diff --git lucene/analysis/common/src/test/org/apache/lucene/analysis/de/TestGermanAnalyzer.java lucene/analysis/common/src/test/org/apache/lucene/analysis/de/TestGermanAnalyzer.java
index fd0cf20..a909578 100644
--- lucene/analysis/common/src/test/org/apache/lucene/analysis/de/TestGermanAnalyzer.java
+++ lucene/analysis/common/src/test/org/apache/lucene/analysis/de/TestGermanAnalyzer.java
@@ -51,7 +51,7 @@ public class TestGermanAnalyzer extends BaseTokenStreamTestCase {
   }
   
   /** test some features of the new snowball filter
-   * these only pass with LUCENE_CURRENT, not if you use o.a.l.a.de.GermanStemmer
+   * these only pass with LATEST, not if you use o.a.l.a.de.GermanStemmer
    */
   public void testGermanSpecials() throws Exception {
     GermanAnalyzer a = new GermanAnalyzer();
diff --git lucene/analysis/smartcn/src/java/org/apache/lucene/analysis/cn/smart/SmartChineseAnalyzer.java lucene/analysis/smartcn/src/java/org/apache/lucene/analysis/cn/smart/SmartChineseAnalyzer.java
index 734117d..a268cc1 100644
--- lucene/analysis/smartcn/src/java/org/apache/lucene/analysis/cn/smart/SmartChineseAnalyzer.java
+++ lucene/analysis/smartcn/src/java/org/apache/lucene/analysis/cn/smart/SmartChineseAnalyzer.java
@@ -132,7 +132,7 @@ public final class SmartChineseAnalyzer extends Analyzer {
   public TokenStreamComponents createComponents(String fieldName) {
     final Tokenizer tokenizer;
     TokenStream result;
-    if (getVersion().onOrAfter(Version.LUCENE_4_8)) {
+    if (getVersion().onOrAfter(Version.LUCENE_4_8_0)) {
       tokenizer = new HMMChineseTokenizer();
       result = tokenizer;
     } else {
diff --git lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask.java lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask.java
index a78693a..48ada22 100644
--- lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask.java
+++ lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/AnalyzerFactoryTask.java
@@ -59,7 +59,7 @@ import java.util.regex.Pattern;
  * </ol>
  *
  * Each component analysis factory map specify <tt>luceneMatchVersion</tt> (defaults to
- * {@link Version#LUCENE_CURRENT}) and any of the args understood by the specified
+ * {@link Version#LATEST}) and any of the args understood by the specified
  * *Factory class, in the above-describe param format.
  * <p/>
  * Example:
@@ -68,7 +68,7 @@ import java.util.regex.Pattern;
  *                      positionIncrementGap:100,
  *                      HTMLStripCharFilter,
  *                      MappingCharFilter(mapping:'mapping-FoldToASCII.txt'),
- *                      WhitespaceTokenizer(luceneMatchVersion:LUCENE_5_0),
+ *                      WhitespaceTokenizer(luceneMatchVersion:LUCENE_5_0_0),
  *                      TokenLimitFilter(maxTokenCount:10000, consumeAllTokens:false))
  *     [...]
  *     -NewAnalyzer('strip html, fold to ascii, whitespace tokenize, max 10k tokens')
@@ -355,7 +355,7 @@ public class AnalyzerFactoryTask extends PerfTask {
         }
       }
       if (!argMap.containsKey("luceneMatchVersion")) {
-        argMap.put("luceneMatchVersion", Version.LUCENE_CURRENT.toString());
+        argMap.put("luceneMatchVersion", Version.LATEST.toString());
       }
       final AbstractAnalysisFactory instance;
       try {
diff --git lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/NewAnalyzerTask.java lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/NewAnalyzerTask.java
index cb8ea74..c3e02e3 100644
--- lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/NewAnalyzerTask.java
+++ lucene/benchmark/src/java/org/apache/lucene/benchmark/byTask/tasks/NewAnalyzerTask.java
@@ -16,9 +16,6 @@ package org.apache.lucene.benchmark.byTask.tasks;
  */
 
 import org.apache.lucene.analysis.Analyzer;
-import org.apache.lucene.analysis.util.CharFilterFactory;
-import org.apache.lucene.analysis.util.TokenFilterFactory;
-import org.apache.lucene.analysis.util.TokenizerFactory;
 import org.apache.lucene.benchmark.byTask.PerfRunData;
 import org.apache.lucene.benchmark.byTask.utils.AnalyzerFactory;
 import org.apache.lucene.util.Version;
@@ -47,7 +44,7 @@ public class NewAnalyzerTask extends PerfTask {
     try {
       // first try to use a ctor with version parameter (needed for many new Analyzers that have no default one anymore
       Constructor<? extends Analyzer> cnstr = clazz.getConstructor(Version.class);
-      return cnstr.newInstance(Version.LUCENE_CURRENT);
+      return cnstr.newInstance(Version.LATEST);
     } catch (NoSuchMethodException nsme) {
       // otherwise use default ctor
       return clazz.newInstance();
diff --git lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTaskTest.java lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTaskTest.java
index 8a8e485..94b4a20 100644
--- lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTaskTest.java
+++ lucene/benchmark/src/test/org/apache/lucene/benchmark/byTask/tasks/CreateIndexTaskTest.java
@@ -38,7 +38,7 @@ public class CreateIndexTaskTest extends BenchmarkTestCase {
   private PerfRunData createPerfRunData(String infoStreamValue) throws Exception {
     Properties props = new Properties();
     // :Post-Release-Update-Version.LUCENE_XY:
-    props.setProperty("writer.version", Version.LUCENE_5_0.toString());
+    props.setProperty("writer.version", Version.LUCENE_5_0_0.toString());
     props.setProperty("print.props", "false"); // don't print anything
     props.setProperty("directory", "RAMDirectory");
     if (infoStreamValue != null) {
diff --git lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoReader.java lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoReader.java
index 13a97e2..1a416d9 100644
--- lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoReader.java
+++ lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoReader.java
@@ -42,6 +42,7 @@ import org.apache.lucene.store.IOContext;
 import org.apache.lucene.util.BytesRefBuilder;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.StringHelper;
+import org.apache.lucene.util.Version;
 
 /**
  * reads plaintext segments files
@@ -60,7 +61,7 @@ public class SimpleTextSegmentInfoReader extends SegmentInfoReader {
     try {
       SimpleTextUtil.readLine(input, scratch);
       assert StringHelper.startsWith(scratch.get(), SI_VERSION);
-      final String version = readString(SI_VERSION.length, scratch);
+      final Version version = Version.parse(readString(SI_VERSION.length, scratch));
     
       SimpleTextUtil.readLine(input, scratch);
       assert StringHelper.startsWith(scratch.get(), SI_DOCCOUNT);
diff --git lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoWriter.java lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoWriter.java
index e840239..38f15fa 100644
--- lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoWriter.java
+++ lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextSegmentInfoWriter.java
@@ -62,7 +62,7 @@ public class SimpleTextSegmentInfoWriter extends SegmentInfoWriter {
       BytesRefBuilder scratch = new BytesRefBuilder();
     
       SimpleTextUtil.write(output, SI_VERSION);
-      SimpleTextUtil.write(output, si.getVersion(), scratch);
+      SimpleTextUtil.write(output, si.getVersion().toString(), scratch);
       SimpleTextUtil.writeNewline(output);
     
       SimpleTextUtil.write(output, SI_DOCCOUNT);
diff --git lucene/common-build.xml lucene/common-build.xml
index ad32fb3..c4ec683 100644
--- lucene/common-build.xml
+++ lucene/common-build.xml
@@ -26,6 +26,14 @@
     for standalone use.
   </description>
 
+  <!-- !!! RELEASE MANAGER: Change version numbers only here: !!! -->
+  
+  <!-- The base version of the next release (including bugfix number, e.g., x.y.z+): -->
+  <property name="version.base" value="5.0.0"/>
+
+  
+  <!-- !!! RELEASE MANAGER: Don't change anything after this line! !!! -->
+
   <dirname file="${ant.file.common}" property="common.dir"/>
   <property name="dev-tools.dir" location="${common.dir}/../dev-tools"/>
   <property name="prettify.dir" location="${common.dir}/tools/prettify"/>
@@ -48,14 +56,31 @@
   </tstamp>
 
   <property name="Name" value="Lucene"/>
-  
   <property name="name" value="${ant.project.name}"/>
-  <property name="tests.luceneMatchVersion" value="5.0"/>
-  <property name="dev.version.base" value="5.0"/>
-  <property name="dev.version.suffix" value="SNAPSHOT"/>
-  <property name="dev.version" value="${dev.version.base}-${dev.version.suffix}"/>
-  <property name="version" value="${dev.version}"/>
-  <property name="spec.version" value="${version}"/>	
+  
+  <!--TODO: remove once Jenkins jobs are updated:--><property name="dev.version.suffix" value="SNAPSHOT"/>
+
+  <!-- The corresponding version as oal.util.Version used for matchVersion (x.y): -->
+  <property name="version.luceneMatchVersion" value="${version.base}"/>
+  <!-- Suffix of the version, by default SNAPSHOT: -->
+  <property name="version.suffix" value="${dev.version.suffix}"/>
+  <property name="version" value="${version.base}-${version.suffix}"/>
+
+  
+  <fail message="If you pass -Dversion=... to set a release version, it must match &quot;${version.base}&quot;, optionally followed by a suffix (e.g., &quot;-SNAPSHOT&quot;).">
+    <condition>
+      <not><matches pattern="^\Q${version.base}\E(|\-.*)$" casesensitive="true" string="${version}"/></not>
+    </condition>
+  </fail>
+
+  <fail message="Invalid version.luceneMatchVersion property: ${version.luceneMatchVersion}">
+    <condition>
+      <not><and>
+        <matches pattern="^\d+\.\d+\.\d+$" casesensitive="true" string="${version.luceneMatchVersion}"/>
+        <matches pattern="^\Q${version.luceneMatchVersion}\E(\.|\-|\b).*$" casesensitive="true" string="${version}"/>
+      </and></not>
+    </condition>
+  </fail>
 
   <property name="year" value="2000-${current.year}"/>
   
@@ -118,6 +143,7 @@
   <property name="tests.verbose" value="false"/>
   <property name="tests.infostream" value="${tests.verbose}"/>
   <property name="tests.filterstacks" value="true"/>
+  <property name="tests.luceneMatchVersion" value="${version.luceneMatchVersion}"/>
 
   <condition property="tests.heapsize" value="768M">
     <isset property="run.clover"/>
@@ -640,7 +666,7 @@
     <attribute name="excludes" default="**/pom.xml,**/*.iml"/>
     <attribute name="metainf.source.dir" default="${common.dir}"/>
     <attribute name="implementation.title" default="org.apache.lucene"/>
-    <attribute name="spec.version" default="${spec.version}"/>
+    <attribute name="spec.version" default="${version}"/>
     <attribute name="manifest.file" default="${manifest.file}"/>
     <element name="filesets" optional="true"/>
     <element name="jarify-additional-manifest-attributes" optional="true"/>
@@ -986,7 +1012,7 @@
             <sysproperty key="java.security.manager" value="org.apache.lucene.util.TestSecurityManager" />
             <sysproperty key="java.security.policy" file="${common.dir}/tools/junit4/tests.policy" />
 
-            <sysproperty key="lucene.version" value="${version}"/>
+            <sysproperty key="tests.LUCENE_VERSION" value="${version.base}"/>
 
             <sysproperty key="jetty.testMode" value="1"/>
             <sysproperty key="jetty.insecurerandom" value="1"/>
diff --git lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java
index d3aabd5..d064dd2 100644
--- lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java
+++ lucene/core/src/java/org/apache/lucene/analysis/Analyzer.java
@@ -72,7 +72,7 @@ import java.util.Map;
 public abstract class Analyzer implements Closeable {
 
   private final ReuseStrategy reuseStrategy;
-  private Version version = Version.LUCENE_CURRENT;
+  private Version version = Version.LATEST;
 
   // non final as it gets nulled if closed; pkg private for access by ReuseStrategy's final helper methods:
   CloseableThreadLocal<Object> storedValue = new CloseableThreadLocal<>();
diff --git lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java
index 188af99..078b1ae 100644
--- lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java
+++ lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoReader.java
@@ -30,6 +30,7 @@ import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.IndexInput;
 import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.Version;
 
 /**
  * Lucene 4.0 implementation of {@link SegmentInfoReader}.
@@ -54,7 +55,7 @@ public class Lucene40SegmentInfoReader extends SegmentInfoReader {
       CodecUtil.checkHeader(input, Lucene40SegmentInfoFormat.CODEC_NAME,
                                    Lucene40SegmentInfoFormat.VERSION_START,
                                    Lucene40SegmentInfoFormat.VERSION_CURRENT);
-      final String version = input.readString();
+      final Version version = Version.parse(input.readString());
       final int docCount = input.readInt();
       if (docCount < 0) {
         throw new CorruptIndexException("invalid docCount: " + docCount + " (resource=" + input + ")");
diff --git lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java
index 7cd433b..b5f182c 100644
--- lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java
+++ lucene/core/src/java/org/apache/lucene/codecs/lucene40/Lucene40SegmentInfoWriter.java
@@ -55,7 +55,7 @@ public class Lucene40SegmentInfoWriter extends SegmentInfoWriter {
     try {
       CodecUtil.writeHeader(output, Lucene40SegmentInfoFormat.CODEC_NAME, Lucene40SegmentInfoFormat.VERSION_CURRENT);
       // Write the Lucene version that created this segment, since 3.1
-      output.writeString(si.getVersion());
+      output.writeString(si.getVersion().toString());
       output.writeInt(si.getDocCount());
 
       output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));
diff --git lucene/core/src/java/org/apache/lucene/codecs/lucene45/Lucene45DocValuesProducer.java lucene/core/src/java/org/apache/lucene/codecs/lucene45/Lucene45DocValuesProducer.java
index f09078e..7dedb33 100644
--- lucene/core/src/java/org/apache/lucene/codecs/lucene45/Lucene45DocValuesProducer.java
+++ lucene/core/src/java/org/apache/lucene/codecs/lucene45/Lucene45DocValuesProducer.java
@@ -91,8 +91,8 @@ class Lucene45DocValuesProducer extends DocValuesProducer implements Closeable {
   /** expert: instantiates a new reader */
   @SuppressWarnings("deprecation")
   protected Lucene45DocValuesProducer(SegmentReadState state, String dataCodec, String dataExtension, String metaCodec, String metaExtension) throws IOException {
-    String ver = state.segmentInfo.getVersion();
-    lenientFieldInfoCheck = StringHelper.getVersionComparator().compare(ver, "4.9.0") < 0;
+    Version ver = state.segmentInfo.getVersion();
+    lenientFieldInfoCheck = Version.LUCENE_4_9_0.onOrAfter(ver);
     String metaName = IndexFileNames.segmentFileName(state.segmentInfo.name, state.segmentSuffix, metaExtension);
     // read in the entries from the metadata file.
     ChecksumIndexInput in = state.directory.openChecksumInput(metaName, state.context);
diff --git lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java
index 6a1cb6b..5e9e611 100755
--- lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java
+++ lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoReader.java
@@ -30,6 +30,7 @@ import org.apache.lucene.store.ChecksumIndexInput;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.util.IOUtils;
+import org.apache.lucene.util.Version;
 
 /**
  * Lucene 4.6 implementation of {@link SegmentInfoReader}.
@@ -52,7 +53,7 @@ public class Lucene46SegmentInfoReader extends SegmentInfoReader {
       int codecVersion = CodecUtil.checkHeader(input, Lucene46SegmentInfoFormat.CODEC_NAME,
                                                       Lucene46SegmentInfoFormat.VERSION_START,
                                                       Lucene46SegmentInfoFormat.VERSION_CURRENT);
-      final String version = input.readString();
+      final Version version = Version.parse(input.readString());
       final int docCount = input.readInt();
       if (docCount < 0) {
         throw new CorruptIndexException("invalid docCount: " + docCount + " (resource=" + input + ")");
diff --git lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java
index af03f40..7e51e19 100755
--- lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java
+++ lucene/core/src/java/org/apache/lucene/codecs/lucene46/Lucene46SegmentInfoWriter.java
@@ -53,7 +53,7 @@ public class Lucene46SegmentInfoWriter extends SegmentInfoWriter {
     try {
       CodecUtil.writeHeader(output, Lucene46SegmentInfoFormat.CODEC_NAME, Lucene46SegmentInfoFormat.VERSION_CURRENT);
       // Write the Lucene version that created this segment, since 3.1
-      output.writeString(si.getVersion());
+      output.writeString(si.getVersion().toString());
       output.writeInt(si.getDocCount());
 
       output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));
diff --git lucene/core/src/java/org/apache/lucene/index/CheckIndex.java lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
index 0eb8da8..f41a9f7 100644
--- lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
+++ lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
@@ -22,7 +22,6 @@ import java.io.IOException;
 import java.io.PrintStream;
 import java.text.NumberFormat;
 import java.util.ArrayList;
-import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Locale;
@@ -46,7 +45,7 @@ import org.apache.lucene.util.CommandLineUtil;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LongBitSet;
-import org.apache.lucene.util.StringHelper;
+import org.apache.lucene.util.Version;
 
 
 /**
@@ -409,21 +408,19 @@ public class CheckIndex {
     }
 
     // find the oldest and newest segment versions
-    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);
+    Version oldest = null;
+    Version newest = null;
     String oldSegs = null;
-    boolean foundNonNullVersion = false;
-    Comparator<String> versionComparator = StringHelper.getVersionComparator();
     for (SegmentCommitInfo si : sis) {
-      String version = si.info.getVersion();
+      Version version = si.info.getVersion();
       if (version == null) {
         // pre-3.1 segment
         oldSegs = "pre-3.1";
       } else {
-        foundNonNullVersion = true;
-        if (versionComparator.compare(version, oldest) < 0) {
+        if (oldest == null || version.onOrAfter(oldest) == false) {
           oldest = version;
         }
-        if (versionComparator.compare(version, newest) > 0) {
+        if (newest == null || version.onOrAfter(newest)) {
           newest = version;
         }
       }
@@ -475,14 +472,14 @@ public class CheckIndex {
       userDataString = "";
     }
 
-    String versionString = null;
+    String versionString = "";
     if (oldSegs != null) {
-      if (foundNonNullVersion) {
+      if (newest != null) {
         versionString = "versions=[" + oldSegs + " .. " + newest + "]";
       } else {
         versionString = "version=" + oldSegs;
       }
-    } else {
+    } else if (newest != null) { // implies oldest != null
       versionString = oldest.equals(newest) ? ( "version=" + oldest ) : ("versions=[" + oldest + " .. " + newest + "]");
     }
 
@@ -527,8 +524,8 @@ public class CheckIndex {
       segInfoStat.name = info.info.name;
       segInfoStat.docCount = info.info.getDocCount();
       
-      final String version = info.info.getVersion();
-      if (info.info.getDocCount() <= 0 && version != null && versionComparator.compare(version, "4.5") >= 0) {
+      final Version version = info.info.getVersion();
+      if (info.info.getDocCount() <= 0 && version != null && version.onOrAfter(Version.LUCENE_4_5_0)) {
         throw new RuntimeException("illegal number of documents: maxDoc=" + info.info.getDocCount());
       }
 
diff --git lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread.java lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread.java
index 048b615..0307285 100644
--- lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread.java
+++ lucene/core/src/java/org/apache/lucene/index/DocumentsWriterPerThread.java
@@ -34,12 +34,12 @@ import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.TrackingDirectoryWrapper;
 import org.apache.lucene.util.ByteBlockPool.Allocator;
 import org.apache.lucene.util.ByteBlockPool.DirectTrackingAllocator;
-import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.Counter;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.IntBlockPool;
 import org.apache.lucene.util.MutableBits;
 import org.apache.lucene.util.RamUsageEstimator;
+import org.apache.lucene.util.Version;
 
 import static org.apache.lucene.util.ByteBlockPool.BYTE_BLOCK_MASK;
 import static org.apache.lucene.util.ByteBlockPool.BYTE_BLOCK_SIZE;
@@ -178,7 +178,7 @@ class DocumentsWriterPerThread {
     pendingUpdates.clear();
     deleteSlice = deleteQueue.newSlice();
    
-    segmentInfo = new SegmentInfo(directoryOrig, Constants.LUCENE_MAIN_VERSION, segmentName, -1, false, codec, null);
+    segmentInfo = new SegmentInfo(directoryOrig, Version.LATEST, segmentName, -1, false, codec, null);
     assert numDocsInRAM == 0;
     if (INFO_VERBOSE && infoStream.isEnabled("DWPT")) {
       infoStream.message("DWPT", Thread.currentThread().getName() + " init seg=" + segmentName + " delQueue=" + deleteQueue);  
diff --git lucene/core/src/java/org/apache/lucene/index/IndexUpgrader.java lucene/core/src/java/org/apache/lucene/index/IndexUpgrader.java
index f168be1..99c9360 100644
--- lucene/core/src/java/org/apache/lucene/index/IndexUpgrader.java
+++ lucene/core/src/java/org/apache/lucene/index/IndexUpgrader.java
@@ -20,9 +20,9 @@ package org.apache.lucene.index;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.FSDirectory;
 import org.apache.lucene.util.CommandLineUtil;
-import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.PrintStreamInfoStream;
+import org.apache.lucene.util.Version;
 
 import java.io.File;
 import java.io.IOException;
@@ -160,11 +160,11 @@ public final class IndexUpgrader {
     try {
       InfoStream infoStream = iwc.getInfoStream();
       if (infoStream.isEnabled("IndexUpgrader")) {
-        infoStream.message("IndexUpgrader", "Upgrading all pre-" + Constants.LUCENE_MAIN_VERSION + " segments of index directory '" + dir + "' to version " + Constants.LUCENE_MAIN_VERSION + "...");
+        infoStream.message("IndexUpgrader", "Upgrading all pre-" + Version.LATEST + " segments of index directory '" + dir + "' to version " + Version.LATEST + "...");
       }
       w.forceMerge(1);
       if (infoStream.isEnabled("IndexUpgrader")) {
-        infoStream.message("IndexUpgrader", "All segments upgraded to version " + Constants.LUCENE_MAIN_VERSION);
+        infoStream.message("IndexUpgrader", "All segments upgraded to version " + Version.LATEST);
       }
     } finally {
       w.close();
diff --git lucene/core/src/java/org/apache/lucene/index/IndexWriter.java lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
index 074994a..e9252e4 100644
--- lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
+++ lucene/core/src/java/org/apache/lucene/index/IndexWriter.java
@@ -64,6 +64,7 @@ import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.ThreadInterruptedException;
+import org.apache.lucene.util.Version;
 
 /**
   An <code>IndexWriter</code> creates and maintains an index.
@@ -883,7 +884,7 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable {
       didMessageState = true;
       infoStream.message("IW", "\ndir=" + directory + "\n" +
             "index=" + segString() + "\n" +
-            "version=" + Constants.LUCENE_VERSION + "\n" +
+            "version=" + Version.LATEST.toString() + "\n" +
             config.toString());
     }
   }
@@ -2569,7 +2570,7 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable {
       // abortable so that IW.close(false) is able to stop it
       TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(directory);
 
-      SegmentInfo info = new SegmentInfo(directory, Constants.LUCENE_MAIN_VERSION, mergedName, -1,
+      SegmentInfo info = new SegmentInfo(directory, Version.LATEST, mergedName, -1,
                                          false, codec, null);
 
       SegmentMerger merger = new SegmentMerger(mergeReaders, info, infoStream, trackingDir,
@@ -3793,7 +3794,7 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable {
     // ConcurrentMergePolicy we keep deterministic segment
     // names.
     final String mergeSegmentName = newSegmentName();
-    SegmentInfo si = new SegmentInfo(directory, Constants.LUCENE_MAIN_VERSION, mergeSegmentName, -1, false, codec, null);
+    SegmentInfo si = new SegmentInfo(directory, Version.LATEST, mergeSegmentName, -1, false, codec, null);
     Map<String,String> details = new HashMap<>();
     details.put("mergeMaxNumSegments", "" + merge.maxNumSegments);
     details.put("mergeFactor", Integer.toString(merge.segments.size()));
@@ -3817,7 +3818,7 @@ public class IndexWriter implements Closeable, TwoPhaseCommit, Accountable {
   private static void setDiagnostics(SegmentInfo info, String source, Map<String,String> details) {
     Map<String,String> diagnostics = new HashMap<>();
     diagnostics.put("source", source);
-    diagnostics.put("lucene.version", Constants.LUCENE_VERSION);
+    diagnostics.put("lucene.version", Version.LATEST.toString());
     diagnostics.put("os", Constants.OS_NAME);
     diagnostics.put("os.arch", Constants.OS_ARCH);
     diagnostics.put("os.version", Constants.OS_VERSION);
diff --git lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java
index 8b0b6e8..d4ac8ca 100644
--- lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java
+++ lucene/core/src/java/org/apache/lucene/index/SegmentInfo.java
@@ -27,6 +27,9 @@ import java.util.regex.Matcher;
 import org.apache.lucene.codecs.Codec;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.TrackingDirectoryWrapper;
+import org.apache.lucene.util.Constants;
+import org.apache.lucene.util.StringHelper;
+import org.apache.lucene.util.Version;
 
 /**
  * Information about a segment such as it's name, directory, and files related
@@ -62,9 +65,9 @@ public final class SegmentInfo {
   // Tracks the Lucene version this segment was created with, since 3.1. Null
   // indicates an older than 3.0 index, and it's used to detect a too old index.
   // The format expected is "x.y" - "2.x" for pre-3.0 indexes (or null), and
-  // specific versions afterwards ("3.0", "3.1" etc.).
-  // see Constants.LUCENE_MAIN_VERSION.
-  private String version;
+  // specific versions afterwards ("3.0.0", "3.1.0" etc.).
+  // see o.a.l.util.Version.
+  private Version version;
 
   void setDiagnostics(Map<String, String> diagnostics) {
     this.diagnostics = diagnostics;
@@ -81,7 +84,7 @@ public final class SegmentInfo {
    * <p>Note: this is public only to allow access from
    * the codecs package.</p>
    */
-  public SegmentInfo(Directory dir, String version, String name, int docCount, 
+  public SegmentInfo(Directory dir, Version version, String name, int docCount,
                      boolean isCompoundFile, Codec codec, Map<String,String> diagnostics) {
     assert !(dir instanceof TrackingDirectoryWrapper);
     this.dir = dir;
@@ -203,23 +206,9 @@ public final class SegmentInfo {
     return dir.hashCode() + name.hashCode();
   }
 
-  /**
-   * Used by DefaultSegmentInfosReader to upgrade a 3.0 segment to record its
-   * version is "3.0". This method can be removed when we're not required to
-   * support 3x indexes anymore, e.g. in 5.0.
-   * <p>
-   * <b>NOTE:</b> this method is used for internal purposes only - you should
-   * not modify the version of a SegmentInfo, or it may result in unexpected
-   * exceptions thrown when you attempt to open the index.
-   *
-   * @lucene.internal
+  /** Returns the version of the code which wrote the segment.
    */
-  public void setVersion(String version) {
-    this.version = version;
-  }
-
-  /** Returns the version of the code which wrote the segment. */
-  public String getVersion() {
+  public Version getVersion() {
     return version;
   }
 
diff --git lucene/core/src/java/org/apache/lucene/index/SegmentReader.java lucene/core/src/java/org/apache/lucene/index/SegmentReader.java
index b8b5abc..3f4de57 100644
--- lucene/core/src/java/org/apache/lucene/index/SegmentReader.java
+++ lucene/core/src/java/org/apache/lucene/index/SegmentReader.java
@@ -200,8 +200,8 @@ public final class SegmentReader extends AtomicReader implements Accountable {
       return;
     }
 
-    String ver = si.info.getVersion();
-    if (ver != null && StringHelper.getVersionComparator().compare(ver, "4.9.0") >= 0) {
+    Version ver = si.info.getVersion();
+    if (ver != null && ver.onOrAfter(Version.LUCENE_4_9_0)) {
       DocValuesProducer baseProducer = null;
       for (FieldInfo fi : fieldInfos) {
         if (!fi.hasDocValues()) continue;
diff --git lucene/core/src/java/org/apache/lucene/index/UpgradeIndexMergePolicy.java lucene/core/src/java/org/apache/lucene/index/UpgradeIndexMergePolicy.java
index 7781df3..9374e64 100644
--- lucene/core/src/java/org/apache/lucene/index/UpgradeIndexMergePolicy.java
+++ lucene/core/src/java/org/apache/lucene/index/UpgradeIndexMergePolicy.java
@@ -17,7 +17,7 @@ package org.apache.lucene.index;
  * limitations under the License.
  */
 
-import org.apache.lucene.util.Constants;
+import org.apache.lucene.util.Version;
 
 import java.io.IOException;
 import java.util.ArrayList;
@@ -60,12 +60,12 @@ public class UpgradeIndexMergePolicy extends MergePolicy {
   }
   
   /** Returns if the given segment should be upgraded. The default implementation
-   * will return {@code !Constants.LUCENE_MAIN_VERSION.equals(si.getVersion())},
+   * will return {@code !Version.LATEST.equals(si.getVersion())},
    * so all segments created with a different version number than this Lucene version will
    * get upgraded.
    */
   protected boolean shouldUpgradeSegment(SegmentCommitInfo si) {
-    return !Constants.LUCENE_MAIN_VERSION.equals(si.info.getVersion());
+    return !Version.LATEST.equals(si.info.getVersion());
   }
 
   @Override
diff --git lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory.java lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory.java
index 8f79fd9..7719dc3 100644
--- lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory.java
+++ lucene/core/src/java/org/apache/lucene/store/NRTCachingDirectory.java
@@ -52,7 +52,7 @@ import org.apache.lucene.util.IOUtils;
  * <pre class="prettyprint">
  *   Directory fsDir = FSDirectory.open(new File("/path/to/index"));
  *   NRTCachingDirectory cachedFSDir = new NRTCachingDirectory(fsDir, 5.0, 60.0);
- *   IndexWriterConfig conf = new IndexWriterConfig(Version.LUCENE_5_0, analyzer);
+ *   IndexWriterConfig conf = new IndexWriterConfig(Version.LUCENE_5_0_0, analyzer);
  *   IndexWriter writer = new IndexWriter(cachedFSDir, conf);
  * </pre>
  *
diff --git lucene/core/src/java/org/apache/lucene/util/Constants.java lucene/core/src/java/org/apache/lucene/util/Constants.java
index a5c8d9f..74261e2 100644
--- lucene/core/src/java/org/apache/lucene/util/Constants.java
+++ lucene/core/src/java/org/apache/lucene/util/Constants.java
@@ -19,7 +19,6 @@ package org.apache.lucene.util;
 
 import java.lang.reflect.Field;
 import java.util.Collections;
-import org.apache.lucene.LucenePackage;
 
 /**
  * Some useful constants.
@@ -93,45 +92,18 @@ public final class Constants {
     JRE_IS_MINIMUM_JAVA8 = v8;
   }
 
-  // this method prevents inlining the final version constant in compiled classes,
-  // see: http://www.javaworld.com/community/node/3400
-  private static String ident(final String s) {
-    return s.toString();
-  }
-  
-  // We should never change index format with minor versions, so it should always be x.y or x.y.0.z for alpha/beta versions!
-  /**
-   * This is the internal Lucene version, recorded into each segment.
-   * NOTE: we track per-segment version as a String with the {@code "X.Y"} format
-   * (no minor version), e.g. {@code "4.0", "3.1", "3.0"}.
-   * <p>Alpha and Beta versions will have numbers like {@code "X.Y.0.Z"},
-   * anything else is not allowed. This is done to prevent people from
-   * using indexes created with ALPHA/BETA versions with the released version.
-   */
-  public static final String LUCENE_MAIN_VERSION = ident("5.0");
-
   /**
-   * This is the Lucene version for display purposes.
+   * This is the internal Lucene version, including bugfix versions, recorded into each segment.
+   * @deprecated Use {@link Version#LATEST#toString()}
    */
-  public static final String LUCENE_VERSION;
-  static {
-    Package pkg = LucenePackage.get();
-    String v = (pkg == null) ? null : pkg.getImplementationVersion();
-    if (v == null) {
-      v = mainVersionWithoutAlphaBeta() + "-SNAPSHOT";
-    }
-    LUCENE_VERSION = ident(v);
-  }
+  @Deprecated
+  public static final String LUCENE_MAIN_VERSION = Version.LATEST.toString();
   
   /**
-   * Returns a LUCENE_MAIN_VERSION without any ALPHA/BETA qualifier
-   * Used by test only!
+   * Don't use this constant because the name is not self-describing!
+   * @deprecated Use {@link Version#LATEST#toString()}
    */
-  static String mainVersionWithoutAlphaBeta() {
-    final String parts[] = LUCENE_MAIN_VERSION.split("\\.");
-    if (parts.length == 4 && "0".equals(parts[2])) {
-      return parts[0] + "." + parts[1];
-    }
-    return LUCENE_MAIN_VERSION;
-  }
+  @Deprecated
+  public static final String LUCENE_VERSION = Version.LATEST.toString();
+  
 }
diff --git lucene/core/src/java/org/apache/lucene/util/StringHelper.java lucene/core/src/java/org/apache/lucene/util/StringHelper.java
index f759d21..3a753de 100644
--- lucene/core/src/java/org/apache/lucene/util/StringHelper.java
+++ lucene/core/src/java/org/apache/lucene/util/StringHelper.java
@@ -66,45 +66,6 @@ public abstract class StringHelper {
 
   private StringHelper() {
   }
-  
-  /**
-   * @return a Comparator over versioned strings such as X.YY.Z
-   * @lucene.internal
-   */
-  public static Comparator<String> getVersionComparator() {
-    return versionComparator;
-  }
-  
-  private static Comparator<String> versionComparator = new Comparator<String>() {
-    @Override
-    public int compare(String a, String b) {
-      StringTokenizer aTokens = new StringTokenizer(a, ".");
-      StringTokenizer bTokens = new StringTokenizer(b, ".");
-      
-      while (aTokens.hasMoreTokens()) {
-        int aToken = Integer.parseInt(aTokens.nextToken());
-        if (bTokens.hasMoreTokens()) {
-          int bToken = Integer.parseInt(bTokens.nextToken());
-          if (aToken != bToken) {
-            return aToken < bToken ? -1 : 1;
-          }
-        } else {
-          // a has some extra trailing tokens. if these are all zeroes, thats ok.
-          if (aToken != 0) {
-            return 1; 
-          }
-        }
-      }
-      
-      // b has some extra trailing tokens. if these are all zeroes, thats ok.
-      while (bTokens.hasMoreTokens()) {
-        if (Integer.parseInt(bTokens.nextToken()) != 0)
-          return -1;
-      }
-      
-      return 0;
-    }
-  };
 
   public static boolean equals(String s1, String s2) {
     if (s1 == null) {
diff --git lucene/core/src/java/org/apache/lucene/util/Version.java lucene/core/src/java/org/apache/lucene/util/Version.java
index bb6157c..3f12936 100644
--- lucene/core/src/java/org/apache/lucene/util/Version.java
+++ lucene/core/src/java/org/apache/lucene/util/Version.java
@@ -29,95 +29,158 @@ import java.util.Locale;
  * change the version at search-time, but instead also adjust
  * your indexing code to match, and re-index.
  */
-// remove me when java 5 is no longer supported
-// this is a workaround for a JDK bug that wrongly emits a warning.
-@SuppressWarnings("dep-ann")
-public enum Version { 
+public final class Version {
+
   /**
-   * Match settings and bugs in Lucene's 4.0 release.
+   * Match settings and bugs in Lucene's 4.0.0-ALPHA release.
    * @deprecated (5.0) Use latest
    */
   @Deprecated
-  LUCENE_4_0,
+  public static final Version LUCENE_4_0_0_ALPHA = new Version(4, 0, 0, 1);
+
+  /**
+   * Match settings and bugs in Lucene's 4.0.0-BETA release.
+   * @deprecated (5.0) Use latest
+   */
+  @Deprecated
+  public static final Version LUCENE_4_0_0_BETA = new Version(4, 0, 0, 2);
+
+  /**
+   * Match settings and bugs in Lucene's 4.0.0 release.
+   * @deprecated (5.0) Use latest
+   */
+  @Deprecated
+  public static final Version LUCENE_4_0_0 = new Version(4, 0, 0);
   
   /**
-   * Match settings and bugs in Lucene's 4.1 release.
+   * Match settings and bugs in Lucene's 4.1.0 release.
    * @deprecated (5.0) Use latest
    */
   @Deprecated
-  LUCENE_4_1,
+  public static final Version LUCENE_4_1_0 = new Version(4, 1, 0);
 
   /**
-   * Match settings and bugs in Lucene's 4.2 release.
+   * Match settings and bugs in Lucene's 4.2.0 release.
    * @deprecated (5.0) Use latest
    */
   @Deprecated
-  LUCENE_4_2,
+  public static final Version LUCENE_4_2_0 = new Version(4, 2, 0);
 
   /**
-   * Match settings and bugs in Lucene's 4.3 release.
+   * Match settings and bugs in Lucene's 4.2.1 release.
    * @deprecated (5.0) Use latest
    */
   @Deprecated
-  LUCENE_4_3,
+  public static final Version LUCENE_4_2_1 = new Version(4, 2, 1);
 
   /**
-   * Match settings and bugs in Lucene's 4.4 release.
+   * Match settings and bugs in Lucene's 4.3.0 release.
    * @deprecated (5.0) Use latest
    */
   @Deprecated
-  LUCENE_4_4,
+  public static final Version LUCENE_4_3_0 = new Version(4, 3, 0);
 
   /**
-   * Match settings and bugs in Lucene's 4.5 release.
+   * Match settings and bugs in Lucene's 4.3.1 release.
    * @deprecated (5.0) Use latest
    */
   @Deprecated
-  LUCENE_4_5,
+  public static final Version LUCENE_4_3_1 = new Version(4, 3, 1);
 
   /**
-   * Match settings and bugs in Lucene's 4.6 release.
+   * Match settings and bugs in Lucene's 4.4.0 release.
    * @deprecated (5.0) Use latest
    */
   @Deprecated
-  LUCENE_4_6,
+  public static final Version LUCENE_4_4_0 = new Version(4, 4, 0);
+
+  /**
+   * Match settings and bugs in Lucene's 4.5.0 release.
+   * @deprecated (5.0) Use latest
+   */
+  @Deprecated
+  public static final Version LUCENE_4_5_0 = new Version(4, 5, 0);
+
+  /**
+   * Match settings and bugs in Lucene's 4.5.1 release.
+   * @deprecated (5.0) Use latest
+   */
+  @Deprecated
+  public static final Version LUCENE_4_5_1 = new Version(4, 5, 1);
+
+  /**
+   * Match settings and bugs in Lucene's 4.6.0 release.
+   * @deprecated (5.0) Use latest
+   */
+  @Deprecated
+  public static final Version LUCENE_4_6_0 = new Version(4, 6, 0);
+
+  /**
+   * Match settings and bugs in Lucene's 4.6.1 release.
+   * @deprecated (5.0) Use latest
+   */
+  @Deprecated
+  public static final Version LUCENE_4_6_1 = new Version(4, 6, 1);
   
   /**
-   * Match settings and bugs in Lucene's 4.7 release.
+   * Match settings and bugs in Lucene's 4.7.0 release.
+   * @deprecated (5.0) Use latest
+   */
+  @Deprecated
+  public static final Version LUCENE_4_7_0 = new Version(4, 7, 0);
+
+  /**
+   * Match settings and bugs in Lucene's 4.7.1 release.
+   * @deprecated (5.0) Use latest
+   */
+  @Deprecated
+  public static final Version LUCENE_4_7_1 = new Version(4, 7, 1);
+
+  /**
+   * Match settings and bugs in Lucene's 4.7.2 release.
    * @deprecated (5.0) Use latest
    */
   @Deprecated
-  LUCENE_4_7,
+  public static final Version LUCENE_4_7_2 = new Version(4, 7, 2);
   
   /**
-   * Match settings and bugs in Lucene's 4.8 release.
+   * Match settings and bugs in Lucene's 4.8.0 release.
+   * @deprecated (5.0) Use latest
+   */
+  @Deprecated
+  public static final Version LUCENE_4_8_0 = new Version(4, 8, 0);
+
+  /**
+   * Match settings and bugs in Lucene's 4.8.1 release.
    * @deprecated (5.0) Use latest
    */
   @Deprecated
-  LUCENE_4_8,
+  public static final Version LUCENE_4_8_1 = new Version(4, 8, 1);
 
   /**
-   * Match settings and bugs in Lucene's 4.9 release.
+   * Match settings and bugs in Lucene's 4.9.0 release.
    * @deprecated (5.0) Use latest
    */
   @Deprecated
-  LUCENE_4_9,
+  public static final Version LUCENE_4_9_0 = new Version(4, 9, 0);
   
   /**
    * Match settings and bugs in Lucene's 4.10 release.
    * @deprecated (5.0) Use latest
    */
   @Deprecated
-  LUCENE_4_10,
+  public static final Version LUCENE_4_10_0 = new Version(4, 10, 0);
 
   /** Match settings and bugs in Lucene's 5.0 release.
    *  <p>
    *  Use this to get the latest &amp; greatest settings, bug
    *  fixes, etc, for Lucene.
    */
-  LUCENE_5_0,
-  
-  /* Add new constants for later versions **here** to respect order! */
+  public static final Version LUCENE_5_0_0 = new Version(5, 0, 0);
+
+  // To add a new version:
+  //  * Only add above this comment
+  //  * If the new version is the newest, change LATEST below and deprecate the previous LATEST
 
   /**
    * <p><b>WARNING</b>: if you use this setting, and then
@@ -132,21 +195,158 @@ public enum Version {
    * Additionally, you may need to <b>re-test your entire
    * application</b> to ensure it behaves as expected, as 
    * some defaults may have changed and may break functionality 
-   * in your application. 
-   * @deprecated Use an actual version instead. 
+   * in your application.
+   */
+  public static final Version LATEST = LUCENE_5_0_0;
+
+  /**
+   * Constant for backwards compatibility.
+   * @deprecated Use {@link #LATEST}
    */
   @Deprecated
-  LUCENE_CURRENT;
+  public static final Version LUCENE_CURRENT = LATEST;
 
-  public boolean onOrAfter(Version other) {
-    return compareTo(other) >= 0;
+  /** @deprecated Bad naming of constant; use {@link #LUCENE_4_0_0} instead. */
+  @Deprecated
+  public static final Version LUCENE_4_0 = LUCENE_4_0_0;
+
+  /** @deprecated Bad naming of constant; use {@link #LUCENE_4_1_0} instead. */
+  @Deprecated
+  public static final Version LUCENE_4_1 = LUCENE_4_1_0;
+
+  /** @deprecated Bad naming of constant; use {@link #LUCENE_4_2_0} instead. */
+  @Deprecated
+  public static final Version LUCENE_4_2 = LUCENE_4_2_0;
+
+  /** @deprecated Bad naming of constant; use {@link #LUCENE_4_3_0} instead. */
+  @Deprecated
+  public static final Version LUCENE_4_3 = LUCENE_4_3_0;
+
+  /** @deprecated Bad naming of constant; use {@link #LUCENE_4_4_0} instead. */
+  @Deprecated
+  public static final Version LUCENE_4_4 = LUCENE_4_4_0;
+
+  /** @deprecated Bad naming of constant; use {@link #LUCENE_4_5_0} instead. */
+  @Deprecated
+  public static final Version LUCENE_4_5 = LUCENE_4_5_0;
+
+  /** @deprecated Bad naming of constant; use {@link #LUCENE_4_6_0} instead. */
+  @Deprecated
+  public static final Version LUCENE_4_6 = LUCENE_4_6_0;
+
+  /** @deprecated Bad naming of constant; use {@link #LUCENE_4_7_0} instead. */
+  @Deprecated
+  public static final Version LUCENE_4_7 = LUCENE_4_7_0;
+
+  /** @deprecated Bad naming of constant; use {@link #LUCENE_4_8_0} instead. */
+  @Deprecated
+  public static final Version LUCENE_4_8 = LUCENE_4_8_0;
+
+  /** @deprecated Bad naming of constant; use {@link #LUCENE_4_9_0} instead. */
+  @Deprecated
+  public static final Version LUCENE_4_9 = LUCENE_4_9_0;
+
+
+  /**
+   * Parse a version number of the form {@code "major.minor.bugfix.prerelease"}.
+   *
+   * Part {@code ".bugfix"} and part {@code ".prerelease"} are optional.
+   * Note that this is forwards compatible: the parsed version does not have to exist as
+   * a constant.
+   */
+  public static Version parse(String version) {
+    String[] pieces = version.split("\\.");
+    if (pieces.length < 2 || pieces.length > 4) {
+      throw new IllegalArgumentException("Version is not in form major.minor.bugfix(.prerelease): " + version);
+    }
+
+    int major = Integer.parseInt(pieces[0]);
+    int minor = Integer.parseInt(pieces[1]);
+    int bugfix = 0;
+    int prerelease = 0;
+    if (pieces.length > 2) {
+      bugfix = Integer.parseInt(pieces[2]);
+    }
+    if (pieces.length > 3) {
+      prerelease = Integer.parseInt(pieces[3]);
+      if (prerelease == 0) {
+        throw new IllegalArgumentException("Invalid value " + prerelease + " for prelrease of version " + version +", should be 1 or 2");
+      }
+    }
+
+    return new Version(major, minor, bugfix, prerelease);
   }
-  
+
+  /**
+   * Parse the given version number as a constant or dot based version.
+   * <p>This method allows to use {@code "LUCENE_X_Y"} constant names,
+   * or version numbers in the format {@code "x.y.z"}.
+   */
   public static Version parseLeniently(String version) {
+    if (version.equals("LATEST") || version.equals("LUCENE_CURRENT")) return LATEST;
     final String parsedMatchVersion = version
         .toUpperCase(Locale.ROOT)
-        .replaceFirst("^(\\d+)\\.(\\d+)$", "LUCENE_$1_$2")
-        .replaceFirst("^LUCENE_(\\d)(\\d)$", "LUCENE_$1_$2");
-    return Version.valueOf(parsedMatchVersion);
+        .replaceFirst("^LUCENE_(\\d+)_(\\d+)_(\\d+)$", "$1.$2.$3")
+        .replaceFirst("^LUCENE_(\\d+)_(\\d+)$", "$1.$2.0")
+        .replaceFirst("^LUCENE_(\\d)(\\d)$", "$1.$2.0");
+    return parse(parsedMatchVersion);
+  }
+
+  // stores the version pieces, with most significant pieces in high bits
+  // ie:  | 1 byte | 1 byte | 1 byte |   2 bits   |
+  //         major   minor    bugfix   prerelease
+  private final int encodedValue;
+
+  private Version(int major, int minor, int bugfix) {
+    this(major, minor, bugfix, 0);
+  }
+
+  private Version(int major, int minor, int bugfix, int prerelease) {
+    if (major > 5 || major < 4) {
+      throw new IllegalArgumentException("Lucene 5.x only supports 5.x and 4.x versions");
+    }
+    if (minor > 255 | minor < 0) {
+      throw new IllegalArgumentException("Illegal minor version: " + minor);
+    }
+    if (bugfix > 255 | bugfix < 0) {
+      throw new IllegalArgumentException("Illegal bugfix version: " + bugfix);
+    }
+    if (prerelease > 2 | prerelease < 0) {
+      throw new IllegalArgumentException("Illegal prerelease version: " + prerelease);
+    }
+    if (prerelease != 0 && (minor != 0 || bugfix != 0)) {
+      throw new IllegalArgumentException("Prerelease version only supported with major release");
+    }
+
+    if (prerelease == 0) {
+      // final release should sort after alpha/beta
+      prerelease = 3;
+    }
+
+    encodedValue = major << 18 | minor << 10 | bugfix << 2 | prerelease;
+  }
+
+  /**
+   * Returns true if this version is the same or after the version from the argument.
+   */
+  public boolean onOrAfter(Version other) {
+    return encodedValue >= other.encodedValue;
+  }
+
+  @Override
+  public String toString() {
+    int major = (encodedValue >>> 18) & 0xFF;
+    int minor = (encodedValue >>> 10) & 0xFF;
+    int bugfix = (encodedValue >>> 2) & 0xFF;
+    int prerelease = encodedValue & 0x3;
+    if (prerelease == 3) { // ie unencoded value is 0
+      return "" + major + "." + minor + "." + bugfix;
+    }
+    return "" + major + "." + minor + "." + bugfix + "." + prerelease;
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    return o != null && o instanceof Version && ((Version)o).encodedValue == encodedValue;
   }
 }
diff --git lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
index 1f0c44f..87970c3 100644
--- lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
+++ lucene/core/src/test/org/apache/lucene/index/TestBackwardsCompatibility.java
@@ -23,7 +23,6 @@ import java.io.IOException;
 import java.io.PrintStream;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Comparator;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -59,14 +58,13 @@ import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.store.SimpleFSDirectory;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.LuceneTestCase.SuppressCodecs;
 import org.apache.lucene.util.NumericUtils;
-import org.apache.lucene.util.StringHelper;
 import org.apache.lucene.util.TestUtil;
+import org.apache.lucene.util.Version;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
@@ -846,23 +844,21 @@ public class TestBackwardsCompatibility extends LuceneTestCase {
     riw.close();
     DirectoryReader ir = DirectoryReader.open(currentDir);
     SegmentReader air = (SegmentReader)ir.leaves().get(0).reader();
-    String currentVersion = air.getSegmentInfo().info.getVersion();
+    Version currentVersion = air.getSegmentInfo().info.getVersion();
     assertNotNull(currentVersion); // only 3.0 segments can have a null version
     ir.close();
     currentDir.close();
     
-    Comparator<String> comparator = StringHelper.getVersionComparator();
-    
     // now check all the old indexes, their version should be < the current version
     for (String name : oldNames) {
       Directory dir = oldIndexDirs.get(name);
       DirectoryReader r = DirectoryReader.open(dir);
       for (AtomicReaderContext context : r.leaves()) {
         air = (SegmentReader) context.reader();
-        String oldVersion = air.getSegmentInfo().info.getVersion();
+        Version oldVersion = air.getSegmentInfo().info.getVersion();
         assertNotNull(oldVersion); // only 3.0 segments can have a null version
-        assertTrue("current Constants.LUCENE_MAIN_VERSION is <= an old index: did you forget to bump it?!",
-            comparator.compare(oldVersion, currentVersion) < 0);
+        assertTrue("current Version.LATEST is <= an old index: did you forget to bump it?!",
+                   currentVersion.onOrAfter(oldVersion));
       }
       r.close();
     }
@@ -920,7 +916,7 @@ public class TestBackwardsCompatibility extends LuceneTestCase {
       System.out.println("checkAllSegmentsUpgraded: " + infos);
     }
     for (SegmentCommitInfo si : infos) {
-      assertEquals(Constants.LUCENE_MAIN_VERSION, si.info.getVersion());
+      assertEquals(Version.LATEST, si.info.getVersion());
     }
     return infos.size();
   }
diff --git lucene/core/src/test/org/apache/lucene/index/TestCodecs.java lucene/core/src/test/org/apache/lucene/index/TestCodecs.java
index b24a6f6..e1753f9 100644
--- lucene/core/src/test/org/apache/lucene/index/TestCodecs.java
+++ lucene/core/src/test/org/apache/lucene/index/TestCodecs.java
@@ -43,11 +43,11 @@ import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
+import org.apache.lucene.util.Version;
 import org.junit.BeforeClass;
 
 // TODO: test multiple codecs here?
@@ -252,7 +252,7 @@ public class TestCodecs extends LuceneTestCase {
     final Directory dir = newDirectory();
     this.write(fieldInfos, dir, fields);
     Codec codec = Codec.getDefault();
-    final SegmentInfo si = new SegmentInfo(dir, Constants.LUCENE_MAIN_VERSION, SEGMENT, 10000, false, codec, null);
+    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, SEGMENT, 10000, false, codec, null);
 
     final FieldsProducer reader = codec.postingsFormat().fieldsProducer(new SegmentReadState(dir, si, fieldInfos, newIOContext(random())));
 
@@ -309,7 +309,7 @@ public class TestCodecs extends LuceneTestCase {
 
     this.write(fieldInfos, dir, fields);
     Codec codec = Codec.getDefault();
-    final SegmentInfo si = new SegmentInfo(dir, Constants.LUCENE_MAIN_VERSION, SEGMENT, 10000, false, codec, null);
+    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, SEGMENT, 10000, false, codec, null);
 
     if (VERBOSE) {
       System.out.println("TEST: now read postings");
@@ -804,7 +804,7 @@ public class TestCodecs extends LuceneTestCase {
   private void write(final FieldInfos fieldInfos, final Directory dir, final FieldData[] fields) throws Throwable {
 
     final Codec codec = Codec.getDefault();
-    final SegmentInfo si = new SegmentInfo(dir, Constants.LUCENE_MAIN_VERSION, SEGMENT, 10000, false, codec, null);
+    final SegmentInfo si = new SegmentInfo(dir, Version.LATEST, SEGMENT, 10000, false, codec, null);
     final SegmentWriteState state = new SegmentWriteState(InfoStream.getDefault(), dir, si, fieldInfos, null, newIOContext(random()));
 
     Arrays.sort(fields);
diff --git lucene/core/src/test/org/apache/lucene/index/TestDoc.java lucene/core/src/test/org/apache/lucene/index/TestDoc.java
index 6c322a9..9dbb756 100644
--- lucene/core/src/test/org/apache/lucene/index/TestDoc.java
+++ lucene/core/src/test/org/apache/lucene/index/TestDoc.java
@@ -41,9 +41,9 @@ import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.store.MockDirectoryWrapper;
 import org.apache.lucene.store.TrackingDirectoryWrapper;
-import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.Version;
 
 
 /** JUnit adaptation of an older test case DocTest. */
@@ -217,7 +217,7 @@ public class TestDoc extends LuceneTestCase {
 
       final Codec codec = Codec.getDefault();
       TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(si1.info.dir);
-      final SegmentInfo si = new SegmentInfo(si1.info.dir, Constants.LUCENE_MAIN_VERSION, merged, -1, false, codec, null);
+      final SegmentInfo si = new SegmentInfo(si1.info.dir, Version.LATEST, merged, -1, false, codec, null);
 
       SegmentMerger merger = new SegmentMerger(Arrays.<AtomicReader>asList(r1, r2),
           si, InfoStream.getDefault(), trackingDir,
@@ -226,7 +226,7 @@ public class TestDoc extends LuceneTestCase {
       MergeState mergeState = merger.merge();
       r1.close();
       r2.close();
-      final SegmentInfo info = new SegmentInfo(si1.info.dir, Constants.LUCENE_MAIN_VERSION, merged,
+      final SegmentInfo info = new SegmentInfo(si1.info.dir, Version.LATEST, merged,
                                                si1.info.getDocCount() + si2.info.getDocCount(),
                                                false, codec, null);
       info.setFiles(new HashSet<>(trackingDir.getCreatedFiles()));
diff --git lucene/core/src/test/org/apache/lucene/index/TestSegmentMerger.java lucene/core/src/test/org/apache/lucene/index/TestSegmentMerger.java
index ed6ee45..041ca16 100644
--- lucene/core/src/test/org/apache/lucene/index/TestSegmentMerger.java
+++ lucene/core/src/test/org/apache/lucene/index/TestSegmentMerger.java
@@ -25,11 +25,11 @@ import org.apache.lucene.document.Document;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.InfoStream;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
+import org.apache.lucene.util.Version;
 
 public class TestSegmentMerger extends LuceneTestCase {
   //The variables for the new merged segment
@@ -78,7 +78,7 @@ public class TestSegmentMerger extends LuceneTestCase {
 
   public void testMerge() throws IOException {
     final Codec codec = Codec.getDefault();
-    final SegmentInfo si = new SegmentInfo(mergedDir, Constants.LUCENE_MAIN_VERSION, mergedSegment, -1, false, codec, null);
+    final SegmentInfo si = new SegmentInfo(mergedDir, Version.LATEST, mergedSegment, -1, false, codec, null);
 
     SegmentMerger merger = new SegmentMerger(Arrays.<AtomicReader>asList(reader1, reader2),
         si, InfoStream.getDefault(), mergedDir,
@@ -88,7 +88,7 @@ public class TestSegmentMerger extends LuceneTestCase {
     assertTrue(docsMerged == 2);
     //Should be able to open a new SegmentReader against the new directory
     SegmentReader mergedReader = new SegmentReader(new SegmentCommitInfo(
-                                                         new SegmentInfo(mergedDir, Constants.LUCENE_MAIN_VERSION, mergedSegment, docsMerged,
+                                                         new SegmentInfo(mergedDir, Version.LATEST, mergedSegment, docsMerged,
                                                                          false, codec, null),
                                                          0, -1L, -1L, -1L),
                                                    newIOContext(random()));
diff --git lucene/core/src/test/org/apache/lucene/util/TestConstants.java lucene/core/src/test/org/apache/lucene/util/TestConstants.java
deleted file mode 100644
index e6f00e3..0000000
--- lucene/core/src/test/org/apache/lucene/util/TestConstants.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package org.apache.lucene.util;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-public class TestConstants extends LuceneTestCase {
-  
-  private String getVersionDetails() {
-    return " (LUCENE_MAIN_VERSION=" + Constants.LUCENE_MAIN_VERSION +
-        ", LUCENE_MAIN_VERSION(without alpha/beta)=" + Constants.mainVersionWithoutAlphaBeta() +
-        ", LUCENE_VERSION=" + Constants.LUCENE_VERSION + ")";
-  }
-  
-  public void testLuceneMainVersionConstant() {
-    assertTrue("LUCENE_MAIN_VERSION does not follow pattern: 'x.y' (stable release) or 'x.y.0.z' (alpha/beta version)" + getVersionDetails(),
-        Constants.LUCENE_MAIN_VERSION.matches("\\d+\\.\\d+(|\\.0\\.\\d+)"));
-    assertTrue("LUCENE_VERSION does not start with LUCENE_MAIN_VERSION (without alpha/beta marker)" + getVersionDetails(),
-        Constants.LUCENE_VERSION.startsWith(Constants.mainVersionWithoutAlphaBeta()));
-  }
-  
-  public void testBuildSetup() {
-    // common-build.xml sets lucene.version, if not, we skip this test!
-    String version = System.getProperty("lucene.version");
-    assumeTrue("Null lucene.version test property. You should run the tests with the official Lucene build file",
-        version != null);
-    
-    // remove anything after a "-" from the version string:
-    version = version.replaceAll("-.*$", "");
-    String versionConstant = Constants.LUCENE_VERSION.replaceAll("-.*$", "");
-    assertTrue("LUCENE_VERSION should share the same prefix with lucene.version test property ('" + version + "')." + getVersionDetails(),
-        versionConstant.startsWith(version) || version.startsWith(versionConstant));
-  }
-  
-}
diff --git lucene/core/src/test/org/apache/lucene/util/TestVersion.java lucene/core/src/test/org/apache/lucene/util/TestVersion.java
index e079269..8e15efe 100644
--- lucene/core/src/test/org/apache/lucene/util/TestVersion.java
+++ lucene/core/src/test/org/apache/lucene/util/TestVersion.java
@@ -17,46 +17,173 @@
 
 package org.apache.lucene.util;
 
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+
 public class TestVersion extends LuceneTestCase {
 
-  public void test() {
-    for (Version v : Version.values()) {
-      assertTrue("LUCENE_CURRENT must be always onOrAfter("+v+")", Version.LUCENE_CURRENT.onOrAfter(v));
+  public void testOnOrAfter() throws Exception {
+    for (Field field : Version.class.getDeclaredFields()) {
+      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {
+        Version v = (Version)field.get(Version.class);
+        assertTrue("LATEST must be always onOrAfter("+v+")", Version.LATEST.onOrAfter(v));
+      }
     }
-    assertTrue(Version.LUCENE_5_0.onOrAfter(Version.LUCENE_4_0));
-    assertFalse(Version.LUCENE_4_0.onOrAfter(Version.LUCENE_5_0));
+    assertTrue(Version.LUCENE_5_0_0.onOrAfter(Version.LUCENE_4_0_0));
+    assertFalse(Version.LUCENE_4_0_0.onOrAfter(Version.LUCENE_5_0_0));
+    assertTrue(Version.LUCENE_4_0_0_ALPHA.onOrAfter(Version.LUCENE_4_0_0_ALPHA));
+    assertTrue(Version.LUCENE_4_0_0_BETA.onOrAfter(Version.LUCENE_4_0_0_ALPHA));
+    assertTrue(Version.LUCENE_4_0_0.onOrAfter(Version.LUCENE_4_0_0_ALPHA));
+    assertTrue(Version.LUCENE_4_0_0.onOrAfter(Version.LUCENE_4_0_0_BETA));
+  }
+
+  public void testToString() {
+    assertEquals("4.2.0", Version.LUCENE_4_2_0.toString());
+    assertEquals("4.2.0", Version.LUCENE_4_2.toString());
+    assertEquals("4.2.1", Version.LUCENE_4_2_1.toString());
+    assertEquals("4.0.0.1", Version.LUCENE_4_0_0_ALPHA.toString());
+    assertEquals("4.0.0.2", Version.LUCENE_4_0_0_BETA.toString());
   }
 
   public void testParseLeniently() {
-    assertEquals(Version.LUCENE_4_0, Version.parseLeniently("4.0"));
-    assertEquals(Version.LUCENE_4_0, Version.parseLeniently("LUCENE_40"));
-    assertEquals(Version.LUCENE_4_0, Version.parseLeniently("LUCENE_4_0"));
-    assertEquals(Version.LUCENE_CURRENT, Version.parseLeniently("LUCENE_CURRENT"));
+    assertEquals(Version.LUCENE_4_0_0, Version.parseLeniently("4.0"));
+    assertEquals(Version.LUCENE_4_0_0, Version.parseLeniently("4.0.0"));
+    assertEquals(Version.LUCENE_4_0_0, Version.parseLeniently("LUCENE_40"));
+    assertEquals(Version.LUCENE_4_0_0, Version.parseLeniently("LUCENE_4_0"));
+    assertEquals(Version.LATEST, Version.parseLeniently("LATEST"));
+    assertEquals(Version.LATEST, Version.parseLeniently("LUCENE_CURRENT"));
+  }
+  
+  public void testParseLenientlyExceptions() {
+    try {
+      Version.parseLeniently("LUCENE");
+      fail();
+    } catch (IllegalArgumentException iae) {
+      // pass
+    }
+  }
+
+  public void testParse() {
+    assertEquals(Version.LUCENE_5_0_0, Version.parse("5.0.0"));
+    assertEquals(Version.LUCENE_4_1_0, Version.parse("4.1"));
+    assertEquals(Version.LUCENE_4_1_0, Version.parseLeniently("4.1.0"));
+    assertEquals(Version.LUCENE_4_0_0_ALPHA, Version.parseLeniently("4.0.0.1"));
+    assertEquals(Version.LUCENE_4_0_0_BETA, Version.parseLeniently("4.0.0.2"));
+  }
+
+  public void testForwardsCompatibility() {
+    assertTrue(Version.parse("4.7.10").onOrAfter(Version.LUCENE_4_7_2));
+    assertTrue(Version.parse("4.20.0").onOrAfter(Version.LUCENE_4_8_1));
+    assertTrue(Version.parse("5.10.20").onOrAfter(Version.LUCENE_5_0_0));
+  }
+
+  public void testParseExceptions() {
+    try {
+      Version.parse("1.0");
+      fail();
+    } catch (IllegalArgumentException iae) {
+      // pass
+    }
+
+    try {
+      Version.parse("LUCENE_4_0_0");
+      fail();
+    } catch (IllegalArgumentException iae) {
+      // pass
+    }
+
+    try {
+      Version.parse("4.256");
+      fail();
+    } catch (IllegalArgumentException iae) {
+      // pass
+    }
+
+    try {
+      Version.parse("4.-1");
+      fail();
+    } catch (IllegalArgumentException iae) {
+      // pass
+    }
+
+    try {
+      Version.parse("4.1.256");
+      fail();
+    } catch (IllegalArgumentException iae) {
+      // pass
+    }
+
+    try {
+      Version.parse("4.1.-1");
+      fail();
+    } catch (IllegalArgumentException iae) {
+      // pass
+    }
+
+    try {
+      Version.parse("4.1.1.3");
+      fail();
+    } catch (IllegalArgumentException iae) {
+      // pass
+    }
+
+    try {
+      Version.parse("4.1.1.-1");
+      fail();
+    } catch (IllegalArgumentException iae) {
+      // pass
+    }
+
+    try {
+      Version.parse("4.1.1.1");
+      fail();
+    } catch (IllegalArgumentException iae) {
+      // pass
+    }
+
+    try {
+      Version.parse("4.1.1.2");
+      fail();
+    } catch (IllegalArgumentException iae) {
+      // pass
+    }
+
+    try {
+      Version.parse("4.0.0.0");
+      fail();
+    } catch (IllegalArgumentException iae) {
+      // pass
+    }
+
+    try {
+      Version.parse("6.0.0");
+      fail();
+    } catch (IllegalArgumentException iae) {
+      // pass
+    }
   }
   
   public void testDeprecations() throws Exception {
-    Version values[] = Version.values();
     // all but the latest version should be deprecated
-    for (int i = 0; i < values.length; i++) {
-      if (i + 1 == values.length) {
-        assertSame("Last constant must be LUCENE_CURRENT", Version.LUCENE_CURRENT, values[i]);
-      }
-      final boolean dep = Version.class.getField(values[i].name()).isAnnotationPresent(Deprecated.class);
-      if (i + 2 != values.length) {
-        assertTrue(values[i].name() + " should be deprecated", dep);
-      } else {
-        assertFalse(values[i].name() + " should not be deprecated", dep);
+    for (Field field : Version.class.getDeclaredFields()) {
+      if (Modifier.isStatic(field.getModifiers()) && field.getType() == Version.class) {
+        Version v = (Version)field.get(Version.class);
+        final boolean dep = field.isAnnotationPresent(Deprecated.class);
+        if (v.equals(Version.LATEST) && field.getName().equals("LUCENE_CURRENT") == false) {
+          assertFalse(field.getName() + " should not be deprecated", dep);
+        } else {
+          assertTrue(field.getName() + " should be deprecated", dep);
+        }
       }
     }
   }
-  
-  public void testAgainstMainVersionConstant() {
-    final Version values[] = Version.values();
-    assertTrue(values.length >= 2);
-    final String mainVersionWithoutAlphaBeta = Constants.mainVersionWithoutAlphaBeta();
-    final Version mainVersionParsed = Version.parseLeniently(mainVersionWithoutAlphaBeta); 
-    assertSame("Constant one before last must be the same as the parsed LUCENE_MAIN_VERSION (without alpha/beta) constant: " + 
-        mainVersionWithoutAlphaBeta,
-        mainVersionParsed, values[values.length - 2]);
+
+  public void testLatestVersionCommonBuild() {
+    // common-build.xml sets 'tests.LUCENE_VERSION', if not, we skip this test!
+    String commonBuildVersion = System.getProperty("tests.LUCENE_VERSION");
+    assumeTrue("Null 'tests.LUCENE_VERSION' test property. You should run the tests with the official Lucene build file",
+        commonBuildVersion != null);
+    assertEquals("Version.LATEST does not match the one given in common-build.xml",
+        Version.LATEST.toString(), commonBuildVersion);
   }
 }
diff --git lucene/core/src/test/org/apache/lucene/util/TestVersionComparator.java lucene/core/src/test/org/apache/lucene/util/TestVersionComparator.java
deleted file mode 100644
index 8c649d7..0000000
--- lucene/core/src/test/org/apache/lucene/util/TestVersionComparator.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.apache.lucene.util;
-
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-import java.util.Comparator;
-
-/**
- * Tests for StringHelper.getVersionComparator
- */
-public class TestVersionComparator extends LuceneTestCase {
-  public void testVersions() {
-    Comparator<String> comp = StringHelper.getVersionComparator();
-    assertTrue(comp.compare("1", "2") < 0);
-    assertTrue(comp.compare("1", "1") == 0);
-    assertTrue(comp.compare("2", "1") > 0);
-    
-    assertTrue(comp.compare("1.1", "1") > 0);
-    assertTrue(comp.compare("1", "1.1") < 0);
-    assertTrue(comp.compare("1.1", "1.1") == 0);
-    
-    assertTrue(comp.compare("1.0", "1") == 0);
-    assertTrue(comp.compare("1", "1.0") == 0);
-    assertTrue(comp.compare("1.0.1", "1.0") > 0);
-    assertTrue(comp.compare("1.0", "1.0.1") < 0);
-    
-    assertTrue(comp.compare("1.02.003", "1.2.3.0") == 0);
-    assertTrue(comp.compare("1.2.3.0", "1.02.003") == 0);
-    
-    assertTrue(comp.compare("1.10", "1.9") > 0);
-    assertTrue(comp.compare("1.9", "1.10") < 0);
-    
-    assertTrue(comp.compare("0", "1.0") < 0);
-    assertTrue(comp.compare("00", "1.0") < 0);
-    assertTrue(comp.compare("-1.0", "1.0") < 0);
-    assertTrue(comp.compare("3.0", Integer.toString(Integer.MIN_VALUE)) > 0);
-  }
-}
diff --git lucene/demo/src/java/org/apache/lucene/demo/facet/FacetExamples.java lucene/demo/src/java/org/apache/lucene/demo/facet/FacetExamples.java
index faf643c..f1b0de8 100644
--- lucene/demo/src/java/org/apache/lucene/demo/facet/FacetExamples.java
+++ lucene/demo/src/java/org/apache/lucene/demo/facet/FacetExamples.java
@@ -28,6 +28,6 @@ public interface FacetExamples {
 
   // :Post-Release-Update-Version.LUCENE_XY:
   /** The Lucene {@link Version} used by the example code. */
-  public static final Version EXAMPLES_VER = Version.LUCENE_5_0;
+  public static final Version EXAMPLES_VER = Version.LUCENE_5_0_0;
 
 }
diff --git lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldTermStack.java lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldTermStack.java
index 18774fe..29c307a 100644
--- lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldTermStack.java
+++ lucene/highlighter/src/java/org/apache/lucene/search/vectorhighlight/FieldTermStack.java
@@ -41,13 +41,13 @@ public class FieldTermStack {
   LinkedList<TermInfo> termList = new LinkedList<>();
   
   //public static void main( String[] args ) throws Exception {
-  //  Analyzer analyzer = new WhitespaceAnalyzer(Version.LUCENE_CURRENT);
-  //  QueryParser parser = new QueryParser(Version.LUCENE_CURRENT,  "f", analyzer );
+  //  Analyzer analyzer = new WhitespaceAnalyzer(Version.LATEST);
+  //  QueryParser parser = new QueryParser(Version.LATEST,  "f", analyzer );
   //  Query query = parser.parse( "a x:b" );
   //  FieldQuery fieldQuery = new FieldQuery( query, true, false );
     
   //  Directory dir = new RAMDirectory();
-  //  IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(Version.LUCENE_CURRENT, analyzer));
+  //  IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(Version.LATEST, analyzer));
   //  Document doc = new Document();
   //  FieldType ft = new FieldType(TextField.TYPE_STORED);
   //  ft.setStoreTermVectors(true);
diff --git lucene/misc/src/java/org/apache/lucene/index/MultiPassIndexSplitter.java lucene/misc/src/java/org/apache/lucene/index/MultiPassIndexSplitter.java
index bf1e11a..746c26b 100644
--- lucene/misc/src/java/org/apache/lucene/index/MultiPassIndexSplitter.java
+++ lucene/misc/src/java/org/apache/lucene/index/MultiPassIndexSplitter.java
@@ -170,7 +170,7 @@ public class MultiPassIndexSplitter {
     } else {
       input = new MultiReader(indexes.toArray(new IndexReader[indexes.size()]));
     }
-    splitter.split(Version.LUCENE_CURRENT, input, dirs, seq);
+    splitter.split(Version.LATEST, input, dirs, seq);
   }
   
   /**
diff --git lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java
index 80aa659..d513162 100644
--- lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java
+++ lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingInfixSuggester.java
@@ -72,7 +72,6 @@ import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopFieldCollector;
 import org.apache.lucene.search.TopFieldDocs;
 import org.apache.lucene.search.suggest.InputIterator;
-import org.apache.lucene.search.suggest.Lookup.LookupResult; // javadocs
 import org.apache.lucene.search.suggest.Lookup;
 import org.apache.lucene.store.DataInput;
 import org.apache.lucene.store.DataOutput;
@@ -260,7 +259,7 @@ public class AnalyzingInfixSuggester extends Lookup implements Closeable {
         if (fieldName.equals("textgrams") && minPrefixChars > 0) {
           // TODO: should use an EdgeNGramTokenFilterFactory here
           TokenFilter filter;
-          if (matchVersion.onOrAfter(Version.LUCENE_4_4)) {
+          if (matchVersion.onOrAfter(Version.LUCENE_4_4_0)) {
             filter = new EdgeNGramTokenFilter(components.getTokenStream(), 1, minPrefixChars);
           } else {
             filter = new Lucene43EdgeNGramTokenFilter(components.getTokenStream(), 1, minPrefixChars);
diff --git lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java
index 579b447..d6038ac 100644
--- lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java
+++ lucene/test-framework/src/java/org/apache/lucene/index/BasePostingsFormatTestCase.java
@@ -53,13 +53,13 @@ import org.apache.lucene.store.FlushInfo;
 import org.apache.lucene.store.IOContext;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.Constants;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LineFileDocs;
 import org.apache.lucene.util.RamUsageTester;
 import org.apache.lucene.util.TestUtil;
 import org.apache.lucene.util.UnicodeUtil;
+import org.apache.lucene.util.Version;
 import org.apache.lucene.util.automaton.Automaton;
 import org.apache.lucene.util.automaton.AutomatonTestUtil.RandomAcceptedStrings;
 import org.apache.lucene.util.automaton.AutomatonTestUtil;
@@ -675,7 +675,7 @@ public abstract class BasePostingsFormatTestCase extends BaseIndexFileFormatTest
   // randomly index at lower IndexOption
   private FieldsProducer buildIndex(Directory dir, IndexOptions maxAllowed, boolean allowPayloads, boolean alwaysTestMax) throws IOException {
     Codec codec = getCodec();
-    SegmentInfo segmentInfo = new SegmentInfo(dir, Constants.LUCENE_MAIN_VERSION, "_0", maxDoc, false, codec, null);
+    SegmentInfo segmentInfo = new SegmentInfo(dir, Version.LATEST, "_0", maxDoc, false, codec, null);
 
     int maxIndexOption = Arrays.asList(IndexOptions.values()).indexOf(maxAllowed);
     if (VERBOSE) {
diff --git lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
index f1afee8..5d2dc61 100644
--- lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
+++ lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase.java
@@ -373,7 +373,7 @@ public abstract class LuceneTestCase extends Assert {
    * Use this constant when creating Analyzers and any other version-dependent stuff.
    * <p><b>NOTE:</b> Change this when development starts for new Lucene version:
    */
-  public static final Version TEST_VERSION_CURRENT = Version.LUCENE_5_0;
+  public static final Version TEST_VERSION_CURRENT = Version.LUCENE_5_0_0;
 
   /**
    * True if and only if tests are run in verbose mode. If this flag is false
diff --git solr/common-build.xml solr/common-build.xml
index 3655ca5..cedfb71 100644
--- solr/common-build.xml
+++ solr/common-build.xml
@@ -200,7 +200,7 @@
     <attribute name="excludes" default="**/pom.xml,**/*.iml"/>
     <attribute name="metainf.source.dir" default="${common-solr.dir}"/>
     <attribute name="implementation.title" default="org.apache.solr"/>
-    <attribute name="spec.version" default="${spec.version}"/>
+    <attribute name="spec.version" default="${version}"/>
     <attribute name="manifest.file" default="${manifest.file}"/>
     <element name="solr-jarify-filesets" optional="true"/>
     <element name="solr-jarify-additional-manifest-attributes" optional="true"/>
diff --git solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java
index 4291917..d72d38b 100644
--- solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java
+++ solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java
@@ -187,7 +187,7 @@ public class ICUCollationField extends FieldType {
       rbc.setVariableTop(variableTop);
     }
 
-    analyzer = new ICUCollationKeyAnalyzer(Version.LUCENE_CURRENT, collator);
+    analyzer = new ICUCollationKeyAnalyzer(Version.LATEST, collator);
   }
   
   /**
diff --git solr/core/src/java/org/apache/solr/core/Config.java solr/core/src/java/org/apache/solr/core/Config.java
index 8d1ef49..8ac097e 100644
--- solr/core/src/java/org/apache/solr/core/Config.java
+++ solr/core/src/java/org/apache/solr/core/Config.java
@@ -443,14 +443,12 @@ public class Config {
       version = Version.parseLeniently(matchVersion);
     } catch (IllegalArgumentException iae) {
       throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
-        "Invalid luceneMatchVersion '" + matchVersion +
-        "', valid values are: " + Arrays.toString(Version.values()) +
-        " or a string in format 'V.V'", iae);
+        "Invalid luceneMatchVersion.  Should be of the form 'V.V.V' (e.g. 4.8.0)", iae);
     }
     
-    if (version == Version.LUCENE_CURRENT && !versionWarningAlreadyLogged.getAndSet(true)) {
+    if (version == Version.LATEST && !versionWarningAlreadyLogged.getAndSet(true)) {
       log.warn(
-        "You should not use LUCENE_CURRENT as luceneMatchVersion property: "+
+        "You should not use LATEST as luceneMatchVersion property: "+
         "if you use this setting, and then Solr upgrades to a newer release of Lucene, "+
         "sizable changes may happen. If precise back compatibility is important "+
         "then you should instead explicitly specify an actual Lucene version."
diff --git solr/core/src/java/org/apache/solr/core/SolrConfig.java solr/core/src/java/org/apache/solr/core/SolrConfig.java
index bab158f..3ab2a71 100644
--- solr/core/src/java/org/apache/solr/core/SolrConfig.java
+++ solr/core/src/java/org/apache/solr/core/SolrConfig.java
@@ -163,19 +163,19 @@ public class SolrConfig extends Config {
     luceneMatchVersion = getLuceneVersion("luceneMatchVersion");
     String indexConfigPrefix;
 
-    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0.
+    // Old indexDefaults and mainIndex sections are deprecated and fails fast for luceneMatchVersion=>LUCENE_4_0_0.
     // For older solrconfig.xml's we allow the old sections, but never mixed with the new <indexConfig>
     boolean hasDeprecatedIndexConfig = (getNode("indexDefaults", false) != null) || (getNode("mainIndex", false) != null);
     boolean hasNewIndexConfig = getNode("indexConfig", false) != null;
     if(hasDeprecatedIndexConfig){
-      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0)) {
+      if(luceneMatchVersion.onOrAfter(Version.LUCENE_4_0_0)) {
         throw new SolrException(ErrorCode.FORBIDDEN, "<indexDefaults> and <mainIndex> configuration sections are discontinued. Use <indexConfig> instead.");
       } else {
         // Still allow the old sections for older LuceneMatchVersion's
         if(hasNewIndexConfig) {
           throw new SolrException(ErrorCode.FORBIDDEN, "Cannot specify both <indexDefaults>, <mainIndex> and <indexConfig> at the same time. Please use <indexConfig> only.");
         }
-        log.warn("<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0 and later. Please use <indexConfig> instead.");
+        log.warn("<indexDefaults> and <mainIndex> configuration sections are deprecated and will fail for luceneMatchVersion=LUCENE_4_0_0 and later. Please use <indexConfig> instead.");
         defaultIndexConfig = new SolrIndexConfig(this, "indexDefaults", null);
         mainIndexConfig = new SolrIndexConfig(this, "mainIndex", defaultIndexConfig);
         indexConfigPrefix = "mainIndex";
diff --git solr/core/src/java/org/apache/solr/schema/FieldTypePluginLoader.java solr/core/src/java/org/apache/solr/schema/FieldTypePluginLoader.java
index 8cd3f26..ea0c2ca 100644
--- solr/core/src/java/org/apache/solr/schema/FieldTypePluginLoader.java
+++ solr/core/src/java/org/apache/solr/schema/FieldTypePluginLoader.java
@@ -35,7 +35,6 @@ import javax.xml.xpath.XPathConstants;
 import javax.xml.xpath.XPathExpressionException;
 import javax.xml.xpath.XPathFactory;
 import java.util.*;
-import java.lang.reflect.Constructor;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -399,7 +398,7 @@ public final class FieldTypePluginLoader
     Version version = (configuredVersion != null) ?
             Config.parseLuceneVersionString(configuredVersion) : schema.getDefaultLuceneMatchVersion();
 
-    if (!version.onOrAfter(Version.LUCENE_4_0)) {
+    if (!version.onOrAfter(Version.LUCENE_4_0_0)) {
       log.warn(pluginClassName + " is using deprecated " + version +
         " emulation. You should at some point declare and reindex to at least 4.0, because " +
         "3.x emulation is deprecated and will be removed in 5.0");
diff --git solr/core/src/java/org/apache/solr/schema/IndexSchema.java solr/core/src/java/org/apache/solr/schema/IndexSchema.java
index 67ecb95..c4fbc03 100644
--- solr/core/src/java/org/apache/solr/schema/IndexSchema.java
+++ solr/core/src/java/org/apache/solr/schema/IndexSchema.java
@@ -500,7 +500,7 @@ public class IndexSchema {
         similarityFactory = new DefaultSimilarityFactory();
         final NamedList similarityParams = new NamedList();
         Version luceneVersion = getDefaultLuceneMatchVersion();
-        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7)) {
+        if (!luceneVersion.onOrAfter(Version.LUCENE_4_7_0)) {
           similarityParams.add(DefaultSimilarityFactory.DISCOUNT_OVERLAPS, false);
         }
         similarityFactory.init(SolrParams.toSolrParams(similarityParams));
diff --git solr/core/src/test/org/apache/solr/analysis/TestLuceneMatchVersion.java solr/core/src/test/org/apache/solr/analysis/TestLuceneMatchVersion.java
index e755f3c..24b4f5a 100644
--- solr/core/src/test/org/apache/solr/analysis/TestLuceneMatchVersion.java
+++ solr/core/src/test/org/apache/solr/analysis/TestLuceneMatchVersion.java
@@ -37,7 +37,7 @@ public class TestLuceneMatchVersion extends SolrTestCaseJ4 {
   
   // this must match the solrconfig.xml version for this test
   public static final Version DEFAULT_VERSION =
-    Config.parseLuceneVersionString(System.getProperty("tests.luceneMatchVersion", "LUCENE_CURRENT"));
+    Config.parseLuceneVersionString(System.getProperty("tests.luceneMatchVersion", "LATEST"));
 
   public void testStandardTokenizerVersions() throws Exception {
     assertEquals(DEFAULT_VERSION, solrConfig.luceneMatchVersion);
@@ -51,18 +51,17 @@ public class TestLuceneMatchVersion extends SolrTestCaseJ4 {
 
     type = schema.getFieldType("text40");
     ana = (TokenizerChain) type.getIndexAnalyzer();
-    assertEquals(Version.LUCENE_4_0, (ana.getTokenizerFactory()).getLuceneMatchVersion());
-    assertEquals(Version.LUCENE_5_0, (ana.getTokenFilterFactories()[2]).getLuceneMatchVersion());
+    assertEquals(Version.LUCENE_4_0_0, (ana.getTokenizerFactory()).getLuceneMatchVersion());
+    assertEquals(Version.LUCENE_5_0_0, (ana.getTokenFilterFactories()[2]).getLuceneMatchVersion());
 
     type = schema.getFieldType("textTurkishAnalyzerDefault");
     Analyzer ana1 = type.getIndexAnalyzer();
     assertTrue(ana1 instanceof TurkishAnalyzer);
-    System.out.println("DEFAULT_VERSION = " + ana1.getVersion().name());
     assertEquals(DEFAULT_VERSION, ana1.getVersion());
 
     type = schema.getFieldType("textTurkishAnalyzer40");
     ana1 = type.getIndexAnalyzer();
     assertTrue(ana1 instanceof TurkishAnalyzer);
-    assertEquals(Version.LUCENE_4_0, ana1.getVersion());
+    assertEquals(Version.LUCENE_4_0_0, ana1.getVersion());
   }
 }
diff --git solr/core/src/test/org/apache/solr/rest/schema/TestSerializedLuceneMatchVersion.java solr/core/src/test/org/apache/solr/rest/schema/TestSerializedLuceneMatchVersion.java
index d137eda..ca3d8ed 100644
--- solr/core/src/test/org/apache/solr/rest/schema/TestSerializedLuceneMatchVersion.java
+++ solr/core/src/test/org/apache/solr/rest/schema/TestSerializedLuceneMatchVersion.java
@@ -45,13 +45,13 @@ public class TestSerializedLuceneMatchVersion extends RestTestBase {
             "count(/response/lst[@name='fieldType']) = 1",
         
             "//lst[str[@name='class'][.='org.apache.solr.analysis.MockCharFilterFactory']]"
-           +"     [str[@name='luceneMatchVersion'][.='LUCENE_4_0']]",
+           +"     [str[@name='luceneMatchVersion'][.='4.0.0']]",
         
             "//lst[str[@name='class'][.='org.apache.solr.analysis.MockTokenizerFactory']]"
-           +"     [str[@name='luceneMatchVersion'][.='LUCENE_4_0']]",
+           +"     [str[@name='luceneMatchVersion'][.='4.0.0']]",
         
             "//lst[str[@name='class'][.='org.apache.solr.analysis.MockTokenFilterFactory']]"
-           +"     [str[@name='luceneMatchVersion'][.='LUCENE_4_0']]");
+           +"     [str[@name='luceneMatchVersion'][.='4.0.0']]");
   }
 
   @Test
diff --git solr/core/src/test/org/apache/solr/search/similarities/TestNonDefinedSimilarityFactory.java solr/core/src/test/org/apache/solr/search/similarities/TestNonDefinedSimilarityFactory.java
index 70cb5e0..f78e8d4 100644
--- solr/core/src/test/org/apache/solr/search/similarities/TestNonDefinedSimilarityFactory.java
+++ solr/core/src/test/org/apache/solr/search/similarities/TestNonDefinedSimilarityFactory.java
@@ -18,7 +18,6 @@ package org.apache.solr.search.similarities;
  */
 
 import org.apache.lucene.search.similarities.DefaultSimilarity;
-import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.util.Version;
 import org.junit.After;
 
@@ -36,21 +35,21 @@ public class TestNonDefinedSimilarityFactory extends BaseSimilarityTestCase {
   }
 
   public void testCurrent() throws Exception {
-    // no sys prop set, rely on LUCENE_CURRENT
+    // no sys prop set, rely on LATEST
     initCore("solrconfig-basic.xml","schema-tiny.xml");
     DefaultSimilarity sim = getSimilarity("text", DefaultSimilarity.class);
     assertEquals(true, sim.getDiscountOverlaps());
   }
 
   public void test47() throws Exception {
-    System.setProperty("tests.luceneMatchVersion", Version.LUCENE_4_7.toString());
+    System.setProperty("tests.luceneMatchVersion", Version.LUCENE_4_7_0.toString());
     initCore("solrconfig-basic.xml","schema-tiny.xml");
     DefaultSimilarity sim = getSimilarity("text", DefaultSimilarity.class);
     assertEquals(true, sim.getDiscountOverlaps());
   }
 
   public void test46() throws Exception {
-    System.setProperty("tests.luceneMatchVersion", Version.LUCENE_4_6.toString());
+    System.setProperty("tests.luceneMatchVersion", Version.LUCENE_4_6_0.toString());
     initCore("solrconfig-basic.xml","schema-tiny.xml");
     DefaultSimilarity sim = getSimilarity("text", DefaultSimilarity.class);
     assertEquals(false, sim.getDiscountOverlaps());
