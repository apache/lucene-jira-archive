Index: lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomPlaneTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomPlaneTest.java	(date 1516881857000)
+++ lucene/spatial3d/src/test/org/apache/lucene/spatial3d/geom/RandomPlaneTest.java	(revision )
@@ -51,7 +51,7 @@
     }
   }
 
-  /*
+
   @Test
   @Repeat(iterations = 10)
   public void testPolygonAccuracy() {
@@ -70,5 +70,5 @@
 
     }
   }
-  */
+
 }
Index: lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java	(date 1516881857000)
+++ lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory.java	(revision )
@@ -162,6 +162,14 @@
     if (filteredPointList == null) {
       return null;
     }
+
+    //First approximation to find a point
+    final GeoPoint centerOfMass = getCenterOfMass(filteredPointList);
+    final Boolean isCenterOfMassInside = isInsidePolygon(centerOfMass, filteredPointList);
+    if (isCenterOfMassInside != null) {
+      return generateGeoPolygon(planetModel, filteredPointList, holes, centerOfMass, isCenterOfMassInside);
+    }
+    
     //System.err.println("points="+pointList);
     // Create a random number generator.  Effectively this furnishes us with a repeatable sequence
     // of points to use for poles.
@@ -182,6 +190,19 @@
     }
     throw new IllegalArgumentException("cannot find a point that is inside the polygon "+filteredPointList);
   }
+
+  private static GeoPoint getCenterOfMass(List<GeoPoint> points) {
+    double x = 0;
+    double y = 0;
+    double z = 0;
+    //get center of mass
+    for (GeoPoint point : points) {
+      x += point.x;
+      y += point.y;
+      z += point.z;
+    }
+    return new GeoPoint(x / points.size(), y / points.size(), z / points.size());
+  }
   
   /** Use this class to specify a polygon with associated holes.
    */
