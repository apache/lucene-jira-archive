diff --git a/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java b/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java
index 778cb63..4481a78 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java
@@ -85,10 +85,10 @@ final class BooleanWeight extends Weight {
           subs.add(e);
           sum += e.getValue();
         } else if (c.isRequired()) {
-          subs.add(Explanation.match(0f, "match on required clause, product of:",
+          subs.add(Explanation.match(0f, "match on required clause, product of:", Explanation.Condition.REQUIRED,
               Explanation.match(0f, Occur.FILTER + " clause"), e));
         } else if (c.isProhibited()) {
-          subs.add(Explanation.noMatch("match on prohibited clause (" + c.getQuery().toString() + ")", e));
+          subs.add(Explanation.noMatch("match on prohibited clause (" + c.getQuery().toString() + ")", Explanation.Condition.PROHIBITED, e));
           fail = true;
         }
         if (!c.isProhibited()) {
@@ -98,19 +98,23 @@ final class BooleanWeight extends Weight {
           shouldMatchCount++;
         }
       } else if (c.isRequired()) {
-        subs.add(Explanation.noMatch("no match on required clause (" + c.getQuery().toString() + ")", e));
+        subs.add(Explanation.noMatch("no match on required clause (" + c.getQuery().toString() + ")", Explanation.Condition.REQUIRED, e));
         fail = true;
+      } else if (c.isProhibited()) {
+        subs.add(Explanation.noMatch("no match on prohibited clause (" + c.getQuery().toString() + ")", Explanation.Condition.OPTIONAL, e));
+      } else {
+        subs.add(Explanation.noMatch("no match on optional clause (" + c.getQuery().toString() + ")", Explanation.Condition.OPTIONAL, e));
       }
     }
     if (fail) {
-      return Explanation.noMatch("Failure to meet condition(s) of required/prohibited clause(s)", subs);
+      return Explanation.noMatch("Failure to meet condition(s) of required/prohibited clause(s)", Explanation.Condition.REQUIRED, subs);
     } else if (matchCount == 0) {
-      return Explanation.noMatch("No matching clauses", subs);
+      return Explanation.noMatch("No matching clauses", Explanation.Condition.REQUIRED, subs);
     } else if (shouldMatchCount < minShouldMatch) {
-      return Explanation.noMatch("Failure to match minimum number of optional clauses: " + minShouldMatch, subs);
+      return Explanation.noMatch("Failure to match minimum number of optional clauses: " + minShouldMatch, Explanation.Condition.REQUIRED, subs);
     } else {
       // we have a match
-      return Explanation.match(sum, "sum of:", subs);
+      return Explanation.match(sum, "sum of:", Explanation.Condition.OPTIONAL, subs);
     }
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
index 4ea29d6..91ea954 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
@@ -146,10 +146,17 @@ public final class DisjunctionMaxQuery extends Query implements Iterable<Query>
       for (Weight wt : weights) {
         Explanation e = wt.explain(context, doc);
         if (e.isMatch()) {
+          if (match == false) {
+            // discard any accumulated non-matching subs since the explanation won't need them
+            subs.clear();
+          }
           match = true;
           subs.add(e);
           sum += e.getValue();
           max = Math.max(max, e.getValue());
+        } else if (match == false) {
+          // accumulate the non-matching subs so we can explain the no-match case in detail
+          subs.add(e);
         }
       }
       if (match) {
@@ -157,7 +164,7 @@ public final class DisjunctionMaxQuery extends Query implements Iterable<Query>
         final String desc = tieBreakerMultiplier == 0.0f ? "max of:" : "max plus " + tieBreakerMultiplier + " times others of:";
         return Explanation.match(score, desc, subs);
       } else {
-        return Explanation.noMatch("No matching clause");
+        return Explanation.noMatch("No matching clause", Explanation.Condition.OPTIONAL, subs);
       }
     }
     
diff --git a/lucene/core/src/java/org/apache/lucene/search/Explanation.java b/lucene/core/src/java/org/apache/lucene/search/Explanation.java
index 42e3ce7..e6aeeb4 100644
--- a/lucene/core/src/java/org/apache/lucene/search/Explanation.java
+++ b/lucene/core/src/java/org/apache/lucene/search/Explanation.java
@@ -27,13 +27,43 @@ import java.util.Objects;
 public final class Explanation {
 
   /**
+   * Explanations for non-matches, and prohibited matches may be annotated with a condition
+   * in order to guide analysis of the ultimate cause of a failed match.
+   */
+  public enum Condition {
+      NONE, OPTIONAL, REQUIRED, PROHIBITED
+  }
+
+  /**
+   * Create a new explanation for a match.
+   * @param value       the contribution to the score of the document
+   * @param condition   associated boolean condition
+   * @param description how {@code value} was computed
+   * @param details     sub explanations that contributed to this explanation
+   */
+  public static Explanation match(float value, String description, Condition condition, Collection<Explanation> details) {
+    return new Explanation(true, value, description, condition, details);
+  }
+
+  /**
    * Create a new explanation for a match.
    * @param value       the contribution to the score of the document
    * @param description how {@code value} was computed
    * @param details     sub explanations that contributed to this explanation
    */
   public static Explanation match(float value, String description, Collection<Explanation> details) {
-    return new Explanation(true, value, description, details);
+    return new Explanation(true, value, description, Condition.NONE, details);
+  }
+
+  /**
+   * Create a new explanation for a match.
+   * @param value       the contribution to the score of the document
+   * @param description how {@code value} was computed
+   * @param condition   associated boolean condition
+   * @param details     sub explanations that contributed to this explanation
+   */
+  public static Explanation match(float value, String description, Condition condition, Explanation... details) {
+    return new Explanation(true, value, description, condition, Arrays.asList(details));
   }
 
   /**
@@ -43,32 +73,64 @@ public final class Explanation {
    * @param details     sub explanations that contributed to this explanation
    */
   public static Explanation match(float value, String description, Explanation... details) {
-    return new Explanation(true, value, description, Arrays.asList(details));
+    return new Explanation(true, value, description, Condition.NONE, Arrays.asList(details));
+  }
+
+  /**
+   * Create a new explanation for a match.
+   * @param value       the contribution to the score of the document
+   * @param description how {@code value} was computed
+   */
+  public static Explanation match(float value, String description) {
+    return new Explanation(true, value, description, Condition.NONE, Collections.emptyList());
+  }
+
+  /**
+   * Create a new explanation for a document which does not match.
+   */
+  public static Explanation noMatch(String description, Condition condition, Collection<Explanation> details) {
+    return new Explanation(false, 0f, description, condition, details);
   }
 
   /**
    * Create a new explanation for a document which does not match.
    */
   public static Explanation noMatch(String description, Collection<Explanation> details) {
-    return new Explanation(false, 0f, description, details);
+    return new Explanation(false, 0f, description, Condition.NONE, details);
+  }
+
+  /**
+   * Create a new explanation for a document which does not match.
+   */
+  public static Explanation noMatch(String description, Condition condition, Explanation... details) {
+    return new Explanation(false, 0f, description, condition, Arrays.asList(details));
   }
 
   /**
    * Create a new explanation for a document which does not match.
    */
   public static Explanation noMatch(String description, Explanation... details) {
-    return new Explanation(false, 0f, description, Arrays.asList(details));
+    return new Explanation(false, 0f, description, Condition.NONE, Arrays.asList(details));
+  }
+
+  /**
+   * Create a new explanation for a document which does not match.
+   */
+  public static Explanation noMatch(String description) {
+    return new Explanation(false, 0f, description, Condition.NONE, Collections.emptyList());
   }
 
   private final boolean match;                          // whether the document matched
   private final float value;                            // the value of this node
+  private final Condition condition;                    // boolean condition
   private final String description;                     // what it represents
   private final List<Explanation> details;              // sub-explanations
 
   /** Create a new explanation  */
-  private Explanation(boolean match, float value, String description, Collection<Explanation> details) {
+  private Explanation(boolean match, float value, String description, Condition condition, Collection<Explanation> details) {
     this.match = match;
     this.value = value;
+    this.condition = condition;
     this.description = Objects.requireNonNull(description);
     this.details = Collections.unmodifiableList(new ArrayList<>(details));
     for (Explanation detail : details) {
@@ -98,6 +160,44 @@ public final class Explanation {
     return details.toArray(new Explanation[0]);
   }
 
+  /**
+   * @return a list of brief explanations of the ultimate causes of failure of a query to match.
+   */
+  public List<String> getFailureCauses() {
+    if ((isMatch() != (condition == Condition.PROHIBITED))) {
+      // success: either a wanted clause matched, or a prohibited clause did not match
+      return Collections.emptyList();
+    }
+    if (condition == Condition.NONE) {
+      //return Collections.emptyList();
+      return Collections.singletonList(getDescription());
+    }
+    List<String> causes = new ArrayList<>();
+    if (condition == Condition.REQUIRED || condition == Condition.PROHIBITED) {
+      if (getDetails().length == 0) {
+        return Collections.singletonList(getDescription());
+      }
+      // (((main_title:postit)^2.0 | single-index-body:postit | (single-index-body-keywords:postit)^0.5)~0.01)
+      
+      for (Explanation sub : getDetails()) {
+        causes.addAll(sub.getFailureCauses());
+      }
+      if (causes.size() == 0) {
+        // All details were optional, dive inside the optional clauses looking for required ones
+        for (Explanation sub : getDetails()) {
+          for (Explanation subsub : sub.getDetails()) {
+            causes.addAll(subsub.getFailureCauses());
+          }
+        }
+      }
+      if (causes.size() == 0) {
+        // still empty?! return our full explanation
+        return Collections.singletonList(toString());
+      }
+    }
+    return causes;
+  }
+
   /** Render an explanation as text. */
   @Override
   public String toString() {
diff --git a/lucene/core/src/java/org/apache/lucene/search/SortRescorer.java b/lucene/core/src/java/org/apache/lucene/search/SortRescorer.java
index f051d38..c7681e8 100644
--- a/lucene/core/src/java/org/apache/lucene/search/SortRescorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/SortRescorer.java
@@ -102,7 +102,7 @@ public class SortRescorer extends Rescorer {
     List<Explanation> subs = new ArrayList<>();
 
     // Add first pass:
-    Explanation first = Explanation.match(firstPassExplanation.getValue(), "first pass score", firstPassExplanation);
+    Explanation first = Explanation.match(firstPassExplanation.getValue(), "first pass score", Explanation.Condition.OPTIONAL, firstPassExplanation);
     subs.add(first);
 
     FieldDoc fieldDoc = (FieldDoc) hits.scoreDocs[0];
@@ -115,6 +115,6 @@ public class SortRescorer extends Rescorer {
 
     // TODO: if we could ask the Sort to explain itself then
     // we wouldn't need the separate ExpressionRescorer...
-    return Explanation.match(0.0f, "sort field values for sort=" + sort.toString(), subs);
+    return Explanation.match(0.0f, "sort field values for sort=" + sort.toString(), Explanation.Condition.NONE, subs);
   }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java b/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
index c718dc9..8c6b20d 100644
--- a/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
@@ -177,10 +177,18 @@ public final class SynonymQuery extends Query {
               scoreExplanation.getValue(),
               "weight(" + getQuery() + " in " + doc + ") ["
                   + similarity.getClass().getSimpleName() + "], result of:",
-              scoreExplanation);
+              Explanation.Condition.OPTIONAL, scoreExplanation);
         }
       }
-      return Explanation.noMatch("no matching term");
+      StringBuilder buf = new StringBuilder();
+      buf.append("no matching term ");
+      for (int i = 0; i < terms.length; i++) {
+          if (i > 0) {
+              buf.append(", ");
+          }
+          buf.append(terms[i].toString());
+      }
+      return Explanation.noMatch(buf.toString(), Explanation.Condition.REQUIRED);
     }
 
     @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/TermQuery.java b/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
index e3e299f..1a2e71e 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TermQuery.java
@@ -151,7 +151,7 @@ public class TermQuery extends Query {
               scoreExplanation);
         }
       }
-      return Explanation.noMatch("no matching term");
+      return Explanation.noMatch("no matching term " + term, Explanation.Condition.REQUIRED);
     }
   }
 
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/CheckHits.java b/lucene/test-framework/src/java/org/apache/lucene/search/CheckHits.java
index dee7d84..988438f 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/CheckHits.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/CheckHits.java
@@ -350,7 +350,9 @@ public class CheckHits {
     if (descr.startsWith("score based on ") && descr.contains("child docs in range")) {
       Assert.assertTrue("Child doc explanations are missing", detail.length > 0);
     }
-    if (detail.length > 0) {
+    // Boolean failures may have details that don't sum up to zero
+    boolean hasFailedClauses = descr.contains("clause") && !expl.isMatch();
+    if (detail.length > 0 && !hasFailedClauses) {
       if (detail.length==1) {
         // simple containment, unless it's a freq of: (which lets a query explain how the freq is calculated), 
         // just verify contained expl has same score
