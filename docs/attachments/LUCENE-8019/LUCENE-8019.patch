diff --git a/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java b/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
index c5d9ddc..6648762 100644
--- a/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
+++ b/lucene/core/src/java/org/apache/lucene/search/IndexSearcher.java
@@ -22,6 +22,7 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Objects;
 import java.util.Set;
@@ -804,4 +805,132 @@ public class IndexSearcher {
 
     return new CollectionStatistics(field, reader.maxDoc(), docCount, sumTotalTermFreq, sumDocFreq);
   }
+
+  /**
+   * Returns a list of the ultimate causes of failure of a query to match a specific document.
+   * Each cause is a BooleanClause: a Query together with a condition indicating whether it was required, prohibited,
+   * or optional. When an optional cause is returned, the indication is that at least one (maybe more) of the optional
+   * causes would have had to match in order for the overall query to match.
+   *
+   * If the query in fact does match the document, an empty list is returned.
+   *
+   * This is an expensive operation intended for debugging queries, not for use in normal search workloads.
+   * @throws IOException if the given doc is deleted, or if an IOException is thrown while scoring the query.
+   */
+  public List<BooleanClause> getNoMatchClauses(Query query, int doc) throws IOException {
+    return getNoMatchClauses(createNormalizedWeight(query, true), doc);
+  }
+
+  private List<BooleanClause> getNoMatchClauses(Weight weight, int doc) throws IOException {
+    int n = ReaderUtil.subIndex(doc, leafContexts);
+    final LeafReaderContext ctx = leafContexts.get(n);
+    int deBasedDoc = doc - ctx.docBase;
+    final Bits liveDocs = ctx.reader().getLiveDocs();
+    if (liveDocs != null && liveDocs.get(deBasedDoc) == false) {
+      throw new IOException("Document " + doc + " is deleted");
+    }
+    // return getNoMatchClauses(weight, ctx, doc, BooleanClause.Occur.MUST);
+    Scorer scorer = weight.scorer(ctx);
+    if (scorer == null) {
+      return Collections.singletonList(new BooleanClause(weight.getQuery(), BooleanClause.Occur.MUST));
+    }
+    scorer.iterator().advance(doc);
+    return getNoMatchClauses(scorer, doc, BooleanClause.Occur.MUST);
+  }
+
+  private List<BooleanClause> getNoMatchClauses(Scorer scorer, int doc, BooleanClause.Occur occur) throws IOException {
+    boolean matches = scorer.docID() == doc;
+    boolean permitted = (occur != BooleanClause.Occur.MUST_NOT);
+    if (matches == permitted) {
+      return Collections.emptyList();
+    }
+    Query query = scorer.weight.getQuery();
+    if (query instanceof TermQuery) {
+      return Collections.singletonList(new BooleanClause(query, occur));
+    }
+    if (query instanceof BooleanQuery) {
+      List<BooleanClause> requiredCauses = new ArrayList<>();
+      List<BooleanClause> optionalCauses = new ArrayList<>();
+      Iterator<BooleanClause> cIter = ((BooleanQuery) query).iterator();
+      for (Scorer.ChildScorer childScorer : scorer.getChildren()) {
+        // FIXME: this generally fails because even "matching" child scorers will have been advanced beyond doc
+        BooleanClause c = cIter.next();
+        BooleanClause.Occur childOccur = permitted ? c.getOccur() : BooleanClause.Occur.MUST;
+        if (c.isProhibited()) {
+          requiredCauses.addAll(getNoMatchClauses(childScorer.child, doc, childOccur));
+        } else if (c.isRequired() == permitted) {
+          requiredCauses.addAll(getNoMatchClauses(childScorer.child, doc, childOccur));
+        } else {
+          optionalCauses.addAll(getNoMatchClauses(childScorer.child, doc, childOccur));
+        }
+      }
+      if (requiredCauses.isEmpty()) {
+        return optionalCauses;
+      } else {
+        return requiredCauses;
+      }
+    }
+    if (query instanceof DisjunctionMaxQuery) {
+      // Handle any pure disjunction queries here by returning all of their reasons
+      BooleanClause.Occur childOccur = permitted ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;
+      List<BooleanClause> causes = new ArrayList<>();
+      for (Scorer.ChildScorer childScorer : scorer.getChildren()) {
+        causes.addAll(getNoMatchClauses(childScorer.child, doc, childOccur));
+      }
+    }
+    // fall back to just listing the query that failed, without any deeper explanation
+    return Collections.singletonList(new BooleanClause(query, BooleanClause.Occur.MUST));
+  }
+
+  /*
+  FIXME: unused Weight-based approach. This fails with:
+  java.lang.ClassCastException: org.apache.lucene.search.LRUQueryCache$CachingWrapperWeight cannot be cast to org.apache.lucene.search.BooleanWeight
+   */
+  private List<BooleanClause> getNoMatchClauses(Weight weight, LeafReaderContext ctx, int doc, BooleanClause.Occur occur) throws IOException {
+    Scorer scorer = weight.scorer(ctx);
+    if (scorer == null) {
+      return Collections.singletonList(new BooleanClause(weight.getQuery(), BooleanClause.Occur.MUST));
+    }
+    boolean matches = doc == scorer.iterator().advance(doc);
+    boolean permitted = (occur != BooleanClause.Occur.MUST_NOT);
+    if (matches == permitted) {
+      return Collections.emptyList();
+    }
+    Query query = weight.getQuery();
+    if (query instanceof TermQuery) {
+      return Collections.singletonList(new BooleanClause(query, occur));
+    }
+    if (query instanceof BooleanQuery) {
+      List<BooleanClause> requiredCauses = new ArrayList<>();
+      List<BooleanClause> optionalCauses = new ArrayList<>();
+      Iterator<BooleanClause> cIter = ((BooleanQuery) query).iterator();
+      for (Weight childWeight : ((BooleanWeight) weight).weights) {
+        BooleanClause c = cIter.next();
+        BooleanClause.Occur childOccur = permitted ? c.getOccur() : BooleanClause.Occur.MUST;
+        if (c.isProhibited()) {
+          requiredCauses.addAll(getNoMatchClauses(childWeight, ctx, doc, childOccur));
+        } else if (c.isRequired() == permitted) {
+          requiredCauses.addAll(getNoMatchClauses(childWeight, ctx, doc, childOccur));
+        } else {
+          optionalCauses.addAll(getNoMatchClauses(childWeight, ctx, doc, childOccur));
+        }
+      }
+      if (requiredCauses.isEmpty()) {
+        return optionalCauses;
+      } else {
+        return requiredCauses;
+      }
+    }
+    if (query instanceof DisjunctionMaxQuery) {
+      // Handle any pure disjunction queries here by returning all of their reasons
+      BooleanClause.Occur childOccur = permitted ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;
+      List<BooleanClause> causes = new ArrayList<>();
+      for (Scorer.ChildScorer childScorer : scorer.getChildren()) {
+        causes.addAll(getNoMatchClauses(childScorer.child.weight, ctx, doc, childOccur));
+      }
+    }
+    // fall back to just listing the query that failed, without any deeper explanation
+    return Collections.singletonList(new BooleanClause(query, BooleanClause.Occur.MUST));
+  }
+
 }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java b/lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java
index 8748a1a..c7a791a 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestIndexSearcher.java
@@ -19,6 +19,7 @@ package org.apache.lucene.search;
 
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.List;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
@@ -219,4 +220,86 @@ public class TestIndexSearcher extends LuceneTestCase {
     searcher = new IndexSearcher(new MultiReader());
     assertEquals(dummyPolicy, searcher.getQueryCachingPolicy());
   }
+
+  public void testNoMatchClauses() throws IOException {
+    IndexSearcher searcher = new IndexSearcher(reader);
+    Query qf1 = new TermQuery(new Term("field", "1"));
+    Query qf2 = new TermQuery(new Term("field", "2"));
+    Query qf3 = new TermQuery(new Term("field", "3"));
+    int doc1 = searcher.search(qf1, 1).scoreDocs[0].doc;
+
+    // Match: qf1 matches doc1
+    assertTrue(searcher.getNoMatchClauses(qf1, doc1).isEmpty());
+
+    // unmatched TermQuery
+    List<BooleanClause> noMatchClauses = searcher.getNoMatchClauses(qf2, doc1);
+    assertEquals(1, noMatchClauses.size());
+    assertEquals(qf2, noMatchClauses.get(0).getQuery());
+    assertEquals(Occur.MUST, noMatchClauses.get(0).getOccur());
+
+    // matched prohibited TermQuery, rewritten to a MatchNoDocs query:
+    BooleanQuery bq = new BooleanQuery.Builder().add(qf1, Occur.MUST_NOT).build();
+    noMatchClauses = searcher.getNoMatchClauses(bq, doc1);
+    assertEquals(1, noMatchClauses.size());
+    assertEquals(new MatchNoDocsQuery(), noMatchClauses.get(0).getQuery());
+    assertEquals(Occur.MUST, noMatchClauses.get(0).getOccur());
+
+    // matched prohibited TermQuery
+    bq = new BooleanQuery.Builder().add(qf1, Occur.MUST_NOT).add(new MatchAllDocsQuery(), Occur.MUST).build();
+    //assertEquals("", searcher.explain(bq, doc1).getDescription());
+    noMatchClauses = searcher.getNoMatchClauses(bq, doc1);
+    // FIXME These assertions fail due to ReqExclScorer not including all of its children:
+    // assertEquals(1, noMatchClauses.size());
+    // assertEquals(qf1, noMatchClauses.get(0).getQuery());
+    // assertEquals(Occur.MUST_NOT, noMatchClauses.get(0).getOccur());
+
+    // unmatched required clause
+    bq = new BooleanQuery.Builder().add(qf1, Occur.MUST).add(qf2, Occur.MUST).build();
+    noMatchClauses = searcher.getNoMatchClauses(bq, doc1);
+    assertEquals(1, noMatchClauses.size());
+    assertEquals(qf2, noMatchClauses.get(0).getQuery());
+    assertEquals(Occur.MUST, noMatchClauses.get(0).getOccur());
+
+    // unmatched optional clause
+    bq = new BooleanQuery.Builder().add(qf2, Occur.SHOULD).add(qf3, Occur.SHOULD).build();
+    noMatchClauses = searcher.getNoMatchClauses(bq, doc1);
+    assertEquals(2, noMatchClauses.size());
+    assertEquals(qf2, noMatchClauses.get(0).getQuery());
+    assertEquals(Occur.SHOULD, noMatchClauses.get(0).getOccur());
+    assertEquals(qf3, noMatchClauses.get(1).getQuery());
+    assertEquals(Occur.SHOULD, noMatchClauses.get(1).getOccur());
+
+    // unmatched dismax query
+    DisjunctionMaxQuery dmq = new DisjunctionMaxQuery(Arrays.asList(qf2, qf3), 1);
+    noMatchClauses = searcher.getNoMatchClauses(dmq, doc1);
+    assertEquals(2, noMatchClauses.size());
+    assertEquals(qf2, noMatchClauses.get(0).getQuery());
+    assertEquals(Occur.SHOULD, noMatchClauses.get(0).getOccur());
+    assertEquals(qf3, noMatchClauses.get(1).getQuery());
+    assertEquals(Occur.SHOULD, noMatchClauses.get(1).getOccur());
+
+    // unmatched phrase query as a representative of queries for which we fall back to generic handling
+    PhraseQuery pq = new PhraseQuery("field", "1", "2");
+    try {
+      noMatchClauses = searcher.getNoMatchClauses(pq, doc1);
+      assertEquals(1, noMatchClauses.size());
+      assertEquals(pq, noMatchClauses.get(0).getQuery());
+      assertEquals(Occur.MUST, noMatchClauses.get(0).getOccur());
+    } catch (IllegalStateException e) {
+      // sometimes there are no positions
+    }
+
+    // nested boolean with negations
+    bq = new BooleanQuery.Builder()
+        .add(new BooleanQuery.Builder().add(qf1, Occur.SHOULD).add(qf2, Occur.SHOULD).build(), Occur.MUST_NOT)
+        .add(new BooleanQuery.Builder().add(qf2, Occur.MUST).add(qf3, Occur.MUST).build(), Occur.MUST_NOT)
+        .add(new BooleanQuery.Builder().add(qf1, Occur.MUST_NOT).add(new MatchAllDocsQuery(), Occur.MUST).build(), Occur.MUST_NOT)
+        .add(new MatchAllDocsQuery(), Occur.MUST)
+        .build();
+    noMatchClauses = searcher.getNoMatchClauses(bq, doc1);
+    assertEquals(1, noMatchClauses.size());
+    assertEquals(qf1, noMatchClauses.get(0).getQuery());
+    assertEquals(Occur.SHOULD, noMatchClauses.get(0).getOccur());
+
+  }
 }
