Index: src/test/org/apache/lucene/queryParser/TestQueryParser.java
===================================================================
--- src/test/org/apache/lucene/queryParser/TestQueryParser.java	(revision 469278)
+++ src/test/org/apache/lucene/queryParser/TestQueryParser.java	(working copy)
@@ -30,6 +30,7 @@
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.ConstantScoreRangeQuery;
 import org.apache.lucene.search.FuzzyQuery;
 import org.apache.lucene.search.Hits;
 import org.apache.lucene.search.IndexSearcher;
@@ -370,7 +371,12 @@
 
   public void testRange() throws Exception {
     assertQueryEquals("[ a TO z]", null, "[a TO z]");
-    assertTrue(getQuery("[ a TO z]", null) instanceof RangeQuery);
+    assertTrue(getQuery("[ a TO z]", null) instanceof ConstantScoreRangeQuery);
+
+    QueryParser qp = new QueryParser("field", new SimpleAnalyzer());
+	qp.setUseOldRangeQuery(true);
+    assertTrue(qp.parse("[ a TO z]") instanceof RangeQuery);
+    
     assertQueryEquals("[ a TO z ]", null, "[a TO z]");
     assertQueryEquals("{ a TO z}", null, "{a TO z}");
     assertQueryEquals("{ a TO z }", null, "{a TO z}");
Index: src/java/org/apache/lucene/queryParser/QueryParser.java
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParser.java	(revision 469278)
+++ src/java/org/apache/lucene/queryParser/QueryParser.java	(working copy)
@@ -82,6 +82,7 @@
   private Operator operator = OR_OPERATOR;
 
   boolean lowercaseExpandedTerms = true;
+  boolean useOldRangeQuery= false;
   boolean allowLeadingWildcard = false;
 
   Analyzer analyzer;
@@ -250,6 +251,28 @@
   }
 
   /**
+   * By default QueryParser uses new ConstantScoreRangeQuery in preference to RangeQuery
+   * for range queries. This implementation is generally preferable because it 
+   * a) Runs faster b) Does not have the scarcity of range terms unduly influence score 
+   * c) avoids any "TooManyBooleanClauses" exception.
+   * However, if your application really needs to use the old-fashioned RangeQuery and the above
+   * points are not required then set this option to <code>true</code>
+   * Default is <code>false</code>.
+   */
+  public void setUseOldRangeQuery(boolean useOldRangeQuery) {
+    this.useOldRangeQuery = useOldRangeQuery;
+  }
+
+
+  /**
+   * @see #setUseOldRangeQuery(boolean)
+   */
+  public boolean getUseOldRangeQuery() {
+    return useOldRangeQuery;
+  }
+
+
+  /**
    * Set locale used by date range parsing.
    */
   public void setLocale(Locale locale) {
@@ -454,9 +477,16 @@
     }
     catch (Exception e) { }
 
-    return new RangeQuery(new Term(field, part1),
+    if(useOldRangeQuery)
+    {
+            return new RangeQuery(new Term(field, part1),
                           new Term(field, part2),
                           inclusive);
+    }
+    else
+    {
+      return new ConstantScoreRangeQuery(field,part1,part2,inclusive,inclusive);
+    }
   }
 
   /**
Index: src/java/org/apache/lucene/queryParser/QueryParser.jj
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParser.jj	(revision 469278)
+++ src/java/org/apache/lucene/queryParser/QueryParser.jj	(working copy)
@@ -105,6 +105,7 @@
   private Operator operator = OR_OPERATOR;
 
   boolean lowercaseExpandedTerms = true;
+  boolean useOldRangeQuery= false;  
   boolean allowLeadingWildcard = false;
 
   Analyzer analyzer;
@@ -271,8 +272,30 @@
   public boolean getLowercaseExpandedTerms() {
     return lowercaseExpandedTerms;
   }
+  
+  /**
+   * By default QueryParser uses new ConstantScoreRangeQuery in preference to RangeQuery
+   * for range queries. This implementation is generally preferable because it 
+   * a) Runs faster b) Does not have the scarcity of range terms unduly influence score 
+   * c) avoids any "TooManyBooleanClauses" exception.
+   * However, if your application really needs to use the old-fashioned RangeQuery and the above
+   * points are not required then set this option to <code>true</code>
+   * Default is <code>false</code>.
+   */
+  public void setUseOldRangeQuery(boolean useOldRangeQuery) {
+    this.useOldRangeQuery = useOldRangeQuery;
+  }
 
+
   /**
+   * @see #setUseOldRangeQuery(boolean)
+   */
+  public boolean getUseOldRangeQuery() {
+    return useOldRangeQuery;
+  }
+  
+
+  /**
    * Set locale used by date range parsing.
    */
   public void setLocale(Locale locale) {
@@ -477,9 +500,16 @@
     }
     catch (Exception e) { }
 
-    return new RangeQuery(new Term(field, part1),
+    if(useOldRangeQuery)
+    {
+	    return new RangeQuery(new Term(field, part1),
                           new Term(field, part2),
                           inclusive);
+    }
+    else
+    {
+      return new ConstantScoreRangeQuery(field,part1,part2,inclusive,inclusive);
+    }
   }
 
   /**
