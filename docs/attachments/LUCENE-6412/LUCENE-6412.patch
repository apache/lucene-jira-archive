Index: benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiQueryMaker.java
===================================================================
--- benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiQueryMaker.java	(revision 1672105)
+++ benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/EnwikiQueryMaker.java	(working copy)
@@ -17,23 +17,23 @@
  * limitations under the License.
  */
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.standard.StandardAnalyzer;
+import org.apache.lucene.benchmark.byTask.tasks.NewAnalyzerTask;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryparser.classic.QueryParser;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.search.spans.SpanFirstQuery;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.benchmark.byTask.tasks.NewAnalyzerTask;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
 /**
  * A QueryMaker that uses common and uncommon actual Wikipedia queries for
  * searching the English Wikipedia collection. 90 queries total.
@@ -75,13 +75,13 @@
     wcq .setRewriteMethod(MultiTermQuery.CONSTANT_SCORE_REWRITE);
     // be wary of unanalyzed text
     return new Query[] {
-        new SpanFirstQuery(new SpanTermQuery(new Term(field, "ford")), 5),
+        new SpanFirstQuery(new TermQuery(new Term(field, "ford")), 5),
         new SpanNearQuery(new SpanQuery[] {
-            new SpanTermQuery(new Term(field, "night")),
-            new SpanTermQuery(new Term(field, "trading")) }, 4, false),
+            new TermQuery(new Term(field, "night")),
+            new TermQuery(new Term(field, "trading")) }, 4, false),
         new SpanNearQuery(new SpanQuery[] {
-            new SpanFirstQuery(new SpanTermQuery(new Term(field, "ford")), 10),
-            new SpanTermQuery(new Term(field, "credit")) }, 10, false), wcq, };
+            new SpanFirstQuery(new TermQuery(new Term(field, "ford")), 10),
+            new TermQuery(new Term(field, "credit")) }, 10, false), wcq, };
   }
 
   /**
Index: benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java
===================================================================
--- benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java	(revision 1672105)
+++ benchmark/src/java/org/apache/lucene/benchmark/byTask/feeds/ReutersQueryMaker.java	(working copy)
@@ -18,15 +18,15 @@
  */
 
 import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.benchmark.byTask.tasks.NewAnalyzerTask;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.queryparser.classic.QueryParser;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.search.spans.SpanFirstQuery;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.benchmark.byTask.tasks.NewAnalyzerTask;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -57,9 +57,9 @@
   private static Query[] getPrebuiltQueries(String field) {
     //  be wary of unanalyzed text
     return new Query[] {
-        new SpanFirstQuery(new SpanTermQuery(new Term(field, "ford")), 5),
-        new SpanNearQuery(new SpanQuery[]{new SpanTermQuery(new Term(field, "night")), new SpanTermQuery(new Term(field, "trading"))}, 4, false),
-        new SpanNearQuery(new SpanQuery[]{new SpanFirstQuery(new SpanTermQuery(new Term(field, "ford")), 10), new SpanTermQuery(new Term(field, "credit"))}, 10, false),
+        new SpanFirstQuery(new TermQuery(new Term(field, "ford")), 5),
+        new SpanNearQuery(new SpanQuery[]{new TermQuery(new Term(field, "night")), new TermQuery(new Term(field, "trading"))}, 4, false),
+        new SpanNearQuery(new SpanQuery[]{new SpanFirstQuery(new TermQuery(new Term(field, "ford")), 10), new TermQuery(new Term(field, "credit"))}, 10, false),
         new WildcardQuery(new Term(field, "fo*")),
     };
   }
Index: core/src/java/org/apache/lucene/search/TermQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/TermQuery.java	(revision 1672105)
+++ core/src/java/org/apache/lucene/search/TermQuery.java	(working copy)
@@ -17,9 +17,6 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.Set;
-
 import org.apache.lucene.index.IndexReaderContext;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
@@ -28,18 +25,26 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.index.TermState;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
+import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.search.spans.TermSpans;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.ToStringUtils;
 
+import java.io.IOException;
+import java.util.Map;
+import java.util.Set;
+
 /**
  * A Query that matches documents containing a term. This may be combined with
  * other terms with a {@link BooleanQuery}.
  */
-public class TermQuery extends Query {
-  private final Term term;
+public class TermQuery extends SpanQuery {
+  protected final Term term;
   private final int docFreq;
   private final TermContext perReaderTermState;
   
@@ -166,8 +171,50 @@
   public Term getTerm() {
     return term;
   }
-  
+
   @Override
+  public Spans getSpans(LeafReaderContext context, Bits acceptDocs, Map<Term, TermContext> termContexts) throws IOException {
+    TermContext termContext = termContexts.get(term);
+    final TermState state;
+    if (termContext == null) {
+      // this happens with span-not query, as it doesn't include the NOT side in extractTerms()
+      // so we seek to the term now in this segment..., this sucks because it's ugly mostly!
+      final Terms terms = context.reader().terms(term.field());
+      if (terms != null) {
+        if (terms.hasPositions() == false) {
+          throw new IllegalStateException("field \"" + term.field() + "\" was indexed without position data; cannot run SpanTermQuery (term=" + term.text() + ")");
+        }
+
+        final TermsEnum termsEnum = terms.iterator(null);
+        if (termsEnum.seekExact(term.bytes())) {
+          state = termsEnum.termState();
+        } else {
+          state = null;
+        }
+      } else {
+        state = null;
+      }
+    } else {
+      state = termContext.get(context.ord);
+    }
+
+    if (state == null) { // term is not present in that reader
+      return null;
+    }
+
+    final TermsEnum termsEnum = context.reader().terms(term.field()).iterator(null);
+    termsEnum.seekExact(term.bytes(), state);
+
+    final PostingsEnum postings = termsEnum.postings(acceptDocs, null, PostingsEnum.PAYLOADS);
+    return new TermSpans(postings, term);
+  }
+
+  @Override
+  public String getField() {
+    return term.field();
+  }
+
+  @Override
   public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     final IndexReaderContext context = searcher.getTopReaderContext();
     final TermContext termState;
Index: core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
===================================================================
--- core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java	(revision 1672105)
+++ core/src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java	(working copy)
@@ -17,18 +17,9 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.TreeSet;
-
-import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
 import org.apache.lucene.search.BooleanClause;
@@ -42,9 +33,17 @@
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.Spans;
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeSet;
+
 /**
  * Experimental class to get set of payloads for most standard Lucene queries.
  * Operates like Highlighter - IndexReader should only contain doc of interest,
@@ -94,7 +93,7 @@
       Term[] phraseQueryTerms = ((PhraseQuery) query).getTerms();
       SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];
       for (int i = 0; i < phraseQueryTerms.length; i++) {
-        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);
+        clauses[i] = new TermQuery(phraseQueryTerms[i]);
       }
 
       int slop = ((PhraseQuery) query).getSlop();
@@ -107,10 +106,6 @@
       SpanNearQuery sp = new SpanNearQuery(clauses, slop, inorder);
       sp.setBoost(query.getBoost());
       getPayloads(payloads, sp);
-    } else if (query instanceof TermQuery) {
-      SpanTermQuery stq = new SpanTermQuery(((TermQuery) query).getTerm());
-      stq.setBoost(query.getBoost());
-      getPayloads(payloads, stq);
     } else if (query instanceof SpanQuery) {
       getPayloads(payloads, (SpanQuery) query);
     } else if (query instanceof FilteredQuery) {
@@ -148,7 +143,7 @@
             ++distinctPositions;
           }
           for (final Term term : termArray) {
-            disjuncts.add(new SpanTermQuery(term));
+            disjuncts.add(new TermQuery(term));
           }
         }
 
Index: core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java	(revision 1672105)
+++ core/src/java/org/apache/lucene/search/payloads/PayloadTermQuery.java	(working copy)
@@ -17,9 +17,6 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.Objects;
-
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.PostingsEnum;
 import org.apache.lucene.index.Term;
@@ -26,22 +23,23 @@
 import org.apache.lucene.search.ComplexExplanation;
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.similarities.Similarity.SimScorer;
-import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanScorer;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.SpanWeight;
+import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.search.spans.TermSpans;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 
+import java.io.IOException;
+import java.util.Objects;
+
 /**
- * This class is very similar to
- * {@link org.apache.lucene.search.spans.SpanTermQuery} except that it factors
+ * This class factors
  * in the value of the payload located at each of the positions where the
  * {@link org.apache.lucene.index.Term} occurs.
  * <p>
@@ -52,7 +50,7 @@
  * Payload scores are aggregated using a pluggable {@link PayloadFunction}.
  * @see org.apache.lucene.search.similarities.Similarity.SimScorer#computePayloadFactor(int, int, int, BytesRef)
  **/
-public class PayloadTermQuery extends SpanTermQuery {
+public class PayloadTermQuery extends TermQuery {
   protected PayloadFunction function;
   private boolean includeSpanScore;
 
Index: core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java	(revision 1672105)
+++ core/src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java	(working copy)
@@ -17,20 +17,21 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.Map;
-import java.util.Set;
-
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.Weight;
-import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.ToStringUtils;
 
+import java.io.IOException;
+import java.util.Map;
+import java.util.Set;
+
 /**
  * <p>Wrapper to allow {@link SpanQuery} objects participate in composite 
  * single-field SpanQueries by 'lying' about their search field. That is, 
@@ -58,10 +59,10 @@
  * </pre>
  * 
  * <p>a SpanNearQuery with a slop of 0 can be applied across two 
- * {@link SpanTermQuery} objects as follows:
+ * {@link TermQuery} objects as follows:
  * <pre class="prettyprint">
- *    SpanQuery q1  = new SpanTermQuery(new Term("studentfirstname", "james"));
- *    SpanQuery q2  = new SpanTermQuery(new Term("studentsurname", "jones"));
+ *    SpanQuery q1  = new TermQuery(new Term("studentfirstname", "james"));
+ *    SpanQuery q2  = new TermQuery(new Term("studentsurname", "jones"));
  *    SpanQuery q2m = new FieldMaskingSpanQuery(q2, "studentfirstname");
  *    Query q = new SpanNearQuery(new SpanQuery[]{q1, q2m}, -1, false);
  * </pre>
@@ -106,7 +107,7 @@
   }  
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     return maskedQuery.createWeight(searcher, needsScores);
   }
 
Index: core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java	(revision 1672105)
+++ core/src/java/org/apache/lucene/search/spans/SpanMultiTermQueryWrapper.java	(working copy)
@@ -17,20 +17,21 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.Map;
-
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.ScoringRewrite;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopTermsRewrite;
-import org.apache.lucene.search.ScoringRewrite;
-import org.apache.lucene.search.BooleanClause.Occur; // javadocs only
 import org.apache.lucene.util.Bits;
 
+import java.io.IOException;
+import java.util.Map;
+
 /**
  * Wraps any {@link MultiTermQuery} as a {@link SpanQuery}, 
  * so it can be nested within other SpanQuery classes.
@@ -179,7 +180,7 @@
         // TODO: would be nice to not lose term-state here.
         // we could add a hack option to SpanOrQuery, but the hack would only work if this is the top-level Span
         // (if you put this thing in another span query, it would extractTerms/double-seek anyway)
-        final SpanTermQuery q = new SpanTermQuery(term);
+        final TermQuery q = new TermQuery(term);
         q.setBoost(boost);
         topLevel.addClause(q);
       }
@@ -223,7 +224,7 @@
 
         @Override
         protected void addClause(SpanOrQuery topLevel, Term term, int docFreq, float boost, TermContext states) {
-          final SpanTermQuery q = new SpanTermQuery(term);
+          final TermQuery q = new TermQuery(term);
           q.setBoost(boost);
           topLevel.addClause(q);
         }
Index: core/src/java/org/apache/lucene/search/spans/SpanQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanQuery.java	(revision 1672105)
+++ core/src/java/org/apache/lucene/search/spans/SpanQuery.java	(working copy)
@@ -17,16 +17,17 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.Map;
-
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Weight;
 import org.apache.lucene.util.Bits;
 
+import java.io.IOException;
+import java.util.Map;
+
 /** Base class for span-based queries. */
 public abstract class SpanQuery extends Query {
   /** Expert: Returns the matches for this query in an index.  
@@ -43,7 +44,7 @@
   public abstract String getField();
 
   @Override
-  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
     return new SpanWeight(this, searcher);
   }
 
Index: core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(revision 1672105)
+++ core/src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(working copy)
@@ -17,108 +17,26 @@
  * limitations under the License.
  */
 
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.Weight;
+
 import java.io.IOException;
-import java.util.Map;
-import java.util.Set;
-import java.util.Objects;
 
-import org.apache.lucene.index.PostingsEnum;
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.Term;
-import org.apache.lucene.index.TermContext;
-import org.apache.lucene.index.TermState;
-import org.apache.lucene.index.Terms;
-import org.apache.lucene.index.TermsEnum;
-import org.apache.lucene.util.Bits;
-import org.apache.lucene.util.ToStringUtils;
-
-/** Matches spans containing a term.
- * This should not be used for terms that are indexed at position Integer.MAX_VALUE.
+/**
+ * @deprecated use TermQuery
  */
-public class SpanTermQuery extends SpanQuery {
-  protected Term term;
+@Deprecated
+public class SpanTermQuery extends TermQuery {
 
   /** Construct a SpanTermQuery matching the named term's spans. */
   public SpanTermQuery(Term term) {
-    this.term = Objects.requireNonNull(term);
+    super(term);
   }
 
-  /** Return the term whose spans are matched. */
-  public Term getTerm() { return term; }
-
   @Override
-  public String getField() { return term.field(); }
-
-  @Override
-  public void extractTerms(Set<Term> terms) {
-    terms.add(term);
+  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    return new SpanWeight(this, searcher);
   }
-
-  @Override
-  public String toString(String field) {
-    StringBuilder buffer = new StringBuilder();
-    if (term.field().equals(field))
-      buffer.append(term.text());
-    else
-      buffer.append(term.toString());
-    buffer.append(ToStringUtils.boost(getBoost()));
-    return buffer.toString();
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = super.hashCode();
-    result = prime * result + term.hashCode();
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (!super.equals(obj))
-      return false;
-    if (getClass() != obj.getClass())
-      return false;
-    SpanTermQuery other = (SpanTermQuery) obj;
-    return term.equals(other.term);
-  }
-
-  @Override
-  public Spans getSpans(final LeafReaderContext context, Bits acceptDocs, Map<Term,TermContext> termContexts) throws IOException {
-    TermContext termContext = termContexts.get(term);
-    final TermState state;
-    if (termContext == null) {
-      // this happens with span-not query, as it doesn't include the NOT side in extractTerms()
-      // so we seek to the term now in this segment..., this sucks because it's ugly mostly!
-      final Terms terms = context.reader().terms(term.field());
-      if (terms != null) {
-        if (terms.hasPositions() == false) {
-          throw new IllegalStateException("field \"" + term.field() + "\" was indexed without position data; cannot run SpanTermQuery (term=" + term.text() + ")");
-        }
-
-        final TermsEnum termsEnum = terms.iterator(null);
-        if (termsEnum.seekExact(term.bytes())) {
-          state = termsEnum.termState();
-        } else {
-          state = null;
-        }
-      } else {
-        state = null;
-      }
-    } else {
-      state = termContext.get(context.ord);
-    }
-
-    if (state == null) { // term is not present in that reader
-      return null;
-    }
-
-    final TermsEnum termsEnum = context.reader().terms(term.field()).iterator(null);
-    termsEnum.seekExact(term.bytes(), state);
-
-    final PostingsEnum postings = termsEnum.postings(acceptDocs, null, PostingsEnum.PAYLOADS);
-    return new TermSpans(postings, term);
-  }
 }
Index: core/src/java/org/apache/lucene/search/spans/package-info.java
===================================================================
--- core/src/java/org/apache/lucene/search/spans/package-info.java	(revision 1672105)
+++ core/src/java/org/apache/lucene/search/spans/package-info.java	(working copy)
@@ -26,7 +26,7 @@
  * 
  * <ul>
  * 
- * <li>A {@link org.apache.lucene.search.spans.SpanTermQuery SpanTermQuery} matches all spans
+ * <li>A {@link org.apache.lucene.search.TermQuery TermQuery} matches all spans
  *    containing a particular {@link org.apache.lucene.index.Term Term}.
  *    This should not be used for terms that are indexed at position Integer.MAX_VALUE.
  * </li>
@@ -33,7 +33,7 @@
  * 
  * <li> A {@link org.apache.lucene.search.spans.SpanNearQuery SpanNearQuery} matches spans
  * which occur near one another, and can be used to implement things like
- * phrase search (when constructed from {@link org.apache.lucene.search.spans.SpanTermQuery}s)
+ * phrase search (when constructed from {@link org.apache.lucene.search.TermQuery}s)
  * and inter-phrase proximity (when constructed from other {@link org.apache.lucene.search.spans.SpanNearQuery}s).</li>
  * 
  * <li>A {@link org.apache.lucene.search.spans.SpanOrQuery SpanOrQuery} merges spans from a
Index: core/src/test/org/apache/lucene/search/TestBooleanQuery.java
===================================================================
--- core/src/test/org/apache/lucene/search/TestBooleanQuery.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/TestBooleanQuery.java	(working copy)
@@ -17,16 +17,6 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.BitSet;
-import java.util.List;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
@@ -44,12 +34,21 @@
 import org.apache.lucene.search.BooleanTopLevelScorers.BoostedScorer;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.NamedThreadFactory;
 import org.apache.lucene.util.TestUtil;
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
 public class TestBooleanQuery extends LuceneTestCase {
 
   public void testEquality() throws Exception {
@@ -314,8 +313,8 @@
     IndexSearcher searcher = newSearcher(indexReader);
 
     BooleanQuery query = new BooleanQuery();
-    SpanQuery sq1 = new SpanTermQuery(new Term(FIELD, "clockwork"));
-    SpanQuery sq2 = new SpanTermQuery(new Term(FIELD, "clckwork"));
+    SpanQuery sq1 = new TermQuery(new Term(FIELD, "clockwork"));
+    SpanQuery sq2 = new TermQuery(new Term(FIELD, "clckwork"));
     query.add(sq1, BooleanClause.Occur.SHOULD);
     query.add(sq2, BooleanClause.Occur.SHOULD);
     TopScoreDocCollector collector = TopScoreDocCollector.create(1000);
Index: core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java
===================================================================
--- core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/TestDisjunctionMaxQuery.java	(working copy)
@@ -17,11 +17,6 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.text.DecimalFormat;
-import java.text.DecimalFormatSymbols;
-import java.util.Locale;
-
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
@@ -41,10 +36,14 @@
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 
+import java.io.IOException;
+import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
+import java.util.Locale;
+
 /**
  * Test of the DisjunctionMaxQuery.
  * 
@@ -494,8 +493,8 @@
     IndexSearcher searcher = newSearcher(indexReader);
 
     DisjunctionMaxQuery query = new DisjunctionMaxQuery(1.0f);
-    SpanQuery sq1 = new SpanTermQuery(new Term(FIELD, "clockwork"));
-    SpanQuery sq2 = new SpanTermQuery(new Term(FIELD, "clckwork"));
+    SpanQuery sq1 = new TermQuery(new Term(FIELD, "clockwork"));
+    SpanQuery sq2 = new TermQuery(new Term(FIELD, "clckwork"));
     query.add(sq1);
     query.add(sq2);
     TopScoreDocCollector collector = TopScoreDocCollector.create(1000);
Index: core/src/test/org/apache/lucene/search/TestPositionIncrement.java
===================================================================
--- core/src/test/org/apache/lucene/search/TestPositionIncrement.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/TestPositionIncrement.java	(working copy)
@@ -17,35 +17,36 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.io.StringReader;
-import java.nio.charset.StandardCharsets;
-import java.util.Collection;
-
-import org.apache.lucene.analysis.*;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockPayloadAnalyzer;
+import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.PostingsEnum;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.SlowCompositeReaderWrapper;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.store.Directory;
 import org.apache.lucene.search.payloads.PayloadSpanUtil;
 import org.apache.lucene.search.spans.MultiSpansWrapper;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.Spans;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.BytesRef;
 
+import java.io.IOException;
+import java.io.StringReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Collection;
+
 /**
  * Term position unit test.
  *
@@ -228,8 +229,8 @@
 
     IndexSearcher is = newSearcher(readerFromWriter);
   
-    SpanTermQuery stq1 = new SpanTermQuery(new Term("content", "a"));
-    SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
+    TermQuery stq1 = new TermQuery(new Term("content", "a"));
+    TermQuery stq2 = new TermQuery(new Term("content", "k"));
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 30, false);
 
Index: core/src/test/org/apache/lucene/search/TestQueryRescorer.java
===================================================================
--- core/src/test/org/apache/lucene/search/TestQueryRescorer.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/TestQueryRescorer.java	(working copy)
@@ -17,11 +17,6 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.Set;
-
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.NumericDocValuesField;
@@ -33,12 +28,16 @@
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.TestUtil;
 
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.Set;
+
 public class TestQueryRescorer extends LuceneTestCase {
 
   private IndexSearcher getSearcher(IndexReader r) {
@@ -92,8 +91,8 @@
     assertEquals("0", searcher.doc(hits2.scoreDocs[1].doc).get("id"));
 
     // Resort using SpanNearQuery:
-    SpanTermQuery t1 = new SpanTermQuery(new Term("field", "wizard"));
-    SpanTermQuery t2 = new SpanTermQuery(new Term("field", "oz"));
+    TermQuery t1 = new TermQuery(new Term("field", "wizard"));
+    TermQuery t2 = new TermQuery(new Term("field", "oz"));
     SpanNearQuery snq = new SpanNearQuery(new SpanQuery[] {t1, t2}, 0, true);
 
     TopDocs hits3 = QueryRescorer.rescore(searcher, hits, snq, 2.0, 10);
@@ -319,8 +318,8 @@
     assertEquals("0", searcher.doc(hits2.scoreDocs[1].doc).get("id"));
 
     // Resort using SpanNearQuery:
-    SpanTermQuery t1 = new SpanTermQuery(new Term("field", "wizard"));
-    SpanTermQuery t2 = new SpanTermQuery(new Term("field", "oz"));
+    TermQuery t1 = new TermQuery(new Term("field", "wizard"));
+    TermQuery t2 = new TermQuery(new Term("field", "oz"));
     SpanNearQuery snq = new SpanNearQuery(new SpanQuery[] {t1, t2}, 0, true);
 
     TopDocs hits3 = QueryRescorer.rescore(searcher, hits, snq, 2.0, 10);
Index: core/src/test/org/apache/lucene/search/payloads/TestPayloadNearQuery.java
===================================================================
--- core/src/test/org/apache/lucene/search/payloads/TestPayloadNearQuery.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/payloads/TestPayloadNearQuery.java	(working copy)
@@ -15,9 +15,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-import java.io.IOException;
 
-import org.apache.lucene.analysis.*;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
@@ -27,15 +30,15 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.CollectionStatistics;
 import org.apache.lucene.search.Explanation;
+import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.QueryUtils;
 import org.apache.lucene.search.ScoreDoc;
-import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TermStatistics;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
+import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanNearQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.English;
@@ -43,7 +46,9 @@
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
+import java.io.IOException;
 
+
 public class TestPayloadNearQuery extends LuceneTestCase {
   private static IndexSearcher searcher;
   private static IndexReader reader;
@@ -97,7 +102,7 @@
     String[] words = phrase.split("[\\s]+");
     SpanQuery clauses[] = new SpanQuery[words.length];
     for (int i=0;i<clauses.length;i++) {
-      clauses[i] = new SpanTermQuery(new Term(fieldName, words[i]));  
+      clauses[i] = new TermQuery(new Term(fieldName, words[i]));
     } 
     return new PayloadNearQuery(clauses, 0, inOrder, function);
   }
Index: core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java
===================================================================
--- core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/payloads/TestPayloadTermQuery.java	(working copy)
@@ -16,31 +16,35 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.analysis.*;
-import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.English;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.FieldInvertState;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.CheckHits;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
-import org.apache.lucene.search.ScoreDoc;
-import org.apache.lucene.search.CheckHits;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.search.similarities.Similarity;
 import org.apache.lucene.search.spans.MultiSpansWrapper;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.Spans;
-import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.FieldInvertState;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.Term;
 import org.apache.lucene.store.Directory;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.Field;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.English;
+import org.apache.lucene.util.LuceneTestCase;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
@@ -174,9 +178,9 @@
     PayloadTermQuery boostingFuncTermQuery = new PayloadTermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"),
         new MaxPayloadFunction());
     QueryUtils.check(boostingFuncTermQuery);
-    
-    SpanTermQuery spanTermQuery = new SpanTermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"));
 
+    TermQuery spanTermQuery = new TermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"));
+
     assertTrue(boostingFuncTermQuery.equals(spanTermQuery) == spanTermQuery.equals(boostingFuncTermQuery));
     
     PayloadTermQuery boostingFuncTermQuery2 = new PayloadTermQuery(new Term(PayloadHelper.MULTI_FIELD, "seventy"),
Index: core/src/test/org/apache/lucene/search/similarities/TestSimilarity2.java
===================================================================
--- core/src/test/org/apache/lucene/search/similarities/TestSimilarity2.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/similarities/TestSimilarity2.java	(working copy)
@@ -17,9 +17,6 @@
  * limitations under the License.
  */
 
-import java.util.ArrayList;
-import java.util.List;
-
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FieldType;
@@ -35,10 +32,12 @@
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.spans.SpanOrQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 
+import java.util.ArrayList;
+import java.util.List;
+
 /**
  * Tests against all the similarities we have
  */
@@ -226,8 +225,8 @@
     
     for (Similarity sim : sims) {
       is.setSimilarity(sim);
-      SpanTermQuery s1 = new SpanTermQuery(new Term("foo", "bar"));
-      SpanTermQuery s2 = new SpanTermQuery(new Term("foo", "baz"));
+      TermQuery s1 = new TermQuery(new Term("foo", "bar"));
+      TermQuery s2 = new TermQuery(new Term("foo", "baz"));
       Query query = new SpanOrQuery(s1, s2);
       TopDocs td = is.search(query, 10);
       assertEquals(1, td.totalHits);
Index: core/src/test/org/apache/lucene/search/spans/TestBasics.java
===================================================================
--- core/src/test/org/apache/lucene/search/spans/TestBasics.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/spans/TestBasics.java	(working copy)
@@ -17,14 +17,11 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-
-import org.apache.lucene.analysis.*;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
 import org.apache.lucene.document.Document;
@@ -49,6 +46,13 @@
 import org.junit.BeforeClass;
 import org.junit.Test;
 
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
 /**
  * Tests basic search capabilities.
  *
@@ -203,8 +207,8 @@
 
   @Test
   public void testSpanNearExact() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "seventy"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "seven"));
+    TermQuery term1 = new TermQuery(new Term("field", "seventy"));
+    TermQuery term2 = new TermQuery(new Term("field", "seven"));
     SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {term1, term2},
                                             0, true);
     checkHits(query, new int[]
@@ -218,8 +222,8 @@
     QueryUtils.checkUnequal(term1,term2);
   }
   
-  public void testSpanTermQuery() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "seventy"));
+  public void testTermQuery() throws Exception {
+    TermQuery term1 = new TermQuery(new Term("field", "seventy"));
     checkHits(term1, new int[]
                              { 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 170,
         171, 172, 173, 174, 175, 176, 177, 178, 179, 270, 271, 272, 273, 274,
@@ -241,8 +245,8 @@
 
   @Test
   public void testSpanNearUnordered() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "nine"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "six"));
+    TermQuery term1 = new TermQuery(new Term("field", "nine"));
+    TermQuery term2 = new TermQuery(new Term("field", "six"));
     SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {term1, term2},
                                             4, false);
 
@@ -255,8 +259,8 @@
 
   @Test
   public void testSpanNearOrdered() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "nine"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "six"));
+    TermQuery term1 = new TermQuery(new Term("field", "nine"));
+    TermQuery term2 = new TermQuery(new Term("field", "six"));
     SpanNearQuery query = new SpanNearQuery(new SpanQuery[] {term1, term2},
                                             4, true);
     checkHits(query, new int[]
@@ -265,11 +269,11 @@
 
   @Test
   public void testSpanNot() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
+    TermQuery term1 = new TermQuery(new Term("field", "eight"));
+    TermQuery term2 = new TermQuery(new Term("field", "one"));
     SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
                                            4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
+    TermQuery term3 = new TermQuery(new Term("field", "forty"));
     SpanNotQuery query = new SpanNotQuery(near, term3);
 
     checkHits(query, new int[]
@@ -281,11 +285,11 @@
   
   @Test
   public void testSpanWithMultipleNotSingle() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
+    TermQuery term1 = new TermQuery(new Term("field", "eight"));
+    TermQuery term2 = new TermQuery(new Term("field", "one"));
     SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
                                            4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
+    TermQuery term3 = new TermQuery(new Term("field", "forty"));
 
     SpanOrQuery or = new SpanOrQuery(term3);
 
@@ -301,13 +305,13 @@
 
   @Test
   public void testSpanWithMultipleNotMany() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
+    TermQuery term1 = new TermQuery(new Term("field", "eight"));
+    TermQuery term2 = new TermQuery(new Term("field", "one"));
     SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
                                            4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
-    SpanTermQuery term4 = new SpanTermQuery(new Term("field", "sixty"));
-    SpanTermQuery term5 = new SpanTermQuery(new Term("field", "eighty"));
+    TermQuery term3 = new TermQuery(new Term("field", "forty"));
+    TermQuery term4 = new TermQuery(new Term("field", "sixty"));
+    TermQuery term5 = new TermQuery(new Term("field", "eighty"));
 
     SpanOrQuery or = new SpanOrQuery(term3, term4, term5);
 
@@ -322,12 +326,12 @@
 
   @Test
   public void testNpeInSpanNearWithSpanNot() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
+    TermQuery term1 = new TermQuery(new Term("field", "eight"));
+    TermQuery term2 = new TermQuery(new Term("field", "one"));
     SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
                                            4, true);
-    SpanTermQuery hun = new SpanTermQuery(new Term("field", "hundred"));
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
+    TermQuery hun = new TermQuery(new Term("field", "hundred"));
+    TermQuery term3 = new TermQuery(new Term("field", "forty"));
     SpanNearQuery exclude = new SpanNearQuery(new SpanQuery[] {hun, term3},
                                               1, true);
     
@@ -344,9 +348,9 @@
   @Test
   public void testNpeInSpanNearInSpanFirstInSpanNot() throws Exception {
     int n = 5;
-    SpanTermQuery hun = new SpanTermQuery(new Term("field", "hundred"));
-    SpanTermQuery term40 = new SpanTermQuery(new Term("field", "forty"));
-    SpanTermQuery term40c = (SpanTermQuery)term40.clone();
+    TermQuery hun = new TermQuery(new Term("field", "hundred"));
+    TermQuery term40 = new TermQuery(new Term("field", "forty"));
+    TermQuery term40c = (TermQuery)term40.clone();
 
     SpanFirstQuery include = new SpanFirstQuery(term40, n);
     SpanNearQuery near = new SpanNearQuery(new SpanQuery[]{hun, term40c},
@@ -365,11 +369,11 @@
   
   @Test
   public void testSpanNotWindowOne() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "forty"));
+    TermQuery term1 = new TermQuery(new Term("field", "eight"));
+    TermQuery term2 = new TermQuery(new Term("field", "forty"));
     SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
                                            4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "one"));
+    TermQuery term3 = new TermQuery(new Term("field", "one"));
     SpanNotQuery query = new SpanNotQuery(near, term3, 1, 1);
 
     checkHits(query, new int[]
@@ -382,11 +386,11 @@
   
   @Test
   public void testSpanNotWindowTwoBefore() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "forty"));
+    TermQuery term1 = new TermQuery(new Term("field", "eight"));
+    TermQuery term2 = new TermQuery(new Term("field", "forty"));
     SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
                                            4, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "one"));
+    TermQuery term3 = new TermQuery(new Term("field", "one"));
     SpanNotQuery query = new SpanNotQuery(near, term3, 2, 0);
 
     checkHits(query, new int[]
@@ -399,11 +403,11 @@
   @Test
   public void testSpanNotWindowNeg() throws Exception {
      //test handling of invalid window < 0
-     SpanTermQuery term1 = new SpanTermQuery(new Term("field", "eight"));
-     SpanTermQuery term2 = new SpanTermQuery(new Term("field", "one"));
+     TermQuery term1 = new TermQuery(new Term("field", "eight"));
+     TermQuery term2 = new TermQuery(new Term("field", "one"));
      SpanNearQuery near = new SpanNearQuery(new SpanQuery[] {term1, term2},
                                             4, true);
-     SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
+     TermQuery term3 = new TermQuery(new Term("field", "forty"));
 
      SpanOrQuery or = new SpanOrQuery(term3);
 
@@ -420,10 +424,10 @@
   @Test
   public void testSpanNotWindowDoubleExcludesBefore() throws Exception {
      //test hitting two excludes before an include
-     SpanTermQuery term1 = new SpanTermQuery(new Term("field", "forty"));
-     SpanTermQuery term2 = new SpanTermQuery(new Term("field", "two"));
-     SpanNearQuery near = new SpanNearQuery(new SpanTermQuery[]{term1, term2}, 2, true);
-     SpanTermQuery exclude = new SpanTermQuery(new Term("field", "one"));
+     TermQuery term1 = new TermQuery(new Term("field", "forty"));
+     TermQuery term2 = new TermQuery(new Term("field", "two"));
+     SpanNearQuery near = new SpanNearQuery(new TermQuery[]{term1, term2}, 2, true);
+     TermQuery exclude = new TermQuery(new Term("field", "one"));
 
      SpanNotQuery query = new SpanNotQuery(near, exclude, 4, 1);
 
@@ -436,7 +440,7 @@
   
   @Test
   public void testSpanFirst() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "five"));
+    TermQuery term1 = new TermQuery(new Term("field", "five"));
     SpanFirstQuery query = new SpanFirstQuery(term1, 1);
 
     checkHits(query, new int[]
@@ -457,7 +461,7 @@
   @Test
   public void testSpanPositionRange() throws Exception {
     SpanPositionRangeQuery query;
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "five"));
+    TermQuery term1 = new TermQuery(new Term("field", "five"));
     query = new SpanPositionRangeQuery(term1, 1, 2);
     checkHits(query, new int[]
       {25,35, 45, 55, 65, 75, 85, 95});
@@ -482,7 +486,7 @@
 
   @Test
   public void testSpanPayloadCheck() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "five"));
+    TermQuery term1 = new TermQuery(new Term("field", "five"));
     BytesRef pay = new BytesRef(("pos: " + 5).getBytes(StandardCharsets.UTF_8));
     SpanQuery query = new SpanPayloadCheckQuery(term1, Collections.singletonList(pay.bytes));
     checkHits(query, new int[]
@@ -489,7 +493,7 @@
       {1125, 1135, 1145, 1155, 1165, 1175, 1185, 1195, 1225, 1235, 1245, 1255, 1265, 1275, 1285, 1295, 1325, 1335, 1345, 1355, 1365, 1375, 1385, 1395, 1425, 1435, 1445, 1455, 1465, 1475, 1485, 1495, 1525, 1535, 1545, 1555, 1565, 1575, 1585, 1595, 1625, 1635, 1645, 1655, 1665, 1675, 1685, 1695, 1725, 1735, 1745, 1755, 1765, 1775, 1785, 1795, 1825, 1835, 1845, 1855, 1865, 1875, 1885, 1895, 1925, 1935, 1945, 1955, 1965, 1975, 1985, 1995});
     assertTrue(searcher.explain(query, 1125).getValue() > 0.0f);
 
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "hundred"));
+    TermQuery term2 = new TermQuery(new Term("field", "hundred"));
     SpanNearQuery snq;
     SpanQuery[] clauses;
     List<byte[]> list;
@@ -509,7 +513,7 @@
     clauses = new SpanQuery[3];
     clauses[0] = term1;
     clauses[1] = term2;
-    clauses[2] = new SpanTermQuery(new Term("field", "five"));
+    clauses[2] = new TermQuery(new Term("field", "five"));
     snq = new SpanNearQuery(clauses, 0, true);
     pay = new BytesRef(("pos: " + 0).getBytes(StandardCharsets.UTF_8));
     pay2 = new BytesRef(("pos: " + 1).getBytes(StandardCharsets.UTF_8));
@@ -524,11 +528,11 @@
   }
 
   public void testComplexSpanChecks() throws Exception {
-    SpanTermQuery one = new SpanTermQuery(new Term("field", "one"));
-    SpanTermQuery thous = new SpanTermQuery(new Term("field", "thousand"));
+    TermQuery one = new TermQuery(new Term("field", "one"));
+    TermQuery thous = new TermQuery(new Term("field", "thousand"));
     //should be one position in between
-    SpanTermQuery hundred = new SpanTermQuery(new Term("field", "hundred"));
-    SpanTermQuery three = new SpanTermQuery(new Term("field", "three"));
+    TermQuery hundred = new TermQuery(new Term("field", "hundred"));
+    TermQuery three = new TermQuery(new Term("field", "three"));
 
     SpanNearQuery oneThous = new SpanNearQuery(new SpanQuery[]{one, thous}, 0, true);
     SpanNearQuery hundredThree = new SpanNearQuery(new SpanQuery[]{hundred, three}, 0, true);
@@ -558,12 +562,12 @@
 
   @Test
   public void testSpanOr() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "thirty"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "three"));
+    TermQuery term1 = new TermQuery(new Term("field", "thirty"));
+    TermQuery term2 = new TermQuery(new Term("field", "three"));
     SpanNearQuery near1 = new SpanNearQuery(new SpanQuery[] {term1, term2},
                                             0, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "forty"));
-    SpanTermQuery term4 = new SpanTermQuery(new Term("field", "seven"));
+    TermQuery term3 = new TermQuery(new Term("field", "forty"));
+    TermQuery term4 = new TermQuery(new Term("field", "seven"));
     SpanNearQuery near2 = new SpanNearQuery(new SpanQuery[] {term3, term4},
                                             0, true);
 
@@ -580,12 +584,12 @@
 
   @Test
   public void testSpanExactNested() throws Exception {
-    SpanTermQuery term1 = new SpanTermQuery(new Term("field", "three"));
-    SpanTermQuery term2 = new SpanTermQuery(new Term("field", "hundred"));
+    TermQuery term1 = new TermQuery(new Term("field", "three"));
+    TermQuery term2 = new TermQuery(new Term("field", "hundred"));
     SpanNearQuery near1 = new SpanNearQuery(new SpanQuery[] {term1, term2},
                                             0, true);
-    SpanTermQuery term3 = new SpanTermQuery(new Term("field", "thirty"));
-    SpanTermQuery term4 = new SpanTermQuery(new Term("field", "three"));
+    TermQuery term3 = new TermQuery(new Term("field", "thirty"));
+    TermQuery term4 = new TermQuery(new Term("field", "three"));
     SpanNearQuery near2 = new SpanNearQuery(new SpanQuery[] {term3, term4},
                                             0, true);
 
@@ -600,11 +604,11 @@
   @Test
   public void testSpanNearOr() throws Exception {
 
-    SpanTermQuery t1 = new SpanTermQuery(new Term("field","six"));
-    SpanTermQuery t3 = new SpanTermQuery(new Term("field","seven"));
+    TermQuery t1 = new TermQuery(new Term("field","six"));
+    TermQuery t3 = new TermQuery(new Term("field","seven"));
     
-    SpanTermQuery t5 = new SpanTermQuery(new Term("field","seven"));
-    SpanTermQuery t6 = new SpanTermQuery(new Term("field","six"));
+    TermQuery t5 = new TermQuery(new Term("field","seven"));
+    TermQuery t6 = new TermQuery(new Term("field","six"));
 
     SpanOrQuery to1 = new SpanOrQuery(t1, t3);
     SpanOrQuery to2 = new SpanOrQuery(t5, t6);
@@ -625,16 +629,16 @@
   @Test
   public void testSpanComplex1() throws Exception {
       
-    SpanTermQuery t1 = new SpanTermQuery(new Term("field","six"));
-    SpanTermQuery t2 = new SpanTermQuery(new Term("field","hundred"));
+    TermQuery t1 = new TermQuery(new Term("field","six"));
+    TermQuery t2 = new TermQuery(new Term("field","hundred"));
     SpanNearQuery tt1 = new SpanNearQuery(new SpanQuery[] {t1, t2}, 0,true);
 
-    SpanTermQuery t3 = new SpanTermQuery(new Term("field","seven"));
-    SpanTermQuery t4 = new SpanTermQuery(new Term("field","hundred"));
+    TermQuery t3 = new TermQuery(new Term("field","seven"));
+    TermQuery t4 = new TermQuery(new Term("field","hundred"));
     SpanNearQuery tt2 = new SpanNearQuery(new SpanQuery[] {t3, t4}, 0,true);
     
-    SpanTermQuery t5 = new SpanTermQuery(new Term("field","seven"));
-    SpanTermQuery t6 = new SpanTermQuery(new Term("field","six"));
+    TermQuery t5 = new TermQuery(new Term("field","seven"));
+    TermQuery t6 = new TermQuery(new Term("field","six"));
 
     SpanOrQuery to1 = new SpanOrQuery(tt1, tt2);
     SpanOrQuery to2 = new SpanOrQuery(t5, t6);
Index: core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java
===================================================================
--- core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/spans/TestFieldMaskingSpanQuery.java	(working copy)
@@ -17,9 +17,6 @@
  * limitations under the License.
  */
 
-import java.util.HashSet;
-import java.util.Set;
-
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
@@ -30,6 +27,7 @@
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.similarities.TFIDFSimilarity;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
@@ -36,6 +34,9 @@
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 
+import java.util.HashSet;
+import java.util.Set;
+
 public class TestFieldMaskingSpanQuery extends LuceneTestCase {
 
   protected static Document doc(Field[] fields) {
@@ -132,7 +133,7 @@
 
   public void testRewrite0() throws Exception {
     SpanQuery q = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "sally")) , "first");
+      (new TermQuery(new Term("last", "sally")) , "first");
     q.setBoost(8.7654321f);
     SpanQuery qr = (SpanQuery) searcher.rewrite(q);
 
@@ -146,11 +147,11 @@
   public void testRewrite1() throws Exception {
     // mask an anon SpanQuery class that rewrites to something else.
     SpanQuery q = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "sally")) {
+      (new TermQuery(new Term("last", "sally")) {
           @Override
           public Query rewrite(IndexReader reader) {
-            return new SpanOrQuery(new SpanTermQuery(new Term("first", "sally")),
-                new SpanTermQuery(new Term("first", "james")));
+            return new SpanOrQuery(new TermQuery(new Term("first", "sally")),
+                new TermQuery(new Term("first", "james")));
           }
         }, "first");
 
@@ -164,8 +165,8 @@
   }
   
   public void testRewrite2() throws Exception {
-    SpanQuery q1 = new SpanTermQuery(new Term("last", "smith"));
-    SpanQuery q2 = new SpanTermQuery(new Term("last", "jones"));
+    SpanQuery q1 = new TermQuery(new Term("last", "smith"));
+    SpanQuery q2 = new TermQuery(new Term("last", "jones"));
     SpanQuery q = new SpanNearQuery(new SpanQuery[]
       { q1, new FieldMaskingSpanQuery(q2, "last")}, 1, true );
     Query qr = searcher.rewrite(q);
@@ -179,15 +180,15 @@
   
   public void testEquality1() {
     SpanQuery q1 = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "sally")) , "first");
+      (new TermQuery(new Term("last", "sally")) , "first");
     SpanQuery q2 = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "sally")) , "first");
+      (new TermQuery(new Term("last", "sally")) , "first");
     SpanQuery q3 = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "sally")) , "XXXXX");
+      (new TermQuery(new Term("last", "sally")) , "XXXXX");
     SpanQuery q4 = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "XXXXX")) , "first");
+      (new TermQuery(new Term("last", "XXXXX")) , "first");
     SpanQuery q5 = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("xXXX", "sally")) , "first");
+      (new TermQuery(new Term("xXXX", "sally")) , "first");
     QueryUtils.checkEqual(q1, q2);
     QueryUtils.checkUnequal(q1, q3);
     QueryUtils.checkUnequal(q1, q4);
@@ -194,10 +195,10 @@
     QueryUtils.checkUnequal(q1, q5);
     
     SpanQuery qA = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "sally")) , "first");
+      (new TermQuery(new Term("last", "sally")) , "first");
     qA.setBoost(9f);
     SpanQuery qB = new FieldMaskingSpanQuery
-      (new SpanTermQuery(new Term("last", "sally")) , "first");
+      (new TermQuery(new Term("last", "sally")) , "first");
     QueryUtils.checkUnequal(qA, qB);
     qB.setBoost(9f);
     QueryUtils.checkEqual(qA, qB);
@@ -205,13 +206,13 @@
   }
   
   public void testNoop0() throws Exception {
-    SpanQuery q1 = new SpanTermQuery(new Term("last", "sally"));
+    SpanQuery q1 = new TermQuery(new Term("last", "sally"));
     SpanQuery q = new FieldMaskingSpanQuery(q1, "first");
     check(q, new int[] { /* :EMPTY: */ });
   }
   public void testNoop1() throws Exception {
-    SpanQuery q1 = new SpanTermQuery(new Term("last", "smith"));
-    SpanQuery q2 = new SpanTermQuery(new Term("last", "jones"));
+    SpanQuery q1 = new TermQuery(new Term("last", "smith"));
+    SpanQuery q2 = new TermQuery(new Term("last", "jones"));
     SpanQuery q = new SpanNearQuery(new SpanQuery[]
       { q1, new FieldMaskingSpanQuery(q2, "last")}, 0, true );
     check(q, new int[] { 1, 2 });
@@ -222,8 +223,8 @@
   }
   
   public void testSimple1() throws Exception {
-    SpanQuery q1 = new SpanTermQuery(new Term("first", "james"));
-    SpanQuery q2 = new SpanTermQuery(new Term("last", "jones"));
+    SpanQuery q1 = new TermQuery(new Term("first", "james"));
+    SpanQuery q2 = new TermQuery(new Term("last", "jones"));
     SpanQuery q = new SpanNearQuery(new SpanQuery[]
       { q1, new FieldMaskingSpanQuery(q2, "first")}, -1, false );
     check(q, new int[] { 0, 2 });
@@ -242,8 +243,8 @@
   public void testSimple2() throws Exception {
     assumeTrue("Broken scoring: LUCENE-3723", 
         searcher.getSimilarity() instanceof TFIDFSimilarity);
-    SpanQuery q1 = new SpanTermQuery(new Term("gender", "female"));
-    SpanQuery q2 = new SpanTermQuery(new Term("last", "smith"));
+    SpanQuery q1 = new TermQuery(new Term("gender", "female"));
+    SpanQuery q2 = new TermQuery(new Term("last", "smith"));
     SpanQuery q = new SpanNearQuery(new SpanQuery[]
       { q1, new FieldMaskingSpanQuery(q2, "gender")}, -1, false );
     check(q, new int[] { 2, 4 });
@@ -254,8 +255,8 @@
   }
 
   public void testSpans0() throws Exception {
-    SpanQuery q1 = new SpanTermQuery(new Term("gender", "female"));
-    SpanQuery q2 = new SpanTermQuery(new Term("first",  "james"));
+    SpanQuery q1 = new TermQuery(new Term("gender", "female"));
+    SpanQuery q2 = new TermQuery(new Term("first",  "james"));
     SpanQuery q  = new SpanOrQuery(q1, new FieldMaskingSpanQuery(q2, "gender"));
     check(q, new int[] { 0, 1, 2, 3, 4 });
 
@@ -274,8 +275,8 @@
   }
   
   public void testSpans1() throws Exception {
-    SpanQuery q1 = new SpanTermQuery(new Term("first", "sally"));
-    SpanQuery q2 = new SpanTermQuery(new Term("first", "james"));
+    SpanQuery q1 = new TermQuery(new Term("first", "sally"));
+    SpanQuery q2 = new TermQuery(new Term("first", "james"));
     SpanQuery qA = new SpanOrQuery(q1, q2);
     SpanQuery qB = new FieldMaskingSpanQuery(qA, "id");
                                             
@@ -299,10 +300,10 @@
   public void testSpans2() throws Exception {
     assumeTrue("Broken scoring: LUCENE-3723",
         searcher.getSimilarity() instanceof TFIDFSimilarity);
-    SpanQuery qA1 = new SpanTermQuery(new Term("gender", "female"));
-    SpanQuery qA2 = new SpanTermQuery(new Term("first",  "james"));
+    SpanQuery qA1 = new TermQuery(new Term("gender", "female"));
+    SpanQuery qA2 = new TermQuery(new Term("first",  "james"));
     SpanQuery qA  = new SpanOrQuery(qA1, new FieldMaskingSpanQuery(qA2, "gender"));
-    SpanQuery qB  = new SpanTermQuery(new Term("last",   "jones"));
+    SpanQuery qB  = new TermQuery(new Term("last",   "jones"));
     SpanQuery q   = new SpanNearQuery(new SpanQuery[]
       { new FieldMaskingSpanQuery(qA, "id"),
         new FieldMaskingSpanQuery(qB, "id") }, -1, false );
Index: core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java
===================================================================
--- core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/spans/TestNearSpansOrdered.java	(working copy)
@@ -20,10 +20,9 @@
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
-import org.apache.lucene.index.PostingsEnum;
-import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.CheckHits;
@@ -30,6 +29,7 @@
 import org.apache.lucene.search.Explanation;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.Weight;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
@@ -74,9 +74,9 @@
                                     int slop, boolean inOrder) {
     return new SpanNearQuery
       (new SpanQuery[] {
-        new SpanTermQuery(new Term(FIELD, s1)),
-        new SpanTermQuery(new Term(FIELD, s2)),
-        new SpanTermQuery(new Term(FIELD, s3)) },
+        new TermQuery(new Term(FIELD, s1)),
+        new TermQuery(new Term(FIELD, s2)),
+        new TermQuery(new Term(FIELD, s3)) },
        slop,
        inOrder);
   }
@@ -90,12 +90,12 @@
     return new SpanNearQuery(
       new SpanQuery[] {
         new SpanNearQuery(new SpanQuery[] {
-          new SpanTermQuery(new Term(FIELD, sqt1)),
-            new SpanTermQuery(new Term(FIELD, sqt2)) },
+          new TermQuery(new Term(FIELD, sqt1)),
+            new TermQuery(new Term(FIELD, sqt2)) },
             1,
             sqOrdered
           ),
-          new SpanTermQuery(new Term(FIELD, t3)) },
+          new TermQuery(new Term(FIELD, t3)) },
           0,
           ordered);
   }
Index: core/src/test/org/apache/lucene/search/spans/TestPayloadSpans.java
===================================================================
--- core/src/test/org/apache/lucene/search/spans/TestPayloadSpans.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/spans/TestPayloadSpans.java	(working copy)
@@ -16,26 +16,19 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.io.StringReader;
-import java.nio.charset.StandardCharsets;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
-
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.analysis.TokenFilter;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.TermQuery;
@@ -48,6 +41,13 @@
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
 
+import java.io.IOException;
+import java.io.StringReader;
+import java.nio.charset.StandardCharsets;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
 public class TestPayloadSpans extends LuceneTestCase {
   private IndexSearcher searcher;
   private Similarity similarity = new DefaultSimilarity();
@@ -63,15 +63,15 @@
     indexReader = searcher.getIndexReader();
   }
 
-  public void testSpanTermQuery() throws Exception {
-    SpanTermQuery stq;
+  public void testTermQuery() throws Exception {
+    TermQuery stq;
     Spans spans;
-    stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "seventy"));
+    stq = new TermQuery(new Term(PayloadHelper.FIELD, "seventy"));
     spans = MultiSpansWrapper.wrap(indexReader, stq);
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, 100, 1, 1, 1);
 
-    stq = new SpanTermQuery(new Term(PayloadHelper.NO_PAYLOAD_FIELD, "seventy"));  
+    stq = new TermQuery(new Term(PayloadHelper.NO_PAYLOAD_FIELD, "seventy"));  
     spans = MultiSpansWrapper.wrap(indexReader, stq);
     assertTrue("spans is null and it shouldn't be", spans != null);
     checkSpans(spans, 100, 0, 0, 0);
@@ -81,14 +81,14 @@
 
     SpanQuery match;
     SpanFirstQuery sfq;
-    match = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
+    match = new TermQuery(new Term(PayloadHelper.FIELD, "one"));
     sfq = new SpanFirstQuery(match, 2);
     Spans spans = MultiSpansWrapper.wrap(indexReader, sfq);
     checkSpans(spans, 109, 1, 1, 1);
     //Test more complicated subclause
     SpanQuery[] clauses = new SpanQuery[2];
-    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "hundred"));
+    clauses[0] = new TermQuery(new Term(PayloadHelper.FIELD, "one"));
+    clauses[1] = new TermQuery(new Term(PayloadHelper.FIELD, "hundred"));
     match = new SpanNearQuery(clauses, 0, true);
     sfq = new SpanFirstQuery(match, 2);
     checkSpans(MultiSpansWrapper.wrap(indexReader, sfq), 100, 2, 1, 1);
@@ -101,10 +101,10 @@
   
   public void testSpanNot() throws Exception {
     SpanQuery[] clauses = new SpanQuery[2];
-    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "three"));
+    clauses[0] = new TermQuery(new Term(PayloadHelper.FIELD, "one"));
+    clauses[1] = new TermQuery(new Term(PayloadHelper.FIELD, "three"));
     SpanQuery spq = new SpanNearQuery(clauses, 5, true);
-    SpanNotQuery snq = new SpanNotQuery(spq, new SpanTermQuery(new Term(PayloadHelper.FIELD, "two")));
+    SpanNotQuery snq = new SpanNotQuery(spq, new TermQuery(new Term(PayloadHelper.FIELD, "two")));
 
 
 
@@ -125,17 +125,17 @@
   }
   
   public void testNestedSpans() throws Exception {
-    SpanTermQuery stq;
+    TermQuery stq;
     Spans spans;
     IndexSearcher searcher = getSearcher();
-    stq = new SpanTermQuery(new Term(PayloadHelper.FIELD, "mark"));
+    stq = new TermQuery(new Term(PayloadHelper.FIELD, "mark"));
     spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), stq);
     assertNull(spans);
 
     SpanQuery[] clauses = new SpanQuery[3];
-    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "rr"));
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "yy"));
-    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
+    clauses[0] = new TermQuery(new Term(PayloadHelper.FIELD, "rr"));
+    clauses[1] = new TermQuery(new Term(PayloadHelper.FIELD, "yy"));
+    clauses[2] = new TermQuery(new Term(PayloadHelper.FIELD, "xx"));
     SpanNearQuery spanNearQuery = new SpanNearQuery(clauses, 12, false);
 
     spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), spanNearQuery);
@@ -143,9 +143,9 @@
     checkSpans(spans, 2, new int[]{3,3});
 
      
-    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "rr"));
-    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "yy"));
+    clauses[0] = new TermQuery(new Term(PayloadHelper.FIELD, "xx"));
+    clauses[1] = new TermQuery(new Term(PayloadHelper.FIELD, "rr"));
+    clauses[2] = new TermQuery(new Term(PayloadHelper.FIELD, "yy"));
 
     spanNearQuery = new SpanNearQuery(clauses, 6, true);
    
@@ -156,8 +156,8 @@
      
     clauses = new SpanQuery[2];
      
-    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "xx"));
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "rr"));
+    clauses[0] = new TermQuery(new Term(PayloadHelper.FIELD, "xx"));
+    clauses[1] = new TermQuery(new Term(PayloadHelper.FIELD, "rr"));
 
     spanNearQuery = new SpanNearQuery(clauses, 6, true);
      
@@ -165,7 +165,7 @@
     
     SpanQuery[] clauses2 = new SpanQuery[2];
      
-    clauses2[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "yy"));
+    clauses2[0] = new TermQuery(new Term(PayloadHelper.FIELD, "yy"));
     clauses2[1] = spanNearQuery;
      
     SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses2, 6, false);
@@ -184,15 +184,15 @@
     IndexSearcher searcher = getSearcher();
 
     SpanQuery[] clauses = new SpanQuery[3];
-    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "nopayload"));
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "qq"));
-    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "ss"));
+    clauses[0] = new TermQuery(new Term(PayloadHelper.FIELD, "nopayload"));
+    clauses[1] = new TermQuery(new Term(PayloadHelper.FIELD, "qq"));
+    clauses[2] = new TermQuery(new Term(PayloadHelper.FIELD, "ss"));
 
     SpanNearQuery spanNearQuery = new SpanNearQuery(clauses, 6, true);
     
     SpanQuery[] clauses2 = new SpanQuery[2];
      
-    clauses2[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "pp"));
+    clauses2[0] = new TermQuery(new Term(PayloadHelper.FIELD, "pp"));
     clauses2[1] = spanNearQuery;
 
     SpanNearQuery snq = new SpanNearQuery(clauses2, 6, false);
@@ -199,7 +199,7 @@
     
     SpanQuery[] clauses3 = new SpanQuery[2];
      
-    clauses3[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "np"));
+    clauses3[0] = new TermQuery(new Term(PayloadHelper.FIELD, "np"));
     clauses3[1] = snq;
      
     SpanNearQuery nestedSpanNearQuery = new SpanNearQuery(clauses3, 6, false);
@@ -216,26 +216,26 @@
     IndexSearcher searcher = getSearcher();
 
     SpanQuery[] clauses = new SpanQuery[3];
-    clauses[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "one"));
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "two"));
-    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "three"));
+    clauses[0] = new TermQuery(new Term(PayloadHelper.FIELD, "one"));
+    clauses[1] = new TermQuery(new Term(PayloadHelper.FIELD, "two"));
+    clauses[2] = new TermQuery(new Term(PayloadHelper.FIELD, "three"));
 
     SpanNearQuery spanNearQuery = new SpanNearQuery(clauses, 5, true);
    
     clauses = new SpanQuery[3];
     clauses[0] = spanNearQuery; 
-    clauses[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "five"));
-    clauses[2] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "six"));
+    clauses[1] = new TermQuery(new Term(PayloadHelper.FIELD, "five"));
+    clauses[2] = new TermQuery(new Term(PayloadHelper.FIELD, "six"));
 
     SpanNearQuery spanNearQuery2 = new SpanNearQuery(clauses, 6, true);
      
     SpanQuery[] clauses2 = new SpanQuery[2];
-    clauses2[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "eleven"));
-    clauses2[1] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "ten"));
+    clauses2[0] = new TermQuery(new Term(PayloadHelper.FIELD, "eleven"));
+    clauses2[1] = new TermQuery(new Term(PayloadHelper.FIELD, "ten"));
     SpanNearQuery spanNearQuery3 = new SpanNearQuery(clauses2, 2, false);
     
     SpanQuery[] clauses3 = new SpanQuery[3];
-    clauses3[0] = new SpanTermQuery(new Term(PayloadHelper.FIELD, "nine"));
+    clauses3[0] = new TermQuery(new Term(PayloadHelper.FIELD, "nine"));
     clauses3[1] = spanNearQuery2;
     clauses3[2] = spanNearQuery3;
      
@@ -261,8 +261,8 @@
     IndexSearcher is = newSearcher(reader);
     writer.close();
 
-    SpanTermQuery stq1 = new SpanTermQuery(new Term("content", "a"));
-    SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
+    TermQuery stq1 = new TermQuery(new Term("content", "a"));
+    TermQuery stq2 = new TermQuery(new Term("content", "k"));
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 1, true);
     Spans spans = MultiSpansWrapper.wrap(is.getIndexReader(), snq);
@@ -299,8 +299,8 @@
     IndexSearcher is = newSearcher(reader);
     writer.close();
 
-    SpanTermQuery stq1 = new SpanTermQuery(new Term("content", "a"));
-    SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
+    TermQuery stq1 = new TermQuery(new Term("content", "a"));
+    TermQuery stq2 = new TermQuery(new Term("content", "k"));
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
     Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq);
@@ -337,8 +337,8 @@
     IndexSearcher is = newSearcher(reader);
     writer.close();
 
-    SpanTermQuery stq1 = new SpanTermQuery(new Term("content", "a"));
-    SpanTermQuery stq2 = new SpanTermQuery(new Term("content", "k"));
+    TermQuery stq1 = new TermQuery(new Term("content", "a"));
+    TermQuery stq2 = new TermQuery(new Term("content", "k"));
     SpanQuery[] sqs = { stq1, stq2 };
     SpanNearQuery snq = new SpanNearQuery(sqs, 0, true);
     Spans spans =  MultiSpansWrapper.wrap(is.getIndexReader(), snq);
Index: core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java
===================================================================
--- core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/spans/TestSpanFirstQuery.java	(working copy)
@@ -26,6 +26,7 @@
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.automaton.CharacterRunAutomaton;
@@ -51,11 +52,11 @@
     IndexSearcher searcher = newSearcher(reader);
     
     // user queries on "starts-with quick"
-    SpanQuery sfq = new SpanFirstQuery(new SpanTermQuery(new Term("field", "quick")), 1);
+    SpanQuery sfq = new SpanFirstQuery(new TermQuery(new Term("field", "quick")), 1);
     assertEquals(1, searcher.search(sfq, 10).totalHits);
     
     // user queries on "starts-with the quick"
-    SpanQuery include = new SpanFirstQuery(new SpanTermQuery(new Term("field", "quick")), 2);
+    SpanQuery include = new SpanFirstQuery(new TermQuery(new Term("field", "quick")), 2);
     sfq = new SpanNotQuery(include, sfq);
     assertEquals(1, searcher.search(sfq, 10).totalHits);
     
Index: core/src/test/org/apache/lucene/search/spans/TestSpanMultiTermQueryWrapper.java
===================================================================
--- core/src/test/org/apache/lucene/search/spans/TestSpanMultiTermQueryWrapper.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/spans/TestSpanMultiTermQueryWrapper.java	(working copy)
@@ -26,6 +26,7 @@
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.PrefixQuery;
 import org.apache.lucene.search.RegexpQuery;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.WildcardQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
@@ -101,7 +102,7 @@
     //test to make sure non existent multiterms aren't throwing null pointer exceptions  
     FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
     SpanQuery spanNoSuch = new SpanMultiTermQueryWrapper<>(fuzzyNoSuch);
-    SpanQuery term = new SpanTermQuery(new Term("field", "brown"));
+    SpanQuery term = new TermQuery(new Term("field", "brown"));
     SpanQuery near = new SpanNearQuery(new SpanQuery[]{term, spanNoSuch}, 1, true);
     assertEquals(0, searcher.search(near, 10).totalHits);
     //flip order
@@ -137,7 +138,7 @@
     //test to make sure non existent multiterms aren't throwing non-matching field exceptions  
     FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
     SpanQuery spanNoSuch = new SpanMultiTermQueryWrapper<>(fuzzyNoSuch);
-    SpanQuery term = new SpanTermQuery(new Term("field", "brown"));
+    SpanQuery term = new TermQuery(new Term("field", "brown"));
     SpanNotQuery notNear = new SpanNotQuery(term, spanNoSuch, 0,0);
     assertEquals(1, searcher.search(notNear, 10).totalHits);
 
@@ -170,7 +171,7 @@
     //test to make sure non existent multiterms aren't throwing null pointer exceptions  
     FuzzyQuery fuzzyNoSuch = new FuzzyQuery(new Term("field", "noSuch"), 1, 0, 1, false);
     SpanQuery spanNoSuch = new SpanMultiTermQueryWrapper<>(fuzzyNoSuch);
-    SpanQuery term = new SpanTermQuery(new Term("field", "brown"));
+    SpanQuery term = new TermQuery(new Term("field", "brown"));
     SpanOrQuery near = new SpanOrQuery(new SpanQuery[]{term, spanNoSuch});
     assertEquals(1, searcher.search(near, 10).totalHits);
     
Index: core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java
===================================================================
--- core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java	(working copy)
@@ -34,10 +34,10 @@
   // but these are just simple minimal cases in case something 
   // goes horribly wrong. Put more intense tests elsewhere.
 
-  /** SpanTermQuery(A) = TermQuery(A) */
+  /** TermQuery(A) = TermQuery(A) */
   public void testSpanTermVersusTerm() throws Exception {
     Term t1 = randomTerm();
-    assertSameSet(new TermQuery(t1), new SpanTermQuery(t1));
+    assertSameSet(new TermQuery(t1), new TermQuery(t1));
   }
   
   /** SpanOrQuery(A, B) = (A B) */
@@ -47,24 +47,24 @@
     BooleanQuery q1 = new BooleanQuery();
     q1.add(new TermQuery(t1), Occur.SHOULD);
     q1.add(new TermQuery(t2), Occur.SHOULD);
-    SpanOrQuery q2 = new SpanOrQuery(new SpanTermQuery(t1), new SpanTermQuery(t2));
+    SpanOrQuery q2 = new SpanOrQuery(new TermQuery(t1), new TermQuery(t2));
     assertSameSet(q1, q2);
   }
   
-  /** SpanNotQuery(A, B)  SpanTermQuery(A) */
+  /** SpanNotQuery(A, B)  TermQuery(A) */
   public void testSpanNotVersusSpanTerm() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    assertSubsetOf(new SpanNotQuery(new SpanTermQuery(t1), new SpanTermQuery(t2)), new SpanTermQuery(t1));
+    assertSubsetOf(new SpanNotQuery(new TermQuery(t1), new TermQuery(t2)), new TermQuery(t1));
   }
   
-  /** SpanNotQuery(A, [B C])  SpanTermQuery(A) */
+  /** SpanNotQuery(A, [B C])  TermQuery(A) */
   public void testSpanNotNearVersusSpanTerm() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     Term t3 = randomTerm();
-    SpanQuery near = new SpanNearQuery(new SpanQuery[] { new SpanTermQuery(t2), new SpanTermQuery(t3) }, 10, random().nextBoolean());
-    assertSubsetOf(new SpanNotQuery(new SpanTermQuery(t1), near), new SpanTermQuery(t1));
+    SpanQuery near = new SpanNearQuery(new SpanQuery[] { new TermQuery(t2), new TermQuery(t3) }, 10, random().nextBoolean());
+    assertSubsetOf(new SpanNotQuery(new TermQuery(t1), near), new TermQuery(t1));
   }
   
   /** SpanNotQuery([A B], C)  SpanNearQuery([A B]) */
@@ -72,8 +72,8 @@
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     Term t3 = randomTerm();
-    SpanQuery near = new SpanNearQuery(new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) }, 10, random().nextBoolean());
-    assertSubsetOf(new SpanNotQuery(near, new SpanTermQuery(t3)), near);
+    SpanQuery near = new SpanNearQuery(new SpanQuery[] { new TermQuery(t1), new TermQuery(t2) }, 10, random().nextBoolean());
+    assertSubsetOf(new SpanNotQuery(near, new TermQuery(t3)), near);
   }
   
   /** SpanNotQuery([A B], [C D])  SpanNearQuery([A B]) */
@@ -82,15 +82,15 @@
     Term t2 = randomTerm();
     Term t3 = randomTerm();
     Term t4 = randomTerm();
-    SpanQuery near1 = new SpanNearQuery(new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) }, 10, random().nextBoolean());
-    SpanQuery near2 = new SpanNearQuery(new SpanQuery[] { new SpanTermQuery(t3), new SpanTermQuery(t4) }, 10, random().nextBoolean());
+    SpanQuery near1 = new SpanNearQuery(new SpanQuery[] { new TermQuery(t1), new TermQuery(t2) }, 10, random().nextBoolean());
+    SpanQuery near2 = new SpanNearQuery(new SpanQuery[] { new TermQuery(t3), new TermQuery(t4) }, 10, random().nextBoolean());
     assertSubsetOf(new SpanNotQuery(near1, near2), near1);
   }
   
-  /** SpanFirstQuery(A, 10)  SpanTermQuery(A) */
+  /** SpanFirstQuery(A, 10)  TermQuery(A) */
   public void testSpanFirstVersusSpanTerm() throws Exception {
     Term t1 = randomTerm();
-    assertSubsetOf(new SpanFirstQuery(new SpanTermQuery(t1), 10), new SpanTermQuery(t1));
+    assertSubsetOf(new SpanFirstQuery(new TermQuery(t1), 10), new TermQuery(t1));
   }
   
   /** SpanNearQuery([A, B], 0, true) = "A B" */
@@ -97,7 +97,7 @@
   public void testSpanNearVersusPhrase() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) };
+    SpanQuery subquery[] = new SpanQuery[] { new TermQuery(t1), new TermQuery(t2) };
     SpanNearQuery q1 = new SpanNearQuery(subquery, 0, true);
     PhraseQuery q2 = new PhraseQuery();
     q2.add(t1);
@@ -109,7 +109,7 @@
   public void testSpanNearVersusBooleanAnd() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) };
+    SpanQuery subquery[] = new SpanQuery[] { new TermQuery(t1), new TermQuery(t2) };
     SpanNearQuery q1 = new SpanNearQuery(subquery, Integer.MAX_VALUE, false);
     BooleanQuery q2 = new BooleanQuery();
     q2.add(new TermQuery(t1), Occur.MUST);
@@ -121,7 +121,7 @@
   public void testSpanNearVersusSloppySpanNear() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) };
+    SpanQuery subquery[] = new SpanQuery[] { new TermQuery(t1), new TermQuery(t2) };
     SpanNearQuery q1 = new SpanNearQuery(subquery, 0, false);
     SpanNearQuery q2 = new SpanNearQuery(subquery, 1, false);
     assertSubsetOf(q1, q2);
@@ -131,7 +131,7 @@
   public void testSpanNearInOrderVersusOutOfOrder() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) };
+    SpanQuery subquery[] = new SpanQuery[] { new TermQuery(t1), new TermQuery(t2) };
     SpanNearQuery q1 = new SpanNearQuery(subquery, 3, true);
     SpanNearQuery q2 = new SpanNearQuery(subquery, 3, false);
     assertSubsetOf(q1, q2);
@@ -141,7 +141,7 @@
   public void testSpanNearIncreasingSloppiness() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) };
+    SpanQuery subquery[] = new SpanQuery[] { new TermQuery(t1), new TermQuery(t2) };
     for (int i = 0; i < 10; i++) {
       SpanNearQuery q1 = new SpanNearQuery(subquery, i, false);
       SpanNearQuery q2 = new SpanNearQuery(subquery, i+1, false);
@@ -154,7 +154,7 @@
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     Term t3 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2), new SpanTermQuery(t3) };
+    SpanQuery subquery[] = new SpanQuery[] { new TermQuery(t1), new TermQuery(t2), new TermQuery(t3) };
     for (int i = 0; i < 10; i++) {
       SpanNearQuery q1 = new SpanNearQuery(subquery, i, false);
       SpanNearQuery q2 = new SpanNearQuery(subquery, i+1, false);
@@ -166,7 +166,7 @@
   public void testSpanNearIncreasingOrderedSloppiness() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) };
+    SpanQuery subquery[] = new SpanQuery[] { new TermQuery(t1), new TermQuery(t2) };
     for (int i = 0; i < 10; i++) {
       SpanNearQuery q1 = new SpanNearQuery(subquery, i, false);
       SpanNearQuery q2 = new SpanNearQuery(subquery, i+1, false);
@@ -179,7 +179,7 @@
     Term t1 = randomTerm();
     Term t2 = randomTerm();
     Term t3 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2), new SpanTermQuery(t3) };
+    SpanQuery subquery[] = new SpanQuery[] { new TermQuery(t1), new TermQuery(t2), new TermQuery(t3) };
     for (int i = 0; i < 10; i++) {
       SpanNearQuery q1 = new SpanNearQuery(subquery, i, true);
       SpanNearQuery q2 = new SpanNearQuery(subquery, i+1, true);
@@ -192,7 +192,7 @@
     Term t1 = randomTerm();
     for (int i = 0; i < 5; i++) {
       for (int j = 0; j < 5; j++) {
-        Query q1 = new SpanPositionRangeQuery(new SpanTermQuery(t1), i, i+j);
+        Query q1 = new SpanPositionRangeQuery(new TermQuery(t1), i, i+j);
         Query q2 = new TermQuery(t1);
         assertSubsetOf(q1, q2);
       }
@@ -204,8 +204,8 @@
     Term t1 = randomTerm();
     for (int i = 0; i < 5; i++) {
       for (int j = 0; j < 5; j++) {
-        Query q1 = new SpanPositionRangeQuery(new SpanTermQuery(t1), i, i+j);
-        Query q2 = new SpanPositionRangeQuery(new SpanTermQuery(t1), i, i+j+1);
+        Query q1 = new SpanPositionRangeQuery(new TermQuery(t1), i, i+j);
+        Query q2 = new SpanPositionRangeQuery(new TermQuery(t1), i, i+j+1);
         assertSubsetOf(q1, q2);
       }
     }
@@ -214,7 +214,7 @@
   /** SpanPositionRangeQuery(A, 0, ) = TermQuery(A) */
   public void testSpanRangeTermEverything() throws Exception {
     Term t1 = randomTerm();
-    Query q1 = new SpanPositionRangeQuery(new SpanTermQuery(t1), 0, Integer.MAX_VALUE);
+    Query q1 = new SpanPositionRangeQuery(new TermQuery(t1), 0, Integer.MAX_VALUE);
     Query q2 = new TermQuery(t1);
     assertSameSet(q1, q2);
   }
@@ -223,7 +223,7 @@
   public void testSpanRangeNear() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) };
+    SpanQuery subquery[] = new SpanQuery[] { new TermQuery(t1), new TermQuery(t2) };
     SpanQuery nearQuery = new SpanNearQuery(subquery, 10, true);
     for (int i = 0; i < 5; i++) {
       for (int j = 0; j < 5; j++) {
@@ -238,7 +238,7 @@
   public void testSpanRangeNearIncreasingEnd() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) };
+    SpanQuery subquery[] = new SpanQuery[] { new TermQuery(t1), new TermQuery(t2) };
     SpanQuery nearQuery = new SpanNearQuery(subquery, 10, true);
     for (int i = 0; i < 5; i++) {
       for (int j = 0; j < 5; j++) {
@@ -253,7 +253,7 @@
   public void testSpanRangeNearEverything() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) };
+    SpanQuery subquery[] = new SpanQuery[] { new TermQuery(t1), new TermQuery(t2) };
     SpanQuery nearQuery = new SpanNearQuery(subquery, 10, true);
     Query q1 = new SpanPositionRangeQuery(nearQuery, 0, Integer.MAX_VALUE);
     Query q2 = nearQuery;
@@ -264,7 +264,7 @@
   public void testSpanFirstTerm() throws Exception {
     Term t1 = randomTerm();
     for (int i = 0; i < 10; i++) {
-      Query q1 = new SpanFirstQuery(new SpanTermQuery(t1), i);
+      Query q1 = new SpanFirstQuery(new TermQuery(t1), i);
       Query q2 = new TermQuery(t1);
       assertSubsetOf(q1, q2);
     }
@@ -274,8 +274,8 @@
   public void testSpanFirstTermIncreasing() throws Exception {
     Term t1 = randomTerm();
     for (int i = 0; i < 10; i++) {
-      Query q1 = new SpanFirstQuery(new SpanTermQuery(t1), i);
-      Query q2 = new SpanFirstQuery(new SpanTermQuery(t1), i+1);
+      Query q1 = new SpanFirstQuery(new TermQuery(t1), i);
+      Query q2 = new SpanFirstQuery(new TermQuery(t1), i+1);
       assertSubsetOf(q1, q2);
     }
   }
@@ -283,7 +283,7 @@
   /** SpanFirstQuery(A, ) = TermQuery(A) */
   public void testSpanFirstTermEverything() throws Exception {
     Term t1 = randomTerm();
-    Query q1 = new SpanFirstQuery(new SpanTermQuery(t1), Integer.MAX_VALUE);
+    Query q1 = new SpanFirstQuery(new TermQuery(t1), Integer.MAX_VALUE);
     Query q2 = new TermQuery(t1);
     assertSameSet(q1, q2);
   }
@@ -292,7 +292,7 @@
   public void testSpanFirstNear() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) };
+    SpanQuery subquery[] = new SpanQuery[] { new TermQuery(t1), new TermQuery(t2) };
     SpanQuery nearQuery = new SpanNearQuery(subquery, 10, true);
     for (int i = 0; i < 10; i++) {
       Query q1 = new SpanFirstQuery(nearQuery, i);
@@ -305,7 +305,7 @@
   public void testSpanFirstNearIncreasing() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) };
+    SpanQuery subquery[] = new SpanQuery[] { new TermQuery(t1), new TermQuery(t2) };
     SpanQuery nearQuery = new SpanNearQuery(subquery, 10, true);
     for (int i = 0; i < 10; i++) {
       Query q1 = new SpanFirstQuery(nearQuery, i);
@@ -318,7 +318,7 @@
   public void testSpanFirstNearEverything() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
-    SpanQuery subquery[] = new SpanQuery[] { new SpanTermQuery(t1), new SpanTermQuery(t2) };
+    SpanQuery subquery[] = new SpanQuery[] { new TermQuery(t1), new TermQuery(t2) };
     SpanQuery nearQuery = new SpanNearQuery(subquery, 10, true);
     Query q1 = new SpanFirstQuery(nearQuery, Integer.MAX_VALUE);
     Query q2 = nearQuery;
Index: core/src/test/org/apache/lucene/search/spans/TestSpans.java
===================================================================
--- core/src/test/org/apache/lucene/search/spans/TestSpans.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/spans/TestSpans.java	(working copy)
@@ -88,8 +88,8 @@
     "s2 s1 s1 xx xx s2 xx s2 xx s1 xx xx xx xx xx s2 xx"
   };
 
-  public SpanTermQuery makeSpanTermQuery(String text) {
-    return new SpanTermQuery(new Term(field, text));
+  public TermQuery makeSpanTermQuery(String text) {
+    return new TermQuery(new Term(field, text));
   }
   
   private void checkHits(Query query, int[] results) throws IOException {
@@ -397,7 +397,7 @@
 
   // LUCENE-1404
   private SpanQuery createSpan(String value) {
-    return new SpanTermQuery(new Term("text", value));
+    return new TermQuery(new Term("text", value));
   }                     
   
   // LUCENE-1404
@@ -476,8 +476,8 @@
   }
   
   private int spanCount(String include, String exclude, int pre, int post) throws IOException{
-     SpanTermQuery iq = new SpanTermQuery(new Term(field, include));
-     SpanTermQuery eq = new SpanTermQuery(new Term(field, exclude));
+    TermQuery iq = new TermQuery(new Term(field, include));
+    TermQuery eq = new TermQuery(new Term(field, exclude));
      SpanNotQuery snq = new SpanNotQuery(iq, eq, pre, post);
      Spans spans = MultiSpansWrapper.wrap(searcher.getIndexReader(), snq);
 
Index: core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced.java
===================================================================
--- core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced.java	(working copy)
@@ -17,23 +17,27 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.util.LuceneTestCase;
-
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenFilter;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.StoredDocument;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.*;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.QueryUtils;
+import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.LuceneTestCase;
 
+import java.io.IOException;
+
 /*******************************************************************************
  * Tests the span query bug in Lucene. It demonstrates that SpanTermQuerys don't
  * work correctly in a BooleanQuery.
Index: core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced2.java
===================================================================
--- core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced2.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/spans/TestSpansAdvanced2.java	(working copy)
@@ -17,19 +17,22 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenFilter;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexWriterConfig.OpenMode;
-import org.apache.lucene.search.*;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
 import org.apache.lucene.search.similarities.DefaultSimilarity;
 
+import java.io.IOException;
+
 /*******************************************************************************
  * Some expanded tests to make sure my patch doesn't break other SpanTermQuery
  * functionality.
Index: core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java
===================================================================
--- core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java	(revision 1672105)
+++ core/src/test/org/apache/lucene/search/spans/TestSpansEnum.java	(working copy)
@@ -17,10 +17,11 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-
-import org.apache.lucene.analysis.*;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.PayloadAttribute;
 import org.apache.lucene.document.Document;
@@ -31,6 +32,7 @@
 import org.apache.lucene.search.CheckHits;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.English;
@@ -40,6 +42,9 @@
 import org.junit.BeforeClass;
 import org.junit.Test;
 
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+
 /**
  * Tests Spans (v2)
  *
@@ -124,14 +129,14 @@
     CheckHits.checkHits(random(), query, "field", searcher, results);
   }
 
-  SpanTermQuery spanTQ(String term) {
-    return new SpanTermQuery(new Term("field", term));
+  TermQuery spanTQ(String term) {
+    return new TermQuery(new Term("field", term));
   }
 
   @Test
   public void testSpansEnumOr1() throws Exception {
-    SpanTermQuery t1 = spanTQ("one");
-    SpanTermQuery t2 = spanTQ("two");
+    TermQuery t1 = spanTQ("one");
+    TermQuery t2 = spanTQ("two");
     SpanOrQuery soq = new SpanOrQuery(t1, t2);
     checkHits(soq, new int[] {1, 2, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
   }
@@ -138,8 +143,8 @@
 
   @Test
   public void testSpansEnumOr2() throws Exception {
-    SpanTermQuery t1 = spanTQ("one");
-    SpanTermQuery t11 = spanTQ("eleven");
+    TermQuery t1 = spanTQ("one");
+    TermQuery t11 = spanTQ("eleven");
     SpanOrQuery soq = new SpanOrQuery(t1, t11);
     checkHits(soq, new int[] {1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19});
   }
@@ -146,8 +151,8 @@
 
   @Test
   public void testSpansEnumOr3() throws Exception {
-    SpanTermQuery t12 = spanTQ("twelve");
-    SpanTermQuery t11 = spanTQ("eleven");
+    TermQuery t12 = spanTQ("twelve");
+    TermQuery t11 = spanTQ("eleven");
     SpanOrQuery soq = new SpanOrQuery(t12, t11);
     checkHits(soq, new int[] {});
   }
@@ -154,8 +159,8 @@
 
   @Test
   public void testSpansEnumOrNot1() throws Exception {
-    SpanTermQuery t1 = spanTQ("one");
-    SpanTermQuery t2 = spanTQ("two");
+    TermQuery t1 = spanTQ("one");
+    TermQuery t2 = spanTQ("two");
     SpanOrQuery soq = new SpanOrQuery(t1, t2);
     SpanNotQuery snq = new SpanNotQuery(soq, t1);
     checkHits(snq, new int[] {2,12});
@@ -163,8 +168,8 @@
 
   @Test
   public void testSpansEnumNotBeforeAfter1() throws Exception {
-    SpanTermQuery t1 = spanTQ("one");
-    SpanTermQuery t100 = spanTQ("hundred");
+    TermQuery t1 = spanTQ("one");
+    TermQuery t100 = spanTQ("hundred");
     SpanNotQuery snq = new SpanNotQuery(t100, t1, 0, 0);
     checkHits(snq, new int[] {10, 11, 12, 13, 14, 15, 16, 17, 18, 19}); // include all "one hundred ..."
   }
@@ -171,8 +176,8 @@
 
   @Test
   public void testSpansEnumNotBeforeAfter2() throws Exception {
-    SpanTermQuery t1 = spanTQ("one");
-    SpanTermQuery t100 = spanTQ("hundred");
+    TermQuery t1 = spanTQ("one");
+    TermQuery t100 = spanTQ("hundred");
     SpanNotQuery snq = new SpanNotQuery(t100, t1, 1, 0);
     checkHits(snq, new int[] {}); // exclude all "one hundred ..."
   }
@@ -179,8 +184,8 @@
 
   @Test
   public void testSpansEnumNotBeforeAfter3() throws Exception {
-    SpanTermQuery t1 = spanTQ("one");
-    SpanTermQuery t100 = spanTQ("hundred");
+    TermQuery t1 = spanTQ("one");
+    TermQuery t100 = spanTQ("hundred");
     SpanNotQuery snq = new SpanNotQuery(t100, t1, 0, 1);
     checkHits(snq, new int[] {10, 12, 13, 14, 15, 16, 17, 18, 19}); // exclude "one hundred one"
   }
Index: highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java
===================================================================
--- highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java	(revision 1672105)
+++ highlighter/src/java/org/apache/lucene/search/highlight/WeightedSpanTermExtractor.java	(working copy)
@@ -17,17 +17,6 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeSet;
-
 import org.apache.lucene.analysis.CachingTokenFilter;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.index.BinaryDocValues;
@@ -64,12 +53,22 @@
 import org.apache.lucene.search.spans.SpanNotQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.search.spans.Spans;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.IOUtils;
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeSet;
 
+
 /**
  * Class used to extract {@link WeightedSpanTerm}s from a {@link Query} based on whether 
  * {@link Term}s from the {@link Query} are contained in a supplied {@link TokenStream}.
@@ -118,7 +117,7 @@
       Term[] phraseQueryTerms = phraseQuery.getTerms();
       SpanQuery[] clauses = new SpanQuery[phraseQueryTerms.length];
       for (int i = 0; i < phraseQueryTerms.length; i++) {
-        clauses[i] = new SpanTermQuery(phraseQueryTerms[i]);
+        clauses[i] = new TermQuery(phraseQueryTerms[i]);
       }
       int slop = phraseQuery.getSlop();
       int[] positions = phraseQuery.getPositions();
@@ -197,7 +196,7 @@
             ++distinctPositions;
           }
           for (int j = 0; j < termArray.length; ++j) {
-            disjuncts.add(new SpanTermQuery(termArray[j]));
+            disjuncts.add(new TermQuery(termArray[j]));
           }
         }
 
@@ -615,7 +614,7 @@
         }
       }
       return false; 
-    } else if (spanQuery instanceof SpanTermQuery) {
+    } else if (spanQuery instanceof TermQuery) {
       return false;
     } else {
       return true;
Index: highlighter/src/test/org/apache/lucene/search/highlight/HighlighterPhraseTest.java
===================================================================
--- highlighter/src/test/org/apache/lucene/search/highlight/HighlighterPhraseTest.java	(revision 1672105)
+++ highlighter/src/test/org/apache/lucene/search/highlight/HighlighterPhraseTest.java	(working copy)
@@ -17,37 +17,36 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.analysis.Token;
 import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
-import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
-import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
+import org.apache.lucene.document.FieldType;
 import org.apache.lucene.document.TextField;
-import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SimpleCollector;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
+import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.LuceneTestCase;
-import org.apache.lucene.util.FixedBitSet;
 
+import java.io.IOException;
+
 public class HighlighterPhraseTest extends LuceneTestCase {
   private static final String FIELD = "text";
   public void testConcurrentPhrase() throws IOException, InvalidTokenOffsetsException {
@@ -113,8 +112,8 @@
       assertEquals(1, indexReader.numDocs());
       final IndexSearcher indexSearcher = newSearcher(indexReader);
       final Query phraseQuery = new SpanNearQuery(new SpanQuery[] {
-          new SpanTermQuery(new Term(FIELD, "fox")),
-          new SpanTermQuery(new Term(FIELD, "jumped")) }, 0, true);
+          new TermQuery(new Term(FIELD, "fox")),
+          new TermQuery(new Term(FIELD, "jumped")) }, 0, true);
       final FixedBitSet bitset = new FixedBitSet(indexReader.maxDoc());
       indexSearcher.search(phraseQuery, new SimpleCollector() {
         private int baseDoc;
@@ -261,8 +260,8 @@
       assertEquals(1, indexReader.numDocs());
       final IndexSearcher indexSearcher = newSearcher(indexReader);
       final Query phraseQuery = new SpanNearQuery(new SpanQuery[] {
-          new SpanTermQuery(new Term(FIELD, "did")),
-          new SpanTermQuery(new Term(FIELD, "jump")) }, 0, true);
+          new TermQuery(new Term(FIELD, "did")),
+          new TermQuery(new Term(FIELD, "jump")) }, 0, true);
 
       TopDocs hits = indexSearcher.search(phraseQuery, 1);
       assertEquals(0, hits.totalHits);
Index: highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
===================================================================
--- highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java	(revision 1672105)
+++ highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java	(working copy)
@@ -17,21 +17,6 @@
  * limitations under the License.
  */
 
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.StringTokenizer;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.BaseTokenStreamTestCase;
 import org.apache.lucene.analysis.CachingTokenFilter;
@@ -88,7 +73,6 @@
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanPayloadCheckQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
@@ -98,6 +82,20 @@
 import org.w3c.dom.Element;
 import org.w3c.dom.NodeList;
 
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.StringTokenizer;
+
 /**
  * JUnit Test for Highlighter class.
  *
@@ -797,8 +795,8 @@
 
   public void testNearSpanSimpleQuery() throws Exception {
     doSearching(new SpanNearQuery(new SpanQuery[] {
-        new SpanTermQuery(new Term(FIELD_NAME, "beginning")),
-        new SpanTermQuery(new Term(FIELD_NAME, "kennedy")) }, 3, false));
+        new TermQuery(new Term(FIELD_NAME, "beginning")),
+        new TermQuery(new Term(FIELD_NAME, "kennedy")) }, 3, false));
 
     TestHighlightRunner helper = new TestHighlightRunner() {
 
@@ -835,11 +833,11 @@
 
   public void testSpanHighlighting() throws Exception {
     Query query1 = new SpanNearQuery(new SpanQuery[] {
-        new SpanTermQuery(new Term(FIELD_NAME, "wordx")),
-        new SpanTermQuery(new Term(FIELD_NAME, "wordy")) }, 1, false);
+        new TermQuery(new Term(FIELD_NAME, "wordx")),
+        new TermQuery(new Term(FIELD_NAME, "wordy")) }, 1, false);
     Query query2 = new SpanNearQuery(new SpanQuery[] {
-        new SpanTermQuery(new Term(FIELD_NAME, "wordy")),
-        new SpanTermQuery(new Term(FIELD_NAME, "wordc")) }, 1, false);
+        new TermQuery(new Term(FIELD_NAME, "wordy")),
+        new TermQuery(new Term(FIELD_NAME, "wordc")) }, 1, false);
     BooleanQuery bquery = new BooleanQuery();
     bquery.add(query1, Occur.SHOULD);
     bquery.add(query2, Occur.SHOULD);
@@ -860,8 +858,8 @@
 
   public void testNotSpanSimpleQuery() throws Exception {
     doSearching(new SpanNotQuery(new SpanNearQuery(new SpanQuery[] {
-        new SpanTermQuery(new Term(FIELD_NAME, "shot")),
-        new SpanTermQuery(new Term(FIELD_NAME, "kennedy")) }, 3, false), new SpanTermQuery(
+        new TermQuery(new Term(FIELD_NAME, "shot")),
+        new TermQuery(new Term(FIELD_NAME, "kennedy")) }, 3, false), new TermQuery(
         new Term(FIELD_NAME, "john"))));
     TestHighlightRunner helper = new TestHighlightRunner() {
 
@@ -1109,8 +1107,8 @@
       @Override
       public void run() throws Exception {
         numHighlights = 0;
-        SpanQuery clauses[] = { new SpanTermQuery(new Term("contents", "john")),
-            new SpanTermQuery(new Term("contents", "kennedy")), };
+        SpanQuery clauses[] = { new TermQuery(new Term("contents", "john")),
+            new TermQuery(new Term("contents", "kennedy")), };
 
         SpanNearQuery snq = new SpanNearQuery(clauses, 1, true);
         doSearching(snq);
@@ -1148,8 +1146,8 @@
       @Override
       public void run() throws Exception {
         numHighlights = 0;
-        SpanQuery clauses[] = { new SpanTermQuery(new Term("contents", "john")),
-            new SpanTermQuery(new Term("contents", "kennedy")), };
+        SpanQuery clauses[] = { new TermQuery(new Term("contents", "john")),
+            new TermQuery(new Term("contents", "kennedy")), };
         SpanNearQuery snq = new SpanNearQuery(clauses, 1, true);
         BooleanQuery bq = new BooleanQuery();
         bq.add(snq, Occur.MUST);
@@ -1938,7 +1936,7 @@
       writer.commit();
     }
     try (IndexReader reader = DirectoryReader.open(dir)) {
-      Query query = new SpanPayloadCheckQuery(new SpanTermQuery(new Term(FIELD_NAME, "words")),
+      Query query = new SpanPayloadCheckQuery(new TermQuery(new Term(FIELD_NAME, "words")),
           Collections.singleton("pos: 1".getBytes("UTF-8")));//just match the first "word" occurrence
       IndexSearcher searcher = newSearcher(reader);
       QueryScorer scorer = new QueryScorer(query, searcher.getIndexReader(), FIELD_NAME);
Index: highlighter/src/test/org/apache/lucene/search/highlight/MissesTest.java
===================================================================
--- highlighter/src/test/org/apache/lucene/search/highlight/MissesTest.java	(revision 1672105)
+++ highlighter/src/test/org/apache/lucene/search/highlight/MissesTest.java	(working copy)
@@ -17,8 +17,6 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.analysis.MockTokenizer;
@@ -30,9 +28,10 @@
 import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.util.LuceneTestCase;
 
+import java.io.IOException;
+
 public class MissesTest extends LuceneTestCase {
   public void testTermQuery() throws IOException, InvalidTokenOffsetsException {
     try (Analyzer analyzer = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)) {
@@ -71,8 +70,8 @@
   public void testSpanNearQuery() throws IOException, InvalidTokenOffsetsException {
     try (Analyzer analyzer = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false)) {
       final Query query = new SpanNearQuery(new SpanQuery[] {
-          new SpanTermQuery(new Term("test", "foo")),
-          new SpanTermQuery(new Term("test", "bar"))}, 0, true);
+          new TermQuery(new Term("test", "foo")),
+          new TermQuery(new Term("test", "bar"))}, 0, true);
       final Highlighter highlighter = new Highlighter(new SimpleHTMLFormatter(), new QueryScorer(query));
       assertEquals("this is a <B>foo</B> <B>bar</B> example",
           highlighter.getBestFragment(analyzer, "test", "this is a foo bar example"));
Index: highlighter/src/test/org/apache/lucene/search/highlight/TokenSourcesTest.java
===================================================================
--- highlighter/src/test/org/apache/lucene/search/highlight/TokenSourcesTest.java	(revision 1672105)
+++ highlighter/src/test/org/apache/lucene/search/highlight/TokenSourcesTest.java	(working copy)
@@ -17,8 +17,6 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-
 import com.carrotsearch.randomizedtesting.annotations.Repeat;
 import org.apache.lucene.analysis.BaseTokenStreamTestCase;
 import org.apache.lucene.analysis.CannedTokenStream;
@@ -41,14 +39,16 @@
 import org.apache.lucene.search.DisjunctionMaxQuery;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.TestUtil;
 
+import java.io.IOException;
+
 // LUCENE-2874
 public class TokenSourcesTest extends BaseTokenStreamTestCase {
   private static final String FIELD = "text";
@@ -111,11 +111,11 @@
     final IndexSearcher indexSearcher = newSearcher(indexReader);
     try {
       final DisjunctionMaxQuery query = new DisjunctionMaxQuery(1);
-      query.add(new SpanTermQuery(new Term(FIELD, "{fox}")));
-      query.add(new SpanTermQuery(new Term(FIELD, "fox")));
+      query.add(new TermQuery(new Term(FIELD, "{fox}")));
+      query.add(new TermQuery(new Term(FIELD, "fox")));
         // final Query phraseQuery = new SpanNearQuery(new SpanQuery[] {
-        // new SpanTermQuery(new Term(FIELD, "{fox}")),
-        // new SpanTermQuery(new Term(FIELD, "fox")) }, 0, true);
+        // new TermQuery(new Term(FIELD, "{fox}")),
+        // new TermQuery(new Term(FIELD, "fox")) }, 0, true);
 
       TopDocs hits = indexSearcher.search(query, 1);
       assertEquals(1, hits.totalHits);
@@ -155,11 +155,11 @@
       assertEquals(1, indexReader.numDocs());
       final IndexSearcher indexSearcher = newSearcher(indexReader);
       final DisjunctionMaxQuery query = new DisjunctionMaxQuery(1);
-      query.add(new SpanTermQuery(new Term(FIELD, "{fox}")));
-      query.add(new SpanTermQuery(new Term(FIELD, "fox")));
+      query.add(new TermQuery(new Term(FIELD, "{fox}")));
+      query.add(new TermQuery(new Term(FIELD, "fox")));
       // final Query phraseQuery = new SpanNearQuery(new SpanQuery[] {
-      // new SpanTermQuery(new Term(FIELD, "{fox}")),
-      // new SpanTermQuery(new Term(FIELD, "fox")) }, 0, true);
+      // new TermQuery(new Term(FIELD, "{fox}")),
+      // new TermQuery(new Term(FIELD, "fox")) }, 0, true);
 
       TopDocs hits = indexSearcher.search(query, 1);
       assertEquals(1, hits.totalHits);
@@ -198,11 +198,11 @@
       assertEquals(1, indexReader.numDocs());
       final IndexSearcher indexSearcher = newSearcher(indexReader);
       // final DisjunctionMaxQuery query = new DisjunctionMaxQuery(1);
-      // query.add(new SpanTermQuery(new Term(FIELD, "{fox}")));
-      // query.add(new SpanTermQuery(new Term(FIELD, "fox")));
+      // query.add(new TermQuery(new Term(FIELD, "{fox}")));
+      // query.add(new TermQuery(new Term(FIELD, "fox")));
       final Query phraseQuery = new SpanNearQuery(new SpanQuery[] {
-          new SpanTermQuery(new Term(FIELD, "the")),
-          new SpanTermQuery(new Term(FIELD, "fox"))}, 0, true);
+          new TermQuery(new Term(FIELD, "the")),
+          new TermQuery(new Term(FIELD, "fox"))}, 0, true);
 
       TopDocs hits = indexSearcher.search(phraseQuery, 1);
       assertEquals(1, hits.totalHits);
@@ -241,11 +241,11 @@
       assertEquals(1, indexReader.numDocs());
       final IndexSearcher indexSearcher = newSearcher(indexReader);
       // final DisjunctionMaxQuery query = new DisjunctionMaxQuery(1);
-      // query.add(new SpanTermQuery(new Term(FIELD, "the")));
-      // query.add(new SpanTermQuery(new Term(FIELD, "fox")));
+      // query.add(new TermQuery(new Term(FIELD, "the")));
+      // query.add(new TermQuery(new Term(FIELD, "fox")));
       final Query phraseQuery = new SpanNearQuery(new SpanQuery[] {
-          new SpanTermQuery(new Term(FIELD, "the")),
-          new SpanTermQuery(new Term(FIELD, "fox"))}, 0, true);
+          new TermQuery(new Term(FIELD, "the")),
+          new TermQuery(new Term(FIELD, "fox"))}, 0, true);
 
       TopDocs hits = indexSearcher.search(phraseQuery, 1);
       assertEquals(1, hits.totalHits);
Index: highlighter/src/test/org/apache/lucene/search/postingshighlight/TestMultiTermHighlighting.java
===================================================================
--- highlighter/src/test/org/apache/lucene/search/postingshighlight/TestMultiTermHighlighting.java	(revision 1672105)
+++ highlighter/src/test/org/apache/lucene/search/postingshighlight/TestMultiTermHighlighting.java	(working copy)
@@ -52,7 +52,6 @@
 import org.apache.lucene.search.spans.SpanNotQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 
@@ -723,7 +722,7 @@
       }
     };
     SpanQuery include = new SpanMultiTermQueryWrapper<>(new WildcardQuery(new Term("body", "te*")));
-    SpanQuery exclude = new SpanTermQuery(new Term("body", "bogus"));
+    SpanQuery exclude = new TermQuery(new Term("body", "bogus"));
     Query query = new SpanNotQuery(include, exclude);
     TopDocs topDocs = searcher.search(query, 10, Sort.INDEXORDER);
     assertEquals(2, topDocs.totalHits);
Index: queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java
===================================================================
--- queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java	(revision 1672105)
+++ queryparser/src/java/org/apache/lucene/queryparser/complexPhrase/ComplexPhraseQueryParser.java	(working copy)
@@ -17,11 +17,6 @@
  * limitations under the License.
  */
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
@@ -37,8 +32,12 @@
 import org.apache.lucene.search.spans.SpanNotQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
 /**
  * QueryParser which permits complex phrase query syntax eg "(john jon
  * jonathan~) peters*".
@@ -285,13 +284,13 @@
             // Insert fake term e.g. phrase query was for "Fred Smithe*" and
             // there were no "Smithe*" terms - need to
             // prevent match on just "Fred".
-            allSpanClauses[i] = new SpanTermQuery(new Term(field,
+            allSpanClauses[i] = new TermQuery(new Term(field,
                 "Dummy clause because no terms found - must match nothing"));
           }
         } else {
           if (qc instanceof TermQuery) {
             TermQuery tq = (TermQuery) qc;
-            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());
+            allSpanClauses[i] = new TermQuery(tq.getTerm());
           } else {
             throw new IllegalArgumentException("Unknown query type \""
                 + qc.getClass().getName()
@@ -350,9 +349,7 @@
         }
 
         if (childQuery instanceof TermQuery) {
-          TermQuery tq = (TermQuery) childQuery;
-          SpanTermQuery stq = new SpanTermQuery(tq.getTerm());
-          stq.setBoost(tq.getBoost());
+          TermQuery stq = (TermQuery) childQuery;
           chosenList.add(stq);
         } else if (childQuery instanceof BooleanQuery) {
           BooleanQuery cbq = (BooleanQuery) childQuery;
Index: queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java
===================================================================
--- queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java	(revision 1672105)
+++ queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java	(working copy)
@@ -27,7 +27,6 @@
  
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.TermQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 
 /** Factory for creating basic term queries */
 public class BasicQueryFactory {
@@ -68,11 +67,6 @@
     checkMax();
     return new TermQuery(term);
   }
-  
-  public SpanTermQuery newSpanTermQuery(Term term) throws TooManyBasicQueries {
-    checkMax();
-    return new SpanTermQuery(term);
-  }
 
   @Override
   public int hashCode() {
Index: queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java
===================================================================
--- queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java	(revision 1672105)
+++ queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java	(working copy)
@@ -52,18 +52,18 @@
    - SpanNotQuery: treat similar to subquery SpanNearQuery. (ok?)
  */
 
-import java.io.IOException;
-import java.util.Iterator;
-import java.util.HashMap;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanNearQuery;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Iterator;
 
+
 /**
  * Factory for {@link SpanOrQuery}
  */
@@ -99,7 +99,7 @@
   }
   
   public void addTermWeighted(Term t, float weight) throws IOException {   
-    SpanTermQuery stq = qf.newSpanTermQuery(t);
+    TermQuery stq = qf.newTermQuery(t);
     /* CHECKME: wrap in Hashable...? */
     addSpanQueryWeighted(stq, weight);
   }
Index: queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanOrTermsBuilder.java
===================================================================
--- queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanOrTermsBuilder.java	(revision 1672105)
+++ queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanOrTermsBuilder.java	(working copy)
@@ -4,12 +4,12 @@
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.queryparser.xml.DOMUtils;
+import org.apache.lucene.queryparser.xml.ParserException;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.queryparser.xml.DOMUtils;
-import org.apache.lucene.queryparser.xml.ParserException;
 import org.w3c.dom.Element;
 
 import java.io.IOException;
@@ -57,7 +57,7 @@
       ts.reset();
       while (ts.incrementToken()) {
         termAtt.fillBytesRef();
-        SpanTermQuery stq = new SpanTermQuery(new Term(fieldName, BytesRef.deepCopyOf(bytes)));
+        TermQuery stq = new TermQuery(new Term(fieldName, BytesRef.deepCopyOf(bytes)));
         clausesList.add(stq);
       }
       ts.end();
Index: queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanTermBuilder.java
===================================================================
--- queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanTermBuilder.java	(revision 1672105)
+++ queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanTermBuilder.java	(working copy)
@@ -1,10 +1,10 @@
 package org.apache.lucene.queryparser.xml.builders;
 
 import org.apache.lucene.index.Term;
-import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.queryparser.xml.DOMUtils;
 import org.apache.lucene.queryparser.xml.ParserException;
+import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.spans.SpanQuery;
 import org.w3c.dom.Element;
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
@@ -24,7 +24,7 @@
  */
 
 /**
- * Builder for {@link SpanTermQuery}
+ * Builder for {@link TermQuery}
  */
 public class SpanTermBuilder extends SpanBuilderBase {
 
@@ -32,7 +32,7 @@
   public SpanQuery getSpanQuery(Element e) throws ParserException {
     String fieldName = DOMUtils.getAttributeWithInheritanceOrFail(e, "fieldName");
     String value = DOMUtils.getNonBlankTextOrFail(e);
-    SpanTermQuery stq = new SpanTermQuery(new Term(fieldName, value));
+    TermQuery stq = new TermQuery(new Term(fieldName, value));
 
     stq.setBoost(DOMUtils.getAttribute(e, "boost", 1.0f));
     return stq;
Index: queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanTermQueryNodeBuilder.java
===================================================================
--- queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanTermQueryNodeBuilder.java	(revision 1672105)
+++ queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/SpanTermQueryNodeBuilder.java	(working copy)
@@ -22,19 +22,19 @@
 import org.apache.lucene.queryparser.flexible.core.nodes.FieldQueryNode;
 import org.apache.lucene.queryparser.flexible.core.nodes.QueryNode;
 import org.apache.lucene.queryparser.flexible.standard.builders.StandardQueryBuilder;
-import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.TermQuery;
 
 /**
- * This builder creates {@link SpanTermQuery}s from a {@link FieldQueryNode}
+ * This builder creates {@link TermQuery}s from a {@link FieldQueryNode}
  * object.
  */
 public class SpanTermQueryNodeBuilder implements StandardQueryBuilder {
 
   @Override
-  public SpanTermQuery build(QueryNode node) throws QueryNodeException {
+  public TermQuery build(QueryNode node) throws QueryNodeException {
     FieldQueryNode fieldQueryNode = (FieldQueryNode) node;
 
-    return new SpanTermQuery(new Term(fieldQueryNode.getFieldAsString(),
+    return new TermQuery(new Term(fieldQueryNode.getFieldAsString(),
         fieldQueryNode.getTextAsString()));
 
   }
Index: queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParser.java
===================================================================
--- queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParser.java	(revision 1672105)
+++ queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParser.java	(working copy)
@@ -24,10 +24,10 @@
 import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorPipeline;
 import org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser;
 import org.apache.lucene.queryparser.flexible.standard.processors.WildcardQueryNodeProcessor;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.search.Query;
 import org.apache.lucene.util.LuceneTestCase;
 
 /**
@@ -43,7 +43,7 @@
  * "field:term" or a list of pairs separated or not by an OR operator, and from
  * this query generate {@link SpanQuery} objects instead of the regular
  * {@link Query} objects. Basically, every pair will be converted to a
- * {@link SpanTermQuery} object and if there are more than one pair they will be
+ * {@link TermQuery} object and if there are more than one pair they will be
  * grouped by an {@link OrQueryNode}.<br>
  * <br>
  * 
@@ -143,8 +143,8 @@
     assertEquals(getSpanQuery("field:term").toString(), "term");
     assertEquals(getSpanQuery("term").toString(), "term");
 
-    assertTrue(getSpanQuery("field:term") instanceof SpanTermQuery);
-    assertTrue(getSpanQuery("term") instanceof SpanTermQuery);
+    assertTrue(getSpanQuery("field:term") instanceof TermQuery);
+    assertTrue(getSpanQuery("term") instanceof TermQuery);
 
   }
 
Index: queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParserSimpleSample.java
===================================================================
--- queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParserSimpleSample.java	(revision 1672105)
+++ queryparser/src/test/org/apache/lucene/queryparser/flexible/spans/TestSpanQueryParserSimpleSample.java	(working copy)
@@ -24,8 +24,8 @@
 import org.apache.lucene.queryparser.flexible.core.processors.QueryNodeProcessorPipeline;
 import org.apache.lucene.queryparser.flexible.standard.parser.StandardSyntaxParser;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.util.LuceneTestCase;
 
 /**
@@ -41,7 +41,7 @@
  * "field:term" or a list of pairs separated or not by an OR operator, and from
  * this query generate {@link SpanQuery} objects instead of the regular
  * {@link Query} objects. Basically, every pair will be converted to a
- * {@link SpanTermQuery} object and if there are more than one pair they will be
+ * {@link TermQuery} object and if there are more than one pair they will be
  * grouped by an {@link OrQueryNode}.<br>
  * <br>
  * 
@@ -129,7 +129,7 @@
     // convert QueryNode tree to span query Objects
     SpanQuery spanquery = spansQueryTreeBuilder.build(queryTree);
 
-    assertTrue(spanquery instanceof SpanTermQuery);
+    assertTrue(spanquery instanceof TermQuery);
     assertEquals(spanquery.toString(), "index:text");
 
   }
Index: test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java
===================================================================
--- test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java	(revision 1672105)
+++ test-framework/src/java/org/apache/lucene/search/BaseExplanationTestCase.java	(working copy)
@@ -30,7 +30,6 @@
 import org.apache.lucene.search.spans.SpanNotQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
-import org.apache.lucene.search.spans.SpanTermQuery;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
@@ -139,9 +138,9 @@
     return t;
   }
 
-  /** MACRO for SpanTermQuery */
-  public SpanTermQuery st(String s) {
-    return new SpanTermQuery(new Term(FIELD,s));
+  /** MACRO for TermQuery */
+  public TermQuery st(String s) {
+    return new TermQuery(new Term(FIELD,s));
   }
   
   /** MACRO for SpanNotQuery */
