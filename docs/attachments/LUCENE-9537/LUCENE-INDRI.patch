diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriAndQuery.java b/lucene/core/src/java/org/apache/lucene/search/IndriAndQuery.java
new file mode 100644
index 0000000..4700482
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriAndQuery.java
@@ -0,0 +1,18 @@
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.List;
+
+public class IndriAndQuery extends IndriQuery {
+
+    public IndriAndQuery(List<BooleanClause> clauses) {
+	super(clauses);
+    }
+
+    @Override
+    public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {
+	IndriAndQuery query = this;
+	return new IndriAndWeight(query, searcher, ScoreMode.TOP_SCORES, boost);
+    }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriAndScorer.java b/lucene/core/src/java/org/apache/lucene/search/IndriAndScorer.java
new file mode 100644
index 0000000..64399ec
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriAndScorer.java
@@ -0,0 +1,50 @@
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.List;
+
+public class IndriAndScorer extends IndriDisjunctionScorer {
+
+    protected IndriAndScorer(Weight weight, List<Scorer> subScorers, ScoreMode scoreMode, float boost)
+	throws IOException {
+	super(weight, subScorers, scoreMode, boost);
+    }
+
+    @Override
+    public float score(List<Scorer> subScorers) throws IOException {
+	int docId = this.docID();
+	return scoreDoc(subScorers, docId);
+    }
+
+    @Override
+    public float smoothingScore(List<Scorer> subScorers, int docId) throws IOException {
+	return scoreDoc(subScorers, docId);
+    }
+
+    private float scoreDoc(List<Scorer> subScorers, int docId) throws IOException {
+	double score = 0;
+	double boostSum = 0.0;
+	for (Scorer scorer : subScorers) {
+	    if (scorer instanceof IndriScorer) {
+		IndriScorer indriScorer = (IndriScorer) scorer;
+		int scorerDocId = indriScorer.docID();
+		if (docId == scorerDocId) {
+		    double tempScore = indriScorer.score();
+		    tempScore *= indriScorer.getBoost();
+		    score += tempScore;
+		} else {
+		    float smoothingScore = indriScorer.smoothingScore(docId);
+		    smoothingScore *= indriScorer.getBoost();
+		    score += smoothingScore;
+		}
+		boostSum += indriScorer.getBoost();
+	    }
+	}
+	if (boostSum == 0) {
+	    return 0;
+	} else {
+	    return (float) (score / boostSum);
+	}
+    }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriAndWeight.java b/lucene/core/src/java/org/apache/lucene/search/IndriAndWeight.java
new file mode 100644
index 0000000..f881574
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriAndWeight.java
@@ -0,0 +1,62 @@
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.index.LeafReaderContext;
+
+public class IndriAndWeight extends IndriWeight {
+
+    private final ArrayList<Weight> weights;
+    private final ScoreMode scoreMode;
+    private final float boost;
+
+    public IndriAndWeight(IndriAndQuery query, IndexSearcher searcher, ScoreMode scoreMode, float boost)
+	throws IOException {
+	super(query, searcher, scoreMode, boost);
+	this.boost = boost;
+	this.scoreMode = scoreMode;
+	weights = new ArrayList<>();
+	for (BooleanClause c : query) {
+	    Weight w = searcher.createWeight(c.getQuery(), scoreMode, 1.0f);
+	    weights.add(w);
+	}
+    }
+
+    private Scorer getScorer(LeafReaderContext context) throws IOException {
+	List<Scorer> subScorers = new ArrayList<>();
+
+	for (Weight w : weights) {
+	    Scorer scorer = w.scorer(context);
+	    if (scorer != null) {
+		subScorers.add(scorer);
+	    }
+	}
+
+	if (subScorers.isEmpty()) {
+	    return null;
+	}
+	Scorer scorer = subScorers.get(0);
+	if (subScorers.size() > 1) {
+	    scorer = new IndriAndScorer(this, subScorers, scoreMode, boost);
+	}
+	return scorer;
+    }
+
+    @Override
+    public Scorer scorer(LeafReaderContext context) throws IOException {
+	return getScorer(context);
+    }
+
+    @Override
+    public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {
+	Scorer scorer = getScorer(context);
+	if (scorer != null) {
+	    BulkScorer bulkScorer = new DefaultBulkScorer(scorer);
+	    return bulkScorer;
+	}
+	return null;
+    }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriDisjunctionScorer.java b/lucene/core/src/java/org/apache/lucene/search/IndriDisjunctionScorer.java
new file mode 100644
index 0000000..6e43f5c
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriDisjunctionScorer.java
@@ -0,0 +1,56 @@
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.List;
+
+abstract public class IndriDisjunctionScorer extends IndriScorer {
+
+    private final List<Scorer> subScorersList;
+    private final DisiPriorityQueue subScorers;
+    private final DocIdSetIterator approximation;
+
+    protected IndriDisjunctionScorer(Weight weight, List<Scorer> subScorersList, ScoreMode scoreMode, float boost) {
+	super(weight, boost);
+	this.subScorersList = subScorersList;
+	this.subScorers = new DisiPriorityQueue(subScorersList.size());
+	for (Scorer scorer : subScorersList) {
+	    final DisiWrapper w = new DisiWrapper(scorer);
+	    this.subScorers.add(w);
+	}
+	this.approximation = new DisjunctionDISIApproximation(this.subScorers);
+    }
+
+    @Override
+    public DocIdSetIterator iterator() {
+	return approximation;
+    }
+
+    @Override
+    public float getMaxScore(int upTo) throws IOException {
+	return 0;
+    }
+
+    public List<Scorer> getSubMatches() throws IOException {
+	return subScorersList;
+    }
+
+    abstract float score(List<Scorer> subScorers) throws IOException;
+
+    abstract public float smoothingScore(List<Scorer> subScorers, int docId) throws IOException;
+
+    @Override
+    public float score() throws IOException {
+	return score(getSubMatches());
+    }
+
+    @Override
+    public float smoothingScore(int docId) throws IOException {
+	return smoothingScore(getSubMatches(), docId);
+    }
+
+    @Override
+    public int docID() {
+	return subScorers.top().doc;
+    }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriQuery.java b/lucene/core/src/java/org/apache/lucene/search/IndriQuery.java
new file mode 100644
index 0000000..f79e0bd
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriQuery.java
@@ -0,0 +1,77 @@
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Objects;
+
+public abstract class IndriQuery extends Query implements Iterable<BooleanClause> {
+
+    private List<BooleanClause> clauses;
+
+    public IndriQuery(List<BooleanClause> clauses) {
+	this.clauses = clauses;
+    }
+
+    @Override
+	public abstract Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException;
+
+    @Override
+	public String toString(String field) {
+	StringBuilder buffer = new StringBuilder();
+
+	int i = 0;
+	for (BooleanClause c : this) {
+	    buffer.append(c.getOccur().toString());
+
+	    Query subQuery = c.getQuery();
+	    if (subQuery instanceof BooleanQuery) { // wrap sub-bools in parens
+		buffer.append("(");
+		buffer.append(subQuery.toString(field));
+		buffer.append(")");
+	    } else {
+		buffer.append(subQuery.toString(field));
+	    }
+
+	    if (i != clauses.size() - 1) {
+		buffer.append(" ");
+	    }
+	    i += 1;
+	}
+
+	return buffer.toString();
+    }
+
+    @Override
+	public boolean equals(Object o) {
+	return sameClassAs(o) && equalsTo(getClass().cast(o));
+    }
+
+    @Override
+    public void visit(QueryVisitor visitor) {
+	visitor.visitLeaf(this);
+    }
+
+    private boolean equalsTo(IndriQuery other) {
+	return clauses.equals(other.clauses);
+    }
+
+    @Override
+	public int hashCode() {
+	int hashCode = Objects.hash(clauses);
+	if (hashCode == 0) {
+	    hashCode = 1;
+	}
+	return hashCode;
+    }
+
+    @Override
+	public Iterator<BooleanClause> iterator() {
+	return clauses.iterator();
+    }
+
+    public List<BooleanClause> getClauses() {
+	return this.clauses;
+    }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriScorer.java b/lucene/core/src/java/org/apache/lucene/search/IndriScorer.java
new file mode 100644
index 0000000..236cd88
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriScorer.java
@@ -0,0 +1,36 @@
+package org.apache.lucene.search;
+
+import java.io.IOException;
+
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.search.Scorer;
+import org.apache.lucene.search.Weight;
+
+abstract public class IndriScorer extends Scorer {
+
+    private float boost;
+
+    protected IndriScorer(Weight weight, float boost) {
+	super(weight);
+	this.boost = boost;
+    }
+
+    @Override
+    abstract public DocIdSetIterator iterator();
+
+    @Override
+    abstract public float getMaxScore(int upTo) throws IOException;
+
+    @Override
+    abstract public float score() throws IOException;
+
+    abstract public float smoothingScore(int docId) throws IOException;
+
+    @Override
+    abstract public int docID();
+
+    public float getBoost() {
+	return this.boost;
+    }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriTermQuery.java b/lucene/core/src/java/org/apache/lucene/search/IndriTermQuery.java
new file mode 100644
index 0000000..9e4a56a
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriTermQuery.java
@@ -0,0 +1,195 @@
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.Objects;
+import java.util.Set;
+
+import org.apache.lucene.index.IndexReaderContext;
+import org.apache.lucene.index.LeafReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.PostingsEnum;
+import org.apache.lucene.index.ReaderUtil;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermState;
+import org.apache.lucene.index.TermStates;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.search.similarities.Similarity;
+
+public class IndriTermQuery extends Query {
+
+    private final Term term;
+    private final TermStates perReaderTermState;
+
+    final class IndriTermWeight extends Weight {
+	private final Similarity similarity;
+	private final float boost;
+	private final Similarity.SimScorer simScorer;
+	private final TermStates termStates;
+	private final ScoreMode scoreMode;
+
+	public IndriTermWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost, TermStates termStates)
+	    throws IOException {
+	    super(IndriTermQuery.this);
+	    this.boost = boost;
+	    this.similarity = searcher.getSimilarity();
+	    this.scoreMode = ScoreMode.TOP_SCORES;
+	    this.termStates = termStates;
+
+	    final CollectionStatistics collectionStats;
+	    final TermStatistics termStats;
+	    collectionStats = searcher.collectionStatistics(IndriTermQuery.this.getTerm().field());
+	    termStats = searcher.termStatistics(IndriTermQuery.this.getTerm(), termStates.docFreq(), termStates.totalTermFreq());
+
+	    if (termStats == null) {
+		this.simScorer = null; // term doesn't exist in any segment, we won't use similarity at all
+	    } else {
+		this.simScorer = similarity.scorer(boost, collectionStats, termStats);
+	    }
+	}
+
+	@Override
+	public Matches matches(LeafReaderContext context, int doc) throws IOException {
+	    return null;
+	}
+
+	@Override
+	public String toString() {
+	    return "weight(" + IndriTermQuery.this + ")";
+	}
+
+	@Override
+	public Scorer scorer(LeafReaderContext context) throws IOException {
+	    assert termStates == null || termStates.wasBuiltFor(ReaderUtil.getTopLevelContext(
+											      context)) : "The top-reader used to create Weight is not the same as the current reader's top-reader ("
+		+ ReaderUtil.getTopLevelContext(context);
+	    ;
+	    final TermsEnum termsEnum = getTermsEnum(context);
+	    if (termsEnum == null || simScorer == null) {
+		return null;
+	    }
+	    LeafSimScorer scorer = new LeafSimScorer(simScorer, context.reader(), term.field(),
+						     scoreMode.needsScores());
+
+	    Scorer indriTermScorer = new IndriTermScorer(this, termsEnum.impacts(PostingsEnum.POSITIONS), scorer,
+							 this.boost);
+	    return indriTermScorer;
+	}
+
+	/**
+	 * Returns a {@link TermsEnum} positioned at this weights Term or null if the
+	 * term does not exist in the given context
+	 */
+	private TermsEnum getTermsEnum(LeafReaderContext context) throws IOException {
+	    assert termStates != null;
+	    assert termStates.wasBuiltFor(ReaderUtil.getTopLevelContext(
+									context)) : "The top-reader used to create Weight is not the same as the current reader's top-reader ("
+		+ ReaderUtil.getTopLevelContext(context);
+	    final TermState state = termStates.get(context);
+	    if (state == null) { // term is not present in that reader
+		assert termNotInReader(context.reader(), term) : "no termstate found but term exists in reader term="
+		    + term;
+		return null;
+	    }
+	    final TermsEnum termsEnum = context.reader().terms(term.field()).iterator();
+	    termsEnum.seekExact(term.bytes(), state);
+	    return termsEnum;
+	}
+
+	private boolean termNotInReader(LeafReader reader, Term term) throws IOException {
+	    return reader.docFreq(term) == 0;
+	}
+
+	@Override
+	public boolean isCacheable(LeafReaderContext ctx) {
+	    return true;
+	}
+
+	@Override
+	public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+	    IndriTermScorer scorer = (IndriTermScorer) scorer(context);
+	    if (scorer != null) {
+		int newDoc = scorer.iterator().advance(doc);
+		if (newDoc == doc) {
+		    float freq = scorer.freq();
+		    LeafSimScorer docScorer = new LeafSimScorer(simScorer, context.reader(), term.field(), true);
+		    Explanation freqExplanation = Explanation.match(freq, "freq, occurrences of term within document");
+		    Explanation scoreExplanation = docScorer.explain(doc, freqExplanation);
+		    return Explanation.match(scoreExplanation.getValue(), "weight(" + getQuery() + " in " + doc + ") ["
+					     + similarity.getClass().getSimpleName() + "], result of:", scoreExplanation);
+		}
+	    }
+	    return Explanation.noMatch("no matching term");
+	}
+    }
+
+    /** Constructs a query for the term <code>t</code>. */
+    public IndriTermQuery(Term t) {
+	this.term = t;
+	this.perReaderTermState = null;
+    }
+
+    /**
+     * Expert: constructs a TermQuery that will use the provided docFreq instead of
+     * looking up the docFreq against the searcher.
+     */
+    public IndriTermQuery(Term t, TermStates states) {
+	this.term = t;
+	this.perReaderTermState = Objects.requireNonNull(states);
+    }
+
+    @Override
+    public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {
+	final IndexReaderContext context = searcher.getTopReaderContext();
+	final TermStates termState;
+	if (perReaderTermState == null || perReaderTermState.wasBuiltFor(context) == false) {
+	    termState = TermStates.build(context, term, scoreMode.needsScores());
+	} else {
+	    // PRTS was pre-build for this IS
+	    termState = this.perReaderTermState;
+	}
+
+	return new IndriTermWeight(searcher, scoreMode, boost, termState);
+    }
+
+    /** Returns the term of this query. */
+    public Term getTerm() {
+	return term;
+    }
+
+    @Override
+    public void visit(QueryVisitor visitor) {
+	visitor.visitLeaf(this);
+    }
+
+    /**
+     * Returns the {@link TermStates} passed to the constructor, or null if it was
+     * not passed.
+     *
+     * @lucene.experimental
+     */
+    public TermStates getTermStates() {
+	return perReaderTermState;
+    }
+
+    @Override
+    public String toString(String field) {
+	StringBuilder buffer = new StringBuilder();
+	if (!term.field().equals(field)) {
+	    buffer.append(term.field());
+	    buffer.append(":");
+	}
+	buffer.append(term.text());
+	return buffer.toString();
+    }
+
+    @Override
+    public boolean equals(Object other) {
+	return sameClassAs(other) && term.equals(((IndriTermQuery) other).term);
+    }
+
+    @Override
+    public int hashCode() {
+	return classHash() ^ term.hashCode();
+    }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriTermScorer.java b/lucene/core/src/java/org/apache/lucene/search/IndriTermScorer.java
new file mode 100644
index 0000000..d70870a
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriTermScorer.java
@@ -0,0 +1,49 @@
+package org.apache.lucene.search;
+
+import java.io.IOException;
+
+import org.apache.lucene.index.PostingsEnum;
+
+public class IndriTermScorer extends IndriScorer {
+
+    private final PostingsEnum postingsEnum;
+    private final DocIdSetIterator iterator;
+    private final LeafSimScorer docScorer;
+
+    protected IndriTermScorer(Weight weight, PostingsEnum postingsEnum, LeafSimScorer docScorer, float boost) {
+	super(weight, boost);
+	this.docScorer = docScorer;
+	iterator = this.postingsEnum = postingsEnum;
+    }
+
+    @Override
+    public float smoothingScore(int docId) throws IOException {
+	return docScorer.score(docId, 0);
+    }
+
+    @Override
+    public int docID() {
+	return postingsEnum.docID();
+    }
+
+    @Override
+    public float score() throws IOException {
+	assert docID() != DocIdSetIterator.NO_MORE_DOCS;
+	return docScorer.score(postingsEnum.docID(), postingsEnum.freq());
+    }
+
+    @Override
+    public DocIdSetIterator iterator() {
+	return iterator;
+    }
+
+    @Override
+    public float getMaxScore(int upTo) throws IOException {
+	return 0;
+    }
+
+    final int freq() throws IOException {
+	return postingsEnum.freq();
+    }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriWeight.java b/lucene/core/src/java/org/apache/lucene/search/IndriWeight.java
new file mode 100644
index 0000000..f04a13d
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriWeight.java
@@ -0,0 +1,90 @@
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause.Occur;
+
+public abstract class IndriWeight extends Weight {
+
+    final IndriQuery query;
+    final ArrayList<Weight> weights;
+    final ScoreMode scoreMode;
+
+    protected IndriWeight(IndriQuery query, IndexSearcher searcher, ScoreMode scoreMode, float boost)
+	throws IOException {
+	super(query);
+	this.query = query;
+	this.scoreMode = scoreMode;
+	weights = new ArrayList<>();
+	for (BooleanClause c : query) {
+	    Weight w = searcher.createWeight(c.getQuery(), c.isScoring() ? scoreMode : ScoreMode.COMPLETE_NO_SCORES,
+					     boost);
+	    weights.add(w);
+	}
+    }
+
+    @Override
+    public boolean isCacheable(LeafReaderContext ctx) {
+	for (Weight w : weights) {
+	    if (w.isCacheable(ctx) == false)
+		return false;
+	}
+	return true;
+    }
+
+    @Override
+    public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+	List<Explanation> subs = new ArrayList<>();
+	boolean fail = false;
+	int matchCount = 0;
+	int shouldMatchCount = 0;
+	Iterator<BooleanClause> cIter = query.iterator();
+	for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {
+	    Weight w = wIter.next();
+	    BooleanClause c = cIter.next();
+	    Explanation e = w.explain(context, doc);
+	    if (e.isMatch()) {
+		if (c.isScoring()) {
+		    subs.add(e);
+		} else if (c.isRequired()) {
+		    subs.add(Explanation.match(0f, "match on required clause, product of:",
+					       Explanation.match(0f, Occur.FILTER + " clause"), e));
+		} else if (c.isProhibited()) {
+		    subs.add(Explanation.noMatch("match on prohibited clause (" + c.getQuery().toString() + ")", e));
+		    fail = true;
+		}
+		if (!c.isProhibited()) {
+		    matchCount++;
+		}
+		if (c.getOccur() == Occur.SHOULD) {
+		    shouldMatchCount++;
+		}
+	    } else if (c.isRequired()) {
+		subs.add(Explanation.noMatch("no match on required clause (" + c.getQuery().toString() + ")", e));
+		fail = true;
+	    }
+	}
+	if (fail) {
+	    return Explanation.noMatch("Failure to meet condition(s) of required/prohibited clause(s)", subs);
+	} else if (matchCount == 0) {
+	    return Explanation.noMatch("No matching clauses", subs);
+	} else {
+	    // Replicating the same floating-point errors as the scorer does is quite
+	    // complex (essentially because of how ReqOptSumScorer casts intermediate
+	    // contributions to the score to floats), so in order to make sure that
+	    // explanations have the same value as the score, we pull a scorer and
+	    // use it to compute the score.
+	    Scorer scorer = scorer(context);
+	    int advanced = scorer.iterator().advance(doc);
+	    assert advanced == doc;
+	    return Explanation.match(scorer.score(), "sum of:", subs);
+	}
+    }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/similarities/IndriDirichletSimilarity.java b/lucene/core/src/java/org/apache/lucene/search/similarities/IndriDirichletSimilarity.java
new file mode 100644
index 0000000..397a587
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/similarities/IndriDirichletSimilarity.java
@@ -0,0 +1,86 @@
+package org.apache.lucene.search.similarities;
+
+import java.util.List;
+import java.util.Locale;
+
+import org.apache.lucene.search.Explanation;
+
+public class IndriDirichletSimilarity extends LMSimilarity {
+
+    /** The &mu; parameter. */
+    private final float mu;
+
+    /** Instantiates the similarity with the provided &mu; parameter. */
+    public IndriDirichletSimilarity(CollectionModel collectionModel, float mu) {
+	super(collectionModel);
+	this.mu = mu;
+    }
+
+    /** Instantiates the similarity with the provided &mu; parameter. */
+    public IndriDirichletSimilarity(float mu) {
+	this.mu = mu;
+    }
+
+    /** Instantiates the similarity with the default &mu; value of 2000. */
+    public IndriDirichletSimilarity(CollectionModel collectionModel) {
+	this(collectionModel, 2000);
+    }
+
+    /** Instantiates the similarity with the default &mu; value of 2000. */
+    public IndriDirichletSimilarity() {
+	this(new IndriCollectionModel(), 2000);
+    }
+
+    @Override
+    protected double score(BasicStats stats, double freq, double docLen) {
+	double collectionProbability = ((LMStats) stats).getCollectionProbability();
+	double score = (freq + (mu * collectionProbability)) / (docLen + mu);
+	return Math.log(score);
+    }
+
+    @Override
+    protected void explain(List<Explanation> subs, BasicStats stats, double freq, double docLen) {
+	if (stats.getBoost() != 1.0f) {
+	    subs.add(Explanation.match(stats.getBoost(), "boost"));
+	}
+
+	subs.add(Explanation.match(mu, "mu"));
+	double collectionProbability = ((LMStats) stats).getCollectionProbability();
+	Explanation weightExpl = Explanation
+	    .match((float) Math.log((freq + (mu * collectionProbability)) / (docLen + mu)), "term weight");
+	subs.add(weightExpl);
+	subs.add(Explanation.match((float) Math.log(mu / (docLen + mu)), "document norm"));
+	super.explain(subs, stats, freq, docLen);
+    }
+
+    /** Returns the &mu; parameter. */
+    public float getMu() {
+	return mu;
+    }
+
+    public String getName() {
+	return String.format(Locale.ROOT, "IndriDirichlet(%f)", getMu());
+    }
+
+    /**
+     * Models {@code p(w|C)} as the number of occurrences of the term in the
+     * collection, divided by the total number of tokens {@code + 1}.
+     */
+    public static class IndriCollectionModel implements CollectionModel {
+
+	/** Sole constructor: parameter-free */
+	public IndriCollectionModel() {
+	}
+
+	@Override
+	public double computeProbability(BasicStats stats) {
+	    return ((double) stats.getTotalTermFreq()) / ((double) stats.getNumberOfFieldTokens());
+	}
+
+	@Override
+	public String getName() {
+	    return null;
+	}
+    }
+
+}
