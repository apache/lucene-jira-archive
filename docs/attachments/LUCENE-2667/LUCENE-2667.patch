Index: lucene/src/test/org/apache/lucene/queryParser/TestMultiFieldQueryParser.java
===================================================================
--- lucene/src/test/org/apache/lucene/queryParser/TestMultiFieldQueryParser.java	(revision 1002153)
+++ lucene/src/test/org/apache/lucene/queryParser/TestMultiFieldQueryParser.java	(working copy)
@@ -87,7 +87,7 @@
     assertEquals("((b:one t:one)^2.0) (b:two t:two)", q.toString());
 
     q = mfqp.parse("one~ two");
-    assertEquals("(b:one~0.5 t:one~0.5) (b:two t:two)", q.toString());
+    assertEquals("(b:one~2.0 t:one~2.0) (b:two t:two)", q.toString());
 
     q = mfqp.parse("one~0.8 two^2");
     assertEquals("(b:one~0.8 t:one~0.8) ((b:two t:two)^2.0)", q.toString());
@@ -274,7 +274,7 @@
     q = parser.parse("bla*");
     assertEquals("f1:bla* f2:bla* f3:bla*", q.toString());
     q = parser.parse("bla~");
-    assertEquals("f1:bla~0.5 f2:bla~0.5 f3:bla~0.5", q.toString());
+    assertEquals("f1:bla~2.0 f2:bla~2.0 f3:bla~2.0", q.toString());
     q = parser.parse("[a TO c]");
     assertEquals("f1:[a TO c] f2:[a TO c] f3:[a TO c]", q.toString());
   }
Index: lucene/src/test/org/apache/lucene/queryParser/TestQueryParser.java
===================================================================
--- lucene/src/test/org/apache/lucene/queryParser/TestQueryParser.java	(revision 1002153)
+++ lucene/src/test/org/apache/lucene/queryParser/TestQueryParser.java	(working copy)
@@ -431,10 +431,10 @@
   public void testWildcard() throws Exception {
     assertQueryEquals("term*", null, "term*");
     assertQueryEquals("term*^2", null, "term*^2.0");
-    assertQueryEquals("term~", null, "term~0.5");
+    assertQueryEquals("term~", null, "term~2.0");
     assertQueryEquals("term~0.7", null, "term~0.7");
-    assertQueryEquals("term~^2", null, "term~0.5^2.0");
-    assertQueryEquals("term^2~", null, "term~0.5^2.0");
+    assertQueryEquals("term~^3", null, "term~2.0^3.0");
+    assertQueryEquals("term^3~", null, "term~2.0^3.0");
     assertQueryEquals("term*germ", null, "term*germ");
     assertQueryEquals("term*germ^3", null, "term*germ^3.0");
 
@@ -446,7 +446,7 @@
     assertEquals(0.7f, fq.getMinSimilarity(), 0.1f);
     assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
     fq = (FuzzyQuery)getQuery("term~", null);
-    assertEquals(0.5f, fq.getMinSimilarity(), 0.1f);
+    assertEquals(2.0f, fq.getMinSimilarity(), 0.1f);
     assertEquals(FuzzyQuery.defaultPrefixLength, fq.getPrefixLength());
     
     assertParseException("term~1.1"); // value > 1, throws exception
@@ -481,9 +481,9 @@
     assertWildcardQueryEquals("TE?M", false, "TE?M");
     assertWildcardQueryEquals("Te?m*gerM", false, "Te?m*gerM");
 //  Fuzzy queries:
-    assertWildcardQueryEquals("Term~", "term~0.5");
-    assertWildcardQueryEquals("Term~", true, "term~0.5");
-    assertWildcardQueryEquals("Term~", false, "Term~0.5");
+    assertWildcardQueryEquals("Term~", "term~2.0");
+    assertWildcardQueryEquals("Term~", true, "term~2.0");
+    assertWildcardQueryEquals("Term~", false, "Term~2.0");
 //  Range queries:
     assertWildcardQueryEquals("[A TO C]", "[a TO c]");
     assertWildcardQueryEquals("[A TO C]", true, "[a TO c]");
@@ -761,10 +761,10 @@
 
     assertQueryEquals("a:b\\\\?c", a, "a:b\\?c");
 
-    assertQueryEquals("a:b\\-c~", a, "a:b-c~0.5");
-    assertQueryEquals("a:b\\+c~", a, "a:b+c~0.5");
-    assertQueryEquals("a:b\\:c~", a, "a:b:c~0.5");
-    assertQueryEquals("a:b\\\\c~", a, "a:b\\c~0.5");
+    assertQueryEquals("a:b\\-c~", a, "a:b-c~2.0");
+    assertQueryEquals("a:b\\+c~", a, "a:b+c~2.0");
+    assertQueryEquals("a:b\\:c~", a, "a:b:c~2.0");
+    assertQueryEquals("a:b\\\\c~", a, "a:b\\c~2.0");
 
     assertQueryEquals("[ a\\- TO a\\+ ]", null, "[a- TO a+]");
     assertQueryEquals("[ a\\: TO a\\~ ]", null, "[a: TO a~]");
Index: lucene/src/test/org/apache/lucene/search/TestFuzzyQuery.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestFuzzyQuery.java	(revision 1002153)
+++ lucene/src/test/org/apache/lucene/search/TestFuzzyQuery.java	(working copy)
@@ -27,9 +27,12 @@
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.queryParser.QueryParser;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util._TestUtil;
+import org.junit.Ignore;
 
 /**
  * Tests {@link FuzzyQuery}.
@@ -202,58 +205,58 @@
 
     FuzzyQuery query;
     // not similar enough:
-    query = new FuzzyQuery(new Term("field", "xxxxx"), FuzzyQuery.defaultMinSimilarity, 0);   
+    query = new FuzzyQuery(new Term("field", "xxxxx"), 0.5f, 0);   
     ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals(0, hits.length);
     // edit distance to "aaaaaaa" = 3, this matches because the string is longer than
     // in testDefaultFuzziness so a bigger difference is allowed:
-    query = new FuzzyQuery(new Term("field", "aaaaccc"), FuzzyQuery.defaultMinSimilarity, 0);   
+    query = new FuzzyQuery(new Term("field", "aaaaccc"), 0.5f, 0);   
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals(1, hits.length);
     assertEquals(searcher.doc(hits[0].doc).get("field"), ("aaaaaaa"));
     
     // now with prefix
-    query = new FuzzyQuery(new Term("field", "aaaaccc"), FuzzyQuery.defaultMinSimilarity, 1);   
+    query = new FuzzyQuery(new Term("field", "aaaaccc"), 0.5f, 1);   
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals(1, hits.length);
     assertEquals(searcher.doc(hits[0].doc).get("field"), ("aaaaaaa"));
-    query = new FuzzyQuery(new Term("field", "aaaaccc"), FuzzyQuery.defaultMinSimilarity, 4);   
+    query = new FuzzyQuery(new Term("field", "aaaaccc"), 0.5f, 4);   
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals(1, hits.length);
     assertEquals(searcher.doc(hits[0].doc).get("field"), ("aaaaaaa"));
-    query = new FuzzyQuery(new Term("field", "aaaaccc"), FuzzyQuery.defaultMinSimilarity, 5);   
+    query = new FuzzyQuery(new Term("field", "aaaaccc"), 0.5f, 5);   
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals(0, hits.length);
 
     // no match, more than half of the characters is wrong:
-    query = new FuzzyQuery(new Term("field", "aaacccc"), FuzzyQuery.defaultMinSimilarity, 0);   
+    query = new FuzzyQuery(new Term("field", "aaacccc"), 0.5f, 0);   
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals(0, hits.length);
     
     // now with prefix
-    query = new FuzzyQuery(new Term("field", "aaacccc"), FuzzyQuery.defaultMinSimilarity, 2);   
+    query = new FuzzyQuery(new Term("field", "aaacccc"), 0.5f, 2);   
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals(0, hits.length);
 
     // "student" and "stellent" are indeed similar to "segment" by default:
-    query = new FuzzyQuery(new Term("field", "student"), FuzzyQuery.defaultMinSimilarity, 0);   
+    query = new FuzzyQuery(new Term("field", "student"), 0.5f, 0);   
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals(1, hits.length);
-    query = new FuzzyQuery(new Term("field", "stellent"), FuzzyQuery.defaultMinSimilarity, 0);   
+    query = new FuzzyQuery(new Term("field", "stellent"), 0.5f, 0);   
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals(1, hits.length);
     
     // now with prefix
-    query = new FuzzyQuery(new Term("field", "student"), FuzzyQuery.defaultMinSimilarity, 1);   
+    query = new FuzzyQuery(new Term("field", "student"), 0.5f, 1);   
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals(1, hits.length);
-    query = new FuzzyQuery(new Term("field", "stellent"), FuzzyQuery.defaultMinSimilarity, 1);   
+    query = new FuzzyQuery(new Term("field", "stellent"), 0.5f, 1);   
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals(1, hits.length);
-    query = new FuzzyQuery(new Term("field", "student"), FuzzyQuery.defaultMinSimilarity, 2);   
+    query = new FuzzyQuery(new Term("field", "student"), 0.5f, 2);   
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals(0, hits.length);
-    query = new FuzzyQuery(new Term("field", "stellent"), FuzzyQuery.defaultMinSimilarity, 2);   
+    query = new FuzzyQuery(new Term("field", "stellent"), 0.5f, 2);   
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals(0, hits.length);
     
@@ -328,7 +331,7 @@
     IndexSearcher searcher = new IndexSearcher(reader);
     writer.close();
     
-    FuzzyQuery query = new FuzzyQuery(new Term("field", "Lucene"));
+    FuzzyQuery query = new FuzzyQuery(new Term("field", "lucene"));
     query.setRewriteMethod(new MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite());
     ScoreDoc[] hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals(3, hits.length);
@@ -378,6 +381,54 @@
     r.close();
     index.close();
   }
+  
+  public void testDistanceAsEditsParsing() throws Exception {
+    QueryParser qp = new QueryParser(TEST_VERSION_CURRENT, "field", new MockAnalyzer());
+    FuzzyQuery q = (FuzzyQuery) qp.parse("foobar~2");
+    assertEquals(2f, q.getMinSimilarity(), 0.0001f);
+  }
+  
+  public void testDistanceAsEditsSearching() throws Exception {
+    Directory index = newDirectory();
+    RandomIndexWriter w = new RandomIndexWriter(random, index);
+    addDoc("foobar", w);
+    addDoc("test", w);
+    addDoc("working", w);
+    IndexReader reader = w.getReader();
+    IndexSearcher searcher = new IndexSearcher(reader);
+    w.close();
+    QueryParser qp = new QueryParser(TEST_VERSION_CURRENT, "field", new MockAnalyzer());
+    
+    FuzzyQuery q = (FuzzyQuery) qp.parse("fouba~2");
+    ScoreDoc[] hits = searcher.search(q, 10).scoreDocs;
+    assertEquals(1, hits.length);
+    assertEquals("foobar", searcher.doc(hits[0].doc).get("field"));
+    
+    q = (FuzzyQuery) qp.parse("foubara~2");
+    hits = searcher.search(q, 10).scoreDocs;
+    assertEquals(1, hits.length);
+    assertEquals("foobar", searcher.doc(hits[0].doc).get("field"));
+    
+    q = (FuzzyQuery) qp.parse("t~3");
+    hits = searcher.search(q, 10).scoreDocs;
+    assertEquals(1, hits.length);
+    assertEquals("test", searcher.doc(hits[0].doc).get("field"));
+    
+    q = new FuzzyQuery(new Term("field", "a"), 4f, 0, 50);
+    hits = searcher.search(q, 10).scoreDocs;
+    assertEquals(1, hits.length);
+    assertEquals("test", searcher.doc(hits[0].doc).get("field"));
+    
+    q = new FuzzyQuery(new Term("field", "a"), 6f, 0, 50);
+    hits = searcher.search(q, 10).scoreDocs;
+    assertEquals(2, hits.length);
+    assertEquals("test", searcher.doc(hits[0].doc).get("field"));
+    assertEquals("foobar", searcher.doc(hits[1].doc).get("field"));
+    
+    searcher.close();
+    reader.close();
+    index.close();
+  }
 
   private void addDoc(String text, RandomIndexWriter writer) throws IOException {
     Document doc = new Document();
Index: lucene/src/java/org/apache/lucene/queryParser/Token.java
===================================================================
--- lucene/src/java/org/apache/lucene/queryParser/Token.java	(revision 1002153)
+++ lucene/src/java/org/apache/lucene/queryParser/Token.java	(working copy)
@@ -121,4 +121,4 @@
   }
 
 }
-/* JavaCC - OriginalChecksum=37b1923f964a5a434f5ea3d6952ff200 (do not edit this line) */
+/* JavaCC - OriginalChecksum=c147cc166a7cf8812c7c39bc8c5eb868 (do not edit this line) */
Index: lucene/src/java/org/apache/lucene/queryParser/TokenMgrError.java
===================================================================
--- lucene/src/java/org/apache/lucene/queryParser/TokenMgrError.java	(revision 1002153)
+++ lucene/src/java/org/apache/lucene/queryParser/TokenMgrError.java	(working copy)
@@ -138,4 +138,4 @@
       this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
    }
 }
-/* JavaCC - OriginalChecksum=334e679cf1a88b3070bb8e3d80ee3f5e (do not edit this line) */
+/* JavaCC - OriginalChecksum=1c94e13236c7e0121e49427992341ee3 (do not edit this line) */
Index: lucene/src/java/org/apache/lucene/queryParser/QueryParser.java
===================================================================
--- lucene/src/java/org/apache/lucene/queryParser/QueryParser.java	(revision 1002153)
+++ lucene/src/java/org/apache/lucene/queryParser/QueryParser.java	(working copy)
@@ -1446,8 +1446,10 @@
           try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
           } catch (Exception ignored) { }
-         if(fms < 0.0f || fms > 1.0f){
+         if(fms < 0.0f){
            {if (true) throw new ParseException("Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !");}
+         } else if (fms >= 1.0f && fms != (int) fms) {
+           {if (true) throw new ParseException("Fractional edit distances are not allowed!");}
          }
          q = getFuzzyQuery(field, termImage,fms);
        } else {
Index: lucene/src/java/org/apache/lucene/queryParser/QueryParser.jj
===================================================================
--- lucene/src/java/org/apache/lucene/queryParser/QueryParser.jj	(revision 1002153)
+++ lucene/src/java/org/apache/lucene/queryParser/QueryParser.jj	(working copy)
@@ -1412,8 +1412,10 @@
        	  try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
        	  } catch (Exception ignored) { }
-       	 if(fms < 0.0f || fms > 1.0f){
+       	 if(fms < 0.0f){
        	   throw new ParseException("Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !");
+       	 } else if (fms >= 1.0f && fms != (int) fms) {
+       	   throw new ParseException("Fractional edit distances are not allowed!");
        	 }
        	 q = getFuzzyQuery(field, termImage,fms);
        } else {
Index: lucene/src/java/org/apache/lucene/queryParser/CharStream.java
===================================================================
--- lucene/src/java/org/apache/lucene/queryParser/CharStream.java	(revision 1002153)
+++ lucene/src/java/org/apache/lucene/queryParser/CharStream.java	(working copy)
@@ -109,4 +109,4 @@
   void Done();
 
 }
-/* JavaCC - OriginalChecksum=a83909a2403f969f94d18375f9f143e4 (do not edit this line) */
+/* JavaCC - OriginalChecksum=32a89423891f765dde472f7ef0e3ef7b (do not edit this line) */
Index: lucene/src/java/org/apache/lucene/queryParser/ParseException.java
===================================================================
--- lucene/src/java/org/apache/lucene/queryParser/ParseException.java	(revision 1002153)
+++ lucene/src/java/org/apache/lucene/queryParser/ParseException.java	(working copy)
@@ -195,4 +195,4 @@
    }
 
 }
-/* JavaCC - OriginalChecksum=c63b396885c4ff44d7aa48d3feae60cd (do not edit this line) */
+/* JavaCC - OriginalChecksum=c7631a240f7446940695eac31d9483ca (do not edit this line) */
Index: lucene/src/java/org/apache/lucene/search/FuzzyQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/FuzzyQuery.java	(revision 1002153)
+++ lucene/src/java/org/apache/lucene/search/FuzzyQuery.java	(working copy)
@@ -21,16 +21,13 @@
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.ToStringUtils;
+import org.apache.lucene.util.automaton.LevenshteinAutomata;
 
 import java.io.IOException;
 
 /** Implements the fuzzy search query. The similarity measurement
  * is based on the Levenshtein (edit distance) algorithm.
  * 
- * <p><em>Warning:</em> this query is not very scalable with its default prefix
- * length of 0 - in this case, *every* term will be enumerated and
- * cause an edit score calculation.
- * 
  * <p>This query uses {@link MultiTermQuery.TopTermsScoringBooleanQueryRewrite}
  * as default. So terms will be collected and scored according to their
  * edit distance. Only the top terms are used for building the {@link BooleanQuery}.
@@ -38,9 +35,9 @@
  */
 public class FuzzyQuery extends MultiTermQuery {
   
-  public final static float defaultMinSimilarity = 0.5f;
+  public final static float defaultMinSimilarity = LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE;
   public final static int defaultPrefixLength = 0;
-  public final static int defaultMaxExpansions = Integer.MAX_VALUE;
+  public final static int defaultMaxExpansions = 50;
   
   private float minimumSimilarity;
   private int prefixLength;
@@ -60,6 +57,12 @@
    *  <code>minimumSimilarity</code> of <code>0.5</code> a term of the same length
    *  as the query term is considered similar to the query term if the edit distance
    *  between both terms is less than <code>length(term)*0.5</code>
+   *  <p>
+   *  Alternatively, if <code>minimumSimilarity</code> is >= 1f, it is interpreted 
+   *  as a pure Levenshtein edit distance. For example, a value of <code>2f</code>
+   *  will match all terms within an edit distance of <code>2</code> from the 
+   *  query term. Edit distances specified in this way may not be fractional.
+   *  
    * @param prefixLength length of common (non-fuzzy) prefix
    * @param maxExpansions the maximum number of terms to match. If this number is
    *  greater than {@link BooleanQuery#getMaxClauseCount} when the query is rewritten, 
@@ -72,9 +75,9 @@
     super(term.field());
     this.term = term;
     
-    if (minimumSimilarity >= 1.0f)
-      throw new IllegalArgumentException("minimumSimilarity >= 1");
-    else if (minimumSimilarity < 0.0f)
+    if (minimumSimilarity >= 1.0f && minimumSimilarity != (int)minimumSimilarity)
+      throw new IllegalArgumentException("fractional edit distances are not allowed");
+    if (minimumSimilarity < 0.0f)
       throw new IllegalArgumentException("minimumSimilarity < 0");
     if (prefixLength < 0)
       throw new IllegalArgumentException("prefixLength < 0");
@@ -84,7 +87,8 @@
     setRewriteMethod(new MultiTermQuery.TopTermsScoringBooleanQueryRewrite(maxExpansions));
     
     String text = term.text();
-    if (text.codePointCount(0, text.length()) > 1.0f / (1.0f - minimumSimilarity)) {
+    int len = text.codePointCount(0, text.length());
+    if (len > 0 && (minimumSimilarity >= 1f || len > 1.0f / (1.0f - minimumSimilarity))) {
       this.termLongEnough = true;
     }
     
Index: lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.java	(revision 1002153)
+++ lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.java	(working copy)
@@ -58,7 +58,8 @@
   
   private final int termLength;
   
-  private int maxEdits;
+  int maxEdits;
+  private final boolean raw;
 
   private List<ByteRunAutomaton> runAutomata;
   
@@ -77,15 +78,15 @@
    * 
    * @param reader Delivers terms.
    * @param term Pattern term.
-   * @param minSimilarity Minimum required similarity for terms from the reader. Default value is 0.5f.
+   * @param minSimilarity Minimum required similarity for terms from the reader.
    * @param prefixLength Length of required common prefix. Default value is 0.
    * @throws IOException
    */
   public FuzzyTermsEnum(IndexReader reader, Term term, 
       final float minSimilarity, final int prefixLength) throws IOException {
-    if (minSimilarity >= 1.0f)
-      throw new IllegalArgumentException("minimumSimilarity cannot be greater than or equal to 1");
-    else if (minSimilarity < 0.0f)
+    if (minSimilarity >= 1.0f && minSimilarity != (int)minSimilarity)
+      throw new IllegalArgumentException("fractional edit distances are not allowed");
+    if (minSimilarity < 0.0f)
       throw new IllegalArgumentException("minimumSimilarity cannot be less than 0");
     if(prefixLength < 0)
       throw new IllegalArgumentException("prefixLength cannot be less than 0");
@@ -102,12 +103,19 @@
     //The prefix could be longer than the word.
     //It's kind of silly though.  It means we must match the entire word.
     this.realPrefixLength = prefixLength > termLength ? termLength : prefixLength;
-    this.minSimilarity = minSimilarity;
-    this.scale_factor = 1.0f / (1.0f - minSimilarity);
-    
-    // calculate the maximum k edits for this similarity
-    maxEdits = initialMaxDistance(minSimilarity, termLength);
-  
+    // if minSimilarity >= 1, we treat it as number of edits
+    if (minSimilarity >= 1f) {
+      this.minSimilarity = 1 - (minSimilarity+1) / this.termLength;
+      maxEdits = (int) minSimilarity;
+      raw = true;
+    } else {
+      this.minSimilarity = minSimilarity;
+      // calculate the maximum k edits for this similarity
+      maxEdits = initialMaxDistance(this.minSimilarity, termLength);
+      raw = false;
+    }
+    this.scale_factor = 1.0f / (1.0f - this.minSimilarity);
+
     TermsEnum subEnum = getAutomatonEnum(maxEdits, null);
     setEnum(subEnum != null ? subEnum : 
       new LinearFuzzyTermsEnum());
@@ -176,15 +184,11 @@
         setEnum(newEnum);
       }
     }
-    // TODO, besides changing linear -> automaton, and swapping in a smaller
-    // automaton, we can also use this information to optimize the linear case
-    // itself: re-init maxDistances so the fast-fail happens for more terms due
-    // to the now stricter constraints.
   }
 
   // for some raw min similarity and input term length, the maximum # of edits
   private int initialMaxDistance(float minimumSimilarity, int termLen) {
-    return (int) ((1-minimumSimilarity) * termLen);
+    return (int) ((1D-minimumSimilarity) * termLen);
   }
   
   // for some number of edits, the maximum possible scaled boost
@@ -442,7 +446,7 @@
         //which is 8-3 or more precisely Math.abs(3-8).
         //if our maximum edit distance is 4, then we can discard this word
         //without looking at it.
-        return 0.0f;
+        return Float.NEGATIVE_INFINITY;
       }
       
       // init matrix d
@@ -473,7 +477,7 @@
         if (j > maxDistance && bestPossibleEditDistance > maxDistance) {  //equal is okay, but not greater
           //the closest the target can be to the text is just too far away.
           //this target is leaving the party early.
-          return 0.0f;
+          return Float.NEGATIVE_INFINITY;
         }
 
         // copy current distance counts to 'previous row' distance counts: swap p and d
@@ -501,7 +505,8 @@
      * @return the maximum levenshtein distance that we care about
      */
     private int calculateMaxDistance(int m) {
-      return (int) ((1-minSimilarity) * (Math.min(text.length, m) + realPrefixLength));
+      return raw ? maxEdits : Math.min(maxEdits, 
+          (int)((1-minSimilarity) * (Math.min(text.length, m) + realPrefixLength)));
     }
   }
 }
Index: lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/analyzing/TestAnalyzingQueryParser.java
===================================================================
--- lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/analyzing/TestAnalyzingQueryParser.java	(revision 1002153)
+++ lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/analyzing/TestAnalyzingQueryParser.java	(working copy)
@@ -64,7 +64,7 @@
         "Mötley Crüe Mötley~0.75 Crüe~0.5",
         "Renée Zellweger Renée~0.9 Zellweger~" };
     fuzzyExpected = new String[] { "ubersetzung ubersetzung~0.9",
-        "motley crue motley~0.75 crue~0.5", "renee zellweger renee~0.9 zellweger~0.5" };
+        "motley crue motley~0.75 crue~0.5", "renee zellweger renee~0.9 zellweger~2.0" };
 
     a = new ASCIIAnalyzer();
   }
Index: lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java
===================================================================
--- lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java	(revision 1002153)
+++ lucene/contrib/queryparser/src/test/org/apache/lucene/queryParser/precedence/TestPrecedenceQueryParser.java	(working copy)
@@ -543,10 +543,10 @@
 
     assertQueryEquals("a:b\\\\?c", a, "a:b\\?c");
 
-    assertQueryEquals("a:b\\-c~", a, "a:b-c~0.5");
-    assertQueryEquals("a:b\\+c~", a, "a:b+c~0.5");
-    assertQueryEquals("a:b\\:c~", a, "a:b:c~0.5");
-    assertQueryEquals("a:b\\\\c~", a, "a:b\\c~0.5");
+    assertQueryEquals("a:b\\-c~", a, "a:b-c~2.0");
+    assertQueryEquals("a:b\\+c~", a, "a:b+c~2.0");
+    assertQueryEquals("a:b\\:c~", a, "a:b:c~2.0");
+    assertQueryEquals("a:b\\\\c~", a, "a:b\\c~2.0");
 
     assertQueryEquals("[ a\\- TO a\\+ ]", null, "[a- TO a+]");
     assertQueryEquals("[ a\\: TO a\\~ ]", null, "[a: TO a~]");
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/Token.java
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/Token.java	(revision 1002153)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/Token.java	(working copy)
@@ -121,4 +121,4 @@
   }
 
 }
-/* JavaCC - OriginalChecksum=cecb6022e0f2e2fca751015375f6d319 (do not edit this line) */
+/* JavaCC - OriginalChecksum=0aac6816ecd328eda2f38b9d09739ab6 (do not edit this line) */
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/TokenMgrError.java
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/TokenMgrError.java	(revision 1002153)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/TokenMgrError.java	(working copy)
@@ -138,4 +138,4 @@
       this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
    }
 }
-/* JavaCC - OriginalChecksum=0e9c5fad06efef4f41f97b851ac7b0ce (do not edit this line) */
+/* JavaCC - OriginalChecksum=a75b5b61664a73631a032a6e44f4b38a (do not edit this line) */
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java	(revision 1002153)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.java	(working copy)
@@ -433,8 +433,10 @@
           try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
           } catch (Exception ignored) { }
-         if(fms < 0.0f || fms > 1.0f){
+         if(fms < 0.0f){
            {if (true) throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));}
+         } else if (fms >= 1.0f && fms != (int) fms) {
+           {if (true) throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_EDITS));}
          }
          q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
        } else if (regexp) {
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj	(revision 1002153)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/StandardSyntaxParser.jj	(working copy)
@@ -396,8 +396,10 @@
        	  try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
        	  } catch (Exception ignored) { }
-       	 if(fms < 0.0f || fms > 1.0f){
+       	 if(fms < 0.0f){
        	   throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_LIMITS));
+       	 } else if (fms >= 1.0f && fms != (int) fms) {
+       	   throw new ParseException(new MessageImpl(QueryParserMessages.INVALID_SYNTAX_FUZZY_EDITS));
        	 }
        	 q = new FuzzyQueryNode(field, EscapeQuerySyntaxImpl.discardEscapeChar(term.image), fms, term.beginColumn, term.endColumn);
        } else if (regexp) {
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java	(revision 1002153)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/ParseException.java	(working copy)
@@ -193,4 +193,4 @@
    }
 
 }
-/* JavaCC - OriginalChecksum=d0caeac083e9874065f9d1e298b5ccd9 (do not edit this line) */
+/* JavaCC - OriginalChecksum=38bce846fe6c8482993969f741c0323e (do not edit this line) */
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/JavaCharStream.java
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/JavaCharStream.java	(revision 1002153)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/standard/parser/JavaCharStream.java	(working copy)
@@ -613,4 +613,4 @@
   }
 
 }
-/* JavaCC - OriginalChecksum=31519f95b41182c6740c2afd8dfbf344 (do not edit this line) */
+/* JavaCC - OriginalChecksum=f19c73b8f7faf94cc4a581e7b2933cc6 (do not edit this line) */
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/QueryParserMessages.java
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/QueryParserMessages.java	(revision 1002153)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/core/messages/QueryParserMessages.java	(working copy)
@@ -40,6 +40,7 @@
   public static String INVALID_SYNTAX;
   public static String INVALID_SYNTAX_CANNOT_PARSE;
   public static String INVALID_SYNTAX_FUZZY_LIMITS;
+  public static String INVALID_SYNTAX_FUZZY_EDITS;
   public static String INVALID_SYNTAX_ESCAPE_UNICODE_TRUNCATION;
   public static String INVALID_SYNTAX_ESCAPE_CHARACTER;
   public static String INVALID_SYNTAX_ESCAPE_NONE_HEX_UNICODE;
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.java
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.java	(revision 1002153)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.java	(working copy)
@@ -927,8 +927,10 @@
           try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
           } catch (Exception ignored) { }
-         if(fms < 0.0f || fms > 1.0f){
+         if(fms < 0.0f){
            {if (true) throw new ParseException("Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !");}
+         } else if (fms >= 1.0f && fms != (int) fms) {
+           {if (true) throw new ParseException("Fractional edit distances are not allowed!");}
          }
          q = getFuzzyQuery(field, termImage, fms);
        } else {
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/Token.java
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/Token.java	(revision 1002153)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/Token.java	(working copy)
@@ -121,4 +121,4 @@
   }
 
 }
-/* JavaCC - OriginalChecksum=bc9495ddfa3189061fb4f1bf3c4f64e2 (do not edit this line) */
+/* JavaCC - OriginalChecksum=0dc5808f2ab8aac8775ea9175fa2cb51 (do not edit this line) */
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/TokenMgrError.java
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/TokenMgrError.java	(revision 1002153)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/TokenMgrError.java	(working copy)
@@ -138,4 +138,4 @@
       this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);
    }
 }
-/* JavaCC - OriginalChecksum=e01667f2eb6d0b2f1fbb6958df0ca751 (do not edit this line) */
+/* JavaCC - OriginalChecksum=257b82f2650841e86289a309cb3dae76 (do not edit this line) */
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.jj
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.jj	(revision 1002153)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/PrecedenceQueryParser.jj	(working copy)
@@ -905,8 +905,10 @@
        	  try {
             fms = Float.valueOf(fuzzySlop.image.substring(1)).floatValue();
        	  } catch (Exception ignored) { }
-       	 if(fms < 0.0f || fms > 1.0f){
+       	 if(fms < 0.0f){
        	   throw new ParseException("Minimum similarity for a FuzzyQuery has to be between 0.0f and 1.0f !");
+       	 } else if (fms >= 1.0f && fms != (int) fms) {
+       	   throw new ParseException("Fractional edit distances are not allowed!");
        	 }
          q = getFuzzyQuery(field, termImage, fms);
        } else {
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/CharStream.java
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/CharStream.java	(revision 1002153)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/CharStream.java	(working copy)
@@ -109,4 +109,4 @@
   void Done();
 
 }
-/* JavaCC - OriginalChecksum=7bcd45d10a032f1c9da64691d073cf75 (do not edit this line) */
+/* JavaCC - OriginalChecksum=8cc617b193267dc876ef9699367c8186 (do not edit this line) */
Index: lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/ParseException.java
===================================================================
--- lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/ParseException.java	(revision 1002153)
+++ lucene/contrib/queryparser/src/java/org/apache/lucene/queryParser/precedence/ParseException.java	(working copy)
@@ -195,4 +195,4 @@
    }
 
 }
-/* JavaCC - OriginalChecksum=4440e368eeef562faffeca98a200334b (do not edit this line) */
+/* JavaCC - OriginalChecksum=15fbbe38a36c8ac9e2740d030624c321 (do not edit this line) */
Index: lucene/contrib/queryparser/src/resources/org/apache/lucene/queryParser/core/messages/QueryParserMessages.properties
===================================================================
--- lucene/contrib/queryparser/src/resources/org/apache/lucene/queryParser/core/messages/QueryParserMessages.properties	(revision 1002153)
+++ lucene/contrib/queryparser/src/resources/org/apache/lucene/queryParser/core/messages/QueryParserMessages.properties	(working copy)
@@ -13,6 +13,9 @@
 INVALID_SYNTAX_FUZZY_LIMITS = The similarity value for a fuzzy search must be between 0.0 and 1.0.
 
 #<CREATEDBY>Apache Lucene Community</CREATEDBY>
+INVALID_SYNTAX_FUZZY_EDITS = Fractional edit distances are not allowed.
+
+#<CREATEDBY>Apache Lucene Community</CREATEDBY>
 INVALID_SYNTAX_ESCAPE_UNICODE_TRUNCATION = Truncated unicode escape sequence.
 
 #<CREATEDBY>Apache Lucene Community</CREATEDBY>
Index: lucene/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java
===================================================================
--- lucene/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java	(revision 1002153)
+++ lucene/contrib/highlighter/src/test/org/apache/lucene/search/highlight/HighlighterTest.java	(working copy)
@@ -614,7 +614,7 @@
       @Override
       public void run() throws Exception {
         numHighlights = 0;
-        doSearching("Kinnedy~");
+        doSearching("Kinnedy~0.5");
         doStandardHighlights(analyzer, searcher, hits, query, HighlighterTest.this, true);
         assertTrue("Failed to find correct number of highlights " + numHighlights + " found",
             numHighlights == 5);
