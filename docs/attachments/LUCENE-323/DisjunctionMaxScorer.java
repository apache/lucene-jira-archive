package org.apache.lucene.search;

/**
 * Copyright 2004 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;

/**
 * The Scorer for DisjunctionMaxQuery's.  The union of all documents generated by the the subquery scorers
 * is generated in document number order.  The score for each document is the maximum of the scores computed
 * by the subquery scorers that generate that document, plus tieBreakerMultiplier times the sum of the scores
 * for the other subqueries that generate the document.
 * @author Chuck Williams
 */
class DisjunctionMaxScorer extends Scorer {

    /* The scorers for subqueries that have remaining docs, kept sorted by number of next doc. */
    private ArrayList subScorers = new ArrayList();

    /* Multiplier applied to non-maximum-scoring subqueries for a document as they are summed into the result. */
    private float tieBreakerMultiplier;

    private boolean more = false;          // True iff there is a next document
    private boolean firstTime = true;      // True iff next() has not yet been called

    /* Comparator to sort subScorers according to the document number of next document */
    private static class MaxDisjunctionClauseComparator implements Comparator {

        /* Scorers have all been positioned at their next document already */
        public int compare(Object o1, Object o2) {
            if (o1 instanceof Scorer && o2 instanceof Scorer) {
                Scorer s1 = (Scorer) o1;
                Scorer s2 = (Scorer) o2;

                return s1.doc() - s2.doc();
            }
            else {
                throw new ClassCastException("Objects not of the type 'Scorer'");
            }
        }

        /* Compatible equality */
        public boolean equals(Scorer s1, Scorer s2) {
            return s1.doc() == s2.doc();
        }

     }

    /* Fixed instance of the comparator to reuse */
    private static MaxDisjunctionClauseComparator subScorerComparator = new MaxDisjunctionClauseComparator();

    /** Creates a new instance of DisjunctionMaxScorer
     * @param similarity -- not used since our definition involves neither coord nor terms directly */
    public DisjunctionMaxScorer(float tieBreakerMultiplier, Similarity similarity) {
        super(similarity);
        this.tieBreakerMultiplier = tieBreakerMultiplier;
    }

    /** Add the scorer for a subquery
     * @param scorer the scorer of a subquery of our associated DisjunctionMaxQuery
     */
    public void add(Scorer scorer) throws IOException {
        if ( scorer.next() ) {       // Initialize and retain only if it produces docs
            subScorers.add(scorer);
            more = true;
        }
    }

    /* First time initialization.  Sort subScorers. */
    private void init() {
        sortSubScorers();
        firstTime = false;
    }

    /* Sort subScorers in order of document number of next document to be generated */
    private void sortSubScorers() {
        Scorer[] sorted = (Scorer[]) subScorers.toArray(new Scorer[subScorers.size()]);
        Arrays.sort(sorted, subScorerComparator);
        for (int i=0; i<sorted.length; i++) subScorers.set(i, sorted[i]);
    }

    /** Generate the next document matching our associated DisjunctionMaxQuery.
     * @return true iff there is a next document
     */
    public boolean next() throws IOException {
        if ( !more ) return false;
        if ( firstTime ) {
            init();
            return true;   // more would have been false if no subScorers had any docs
        }
        // Increment all generators that generated the last doc and incrementally re-sort.
        int lastdoc = ((Scorer) subScorers.get(0)).doc();
        do {
            if ( ((Scorer) subScorers.get(0)).next() ) {
                Scorer s = (Scorer) subScorers.get(0);
                int snextdoc = s.doc(), i=1;
                for (; i<subScorers.size() && snextdoc > ((Scorer) subScorers.get(i)).doc(); i++)
                    subScorers.set(i-1, subScorers.get(i));
                if ( i!=1 ) subScorers.set(i-1, s);
            } else {
                subScorers.remove(0);
                if ( subScorers.isEmpty() ) return (more = false);
            }
        } while ( ((Scorer) subScorers.get(0)).doc()==lastdoc );
        return true;
    }

    /** Determine the current document number.  Initially invalid, until {@link #next()} is called the first time.
     * @return the document number of the currently generated document
     */
    public int doc() {
        return ((Scorer) subScorers.get(0)).doc();
    }

    /** Determine the current document score.  Initially invalid, until {@link #next()} is called the first time.
     * @return the score of the current generated document
     */
    public float score() throws IOException {
        float max = ((Scorer) subScorers.get(0)).score(), sum = max;
        for (int i = 1, doc = ((Scorer) subScorers.get(0)).doc(); i < subScorers.size() && ((Scorer) subScorers.get(i)).doc() == doc; i++) {
            float sub = ((Scorer) subScorers.get(i)).score();
            sum += sub;
            max = Math.max(max, sub);
        }
        return max + (sum - max)*tieBreakerMultiplier;
    }

    /** Advance to the first document beyond the current whose number is greater than or equal to target.
     * @param target the minimum number of the next desired document
     * @return true iff there is a document to be generated whose number is at least target
     */
    public boolean skipTo(int target) throws IOException {
        int i=0;
        while ( i<subScorers.size() ) {
            if ( ((Scorer) subScorers.get(i)).doc() < target ) {
                if ( ((Scorer) subScorers.get(i)).skipTo(target) ) i++;
                else subScorers.remove(i);
            } else i++;
        }
        if ( i == 0 ) return false;
        sortSubScorers();
        return true;
    }

    /** Explain a score that we computed.  UNSUPPORTED -- see explanation capability in DisjunctionMaxQuery.
     * @param doc the number of a document we scored
     * @return the Explanation for our score
     */
    public Explanation explain(int doc) throws IOException {
        throw new UnsupportedOperationException();
    }

}
