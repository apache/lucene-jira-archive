Index: contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java
===================================================================
--- contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java	(revision 833867)
+++ contrib/spatial/src/test/org/apache/lucene/spatial/tier/TestCartesian.java	Fri Dec 11 14:28:42 CET 2009
@@ -40,7 +40,6 @@
 import org.apache.lucene.search.function.FieldScoreQuery.Type;
 import org.apache.lucene.spatial.geohash.GeoHashUtils;
 import org.apache.lucene.spatial.geometry.DistanceUnits;
-import org.apache.lucene.spatial.geometry.FloatLatLng;
 import org.apache.lucene.spatial.geometry.LatLng;
 import org.apache.lucene.spatial.tier.projections.CartesianTierPlotter;
 import org.apache.lucene.spatial.tier.projections.IProjector;
@@ -152,17 +151,17 @@
 
 
   public void testDistances() throws IOException, InvalidGeoException {
-    LatLng p1 = new FloatLatLng( 7.06, 171.2 );
-    LatLng p2 = new FloatLatLng( 21.6032207, -158.0 );
+    LatLng p1 = new LatLng( 7.06, 171.2 );
+    LatLng p2 = new LatLng( 21.6032207, -158.0 );
     double miles = p1.arcDistance( p2, DistanceUnits.MILES );
     System.out.println("testDistances");
     System.out.println("miles:" + miles);
-    assertEquals(2288.82495932794, miles); 
-    LatLng p3 = new FloatLatLng( 41.6032207, -73.087749);
-    LatLng p4 = new FloatLatLng( 55.0, 4.0 );
+    assertEquals(2288.8249593244245, miles);
+    LatLng p3 = new LatLng( 41.6032207, -73.087749);
+    LatLng p4 = new LatLng( 55.0, 4.0 );
     miles = p3.arcDistance( p4, DistanceUnits.MILES );
     System.out.println("miles:" + miles);
-    assertEquals(3474.331719997617, miles); 
+    assertEquals(3474.331719998743, miles); 
   }
 
   public void testAntiM() throws IOException, InvalidGeoException {
Index: contrib/spatial/src/java/org/apache/lucene/spatial/geometry/LatLng.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/geometry/LatLng.java	(revision 833867)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/geometry/LatLng.java	Fri Dec 11 14:23:32 CET 2009
@@ -17,76 +17,38 @@
 
 package org.apache.lucene.spatial.geometry;
 
-
 /**
- * Abstract base lat-lng class which can manipulate fixed point or floating
- * point based coordinates. Instances are immutable.
+ * Class representing a latitude longitude pair.
- * 
+ *
- * @see FloatLatLng
- *
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
+ * <p><font color="red"><b>NOTE:</b> This API is still in flux and might change in incompatible ways in the next release.</font>
  */
-public abstract class LatLng {
+public class LatLng {
 
-  public abstract boolean isNormalized();
+  private final static int LONGITUDE_DECIMAL_DEGREE_RANGE = 360;
+  private final static int LATITUDE_DECIMAL_DEGREE_RANGE = 180;
 
-  public abstract boolean isFixedPoint();
+  private final double lat;
+  private final double lng;
+  private boolean normalized;
 
-  public abstract LatLng normalize();
-
-  public abstract int getFixedLat();
-
-  public abstract int getFixedLng();
-
-  public abstract double getLat();
-
-  public abstract double getLng();
-
-  public abstract LatLng copy();
-
-  public abstract FixedLatLng toFixed();
-
-  public abstract FloatLatLng toFloat();
-  
   /**
-   * Convert the lat/lng into the cartesian coordinate plane such that all
-   * world coordinates are represented in the first quadrant.
-   * The x dimension corresponds to latitude and y corresponds to longitude.
-   * The translation starts with the normalized latlng and adds 180 to the latitude and 
-   * 90 to the longitude (subject to fixed point scaling).
+   * Creates a new LatLng with the given latitude and longitude
+   *
+   * @param lat Latitude part of the LatLng
+   * @param lng Longitude part of the LatLng
    */
-  public CartesianPoint toCartesian() {
-    LatLng ll=normalize();
-    
-    int lat=ll.getFixedLat();
-    int lng=ll.getFixedLng();
-    
-    return new CartesianPoint(
-        lng+180*FixedLatLng.SCALE_FACTOR_INT,
-        lat+90*FixedLatLng.SCALE_FACTOR_INT
-    );
+  public LatLng(double lat, double lng) {
+    if (lat > 90.0 || lat < -90.0) {
+      throw new IllegalArgumentException("Illegal latitude value " + lat);
-  }
+    }
-  
-  /**
-   * The inverse of toCartesian().  Always returns a FixedLatLng.
-   * @param pt
-   */
-  public static LatLng fromCartesian(CartesianPoint pt) {
-    int lat=pt.getY() - 90 * FixedLatLng.SCALE_FACTOR_INT;
-    int lng=pt.getX() - 180 * FixedLatLng.SCALE_FACTOR_INT;
-    
-    return new FixedLatLng(lat, lng);
+    this.lat = lat;
+    this.lng = lng;
   }
-  
+
   /**
    * Calculates the distance between two lat/lng's in miles.
-   * Imported from mq java client.
-   * 
+   *
-   * @param ll2
-   *            Second lat,lng position to calculate distance to.
-   * 
+   * @param ll2 Second lat,lng position to calculate distance to.
    * @return Returns the distance in miles.
    */
   public double arcDistance(LatLng ll2) {
@@ -94,67 +56,73 @@
   }
 
   /**
-   * Calculates the distance between two lat/lng's in miles or meters.
-   * Imported from mq java client.  Variable references changed to match.
+   * Calculates the distance between two lat/lng's in miles or kilometres
-   * 
+   *
-   * @param ll2
-   *            Second lat,lng position to calculate distance to.
-   * @param lUnits
-   *            Units to calculate distance, defaults to miles
-   * 
+   * @param targetLatLng Second lat,lng position to calculate distance to.
+   * @param distanceUnit Units to calculate distace, defaults to miles
    * @return Returns the distance in meters or miles.
    */
-  public double arcDistance(LatLng ll2, DistanceUnits lUnits) {
-    LatLng ll1 = normalize();
-    ll2 = ll2.normalize();
+  public double arcDistance(LatLng targetLatLng, DistanceUnits distanceUnit) {
+    LatLng srcLatLng = normalize();
+    targetLatLng = targetLatLng.normalize();
 
-    double lat1 = ll1.getLat(), lng1 = ll1.getLng();
-    double lat2 = ll2.getLat(), lng2 = ll2.getLng();
+    double srcLat = Math.toRadians(srcLatLng.getLat());
+    double srcLng = Math.toRadians(srcLatLng.getLng());
+    double targetLat = Math.toRadians(targetLatLng.getLat());
+    double targetLng = Math.toRadians(targetLatLng.getLng());
 
-    // Check for same position
-    if (lat1 == lat2 && lng1 == lng2)
-      return 0.0;
+    // TODO - Change to SpatialConstants
+    double radius = (distanceUnit == DistanceUnits.MILES) ? 3963.205/* MILERADIUSOFEARTH */
+        : 6378.160187/* KMRADIUSOFEARTH */;
 
-    // Get the m_dLongitude difference. Don't need to worry about
-    // crossing 180 since cos(x) = cos(-x)
-    double dLon = lng2 - lng1;
+    return Math.acos(Math.sin(srcLat) * Math.sin(targetLat) + Math.cos(srcLat) * Math.cos(targetLat) * Math.cos(targetLng - srcLng)) * radius;
+  }
 
-    double a = radians(90.0 - lat1);
-    double c = radians(90.0 - lat2);
-    double cosB = (Math.cos(a) * Math.cos(c))
-        + (Math.sin(a) * Math.sin(c) * Math.cos(radians(dLon)));
+  // =============================================== Helper methods ==================================================
 
-    double radius = (lUnits == DistanceUnits.MILES) ? 3963.205/* MILERADIUSOFEARTH */
-    : 6378.160187/* KMRADIUSOFEARTH */;
-
-    // Find angle subtended (with some bounds checking) in radians and
-    // multiply by earth radius to find the arc distance
-    if (cosB < -1.0)
-      return 3.14159265358979323846/* PI */* radius;
-    else if (cosB >= 1.0)
-      return 0;
-    else
-      return Math.acos(cosB) * radius;
+  /**
+   * Checks if {@code this} has already been normalized
+   *
+   * @return {@code true} if {@code this} is normalized, {@code false} otherwise
+   */
+  private boolean isNormalized() {
+    return normalized || ((lng >= -180) && (lng <= 180));
   }
 
-  private double radians(double a) {
-    return a * 0.01745329251994;
+  /**
+   * Normalizes the latitude/longitude of {@code this}, returning a new instance if any values have to change
+   *
+   * @return {@code this} if no normalization has to occur, otherwise a new instance with the normalized latitude and longitude
+   */
+  private LatLng normalize() {
+    if (isNormalized()) {
+      return this;
-  }
+    }
 
-  @Override
-  public String toString() {
-    return "[" + getLat() + "," + getLng() + "]";
+    double newLng = ((lng + LONGITUDE_DECIMAL_DEGREE_RANGE) % LONGITUDE_DECIMAL_DEGREE_RANGE) - LONGITUDE_DECIMAL_DEGREE_RANGE / 2.0;
+
+    LatLng ret = new LatLng(lat, newLng);
+    ret.normalized = true;
+    return ret;
   }
 
+  // =============================================== Getter / Setters ================================================
+
   /**
-   * Calculate the midpoint between this point an another.  Respects fixed vs floating point
-   * @param other
+   * Returns the latitude part of the LatLng
+   *
+   * @return Latitude part of the LatLng
    */
-  public abstract LatLng calculateMidpoint(LatLng other);
+  public double getLat() {
+    return this.lat;
+  }
-  
+
-  @Override
-  public abstract int hashCode();
-
-  @Override
-  public abstract boolean equals(Object obj);
+  /**
+   * Returns the longitude part of the LatLng
+   *
+   * @return Longitude part of the LatLng
+   */
+  public double getLng() {
+    return this.lng;
-}
+  }
+}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceUtils.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceUtils.java	(revision 810951)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/tier/DistanceUtils.java	Fri Dec 11 14:27:22 CET 2009
@@ -18,7 +18,6 @@
 package org.apache.lucene.spatial.tier;
 
 import org.apache.lucene.spatial.geometry.DistanceUnits;
-import org.apache.lucene.spatial.geometry.FloatLatLng;
 import org.apache.lucene.spatial.geometry.LatLng;
 import org.apache.lucene.spatial.geometry.shape.LLRect;
 import org.apache.lucene.spatial.geometry.shape.Rectangle;
@@ -51,7 +50,7 @@
    */
   public Rectangle getBoundary (double x1, double y1, double miles) {
 
-    LLRect box = LLRect.createBox( new FloatLatLng( x1, y1 ), miles, miles );
+    LLRect box = LLRect.createBox( new LatLng( x1, y1 ), miles);
     
     //System.out.println("Box: "+maxX+" | "+ maxY+" | "+ minX + " | "+ minY);
     return box.toRectangle();
@@ -60,8 +59,8 @@
   
   public double getLLMDistance (double x1, double y1, double x2, double y2) {  
 
-    LatLng p1 = new FloatLatLng( x1, y1 );
-    LatLng p2 = new FloatLatLng( x2, y2 );
+    LatLng p1 = new LatLng( x1, y1 );
+    LatLng p2 = new LatLng( x2, y2 );
     return p1.arcDistance( p2, DistanceUnits.MILES );
   }
 }
Index: contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder.java	(revision 833122)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder.java	Fri Dec 11 14:27:22 CET 2009
@@ -25,7 +25,6 @@
 import org.apache.lucene.spatial.tier.projections.IProjector;
 import org.apache.lucene.spatial.tier.projections.SinusoidalProjector;
 import org.apache.lucene.spatial.geometry.LatLng;
-import org.apache.lucene.spatial.geometry.FloatLatLng;
 import org.apache.lucene.spatial.geometry.shape.LLRect;
 
 
@@ -54,7 +53,7 @@
     if (miles < MILES_FLOOR) {
       miles = MILES_FLOOR;
     }
-    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );
+    LLRect box1 = LLRect.createBox( new LatLng( latitude, longitude ), miles);
     LatLng ll = box1.getLowerLeft();
     LatLng ur = box1.getUpperRight();
 
Index: contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/LLRect.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/LLRect.java	(revision 817456)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/geometry/shape/LLRect.java	Fri Dec 11 14:27:22 CET 2009
@@ -17,175 +17,140 @@
 
 package org.apache.lucene.spatial.geometry.shape;
 
-import org.apache.lucene.spatial.geometry.FloatLatLng;
 import org.apache.lucene.spatial.geometry.LatLng;
+import org.apache.lucene.spatial.util.SpatialConstants;
 
-
-
 /**
- * Lat-long rect.  Instances are mutable.
+ * Rectangle based on latitude and longitudes
  *
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
+ * <p><font color="red"><b>NOTE:</b> This API is still in flux and might change in incompatible ways in the next release.</font>
  */
 public class LLRect {
-  private LatLng ll, ur;
-  
+
-  public LLRect(LatLng ll, LatLng ur) {
-    this.ll=ll;
-    this.ur=ur;
-  }
+  private final LatLng lowerLeft;
+  private final LatLng upperRight;
-  
+
-  public LLRect(LLRect other) {
-    this.ll=other.ll;
-    this.ur=other.ur;
-  }
-  
   /**
-   * Return the area in units of lat-lng squared.  This is a contrived unit
-   * that only has value when comparing to something else.
+   * Creates a new LatLngRectangle with the given lowerLeft latitude/longitude and upperRight latitude/longitude
+   *
+   * @param lowerLeft Latitude & longitude of the lower left point of the Rectangle
+   * @param upperRight Latitude & longitude of the upper right point of the Rectangle
    */
-  public double area() {
-    return Math.abs((ll.getLat()-ur.getLat()) * (ll.getLng()-ur.getLng()));
+  public LLRect(LatLng lowerLeft, LatLng upperRight) {
+    this.lowerLeft = lowerLeft;
+    this.upperRight = upperRight;
   }
 
-  public LatLng getLowerLeft() {
-    return ll;
-  }
-  
-  public LatLng getUpperRight() {
-    return ur;
-  }
-  
-  @Override
-  public String toString() {
-    return "{" + ll + ", " + ur + "}";
-  }
-
-  public LatLng getMidpoint() {
-    return ll.calculateMidpoint(ur);
-  }
-
   /**
-   * Approximates a box centered at the given point with the given width and height in miles.
-   * @param center
-   * @param widthMi
-   * @param heightMi
+   * Creates a new LatLngRectangle with the given latitude/longitude as its centre, and the given width as both its width
+   * and height (creating a square box)
+   *
+   * @param centre Latitude and longitude of the centre of the box
+   * @param width Width/height of the box
+   * @return LatLngRectangle representing a box with the given centre and width
    */
-  public static LLRect createBox(LatLng center, double widthMi, double heightMi) {
-    double d = widthMi;
-    LatLng ur = boxCorners(center, d, 45.0); // assume right angles
-    LatLng ll = boxCorners(center, d, 225.0);
-
-    //System.err.println("boxCorners: ur " + ur.getLat() + ',' + ur.getLng());
-    //System.err.println("boxCorners: cnt " + center.getLat() + ',' + center.getLng());
-    //System.err.println("boxCorners: ll " + ll.getLat() + ',' + ll.getLng());
-    return new LLRect(ll, ur);
+  public static LLRect createBox(LatLng centre, double width) {
+    LatLng upperRight = boxCorner(centre, width, 45.0);
+    LatLng lowerLeft = boxCorner(centre, width, 225.0);
+    return new LLRect(lowerLeft, upperRight);
   }
-  
+
   /**
-   * Returns a rectangle shape for the bounding box
+   * Converts the LatLngRectangle into a plain ordinary {@link org.apache.lucene.spatial.geometry.shape.Rectangle}
+   *
+   * @return Rectangle representation of {@code this}
    */
   public Rectangle toRectangle() {
-    return new Rectangle(ll.getLng(), ll.getLat(), ur.getLng(), ur.getLat());
+    return new Rectangle(lowerLeft.getLng(), lowerLeft.getLng(), upperRight.getLng(), upperRight.getLat());
   }
 
-  private static LatLng boxCorners(LatLng center, double d, double brngdeg) {
-    double a = center.getLat();
-    double b = center.getLng();
-    double R = 3963.0; // radius of earth in miles
-    double brng = (Math.PI*brngdeg/180);
-    double lat1 = (Math.PI*a/180);
-    double lon1 = (Math.PI*b/180);
+  // =============================================== Helper methods ==================================================
 
-    // Haversine formula
-    double lat2 = Math.asin( Math.sin(lat1)*Math.cos(d/R) +
-                             Math.cos(lat1)*Math.sin(d/R)*Math.cos(brng) );
-    double lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(d/R)*Math.cos(lat1),
-                                    Math.cos(d/R)-Math.sin(lat1)*Math.sin(lat2));
+  /**
+   * Calculates the corner (defined by the given degrees) of a box with the given LatLng at its centre, the given widths
+   *
+   * @param centre LatLng that is the centre of the box
+   * @param width Width of the box
+   * @param degrees Degrees of the corner whose LatLng is to be calculated
+   * @return LatLng of the corner at the given degrees in the box
+   */
+  private static LatLng boxCorner(LatLng centre, double width, double degrees) {
+    double a = centre.getLat();
+    double b = centre.getLng();
+    double R = SpatialConstants.EARTH_RADIUS_MILES;
+    double brng = Math.PI * degrees / 180;
+    double lat1 = Math.PI * a / 180;
+    double lng1 = Math.PI * b / 180;
 
+    double lat2 = Math.asin(Math.sin(lat1) * Math.cos(width / R) + Math.cos(lat1) * Math.sin(width / R) * Math.cos(brng));
+    double lng2 = lng1 + Math.atan2(Math.sin(brng) * Math.sin(width / R) * Math.cos(lat1), Math.cos(width / R) - Math.sin(lat1) * Math.sin(lat2));
+
-    lat2 = (lat2*180)/Math.PI;
+    lat2 = (lat2 * 180) / Math.PI;
-    lon2 = (lon2*180)/Math.PI;
+    lng2 = (lng2 * 180) / Math.PI;
 
-    // normalize long first
-    LatLng ll = normLng(lat2,lon2);
-
-    // normalize lat - could flip poles
-    ll = normLat(ll.getLat(),ll.getLng());
-
-    return ll;
+    LatLng latLng = normLng(lat2, lng2);
+    return normLat(latLng.getLat(), latLng.getLng());
-}
+  }
 
   /**
-   * Returns a normalized Lat rectangle shape for the bounding box
-   * If you go over the poles, you need to flip the lng value too
+   * Normalises the given latitude and creates a new LatLng
+   *
+   * @param lat Latitude to normalise
+   * @param lng Longitude that will be part of the new LatLng
+   * @return LatLng created from the given lng and the normalisation of the lat
    */
   private static LatLng normLat(double lat, double lng) {
     if (lat > 90.0) {
-        lat = 90.0 - (lat - 90.0);
-        if (lng < 0) {
+      lat = 90.0 - (lat - 90.0);
+      if (lng < 0) {
-                lng = lng+180;
+        lng = lng + 180;
-        } else {
+      } else {
-                lng=lng-180;
+        lng = lng - 180;
-        }
+      }
-    }
-    else if (lat < -90.0) {
+    } else if (lat < -90.0) {
-        lat = -90.0 - (lat + 90.0);
-        if (lng < 0) {
+      lat = -90.0 - (lat + 90.0);
+      if (lng < 0) {
-                lng = lng+180;
+        lng = lng + 180;
-        } else {
+      } else {
-                lng=lng-180;
+        lng = lng - 180;
-        }
+      }
     }
-    LatLng ll=new FloatLatLng(lat, lng);
-    return ll;
+    return new LatLng(lat, lng);
   }
 
   /**
-   * Returns a normalized Lng rectangle shape for the bounding box
+   * Normalises the given longitude and creates a new LatLng
+   *
+   * @param lat Latitude that will be part of the new LatLng
+   * @param lng Longitude to normalise
+   * @return LatLng created from the given lat and the normalisation of the lng
    */
-  private static LatLng normLng(double lat,double lng) {
+  private static LatLng normLng(double lat, double lng) {
     if (lng > 180.0) {
-        lng = -1.0*(180.0 - (lng - 180.0));
+      lng = -1.0 * (180.0 - (lng - 180.0));
-    }
-    else if (lng < -180.0) {
+    } else if (lng < -180.0) {
-        lng = (lng + 180.0)+180.0;
+      lng = (lng + 180.0) + 180.0;
     }
-    LatLng ll=new FloatLatLng(lat, lng);
-    return ll;
+    return new LatLng(lat, lng);
   }
 
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = 1;
-    result = prime * result + ((ll == null) ? 0 : ll.hashCode());
-    result = prime * result + ((ur == null) ? 0 : ur.hashCode());
-    return result;
-  }
+  // =============================================== Getter / Setters ================================================
 
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (obj == null)
-      return false;
-    if (getClass() != obj.getClass())
-      return false;
-    LLRect other = (LLRect) obj;
-    if (ll == null) {
-      if (other.ll != null)
-        return false;
-    } else if (!ll.equals(other.ll))
-      return false;
-    if (ur == null) {
-      if (other.ur != null)
-        return false;
-    } else if (!ur.equals(other.ur))
-      return false;
-    return true;
+  /**
+   * Returns the lower left LatLng
+   *
+   * @return Lower left LatLng
+   */
+  public LatLng getLowerLeft() {
+    return lowerLeft;
   }
-  
+
-  
+  /**
+   * Returns the upper right corner LatLng
+   *
+   * @return Upper right corner LatLng
+   */
+  public LatLng getUpperRight() {
+    return upperRight;
-}
+  }
+}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FloatLatLng.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FloatLatLng.java	(revision 812248)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FloatLatLng.java	(revision 812248)
@@ -1,143 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry;
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class FloatLatLng extends LatLng {
-  private double lat;
-  private double lng;
-  private boolean normalized;
-  
-  public FloatLatLng(double lat, double lng) {
-    if (lat>90.0 || lat<-90.0) throw new IllegalArgumentException("Illegal latitude value " + lat);
-    this.lat=lat;
-    this.lng=lng;
-  }
-  
-  public FloatLatLng(LatLng ll) {
-    this.lat=ll.getLat();
-    this.lng=ll.getLng();
-  }
-  
-  @Override
-  public LatLng copy() {
-    return new FloatLatLng(this);
-  }
-
-  @Override
-  public int getFixedLat() {
-    return FixedLatLng.doubleToFixed(this.lat);
-  }
-
-  @Override
-  public int getFixedLng() {
-    return FixedLatLng.doubleToFixed(this.lng);
-  }
-
-  @Override
-  public double getLat() {
-    return this.lat;
-  }
-
-  @Override
-  public double getLng() {
-    return this.lng;
-  }
-
-  @Override
-  public boolean isFixedPoint() {
-    return false;
-  }
-
-  @Override
-  public FixedLatLng toFixed() {
-    return new FixedLatLng(this);
-  }
-
-  @Override
-  public FloatLatLng toFloat() {
-    return this;
-  }
-  
-  @Override
-  public boolean isNormalized() {
-    return 
-      normalized || (
-          (lng>=-180) &&
-          (lng<=180)
-          );
-  }
-
-  @Override
-  public LatLng normalize() {
-    if (isNormalized()) return this;
-    
-    double delta=0;
-    if (lng<0) delta=360;
-    if (lng>=0) delta=-360;
-    
-    double newLng=lng;
-    while (newLng<=-180 || newLng>=180) {
-      newLng+=delta;
-    }
-    
-    FloatLatLng ret=new FloatLatLng(lat, newLng);
-    ret.normalized=true;
-    return ret;
-  }
-
-  @Override
-  public LatLng calculateMidpoint(LatLng other) {
-    return new FloatLatLng(
-        (lat+other.getLat())/2.0,
-        (lng+other.getLng())/2.0);
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    long temp;
-    temp = Double.doubleToLongBits(lat);
-    int result = prime  + (int) (temp ^ (temp >>> 32));
-    temp = Double.doubleToLongBits(lng);
-    result = prime * result + (int) (temp ^ (temp >>> 32));
-    result = prime * result + (normalized ? 1231 : 1237);
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (getClass() != obj.getClass())
-      return false;
-    FloatLatLng other = (FloatLatLng) obj;
-    if (Double.doubleToLongBits(lat) != Double.doubleToLongBits(other.lat))
-      return false;
-    if (Double.doubleToLongBits(lng) != Double.doubleToLongBits(other.lng))
-      return false;
-    if (normalized != other.normalized)
-      return false;
-    return true;
-  }
-
-}
Index: contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FixedLatLng.java
===================================================================
--- contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FixedLatLng.java	(revision 812248)
+++ contrib/spatial/src/java/org/apache/lucene/spatial/geometry/FixedLatLng.java	(revision 812248)
@@ -1,160 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.lucene.spatial.geometry;
-
-/**
- * <p><font color="red"><b>NOTE:</b> This API is still in
- * flux and might change in incompatible ways in the next
- * release.</font>
- */
-public class FixedLatLng extends LatLng {
-  public static final double SCALE_FACTOR=1000000;
-  public static final int SCALE_FACTOR_INT=1000000;
-  
-  private int lat, lng;
-  private boolean normalized;
-  
-  public FixedLatLng(int lat, int lng) {
-    setLat(lat);
-    setLng(lng);
-  }
-  
-  public FixedLatLng(LatLng ll) {
-    this.lat=ll.getFixedLat();
-    this.lng=ll.getFixedLng();
-  }
-  
-  protected void setLat(int lat) {
-    if (lat>90*SCALE_FACTOR || lat<-90*SCALE_FACTOR) {
-      throw new IllegalArgumentException("Illegal lattitude");
-    }
-    this.lat=lat;
-  }
-
-  protected void setLng(int lng) {
-    this.lng=lng;
-  }
-  
-  public static double fixedToDouble(int fixed) {
-    return (fixed)/SCALE_FACTOR;
-  }
-  
-  public static int doubleToFixed(double d) {
-    return (int)(d*SCALE_FACTOR);
-  }
-  
-  @Override
-  public LatLng copy() {
-    return new FixedLatLng(this);
-  }
-
-  @Override
-  public int getFixedLat() {
-    return lat;
-  }
-
-  @Override
-  public int getFixedLng() {
-    return lng;
-  }
-
-  @Override
-  public double getLat() {
-    return fixedToDouble(lat);
-  }
-
-  @Override
-  public double getLng() {
-    return fixedToDouble(lng);
-  }
-
-  @Override
-  public boolean isFixedPoint() {
-    return true;
-  }
-
-  @Override
-  public FixedLatLng toFixed() {
-    return this;
-  }
-
-  @Override
-  public FloatLatLng toFloat() {
-    return new FloatLatLng(this);
-  }
-
-  @Override
-  public boolean isNormalized() {
-    return 
-      normalized || (
-          (lng>=-180*SCALE_FACTOR_INT) &&
-          (lng<=180*SCALE_FACTOR_INT)
-          );
-  }
-
-  @Override
-  public LatLng normalize() {
-    if (isNormalized()) return this;
-    
-    int delta=0;
-    if (lng<0) delta=360*SCALE_FACTOR_INT;
-    if (lng>=0) delta=-360*SCALE_FACTOR_INT;
-    
-    int newLng=lng;
-    while (newLng<=-180*SCALE_FACTOR_INT || newLng>=180*SCALE_FACTOR_INT) {
-      newLng+=delta;
-    }
-    
-    FixedLatLng ret=new FixedLatLng(lat, newLng);
-    ret.normalized=true;
-    return ret;
-  }
-  
-  @Override
-  public LatLng calculateMidpoint(LatLng other) {
-    return new FixedLatLng(
-        (lat+other.getFixedLat())/2,
-        (lng+other.getFixedLng())/2);
-  }
-
-  @Override
-  public int hashCode() {
-    final int prime = 31;
-    int result = prime + lat;
-    result = prime * result + lng;
-    result = prime * result + (normalized ? 1231 : 1237);
-    return result;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (this == obj)
-      return true;
-    if (getClass() != obj.getClass())
-      return false;
-    FixedLatLng other = (FixedLatLng) obj;
-    if (lat != other.lat)
-      return false;
-    if (lng != other.lng)
-      return false;
-    if (normalized != other.normalized)
-      return false;
-    return true;
-  }
-  
-}
