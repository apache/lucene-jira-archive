Index: lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java	(revision 1671162)
+++ lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java	(working copy)
@@ -27,7 +27,7 @@
  * A {@link Spans} implementation wrapping another spans instance,
  * allowing to override selected methods in a subclass.
  */
-public class FilterSpans extends Spans {
+public abstract class FilterSpans extends Spans {
  
   /** The wrapped spans instance. */
   protected final Spans in;
@@ -89,6 +89,22 @@
   
   @Override
   public TwoPhaseIterator asTwoPhaseIterator() {
-    return in.asTwoPhaseIterator();
+    TwoPhaseIterator inner = in.asTwoPhaseIterator();
+    if (inner == null) {
+      return null;
+    }
+    return new TwoPhaseIterator(inner.approximation()) {
+      @Override
+      public boolean matches() throws IOException {
+        return inner.matches() && twoPhaseCurrentDocMatches();
+      }
+    };
   }
+  
+  /**
+   * Returns true if the current document matches.
+   * <p>
+   * This is called during two-phase processing.
+   */
+  public abstract boolean twoPhaseCurrentDocMatches() throws IOException;
 }
Index: lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(revision 1671162)
+++ lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(working copy)
@@ -106,6 +106,11 @@
     }
 
     @Override
+    public boolean twoPhaseCurrentDocMatches() throws IOException {
+      return true; // we don't modify the spans, we just capture information from it.
+    }
+
+    @Override
     public String toString() {
       return "NearSpansUnordered.SpansCell(" + in.toString() + ")";
     }
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java	(revision 1671162)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java	(working copy)
@@ -190,6 +190,28 @@
         }
       }
     }
+    
+    // TODO: can/should we combine this with the logic above?
+    public boolean twoPhaseCurrentDocMatches() throws IOException {
+      startPos = in.nextStartPosition();
+      assert startPos != NO_MORE_POSITIONS;
+      for (;;) {
+        switch(acceptPosition(in)) {
+          case YES:
+            atFirstInCurrentDoc = true;
+            return true;
+          case NO:
+            startPos = in.nextStartPosition();
+            if (startPos != NO_MORE_POSITIONS) {
+              break;
+            }
+            // else fallthrough
+          case NO_MORE_IN_CURRENT_DOC:
+            startPos = -1;
+            return false;
+        }
+      }
+    }
 
     @Override
     public int startPosition() {
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java	(revision 1671162)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java	(working copy)
@@ -187,7 +187,6 @@
   }
   
   /** SpanFirstQuery([A B], N) ⊆ SpanNearQuery([A B]) */
-  @AwaitsFix(bugUrl = "https://issues.apache.org/jira/browse/LUCENE-6393")
   public void testSpanFirstNear() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
@@ -201,7 +200,6 @@
   }
   
   /** SpanFirstQuery([A B], N) ⊆ SpanFirstQuery([A B], N+1) */
-  @AwaitsFix(bugUrl = "https://issues.apache.org/jira/browse/LUCENE-6393")
   public void testSpanFirstNearIncreasing() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
@@ -215,7 +213,6 @@
   }
   
   /** SpanFirstQuery([A B], ∞) = SpanNearQuery([A B]) */
-  @AwaitsFix(bugUrl = "https://issues.apache.org/jira/browse/LUCENE-6393")
   public void testSpanFirstNearEverything() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
