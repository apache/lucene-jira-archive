Index: lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java	(revision 1671331)
+++ lucene/core/src/java/org/apache/lucene/search/spans/FilterSpans.java	(working copy)
@@ -27,7 +27,7 @@
  * A {@link Spans} implementation wrapping another spans instance,
  * allowing to override selected methods in a subclass.
  */
-public class FilterSpans extends Spans {
+public abstract class FilterSpans extends Spans {
  
   /** The wrapped spans instance. */
   protected final Spans in;
@@ -89,6 +89,22 @@
   
   @Override
   public TwoPhaseIterator asTwoPhaseIterator() {
-    return in.asTwoPhaseIterator();
+    TwoPhaseIterator inner = in.asTwoPhaseIterator();
+    if (inner == null) {
+      return null;
+    }
+    return new TwoPhaseIterator(inner.approximation()) {
+      @Override
+      public boolean matches() throws IOException {
+        return inner.matches() && twoPhaseCurrentDocMatches();
+      }
+    };
   }
+  
+  /**
+   * Returns true if the current document matches.
+   * <p>
+   * This is called during two-phase processing.
+   */
+  public abstract boolean twoPhaseCurrentDocMatches() throws IOException;
 }
Index: lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(revision 1671331)
+++ lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(working copy)
@@ -106,6 +106,11 @@
     }
 
     @Override
+    public boolean twoPhaseCurrentDocMatches() throws IOException {
+      return true; // we don't modify the spans, we just capture information from it.
+    }
+
+    @Override
     public String toString() {
       return "NearSpansUnordered.SpansCell(" + in.toString() + ")";
     }
Index: lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java	(revision 1671331)
+++ lucene/core/src/java/org/apache/lucene/search/spans/SpanPositionCheckQuery.java	(working copy)
@@ -127,45 +127,27 @@
 
     @Override
     public int nextDoc() throws IOException {
-      if (in.nextDoc() == NO_MORE_DOCS)
-        return NO_MORE_DOCS;
-
-      return toNextDocWithAllowedPosition();
+      while (true) {
+        int doc = in.nextDoc();
+        if (doc == NO_MORE_DOCS) {
+          return NO_MORE_DOCS;
+        } else if (twoPhaseCurrentDocMatches()) {
+          return doc;
+        }
+      }
     }
 
     @Override
     public int advance(int target) throws IOException {
-      if (in.advance(target) == NO_MORE_DOCS)
-        return NO_MORE_DOCS;
-
-      return toNextDocWithAllowedPosition();
-    }
-
-    @SuppressWarnings("fallthrough")
-    protected int toNextDocWithAllowedPosition() throws IOException {
-      startPos = in.nextStartPosition();
-      assert startPos != NO_MORE_POSITIONS;
-      for (;;) {
-        switch(acceptPosition(in)) {
-          case YES:
-            atFirstInCurrentDoc = true;
-            return in.docID();
-          case NO:
-            startPos = in.nextStartPosition();
-            if (startPos != NO_MORE_POSITIONS) {
-              break;
-            }
-            // else fallthrough
-          case NO_MORE_IN_CURRENT_DOC:
-            if (in.nextDoc() == NO_MORE_DOCS) {
-              startPos = -1;
-              return NO_MORE_DOCS;
-            }
-            startPos = in.nextStartPosition();
-            assert startPos != NO_MORE_POSITIONS : "no start position at doc="+in.docID();
-            break;
+      int doc = in.advance(target);
+      while (doc != NO_MORE_DOCS) {
+        if (twoPhaseCurrentDocMatches()) {
+          break;
         }
+        doc = in.nextDoc();
       }
+
+      return doc;
     }
 
     @Override
@@ -190,6 +172,30 @@
         }
       }
     }
+    
+    // return true if the current document matches
+    @SuppressWarnings("fallthrough")
+    public boolean twoPhaseCurrentDocMatches() throws IOException {
+      atFirstInCurrentDoc = false;
+      startPos = in.nextStartPosition();
+      assert startPos != NO_MORE_POSITIONS;
+      for (;;) {
+        switch(acceptPosition(in)) {
+          case YES:
+            atFirstInCurrentDoc = true;
+            return true;
+          case NO:
+            startPos = in.nextStartPosition();
+            if (startPos != NO_MORE_POSITIONS) {
+              break;
+            }
+            // else fallthrough
+          case NO_MORE_IN_CURRENT_DOC:
+            startPos = -1;
+            return false;
+        }
+      }
+    }
 
     @Override
     public int startPosition() {
Index: lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java	(revision 1671331)
+++ lucene/core/src/test/org/apache/lucene/search/spans/TestSpanSearchEquivalence.java	(working copy)
@@ -187,7 +187,6 @@
   }
   
   /** SpanFirstQuery([A B], N) ⊆ SpanNearQuery([A B]) */
-  @AwaitsFix(bugUrl = "https://issues.apache.org/jira/browse/LUCENE-6393")
   public void testSpanFirstNear() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
@@ -201,7 +200,6 @@
   }
   
   /** SpanFirstQuery([A B], N) ⊆ SpanFirstQuery([A B], N+1) */
-  @AwaitsFix(bugUrl = "https://issues.apache.org/jira/browse/LUCENE-6393")
   public void testSpanFirstNearIncreasing() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
@@ -215,7 +213,6 @@
   }
   
   /** SpanFirstQuery([A B], ∞) = SpanNearQuery([A B]) */
-  @AwaitsFix(bugUrl = "https://issues.apache.org/jira/browse/LUCENE-6393")
   public void testSpanFirstNearEverything() throws Exception {
     Term t1 = randomTerm();
     Term t2 = randomTerm();
