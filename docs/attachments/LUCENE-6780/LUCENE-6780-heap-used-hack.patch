Index: lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermsEnum.java
===================================================================
--- lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermsEnum.java	(revision 1703879)
+++ lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermsEnum.java	(working copy)
@@ -17,6 +17,7 @@
  * limitations under the License.
  */
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
@@ -35,7 +36,8 @@
  *
  *  @lucene.experimental
  */
-abstract class GeoPointTermsEnum extends FilteredTermsEnum {
+// nocommit put back to package private:
+public abstract class GeoPointTermsEnum extends FilteredTermsEnum {
   protected final double minLon;
   protected final double minLat;
   protected final double maxLon;
@@ -50,6 +52,8 @@
   // detail level should be a factor of PRECISION_STEP limiting the depth of recursion (and number of ranges)
   protected final short DETAIL_LEVEL;
 
+  public static List<Range> maxList;
+
   GeoPointTermsEnum(final TermsEnum tenum, final double minLon, final double minLat,
                     final double maxLon, final double maxLat) {
     super(tenum);
@@ -63,6 +67,13 @@
 
     computeRange(0L, (short) (((GeoUtils.BITS) << 1) - 1));
     Collections.sort(rangeBounds);
+    int count = rangeBounds.size();
+    System.out.println("TERMS: " + count);
+    if (maxList == null || count > maxList.size()) {
+      maxList = new ArrayList<>(rangeBounds);
+      System.out.println("  ****");
+      new Throwable().printStackTrace(System.out);
+    }
   }
 
   /**
Index: lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase.java
===================================================================
--- lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase.java	(revision 1704496)
+++ lucene/sandbox/src/test/org/apache/lucene/util/BaseGeoPointTestCase.java	(working copy)
@@ -39,6 +39,7 @@
 import org.apache.lucene.index.NumericDocValues;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.search.GeoPointTermsEnum;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SimpleCollector;
@@ -310,6 +311,8 @@
     double[] lons = new double[numPoints];
 
     boolean small = random().nextBoolean();
+    // nocommit
+    small = false;
 
     boolean haveRealDoc = false;
 
@@ -430,6 +433,7 @@
 
     public void test(boolean small, IndexSearcher s, NumericDocValues docIDToID, Set<Integer> deleted, Query query, double[] lats, double[] lons) throws Exception {
       int maxDoc = s.getIndexReader().maxDoc();
+      System.out.println("MAX BYTES: " + RamUsageTester.sizeOf(GeoPointTermsEnum.maxList));
       final FixedBitSet hits = new FixedBitSet(maxDoc);
       s.search(query, new SimpleCollector() {
 
@@ -465,7 +469,8 @@
         }
 
         // null means it's a borderline case which is allowed to be wrong:
-        if (expected != null && hits.get(docID) != expected) {
+        // nocommit
+        if (false && expected != null && hits.get(docID) != expected) {
           if (expected) {
             System.out.println(Thread.currentThread().getName() + ": id=" + id + " should match but did not");
           } else {
@@ -582,6 +587,7 @@
                 final GeoRect bbox = randomRect(small, true);
 
                 query = newBBoxQuery(FIELD_NAME, bbox);
+                System.out.println("bbox: " + query);
 
                 verifyHits = new VerifyHits() {
                     @Override
@@ -615,6 +621,8 @@
 
                 query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);
 
+                System.out.println("distance: " + query);
+
                 verifyHits = new VerifyHits() {
                     @Override
                     protected Boolean shouldMatch(double pointLat, double pointLon) {
