Index: lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/Passage.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/Passage.java	(date 1479075603000)
+++ lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/Passage.java	(revision )
@@ -23,7 +23,7 @@
 import org.apache.lucene.util.RamUsageEstimator;
 
 /**
- * Represents a passage (typically a sentence of the document). 
+ * Represents a passage (typically a sentence of the document).
  * <p>
  * A passage contains {@link #getNumMatches} highlights from the query,
  * and the offsets and query terms that correspond with each match.
@@ -31,131 +31,152 @@
  * @lucene.experimental
  */
 public final class Passage {
-    int startOffset = -1;
-    int endOffset = -1;
-    float score = 0.0f;
+  private int startOffset = -1;
+  private int endOffset = -1;
+  private float score = 0.0f;
 
-    int matchStarts[] = new int[8];
-    int matchEnds[] = new int[8];
-    BytesRef matchTerms[] = new BytesRef[8];
-    int numMatches = 0;
+  private int[] matchStarts = new int[8];
+  private int[] matchEnds = new int[8];
+  private BytesRef[] matchTerms = new BytesRef[8];
+  private int numMatches = 0;
 
+  /** @lucene.internal */
-    public void addMatch(int startOffset, int endOffset, BytesRef term) {
-        assert startOffset >= this.startOffset && startOffset <= this.endOffset;
-        if (numMatches == matchStarts.length) {
+  public void addMatch(int startOffset, int endOffset, BytesRef term) {
+    assert startOffset >= this.startOffset && startOffset <= this.endOffset;
+    if (numMatches == matchStarts.length) {
-            int newLength = ArrayUtil.oversize(numMatches+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);
+      int newLength = ArrayUtil.oversize(numMatches + 1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);
-            int newMatchStarts[] = new int[newLength];
-            int newMatchEnds[] = new int[newLength];
-            BytesRef newMatchTerms[] = new BytesRef[newLength];
-            System.arraycopy(matchStarts, 0, newMatchStarts, 0, numMatches);
-            System.arraycopy(matchEnds, 0, newMatchEnds, 0, numMatches);
-            System.arraycopy(matchTerms, 0, newMatchTerms, 0, numMatches);
-            matchStarts = newMatchStarts;
-            matchEnds = newMatchEnds;
-            matchTerms = newMatchTerms;
-        }
-        assert matchStarts.length == matchEnds.length && matchEnds.length == matchTerms.length;
-        matchStarts[numMatches] = startOffset;
-        matchEnds[numMatches] = endOffset;
-        matchTerms[numMatches] = term;
-        numMatches++;
-    }
+      int newMatchStarts[] = new int[newLength];
+      int newMatchEnds[] = new int[newLength];
+      BytesRef newMatchTerms[] = new BytesRef[newLength];
+      System.arraycopy(matchStarts, 0, newMatchStarts, 0, numMatches);
+      System.arraycopy(matchEnds, 0, newMatchEnds, 0, numMatches);
+      System.arraycopy(matchTerms, 0, newMatchTerms, 0, numMatches);
+      matchStarts = newMatchStarts;
+      matchEnds = newMatchEnds;
+      matchTerms = newMatchTerms;
+    }
+    assert matchStarts.length == matchEnds.length && matchEnds.length == matchTerms.length;
+    matchStarts[numMatches] = startOffset;
+    matchEnds[numMatches] = endOffset;
+    matchTerms[numMatches] = term;
+    numMatches++;
+  }
 
-    void sort() {
+  /** @lucene.internal */
+  public void sort() {
-        final int starts[] = matchStarts;
-        final int ends[] = matchEnds;
-        final BytesRef terms[] = matchTerms;
-        new InPlaceMergeSorter() {
-            @Override
-            protected void swap(int i, int j) {
-                int temp = starts[i];
-                starts[i] = starts[j];
-                starts[j] = temp;
+    final int starts[] = matchStarts;
+    final int ends[] = matchEnds;
+    final BytesRef terms[] = matchTerms;
+    new InPlaceMergeSorter() {
+      @Override
+      protected void swap(int i, int j) {
+        int temp = starts[i];
+        starts[i] = starts[j];
+        starts[j] = temp;
 
-                temp = ends[i];
-                ends[i] = ends[j];
-                ends[j] = temp;
+        temp = ends[i];
+        ends[i] = ends[j];
+        ends[j] = temp;
 
-                BytesRef tempTerm = terms[i];
-                terms[i] = terms[j];
-                terms[j] = tempTerm;
-            }
+        BytesRef tempTerm = terms[i];
+        terms[i] = terms[j];
+        terms[j] = tempTerm;
+      }
 
-            @Override
-            protected int compare(int i, int j) {
-                return Integer.compare(starts[i], starts[j]);
-            }
+      @Override
+      protected int compare(int i, int j) {
+        return Integer.compare(starts[i], starts[j]);
+      }
 
-        }.sort(0, numMatches);
-    }
+    }.sort(0, numMatches);
+  }
 
-    void reset() {
+  /** @lucene.internal */
+  public void reset() {
-        startOffset = endOffset = -1;
-        score = 0.0f;
-        numMatches = 0;
-    }
+    startOffset = endOffset = -1;
+    score = 0.0f;
+    numMatches = 0;
+  }
 
-    /**
-     * Start offset of this passage.
+  /**
+   * Start offset of this passage.
+   *
-     * @return start index (inclusive) of the passage in the
+   * @return start index (inclusive) of the passage in the
-     *         original content: always &gt;= 0.
+   * original content: always &gt;= 0.
-     */
-    public int getStartOffset() {
-        return startOffset;
-    }
+   */
+  public int getStartOffset() {
+    return startOffset;
+  }
 
-    /**
-     * End offset of this passage.
+  /**
+   * End offset of this passage.
+   *
-     * @return end index (exclusive) of the passage in the
+   * @return end index (exclusive) of the passage in the
-     *         original content: always &gt;= {@link #getStartOffset()}
+   * original content: always &gt;= {@link #getStartOffset()}
-     */
-    public int getEndOffset() {
-        return endOffset;
-    }
+   */
+  public int getEndOffset() {
+    return endOffset;
+  }
 
-    /**
-     * Passage's score.
-     */
-    public float getScore() {
-        return score;
-    }
+  /**
+   * Passage's score.
+   */
+  public float getScore() {
+    return score;
+  }
 
-    /**
-     * Number of term matches available in
-     * {@link #getMatchStarts}, {@link #getMatchEnds},
-     * {@link #getMatchTerms}
-     */
-    public int getNumMatches() {
-        return numMatches;
-    }
+  /**
+   * Number of term matches available in
+   * {@link #getMatchStarts}, {@link #getMatchEnds},
+   * {@link #getMatchTerms}
+   */
+  public int getNumMatches() {
+    return numMatches;
+  }
 
-    /**
-     * Start offsets of the term matches, in increasing order.
-     * <p>
-     * Only {@link #getNumMatches} are valid. Note that these
-     * offsets are absolute (not relative to {@link #getStartOffset()}).
-     */
-    public int[] getMatchStarts() {
-        return matchStarts;
-    }
+  /**
+   * Start offsets of the term matches, in increasing order.
+   * <p>
+   * Only {@link #getNumMatches} are valid. Note that these
+   * offsets are absolute (not relative to {@link #getStartOffset()}).
+   */
+  public int[] getMatchStarts() {
+    return matchStarts;
+  }
 
-    /**
-     * End offsets of the term matches, corresponding with {@link #getMatchStarts}.
-     * <p>
-     * Only {@link #getNumMatches} are valid. Note that its possible that an end offset
-     * could exceed beyond the bounds of the passage ({@link #getEndOffset()}), if the
-     * Analyzer produced a term which spans a passage boundary.
-     */
-    public int[] getMatchEnds() {
-        return matchEnds;
-    }
+  /**
+   * End offsets of the term matches, corresponding with {@link #getMatchStarts}.
+   * <p>
+   * Only {@link #getNumMatches} are valid. Note that its possible that an end offset
+   * could exceed beyond the bounds of the passage ({@link #getEndOffset()}), if the
+   * Analyzer produced a term which spans a passage boundary.
+   */
+  public int[] getMatchEnds() {
+    return matchEnds;
+  }
 
-    /**
-     * BytesRef (term text) of the matches, corresponding with {@link #getMatchStarts()}.
-     * <p>
-     * Only {@link #getNumMatches()} are valid.
-     */
-    public BytesRef[] getMatchTerms() {
-        return matchTerms;
-    }
+  /**
+   * BytesRef (term text) of the matches, corresponding with {@link #getMatchStarts()}.
+   * <p>
+   * Only {@link #getNumMatches()} are valid.
+   */
+  public BytesRef[] getMatchTerms() {
+    return matchTerms;
+  }
+
+  /** @lucene.internal */
+  public void setStartOffset(int startOffset) {
+    this.startOffset = startOffset;
+  }
+
+  /** @lucene.internal */
+  public void setEndOffset(int endOffset) {
+    this.endOffset = endOffset;
+  }
+
+  /** @lucene.internal */
+  public void setScore(float score) {
+    this.score = score;
+  }
+
 }
Index: lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/DefaultPassageFormatter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/DefaultPassageFormatter.java	(date 1479075603000)
+++ lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/DefaultPassageFormatter.java	(revision )
@@ -63,13 +63,13 @@
         int pos = 0;
         for (Passage passage : passages) {
             // don't add ellipsis if its the first one, or if its connected.
-            if (passage.startOffset > pos && pos > 0) {
+            if (passage.getStartOffset() > pos && pos > 0) {
                 sb.append(ellipsis);
             }
-            pos = passage.startOffset;
-            for (int i = 0; i < passage.numMatches; i++) {
-                int start = passage.matchStarts[i];
-                int end = passage.matchEnds[i];
+            pos = passage.getStartOffset();
+            for (int i = 0; i < passage.getNumMatches(); i++) {
+                int start = passage.getMatchStarts()[i];
+                int end = passage.getMatchEnds()[i];
                 // its possible to have overlapping terms
                 if (start > pos) {
                     append(sb, content, pos, start);
@@ -82,8 +82,8 @@
                 }
             }
             // its possible a "term" from the analyzer could span a sentence boundary.
-            append(sb, content, pos, Math.max(pos, passage.endOffset));
-            pos = passage.endOffset;
+            append(sb, content, pos, Math.max(pos, passage.getEndOffset()));
+            pos = passage.getEndOffset();
         }
         return sb.toString();
     }
Index: lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/FieldHighlighter.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/FieldHighlighter.java	(date 1479075603000)
+++ lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/FieldHighlighter.java	(revision )
@@ -117,9 +117,9 @@
         break;
       }
       Passage passage = new Passage();
-      passage.score = Float.NaN;
-      passage.startOffset = pos;
-      passage.endOffset = next;
+      passage.setScore(Float.NaN);
+      passage.setStartOffset(pos);
+      passage.setEndOffset(next);
       passages.add(passage);
       pos = next;
     }
@@ -145,12 +145,12 @@
     offsetsEnumQueue.add(new OffsetsEnum(null, EMPTY)); // a sentinel for termination
 
     PriorityQueue<Passage> passageQueue = new PriorityQueue<>(Math.min(64, maxPassages + 1), (left, right) -> {
-      if (left.score < right.score) {
+      if (left.getScore() < right.getScore()) {
         return -1;
-      } else if (left.score > right.score) {
+      } else if (left.getScore() > right.getScore()) {
         return 1;
       } else {
-        return left.startOffset - right.startOffset;
+        return left.getStartOffset() - right.getStartOffset();
       }
     });
     Passage passage = new Passage(); // the current passage in-progress.  Will either get reset or added to queue.
@@ -170,12 +170,12 @@
         continue;
       }
       // See if this term should be part of a new passage.
-      if (start >= passage.endOffset) {
-        if (passage.startOffset >= 0) { // true if this passage has terms; otherwise couldn't find any (yet)
+      if (start >= passage.getEndOffset()) {
+        if (passage.getStartOffset() >= 0) { // true if this passage has terms; otherwise couldn't find any (yet)
           // finalize passage
-          passage.score *= scorer.norm(passage.startOffset);
+          passage.setScore(passage.getScore() * scorer.norm(passage.getStartOffset()));
           // new sentence: first add 'passage' to queue
-          if (passageQueue.size() == maxPassages && passage.score < passageQueue.peek().score) {
+          if (passageQueue.size() == maxPassages && passage.getScore() < passageQueue.peek().getScore()) {
             passage.reset(); // can't compete, just reset it
           } else {
             passageQueue.offer(passage);
@@ -192,8 +192,8 @@
           break;
         }
         // advance breakIterator
-        passage.startOffset = Math.max(breakIterator.preceding(start + 1), 0);
-        passage.endOffset = Math.min(breakIterator.following(start), contentLength);
+        passage.setStartOffset(Math.max(breakIterator.preceding(start + 1), 0));
+        passage.setEndOffset(Math.min(breakIterator.following(start), contentLength));
       }
       // Add this term to the passage.
       int tf = 0;
@@ -209,12 +209,12 @@
         off.nextPosition();
         start = off.startOffset();
         end = off.endOffset();
-        if (start >= passage.endOffset || end > contentLength) { // it's beyond this passage
+        if (start >= passage.getEndOffset() || end > contentLength) { // it's beyond this passage
           offsetsEnumQueue.offer(off);
           break;
         }
       }
-      passage.score += off.weight * scorer.tf(tf, passage.endOffset - passage.startOffset);
+      passage.setScore(passage.getScore() + off.weight * scorer.tf(tf, passage.getEndOffset() - passage.getStartOffset()));
     }
 
     Passage[] passages = passageQueue.toArray(new Passage[passageQueue.size()]);
@@ -222,7 +222,7 @@
       p.sort();
     }
     // sort in ascending order
-    Arrays.sort(passages, (left, right) -> left.startOffset - right.startOffset);
+    Arrays.sort(passages, (left, right) -> left.getStartOffset() - right.getStartOffset());
     return passages;
   }
 
Index: lucene/highlighter/src/test/org/apache/lucene/search/uhighlight/TestUnifiedHighlighterMTQ.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/highlighter/src/test/org/apache/lucene/search/uhighlight/TestUnifiedHighlighterMTQ.java	(date 1479075603000)
+++ lucene/highlighter/src/test/org/apache/lucene/search/uhighlight/TestUnifiedHighlighterMTQ.java	(revision )
@@ -697,13 +697,13 @@
             int pos = 0;
             for (Passage passage : passages) {
               // don't add ellipsis if its the first one, or if its connected.
-              if (passage.startOffset > pos && pos > 0) {
+              if (passage.getStartOffset() > pos && pos > 0) {
                 sb.append("... ");
               }
-              pos = passage.startOffset;
-              for (int i = 0; i < passage.numMatches; i++) {
-                int start = passage.matchStarts[i];
-                int end = passage.matchEnds[i];
+              pos = passage.getStartOffset();
+              for (int i = 0; i < passage.getNumMatches(); i++) {
+                int start = passage.getMatchStarts()[i];
+                int end = passage.getMatchEnds()[i];
                 // its possible to have overlapping terms
                 if (start > pos) {
                   sb.append(content, pos, start);
@@ -719,8 +719,8 @@
                 }
               }
               // its possible a "term" from the analyzer could span a sentence boundary.
-              sb.append(content, pos, Math.max(pos, passage.endOffset));
-              pos = passage.endOffset;
+              sb.append(content, pos, Math.max(pos, passage.getEndOffset()));
+              pos = passage.getEndOffset();
             }
             return sb.toString();
           }
