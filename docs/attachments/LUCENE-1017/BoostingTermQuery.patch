===================================================================
--- D:/lucene-2.2.0/src/java/org/apache/lucene/search/payloads/BoostingTermQuery.java	(revision 581681)
+++ D:/lucene-2.2.0/src/java/org/apache/lucene/search/payloads/BoostingTermQuery.java	(working copy)
@@ -2,13 +2,11 @@
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermDocs;
 import org.apache.lucene.index.TermPositions;
 import org.apache.lucene.search.*;
-import org.apache.lucene.search.spans.SpanScorer;
-import org.apache.lucene.search.spans.SpanTermQuery;
-import org.apache.lucene.search.spans.SpanWeight;
-import org.apache.lucene.search.spans.TermSpans;
 
+
 import java.io.IOException;
 
 /**
@@ -28,7 +26,7 @@
  */
 
 /**
- * The BoostingTermQuery is very similar to the {@link org.apache.lucene.search.spans.SpanTermQuery} except
+ * The BoostingTermQuery is very similar to the {@link org.apache.lucene.search.TermQuery} except
  * that it factors in the value of the payload located at each of the positions where the
  * {@link org.apache.lucene.index.Term} occurs.
  * <p>
@@ -44,145 +42,136 @@
  *
  * @see org.apache.lucene.search.Similarity#scorePayload(byte[], int, int)
  */
-public class BoostingTermQuery extends SpanTermQuery{
+public class BoostingTermQuery extends TermQuery{
+	Term term;
+	Similarity similarity;
 
+	public BoostingTermQuery(Term term) {
+		super(term);
+		this.term = term;
 
-  public BoostingTermQuery(Term term) {
-    super(term);
-  }
+	}
 
+	protected Weight createWeight(Searcher searcher) throws IOException {
+		this.similarity = getSimilarity(searcher);	  
+		return new BoostingTermWeight(this, searcher);
+	}
 
-  protected Weight createWeight(Searcher searcher) throws IOException {
-    return new BoostingTermWeight(this, searcher);
-  }
+	protected class BoostingTermWeight extends TermWeight implements Weight {
+		public BoostingTermWeight(BoostingTermQuery query, Searcher searcher) throws IOException {
+			super(searcher);
+		}
 
-  protected class BoostingTermWeight extends SpanWeight implements Weight {
+		public Scorer scorer(IndexReader reader) throws IOException {
+			return new BoostingTermScorer(reader.termDocs(term), reader.termPositions(term), this, similarity,
+					reader.norms(term.field()));
+		}
+		class BoostingTermScorer extends TermScorer {
 
+			//TODO: is this the best way to allocate this?
+			byte[] payload = new byte[256];
+			private TermPositions positions;
+			protected float payloadScore;
+			private int payloadsSeen;
+			boolean more;
+			protected boolean firstTime = true;
+			protected int doc;
+			protected int freq;
+			protected int position;     
+			public BoostingTermScorer(TermDocs termDocs, TermPositions termPositions, Weight weight,
+					Similarity similarity, byte[] norms) throws IOException {
+				super(weight, termDocs, similarity, norms);
+				positions = termPositions;
 
-    public BoostingTermWeight(BoostingTermQuery query, Searcher searcher) throws IOException {
-      super(query, searcher);
-    }
+			}
 
+			/**
+			 * Go to the next document
+			 * 
+			 */
+			 public boolean next() throws IOException {
+				 if (super.next()) {
+					 return getPayloads();
+				 } else {
+					 return false;
+				 }
+			 }
 
+			 public boolean skipTo(int target) throws IOException {
+				 if (super.skipTo(target)) {
+					 return getPayloads();
+				 } else {
+					 return false;
+				 }
+			 }
+			 protected boolean getPayloads() throws IOException {
+				 doc = super.doc();
+				 payloadScore = 0;
+				 payloadsSeen = 0;
+				 Similarity similarity1 = getSimilarity();
+				 // set term positions to current doc
+				 positions.skipTo(doc);
+				 freq = positions.freq();
+				 for (int i=0;i<freq;i++) {
+					 position = positions.nextPosition();
+					 processPayload(similarity1);
+				 }
+				 return true;        	
+			 }
 
+			 protected void processPayload(Similarity similarity) throws IOException {
+				 if (positions.isPayloadAvailable()) {
+					 payload = positions.getPayload(payload, 0);
+					 payloadScore += similarity.scorePayload(payload, 0, positions.getPayloadLength());
+					 payloadsSeen++;
+				 } else {
+					 //zero out the payload?
+				 }
 
-    public Scorer scorer(IndexReader reader) throws IOException {
-      return new BoostingSpanScorer((TermSpans)query.getSpans(reader), this, similarity,
-              reader.norms(query.getField()));
-    }
+			 }
 
-    class BoostingSpanScorer extends SpanScorer {
+			 public float score() {
+				 return super.score() * (payloadsSeen > 0 ? (payloadScore / payloadsSeen) : 1);
+			 }
 
-      //TODO: is this the best way to allocate this?
-      byte[] payload = new byte[256];
-      private TermPositions positions;
-      protected float payloadScore;
-      private int payloadsSeen;
+			 public void score(HitCollector hc) throws IOException {
+				 while (next()) {
+					 hc.collect(doc, score());
+				 }
+			 }
 
-      public BoostingSpanScorer(TermSpans spans, Weight weight,
-                                Similarity similarity, byte[] norms) throws IOException {
-        super(spans, weight, similarity, norms);
-        positions = spans.getPositions();
+			 public Explanation explain(final int doc) throws IOException {
+				 Explanation result = new Explanation();
+				 Explanation nonPayloadExpl = super.explain(doc);
+				 result.addDetail(nonPayloadExpl);
+				 //QUESTION: Is there a wau to avoid this skipTo call?  We need to know whether to load the payload or not
 
-      }
-
-      /**
-       * Go to the next document
-       * 
-       */
-      /*public boolean next() throws IOException {
-
-        boolean result = super.next();
-        //set the payload.  super.next() properly increments the term positions
-        if (result) {
-          //Load the payloads for all 
-          processPayload();
-        }
-
-        return result;
-      }
-
-      public boolean skipTo(int target) throws IOException {
-        boolean result = super.skipTo(target);
-
-        if (result) {
-          processPayload();
-        }
-
-        return result;
-      }*/
-
-      protected boolean setFreqCurrentDoc() throws IOException {
-        if (!more) {
-          return false;
-        }
-        doc = spans.doc();
-        freq = 0.0f;
-        payloadScore = 0;
-        payloadsSeen = 0;
-        Similarity similarity1 = getSimilarity();
-        while (more && doc == spans.doc()) {
-          int matchLength = spans.end() - spans.start();
-
-          freq += similarity1.sloppyFreq(matchLength);
-          processPayload(similarity1);
-
-          more = spans.next();//this moves positions to the next match in this document
-        }
-        return more || (freq != 0);
-      }
-
-
-      protected void processPayload(Similarity similarity) throws IOException {
-        if (positions.isPayloadAvailable()) {
-          payload = positions.getPayload(payload, 0);
-          payloadScore += similarity.scorePayload(payload, 0, positions.getPayloadLength());
-          payloadsSeen++;
-
-        } else {
-          //zero out the payload?
-        }
-
-      }
-
-      public float score() throws IOException {
-
-        return super.score() * (payloadsSeen > 0 ? (payloadScore / payloadsSeen) : 1);
-      }
-
-
-      public Explanation explain(final int doc) throws IOException {
-        Explanation result = new Explanation();
-        Explanation nonPayloadExpl = super.explain(doc);
-        result.addDetail(nonPayloadExpl);
-        //QUESTION: Is there a wau to avoid this skipTo call?  We need to know whether to load the payload or not
-        
-        Explanation payloadBoost = new Explanation();
-        result.addDetail(payloadBoost);
-/*
+				 Explanation payloadBoost = new Explanation();
+				 result.addDetail(payloadBoost);
+				 /*
         if (skipTo(doc) == true) {
           processPayload();
         }
-*/
+				  */
 
-        float avgPayloadScore =  (payloadsSeen > 0 ? (payloadScore / payloadsSeen) : 1); 
-        payloadBoost.setValue(avgPayloadScore);
-        //GSI: I suppose we could toString the payload, but I don't think that would be a good idea 
-        payloadBoost.setDescription("scorePayload(...)");
-        result.setValue(nonPayloadExpl.getValue() * avgPayloadScore);
-        result.setDescription("btq, product of:");
-        return result;
-      }
-    }
+				 float avgPayloadScore =  (payloadsSeen > 0 ? (payloadScore / payloadsSeen) : 1); 
+				 payloadBoost.setValue(avgPayloadScore);
+				 //GSI: I suppose we could toString the payload, but I don't think that would be a good idea 
+				 payloadBoost.setDescription("scorePayload(...)");
+				 result.setValue(nonPayloadExpl.getValue() * avgPayloadScore);
+				 result.setDescription("btq, product of:");
+				 return result;
+			 }
+		}
 
-  }
+	}
 
 
-  public boolean equals(Object o) {
-    if (!(o instanceof BoostingTermQuery))
-      return false;
-    BoostingTermQuery other = (BoostingTermQuery) o;
-    return (this.getBoost() == other.getBoost())
-            && this.term.equals(other.term);
-  }
+	public boolean equals(Object o) {
+		if (!(o instanceof BoostingTermQuery))
+			return false;
+		BoostingTermQuery other = (BoostingTermQuery) o;
+		return (this.getBoost() == other.getBoost())
+		&& this.term.equals(other.term);
+	}
 }
