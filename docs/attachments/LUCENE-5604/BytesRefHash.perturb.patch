Index: core/src/java/org/apache/lucene/util/BytesRefHash.java
===================================================================
--- core/src/java/org/apache/lucene/util/BytesRefHash.java	(revision 1586900)
+++ core/src/java/org/apache/lucene/util/BytesRefHash.java	(working copy)
@@ -274,6 +274,7 @@
     return add(bytes, bytes.hashCode());
   }
 
+  // nocommit fix hashcode javadocs:
   /**
    * Adds a new {@link BytesRef} with a pre-calculated hash code.
    * 
@@ -382,24 +383,31 @@
   public int find(BytesRef bytes, int code) {
     return ids[findHash(bytes, code)];
   }
+
+  // nocommit point to python's explanation:
+  private static final int PERTURB_SHIFT = 5;
+
+  public static int totConflict;
   
   private int findHash(BytesRef bytes, int code) {
     assert bytesStart != null : "bytesStart is null - not initialized";
     // final position
-    int hashPos = code & hashMask;
-    int e = ids[hashPos];
+    int i = code & hashMask;
+    int e = ids[i];
     if (e != -1 && !equals(e, bytes)) {
       // Conflict: keep searching different locations in
       // the hash table.
-      final int inc = ((code >> 8) + code) | 1;
-      do {
-        code += inc;
-        hashPos = code & hashMask;
-        e = ids[hashPos];
-      } while (e != -1 && !equals(e, bytes));
+      for (int perturb = code & 0x7ffffff; ; perturb >>= PERTURB_SHIFT) {
+        totConflict++;
+        i = (i << 2) + i + perturb + 1;
+        e = ids[i & hashMask];
+        if (e == -1 || equals(e, bytes)) {
+          return i & hashMask;
+        }
+      }
+    } else {
+      return i;
     }
-    
-    return hashPos;
   }
 
   /** Adds a "arbitrary" int offset instead of a BytesRef
@@ -417,12 +425,15 @@
     if (e != -1 && bytesStart[e] != offset) {
       // Conflict: keep searching different locations in
       // the hash table.
-      final int inc = ((code >> 8) + code) | 1;
-      do {
-        code += inc;
-        hashPos = code & hashMask;
+      int i = hashPos;
+      for (int perturb = code & 0x7ffffff; ; perturb >>= PERTURB_SHIFT) {
+        i = (i << 2) + i + perturb + 1;
+        hashPos = i & hashMask;
         e = ids[hashPos];
-      } while (e != -1 && bytesStart[e] != offset);
+        if (e == -1 || bytesStart[e] == offset) {
+          break;
+        }
+      }
     }
     if (e == -1) {
       // new entry
@@ -458,6 +469,7 @@
       if (e0 != -1) {
         int code;
         if (hashOnData) {
+
           final int off = bytesStart[e0];
           final int start = off & BYTE_BLOCK_MASK;
           final byte[] bytes = pool.buffers[off >> BYTE_BLOCK_SHIFT];
@@ -472,11 +484,13 @@
             len = (bytes[start] & 0x7f) + ((bytes[start + 1] & 0xff) << 7);
             pos = start + 2;
           }
-
+          /*
           final int endPos = pos + len;
           while (pos < endPos) {
             code = 31 * code + bytes[pos++];
           }
+          */
+          code = StringHelper.murmurhash3_x86_32(bytes, pos, len, 0);
         } else {
           code = bytesStart[e0];
         }
@@ -484,11 +498,14 @@
         int hashPos = code & newMask;
         assert hashPos >= 0;
         if (newHash[hashPos] != -1) {
-          final int inc = ((code >> 8) + code) | 1;
-          do {
-            code += inc;
-            hashPos = code & newMask;
-          } while (newHash[hashPos] != -1);
+          int j = hashPos;
+          for (int perturb = code & 0x7ffffff; ; perturb >>= PERTURB_SHIFT) {
+            j = (j << 2) + j + perturb + 1;
+            hashPos = j & newMask;
+            if (newHash[hashPos] == -1) {
+              break;
+            }
+          }
         }
         newHash[hashPos] = e0;
       }
