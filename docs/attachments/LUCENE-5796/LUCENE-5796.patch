commit c64bb6f2df8f33dd8daafc953d9c27b5cbf29fa3
Author: Terry Smith <terry@shebiki.org>
Date:   Mon Jun 30 13:19:08 2014 -0400

    Fixes the Scorer.getChildren() method for two combinations of BooleanQuery.
    Removes FilterScorer.getChildren() to prevent mistakes and force subclasses
    to provide a correct implementation.

diff --git a/lucene/core/src/java/org/apache/lucene/search/BooleanTopLevelScorers.java b/lucene/core/src/java/org/apache/lucene/search/BooleanTopLevelScorers.java
index aedc5b0..2c49ec7 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BooleanTopLevelScorers.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BooleanTopLevelScorers.java
@@ -18,6 +18,10 @@ package org.apache.lucene.search;
  */
 
 import java.io.IOException;
+import java.util.Collection;
+import java.util.Collections;
+
+import org.apache.lucene.search.Scorer.ChildScorer;
 
 /** Internal document-at-a-time scorers used to deal with stupid coord() computation */
 class BooleanTopLevelScorers {
@@ -39,6 +43,11 @@ class BooleanTopLevelScorers {
     public float score() throws IOException {
       return in.score() * boost;
     }
+
+    @Override
+    public Collection<ChildScorer> getChildren() {
+      return Collections.singleton(new ChildScorer(in, "BOOSTED"));
+    }
   }
   
   /** 
diff --git a/lucene/core/src/java/org/apache/lucene/search/FilterScorer.java b/lucene/core/src/java/org/apache/lucene/search/FilterScorer.java
index 6b64d8a..88881bd 100644
--- a/lucene/core/src/java/org/apache/lucene/search/FilterScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/FilterScorer.java
@@ -71,11 +71,6 @@ abstract class FilterScorer extends Scorer {
   }
 
   @Override
-  public Collection<ChildScorer> getChildren() {
-    return in.getChildren();
-  }
-
-  @Override
   public AttributeSource attributes() {
     return in.attributes();
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java b/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java
index a2cb61b..3f31ace 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java
@@ -114,9 +114,9 @@ class MinShouldMatchSumScorer extends Scorer {
 
   @Override
   public final Collection<ChildScorer> getChildren() {
-    ArrayList<ChildScorer> children = new ArrayList<>(numScorers);
-    for (int i = 0; i < numScorers; i++) {
-      children.add(new ChildScorer(subScorers[i], "SHOULD"));
+    ArrayList<ChildScorer> children = new ArrayList<>(sortedSubScorers.length);
+    for (int i = 0; i < sortedSubScorers.length; i++) {
+      children.add(new ChildScorer(sortedSubScorers[i], "SHOULD"));
     }
     return children;
   }
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java b/lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java
index 175061a..0747c43 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestBooleanQueryVisitSubscorers.java
@@ -18,8 +18,11 @@ package org.apache.lucene.search;
  */
 
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
@@ -33,6 +36,7 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriterConfig;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause.Occur;
 import org.apache.lucene.search.Scorer.ChildScorer;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
@@ -181,4 +185,93 @@ public class TestBooleanQueryVisitSubscorers extends LuceneTestCase {
       return docCounts.get(doc);
     }
   }
+
+  public void testGetChildrenMinShouldMatchSumScorer() throws IOException {
+    final BooleanQuery query = new BooleanQuery();
+    query.add(new TermQuery(new Term(F2, "nutch")), Occur.SHOULD);
+    query.add(new TermQuery(new Term(F2, "web")), Occur.SHOULD);
+    query.add(new TermQuery(new Term(F2, "crawler")), Occur.SHOULD);
+    query.setMinimumNumberShouldMatch(2);
+    ScorerSummarizingCollector collector = new ScorerSummarizingCollector();
+    searcher.search(query, collector);
+    assertEquals(1, collector.getNumHits());
+    assertFalse(collector.getSummaries().isEmpty());
+    for (String summary : collector.getSummaries()) {
+      assertEquals(
+          "MinShouldMatchSumScorer\n" +
+          "    SHOULD TermScorer body:nutch\n" +
+          "    SHOULD TermScorer body:web\n" +
+          "    SHOULD TermScorer body:crawler", summary);
+    }
+  }
+
+  public void testGetChildrenBoosterScorer() throws IOException {
+    final BooleanQuery query = new BooleanQuery();
+    query.add(new TermQuery(new Term(F2, "nutch")), Occur.SHOULD);
+    query.add(new TermQuery(new Term(F2, "miss")), Occur.SHOULD);
+    ScorerSummarizingCollector collector = new ScorerSummarizingCollector();
+    searcher.search(query, collector);
+    assertEquals(1, collector.getNumHits());
+    assertFalse(collector.getSummaries().isEmpty());
+    for (String summary : collector.getSummaries()) {
+      assertEquals(
+          "BoostedScorer\n" +
+          "    BOOSTED TermScorer body:nutch", summary);
+    }
+  }
+
+  private static class ScorerSummarizingCollector extends Collector {
+    private List<String> summaries = new ArrayList<>();
+    private int numHits;
+
+    public int getNumHits() {
+      return numHits;
+    }
+
+    public List<String> getSummaries() {
+      return summaries;
+    }
+
+    @Override
+    public void setScorer(Scorer scorer) throws IOException {
+      final StringBuilder builder = new StringBuilder();
+      summarizeScorer(builder, scorer, 0);
+      summaries.add(builder.toString());
+    }
+
+    @Override
+    public void collect(int doc) throws IOException {
+      numHits++;
+    }
+
+    @Override
+    public void setNextReader(AtomicReaderContext context) throws IOException {}
+
+    @Override
+    public boolean acceptsDocsOutOfOrder() {
+      return false;
+    }
+
+    private static void summarizeScorer(final StringBuilder builder, final Scorer scorer, final int indent) {
+      builder.append(scorer.getClass().getSimpleName());
+      if (scorer instanceof TermScorer) {
+        TermQuery termQuery = (TermQuery) scorer.getWeight().getQuery();
+        builder.append(" ").append(termQuery.getTerm().field()).append(":").append(termQuery.getTerm().text());
+      }
+      for (final ChildScorer childScorer : scorer.getChildren()) {
+        indent(builder, indent + 1).append(childScorer.relationship).append(" ");
+        summarizeScorer(builder, childScorer.child, indent + 2);
+      }
+    }
+
+    private static StringBuilder indent(final StringBuilder builder, final int indent) {
+      if (builder.length() != 0) {
+        builder.append("\n");
+      }
+      for (int i = 0; i < indent; i++) {
+        builder.append("    ");
+      }
+      return builder;
+    }
+  }
 }
