diff --git a/lucene/spatial-extras/src/java/org/apache/lucene/spatial/SpatialStrategy.java b/lucene/spatial-extras/src/java/org/apache/lucene/spatial/SpatialStrategy.java
index d980ba9..ffbcc44 100644
--- a/lucene/spatial-extras/src/java/org/apache/lucene/spatial/SpatialStrategy.java
+++ b/lucene/spatial-extras/src/java/org/apache/lucene/spatial/SpatialStrategy.java
@@ -16,6 +16,8 @@
  */
 package org.apache.lucene.spatial;
 
+import org.apache.lucene.document.FieldType;
+import org.apache.lucene.index.DocValuesType;
 import org.locationtech.spatial4j.context.SpatialContext;
 import org.locationtech.spatial4j.shape.Point;
 import org.locationtech.spatial4j.shape.Rectangle;
@@ -57,6 +59,8 @@ public abstract class SpatialStrategy {
 
   protected final SpatialContext ctx;
   private final String fieldName;
+  protected FieldType fieldType;
+  public static final String SUFFIX_DV = "_dv";
 
   /**
    * Constructs the spatial strategy with its mandatory arguments.
@@ -84,6 +88,14 @@ public abstract class SpatialStrategy {
   }
 
   /**
+   * The type configuration for the field
+   * @return Not null.
+   */
+  public FieldType getFieldType() {
+    return this.fieldType;
+  }
+
+  /**
    * Returns the IndexableField(s) from the {@code shape} that are to be
    * added to the {@link org.apache.lucene.document.Document}.  These fields
    * are expected to be marked as indexed and not stored.
diff --git a/lucene/spatial-extras/src/java/org/apache/lucene/spatial/bbox/BBoxStrategy.java b/lucene/spatial-extras/src/java/org/apache/lucene/spatial/bbox/BBoxStrategy.java
index 253b290..2183486 100644
--- a/lucene/spatial-extras/src/java/org/apache/lucene/spatial/bbox/BBoxStrategy.java
+++ b/lucene/spatial-extras/src/java/org/apache/lucene/spatial/bbox/BBoxStrategy.java
@@ -16,6 +16,9 @@
  */
 package org.apache.lucene.spatial.bbox;
 
+import org.apache.lucene.document.DoubleDocValuesField;
+import org.apache.lucene.document.DoublePoint;
+import org.apache.lucene.index.IndexOptions;
 import org.locationtech.spatial4j.context.SpatialContext;
 import org.locationtech.spatial4j.shape.Point;
 import org.locationtech.spatial4j.shape.Rectangle;
@@ -91,10 +94,11 @@ public class BBoxStrategy extends SpatialStrategy {
   protected final String field_maxY;
   protected final String field_xdl; // crosses dateline
 
-  protected FieldType fieldType;//for the 4 numbers
   protected FieldType xdlFieldType;
 
-  public BBoxStrategy(SpatialContext ctx, String fieldNamePrefix) {
+  private boolean hasNumericDV = true; // default turns on numeric docvalues
+
+  private BBoxStrategy(SpatialContext ctx, String fieldNamePrefix, final boolean legacyNumeric) {
     super(ctx, fieldNamePrefix);
     field_bbox = fieldNamePrefix;
     field_minX = fieldNamePrefix + SUFFIX_MINX;
@@ -103,12 +107,40 @@ public class BBoxStrategy extends SpatialStrategy {
     field_maxY = fieldNamePrefix + SUFFIX_MAXY;
     field_xdl = fieldNamePrefix + SUFFIX_XDL;
 
-    FieldType fieldType = new FieldType(LegacyDoubleField.TYPE_NOT_STORED);
-    fieldType.setNumericPrecisionStep(8);//Solr's default
-    fieldType.setDocValuesType(DocValuesType.NUMERIC);
+    FieldType fieldType;
+    if (legacyNumeric == true) {
+      fieldType = new FieldType(LegacyDoubleField.TYPE_NOT_STORED);
+      fieldType.setDocValuesType(DocValuesType.NUMERIC);
+      fieldType.setNumericPrecisionStep(8);//Solr's default
+    } else {
+      fieldType = new FieldType();
+      fieldType.setDimensions(1, Double.BYTES);
+    }
     setFieldType(fieldType);
   }
 
+  /**
+   * Creates a new {@link BBoxStrategy} instance that uses {@link DoublePoint} and {@link DoublePoint#newRangeQuery}
+   */
+  public static BBoxStrategy newInstance(SpatialContext ctx, String fieldNamePrefix) {
+    return new BBoxStrategy(ctx, fieldNamePrefix, false);
+  }
+
+  /**
+   * Creates a new {@link BBoxStrategy} instance that uses {@link LegacyDoubleField} for backwards compatibility
+   * @deprecated LegacyNumerics will be removed
+   */
+  @Deprecated
+  public static BBoxStrategy newLegacyInstance(SpatialContext ctx, String fieldNamePrefix) {
+    return new BBoxStrategy(ctx, fieldNamePrefix, true);
+  }
+
+  /**
+   * Return the {@link LegacyDoubleField} precision step parameter
+   *
+   * @deprecated LegacyNumerics will be removed
+   */
+  @Deprecated
   private int getPrecisionStep() {
     return fieldType.numericPrecisionStep();
   }
@@ -121,18 +153,39 @@ public class BBoxStrategy extends SpatialStrategy {
    * requires indexed=true, and relevancy requires docValues. If these features aren't needed then disable them.
    * {@link FieldType#freeze()} is called on the argument. */
   public void setFieldType(FieldType fieldType) {
+    if (fieldType.numericType() != null && fieldType.numericType() != FieldType.LegacyNumericType.DOUBLE) {
+      //only double's supported right now
+      throw new IllegalArgumentException("BBoxStrategy only supports doubles at this time.");
+    }
+
+    // if using legacy numerics and DocValues is set we need to index DoubleDocValuesField separately
+    // and turn off wasteful LegacyDoubleField docValues (which is a truncated double value)
+    if (fieldType.numericType() != null) {
+      this.hasNumericDV = fieldType.docValuesType() == DocValuesType.NUMERIC;
+      if (this.hasNumericDV) {
+        // set doc values to NONE so we don't index useless longs
+        fieldType.setDocValuesType(DocValuesType.NONE);
+      }
+    }
+
     fieldType.freeze();
     this.fieldType = fieldType;
-    //only double's supported right now
-    if (fieldType.numericType() != FieldType.LegacyNumericType.DOUBLE)
-      throw new IllegalArgumentException("BBoxStrategy only supports doubles at this time.");
+
     //for xdlFieldType, copy some similar options. Don't do docValues since it isn't needed here.
     xdlFieldType = new FieldType(StringField.TYPE_NOT_STORED);
     xdlFieldType.setStored(fieldType.stored());
-    xdlFieldType.setIndexOptions(fieldType.indexOptions());
+    if (fieldType.stored() == false) {
+      xdlFieldType.setIndexOptions(IndexOptions.DOCS);
+    } else {
+      xdlFieldType.setIndexOptions(fieldType.indexOptions());
+    }
     xdlFieldType.freeze();
   }
 
+  public boolean hasNumericDocValues() {
+    return this.hasNumericDV;
+  }
+
   //---------------------------------
   // Indexing
   //---------------------------------
@@ -142,14 +195,44 @@ public class BBoxStrategy extends SpatialStrategy {
     return createIndexableFields(shape.getBoundingBox());
   }
 
-  public Field[] createIndexableFields(Rectangle bbox) {
-    Field[] fields = new Field[5];
+  private Field[] createIndexableFields(Rectangle bbox) {
+    Field[] fields;
+    // double types won't index the actual double - it seems like they should instead of having this
+    // "syntactic sugar" type? but it is what it is. DocValues need to be indexed separately.
+    if (hasNumericDV == false) {
+      fields = new Field[5];
+    } else {
+      // index double docValues
+      fields = new Field[9];
+      fields[5] = new DoubleDocValuesField(field_minX + SUFFIX_DV, bbox.getMinX());
+      fields[6] = new DoubleDocValuesField(field_maxX + SUFFIX_DV, bbox.getMaxX());
+      fields[7] = new DoubleDocValuesField(field_minY + SUFFIX_DV, bbox.getMinY());
+      fields[8] = new DoubleDocValuesField(field_maxY + SUFFIX_DV, bbox.getMaxY());
+    }
+    if (fieldType.numericType() == null) {
+      fields[0] = new DoublePoint(field_minX, bbox.getMinX());
+      fields[1] = new DoublePoint(field_maxX, bbox.getMaxX());
+      fields[2] = new DoublePoint(field_minY, bbox.getMinY());
+      fields[3] = new DoublePoint(field_maxY, bbox.getMaxY());
+    } else {
+      createLegacyIndexableFields(bbox, fields);
+    }
+    // index cross dateline shortcut term
+    fields[4] = new Field(field_xdl, bbox.getCrossesDateLine()?"T":"F", xdlFieldType);
+    return fields;
+  }
+
+  /**
+   * Creates LegacyDoubleFields - Will be removed in 7.0
+   *
+   * @deprecated LegacyNumerics will be removed
+   */
+  @Deprecated
+  private void createLegacyIndexableFields(Rectangle bbox, Field[] fields) {
     fields[0] = new ComboField(field_minX, bbox.getMinX(), fieldType);
     fields[1] = new ComboField(field_maxX, bbox.getMaxX(), fieldType);
     fields[2] = new ComboField(field_minY, bbox.getMinY(), fieldType);
     fields[3] = new ComboField(field_maxY, bbox.getMaxY(), fieldType);
-    fields[4] = new ComboField(field_xdl, bbox.getCrossesDateLine()?"T":"F", xdlFieldType);
-    return fields;
   }
 
   /** Field subclass circumventing Field limitations. This one instance can have any combination of indexed, stored,
@@ -253,8 +336,8 @@ public class BBoxStrategy extends SpatialStrategy {
 
     // Y conditions
     // docMinY <= queryExtent.getMinY() AND docMaxY >= queryExtent.getMaxY()
-    Query qMinY = LegacyNumericRangeQuery.newDoubleRange(field_minY, getPrecisionStep(), null, bbox.getMinY(), false, true);
-    Query qMaxY = LegacyNumericRangeQuery.newDoubleRange(field_maxY, getPrecisionStep(), bbox.getMaxY(), null, true, false);
+    Query qMinY = this.makeNumericRangeQuery(field_minY, null, bbox.getMinY(), false, true);
+    Query qMaxY = this.makeNumericRangeQuery(field_maxY, bbox.getMaxY(), null, true, false);
     Query yConditions = this.makeQuery(BooleanClause.Occur.MUST, qMinY, qMaxY);
 
     // X conditions
@@ -266,8 +349,8 @@ public class BBoxStrategy extends SpatialStrategy {
       // X Conditions for documents that do not cross the date line,
       // documents that contain the min X and max X of the query envelope,
       // docMinX <= queryExtent.getMinX() AND docMaxX >= queryExtent.getMaxX()
-      Query qMinX = LegacyNumericRangeQuery.newDoubleRange(field_minX, getPrecisionStep(), null, bbox.getMinX(), false, true);
-      Query qMaxX = LegacyNumericRangeQuery.newDoubleRange(field_maxX, getPrecisionStep(), bbox.getMaxX(), null, true, false);
+      Query qMinX = this.makeNumericRangeQuery(field_minX, null, bbox.getMinX(), false, true);
+      Query qMaxX = this.makeNumericRangeQuery(field_maxX, bbox.getMaxX(), null, true, false);
       Query qMinMax = this.makeQuery(BooleanClause.Occur.MUST, qMinX, qMaxX);
       Query qNonXDL = this.makeXDL(false, qMinMax);
 
@@ -278,8 +361,8 @@ public class BBoxStrategy extends SpatialStrategy {
         // the left portion of the document contains the min X of the query
         // OR the right portion of the document contains the max X of the query,
         // docMinXLeft <= queryExtent.getMinX() OR docMaxXRight >= queryExtent.getMaxX()
-        Query qXDLLeft = LegacyNumericRangeQuery.newDoubleRange(field_minX, getPrecisionStep(), null, bbox.getMinX(), false, true);
-        Query qXDLRight = LegacyNumericRangeQuery.newDoubleRange(field_maxX, getPrecisionStep(), bbox.getMaxX(), null, true, false);
+        Query qXDLLeft = this.makeNumericRangeQuery(field_minX, null, bbox.getMinX(), false, true);
+        Query qXDLRight = this.makeNumericRangeQuery(field_maxX, bbox.getMaxX(), null, true, false);
         Query qXDLLeftRight = this.makeQuery(BooleanClause.Occur.SHOULD, qXDLLeft, qXDLRight);
         Query qXDL = this.makeXDL(true, qXDLLeftRight);
 
@@ -302,8 +385,8 @@ public class BBoxStrategy extends SpatialStrategy {
       // the left portion of the document contains the min X of the query
       // AND the right portion of the document contains the max X of the query,
       // docMinXLeft <= queryExtent.getMinX() AND docMaxXRight >= queryExtent.getMaxX()
-      Query qXDLLeft = LegacyNumericRangeQuery.newDoubleRange(field_minX, getPrecisionStep(), null, bbox.getMinX(), false, true);
-      Query qXDLRight = LegacyNumericRangeQuery.newDoubleRange(field_maxX, getPrecisionStep(), bbox.getMaxX(), null, true, false);
+      Query qXDLLeft = this.makeNumericRangeQuery(field_minX, null, bbox.getMinX(), false, true);
+      Query qXDLRight = this.makeNumericRangeQuery(field_maxX, bbox.getMaxX(), null, true, false);
       Query qXDLLeftRight = this.makeXDL(true, this.makeQuery(BooleanClause.Occur.MUST, qXDLLeft, qXDLRight));
 
       Query qWorld = makeQuery(BooleanClause.Occur.MUST,
@@ -328,8 +411,8 @@ public class BBoxStrategy extends SpatialStrategy {
 
     // Y conditions
     // docMinY > queryExtent.getMaxY() OR docMaxY < queryExtent.getMinY()
-    Query qMinY = LegacyNumericRangeQuery.newDoubleRange(field_minY, getPrecisionStep(), bbox.getMaxY(), null, false, false);
-    Query qMaxY = LegacyNumericRangeQuery.newDoubleRange(field_maxY, getPrecisionStep(), null, bbox.getMinY(), false, false);
+    Query qMinY = this.makeNumericRangeQuery(field_minY, bbox.getMaxY(), null, false, false);
+    Query qMaxY = this.makeNumericRangeQuery(field_maxY, null, bbox.getMinY(), false, false);
     Query yConditions = this.makeQuery(BooleanClause.Occur.SHOULD, qMinY, qMaxY);
 
     // X conditions
@@ -340,14 +423,15 @@ public class BBoxStrategy extends SpatialStrategy {
 
       // X Conditions for documents that do not cross the date line,
       // docMinX > queryExtent.getMaxX() OR docMaxX < queryExtent.getMinX()
-      Query qMinX = LegacyNumericRangeQuery.newDoubleRange(field_minX, getPrecisionStep(), bbox.getMaxX(), null, false, false);
+      Query qMinX = this.makeNumericRangeQuery(field_minX, bbox.getMaxX(), null, false, false);
       if (bbox.getMinX() == -180.0 && ctx.isGeo()) {//touches dateline; -180 == 180
         BooleanQuery.Builder bq = new BooleanQuery.Builder();
         bq.add(qMinX, BooleanClause.Occur.MUST);
         bq.add(makeNumberTermQuery(field_maxX, 180.0), BooleanClause.Occur.MUST_NOT);
         qMinX = bq.build();
       }
-      Query qMaxX = LegacyNumericRangeQuery.newDoubleRange(field_maxX, getPrecisionStep(), null, bbox.getMinX(), false, false);
+      Query qMaxX = this.makeNumericRangeQuery(field_maxX, null, bbox.getMinX(), false, false);
+
       if (bbox.getMaxX() == 180.0 && ctx.isGeo()) {//touches dateline; -180 == 180
         BooleanQuery.Builder bq = new BooleanQuery.Builder();
         bq.add(qMaxX, BooleanClause.Occur.MUST);
@@ -368,8 +452,8 @@ public class BBoxStrategy extends SpatialStrategy {
         // where: docMaxXLeft = 180.0, docMinXRight = -180.0
         // (docMaxXLeft  < queryExtent.getMinX()) equates to (180.0  < queryExtent.getMinX()) and is ignored
         // (docMinXRight > queryExtent.getMaxX()) equates to (-180.0 > queryExtent.getMaxX()) and is ignored
-        Query qMinXLeft = LegacyNumericRangeQuery.newDoubleRange(field_minX, getPrecisionStep(), bbox.getMaxX(), null, false, false);
-        Query qMaxXRight = LegacyNumericRangeQuery.newDoubleRange(field_maxX, getPrecisionStep(), null, bbox.getMinX(), false, false);
+        Query qMinXLeft = this.makeNumericRangeQuery(field_minX, bbox.getMaxX(), null, false, false);
+        Query qMaxXRight = this.makeNumericRangeQuery(field_maxX, null, bbox.getMinX(), false, false);
         Query qLeftRight = this.makeQuery(BooleanClause.Occur.MUST, qMinXLeft, qMaxXRight);
         Query qXDL = this.makeXDL(true, qLeftRight);
 
@@ -383,10 +467,10 @@ public class BBoxStrategy extends SpatialStrategy {
       // the document must be disjoint to both the left and right query portions
       // (docMinX > queryExtent.getMaxX()Left OR docMaxX < queryExtent.getMinX()) AND (docMinX > queryExtent.getMaxX() OR docMaxX < queryExtent.getMinX()Left)
       // where: queryExtent.getMaxX()Left = 180.0, queryExtent.getMinX()Left = -180.0
-      Query qMinXLeft = LegacyNumericRangeQuery.newDoubleRange(field_minX, getPrecisionStep(), 180.0, null, false, false);
-      Query qMaxXLeft = LegacyNumericRangeQuery.newDoubleRange(field_maxX, getPrecisionStep(), null, bbox.getMinX(), false, false);
-      Query qMinXRight = LegacyNumericRangeQuery.newDoubleRange(field_minX, getPrecisionStep(), bbox.getMaxX(), null, false, false);
-      Query qMaxXRight = LegacyNumericRangeQuery.newDoubleRange(field_maxX, getPrecisionStep(), null, -180.0, false, false);
+      Query qMinXLeft = this.makeNumericRangeQuery(field_minX, 180.0, null, false, false);
+      Query qMaxXLeft = this.makeNumericRangeQuery(field_maxX, null, bbox.getMinX(), false, false);
+      Query qMinXRight = this.makeNumericRangeQuery(field_minX, bbox.getMaxX(), null, false, false);
+      Query qMaxXRight = this.makeNumericRangeQuery(field_maxX, null, -180.0, false, false);
       Query qLeft = this.makeQuery(BooleanClause.Occur.SHOULD, qMinXLeft, qMaxXLeft);
       Query qRight = this.makeQuery(BooleanClause.Occur.SHOULD, qMinXRight, qMaxXRight);
       Query qLeftRight = this.makeQuery(BooleanClause.Occur.MUST, qLeft, qRight);
@@ -478,8 +562,8 @@ public class BBoxStrategy extends SpatialStrategy {
 
     // Y conditions
     // docMinY >= queryExtent.getMinY() AND docMaxY <= queryExtent.getMaxY()
-    Query qMinY = LegacyNumericRangeQuery.newDoubleRange(field_minY, getPrecisionStep(), bbox.getMinY(), null, true, false);
-    Query qMaxY = LegacyNumericRangeQuery.newDoubleRange(field_maxY, getPrecisionStep(), null, bbox.getMaxY(), false, true);
+    Query qMinY = this.makeNumericRangeQuery(field_minY, bbox.getMinY(), null, true, false);
+    Query qMaxY = this.makeNumericRangeQuery(field_maxY, null, bbox.getMaxY(), false, true);
     Query yConditions = this.makeQuery(BooleanClause.Occur.MUST, qMinY, qMaxY);
 
     // X conditions
@@ -493,8 +577,8 @@ public class BBoxStrategy extends SpatialStrategy {
       // queries that do not cross the date line
 
       // docMinX >= queryExtent.getMinX() AND docMaxX <= queryExtent.getMaxX()
-      Query qMinX = LegacyNumericRangeQuery.newDoubleRange(field_minX, getPrecisionStep(), bbox.getMinX(), null, true, false);
-      Query qMaxX = LegacyNumericRangeQuery.newDoubleRange(field_maxX, getPrecisionStep(), null, bbox.getMaxX(), false, true);
+      Query qMinX = this.makeNumericRangeQuery(field_minX, bbox.getMinX(), null, true, false);
+      Query qMaxX = this.makeNumericRangeQuery(field_maxX, null, bbox.getMaxX(), false, true);
       Query qMinMax = this.makeQuery(BooleanClause.Occur.MUST, qMinX, qMaxX);
 
       double edge = 0;//none, otherwise opposite dateline of query
@@ -517,14 +601,14 @@ public class BBoxStrategy extends SpatialStrategy {
 
       // the document should be within the left portion of the query
       // docMinX >= queryExtent.getMinX() AND docMaxX <= 180.0
-      Query qMinXLeft = LegacyNumericRangeQuery.newDoubleRange(field_minX, getPrecisionStep(), bbox.getMinX(), null, true, false);
-      Query qMaxXLeft = LegacyNumericRangeQuery.newDoubleRange(field_maxX, getPrecisionStep(), null, 180.0, false, true);
+      Query qMinXLeft = this.makeNumericRangeQuery(field_minX, bbox.getMinX(), null, true, false);
+      Query qMaxXLeft = this.makeNumericRangeQuery(field_maxX, null, 180.0, false, true);
       Query qLeft = this.makeQuery(BooleanClause.Occur.MUST, qMinXLeft, qMaxXLeft);
 
       // the document should be within the right portion of the query
       // docMinX >= -180.0 AND docMaxX <= queryExtent.getMaxX()
-      Query qMinXRight = LegacyNumericRangeQuery.newDoubleRange(field_minX, getPrecisionStep(), -180.0, null, true, false);
-      Query qMaxXRight = LegacyNumericRangeQuery.newDoubleRange(field_maxX, getPrecisionStep(), null, bbox.getMaxX(), false, true);
+      Query qMinXRight = this.makeNumericRangeQuery(field_minX, -180.0, null, true, false);
+      Query qMaxXRight = this.makeNumericRangeQuery(field_maxX, null, bbox.getMaxX(), false, true);
       Query qRight = this.makeQuery(BooleanClause.Occur.MUST, qMinXRight, qMaxXRight);
 
       // either left or right conditions should occur,
@@ -537,8 +621,8 @@ public class BBoxStrategy extends SpatialStrategy {
       // AND the right portion of the document must be within the right portion of the query
       // docMinXLeft >= queryExtent.getMinX() AND docMaxXLeft <= 180.0
       // AND docMinXRight >= -180.0 AND docMaxXRight <= queryExtent.getMaxX()
-      Query qXDLLeft = LegacyNumericRangeQuery.newDoubleRange(field_minX, getPrecisionStep(), bbox.getMinX(), null, true, false);
-      Query qXDLRight = LegacyNumericRangeQuery.newDoubleRange(field_maxX, getPrecisionStep(), null, bbox.getMaxX(), false, true);
+      Query qXDLLeft = this.makeNumericRangeQuery(field_minX, bbox.getMinX(), null, true, false);
+      Query qXDLRight = this.makeNumericRangeQuery(field_maxX, null, bbox.getMaxX(), false, true);
       Query qXDLLeftRight = this.makeQuery(BooleanClause.Occur.MUST, qXDLLeft, qXDLRight);
       Query qXDL = this.makeXDL(true, qXDLLeftRight);
 
@@ -581,9 +665,47 @@ public class BBoxStrategy extends SpatialStrategy {
   }
 
   private Query makeNumberTermQuery(String field, double number) {
-    BytesRefBuilder bytes = new BytesRefBuilder();
-    LegacyNumericUtils.longToPrefixCoded(NumericUtils.doubleToSortableLong(number), 0, bytes);
-    return new TermQuery(new Term(field, bytes.get()));
+    if (fieldType.numericType() != null) {
+      BytesRefBuilder bytes = new BytesRefBuilder();
+      LegacyNumericUtils.longToPrefixCoded(NumericUtils.doubleToSortableLong(number), 0, bytes);
+      return new TermQuery(new Term(field, bytes.get()));
+    }
+    return DoublePoint.newExactQuery(field, number);
   }
 
+  /**
+   * Returns a numeric range query based on FieldType
+   * {@link LegacyNumericRangeQuery} is used for indexes created using {@code FieldType.LegacyNumericType}
+   * {@link DoublePoint#newRangeQuery} is used for indexes created using {@link DoublePoint} fields
+   *
+   * @param fieldname field name. must not be <code>null</code>.
+   * @param min minimum value of the range.
+   * @param max maximum value of the range.
+   * @param minInclusive include the minimum value if <code>true</code>.
+   * @param maxInclusive include the maximum value if <code>true</code>
+   */
+  private Query makeNumericRangeQuery(String fieldname, Double min, Double max, boolean minInclusive, boolean maxInclusive) {
+    // todo remove legacy numeric support in 7.0
+    if (this.fieldType.numericType() != null) {
+      return LegacyNumericRangeQuery.newDoubleRange(fieldname, getPrecisionStep(), min, max, minInclusive, maxInclusive);
+    }
+
+    if (min == null) {
+        min = Double.NEGATIVE_INFINITY;
+    }
+
+    if (max == null) {
+        max = Double.POSITIVE_INFINITY;
+    }
+
+    if (minInclusive == false) {
+      min = Math.nextUp(min);
+    }
+
+    if (maxInclusive == false) {
+      max = Math.nextDown(max);
+    }
+
+    return DoublePoint.newRangeQuery(fieldname, min, max);
+  }
 }
diff --git a/lucene/spatial-extras/src/java/org/apache/lucene/spatial/bbox/BBoxValueSource.java b/lucene/spatial-extras/src/java/org/apache/lucene/spatial/bbox/BBoxValueSource.java
index 2bfbfd9..50e9032 100644
--- a/lucene/spatial-extras/src/java/org/apache/lucene/spatial/bbox/BBoxValueSource.java
+++ b/lucene/spatial-extras/src/java/org/apache/lucene/spatial/bbox/BBoxValueSource.java
@@ -16,6 +16,8 @@
  */
 package org.apache.lucene.spatial.bbox;
 
+import org.apache.lucene.index.DocValuesType;
+import org.apache.lucene.index.FieldInfo;
 import org.locationtech.spatial4j.shape.Rectangle;
 import org.apache.lucene.index.LeafReader;
 import org.apache.lucene.index.LeafReaderContext;
@@ -29,6 +31,8 @@ import org.apache.lucene.util.Bits;
 import java.io.IOException;
 import java.util.Map;
 
+import static org.apache.lucene.spatial.SpatialStrategy.SUFFIX_DV;
+
 /**
  * A ValueSource in which the indexed Rectangle is returned from
  * {@link org.apache.lucene.queries.function.FunctionValues#objectVal(int)}.
@@ -51,12 +55,32 @@ class BBoxValueSource extends ValueSource {
   @Override
   public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {
     LeafReader reader = readerContext.reader();
-    final NumericDocValues minX = DocValues.getNumeric(reader, strategy.field_minX);
-    final NumericDocValues minY = DocValues.getNumeric(reader, strategy.field_minY);
-    final NumericDocValues maxX = DocValues.getNumeric(reader, strategy.field_maxX);
-    final NumericDocValues maxY = DocValues.getNumeric(reader, strategy.field_maxY);
 
-    final Bits validBits = DocValues.getDocsWithField(reader, strategy.field_minX);//could have chosen any field
+    final NumericDocValues minX;
+    final NumericDocValues minY;
+    final NumericDocValues maxX;
+    final NumericDocValues maxY;
+
+    if (strategy.hasNumericDocValues() == true) {
+      // index doc values separately - needed because Double's docvalues are not indexed as doubles
+      // they're indexed as a double casted to a long (a truncated double)
+      minX = DocValues.getNumeric(reader, strategy.field_minX + SUFFIX_DV);
+      minY = DocValues.getNumeric(reader, strategy.field_minY + SUFFIX_DV);
+      maxX = DocValues.getNumeric(reader, strategy.field_maxX + SUFFIX_DV);
+      maxY = DocValues.getNumeric(reader, strategy.field_maxY + SUFFIX_DV);
+    } else if (strategy.getFieldType().numericType() != null) {
+      // legacy support for UninvertingReader
+      minX = DocValues.getNumeric(reader, strategy.field_minX);
+      minY = DocValues.getNumeric(reader, strategy.field_minY);
+      maxX = DocValues.getNumeric(reader, strategy.field_maxX);
+      maxY = DocValues.getNumeric(reader, strategy.field_maxY);
+    } else {
+      throw new IllegalStateException("BBoxValueSource expects docvalues: " + DocValuesType.NUMERIC + ". "
+          + "Either reindex with docvalues or use an UninvertingReader");
+    }
+
+    //could have chosen any field
+    final Bits validBits = DocValues.getDocsWithField(reader, strategy.field_minX + SUFFIX_DV);
     //reused
     final Rectangle rect = strategy.getSpatialContext().makeRectangle(0,0,0,0);
 
diff --git a/lucene/spatial-extras/src/java/org/apache/lucene/spatial/vector/DistanceValueSource.java b/lucene/spatial-extras/src/java/org/apache/lucene/spatial/vector/DistanceValueSource.java
index 7cab3fe..8f3d93c 100644
--- a/lucene/spatial-extras/src/java/org/apache/lucene/spatial/vector/DistanceValueSource.java
+++ b/lucene/spatial-extras/src/java/org/apache/lucene/spatial/vector/DistanceValueSource.java
@@ -29,6 +29,8 @@ import org.apache.lucene.util.Bits;
 import java.io.IOException;
 import java.util.Map;
 
+import static org.apache.lucene.spatial.SpatialStrategy.SUFFIX_DV;
+
 /**
  * An implementation of the Lucene ValueSource model that returns the distance
  * for a {@link PointVectorStrategy}.
@@ -65,10 +67,10 @@ public class DistanceValueSource extends ValueSource {
   public FunctionValues getValues(Map context, LeafReaderContext readerContext) throws IOException {
     LeafReader reader = readerContext.reader();
 
-    final NumericDocValues ptX = DocValues.getNumeric(reader, strategy.getFieldNameX());
-    final NumericDocValues ptY = DocValues.getNumeric(reader, strategy.getFieldNameY());
-    final Bits validX =  DocValues.getDocsWithField(reader, strategy.getFieldNameX());
-    final Bits validY =  DocValues.getDocsWithField(reader, strategy.getFieldNameY());
+    final NumericDocValues ptX = DocValues.getNumeric(reader, strategy.getFieldNameX() + SUFFIX_DV);
+    final NumericDocValues ptY = DocValues.getNumeric(reader, strategy.getFieldNameY() + SUFFIX_DV);
+    final Bits validX =  DocValues.getDocsWithField(reader, strategy.getFieldNameX() + SUFFIX_DV);
+    final Bits validY =  DocValues.getDocsWithField(reader, strategy.getFieldNameY() + SUFFIX_DV);
 
     return new FunctionValues() {
 
diff --git a/lucene/spatial-extras/src/java/org/apache/lucene/spatial/vector/PointVectorStrategy.java b/lucene/spatial-extras/src/java/org/apache/lucene/spatial/vector/PointVectorStrategy.java
index f5f5f34..9f7b7fc 100644
--- a/lucene/spatial-extras/src/java/org/apache/lucene/spatial/vector/PointVectorStrategy.java
+++ b/lucene/spatial-extras/src/java/org/apache/lucene/spatial/vector/PointVectorStrategy.java
@@ -16,6 +16,8 @@
  */
 package org.apache.lucene.spatial.vector;
 
+import org.apache.lucene.document.DoubleDocValuesField;
+import org.apache.lucene.document.DoublePoint;
 import org.locationtech.spatial4j.context.SpatialContext;
 import org.locationtech.spatial4j.shape.Circle;
 import org.locationtech.spatial4j.shape.Point;
@@ -77,18 +79,70 @@ public class PointVectorStrategy extends SpatialStrategy {
   private final String fieldNameX;
   private final String fieldNameY;
 
-  public int precisionStep = 8; // same as solr default
+  protected boolean hasNumericDV = true; // default turns on numeric docvalues
 
-  public PointVectorStrategy(SpatialContext ctx, String fieldNamePrefix) {
+  private PointVectorStrategy(SpatialContext ctx, String fieldNamePrefix, final boolean legacyNumeric) {
     super(ctx, fieldNamePrefix);
     this.fieldNameX = fieldNamePrefix+SUFFIX_X;
     this.fieldNameY = fieldNamePrefix+SUFFIX_Y;
+
+    FieldType fieldType;
+    if (legacyNumeric == true) {
+      // backcompat support for LegacyDoubleField
+      // todo remove in 7.0
+      fieldType = new FieldType(LegacyDoubleField.TYPE_NOT_STORED);
+      fieldType.setNumericPrecisionStep(8); // same as solr default
+    } else {
+      // add support for PointField types
+      fieldType = new FieldType();
+      fieldType.setDimensions(1, Double.BYTES);
+    }
+    fieldType.freeze();
+    this.fieldType = fieldType;
   }
 
+  /**
+   * Create a new {@link PointVectorStrategy} instance that uses {@link DoublePoint} and {@link DoublePoint#newRangeQuery}
+   */
+  public static PointVectorStrategy newInstance(SpatialContext ctx, String fieldNamePrefix) {
+    return new PointVectorStrategy(ctx, fieldNamePrefix, false);
+  }
+
+  /**
+   * Create a new {@link PointVectorStrategy} instance that uses {@link LegacyDoubleField} for backwards compatibility
+   *
+   * @deprecated LegacyNumerics will be removed
+   */
+  @Deprecated
+  public static PointVectorStrategy newLegacyInstance(SpatialContext ctx, String fieldNamePrefix) {
+    return new PointVectorStrategy(ctx, fieldNamePrefix, true);
+  }
+
+  /**
+   * Set the precision step for {@link LegacyDoubleField}
+   *
+   * @deprecated LegacyNumerics will be removed
+   */
+  @Deprecated
   public void setPrecisionStep( int p ) {
-    precisionStep = p;
-    if (precisionStep<=0 || precisionStep>=64)
-      precisionStep=Integer.MAX_VALUE;
+    if (p <= 0 || p >= 64) {
+      throw new IllegalArgumentException("Invalid precision step " + p + ". Must be between 0 and 64");
+    }
+
+    FieldType ft = new FieldType(this.fieldType);
+    ft.setNumericPrecisionStep(p);
+    ft.freeze();
+    this.fieldType = ft;
+  }
+
+  /**
+   * Return the {@link LegacyDoubleField} precision step parameter
+   *
+   * @deprecated LegacyNumerics will be removed
+   */
+  @Deprecated
+  private int getPrecisionStep() {
+    return fieldType.numericPrecisionStep();
   }
 
   String getFieldNameX() {
@@ -107,13 +161,26 @@ public class PointVectorStrategy extends SpatialStrategy {
   }
 
   /** @see #createIndexableFields(org.locationtech.spatial4j.shape.Shape) */
-  public Field[] createIndexableFields(Point point) {
-    FieldType doubleFieldType = new FieldType(LegacyDoubleField.TYPE_NOT_STORED);
-    doubleFieldType.setNumericPrecisionStep(precisionStep);
-    Field[] f = new Field[2];
-    f[0] = new LegacyDoubleField(fieldNameX, point.getX(), doubleFieldType);
-    f[1] = new LegacyDoubleField(fieldNameY, point.getY(), doubleFieldType);
-    return f;
+  private Field[] createIndexableFields(Point point) {
+    Field[] fields;
+    if (hasNumericDV == false) {
+      fields = new Field[2];
+    } else {
+      // index doc values
+      fields = new Field[4];
+      fields[2] = new DoubleDocValuesField(fieldNameX + SUFFIX_DV, point.getX());
+      fields[3] = new DoubleDocValuesField(fieldNameY + SUFFIX_DV, point.getY());
+    }
+
+    if (fieldType.numericType() != null) {
+      fields[0] = new LegacyDoubleField(fieldNameX, point.getX(), this.fieldType);
+      fields[1] = new LegacyDoubleField(fieldNameY, point.getY(), this.fieldType);
+    } else {
+      fields[0] = new DoublePoint(fieldNameX, point.getX());
+      fields[1] = new DoublePoint(fieldNameY, point.getY());
+    }
+
+    return fields;
   }
 
   @Override
@@ -165,14 +232,25 @@ public class PointVectorStrategy extends SpatialStrategy {
     return bq.build();
   }
 
-  private LegacyNumericRangeQuery<Double> rangeQuery(String fieldName, Double min, Double max) {
-    return LegacyNumericRangeQuery.newDoubleRange(
-        fieldName,
-        precisionStep,
-        min,
-        max,
-        true,
-        true);//inclusive
-  }
+  /**
+   * Returns a numeric range query based on FieldType
+   * {@link LegacyNumericRangeQuery} is used for indexes created using {@code FieldType.LegacyNumericType}
+   * {@link DoublePoint#newRangeQuery} is used for indexes created using {@link DoublePoint} fields
+   */
+  private Query rangeQuery(String fieldName, Double min, Double max) {
+    // todo remove legacy numeric support in 7.0
+    if (this.fieldType.numericType() != null) {
+      return LegacyNumericRangeQuery.newDoubleRange(fieldName, getPrecisionStep(), min, max, true, true);//inclusive
+    }
+
+    if (min == null) {
+      min = Double.NEGATIVE_INFINITY;
+    }
+
+    if (max == null) {
+      max = Double.POSITIVE_INFINITY;
+    }
 
+    return DoublePoint.newRangeQuery(fieldName, min, max);
+  }
 }
diff --git a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java
index 1602679..bc0eb64 100644
--- a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java
+++ b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/DistanceStrategyTest.java
@@ -22,11 +22,11 @@ import java.util.Arrays;
 import java.util.List;
 
 import com.carrotsearch.randomizedtesting.annotations.ParametersFactory;
+import org.apache.lucene.index.DocValuesType;
 import org.locationtech.spatial4j.context.SpatialContext;
 import org.locationtech.spatial4j.shape.Point;
 import org.locationtech.spatial4j.shape.Shape;
 import org.apache.lucene.document.FieldType;
-import org.apache.lucene.index.IndexOptions;
 import org.apache.lucene.spatial.bbox.BBoxStrategy;
 import org.apache.lucene.spatial.prefix.RecursivePrefixTreeStrategy;
 import org.apache.lucene.spatial.prefix.TermQueryPrefixTreeStrategy;
@@ -59,10 +59,16 @@ public class DistanceStrategyTest extends StrategyTestCase {
     strategy = new RecursivePrefixTreeStrategy(grid, "recursive_packedquad");
     ctorArgs.add(new Object[]{strategy.getFieldName(), strategy});
 
-    strategy = new PointVectorStrategy(ctx, "pointvector");
+    strategy = PointVectorStrategy.newInstance(ctx, "pointvector");
     ctorArgs.add(new Object[]{strategy.getFieldName(), strategy});
 
-    strategy = new BBoxStrategy(ctx, "bbox");
+    strategy = PointVectorStrategy.newLegacyInstance(ctx, "pointvector_legacy");
+    ctorArgs.add(new Object[]{strategy.getFieldName(), strategy});
+
+    strategy = BBoxStrategy.newInstance(ctx, "bbox");
+    ctorArgs.add(new Object[]{strategy.getFieldName(), strategy});
+
+    strategy = BBoxStrategy.newLegacyInstance(ctx, "bbox_legacy");
     ctorArgs.add(new Object[]{strategy.getFieldName(), strategy});
 
     strategy = new SerializedDVStrategy(ctx, "serialized");
@@ -79,19 +85,18 @@ public class DistanceStrategyTest extends StrategyTestCase {
   @Override
   public void setUp() throws Exception {
     super.setUp();
-    if (strategy instanceof BBoxStrategy && random().nextBoolean()) {//disable indexing sometimes
-      BBoxStrategy bboxStrategy = (BBoxStrategy)strategy;
-      final FieldType fieldType = new FieldType(bboxStrategy.getFieldType());
-      fieldType.setIndexOptions(IndexOptions.NONE);
-      bboxStrategy.setFieldType(fieldType);
+    if (strategy instanceof BBoxStrategy) {
+      BBoxStrategy bboxStrategy = (BBoxStrategy) strategy;
+      FieldType bboxFT = bboxStrategy.getFieldType();
+      // we do not test with UninvertingReader so if using legacy numerics this test needs to turn on DocValues
+      if (bboxFT.numericType() != null && bboxFT.docValuesType() != DocValuesType.NUMERIC) {
+        final FieldType fieldType = new FieldType(bboxFT);
+        fieldType.setDocValuesType(DocValuesType.NUMERIC);
+        bboxStrategy.setFieldType(fieldType);
+      }
     }
   }
 
-  @Override
-  protected boolean needsDocValues() {
-    return true;
-  }
-
   @Test
   public void testDistanceOrder() throws IOException {
     adoc("100", ctx.makePoint(2, 1));
@@ -108,9 +113,9 @@ public class DistanceStrategyTest extends StrategyTestCase {
 
   @Test
   public void testRecipScore() throws IOException {
-    Point p100 = ctx.makePoint(2, 1);
+    Point p100 = ctx.makePoint(2.02, 0.98);
     adoc("100", p100);
-    Point p101 = ctx.makePoint(-1, 4);
+    Point p101 = ctx.makePoint(-1.001, 4.001);
     adoc("101", p101);
     adoc("103", (Shape)null);//test score for nothing
     adoc("999", ctx.makePoint(2, 1));//test deleted
diff --git a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/PortedSolr3Test.java b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/PortedSolr3Test.java
index a081497..359e603 100644
--- a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/PortedSolr3Test.java
+++ b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/PortedSolr3Test.java
@@ -62,7 +62,10 @@ public class PortedSolr3Test extends StrategyTestCase {
     strategy = new TermQueryPrefixTreeStrategy(grid, "termquery_geohash");
     ctorArgs.add(new Object[]{strategy.getFieldName(), strategy});
 
-    strategy = new PointVectorStrategy(ctx, "pointvector");
+    strategy = PointVectorStrategy.newInstance(ctx, "pointvector");
+    ctorArgs.add(new Object[]{strategy.getFieldName(), strategy});
+
+    strategy = PointVectorStrategy.newInstance(ctx, "pointvector_legacy");
     ctorArgs.add(new Object[]{strategy.getFieldName(), strategy});
 
     return ctorArgs;
diff --git a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/QueryEqualsHashCodeTest.java b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/QueryEqualsHashCodeTest.java
index 5dbb8f8..c084abb 100644
--- a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/QueryEqualsHashCodeTest.java
+++ b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/QueryEqualsHashCodeTest.java
@@ -57,8 +57,10 @@ public class QueryEqualsHashCodeTest extends LuceneTestCase {
     RecursivePrefixTreeStrategy recursive_geohash = new RecursivePrefixTreeStrategy(gridGeohash, "recursive_geohash");
     strategies.add(recursive_geohash);
     strategies.add(new TermQueryPrefixTreeStrategy(gridQuad, "termquery_quad"));
-    strategies.add(new PointVectorStrategy(ctx, "pointvector"));
-    strategies.add(new BBoxStrategy(ctx, "bbox"));
+    strategies.add(PointVectorStrategy.newInstance(ctx, "pointvector"));
+    strategies.add(PointVectorStrategy.newLegacyInstance(ctx, "pointvector_legacy"));
+    strategies.add(BBoxStrategy.newInstance(ctx, "bbox"));
+    strategies.add(BBoxStrategy.newLegacyInstance(ctx, "bbox_legacy"));
     final SerializedDVStrategy serialized = new SerializedDVStrategy(ctx, "serialized");
     strategies.add(serialized);
     strategies.add(new CompositeSpatialStrategy("composite", recursive_geohash, serialized));
diff --git a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialTestCase.java b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialTestCase.java
index 8ccb9af..ba8b561 100644
--- a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialTestCase.java
+++ b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/SpatialTestCase.java
@@ -18,34 +18,27 @@ package org.apache.lucene.spatial;
 
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
-import java.util.Random;
 import java.util.logging.Logger;
 
+import org.apache.lucene.index.IndexWriter;
 import org.locationtech.spatial4j.context.SpatialContext;
 import org.locationtech.spatial4j.distance.DistanceUtils;
 import org.locationtech.spatial4j.shape.Point;
 import org.locationtech.spatial4j.shape.Rectangle;
 
-import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.MockAnalyzer;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexWriterConfig;
-import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TopDocs;
 import org.apache.lucene.store.Directory;
-import org.apache.lucene.uninverting.UninvertingReader;
-import org.apache.lucene.uninverting.UninvertingReader.Type;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.util.LuceneTestCase.SuppressSysoutChecks;
-import org.apache.lucene.util.TestUtil;
 
 import static com.carrotsearch.randomizedtesting.RandomizedTest.randomDouble;
 import static com.carrotsearch.randomizedtesting.RandomizedTest.randomGaussian;
@@ -59,46 +52,25 @@ public abstract class SpatialTestCase extends LuceneTestCase {
   protected Logger log = Logger.getLogger(getClass().getName());
 
   private DirectoryReader indexReader;
-  protected RandomIndexWriter indexWriter;
+  protected IndexWriter indexWriter;
   private Directory directory;
-  private Analyzer analyzer;
   protected IndexSearcher indexSearcher;
 
   protected SpatialContext ctx;//subclass must initialize
 
-  protected Map<String,Type> uninvertMap = new HashMap<>();
-
   @Override
   public void setUp() throws Exception {
     super.setUp();
-    // TODO: change this module to index docvalues instead of uninverting
-    uninvertMap.clear();
-    uninvertMap.put("pointvector__x", Type.LEGACY_DOUBLE);
-    uninvertMap.put("pointvector__y", Type.LEGACY_DOUBLE);
 
     directory = newDirectory();
-    final Random random = random();
-    analyzer = new MockAnalyzer(random);
-    indexWriter = new RandomIndexWriter(random,directory, newIWConfig(random, analyzer));
-    indexReader = UninvertingReader.wrap(indexWriter.getReader(), uninvertMap);
-    indexSearcher = newSearcher(indexReader);
-  }
-
-  protected IndexWriterConfig newIWConfig(Random random, Analyzer analyzer) {
-    final IndexWriterConfig indexWriterConfig = LuceneTestCase.newIndexWriterConfig(random, analyzer);
-    //TODO can we randomly choose a doc-values supported format?
-    if (needsDocValues())
-      indexWriterConfig.setCodec( TestUtil.getDefaultCodec());
-    return indexWriterConfig;
-  }
-
-  protected boolean needsDocValues() {
-    return false;
+    indexWriter = new IndexWriter(directory, new IndexWriterConfig(new MockAnalyzer(random())));
+    indexReader = DirectoryReader.open(indexWriter);
+    indexSearcher = new IndexSearcher(indexReader);
   }
 
   @Override
   public void tearDown() throws Exception {
-    IOUtils.close(indexWriter, indexReader, analyzer, directory);
+    IOUtils.close(indexWriter, indexReader, directory);
     super.tearDown();
   }
 
@@ -126,7 +98,7 @@ public abstract class SpatialTestCase extends LuceneTestCase {
       IOUtils.close(indexReader);
       indexReader = newReader;
     }
-    indexSearcher = newSearcher(indexReader);
+    indexSearcher = new IndexSearcher(indexReader);
   }
 
   protected void verifyDocumentsIndexed(int numDocs) {
diff --git a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java
index 20a7202..f037602 100644
--- a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java
+++ b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/bbox/TestBBoxStrategy.java
@@ -40,11 +40,6 @@ import org.junit.Test;
 public class TestBBoxStrategy extends RandomSpatialOpStrategyTestCase {
 
   @Override
-  protected boolean needsDocValues() {
-    return true;
-  }
-
-  @Override
   protected Shape randomIndexedShape() {
     Rectangle world = ctx.getWorldBounds();
     if (random().nextInt(10) == 0) // increased chance of getting one of these
@@ -97,7 +92,12 @@ public class TestBBoxStrategy extends RandomSpatialOpStrategyTestCase {
       factory.worldBounds = new RectangleImpl(-300, 300, -100, 100, null);
       this.ctx = factory.newSpatialContext();
     }
-    this.strategy = new BBoxStrategy(ctx, "bbox");
+    // randomly test legacy (numeric) and point based bbox strategy
+    if (random().nextBoolean()) {
+      this.strategy = BBoxStrategy.newInstance(ctx, "bbox");
+    } else {
+      this.strategy = BBoxStrategy.newLegacyInstance(ctx, "bbox");
+    }
     //test we can disable docValues for predicate tests
     if (random().nextBoolean()) {
       BBoxStrategy bboxStrategy = (BBoxStrategy) strategy;
@@ -189,7 +189,11 @@ public class TestBBoxStrategy extends RandomSpatialOpStrategyTestCase {
 
   private void setupGeo() {
     this.ctx = SpatialContext.GEO;
-    this.strategy = new BBoxStrategy(ctx, "bbox");
+    if (random().nextBoolean()) {
+      this.strategy = BBoxStrategy.newInstance(ctx, "bbox");
+    } else {
+      this.strategy = BBoxStrategy.newLegacyInstance(ctx, "bbox");
+    }
   }
 
   // OLD STATIC TESTS (worthless?)
diff --git a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/composite/CompositeStrategyTest.java b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/composite/CompositeStrategyTest.java
index 7d49e8b..24533a9 100644
--- a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/composite/CompositeStrategyTest.java
+++ b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/composite/CompositeStrategyTest.java
@@ -102,11 +102,6 @@ public class CompositeStrategyTest extends RandomSpatialOpStrategyTestCase {
   }
 
   @Override
-  protected boolean needsDocValues() {
-    return true;//due to SerializedDVStrategy
-  }
-
-  @Override
   protected Shape randomIndexedShape() {
     return randomShape();
   }
diff --git a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/serialized/SerializedStrategyTest.java b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/serialized/SerializedStrategyTest.java
index 6a73d23..f65f029 100644
--- a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/serialized/SerializedStrategyTest.java
+++ b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/serialized/SerializedStrategyTest.java
@@ -34,11 +34,6 @@ public class SerializedStrategyTest extends StrategyTestCase {
     this.strategy = new SerializedDVStrategy(ctx, "serialized");
   }
 
-  @Override
-  protected boolean needsDocValues() {
-    return (strategy instanceof SerializedDVStrategy);
-  }
-
   @Test
   public void testBasicOperaions() throws IOException {
     getAddAndVerifyIndexedDocuments(DATA_SIMPLE_BBOX);
diff --git a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java
index e62b857..8146fef 100644
--- a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java
+++ b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/spatial4j/Geo3dRptTest.java
@@ -63,11 +63,6 @@ public class Geo3dRptTest extends RandomSpatialOpStrategyTestCase {
     return rpt;
   }
 
-  @Override
-  protected boolean needsDocValues() {
-    return true;//due to SerializedDVStrategy
-  }
-
   private void setupStrategy() {
     //setup
     setupGeohashGrid();
diff --git a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/vector/TestPointVectorStrategy.java b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/vector/TestPointVectorStrategy.java
index 69f8c4d..046123b 100644
--- a/lucene/spatial-extras/src/test/org/apache/lucene/spatial/vector/TestPointVectorStrategy.java
+++ b/lucene/spatial-extras/src/test/org/apache/lucene/spatial/vector/TestPointVectorStrategy.java
@@ -36,7 +36,11 @@ public class TestPointVectorStrategy extends StrategyTestCase {
   public void setUp() throws Exception {
     super.setUp();
     this.ctx = SpatialContext.GEO;
-    this.strategy = new PointVectorStrategy(ctx, getClass().getSimpleName());
+    if (random().nextBoolean()) {
+      this.strategy = PointVectorStrategy.newInstance(ctx, getClass().getSimpleName());
+    } else {
+      this.strategy = PointVectorStrategy.newLegacyInstance(ctx, getClass().getSimpleName());
+    }
   }
 
   @Test
diff --git a/solr/core/src/java/org/apache/solr/schema/BBoxField.java b/solr/core/src/java/org/apache/solr/schema/BBoxField.java
index f655e68..c893d4a 100644
--- a/solr/core/src/java/org/apache/solr/schema/BBoxField.java
+++ b/solr/core/src/java/org/apache/solr/schema/BBoxField.java
@@ -133,7 +133,13 @@ public class BBoxField extends AbstractSpatialFieldType<BBoxStrategy> implements
       registerSubFields(schema, fieldName, numberType, booleanType);
     }
 
-    BBoxStrategy strategy = new BBoxStrategy(ctx, fieldName);
+    BBoxStrategy strategy;
+    if (numberType.getNumericType() != null) {
+      strategy = BBoxStrategy.newLegacyInstance(ctx, fieldName);
+    } else {
+      strategy = BBoxStrategy.newInstance(ctx, fieldName);
+    }
+
     //Solr's FieldType ought to expose Lucene FieldType. Instead as a hack we create a Field with a dummy value.
     final SchemaField solrNumField = new SchemaField("_", numberType);//dummy temp
     org.apache.lucene.document.FieldType luceneType =
diff --git a/solr/core/src/java/org/apache/solr/schema/SpatialPointVectorFieldType.java b/solr/core/src/java/org/apache/solr/schema/SpatialPointVectorFieldType.java
index 99bf3fe..ae21a23 100644
--- a/solr/core/src/java/org/apache/solr/schema/SpatialPointVectorFieldType.java
+++ b/solr/core/src/java/org/apache/solr/schema/SpatialPointVectorFieldType.java
@@ -79,8 +79,15 @@ public class SpatialPointVectorFieldType extends AbstractSpatialFieldType<PointV
 
   @Override
   protected PointVectorStrategy newSpatialStrategy(String fieldName) {
-    PointVectorStrategy strategy = new PointVectorStrategy(ctx, fieldName);
-    strategy.setPrecisionStep(precisionStep);
+    PointVectorStrategy strategy;
+    if (this.getNumericType() != null) {
+      // create strategy based on legacy numerics
+      // todo remove in 7.0
+      strategy = PointVectorStrategy.newLegacyInstance(ctx, fieldName);
+      strategy.setPrecisionStep(precisionStep);
+    } else {
+      strategy = PointVectorStrategy.newInstance(ctx, fieldName);
+    }
     return strategy;
   }
 
