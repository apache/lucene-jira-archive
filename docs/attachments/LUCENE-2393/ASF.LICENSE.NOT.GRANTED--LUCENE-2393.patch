Index: contrib/misc/src/java/org/apache/lucene/misc/GetTermInfo.java
===================================================================
--- contrib/misc/src/java/org/apache/lucene/misc/GetTermInfo.java	(revision 0)
+++ contrib/misc/src/java/org/apache/lucene/misc/GetTermInfo.java	(revision 0)
@@ -0,0 +1,72 @@
+package org.apache.lucene.misc;
+
+import java.io.File;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.FSDirectory;
+import org.apache.lucene.misc.TermInfoWithTotalTF;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.TermDocs;
+
+/**
+* <code> GetTermInfo</code> class looks up the document frequency of a term in a lucene index and also 
+* looks up the term frequency of the the term in each document and computes the sum of the term frequencies. 
+* The sum of the term frequencies is useful for estimating the size of the entry for the term in the *prx files
+*
+**/
+public class GetTermInfo {
+  
+    public static void main(String[] args) throws Exception {
+    
+    FSDirectory dir = null;
+    String inputStr = null;
+    String DEFAULT_FIELD = "ocr";
+    String field = DEFAULT_FIELD;
+    
+    if (args.length == 2) {
+      dir = FSDirectory.open(new File(args[0]));
+      inputStr = args[1];
+    } else if (args.length == 3) {
+      dir = FSDirectory.open(new File(args[0]));
+      field = args[1];
+      inputStr = args[2];
+    } else if (args.length == 4) {
+      dir = FSDirectory.open(new File(args[0]));
+      field = args[1];
+      inputStr = args[2] + " " + args[3];// hack to allow tokens with whitespace
+      // i.e. "can t"
+    } else {
+      usage();
+      System.exit(1);
+    }
+    
+    Term term = new Term(field, inputStr);
+    TermInfoWithTotalTF ti = new TermInfoWithTotalTF(term, 1);
+    TermInfoWithTotalTF result = getTermInfo(dir, ti, new String[] {field});
+    
+    System.out.print(result.term + " df = ");
+    System.out.printf("%,d", result.docFreq);
+    System.out.print(" Total tf = ");
+    System.out.printf("%,d", +result.termFreq);
+  }
+  
+  public static TermInfoWithTotalTF getTermInfo(Directory dir, TermInfoWithTotalTF tinfo, String[] fields) throws Exception {
+    IndexReader reader = IndexReader.open(dir);
+    // get enum:list of docs and tf for the term
+    TermDocs td = reader.termDocs(tinfo.term);
+    TermInfoWithTotalTF result = new TermInfoWithTotalTF(tinfo.term, reader.docFreq(tinfo.term));
+    long total_tf = 0;
+    while (td.next()) {
+      total_tf += td.freq();
+    }
+    
+    result.termFreq = total_tf;
+    return result;
+  }
+  
+  private static void usage() {
+    System.out
+        .println("\n\nusage:\n\t"
+            + "java org.apache.lucene.index.GetTermInfo <index dir> [field] term \n\n");
+  }
+}

Property changes on: contrib/misc/src/java/org/apache/lucene/misc/GetTermInfo.java
___________________________________________________________________
Added: svn:executable
   + *

Index: contrib/misc/src/java/org/apache/lucene/misc/TermInfoWithTotalTF.java
===================================================================
--- contrib/misc/src/java/org/apache/lucene/misc/TermInfoWithTotalTF.java	(revision 0)
+++ contrib/misc/src/java/org/apache/lucene/misc/TermInfoWithTotalTF.java	(revision 0)
@@ -0,0 +1,20 @@
+package org.apache.lucene.misc;
+
+import org.apache.lucene.index.Term;
+
+public class TermInfoWithTotalTF {
+  public Term term;
+  public int docFreq;
+  public long termFreq;
+  
+  public TermInfoWithTotalTF(Term t, int df) {
+    this.term = t;
+    this.docFreq = df;
+  }
+  
+  public TermInfoWithTotalTF(Term t, int df, long tf) {
+    this.term = t;
+    this.docFreq = df;
+    this.termFreq = tf;
+  }
+}

Property changes on: contrib/misc/src/java/org/apache/lucene/misc/TermInfoWithTotalTF.java
___________________________________________________________________
Added: svn:executable
   + *

Index: contrib/misc/src/java/org/apache/lucene/misc/HighFreqTermsWithTF.java
===================================================================
--- contrib/misc/src/java/org/apache/lucene/misc/HighFreqTermsWithTF.java	(revision 0)
+++ contrib/misc/src/java/org/apache/lucene/misc/HighFreqTermsWithTF.java	(revision 0)
@@ -0,0 +1,230 @@
+package org.apache.lucene.misc;
+
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.MultiFields;
+import org.apache.lucene.index.Fields;
+import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.index.TermsEnum;
+import org.apache.lucene.index.FieldsEnum;
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.index.FieldReaderException;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.index.DocsEnum;
+import org.apache.lucene.store.FSDirectory;
+import org.apache.lucene.util.PriorityQueue;
+
+import org.apache.lucene.misc.TermInfoWithTotalTF;
+
+import java.io.File;
+
+/**
+ * 
+ * <code>HighFreqTermsWithTF</code> class extracts the top n most frequent terms
+ * (by document frequency ) from an existing Lucene index and reports both thier
+ * document frequency and their total tf (total number of occurences) in order
+ * of highest total tf
+ */
+public class HighFreqTermsWithTF {
+  
+  // The top numTerms will be displayed
+  public static final int DEFAULTnumTerms = 100;
+  public static int numTerms = DEFAULTnumTerms;
+  
+  public static void main(String[] args) throws Exception {
+    IndexReader reader = null;
+    FSDirectory dir = null;
+    String field = null;
+    
+    if (args.length == 1) {
+      dir = FSDirectory.open(new File(args[0]));
+    } else if (args.length == 2) {
+      try {
+        numTerms = Integer.parseInt(args[1]);
+      } catch (NumberFormatException e) {
+        System.err.println("second argument must be an integer");
+        usage();
+        System.exit(1);
+      }
+      dir = FSDirectory.open(new File(args[0]));
+    } else if (args.length == 3) {
+      try {
+        numTerms = Integer.parseInt(args[1]);
+      } catch (NumberFormatException e) {
+        System.err.println("second argument must be an integer");
+        usage();
+        System.exit(1);
+      }
+      field = args[2];
+      dir = FSDirectory.open(new File(args[0]));
+      
+    } else {
+      usage();
+      System.exit(1);
+    }
+    
+    reader = IndexReader.open(dir, true);
+    TermInfoWithTotalTF[] terms = getHighFreqTerms(reader, numTerms, field);
+    TermInfoWithTotalTF[] termsWithTF = getTermFreqOrdered(reader, terms);
+    
+    for (int i = 0; i < termsWithTF.length; i++) {
+      System.out.printf("%s \t total_tf = %,d \t doc freq = %,d \n",
+          termsWithTF[i].term, termsWithTF[i].termFreq, termsWithTF[i].docFreq);
+    }
+    reader.close();
+  }
+  
+  /**
+   * 
+   * @param reader
+   * @param numTerms
+   * @param field
+   * @return TermInfoWithTotalTF[] ordered by terms with highest docFreq first.
+   * @throws Exception
+   */
+  public static TermInfoWithTotalTF[] getHighFreqTerms(IndexReader reader,
+      int numTerms, String field) throws Exception {
+    TermInfoWiTFQueue tiq = new TermInfoWiTFQueue(numTerms);
+    
+    if (field != null) {
+      Fields fields = MultiFields.getFields(reader);
+      if (fields == null) {
+        throw new FieldReaderException("field " + field + " not found");
+      }
+      Terms terms = fields.terms(field);
+      if (terms != null) {
+        TermsEnum termsEnum = terms.iterator();
+        while (true) {
+          BytesRef term = termsEnum.next();
+          if (term != null) {
+            tiq.insertWithOverflow(new TermInfoWithTotalTF(new Term(field, term.utf8ToString()), termsEnum.docFreq()));
+          } else {
+            break;
+          }
+        }
+      }
+    } else {
+      Fields fields = MultiFields.getFields(reader);
+      if (fields == null) {
+        throw new FieldReaderException("no fields found for this index");
+      }
+      FieldsEnum fieldsEnum = fields.iterator();
+      while (true) {
+        field = fieldsEnum.next();
+        if (field != null) {
+          TermsEnum terms = fieldsEnum.terms();
+          while (true) {
+            BytesRef term = terms.next();
+            if (term != null) {
+              tiq.insertWithOverflow(new TermInfoWithTotalTF(new Term(field, term.utf8ToString()), terms.docFreq()));
+            } else {
+              break;
+            }
+          }
+        } else {
+          break;
+        }
+      }
+    }
+    
+    TermInfoWithTotalTF[] result = new TermInfoWithTotalTF[tiq.size()];
+    // we want highest first so we read the queue and populate the array
+    // starting at the end and work backwards
+    int count = tiq.size() - 1;
+    while (tiq.size() != 0) {
+      result[count] = tiq.pop();
+      count--;
+    }
+    return result;
+  }
+  
+  /**
+   * Takes array of TermInfoWithTotalTF. For each term looks up the tf for each
+   * doc containing the term and stores the total in the output array of
+   * TermInfoWithTotalTF. Output array is sorted by highest total tf.
+   * 
+   * @param reader
+   * @param terms
+   *          TermInfoWithTotalTF[]
+   * @return TermInfoWithTotalTF[]
+   * @throws Exception
+   */
+  public static TermInfoWithTotalTF[] getTermFreqOrdered(IndexReader reader,TermInfoWithTotalTF[] terms) throws Exception {
+    TermFreqInfoWiTFQueue tfiq = new TermFreqInfoWiTFQueue(terms.length);
+    long total_tf;
+    
+    for (int i = 0; i < terms.length; i++) {
+      total_tf = 0;
+      Bits skipDocs = MultiFields.getDeletedDocs(reader);
+      BytesRef br = new BytesRef(terms[i].term.text());
+      DocsEnum de = MultiFields.getTermDocsEnum(reader, skipDocs, terms[i].term
+          .field(), br);
+      // iterate through docs enum
+      while (de.nextDoc() != DocsEnum.NO_MORE_DOCS) {
+        total_tf += de.freq();
+      }
+      tfiq.insertWithOverflow(new TermInfoWithTotalTF(terms[i].term,
+          terms[i].docFreq, total_tf));
+    }
+    
+    TermInfoWithTotalTF[] result = new TermInfoWithTotalTF[tfiq.size()];
+    int count = tfiq.size() - 1;
+    while (tfiq.size() != 0) {
+      result[count] = tfiq.pop();
+      count--;
+    }
+    return result;
+  }
+  
+  private static void usage() {
+    System.out
+        .println("\n\n"
+            + "java org.apache.lucene.misc.HighFreqTerms <index dir> [number_terms | number_terms field]\n\n");
+  }
+}
+
+/**
+ * Priority queue for TermInfoWiTF objects ordered by TermInfoWiTF.docFreq
+ **/
+final class TermInfoWiTFQueue extends PriorityQueue<TermInfoWithTotalTF> {
+  TermInfoWiTFQueue(int size) {
+    initialize(size);
+  }
+  
+  @Override
+  protected final boolean lessThan(TermInfoWithTotalTF termInfoA,
+      TermInfoWithTotalTF termInfoB) {
+    return termInfoA.docFreq < termInfoB.docFreq;
+  }
+}
+
+/**
+ * Priority queue for TermInfoWiTF objects ordered by TermInfoWiTF.termFreq
+ */
+final class TermFreqInfoWiTFQueue extends PriorityQueue<TermInfoWithTotalTF> {
+  TermFreqInfoWiTFQueue(int size) {
+    initialize(size);
+  }
+  
+  @Override
+  protected final boolean lessThan(TermInfoWithTotalTF termInfoA,
+      TermInfoWithTotalTF termInfoB) {
+    return termInfoA.termFreq < termInfoB.termFreq;
+  }
+}

Property changes on: contrib/misc/src/java/org/apache/lucene/misc/HighFreqTermsWithTF.java
___________________________________________________________________
Added: svn:executable
   + *

