From 3eea1869364856218bc6d0f22e901b23c378a9be Mon Sep 17 00:00:00 2001
From: Namgyu Kim <kng0828@gmail.com>
Date: Fri, 2 Nov 2018 01:13:25 +0900
Subject: [PATCH] LUCENE-8553: New KoreanDecomposeFilter for
 KoreanAnalyzer(Nori)

Signed-off-by: Namgyu Kim <kng0828@gmail.com>
---
 .../lucene/analysis/ko/DecomposeOption.java   |  55 ++++++
 .../lucene/analysis/ko/KoreanAnalyzer.java    |  16 ++
 .../analysis/ko/KoreanDecomposeFilter.java    |  67 +++++++
 .../ko/KoreanDecomposeFilterFactory.java      |  72 +++++++
 .../lucene/analysis/ko/util/HangulUtil.java   | 179 ++++++++++++++++++
 .../analysis/ko/TestKoreanAnalyzer.java       |  59 +++++-
 .../ko/TestKoreanDecomposeFilterFactory.java  | 124 ++++++++++++
 .../analysis/ko/util/TestHangulUtil.java      |  59 ++++++
 8 files changed, 630 insertions(+), 1 deletion(-)
 create mode 100644 lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/DecomposeOption.java
 create mode 100644 lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanDecomposeFilter.java
 create mode 100644 lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanDecomposeFilterFactory.java
 create mode 100644 lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/util/HangulUtil.java
 create mode 100644 lucene/analysis/nori/src/test/org/apache/lucene/analysis/ko/TestKoreanDecomposeFilterFactory.java
 create mode 100644 lucene/analysis/nori/src/test/org/apache/lucene/analysis/ko/util/TestHangulUtil.java

diff --git a/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/DecomposeOption.java b/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/DecomposeOption.java
new file mode 100644
index 0000000000..7f7a42259f
--- /dev/null
+++ b/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/DecomposeOption.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.analysis.ko;
+
+/**
+ * Decompose options that use in {@link KoreanDecomposeFilter}
+ * @lucene.experimental
+ */
+public enum DecomposeOption {
+
+  /**
+   * Keep original Hangul char.
+   * EXAMPLE: "된장찌개" -> "된장찌개"
+   */
+  ORIGIN,
+
+  /**
+   * Keep only Choseong Hangul char.
+   * EXAMPLE: "된장찌개" -> "ㄷㅈㅉㄱ"
+   */
+  SINGLECHOSEONG,
+
+  /**
+   * Keep only Choseong Hangul char. (decompose dual char)
+   * EXAMPLE: "된장찌개" -> "ㄷㅈㅈㅈㄱ"
+   */
+  DUALCHOSEONG,
+
+  /**
+   * Keep Choseong, Jungseong and Jongseong after decompose
+   * EXAMPLE: "된장찌개" -> "ㄷㅚㄴㅈㅏㅇㅉㅣㄱㅐ"
+   */
+  SINGLEJAMO,
+
+  /**
+   * Keep Choseong, Jungseong and Jongseong after decompose (decompose dual char)
+   * EXAMPLE: "된장찌개" -> "ㄷㅗㅣㄴㅈㅏㅇㅈㅈㅣㄱㅏㅣ"
+   */
+  DUALJAMO
+}
diff --git a/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanAnalyzer.java b/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanAnalyzer.java
index 76023bbe8f..53a1b41942 100644
--- a/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanAnalyzer.java
+++ b/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanAnalyzer.java
@@ -37,6 +37,7 @@ public class KoreanAnalyzer extends Analyzer {
   private final KoreanTokenizer.DecompoundMode mode;
   private final Set<POS.Tag> stopTags;
   private final boolean outputUnknownUnigrams;
+  private final DecomposeOption decomposeOption;
 
   /**
    * Creates a new KoreanAnalyzer.
@@ -54,11 +55,25 @@ public class KoreanAnalyzer extends Analyzer {
    * @param outputUnknownUnigrams If true outputs unigrams for unknown words.
    */
   public KoreanAnalyzer(UserDictionary userDict, DecompoundMode mode, Set<POS.Tag> stopTags, boolean outputUnknownUnigrams) {
+    this(userDict, mode, stopTags, outputUnknownUnigrams, DecomposeOption.ORIGIN);
+  }
+
+  /**
+   * Creates a new KoreanAnalyzer.
+   *
+   * @param userDict Optional: if non-null, user dictionary.
+   * @param mode Decompound mode.
+   * @param stopTags The set of part of speech that should be filtered.
+   * @param outputUnknownUnigrams If true outputs unigrams for unknown words.
+   * @param decomposeOption the {@link DecomposeOption} option.
+   */
+  public KoreanAnalyzer(UserDictionary userDict, DecompoundMode mode, Set<POS.Tag> stopTags, boolean outputUnknownUnigrams, DecomposeOption decomposeOption) {
     super();
     this.userDict = userDict;
     this.mode = mode;
     this.stopTags = stopTags;
     this.outputUnknownUnigrams = outputUnknownUnigrams;
+    this.decomposeOption = decomposeOption;
   }
   
   @Override
@@ -67,6 +82,7 @@ public class KoreanAnalyzer extends Analyzer {
     TokenStream stream = new KoreanPartOfSpeechStopFilter(tokenizer, stopTags);
     stream = new KoreanReadingFormFilter(stream);
     stream = new LowerCaseFilter(stream);
+    stream = new KoreanDecomposeFilter(stream, decomposeOption);
     return new TokenStreamComponents(tokenizer, stream);
   }
 
diff --git a/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanDecomposeFilter.java b/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanDecomposeFilter.java
new file mode 100644
index 0000000000..ca89e51d06
--- /dev/null
+++ b/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanDecomposeFilter.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.analysis.ko;
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.TokenFilter;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.ko.util.HangulUtil;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+
+/**
+ * Convert Hangul characters to Choseong or Jamo
+ * by using {@link DecomposeOption}.
+ * @lucene.experimental
+ */
+public final class KoreanDecomposeFilter extends TokenFilter {
+  private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+  private final DecomposeOption decomposeOption;
+
+  /**
+   * Create a new {@link KoreanDecomposeFilter} with the default
+   * origin option {@link DecomposeOption#ORIGIN}.
+   *
+   * @param input    the {@link TokenStream}
+   */
+  public KoreanDecomposeFilter(TokenStream input) {
+    this(input, DecomposeOption.ORIGIN);
+  }
+
+  /**
+   * Create a new {@link KoreanDecomposeFilter}.
+   * @param input    the {@link TokenStream}
+   * @param option   the {@link DecomposeOption} option to be used
+   */
+  public KoreanDecomposeFilter(TokenStream input, DecomposeOption option) {
+    super(input);
+    this.decomposeOption = option;
+  }
+
+  @Override
+  public boolean incrementToken() throws IOException {
+    if (input.incrementToken()) {
+      char[] input = termAtt.toString().toCharArray();
+      String token = HangulUtil.decomposeHangul(input, decomposeOption);
+      termAtt.setEmpty().append(token);
+      return true;
+    } else {
+      return false;
+    }
+  }
+}
diff --git a/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanDecomposeFilterFactory.java b/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanDecomposeFilterFactory.java
new file mode 100644
index 0000000000..d21554b6a2
--- /dev/null
+++ b/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/KoreanDecomposeFilterFactory.java
@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.analysis.ko;
+
+import java.util.Map;
+
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.util.TokenFilterFactory;
+
+/**
+ * Factory for {@link KoreanDecomposeFilter}.
+ * <pre class="prettyprint">
+ * &lt;fieldType name="text_ko" class="solr.TextField"&gt;
+ *   &lt;analyzer&gt;
+ *     &lt;tokenizer class="solr.KoreanTokenizerFactory"/&gt;
+ *     &lt;filter class="solr.KoreanDecomposeFilterFactory"
+ *  *              option="SINGLECHOSEONG"/&gt;
+ *   &lt;/analyzer&gt;
+ * &lt;/fieldType&gt;
+ * </pre>
+ * @lucene.experimental
+ */
+public class KoreanDecomposeFilterFactory extends TokenFilterFactory {
+  private DecomposeOption decomposeOption;
+
+  /** Creates a new {@link KoreanDecomposeFilterFactory} */
+  public KoreanDecomposeFilterFactory(Map<String,String> args) {
+    super(args);
+    String option = get(args, "decomposeOption");
+    if (option != null) {
+      switch (option) {
+        case "ORIGIN":
+          decomposeOption = DecomposeOption.ORIGIN;
+          break;
+        case "SINGLECHOSEONG":
+          decomposeOption = DecomposeOption.SINGLECHOSEONG;
+          break;
+        case "DUALCHOSEONG":
+          decomposeOption = DecomposeOption.DUALCHOSEONG;
+          break;
+        case "SINGLEJAMO":
+          decomposeOption = DecomposeOption.SINGLEJAMO;
+          break;
+        case "DUALJAMO":
+          decomposeOption = DecomposeOption.DUALJAMO;
+          break;
+      }
+    }
+    if (!args.isEmpty()) {
+      throw new IllegalArgumentException("Unknown parameters: " + args);
+    }
+  }
+  
+  @Override
+  public TokenStream create(TokenStream input) {
+    return new KoreanDecomposeFilter(input, decomposeOption);
+  }
+}
diff --git a/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/util/HangulUtil.java b/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/util/HangulUtil.java
new file mode 100644
index 0000000000..6017f94d24
--- /dev/null
+++ b/lucene/analysis/nori/src/java/org/apache/lucene/analysis/ko/util/HangulUtil.java
@@ -0,0 +1,179 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.analysis.ko.util;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.lucene.analysis.ko.DecomposeOption;
+
+/**
+ * Utility class for decompose Hangul text
+ */
+public final class HangulUtil {
+  private static int hangulStart = 0xAC00;
+  private static int hangulEnd = 0xD7AF;
+
+  private static final char[] CHOSEONG =
+      { 'ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ',
+        'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'};
+  private static final char[] JUNGSEONG =
+      { 'ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ',
+        'ㅙ', 'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'};
+  private static final char[] JONGSEONG =
+      { 0, 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ',
+           'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ',
+           'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'};
+  // Hangul dual char map
+  private static final Map<Character, String> DUALMAP = new HashMap<>();
+
+  static {
+    char[] dualChar =
+        { 'ㄲ', 'ㄸ', 'ㅃ', 'ㅆ', 'ㅉ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅝ', 'ㅞ',
+          'ㅟ', 'ㅢ', 'ㄳ', 'ㄵ', 'ㄶ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ',
+          'ㄿ', 'ㅀ', 'ㅄ'};
+
+    String[] dualString =
+        { "ㄱㄱ", "ㄷㄷ", "ㅂㅂ", "ㅅㅅ", "ㅈㅈ", "ㅗㅏ", "ㅗㅐ", "ㅗㅣ", "ㅜㅓ", "ㅜㅔ",
+          "ㅜㅣ", "ㅡㅣ", "ㄱㅅ", "ㄴㅈ", "ㄴㅎ", "ㄹㄱ", "ㄹㅁ", "ㄹㅂ", "ㄹㅅ", "ㄹㅌ",
+          "ㄹㅍ", "ㄹㅎ", "ㅂㅅ"};
+
+    for (int i = 0; i < dualChar.length; i++)
+      DUALMAP.put(dualChar[i], dualString[i]);
+
+  }
+
+  /**
+   * Decompose Hangul by using {@link DecomposeOption}.
+   * @param buffer buffer to be decomposed
+   * @param option the {@link DecomposeOption}
+   * @return converted String
+   */
+  public static String decomposeHangul(char[] buffer, DecomposeOption option) {
+    String result;
+    switch (option) {
+      case SINGLECHOSEONG:
+        result = getSingleChoseong(buffer);
+        break;
+      case DUALCHOSEONG:
+        result = getDualChoseong(buffer);
+        break;
+      case SINGLEJAMO:
+        result = getSingleJamo(buffer);
+        break;
+      case DUALJAMO:
+        result = getDualJamo(buffer);
+        break;
+      default:
+        result = String.copyValueOf(buffer);
+        break;
+    }
+    return result;
+  }
+
+  // Get Choseong char from buffer.
+  private static String getSingleChoseong(char[] buffer) {
+    StringBuilder builder = new StringBuilder();
+    for (int i = 0; i < buffer.length; i++) {
+      if (buffer[i] >= hangulStart && buffer[i] <= hangulEnd) {
+        int unicodeVal = buffer[i] - hangulStart;
+        int jongseongIdx = unicodeVal % 28;
+        int choseongIdx = ((unicodeVal - jongseongIdx) / JUNGSEONG.length) / JONGSEONG.length;
+        builder.append(CHOSEONG[choseongIdx]);
+      } else {
+        builder.append(buffer[i]);
+      }
+    }
+    return builder.toString();
+  }
+
+  // Get Choseong char from buffer. (if dual char exists, decompose)
+  private static String getDualChoseong(char[] buffer) {
+    StringBuilder builder = new StringBuilder();
+    for (int i = 0; i < buffer.length; i++) {
+      if (buffer[i] >= hangulStart && buffer[i] <= hangulEnd) {
+        int unicodeVal = buffer[i] - hangulStart;
+        int jongseongIdx = unicodeVal % 28;
+        int choseongIdx = ((unicodeVal - jongseongIdx) / JUNGSEONG.length) / JONGSEONG.length;
+        if (DUALMAP.containsKey(CHOSEONG[choseongIdx]))
+          builder.append(DUALMAP.get(CHOSEONG[choseongIdx]));
+        else
+          builder.append(CHOSEONG[choseongIdx]);
+      } else {
+        builder.append(buffer[i]);
+      }
+    }
+    return builder.toString();
+  }
+
+  // Get Jamo from buffer.
+  private static String getSingleJamo(char[] buffer) {
+    StringBuilder builder = new StringBuilder();
+    for (int i = 0; i < buffer.length; i++) {
+      if (buffer[i] >= hangulStart && buffer[i] <= hangulEnd) {
+        int unicodeVal = buffer[i] - hangulStart;
+        int jongseongIdx = unicodeVal % JONGSEONG.length;
+        int choseongIdx = ((unicodeVal - jongseongIdx) / JONGSEONG.length) / JUNGSEONG.length;
+        int jungseongIdx = ((unicodeVal - jongseongIdx) / JONGSEONG.length) % JUNGSEONG.length;
+        builder.append(CHOSEONG[choseongIdx]).append(JUNGSEONG[jungseongIdx]);
+        if (jongseongIdx != 0)
+          builder.append(JONGSEONG[jongseongIdx]);
+      } else {
+        builder.append(buffer[i]);
+      }
+    }
+    return builder.toString();
+  }
+
+  // Get Jamo from buffer. (if dual char exists, decompose)
+  private static String getDualJamo(char[] buffer) {
+    StringBuilder builder = new StringBuilder();
+    for (int i = 0; i < buffer.length; i++) {
+      if (buffer[i] >= hangulStart && buffer[i] <= hangulEnd) {
+        int unicodeVal = buffer[i] - hangulStart;
+        int jongseongIdx = unicodeVal % JONGSEONG.length;
+        int choseongIdx = ((unicodeVal - jongseongIdx) / JONGSEONG.length) / JUNGSEONG.length;
+        int jungseongIdx = ((unicodeVal - jongseongIdx) / JONGSEONG.length) % JUNGSEONG.length;
+
+        char choseongChar = CHOSEONG[choseongIdx];
+        char jungseongChar = JUNGSEONG[jungseongIdx];
+        char jongseongChar = JONGSEONG[jongseongIdx];
+
+        if (DUALMAP.containsKey(choseongChar))
+          builder.append(DUALMAP.get(choseongChar));
+        else
+          builder.append(choseongChar);
+
+        if (DUALMAP.containsKey(jungseongChar))
+          builder.append(DUALMAP.get(jungseongChar));
+        else
+          builder.append(jungseongChar);
+
+        if (jongseongIdx != 0) {
+          if (DUALMAP.containsKey(jongseongChar))
+            builder.append(DUALMAP.get(jongseongChar));
+          else
+            builder.append(jongseongChar);
+        }
+      } else {
+        builder.append(buffer[i]);
+      }
+    }
+    return builder.toString();
+  }
+}
\ No newline at end of file
diff --git a/lucene/analysis/nori/src/test/org/apache/lucene/analysis/ko/TestKoreanAnalyzer.java b/lucene/analysis/nori/src/test/org/apache/lucene/analysis/ko/TestKoreanAnalyzer.java
index fd574cede4..6f44aeacbd 100644
--- a/lucene/analysis/nori/src/test/org/apache/lucene/analysis/ko/TestKoreanAnalyzer.java
+++ b/lucene/analysis/nori/src/test/org/apache/lucene/analysis/ko/TestKoreanAnalyzer.java
@@ -106,4 +106,61 @@ public class TestKoreanAnalyzer extends BaseTokenStreamTestCase {
         new int[]{1, 1, 1}
     );
   }
-}
\ No newline at end of file
+
+  // Korean Decompose Filter ORIGIN option test.
+  public void testDecompose_Origin() throws IOException {
+    final Analyzer analyzer = new KoreanAnalyzer(null,
+        KoreanTokenizer.DEFAULT_DECOMPOUND, KoreanPartOfSpeechStopFilter.DEFAULT_STOP_TAGS, false, DecomposeOption.ORIGIN);
+    assertAnalyzesTo(analyzer, "된장찌개",
+        new String[]{"된장", "찌개"},
+        new int[]{0, 2},
+        new int[]{2, 4},
+        new int[]{1, 1}
+    );
+  }
+
+  // Korean Decompose Filter SINGLECHOSEONG option test.
+  public void testDecompose_SingleChoseong() throws IOException {
+    final Analyzer analyzer = new KoreanAnalyzer(null,
+        KoreanTokenizer.DEFAULT_DECOMPOUND, KoreanPartOfSpeechStopFilter.DEFAULT_STOP_TAGS, false, DecomposeOption.SINGLECHOSEONG);
+    assertAnalyzesTo(analyzer, "된장찌개",
+        new String[]{"ㄷㅈ", "ㅉㄱ"},
+        new int[]{0, 2},
+        new int[]{2, 4},
+        new int[]{1, 1}
+    );
+  }
+
+  public void testDecompose_DualChoseong() throws IOException {
+    final Analyzer analyzer = new KoreanAnalyzer(null,
+        KoreanTokenizer.DEFAULT_DECOMPOUND, KoreanPartOfSpeechStopFilter.DEFAULT_STOP_TAGS, false, DecomposeOption.DUALCHOSEONG);
+    assertAnalyzesTo(analyzer, "된장찌개",
+        new String[]{"ㄷㅈ", "ㅈㅈㄱ"},
+        new int[]{0, 2},
+        new int[]{2, 4},
+        new int[]{1, 1}
+    );
+  }
+
+  public void testDecompose_SingleJamo() throws IOException {
+    final Analyzer analyzer = new KoreanAnalyzer(null,
+        KoreanTokenizer.DEFAULT_DECOMPOUND, KoreanPartOfSpeechStopFilter.DEFAULT_STOP_TAGS, false, DecomposeOption.SINGLEJAMO);
+    assertAnalyzesTo(analyzer, "된장찌개",
+        new String[]{"ㄷㅚㄴㅈㅏㅇ", "ㅉㅣㄱㅐ"},
+        new int[]{0, 2},
+        new int[]{2, 4},
+        new int[]{1, 1}
+    );
+  }
+
+  public void testDecompose_DualJamo() throws IOException {
+    final Analyzer analyzer = new KoreanAnalyzer(null,
+        KoreanTokenizer.DEFAULT_DECOMPOUND, KoreanPartOfSpeechStopFilter.DEFAULT_STOP_TAGS, false, DecomposeOption.DUALJAMO);
+    assertAnalyzesTo(analyzer, "된장찌개",
+        new String[]{"ㄷㅗㅣㄴㅈㅏㅇ", "ㅈㅈㅣㄱㅐ"},
+        new int[]{0, 2},
+        new int[]{2, 4},
+        new int[]{1, 1}
+    );
+  }
+}
diff --git a/lucene/analysis/nori/src/test/org/apache/lucene/analysis/ko/TestKoreanDecomposeFilterFactory.java b/lucene/analysis/nori/src/test/org/apache/lucene/analysis/ko/TestKoreanDecomposeFilterFactory.java
new file mode 100644
index 0000000000..400dfe8d3c
--- /dev/null
+++ b/lucene/analysis/nori/src/test/org/apache/lucene/analysis/ko/TestKoreanDecomposeFilterFactory.java
@@ -0,0 +1,124 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.analysis.ko;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.lucene.analysis.BaseTokenStreamTestCase;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.Tokenizer;
+import org.apache.lucene.util.Version;
+
+/**
+ * Simple tests for {@link KoreanDecomposeFilterFactory}
+ */
+public class TestKoreanDecomposeFilterFactory extends BaseTokenStreamTestCase {
+
+  // Origin
+  public void testOriginOption() throws IOException {
+    KoreanTokenizerFactory tokenizerFactory = new KoreanTokenizerFactory(new HashMap<>());
+    tokenizerFactory.inform(new StringMockResourceLoader(""));
+    TokenStream ts = tokenizerFactory.create();
+    ((Tokenizer)ts).setReader(new StringReader("된장찌개"));
+    Map<String,String> args = new HashMap<>();
+    args.put("luceneMatchVersion", Version.LATEST.toString());
+    args.put("decomposeOption", "ORIGIN");
+    KoreanDecomposeFilterFactory factory = new KoreanDecomposeFilterFactory(args);
+    ts = factory.create(ts);
+    assertTokenStreamContents(ts,
+        new String[] { "된장", "찌개" }
+    );
+  }
+
+  // Single Choseong
+  public void testSingleChoseongOption() throws IOException {
+    KoreanTokenizerFactory tokenizerFactory = new KoreanTokenizerFactory(new HashMap<>());
+    tokenizerFactory.inform(new StringMockResourceLoader(""));
+    TokenStream ts = tokenizerFactory.create();
+    ((Tokenizer)ts).setReader(new StringReader("된장찌개"));
+    Map<String,String> args = new HashMap<>();
+    args.put("luceneMatchVersion", Version.LATEST.toString());
+    args.put("decomposeOption", "SINGLECHOSEONG");
+    KoreanDecomposeFilterFactory factory = new KoreanDecomposeFilterFactory(args);
+    ts = factory.create(ts);
+    assertTokenStreamContents(ts,
+        new String[] { "ㄷㅈ", "ㅉㄱ" }
+    );
+  }
+
+  // Dual Choseong
+  public void testDualChoseongOption() throws IOException {
+    KoreanTokenizerFactory tokenizerFactory = new KoreanTokenizerFactory(new HashMap<String,String>());
+    tokenizerFactory.inform(new StringMockResourceLoader(""));
+    TokenStream ts = tokenizerFactory.create();
+    ((Tokenizer)ts).setReader(new StringReader("된장찌개"));
+    Map<String,String> args = new HashMap<>();
+    args.put("luceneMatchVersion", Version.LATEST.toString());
+    args.put("decomposeOption", "DUALCHOSEONG");
+    KoreanDecomposeFilterFactory factory = new KoreanDecomposeFilterFactory(args);
+    ts = factory.create(ts);
+    assertTokenStreamContents(ts,
+        new String[] { "ㄷㅈ", "ㅈㅈㄱ" }
+    );
+  }
+
+  // Single Jamo
+  public void testSingleJamoOption() throws IOException {
+    KoreanTokenizerFactory tokenizerFactory = new KoreanTokenizerFactory(new HashMap<String,String>());
+    tokenizerFactory.inform(new StringMockResourceLoader(""));
+    TokenStream ts = tokenizerFactory.create();
+    ((Tokenizer)ts).setReader(new StringReader("된장찌개"));
+    Map<String,String> args = new HashMap<>();
+    args.put("luceneMatchVersion", Version.LATEST.toString());
+    args.put("decomposeOption", "SINGLEJAMO");
+    KoreanDecomposeFilterFactory factory = new KoreanDecomposeFilterFactory(args);
+    ts = factory.create(ts);
+    assertTokenStreamContents(ts,
+        new String[] { "ㄷㅚㄴㅈㅏㅇ", "ㅉㅣㄱㅐ" }
+    );
+  }
+
+  // Dual Jamo
+  public void testDualJamoOption() throws IOException {
+    KoreanTokenizerFactory tokenizerFactory = new KoreanTokenizerFactory(new HashMap<String,String>());
+    tokenizerFactory.inform(new StringMockResourceLoader(""));
+    TokenStream ts = tokenizerFactory.create();
+    ((Tokenizer)ts).setReader(new StringReader("된장찌개"));
+    Map<String,String> args = new HashMap<>();
+    args.put("luceneMatchVersion", Version.LATEST.toString());
+    args.put("decomposeOption", "DUALJAMO");
+    KoreanDecomposeFilterFactory factory = new KoreanDecomposeFilterFactory(args);
+    ts = factory.create(ts);
+    assertTokenStreamContents(ts,
+        new String[] { "ㄷㅗㅣㄴㅈㅏㅇ", "ㅈㅈㅣㄱㅐ" }
+    );
+  }
+
+  /** Test that bogus arguments result in exception */
+  public void testBogusArguments() throws Exception {
+    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
+      new KoreanDecomposeFilterFactory(new HashMap<String,String>() {{
+        put("luceneMatchVersion", Version.LATEST.toString());
+        put("bogusArg", "bogusValue");
+      }});
+    });
+    assertTrue(expected.getMessage().contains("Unknown parameters"));
+  }
+}
diff --git a/lucene/analysis/nori/src/test/org/apache/lucene/analysis/ko/util/TestHangulUtil.java b/lucene/analysis/nori/src/test/org/apache/lucene/analysis/ko/util/TestHangulUtil.java
new file mode 100644
index 0000000000..f0649604f8
--- /dev/null
+++ b/lucene/analysis/nori/src/test/org/apache/lucene/analysis/ko/util/TestHangulUtil.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.analysis.ko.util;
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.ko.DecomposeOption;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class TestHangulUtil {
+
+  // Test getSingleChoseong method.
+  @Test
+  public void testGetSingleChoseong() throws IOException {
+    char[] input = "된장찌개".toCharArray();
+    String answer = HangulUtil.decomposeHangul(input, DecomposeOption.SINGLECHOSEONG);
+    Assert.assertEquals(answer, "ㄷㅈㅉㄱ");
+  }
+
+  // Test getDualChoseong method.
+  @Test
+  public void testGetDualChoseong() throws IOException {
+    char[] input = "된장찌개".toCharArray();
+    String answer = HangulUtil.decomposeHangul(input, DecomposeOption.DUALCHOSEONG);
+    Assert.assertEquals(answer, "ㄷㅈㅈㅈㄱ");
+  }
+
+  // Test getSingleJamo method.
+  @Test
+  public void testGetSingleJamo() throws IOException {
+    char[] input = "된장찌개".toCharArray();
+    String answer = HangulUtil.decomposeHangul(input, DecomposeOption.SINGLEJAMO);
+    Assert.assertEquals(answer, "ㄷㅚㄴㅈㅏㅇㅉㅣㄱㅐ");
+  }
+
+  // Test getDualJamo method.
+  @Test
+  public void testGetDualJamo() throws IOException {
+    char[] input = "된장찌개".toCharArray();
+    String answer = HangulUtil.decomposeHangul(input, DecomposeOption.DUALJAMO);
+    Assert.assertEquals(answer, "ㄷㅗㅣㄴㅈㅏㅇㅈㅈㅣㄱㅐ");
+  }
+}
-- 
2.18.0.windows.1

