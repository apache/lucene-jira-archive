diff --git a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
index 6d2f65c..0434e0f 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
@@ -50,28 +50,32 @@ final class DisjunctionMaxScorer extends DisjunctionScorer {
       throw new IllegalArgumentException("tieBreakerMultiplier must be in [0, 1]");
     }
 
-    float scoreMax = 0;
-    double otherScoreSum = 0;
-    for (Scorer scorer : subScorers) {
-      scorer.advanceShallow(0);
-      float subScore = scorer.getMaxScore(DocIdSetIterator.NO_MORE_DOCS);
-      if (subScore >= scoreMax) {
-        otherScoreSum += scoreMax;
-        scoreMax = subScore;
-      } else {
-        otherScoreSum += subScore;
+    if (needsScores == false) {
+      this.maxScore = Float.MAX_VALUE;
+    } else {
+      float scoreMax = 0;
+      double otherScoreSum = 0;
+      for (Scorer scorer : subScorers) {
+        scorer.advanceShallow(0);
+        float subScore = scorer.getMaxScore(DocIdSetIterator.NO_MORE_DOCS);
+        if (subScore >= scoreMax) {
+          otherScoreSum += scoreMax;
+          scoreMax = subScore;
+        } else {
+          otherScoreSum += subScore;
+        }
       }
-    }
 
-    if (tieBreakerMultiplier == 0) {
-      this.maxScore = scoreMax;
-    } else {
-      // The error of sums depends on the order in which values are summed up. In
-      // order to avoid this issue, we compute an upper bound of the value that
-      // the sum may take. If the max relative error is b, then it means that two
-      // sums are always within 2*b of each other.
-      otherScoreSum *= (1 + 2 * MathUtil.sumRelativeErrorBound(subScorers.size() - 1));
-      this.maxScore = (float) (scoreMax + otherScoreSum * tieBreakerMultiplier);
+      if (tieBreakerMultiplier == 0) {
+        this.maxScore = scoreMax;
+      } else {
+        // The error of sums depends on the order in which values are summed up. In
+        // order to avoid this issue, we compute an upper bound of the value that
+        // the sum may take. If the max relative error is b, then it means that two
+        // sums are always within 2*b of each other.
+        otherScoreSum *= (1 + 2 * MathUtil.sumRelativeErrorBound(subScorers.size() - 1));
+        this.maxScore = (float) (scoreMax + otherScoreSum * tieBreakerMultiplier);
+      }
     }
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisjunctionSumScorer.java b/lucene/core/src/java/org/apache/lucene/search/DisjunctionSumScorer.java
index 4f45b07..06e8c4a 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisjunctionSumScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisjunctionSumScorer.java
@@ -20,31 +20,16 @@ package org.apache.lucene.search;
 import java.io.IOException;
 import java.util.List;
 
-import org.apache.lucene.util.MathUtil;
-
 /** A Scorer for OR like queries, counterpart of <code>ConjunctionScorer</code>.
  */
 final class DisjunctionSumScorer extends DisjunctionScorer {
 
-  private final float maxScore;
-
   /** Construct a <code>DisjunctionScorer</code>.
    * @param weight The weight to be used.
    * @param subScorers Array of at least two subscorers.
    */
   DisjunctionSumScorer(Weight weight, List<Scorer> subScorers, boolean needsScores) throws IOException {
     super(weight, subScorers, needsScores);
-    double maxScore = 0;
-    for (Scorer scorer : subScorers) {
-      scorer.advanceShallow(0);
-      maxScore += scorer.getMaxScore(DocIdSetIterator.NO_MORE_DOCS);
-    }
-    // The error of sums depends on the order in which values are summed up. In
-    // order to avoid this issue, we compute an upper bound of the value that
-    // the sum may take. If the max relative error is b, then it means that two
-    // sums are always within 2*b of each other.
-    double maxScoreRelativeErrorBound = MathUtil.sumRelativeErrorBound(subScorers.size());
-    this.maxScore = (float) ((1.0 + 2 * maxScoreRelativeErrorBound) * maxScore);
   }
 
   @Override
@@ -59,7 +44,9 @@ final class DisjunctionSumScorer extends DisjunctionScorer {
 
   @Override
   public float getMaxScore(int upTo) throws IOException {
-    return maxScore;
+    // It's ok to return a bad upper bound here since we use WANDScorer when
+    // we actually care about block scores.
+    return Float.MAX_VALUE;
   }
 
 }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java b/lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java
index a8c32cf..41bc13c 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java
@@ -76,6 +76,7 @@ public class AssertingScorer extends Scorer {
 
   @Override
   public int advanceShallow(int target) throws IOException {
+    assert scoreMode.needsScores();
     assert target >= lastShallowTarget : "called on decreasing targets: target = " + target + " < last target = " + lastShallowTarget;
     assert target >= docID() : "target = " + target + " < docID = " + docID();
     int upTo = in.advanceShallow(target);
@@ -87,6 +88,7 @@ public class AssertingScorer extends Scorer {
 
   @Override
   public float getMaxScore(int upTo) throws IOException {
+    assert scoreMode.needsScores();
     assert upTo >= lastShallowTarget : "uTo = " + upTo + " < last target = " + lastShallowTarget;
     assert docID() >= 0 || lastShallowTarget >= 0 : "Cannot get max scores until the iterator is positioned or advanceShallow has been called";
     float maxScore = in.getMaxScore(upTo);
