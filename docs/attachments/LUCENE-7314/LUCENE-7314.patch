diff --git a/lucene/CHANGES.txt b/lucene/CHANGES.txt
index 477f261075..47d5d3ef94 100644
--- a/lucene/CHANGES.txt
+++ b/lucene/CHANGES.txt
@@ -118,6 +118,10 @@ Bug Fixes:
    via LUCENE-8165 since we are now checking for offset+length going out of bounds.
    (Robert Muir, Nhat Nyugen, Simon Willnauer)
 
+API Changes
+
+* LUCENE-7314: Graduate LatLonPoint and query classes to core (Nick Knize)
+
 Changes in Runtime Behavior:
 
 * LUCENE-7976: TieredMergePolicy now respects maxSegmentSizeMB by default when executing
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonDocValuesBoxQuery.java b/lucene/core/src/java/org/apache/lucene/document/LatLonDocValuesBoxQuery.java
similarity index 100%
rename from lucene/sandbox/src/java/org/apache/lucene/document/LatLonDocValuesBoxQuery.java
rename to lucene/core/src/java/org/apache/lucene/document/LatLonDocValuesBoxQuery.java
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonDocValuesDistanceQuery.java b/lucene/core/src/java/org/apache/lucene/document/LatLonDocValuesDistanceQuery.java
similarity index 100%
rename from lucene/sandbox/src/java/org/apache/lucene/document/LatLonDocValuesDistanceQuery.java
rename to lucene/core/src/java/org/apache/lucene/document/LatLonDocValuesDistanceQuery.java
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonDocValuesField.java b/lucene/core/src/java/org/apache/lucene/document/LatLonDocValuesField.java
similarity index 98%
rename from lucene/sandbox/src/java/org/apache/lucene/document/LatLonDocValuesField.java
rename to lucene/core/src/java/org/apache/lucene/document/LatLonDocValuesField.java
index 6bcc3942a6..8acfbeaab6 100644
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint.java b/lucene/core/src/java/org/apache/lucene/document/LatLonPoint.java
similarity index 73%
rename from lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint.java
rename to lucene/core/src/java/org/apache/lucene/document/LatLonPoint.java
index 1e5e4bd9dc..c609228a1b 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/LatLonPoint.java
@@ -16,31 +16,17 @@
  */
 package org.apache.lucene.document;
 
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.lucene.codecs.lucene60.Lucene60PointsFormat;
-import org.apache.lucene.geo.GeoUtils;
 import org.apache.lucene.geo.Polygon;
 import org.apache.lucene.index.FieldInfo;
-import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.PointValues;
 import org.apache.lucene.search.BooleanClause;
 import org.apache.lucene.search.BooleanQuery;
 import org.apache.lucene.search.ConstantScoreQuery;
-import org.apache.lucene.search.FieldDoc;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.MatchAllDocsQuery;
 import org.apache.lucene.search.MatchNoDocsQuery;
 import org.apache.lucene.search.PointRangeQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.ScoreDoc;
-import org.apache.lucene.search.TopFieldDocs;
-import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.NumericUtils;
-import org.apache.lucene.util.bkd.BKDReader;
 
 import static org.apache.lucene.geo.GeoEncodingUtils.decodeLatitude;
 import static org.apache.lucene.geo.GeoEncodingUtils.decodeLongitude;
@@ -61,7 +47,6 @@ import static org.apache.lucene.geo.GeoEncodingUtils.encodeLongitudeCeil;
  *   <li>{@link #newBoxQuery newBoxQuery()} for matching points within a bounding box.
  *   <li>{@link #newDistanceQuery newDistanceQuery()} for matching points within a specified distance.
  *   <li>{@link #newPolygonQuery newPolygonQuery()} for matching points within an arbitrary polygon.
- *   <li>{@link #nearest nearest()} for finding the k-nearest neighbors by distance.
  * </ul>
  * <p>
  * If you also need per-document operations such as sort by distance, add a separate {@link LatLonDocValuesField} instance.
@@ -267,69 +252,4 @@ public class LatLonPoint extends Field {
     return new LatLonPointInPolygonQuery(field, polygons);
   }
 
-  /**
-   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.
-   * <p>
-   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},
-   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this
-   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are
-   * currently not de-duplicated, so if a document had multiple instances of the specified field that
-   * make it into the top n, that document will appear more than once.
-   * <p>
-   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for
-   * the hits contains a Double instance with the distance in meters.
-   * 
-   * @param searcher IndexSearcher to find nearest points from.
-   * @param field field name. must not be null.
-   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.
-   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.
-   * @param n the number of nearest neighbors to retrieve.
-   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters
-   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or
-   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds
-   * @throws IOException if an IOException occurs while finding the points.
-   */
-  // TODO: what about multi-valued documents? what happens?
-  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {
-    GeoUtils.checkLatitude(latitude);
-    GeoUtils.checkLongitude(longitude);
-    if (n < 1) {
-      throw new IllegalArgumentException("n must be at least 1; got " + n);
-    }
-    if (field == null) {
-      throw new IllegalArgumentException("field must not be null");
-    }
-    if (searcher == null) {
-      throw new IllegalArgumentException("searcher must not be null");
-    }
-    List<BKDReader> readers = new ArrayList<>();
-    List<Integer> docBases = new ArrayList<>();
-    List<Bits> liveDocs = new ArrayList<>();
-    int totalHits = 0;
-    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {
-      PointValues points = leaf.reader().getPointValues(field);
-      if (points != null) {
-        if (points instanceof BKDReader == false) {
-          throw new IllegalArgumentException("can only run on Lucene60PointsReader points implementation, but got " + points);
-        }
-        totalHits += points.getDocCount();
-        BKDReader reader = (BKDReader) points;
-        if (reader != null) {
-          readers.add(reader);
-          docBases.add(leaf.docBase);
-          liveDocs.add(leaf.reader().getLiveDocs());
-        }
-      }
-    }
-
-    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);
-
-    // Convert to TopFieldDocs:
-    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];
-    for(int i=0;i<hits.length;i++) {
-      NearestNeighbor.NearestHit hit = hits[i];
-      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});
-    }
-    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);
-  }
 }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java b/lucene/core/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java
similarity index 98%
rename from lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java
rename to lucene/core/src/java/org/apache/lucene/document/LatLonPointDistanceComparator.java
index 40e8deecb7..dcb2412c90 100644
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java b/lucene/core/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
similarity index 100%
rename from lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
rename to lucene/core/src/java/org/apache/lucene/document/LatLonPointDistanceQuery.java
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java b/lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
similarity index 99%
rename from lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
rename to lucene/core/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery.java
index 1b2e3a6b6d..49818215b5 100644
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointSortField.java b/lucene/core/src/java/org/apache/lucene/document/LatLonPointSortField.java
similarity index 99%
rename from lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointSortField.java
rename to lucene/core/src/java/org/apache/lucene/document/LatLonPointSortField.java
index 10e72cc2e9..849dee2670 100644
diff --git a/lucene/core/src/java/org/apache/lucene/index/PointValues.java b/lucene/core/src/java/org/apache/lucene/index/PointValues.java
index 186dbd5e61..c3383836d0 100644
--- a/lucene/core/src/java/org/apache/lucene/index/PointValues.java
+++ b/lucene/core/src/java/org/apache/lucene/index/PointValues.java
@@ -25,6 +25,7 @@ import org.apache.lucene.document.DoublePoint;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.FloatPoint;
 import org.apache.lucene.document.IntPoint;
+import org.apache.lucene.document.LatLonPoint;
 import org.apache.lucene.document.LongPoint;
 import org.apache.lucene.search.DocIdSetIterator;
 import org.apache.lucene.util.StringHelper;
@@ -70,7 +71,7 @@ import org.apache.lucene.util.bkd.BKDWriter;
  * support special operations such as <i>distance</i> and <i>polygon</i> queries. There are currently two implementations:
  * <br>
  * <ol>
- *   <li><a href="{@docRoot}/../sandbox/org/apache/lucene/document/LatLonPoint.html">LatLonPoint</a> in <i>lucene-sandbox</i>: indexes {@code (latitude,longitude)} as {@code (x,y)} in two-dimensional space.
+ *   <li>{@link LatLonPoint}: indexes {@code (latitude,longitude)} as {@code (x,y)} in two-dimensional space.
  *   <li><a href="{@docRoot}/../spatial3d/org/apache/lucene/spatial3d/Geo3DPoint.html">Geo3DPoint</a>* in <i>lucene-spatial3d</i>: indexes {@code (latitude,longitude)} as {@code (x,y,z)} in three-dimensional space.
  * </ol>
  * * does <b>not</b> support altitude, 3D here means "uses three dimensions under-the-hood"<br>
diff --git a/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonDocValuesField.java b/lucene/core/src/test/org/apache/lucene/document/TestLatLonDocValuesField.java
similarity index 99%
rename from lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonDocValuesField.java
rename to lucene/core/src/test/org/apache/lucene/document/TestLatLonDocValuesField.java
index df934d1340..77d970d427 100644
diff --git a/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPoint.java b/lucene/core/src/test/org/apache/lucene/document/TestLatLonPoint.java
similarity index 99%
rename from lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPoint.java
rename to lucene/core/src/test/org/apache/lucene/document/TestLatLonPoint.java
index 700eb56e45..1ba4abacb9 100644
diff --git a/lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java b/lucene/core/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java
similarity index 97%
rename from lucene/sandbox/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java
rename to lucene/core/src/test/org/apache/lucene/document/TestLatLonPointDistanceSort.java
index 6d825d2b76..a4604b2d5e 100644
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonDocValuesQueries.java b/lucene/core/src/test/org/apache/lucene/search/TestLatLonDocValuesQueries.java
similarity index 100%
rename from lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonDocValuesQueries.java
rename to lucene/core/src/test/org/apache/lucene/search/TestLatLonDocValuesQueries.java
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries.java b/lucene/core/src/test/org/apache/lucene/search/TestLatLonPointQueries.java
similarity index 100%
rename from lucene/sandbox/src/test/org/apache/lucene/search/TestLatLonPointQueries.java
rename to lucene/core/src/test/org/apache/lucene/search/TestLatLonPointQueries.java
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointPrototypeQueries.java b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointPrototypeQueries.java
new file mode 100644
index 0000000000..93d879ecb0
--- /dev/null
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointPrototypeQueries.java
@@ -0,0 +1,114 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.document;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.codecs.lucene60.Lucene60PointsFormat;
+import org.apache.lucene.geo.GeoUtils;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.PointValues;
+import org.apache.lucene.search.FieldDoc;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.MatchAllDocsQuery;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.TopFieldDocs;
+import org.apache.lucene.util.Bits;
+import org.apache.lucene.util.bkd.BKDReader;
+
+/**
+ * Holder class for prototype sandboxed queries
+ *
+ * When the query graduates from sandbox, these static calls should be
+ * placed in {@link LatLonPoint}
+ *
+ * @lucene.experimental
+ */
+public class LatLonPointPrototypeQueries {
+
+    // no instance
+    private LatLonPointPrototypeQueries() {
+    }
+
+  /**
+   * Finds the {@code n} nearest indexed points to the provided point, according to Haversine distance.
+   * <p>
+   * This is functionally equivalent to running {@link MatchAllDocsQuery} with a {@link LatLonDocValuesField#newDistanceSort},
+   * but is far more efficient since it takes advantage of properties the indexed BKD tree.  Currently this
+   * only works with {@link Lucene60PointsFormat} (used by the default codec).  Multi-valued fields are
+   * currently not de-duplicated, so if a document had multiple instances of the specified field that
+   * make it into the top n, that document will appear more than once.
+   * <p>
+   * Documents are ordered by ascending distance from the location. The value returned in {@link FieldDoc} for
+   * the hits contains a Double instance with the distance in meters.
+   *
+   * @param searcher IndexSearcher to find nearest points from.
+   * @param field field name. must not be null.
+   * @param latitude latitude at the center: must be within standard +/-90 coordinate bounds.
+   * @param longitude longitude at the center: must be within standard +/-180 coordinate bounds.
+   * @param n the number of nearest neighbors to retrieve.
+   * @return TopFieldDocs containing documents ordered by distance, where the field value for each {@link FieldDoc} is the distance in meters
+   * @throws IllegalArgumentException if the underlying PointValues is not a {@code Lucene60PointsReader} (this is a current limitation), or
+   *         if {@code field} or {@code searcher} is null, or if {@code latitude}, {@code longitude} or {@code n} are out-of-bounds
+   * @throws IOException if an IOException occurs while finding the points.
+   */
+  // TODO: what about multi-valued documents? what happens?
+  public static TopFieldDocs nearest(IndexSearcher searcher, String field, double latitude, double longitude, int n) throws IOException {
+    GeoUtils.checkLatitude(latitude);
+    GeoUtils.checkLongitude(longitude);
+    if (n < 1) {
+      throw new IllegalArgumentException("n must be at least 1; got " + n);
+    }
+    if (field == null) {
+      throw new IllegalArgumentException("field must not be null");
+    }
+    if (searcher == null) {
+      throw new IllegalArgumentException("searcher must not be null");
+    }
+    List<BKDReader> readers = new ArrayList<>();
+    List<Integer> docBases = new ArrayList<>();
+    List<Bits> liveDocs = new ArrayList<>();
+    int totalHits = 0;
+    for(LeafReaderContext leaf : searcher.getIndexReader().leaves()) {
+      PointValues points = leaf.reader().getPointValues(field);
+      if (points != null) {
+        if (points instanceof BKDReader == false) {
+          throw new IllegalArgumentException("can only run on Lucene60PointsReader points implementation, but got " + points);
+        }
+        totalHits += points.getDocCount();
+        BKDReader reader = (BKDReader) points;
+        if (reader != null) {
+          readers.add(reader);
+          docBases.add(leaf.docBase);
+          liveDocs.add(leaf.reader().getLiveDocs());
+        }
+      }
+    }
+
+    NearestNeighbor.NearestHit[] hits = NearestNeighbor.nearest(latitude, longitude, readers, liveDocs, docBases, n);
+
+    // Convert to TopFieldDocs:
+    ScoreDoc[] scoreDocs = new ScoreDoc[hits.length];
+    for(int i=0;i<hits.length;i++) {
+      NearestNeighbor.NearestHit hit = hits[i];
+      scoreDocs[i] = new FieldDoc(hit.docID, 0.0f, new Object[] {Double.valueOf(hit.distanceMeters)});
+    }
+    return new TopFieldDocs(totalHits, scoreDocs, null, 0.0f);
+  }
+}
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/NearestNeighbor.java b/lucene/sandbox/src/java/org/apache/lucene/document/NearestNeighbor.java
index 587c63fb7a..f7812dd386 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/NearestNeighbor.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/NearestNeighbor.java
@@ -182,7 +182,7 @@ class NearestNeighbor {
     }
   }
 
-  /** Holds one hit from {@link LatLonPoint#nearest} */
+  /** Holds one hit from {@link LatLonPointPrototypeQueries#nearest} */
   static class NearestHit {
     public int docID;
     public double distanceMeters;
@@ -325,4 +325,5 @@ class NearestNeighbor {
     double d4 = SloppyMath.haversinMeters(pointLat, pointLon, maxLat, minLon);
     return Math.min(Math.min(d1, d2), Math.min(d3, d4));
   }
+
 }
diff --git a/lucene/sandbox/src/test/org/apache/lucene/document/TestFloatPointNearestNeighbor.java b/lucene/sandbox/src/test/org/apache/lucene/document/TestFloatPointNearestNeighbor.java
index 9e3c3c1a8e..318180cf55 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/document/TestFloatPointNearestNeighbor.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/document/TestFloatPointNearestNeighbor.java
@@ -59,7 +59,7 @@ public class TestFloatPointNearestNeighbor extends LuceneTestCase {
     r = w.getReader();
     // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:
     s = newSearcher(r, false);
-    hit = (FieldDoc)LatLonPoint.nearest(s, "point", 40.0, 50.0, 1).scoreDocs[0];
+    hit = (FieldDoc)LatLonPointPrototypeQueries.nearest(s, "point", 40.0, 50.0, 1).scoreDocs[0];
     assertEquals("1", r.document(hit.doc).getField("id").stringValue());
     r.close();
     w.close();
diff --git a/lucene/sandbox/src/test/org/apache/lucene/document/TestNearest.java b/lucene/sandbox/src/test/org/apache/lucene/document/TestNearest.java
index 2fb2077ef8..c91785a143 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/document/TestNearest.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/document/TestNearest.java
@@ -58,7 +58,7 @@ public class TestNearest extends LuceneTestCase {
     DirectoryReader r = w.getReader();
     // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:
     IndexSearcher s = newSearcher(r, false);
-    FieldDoc hit = (FieldDoc) LatLonPoint.nearest(s, "point", 40.0, 50.0, 1).scoreDocs[0];
+    FieldDoc hit = (FieldDoc) LatLonPointPrototypeQueries.nearest(s, "point", 40.0, 50.0, 1).scoreDocs[0];
     assertEquals("0", r.document(hit.doc).getField("id").stringValue());
     r.close();
 
@@ -66,7 +66,7 @@ public class TestNearest extends LuceneTestCase {
     r = w.getReader();
     // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:
     s = newSearcher(r, false);
-    hit = (FieldDoc) LatLonPoint.nearest(s, "point", 40.0, 50.0, 1).scoreDocs[0];
+    hit = (FieldDoc) LatLonPointPrototypeQueries.nearest(s, "point", 40.0, 50.0, 1).scoreDocs[0];
     assertEquals("1", r.document(hit.doc).getField("id").stringValue());
     r.close();
     w.close();
@@ -88,7 +88,7 @@ public class TestNearest extends LuceneTestCase {
     DirectoryReader r = w.getReader();
     // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:
     IndexSearcher s = newSearcher(r, false);
-    FieldDoc hit = (FieldDoc) LatLonPoint.nearest(s, "point", 40.0, 50.0, 1).scoreDocs[0];
+    FieldDoc hit = (FieldDoc) LatLonPointPrototypeQueries.nearest(s, "point", 40.0, 50.0, 1).scoreDocs[0];
     assertEquals("0", r.document(hit.doc).getField("id").stringValue());
     r.close();
 
@@ -97,7 +97,7 @@ public class TestNearest extends LuceneTestCase {
     r = w.getReader();
     // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:
     s = newSearcher(r, false);
-    assertEquals(0, LatLonPoint.nearest(s, "point", 40.0, 50.0, 1).scoreDocs.length);
+    assertEquals(0, LatLonPointPrototypeQueries.nearest(s, "point", 40.0, 50.0, 1).scoreDocs.length);
     r.close();
     w.close();
     dir.close();
@@ -117,7 +117,7 @@ public class TestNearest extends LuceneTestCase {
 
     DirectoryReader r = DirectoryReader.open(w);
     // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:
-    ScoreDoc[] hits = LatLonPoint.nearest(newSearcher(r, false), "point", 45.0, 50.0, 2).scoreDocs;
+    ScoreDoc[] hits = LatLonPointPrototypeQueries.nearest(newSearcher(r, false), "point", 45.0, 50.0, 2).scoreDocs;
     assertEquals("0", r.document(hits[0].doc).getField("id").stringValue());
     assertEquals("1", r.document(hits[1].doc).getField("id").stringValue());
 
@@ -131,7 +131,7 @@ public class TestNearest extends LuceneTestCase {
     RandomIndexWriter w = new RandomIndexWriter(random(), dir, getIndexWriterConfig());
     DirectoryReader r = w.getReader();
     // can't wrap because we require Lucene60PointsFormat directly but e.g. ParallelReader wraps with its own points impl:
-    assertEquals(0, LatLonPoint.nearest(newSearcher(r, false), "point", 40.0, 50.0, 1).scoreDocs.length);
+    assertEquals(0, LatLonPointPrototypeQueries.nearest(newSearcher(r, false), "point", 40.0, 50.0, 1).scoreDocs.length);
     r.close();
     w.close();
     dir.close();
@@ -219,7 +219,7 @@ public class TestNearest extends LuceneTestCase {
       // Also test with MatchAllDocsQuery, sorting by distance:
       TopFieldDocs fieldDocs = s.search(new MatchAllDocsQuery(), topN, new Sort(LatLonDocValuesField.newDistanceSort("point", pointLat, pointLon)));
 
-      ScoreDoc[] hits = LatLonPoint.nearest(s, "point", pointLat, pointLon, topN).scoreDocs;
+      ScoreDoc[] hits = LatLonPointPrototypeQueries.nearest(s, "point", pointLat, pointLon, topN).scoreDocs;
       for(int i=0;i<topN;i++) {
         NearestHit expected = expectedHits[i];
         FieldDoc expected2 = (FieldDoc) fieldDocs.scoreDocs[i];
