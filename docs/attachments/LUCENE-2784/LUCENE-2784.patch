Index: lucene/src/test/org/apache/lucene/search/TestTermRangeQuery.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestTermRangeQuery.java	(revision 1040141)
+++ lucene/src/test/org/apache/lucene/search/TestTermRangeQuery.java	(working copy)
@@ -20,6 +20,8 @@
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.MultiFields;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.IndexWriterConfig.OpenMode;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.analysis.Analyzer;
@@ -103,17 +105,18 @@
     initializeIndex(new String[]{"A", "B", "C", "D"});
     IndexSearcher searcher = new IndexSearcher(dir, true);
     TermRangeQuery query = new TermRangeQuery("content", null, null, true, true);
-    assertFalse(query.getTermsEnum(searcher.getIndexReader()) instanceof TermRangeTermsEnum);
+    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), "content");
+    assertFalse(query.getTermsEnum(terms) instanceof TermRangeTermsEnum);
     assertEquals(4, searcher.search(query, null, 1000).scoreDocs.length);
     query = new TermRangeQuery("content", null, null, false, false);
-    assertFalse(query.getTermsEnum(searcher.getIndexReader()) instanceof TermRangeTermsEnum);
+    assertFalse(query.getTermsEnum(terms) instanceof TermRangeTermsEnum);
     assertEquals(4, searcher.search(query, null, 1000).scoreDocs.length);
     query = new TermRangeQuery("content", "", null, true, false);
-    assertFalse(query.getTermsEnum(searcher.getIndexReader()) instanceof TermRangeTermsEnum);
+    assertFalse(query.getTermsEnum(terms) instanceof TermRangeTermsEnum);
     assertEquals(4, searcher.search(query, null, 1000).scoreDocs.length);
     // and now anothe one
     query = new TermRangeQuery("content", "B", null, true, false);
-    assertTrue(query.getTermsEnum(searcher.getIndexReader()) instanceof TermRangeTermsEnum);
+    assertTrue(query.getTermsEnum(terms) instanceof TermRangeTermsEnum);
     assertEquals(3, searcher.search(query, null, 1000).scoreDocs.length);
     searcher.close();
   }
Index: lucene/src/test/org/apache/lucene/search/TestMultiTermQueryRewrites.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestMultiTermQueryRewrites.java	(revision 1040141)
+++ lucene/src/test/org/apache/lucene/search/TestMultiTermQueryRewrites.java	(working copy)
@@ -24,6 +24,7 @@
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.store.Directory;
@@ -156,8 +157,8 @@
   private void checkBoosts(MultiTermQuery.RewriteMethod method) throws Exception {
     final MultiTermQuery mtq = new MultiTermQuery("data") {
       @Override
-      protected TermsEnum getTermsEnum(IndexReader reader, AttributeSource atts) throws IOException {
-        return new TermRangeTermsEnum(reader, field, "2", "7", true, true, null) {
+      protected TermsEnum getTermsEnum(Terms terms, AttributeSource atts) throws IOException {
+        return new TermRangeTermsEnum(terms.iterator(), "2", "7", true, true, null) {
           final BoostAttribute boostAtt =
             attributes().addAttribute(BoostAttribute.class);
         
Index: lucene/src/test/org/apache/lucene/search/TestWildcard.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestWildcard.java	(revision 1040141)
+++ lucene/src/test/org/apache/lucene/search/TestWildcard.java	(working copy)
@@ -24,8 +24,10 @@
 import org.apache.lucene.document.Field;
 import org.apache.lucene.document.Field.Store;
 import org.apache.lucene.document.Field.Index;
+import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.queryParser.QueryParser;
 
 import java.io.IOException;
@@ -128,13 +130,13 @@
 
     MultiTermQuery wq = new WildcardQuery(new Term("field", "prefix*"));
     assertMatches(searcher, wq, 2);
+    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), "field");
+    assertTrue(wq.getTermsEnum(terms) instanceof PrefixTermsEnum);
     
-    assertTrue(wq.getTermsEnum(searcher.getIndexReader()) instanceof PrefixTermsEnum);
-    
     wq = new WildcardQuery(new Term("field", "*"));
     assertMatches(searcher, wq, 2);
-    assertFalse(wq.getTermsEnum(searcher.getIndexReader()) instanceof PrefixTermsEnum);
-    assertFalse(wq.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum);
+    assertFalse(wq.getTermsEnum(terms) instanceof PrefixTermsEnum);
+    assertFalse(wq.getTermsEnum(terms) instanceof AutomatonTermsEnum);
     searcher.close();
     indexStore.close();
   }
Index: lucene/src/test/org/apache/lucene/search/TestAutomatonQuery.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestAutomatonQuery.java	(revision 1040141)
+++ lucene/src/test/org/apache/lucene/search/TestAutomatonQuery.java	(working copy)
@@ -22,8 +22,10 @@
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
@@ -170,7 +172,8 @@
   public void testRewriteSingleTerm() throws IOException {
     AutomatonQuery aq = new AutomatonQuery(newTerm("bogus"), BasicAutomata
         .makeString("piece"));
-    assertTrue(aq.getTermsEnum(searcher.getIndexReader()) instanceof SingleTermsEnum);
+    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), FN);
+    assertTrue(aq.getTermsEnum(terms) instanceof SingleTermsEnum);
     assertEquals(1, automatonQueryNrHits(aq));
   }
   
@@ -184,7 +187,8 @@
     Automaton prefixAutomaton = BasicOperations.concatenate(pfx, BasicAutomata
         .makeAnyString());
     AutomatonQuery aq = new AutomatonQuery(newTerm("bogus"), prefixAutomaton);
-    assertTrue(aq.getTermsEnum(searcher.getIndexReader()) instanceof PrefixTermsEnum);
+    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), FN);
+    assertTrue(aq.getTermsEnum(terms) instanceof PrefixTermsEnum);
     assertEquals(3, automatonQueryNrHits(aq));
   }
   
@@ -196,7 +200,8 @@
         .makeEmpty());
     // not yet available: assertTrue(aq.getEnum(searcher.getIndexReader())
     // instanceof EmptyTermEnum);
-    assertSame(TermsEnum.EMPTY, aq.getTermsEnum(searcher.getIndexReader()));
+    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), FN);
+    assertSame(TermsEnum.EMPTY, aq.getTermsEnum(terms));
     assertEquals(0, automatonQueryNrHits(aq));
   }
 }
Index: lucene/src/test/org/apache/lucene/search/TestRegexpRandom2.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestRegexpRandom2.java	(revision 1040141)
+++ lucene/src/test/org/apache/lucene/search/TestRegexpRandom2.java	(working copy)
@@ -27,7 +27,9 @@
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.codecs.CodecProvider;
@@ -103,16 +105,16 @@
     }
     
     @Override
-    protected TermsEnum getTermsEnum(IndexReader reader, AttributeSource atts) throws IOException {
-      return new SimpleAutomatonTermsEnum(reader, field);
+    protected TermsEnum getTermsEnum(Terms terms, AttributeSource atts) throws IOException {
+      return new SimpleAutomatonTermsEnum(terms.iterator());
     }
 
     private class SimpleAutomatonTermsEnum extends FilteredTermsEnum {
       CharacterRunAutomaton runAutomaton = new CharacterRunAutomaton(automaton);
       UnicodeUtil.UTF16Result utf16 = new UnicodeUtil.UTF16Result();
 
-      private SimpleAutomatonTermsEnum(IndexReader reader, String field) throws IOException {
-        super(reader, field);
+      private SimpleAutomatonTermsEnum(TermsEnum tenum) throws IOException {
+        super(tenum);
         setInitialSeekTerm(new BytesRef(""));
       }
       
@@ -153,7 +155,10 @@
     // a\uda07* prefixquery. Prefixquery then does the "wrong" thing, which
     // isn't really wrong as the query was undefined to begin with... but not
     // automatically comparable.
-    if (!(smart.getTermsEnum(searcher.getIndexReader()) instanceof AutomatonTermsEnum))
+    
+    // TODO: does this check even matter anymore?!
+    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), "field");
+    if (!(smart.getTermsEnum(terms) instanceof AutomatonTermsEnum))
       return;
     
     TopDocs smartDocs = searcher.search(smart, 25);
Index: lucene/src/test/org/apache/lucene/search/TestPrefixRandom.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestPrefixRandom.java	(revision 1040141)
+++ lucene/src/test/org/apache/lucene/search/TestPrefixRandom.java	(working copy)
@@ -25,6 +25,7 @@
 import org.apache.lucene.document.Field;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.codecs.CodecProvider;
@@ -86,16 +87,15 @@
     }
     
     @Override
-    protected TermsEnum getTermsEnum(IndexReader reader, AttributeSource atts) throws IOException {
-      return new SimplePrefixTermsEnum(reader, field, prefix);
+    protected TermsEnum getTermsEnum(Terms terms, AttributeSource atts) throws IOException {
+      return new SimplePrefixTermsEnum(terms.iterator(), prefix);
     }
 
     private class SimplePrefixTermsEnum extends FilteredTermsEnum {
       private final BytesRef prefix;
 
-      private SimplePrefixTermsEnum(IndexReader reader, 
-          String field, BytesRef prefix) throws IOException {
-        super(reader, field);
+      private SimplePrefixTermsEnum(TermsEnum tenum, BytesRef prefix) throws IOException {
+        super(tenum);
         this.prefix = prefix;
         setInitialSeekTerm(new BytesRef(""));
       }
Index: lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java	(revision 1040141)
+++ lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java	(working copy)
@@ -23,7 +23,9 @@
 import org.apache.lucene.document.NumericField;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.RandomIndexWriter;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.BytesRef;
@@ -563,7 +565,8 @@
   private void testEnum(int lower, int upper) throws Exception {
     NumericRangeQuery<Integer> q = NumericRangeQuery.newIntRange("field4", 4,
         lower, upper, true, true);
-    TermsEnum termEnum = q.getTermsEnum(searcher.getIndexReader());
+    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), "field4");
+    TermsEnum termEnum = q.getTermsEnum(terms);
     int count = 0;
     while (termEnum.next() != null) {
       final BytesRef t = termEnum.term();
Index: lucene/src/test/org/apache/lucene/search/TestPrefixQuery.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestPrefixQuery.java	(revision 1040141)
+++ lucene/src/test/org/apache/lucene/search/TestPrefixQuery.java	(working copy)
@@ -20,8 +20,10 @@
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.LuceneTestCase;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 
@@ -54,7 +56,8 @@
     assertEquals("One in /Computers/Mac", 1, hits.length);
 
     query = new PrefixQuery(new Term("category", ""));
-    assertFalse(query.getTermsEnum(searcher.getIndexReader()) instanceof PrefixTermsEnum);
+    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), "category");
+    assertFalse(query.getTermsEnum(terms) instanceof PrefixTermsEnum);
     hits = searcher.search(query, null, 1000).scoreDocs;
     assertEquals("everything", 3, hits.length);
     writer.close();
Index: lucene/src/java/org/apache/lucene/search/MultiTermQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/MultiTermQuery.java	(revision 1040141)
+++ lucene/src/java/org/apache/lucene/search/MultiTermQuery.java	(working copy)
@@ -22,6 +22,7 @@
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.queryParser.QueryParser;
 import org.apache.lucene.util.AttributeSource;
@@ -268,14 +269,14 @@
    * provide attributes, the rewrite method uses to inform about e.g. maximum competitive boosts.
    * This is currently only used by {@link TopTermsRewrite}
    */
-  protected abstract TermsEnum getTermsEnum(IndexReader reader, AttributeSource atts) throws IOException;
+  protected abstract TermsEnum getTermsEnum(Terms terms, AttributeSource atts) throws IOException;
 
   /** Convenience method, if no attributes are needed:
    * This simply passes empty attributes and is equal to:
-   * <code>getTermsEnum(reader, new AttributeSource())</code>
+   * <code>getTermsEnum(terms, new AttributeSource())</code>
    */
-  protected final TermsEnum getTermsEnum(IndexReader reader) throws IOException {
-    return getTermsEnum(reader, new AttributeSource());
+  protected final TermsEnum getTermsEnum(Terms terms) throws IOException {
+    return getTermsEnum(terms, new AttributeSource());
   }
 
   /**
Index: lucene/src/java/org/apache/lucene/search/FuzzyQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/FuzzyQuery.java	(revision 1040141)
+++ lucene/src/java/org/apache/lucene/search/FuzzyQuery.java	(working copy)
@@ -17,8 +17,8 @@
  * limitations under the License.
  */
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.ToStringUtils;
@@ -136,11 +136,13 @@
   }
 
   @Override
-  protected TermsEnum getTermsEnum(IndexReader reader, AttributeSource atts) throws IOException {
+  protected TermsEnum getTermsEnum(Terms terms, AttributeSource atts) throws IOException {
+    TermsEnum tenum = terms.iterator();
+    
     if (!termLongEnough) {  // can only match if it's exact
-      return new SingleTermsEnum(reader, term);
+      return new SingleTermsEnum(tenum, term);
     }
-    return new FuzzyTermsEnum(reader, atts, getTerm(), minimumSimilarity, prefixLength);
+    return new FuzzyTermsEnum(tenum, atts, getTerm(), minimumSimilarity, prefixLength);
   }
   
   /**
Index: lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java	(revision 1040141)
+++ lucene/src/java/org/apache/lucene/search/MultiTermQueryWrapperFilter.java	(working copy)
@@ -118,7 +118,7 @@
       return DocIdSet.EMPTY_DOCIDSET;
     }
 
-    final TermsEnum termsEnum = query.getTermsEnum(reader);
+    final TermsEnum termsEnum = query.getTermsEnum(terms);
     assert termsEnum != null;
     if (termsEnum.next() != null) {
       // fill into a OpenBitSet
Index: lucene/src/java/org/apache/lucene/search/PrefixTermsEnum.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/PrefixTermsEnum.java	(revision 1040141)
+++ lucene/src/java/org/apache/lucene/search/PrefixTermsEnum.java	(working copy)
@@ -19,8 +19,8 @@
 
 import java.io.IOException;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.BytesRef;
 
 /**
@@ -34,8 +34,8 @@
 
   private final BytesRef prefixRef;
 
-  public PrefixTermsEnum(IndexReader reader, Term prefix) throws IOException {
-    super(reader, prefix.field());
+  public PrefixTermsEnum(TermsEnum tenum, Term prefix) throws IOException {
+    super(tenum);
     setInitialSeekTerm(prefixRef = prefix.bytes());
   }
 
Index: lucene/src/java/org/apache/lucene/search/FilteredTermsEnum.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/FilteredTermsEnum.java	(revision 1040141)
+++ lucene/src/java/org/apache/lucene/search/FilteredTermsEnum.java	(working copy)
@@ -20,11 +20,8 @@
 import java.io.IOException;
 import java.util.Comparator;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.index.TermsEnum;
-import org.apache.lucene.index.Terms;
-import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.DocsEnum;
 import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.util.AttributeSource;
@@ -62,22 +59,11 @@
   protected abstract AcceptStatus accept(BytesRef term) throws IOException;
 
   /**
-   * Creates a filtered {@link TermsEnum} for the given field name and reader.
-   */
-  public FilteredTermsEnum(final IndexReader reader, final String field) throws IOException {
-    final Terms terms = MultiFields.getTerms(reader, field);
-    if (terms != null) {
-      tenum = terms.iterator();
-    } else {
-      tenum = null;
-    }
-  }
-
-  /**
    * Creates a filtered {@link TermsEnum} on a terms enum.
-   * @param tenum the terms enumeration to filter, if {@code null} this is the null iterator.
+   * @param tenum the terms enumeration to filter.
    */
   public FilteredTermsEnum(final TermsEnum tenum) {
+    assert tenum != null;
     this.tenum = tenum;
   }
 
@@ -121,26 +107,21 @@
    */
   @Override
   public AttributeSource attributes() {
-    /* if we have no tenum, we return a new attributes instance,
-     * to prevent NPE in subclasses that use attributes.
-     * in all other cases we share the attributes with our delegate. */
-    return (tenum == null) ? super.attributes() : tenum.attributes();
+    return tenum.attributes();
   }
   
   @Override
   public BytesRef term() throws IOException {
-    assert tenum != null;
     return tenum.term();
   }
 
   @Override
   public Comparator<BytesRef> getComparator() throws IOException {
-    return (tenum == null) ? null : tenum.getComparator();
+    return tenum.getComparator();
   }
     
   @Override
   public int docFreq() {
-    assert tenum != null;
     return tenum.docFreq();
   }
 
@@ -162,19 +143,16 @@
 
   @Override
   public long ord() throws IOException {
-    assert tenum != null;
     return tenum.ord();
   }
 
   @Override
   public DocsEnum docs(Bits bits, DocsEnum reuse) throws IOException {
-    assert tenum != null;
     return tenum.docs(bits, reuse);
   }
     
   @Override
   public DocsAndPositionsEnum docsAndPositions(Bits bits, DocsAndPositionsEnum reuse) throws IOException {
-    assert tenum != null;
     return tenum.docsAndPositions(bits, reuse);
   }
 
@@ -186,8 +164,6 @@
   @SuppressWarnings("fallthrough")
   @Override
   public BytesRef next() throws IOException {
-    if (tenum == null)
-      return null;
     for (;;) {
       // Seek or forward the iterator
       if (doSeek) {
Index: lucene/src/java/org/apache/lucene/search/PrefixQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/PrefixQuery.java	(revision 1040141)
+++ lucene/src/java/org/apache/lucene/search/PrefixQuery.java	(working copy)
@@ -19,11 +19,9 @@
 
 import java.io.IOException;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.Terms;
-import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.ToStringUtils;
 
@@ -46,15 +44,14 @@
   public Term getPrefix() { return prefix; }
   
   @Override  
-  protected TermsEnum getTermsEnum(IndexReader reader, AttributeSource atts) throws IOException {
+  protected TermsEnum getTermsEnum(Terms terms, AttributeSource atts) throws IOException {
+    TermsEnum tenum = terms.iterator();
+    
     if (prefix.bytes().length == 0) {
       // no prefix -- match all terms for this field:
-      // NOTE: for now, MultiTermQuery enums terms at the
-      // MultiReader level, so we must use MultiFields here:
-      final Terms terms = MultiFields.getTerms(reader, getField());
-      return (terms != null) ? terms.iterator() : TermsEnum.EMPTY;
+      return tenum;
     }
-    return new PrefixTermsEnum(reader, prefix);
+    return new PrefixTermsEnum(tenum, prefix);
   }
 
   /** Prints a user-readable version of this query. */
Index: lucene/src/java/org/apache/lucene/search/TermRangeTermsEnum.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/TermRangeTermsEnum.java	(revision 1040141)
+++ lucene/src/java/org/apache/lucene/search/TermRangeTermsEnum.java	(working copy)
@@ -21,7 +21,7 @@
 import java.text.Collator;
 import java.util.Comparator;
 
-import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.BytesRef;
 
 /**
@@ -51,9 +51,8 @@
    * (you can't select all but the first or last term without 
    * explicitly specifying the term to exclude.)
    * 
-   * @param reader
-   * @param field
-   *          An interned field that holds both lower and upper terms.
+   * @param tenum
+   *          TermsEnum to filter
    * @param lowerTermText
    *          The term text at the lower end of the range
    * @param upperTermText
@@ -69,9 +68,9 @@
    * 
    * @throws IOException
    */
-  public TermRangeTermsEnum(IndexReader reader, String field, String lowerTermText, String upperTermText, 
+  public TermRangeTermsEnum(TermsEnum tenum, String lowerTermText, String upperTermText, 
     boolean includeLower, boolean includeUpper, Collator collator) throws IOException {
-    super(reader, field);
+    super(tenum);
     this.collator = collator;
     this.upperTermText = upperTermText;
     this.lowerTermText = lowerTermText;
Index: lucene/src/java/org/apache/lucene/search/NumericRangeQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/NumericRangeQuery.java	(revision 1040141)
+++ lucene/src/java/org/apache/lucene/search/NumericRangeQuery.java	(working copy)
@@ -25,7 +25,7 @@
 import org.apache.lucene.document.NumericField; // for javadocs
 import org.apache.lucene.util.NumericUtils;
 import org.apache.lucene.util.ToStringUtils;
-import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.index.TermsEnum;
@@ -302,11 +302,11 @@
   }
 
   @Override @SuppressWarnings("unchecked")
-  protected TermsEnum getTermsEnum(final IndexReader reader, AttributeSource atts) throws IOException {
+  protected TermsEnum getTermsEnum(final Terms terms, AttributeSource atts) throws IOException {
     // very strange: java.lang.Number itsself is not Comparable, but all subclasses used here are
     return (min != null && max != null && ((Comparable<T>) min).compareTo(max) > 0) ?
       TermsEnum.EMPTY :
-      new NumericRangeTermsEnum(reader);
+      new NumericRangeTermsEnum(terms.iterator());
   }
 
   /** Returns <code>true</code> if the lower endpoint is inclusive */
@@ -385,8 +385,8 @@
     private final LinkedList<BytesRef> rangeBounds = new LinkedList<BytesRef>();
     private final Comparator<BytesRef> termComp;
 
-    NumericRangeTermsEnum(final IndexReader reader) throws IOException {
-      super(reader, getField());
+    NumericRangeTermsEnum(final TermsEnum tenum) throws IOException {
+      super(tenum);
       switch (valSize) {
         case 64: {
           // lower
Index: lucene/src/java/org/apache/lucene/search/TermRangeQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/TermRangeQuery.java	(revision 1040141)
+++ lucene/src/java/org/apache/lucene/search/TermRangeQuery.java	(working copy)
@@ -20,10 +20,8 @@
 import java.io.IOException;
 import java.text.Collator;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.Terms;
-import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.util.ToStringUtils;
 import org.apache.lucene.util.AttributeSource;
 
@@ -131,17 +129,17 @@
   public Collator getCollator() { return collator; }
   
   @Override
-  protected TermsEnum getTermsEnum(IndexReader reader, AttributeSource atts) throws IOException {
+  protected TermsEnum getTermsEnum(Terms terms, AttributeSource atts) throws IOException {
     if (collator == null && lowerTerm != null && upperTerm != null && lowerTerm.compareTo(upperTerm) > 0) {
       return TermsEnum.EMPTY;
     }
+    
+    TermsEnum tenum = terms.iterator();
+    
     if ((lowerTerm == null || (collator == null && includeLower && "".equals(lowerTerm))) && upperTerm == null) {
-      // NOTE: for now, MultiTermQuery enums terms at the
-      // MultiReader level, so we must use MultiFields here:
-      final Terms terms = MultiFields.getTerms(reader, field);
-      return (terms != null) ? terms.iterator() : null;
+      return tenum;
     }
-    return new TermRangeTermsEnum(reader, field,
+    return new TermRangeTermsEnum(tenum,
         lowerTerm, upperTerm, includeLower, includeUpper, collator);
   }
 
Index: lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum.java	(revision 1040141)
+++ lucene/src/java/org/apache/lucene/search/AutomatonTermsEnum.java	(working copy)
@@ -20,7 +20,7 @@
 import java.io.IOException;
 import java.util.Comparator;
 
-import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.IntsRef;
 import org.apache.lucene.util.automaton.Automaton;
@@ -73,7 +73,7 @@
   /**
    * Expert ctor:
    * Construct an enumerator based upon an automaton, enumerating the specified
-   * field, working on a supplied reader.
+   * field, working on a supplied TermsEnum
    * <p>
    * @lucene.experimental 
    * <p>
@@ -81,10 +81,10 @@
    * @param finite true if the automaton accepts a finite language
    */
   public AutomatonTermsEnum(ByteRunAutomaton runAutomaton,
-                     String field, IndexReader reader,
+                     TermsEnum tenum,
                      boolean finite, BytesRef commonSuffixRef)
       throws IOException {
-    super(reader, field);
+    super(tenum);
     this.automaton = runAutomaton.getAutomaton();
     this.finite = finite;
 
@@ -110,13 +110,13 @@
   
   /**
    * Construct an enumerator based upon an automaton, enumerating the specified
-   * field, working on a supplied reader.
+   * field, working on a supplied TermsEnum
    * <p>
    * It will automatically calculate whether or not the automaton is finite
    */
-  public AutomatonTermsEnum(Automaton automaton, String field, IndexReader reader)
+  public AutomatonTermsEnum(Automaton automaton, TermsEnum tenum)
     throws IOException {
-    this(new ByteRunAutomaton(automaton), field, reader, SpecialOperations.isFinite(automaton), null);
+    this(new ByteRunAutomaton(automaton), tenum, SpecialOperations.isFinite(automaton), null);
   }
  
   /**
Index: lucene/src/java/org/apache/lucene/search/TermCollectingRewrite.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/TermCollectingRewrite.java	(revision 1040141)
+++ lucene/src/java/org/apache/lucene/search/TermCollectingRewrite.java	(working copy)
@@ -58,7 +58,7 @@
         continue;
       }
 
-      final TermsEnum termsEnum = query.getTermsEnum(r, collector.attributes);
+      final TermsEnum termsEnum = query.getTermsEnum(terms, collector.attributes);
       assert termsEnum != null;
 
       if (termsEnum == TermsEnum.EMPTY)
Index: lucene/src/java/org/apache/lucene/search/SingleTermsEnum.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/SingleTermsEnum.java	(revision 1040141)
+++ lucene/src/java/org/apache/lucene/search/SingleTermsEnum.java	(working copy)
@@ -19,8 +19,8 @@
 
 import java.io.IOException;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.BytesRef;
 
 /**
@@ -39,8 +39,8 @@
    * After calling the constructor the enumeration is already pointing to the term,
    * if it exists.
    */
-  public SingleTermsEnum(IndexReader reader, Term singleTerm) throws IOException {
-    super(reader, singleTerm.field());
+  public SingleTermsEnum(TermsEnum tenum, Term singleTerm) throws IOException {
+    super(tenum);
     singleRef = singleTerm.bytes();
     setInitialSeekTerm(singleRef);
   }
Index: lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.java	(revision 1040141)
+++ lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.java	(working copy)
@@ -19,7 +19,6 @@
 
 import org.apache.lucene.index.DocsAndPositionsEnum;
 import org.apache.lucene.index.DocsEnum;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.Attribute;
@@ -71,7 +70,7 @@
   private int maxEdits;
   private final boolean raw;
 
-  private final IndexReader reader;
+  private final TermsEnum tenum;
   private final Term term;
   private final int termText[];
   private final int realPrefixLength;
@@ -84,7 +83,7 @@
    * After calling the constructor the enumeration is already pointing to the first 
    * valid term if such a term exists. 
    * 
-   * @param reader Delivers terms.
+   * @param tenum Delivers terms.
    * @param atts {@link AttributeSource} created by the rewrite method of {@link MultiTermQuery}
    * thats contains information about competitive boosts during rewrite. It is also used
    * to cache DFAs between segment transitions.
@@ -93,7 +92,7 @@
    * @param prefixLength Length of required common prefix. Default value is 0.
    * @throws IOException
    */
-  public FuzzyTermsEnum(IndexReader reader, AttributeSource atts, Term term, 
+  public FuzzyTermsEnum(TermsEnum tenum, AttributeSource atts, Term term, 
       final float minSimilarity, final int prefixLength) throws IOException {
     if (minSimilarity >= 1.0f && minSimilarity != (int)minSimilarity)
       throw new IllegalArgumentException("fractional edit distances are not allowed");
@@ -101,7 +100,7 @@
       throw new IllegalArgumentException("minimumSimilarity cannot be less than 0");
     if(prefixLength < 0)
       throw new IllegalArgumentException("prefixLength cannot be less than 0");
-    this.reader = reader;
+    this.tenum = tenum;
     this.term = term;
 
     // convert the string into a utf32 int[] representation for fast comparisons
@@ -304,7 +303,7 @@
     
     public AutomatonFuzzyTermsEnum(ByteRunAutomaton matchers[], 
         BytesRef lastTerm) throws IOException {
-      super(matchers[matchers.length - 1], term.field(), reader, true, null);
+      super(matchers[matchers.length - 1], tenum, true, null);
       this.matchers = matchers;
       this.lastTerm = lastTerm;
       termRef = new BytesRef(term.text());
@@ -380,7 +379,7 @@
      * @throws IOException
      */
     public LinearFuzzyTermsEnum() throws IOException {
-      super(reader, term.field());
+      super(tenum);
 
       this.text = new int[termLength - realPrefixLength];
       System.arraycopy(termText, realPrefixLength, text, 0, text.length);
Index: lucene/src/java/org/apache/lucene/search/AutomatonQuery.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/AutomatonQuery.java	(revision 1040141)
+++ lucene/src/java/org/apache/lucene/search/AutomatonQuery.java	(working copy)
@@ -19,10 +19,9 @@
 
 import java.io.IOException;
 
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.TermsEnum;
-import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.util.ToStringUtils;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.BytesRef;
@@ -86,43 +85,43 @@
   }
 
   @Override
-  protected TermsEnum getTermsEnum(IndexReader reader, AttributeSource atts) throws IOException {
+  protected TermsEnum getTermsEnum(Terms terms, AttributeSource atts) throws IOException {
     // matches nothing
     if (BasicOperations.isEmpty(automaton)) {
       return TermsEnum.EMPTY;
     }
     
+    TermsEnum tenum = terms.iterator();
+    
     // matches all possible strings
     if (BasicOperations.isTotal(automaton)) {
-      // NOTE: for now, MultiTermQuery enums terms at the
-      // MultiReader level, so we must use MultiFields here:
-      return MultiFields.getTerms(reader, getField()).iterator();
+      return tenum;
     }
     
     // matches a fixed string in singleton representation
     String singleton = automaton.getSingleton();
     if (singleton != null)
-      return new SingleTermsEnum(reader, term.createTerm(singleton));
+      return new SingleTermsEnum(tenum, term.createTerm(singleton));
 
     // matches a fixed string in expanded representation
     final String commonPrefix = SpecialOperations.getCommonPrefix(automaton);
 
     if (commonPrefix.length() > 0) {
       if (BasicOperations.sameLanguage(automaton, BasicAutomata.makeString(commonPrefix))) {
-        return new SingleTermsEnum(reader, term.createTerm(commonPrefix));
+        return new SingleTermsEnum(tenum, term.createTerm(commonPrefix));
       }
     
       // matches a constant prefix
       Automaton prefixAutomaton = BasicOperations.concatenate(BasicAutomata
                                                               .makeString(commonPrefix), BasicAutomata.makeAnyString());
       if (BasicOperations.sameLanguage(automaton, prefixAutomaton)) {
-        return new PrefixTermsEnum(reader, term.createTerm(commonPrefix));
+        return new PrefixTermsEnum(tenum, term.createTerm(commonPrefix));
       }
     }
 
     compileAutomaton();
     
-    return new AutomatonTermsEnum(runAutomaton, term.field(), reader, isFinite, commonSuffixRef);
+    return new AutomatonTermsEnum(runAutomaton, tenum, isFinite, commonSuffixRef);
   }
 
   @Override
Index: lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker.java
===================================================================
--- lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker.java	(revision 1040141)
+++ lucene/contrib/spellchecker/src/java/org/apache/lucene/search/spell/DirectSpellChecker.java	(working copy)
@@ -26,6 +26,7 @@
 import java.util.PriorityQueue;
 
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.FuzzyTermsEnum;
 import org.apache.lucene.search.BoostAttribute;
@@ -392,7 +393,7 @@
     AttributeSource atts = new AttributeSource();
     MaxNonCompetitiveBoostAttribute maxBoostAtt =
       atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);
-    FuzzyTermsEnum e = new FuzzyTermsEnum(ir, atts, term, editDistance, Math.max(minPrefix, editDistance-1));
+    FuzzyTermsEnum e = new FuzzyTermsEnum(MultiFields.getTerms(ir, term.field()).iterator(), atts, term, editDistance, Math.max(minPrefix, editDistance-1));
     final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();
     
     BytesRef queryTerm = new BytesRef(term.text());
Index: lucene/contrib/queries/src/test/org/apache/lucene/search/regex/TestRegexQuery.java
===================================================================
--- lucene/contrib/queries/src/test/org/apache/lucene/search/regex/TestRegexQuery.java	(revision 1040141)
+++ lucene/contrib/queries/src/test/org/apache/lucene/search/regex/TestRegexQuery.java	(working copy)
@@ -19,8 +19,10 @@
 
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
 import org.apache.lucene.search.IndexSearcher;
@@ -79,9 +81,10 @@
   }
 
   public void testMatchAll() throws Exception {
-    TermsEnum terms = new RegexQuery(new Term(FN, "jum.")).getTermsEnum(searcher.getIndexReader(), new AttributeSource() /*dummy*/);
+    Terms terms = MultiFields.getTerms(searcher.getIndexReader(), FN);
+    TermsEnum te = new RegexQuery(new Term(FN, "jum.")).getTermsEnum(terms, new AttributeSource() /*dummy*/);
     // no term should match
-    assertNull(terms.next());
+    assertNull(te.next());
   }
 
   public void testRegex1() throws Exception {
Index: lucene/contrib/queries/src/java/org/apache/lucene/search/regex/RegexQuery.java
===================================================================
--- lucene/contrib/queries/src/java/org/apache/lucene/search/regex/RegexQuery.java	(revision 1040141)
+++ lucene/contrib/queries/src/java/org/apache/lucene/search/regex/RegexQuery.java	(working copy)
@@ -20,7 +20,7 @@
 import org.apache.lucene.search.MultiTermQuery;
 import org.apache.lucene.search.FilteredTermsEnum;
 import org.apache.lucene.index.Term;
-import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Terms;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.ToStringUtils;
 
@@ -61,8 +61,8 @@
   }
 
   @Override
-  protected FilteredTermsEnum getTermsEnum(IndexReader reader, AttributeSource atts) throws IOException {
-    return new RegexTermsEnum(reader, term, regexImpl);
+  protected FilteredTermsEnum getTermsEnum(Terms terms, AttributeSource atts) throws IOException {
+    return new RegexTermsEnum(terms.iterator(), term, regexImpl);
   }
 
   @Override
Index: lucene/contrib/queries/src/java/org/apache/lucene/search/regex/RegexTermsEnum.java
===================================================================
--- lucene/contrib/queries/src/java/org/apache/lucene/search/regex/RegexTermsEnum.java	(revision 1040141)
+++ lucene/contrib/queries/src/java/org/apache/lucene/search/regex/RegexTermsEnum.java	(working copy)
@@ -18,8 +18,8 @@
  */
 
 import org.apache.lucene.search.FilteredTermsEnum;
-import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.util.BytesRef;
 
 import java.io.IOException;
@@ -37,8 +37,8 @@
   private RegexCapabilities.RegexMatcher regexImpl;
   private final BytesRef prefixRef;
 
-  public RegexTermsEnum(IndexReader reader, Term term, RegexCapabilities regexCap) throws IOException {
-    super(reader, term.field());
+  public RegexTermsEnum(TermsEnum tenum, Term term, RegexCapabilities regexCap) throws IOException {
+    super(tenum);
     String text = term.text();
     this.regexImpl = regexCap.compile(text);
 
Index: lucene/contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery.java
===================================================================
--- lucene/contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery.java	(revision 1040141)
+++ lucene/contrib/queries/src/java/org/apache/lucene/search/FuzzyLikeThisQuery.java	(working copy)
@@ -28,6 +28,7 @@
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.MultiFields;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.util.AttributeSource;
 import org.apache.lucene.util.BytesRef;
@@ -203,7 +204,7 @@
                   AttributeSource atts = new AttributeSource();
                   MaxNonCompetitiveBoostAttribute maxBoostAtt =
                     atts.addAttribute(MaxNonCompetitiveBoostAttribute.class);
-                  FuzzyTermsEnum fe = new FuzzyTermsEnum(reader, atts, startTerm, f.minSimilarity, f.prefixLength);
+                  FuzzyTermsEnum fe = new FuzzyTermsEnum(MultiFields.getTerms(reader, startTerm.field()).iterator(), atts, startTerm, f.minSimilarity, f.prefixLength);
                   //store the df so all variants use same idf
                   int df = reader.docFreq(startTerm);
                   int numVariants=0;
