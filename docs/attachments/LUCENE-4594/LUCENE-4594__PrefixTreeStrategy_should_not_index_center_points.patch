Index: lucene/CHANGES.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/CHANGES.txt	(revision 1418008)
+++ lucene/CHANGES.txt	(revision )
@@ -74,7 +74,12 @@
   re-index is not done, then an indexed point is ~1/2 the smallest grid cell
   larger and as such is slightly more likely to match a query shape.
   (David Smiley)
-  
+
+* LUCENE-4594: Spatial PrefixTreeStrategy no longer indexes center points of
+  non-point shapes.  If you want to call makeDistanceValueSource() based on
+  shape centers, you need to do this yourself in another spatial field.
+  (David Smiley)
+  
 New Features
 
 * LUCENE-4226: New experimental StoredFieldsFormat that compresses chunks of
@@ -218,6 +223,13 @@
   documents with shapes near a query shape were erroneously considered a match.
   In addition, it wasn't possible to index a shape representing the entire
   globe.
+
+* LUCENE-4594: Spatial PrefixTreeStrategy would index center-points in addition
+  to the shape to index if it was non-point, in the same field.  But sometimes
+  the center-point isn't actually in the shape (consider a LineString), and for
+  highly precise shapes it could cause makeDistanceValueSource's cache to load
+  parts of the shape's boundary erroneously too.  So center points aren't
+  indexed any more; you should use another spatial field. (David Smiley)
 
 Optimizations
 
Index: lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy.java	(revision 1417996)
+++ lucene/spatial/src/java/org/apache/lucene/spatial/prefix/PrefixTreeStrategy.java	(revision )
@@ -45,7 +45,7 @@
  * <h4>Characteristics:</h4>
  * <ul>
  * <li>Can index any shape; however only {@link RecursivePrefixTreeStrategy}
- * can effectively search non-point shapes. <em>Not tested.</em></li>
+ * can effectively search non-point shapes.</li>
  * <li>Can index a variable number of shapes per field value. This strategy
  * can do it via multiple calls to {@link #createIndexableFields(com.spatial4j.core.shape.Shape)}
  * for a document or by giving it some sort of Shape aggregate (e.g. JTS
@@ -57,8 +57,9 @@
  * is supported.  If only points are indexed then this is effectively equivalent
  * to IsWithin.</li>
  * <li>The strategy supports {@link #makeDistanceValueSource(com.spatial4j.core.shape.Point)}
- * even for multi-valued data.  However, <em>it will likely be removed in the
- * future</em> in lieu of using another strategy with a more scalable
+ * even for multi-valued data, so long as the indexed data is all points; the
+ * behavior is undefined otherwise.  However, <em>it will likely be removed in
+ * the future</em> in lieu of using another strategy with a more scalable
  * implementation.  Use of this call is the only
  * circumstance in which a cache is used.  The cache is simple but as such
  * it doesn't scale to large numbers of points nor is it real-time-search
@@ -123,20 +124,12 @@
   public Field[] createIndexableFields(Shape shape, double distErr) {
     int detailLevel = grid.getLevelForDistance(distErr);
     List<Node> cells = grid.getNodes(shape, detailLevel, true);//true=intermediates cells
-    //If shape isn't a point, add a full-resolution center-point so that
-    // PointPrefixTreeFieldCacheProvider has the center-points.
-    //TODO index each point of a multi-point or other aggregate.
-    //TODO remove this once support for a distance ValueSource is removed.
-    if (!(shape instanceof Point)) {
-      Point ctr = shape.getCenter();
-      //TODO should be smarter; don't index 2 tokens for this in CellTokenStream. Harmless though.
-      cells.add(grid.getNodes(ctr,grid.getMaxLevels(),false).get(0));
-    }
 
     //TODO is CellTokenStream supposed to be re-used somehow? see Uwe's comments:
     //  http://code.google.com/p/lucene-spatial-playground/issues/detail?id=4
 
-    Field field = new Field(getFieldName(), new CellTokenStream(cells.iterator()), FIELD_TYPE);
+    Field field = new Field(getFieldName(),
+        new CellTokenStream(cells.iterator()), FIELD_TYPE);
     return new Field[]{field};
   }
 
