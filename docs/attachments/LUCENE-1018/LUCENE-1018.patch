Index: src/test/org/apache/lucene/index/TestConcurrentMergeScheduler.java
===================================================================
--- src/test/org/apache/lucene/index/TestConcurrentMergeScheduler.java	(revision 581682)
+++ src/test/org/apache/lucene/index/TestConcurrentMergeScheduler.java	(working copy)
@@ -225,8 +225,8 @@
 
     try {
       directory.close();
-    } catch (RuntimeException ioe) {
-      // MockRAMDirectory will throw IOExceptions when there
+    } catch (RuntimeException re) {
+      // MockRAMDirectory will throw RuntimeExceptions when there
       // are still open files, which is OK since some merge
       // threads may still be running at this point.
     }
Index: src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java
===================================================================
--- src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java	(revision 581682)
+++ src/java/org/apache/lucene/index/ConcurrentMergeScheduler.java	(working copy)
@@ -107,10 +107,8 @@
     while(mergeThreads.size() > 0) {
       if (VERBOSE) {
         message("now wait for threads; currently " + mergeThreads.size() + " still running");
-        for(int i=0;i<mergeThreads.size();i++) {
-          final MergeThread mergeThread = ((MergeThread) mergeThreads.get(i));
-          message("    " + i + ": " + mergeThread.merge.segString(dir));
-        }
+        for(int i=0;i<mergeThreads.size();i++)
+          message("    " + i + ": " + ((MergeThread) mergeThreads.get(i)));
       }
 
       try {
@@ -210,24 +208,35 @@
   private class MergeThread extends Thread {
 
     IndexWriter writer;
-    MergePolicy.OneMerge merge;
+    MergePolicy.OneMerge startMerge;
+    MergePolicy.OneMerge runningMerge;
 
-    public MergeThread(IndexWriter writer, MergePolicy.OneMerge merge) throws IOException {
+    public MergeThread(IndexWriter writer, MergePolicy.OneMerge startMerge) throws IOException {
       this.writer = writer;
-      this.merge = merge;
+      this.startMerge = startMerge;
     }
 
+    public synchronized void setRunningMerge(MergePolicy.OneMerge merge) {
+      runningMerge = merge;
+    }
+
+    public synchronized MergePolicy.OneMerge getRunningMerge() {
+      return runningMerge;
+    }
+
     public void run() {
+      
+      // First time through the while loop we do the merge
+      // that we were started with:
+      MergePolicy.OneMerge merge = this.startMerge;
+      
       try {
 
         if (VERBOSE)
           message("  merge thread: start");
 
-        // First time through the while loop we do the merge
-        // that we were started with:
-        MergePolicy.OneMerge merge = this.merge;
-
         while(true) {
+          setRunningMerge(merge);
           writer.merge(merge);
 
           // Subsequent times through the loop we do any new
@@ -248,13 +257,17 @@
         // When a merge was aborted & IndexWriter closed,
         // it's possible to get various IOExceptions,
         // NullPointerExceptions, AlreadyClosedExceptions:
-        merge.setException(exc);
-        writer.addMergeException(merge);
+        if (merge != null) {
+          merge.setException(exc);
+          writer.addMergeException(merge);
+        }
 
-        if (!merge.isAborted()) {
+        if (merge == null || !merge.isAborted()) {
           // If the merge was not aborted then the exception
           // is real
-          exceptions.add(exc);
+          synchronized(ConcurrentMergeScheduler.this) {
+            exceptions.add(exc);
+          }
           
           if (!suppressExceptions)
             // suppressExceptions is normally only set during
@@ -270,6 +283,9 @@
     }
 
     public String toString() {
+      MergePolicy.OneMerge merge = getRunningMerge();
+      if (merge == null)
+        merge = startMerge;
       return "merge thread: " + merge.segString(dir);
     }
   }
Index: src/java/org/apache/lucene/index/IndexWriter.java
===================================================================
--- src/java/org/apache/lucene/index/IndexWriter.java	(revision 581682)
+++ src/java/org/apache/lucene/index/IndexWriter.java	(working copy)
@@ -1178,7 +1178,9 @@
       if (infoStream != null)
         message("now flush at close");
 
-      flush(true, true);
+      // Only allow a new merge to be triggered if we are
+      // going to wait for merges:
+      flush(waitForMerges, true);
 
       mergePolicy.close();
 
@@ -1953,15 +1955,23 @@
     if (!waitForMerges) {
       // Abort all pending & running merges:
       Iterator it = pendingMerges.iterator();
-      while(it.hasNext())
-        ((MergePolicy.OneMerge) it.next()).abort();
+      while(it.hasNext()) {
+        final MergePolicy.OneMerge merge = (MergePolicy.OneMerge) it.next();
+        if (infoStream != null)
+          message("now abort pending merge " + merge.segString(directory));
+        merge.abort();
+      }
+      pendingMerges.clear();
 
-      pendingMerges.clear();
       it = runningMerges.iterator();
-      while(it.hasNext())
-        ((MergePolicy.OneMerge) it.next()).abort();
+      while(it.hasNext()) {
+        final MergePolicy.OneMerge merge = (MergePolicy.OneMerge) it.next();
+        if (infoStream != null)
+          message("now abort running merge " + merge.segString(directory));
+        merge.abort();
+      }
+      runningMerges.clear();
 
-      runningMerges.clear();
       mergingSegments.clear();
       notifyAll();
     } else {
@@ -3084,7 +3094,7 @@
     return mergedDocCount;
   }
 
-  void addMergeException(MergePolicy.OneMerge merge) {
+  synchronized void addMergeException(MergePolicy.OneMerge merge) {
     if (!mergeExceptions.contains(merge) && mergeGen == merge.mergeGen)
       mergeExceptions.add(merge);
   }
Index: src/java/org/apache/lucene/index/IndexFileDeleter.java
===================================================================
--- src/java/org/apache/lucene/index/IndexFileDeleter.java	(revision 581682)
+++ src/java/org/apache/lucene/index/IndexFileDeleter.java	(working copy)
@@ -100,6 +100,10 @@
   private IndexDeletionPolicy policy;
   private DocumentsWriter docWriter;
 
+  /** Change to true to see details of reference counts when
+   *  infoStream != null */
+  public static boolean VERBOSE_REF_COUNTS = false;
+
   void setInfoStream(PrintStream infoStream) {
     this.infoStream = infoStream;
     if (infoStream != null)
@@ -342,6 +346,8 @@
       deletable = null;
       int size = oldDeletable.size();
       for(int i=0;i<size;i++) {
+        if (infoStream != null)
+          message("delete pending file " + oldDeletable.get(i));
         deleteFile((String) oldDeletable.get(i));
       }
     }
@@ -441,7 +447,7 @@
     for(int i=0;i<size;i++) {
       String fileName = (String) files.get(i);
       RefCount rc = getRefCount(fileName);
-      if (infoStream != null) {
+      if (infoStream != null && VERBOSE_REF_COUNTS) {
         message("  IncRef \"" + fileName + "\": pre-incr count is " + rc.count);
       }
       rc.IncRef();
@@ -457,7 +463,7 @@
 
   private void decRef(String fileName) throws IOException {
     RefCount rc = getRefCount(fileName);
-    if (infoStream != null) {
+    if (infoStream != null && VERBOSE_REF_COUNTS) {
       message("  DecRef \"" + fileName + "\": pre-decr count is " + rc.count);
     }
     if (0 == rc.DecRef()) {
