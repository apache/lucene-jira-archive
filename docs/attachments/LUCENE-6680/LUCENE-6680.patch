Index: lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest.java	(revision 09d7a2b9dd266fbfff777a813cba531710a97614)
+++ lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggesterTest.java	(revision )
@@ -22,6 +22,8 @@
 import java.util.List;
 
 import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.analysis.standard.StandardAnalyzer;
 import org.apache.lucene.analysis.util.CharArraySet;
 import org.apache.lucene.search.suggest.Input;
@@ -29,9 +31,11 @@
 import org.apache.lucene.search.suggest.Lookup;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.TestUtil;
 
 public class BlendedInfixSuggesterTest extends LuceneTestCase {
 
+
   /**
    * Test the weight transformation depending on the position
    * of the matching term.
@@ -192,6 +196,65 @@
     suggester.close();
   }
 
+  public void testBlendedInfixSuggesterDedupsOnWeightTitleAndPayload() throws Exception {
+
+    //exactly same inputs
+    Input[] inputDocuments = new Input[] {
+        new Input("lend me your ear", 7, new BytesRef("uid1")),
+        new Input("lend me your ear", 7, new BytesRef("uid1")),
+    };
+    duplicateCheck(inputDocuments, 1);
+
+    // inputs differ on payload
+    inputDocuments = new Input[] {
+        new Input("lend me your ear", 7, new BytesRef("uid1")),
+        new Input("lend me your ear", 7, new BytesRef("uid2")),
+    };
+    duplicateCheck(inputDocuments, 2);
+
+    //exactly same input without payloads
+    inputDocuments = new Input[] {
+        new Input("lend me your ear", 7),
+        new Input("lend me your ear", 7),
+    };
+    duplicateCheck(inputDocuments, 1);
+
+    //Same input with first has payloads, second does not
+    inputDocuments = new Input[] {
+        new Input("lend me your ear", 7, new BytesRef("uid1")),
+        new Input("lend me your ear", 7),
+    };
+    duplicateCheck(inputDocuments, 2);
+
+    /**same input, first not having a payload, the second having payload
+     * we would expect 2 entries out but we are getting only 1 because
+     * the InputArrayIterator#hasPayloads() returns false because the first
+     * item has no payload, therefore, when ingested, none of the 2 input has payload and become 1
+     */
+    inputDocuments = new Input[] {
+        new Input("lend me your ear", 7),
+        new Input("lend me your ear", 7, new BytesRef("uid2")),
+    };
+    List<Lookup.LookupResult> results = duplicateCheck(inputDocuments, 1);
+    assertNull(results.get(0).payload);
+
+
+    //exactly same inputs but different weight
+    inputDocuments = new Input[] {
+        new Input("lend me your ear", 1, new BytesRef("uid1")),
+        new Input("lend me your ear", 7, new BytesRef("uid1")),
+    };
+    duplicateCheck(inputDocuments, 2);
+
+    //exactly same inputs but different text
+    inputDocuments = new Input[] {
+        new Input("lend me your earings", 7, new BytesRef("uid1")),
+        new Input("lend me your ear", 7, new BytesRef("uid1")),
+    };
+    duplicateCheck(inputDocuments, 2);
+
+  }
+
   public void /*testT*/rying() throws IOException {
 
     BytesRef lake = new BytesRef("lake");
@@ -236,4 +299,23 @@
 
     return -1;
   }
+
+  private List<Lookup.LookupResult> duplicateCheck(Input[] inputs, int expectedSuggestionCount) throws IOException {
+
+    Analyzer a = new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false);
+    BlendedInfixSuggester suggester = new BlendedInfixSuggester(newDirectory(), a, a,  AnalyzingInfixSuggester.DEFAULT_MIN_PREFIX_CHARS,
+        BlendedInfixSuggester.BlenderType.POSITION_RECIPROCAL,10, false);
+
+    InputArrayIterator inputArrayIterator = new InputArrayIterator(inputs);
+    suggester.build(inputArrayIterator);
+
+    List<Lookup.LookupResult> results = suggester.lookup(TestUtil.stringToCharSequence("ear", random()), 10, true, true);
+    assertEquals(expectedSuggestionCount, results.size());
+
+    suggester.close();
+    a.close();
+
+    return results;
+  }
+
 }
Index: lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester.java	(revision 09d7a2b9dd266fbfff777a813cba531710a97614)
+++ lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/BlendedInfixSuggester.java	(revision )
@@ -341,10 +341,18 @@
         return -1;
       }
 
-      // otherwise on alphabetic order
+      //otherwise on alphabetic order
-      return CHARSEQUENCE_COMPARATOR.compare(o1.key, o2.key);
+      int keyCompare = CHARSEQUENCE_COMPARATOR.compare(o1.key, o2.key);
+
+      // if same weight and title, use the payload if there is one
+      if (keyCompare == 0 && o1.payload != null) {
+        return o1.payload.compareTo(o2.payload);
-    }
+      }
+
+      return keyCompare;
+
-  }
+    }
 
+  }
 }
 
