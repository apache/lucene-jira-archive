From d7e297f49b3e636387f0b0525ed43a1be1a69ac3 Mon Sep 17 00:00:00 2001
From: Julien Massenet <julien.massenet@mail.rakuten.com>
Date: Wed, 31 Jan 2018 16:38:03 +0100
Subject: [PATCH] LUCENE-8146: centralize access to the tests.seed system
 property

Make sure that an empty seed does not trigger
java.lang.ExceptionInInitializerError
---
 .../java/org/apache/lucene/util/SeedProvider.java  | 60 ++++++++++++++++++++++
 .../java/org/apache/lucene/util/StringHelper.java  |  4 +-
 .../OverseerCollectionMessageHandler.java          | 15 ++----
 .../java/org/apache/solr/core/BlobRepository.java  | 16 ++----
 .../java/org/apache/solr/servlet/HttpSolrCall.java | 15 ++----
 5 files changed, 74 insertions(+), 36 deletions(-)
 create mode 100644 lucene/core/src/java/org/apache/lucene/util/SeedProvider.java

diff --git a/lucene/core/src/java/org/apache/lucene/util/SeedProvider.java b/lucene/core/src/java/org/apache/lucene/util/SeedProvider.java
new file mode 100644
index 0000000000..84f50363d6
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/util/SeedProvider.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.util;
+
+import java.util.Random;
+
+/**
+ * Provides a seed for operations that require one (such as initializing a Random instance).
+ * <p>
+ * Anytime randomness is used, it makes it much harder to have reproducible tests.
+ * To avoid that, use the externally provided seed if there is one for initializing randomness sources.
+ */
+public abstract class SeedProvider {
+  public static final String SYSPROP_SEED = "tests.seed";
+
+  private SeedProvider() {
+  }
+
+  /**
+   * Gets the external seed, or null if none was set.
+   */
+  public static String getExternalSeed() {
+    String value = System.getProperty(SYSPROP_SEED);
+    if (value != null) {
+      value = value.trim();
+      if (value.trim().isEmpty()) {
+        value = null;
+      }
+    }
+    return value;
+  }
+
+  /**
+   * Get a Random instance, seeded with the external seed if available.
+   */
+  public static Random getSeededRandom() {
+    String seed = SeedProvider.getExternalSeed();
+    Random random;
+    if (seed == null) {
+      random = new Random();
+    } else {
+      random = new Random(seed.hashCode());
+    }
+    return random;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/util/StringHelper.java b/lucene/core/src/java/org/apache/lucene/util/StringHelper.java
index 6d958bace5..e81c06f3fd 100644
--- a/lucene/core/src/java/org/apache/lucene/util/StringHelper.java
+++ b/lucene/core/src/java/org/apache/lucene/util/StringHelper.java
@@ -153,7 +153,7 @@ public abstract class StringHelper {
   public static final int GOOD_FAST_HASH_SEED;
 
   static {
-    String prop = System.getProperty("tests.seed");
+    String prop = SeedProvider.getExternalSeed();
     if (prop != null) {
       // So if there is a test failure that relied on hash
       // order, we remain reproducible based on the test seed:
@@ -233,7 +233,7 @@ public abstract class StringHelper {
     Arrays.fill(maskBytes128, (byte) 0xff);
     mask128 = new BigInteger(1, maskBytes128);
     
-    String prop = System.getProperty("tests.seed");
+    String prop = SeedProvider.getExternalSeed();
 
     // State for xorshift128:
     long x0;
diff --git a/solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler.java b/solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler.java
index e482560be4..40c933fed3 100644
--- a/solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler.java
+++ b/solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler.java
@@ -34,6 +34,7 @@ import java.util.concurrent.TimeUnit;
 
 import com.google.common.collect.ImmutableMap;
 import org.apache.commons.lang.StringUtils;
+import org.apache.lucene.util.SeedProvider;
 import org.apache.solr.client.solrj.SolrResponse;
 import org.apache.solr.client.solrj.SolrServerException;
 import org.apache.solr.client.solrj.cloud.DistributedQueue;
@@ -171,17 +172,9 @@ public class OverseerCollectionMessageHandler implements OverseerMessageHandler,
       new SynchronousQueue<>(),
       new DefaultSolrThreadFactory("OverseerCollectionMessageHandlerThreadFactory"));
 
-  protected static final Random RANDOM;
-  static {
-    // We try to make things reproducible in the context of our tests by initializing the random instance
-    // based on the current seed
-    String seed = System.getProperty("tests.seed");
-    if (seed == null) {
-      RANDOM = new Random();
-    } else {
-      RANDOM = new Random(seed.hashCode());
-    }
-  }
+  // We try to make things reproducible in the context of our tests by initializing the random instance
+  // based on the current seed
+  protected static final Random RANDOM = SeedProvider.getSeededRandom();
 
   final Map<CollectionAction, Cmd> commandMap;
 
diff --git a/solr/core/src/java/org/apache/solr/core/BlobRepository.java b/solr/core/src/java/org/apache/solr/core/BlobRepository.java
index e4d5e04955..009dbd6a56 100644
--- a/solr/core/src/java/org/apache/solr/core/BlobRepository.java
+++ b/solr/core/src/java/org/apache/solr/core/BlobRepository.java
@@ -36,6 +36,7 @@ import java.util.regex.Pattern;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.HttpClient;
 import org.apache.http.client.methods.HttpGet;
+import org.apache.lucene.util.SeedProvider;
 import org.apache.solr.common.SolrException;
 import org.apache.solr.common.cloud.ClusterState;
 import org.apache.solr.common.cloud.DocCollection;
@@ -53,20 +54,11 @@ import org.slf4j.LoggerFactory;
  */
 public class BlobRepository {
   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
-  static final Random RANDOM;
+  // We try to make things reproducible in the context of our tests by initializing the random instance
+  // based on the current seed
+  static final Random RANDOM = SeedProvider.getSeededRandom();
   static final Pattern BLOB_KEY_PATTERN_CHECKER = Pattern.compile(".*/\\d+");
 
-  static {
-    // We try to make things reproducible in the context of our tests by initializing the random instance
-    // based on the current seed
-    String seed = System.getProperty("tests.seed");
-    if (seed == null) {
-      RANDOM = new Random();
-    } else {
-      RANDOM = new Random(seed.hashCode());
-    }
-  }
-
   private final CoreContainer coreContainer;
   private Map<String, BlobContent> blobs = createMap();
 
diff --git a/solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java b/solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java
index ba4aa137ed..6f84f68ef9 100644
--- a/solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java
+++ b/solr/core/src/java/org/apache/solr/servlet/HttpSolrCall.java
@@ -56,6 +56,7 @@ import org.apache.http.client.methods.HttpPost;
 import org.apache.http.client.methods.HttpPut;
 import org.apache.http.client.methods.HttpRequestBase;
 import org.apache.http.entity.InputStreamEntity;
+import org.apache.lucene.util.SeedProvider;
 import org.apache.solr.api.ApiBag;
 import org.apache.solr.client.solrj.impl.CloudSolrClient;
 import org.apache.solr.client.solrj.impl.HttpClientUtil;
@@ -135,17 +136,9 @@ import static org.apache.solr.servlet.SolrDispatchFilter.Action.RETURN;
 public class HttpSolrCall {
   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
 
-  static final Random random;
-  static {
-    // We try to make things reproducible in the context of our tests by initializing the random instance
-    // based on the current seed
-    String seed = System.getProperty("tests.seed");
-    if (seed == null) {
-      random = new Random();
-    } else {
-      random = new Random(seed.hashCode());
-    }
-  }
+  // We try to make things reproducible in the context of our tests by initializing the random instance
+  // based on the current seed
+  static final Random random = SeedProvider.getSeededRandom();
 
   protected final SolrDispatchFilter solrDispatchFilter;
   protected final CoreContainer cores;
-- 
2.16.1

