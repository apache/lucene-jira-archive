diff --git a/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java b/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
index f077bfd..bec137c 100644
--- a/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
+++ b/lucene/core/src/java/org/apache/lucene/util/QueryBuilder.java
@@ -25,6 +25,7 @@ import java.util.List;
 import org.apache.lucene.analysis.Analyzer;
 import org.apache.lucene.analysis.CachingTokenFilter;
 import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionLengthAttribute;
 import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
@@ -276,6 +277,7 @@ public class QueryBuilder {
       TermToBytesRefAttribute termAtt = stream.getAttribute(TermToBytesRefAttribute.class);
       PositionIncrementAttribute posIncAtt = stream.addAttribute(PositionIncrementAttribute.class);
       PositionLengthAttribute posLenAtt = stream.addAttribute(PositionLengthAttribute.class);
+      CharTermAttribute charAtt = stream.getAttribute(CharTermAttribute.class);
 
       if (termAtt == null) {
         return null; 
@@ -288,6 +290,7 @@ public class QueryBuilder {
       int positionCount = 0;
       boolean hasSynonyms = false;
       boolean isGraph = false;
+      boolean isMultiTerm = false;
 
       stream.reset();
       while (stream.incrementToken()) {
@@ -303,6 +306,9 @@ public class QueryBuilder {
         if (enableGraphQueries && positionLength > 1) {
           isGraph = true;
         }
+
+        if (isMultiTerm(charAtt))
+          isMultiTerm = true;
       }
       
       // phase 2: based on token count, presence of synonyms, and options
@@ -313,7 +319,7 @@ public class QueryBuilder {
       } else if (numTokens == 1) {
         // single term
         return analyzeTerm(field, stream);
-      } else if (isGraph) {
+      } else if (isGraph || (quoted && isMultiTerm)) {
         // graph
         if (quoted) {
           return analyzeGraphPhrase(stream, field, phraseSlop);
@@ -345,6 +351,13 @@ public class QueryBuilder {
   }
 
   /**
+   * Hook for subclasses to check if an analyzed term will be expanded into a MultiTermQuery
+   */
+  protected boolean isMultiTerm(CharTermAttribute charAtt) {
+    return false;
+  }
+
+  /**
    * Creates a span query from the tokenstream.  In the case of a single token, a simple <code>SpanTermQuery</code> is
    * returned.  When multiple tokens, an ordered <code>SpanNearQuery</code> with slop of 0 is returned.
    */
@@ -354,9 +367,9 @@ public class QueryBuilder {
       return null;
     }
 
-    List<SpanTermQuery> terms = new ArrayList<>();
+    List<SpanQuery> terms = new ArrayList<>();
     while (in.incrementToken()) {
-      terms.add(new SpanTermQuery(new Term(field, termAtt.getBytesRef())));
+      terms.add(newSpanTermQuery(new Term(field, termAtt.getBytesRef())));
     }
 
     if (terms.isEmpty()) {
@@ -364,7 +377,7 @@ public class QueryBuilder {
     } else if (terms.size() == 1) {
       return terms.get(0);
     } else {
-      return new SpanNearQuery(terms.toArray(new SpanTermQuery[0]), 0, true);
+      return new SpanNearQuery(terms.toArray(new SpanQuery[0]), 0, true);
     }
   }
 
@@ -579,11 +592,11 @@ public class QueryBuilder {
         Term[] terms = graph.getTerms(field, start);
         assert terms.length > 0;
         if (terms.length == 1) {
-          queryPos = new SpanTermQuery(terms[0]);
+          queryPos = newSpanTermQuery(terms[0]);
         } else {
-          SpanTermQuery[] orClauses = new SpanTermQuery[terms.length];
+          SpanQuery[] orClauses = new SpanQuery[terms.length];
           for (int idx = 0; idx < terms.length; idx++) {
-            orClauses[idx] = new SpanTermQuery(terms[idx]);
+            orClauses[idx] = newSpanTermQuery(terms[idx]);
           }
 
           queryPos = new SpanOrQuery(orClauses);
@@ -641,6 +654,18 @@ public class QueryBuilder {
     }
     return bq;
   }
+
+  /**
+   * Builds a new SpanTermQuery instance
+   * <p>
+   * This is intended for subclasses that wish to customize the generated queries
+   * </p>
+   * @param term term
+   * @return new SpanTermQuery instance
+   */
+  protected SpanQuery newSpanTermQuery(Term term) {
+    return new SpanTermQuery(term);
+  }
   
   /**
    * Builds a new TermQuery instance.
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java b/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
index fece166..e3bf0b8 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestQueryBuilder.java
@@ -36,6 +36,8 @@ import org.apache.lucene.search.PhraseQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.SynonymQuery;
 import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.WildcardQuery;
+import org.apache.lucene.search.spans.SpanMultiTermQueryWrapper;
 import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanOrQuery;
 import org.apache.lucene.search.spans.SpanQuery;
@@ -443,4 +445,48 @@ public class TestQueryBuilder extends LuceneTestCase {
     QueryBuilder builder = new QueryBuilder(analyzer);
     assertNull(builder.createBooleanQuery("field", "whatever"));
   }
+
+  class MultiTermQueryBuilder extends QueryBuilder {
+
+    public MultiTermQueryBuilder(Analyzer analyzer) {
+      super(analyzer);
+    }
+
+    @Override
+    protected SpanQuery newSpanTermQuery(Term term) {
+      if (term.text().contains("*"))
+        return new SpanMultiTermQueryWrapper<>(new WildcardQuery(term));
+      return super.newSpanTermQuery(term);
+    }
+
+    @Override
+    protected Query newTermQuery(Term term) {
+      if (term.text().contains("*"))
+        return new WildcardQuery(term);
+      return super.newTermQuery(term);
+    }
+
+    @Override
+    protected boolean isMultiTerm(CharTermAttribute charAtt) {
+      return charAtt.toString().contains("*");
+    }
+  }
+
+  public void testMultiTermHooks() {
+
+    QueryBuilder builder = new MultiTermQueryBuilder(new MockAnalyzer(random()));
+
+    Query expectedSingle = new WildcardQuery(new Term("field", "term*"));
+    assertEquals(expectedSingle, builder.createPhraseQuery("field", "term*"));
+
+    Query expectedPhrase = SpanNearQuery.newOrderedNearQuery("field")
+        .addClause(new SpanTermQuery(new Term("field", "first")))
+        .addClause(new SpanMultiTermQueryWrapper<>(new WildcardQuery(new Term("field", "secon*"))))
+        .build();
+    assertEquals(expectedPhrase, builder.createPhraseQuery("field", "first secon*"));
+
+    Query expectedSimplePhrase = new PhraseQuery("field", "first", "second");
+    assertEquals(expectedSimplePhrase, builder.createPhraseQuery("field", "first second"));
+
+  }
 }
