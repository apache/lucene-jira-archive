diff --git a/.gitignore b/.gitignore
index a0d9c5612b4..6543be00231 100644
--- a/.gitignore
+++ b/.gitignore
@@ -32,3 +32,4 @@ __pycache__
 
 # SDKMAN
 .sdkmanrc
+/.metadata/
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriNotQuery.java b/lucene/core/src/java/org/apache/lucene/search/IndriNotQuery.java
new file mode 100644
index 00000000000..cb7a61286be
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriNotQuery.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.List;
+
+public class IndriNotQuery extends IndriQuery {
+
+  public IndriNotQuery(List<BooleanClause> clauses) {
+    super(clauses);
+  }
+
+  @Override
+  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreModes, float boost)
+      throws IOException {
+    IndriNotQuery query = this;
+    return new IndriNotWeight(query, searcher, scoreModes, boost);
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriNotScorer.java b/lucene/core/src/java/org/apache/lucene/search/IndriNotScorer.java
new file mode 100644
index 00000000000..7d8ce0a99d6
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriNotScorer.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import java.io.IOException;
+
+public class IndriNotScorer extends IndriScorer {
+  private Scorer subScorer;
+
+  protected IndriNotScorer(Weight weight, Scorer subScorer, float boost) {
+    super(weight, boost);
+    this.subScorer = subScorer;
+  }
+
+  @Override
+  public float score() throws IOException {
+    float score = subScorer.score();
+    if (subScorer instanceof IndriScorer) {
+      score *= ((IndriScorer) subScorer).getBoost();
+    }
+    return (float) (Math.log(1.0 - Math.exp(score)));
+  }
+
+  @Override
+  public float smoothingScore(int docId) throws IOException {
+    float score = 0.0f;
+    score = subScorer.smoothingScore(docId);
+    if (subScorer instanceof IndriScorer) {
+      score *= ((IndriScorer) subScorer).getBoost();
+    }
+    return (float) (Math.log(1.0 - Math.exp(score)));
+  }
+
+  @Override
+  public int docID() {
+    return subScorer.docID();
+  }
+
+  @Override
+  public DocIdSetIterator iterator() {
+    return subScorer.iterator();
+  }
+
+  @Override
+  public float getMaxScore(int upTo) throws IOException {
+    return 0;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriNotWeight.java b/lucene/core/src/java/org/apache/lucene/search/IndriNotWeight.java
new file mode 100644
index 00000000000..0f371ad455a
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriNotWeight.java
@@ -0,0 +1,101 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import org.apache.lucene.index.LeafReaderContext;
+
+public class IndriNotWeight extends Weight {
+
+  private final IndriQuery query;
+  private final Weight weight;
+  private final float boost;
+
+  public IndriNotWeight(
+      IndriNotQuery query, IndexSearcher searcher, ScoreMode scoreMode, float boost)
+      throws IOException {
+    super(query);
+    this.query = query;
+    this.boost = boost;
+    // Not Query only has one clause
+    BooleanClause c = query.iterator().next();
+    weight = searcher.createWeight(c.getQuery(), scoreMode, 1.0f);
+  }
+
+  private Scorer getScorer(LeafReaderContext context) throws IOException {
+    Scorer scorer = weight.scorer(context);
+    if (scorer != null) {
+      Scorer scorerWrapper = new IndriNotScorer(this, scorer, boost);
+      return scorerWrapper;
+    }
+    return null;
+  }
+
+  @Override
+  public Scorer scorer(LeafReaderContext context) throws IOException {
+    return getScorer(context);
+  }
+
+  @Override
+  public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {
+    Scorer scorer = getScorer(context);
+    if (scorer != null) {
+      BulkScorer bulkScorer = new DefaultBulkScorer(scorer);
+      return bulkScorer;
+    }
+    return null;
+  }
+
+  @Override
+  public boolean isCacheable(LeafReaderContext ctx) {
+    if (weight.isCacheable(ctx) == false) return false;
+    return true;
+  }
+
+  @Override
+  public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+    List<Explanation> subs = new ArrayList<>();
+    boolean fail = false;
+    Iterator<BooleanClause> cIter = query.iterator();
+    BooleanClause c = cIter.next();
+    Explanation e = weight.explain(context, doc);
+    if (e.isMatch()) {
+      subs.add(e);
+    } else if (c.isRequired()) {
+      subs.add(
+          Explanation.noMatch("no match on required clause (" + c.getQuery().toString() + ")", e));
+      fail = true;
+    }
+    if (fail) {
+      return Explanation.noMatch(
+          "Failure to meet condition(s) of required/prohibited clause(s)", subs);
+    } else {
+      Scorer scorer = scorer(context);
+      if (scorer != null) {
+        int advanced = scorer.iterator().advance(doc);
+        assert advanced == doc;
+        return Explanation.match(scorer.score(), "sum of:", subs);
+      } else {
+        return Explanation.noMatch(
+            "Failure to meet condition(s) of required/prohibited clause(s)", subs);
+      }
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriOrQuery.java b/lucene/core/src/java/org/apache/lucene/search/IndriOrQuery.java
new file mode 100644
index 00000000000..7c25a027e58
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriOrQuery.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.List;
+
+public class IndriOrQuery extends IndriQuery {
+
+  public IndriOrQuery(List<BooleanClause> clauses) {
+    super(clauses);
+  }
+
+  @Override
+  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost)
+      throws IOException {
+    IndriOrQuery query = this;
+    return new IndriOrWeight(query, searcher, scoreMode, boost);
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriOrScorer.java b/lucene/core/src/java/org/apache/lucene/search/IndriOrScorer.java
new file mode 100644
index 00000000000..8d89d3338d9
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriOrScorer.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.List;
+
+public class IndriOrScorer extends IndriDisjunctionScorer {
+
+  protected IndriOrScorer(Weight weight, List<Scorer> subScorers, ScoreMode scoreMode, float boost)
+      throws IOException {
+    super(weight, subScorers, scoreMode, boost);
+  }
+
+  @Override
+  public float score(List<Scorer> subScorers) throws IOException {
+    int docId = this.docID();
+    return scoreDoc(subScorers, docId);
+  }
+
+  @Override
+  public float smoothingScore(List<Scorer> subScorers, int docId) throws IOException {
+    return scoreDoc(subScorers, docId);
+  }
+
+  private float scoreDoc(List<Scorer> subScorers, int docId) throws IOException {
+    double score = 1;
+    for (Scorer scorer : subScorers) {
+      int scorerDocId = scorer.docID();
+      if (docId == scorerDocId) {
+        score *= (1 - Math.exp(scorer.score()));
+      } else {
+        score *= (1 - Math.exp(scorer.smoothingScore(docId)));
+      }
+    }
+    return (float) (Math.log(1.0 - score));
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriOrWeight.java b/lucene/core/src/java/org/apache/lucene/search/IndriOrWeight.java
new file mode 100644
index 00000000000..8af93b75c13
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriOrWeight.java
@@ -0,0 +1,121 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import org.apache.lucene.index.LeafReaderContext;
+
+public class IndriOrWeight extends Weight {
+
+  private final IndriQuery query;
+  private final float boost;
+  private final ArrayList<Weight> weights;
+  private final ScoreMode scoreMode;
+
+  public IndriOrWeight(IndriOrQuery query, IndexSearcher searcher, ScoreMode scoreMode, float boost)
+      throws IOException {
+    super(query);
+    this.query = query;
+    this.boost = boost;
+    this.scoreMode = scoreMode;
+    weights = new ArrayList<>();
+    for (BooleanClause c : query) {
+      Weight w = searcher.createWeight(c.getQuery(), scoreMode, 1.0f);
+      weights.add(w);
+    }
+  }
+
+  private Scorer getScorer(LeafReaderContext context) throws IOException {
+    List<Scorer> subScorers = new ArrayList<>();
+    for (Weight w : weights) {
+      Scorer scorer = w.scorer(context);
+      if (scorer != null) {
+        subScorers.add(scorer);
+      }
+    }
+
+    if (subScorers.isEmpty()) {
+      return null;
+    }
+
+    Scorer scorer = subScorers.get(0);
+    if (subScorers.size() > 1) {
+      scorer = new IndriOrScorer(this, subScorers, scoreMode, boost);
+    }
+    return scorer;
+  }
+
+  @Override
+  public Scorer scorer(LeafReaderContext context) throws IOException {
+    return getScorer(context);
+  }
+
+  @Override
+  public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {
+    Scorer scorer = getScorer(context);
+    if (scorer != null) {
+      BulkScorer bulkScorer = new DefaultBulkScorer(scorer);
+      return bulkScorer;
+    }
+    return null;
+  }
+
+  @Override
+  public boolean isCacheable(LeafReaderContext ctx) {
+    for (Weight w : weights) {
+      if (w.isCacheable(ctx) == false) return false;
+    }
+    return true;
+  }
+
+  @Override
+  public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+    List<Explanation> subs = new ArrayList<>();
+    boolean fail = false;
+    Iterator<BooleanClause> cIter = query.iterator();
+    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext(); ) {
+      Weight w = wIter.next();
+      BooleanClause c = cIter.next();
+      Explanation e = w.explain(context, doc);
+      if (e.isMatch()) {
+        subs.add(e);
+      } else if (c.isRequired()) {
+        subs.add(
+            Explanation.noMatch(
+                "no match on required clause (" + c.getQuery().toString() + ")", e));
+        fail = true;
+      }
+    }
+    if (fail) {
+      return Explanation.noMatch(
+          "Failure to meet condition(s) of required/prohibited clause(s)", subs);
+    } else {
+      Scorer scorer = scorer(context);
+      if (scorer != null) {
+        int advanced = scorer.iterator().advance(doc);
+        assert advanced == doc;
+        return Explanation.match(scorer.score(), "sum of:", subs);
+      } else {
+        return Explanation.noMatch(
+            "Failure to meet condition(s) of required/prohibited clause(s)", subs);
+      }
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriWeightedSumQuery.java b/lucene/core/src/java/org/apache/lucene/search/IndriWeightedSumQuery.java
new file mode 100644
index 00000000000..4e405fd877a
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriWeightedSumQuery.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.List;
+
+public class IndriWeightedSumQuery extends IndriQuery {
+
+  public IndriWeightedSumQuery(List<BooleanClause> clauses) {
+    super(clauses);
+  }
+
+  @Override
+  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost)
+      throws IOException {
+    IndriWeightedSumQuery query = this;
+    return new IndriWeightedSumWeight(query, searcher, scoreMode, boost);
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriWeightedSumScorer.java b/lucene/core/src/java/org/apache/lucene/search/IndriWeightedSumScorer.java
new file mode 100644
index 00000000000..396983abbab
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriWeightedSumScorer.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.List;
+
+public class IndriWeightedSumScorer extends IndriDisjunctionScorer {
+
+  protected IndriWeightedSumScorer(
+      Weight weight, List<Scorer> subScorers, ScoreMode scoreMode, float boost) throws IOException {
+    super(weight, subScorers, scoreMode, boost);
+  }
+
+  @Override
+  public float score(List<Scorer> subScorers) throws IOException {
+    int docId = this.docID();
+    return scoreDoc(subScorers, docId);
+  }
+
+  @Override
+  public float smoothingScore(List<Scorer> subScorers, int docId) throws IOException {
+    return scoreDoc(subScorers, docId);
+  }
+
+  private float scoreDoc(List<Scorer> subScorers, int docId) throws IOException {
+    double score = 0;
+    double boostSum = 0.0;
+    for (Scorer scorer : subScorers) {
+      if (scorer instanceof IndriScorer) {
+        IndriScorer indriScorer = (IndriScorer) scorer;
+        int scorerDocId = indriScorer.docID();
+        double subScore = 0;
+        if (docId == scorerDocId) {
+          score += indriScorer.getBoost() * Math.exp(indriScorer.score());
+        } else {
+          double smoothingScore =
+              indriScorer.getBoost() * Math.exp(indriScorer.smoothingScore(docId));
+          score += smoothingScore;
+        }
+        subScore *= indriScorer.getBoost();
+        score += subScore;
+        boostSum += indriScorer.getBoost();
+      }
+    }
+    if (boostSum == 0) {
+      return 0;
+    } else {
+      return (float) (Math.log((score / boostSum)));
+    }
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/IndriWeightedSumWeight.java b/lucene/core/src/java/org/apache/lucene/search/IndriWeightedSumWeight.java
new file mode 100644
index 00000000000..daf3d43726b
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/IndriWeightedSumWeight.java
@@ -0,0 +1,123 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import org.apache.lucene.index.LeafReaderContext;
+
+public class IndriWeightedSumWeight extends Weight {
+  private final IndriWeightedSumQuery query;
+
+  private final ArrayList<Weight> weights;
+  private final ScoreMode scoreMode;
+  private final float boost;
+
+  public IndriWeightedSumWeight(
+      IndriWeightedSumQuery query, IndexSearcher searcher, ScoreMode scoreMode, float boost)
+      throws IOException {
+    super(query);
+    this.query = query;
+    this.boost = boost;
+    this.scoreMode = scoreMode;
+    weights = new ArrayList<>();
+    for (BooleanClause c : query) {
+      Weight w = searcher.createWeight(c.getQuery(), scoreMode, 1.0f);
+      weights.add(w);
+    }
+  }
+
+  private Scorer getScorer(LeafReaderContext context) throws IOException {
+    List<Scorer> subScorers = new ArrayList<>();
+    Iterator<BooleanClause> cIter = query.iterator();
+    for (Weight w : weights) {
+      BooleanClause c = cIter.next();
+      Scorer scorer = w.scorer(context);
+      if (scorer != null) {
+        subScorers.add(scorer);
+      }
+    }
+    if (subScorers.isEmpty()) {
+      return null;
+    }
+
+    Scorer scorer = subScorers.get(0);
+    if (subScorers.size() > 1) {
+      scorer = new IndriWeightedSumScorer(this, subScorers, scoreMode, boost);
+    }
+    return scorer;
+  }
+
+  @Override
+  public Scorer scorer(LeafReaderContext context) throws IOException {
+    return getScorer(context);
+  }
+
+  @Override
+  public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {
+    Scorer scorer = getScorer(context);
+    if (scorer != null) {
+      BulkScorer bulkScorer = new DefaultBulkScorer(scorer);
+      return bulkScorer;
+    }
+    return null;
+  }
+
+  @Override
+  public boolean isCacheable(LeafReaderContext ctx) {
+    for (Weight w : weights) {
+      if (w.isCacheable(ctx) == false) return false;
+    }
+    return true;
+  }
+
+  @Override
+  public Explanation explain(LeafReaderContext context, int doc) throws IOException {
+    List<Explanation> subs = new ArrayList<>();
+    boolean fail = false;
+    Iterator<BooleanClause> cIter = query.iterator();
+    for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext(); ) {
+      Weight w = wIter.next();
+      BooleanClause c = cIter.next();
+      Explanation e = w.explain(context, doc);
+      if (e.isMatch()) {
+        subs.add(e);
+      } else if (c.isRequired()) {
+        subs.add(
+            Explanation.noMatch(
+                "no match on required clause (" + c.getQuery().toString() + ")", e));
+        fail = true;
+      }
+    }
+    if (fail) {
+      return Explanation.noMatch(
+          "Failure to meet condition(s) of required/prohibited clause(s)", subs);
+    } else {
+      Scorer scorer = scorer(context);
+      if (scorer != null) {
+        int advanced = scorer.iterator().advance(doc);
+        assert advanced == doc;
+        return Explanation.match(scorer.score(), "sum of:", subs);
+      } else {
+        return Explanation.noMatch(
+            "Failure to meet condition(s) of required/prohibited clause(s)", subs);
+      }
+    }
+  }
+}
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/indri/IndriQueryParser.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/indri/IndriQueryParser.java
new file mode 100644
index 00000000000..ac9dd585a83
--- /dev/null
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/indri/IndriQueryParser.java
@@ -0,0 +1,392 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.queryparser.indri;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.List;
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.TokenStream;
+import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.search.BoostQuery;
+import org.apache.lucene.search.IndriAndQuery;
+import org.apache.lucene.search.IndriNotQuery;
+import org.apache.lucene.search.IndriOrQuery;
+import org.apache.lucene.search.IndriWeightedSumQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+
+public class IndriQueryParser {
+
+  private static final String AND = "and";
+  private static final String OR = "or";
+  private static final String WAND = "wand";
+  private static final String WEIGHT = "weight";
+  private static final String WSUM = "wsum";
+  private static final String COMBINE = "combine";
+  private static final String NOT = "not";
+
+  private final Analyzer analyzer;
+  private String field;
+
+  public IndriQueryParser(Analyzer analyzer) throws IOException {
+    this.analyzer = analyzer;
+    this.field = "fulltext";
+  }
+
+  public IndriQueryParser(Analyzer analyzer, String field) throws IOException {
+    this.analyzer = analyzer;
+    this.field = field;
+  }
+
+  /**
+   * Count the number of occurrences of character c in string s.
+   *
+   * @param c A character.
+   * @param s A string.
+   */
+  private static int countChars(String s, char c) {
+    int count = 0;
+
+    for (int i = 0; i < s.length(); i++) {
+      if (s.charAt(i) == c) {
+        count++;
+      }
+    }
+    return count;
+  }
+
+  /**
+   * Get the index of the right parenenthesis that balances the left-most parenthesis. Return -1 if
+   * it doesn't exist.
+   *
+   * @param s A string containing a query.
+   */
+  private static int indexOfBalencingParen(String s) {
+    int depth = 0;
+
+    for (int i = 0; i < s.length(); i++) {
+      if (s.charAt(i) == '(') {
+        depth++;
+      } else if (s.charAt(i) == ')') {
+        depth--;
+
+        if (depth == 0) {
+          return i;
+        }
+      }
+    }
+    return -1;
+  }
+
+  private QueryParserOperatorQuery createOperator(String operatorName, Occur occur) {
+    QueryParserOperatorQuery operatorQuery = new QueryParserOperatorQuery();
+
+    int operatorDistance = 0;
+    String operatorNameLowerCase = (new String(operatorName)).toLowerCase();
+    operatorNameLowerCase = operatorNameLowerCase.replace("#", "");
+    operatorNameLowerCase = operatorNameLowerCase.replace("~", "");
+
+    operatorQuery.setOperator(operatorNameLowerCase);
+    operatorQuery.setField(field);
+    operatorQuery.setDistance(operatorDistance);
+    operatorQuery.setOccur(occur);
+
+    return operatorQuery;
+  }
+
+  private class PopWeight {
+    private Float weight;
+    private String queryString;
+
+    public Float getWeight() {
+      return weight;
+    }
+
+    public void setWeight(Float weight) {
+      this.weight = weight;
+    }
+
+    public String getQueryString() {
+      return queryString;
+    }
+
+    public void setQueryString(String queryString) {
+      this.queryString = queryString;
+    }
+  }
+
+  /**
+   * Remove a weight from an argument string. Return the weight and the modified argument string.
+   *
+   * @param String A partial query argument string, e.g., "3.0 fu 2.0 bar".
+   * @return PopData<String,String> The weight string and the modified argString (e.g., "3.0" and
+   *     "fu 2.0 bar".
+   */
+  private PopWeight popWeight(String argString, Float weight) {
+
+    String[] substrings = argString.split("[ \t]+", 2);
+
+    if (substrings.length < 2) {
+      syntaxError("Missing weight or query argument");
+    }
+
+    PopWeight popWeight = new PopWeight();
+    popWeight.setWeight(Float.valueOf(substrings[0]));
+    popWeight.setQueryString(substrings[1]);
+
+    return popWeight;
+  }
+
+  /**
+   * Remove a subQuery from an argument string. Return the subquery and the modified argument
+   * string.
+   *
+   * @param String A partial query argument string, e.g., "#and(a b) c d".
+   * @return PopData<String,String> The subquery string and the modified argString (e.g., "#and(a
+   *     b)" and "c d".
+   */
+  private String popSubquery(
+      String argString, QueryParserOperatorQuery queryTree, Float weight, Occur occur) {
+
+    int i = indexOfBalencingParen(argString);
+
+    if (i < 0) { // Query syntax error. The parser
+      i = argString.length(); // handles it. Here, just don't fail.
+    }
+
+    String subquery = argString.substring(0, i + 1);
+    queryTree.addSubquery(parseQueryString(subquery, occur), weight);
+
+    argString = argString.substring(i + 1);
+
+    return argString;
+  }
+
+  /**
+   * Remove a term from an argument string. Return the term and the modified argument string.
+   *
+   * @param String A partial query argument string, e.g., "a b c d".
+   * @return PopData<String,String> The term string and the modified argString (e.g., "a" and "b c
+   *     d".
+   */
+  private String popTerm(
+      String argString, QueryParserOperatorQuery queryTree, Float weight, Occur occur) {
+    String[] substrings = argString.split("[ \t\n\r]+", 2);
+    String token = substrings[0];
+
+    // Split the token into a term and a field.
+    int delimiter = token.indexOf('.');
+    String term = null;
+
+    if (delimiter < 0) {
+      term = token;
+    } else { // Remove the field from the token
+      field = token.substring(delimiter + 1).toLowerCase();
+      term = token.substring(0, delimiter);
+    }
+
+    List<String> tokens = tokenizeString(analyzer, term);
+    for (String t : tokens) {
+      // Creat the term query
+      QueryParserTermQuery termQuery = new QueryParserTermQuery();
+      termQuery.setTerm(t);
+      termQuery.setField(field);
+      termQuery.setOccur(occur);
+      queryTree.addSubquery(termQuery, weight);
+    }
+
+    if (substrings.length < 2) { // Is this the last argument?
+      argString = "";
+    } else {
+      argString = substrings[1];
+    }
+
+    return argString;
+  }
+
+  private QueryParserQuery parseQueryString(String queryString, Occur occur) {
+    // Create the query tree
+    // This simple parser is sensitive to parenthensis placement, so
+    // check for basic errors first.
+    queryString = queryString.trim(); // The last character should be ')'
+
+    if ((countChars(queryString, '(') == 0)
+        || (countChars(queryString, '(') != countChars(queryString, ')'))
+        || (indexOfBalencingParen(queryString) != (queryString.length() - 1))) {
+      // throw IllegalArgumentException("Missing, unbalanced, or misplaced
+      // parentheses");
+    }
+
+    // The query language is prefix-oriented, so the query string can
+    // be processed left to right. At each step, a substring is
+    // popped from the head (left) of the string, and is converted to
+    // a Qry object that is added to the query tree. Subqueries are
+    // handled via recursion.
+
+    // Find the left-most query operator and start the query tree.
+    String[] substrings = queryString.split("[(]", 2);
+    String queryOperator = AND;
+    if (substrings.length > 1) {
+      queryOperator = substrings[0].trim();
+    }
+    QueryParserOperatorQuery queryTree = createOperator(queryOperator, occur);
+
+    // Start consuming queryString by removing the query operator and
+    // its terminating ')'. queryString is always the part of the
+    // query that hasn't been processed yet.
+
+    if (substrings.length > 1) {
+      queryString = substrings[1];
+      queryString = queryString.substring(0, queryString.lastIndexOf(")")).trim();
+    }
+
+    // Each pass below handles one argument to the query operator.
+    // Note: An argument can be a token that produces multiple terms
+    // (e.g., "near-death") or a subquery (e.g., "#and (a b c)").
+    // Recurse on subqueries.
+
+    while (queryString.length() > 0) {
+
+      // If the operator uses weighted query arguments, each pass of
+      // this loop must handle "weight arg". Handle the weight first.
+
+      Float weight = null;
+      if ((queryTree.getOperator().equals(WEIGHT))
+          || (queryTree.getOperator().equals(WAND))
+          || queryTree.getOperator().equals(WSUM)) {
+        PopWeight popWeight = popWeight(queryString, weight);
+        weight = popWeight.getWeight();
+        queryString = popWeight.getQueryString();
+      }
+
+      // Now handle the argument (which could be a subquery).
+      if (queryString.charAt(0) == '#' || queryString.charAt(0) == '~') { // Subquery
+        queryString = popSubquery(queryString, queryTree, weight, occur).trim();
+        occur = Occur.SHOULD;
+      } else { // Term
+        queryString = popTerm(queryString, queryTree, weight, occur);
+        occur = Occur.SHOULD;
+      }
+    }
+
+    return queryTree;
+  }
+
+  public Query parseQuery(String queryString) {
+    // TODO: json or indri query
+    queryString = queryString.replace("'", "");
+    queryString = queryString.replace("\"", "");
+    queryString = queryString.replace("+", " ");
+    queryString = queryString.replace(":", ".");
+    QueryParserQuery qry = parseQueryString(queryString, Occur.SHOULD);
+    return getLuceneQuery(qry);
+  }
+
+  public Query parseJsonQueryString(String jsonQueryString) {
+    // TODO: json implementation
+    return null;
+  }
+
+  private Query getLuceneQuery(QueryParserQuery queryTree) {
+    BooleanClause clause = createBooleanClause(queryTree);
+    Query query = null;
+    if (clause != null) {
+      query = clause.getQuery();
+    }
+    return query;
+  }
+
+  public BooleanClause createBooleanClause(QueryParserQuery queryTree) {
+    Query query = null;
+    if (queryTree instanceof QueryParserOperatorQuery) {
+      QueryParserOperatorQuery operatorQuery = (QueryParserOperatorQuery) queryTree;
+
+      // Create clauses for subqueries
+      List<BooleanClause> clauses = new ArrayList<>();
+      if (operatorQuery.getSubqueries() != null) {
+        for (QueryParserQuery subquery : operatorQuery.getSubqueries()) {
+          BooleanClause clause = createBooleanClause(subquery);
+          if (clause != null) {
+            clauses.add(clause);
+          }
+        }
+
+        // Create Operator
+        if (operatorQuery.getOperator().equalsIgnoreCase(OR)) {
+          query = new IndriOrQuery(clauses);
+        } else if (operatorQuery.getOperator().equalsIgnoreCase(WSUM)) {
+          query = new IndriWeightedSumQuery(clauses);
+        } else if (operatorQuery.getOperator().equalsIgnoreCase(WAND)) {
+          query = new IndriAndQuery(clauses);
+        } else if (operatorQuery.getOperator().equalsIgnoreCase(NOT)) {
+          query = new IndriNotQuery(clauses);
+        } else {
+          query = new IndriAndQuery(clauses);
+        }
+      }
+    } else if (queryTree instanceof QueryParserTermQuery) {
+      // Create term query
+      QueryParserTermQuery termQuery = (QueryParserTermQuery) queryTree;
+      // System.out.println(jsonQuery);
+      String field = "all";
+      if (termQuery.getField() != null) {
+        field = termQuery.getField();
+      }
+      query = new TermQuery(new Term(field, termQuery.getTerm()));
+    }
+    if (queryTree.getBoost() != null && query != null) {
+      query = new BoostQuery(query, queryTree.getBoost().floatValue());
+    }
+    BooleanClause clause = null;
+    if (query != null) {
+      clause = new BooleanClause(query, queryTree.getOccur());
+    }
+    return clause;
+  }
+
+  /**
+   * Given part of a query string, returns an array of terms with stopwords removed and the terms
+   * stemmed using the Krovetz stemmer. Use this method to process raw query terms.
+   */
+  public static List<String> tokenizeString(Analyzer analyzer, String string) {
+    List<String> tokens = new ArrayList<>();
+    try (TokenStream tokenStream = analyzer.tokenStream(null, new StringReader(string))) {
+      tokenStream.reset(); // required
+      while (tokenStream.incrementToken()) {
+        tokens.add(tokenStream.getAttribute(CharTermAttribute.class).toString());
+      }
+    } catch (IOException e) {
+      new RuntimeException(e); // Shouldn't happen...
+    }
+    return tokens;
+  }
+
+  /**
+   * Throw an error specialized for query parsing syntax errors.
+   *
+   * @param errorString The string "Syntax
+   * @throws IllegalArgumentException The query contained a syntax error
+   */
+  private static void syntaxError(String errorString) throws IllegalArgumentException {
+    throw new IllegalArgumentException("Syntax Error: " + errorString);
+  }
+}
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/indri/QueryParserOperatorQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/indri/QueryParserOperatorQuery.java
new file mode 100644
index 00000000000..ec3687abc3a
--- /dev/null
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/indri/QueryParserOperatorQuery.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.queryparser.indri;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class QueryParserOperatorQuery extends QueryParserQuery {
+
+  private String operator;
+  private Integer distance;
+  private List<QueryParserQuery> subqueries;
+
+  public String getOperator() {
+    return operator;
+  }
+
+  public void setOperator(String operator) {
+    this.operator = operator;
+  }
+
+  public Integer getDistance() {
+    return distance;
+  }
+
+  public void setDistance(Integer distance) {
+    this.distance = distance;
+  }
+
+  public List<QueryParserQuery> getSubqueries() {
+    return subqueries;
+  }
+
+  public void setSubqueries(List<QueryParserQuery> subqueries) {
+    this.subqueries = subqueries;
+  }
+
+  public void addSubquery(QueryParserQuery subquery, Float weight) {
+    subquery.setBoost(weight);
+    if (this.subqueries == null) {
+      this.subqueries = new ArrayList<QueryParserQuery>();
+    }
+    this.subqueries.add(subquery);
+  }
+}
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/indri/QueryParserQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/indri/QueryParserQuery.java
new file mode 100644
index 00000000000..ecba774e0da
--- /dev/null
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/indri/QueryParserQuery.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.queryparser.indri;
+
+import org.apache.lucene.search.BooleanClause.Occur;
+
+public abstract class QueryParserQuery {
+
+  private String type; // Either operator or term
+  private Float boost;
+  private String field;
+  private Occur occur;
+
+  public Float getBoost() {
+    return boost;
+  }
+
+  public void setBoost(Float boost) {
+    this.boost = boost;
+  }
+
+  public String getType() {
+    return type;
+  }
+
+  public void setType(String type) {
+    this.type = type;
+  }
+
+  public String getField() {
+    return field;
+  }
+
+  public void setField(String field) {
+    this.field = field;
+  }
+
+  public Occur getOccur() {
+    return occur;
+  }
+
+  public void setOccur(Occur occur) {
+    this.occur = occur;
+  }
+}
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/indri/QueryParserTermQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/indri/QueryParserTermQuery.java
new file mode 100644
index 00000000000..f11c4c60da0
--- /dev/null
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/indri/QueryParserTermQuery.java
@@ -0,0 +1,30 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.queryparser.indri;
+
+public class QueryParserTermQuery extends QueryParserQuery {
+
+  private String term;
+
+  public String getTerm() {
+    return term;
+  }
+
+  public void setTerm(String term) {
+    this.term = term;
+  }
+}
