Index: src/java/org/apache/lucene/index/SegmentInfo.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentInfo.java	(revision 826272)
+++ src/java/org/apache/lucene/index/SegmentInfo.java	(working copy)
@@ -89,7 +89,7 @@
 
   private boolean hasProx;                        // True if this segment has any fields with omitTermFreqAndPositions==false
 
-  private Map diagnostics;
+  private Map<String, String> diagnostics;
 
   public String toString() {
     return "si: "+dir.toString()+" "+name+" docCount: "+docCount+" delCount: "+delCount+" delFileName: "+getDelFileName();
@@ -152,12 +152,12 @@
   }
 
   // must be Map<String, String>
-  void setDiagnostics(Map diagnostics) {
+  void setDiagnostics(Map<String, String> diagnostics) {
     this.diagnostics = diagnostics;
   }
 
   // returns Map<String, String>
-  public Map getDiagnostics() {
+  public Map<String, String> getDiagnostics() {
     return diagnostics;
   }
 
Index: src/java/org/apache/lucene/index/SegmentReader.java
===================================================================
--- src/java/org/apache/lucene/index/SegmentReader.java	(revision 826272)
+++ src/java/org/apache/lucene/index/SegmentReader.java	(working copy)
@@ -971,10 +971,10 @@
   /**
    * @see IndexReader#getFieldNames(IndexReader.FieldOption fldOption)
    */
-  public Collection getFieldNames(IndexReader.FieldOption fieldOption) {
+  public Collection<String> getFieldNames(IndexReader.FieldOption fieldOption) {
     ensureOpen();
 
-    Set fieldSet = new HashSet();
+    Set<String> fieldSet = new HashSet<String>();
     for (int i = 0; i < core.fieldInfos.size(); i++) {
       FieldInfo fi = core.fieldInfos.fieldInfo(i);
       if (fieldOption == IndexReader.FieldOption.ALL) {
Index: src/java/org/apache/lucene/index/CheckIndex.java
===================================================================
--- src/java/org/apache/lucene/index/CheckIndex.java	(revision 826272)
+++ src/java/org/apache/lucene/index/CheckIndex.java	(working copy)
@@ -28,7 +28,7 @@
 import java.io.IOException;
 import java.io.File;
 import java.util.Collection;
-import java.util.Iterator;
+
 import java.util.List;
 import java.util.ArrayList;
 import java.util.Map;
@@ -113,7 +113,7 @@
     public boolean partial;
 
     /** Holds the userData of the last commit in the index */
-    public Map userData;
+    public Map<String, String> userData;
 
     /** Holds the status of each segment in the index.
      *  See {@link #segmentInfos}.
@@ -172,10 +172,10 @@
        *  @see AbstractField#setOmitTermFreqAndPositions */
       public boolean hasProx;
 
-      /** Map<String, String> that includes certain
+      /** Map  that includes certain
        *  debugging details that IndexWriter records into
        *  each segment it creates */
-      public Map diagnostics;
+      public Map<String, String> diagnostics;
 
       /** Status for testing of field norms (null if field norms could not be tested). */
       public FieldNormStatus fieldNormStatus;
@@ -309,7 +309,7 @@
    *  <p><b>WARNING</b>: make sure
    *  you only call this when the index is not opened by any
    *  writer. */
-  public Status checkIndex(List onlySegments) throws IOException {
+  public Status checkIndex(List<String> onlySegments) throws IOException {
     NumberFormat nf = NumberFormat.getInstance();
     SegmentInfos sis = new SegmentInfos();
     Status result = new Status();
@@ -397,10 +397,9 @@
       result.partial = true;
       if (infoStream != null)
         infoStream.print("\nChecking only these segments:");
-      Iterator it = onlySegments.iterator();
-      while (it.hasNext()) {
+      for (String s : onlySegments) {
         if (infoStream != null)
-          infoStream.print(" " + it.next());
+          infoStream.print(" " + s);
       }
       result.segmentsChecked.addAll(onlySegments);
       msg(":");
@@ -439,7 +438,7 @@
         segInfoStat.numFiles = info.files().size();
         msg("    size (MB)=" + nf.format(info.sizeInBytes()/(1024.*1024.)));
         segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);
-        Map diagnostics = info.getDiagnostics();
+        Map<String, String> diagnostics = info.getDiagnostics();
         segInfoStat.diagnostics = diagnostics;
         if (diagnostics.size() > 0) {
           msg("    diagnostics = " + diagnostics);
@@ -497,7 +496,7 @@
         if (infoStream != null) {
           infoStream.print("    test: fields..............");
         }         
-        Collection fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);
+        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);
         msg("OK [" + fieldNames.size() + " fields]");
         segInfoStat.numFields = fieldNames.size();
         
@@ -559,7 +558,7 @@
   /**
    * Test field norms.
    */
-  private Status.FieldNormStatus testFieldNorms(Collection fieldNames, SegmentReader reader) {
+  private Status.FieldNormStatus testFieldNorms(Collection<String> fieldNames, SegmentReader reader) {
     final Status.FieldNormStatus status = new Status.FieldNormStatus();
 
     try {
@@ -567,10 +566,8 @@
       if (infoStream != null) {
         infoStream.print("    test: field norms.........");
       }
-      Iterator it = fieldNames.iterator();
       final byte[] b = new byte[reader.maxDoc()];
-      while (it.hasNext()) {
-        final String fieldName = (String) it.next();
+      for (final String fieldName : fieldNames) {
         reader.norms(fieldName, b, 0);
         ++status.totFields;
       }
@@ -807,7 +804,7 @@
   public static void main(String[] args) throws IOException, InterruptedException {
 
     boolean doFix = false;
-    List onlySegments = new ArrayList();
+    List<String> onlySegments = new ArrayList<String>();
     String indexPath = null;
     int i = 0;
     while(i < args.length) {
