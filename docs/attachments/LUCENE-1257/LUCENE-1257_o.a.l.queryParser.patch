Index: src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java
===================================================================
--- src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java	(revision 826534)
+++ src/java/org/apache/lucene/queryParser/MultiFieldQueryParser.java	(working copy)
@@ -36,7 +36,7 @@
 public class MultiFieldQueryParser extends QueryParser
 {
   protected String[] fields;
-  protected Map      boosts;
+  protected Map<String,Float>      boosts;
 
   /**
    * Creates a MultiFieldQueryParser. 
@@ -65,7 +65,7 @@
    * <p>In other words, all the query's terms must appear, but it doesn't matter in
    * what fields they appear.</p>
    */
-  public MultiFieldQueryParser(String[] fields, Analyzer analyzer, Map boosts) {
+  public MultiFieldQueryParser(String[] fields, Analyzer analyzer, Map<String,Float> boosts) {
     this(fields,analyzer);
     this.boosts = boosts;
   }
@@ -97,7 +97,7 @@
   
   protected Query getFieldQuery(String field, String queryText, int slop) throws ParseException {
     if (field == null) {
-      List clauses = new ArrayList();
+      List<BooleanClause> clauses = new ArrayList<BooleanClause>();
       for (int i = 0; i < fields.length; i++) {
         Query q = super.getFieldQuery(fields[i], queryText);
         if (q != null) {
@@ -139,7 +139,7 @@
   protected Query getFuzzyQuery(String field, String termStr, float minSimilarity) throws ParseException
   {
     if (field == null) {
-      List clauses = new ArrayList();
+      List<BooleanClause> clauses = new ArrayList<BooleanClause>();
       for (int i = 0; i < fields.length; i++) {
         clauses.add(new BooleanClause(getFuzzyQuery(fields[i], termStr, minSimilarity),
             BooleanClause.Occur.SHOULD));
@@ -152,7 +152,7 @@
   protected Query getPrefixQuery(String field, String termStr) throws ParseException
   {
     if (field == null) {
-      List clauses = new ArrayList();
+      List<BooleanClause> clauses = new ArrayList<BooleanClause>();
       for (int i = 0; i < fields.length; i++) {
         clauses.add(new BooleanClause(getPrefixQuery(fields[i], termStr),
             BooleanClause.Occur.SHOULD));
@@ -164,7 +164,7 @@
 
   protected Query getWildcardQuery(String field, String termStr) throws ParseException {
     if (field == null) {
-      List clauses = new ArrayList();
+      List<BooleanClause> clauses = new ArrayList<BooleanClause>();
       for (int i = 0; i < fields.length; i++) {
         clauses.add(new BooleanClause(getWildcardQuery(fields[i], termStr),
             BooleanClause.Occur.SHOULD));
@@ -177,7 +177,7 @@
  
   protected Query getRangeQuery(String field, String part1, String part2, boolean inclusive) throws ParseException {
     if (field == null) {
-      List clauses = new ArrayList();
+      List<BooleanClause> clauses = new ArrayList<BooleanClause>();
       for (int i = 0; i < fields.length; i++) {
         clauses.add(new BooleanClause(getRangeQuery(fields[i], part1, part2, inclusive),
             BooleanClause.Occur.SHOULD));
Index: src/java/org/apache/lucene/queryParser/QueryParser.java
===================================================================
--- src/java/org/apache/lucene/queryParser/QueryParser.java	(revision 826534)
+++ src/java/org/apache/lucene/queryParser/QueryParser.java	(working copy)
@@ -19,6 +19,7 @@
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.analysis.tokenattributes.TermAttribute;
+
 import org.apache.lucene.document.DateField;
 import org.apache.lucene.document.DateTools;
 import org.apache.lucene.index.Term;
@@ -137,7 +138,7 @@
   // the default date resolution
   DateTools.Resolution dateResolution = null;
   // maps field names to date resolutions
-  Map fieldToDateResolution = null;
+  Map<String,DateTools.Resolution> fieldToDateResolution = null;
 
   // The collator to use when determining range inclusion,
   // for use when constructing RangeQuerys.
@@ -418,7 +419,7 @@
 
     if (fieldToDateResolution == null) {
       // lazily initialize HashMap
-      fieldToDateResolution = new HashMap();
+      fieldToDateResolution = new HashMap<String,DateTools.Resolution>();
     }
 
     fieldToDateResolution.put(fieldName, dateResolution);
@@ -476,11 +477,11 @@
   /**
    * @deprecated use {@link #addClause(List, int, int, Query)} instead.
    */
-  protected void addClause(Vector clauses, int conj, int mods, Query q) {
-    addClause((List) clauses, conj, mods, q);
+  protected void addClause(Vector<BooleanClause> clauses, int conj, int mods, Query q) {
+    addClause(clauses, conj, mods, q);
   }
 
-  protected void addClause(List clauses, int conj, int mods, Query q) {
+  protected void addClause(List<BooleanClause> clauses, int conj, int mods, Query q) {
     boolean required, prohibited;
 
     // If this term is introduced by AND, make the preceding term required,
@@ -635,7 +636,7 @@
           // phrase query:
           MultiPhraseQuery mpq = newMultiPhraseQuery();
           mpq.setSlop(phraseSlop);
-          List multiTerms = new ArrayList();
+          List<Term> multiTerms = new ArrayList<Term>();
           int position = -1;
           for (int i = 0; i < numTokens; i++) {
             String term = null;
@@ -887,8 +888,8 @@
    * @exception ParseException throw in overridden method to disallow
    * @deprecated use {@link #getBooleanQuery(List)} instead
    */
-  protected Query getBooleanQuery(Vector clauses) throws ParseException {
-    return getBooleanQuery((List) clauses, false);
+  protected Query getBooleanQuery(Vector<BooleanClause> clauses) throws ParseException {
+    return getBooleanQuery(clauses, false);
   }
 
   /**
@@ -904,7 +905,7 @@
    * @return Resulting {@link Query} object.
    * @exception ParseException throw in overridden method to disallow
    */
-  protected Query getBooleanQuery(List clauses) throws ParseException {
+  protected Query getBooleanQuery(List<BooleanClause> clauses) throws ParseException {
     return getBooleanQuery(clauses, false);
   }
 
@@ -923,10 +924,10 @@
    * @exception ParseException throw in overridden method to disallow
    * @deprecated use {@link #getBooleanQuery(List, boolean)} instead
    */
-  protected Query getBooleanQuery(Vector clauses, boolean disableCoord)
+  protected Query getBooleanQuery(Vector<BooleanClause> clauses, boolean disableCoord)
     throws ParseException
   {
-    return getBooleanQuery((List) clauses, disableCoord);
+    return getBooleanQuery(clauses, disableCoord);
   }
 
   /**
@@ -943,15 +944,15 @@
    * @return Resulting {@link Query} object.
    * @exception ParseException throw in overridden method to disallow
    */
-  protected Query getBooleanQuery(List clauses, boolean disableCoord)
+  protected Query getBooleanQuery(List<BooleanClause> clauses, boolean disableCoord)
     throws ParseException
   {
     if (clauses.size()==0) {
       return null; // all clause words were filtered away by the analyzer.
     }
     BooleanQuery query = newBooleanQuery(disableCoord);
-    for (int i = 0; i < clauses.size(); i++) {
-      query.add((BooleanClause)clauses.get(i));
+    for (final BooleanClause clause : clauses) {
+      query.add(clause);
     }
     return query;
   }
@@ -1234,7 +1235,7 @@
   }
 
   final public Query Query(String field) throws ParseException {
-  List clauses = new ArrayList();
+  List<BooleanClause> clauses = new ArrayList<BooleanClause>();
   Query q, firstQuery=null;
   int conj, mods;
     mods = Modifiers();
@@ -1754,7 +1755,7 @@
       return (jj_ntk = jj_nt.kind);
   }
 
-  private java.util.List jj_expentries = new java.util.ArrayList();
+  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
   private int[] jj_expentry;
   private int jj_kind = -1;
   private int[] jj_lasttokens = new int[100];
@@ -1769,8 +1770,8 @@
       for (int i = 0; i < jj_endpos; i++) {
         jj_expentry[i] = jj_lasttokens[i];
       }
-      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
-        int[] oldentry = (int[])(it.next());
+      jj_entries_loop: for (java.util.Iterator<int[]> it = jj_expentries.iterator(); it.hasNext();) {
+        int[] oldentry = it.next();
         if (oldentry.length == jj_expentry.length) {
           for (int i = 0; i < jj_expentry.length; i++) {
             if (oldentry[i] != jj_expentry[i]) {
