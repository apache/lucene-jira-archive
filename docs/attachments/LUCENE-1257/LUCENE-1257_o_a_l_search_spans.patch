Index: src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
===================================================================
--- src/java/org/apache/lucene/search/spans/NearSpansOrdered.java	(revision 826473)
+++ src/java/org/apache/lucene/search/spans/NearSpansOrdered.java	(working copy)
@@ -65,12 +65,12 @@
   private int matchDoc = -1;
   private int matchStart = -1;
   private int matchEnd = -1;
-  private List/*<byte[]>*/ matchPayload;
+  private List<byte[]> matchPayload;
 
   private final Spans[] subSpansByDoc;
-  private final Comparator spanDocComparator = new Comparator() {
-    public int compare(Object o1, Object o2) {
-      return ((Spans)o1).doc() - ((Spans)o2).doc();
+  private final Comparator<Spans> spanDocComparator = new Comparator<Spans>() {
+    public int compare(Spans o1, Spans o2) {
+      return o1.doc() - o2.doc();
     }
   };
   
@@ -91,7 +91,7 @@
     allowedSlop = spanNearQuery.getSlop();
     SpanQuery[] clauses = spanNearQuery.getClauses();
     subSpans = new Spans[clauses.length];
-    matchPayload = new LinkedList();
+    matchPayload = new LinkedList<byte[]>();
     subSpansByDoc = new Spans[clauses.length];
     for (int i = 0; i < clauses.length; i++) {
       subSpans[i] = clauses[i].getSpans(reader);
@@ -115,7 +115,7 @@
 
   // TODO: Remove warning after API has been finalized
   // TODO: Would be nice to be able to lazy load payloads
-  public Collection/*<byte[]>*/ getPayload() throws IOException {
+  public Collection<byte[]> getPayload() throws IOException {
     return matchPayload;
   }
 
@@ -256,12 +256,12 @@
   private boolean shrinkToAfterShortestMatch() throws IOException {
     matchStart = subSpans[subSpans.length - 1].start();
     matchEnd = subSpans[subSpans.length - 1].end();
-    Set possibleMatchPayloads = new HashSet();
+    Set<byte[]> possibleMatchPayloads = new HashSet<byte[]>();
     if (subSpans[subSpans.length - 1].isPayloadAvailable()) {
       possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());
     }
 
-    Collection possiblePayload = null;
+    Collection<byte[]> possiblePayload = null;
     
     int matchSlop = 0;
     int lastStart = matchStart;
@@ -269,8 +269,8 @@
     for (int i = subSpans.length - 2; i >= 0; i--) {
       Spans prevSpans = subSpans[i];
       if (collectPayloads && prevSpans.isPayloadAvailable()) {
-        Collection payload = prevSpans.getPayload();
-        possiblePayload = new ArrayList(payload.size());
+        Collection<byte[]> payload = prevSpans.getPayload();
+        possiblePayload = new ArrayList<byte[]>(payload.size());
         possiblePayload.addAll(payload);
       }
       
@@ -293,8 +293,8 @@
             prevStart = ppStart;
             prevEnd = ppEnd;
             if (collectPayloads && prevSpans.isPayloadAvailable()) {
-              Collection payload = prevSpans.getPayload();
-              possiblePayload = new ArrayList(payload.size());
+              Collection<byte[]> payload = prevSpans.getPayload();
+              possiblePayload = new ArrayList<byte[]>(payload.size());
               possiblePayload.addAll(payload);
             }
           }
Index: src/java/org/apache/lucene/search/spans/SpanFirstQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanFirstQuery.java	(revision 826473)
+++ src/java/org/apache/lucene/search/spans/SpanFirstQuery.java	(working copy)
@@ -94,10 +94,10 @@
         public int end() { return spans.end(); }
 
       // TODO: Remove warning after API has been finalized
-      public Collection/*<byte[]>*/ getPayload() throws IOException {
-        ArrayList result = null;
+      public Collection<byte[]> getPayload() throws IOException {
+        ArrayList<byte[]> result = null;
         if (spans.isPayloadAvailable()) {
-          result = new ArrayList(spans.getPayload());
+          result = new ArrayList<byte[]>(spans.getPayload());
         }
         return result;//TODO: any way to avoid the new construction?
       }
Index: src/java/org/apache/lucene/search/spans/SpanTermQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(revision 826473)
+++ src/java/org/apache/lucene/search/spans/SpanTermQuery.java	(working copy)
@@ -22,8 +22,6 @@
 import org.apache.lucene.util.ToStringUtils;
 
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Set;
 
 /** Matches spans containing a term. */
Index: src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
===================================================================
--- src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(revision 826473)
+++ src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(working copy)
@@ -36,7 +36,7 @@
 public class NearSpansUnordered extends Spans {
   private SpanNearQuery query;
 
-  private List ordered = new ArrayList();         // spans in query order
+  private List<SpansCell> ordered = new ArrayList<SpansCell>();         // spans in query order
   private Spans[] subSpans;  
   private int slop;                               // from query
 
@@ -107,8 +107,8 @@
     public int start() { return spans.start(); }
     public int end() { return spans.end(); }
                     // TODO: Remove warning after API has been finalized
-    public Collection/*<byte[]>*/ getPayload() throws IOException {
-      return new ArrayList(spans.getPayload());
+    public Collection<byte[]> getPayload() throws IOException {
+      return new ArrayList<byte[]>(spans.getPayload());
     }
 
     // TODO: Remove warning after API has been finalized
@@ -223,8 +223,8 @@
    * @return Collection of <code>byte[]</code> payloads
    * @throws IOException
    */
-  public Collection/*<byte[]>*/ getPayload() throws IOException {
-    Set/*<byte[]*/ matchPayload = new HashSet();
+  public Collection<byte[]> getPayload() throws IOException {
+    Set<byte[]> matchPayload = new HashSet<byte[]>();
     for (SpansCell cell = first; cell != null; cell = cell.next) {
       if (cell.isPayloadAvailable()) {
         matchPayload.addAll(cell.getPayload());
@@ -253,7 +253,7 @@
 
   private void initList(boolean next) throws IOException {
     for (int i = 0; more && i < ordered.size(); i++) {
-      SpansCell cell = (SpansCell)ordered.get(i);
+      SpansCell cell = ordered.get(i);
       if (next)
         more = cell.next();                       // move to first entry
       if (more) {
Index: src/java/org/apache/lucene/search/spans/Spans.java
===================================================================
--- src/java/org/apache/lucene/search/spans/Spans.java	(revision 826473)
+++ src/java/org/apache/lucene/search/spans/Spans.java	(working copy)
@@ -75,7 +75,7 @@
    * @throws java.io.IOException
     */
   // TODO: Remove warning after API has been finalized
-  public abstract Collection/*<byte[]>*/ getPayload() throws IOException;
+  public abstract Collection<byte[]> getPayload() throws IOException;
 
   /**
    * Checks if a payload can be loaded at this position.
Index: src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java	(revision 826473)
+++ src/java/org/apache/lucene/search/spans/FieldMaskingSpanQuery.java	(working copy)
@@ -18,7 +18,6 @@
  */
 
 import java.io.IOException;
-import java.util.Collection;
 import java.util.Set;
 
 import org.apache.lucene.index.IndexReader;
Index: src/java/org/apache/lucene/search/spans/SpanQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanQuery.java	(revision 826473)
+++ src/java/org/apache/lucene/search/spans/SpanQuery.java	(working copy)
@@ -18,8 +18,6 @@
  */
 
 import java.io.IOException;
-import java.util.Collection;
-import java.util.Set;
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.Query;
Index: src/java/org/apache/lucene/search/spans/SpanNotQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanNotQuery.java	(revision 826473)
+++ src/java/org/apache/lucene/search/spans/SpanNotQuery.java	(working copy)
@@ -132,10 +132,10 @@
         public int end() { return includeSpans.end(); }
 
       // TODO: Remove warning after API has been finalized
-      public Collection/*<byte[]>*/ getPayload() throws IOException {
-        ArrayList result = null;
+      public Collection<byte[]> getPayload() throws IOException {
+        ArrayList<byte[]> result = null;
         if (includeSpans.isPayloadAvailable()) {
-          result = new ArrayList(includeSpans.getPayload());
+          result = new ArrayList<byte[]>(includeSpans.getPayload());
         }
         return result;
       }
Index: src/java/org/apache/lucene/search/spans/SpanOrQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(revision 826473)
+++ src/java/org/apache/lucene/search/spans/SpanOrQuery.java	(working copy)
@@ -33,14 +33,14 @@
 
 /** Matches the union of its clauses.*/
 public class SpanOrQuery extends SpanQuery implements Cloneable {
-  private List clauses;
+  private List<SpanQuery> clauses;
   private String field;
 
   /** Construct a SpanOrQuery merging the provided clauses. */
   public SpanOrQuery(SpanQuery[] clauses) {
 
     // copy clauses array into an ArrayList
-    this.clauses = new ArrayList(clauses.length);
+    this.clauses = new ArrayList<SpanQuery>(clauses.length);
     for (int i = 0; i < clauses.length; i++) {
       SpanQuery clause = clauses[i];
       if (i == 0) {                               // check field
@@ -60,9 +60,7 @@
   public String getField() { return field; }
 
   public void extractTerms(Set<Term> terms) {
-    Iterator i = clauses.iterator();
-    while (i.hasNext()) {
-      SpanQuery clause = (SpanQuery)i.next();
+    for(final SpanQuery clause: clauses) {
       clause.extractTerms(terms);
     }
   }
@@ -72,8 +70,7 @@
     SpanQuery[] newClauses = new SpanQuery[sz];
 
     for (int i = 0; i < sz; i++) {
-      SpanQuery clause = (SpanQuery) clauses.get(i);
-      newClauses[i] = (SpanQuery) clause.clone();
+      newClauses[i] = (SpanQuery) clauses.get(i).clone();
     }
     SpanOrQuery soq = new SpanOrQuery(newClauses);
     soq.setBoost(getBoost());
@@ -83,7 +80,7 @@
   public Query rewrite(IndexReader reader) throws IOException {
     SpanOrQuery clone = null;
     for (int i = 0 ; i < clauses.size(); i++) {
-      SpanQuery c = (SpanQuery)clauses.get(i);
+      SpanQuery c = clauses.get(i);
       SpanQuery query = (SpanQuery) c.rewrite(reader);
       if (query != c) {                     // clause rewrote: must clone
         if (clone == null)
@@ -101,9 +98,9 @@
   public String toString(String field) {
     StringBuilder buffer = new StringBuilder();
     buffer.append("spanOr([");
-    Iterator i = clauses.iterator();
+    Iterator<SpanQuery> i = clauses.iterator();
     while (i.hasNext()) {
-      SpanQuery clause = (SpanQuery)i.next();
+      SpanQuery clause = i.next();
       buffer.append(clause.toString(field));
       if (i.hasNext()) {
         buffer.append(", ");
@@ -134,14 +131,12 @@
   }
 
 
-  private class SpanQueue extends PriorityQueue {
+  private class SpanQueue extends PriorityQueue<Spans> {
     public SpanQueue(int size) {
       initialize(size);
     }
 
-    protected final boolean lessThan(Object o1, Object o2) {
-      Spans spans1 = (Spans)o1;
-      Spans spans2 = (Spans)o2;
+    protected final boolean lessThan(Spans spans1, Spans spans2) {
       if (spans1.doc() == spans2.doc()) {
         if (spans1.start() == spans2.start()) {
           return spans1.end() < spans2.end();
@@ -163,9 +158,9 @@
 
         private boolean initSpanQueue(int target) throws IOException {
           queue = new SpanQueue(clauses.size());
-          Iterator i = clauses.iterator();
+          Iterator<SpanQuery> i = clauses.iterator();
           while (i.hasNext()) {
-            Spans spans = ((SpanQuery)i.next()).getSpans(reader);
+            Spans spans = i.next().getSpans(reader);
             if (   ((target == -1) && spans.next())
                 || ((target != -1) && spans.skipTo(target))) {
               queue.add(spans);
@@ -219,11 +214,11 @@
         public int start() { return top().start(); }
         public int end() { return top().end(); }
 
-      public Collection/*<byte[]>*/ getPayload() throws IOException {
-        ArrayList result = null;
+      public Collection<byte[]> getPayload() throws IOException {
+        ArrayList<byte[]> result = null;
         Spans theTop = top();
         if (theTop != null && theTop.isPayloadAvailable()) {
-          result = new ArrayList(theTop.getPayload());
+          result = new ArrayList<byte[]>(theTop.getPayload());
         }
         return result;
       }
Index: src/java/org/apache/lucene/search/spans/SpanWeight.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanWeight.java	(revision 826473)
+++ src/java/org/apache/lucene/search/spans/SpanWeight.java	(working copy)
@@ -18,6 +18,7 @@
  */
 
 import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.Term;
 import org.apache.lucene.search.*;
 import org.apache.lucene.search.Explanation.IDFExplanation;
 
@@ -35,7 +36,7 @@
   protected float queryNorm;
   protected float queryWeight;
 
-  protected Set terms;
+  protected Set<Term> terms;
   protected SpanQuery query;
   private IDFExplanation idfExp;
 
@@ -43,8 +44,10 @@
     throws IOException {
     this.similarity = query.getSimilarity(searcher);
     this.query = query;
-    terms=new HashSet();
+    
+    terms=new HashSet<Term>();
     query.extractTerms(terms);
+    
     idfExp = similarity.idfExplain(terms, searcher);
     idf = idfExp.getIdf();
   }
Index: src/java/org/apache/lucene/search/spans/TermSpans.java
===================================================================
--- src/java/org/apache/lucene/search/spans/TermSpans.java	(revision 826473)
+++ src/java/org/apache/lucene/search/spans/TermSpans.java	(working copy)
@@ -87,7 +87,7 @@
   }
 
   // TODO: Remove warning after API has been finalized
-  public Collection/*<byte[]>*/ getPayload() throws IOException {
+  public Collection<byte[]> getPayload() throws IOException {
     byte [] bytes = new byte[positions.getPayloadLength()]; 
     bytes = positions.getPayload(bytes, 0);
     return Collections.singletonList(bytes);
Index: src/java/org/apache/lucene/search/spans/SpanNearQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(revision 826473)
+++ src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(working copy)
@@ -19,7 +19,7 @@
 
 import java.io.IOException;
 
-import java.util.Collection;
+
 import java.util.List;
 import java.util.ArrayList;
 import java.util.Iterator;
@@ -35,7 +35,7 @@
  * maximum number of intervening unmatched positions, as well as whether
  * matches are required to be in-order. */
 public class SpanNearQuery extends SpanQuery implements Cloneable {
-  protected List clauses;
+  protected List<SpanQuery> clauses;
   protected int slop;
   protected boolean inOrder;
 
@@ -53,7 +53,7 @@
   public SpanNearQuery(SpanQuery[] clauses, int slop, boolean inOrder, boolean collectPayloads) {
 
     // copy clauses array into an ArrayList
-    this.clauses = new ArrayList(clauses.length);
+    this.clauses = new ArrayList<SpanQuery>(clauses.length);
     for (int i = 0; i < clauses.length; i++) {
       SpanQuery clause = clauses[i];
       if (i == 0) {                               // check field
@@ -82,9 +82,7 @@
   public String getField() { return field; }
   
   public void extractTerms(Set<Term> terms) {
-	    Iterator i = clauses.iterator();
-	    while (i.hasNext()) {
-	      SpanQuery clause = (SpanQuery)i.next();
+	    for(final SpanQuery clause : clauses) {
 	      clause.extractTerms(terms);
 	    }
   }  
@@ -93,9 +91,9 @@
   public String toString(String field) {
     StringBuilder buffer = new StringBuilder();
     buffer.append("spanNear([");
-    Iterator i = clauses.iterator();
+    Iterator<SpanQuery> i = clauses.iterator();
     while (i.hasNext()) {
-      SpanQuery clause = (SpanQuery)i.next();
+      SpanQuery clause = i.next();
       buffer.append(clause.toString(field));
       if (i.hasNext()) {
         buffer.append(", ");
