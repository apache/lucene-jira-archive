Index: src/java/org/apache/lucene/search/FieldValueHitQueue.java
===================================================================
--- src/java/org/apache/lucene/search/FieldValueHitQueue.java	(revision 826799)
+++ src/java/org/apache/lucene/search/FieldValueHitQueue.java	(working copy)
@@ -34,7 +34,7 @@
  * @see Searcher#search(Query,Filter,int,Sort)
  * @see FieldCache
  */
-public abstract class FieldValueHitQueue extends PriorityQueue {
+public abstract class FieldValueHitQueue extends PriorityQueue<FieldValueHitQueue.Entry> {
 
   final static class Entry {
     int slot;
@@ -84,9 +84,7 @@
      * @param b ScoreDoc
      * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.
      */
-    protected boolean lessThan(final Object a, final Object b) {
-      final Entry hitA = (Entry) a;
-      final Entry hitB = (Entry) b;
+    protected boolean lessThan(final Entry hitA, final Entry hitB) {
 
       assert hitA != hitB;
       assert hitA.slot != hitB.slot;
@@ -123,9 +121,7 @@
       initialize(size);
     }
   
-    protected boolean lessThan(final Object a, final Object b) {
-      final Entry hitA = (Entry) a;
-      final Entry hitB = (Entry) b;
+    protected boolean lessThan(final Entry hitA, final Entry hitB) {
 
       assert hitA != hitB;
       assert hitA.slot != hitB.slot;
@@ -194,7 +190,7 @@
   protected final FieldComparator[] comparators;
   protected final int[] reverseMul;
 
-  protected abstract boolean lessThan (final Object a, final Object b);
+  protected abstract boolean lessThan (final Entry a, final Entry b);
 
   /**
    * Given a queue Entry, creates a corresponding FieldDoc
Index: src/java/org/apache/lucene/search/TopScoreDocCollector.java
===================================================================
--- src/java/org/apache/lucene/search/TopScoreDocCollector.java	(revision 826799)
+++ src/java/org/apache/lucene/search/TopScoreDocCollector.java	(working copy)
@@ -34,7 +34,7 @@
  * not valid scores.  This collector will not properly
  * collect hits with such scores.
  */
-public abstract class TopScoreDocCollector extends TopDocsCollector {
+public abstract class TopScoreDocCollector extends TopDocsCollector<ScoreDoc> {
 
   // Assumes docs are scored in order.
   private static class InOrderTopScoreDocCollector extends TopScoreDocCollector {
@@ -53,7 +53,7 @@
       }
       pqTop.doc = doc + docBase;
       pqTop.score = score;
-      pqTop = (ScoreDoc) pq.updateTop();
+      pqTop = pq.updateTop();
     }
     
     public boolean acceptsDocsOutOfOrder() {
@@ -76,7 +76,7 @@
       }
       pqTop.doc = doc;
       pqTop.score = score;
-      pqTop = (ScoreDoc) pq.updateTop();
+      pqTop = pq.updateTop();
     }
     
     public boolean acceptsDocsOutOfOrder() {
@@ -113,7 +113,7 @@
     super(new HitQueue(numHits, true));
     // HitQueue implements getSentinelObject to return a ScoreDoc, so we know
     // that at this point top() is already initialized.
-    pqTop = (ScoreDoc) pq.top();
+    pqTop = pq.top();
   }
 
   protected TopDocs newTopDocs(ScoreDoc[] results, int start) {
@@ -130,7 +130,7 @@
       maxScore = results[0].score;
     } else {
       for (int i = pq.size(); i > 1; i--) { pq.pop(); }
-      maxScore = ((ScoreDoc) pq.pop()).score;
+      maxScore = pq.pop().score;
     }
     
     return new TopDocs(totalHits, results, maxScore);
Index: src/java/org/apache/lucene/search/TopFieldCollector.java
===================================================================
--- src/java/org/apache/lucene/search/TopFieldCollector.java	(revision 826799)
+++ src/java/org/apache/lucene/search/TopFieldCollector.java	(working copy)
@@ -33,7 +33,7 @@
  * <p><b>NOTE:</b> This API is experimental and might change in
  * incompatible ways in the next release.</p>
  */
-public abstract class TopFieldCollector extends TopDocsCollector {
+public abstract class TopFieldCollector extends TopDocsCollector<Entry> {
   
   // TODO: one optimization we could do is to pre-fill
   // the queue with sentinel value that guaranteed to
@@ -60,7 +60,7 @@
     final void updateBottom(int doc) {
       // bottom.score is already set to Float.NaN in add().
       bottom.docID = docBase + doc;
-      bottom = (Entry) pq.updateTop();
+      bottom = pq.updateTop();
     }
 
     public void collect(int doc) throws IOException {
@@ -161,7 +161,7 @@
     final void updateBottom(int doc, float score) {
       bottom.docID = docBase + doc;
       bottom.score = score;
-      bottom = (Entry) pq.updateTop();
+      bottom = pq.updateTop();
     }
 
     public void collect(int doc) throws IOException {
@@ -273,7 +273,7 @@
     final void updateBottom(int doc, float score) {
       bottom.docID = docBase + doc;
       bottom.score = score;
-      bottom = (Entry) pq.updateTop();
+      bottom =  pq.updateTop();
     }
 
     public void collect(int doc) throws IOException {
@@ -380,7 +380,7 @@
     final void updateBottom(int doc) {
       // bottom.score is already set to Float.NaN in add().
       bottom.docID = docBase + doc;
-      bottom = (Entry) pq.updateTop();
+      bottom = pq.updateTop();
     }
 
     public void collect(int doc) throws IOException {
@@ -529,7 +529,7 @@
     final void updateBottom(int doc, float score) {
       bottom.docID = docBase + doc;
       bottom.score = score;
-      bottom = (Entry) pq.updateTop();
+      bottom =  pq.updateTop();
     }
 
     public void collect(int doc) throws IOException {
@@ -675,7 +675,7 @@
     final void updateBottom(int doc, float score) {
       bottom.docID = docBase + doc;
       bottom.score = score;
-      bottom = (Entry) pq.updateTop();
+      bottom = pq.updateTop();
     }
 
     public void collect(int doc) throws IOException {
@@ -833,7 +833,7 @@
   // internal versions. If someone will define a constructor with any other
   // visibility, then anyone will be able to extend the class, which is not what
   // we want.
-  private TopFieldCollector(PriorityQueue pq, int numHits, boolean fillFields) {
+  private TopFieldCollector(PriorityQueue<Entry> pq, int numHits, boolean fillFields) {
     super(pq);
     this.numHits = numHits;
     this.fillFields = fillFields;
@@ -925,7 +925,7 @@
   }
   
   final void add(int slot, int doc, float score) {
-    bottom = (Entry) pq.add(new Entry(slot, docBase + doc, score));
+    bottom = pq.add(new Entry(slot, docBase + doc, score));
     queueFull = totalHits == numHits;
   }
 
@@ -943,7 +943,7 @@
       }
     } else {
       for (int i = howMany - 1; i >= 0; i--) {
-        Entry entry = (Entry) pq.pop();
+        Entry entry = pq.pop();
         results[i] = new FieldDoc(entry.docID, entry.score);
       }
     }
Index: src/java/org/apache/lucene/search/TopDocsCollector.java
===================================================================
--- src/java/org/apache/lucene/search/TopDocsCollector.java	(revision 826799)
+++ src/java/org/apache/lucene/search/TopDocsCollector.java	(working copy)
@@ -17,6 +17,7 @@
  * limitations under the License.
  */
 
+
 import org.apache.lucene.util.PriorityQueue;
 
 /**
@@ -27,7 +28,7 @@
  * Extending classes can override {@link #topDocs(int, int)} and
  * {@link #getTotalHits()} in order to provide their own implementation.
  */
-public abstract class TopDocsCollector extends Collector {
+public abstract class TopDocsCollector<T> extends Collector {
 
   // This is used in case topDocs() is called with illegal parameters, or there
   // simply aren't (enough) results.
@@ -39,12 +40,12 @@
    * HitQueue for example aggregates the top scoring documents, while other PQ
    * implementations may hold documents sorted by other criteria.
    */
-  protected PriorityQueue pq;
+  protected PriorityQueue<T> pq;
 
   /** The total number of documents that the collector encountered. */
   protected int totalHits;
   
-  protected TopDocsCollector(PriorityQueue pq) {
+  protected TopDocsCollector(PriorityQueue<T> pq) {
     this.pq = pq;
   }
   
