Index: src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java
===================================================================
--- src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java	(revision 826485)
+++ src/java/org/apache/lucene/search/payloads/PayloadNearQuery.java	(working copy)
@@ -77,8 +77,7 @@
     SpanQuery[] newClauses = new SpanQuery[sz];
 
     for (int i = 0; i < sz; i++) {
-      SpanQuery clause = (SpanQuery) clauses.get(i);
-      newClauses[i] = (SpanQuery) clause.clone();
+      newClauses[i] = (SpanQuery) clauses.get(i).clone();
     }
     PayloadNearQuery boostingNearQuery = new PayloadNearQuery(newClauses, slop,
         inOrder);
@@ -90,9 +89,9 @@
   public String toString(String field) {
     StringBuilder buffer = new StringBuilder();
     buffer.append("payloadNear([");
-    Iterator i = clauses.iterator();
+    Iterator<SpanQuery> i = clauses.iterator();
     while (i.hasNext()) {
-      SpanQuery clause = (SpanQuery) i.next();
+      SpanQuery clause = i.next();
       buffer.append(clause.toString(field));
       if (i.hasNext()) {
         buffer.append(", ");
@@ -194,9 +193,8 @@
      * 
      * @see Spans
      */
-    protected void processPayloads(Collection payLoads, int start, int end) {
-      for (Iterator iterator = payLoads.iterator(); iterator.hasNext();) {
-        byte[] thePayload = (byte[]) iterator.next();
+    protected void processPayloads(Collection<byte[]> payLoads, int start, int end) {
+      for (final byte[] thePayload : payLoads) {
         payloadScore = function.currentScore(doc, fieldName, start, end,
             payloadsSeen, payloadScore, similarity.scorePayload(doc, fieldName,
                 spans.start(), spans.end(), thePayload, 0, thePayload.length));
Index: src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java
===================================================================
--- src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java	(revision 826485)
+++ src/java/org/apache/lucene/search/payloads/PayloadSpanUtil.java	(working copy)
@@ -69,13 +69,13 @@
    * @return payloads Collection
    * @throws IOException
    */
-  public Collection getPayloadsForQuery(Query query) throws IOException {
-    Collection payloads = new ArrayList();
+  public Collection<byte[]> getPayloadsForQuery(Query query) throws IOException {
+    Collection<byte[]> payloads = new ArrayList<byte[]>();
     queryToSpanQuery(query, payloads);
     return payloads;
   }
 
-  private void queryToSpanQuery(Query query, Collection payloads)
+  private void queryToSpanQuery(Query query, Collection<byte[]> payloads)
       throws IOException {
     if (query instanceof BooleanQuery) {
       BooleanClause[] queryClauses = ((BooleanQuery) query).getClauses();
@@ -113,14 +113,14 @@
       queryToSpanQuery(((FilteredQuery) query).getQuery(), payloads);
     } else if (query instanceof DisjunctionMaxQuery) {
 
-      for (Iterator iterator = ((DisjunctionMaxQuery) query).iterator(); iterator
+      for (Iterator<Query> iterator = ((DisjunctionMaxQuery) query).iterator(); iterator
           .hasNext();) {
-        queryToSpanQuery((Query) iterator.next(), payloads);
+        queryToSpanQuery(iterator.next(), payloads);
       }
 
     } else if (query instanceof MultiPhraseQuery) {
       final MultiPhraseQuery mpq = (MultiPhraseQuery) query;
-      final List termArrays = mpq.getTermArrays();
+      final List<Term[]> termArrays = mpq.getTermArrays();
       final int[] positions = mpq.getPositions();
       if (positions.length > 0) {
 
@@ -131,19 +131,19 @@
           }
         }
 
-        final List[] disjunctLists = new List[maxPosition + 1];
+        final List<Query>[] disjunctLists = new List[maxPosition + 1];
         int distinctPositions = 0;
 
         for (int i = 0; i < termArrays.size(); ++i) {
-          final Term[] termArray = (Term[]) termArrays.get(i);
-          List disjuncts = disjunctLists[positions[i]];
+          final Term[] termArray = termArrays.get(i);
+          List<Query> disjuncts = disjunctLists[positions[i]];
           if (disjuncts == null) {
-            disjuncts = (disjunctLists[positions[i]] = new ArrayList(
+            disjuncts = (disjunctLists[positions[i]] = new ArrayList<Query>(
                 termArray.length));
             ++distinctPositions;
           }
-          for (int j = 0; j < termArray.length; ++j) {
-            disjuncts.add(new SpanTermQuery(termArray[j]));
+          for (final Term term : termArray) {
+            disjuncts.add(new SpanTermQuery(term));
           }
         }
 
@@ -151,9 +151,9 @@
         int position = 0;
         final SpanQuery[] clauses = new SpanQuery[distinctPositions];
         for (int i = 0; i < disjunctLists.length; ++i) {
-          List disjuncts = disjunctLists[i];
+          List<Query> disjuncts = disjunctLists[i];
           if (disjuncts != null) {
-            clauses[position++] = new SpanOrQuery((SpanQuery[]) disjuncts
+            clauses[position++] = new SpanOrQuery(disjuncts
                 .toArray(new SpanQuery[disjuncts.size()]));
           } else {
             ++positionGaps;
@@ -171,16 +171,14 @@
     }
   }
 
-  private void getPayloads(Collection payloads, SpanQuery query)
+  private void getPayloads(Collection<byte []> payloads, SpanQuery query)
       throws IOException {
     Spans spans = query.getSpans(reader);
 
     while (spans.next() == true) {
       if (spans.isPayloadAvailable()) {
-        Collection payload = spans.getPayload();
-        Iterator it = payload.iterator();
-        while (it.hasNext()) {
-          byte[] bytes = (byte[]) it.next();
+        Collection<byte[]> payload = spans.getPayload();
+        for (byte [] bytes : payload) {
           payloads.add(bytes);
         }
 
Index: src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
===================================================================
--- src/java/org/apache/lucene/search/spans/NearSpansOrdered.java	(revision 826485)
+++ src/java/org/apache/lucene/search/spans/NearSpansOrdered.java	(working copy)
@@ -65,12 +65,12 @@
   private int matchDoc = -1;
   private int matchStart = -1;
   private int matchEnd = -1;
-  private List/*<byte[]>*/ matchPayload;
+  private List<byte[]> matchPayload;
 
   private final Spans[] subSpansByDoc;
-  private final Comparator spanDocComparator = new Comparator() {
-    public int compare(Object o1, Object o2) {
-      return ((Spans)o1).doc() - ((Spans)o2).doc();
+  private final Comparator<Spans> spanDocComparator = new Comparator<Spans>() {
+    public int compare(Spans o1, Spans o2) {
+      return o1.doc() - o2.doc();
     }
   };
   
@@ -91,7 +91,7 @@
     allowedSlop = spanNearQuery.getSlop();
     SpanQuery[] clauses = spanNearQuery.getClauses();
     subSpans = new Spans[clauses.length];
-    matchPayload = new LinkedList();
+    matchPayload = new LinkedList<byte[]>();
     subSpansByDoc = new Spans[clauses.length];
     for (int i = 0; i < clauses.length; i++) {
       subSpans[i] = clauses[i].getSpans(reader);
@@ -115,7 +115,7 @@
 
   // TODO: Remove warning after API has been finalized
   // TODO: Would be nice to be able to lazy load payloads
-  public Collection/*<byte[]>*/ getPayload() throws IOException {
+  public Collection<byte[]> getPayload() throws IOException {
     return matchPayload;
   }
 
@@ -256,12 +256,12 @@
   private boolean shrinkToAfterShortestMatch() throws IOException {
     matchStart = subSpans[subSpans.length - 1].start();
     matchEnd = subSpans[subSpans.length - 1].end();
-    Set possibleMatchPayloads = new HashSet();
+    Set<byte[]> possibleMatchPayloads = new HashSet<byte[]>();
     if (subSpans[subSpans.length - 1].isPayloadAvailable()) {
       possibleMatchPayloads.addAll(subSpans[subSpans.length - 1].getPayload());
     }
 
-    Collection possiblePayload = null;
+    Collection<byte[]> possiblePayload = null;
     
     int matchSlop = 0;
     int lastStart = matchStart;
@@ -269,8 +269,8 @@
     for (int i = subSpans.length - 2; i >= 0; i--) {
       Spans prevSpans = subSpans[i];
       if (collectPayloads && prevSpans.isPayloadAvailable()) {
-        Collection payload = prevSpans.getPayload();
-        possiblePayload = new ArrayList(payload.size());
+        Collection<byte[]> payload = prevSpans.getPayload();
+        possiblePayload = new ArrayList<byte[]>(payload.size());
         possiblePayload.addAll(payload);
       }
       
@@ -293,8 +293,8 @@
             prevStart = ppStart;
             prevEnd = ppEnd;
             if (collectPayloads && prevSpans.isPayloadAvailable()) {
-              Collection payload = prevSpans.getPayload();
-              possiblePayload = new ArrayList(payload.size());
+              Collection<byte[]> payload = prevSpans.getPayload();
+              possiblePayload = new ArrayList<byte[]>(payload.size());
               possiblePayload.addAll(payload);
             }
           }
Index: src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
===================================================================
--- src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(revision 826485)
+++ src/java/org/apache/lucene/search/spans/NearSpansUnordered.java	(working copy)
@@ -36,7 +36,7 @@
 public class NearSpansUnordered extends Spans {
   private SpanNearQuery query;
 
-  private List ordered = new ArrayList();         // spans in query order
+  private List<SpansCell> ordered = new ArrayList<SpansCell>();         // spans in query order
   private Spans[] subSpans;  
   private int slop;                               // from query
 
@@ -107,8 +107,8 @@
     public int start() { return spans.start(); }
     public int end() { return spans.end(); }
                     // TODO: Remove warning after API has been finalized
-    public Collection/*<byte[]>*/ getPayload() throws IOException {
-      return new ArrayList(spans.getPayload());
+    public Collection<byte[]> getPayload() throws IOException {
+      return new ArrayList<byte[]>(spans.getPayload());
     }
 
     // TODO: Remove warning after API has been finalized
@@ -223,8 +223,8 @@
    * @return Collection of <code>byte[]</code> payloads
    * @throws IOException
    */
-  public Collection/*<byte[]>*/ getPayload() throws IOException {
-    Set/*<byte[]*/ matchPayload = new HashSet();
+  public Collection<byte[]> getPayload() throws IOException {
+    Set<byte[]> matchPayload = new HashSet<byte[]>();
     for (SpansCell cell = first; cell != null; cell = cell.next) {
       if (cell.isPayloadAvailable()) {
         matchPayload.addAll(cell.getPayload());
Index: src/java/org/apache/lucene/search/spans/Spans.java
===================================================================
--- src/java/org/apache/lucene/search/spans/Spans.java	(revision 826485)
+++ src/java/org/apache/lucene/search/spans/Spans.java	(working copy)
@@ -75,7 +75,7 @@
    * @throws java.io.IOException
     */
   // TODO: Remove warning after API has been finalized
-  public abstract Collection/*<byte[]>*/ getPayload() throws IOException;
+  public abstract Collection<byte[]> getPayload() throws IOException;
 
   /**
    * Checks if a payload can be loaded at this position.
Index: src/java/org/apache/lucene/search/spans/SpanNearQuery.java
===================================================================
--- src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(revision 826485)
+++ src/java/org/apache/lucene/search/spans/SpanNearQuery.java	(working copy)
@@ -19,7 +19,7 @@
 
 import java.io.IOException;
 
-import java.util.Collection;
+
 import java.util.List;
 import java.util.ArrayList;
 import java.util.Iterator;
@@ -35,7 +35,7 @@
  * maximum number of intervening unmatched positions, as well as whether
  * matches are required to be in-order. */
 public class SpanNearQuery extends SpanQuery implements Cloneable {
-  protected List clauses;
+  protected List<SpanQuery> clauses;
   protected int slop;
   protected boolean inOrder;
 
@@ -53,7 +53,7 @@
   public SpanNearQuery(SpanQuery[] clauses, int slop, boolean inOrder, boolean collectPayloads) {
 
     // copy clauses array into an ArrayList
-    this.clauses = new ArrayList(clauses.length);
+    this.clauses = new ArrayList<SpanQuery>(clauses.length);
     for (int i = 0; i < clauses.length; i++) {
       SpanQuery clause = clauses[i];
       if (i == 0) {                               // check field
@@ -70,7 +70,7 @@
 
   /** Return the clauses whose spans are matched. */
   public SpanQuery[] getClauses() {
-    return (SpanQuery[])clauses.toArray(new SpanQuery[clauses.size()]);
+    return clauses.toArray(new SpanQuery[clauses.size()]);
   }
 
   /** Return the maximum number of intervening unmatched positions permitted.*/
@@ -82,9 +82,7 @@
   public String getField() { return field; }
   
   public void extractTerms(Set<Term> terms) {
-	    Iterator i = clauses.iterator();
-	    while (i.hasNext()) {
-	      SpanQuery clause = (SpanQuery)i.next();
+	    for (final SpanQuery clause : clauses) {
 	      clause.extractTerms(terms);
 	    }
   }  
@@ -93,9 +91,9 @@
   public String toString(String field) {
     StringBuilder buffer = new StringBuilder();
     buffer.append("spanNear([");
-    Iterator i = clauses.iterator();
+    Iterator<SpanQuery> i = clauses.iterator();
     while (i.hasNext()) {
-      SpanQuery clause = (SpanQuery)i.next();
+      SpanQuery clause = i.next();
       buffer.append(clause.toString(field));
       if (i.hasNext()) {
         buffer.append(", ");
@@ -115,7 +113,7 @@
       return new SpanOrQuery(getClauses()).getSpans(reader);
 
     if (clauses.size() == 1)                      // optimize 1-clause case
-      return ((SpanQuery)clauses.get(0)).getSpans(reader);
+      return clauses.get(0).getSpans(reader);
 
     return inOrder
             ? (Spans) new NearSpansOrdered(this, reader, collectPayloads)
@@ -125,7 +123,7 @@
   public Query rewrite(IndexReader reader) throws IOException {
     SpanNearQuery clone = null;
     for (int i = 0 ; i < clauses.size(); i++) {
-      SpanQuery c = (SpanQuery)clauses.get(i);
+      SpanQuery c = clauses.get(i);
       SpanQuery query = (SpanQuery) c.rewrite(reader);
       if (query != c) {                     // clause rewrote: must clone
         if (clone == null)
@@ -145,8 +143,7 @@
     SpanQuery[] newClauses = new SpanQuery[sz];
 
     for (int i = 0; i < sz; i++) {
-      SpanQuery clause = (SpanQuery) clauses.get(i);
-      newClauses[i] = (SpanQuery) clause.clone();
+      newClauses[i] = (SpanQuery) clauses.get(i).clone();
     }
     SpanNearQuery spanNearQuery = new SpanNearQuery(newClauses, slop, inOrder);
     spanNearQuery.setBoost(getBoost());
Index: src/java/org/apache/lucene/search/MultiPhraseQuery.java
===================================================================
--- src/java/org/apache/lucene/search/MultiPhraseQuery.java	(revision 826485)
+++ src/java/org/apache/lucene/search/MultiPhraseQuery.java	(working copy)
@@ -38,8 +38,8 @@
  */
 public class MultiPhraseQuery extends Query {
   private String field;
-  private ArrayList termArrays = new ArrayList();
-  private ArrayList positions = new ArrayList();
+  private ArrayList<Term[]> termArrays = new ArrayList<Term[]>();
+  private ArrayList<Integer> positions = new ArrayList<Integer>();
 
   private int slop = 0;
 
@@ -95,10 +95,10 @@
   }
 
   /**
-   * Returns a List<Term[]> of the terms in the multiphrase.
+   * Returns a List of the terms in the multiphrase.
    * Do not modify the List or its contents.
    */
-  public List getTermArrays() {
+  public List<Term[]> getTermArrays() {
 	  return Collections.unmodifiableList(termArrays);
   }
 
Index: src/java/org/apache/lucene/util/Parameter.java
===================================================================
--- src/java/org/apache/lucene/util/Parameter.java	(revision 826485)
+++ src/java/org/apache/lucene/util/Parameter.java	(working copy)
@@ -28,7 +28,7 @@
  */
 public abstract class Parameter implements Serializable
 {
-  static Map allParameters = new HashMap();
+  static Map<String,Parameter> allParameters = new HashMap<String,Parameter>();
   
   private String name;
   
Index: src/java/org/apache/lucene/util/cache/SimpleLRUCache.java
===================================================================
--- src/java/org/apache/lucene/util/cache/SimpleLRUCache.java	(revision 826485)
+++ src/java/org/apache/lucene/util/cache/SimpleLRUCache.java	(working copy)
@@ -26,24 +26,19 @@
  * if needed.
  * 
  */
-public class SimpleLRUCache extends SimpleMapCache {
+public class SimpleLRUCache<K,V> extends SimpleMapCache<K,V> {
   private final static float LOADFACTOR = 0.75f;
 
-  private int cacheSize;
-
   /**
    * Creates a last-recently-used cache with the specified size. 
    */
-  public SimpleLRUCache(int cacheSize) {
-    super(null);
-    this.cacheSize = cacheSize;
-    int capacity = (int) Math.ceil(cacheSize / LOADFACTOR) + 1;
-
-    super.map = new LinkedHashMap(capacity, LOADFACTOR, true) {
-      protected boolean removeEldestEntry(Map.Entry eldest) {
-        return size() > SimpleLRUCache.this.cacheSize;
+  public SimpleLRUCache(final int cacheSize) {
+    super(new LinkedHashMap<K,V>((int) Math.ceil(cacheSize / LOADFACTOR) + 1, LOADFACTOR, true) {
+      @Override
+      protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
+        return size() > cacheSize;
       }
-    };
+    });
   }
 
 }
Index: src/java/org/apache/lucene/util/cache/Cache.java
===================================================================
--- src/java/org/apache/lucene/util/cache/Cache.java	(revision 826485)
+++ src/java/org/apache/lucene/util/cache/Cache.java	(working copy)
@@ -21,43 +21,48 @@
 /**
  * Base class for cache implementations.
  */
-public abstract class Cache {
+public abstract class Cache<K,V> {
   
   /**
    * Simple Cache wrapper that synchronizes all
    * calls that access the cache. 
    */
-  static class SynchronizedCache extends Cache {
-    Object mutex;
-    Cache  cache;
+  static class SynchronizedCache<K,V> extends Cache<K,V> {
+    private Object mutex;
+    private Cache<K,V> cache;
     
-    SynchronizedCache(Cache cache) {
+    SynchronizedCache(Cache<K,V> cache) {
       this.cache = cache;
       this.mutex = this;
     }
     
-    SynchronizedCache(Cache cache, Object mutex) {
+    SynchronizedCache(Cache<K,V> cache, Object mutex) {
       this.cache = cache;
       this.mutex = mutex;
     }
     
-    public void put(Object key, Object value) {
+    @Override
+    public void put(K key, V value) {
       synchronized(mutex) {cache.put(key, value);}
     }
     
-    public Object get(Object key) {
+    @Override
+    public V get(Object key) {
       synchronized(mutex) {return cache.get(key);}
     }
     
+    @Override
     public boolean containsKey(Object key) {
       synchronized(mutex) {return cache.containsKey(key);}
     }
     
+    @Override
     public void close() {
       synchronized(mutex) {cache.close();}
     }
     
-    Cache getSynchronizedCache() {
+    @Override
+    Cache<K,V> getSynchronizedCache() {
       return this;
     }
   }
@@ -67,7 +72,7 @@
    * In order to guarantee thread-safety, all access to the backed cache must
    * be accomplished through the returned cache.
    */
-  public static Cache synchronizedCache(Cache cache) {
+  public static <K,V> Cache<K,V> synchronizedCache(Cache<K,V> cache) {
     return cache.getSynchronizedCache();
   }
 
@@ -78,19 +83,19 @@
    * e. g. subclasses of {@link SynchronizedCache} or this
    * in case this cache is already synchronized.
    */
-  Cache getSynchronizedCache() {
-    return new SynchronizedCache(this);
+  Cache<K,V> getSynchronizedCache() {
+    return new SynchronizedCache<K,V>(this);
   }
   
   /**
    * Puts a (key, value)-pair into the cache. 
    */
-  public abstract void put(Object key, Object value);
+  public abstract void put(K key, V value);
   
   /**
    * Returns the value for the given key. 
    */
-  public abstract Object get(Object key);
+  public abstract V get(Object key);
   
   /**
    * Returns whether the given key is in this cache. 
Index: src/java/org/apache/lucene/util/cache/SimpleMapCache.java
===================================================================
--- src/java/org/apache/lucene/util/cache/SimpleMapCache.java	(revision 826485)
+++ src/java/org/apache/lucene/util/cache/SimpleMapCache.java	(working copy)
@@ -26,29 +26,33 @@
  * This cache is not synchronized, use {@link Cache#synchronizedCache(Cache)}
  * if needed.
  */
-public class SimpleMapCache extends Cache {
-  Map map;
+public class SimpleMapCache<K,V> extends Cache<K,V> {
+  protected Map<K,V> map;
   
   public SimpleMapCache() {
-    this(new HashMap());
+    this(new HashMap<K,V>());
   }
 
-  public SimpleMapCache(Map map) {
+  public SimpleMapCache(Map<K,V> map) {
     this.map = map;
   }
   
-  public Object get(Object key) {
+  @Override
+  public V get(Object key) {
     return map.get(key);
   }
 
-  public void put(Object key, Object value) {
+  @Override
+  public void put(K key, V value) {
     map.put(key, value);
   }
 
+  @Override
   public void close() {
     // NOOP
   }
 
+  @Override
   public boolean containsKey(Object key) {
     return map.containsKey(key);
   }
@@ -56,44 +60,51 @@
   /**
    * Returns a Set containing all keys in this cache.
    */
-  public Set keySet() {
+  public Set<K> keySet() {
     return map.keySet();
   }
   
-  Cache getSynchronizedCache() {
-    return new SynchronizedSimpleMapCache(this);
+  @Override
+  Cache<K,V> getSynchronizedCache() {
+    return new SynchronizedSimpleMapCache<K,V>(this);
   }
   
-  private static class SynchronizedSimpleMapCache extends SimpleMapCache {
-    Object mutex;
-    SimpleMapCache cache;
+  private static class SynchronizedSimpleMapCache<K,V> extends SimpleMapCache<K,V> {
+    private Object mutex;
+    private SimpleMapCache<K,V> cache;
     
-    SynchronizedSimpleMapCache(SimpleMapCache cache) {
+    SynchronizedSimpleMapCache(SimpleMapCache<K,V> cache) {
         this.cache = cache;
         this.mutex = this;
     }
     
-    public void put(Object key, Object value) {
+    @Override
+    public void put(K key, V value) {
         synchronized(mutex) {cache.put(key, value);}
     }
     
-    public Object get(Object key) {
+    @Override
+    public V get(Object key) {
         synchronized(mutex) {return cache.get(key);}
     }
     
+    @Override
     public boolean containsKey(Object key) {
         synchronized(mutex) {return cache.containsKey(key);}
     }
     
+    @Override
     public void close() {
         synchronized(mutex) {cache.close();}
     }
     
-    public Set keySet() {
+    @Override
+    public Set<K> keySet() {
       synchronized(mutex) {return cache.keySet();}
     }
     
-    Cache getSynchronizedCache() {
+    @Override
+    Cache<K,V> getSynchronizedCache() {
       return this;
     }
   }
Index: src/java/org/apache/lucene/util/AverageGuessMemoryModel.java
===================================================================
--- src/java/org/apache/lucene/util/AverageGuessMemoryModel.java	(revision 826485)
+++ src/java/org/apache/lucene/util/AverageGuessMemoryModel.java	(working copy)
@@ -26,7 +26,7 @@
  */
 public class AverageGuessMemoryModel extends MemoryModel {
   // best guess primitive sizes
-  private final Map sizes = new IdentityHashMap() {
+  private final Map<Class,Integer> sizes = new IdentityHashMap<Class,Integer>() {
     {
       put(boolean.class, Integer.valueOf(1));
       put(byte.class, Integer.valueOf(1));
@@ -61,7 +61,7 @@
    * @see org.apache.lucene.util.MemoryModel#getPrimitiveSize(java.lang.Class)
    */
   public int getPrimitiveSize(Class clazz) {
-    return ((Integer) sizes.get(clazz)).intValue();
+    return sizes.get(clazz).intValue();
   }
 
   /* (non-Javadoc)
Index: src/java/org/apache/lucene/util/ReaderUtil.java
===================================================================
--- src/java/org/apache/lucene/util/ReaderUtil.java	(revision 826485)
+++ src/java/org/apache/lucene/util/ReaderUtil.java	(working copy)
@@ -34,7 +34,7 @@
    * @param allSubReaders
    * @param reader
    */
-  public static void gatherSubReaders(List allSubReaders, IndexReader reader) {
+  public static void gatherSubReaders(List<IndexReader> allSubReaders, IndexReader reader) {
     IndexReader[] subReaders = reader.getSequentialSubReaders();
     if (subReaders == null) {
       // Add the reader itself, and do not recurse
@@ -54,7 +54,7 @@
    * @return sub reader of parent which contains the specified doc id
    */
   public static IndexReader subReader(int doc, IndexReader reader) {
-    List subReadersList = new ArrayList();
+    List<IndexReader> subReadersList = new ArrayList<IndexReader>();
     ReaderUtil.gatherSubReaders(subReadersList, reader);
     IndexReader[] subReaders = (IndexReader[]) subReadersList
         .toArray(new IndexReader[subReadersList.size()]);
@@ -75,7 +75,7 @@
    * @return the subreader at subIndex
    */
   public static IndexReader subReader(IndexReader reader, int subIndex) {
-    List subReadersList = new ArrayList();
+    List<IndexReader> subReadersList = new ArrayList<IndexReader>();
     ReaderUtil.gatherSubReaders(subReadersList, reader);
     IndexReader[] subReaders = (IndexReader[]) subReadersList
         .toArray(new IndexReader[subReadersList.size()]);
Index: src/java/org/apache/lucene/util/RamUsageEstimator.java
===================================================================
--- src/java/org/apache/lucene/util/RamUsageEstimator.java	(revision 826485)
+++ src/java/org/apache/lucene/util/RamUsageEstimator.java	(working copy)
@@ -37,7 +37,7 @@
 public final class RamUsageEstimator {
   private MemoryModel memoryModel;
 
-  private final Map seen;
+  private final Map<Object,Object> seen;
 
   private int refSize;
   private int arraySize;
@@ -82,7 +82,7 @@
     this.checkInterned = checkInterned;
     // Use Map rather than Set so that we can use an IdentityHashMap - not
     // seeing an IdentityHashSet
-    seen = new IdentityHashMap(64);
+    seen = new IdentityHashMap<Object,Object>(64);
     this.refSize = memoryModel.getReferenceSize();
     this.arraySize = memoryModel.getArraySize();
     this.classSize = memoryModel.getClassSize();
Index: src/java/org/apache/lucene/document/SetBasedFieldSelector.java
===================================================================
--- src/java/org/apache/lucene/document/SetBasedFieldSelector.java	(revision 826485)
+++ src/java/org/apache/lucene/document/SetBasedFieldSelector.java	(working copy)
@@ -23,8 +23,8 @@
  **/
 public class SetBasedFieldSelector implements FieldSelector {
   
-  private Set fieldsToLoad;
-  private Set lazyFieldsToLoad;
+  private Set<String> fieldsToLoad;
+  private Set<String> lazyFieldsToLoad;
   
   
 
@@ -34,7 +34,7 @@
    * @param fieldsToLoad A Set of {@link String} field names to load.  May be empty, but not null
    * @param lazyFieldsToLoad A Set of {@link String} field names to load lazily.  May be empty, but not null  
    */
-  public SetBasedFieldSelector(Set fieldsToLoad, Set lazyFieldsToLoad) {
+  public SetBasedFieldSelector(Set<String> fieldsToLoad, Set<String> lazyFieldsToLoad) {
     this.fieldsToLoad = fieldsToLoad;
     this.lazyFieldsToLoad = lazyFieldsToLoad;
   }
Index: src/java/org/apache/lucene/document/MapFieldSelector.java
===================================================================
--- src/java/org/apache/lucene/document/MapFieldSelector.java	(revision 826485)
+++ src/java/org/apache/lucene/document/MapFieldSelector.java	(working copy)
@@ -17,6 +17,7 @@
  * limitations under the License.
  */
 
+import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -27,39 +28,39 @@
  */
 public class MapFieldSelector implements FieldSelector {
     
-    Map fieldSelections;
+    Map<String,FieldSelectorResult> fieldSelections;
     
     /** Create a a MapFieldSelector
      * @param fieldSelections maps from field names (String) to {@link FieldSelectorResult}s
      */
-    public MapFieldSelector(Map fieldSelections) {
+    public MapFieldSelector(Map<String,FieldSelectorResult> fieldSelections) {
         this.fieldSelections = fieldSelections;
     }
     
     /** Create a a MapFieldSelector
      * @param fields fields to LOAD.  List of Strings.  All other fields are NO_LOAD.
      */
-    public MapFieldSelector(List fields) {
-        fieldSelections = new HashMap(fields.size()*5/3);
-        for (int i=0; i<fields.size(); i++)
-            fieldSelections.put(fields.get(i), FieldSelectorResult.LOAD);
+    public MapFieldSelector(List<String> fields) {
+        fieldSelections = new HashMap<String,FieldSelectorResult>(fields.size()*5/3);
+        for (final String field : fields)
+            fieldSelections.put(field, FieldSelectorResult.LOAD);
     }
     
     /** Create a a MapFieldSelector
      * @param fields fields to LOAD.  All other fields are NO_LOAD.
      */
     public MapFieldSelector(String[] fields) {
-        fieldSelections = new HashMap(fields.length*5/3);
-        for (int i=0; i<fields.length; i++)
-            fieldSelections.put(fields[i], FieldSelectorResult.LOAD);
+      this(Arrays.asList(fields));
     }
+
+
     
     /** Load field according to its associated value in fieldSelections
      * @param field a field name
      * @return the fieldSelections value that field maps to or NO_LOAD if none.
      */
     public FieldSelectorResult accept(String field) {
-        FieldSelectorResult selection = (FieldSelectorResult) fieldSelections.get(field);
+        FieldSelectorResult selection = fieldSelections.get(field);
         return selection!=null ? selection : FieldSelectorResult.NO_LOAD;
     }
     
