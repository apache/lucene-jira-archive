diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/AndQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/AndQuery.java
index 2ed8d79..4045f0f 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/AndQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/AndQuery.java
@@ -29,7 +29,7 @@ public class AndQuery extends ComposedQuery {
   
   @Override
   public Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf) {
-    return SrndBooleanQuery.makeBooleanQuery( /* subqueries can be individually boosted */
+    return qf.newBooleanQuery( // subqueries can be individually boosted
       makeLuceneSubQueriesField(fieldName, qf), BooleanClause.Occur.MUST);
   }
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java
index 4f01a2d..a156b42 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/BasicQueryFactory.java
@@ -15,20 +15,27 @@
  * limitations under the License.
  */
 package org.apache.lucene.queryparser.surround.query;
-/* Create basic queries to be used during rewrite.
- * The basic queries are TermQuery and SpanTermQuery.
- * An exception can be thrown when too many of these are used.
- * SpanTermQuery and TermQuery use IndexReader.termEnum(Term), which causes the buffer usage.
- *
- * Use this class to limit the buffer usage for reading terms from an index.
- * Default is 1024, the same as the max. number of subqueries for a BooleanQuery.
- */
+
+import java.util.List;
 
 import org.apache.lucene.index.Term;
+import org.apache.lucene.search.Query;
 import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.DisjunctionMaxQuery;
+import org.apache.lucene.search.SynonymQuery;
+import org.apache.lucene.search.spans.SpanQuery;
 import org.apache.lucene.search.spans.SpanTermQuery;
+import org.apache.lucene.search.spans.SpanNearQuery;
+import org.apache.lucene.search.spans.SpanSynonymQuery;
 
-/** Factory for creating basic term queries */
+/** Factory for creating primitive queries to be used during as result of rewriting.
+ * An exception can be thrown when too many terms are involved.
+ * <br>
+ * Use this class to limit the total number of terms involved in rewriting to primitive queries.
+ * The default maximum is 1024, the same as the max. number of subqueries for a BooleanQuery.
+ */
 public class BasicQueryFactory {
   public BasicQueryFactory(int maxBasicQueries) {
     this.maxBasicQueries = maxBasicQueries;
@@ -47,46 +54,113 @@ public class BasicQueryFactory {
 
   @Override
   public String toString() {
-    return getClass().getName()
+    return getClass().getSimpleName()
     + "(maxBasicQueries: " + maxBasicQueries
     + ", queriesMade: " + queriesMade
     + ")";
   }
 
-  private boolean atMax() {
-    return queriesMade >= maxBasicQueries;
+  private boolean aboveMax() {
+    return queriesMade > maxBasicQueries;
   }
 
-  protected synchronized void checkMax() throws TooManyBasicQueries {
-    if (atMax())
+  protected void checkMax(int numQueries) throws TooManyBasicQueries {
+    queriesMade += numQueries;
+    if (aboveMax()) {
       throw new TooManyBasicQueries(getMaxBasicQueries());
-    queriesMade++;
+    }
   }
 
   public TermQuery newTermQuery(Term term) throws TooManyBasicQueries {
-    checkMax();
+    checkMax(1);
     return new TermQuery(term);
   }
 
   public SpanTermQuery newSpanTermQuery(Term term) throws TooManyBasicQueries {
-    checkMax();
+    checkMax(1);
     return new SpanTermQuery(term);
   }
 
-  @Override
-  public int hashCode() {
-    return getClass().hashCode() ^ (atMax() ? 7 : 31*32);
+  /** Create a BooleanQuery over the given queries.
+   * If necessary this temporarily increases {@link BooleanQuery#setMaxClauseCount}.
+   */
+  public BooleanQuery newBooleanQuery(List<Query> queries, BooleanClause.Occur occur) {
+    if (queries.size() <= 1) {
+      throw new AssertionError("Too few subqueries: " + queries.size());
+    }
+    BooleanQuery.Builder bq = new BooleanQuery.Builder();
+    for (int i = 0; i < queries.size(); i++) {
+      bq.add( queries.get(i), occur);
+    }
+    return bq.build();
+  }
+
+  /** Create a BooleanQuery with the first subquery required and the later subqueries prohibited.
+   * If necessary this temporarily increases {@link BooleanQuery#setMaxClauseCount}.
+   */
+  public BooleanQuery newNotQuery(List<Query> queries) {
+    if (queries.size() <= 1) {
+      throw new AssertionError("Too few subqueries: " + queries.size());
+    }
+    BooleanQuery.Builder bq = new BooleanQuery.Builder();
+    bq.add( queries.get(0), BooleanClause.Occur.MUST); // first subquery required
+    for (Query q : queries.subList(1, queries.size())) {
+      bq.add( q, BooleanClause.Occur.MUST_NOT); // later subqueries prohibited
+    }
+    return bq.build();
+  }
+
+
+  /** Create a DisjunctionMaxQuery over the given queries using <code>tieBreakerMultiplier=0.1</code>
+   *  <br>Override this to use another <code>tieBreakerMultiplier</code>
+   */
+  public DisjunctionMaxQuery newDisjunctionMaxQuery(List<Query> queries) {
+    float tieBreakerMultiplier = 0.1f;
+    return new DisjunctionMaxQuery(queries, tieBreakerMultiplier);
+  }
+
+  /** Create a SpanNearQuery over the given clauses, with the given allowedSlop and ordered.
+   */
+  public SpanNearQuery newSpanNearQuery(SpanQuery[] spanClauses, int allowedSlop, boolean ordered) {
+    assert allowedSlop >= 0;
+    return new SpanNearQuery(spanClauses, allowedSlop, ordered);
   }
 
-  /** Two BasicQueryFactory's are equal when they generate
-   *  the same types of basic queries, or both cannot generate queries anymore.
+  /** Create a SynonymQuery over the given terms.
+   * If necessary this temporarily increases {@link BooleanQuery#setMaxClauseCount}.
+   */
+  public SynonymQuery newSynonymQuery(List<Term> termList) throws TooManyBasicQueries  {
+    assert termList.size() >= 2;
+    checkMax(termList.size());
+    return new SynonymQuery(termList.toArray(new Term[termList.size()]));
+  }
+
+
+  /** Create a SpanSynonymQuery over the given terms.
+   * If necessary this temporarily increases {@link BooleanQuery#setMaxClauseCount}.
    */
+  public SpanSynonymQuery newSpanSynonymQuery(List<Term> termList) throws TooManyBasicQueries {
+    assert termList.size() >= 2;
+    checkMax(termList.size());
+    return new SpanSynonymQuery(termList.toArray(new Term[termList.size()]));
+  }
+
+
   @Override
-  public boolean equals(Object obj) {
-    if (! (obj instanceof BasicQueryFactory))
+  public boolean equals(Object other) {
+    if (! (other instanceof BasicQueryFactory)) {
       return false;
-    BasicQueryFactory other = (BasicQueryFactory) obj;
-    return atMax() == other.atMax();
+    }
+    BasicQueryFactory obqf = (BasicQueryFactory) other;
+    return maxBasicQueries == obqf.maxBasicQueries
+           && queriesMade == obqf.queriesMade;
+  }
+
+  @Override
+  public int hashCode() {
+    return getClass().hashCode()
+           ^ (7 * maxBasicQueries)
+           ^ (31 * queriesMade);
   }
 }
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java
index 74fd3ae..1fbd9f3 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceQuery.java
@@ -22,7 +22,6 @@ import java.io.IOException;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.search.MatchNoDocsQuery;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.spans.SpanNearQuery;
 import org.apache.lucene.search.spans.SpanQuery;
 
 /** Factory for NEAR queries */
@@ -94,12 +93,18 @@ public class DistanceQuery extends ComposedQuery implements DistanceSubQuery {
       qi++;
     }
 
-    return new SpanNearQuery(spanClauses, getOpDistance() - 1, subQueriesOrdered());
+    return qf.newSpanNearQuery(spanClauses, getOpDistance() - 1, subQueriesOrdered());
   }
 
   @Override
   public Query makeLuceneQueryFieldNoBoost(final String fieldName, final BasicQueryFactory qf) {
-    return new DistanceRewriteQuery(this, fieldName, qf);
+    return new RewriteQuery<DistanceQuery>(this, fieldName, qf) {
+
+      @Override
+      public Query rewrite(IndexReader reader) throws IOException {
+        return srndQuery.getSpanNearQuery(reader, fieldName, qf);
+      }
+    };
   }
 }
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceRewriteQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceRewriteQuery.java
deleted file mode 100644
index 1972a8e..0000000
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/DistanceRewriteQuery.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.queryparser.surround.query;
-import java.io.IOException;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.Query;
-
-class DistanceRewriteQuery extends RewriteQuery<DistanceQuery> {
-
-  DistanceRewriteQuery(
-      DistanceQuery srndQuery,
-      String fieldName,
-      BasicQueryFactory qf) {
-    super(srndQuery, fieldName, qf);
-  }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    return srndQuery.getSpanNearQuery(reader, fieldName, qf);
-  }
-}
-
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/FieldsQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/FieldsQuery.java
index 23bb095..6bc4b3a 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/FieldsQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/FieldsQuery.java
@@ -22,13 +22,13 @@ import java.util.Iterator;
 import org.apache.lucene.search.Query;
 
 /**
- * Forms an OR query of the provided query across multiple fields.
+ * Forms a {@link org.apache.lucene.search.DisjunctionMaxQuery} for
+ * the provided query across multiple fields.
  */
-public class FieldsQuery extends SrndQuery { /* mostly untested */
+public class FieldsQuery extends SrndQuery {
   private SrndQuery q;
   private List<String> fieldNames;
   private final char fieldOp;
-  private final String OrOperatorName = "OR"; /* for expanded queries, not normally visible */
 
   public FieldsQuery(SrndQuery q, List<String> fieldNames, char fieldOp) {
     this.q = q;
@@ -51,19 +51,12 @@ public class FieldsQuery extends SrndQuery { /* mostly untested */
   public Query makeLuceneQueryNoBoost(BasicQueryFactory qf) {
     if (fieldNames.size() == 1) { /* single field name: no new queries needed */
       return q.makeLuceneQueryFieldNoBoost(fieldNames.get(0), qf);
-    } else { /* OR query over the fields */
-      List<SrndQuery> queries = new ArrayList<>();
-      Iterator<String> fni = getFieldNames().listIterator();
-      SrndQuery qc;
-      while (fni.hasNext()) {
-        qc = q.clone();
-        queries.add( new FieldsQuery( qc, fni.next(), fieldOp));
+    } else { /* DisjunctionMaxQuery query over the fields */
+      List<Query> queries = new ArrayList<>();
+      for (String fieldName : fieldNames) {
+        queries.add(q.makeLuceneQueryFieldNoBoost(fieldName, qf));
       }
-      OrQuery oq = new OrQuery(queries,
-                              true /* infix OR for field names */,
-                              OrOperatorName);
-      // System.out.println(getClass().toString() + ", fields expanded: " + oq.toString()); /* needs testing */
-      return oq.makeLuceneQueryField(null, qf);
+      return qf.newDisjunctionMaxQuery(queries);
     }
   }
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/NotQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/NotQuery.java
index 897d3a8..8d09521 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/NotQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/NotQuery.java
@@ -17,8 +17,6 @@
 package org.apache.lucene.queryparser.surround.query;
 import java.util.List;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.BooleanClause;
 
 /**
  * Factory for prohibited clauses
@@ -28,14 +26,8 @@ public class NotQuery extends ComposedQuery {
   
   @Override
   public Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf) {
-    List<Query> luceneSubQueries = makeLuceneSubQueriesField(fieldName, qf);
-    BooleanQuery.Builder bq = new BooleanQuery.Builder();
-    bq.add( luceneSubQueries.get(0), BooleanClause.Occur.MUST);
-    SrndBooleanQuery.addQueriesToBoolean(bq,
     // FIXME: do not allow weights on prohibited subqueries.
-            luceneSubQueries.subList(1, luceneSubQueries.size()),
-            // later subqueries: not required, prohibited
-            BooleanClause.Occur.MUST_NOT);
-    return bq.build();
+    List<Query> luceneSubQueries = makeLuceneSubQueriesField(fieldName, qf);
+    return qf.newNotQuery(luceneSubQueries);
   }
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/OrQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/OrQuery.java
index 76daa19..1d27fb9 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/OrQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/OrQuery.java
@@ -32,8 +32,7 @@ public class OrQuery extends ComposedQuery implements DistanceSubQuery {
 
   @Override
   public Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf) {
-    return SrndBooleanQuery.makeBooleanQuery(
-      /* subqueries can be individually boosted */
+    return qf.newBooleanQuery( // subqueries can be individually boosted
       makeLuceneSubQueriesField(fieldName, qf), BooleanClause.Occur.SHOULD);
   }
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java
index 438535f..af2381e 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/RewriteQuery.java
@@ -40,11 +40,11 @@ abstract class RewriteQuery<SQ extends SrndQuery> extends Query {
 
   @Override
   public String toString(String field) {
-    return getClass().getName()
+    return "RewriteQuery"
     + (field.isEmpty() ? "" : "(unused: " + field + ")")
     + "(" + fieldName
-    + ", " + srndQuery.toString()
-    + ", " + qf.toString()
+    + ": " + srndQuery.toString()
+    // + ", " + qf.toString()
     + ")";
   }
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTerm.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTerm.java
index f574feb..d0d86db 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTerm.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTerm.java
@@ -15,18 +15,23 @@
  * limitations under the License.
  */
 package org.apache.lucene.queryparser.surround.query;
+
 import java.io.IOException;
+import java.util.List;
+import java.util.ArrayList;
 
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.MatchNoDocsQuery;
+import org.apache.lucene.util.BytesRef;
 
 /**
  * Base class for queries that expand to sets of simple terms.
  */
 public abstract class SimpleTerm
   extends SrndQuery
-  implements DistanceSubQuery, Comparable<SimpleTerm>
+  implements DistanceSubQuery
 {
   public SimpleTerm(boolean q) {quoted = q;}
 
@@ -38,16 +43,6 @@ public abstract class SimpleTerm
 
   public abstract String toStringUnquoted();
 
-  /** @deprecated (March 2011) Not normally used, to be removed from Lucene 4.0.
-   *   This class implementing Comparable is to be removed at the same time.
-   */
-  @Override
-  @Deprecated
-  public int compareTo(SimpleTerm ost) {
-    /* for ordering terms and prefixes before using an index, not used */
-    return this.toStringUnquoted().compareTo( ost.toStringUnquoted());
-  }
-  
   protected void suffixToString(StringBuilder r) {} /* override for prefix query */
 
   @Override
@@ -72,10 +67,10 @@ public abstract class SimpleTerm
 
   /**
    * Callback to visit each matching term during "rewrite"
-   * in {@link #visitMatchingTerm(Term)}
+   * in {@link #visitMatchingTerm(BytesRef)}
    */
   public interface MatchingTermVisitor {
-    void visitMatchingTerm(Term t)throws IOException;
+    void visitMatchingTerm(BytesRef termRef)throws IOException;
   }
 
   @Override
@@ -83,21 +78,48 @@ public abstract class SimpleTerm
 
   @Override
   public void addSpanQueries(final SpanNearClauseFactory sncf) throws IOException {
-    visitMatchingTerms(
-          sncf.getIndexReader(),
-          sncf.getFieldName(),
+    ArrayList<Term> terms = new ArrayList<>();
+    String fieldName = sncf.getFieldName();
+    visitMatchingTerms( sncf.getIndexReader(), fieldName,
           new MatchingTermVisitor() {
             @Override
-            public void visitMatchingTerm(Term term) throws IOException {
-              sncf.addTermWeighted(term, getWeight());
+            public void visitMatchingTerm(BytesRef termRef) throws IOException {
+              terms.add(new Term(fieldName, termRef)); // termRef is copied.
             }
           });
+    if (terms.size() == 0) {
+      return;
+    }
+    else if (terms.size() == 1) {
+      sncf.addTermWeighted(terms.get(0), getWeight());
+    }
+    else {
+      BasicQueryFactory qf = sncf.getBasicQueryFactory();
+      sncf.addSpanQueryWeighted(qf.newSpanSynonymQuery(terms), getWeight());
+    }
   }
 
   @Override
   public Query makeLuceneQueryFieldNoBoost(final String fieldName, final BasicQueryFactory qf) {
-    return new SimpleTermRewriteQuery(this, fieldName, qf);
+    return new RewriteQuery<SimpleTerm>(this, fieldName, qf) {
+
+      @Override
+      public Query rewrite(IndexReader reader) throws IOException {
+        final List<Term> terms = new ArrayList<>();
+        srndQuery.visitMatchingTerms(reader, fieldName,
+            new MatchingTermVisitor() {
+              @Override
+              public void visitMatchingTerm(BytesRef termRef) throws IOException {
+                terms.add(new Term(fieldName, termRef));
               }
+            });
+        return  (terms.size() == 0) ? new MatchNoDocsQuery()
+              : (terms.size() == 1) ? qf.newTermQuery(terms.get(0))
+                                    : qf.newSynonymQuery(terms);
+      }
+    };
+  }
+
 }
 
 
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTermRewriteQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTermRewriteQuery.java
deleted file mode 100644
index 3e0e4aa..0000000
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SimpleTermRewriteQuery.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.queryparser.surround.query;
-import java.io.IOException;
-import java.util.List;
-import java.util.ArrayList;
-
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.MatchNoDocsQuery;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanClause;
-import org.apache.lucene.index.Term;
-
-class SimpleTermRewriteQuery extends RewriteQuery<SimpleTerm> {
-
-  SimpleTermRewriteQuery(
-      SimpleTerm srndQuery,
-      String fieldName,
-      BasicQueryFactory qf) {
-    super(srndQuery, fieldName, qf);
-  }
-
-  @Override
-  public Query rewrite(IndexReader reader) throws IOException {
-    final List<Query> luceneSubQueries = new ArrayList<>();
-    srndQuery.visitMatchingTerms(reader, fieldName,
-    new SimpleTerm.MatchingTermVisitor() {
-      @Override
-      public void visitMatchingTerm(Term term) throws IOException {
-        luceneSubQueries.add(qf.newTermQuery(term));
-      }
-    });
-    return  (luceneSubQueries.size() == 0) ? new MatchNoDocsQuery()
-    : (luceneSubQueries.size() == 1) ? luceneSubQueries.get(0)
-    : SrndBooleanQuery.makeBooleanQuery(
-      /* luceneSubQueries all have default weight */
-      luceneSubQueries, BooleanClause.Occur.SHOULD); /* OR the subquery terms */
-  }
-}
-
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java
index 2db315f..42a4ba5 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SpanNearClauseFactory.java
@@ -66,7 +66,7 @@ import org.apache.lucene.search.spans.SpanTermQuery;
 
 
 /**
- * Factory for {@link SpanOrQuery}
+ * Factory for {@link SpanOrQuery}.
  */
 public class SpanNearClauseFactory { // FIXME: rename to SpanClauseFactory
   public SpanNearClauseFactory(IndexReader reader, String fieldName, BasicQueryFactory qf) {
@@ -75,6 +75,11 @@ public class SpanNearClauseFactory { // FIXME: rename to SpanClauseFactory
     this.weightBySpanQuery = new HashMap<>();
     this.qf = qf;
   }
+
+  public SpanNearClauseFactory(SpanNearClauseFactory sncf) {
+    this(sncf.reader, sncf.fieldName, sncf.qf);
+  }
+
   private IndexReader reader;
   private String fieldName;
   private HashMap<SpanQuery, Float> weightBySpanQuery;
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndBooleanQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndBooleanQuery.java
deleted file mode 100644
index 501034e..0000000
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndBooleanQuery.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.queryparser.surround.query;
-import java.util.List;
-
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.BooleanQuery;
-import org.apache.lucene.search.BooleanClause;
-
-class SrndBooleanQuery {
-  public static void addQueriesToBoolean(
-          BooleanQuery.Builder bq,
-          List<Query> queries,
-          BooleanClause.Occur occur) {
-    for (int i = 0; i < queries.size(); i++) {
-      bq.add( queries.get(i), occur);
-    }
-  }
-  
-  public static Query makeBooleanQuery(
-          List<Query> queries,
-          BooleanClause.Occur occur) {
-    if (queries.size() <= 1) {
-      throw new AssertionError("Too few subqueries: " + queries.size());
-    }
-    BooleanQuery.Builder bq = new BooleanQuery.Builder();
-    addQueriesToBoolean(bq, queries.subList(0, queries.size()), occur);
-    return bq.build();
-  }
-}
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndPrefixQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndPrefixQuery.java
index 587c4fb..fac2c3d 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndPrefixQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndPrefixQuery.java
@@ -15,7 +15,9 @@
  * limitations under the License.
  */
 package org.apache.lucene.queryparser.surround.query;
-import org.apache.lucene.index.Term;
+
+import java.io.IOException;
+
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.StringHelper;
@@ -23,36 +25,42 @@ import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.MultiFields;
 
-import java.io.IOException;
-
 
 /**
  * Query that matches String prefixes
  */
 public class SrndPrefixQuery extends SimpleTerm {
-  private final BytesRef prefixRef;
+
   public SrndPrefixQuery(String prefix, boolean quoted, char truncator) {
     super(quoted);
     this.prefix = prefix;
-    prefixRef = new BytesRef(prefix);
+    this.prefixRef = new BytesRef(prefix);
     this.truncator = truncator;
   }
 
+  private BytesRef prefixRef;
+
   private final String prefix;
-  public String getPrefix() {return prefix;}
+
+  public String getPrefix() {
+    return prefix;
+  }
 
   private final char truncator;
-  public char getSuffixOperator() {return truncator;}
 
-  public Term getLucenePrefixTerm(String fieldName) {
-    return new Term(fieldName, getPrefix());
+  public char getSuffixOperator() {
+    return truncator;
   }
 
   @Override
-  public String toStringUnquoted() {return getPrefix();}
+  public String toStringUnquoted() {
+    return prefix;
+  }
 
   @Override
-  protected void suffixToString(StringBuilder r) {r.append(getSuffixOperator());}
+  protected void suffixToString(StringBuilder r) {
+    r.append(getSuffixOperator());
+  }
 
   @Override
   public void visitMatchingTerms(
@@ -60,36 +68,35 @@ public class SrndPrefixQuery extends SimpleTerm {
     String fieldName,
     MatchingTermVisitor mtv) throws IOException
   {
-    /* inspired by PrefixQuery.rewrite(): */
+    // See also PrefixQuery.rewrite()
     Terms terms = MultiFields.getTerms(reader, fieldName);
     if (terms != null) {
       TermsEnum termsEnum = terms.iterator();
-
       boolean skip = false;
-      TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(getPrefix()));
+      TermsEnum.SeekStatus status = termsEnum.seekCeil(prefixRef);
+
       if (status == TermsEnum.SeekStatus.FOUND) {
-        mtv.visitMatchingTerm(getLucenePrefixTerm(fieldName));
-      } else if (status == TermsEnum.SeekStatus.NOT_FOUND) {
-        if (StringHelper.startsWith(termsEnum.term(), prefixRef)) {
-          mtv.visitMatchingTerm(new Term(fieldName, termsEnum.term().utf8ToString()));
-        } else {
-          skip = true;
+        mtv.visitMatchingTerm(prefixRef);
       }
-      } else {
-        // EOF
-        skip = true;
+      else if (status == TermsEnum.SeekStatus.NOT_FOUND) {
+        BytesRef termRef = termsEnum.term();
+        if (! StringHelper.startsWith(termRef, prefixRef)) {
+          return;
+        }
+        mtv.visitMatchingTerm(termRef);
+      }
+      else { // TermsEnum.SeekStatus.END
+        return;
       }
 
-      if (!skip) {
       while(true) {
-          BytesRef text = termsEnum.next();
-          if (text != null && StringHelper.startsWith(text, prefixRef)) {
-            mtv.visitMatchingTerm(new Term(fieldName, text.utf8ToString()));
-          } else {
-            break;
-          }
+        BytesRef termRef = termsEnum.next();
+        if ((termRef == null) || (! StringHelper.startsWith(termRef, prefixRef))) {
+          return;
         }
+        mtv.visitMatchingTerm(termRef);
       }
     }
   }
+
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndQuery.java
index 4ecb30f..dafbe15 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndQuery.java
@@ -14,9 +14,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 package org.apache.lucene.queryparser.surround.query;
-import org.apache.lucene.search.BoostQuery;
+
+import java.util.Arrays;
+
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.BoostQuery;
+import org.apache.lucene.search.spans.SpanQuery;
+import org.apache.lucene.search.spans.SpanBoostQuery;
 
 /** Lowest level base class for surround queries */
 public abstract class SrndQuery implements Cloneable {
@@ -42,16 +48,30 @@ public abstract class SrndQuery implements Cloneable {
     }
   }
 
-  public Query makeLuceneQueryField(String fieldName, BasicQueryFactory qf){
+  public Query makeLuceneQueryField(String fieldName, BasicQueryFactory qf) { /* weight may be at any level in a SrndQuery */
     Query q = makeLuceneQueryFieldNoBoost(fieldName, qf);
     if (isWeighted()) {
-      q = new BoostQuery(q, getWeight()); /* weight may be at any level in a SrndQuery */
+      if (q instanceof SpanQuery) {
+        q = new SpanBoostQuery((SpanQuery) q, getWeight());
+      }
+      else {
+        q = new BoostQuery(q, getWeight());
+      }
     }
     return q;
   }
 
+
   public abstract Query makeLuceneQueryFieldNoBoost(String fieldName, BasicQueryFactory qf);
 
+  public Query makeLuceneQueryFields(BasicQueryFactory qf, String... fieldNames) {
+    if (fieldNames.length == 0) {
+      throw new IllegalArgumentException("No fieldNames given");
+    }
+    char fieldOp = ':'; // same field operator as in surround QueryParser
+    return (new FieldsQuery(this, Arrays.asList(fieldNames), fieldOp)).makeLuceneQueryField(null, qf);
+  }
+
   /** This method is used by {@link #hashCode()} and {@link #equals(Object)},
    *  see LUCENE-2945.
    */
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTermQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTermQuery.java
index ffa8c78..be67bf0 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTermQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTermQuery.java
@@ -18,7 +18,6 @@ package org.apache.lucene.queryparser.surround.query;
 import java.io.IOException;
 
 import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.index.MultiFields;
@@ -29,20 +28,23 @@ import org.apache.lucene.util.BytesRef;
  * Simple single-term clause
  */
 public class SrndTermQuery extends SimpleTerm {
-  public SrndTermQuery(String termText, boolean quoted) {
+  public SrndTermQuery(String term, boolean quoted) {
     super(quoted);
-    this.termText = termText;
+    this.term = term;
+    this.termRef = new BytesRef(term);
   }
 
-  private final String termText;
-  public String getTermText() {return termText;}
+  private final String term;
+  private final BytesRef termRef;
 
-  public Term getLuceneTerm(String fieldName) {
-    return new Term(fieldName, getTermText());
+  private String getTermText() {
+    return term;
   }
 
   @Override
-  public String toStringUnquoted() {return getTermText();}
+  public String toStringUnquoted() {
+    return term;
+  }
 
   @Override
   public void visitMatchingTerms(
@@ -50,14 +52,12 @@ public class SrndTermQuery extends SimpleTerm {
     String fieldName,
     MatchingTermVisitor mtv) throws IOException
   {
-    /* check term presence in index here for symmetry with other SimpleTerm's */
     Terms terms = MultiFields.getTerms(reader, fieldName);
     if (terms != null) {
       TermsEnum termsEnum = terms.iterator();
-
-      TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(getTermText()));
+      TermsEnum.SeekStatus status = termsEnum.seekCeil(termRef);
       if (status == TermsEnum.SeekStatus.FOUND) {
-        mtv.visitMatchingTerm(getLuceneTerm(fieldName));
+        mtv.visitMatchingTerm(termRef);
       }
     }
   }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTruncQuery.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTruncQuery.java
index b987921..abeda1c 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTruncQuery.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/surround/query/SrndTruncQuery.java
@@ -15,7 +15,6 @@
  * limitations under the License.
  */
 package org.apache.lucene.queryparser.surround.query;
-import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermsEnum;
 import org.apache.lucene.index.Terms;
 import org.apache.lucene.util.BytesRef;
@@ -49,10 +48,14 @@ public class SrndTruncQuery extends SimpleTerm {
   private Pattern pattern;
   
   
-  public String getTruncated() {return truncated;}
+  public String getTruncated() {
+    return truncated;
+  }
   
   @Override
-  public String toStringUnquoted() {return getTruncated();}
+  public String toStringUnquoted() {
+    return truncated;
+  }
 
   
   protected boolean matchingChar(char c) {
@@ -107,15 +110,14 @@ public class SrndTruncQuery extends SimpleTerm {
           text = null;
         }
 
-        while(text != null) {
-          if (text != null && StringHelper.startsWith(text, prefixRef)) {
+        while(true) {
+          if ((text == null) || (! StringHelper.startsWith(text, prefixRef))) {
+            return;
+          }
           String textString = text.utf8ToString();
           matcher.reset(textString.substring(prefixLength));
           if (matcher.matches()) {
-              mtv.visitMatchingTerm(new Term(fieldName, textString));
-            }
-          } else {
-            break;
+            mtv.visitMatchingTerm(text);
           }
           text = termsEnum.next();
         }
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/BooleanQueryTst.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/BooleanQueryTst.java
deleted file mode 100644
index 77ce5d5..0000000
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/BooleanQueryTst.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.queryparser.surround.query;
-
-import java.io.IOException;
-
-import org.apache.lucene.index.LeafReaderContext;
-import org.apache.lucene.index.DirectoryReader;
-import org.apache.lucene.index.IndexReader;
-import org.apache.lucene.search.IndexSearcher;
-import org.apache.lucene.search.Scorer;
-import org.apache.lucene.search.Query;
-import org.apache.lucene.search.SimpleCollector;
-import org.apache.lucene.queryparser.surround.parser.QueryParser;
-import org.junit.Assert;
-
-public class BooleanQueryTst {
-  String queryText;
-  final int[] expectedDocNrs;
-  SingleFieldTestDb dBase;
-  String fieldName;
-  Assert testCase;
-  BasicQueryFactory qf;
-  boolean verbose = true;
-
-  public BooleanQueryTst(
-      String queryText,
-      int[] expectedDocNrs,
-      SingleFieldTestDb dBase,
-      String fieldName,
-      Assert testCase,
-      BasicQueryFactory qf) {
-    this.queryText = queryText;
-    this.expectedDocNrs = expectedDocNrs;
-    this.dBase = dBase;
-    this.fieldName = fieldName;
-    this.testCase = testCase;
-    this.qf = qf;
-  }
-  
-  public void setVerbose(boolean verbose) {this.verbose = verbose;}
-
-  class TestCollector extends SimpleCollector { // FIXME: use check hits from Lucene tests
-    int totalMatched;
-    boolean[] encountered;
-    private Scorer scorer = null;
-    private int docBase = 0;
-
-    TestCollector() {
-      totalMatched = 0;
-      encountered = new boolean[expectedDocNrs.length];
-    }
-
-    @Override
-    public void setScorer(Scorer scorer) throws IOException {
-      this.scorer = scorer;
-    }
-
-    @Override
-    protected void doSetNextReader(LeafReaderContext context) throws IOException {
-      docBase = context.docBase;
-    }
-    
-    @Override
-    public void collect(int docNr) throws IOException {
-      float score = scorer.score();
-      docNr += docBase;
-      /* System.out.println(docNr + " '" + dBase.getDocs()[docNr] + "': " + score); */
-      Assert.assertTrue(queryText + ": positive score", score > 0.0);
-      Assert.assertTrue(queryText + ": too many hits", totalMatched < expectedDocNrs.length);
-      int i;
-      for (i = 0; i < expectedDocNrs.length; i++) {
-        if ((! encountered[i]) && (expectedDocNrs[i] == docNr)) {
-          encountered[i] = true;
-          break;
-        }
-      }
-      if (i == expectedDocNrs.length) {
-        Assert.assertTrue(queryText + ": doc nr for hit not expected: " + docNr, false);
-      }
-      totalMatched++;
-    }
-    
-    @Override
-    public boolean needsScores() {
-      return true;
-    }
-
-    void checkNrHits() {
-      Assert.assertEquals(queryText + ": nr of hits", expectedDocNrs.length, totalMatched);
-    }
-  }
-
-  public void doTest() throws Exception {
-
-    if (verbose) {    
-        System.out.println("");
-        System.out.println("Query: " + queryText);
-    }
-    
-    SrndQuery lq = QueryParser.parse(queryText);
-    
-    /* if (verbose) System.out.println("Srnd: " + lq.toString()); */
-    
-    Query query = lq.makeLuceneQueryField(fieldName, qf);
-    /* if (verbose) System.out.println("Lucene: " + query.toString()); */
-
-    TestCollector tc = new TestCollector();
-    IndexReader reader = DirectoryReader.open(dBase.getDb());
-    IndexSearcher searcher = new IndexSearcher(reader);
-    try {
-      searcher.search(query, tc);
-    } finally {
-      reader.close();
-    }
-    tc.checkNrHits();
-  }
-}
-
-
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/ExceptionQueryTst.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/ExceptionQueryTst.java
deleted file mode 100644
index b54f68d..0000000
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/ExceptionQueryTst.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.queryparser.surround.query;
-
-import org.apache.lucene.queryparser.surround.parser.ParseException;
-import org.apache.lucene.queryparser.surround.parser.QueryParser;
-
-
-public class ExceptionQueryTst {
-  private String queryText;
-  private boolean verbose;
-  
-  public ExceptionQueryTst(String queryText, boolean verbose) {
-    this.queryText = queryText;
-    this.verbose = verbose;
-  }
-
-  public void doTest(StringBuilder failQueries) {
-    boolean pass = false;
-    SrndQuery lq = null;
-    try {
-      lq = QueryParser.parse(queryText);
-      if (verbose) {
-        System.out.println("Query: " + queryText + "\nParsed as: " + lq.toString());
-      }
-    } catch (ParseException e) {
-      if (verbose) {
-        System.out.println("Parse exception for query:\n"
-                            + queryText + "\n"
-                            + e.getMessage());
-      }
-      pass = true;
-    }
-    if (! pass) {
-      failQueries.append(queryText);
-      failQueries.append("\nParsed as: ");
-      failQueries.append(lq.toString());
-      failQueries.append("\n");
-    }
-  }
-  
-  public static String getFailQueries(String[] exceptionQueries, boolean verbose) {
-    StringBuilder failQueries = new StringBuilder();
-    for (int i = 0; i < exceptionQueries.length; i++ ) {
-      new ExceptionQueryTst( exceptionQueries[i], verbose).doTest(failQueries);
-    }
-    return failQueries.toString();
-  }
-}
-
-
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/MultiFieldTestDb.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/MultiFieldTestDb.java
new file mode 100644
index 0000000..ba45a7f
--- /dev/null
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/MultiFieldTestDb.java
@@ -0,0 +1,118 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.queryparser.surround.query;
+
+import java.io.IOException;
+import java.util.Random;
+
+import org.junit.Assert;
+
+import org.apache.lucene.document.Field;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.MockDirectoryWrapper;
+import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.TextField;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig;
+
+import org.apache.lucene.index.DirectoryReader;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.IndexSearcher;
+
+
+public class MultiFieldTestDb {
+  private Directory db;
+  private String[][] docsFields;
+  private String[] fieldNames;
+  private IndexReader reader;
+  private IndexSearcher searcher;
+
+  public MultiFieldTestDb(Random random, String[][] docsFields, String[] fieldNames) {
+    try {
+      db = new MockDirectoryWrapper(random, new RAMDirectory());
+      this.docsFields = docsFields;
+      this.fieldNames = fieldNames;
+
+      IndexWriter writer = new IndexWriter(db, new IndexWriterConfig(new MockAnalyzer(random)));
+      for (int docNr = 0; docNr < docsFields.length; docNr++) {
+        Assert.assertTrue(docsFields[docNr].length == fieldNames.length);
+
+        Document d = new Document();
+        for (int f = 0; f < fieldNames.length; f++) {
+          d.add(new TextField(fieldNames[f], docsFields[docNr][f], Field.Store.NO));
+        }
+        writer.addDocument(d);
+      }
+      writer.close();
+      reader = DirectoryReader.open(getDb());
+      searcher = new IndexSearcher(reader);
+    } catch (IOException ioe) {
+      throw new Error(ioe);
+    }
+  }
+
+  public void close() throws IOException {
+    reader.close();
+    db.close();
+    reader = null;
+    searcher = null;
+  }
+
+  static MultiFieldTestDb create(Random random, String[] docs, String fieldName) { // single field
+    String[][] docsFields = new String[docs.length][1];
+    for (int d = 0; d < docs.length; d++) {
+      docsFields[d][0] = docs[d];
+    }
+    String[] fieldNames = {fieldName};
+    return new MultiFieldTestDb(random, docsFields, fieldNames);
+  }
+
+
+  Directory getDb() {return db;}
+
+  IndexReader getReader() {
+    return reader;
+  }
+
+  IndexSearcher getSearcher() {
+    return searcher;
+  }
+
+  String[][] getDocsFields() {return docsFields;}
+
+  String showDoc(int d) {
+    StringBuilder s = new StringBuilder();
+    s.append("[");
+    for (int f = 0; f < docsFields[d].length; f++) {
+      if (f > 0) {
+        s.append(", ");
+      }
+      s.append(fieldNames[f]);
+      s.append(": \"");
+      s.append(docsFields[d][f]);
+      s.append("\"");
+    }
+    s.append("]");
+    return s.toString();
+  }
+
+  String[] getFieldnames() {return fieldNames;}
+}
+
+
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SingleFieldTestDb.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SingleFieldTestDb.java
deleted file mode 100644
index 30a5f92..0000000
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SingleFieldTestDb.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.lucene.queryparser.surround.query;
-
-import java.util.Random;
-
-import org.apache.lucene.document.Field;
-import org.apache.lucene.store.Directory;
-import org.apache.lucene.store.MockDirectoryWrapper;
-import org.apache.lucene.store.RAMDirectory;
-import org.apache.lucene.analysis.MockAnalyzer;
-import org.apache.lucene.document.Document;
-import org.apache.lucene.document.TextField;
-import org.apache.lucene.index.IndexWriter;
-import org.apache.lucene.index.IndexWriterConfig;
-
-public class SingleFieldTestDb {
-  private Directory db;
-  private String[] docs;
-  private String fieldName;
-  
-  public SingleFieldTestDb(Random random, String[] documents, String fName) {
-    try {
-      db = new MockDirectoryWrapper(random, new RAMDirectory());
-      docs = documents;
-      fieldName = fName;
-      IndexWriter writer = new IndexWriter(db, new IndexWriterConfig(new MockAnalyzer(random)));
-      for (int j = 0; j < docs.length; j++) {
-        Document d = new Document();
-        d.add(new TextField(fieldName, docs[j], Field.Store.NO));
-        writer.addDocument(d);
-      }
-      writer.close();
-    } catch (java.io.IOException ioe) {
-      throw new Error(ioe);
-    }
-  }
-  
-  Directory getDb() {return db;}
-  String[] getDocs() {return docs;}
-  String getFieldname() {return fieldName;}
-}
-
-
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SurroundTst.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SurroundTst.java
new file mode 100644
index 0000000..e554d27
--- /dev/null
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/SurroundTst.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.queryparser.surround.query;
+
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.spans.SpansTreeQuery;
+import org.apache.lucene.search.TopScoreDocCollector;
+import org.apache.lucene.search.ScoreDoc;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.CheckHits;
+
+import org.apache.lucene.queryparser.surround.parser.QueryParser;
+import org.apache.lucene.queryparser.surround.parser.ParseException;
+
+
+public class SurroundTst {
+
+  private static void nonExceptionTst(String queryText, StringBuilder nonExceptionQueries) {
+    boolean pass = false;
+    SrndQuery srndq = null;
+    try {
+      srndq = QueryParser.parse(queryText);
+      // no ParseException, report:
+      nonExceptionQueries.append(queryText);
+      nonExceptionQueries.append("\nParsed as: ");
+      nonExceptionQueries.append(srndq.toString());
+      nonExceptionQueries.append("\n");
+    } catch (ParseException e) {
+      //System.out.println("Parse exception for query:\n"
+      //                    + queryText + "\n"
+      //                    + e.getMessage());
+    }
+  }
+
+  public static String getNonExceptionQueries(String[] exceptionQueries) {
+    StringBuilder nonExceptionQueries = new StringBuilder();
+    for (int i = 0; i < exceptionQueries.length; i++ ) {
+      nonExceptionTst(exceptionQueries[i], nonExceptionQueries);
+    }
+    return nonExceptionQueries.toString();
+  }
+
+  static void showQueryResults(String message, Query q, ScoreDoc[] hits) {
+    System.out.println(message + " results from query " + q);
+    for (ScoreDoc hit : hits) {
+      System.out.println("doc=" + hit.doc + ", score=" + hit.score);
+    }
+  }
+
+  public static void doTest(
+                        String queryText,
+                        String[] fieldNames,
+                        BasicQueryFactory basicQueryFactory,
+                        IndexSearcher searcher,
+                        int[] expectedDocNrs)
+  throws Exception {
+    SrndQuery srndq = QueryParser.parse(queryText);
+    Query query = srndq.makeLuceneQueryFields(basicQueryFactory, fieldNames);
+    Query wrapped = SpansTreeQuery.wrapAfterRewrite(query);
+    TopScoreDocCollector collector = TopScoreDocCollector.create(expectedDocNrs.length + 1);
+    searcher.search(wrapped, collector);
+    ScoreDoc[] scoreDocs = collector.topDocs().scoreDocs;
+    //showQueryResults(queryText, query, scoreDocs);
+    CheckHits.checkDocIds(queryText, expectedDocNrs, scoreDocs);
+  }
+}
+
+
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test01Exceptions.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test01Exceptions.java
index f61ebd2..c4c2ed9 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test01Exceptions.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test01Exceptions.java
@@ -16,18 +16,9 @@
  */
 package org.apache.lucene.queryparser.surround.query;
 
-import junit.framework.TestSuite;
-import junit.textui.TestRunner;
-
 import org.apache.lucene.util.LuceneTestCase;
 
 public class Test01Exceptions extends LuceneTestCase {
-  /** Main for running test case by itself. */
-  public static void main(String args[]) {
-    TestRunner.run(new TestSuite(Test01Exceptions.class));
-  }
-
-  boolean verbose = false; /* to show actual parsing error messages */
   final String fieldName = "bi";
 
   String[] exceptionQueries = {
@@ -58,7 +49,7 @@ public class Test01Exceptions extends LuceneTestCase {
   };
 
   public void test01Exceptions() throws Exception {
-    String m = ExceptionQueryTst.getFailQueries(exceptionQueries, verbose);
+    String m = SurroundTst.getNonExceptionQueries(exceptionQueries);
     if (m.length() > 0) {
       fail("No ParseException for:\n" + m);
     }
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test02Boolean.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test02Boolean.java
index 298dbdc..57c572f 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test02Boolean.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test02Boolean.java
@@ -16,21 +16,19 @@
  */
 package org.apache.lucene.queryparser.surround.query;
 
-import junit.framework.TestSuite;
-import junit.textui.TestRunner;
+import org.junit.BeforeClass;
+import org.junit.AfterClass;
+import org.junit.Assert;
 
 import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.search.BooleanQuery;
 
 public class Test02Boolean extends LuceneTestCase {
-  public static void main(String args[]) {
-    TestRunner.run(new TestSuite(Test02Boolean.class));
-  }
 
-  final String fieldName = "bi";
-  boolean verbose = false;
+  static final String fieldName = "bi";
   int maxBasicQueries = 16;
 
-  String[] docs1 = {
+  static String[] docs1 = {
     "word1 word2 word3",
     "word4 word5",
     "ord1 ord2 ord3",
@@ -38,19 +36,22 @@ public class Test02Boolean extends LuceneTestCase {
     "a c e a b c"
   };
 
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    db1 = new SingleFieldTestDb(random(), docs1, fieldName);
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    db1 = MultiFieldTestDb.create(random(), docs1, fieldName);
+  }
+
+  @AfterClass
+  public static void afterClass() throws Exception {
+    db1.close();
   }
 
-  SingleFieldTestDb db1;
+  static MultiFieldTestDb db1;
 
   public void normalTest1(String query, int[] expdnrs) throws Exception {
-    BooleanQueryTst bqt = new BooleanQueryTst( query, expdnrs, db1, fieldName, this,
-                                                new BasicQueryFactory(maxBasicQueries));
-    bqt.setVerbose(verbose);
-    bqt.doTest();
+    String[] fieldNames = {fieldName};
+    SurroundTst.doTest( query, fieldNames, new BasicQueryFactory(maxBasicQueries),
+                        db1.getSearcher(), expdnrs);
   }
 
   public void test02Terms01() throws Exception {
@@ -103,11 +104,14 @@ public class Test02Boolean extends LuceneTestCase {
   public void test03And03() throws Exception {
     int[] expdnrs = {0}; normalTest1( "and(word1,word2)", expdnrs);
   }
+  public void test03And04() throws Exception {
+    int[] expdnrs = {}; normalTest1( "and(word1,ord1a)", expdnrs);
+  }
   public void test04Or01() throws Exception {
     int[] expdnrs = {0, 3}; normalTest1( "word1 or word2", expdnrs);
   }
   public void test04Or02() throws Exception {
-    int[] expdnrs = {0, 1, 2, 3}; normalTest1( "word* OR ord*", expdnrs);
+    int[] expdnrs = {3, 2, 0, 1}; normalTest1( "word* OR ord*", expdnrs);
   }
   public void test04Or03() throws Exception {
     int[] expdnrs = {0, 3}; normalTest1( "OR (word1, word2)", expdnrs);
@@ -124,4 +128,32 @@ public class Test02Boolean extends LuceneTestCase {
   public void test07AndOrNot02() throws Exception {
     int[] expdnrs = {0}; normalTest1( "or( word2* not ord*, and(xyz,def))", expdnrs);
   }
+
+  public void testMaxBasicQueries1() throws Exception {
+    int mcc = BooleanQuery.getMaxClauseCount();
+    try {
+      int maxBasicQueries = 2;
+      // BooleanQuery recursively rewrites, so allow BooleanQuery just what it needs here,
+      // and let BasicQueryFactory throw an exception during rewrite:
+      BooleanQuery.setMaxClauseCount(3);
+      String query = "word1 or word2 or word3";
+      int[] expdnrs = {0, 3};
+      String[] fieldNames = {fieldName};
+      boolean tmbExceptionThrown;
+      try {
+        SurroundTst.doTest( query, fieldNames, new BasicQueryFactory(maxBasicQueries),
+                            db1.getSearcher(), expdnrs);
+        tmbExceptionThrown = false;
+      }
+      catch (TooManyBasicQueries tmb) {
+        tmbExceptionThrown = true;
+      }
+      if (! tmbExceptionThrown) {
+        Assert.fail("Expected TooManyBasicQueries exception");
+      }
+    }
+    finally {
+      BooleanQuery.setMaxClauseCount(mcc);
+    }
+  }
 }
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test03Distance.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test03Distance.java
index 9dca811..f1ce20d 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test03Distance.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test03Distance.java
@@ -16,17 +16,13 @@
  */
 package org.apache.lucene.queryparser.surround.query;
 
-import junit.framework.TestSuite;
-import junit.textui.TestRunner;
+import org.junit.BeforeClass;
+import org.junit.AfterClass;
 
 import org.apache.lucene.util.LuceneTestCase;
 
 public class Test03Distance extends LuceneTestCase {
-  public static void main(String args[]) {
-    TestRunner.run(new TestSuite(Test03Distance.class));
-  }
 
-  boolean verbose = false;
   int maxBasicQueries = 16;
 
   String [] exceptionQueries = {
@@ -42,15 +38,15 @@ public class Test03Distance extends LuceneTestCase {
   };
 
   public void test00Exceptions() throws Exception {
-    String m = ExceptionQueryTst.getFailQueries(exceptionQueries, verbose);
+    String m = SurroundTst.getNonExceptionQueries(exceptionQueries);
     if (m.length() > 0) {
       fail("No ParseException for:\n" + m);
     }
   }
 
-  final String fieldName = "bi";
+  static final String fieldName = "bi";
 
-  String[] docs1 = {
+  static String[] docs1 = {
     "word1 word2 word3",
     "word4 word5",
     "ord1 ord2 ord3",
@@ -58,21 +54,27 @@ public class Test03Distance extends LuceneTestCase {
     "a c e a b c"
   };
 
-  SingleFieldTestDb db1;
+  static MultiFieldTestDb db1;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    db1 = MultiFieldTestDb.create(random(), docs1, fieldName);
+    db2 = MultiFieldTestDb.create(random(), docs2, fieldName);
+    db3 = MultiFieldTestDb.create(random(), docs3, fieldName);
+  }
 
-  @Override
-  public void setUp() throws Exception {
-    super.setUp();
-    db1 = new SingleFieldTestDb(random(), docs1, fieldName);
-    db2 = new SingleFieldTestDb(random(), docs2, fieldName);
-    db3 = new SingleFieldTestDb(random(), docs3, fieldName);
+  @AfterClass
+  public static void afterClass() throws Exception {
+    db1.close();
+    db2.close();
+    db3.close();
   }
 
-  private void distanceTst(String query, int[] expdnrs, SingleFieldTestDb db) throws Exception {
-    BooleanQueryTst bqt = new BooleanQueryTst( query, expdnrs, db, fieldName, this,
-                                                new BasicQueryFactory(maxBasicQueries));
-    bqt.setVerbose(verbose);
-    bqt.doTest();
+
+  private void distanceTst(String query, int[] expdnrs, MultiFieldTestDb db) throws Exception {
+    String[] fieldNames = {fieldName};
+    SurroundTst.doTest( query, fieldNames, new BasicQueryFactory(maxBasicQueries),
+                        db.getSearcher(), expdnrs);
   }
 
   public void distanceTest1(String query, int[] expdnrs) throws Exception {
@@ -181,13 +183,13 @@ public class Test03Distance extends LuceneTestCase {
     int[] expdnrs = {3}; distanceTest1( "(orda2 OR orda3) 2N (word2 OR worda3)", expdnrs);
   }
 
-  String[] docs2 = {
+  static String[] docs2 = {
     "w1 w2 w3 w4 w5",
     "w1 w3 w2 w3",
     ""
   };
 
-  SingleFieldTestDb db2;
+  static MultiFieldTestDb db2;
 
   public void distanceTest2(String query, int[] expdnrs) throws Exception {
     distanceTst(query, expdnrs, db2);
@@ -197,10 +199,10 @@ public class Test03Distance extends LuceneTestCase {
     int[] expdnrs = {0}; distanceTest2( "W (w1, w2, w3)", expdnrs);
   }
   public void test2Nprefix01a() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "N(w1, w2, w3)", expdnrs);
+    int[] expdnrs = {1,0}; distanceTest2( "N(w1, w2, w3)", expdnrs);
   }
   public void test2Nprefix01b() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "N(w3, w1, w2)", expdnrs);
+    int[] expdnrs = {1,0}; distanceTest2( "N(w3, w1, w2)", expdnrs);
   }
 
   public void test2Wprefix02() throws Exception {
@@ -208,10 +210,10 @@ public class Test03Distance extends LuceneTestCase {
   }
 
   public void test2Nprefix02a() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "2N(w1,w2,w3)", expdnrs);
+    int[] expdnrs = {1,0}; distanceTest2( "2N(w1,w2,w3)", expdnrs);
   }
   public void test2Nprefix02b() throws Exception {
-    int[] expdnrs = {0,1}; distanceTest2( "2N(w2,w3,w1)", expdnrs);
+    int[] expdnrs = {1,0}; distanceTest2( "2N(w2,w3,w1)", expdnrs);
   }
 
   public void test2Wnested01() throws Exception {
@@ -228,14 +230,14 @@ public class Test03Distance extends LuceneTestCase {
     int[] expdnrs = {0,1}; distanceTest2( "w1 2N w2 2N w3", expdnrs);
   }
 
-  String[] docs3 = {
+  static String[] docs3 = {
     "low pressure temperature inversion and rain",
     "when the temperature has a negative height above a depression no precipitation gradient is expected",
     "when the temperature has a negative height gradient above a depression no precipitation is expected",
     ""
   };
 
-  SingleFieldTestDb db3;
+  static MultiFieldTestDb db3;
 
   public void distanceTest3(String query, int[] expdnrs) throws Exception {
     distanceTst(query, expdnrs, db3);
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test04Fields.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test04Fields.java
new file mode 100644
index 0000000..240ec75
--- /dev/null
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/surround/query/Test04Fields.java
@@ -0,0 +1,78 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.queryparser.surround.query;
+
+import org.junit.BeforeClass;
+import org.junit.AfterClass;
+
+import org.apache.lucene.util.LuceneTestCase;
+
+public class Test04Fields extends LuceneTestCase {
+
+  int maxBasicQueries = 16;
+
+  String [] exceptionQueries = {
+    "bi1:bi2:",
+    "bi1:bi2:()",
+    "(bi1:bi2:())",
+  };
+
+  public void test00Exceptions() throws Exception {
+    String m = SurroundTst.getNonExceptionQueries(exceptionQueries);
+    if (m.length() > 0) {
+      fail("No ParseException for:\n" + m);
+    }
+  }
+
+  static final String[] fieldNames = {"bi1", "bi2"};
+
+  static String[][] docsFields1 = {
+    {"word1 word2 word3", "word1 word2 word3 word4"},
+    {"word1 word5 word6", "word4 word5 word6"},
+    {"ord1 ord2 ord3", "word1 ord2 ord3 ord4"},
+    {"orda1 orda2 orda3 word2 worda3", "orda1 orda2 orda3 word2 worda3 worda4"},
+    {"a c e a b c", "a c e a b c f"}
+  };
+
+  static MultiFieldTestDb mfdb1;
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    mfdb1 = new MultiFieldTestDb(random(), docsFields1, fieldNames);
+  }
+
+  @AfterClass
+  public static void afterClass() throws Exception {
+    mfdb1.close();
+  }
+
+  private void disMaxTst(String query, int[] expdnrs, MultiFieldTestDb db) throws Exception {
+    SurroundTst.doTest( query, fieldNames, new BasicQueryFactory(maxBasicQueries),
+                        db.getSearcher(), expdnrs);
+  }
+
+  public void testTruncSingleTerm() throws Exception {
+    int[] expdnrs = {0,2,1};
+    disMaxTst("word1*", expdnrs, mfdb1);
+  }
+
+  public void testDistanceQuery() throws Exception {
+    int[] expdnrs = {2,1,0};
+    disMaxTst("word1* w (word2 or word5 or ord2)", expdnrs, mfdb1);
+  }
+
+}
