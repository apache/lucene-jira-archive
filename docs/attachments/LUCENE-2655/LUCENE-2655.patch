Index: lucene/src/test/org/apache/lucene/index/TestSeqDeletes.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestSeqDeletes.java	(revision 0)
+++ lucene/src/test/org/apache/lucene/index/TestSeqDeletes.java	(revision 0)
@@ -0,0 +1,73 @@
+package org.apache.lucene.index;
+
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.search.DocIdSetIterator;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.MockRAMDirectory;
+import org.apache.lucene.util.English;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestSeqDeletes extends LuceneTestCase {
+  public void test() throws Exception {
+    IndexWriterConfig conf = new IndexWriterConfig(TEST_VERSION_CURRENT,
+        new MockAnalyzer());
+    Directory directory = new MockRAMDirectory();
+    IndexWriter writer = new IndexWriter(directory, conf);
+    for (int i = 0; i < 100; i++) {
+      Document d = new Document();
+      d.add(new Field("id", Integer.toString(i), Field.Store.YES,
+          Field.Index.NOT_ANALYZED));
+      d.add(new Field("contents", English.intToEnglish(i), Field.Store.NO,
+          Field.Index.ANALYZED));
+      writer.addDocument(d);
+    }
+    Term delTerm = new Term("id", "6");
+    IndexReader reader = writer.getReader();
+    List<Integer> tds = getDocs(delTerm, reader);
+    assertEquals(1, tds.size());
+    reader.close();
+    writer.deleteDocuments(delTerm);
+    reader = writer.getReader();
+    
+    tds = getDocs(delTerm, reader);
+    assertEquals(0, tds.size());
+    //System.out.println("tds:"+tds);
+    reader.close();
+    writer.close();
+    directory.close();
+  }
+  
+  public static List<Integer> getDocs(Term term, IndexReader reader) throws IOException {
+    DocsEnum termDocs = MultiFields.getTermDocsEnum(reader, null, term.field, term.bytes());
+    int doc = -1;
+    List<Integer> docs = new ArrayList<Integer>();
+    while ( (doc = termDocs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
+      //System.out.println("doc:"+doc);
+      docs.add(doc);
+    }
+    return docs;
+  }
+}
Index: lucene/src/java/org/apache/lucene/index/BufferedDeletesInRAM.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/BufferedDeletesInRAM.java	(revision 998763)
+++ lucene/src/java/org/apache/lucene/index/BufferedDeletesInRAM.java	(working copy)
@@ -21,6 +21,10 @@
       super(flushCount);
       this.term = term;
     }
+    
+    public String toString() {
+      return "deleteterm "+term+" flushCount:"+flushCount;
+    }
   }
 
   final static class DeleteTerms extends Delete {
