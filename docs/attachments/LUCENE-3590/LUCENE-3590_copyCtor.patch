Index: solr/core/src/java/org/apache/solr/schema/BoolField.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/BoolField.java	(revision 1205841)
+++ solr/core/src/java/org/apache/solr/schema/BoolField.java	(working copy)
@@ -142,9 +142,9 @@
   @Override
   public CharsRef indexedToReadable(BytesRef input, CharsRef charsRef) {
     if (input.length > 0 && input.bytes[input.offset] == 'T') {
-      charsRef.copy(TRUE);
+      charsRef.copyChars(TRUE);
     } else {
-      charsRef.copy(FALSE);
+      charsRef.copyChars(FALSE);
     }
     return charsRef;
   }
Index: solr/core/src/java/org/apache/solr/schema/SortableDoubleField.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/SortableDoubleField.java	(revision 1205841)
+++ solr/core/src/java/org/apache/solr/schema/SortableDoubleField.java	(working copy)
@@ -81,7 +81,7 @@
     // TODO: this could be more efficient, but the sortable types should be deprecated instead
     input.utf8ToChars(charsRef);
     final char[] indexedToReadable = indexedToReadable(charsRef.toString()).toCharArray();
-    charsRef.copy(indexedToReadable, 0, indexedToReadable.length);
+    charsRef.copyChars(indexedToReadable, 0, indexedToReadable.length);
     return charsRef;
   }
 
Index: solr/core/src/java/org/apache/solr/schema/SortableLongField.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/SortableLongField.java	(revision 1205841)
+++ solr/core/src/java/org/apache/solr/schema/SortableLongField.java	(working copy)
@@ -69,7 +69,7 @@
   public CharsRef indexedToReadable(BytesRef input, CharsRef charsRef) {
     // TODO: this could be more efficient, but the sortable types should be deprecated instead
     final char[] indexedToReadable = indexedToReadable(input.utf8ToChars(charsRef).toString()).toCharArray();
-    charsRef.copy(indexedToReadable, 0, indexedToReadable.length);
+    charsRef.copyChars(indexedToReadable, 0, indexedToReadable.length);
     return charsRef;
   }
 
Index: solr/core/src/java/org/apache/solr/schema/SortableFloatField.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/SortableFloatField.java	(revision 1205841)
+++ solr/core/src/java/org/apache/solr/schema/SortableFloatField.java	(working copy)
@@ -79,7 +79,7 @@
   public CharsRef indexedToReadable(BytesRef input, CharsRef charsRef) {
     // TODO: this could be more efficient, but the sortable types should be deprecated instead
     final char[] indexedToReadable = indexedToReadable(input.utf8ToChars(charsRef).toString()).toCharArray();
-    charsRef.copy(indexedToReadable, 0, indexedToReadable.length);
+    charsRef.copyChars(indexedToReadable, 0, indexedToReadable.length);
     return charsRef;
   }
 
Index: solr/core/src/java/org/apache/solr/schema/CollationField.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/CollationField.java	(revision 1205841)
+++ solr/core/src/java/org/apache/solr/schema/CollationField.java	(working copy)
@@ -240,7 +240,7 @@
       throw new RuntimeException("Unable to end & close TokenStream after analyzing range part: " + part, e);
     }
       
-    return new BytesRef(bytes);
+    return BytesRef.deepCopyOf(bytes);
   }
   
   @Override
Index: solr/core/src/java/org/apache/solr/schema/SortableIntField.java
===================================================================
--- solr/core/src/java/org/apache/solr/schema/SortableIntField.java	(revision 1205841)
+++ solr/core/src/java/org/apache/solr/schema/SortableIntField.java	(working copy)
@@ -77,7 +77,7 @@
   public CharsRef indexedToReadable(BytesRef input, CharsRef charsRef) {
     // TODO: this could be more efficient, but the sortable types should be deprecated instead
     final char[] indexedToReadable = indexedToReadable(input.utf8ToChars(charsRef).toString()).toCharArray();
-    charsRef.copy(indexedToReadable, 0, indexedToReadable.length);
+    charsRef.copyChars(indexedToReadable, 0, indexedToReadable.length);
     return charsRef;
   }
 
Index: solr/core/src/java/org/apache/solr/search/TermQParserPlugin.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/TermQParserPlugin.java	(revision 1205883)
+++ solr/core/src/java/org/apache/solr/search/TermQParserPlugin.java	(working copy)
@@ -59,7 +59,7 @@
         if (ft != null) {
           ft.readableToIndexed(val, term);
         } else {
-          term.copy(val);
+          term.copyChars(val);
         }
         return new TermQuery(new Term(fname, term));
       }
Index: solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java
===================================================================
--- solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java	(revision 1205841)
+++ solr/core/src/java/org/apache/solr/search/SolrIndexSearcher.java	(working copy)
@@ -846,7 +846,7 @@
     TermQuery key = null;
 
     if (useCache) {
-      key = new TermQuery(new Term(deState.fieldName, new BytesRef(deState.termsEnum.term())));
+      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));
       DocSet result = filterCache.get(key);
       if (result != null) return result;
     }
Index: solr/core/src/java/org/apache/solr/request/SimpleFacets.java
===================================================================
--- solr/core/src/java/org/apache/solr/request/SimpleFacets.java	(revision 1205841)
+++ solr/core/src/java/org/apache/solr/request/SimpleFacets.java	(working copy)
@@ -729,7 +729,7 @@
 
           if (sortByCount) {
             if (c>min) {
-              BytesRef termCopy = new BytesRef(term);
+              BytesRef termCopy = BytesRef.deepCopyOf(term);
               queue.add(new CountPair<BytesRef,Integer>(termCopy, c));
               if (queue.size()>=maxsize) min=queue.last().val;
             }
Index: solr/core/src/java/org/apache/solr/request/UnInvertedField.java
===================================================================
--- solr/core/src/java/org/apache/solr/request/UnInvertedField.java	(revision 1205841)
+++ solr/core/src/java/org/apache/solr/request/UnInvertedField.java	(working copy)
@@ -118,7 +118,7 @@
 
     if (te.docFreq() > maxTermDocFreq) {
       TopTerm topTerm = new TopTerm();
-      topTerm.term = new BytesRef(term);
+      topTerm.term = BytesRef.deepCopyOf(term);
       topTerm.termNum = termNum;
       bigTerms.put(topTerm.termNum, topTerm);
 
Index: solr/core/src/java/org/apache/solr/handler/component/TermsComponent.java
===================================================================
--- solr/core/src/java/org/apache/solr/handler/component/TermsComponent.java	(revision 1205841)
+++ solr/core/src/java/org/apache/solr/handler/component/TermsComponent.java	(working copy)
@@ -207,7 +207,7 @@
         if (docFreq >= freqmin && docFreq <= freqmax) {
           // add the term to the list
           if (sort) {
-            queue.add(new CountPair<BytesRef, Integer>(new BytesRef(term), docFreq));
+            queue.add(new CountPair<BytesRef, Integer>(BytesRef.deepCopyOf(term), docFreq));
           } else {
 
             // TODO: handle raw somehow
Index: solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase.java
===================================================================
--- solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase.java	(revision 1205841)
+++ solr/core/src/java/org/apache/solr/handler/AnalysisRequestHandlerBase.java	(working copy)
@@ -150,7 +150,7 @@
 
       while (tokenStream.incrementToken()) {
         bytesAtt.fillBytesRef();
-        tokens.add(new BytesRef(bytes));
+        tokens.add(BytesRef.deepCopyOf(bytes));
       }
 
       tokenStream.end();
Index: solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java
===================================================================
--- solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java	(revision 1205841)
+++ solr/contrib/analysis-extras/src/java/org/apache/solr/schema/ICUCollationField.java	(working copy)
@@ -218,7 +218,7 @@
       throw new RuntimeException("Unable to end & close TokenStream after analyzing range part: " + part, e);
     }
       
-    return new BytesRef(bytes);
+    return BytesRef.deepCopyOf(bytes);
   }
   
   @Override
Index: modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker.java
===================================================================
--- modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker.java	(revision 1205841)
+++ modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker.java	(working copy)
@@ -436,7 +436,7 @@
         continue;
       
       // add new entry in PQ
-      st.term = new BytesRef(candidateTerm);
+      st.term = BytesRef.deepCopyOf(candidateTerm);
       st.boost = boost;
       st.docfreq = df;
       st.termAsString = termAsString;
Index: modules/suggest/src/java/org/apache/lucene/search/spell/SpellChecker.java
===================================================================
--- modules/suggest/src/java/org/apache/lucene/search/spell/SpellChecker.java	(revision 1205883)
+++ modules/suggest/src/java/org/apache/lucene/search/spell/SpellChecker.java	(working copy)
@@ -521,7 +521,7 @@
   
           if (!isEmpty) {
             // we have a non-empty index, check if the term exists
-            currentTerm.copy(word);
+            currentTerm.copyChars(word);
             for (TermsEnum te : termsEnums) {
               if (te.seekExact(currentTerm, false)) {
                 continue terms;
Index: modules/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/TermsFilterBuilder.java
===================================================================
--- modules/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/TermsFilterBuilder.java	(revision 1205841)
+++ modules/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/TermsFilterBuilder.java	(working copy)
@@ -64,7 +64,7 @@
       ts.reset();
       while (ts.incrementToken()) {
         termAtt.fillBytesRef();
-        term = new Term(fieldName, new BytesRef(bytes));
+        term = new Term(fieldName, BytesRef.deepCopyOf(bytes));
         tf.addTerm(term);
       }
       ts.end();
Index: modules/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanOrTermsBuilder.java
===================================================================
--- modules/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanOrTermsBuilder.java	(revision 1205841)
+++ modules/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/SpanOrTermsBuilder.java	(working copy)
@@ -59,7 +59,7 @@
       ts.reset();
       while (ts.incrementToken()) {
         termAtt.fillBytesRef();
-        SpanTermQuery stq = new SpanTermQuery(new Term(fieldName, new BytesRef(bytes)));
+        SpanTermQuery stq = new SpanTermQuery(new Term(fieldName, BytesRef.deepCopyOf(bytes)));
         clausesList.add(stq);
       }
       ts.end();
Index: modules/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/TermsQueryBuilder.java
===================================================================
--- modules/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/TermsQueryBuilder.java	(revision 1205841)
+++ modules/queryparser/src/java/org/apache/lucene/queryparser/xml/builders/TermsQueryBuilder.java	(working copy)
@@ -59,7 +59,7 @@
       ts.reset();
       while (ts.incrementToken()) {
         termAtt.fillBytesRef();
-        term = new Term(fieldName, new BytesRef(bytes));
+        term = new Term(fieldName, BytesRef.deepCopyOf(bytes));
         bq.add(new BooleanClause(new TermQuery(term), BooleanClause.Occur.SHOULD));
       }
       ts.end();
Index: modules/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
===================================================================
--- modules/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java	(revision 1205841)
+++ modules/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java	(working copy)
@@ -540,7 +540,7 @@
       } catch (IOException e) {
         // safe to ignore, because we know the number of tokens
       }
-      return newTermQuery(new Term(field, new BytesRef(bytes)));
+      return newTermQuery(new Term(field, BytesRef.deepCopyOf(bytes)));
     } else {
       if (severalTokensAtSamePosition || (!quoted && !autoGeneratePhraseQueries)) {
         if (positionCount == 1 || (!quoted && !autoGeneratePhraseQueries)) {
@@ -559,7 +559,7 @@
               // safe to ignore, because we know the number of tokens
             }
             Query currentQuery = newTermQuery(
-                new Term(field, new BytesRef(bytes)));
+                new Term(field, BytesRef.deepCopyOf(bytes)));
             q.add(currentQuery, occur);
           }
           return q;
@@ -592,7 +592,7 @@
               multiTerms.clear();
             }
             position += positionIncrement;
-            multiTerms.add(new Term(field, new BytesRef(bytes)));
+            multiTerms.add(new Term(field, BytesRef.deepCopyOf(bytes)));
           }
           if (enablePositionIncrements) {
             mpq.add(multiTerms.toArray(new Term[0]),position);
@@ -623,9 +623,9 @@
 
           if (enablePositionIncrements) {
             position += positionIncrement;
-            pq.add(new Term(field, new BytesRef(bytes)),position);
+            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)),position);
           } else {
-            pq.add(new Term(field, new BytesRef(bytes)));
+            pq.add(new Term(field, BytesRef.deepCopyOf(bytes)));
           }
         }
         return pq;
@@ -808,7 +808,7 @@
       throw new RuntimeException("Unable to end & close TokenStream after analyzing range part: " + part, e);
     }
     
-    return new BytesRef(bytes);
+    return BytesRef.deepCopyOf(bytes);
   }
 
   /**
Index: modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter.java
===================================================================
--- modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter.java	(revision 1205841)
+++ modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter.java	(working copy)
@@ -185,7 +185,7 @@
       if (outputs[count] == null) {
         outputs[count] = new CharsRef();
       }
-      outputs[count].copy(output, offset, len);
+      outputs[count].copyChars(output, offset, len);
       count++;
     }
   };
@@ -253,7 +253,7 @@
 
     input.state = captureState();
     input.consumed = false;
-    input.term.copy(termAtt.buffer(), 0, termAtt.length());
+    input.term.copyChars(termAtt.buffer(), 0, termAtt.length());
 
     nextWrite = rollIncr(nextWrite);
 
Index: modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymMap.java
===================================================================
--- modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymMap.java	(revision 1205841)
+++ modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymMap.java	(working copy)
@@ -201,7 +201,7 @@
       MapEntry e = workingSet.get(input);
       if (e == null) {
         e = new MapEntry();
-        workingSet.put(new CharsRef(input), e); // make a copy, since we will keep around in our map    
+        workingSet.put(CharsRef.deepCopyOf(input), e); // make a copy, since we will keep around in our map    
       }
       
       e.ords.add(ord);
@@ -307,7 +307,7 @@
         
         scratch.length = scratchOutput.getPosition() - scratch.offset;
         //System.out.println("  add input=" + input + " output=" + scratch + " offset=" + scratch.offset + " length=" + scratch.length + " count=" + count);
-        builder.add(input, new BytesRef(scratch));
+        builder.add(input, BytesRef.deepCopyOf(scratch));
       }
       
       FST<BytesRef> fst = builder.finish();
Index: modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermFirstPassGroupingCollector.java
===================================================================
--- modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermFirstPassGroupingCollector.java	(revision 1205883)
+++ modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermFirstPassGroupingCollector.java	(working copy)
@@ -71,10 +71,10 @@
     if (groupValue == null) {
       return null;
     } else if (reuse != null) {
-      reuse.copy(groupValue);
+      reuse.copyBytes(groupValue);
       return reuse;
     } else {
-      return new BytesRef(groupValue);
+      return BytesRef.deepCopyOf(groupValue);
     }
   }
 
Index: modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermAllGroupHeadsCollector.java
===================================================================
--- modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermAllGroupHeadsCollector.java	(revision 1205841)
+++ modules/grouping/src/java/org/apache/lucene/search/grouping/term/TermAllGroupHeadsCollector.java	(working copy)
@@ -130,7 +130,7 @@
       GroupHead groupHead = groups.get(groupValue);
       if (groupHead == null) {
         groupHead = new GroupHead(groupValue, sortWithinGroup, doc);
-        groups.put(groupValue == null ? null : new BytesRef(groupValue), groupHead);
+        groups.put(groupValue == null ? null : BytesRef.deepCopyOf(groupValue), groupHead);
         temporalResult.stop = true;
       } else {
         temporalResult.stop = false;
Index: modules/queries/src/java/org/apache/lucene/queries/TermsFilter.java
===================================================================
--- modules/queries/src/java/org/apache/lucene/queries/TermsFilter.java	(revision 1205883)
+++ modules/queries/src/java/org/apache/lucene/queries/TermsFilter.java	(working copy)
@@ -79,7 +79,7 @@
       }
 
       if (terms != null) { // TODO this check doesn't make sense, decide which variable its supposed to be for
-        br.copy(term.bytes());
+        br.copyBytes(term.bytes());
         if (termsEnum.seekCeil(br) == TermsEnum.SeekStatus.FOUND) {
           docs = termsEnum.docs(acceptDocs, docs);
           while (docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {
Index: modules/queries/src/java/org/apache/lucene/queries/function/DocValues.java
===================================================================
--- modules/queries/src/java/org/apache/lucene/queries/function/DocValues.java	(revision 1205883)
+++ modules/queries/src/java/org/apache/lucene/queries/function/DocValues.java	(working copy)
@@ -59,7 +59,7 @@
       target.length = 0;
       return false;
     }
-    target.copy(s);
+    target.copyChars(s);
     return true;
   };
 
Index: modules/queries/src/java/org/apache/lucene/queries/function/valuesource/LiteralValueSource.java
===================================================================
--- modules/queries/src/java/org/apache/lucene/queries/function/valuesource/LiteralValueSource.java	(revision 1205883)
+++ modules/queries/src/java/org/apache/lucene/queries/function/valuesource/LiteralValueSource.java	(working copy)
@@ -55,7 +55,7 @@
 
       @Override
       public boolean bytesVal(int doc, BytesRef target) {
-        target.copy(bytesRef);
+        target.copyBytes(bytesRef);
         return true;
       }
 
Index: lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java
===================================================================
--- lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java	(revision 1205883)
+++ lucene/contrib/memory/src/java/org/apache/lucene/index/memory/MemoryIndex.java	(working copy)
@@ -366,7 +366,7 @@
         ArrayIntList positions = terms.get(ref);
         if (positions == null) { // term not seen before
           positions = new ArrayIntList(stride);
-          terms.put(new BytesRef(ref), positions);
+          terms.put(BytesRef.deepCopyOf(ref), positions);
         }
         if (stride == 1) {
           positions.add(pos);
@@ -874,7 +874,7 @@
       public boolean seekExact(BytesRef text, boolean useCache) {
         termUpto = Arrays.binarySearch(info.sortedTerms, text, termComparator);
         if (termUpto >= 0) {
-          br.copy(info.sortedTerms[termUpto].getKey());
+          br.copyBytes(info.sortedTerms[termUpto].getKey());
           return true;
         } else {
           return false;
@@ -889,11 +889,11 @@
           if (termUpto >= info.sortedTerms.length) {
             return SeekStatus.END;
           } else {
-            br.copy(info.sortedTerms[termUpto].getKey());
+            br.copyBytes(info.sortedTerms[termUpto].getKey());
             return SeekStatus.NOT_FOUND;
           }
         } else {
-          br.copy(info.sortedTerms[termUpto].getKey());
+          br.copyBytes(info.sortedTerms[termUpto].getKey());
           return SeekStatus.FOUND;
         }
       }
@@ -910,7 +910,7 @@
         if (termUpto >= info.sortedTerms.length) {
           return null;
         } else {
-          br.copy(info.sortedTerms[termUpto].getKey());
+          br.copyBytes(info.sortedTerms[termUpto].getKey());
           return br;
         }
       }
Index: lucene/contrib/misc/src/java/org/apache/lucene/misc/TermStats.java
===================================================================
--- lucene/contrib/misc/src/java/org/apache/lucene/misc/TermStats.java	(revision 1205841)
+++ lucene/contrib/misc/src/java/org/apache/lucene/misc/TermStats.java	(working copy)
@@ -26,13 +26,13 @@
   public long totalTermFreq;
   
   TermStats(String field, BytesRef termtext, int df) {
-    this.termtext = new BytesRef(termtext);
+    this.termtext = BytesRef.deepCopyOf(termtext);
     this.field = field;
     this.docFreq = df;
   }
   
   TermStats(String field, BytesRef termtext, int df, long tf) {
-    this.termtext = new BytesRef(termtext);
+    this.termtext = BytesRef.deepCopyOf(termtext);
     this.field = field;
     this.docFreq = df;
     this.totalTermFreq = tf;
Index: lucene/contrib/highlighter/src/test/org/apache/lucene/search/vectorhighlight/AbstractTestCase.java
===================================================================
--- lucene/contrib/highlighter/src/test/org/apache/lucene/search/vectorhighlight/AbstractTestCase.java	(revision 1205841)
+++ lucene/contrib/highlighter/src/test/org/apache/lucene/search/vectorhighlight/AbstractTestCase.java	(working copy)
@@ -177,7 +177,7 @@
 
     while (tokenStream.incrementToken()) {
       termAttribute.fillBytesRef();
-      bytesRefs.add(new BytesRef(bytesRef));
+      bytesRefs.add(BytesRef.deepCopyOf(bytesRef));
     }
 
     tokenStream.end();
Index: lucene/contrib/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery.java
===================================================================
--- lucene/contrib/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery.java	(revision 1205841)
+++ lucene/contrib/sandbox/src/java/org/apache/lucene/sandbox/queries/FuzzyLikeThisQuery.java	(working copy)
@@ -224,7 +224,7 @@
                       totalVariantDocFreqs+=fe.docFreq();
                       float score=boostAtt.getBoost();
                       if (variantsQ.size() < MAX_VARIANTS_PER_TERM || score > minScore){
-                        ScoreTerm st=new ScoreTerm(new Term(startTerm.field(), new BytesRef(possibleMatch)),score,startTerm);                    
+                        ScoreTerm st=new ScoreTerm(new Term(startTerm.field(), BytesRef.deepCopyOf(possibleMatch)),score,startTerm);                    
                         variantsQ.insertWithOverflow(st);
                         minScore = variantsQ.top().score; // maintain minScore
                       }
Index: lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java	(revision 1205841)
+++ lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery32.java	(working copy)
@@ -428,7 +428,7 @@
       if (last != null) {
         assertTrue(last.compareTo(cur) < 0);
       }
-      last = new BytesRef(cur);
+      last = BytesRef.deepCopyOf(cur);
     } 
     // LUCENE-3314: the results after next() already returned null are undefined,
     // assertNull(termEnum.next());
Index: lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java	(revision 1205841)
+++ lucene/src/test/org/apache/lucene/search/TestNumericRangeQuery64.java	(working copy)
@@ -447,7 +447,7 @@
       if (last != null) {
         assertTrue(last.compareTo(cur) < 0);
       }
-      last = new BytesRef(cur);
+      last = BytesRef.deepCopyOf(cur);
     } 
     // LUCENE-3314: the results after next() already returned null are undefined,
     // assertNull(termEnum.next());
Index: lucene/src/test/org/apache/lucene/index/TestTermsEnum.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestTermsEnum.java	(revision 1205841)
+++ lucene/src/test/org/apache/lucene/index/TestTermsEnum.java	(working copy)
@@ -65,7 +65,7 @@
     final TermsEnum termsEnum = MultiFields.getTerms(r, "body").iterator(null);
     BytesRef term;
     while((term = termsEnum.next()) != null) {
-      terms.add(new BytesRef(term));
+      terms.add(BytesRef.deepCopyOf(term));
     }
     if (VERBOSE) {
       System.out.println("TEST: " + terms.size() + " terms");
@@ -310,7 +310,7 @@
         if (startTerm == null) {
           loc = 0;
         } else {
-          loc = Arrays.binarySearch(termsArray, new BytesRef(startTerm));
+          loc = Arrays.binarySearch(termsArray, BytesRef.deepCopyOf(startTerm));
           if (loc < 0) {
             loc = -(loc+1);
           } else {
@@ -648,7 +648,7 @@
       } else {
         // pick valid term
         loc = random.nextInt(validTerms.length);
-        t = new BytesRef(validTerms[loc]);
+        t = BytesRef.deepCopyOf(validTerms[loc]);
         termState = null;
         if (VERBOSE) {
           System.out.println("\nTEST: valid term=" + t.utf8ToString());
Index: lucene/src/test/org/apache/lucene/index/TestIndexWriterUnicode.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestIndexWriterUnicode.java	(revision 1205883)
+++ lucene/src/test/org/apache/lucene/index/TestIndexWriterUnicode.java	(working copy)
@@ -148,7 +148,7 @@
       }
 
       assertTrue(last.compareTo(term) < 0);
-      last.copy(term);
+      last.copyBytes(term);
 
       final String s = term.utf8ToString();
       assertTrue("term " + termDesc(s) + " was not added to index (count=" + allTerms.size() + ")", allTerms.contains(s));
Index: lucene/src/test/org/apache/lucene/index/TestTermsEnum2.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestTermsEnum2.java	(revision 1205841)
+++ lucene/src/test/org/apache/lucene/index/TestTermsEnum2.java	(working copy)
@@ -166,7 +166,7 @@
       Automaton expected = BasicOperations.intersection(termsAutomaton, automaton);
       TreeSet<BytesRef> found = new TreeSet<BytesRef>();
       while (te.next() != null) {
-        found.add(new BytesRef(te.term()));
+        found.add(BytesRef.deepCopyOf(te.term()));
       }
       
       Automaton actual = DaciukMihovAutomatonBuilder.build(found);     
Index: lucene/src/test/org/apache/lucene/index/Test2BTerms.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/Test2BTerms.java	(revision 1205841)
+++ lucene/src/test/org/apache/lucene/index/Test2BTerms.java	(working copy)
@@ -77,7 +77,7 @@
       random.nextBytes(bytes.bytes);
       tokenCount++;
       if (--nextSave == 0) {
-        savedTerms.add(new BytesRef(bytes));
+        savedTerms.add(BytesRef.deepCopyOf(bytes));
         System.out.println("TEST: save term=" + bytes);
         nextSave = _TestUtil.nextInt(random, 500000, 1000000);
       }
@@ -231,7 +231,7 @@
     BytesRef term;
     while((term = termsEnum.next()) != null) {
       if (--nextSave == 0) {
-        savedTerms.add(new BytesRef(term));
+        savedTerms.add(BytesRef.deepCopyOf(term));
         System.out.println("TEST: add " + term);
         nextSave = _TestUtil.nextInt(random, 500000, 1000000);
       }
Index: lucene/src/test/org/apache/lucene/index/codecs/lucene3x/TestSurrogates.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/codecs/lucene3x/TestSurrogates.java	(revision 1205883)
+++ lucene/src/test/org/apache/lucene/index/codecs/lucene3x/TestSurrogates.java	(working copy)
@@ -121,10 +121,10 @@
             System.out.println();
           }
           if (lastText == null) {
-            lastText = new BytesRef(text);
+            lastText = BytesRef.deepCopyOf(text);
           } else {
             assertTrue(lastText.compareTo(text) < 0);
-            lastText.copy(text);
+            lastText.copyBytes(text);
           }
           assertEquals(exp.field(), field);
           assertEquals(exp.bytes(), text);
Index: lucene/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue.java
===================================================================
--- lucene/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue.java	(revision 1205883)
+++ lucene/src/test/org/apache/lucene/index/TestDocumentsWriterDeleteQueue.java	(working copy)
@@ -75,7 +75,7 @@
     HashSet<Term> frozenSet = new HashSet<Term>();
     for (Term t : queue.freezeGlobalBuffer(null).termsIterable()) {
       BytesRef bytesRef = new BytesRef();
-      bytesRef.copy(t.bytes);
+      bytesRef.copyBytes(t.bytes);
       frozenSet.add(new Term(t.field, bytesRef));
     }
     assertEquals(uniqueValues, frozenSet);
@@ -204,7 +204,7 @@
     Set<Term> frozenSet = new HashSet<Term>();
     for (Term t : queue.freezeGlobalBuffer(null).termsIterable()) {
       BytesRef bytesRef = new BytesRef();
-      bytesRef.copy(t.bytes);
+      bytesRef.copyBytes(t.bytes);
       frozenSet.add(new Term(t.field, bytesRef));
     }
     assertEquals("num deletes must be 0 after freeze", 0, queue
Index: lucene/src/test/org/apache/lucene/util/TestByteBlockPool.java
===================================================================
--- lucene/src/test/org/apache/lucene/util/TestByteBlockPool.java	(revision 1205883)
+++ lucene/src/test/org/apache/lucene/util/TestByteBlockPool.java	(working copy)
@@ -37,7 +37,7 @@
       final String value = _TestUtil.randomRealisticUnicodeString(random,
           maxLength);
       list.add(value);
-      ref.copy(value);
+      ref.copyChars(value);
       pool.copy(ref);
     }
     RAMDirectory dir = new RAMDirectory();
@@ -50,7 +50,7 @@
     BytesRef expected = new BytesRef();
     BytesRef actual = new BytesRef();
     for (String string : list) {
-      expected.copy(string);
+      expected.copyChars(string);
       actual.grow(expected.length);
       actual.length = expected.length;
       input.readBytes(actual.bytes, 0, actual.length);
Index: lucene/src/test/org/apache/lucene/util/TestBytesRefHash.java
===================================================================
--- lucene/src/test/org/apache/lucene/util/TestBytesRefHash.java	(revision 1205883)
+++ lucene/src/test/org/apache/lucene/util/TestBytesRefHash.java	(working copy)
@@ -73,7 +73,7 @@
         do {
           str = _TestUtil.randomRealisticUnicodeString(random, 1000);
         } while (str.length() == 0);
-        ref.copy(str);
+        ref.copyChars(str);
         int count = hash.size();
         int key = hash.add(ref);
         if (key < 0)
@@ -107,7 +107,7 @@
         do {
           str = _TestUtil.randomRealisticUnicodeString(random, 1000);
         } while (str.length() == 0);
-        ref.copy(str);
+        ref.copyChars(str);
         int count = hash.size();
         int key = hash.add(ref);
         if (key >= 0) {
@@ -121,7 +121,7 @@
         }
       }
       for (Entry<String, Integer> entry : strings.entrySet()) {
-        ref.copy(entry.getKey());
+        ref.copyChars(entry.getKey());
         assertEquals(ref, hash.get(entry.getValue().intValue(), scratch));
       }
       hash.clear();
@@ -146,7 +146,7 @@
         do {
           str = _TestUtil.randomRealisticUnicodeString(random, 1000);
         } while (str.length() == 0);
-        ref.copy(str);
+        ref.copyChars(str);
         final int key = hash.add(ref);
         if (key < 0) {
           assertTrue(bits.get((-key)-1));
@@ -186,7 +186,7 @@
         do {
           str = _TestUtil.randomRealisticUnicodeString(random, 1000);
         } while (str.length() == 0);
-        ref.copy(str);
+        ref.copyChars(str);
         hash.add(ref);
         strings.add(str);
       }
@@ -197,7 +197,7 @@
       int i = 0;
       BytesRef scratch = new BytesRef();
       for (String string : strings) {
-        ref.copy(string);
+        ref.copyChars(string);
         assertEquals(ref, hash.get(sort[i++], scratch));
       }
       hash.clear();
@@ -225,7 +225,7 @@
         do {
           str = _TestUtil.randomRealisticUnicodeString(random, 1000);
         } while (str.length() == 0);
-        ref.copy(str);
+        ref.copyChars(str);
         int count = hash.size();
         int key = hash.add(ref);
 
@@ -288,7 +288,7 @@
         do {
           str = _TestUtil.randomRealisticUnicodeString(random, 1000);
         } while (str.length() == 0);
-        ref.copy(str);
+        ref.copyChars(str);
         int count = hash.size();
         int key = hash.add(ref);
 
@@ -314,7 +314,7 @@
       
       assertAllIn(strings, hash);
       for (String string : strings) {
-        ref.copy(string);
+        ref.copyChars(string);
         int key = hash.add(ref);
         BytesRef bytesRef = offsetHash.get((-key)-1, scratch);
         assertEquals(ref, bytesRef);
@@ -334,7 +334,7 @@
     BytesRef scratch = new BytesRef();
     int count = hash.size();
     for (String string : strings) {
-      ref.copy(string);
+      ref.copyChars(string);
       int key  =  hash.add(ref); // add again to check duplicates
       assertEquals(string, hash.get((-key)-1, scratch).utf8ToString());
       assertEquals(count, hash.size());
Index: lucene/src/test/org/apache/lucene/util/TestCharsRef.java
===================================================================
--- lucene/src/test/org/apache/lucene/util/TestCharsRef.java	(revision 1205841)
+++ lucene/src/test/org/apache/lucene/util/TestCharsRef.java	(working copy)
@@ -62,7 +62,7 @@
       int offset = random.nextInt(charArray.length);
       int length = charArray.length - offset;
       String str = new String(charArray, offset, length);
-      ref.copy(charArray, offset, length);
+      ref.copyChars(charArray, offset, length);
       assertEquals(str, ref.toString());  
     }
     
Index: lucene/src/test/org/apache/lucene/util/fst/TestFSTs.java
===================================================================
--- lucene/src/test/org/apache/lucene/util/fst/TestFSTs.java	(revision 1205883)
+++ lucene/src/test/org/apache/lucene/util/fst/TestFSTs.java	(working copy)
@@ -811,7 +811,7 @@
       final Map<IntsRef,CountMinOutput<T>> prefixes = new HashMap<IntsRef,CountMinOutput<T>>();
       final IntsRef scratch = new IntsRef(10);
       for(InputOutput<T> pair: pairs) {
-        scratch.copy(pair.input);
+        scratch.copyInts(pair.input);
         for(int idx=0;idx<=pair.input.length;idx++) {
           scratch.length = idx;
           CountMinOutput<T> cmo = prefixes.get(scratch);
@@ -819,7 +819,7 @@
             cmo = new CountMinOutput<T>();
             cmo.count = 1;
             cmo.output = pair.output;
-            prefixes.put(new IntsRef(scratch), cmo);
+            prefixes.put(IntsRef.deepCopyOf(scratch), cmo);
           } else {
             cmo.count++;
             cmo.output = outputs.common(cmo.output, pair.output);
@@ -871,7 +871,7 @@
         } else {
           // clear isLeaf for all ancestors
           //System.out.println("    keep");
-          scratch.copy(prefix);
+          scratch.copyInts(prefix);
           scratch.length--;
           while(scratch.length >= 0) {
             final CountMinOutput<T> cmo2 = prefixes.get(scratch);
@@ -1633,7 +1633,7 @@
           if (w == null) {
             break;
           }
-          term.copy(w);
+          term.copyChars(w);
           b.add(term, nothing);
         }
         
Index: lucene/src/java/org/apache/lucene/analysis/NumericTokenStream.java
===================================================================
--- lucene/src/java/org/apache/lucene/analysis/NumericTokenStream.java	(revision 1205883)
+++ lucene/src/java/org/apache/lucene/analysis/NumericTokenStream.java	(working copy)
@@ -186,7 +186,7 @@
     @Override
     public void reflectWith(AttributeReflector reflector) {
       fillBytesRef();
-      reflector.reflect(TermToBytesRefAttribute.class, "bytes", new BytesRef(bytes));
+      reflector.reflect(TermToBytesRefAttribute.class, "bytes", BytesRef.deepCopyOf(bytes));
       reflector.reflect(NumericTermAttribute.class, "shift", shift);
       reflector.reflect(NumericTermAttribute.class, "rawValue", getRawValue());
       reflector.reflect(NumericTermAttribute.class, "valueSize", valueSize);
Index: lucene/src/java/org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl.java
===================================================================
--- lucene/src/java/org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl.java	(revision 1205883)
+++ lucene/src/java/org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl.java	(working copy)
@@ -213,7 +213,7 @@
     // Do a deep clone
     t.termBuffer = new char[this.termLength];
     System.arraycopy(this.termBuffer, 0, t.termBuffer, 0, this.termLength);
-    t.bytes = new BytesRef(bytes);
+    t.bytes = BytesRef.deepCopyOf(bytes);
     return t;
   }
   
@@ -256,7 +256,7 @@
   public void reflectWith(AttributeReflector reflector) {
     reflector.reflect(CharTermAttribute.class, "term", toString());
     fillBytesRef();
-    reflector.reflect(TermToBytesRefAttribute.class, "bytes", new BytesRef(bytes));
+    reflector.reflect(TermToBytesRefAttribute.class, "bytes", BytesRef.deepCopyOf(bytes));
   }
   
   @Override
Index: lucene/src/java/org/apache/lucene/search/TopTermsRewrite.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/TopTermsRewrite.java	(revision 1205883)
+++ lucene/src/java/org/apache/lucene/search/TopTermsRewrite.java	(working copy)
@@ -91,12 +91,12 @@
       private BytesRef lastTerm;
       private boolean compareToLastTerm(BytesRef t) throws IOException {
         if (lastTerm == null && t != null) {
-          lastTerm = new BytesRef(t);
+          lastTerm = BytesRef.deepCopyOf(t);
         } else if (t == null) {
           lastTerm = null;
         } else {
           assert termsEnum.getComparator().compare(lastTerm, t) < 0: "lastTerm=" + lastTerm + " t=" + t;
-          lastTerm.copy(t);
+          lastTerm.copyBytes(t);
         }
         return true;
       }
@@ -127,7 +127,7 @@
           t.termState.register(state, readerContext.ord, termsEnum.docFreq(), termsEnum.totalTermFreq());
         } else {
           // add new entry in PQ, we must clone the term, else it may get overwritten!
-          st.bytes.copy(bytes);
+          st.bytes.copyBytes(bytes);
           st.boost = boost;
           visitedTerms.put(st.bytes, st);
           assert st.termState.docFreq() == 0;
Index: lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.java	(revision 1205841)
+++ lucene/src/java/org/apache/lucene/search/FuzzyTermsEnum.java	(working copy)
@@ -240,7 +240,7 @@
       this.bottomTerm = bottomTerm;
       // clone the term before potentially doing something with it
       // this is a rare but wonderful occurrence anyway
-      queuedBottom = new BytesRef(term);
+      queuedBottom = BytesRef.deepCopyOf(term);
     }
     
     return term;
Index: lucene/src/java/org/apache/lucene/index/PrefixCodedTerms.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/PrefixCodedTerms.java	(revision 1205883)
+++ lucene/src/java/org/apache/lucene/index/PrefixCodedTerms.java	(working copy)
@@ -111,7 +111,7 @@
         }
         output.writeVInt(suffix);
         output.writeBytes(term.bytes.bytes, term.bytes.offset + prefix, suffix);
-        lastTerm.bytes.copy(term.bytes);
+        lastTerm.bytes.copyBytes(term.bytes);
         lastTerm.field = term.field;
       } catch (IOException e) {
         throw new RuntimeException(e);
Index: lucene/src/java/org/apache/lucene/index/DocTermOrds.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/DocTermOrds.java	(revision 1205841)
+++ lucene/src/java/org/apache/lucene/index/DocTermOrds.java	(working copy)
@@ -221,7 +221,7 @@
   protected void uninvert(final IndexReader reader, final BytesRef termPrefix) throws IOException {
     //System.out.println("DTO uninvert field=" + field + " prefix=" + termPrefix);
     final long startTime = System.currentTimeMillis();
-    prefix = termPrefix == null ? null : new BytesRef(termPrefix);
+    prefix = termPrefix == null ? null : BytesRef.deepCopyOf(termPrefix);
 
     final int maxDoc = reader.maxDoc();
     final int[] index = new int[maxDoc];       // immediate term numbers, or the index into the byte[] representing the last number
Index: lucene/src/java/org/apache/lucene/index/values/SortedBytesMergeUtils.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/values/SortedBytesMergeUtils.java	(revision 1205883)
+++ lucene/src/java/org/apache/lucene/index/values/SortedBytesMergeUtils.java	(working copy)
@@ -295,7 +295,7 @@
 
     @Override
     public BytesRef getByOrd(int ord, BytesRef bytesRef) {
-      bytesRef.copy(missingValue);
+      bytesRef.copyBytes(missingValue);
       return bytesRef;
     }
 
Index: lucene/src/java/org/apache/lucene/index/BufferedDeletesStream.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/BufferedDeletesStream.java	(revision 1205841)
+++ lucene/src/java/org/apache/lucene/index/BufferedDeletesStream.java	(working copy)
@@ -455,7 +455,7 @@
       assert lastDeleteTerm == null || term.compareTo(lastDeleteTerm) > 0: "lastTerm=" + lastDeleteTerm + " vs term=" + term;
     }
     // TODO: we re-use term now in our merged iterable, but we shouldn't clone, instead copy for this assert
-    lastDeleteTerm = term == null ? null : new Term(term.field(), new BytesRef(term.bytes));
+    lastDeleteTerm = term == null ? null : new Term(term.field(), BytesRef.deepCopyOf(term.bytes));
     return true;
   }
 
Index: lucene/src/java/org/apache/lucene/index/MultiTermsEnum.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/MultiTermsEnum.java	(revision 1205883)
+++ lucene/src/java/org/apache/lucene/index/MultiTermsEnum.java	(working copy)
@@ -201,7 +201,7 @@
       seekOpt = true;
     }
 
-    lastSeekScratch.copy(term);
+    lastSeekScratch.copyBytes(term);
     lastSeek = lastSeekScratch;
 
     for(int i=0;i<numSubs;i++) {
Index: lucene/src/java/org/apache/lucene/index/CheckIndex.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/CheckIndex.java	(revision 1205883)
+++ lucene/src/java/org/apache/lucene/index/CheckIndex.java	(working copy)
@@ -726,12 +726,12 @@
           // make sure terms arrive in order according to
           // the comp
           if (lastTerm == null) {
-            lastTerm = new BytesRef(term);
+            lastTerm = BytesRef.deepCopyOf(term);
           } else {
             if (termComp.compare(lastTerm, term) >= 0) {
               throw new RuntimeException("terms out of order: lastTerm=" + lastTerm + " term=" + term);
             }
-            lastTerm.copy(term);
+            lastTerm.copyBytes(term);
           }
 
           final int docFreq = termsEnum.docFreq();
@@ -977,7 +977,7 @@
               for(int i=seekCount-1;i>=0;i--) {
                 long ord = i*(termCount/seekCount);
                 termsEnum.seekExact(ord);
-                seekTerms[i] = new BytesRef(termsEnum.term());
+                seekTerms[i] = BytesRef.deepCopyOf(termsEnum.term());
               }
 
               // Seek by term
Index: lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum.java	(revision 1205883)
+++ lucene/src/java/org/apache/lucene/index/AutomatonTermsEnum.java	(working copy)
@@ -116,7 +116,7 @@
         return seekBytesRef;
       }
     } else {
-      seekBytesRef.copy(term);
+      seekBytesRef.copyBytes(term);
     }
 
     // seek to the next possible string;
Index: lucene/src/java/org/apache/lucene/index/codecs/memory/MemoryPostingsFormat.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/memory/MemoryPostingsFormat.java	(revision 1205841)
+++ lucene/src/java/org/apache/lucene/index/codecs/memory/MemoryPostingsFormat.java	(working copy)
@@ -213,7 +213,7 @@
           System.out.println("      " + Integer.toHexString(finalBuffer[i]&0xFF));
         }
       }
-      builder.add(text, new BytesRef(spare));
+      builder.add(text, BytesRef.deepCopyOf(spare));
       termCount++;
     }
 
Index: lucene/src/java/org/apache/lucene/index/codecs/DefaultTermVectorsReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/DefaultTermVectorsReader.java	(revision 1205883)
+++ lucene/src/java/org/apache/lucene/index/codecs/DefaultTermVectorsReader.java	(working copy)
@@ -447,7 +447,7 @@
       if (nextTerm >= numTerms) {
         return null;
       }
-      term.copy(lastTerm);
+      term.copyBytes(lastTerm);
       final int start = tvf.readVInt();
       final int deltaLen = tvf.readVInt();
       term.length = start + deltaLen;
@@ -477,7 +477,7 @@
         }
       }
 
-      lastTerm.copy(term);
+      lastTerm.copyBytes(term);
       nextTerm++;
       return term;
     }
Index: lucene/src/java/org/apache/lucene/index/codecs/lucene3x/TermBuffer.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/lucene3x/TermBuffer.java	(revision 1205883)
+++ lucene/src/java/org/apache/lucene/index/codecs/lucene3x/TermBuffer.java	(working copy)
@@ -78,7 +78,7 @@
       reset();
       return;
     }
-    bytes.copy(term.bytes());
+    bytes.copyBytes(term.bytes());
     field = term.field().intern();
     currentFieldNumber = -1;
     this.term = term;
@@ -90,7 +90,7 @@
     // dangerous to copy Term over, since the underlying
     // BytesRef could subsequently be modified:
     term = null;
-    bytes.copy(other.bytes);
+    bytes.copyBytes(other.bytes);
   }
 
   public void reset() {
@@ -104,7 +104,7 @@
       return null;
 
     if (term == null) {
-      term = new Term(field, new BytesRef(bytes));
+      term = new Term(field, BytesRef.deepCopyOf(bytes));
     }
 
     return term;
@@ -116,7 +116,7 @@
     try {
       clone = (TermBuffer)super.clone();
     } catch (CloneNotSupportedException e) {}
-    clone.bytes = new BytesRef(bytes);
+    clone.bytes = BytesRef.deepCopyOf(bytes);
     return clone;
   }
 }
Index: lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.java	(revision 1205883)
+++ lucene/src/java/org/apache/lucene/index/codecs/lucene3x/Lucene3xFields.java	(working copy)
@@ -407,7 +407,7 @@
             getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);
             //newSuffixStart = downTo+4;
             newSuffixStart = downTo;
-            scratchTerm.copy(termEnum.term().bytes());
+            scratchTerm.copyBytes(termEnum.term().bytes());
             didSeek = true;
             if (DEBUG_SURROGATES) {
               System.out.println("      seek!");
@@ -481,7 +481,7 @@
           // done no scanning (eg, term was precisely
           // and index term, or, was in the term seek
           // cache):
-          scratchTerm.copy(b2);
+          scratchTerm.copyBytes(b2);
           setNewSuffixStart(prevTerm, scratchTerm);
 
           return true;
@@ -554,7 +554,7 @@
       if (termEnum.term() == null || termEnum.term().field() != internedFieldName) {
         scratchTerm.length = 0;
       } else {
-        scratchTerm.copy(termEnum.term().bytes());
+        scratchTerm.copyBytes(termEnum.term().bytes());
       }
       
       if (DEBUG_SURROGATES) {
@@ -687,7 +687,7 @@
             // TODO: more efficient seek?
             getTermsDict().seekEnum(termEnum, seekTermEnum.term(), true);
 
-            scratchTerm.copy(seekTermEnum.term().bytes());
+            scratchTerm.copyBytes(seekTermEnum.term().bytes());
 
             // +3 because we don't need to check the char
             // at upTo: we know it's > BMP
@@ -788,7 +788,7 @@
 
         // We hit EOF; try end-case surrogate dance: if we
         // find an E, try swapping in S, backwards:
-        scratchTerm.copy(term);
+        scratchTerm.copyBytes(term);
 
         assert scratchTerm.offset == 0;
 
@@ -800,7 +800,7 @@
 
             if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {
 
-              scratchTerm.copy(seekTermEnum.term().bytes());
+              scratchTerm.copyBytes(seekTermEnum.term().bytes());
               getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);
 
               newSuffixStart = 1+i;
@@ -826,7 +826,7 @@
         // We found a non-exact but non-null term; this one
         // is fun -- just treat it like next, by pretending
         // requested term was prev:
-        prevTerm.copy(term);
+        prevTerm.copyBytes(term);
 
         if (DEBUG_SURROGATES) {
           System.out.println("  seek hit non-exact term=" + UnicodeUtil.toHexString(t.text()));
@@ -895,7 +895,7 @@
       }
 
       // TODO: can we use STE's prevBuffer here?
-      prevTerm.copy(termEnum.term().bytes());
+      prevTerm.copyBytes(termEnum.term().bytes());
 
       if (termEnum.next() && termEnum.term().field() == internedFieldName) {
         newSuffixStart = termEnum.newSuffixStart;
Index: lucene/src/java/org/apache/lucene/index/codecs/VariableGapTermsIndexWriter.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/VariableGapTermsIndexWriter.java	(revision 1205883)
+++ lucene/src/java/org/apache/lucene/index/codecs/VariableGapTermsIndexWriter.java	(working copy)
@@ -241,7 +241,7 @@
         //System.out.println("  YES");
         return true;
       } else {
-        lastTerm.copy(text);
+        lastTerm.copyBytes(text);
         return false;
       }
     }
@@ -260,7 +260,7 @@
       } finally {
         text.length = lengthSave;
       }
-      lastTerm.copy(text);
+      lastTerm.copyBytes(text);
     }
 
     @Override
Index: lucene/src/java/org/apache/lucene/index/codecs/DefaultTermVectorsWriter.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/DefaultTermVectorsWriter.java	(revision 1205883)
+++ lucene/src/java/org/apache/lucene/index/codecs/DefaultTermVectorsWriter.java	(working copy)
@@ -132,7 +132,7 @@
     tvf.writeVInt(suffix);
     tvf.writeBytes(term.bytes, term.offset + prefix, suffix);
     tvf.writeVInt(freq);
-    lastTerm.copy(term);
+    lastTerm.copyBytes(term);
     lastPosition = lastOffset = 0;
     
     if (offsets && positions) {
Index: lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.java	(revision 1205883)
+++ lucene/src/java/org/apache/lucene/index/codecs/BlockTermsReader.java	(working copy)
@@ -85,7 +85,7 @@
 
     public FieldAndTerm(FieldAndTerm other) {
       field = other.field;
-      term = new BytesRef(other.term);
+      term = BytesRef.deepCopyOf(other.term);
     }
 
     @Override
@@ -437,7 +437,7 @@
             state.ord = indexEnum.ord()-1;
           }
 
-          term.copy(indexEnum.term());
+          term.copyBytes(indexEnum.term());
           //System.out.println("  seek: term=" + term.utf8ToString());
         } else {
           //System.out.println("  skip seek");
@@ -720,7 +720,7 @@
         state.copyFrom(otherState);
         seekPending = true;
         indexIsCurrent = false;
-        term.copy(target);
+        term.copyBytes(target);
       }
       
       @Override
@@ -757,7 +757,7 @@
 
         state.ord = indexEnum.ord()-1;
         assert state.ord >= -1: "ord=" + state.ord;
-        term.copy(indexEnum.term());
+        term.copyBytes(indexEnum.term());
 
         // Now, scan:
         int left = (int) (ord - state.ord);
Index: lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriter.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriter.java	(revision 1205884)
+++ lucene/src/java/org/apache/lucene/index/codecs/pulsing/PulsingPostingsWriter.java	(working copy)
@@ -183,9 +183,9 @@
       pos.docID = currentDoc.docID;
       if (payload != null && payload.length > 0) {
         if (pos.payload == null) {
-          pos.payload = new BytesRef(payload);
+          pos.payload = BytesRef.deepCopyOf(payload);
         } else {
-          pos.payload.copy(payload);
+          pos.payload.copyBytes(payload);
         }
       } else if (pos.payload != null) {
         pos.payload.length = 0;
Index: lucene/src/java/org/apache/lucene/index/codecs/BlockTermsWriter.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/BlockTermsWriter.java	(revision 1205884)
+++ lucene/src/java/org/apache/lucene/index/codecs/BlockTermsWriter.java	(working copy)
@@ -225,7 +225,7 @@
         pendingTerms = newArray;
       }
       final TermEntry te = pendingTerms[pendingCount];
-      te.term.copy(text);
+      te.term.copyBytes(text);
       te.stats = stats;
 
       pendingCount++;
@@ -312,7 +312,7 @@
       bytesWriter.reset();
 
       postingsWriter.flushTermsBlock(pendingCount, pendingCount);
-      lastPrevTerm.copy(pendingTerms[pendingCount-1].term);
+      lastPrevTerm.copyBytes(pendingTerms[pendingCount-1].term);
       pendingCount = 0;
     }
   }
Index: lucene/src/java/org/apache/lucene/index/codecs/FixedGapTermsIndexWriter.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/FixedGapTermsIndexWriter.java	(revision 1205884)
+++ lucene/src/java/org/apache/lucene/index/codecs/FixedGapTermsIndexWriter.java	(working copy)
@@ -141,7 +141,7 @@
         if (0 == numTerms % termIndexInterval) {
           // save last term just before next index term so we
           // can compute wasted suffix
-          lastTerm.copy(text);
+          lastTerm.copyBytes(text);
         }
         return false;
       }
@@ -172,7 +172,7 @@
       termLengths[numIndexTerms] = (short) indexedTermLength;
       totTermLength += indexedTermLength;
 
-      lastTerm.copy(text);
+      lastTerm.copyBytes(text);
       numIndexTerms++;
     }
 
Index: lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsReader.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsReader.java	(revision 1205884)
+++ lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsReader.java	(working copy)
@@ -785,7 +785,7 @@
 
       // only for assert:
       private boolean setSavedStartTerm(BytesRef startTerm) {
-        savedStartTerm = startTerm == null ? null : new BytesRef(startTerm);
+        savedStartTerm = startTerm == null ? null : BytesRef.deepCopyOf(startTerm);
         return true;
       }
 
@@ -1847,7 +1847,7 @@
 
             final SeekStatus result = currentFrame.scanToTerm(target, false);
             if (result == SeekStatus.END) {
-              term.copy(target);
+              term.copyBytes(target);
               termExists = false;
 
               if (next() != null) {
@@ -1900,7 +1900,7 @@
         final SeekStatus result = currentFrame.scanToTerm(target, false);
 
         if (result == SeekStatus.END) {
-          term.copy(target);
+          term.copyBytes(target);
           termExists = false;
           if (next() != null) {
             //if (DEBUG) {
@@ -2120,7 +2120,7 @@
           assert otherState != null && otherState instanceof BlockTermState;
           currentFrame = staticFrame;
           currentFrame.state.copyFrom(otherState);
-          term.copy(target);
+          term.copyBytes(target);
           currentFrame.metaDataUpto = currentFrame.getTermBlockOrd();
           assert currentFrame.metaDataUpto > 0;
           validIndexPrefix = 0;
Index: lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsWriter.java
===================================================================
--- lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsWriter.java	(revision 1205841)
+++ lucene/src/java/org/apache/lucene/index/codecs/BlockTreeTermsWriter.java	(working copy)
@@ -860,7 +860,7 @@
       //if (DEBUG) System.out.println("BTTW.finishTerm term=" + fieldInfo.name + ":" + toString(text) + " seg=" + segment + " df=" + stats.docFreq);
 
       blockBuilder.add(text, noOutputs.getNoOutput());
-      pending.add(new PendingTerm(new BytesRef(text), stats));
+      pending.add(new PendingTerm(BytesRef.deepCopyOf(text), stats));
       postingsWriter.finishTerm(stats);
       numTerms++;
     }
Index: lucene/src/java/org/apache/lucene/util/mutable/MutableValueStr.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/mutable/MutableValueStr.java	(revision 1205884)
+++ lucene/src/java/org/apache/lucene/util/mutable/MutableValueStr.java	(working copy)
@@ -30,13 +30,13 @@
   public void copy(MutableValue source) {
     MutableValueStr s = (MutableValueStr) source;
     exists = s.exists;
-    value.copy(s.value);
+    value.copyBytes(s.value);
   }
 
   @Override
   public MutableValue duplicate() {
     MutableValueStr v = new MutableValueStr();
-    v.value.copy(value);
+    v.value.copyBytes(value);
     v.exists = this.exists;
     return v;
   }
Index: lucene/src/java/org/apache/lucene/util/fst/Builder.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/fst/Builder.java	(revision 1205841)
+++ lucene/src/java/org/apache/lucene/util/fst/Builder.java	(working copy)
@@ -462,7 +462,7 @@
     }
 
     // save last input
-    lastInput.copy(input);
+    lastInput.copyInts(input);
 
     //System.out.println("  count[0]=" + frontier[0].inputCount);
   }
Index: lucene/src/java/org/apache/lucene/util/CharsRef.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/CharsRef.java	(revision 1205841)
+++ lucene/src/java/org/apache/lucene/util/CharsRef.java	(working copy)
@@ -68,18 +68,9 @@
     this.length = chars.length;
   }
 
-  /**
-   * Creates a new {@link CharsRef} and copies the contents of the source into
-   * the new instance.
-   * @see #copy(CharsRef)
-   */
-  public CharsRef(CharsRef other) {
-    copy(other);
-  }
-
   @Override
   public Object clone() {
-    return new CharsRef(this);
+    return CharsRef.deepCopyOf(this);
   }
 
   @Override
@@ -168,7 +159,8 @@
    * @param other
    *          the {@link CharsRef} to copy
    */
-  public void copy(CharsRef other) {
+  // TODO: why does this behave differently/not invoke copyChars(char[], int, int) ???
+  public void copyChars(CharsRef other) {
     if (chars == null) {
       chars = new char[other.length];
     } else {
@@ -188,7 +180,7 @@
   /**
    * Copies the given array into this CharsRef starting at offset 0
    */
-  public void copy(char[] otherChars, int otherOffset, int otherLength) {
+  public void copyChars(char[] otherChars, int otherOffset, int otherLength) {
     grow(otherLength);
     System.arraycopy(otherChars, otherOffset, this.chars, 0,
         otherLength);
@@ -275,4 +267,17 @@
       return a.length - b.length;
     }
   }
+  
+  /**
+   * Creates a new CharsRef that points to a copy of the chars from 
+   * <code>other</code>
+   * <p>
+   * The returned CharsRef will have a length of other.length
+   * and an offset of zero.
+   */
+  public static CharsRef deepCopyOf(CharsRef other) {
+    CharsRef clone = new CharsRef();
+    clone.copyChars(other);
+    return clone;
+  }
 }
\ No newline at end of file
Index: lucene/src/java/org/apache/lucene/util/IntsRef.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/IntsRef.java	(revision 1205841)
+++ lucene/src/java/org/apache/lucene/util/IntsRef.java	(working copy)
@@ -43,13 +43,9 @@
     this.length = length;
   }
 
-  public IntsRef(IntsRef other) {
-    copy(other);
-  }
-
   @Override
   public Object clone() {
-    return new IntsRef(this);
+    return deepCopyOf(this);
   }
 
   @Override
@@ -109,7 +105,7 @@
     return this.length - other.length;
   }
 
-  public void copy(IntsRef other) {
+  public void copyInts(IntsRef other) {
     if (ints == null) {
       ints = new int[other.length];
     } else {
@@ -140,4 +136,17 @@
     sb.append(']');
     return sb.toString();
   }
+  
+  /**
+   * Creates a new IntsRef that points to a copy of the ints from 
+   * <code>other</code>
+   * <p>
+   * The returned IntsRef will have a length of other.length
+   * and an offset of zero.
+   */
+  public static IntsRef deepCopyOf(IntsRef other) {
+    IntsRef clone = new IntsRef();
+    clone.copyInts(other);
+    return clone;
+  }
 }
Index: lucene/src/java/org/apache/lucene/util/BytesRef.java
===================================================================
--- lucene/src/java/org/apache/lucene/util/BytesRef.java	(revision 1205884)
+++ lucene/src/java/org/apache/lucene/util/BytesRef.java	(working copy)
@@ -72,14 +72,9 @@
    */
   public BytesRef(CharSequence text) {
     this();
-    copy(text);
+    copyChars(text);
   }
 
-  public BytesRef(BytesRef other) {
-    this();
-    copy(other);
-  }
-
   /* // maybe?
   public BytesRef(BytesRef other, boolean shallow) {
     this();
@@ -99,7 +94,7 @@
    * @param text Must be well-formed unicode text, with no
    * unpaired surrogates or invalid UTF16 code units.
    */
-  public void copy(CharSequence text) {
+  public void copyChars(CharSequence text) {
     UnicodeUtil.UTF16toUTF8(text, 0, text.length(), this);
   }
   
@@ -121,7 +116,7 @@
 
   @Override
   public Object clone() {
-    return new BytesRef(this);
+    return deepCopyOf(this);
   }
 
   private boolean sliceEquals(BytesRef other, int pos) {
@@ -207,12 +202,12 @@
   }
 
   /**
-   * Copies the given {@link BytesRef}
+   * Copies the bytes from the given {@link BytesRef}
    * <p>
    * NOTE: this method resets the offset to 0 and resizes the reference array
    * if needed.
    */
-  public void copy(BytesRef other) {
+  public void copyBytes(BytesRef other) {
     if (bytes.length < other.length) {
       bytes = new byte[other.length];
     }
@@ -404,4 +399,17 @@
       return a.length - b.length;
     }
   }
+  
+  /**
+   * Creates a new BytesRef that points to a copy of the bytes from 
+   * <code>other</code>
+   * <p>
+   * The returned BytesRef will have a length of other.length
+   * and an offset of zero.
+   */
+  public static BytesRef deepCopyOf(BytesRef other) {
+    BytesRef copy = new BytesRef();
+    copy.copyBytes(other);
+    return copy;
+  }
 }
Index: lucene/src/java/org/apache/lucene/document/IndexDocValuesField.java
===================================================================
--- lucene/src/java/org/apache/lucene/document/IndexDocValuesField.java	(revision 1205884)
+++ lucene/src/java/org/apache/lucene/document/IndexDocValuesField.java	(working copy)
@@ -246,9 +246,9 @@
     }
     setDocValuesType(type);
     if (bytes == null) {
-      bytes = new BytesRef(value);
+      bytes = BytesRef.deepCopyOf(value);
     } else {
-      bytes.copy(value);
+      bytes.copyBytes(value);
     }
     bytesComparator = comp;
   }
Index: lucene/src/test-framework/java/org/apache/lucene/analysis/CollationTestBase.java
===================================================================
--- lucene/src/test-framework/java/org/apache/lucene/analysis/CollationTestBase.java	(revision 1205884)
+++ lucene/src/test-framework/java/org/apache/lucene/analysis/CollationTestBase.java	(working copy)
@@ -279,7 +279,7 @@
       assertTrue(ts.incrementToken());
       termAtt.fillBytesRef();
       // ensure we make a copy of the actual bytes too
-      map.put(term, new BytesRef(bytes));
+      map.put(term, BytesRef.deepCopyOf(bytes));
     }
     
     Thread threads[] = new Thread[numThreads];
Index: lucene/src/test-framework/java/org/apache/lucene/index/codecs/preflexrw/TermInfosWriter.java
===================================================================
--- lucene/src/test-framework/java/org/apache/lucene/index/codecs/preflexrw/TermInfosWriter.java	(revision 1205884)
+++ lucene/src/test-framework/java/org/apache/lucene/index/codecs/preflexrw/TermInfosWriter.java	(working copy)
@@ -170,7 +170,7 @@
         return cmp;
     }
 
-    scratchBytes.copy(term);
+    scratchBytes.copyBytes(term);
     assert lastTerm.offset == 0;
     UnicodeUtil.UTF8toUTF16(lastTerm.bytes, 0, lastTerm.length, utf16Result1);
 
@@ -255,7 +255,7 @@
     output.writeVInt(length);                  // write delta length
     output.writeBytes(term.bytes, start+term.offset, length);  // write delta bytes
     output.writeVInt(fieldNumber); // write field num
-    lastTerm.copy(term);
+    lastTerm.copyBytes(term);
   }
 
   /** Called to complete TermInfos creation. */
Index: lucene/src/test-framework/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java
===================================================================
--- lucene/src/test-framework/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java	(revision 1205841)
+++ lucene/src/test-framework/java/org/apache/lucene/util/automaton/DaciukMihovAutomatonBuilder.java	(working copy)
@@ -324,7 +324,7 @@
   private boolean setPrevious(CharsRef current) {
     // don't need to copy, once we fix https://issues.apache.org/jira/browse/LUCENE-3277
     // still, called only from assert
-    previous = new CharsRef(current);
+    previous = CharsRef.deepCopyOf(current);
     return true;
   }
   
