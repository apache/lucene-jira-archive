diff --git a/.gitignore b/.gitignore
index 71bc12a..7f3567b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -28,6 +28,8 @@ parent.iml
 
 /solr/package
 
+lucene/sandbox/src/java/org/apache/lucene/geoviz
+
 # can this be minimized?
 /solr/example/start.jar
 /solr/example/webapps/*
diff --git a/lucene/sandbox/src/java/org/apache/lucene/document/GeoPointField.java b/lucene/sandbox/src/java/org/apache/lucene/document/GeoPointField.java
index e9ecc76..811b88a 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/document/GeoPointField.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/document/GeoPointField.java
@@ -41,7 +41,7 @@ import org.apache.lucene.util.GeoUtils;
  * @lucene.experimental
  */
 public final class GeoPointField extends Field {
-  public static final int PRECISION_STEP = 6;
+  public static final int PRECISION_STEP = 3;
 
   /**
    * Type for an GeoPointField that is not stored:
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermQuery.java b/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermQuery.java
index 8f0bd15..21c93b5 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermQuery.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermQuery.java
@@ -20,11 +20,16 @@ package org.apache.lucene.search;
 import org.apache.lucene.util.GeoUtils;
 
 /**
- * Abstract base class used by {@code GeoPointInBBoxQueryImpl}
+ * TermQuery for GeoPointField for overriding {@link org.apache.lucene.search.MultiTermQuery} methods specific to
+ * Geospatial operations
+ *
+ * Note: see {@link org.apache.lucene.search.GeoPointTermsEnum} for a special note about
+ * {@param detailLevel}
  *
  * @lucene.experimental
  */
-// TODO: remove this?  Just absorb into its base class
+
+// TODO: remove this?  Just absorb into its base class5
 abstract class GeoPointTermQuery extends MultiTermQuery {
   // simple bounding box optimization - no objects used to avoid dependencies
   protected final double minLon;
diff --git a/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermsEnum.java b/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermsEnum.java
index 5a410d4..718020e 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermsEnum.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/search/GeoPointTermsEnum.java
@@ -32,23 +32,32 @@ import org.apache.lucene.util.NumericUtils;
 /**
  * computes all ranges along a space-filling curve that represents
  * the given bounding box and enumerates all terms contained within those ranges
+ *
+ * Note: the {@param detailLevel} is configurable for controlling the boundary resolution of the query. The
+ * higher the resolution the greater the number of ranges along the query boundary. This results in visiting fewer terms
+ * in the terms dictionary for the price of memory usage. The lower the resolution the fewer number of ranges (and less
+ * memory usage) for the price of visiting more terms.
+ *
+ *  @lucene.experimental
  */
 class GeoPointTermsEnum extends FilteredTermsEnum {
   protected final double minLon;
   protected final double minLat;
   protected final double maxLon;
   protected final double maxLat;
+  protected final short detailLevel;
+  private final static short MIN_LEVEL = 3 * GeoPointField.PRECISION_STEP;
+  private final static short MAX_LEVEL = 6 * GeoPointField.PRECISION_STEP;
 
   private Range currentRange;
   private BytesRef currentLowerBound, currentUpperBound;
 
   private final List<Range> rangeBounds = new LinkedList<>();
 
-  protected static final short DETAIL_LEVEL = 16;
-
   GeoPointTermsEnum(final TermsEnum tenum, final double minLon, final double minLat,
                     final double maxLon, final double maxLat) {
     super(tenum);
+    this.detailLevel = computeDetailLevel(minLon, minLat, maxLon, maxLat);
     final long rectMinHash = GeoUtils.mortonHash(minLon, minLat);
     final long rectMaxHash = GeoUtils.mortonHash(maxLon, maxLat);
     this.minLon = GeoUtils.mortonUnhashLon(rectMinHash);
@@ -89,10 +98,10 @@ class GeoPointTermsEnum extends FilteredTermsEnum {
     final short level = (short)(62-res>>>1);
 
     // if cell is within and a factor of the precision step, or it crosses the edge of the shape add the range
-    final boolean within = res% GeoPointField.PRECISION_STEP == 0 && cellWithin(minLon, minLat, maxLon, maxLat);
-    if (within || (level == DETAIL_LEVEL && cellCrosses(minLon, minLat, maxLon, maxLat))) {
+    final boolean within = res % GeoPointField.PRECISION_STEP == 0 && cellWithin(minLon, minLat, maxLon, maxLat);
+    if (within || (level == detailLevel && cellCrosses(minLon, minLat, maxLon, maxLat))) {
       rangeBounds.add(new Range(start, end, res, level, !within));
-    } else if (level <= DETAIL_LEVEL && cellIntersects(minLon, minLat, maxLon, maxLat)) {
+    } else if (level <= detailLevel && cellIntersects(minLon, minLat, maxLon, maxLat)) {
       computeRange(start, (short)(res - 1));
     }
   }
@@ -203,4 +212,15 @@ class GeoPointTermsEnum extends FilteredTermsEnum {
       return this.lower.compareTo(other.lower);
     }
   }
+
+  /**
+   * Computes the range detail level as a function of the bounding box size. This is currently computed as 5% of the
+   * smallest distance between longitudes or latitudes rounded down to the nearest factor of
+   * {@link org.apache.lucene.document.GeoPointField#PRECISION_STEP}. The detail is currently restricted to a minimum of
+   * 9 and a maximum of 18
+   */
+  private short computeDetailLevel(final double minLon, final double minLat, final double maxLon, final double maxLat) {
+    short level = (short)(StrictMath.log(180.0 / (StrictMath.min(maxLon - minLon, maxLat - minLat) * 0.05)) / GeoUtils.LOG2);
+    return (short)StrictMath.max(MIN_LEVEL, StrictMath.min((level - (level % GeoPointField.PRECISION_STEP)), MAX_LEVEL));
+  }
 }
diff --git a/lucene/sandbox/src/java/org/apache/lucene/util/GeoUtils.java b/lucene/sandbox/src/java/org/apache/lucene/util/GeoUtils.java
index 842ddbd..03165dc 100644
--- a/lucene/sandbox/src/java/org/apache/lucene/util/GeoUtils.java
+++ b/lucene/sandbox/src/java/org/apache/lucene/util/GeoUtils.java
@@ -44,6 +44,8 @@ public final class GeoUtils {
   /** Maximum latitude value. */
   public static final double MAX_LAT_INCL = 90.0D;
 
+  public static double LOG2 = StrictMath.log(2);
+
   // No instance:
   private GeoUtils() {
   }
@@ -290,17 +292,25 @@ public final class GeoUtils {
         !pointInPolygon(shapeX, shapeY, rMaxY, rMaxX) || !pointInPolygon(shapeX, shapeY, rMaxY, rMinX));
   }
 
-  private static boolean rectAnyCornersInCirlce( final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
-                                                 final double centerLon, final double centerLat, final double radius) {
+  private static boolean rectAnyCornersOutsideCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
+                                                     final double centerLon, final double centerLat, final double radius) {
     return (SloppyMath.haversin(centerLat, centerLon, rMinY, rMinX)*1000.0 > radius
         || SloppyMath.haversin(centerLat, centerLon, rMaxY, rMinX)*1000.0 > radius
         || SloppyMath.haversin(centerLat, centerLon, rMaxY, rMaxX)*1000.0 > radius
         || SloppyMath.haversin(centerLat, centerLon, rMinY, rMaxX)*1000.0 > radius);
   }
 
+  private static boolean rectAnyCornersInCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
+                                                final double centerLon, final double centerLat, final double radius) {
+    return (SloppyMath.haversin(centerLat, centerLon, rMinY, rMinX)*1000.0 <= radius
+        || SloppyMath.haversin(centerLat, centerLon, rMaxY, rMinX)*1000.0 <= radius
+        || SloppyMath.haversin(centerLat, centerLon, rMaxY, rMaxX)*1000.0 <= radius
+        || SloppyMath.haversin(centerLat, centerLon, rMinY, rMaxX)*1000.0 <= radius);
+  }
+
   public static boolean rectWithinCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
                                          final double centerLon, final double centerLat, final double radius) {
-    return !(rectAnyCornersInCirlce(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radius));
+    return !(rectAnyCornersOutsideCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radius));
   }
 
   /**
@@ -308,8 +318,7 @@ public final class GeoUtils {
    */
   public static boolean rectCrossesCircle(final double rMinX, final double rMinY, final double rMaxX, final double rMaxY,
                                           final double centerLon, final double centerLat, final double radius) {
-
-    return rectAnyCornersInCirlce(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radius)
+    return rectAnyCornersInCircle(rMinX, rMinY, rMaxX, rMaxY, centerLon, centerLat, radius)
         || lineCrossesSphere(rMinX, rMinY, 0, rMaxX, rMinY, 0, centerLon, centerLat, 0, radius)
         || lineCrossesSphere(rMaxX, rMinY, 0, rMaxX, rMaxY, 0, centerLon, centerLat, 0, radius)
         || lineCrossesSphere(rMaxX, rMaxY, 0, rMinX, rMaxY, 0, centerLon, centerLat, 0, radius)
diff --git a/lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery.java b/lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery.java
index 728d349..9792df6 100644
--- a/lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery.java
+++ b/lucene/sandbox/src/test/org/apache/lucene/search/TestGeoPointQuery.java
@@ -41,6 +41,7 @@ import org.apache.lucene.index.RandomIndexWriter;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.util.FixedBitSet;
+import org.apache.lucene.util.GeoDistanceUtils;
 import org.apache.lucene.util.GeoUtils;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.LuceneTestCase;
@@ -425,8 +426,8 @@ public class TestGeoPointQuery extends LuceneTestCase {
                 double centerLon = bbox.minLon + ((bbox.maxLon - bbox.minLon)/2.0);
 
                 // radius (in meters) as a function of the random generated bbox
-                // TODO: change 100 back to 1000
-                final double radius = SloppyMath.haversin(centerLat, centerLon, bbox.minLat, centerLon)*100;
+                final double radius = GeoDistanceUtils.vincentyDistance(centerLon, centerLat, centerLon, bbox.minLat);
+                //final double radius = SloppyMath.haversin(centerLat, centerLon, bbox.minLat, centerLon)*1000;
                 if (VERBOSE) {
                   System.out.println("\t radius = " + radius);
                 }
@@ -436,9 +437,8 @@ public class TestGeoPointQuery extends LuceneTestCase {
                 verifyHits = new VerifyHits() {
                     @Override
                     protected Boolean shouldMatch(double pointLat, double pointLon) {
-                      if (Double.isNaN(pointLat) || Double.isNaN(pointLon)) {
+                      if (Double.isNaN(pointLat) || Double.isNaN(pointLon))
                         return null;
-                      }
                       if (radiusQueryCanBeWrong(centerLat, centerLon, pointLon, pointLat, radius)) {
                         return null;
                       } else {
