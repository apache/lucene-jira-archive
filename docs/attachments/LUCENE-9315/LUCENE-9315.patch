diff --git a/lucene/core/src/java/org/apache/lucene/search/BooleanClause.java b/lucene/core/src/java/org/apache/lucene/search/BooleanClause.java
index f3931b1f970..975ef833eb7 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BooleanClause.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BooleanClause.java
@@ -58,7 +58,16 @@ public final class BooleanClause {
   */ 
   public BooleanClause(Query query, Occur occur) {
     this.query = Objects.requireNonNull(query, "Query must not be null");
-    this.occur = Objects.requireNonNull(occur, "Occur must not be null");
+    // nocommit: This (and all other changes to this class) are not sustainable changes.
+    // nocommit: 
+    // nocommit: Changes to BooleanClause in this patch are only here to keep the
+    // nocommit: strawman changes to QueryParserBase simple. (ie: no jflex changes yet)
+    //
+    // nocommit: the "correct" way to impliment the intended changes would be to redesign
+    // nocommit: the QueryParserBase protected APIs to use it's own version of a 'BooleanClauseStruc'
+    // nocommit: that supports both nullability and mutability on the Occur property
+    this.occur = occur;
+    //this.occur = Objects.requireNonNull(occur, "Occur must not be null");
     
   }
 
@@ -89,18 +98,18 @@ public final class BooleanClause {
       return false;
     BooleanClause other = (BooleanClause)o;
     return this.query.equals(other.query)
-      && this.occur == other.occur;
+      && Objects.equals(this.occur, other.occur);
   }
 
   /** Returns a hash code value for this object.*/
   @Override
   public int hashCode() {
-    return 31 * query.hashCode() + occur.hashCode();
+    return 31 * query.hashCode() + Objects.hashCode( occur );
   }
 
 
   @Override
   public String toString() {
-    return occur.toString() + query.toString();
+    return Objects.toString(occur, "(UNSPECIFIED)") + query.toString();
   }
 }
diff --git a/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java b/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
index a1f8fa582ad..08217fa8675 100644
--- a/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
+++ b/lucene/queryparser/src/java/org/apache/lucene/queryparser/classic/QueryParserBase.java
@@ -371,25 +371,24 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
     return maxDeterminizedStates;
   }
 
+  // nocommit: see nocommit comments in BooleanClause for how/why this API should change
   protected void addClause(List<BooleanClause> clauses, int conj, int mods, Query q) {
-    boolean required, prohibited;
-
-    // If this term is introduced by AND, make the preceding term required,
-    // unless it's already prohibited
-    if (clauses.size() > 0 && conj == CONJ_AND) {
-      BooleanClause c = clauses.get(clauses.size()-1);
-      if (!c.isProhibited())
-        clauses.set(clauses.size() - 1, new BooleanClause(c.getQuery(), Occur.MUST));
-    }
 
-    if (clauses.size() > 0 && operator == AND_OPERATOR && conj == CONJ_OR) {
-      // If this term is introduced by OR, make the preceding term optional,
-      // unless it's prohibited (that means we leave -a OR b but +a OR b-->a OR b)
-      // notice if the input is a OR b, first term is parsed as required; without
-      // this modification a OR b would parsed as +a OR b
-      BooleanClause c = clauses.get(clauses.size()-1);
-      if (!c.isProhibited())
-        clauses.set(clauses.size() - 1, new BooleanClause(c.getQuery(), Occur.SHOULD));
+    // If this term is introduced by an (infix) CONJunction, then use it to set our clauseOccur;
+    // otherwise leave null to be set at a future date (possibly by our parser default)
+    Occur clauseOccur = null;
+    if (CONJ_NONE != conj) {
+      assert (CONJ_AND == conj || CONJ_OR == conj);
+      clauseOccur = CONJ_AND == conj ? Occur.MUST : Occur.SHOULD;
+    }
+    
+    // If the preceding term does not already have Occur value, but we have one due to an (infix) CONJunction,
+    // then use current clauseOccur to set the occur value on the prior clause...
+    if (clauses.size() > 0 && null != clauseOccur) {
+      final BooleanClause prior = clauses.get(clauses.size()-1);
+      if (null == prior.getOccur()) {
+        clauses.set(clauses.size() - 1, new BooleanClause(prior.getQuery(), clauseOccur));
+      }
     }
 
     // We might have been passed a null query; the term might have been
@@ -397,28 +396,14 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
     if (q == null)
       return;
 
-    if (operator == OR_OPERATOR) {
-      // We set REQUIRED if we're introduced by AND or +; PROHIBITED if
-      // introduced by NOT or -; make sure not to set both.
-      prohibited = (mods == MOD_NOT);
-      required = (mods == MOD_REQ);
-      if (conj == CONJ_AND && !prohibited) {
-        required = true;
-      }
-    } else {
-      // We set PROHIBITED if we're introduced by NOT or -; We set REQUIRED
-      // if not PROHIBITED and not introduced by OR
-      prohibited = (mods == MOD_NOT);
-      required   = (!prohibited && conj != CONJ_OR);
+    // if there is a (prefix) modifier on the current query, use it to set the clauseOccur
+    // (even if already set by an (infix)  CONJunction)
+    if (MOD_NONE != mods) {
+      assert (MOD_NOT == mods || MOD_REQ == mods);
+      clauseOccur = MOD_NOT == mods ? Occur.MUST_NOT : Occur.MUST;
     }
-    if (required && !prohibited)
-      clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST));
-    else if (!required && !prohibited)
-      clauses.add(newBooleanClause(q, BooleanClause.Occur.SHOULD));
-    else if (!required && prohibited)
-      clauses.add(newBooleanClause(q, BooleanClause.Occur.MUST_NOT));
-    else
-      throw new RuntimeException("Clause cannot be both required and prohibited");
+
+    clauses.add(newBooleanClause(q, clauseOccur));
   }
 
   /**
@@ -554,6 +539,7 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
   * @param occur how this clause should occur when matching documents
   * @return new BooleanClause instance
   */
+  // nocommit: see nocommit comments in BooleanClause for how/why this API should change
   protected BooleanClause newBooleanClause(Query q, BooleanClause.Occur occur) {
     return new BooleanClause(q, occur);
   }
@@ -659,13 +645,20 @@ public abstract class QueryParserBase extends QueryBuilder implements CommonQuer
    * @return Resulting {@link org.apache.lucene.search.Query} object.
    * @exception org.apache.lucene.queryparser.classic.ParseException throw in overridden method to disallow
    */
+  // nocommit: see nocommit comments in BooleanClause for how/why this API should change
   protected Query getBooleanQuery(List<BooleanClause> clauses) throws ParseException {
     if (clauses.size()==0) {
       return null; // all clause words were filtered away by the analyzer.
     }
     BooleanQuery.Builder query = newBooleanQuery();
     for(final BooleanClause clause: clauses) {
-      query.add(clause);
+      if (null == clause.getOccur()) {
+        // No prefix or infix operator ever set our occurence, so now, only at the last possible moment,
+        // do we let our default operator determine the default occurence...
+        query.add(newBooleanClause(clause.getQuery(), Operator.AND == this.operator ? Occur.MUST : Occur.SHOULD));
+      } else {
+        query.add(clause);
+      }
     }
     return query.build();
   }
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParserConfusionForUsers.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParserConfusionForUsers.java
new file mode 100644
index 00000000000..eea8725df23
--- /dev/null
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/classic/TestQueryParserConfusionForUsers.java
@@ -0,0 +1,150 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.queryparser.classic;
+
+import java.util.Arrays;
+
+import org.apache.lucene.analysis.Analyzer;
+import org.apache.lucene.analysis.MockAnalyzer;
+import org.apache.lucene.analysis.MockTokenizer;
+
+import org.apache.lucene.index.Term;
+
+import org.apache.lucene.queryparser.classic.QueryParser.Operator;
+
+import org.apache.lucene.search.BooleanClause;
+import org.apache.lucene.search.BooleanClause.Occur;
+import org.apache.lucene.search.BooleanQuery;
+import org.apache.lucene.search.BoostQuery;
+import org.apache.lucene.search.Query;
+import org.apache.lucene.search.TermQuery;
+
+import org.apache.lucene.util.LuceneTestCase;
+
+// nocommit: javadocs
+// nocommit: refactor this into QueryParserTestBase so (flexible) TestStandardQP can inherit the assertions?
+public class TestQueryParserConfusionForUsers extends LuceneTestCase {
+
+  private static final String FIELD = "field";
+  
+  private QueryParser getParser(final Operator defOp) throws Exception {
+    QueryParser qp = new QueryParser(FIELD, new MockAnalyzer(random(), MockTokenizer.SIMPLE, true));
+    qp.setDefaultOperator(defOp);
+    return qp;
+  }
+
+  private void assertEquals(final Operator defOp, final String input, final Query expected) throws Exception {
+    final Query actual = getParser(defOp).parse(input);
+    assertEquals(expected, actual);
+  }
+
+  public void test() throws Exception {
+
+    for (Operator op : Arrays.asList(Operator.OR, Operator.AND)) {
+      // first some queries where the default operator should be irrelevant
+      // because every clause has either a prefix or infix operator
+      
+      // nocommit: add some really trivial queries...
+      // "X AND Y"
+      // "X AND NOT Y"
+      // "X OR Y"
+      // "X OR NOT Y"
+      // "+X +Y"
+      // "+X -Y"
+      
+      assertEquals(op, "X AND Y OR  Z",
+                   new BooleanQuery.Builder()
+                   .add(new TermQuery(new Term(FIELD, "x")), Occur.MUST)
+                   .add(new TermQuery(new Term(FIELD, "y")), Occur.MUST)
+                   .add(new TermQuery(new Term(FIELD, "z")), Occur.SHOULD)
+                   .build());
+      assertEquals(op, "Z OR  Y AND X",
+                   new BooleanQuery.Builder()
+                   .add(new TermQuery(new Term(FIELD, "z")), Occur.SHOULD)
+                   .add(new TermQuery(new Term(FIELD, "y")), Occur.SHOULD)
+                   .add(new TermQuery(new Term(FIELD, "x")), Occur.MUST)
+                   .build());
+
+      assertEquals(op, "+Y OR Z",
+                   new BooleanQuery.Builder()
+                   .add(new TermQuery(new Term(FIELD, "y")), Occur.MUST)
+                   .add(new TermQuery(new Term(FIELD, "z")), Occur.SHOULD)
+                   .build());
+      assertEquals(op, "+Y AND Z",
+                   new BooleanQuery.Builder()
+                   .add(new TermQuery(new Term(FIELD, "y")), Occur.MUST)
+                   .add(new TermQuery(new Term(FIELD, "z")), Occur.MUST)
+                   .build());
+      
+      assertEquals(op, "Z OR  +Y",
+                   new BooleanQuery.Builder()
+                   .add(new TermQuery(new Term(FIELD, "z")), Occur.SHOULD)
+                   .add(new TermQuery(new Term(FIELD, "y")), Occur.MUST)
+                   .build());
+      assertEquals(op, "Z AND +Y",
+                   new BooleanQuery.Builder()
+                   .add(new TermQuery(new Term(FIELD, "z")), Occur.MUST)
+                   .add(new TermQuery(new Term(FIELD, "y")), Occur.MUST)
+                   .build());
+      
+      // Now queries where the default op impacts some underqualified clauses...
+      final Occur occur = Operator.OR.equals(op) ? Occur.SHOULD : Occur.MUST;
+      
+      assert (Occur.MUST.equals(occur) &&  Operator.AND.equals(op))
+        || (Occur.SHOULD.equals(occur) &&  Operator.OR.equals(op));
+      
+      assertEquals(op, "X Y OR  Z", 
+                   new BooleanQuery.Builder()
+                   .add(new TermQuery(new Term(FIELD, "x")), occur)
+                   .add(new TermQuery(new Term(FIELD, "y")), Occur.SHOULD)
+                   .add(new TermQuery(new Term(FIELD, "z")), Occur.SHOULD)
+                   .build());
+      assertEquals(op, "X Y AND Z",
+                   new BooleanQuery.Builder()
+                   .add(new TermQuery(new Term(FIELD, "x")), occur)
+                   .add(new TermQuery(new Term(FIELD, "y")), Occur.MUST)
+                   .add(new TermQuery(new Term(FIELD, "z")), Occur.MUST)
+                   .build());
+      
+      
+    }
+
+    
+
+
+    // // A multi-word synonym source will form a synonym query for the same-starting-position tokens
+    // TermQuery guinea = new TermQuery(new Term("field", "guinea"));
+    // TermQuery pig = new TermQuery(new Term("field", "pig"));
+    // TermQuery cavy = new TermQuery(new Term("field", "cavy"));
+
+    // // A multi-word synonym source will form a graph query for synonyms that formed the graph token stream
+    // BooleanQuery.Builder synonym = new BooleanQuery.Builder();
+    // synonym.add(guinea, BooleanClause.Occur.MUST);
+    // synonym.add(pig, BooleanClause.Occur.MUST);
+    // BooleanQuery guineaPig = synonym.build();
+
+    // BooleanQuery actual = new BooleanQuery.Builder()
+    //     .add(new BooleanQuery.Builder()
+    //         .add(guineaPig, BooleanClause.Occur.SHOULD)
+    //         .add(cavy, BooleanClause.Occur.SHOULD)
+    //         .build(), BooleanClause.Occur.SHOULD)
+    //     .build();
+    // assertEquals(graphQuery, parser.parse("guinea pig"));
+
+
+  }
+}
diff --git a/lucene/queryparser/src/test/org/apache/lucene/queryparser/util/QueryParserTestBase.java b/lucene/queryparser/src/test/org/apache/lucene/queryparser/util/QueryParserTestBase.java
index b4451a6cd52..0beeed96bb8 100644
--- a/lucene/queryparser/src/test/org/apache/lucene/queryparser/util/QueryParserTestBase.java
+++ b/lucene/queryparser/src/test/org/apache/lucene/queryparser/util/QueryParserTestBase.java
@@ -977,13 +977,21 @@ public abstract class QueryParserTestBase extends LuceneTestCase {
   }
 
   /**
+   * Tests left to right precedence of AND/OR is obeyed independently of default OP.
+   *
    * This test differs from TestPrecedenceQueryParser
    */
   public void testPrecedence() throws Exception {
+    final String input = "A AND B OR C AND D";
+    final String expected = "+A +B C +D";
     CommonQueryParserConfiguration qp = getParserConfig(new MockAnalyzer(random(), MockTokenizer.WHITESPACE, false));
-    Query query1 = getQuery("A AND B OR C AND D", qp);
-    Query query2 = getQuery("+A +B +C +D", qp);
-    assertEquals(query1, query2);
+    
+    setDefaultOperatorAND(qp);
+    assertQueryEquals(qp, defaultField, input, expected);
+    
+    setDefaultOperatorAND(qp);
+    assertQueryEquals(qp, defaultField, input, expected);
+    
   }
 
 // Todo: convert this from DateField to DateUtil
