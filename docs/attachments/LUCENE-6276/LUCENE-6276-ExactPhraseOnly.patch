diff --git a/lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer.java b/lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer.java
index 48060ef..1e309b6 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer.java
@@ -44,9 +44,11 @@ final class ExactPhraseScorer extends Scorer {
 
   private final Similarity.SimScorer docScorer;
   private final boolean needsScores;
+  private long matchCost;
 
   ExactPhraseScorer(Weight weight, PhraseQuery.PostingsAndFreq[] postings,
-                    Similarity.SimScorer docScorer, boolean needsScores) throws IOException {
+                    Similarity.SimScorer docScorer, boolean needsScores,
+                    long sumTotalTermFreq) throws IOException {
     super(weight);
     this.docScorer = docScorer;
     this.needsScores = needsScores;
@@ -58,6 +60,7 @@ final class ExactPhraseScorer extends Scorer {
       postingsAndPositions.add(new PostingsAndPosition(posting.postings, posting.position));
     }
     conjunction = ConjunctionDISI.intersect(iterators);
+    this.matchCost = sumTotalTermFreq / conjunction.cost();
     this.postings = postingsAndPositions.toArray(new PostingsAndPosition[postingsAndPositions.size()]);
   }
 
@@ -68,6 +71,11 @@ final class ExactPhraseScorer extends Scorer {
       public boolean matches() throws IOException {
         return phraseFreq() > 0;
       }
+
+      public long matchCost() {
+        return matchCost;
+      }
+
     };
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java b/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
index f29d86a..37cdca6 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
@@ -59,7 +59,7 @@ public class MultiPhraseQuery extends Query {
     if (s < 0) {
       throw new IllegalArgumentException("slop value cannot be negative");
     }
-    slop = s; 
+    slop = s;
   }
 
   /** Sets the phrase slop for this query.
@@ -126,6 +126,7 @@ public class MultiPhraseQuery extends Query {
     private final Similarity.SimWeight stats;
     private final Map<Term,TermContext> termContexts = new HashMap<>();
     private final boolean needsScores;
+    private long sumTotalTermFreq;
 
     public MultiPhraseWeight(IndexSearcher searcher, boolean needsScores)
       throws IOException {
@@ -133,7 +134,7 @@ public class MultiPhraseQuery extends Query {
       this.needsScores = needsScores;
       this.similarity = searcher.getSimilarity(needsScores);
       final IndexReaderContext context = searcher.getTopReaderContext();
-      
+
       // compute idf
       ArrayList<TermStatistics> allTermStats = new ArrayList<>();
       for(final Term[] terms: termArrays) {
@@ -143,11 +144,13 @@ public class MultiPhraseQuery extends Query {
             termContext = TermContext.build(context, term);
             termContexts.put(term, termContext);
           }
-          allTermStats.add(searcher.termStatistics(term, termContext));
+          TermStatistics termStat = searcher.termStatistics(term, termContext);
+          allTermStats.add(termStat);
+          sumTotalTermFreq += termStat.totalTermFreq();
         }
       }
       stats = similarity.computeWeight(
-          searcher.collectionStatistics(field), 
+          searcher.collectionStatistics(field),
           allTermStats.toArray(new TermStatistics[allTermStats.size()]));
     }
 
@@ -174,7 +177,7 @@ public class MultiPhraseQuery extends Query {
     public Scorer scorer(LeafReaderContext context) throws IOException {
       assert !termArrays.isEmpty();
       final LeafReader reader = context.reader();
-      
+
       PhraseQuery.PostingsAndFreq[] postingsFreqs = new PhraseQuery.PostingsAndFreq[termArrays.size()];
 
       final Terms fieldTerms = reader.terms(field);
@@ -193,7 +196,7 @@ public class MultiPhraseQuery extends Query {
       for (int pos=0; pos<postingsFreqs.length; pos++) {
         Term[] terms = termArrays.get(pos);
         List<PostingsEnum> postings = new ArrayList<>();
-        
+
         for (Term term : terms) {
           TermState termState = termContexts.get(term).get(context.ord);
           if (termState != null) {
@@ -201,11 +204,11 @@ public class MultiPhraseQuery extends Query {
             postings.add(termsEnum.postings(null, PostingsEnum.POSITIONS));
           }
         }
-        
+
         if (postings.isEmpty()) {
           return null;
         }
-        
+
         final PostingsEnum postingsEnum;
         if (postings.size() == 1) {
           postingsEnum = postings.get(0);
@@ -222,7 +225,7 @@ public class MultiPhraseQuery extends Query {
       }
 
       if (slop == 0) {
-        return new ExactPhraseScorer(this, postingsFreqs, similarity.simScorer(stats, context), needsScores);
+        return new ExactPhraseScorer(this, postingsFreqs, similarity.simScorer(stats, context), needsScores, sumTotalTermFreq);
       } else {
         return new SloppyPhraseScorer(this, postingsFreqs, slop, similarity.simScorer(stats, context), needsScores);
       }
@@ -244,7 +247,7 @@ public class MultiPhraseQuery extends Query {
               scoreExplanation);
         }
       }
-      
+
       return Explanation.noMatch("no matching term");
     }
   }
@@ -340,7 +343,7 @@ public class MultiPhraseQuery extends Query {
       ^ termArraysHashCode()
       ^ positions.hashCode();
   }
-  
+
   // Breakout calculation of the termArrays hashcode
   private int termArraysHashCode() {
     int hashCode = 1;
@@ -368,8 +371,8 @@ public class MultiPhraseQuery extends Query {
     }
     return true;
   }
-  
-  /** 
+
+  /**
    * Takes the logical union of multiple PostingsEnum iterators.
    * <p>
    * Note: positions are merged during freq()
@@ -379,14 +382,14 @@ public class MultiPhraseQuery extends Query {
     final DocsQueue docsQueue;
     /** cost of this enum: sum of its subs */
     final long cost;
-    
+
     /** queue ordered by position for current doc */
     final PositionsQueue posQueue = new PositionsQueue();
     /** current doc posQueue is working */
     int posQueueDoc = -2;
     /** list of subs (unordered) */
     final PostingsEnum[] subs;
-    
+
     UnionPostingsEnum(Collection<PostingsEnum> subs) {
       docsQueue = new DocsQueue(subs.size());
       long cost = 0;
@@ -431,7 +434,7 @@ public class MultiPhraseQuery extends Query {
     public int nextDoc() throws IOException {
       PostingsEnum top = docsQueue.top();
       int doc = top.docID();
-      
+
       do {
         top.nextDoc();
         top = docsQueue.updateTop();
@@ -443,7 +446,7 @@ public class MultiPhraseQuery extends Query {
     @Override
     public int advance(int target) throws IOException {
       PostingsEnum top = docsQueue.top();
-      
+
       do {
         top.advance(target);
         top = docsQueue.updateTop();
@@ -456,7 +459,7 @@ public class MultiPhraseQuery extends Query {
     public long cost() {
       return cost;
     }
-    
+
     @Override
     public int startOffset() throws IOException {
       return -1; // offsets are unsupported
@@ -471,8 +474,8 @@ public class MultiPhraseQuery extends Query {
     public BytesRef getPayload() throws IOException {
       return null; // payloads are unsupported
     }
-    
-    /** 
+
+    /**
      * disjunction of postings ordered by docid.
      */
     static class DocsQueue extends PriorityQueue<PostingsEnum> {
@@ -485,8 +488,8 @@ public class MultiPhraseQuery extends Query {
         return a.docID() < b.docID();
       }
     }
-    
-    /** 
+
+    /**
      * queue of terms for a single document. its a sorted array of
      * all the positions from all the postings
      */
@@ -495,7 +498,7 @@ public class MultiPhraseQuery extends Query {
       private int index = 0;
       private int size = 0;
       private int[] array = new int[arraySize];
-      
+
       void add(int i) {
         if (size == arraySize)
           growArray();
diff --git a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
index 599a1ae..a6d4310 100644
--- a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
@@ -348,6 +348,7 @@ public class PhraseQuery extends Query {
     private final Similarity.SimWeight stats;
     private final boolean needsScores;
     private transient TermContext states[];
+    private long sumTotalTermFreq;
 
     public PhraseWeight(IndexSearcher searcher, boolean needsScores)
       throws IOException {
@@ -363,10 +364,12 @@ public class PhraseQuery extends Query {
       final IndexReaderContext context = searcher.getTopReaderContext();
       states = new TermContext[terms.length];
       TermStatistics termStats[] = new TermStatistics[terms.length];
+      sumTotalTermFreq = 0;
       for (int i = 0; i < terms.length; i++) {
         final Term term = terms[i];
         states[i] = TermContext.build(context, term);
         termStats[i] = searcher.termStatistics(term, states[i]);
+        sumTotalTermFreq += termStats[i].totalTermFreq();
       }
       stats = similarity.computeWeight(searcher.collectionStatistics(field), termStats);
     }
@@ -425,7 +428,7 @@ public class PhraseQuery extends Query {
       }
 
       if (slop == 0) {  // optimize exact case
-        return new ExactPhraseScorer(this, postingsFreqs, similarity.simScorer(stats, context), needsScores);
+        return new ExactPhraseScorer(this, postingsFreqs, similarity.simScorer(stats, context), needsScores, sumTotalTermFreq);
       } else {
         return new SloppyPhraseScorer(this, postingsFreqs, slop, similarity.simScorer(stats, context), needsScores);
       }
diff --git a/lucene/core/src/java/org/apache/lucene/search/TwoPhaseIterator.java b/lucene/core/src/java/org/apache/lucene/search/TwoPhaseIterator.java
index 3df07a8..d7550fc 100644
--- a/lucene/core/src/java/org/apache/lucene/search/TwoPhaseIterator.java
+++ b/lucene/core/src/java/org/apache/lucene/search/TwoPhaseIterator.java
@@ -93,6 +93,10 @@ public abstract class TwoPhaseIterator {
    *  {@link DocIdSetIterator#NO_MORE_DOCS} -- and at most once. */
   public abstract boolean matches() throws IOException;
 
+  /** An estimate of the expected total cost for matching a single document.
+   */
+  public abstract long matchCost();
+
   /**
    * Returns a {@link TwoPhaseIterator} for this {@link DocIdSetIterator}
    * when available * otherwise returns null.
