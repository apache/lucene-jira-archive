Index: src/java/org/apache/lucene/search/SubQueryQuery.java
===================================================================
--- src/java/org/apache/lucene/search/SubQueryQuery.java	(revision 0)
+++ src/java/org/apache/lucene/search/SubQueryQuery.java	(revision 0)
@@ -0,0 +1,259 @@
+package org.apache.lucene.search;
+
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import org.apache.lucene.index.IndexReader;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.Collection;
+import java.util.Set;
+
+/**
+ * A query that generates the union of documents produced by its subqueries, and that scores each document with the maximum
+ * score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries.
+ * This is useful when searching for a word in multiple fields with different boost factors (so that the fields cannot be
+ * combined equivalently into a single search field).  We want the primary score to be the one associated with the highest boost,
+ * not the sum of the field scores (as BooleanQuery would give).
+ * If the query is "albino elephant" this ensures that "albino" matching one field and "elephant" matching
+ * another gets a higher score than "albino" matching both fields.
+ * To get this result, use both BooleanQuery and DisjunctionMaxQuery:  for each term a DisjunctionMaxQuery searches for it in
+ * each field, while the set of these DisjunctionMaxQuery's is combined into a BooleanQuery.
+ * The tie breaker capability allows results that include the same term in multiple fields to be judged better than results that
+ * include this term in only the best of those multiple fields, without confusing this with the better case of two different terms
+ * in the multiple fields.
+ * @author Chuck Williams
+ */
+public abstract class SubQueryQuery extends Query {
+
+  /* The subqueries */
+  protected ArrayList disjuncts = new ArrayList();
+
+  /** Creates a new empty SubQueryQuery.  Use add() to add the subqueries.
+   * @param tieBreakerMultiplier this score of each non-maximum disjunct for a document is multiplied by this weight
+   *        and added into the final score.  If non-zero, the value should be small, on the order of 0.1, which says that
+   *        10 occurrences of word in a lower-scored field that is also in a higher scored field is just as good as a unique
+   *        word in the lower scored field (i.e., one that is not in any higher scored field.
+   */
+  public SubQueryQuery() {
+  }
+
+  /**
+   * Creates a new SubQueryQuery
+   * @param disjuncts a Collection<Query> of all the disjuncts to add
+   * @param tieBreakerMultiplier   the weight to give to each matching non-maximum disjunct
+   */
+  public SubQueryQuery(Collection disjuncts) {
+    add(disjuncts);
+  }
+
+  /** Add a subquery to this disjunction
+   * @param query the disjunct added
+   */
+  public void add(Query query) {
+    disjuncts.add(query);
+  }
+
+  /** Add a collection of disjuncts to this disjunction
+   * via Iterable<Query>
+   */
+  public void add(Collection disjuncts) {
+    this.disjuncts.addAll(disjuncts);
+  }
+
+  /** An Iterator<Query> over the disjuncts */
+  public Iterator iterator() {
+    return disjuncts.iterator();
+  }
+
+  /* The Weight for SubQueryQuery's, used to normalize, score and explain these queries */
+  protected class SubQueryWeight implements Weight {
+
+    private Searcher searcher;       // The searcher with which we are associated.
+    private ArrayList weights = new ArrayList();  // The Weight's for our subqueries, in 1-1 correspondence with disjuncts
+
+    /* Construct the Weight for this Query searched by searcher.  Recursively construct subquery weights. */
+    public SubQueryWeight(Searcher searcher) throws IOException {
+      this.searcher = searcher;
+      for (int i = 0; i < disjuncts.size(); i++)
+        weights.add(((Query) disjuncts.get(i)).createWeight(searcher));
+    }
+
+    /* Return our associated SubQueryQuery */
+    public Query getQuery() { return SubQueryQuery.this; }
+
+    /* Return our boost */
+    public float getValue() { return getBoost(); }
+
+    /* Compute the sub of squared weights of us applied to our subqueries.  Used for normalization. */
+    public float sumOfSquaredWeights() throws IOException {
+      float ws[] = new float[weights.size()];
+      for (int i = 0; i < weights.size(); i++) {
+        float sub = ((Weight) weights.get(i)).sumOfSquaredWeights();
+	ws[i] = sub;
+      }
+      return squaredWeight(ws) * getBoost() * getBoost();
+    }
+
+    /* Apply the computed normalization factor to our subqueries */
+    public void normalize(float norm) {
+      norm *= getBoost();  // Incorporate our boost
+      for (int i = 0 ; i < weights.size(); i++)
+        ((Weight) weights.get(i)).normalize(norm);
+    }
+
+    /* Create the scorer used to score our associated SubQueryQuery */
+    public Scorer scorer(IndexReader reader) throws IOException {
+      SubQueryScorer result = createScorer(searcher);
+      for (int i = 0 ; i < weights.size(); i++) {
+        Weight w = (Weight) weights.get(i);
+        Scorer subScorer = w.scorer(reader);
+        if (subScorer == null) return null;
+        result.add(subScorer);
+      }
+      return result;
+    }
+
+    /* Explain the score we computed for doc */
+    public Explanation explain(IndexReader reader, int doc) throws IOException {
+      if ( disjuncts.size() == 1) return ((Weight) weights.get(0)).explain(reader,doc);
+      ComplexExplanation result = new ComplexExplanation();
+      result.setDescription(getDescription());
+      ArrayList vals = new ArrayList();
+      for (int i = 0 ; i < weights.size(); i++) {
+        Explanation e = ((Weight) weights.get(i)).explain(reader, doc);
+        if (e.isMatch()) {
+          result.setMatch(Boolean.TRUE);
+          result.addDetail(e);
+	  vals.add(new Float(e.getValue()));
+        }
+      }
+      float[] scores = new float[vals.size()];
+      for(int i = 0; i < vals.size(); i++) 
+	scores[i] = ((Float)vals.get(i)).floatValue();
+      result.setValue(getExplainValue(scores)); 
+      return result;
+    }
+
+  }  // end of DisjunctionMaxWeight inner class
+
+  protected abstract SubQueryScorer createScorer(Searcher searcher);
+  protected abstract String getDescription();
+  protected abstract float getExplainValue(float[] scores);
+  protected float squaredWeight(float[] weights) {
+    float max = 0.0f, sum = 0.0f;
+    for(int i=0; i < weights.length; i++) {
+      sum += weights[i];
+      max = Math.max(max, weights[i]);
+    }
+    return sum;
+  }
+
+  /* Create the Weight used to score us */
+  protected Weight createWeight(Searcher searcher) throws IOException {
+    return new SubQueryWeight(searcher);
+  }
+
+  /** Optimize our representation and our subqueries representations
+   * @param reader the IndexReader we query
+   * @return an optimized copy of us (which may not be a copy if there is nothing to optimize) */
+  public Query rewrite(IndexReader reader) throws IOException {
+    if (disjuncts.size() == 1) {
+      Query singleton = (Query) disjuncts.get(0);
+      Query result = singleton.rewrite(reader);
+      if (getBoost() != 1.0f) {
+        if (result == singleton) result = (Query)result.clone();
+        result.setBoost(getBoost() * result.getBoost());
+      }
+      return result;
+    }
+    SubQueryQuery clone = null;
+    for (int i = 0 ; i < disjuncts.size(); i++) {
+      Query clause = (Query) disjuncts.get(i);
+      Query rewrite = clause.rewrite(reader);
+      if (rewrite != clause) {
+        if (clone == null) clone = (SubQueryQuery)this.clone();
+        clone.disjuncts.set(i, rewrite);
+      }
+    }
+    if (clone != null) return clone;
+    else return this;
+  }
+
+  /** Create a shallow copy of us -- used in rewriting if necessary
+   * @return a copy of us (but reuse, don't copy, our subqueries) */
+  public Object clone() {
+    SubQueryQuery clone = (SubQueryQuery)super.clone();
+    clone.disjuncts = (ArrayList)this.disjuncts.clone();
+    return clone;
+  }
+
+
+  // inherit javadoc
+  public void extractTerms(Set terms) {
+      for (int i = 0; i < disjuncts.size(); i++) {
+          ((Query)disjuncts.get(i)).extractTerms(terms);
+      }
+  }
+
+
+  /** Prettyprint us.
+   * @param field the field to which we are applied
+   * @return a string that shows what we do, of the form "(disjunct1 | disjunct2 | ... | disjunctn)^boost"
+   */
+  public String toString(String field) {
+    StringBuffer buffer = new StringBuffer();
+    buffer.append("(");
+    for (int i = 0 ; i < disjuncts.size(); i++) {
+      Query subquery = (Query) disjuncts.get(i);
+      if (subquery instanceof BooleanQuery) {   // wrap sub-bools in parens
+        buffer.append("(");
+        buffer.append(subquery.toString(field));
+        buffer.append(")");
+      }
+      else buffer.append(subquery.toString(field));
+      if (i != disjuncts.size()-1) buffer.append(" | ");
+    }
+    buffer.append(")");
+    if (getBoost() != 1.0) {
+      buffer.append("^");
+      buffer.append(getBoost());
+    }
+    return buffer.toString();
+  }
+
+  /** Return true iff we represent the same query as o
+   * @param o another object
+   * @return true iff o is a SubQueryQuery with the same boost and the same subqueries, in the same order, as us
+   */
+  public boolean equals(Object o) {
+    if (! (o instanceof SubQueryQuery) ) return false;
+    SubQueryQuery other = (SubQueryQuery)o;
+    return this.getBoost() == other.getBoost()
+            && this.disjuncts.equals(other.disjuncts);
+  }
+
+  /** Compute a hash code for hashing us
+   * @return the hash code
+   */
+  public int hashCode() {
+    return Float.floatToIntBits(getBoost())
+            + disjuncts.hashCode();
+  }
+
+}

Property changes on: src/java/org/apache/lucene/search/SubQueryQuery.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
===================================================================
--- src/java/org/apache/lucene/search/DisjunctionMaxQuery.java	(revision 509832)
+++ src/java/org/apache/lucene/search/DisjunctionMaxQuery.java	(working copy)
@@ -39,11 +39,8 @@
  * in the multiple fields.
  * @author Chuck Williams
  */
-public class DisjunctionMaxQuery extends Query {
+public class DisjunctionMaxQuery extends SubQueryQuery {
 
-  /* The subqueries */
-  private ArrayList disjuncts = new ArrayList();
-
   /* Multiple of the non-max disjunct scores added into our final score.  Non-zero values support tie-breaking. */
   private float tieBreakerMultiplier = 0.0f;
 
@@ -63,102 +60,33 @@
    * @param tieBreakerMultiplier   the weight to give to each matching non-maximum disjunct
    */
   public DisjunctionMaxQuery(Collection disjuncts, float tieBreakerMultiplier) {
+    super(disjuncts);
     this.tieBreakerMultiplier = tieBreakerMultiplier;
-    add(disjuncts);
-  }
 
-  /** Add a subquery to this disjunction
-   * @param query the disjunct added
-   */
-  public void add(Query query) {
-    disjuncts.add(query);
   }
 
-  /** Add a collection of disjuncts to this disjunction
-   * via Iterable<Query>
-   */
-  public void add(Collection disjuncts) {
-    this.disjuncts.addAll(disjuncts);
+  protected SubQueryScorer createScorer(Searcher searcher) {
+    return new DisjunctionMaxScorer(tieBreakerMultiplier, getSimilarity(searcher));
   }
 
-  /** An Iterator<Query> over the disjuncts */
-  public Iterator iterator() {
-    return disjuncts.iterator();
+  protected String getDescription() {
+    return tieBreakerMultiplier == 0.0f ? "max of:" : "max plus " + tieBreakerMultiplier + " times others of:";
   }
-
-  /* The Weight for DisjunctionMaxQuery's, used to normalize, score and explain these queries */
-  private class DisjunctionMaxWeight implements Weight {
-
-    private Searcher searcher;       // The searcher with which we are associated.
-    private ArrayList weights = new ArrayList();  // The Weight's for our subqueries, in 1-1 correspondence with disjuncts
-
-    /* Construct the Weight for this Query searched by searcher.  Recursively construct subquery weights. */
-    public DisjunctionMaxWeight(Searcher searcher) throws IOException {
-      this.searcher = searcher;
-      for (int i = 0; i < disjuncts.size(); i++)
-        weights.add(((Query) disjuncts.get(i)).createWeight(searcher));
+  protected float getExplainValue(float[] scores) {
+    float max = 0.0f, sum = 0.0f;
+    for(int i=0; i < scores.length; i++) {
+      sum += scores[i];
+      max = Math.max(max, scores[i]);
     }
-
-    /* Return our associated DisjunctionMaxQuery */
-    public Query getQuery() { return DisjunctionMaxQuery.this; }
-
-    /* Return our boost */
-    public float getValue() { return getBoost(); }
-
-    /* Compute the sub of squared weights of us applied to our subqueries.  Used for normalization. */
-    public float sumOfSquaredWeights() throws IOException {
-      float max = 0.0f, sum = 0.0f;
-      for (int i = 0; i < weights.size(); i++) {
-        float sub = ((Weight) weights.get(i)).sumOfSquaredWeights();
-        sum += sub;
-        max = Math.max(max, sub);
-      }
-      return (((sum - max) * tieBreakerMultiplier * tieBreakerMultiplier) + max) * getBoost() * getBoost();
+    return max + (sum - max)*tieBreakerMultiplier;
+  }
+  protected float squaredWeight(float[] weights) {
+    float max = 0.0f, sum = 0.0f;
+    for(int i=0; i < weights.length; i++) {
+      sum += weights[i];
+      max = Math.max(max, weights[i]);
     }
-
-    /* Apply the computed normalization factor to our subqueries */
-    public void normalize(float norm) {
-      norm *= getBoost();  // Incorporate our boost
-      for (int i = 0 ; i < weights.size(); i++)
-        ((Weight) weights.get(i)).normalize(norm);
-    }
-
-    /* Create the scorer used to score our associated DisjunctionMaxQuery */
-    public Scorer scorer(IndexReader reader) throws IOException {
-      DisjunctionMaxScorer result = new DisjunctionMaxScorer(tieBreakerMultiplier, getSimilarity(searcher));
-      for (int i = 0 ; i < weights.size(); i++) {
-        Weight w = (Weight) weights.get(i);
-        Scorer subScorer = w.scorer(reader);
-        if (subScorer == null) return null;
-        result.add(subScorer);
-      }
-      return result;
-    }
-
-    /* Explain the score we computed for doc */
-    public Explanation explain(IndexReader reader, int doc) throws IOException {
-      if ( disjuncts.size() == 1) return ((Weight) weights.get(0)).explain(reader,doc);
-      ComplexExplanation result = new ComplexExplanation();
-      float max = 0.0f, sum = 0.0f;
-      result.setDescription(tieBreakerMultiplier == 0.0f ? "max of:" : "max plus " + tieBreakerMultiplier + " times others of:");
-      for (int i = 0 ; i < weights.size(); i++) {
-        Explanation e = ((Weight) weights.get(i)).explain(reader, doc);
-        if (e.isMatch()) {
-          result.setMatch(Boolean.TRUE);
-          result.addDetail(e);
-          sum += e.getValue();
-          max = Math.max(max, e.getValue());
-        }
-      }
-      result.setValue(max + (sum - max)*tieBreakerMultiplier);
-      return result;
-    }
-
-  }  // end of DisjunctionMaxWeight inner class
-
-  /* Create the Weight used to score us */
-  protected Weight createWeight(Searcher searcher) throws IOException {
-    return new DisjunctionMaxWeight(searcher);
+    return max + (sum - max)*tieBreakerMultiplier;
   }
 
   /** Optimize our representation and our subqueries representations
@@ -187,23 +115,6 @@
     else return this;
   }
 
-  /** Create a shallow copy of us -- used in rewriting if necessary
-   * @return a copy of us (but reuse, don't copy, our subqueries) */
-  public Object clone() {
-    DisjunctionMaxQuery clone = (DisjunctionMaxQuery)super.clone();
-    clone.disjuncts = (ArrayList)this.disjuncts.clone();
-    return clone;
-  }
-
-
-  // inherit javadoc
-  public void extractTerms(Set terms) {
-      for (int i = 0; i < disjuncts.size(); i++) {
-          ((Query)disjuncts.get(i)).extractTerms(terms);
-      }
-  }
-
-
   /** Prettyprint us.
    * @param field the field to which we are applied
    * @return a string that shows what we do, of the form "(disjunct1 | disjunct2 | ... | disjunctn)^boost"
@@ -240,18 +151,16 @@
   public boolean equals(Object o) {
     if (! (o instanceof DisjunctionMaxQuery) ) return false;
     DisjunctionMaxQuery other = (DisjunctionMaxQuery)o;
-    return this.getBoost() == other.getBoost()
-            && this.tieBreakerMultiplier == other.tieBreakerMultiplier
-            && this.disjuncts.equals(other.disjuncts);
+    return this.tieBreakerMultiplier == other.tieBreakerMultiplier &&
+      super.equals(o);
   }
 
   /** Compute a hash code for hashing us
    * @return the hash code
    */
   public int hashCode() {
-    return Float.floatToIntBits(getBoost())
-            + Float.floatToIntBits(tieBreakerMultiplier)
-            + disjuncts.hashCode();
+    return Float.floatToIntBits(tieBreakerMultiplier) +
+      super.hashCode();
   }
 
 }
Index: src/java/org/apache/lucene/search/SubQueryScorer.java
===================================================================
--- src/java/org/apache/lucene/search/SubQueryScorer.java	(revision 509832)
+++ src/java/org/apache/lucene/search/SubQueryScorer.java	(working copy)
@@ -18,31 +18,25 @@
 
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.*;
 
 /**
- * The Scorer for DisjunctionMaxQuery's.  The union of all documents generated by the the subquery scorers
- * is generated in document number order.  The score for each document is the maximum of the scores computed
- * by the subquery scorers that generate that document, plus tieBreakerMultiplier times the sum of the scores
- * for the other subqueries that generate the document.
+ * Scorer that maintains a heap of sub scorers with the ability to easy iterate through scorers
+ * corresponding to the current document.
  * @author Chuck Williams
  */
-class DisjunctionMaxScorer extends Scorer {
+abstract class SubQueryScorer extends Scorer {
 
     /* The scorers for subqueries that have remaining docs, kept as a min heap by number of next doc. */
-    private ArrayList subScorers = new ArrayList();
+    protected ArrayList subScorers = new ArrayList();
 
-    /* Multiplier applied to non-maximum-scoring subqueries for a document as they are summed into the result. */
-    private float tieBreakerMultiplier;
+    protected boolean more = false;          // True iff there is a next document
+    protected boolean firstTime = true;      // True iff next() has not yet been called
 
-    private boolean more = false;          // True iff there is a next document
-    private boolean firstTime = true;      // True iff next() has not yet been called
-
-    /** Creates a new instance of DisjunctionMaxScorer
-     * @param tieBreakerMultiplier Multiplier applied to non-maximum-scoring subqueries for a document as they are summed into the result.
+    /** Creates a new instance of SubQueryScorer
      * @param similarity -- not used since our definition involves neither coord nor terms directly */
-    public DisjunctionMaxScorer(float tieBreakerMultiplier, Similarity similarity) {
+    public SubQueryScorer(Similarity similarity) {
         super(similarity);
-        this.tieBreakerMultiplier = tieBreakerMultiplier;
     }
 
     /** Add the scorer for a subquery
@@ -88,26 +82,83 @@
     /** Determine the current document score.  Initially invalid, until {@link #next()} is called the first time.
      * @return the score of the current generated document
      */
-    public float score() throws IOException {
-        int doc = ((Scorer) subScorers.get(0)).doc();
-        float[] sum = {((Scorer) subScorers.get(0)).score()}, max = {sum[0]};
-        int size = subScorers.size();
-        scoreAll(1, size, doc, sum, max);
-        scoreAll(2, size, doc, sum, max);
-        return max[0] + (sum[0] - max[0])*tieBreakerMultiplier;
+    public abstract float score() throws IOException;
+
+
+    /** Helper class */
+    protected class ScorerHeapIterator implements Iterator {
+      private List heap;
+      private LinkedList indices;
+      private int doc;
+      private int size;
+      public ScorerHeapIterator(ArrayList heap) {
+	this.heap = heap;
+	indices = new LinkedList();
+	size = heap.size();
+	if(!heap.isEmpty()) {
+	  indices.add(new Integer(0));
+	  doc = ((Scorer)heap.get(0)).doc();
+	} 
+      }
+      public boolean hasNext() {
+	return !indices.isEmpty();
+      }
+      public Object next() {
+	int idx = ((Integer)indices.removeFirst()).intValue();
+	Scorer cur = (Scorer)heap.get(idx);
+	int next;
+	next = (idx<<1)+1;
+	if(next < size && ((Scorer)heap.get(next)).doc() == doc)
+	  indices.add(new Integer(next));
+	next = (idx<<1)+2;
+	if(next < size && ((Scorer)heap.get(next)).doc() == doc)
+	  indices.add(new Integer(next));
+	return cur;
+      }
+      public void remove() {
+	throw new UnsupportedOperationException();
+      }      
     }
 
-    // Recursively iterate all subScorers that generated last doc computing sum and max
-    private void scoreAll(int root, int size, int doc, float[] sum, float[] max) throws IOException {
-        if (root<size && ((Scorer) subScorers.get(root)).doc() == doc) {
-            float sub = ((Scorer) subScorers.get(root)).score();
-            sum[0] += sub;
-            max[0] = Math.max(max[0], sub);
-            scoreAll((root<<1)+1, size, doc, sum, max);
-            scoreAll((root<<1)+2, size, doc, sum, max);
-        }
+    protected class SequentialScorerHeapIterator implements Iterator {
+      private List heap;
+      private int doc;
+      private int index;
+      private Scorer next;
+      public SequentialScorerHeapIterator(ArrayList heap) {
+	this.heap = heap;
+	int size = heap.size();
+	index = -1;
+	if(size > 0) {
+	  next = (Scorer)heap.get(0);
+	  index = 0;
+	  doc = next.doc();
+	}
+      }
+      public boolean hasNext() { 
+	return next != null;
+      }
+      public Object next() {
+	Scorer cur = next;
+	next = null;
+	while(++index < heap.size()) {
+	  next = (Scorer)heap.get(index);
+	  if(next.doc() != doc)
+	    next = null;
+	  else
+	    break;
+	}
+	return cur;
+      }
+      public void remove() { throw new UnsupportedOperationException(); }      
     }
 
+    protected Iterator currentScorers() throws IOException {
+      if(subScorers.size() <= 5) 
+	return new SequentialScorerHeapIterator(subScorers);
+      else
+	return new ScorerHeapIterator(subScorers);
+    }
     /** Advance to the first document beyond the current whose number is greater than or equal to target.
      * @param target the minimum number of the next desired document
      * @return true iff there is a document to be generated whose number is at least target
@@ -131,7 +182,7 @@
         return true;
     }
 
-    /** Explain a score that we computed.  UNSUPPORTED -- see explanation capability in DisjunctionMaxQuery.
+    /** Explain a score that we computed.  UNSUPPORTED -- see explanation capability in associated Query.
      * @param doc the number of a document we scored
      * @return the Explanation for our score
      */
@@ -140,7 +191,7 @@
     }
 
     // Organize subScorers into a min heap with scorers generating the earlest document on top.
-    private void heapify() {
+    protected void heapify() {
         int size = subScorers.size();
         for (int i=(size>>1)-1; i>=0; i--)
             heapAdjust(i);
@@ -149,7 +200,7 @@
     /* The subtree of subScorers at root is a min heap except possibly for its root element.
      * Bubble the root down as required to make the subtree a heap.
      */
-    private void heapAdjust(int root) {
+    protected void heapAdjust(int root) {
         Scorer scorer=(Scorer)subScorers.get(root);
         int doc=scorer.doc();
         int i=root, size=subScorers.size();
@@ -182,7 +233,7 @@
     }
 
     // Remove the root Scorer from subScorers and re-establish it as a heap
-    private void heapRemoveRoot() {
+    protected void heapRemoveRoot() {
         int size=subScorers.size();
         if (size==1)
             subScorers.remove(0);
@@ -193,4 +244,4 @@
         }
     }
 
-}
+}
\ No newline at end of file
Index: src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
===================================================================
--- src/java/org/apache/lucene/search/DisjunctionMaxScorer.java	(revision 509832)
+++ src/java/org/apache/lucene/search/DisjunctionMaxScorer.java	(working copy)
@@ -17,7 +17,7 @@
  */
 
 import java.io.IOException;
-import java.util.ArrayList;
+import java.util.Iterator;
 
 /**
  * The Scorer for DisjunctionMaxQuery's.  The union of all documents generated by the the subquery scorers
@@ -26,17 +26,12 @@
  * for the other subqueries that generate the document.
  * @author Chuck Williams
  */
-class DisjunctionMaxScorer extends Scorer {
+class DisjunctionMaxScorer extends SubQueryScorer {
 
-    /* The scorers for subqueries that have remaining docs, kept as a min heap by number of next doc. */
-    private ArrayList subScorers = new ArrayList();
 
     /* Multiplier applied to non-maximum-scoring subqueries for a document as they are summed into the result. */
     private float tieBreakerMultiplier;
 
-    private boolean more = false;          // True iff there is a next document
-    private boolean firstTime = true;      // True iff next() has not yet been called
-
     /** Creates a new instance of DisjunctionMaxScorer
      * @param tieBreakerMultiplier Multiplier applied to non-maximum-scoring subqueries for a document as they are summed into the result.
      * @param similarity -- not used since our definition involves neither coord nor terms directly */
@@ -45,152 +40,20 @@
         this.tieBreakerMultiplier = tieBreakerMultiplier;
     }
 
-    /** Add the scorer for a subquery
-     * @param scorer the scorer of a subquery of our associated DisjunctionMaxQuery
-     */
-    public void add(Scorer scorer) throws IOException {
-        if (scorer.next()) {       // Initialize and retain only if it produces docs
-            subScorers.add(scorer);
-            more = true;
-        }
-    }
 
-    /** Generate the next document matching our associated DisjunctionMaxQuery.
-     * @return true iff there is a next document
-     */
-    public boolean next() throws IOException {
-        if (!more) return false;
-        if (firstTime) {
-            heapify();
-            firstTime = false;
-            return true;   // more would have been false if no subScorers had any docs
-        }
-        // Increment all generators that generated the last doc and adjust the heap.
-        int lastdoc = ((Scorer) subScorers.get(0)).doc();
-        do {
-            if (((Scorer) subScorers.get(0)).next())
-                heapAdjust(0);
-            else {
-                heapRemoveRoot();
-                if (subScorers.isEmpty()) return (more = false);
-            }
-        } while ( ((Scorer) subScorers.get(0)).doc()==lastdoc );
-        return true;
-    }
-
-    /** Determine the current document number.  Initially invalid, until {@link #next()} is called the first time.
-     * @return the document number of the currently generated document
-     */
-    public int doc() {
-        return ((Scorer) subScorers.get(0)).doc();
-    }
-
     /** Determine the current document score.  Initially invalid, until {@link #next()} is called the first time.
      * @return the score of the current generated document
      */
     public float score() throws IOException {
-        int doc = ((Scorer) subScorers.get(0)).doc();
-        float[] sum = {((Scorer) subScorers.get(0)).score()}, max = {sum[0]};
-        int size = subScorers.size();
-        scoreAll(1, size, doc, sum, max);
-        scoreAll(2, size, doc, sum, max);
-        return max[0] + (sum[0] - max[0])*tieBreakerMultiplier;
+      float sum, max;
+      sum = max = 0.0f;
+      for(Iterator scorers = currentScorers(); scorers.hasNext(); ) {
+	float score = ((Scorer)scorers.next()).score();
+	sum += score;
+	max = Math.max(max, score);
+      }
+      return max + (sum - max)*tieBreakerMultiplier;
     }
 
-    // Recursively iterate all subScorers that generated last doc computing sum and max
-    private void scoreAll(int root, int size, int doc, float[] sum, float[] max) throws IOException {
-        if (root<size && ((Scorer) subScorers.get(root)).doc() == doc) {
-            float sub = ((Scorer) subScorers.get(root)).score();
-            sum[0] += sub;
-            max[0] = Math.max(max[0], sub);
-            scoreAll((root<<1)+1, size, doc, sum, max);
-            scoreAll((root<<1)+2, size, doc, sum, max);
-        }
-    }
 
-    /** Advance to the first document beyond the current whose number is greater than or equal to target.
-     * @param target the minimum number of the next desired document
-     * @return true iff there is a document to be generated whose number is at least target
-     */
-    public boolean skipTo(int target) throws IOException {
-        if (firstTime) {
-          if (!more) return false;
-          heapify();
-          firstTime = false;
-          return true;   // more would have been false if no subScorers had any docs
-        }
-
-        while (subScorers.size()>0 && ((Scorer)subScorers.get(0)).doc()<target) {
-            if (((Scorer)subScorers.get(0)).skipTo(target))
-                heapAdjust(0);
-            else
-                heapRemoveRoot();
-        }
-        if ((subScorers.size()==0))
-            return (more = false);
-        return true;
-    }
-
-    /** Explain a score that we computed.  UNSUPPORTED -- see explanation capability in DisjunctionMaxQuery.
-     * @param doc the number of a document we scored
-     * @return the Explanation for our score
-     */
-    public Explanation explain(int doc) throws IOException {
-        throw new UnsupportedOperationException();
-    }
-
-    // Organize subScorers into a min heap with scorers generating the earlest document on top.
-    private void heapify() {
-        int size = subScorers.size();
-        for (int i=(size>>1)-1; i>=0; i--)
-            heapAdjust(i);
-    }
-
-    /* The subtree of subScorers at root is a min heap except possibly for its root element.
-     * Bubble the root down as required to make the subtree a heap.
-     */
-    private void heapAdjust(int root) {
-        Scorer scorer=(Scorer)subScorers.get(root);
-        int doc=scorer.doc();
-        int i=root, size=subScorers.size();
-        while (i<=(size>>1)-1) {
-            int lchild=(i<<1)+1;
-            Scorer lscorer=(Scorer)subScorers.get(lchild);
-            int ldoc=lscorer.doc();
-            int rdoc=Integer.MAX_VALUE, rchild=(i<<1)+2;
-            Scorer rscorer=null;
-            if (rchild<size) {
-                rscorer=(Scorer)subScorers.get(rchild);
-                rdoc=rscorer.doc();
-            }
-            if (ldoc<doc) {
-                if (rdoc<ldoc) {
-                    subScorers.set(i, rscorer);
-                    subScorers.set(rchild, scorer);
-                    i=rchild;
-                } else {
-                    subScorers.set(i, lscorer);
-                    subScorers.set(lchild, scorer);
-                    i=lchild;
-                }
-            } else if (rdoc<doc) {
-                subScorers.set(i, rscorer);
-                subScorers.set(rchild, scorer);
-                i=rchild;
-            } else return;
-        }
-    }
-
-    // Remove the root Scorer from subScorers and re-establish it as a heap
-    private void heapRemoveRoot() {
-        int size=subScorers.size();
-        if (size==1)
-            subScorers.remove(0);
-        else {
-            subScorers.set(0, subScorers.get(size-1));
-            subScorers.remove(size-1);
-            heapAdjust(0);
-        }
-    }
-
 }
Index: src/java/org/apache/lucene/search/ProductQuery.java
===================================================================
--- src/java/org/apache/lucene/search/ProductQuery.java	(revision 0)
+++ src/java/org/apache/lucene/search/ProductQuery.java	(revision 0)
@@ -0,0 +1,102 @@
+package org.apache.lucene.search;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.search.*;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.Collection;
+import java.util.Set;
+
+/**
+ * A query that generates the union of documents produced by its subqueries, and that scores each document with the maximum
+ * score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries.
+ * This is useful when searching for a word in multiple fields with different boost factors (so that the fields cannot be
+ * combined equivalently into a single search field).  We want the primary score to be the one associated with the highest boost,
+ * not the sum of the field scores (as BooleanQuery would give).
+ * If the query is "albino elephant" this ensures that "albino" matching one field and "elephant" matching
+ * another gets a higher score than "albino" matching both fields.
+ * To get this result, use both BooleanQuery and ProductQuery:  for each term a ProductQuery searches for it in
+ * each field, while the set of these ProductQuery's is combined into a BooleanQuery.
+ * The tie breaker capability allows results that include the same term in multiple fields to be judged better than results that
+ * include this term in only the best of those multiple fields, without confusing this with the better case of two different terms
+ * in the multiple fields.
+ * @author Chuck Williams
+ */
+public class ProductQuery extends SubQueryQuery {
+
+
+  /** Creates a new empty ProductQuery.  Use add() to add the subqueries.
+   */
+  public ProductQuery() {
+    super();
+  }
+
+  protected SubQueryScorer createScorer(Searcher searcher) {
+    return new ProductScorer(getSimilarity(searcher));
+  }
+
+  protected String getDescription() {
+    return "product of";
+  }
+  protected float getExplainValue(float[] scores) {
+    float prod = 1.0f;
+    for(int i=0; i < scores.length; i++) {
+      prod *= scores[i];
+    }
+    return prod;
+  }
+  protected float squaredWeight(float[] weights) {
+    float max = 0.0f, sum = 0.0f;
+    for(int i=0; i < weights.length; i++) {
+      sum += weights[i];
+      max = Math.max(max, weights[i]);
+    }
+    return sum;
+  }
+
+  /** Prettyprint us.
+   * @param field the field to which we are applied
+   * @return a string that shows what we do, of the form "(disjunct1 | disjunct2 | ... | disjunctn)^boost"
+   */
+  public String toString(String field) {
+    StringBuffer buffer = new StringBuffer();
+    buffer.append("(");
+    for (int i = 0 ; i < disjuncts.size(); i++) {
+      Query subquery = (Query) disjuncts.get(i);
+      if (subquery instanceof BooleanQuery) {   // wrap sub-bools in parens
+        buffer.append("(");
+        buffer.append(subquery.toString(field));
+        buffer.append(")");
+      }
+      else buffer.append(subquery.toString(field));
+      if (i != disjuncts.size()-1) buffer.append(" * ");
+    }
+    buffer.append(")");
+    if (getBoost() != 1.0) {
+      buffer.append("^");
+      buffer.append(getBoost());
+    }
+    return buffer.toString();
+  }
+
+  /** Return true iff we represent the same query as o
+   * @param o another object
+   * @return true iff o is a ProductQuery with the same boost and the same subqueries, in the same order, as us
+   */
+//   public boolean equals(Object o) {
+//     if (! (o instanceof ProductQuery) ) return false;
+//     ProductQuery other = (ProductQuery)o;
+//     return this.tieBreakerMultiplier == other.tieBreakerMultiplier &&
+//       super.equals(o);
+//   }
+
+//   /** Compute a hash code for hashing us
+//    * @return the hash code
+//    */
+//   public int hashCode() {
+//     return Float.floatToIntBits(tieBreakerMultiplier) +
+//       super.hashCode();
+//   }
+
+}

Property changes on: src/java/org/apache/lucene/search/ProductQuery.java
___________________________________________________________________
Name: svn:eol-style
   + native

Index: src/java/org/apache/lucene/search/ProductScorer.java
===================================================================
--- src/java/org/apache/lucene/search/ProductScorer.java	(revision 0)
+++ src/java/org/apache/lucene/search/ProductScorer.java	(revision 0)
@@ -0,0 +1,61 @@
+package org.apache.lucene.search;
+
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.IOException;
+import java.util.Iterator;
+
+import org.apache.lucene.search.*;
+
+
+/**
+ * The Scorer for DisjunctionMaxQuery's.  The union of all documents generated by the the subquery scorers
+ * is generated in document number order.  The score for each document is the maximum of the scores computed
+ * by the subquery scorers that generate that document, plus tieBreakerMultiplier times the sum of the scores
+ * for the other subqueries that generate the document.
+ * @author Chuck Williams
+ */
+class ProductScorer extends SubQueryScorer {
+
+    /** Creates a new instance of ProductScorer
+     * @param tieBreakerMultiplier Multiplier applied to non-maximum-scoring subqueries for a document as they are summed into the result.
+     * @param similarity -- not used since our definition involves neither coord nor terms directly */
+    public ProductScorer(Similarity similarity) {
+        super(similarity);
+    }
+
+
+    /** Determine the current document score.  Initially invalid, until {@link #next()} is called the first time.
+     * @return the score of the current generated document
+     */
+    public float score() throws IOException {
+      int count = 0;
+      float prod;
+      prod = 1.0f;
+      for(Iterator scorers = currentScorers(); scorers.hasNext(); ) {
+	float score = ((Scorer)scorers.next()).score();
+	prod *= score;
+        count += 1;
+      }
+      // require matches from all subscorers
+      if (count < subScorers.size())
+        prod = 0;
+      return prod;
+    }
+
+
+}

Property changes on: src/java/org/apache/lucene/search/ProductScorer.java
___________________________________________________________________
Name: svn:eol-style
   + native

