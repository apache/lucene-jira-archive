diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilter.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilter.java
index e59e61bf72..75f8da4ac9 100644
--- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilter.java
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilter.java
@@ -26,6 +26,7 @@ import org.apache.lucene.analysis.TokenFilter;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.core.FlattenGraphFilter;
 import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
+import org.apache.lucene.analysis.tokenattributes.KeywordAttribute;
 import org.apache.lucene.analysis.tokenattributes.OffsetAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;
 import org.apache.lucene.analysis.tokenattributes.PositionLengthAttribute;
@@ -83,6 +84,7 @@ public final class SynonymGraphFilter extends TokenFilter {
   public static final String TYPE_SYNONYM = "SYNONYM";
 
   private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);
+  private final KeywordAttribute keywordAttr = addAttribute(KeywordAttribute.class);
   private final PositionIncrementAttribute posIncrAtt = addAttribute(PositionIncrementAttribute.class);
   private final PositionLengthAttribute posLenAtt = addAttribute(PositionLengthAttribute.class);
   private final TypeAttribute typeAtt = addAttribute(TypeAttribute.class);
@@ -90,6 +92,7 @@ public final class SynonymGraphFilter extends TokenFilter {
 
   private final SynonymMap synonyms;
   private final boolean ignoreCase;
+  private final boolean skipKeywords;
 
   private final FST<BytesRef> fst;
 
@@ -169,6 +172,9 @@ public final class SynonymGraphFilter extends TokenFilter {
    *                   the input entries when you create the {@link SynonymMap}
    */
   public SynonymGraphFilter(TokenStream input, SynonymMap synonyms, boolean ignoreCase) {
+    this(input, synonyms, ignoreCase, false);
+  }
+  public SynonymGraphFilter(TokenStream input, SynonymMap synonyms, boolean ignoreCase, boolean skipKeywords) {
     super(input);
     this.synonyms = synonyms;
     this.fst = synonyms.fst;
@@ -178,12 +184,13 @@ public final class SynonymGraphFilter extends TokenFilter {
     this.fstReader = fst.getBytesReader();
     scratchArc = new FST.Arc<>();
     this.ignoreCase = ignoreCase;
+    this.skipKeywords = skipKeywords;
   }
 
   @Override
   public boolean incrementToken() throws IOException {
     //System.out.println("\nS: incrToken lastNodeOut=" + lastNodeOut + " nextNodeOut=" + nextNodeOut);
-
+    
     assert lastNodeOut <= nextNodeOut;
       
     if (outputBuffer.isEmpty() == false) {
@@ -249,25 +256,27 @@ public final class SynonymGraphFilter extends TokenFilter {
 
   private void releaseBufferedToken() throws IOException {
     //System.out.println("  releaseBufferedToken");
-
     BufferedOutputToken token = outputBuffer.pollFirst();
-
+    
     if (token.state != null) {
       // This is an original input token (keepOrig=true case):
       //System.out.println("    hasState");
       restoreState(token.state);
       //System.out.println("    startOffset=" + offsetAtt.startOffset() + " endOffset=" + offsetAtt.endOffset());
     } else {
-      clearAttributes();
-      //System.out.println("    no state");
-      termAtt.append(token.term);
-
-      // We better have a match already:
-      assert matchStartOffset != -1;
-
-      offsetAtt.setOffset(matchStartOffset, matchEndOffset);
-      //System.out.println("    startOffset=" + matchStartOffset + " endOffset=" + matchEndOffset);
-      typeAtt.setType(TYPE_SYNONYM);
+      if (!(skipKeywords && keywordAttr.isKeyword())) {
+        clearAttributes();
+        
+        //System.out.println("    no state");
+        termAtt.append(token.term);
+
+        // We better have a match already:
+        assert matchStartOffset != -1;
+
+        offsetAtt.setOffset(matchStartOffset, matchEndOffset);
+        //System.out.println("    startOffset=" + matchStartOffset + " endOffset=" + matchEndOffset);
+        typeAtt.setType(TYPE_SYNONYM);
+      }
     }
 
     //System.out.println("    lastNodeOut=" + lastNodeOut);
diff --git a/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilterFactory.java b/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilterFactory.java
index 4fe68bc3cd..a0ef3e8f3a 100644
--- a/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilterFactory.java
+++ b/lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymGraphFilterFactory.java
@@ -67,6 +67,7 @@ import org.apache.lucene.analysis.util.TokenizerFactory;
  * A custom {@link SynonymMap.Parser} is expected to have a constructor taking:
  * <ul>
  *   <li><code>boolean dedup</code> - true if duplicates should be ignored, false otherwise</li>
+*    <li><code>boolean skipKeywords</code> - true if keywords should be skipped</li>
  *   <li><code>boolean expand</code> - true if conflation groups should be expanded, false if they are one-directional</li>
  *   <li><code>{@link Analyzer} analyzer</code> - an analyzer used for each raw synonym</li>
  * </ul>
@@ -80,6 +81,7 @@ public class SynonymGraphFilterFactory extends TokenFilterFactory implements Res
   private final String tokenizerFactory;
   private final String synonyms;
   private final String format;
+  private final boolean skipKeywords;
   private final boolean expand;
   private final String analyzerName;
   private final Map<String, String> tokArgs = new HashMap<>();
@@ -91,6 +93,7 @@ public class SynonymGraphFilterFactory extends TokenFilterFactory implements Res
     ignoreCase = getBoolean(args, "ignoreCase", false);
     synonyms = require(args, "synonyms");
     format = get(args, "format");
+    skipKeywords = getBoolean(args, "skipKeywords", false);
     expand = getBoolean(args, "expand", true);
 
     analyzerName = get(args, "analyzer");
@@ -117,7 +120,7 @@ public class SynonymGraphFilterFactory extends TokenFilterFactory implements Res
   public TokenStream create(TokenStream input) {
     // if the fst is null, it means there's actually no synonyms... just return the original stream
     // as there is nothing to do here.
-    return map.fst == null ? input : new SynonymGraphFilter(input, map, ignoreCase);
+    return map.fst == null ? input : new SynonymGraphFilter(input, map, ignoreCase, skipKeywords);
   }
 
   @Override
diff --git a/lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymGraphFilter.java b/lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymGraphFilter.java
index 730d00ac0a..d1d55ba228 100644
--- a/lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymGraphFilter.java
+++ b/lucene/analysis/common/src/test/org/apache/lucene/analysis/synonym/TestSynonymGraphFilter.java
@@ -34,6 +34,7 @@ import org.apache.lucene.analysis.MockTokenizer;
 import org.apache.lucene.analysis.TokenStream;
 import org.apache.lucene.analysis.Tokenizer;
 import org.apache.lucene.analysis.core.FlattenGraphFilter;
+import org.apache.lucene.analysis.miscellaneous.KeywordRepeatFilter;
 import org.apache.lucene.analysis.tokenattributes.*;
 import org.apache.lucene.document.Document;
 import org.apache.lucene.document.Field;
@@ -62,6 +63,7 @@ public class TestSynonymGraphFilter extends BaseTokenStreamTestCase {
   /** Set as a side effect by {@link #getAnalyzer} and {@link #getFlattenAnalyzer}. */
   private SynonymGraphFilter synFilter;
   private FlattenGraphFilter flattenFilter;
+  private KeywordRepeatFilter keywordRepeatFilter;
 
   public void testBasicKeepOrigOneOutput() throws Exception {
     SynonymMap.Builder b = new SynonymMap.Builder();
@@ -438,6 +440,32 @@ public class TestSynonymGraphFilter extends BaseTokenStreamTestCase {
     a.close();
   }
 
+  public void testSkipKeywords() throws Exception {
+    SynonymMap.Builder b = new SynonymMap.Builder();
+    add(b, "ab", "xy", false);
+    Analyzer a = getKeywordAnalyzer(b, false);
+    assertAnalyzesTo(a,
+                     "ab",
+                     new String[] {"xy", "xy"},
+                     new int[]    { 0,   0},
+                     new int[]    { 2,   2},
+                     new String[] {"SYNONYM", "SYNONYM"},
+                     new int[]    { 1,   1},
+                     new int[]    { 1,   1});
+    a.close();
+    
+    a = getKeywordAnalyzer(b, true);
+    assertAnalyzesTo(a,
+                     "ab",
+                     new String[] {"ab", "xy"},
+                     new int[]    { 0,   0},
+                     new int[]    { 2,   2},
+                     new String[] {"word", "SYNONYM"},
+                     new int[]    { 1,   1},
+                     new int[]    { 1,   1});
+    a.close();
+  }
+  
   public void testIgnoreCase() throws Exception {
     SynonymMap.Builder b = new SynonymMap.Builder();
     add(b, "a b", "x y", false);
@@ -1295,6 +1323,22 @@ public class TestSynonymGraphFilter extends BaseTokenStreamTestCase {
         }
       };
   }
+  
+  private Analyzer getKeywordAnalyzer(SynonymMap.Builder b, boolean ignoreKeywords) throws IOException {
+    final SynonymMap map = b.build();
+    return new Analyzer() {
+        @Override
+        protected TokenStreamComponents createComponents(String fieldName) {
+          Tokenizer tokenizer = new MockTokenizer(MockTokenizer.WHITESPACE, true);
+          // Make a local variable so testRandomHuge doesn't share it across threads!
+          KeywordRepeatFilter keywordRepeatFilter = new KeywordRepeatFilter(tokenizer);
+          SynonymGraphFilter synFilter = new SynonymGraphFilter(keywordRepeatFilter, map, true, ignoreKeywords);
+          
+          return new TokenStreamComponents(tokenizer, synFilter);
+        }
+      };
+  }
+
 
   private void add(SynonymMap.Builder b, String input, String output, boolean keepOrig) {
     if (VERBOSE) {
