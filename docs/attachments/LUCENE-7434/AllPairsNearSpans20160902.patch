diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/AllPairsNearSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/AllPairsNearSpans.java
new file mode 100644
index 0000000..0c63570
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/AllPairsNearSpans.java
@@ -0,0 +1,161 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search.spans;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.lucene.search.DisiWrapper;
+
+class AllPairsNearSpans extends DisjunctionSpans {
+  final int allowedSlop;
+  protected Spans subTopPositionSpans;
+
+  AllPairsNearSpans(AllPairsSpanNearQuery allPairsNearQuery, int allowedSlop, List<Spans> subSpans) {
+    super(allPairsNearQuery, subSpans);
+    assert subSpans.size() >= 2; // at least one pair needed
+    this.allowedSlop = allowedSlop;
+  }
+
+  @Override
+  public int nextDoc() throws IOException { // at least to subSpans should match the doc
+    if (super.nextDoc() == NO_MORE_DOCS) {
+      return NO_MORE_DOCS;
+    }
+    return toTwoDocs();
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    if (super.advance(target) == NO_MORE_DOCS) {
+      return NO_MORE_DOCS;
+    }
+    return toTwoDocs();
+  }
+
+  int currentStartPos = -1;
+  int currentEndPos = -1;
+  int currentWidth = -1;
+  boolean atFirstInCurrentDoc = false;
+
+  private int toTwoDocs() throws IOException {
+    currentStartPos = -1;
+    currentEndPos = -1;
+    currentWidth = -1;
+    do {
+      DisiWrapper topDocSpans = byDocQueue.top();
+      if (topDocSpans.next == null) { // only one subSpans at current doc
+        if (super.nextDoc() == NO_MORE_DOCS) {
+          return NO_MORE_DOCS;
+        }
+      } else { // at least two subSpans at current doc
+        if (topDocSpans.doc == topDocSpans.next.doc) {
+          return topDocSpans.doc;
+        }
+        assert topDocSpans.next.doc > topDocSpans.doc;
+        assert topDocSpans.next.doc != NO_MORE_DOCS;
+        if (super.advance(topDocSpans.next.doc) == NO_MORE_DOCS) {
+          assert false : "failed to advance to doc " + topDocSpans.next.doc;
+        }
+      }
+    } while (true);
+  }
+
+  @Override
+  boolean twoPhaseCurrentDocMatches() throws IOException {
+    DisiWrapper listAtCurrentDoc = byDocQueue.topList();
+    assert listAtCurrentDoc.next != null; // at least two subSpans are available at current doc.
+
+    // only match with at least two matching DisiWrappers at current doc.
+    int nrMatchingAtCurrentDoc = 0;
+    // remove the head of the list as long as it does not match.
+    final int currentDoc = listAtCurrentDoc.doc;
+    while (listAtCurrentDoc.twoPhaseView != null) {
+      if (listAtCurrentDoc.twoPhaseView.matches()) {
+        // use this spans for positions at current doc:
+        listAtCurrentDoc.lastApproxMatchDoc = currentDoc;
+        nrMatchingAtCurrentDoc++;
+        if (nrMatchingAtCurrentDoc == 2) {
+          break;
+        }
+      } else { // do not use this spans for positions at current doc:
+        listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;
+      }
+      listAtCurrentDoc = listAtCurrentDoc.next;
+      if (listAtCurrentDoc == null) {
+        return false;
+      }
+    }
+    lastDocTwoPhaseMatched = currentDoc;
+    topPositionSpans = null;
+    return true;
+    // NOCOMMIT: check for presence of matching slop
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    if (topPositionSpans == null) {
+      byPositionQueue.clear();
+      fillPositionQueue(); // fills byPositionQueue at first position
+      topPositionSpans = byPositionQueue.top();
+    }
+    return toMatchingSlop();
+  }
+
+  int toMatchingSlop() throws IOException { // return the start position of the next pair with matching slop
+    assert topPositionSpans != null;
+    do {
+      int prevTopStartPos;
+      int prevTopEndPos;
+      Spans prevTopPositionSpans = topPositionSpans;
+      do {
+        prevTopStartPos = topPositionSpans.startPosition();
+        prevTopEndPos = topPositionSpans.endPosition();
+        topPositionSpans.nextStartPosition();
+        topPositionSpans = byPositionQueue.updateTop();
+        if (topPositionSpans.startPosition() == NO_MORE_POSITIONS) {
+          currentEndPos = NO_MORE_POSITIONS;
+          return currentStartPos = NO_MORE_POSITIONS;
+        }
+      } while (prevTopPositionSpans == topPositionSpans);
+      assert topPositionSpans != null;
+      // topPositionSpans just changed, this and prevTopPositionSpans form the current pair
+      int slop = topPositionSpans.startPosition() - prevTopEndPos;
+      if (slop <= allowedSlop) {
+        currentWidth = 1 + Integer.max(slop, 0);
+        currentEndPos = Integer.max(topPositionSpans.endPosition(), prevTopEndPos);
+        return currentStartPos = prevTopStartPos;
+      }
+    } while(true);
+  }
+
+  @Override
+  public int startPosition() {
+    return currentStartPos;
+  }
+
+  @Override
+  public int endPosition() {
+    return currentEndPos;
+  }
+
+  @Override
+  public int width() {
+    return currentWidth;
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/AllPairsSpanNearQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/AllPairsSpanNearQuery.java
new file mode 100644
index 0000000..301bc70
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/AllPairsSpanNearQuery.java
@@ -0,0 +1,242 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search.spans;
+
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.LeafReaderContext;
+import org.apache.lucene.index.Term;
+import org.apache.lucene.index.TermContext;
+import org.apache.lucene.index.Terms;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.search.Query;
+
+/** For a group of spans behave as a SpanOr over unordered SpanNear queries for all pairs.
+ * These SpanNearQueries are not ordered and have no gaps.
+ * <br>Evaluating the Spans of this Query is about twice as expensive as evaluating a SpanOr,
+ * so it is preferable to only do this for reranking a limited number of (otherwise high ranking) results.
+ */
+public class AllPairsSpanNearQuery extends SpanQuery implements Cloneable {
+
+  /**
+   * A builder for SpanNearQueries
+   */
+  public static class Builder {
+    private final String field;
+    private final List<SpanQuery> clauses = new LinkedList<>();
+    private int slop;
+
+    /**
+     * Construct a new builder
+     * @param field the field to search in, must be non null
+     */
+    public Builder(String field) {
+      this.field = Objects.requireNonNull(field);
+    }
+
+    /**
+     * Add a new clause
+     */
+    public Builder addClause(SpanQuery clause) {
+      if (Objects.equals(clause.getField(), field) == false)
+        throw new IllegalArgumentException("Cannot add clause " + clause + " to AllPairsSpanNearQuery for field " + field);
+      this.clauses.add(clause);
+      return this;
+    }
+
+    /**
+     * Set the slop for this query
+     */
+    public Builder setSlop(int slop) {
+      this.slop = slop;
+      return this;
+    }
+
+    /**
+     * Build the query
+     */
+    public AllPairsSpanNearQuery build() {
+      return new AllPairsSpanNearQuery(clauses.toArray(new SpanQuery[clauses.size()]), slop);
+    }
+
+  }
+
+  /**
+   * Returns a {@link Builder} for an all pairs span near query on a particular field.
+   */
+  public static Builder newAllPairsNearQuery(String field) {
+    return new Builder(field);
+  }
+
+  protected List<SpanQuery> clauses;
+  protected String field;
+  protected int slop;
+
+  /** Construct an AllPairsSpanNearQuery.
+   * Matches spans from unordered SpanNear queries for all pairs of input spans,
+   * with up to <code>slop</code> total unmatched positions between them.
+   * @param clausesIn the clauses to find near each other, in the same field, at least 2.
+   * @param slop The slop value
+   */
+  public AllPairsSpanNearQuery(SpanQuery[] clausesIn, int slop) {
+    this.clauses = new ArrayList<>(clausesIn.length);
+    for (SpanQuery clause : clausesIn) {
+      if (this.field == null) {                               // check field
+        this.field = clause.getField();
+      } else if (clause.getField() != null && !clause.getField().equals(field)) {
+        throw new IllegalArgumentException("Clauses must have same field.");
+      }
+      this.clauses.add(clause);
+    }
+    this.slop = slop;
+  }
+
+  /** Return the clauses whose spans are matched. */
+  public SpanQuery[] getClauses() {
+    return clauses.toArray(new SpanQuery[clauses.size()]);
+  }
+
+  /** Return the maximum number of intervening unmatched positions permitted.*/
+  public int getSlop() { return slop; }
+
+  @Override
+  public String getField() { return field; }
+
+  @Override
+  public String toString(String field) {
+    StringBuilder buffer = new StringBuilder();
+    buffer.append("allPairsSpanNear([");
+    Iterator<SpanQuery> i = clauses.iterator();
+    while (i.hasNext()) {
+      SpanQuery clause = i.next();
+      buffer.append(clause.toString(field));
+      if (i.hasNext()) {
+        buffer.append(", ");
+      }
+    }
+    buffer.append("], ");
+    buffer.append(slop);
+    buffer.append(")");
+    return buffer.toString();
+  }
+
+  @Override
+  public SpanWeight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
+    List<SpanWeight> subWeights = new ArrayList<>();
+    for (SpanQuery q : clauses) {
+      subWeights.add(q.createWeight(searcher, false));
+    }
+    return new AllPairsSpanNearWeight(subWeights, searcher, needsScores ? getTermContexts(subWeights) : null);
+  }
+
+  public class AllPairsSpanNearWeight extends SpanWeight {
+
+    final List<SpanWeight> subWeights;
+
+    public AllPairsSpanNearWeight(List<SpanWeight> subWeights, IndexSearcher searcher, Map<Term, TermContext> terms) throws IOException {
+      super(AllPairsSpanNearQuery.this, searcher, terms);
+      this.subWeights = subWeights;
+    }
+
+    @Override
+    public void extractTermContexts(Map<Term, TermContext> contexts) {
+      for (SpanWeight w : subWeights) {
+        w.extractTermContexts(contexts);
+      }
+    }
+
+    @Override
+    public Spans getSpans(final LeafReaderContext context, Postings requiredPostings) throws IOException {
+
+      Terms terms = context.reader().terms(field);
+      if (terms == null) {
+        return null; // field does not exist
+      }
+
+      ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());
+      for (SpanWeight w : subWeights) {
+        Spans subSpan = w.getSpans(context, requiredPostings);
+        if (subSpan != null) {
+          subSpans.add(subSpan);
+        }
+      }
+
+      if (subSpans.size() < 2) {
+        return null; // at least one pair needed
+      }
+
+      return new AllPairsNearSpans(AllPairsSpanNearQuery.this, slop, subSpans);
+    }
+
+    @Override
+    public void extractTerms(Set<Term> terms) {
+      for (SpanWeight w : subWeights) {
+        w.extractTerms(terms);
+      }
+    }
+  }
+
+  @Override
+  public Query rewrite(IndexReader reader) throws IOException {
+    boolean actuallyRewritten = false;
+    List<SpanQuery> rewrittenClauses = new ArrayList<>();
+    for (int i = 0 ; i < clauses.size(); i++) {
+      SpanQuery c = clauses.get(i);
+      SpanQuery query = (SpanQuery) c.rewrite(reader);
+      actuallyRewritten |= query != c;
+      rewrittenClauses.add(query);
+    }
+    if (actuallyRewritten) {
+      try {
+        AllPairsSpanNearQuery rewritten = (AllPairsSpanNearQuery) clone();
+        rewritten.clauses = rewrittenClauses;
+        return rewritten;
+      } catch (CloneNotSupportedException e) {
+        throw new AssertionError(e);
+      }
+    }
+    return super.rewrite(reader);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    return sameClassAs(other) &&
+           equalsTo(getClass().cast(other));
+  }
+
+  private boolean equalsTo(AllPairsSpanNearQuery other) {
+    return slop == other.slop &&
+           clauses.equals(other.clauses);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = classHash();
+    result ^= clauses.hashCode();
+    return result * 17 + slop;
+  }
+
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/DisjunctionSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/DisjunctionSpans.java
new file mode 100644
index 0000000..ba030ab
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/DisjunctionSpans.java
@@ -0,0 +1,236 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.search.spans;
+
+import java.io.IOException;
+import java.util.List;
+
+import org.apache.lucene.search.DisiPriorityQueue;
+import org.apache.lucene.search.DisiWrapper;
+import org.apache.lucene.search.TwoPhaseIterator;
+import org.apache.lucene.search.DisjunctionDISIApproximation;
+
+
+class DisjunctionSpans extends Spans {
+  protected final SpanQuery spanQuery;
+  protected final List<Spans> subSpans;
+  protected final DisiPriorityQueue byDocQueue;
+  protected final SpanPositionQueue byPositionQueue;
+  protected Spans topPositionSpans;
+
+  DisjunctionSpans(SpanQuery spanQuery, List<Spans> subSpans) {
+    this.spanQuery = spanQuery; // for toString() only
+    this.subSpans = subSpans;
+    byDocQueue = new DisiPriorityQueue(subSpans.size());
+    for (Spans spans : subSpans) {
+      byDocQueue.add(new DisiWrapper(spans));
+    }
+    byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1
+    topPositionSpans = null;
+  }
+
+  @Override
+  public int nextDoc() throws IOException {
+    topPositionSpans = null;
+    DisiWrapper topDocSpans = byDocQueue.top();
+    int currentDoc = topDocSpans.doc;
+    do {
+      topDocSpans.doc = topDocSpans.iterator.nextDoc();
+      topDocSpans = byDocQueue.updateTop();
+    } while (topDocSpans.doc == currentDoc);
+    return topDocSpans.doc;
+  }
+
+  @Override
+  public int advance(int target) throws IOException {
+    topPositionSpans = null;
+    DisiWrapper topDocSpans = byDocQueue.top();
+    do {
+      topDocSpans.doc = topDocSpans.iterator.advance(target);
+      topDocSpans = byDocQueue.updateTop();
+    } while (topDocSpans.doc < target);
+    return topDocSpans.doc;
+  }
+
+  @Override
+  public int docID() {
+    DisiWrapper topDocSpans = byDocQueue.top();
+    return topDocSpans.doc;
+  }
+
+  @Override
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    float sumMatchCost = 0; // See also DisjunctionScorer.asTwoPhaseIterator()
+    long sumApproxCost = 0;
+
+    for (DisiWrapper w : byDocQueue) {
+      if (w.twoPhaseView != null) {
+        long costWeight = (w.cost <= 1) ? 1 : w.cost;
+        sumMatchCost += w.twoPhaseView.matchCost() * costWeight;
+        sumApproxCost += costWeight;
+      }
+    }
+
+    if (sumApproxCost == 0) { // no sub spans supports approximations
+      computePositionsCost();
+      return null;
+    }
+
+    final float matchCost = sumMatchCost / sumApproxCost;
+
+    return new TwoPhaseIterator(new DisjunctionDISIApproximation(byDocQueue)) {
+      @Override
+      public boolean matches() throws IOException {
+        return twoPhaseCurrentDocMatches();
+      }
+
+      @Override
+      public float matchCost() {
+        return matchCost;
+      }
+    };
+  }
+
+  float positionsCost = -1;
+
+  void computePositionsCost() {
+    float sumPositionsCost = 0;
+    long sumCost = 0;
+    for (DisiWrapper w : byDocQueue) {
+      long costWeight = (w.cost <= 1) ? 1 : w.cost;
+      sumPositionsCost += w.spans.positionsCost() * costWeight;
+      sumCost += costWeight;
+    }
+    positionsCost = sumPositionsCost / sumCost;
+  }
+
+  @Override
+  public float positionsCost() {
+    // This may be called when asTwoPhaseIterator returned null,
+    // which happens when none of the sub spans supports approximations.
+    assert positionsCost > 0;
+    return positionsCost;
+  }
+
+  int lastDocTwoPhaseMatched = -1;
+
+  boolean twoPhaseCurrentDocMatches() throws IOException {
+    DisiWrapper listAtCurrentDoc = byDocQueue.topList();
+    // remove the head of the list as long as it does not match
+    final int currentDoc = listAtCurrentDoc.doc;
+    while (listAtCurrentDoc.twoPhaseView != null) {
+      if (listAtCurrentDoc.twoPhaseView.matches()) {
+        // use this spans for positions at current doc:
+        listAtCurrentDoc.lastApproxMatchDoc = currentDoc;
+        break;
+      }
+      // do not use this spans for positions at current doc:
+      listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;
+      listAtCurrentDoc = listAtCurrentDoc.next;
+      if (listAtCurrentDoc == null) {
+        return false;
+      }
+    }
+    lastDocTwoPhaseMatched = currentDoc;
+    topPositionSpans = null;
+    return true;
+  }
+
+  void fillPositionQueue() throws IOException { // called at first nextStartPosition
+    assert byPositionQueue.size() == 0;
+    // add all matching Spans at current doc to byPositionQueue
+    DisiWrapper listAtCurrentDoc = byDocQueue.topList();
+    while (listAtCurrentDoc != null) {
+      Spans spansAtDoc = listAtCurrentDoc.spans;
+      if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation
+        if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation
+          if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false
+            spansAtDoc = null;
+          } else {
+            if (listAtCurrentDoc.lastApproxMatchDoc != listAtCurrentDoc.doc) {
+              if (!listAtCurrentDoc.twoPhaseView.matches()) {
+                spansAtDoc = null;
+              }
+            }
+          }
+        }
+      }
+
+      if (spansAtDoc != null) {
+        assert spansAtDoc.docID() == listAtCurrentDoc.doc;
+        assert spansAtDoc.startPosition() == -1;
+        spansAtDoc.nextStartPosition();
+        assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;
+        byPositionQueue.add(spansAtDoc);
+      }
+      listAtCurrentDoc = listAtCurrentDoc.next;
+    }
+    assert byPositionQueue.size() > 0;
+  }
+
+  @Override
+  public int nextStartPosition() throws IOException {
+    if (topPositionSpans == null) {
+      byPositionQueue.clear();
+      fillPositionQueue(); // fills byPositionQueue at first position
+      topPositionSpans = byPositionQueue.top();
+    } else {
+      topPositionSpans.nextStartPosition();
+      topPositionSpans = byPositionQueue.updateTop();
+    }
+    return topPositionSpans.startPosition();
+  }
+
+  @Override
+  public int startPosition() {
+    return topPositionSpans == null ? -1 : topPositionSpans.startPosition();
+  }
+
+  @Override
+  public int endPosition() {
+    return topPositionSpans == null ? -1 : topPositionSpans.endPosition();
+  }
+
+  @Override
+  public int width() {
+    return topPositionSpans.width();
+  }
+
+  @Override
+  public void collect(SpanCollector collector) throws IOException {
+    if (topPositionSpans != null)
+      topPositionSpans.collect(collector);
+  }
+
+  @Override
+  public String toString() {
+    return "spanQuery(" + spanQuery + ")@" + docID() + ": " + startPosition() + " - " + endPosition();
+  }
+
+  long cost = -1;
+
+  @Override
+  public long cost() {
+    if (cost == -1) {
+      cost = 0;
+      for (Spans spans : subSpans) {
+        cost += spans.cost();
+      }
+    }
+    return cost;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
index 15abc7d..ff68214 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
@@ -16,7 +16,6 @@
  */
 package org.apache.lucene.search.spans;
 
-
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
@@ -28,12 +27,8 @@ import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.LeafReaderContext;
 import org.apache.lucene.index.Term;
 import org.apache.lucene.index.TermContext;
-import org.apache.lucene.search.DisiPriorityQueue;
-import org.apache.lucene.search.DisiWrapper;
-import org.apache.lucene.search.DisjunctionDISIApproximation;
 import org.apache.lucene.search.IndexSearcher;
 import org.apache.lucene.search.Query;
-import org.apache.lucene.search.TwoPhaseIterator;
 
 
 /** Matches the union of its clauses.
@@ -164,209 +159,8 @@ public final class SpanOrQuery extends SpanQuery {
         return subSpans.get(0);
       }
 
-      DisiPriorityQueue byDocQueue = new DisiPriorityQueue(subSpans.size());
-      for (Spans spans : subSpans) {
-        byDocQueue.add(new DisiWrapper(spans));
-      }
-
-      SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1
-
-      return new Spans() {
-        Spans topPositionSpans = null;
-
-        @Override
-        public int nextDoc() throws IOException {
-          topPositionSpans = null;
-          DisiWrapper topDocSpans = byDocQueue.top();
-          int currentDoc = topDocSpans.doc;
-          do {
-            topDocSpans.doc = topDocSpans.iterator.nextDoc();
-            topDocSpans = byDocQueue.updateTop();
-          } while (topDocSpans.doc == currentDoc);
-          return topDocSpans.doc;
-        }
-
-        @Override
-        public int advance(int target) throws IOException {
-          topPositionSpans = null;
-          DisiWrapper topDocSpans = byDocQueue.top();
-          do {
-            topDocSpans.doc = topDocSpans.iterator.advance(target);
-            topDocSpans = byDocQueue.updateTop();
-          } while (topDocSpans.doc < target);
-          return topDocSpans.doc;
-        }
-
-        @Override
-        public int docID() {
-          DisiWrapper topDocSpans = byDocQueue.top();
-          return topDocSpans.doc;
-        }
-
-        @Override
-        public TwoPhaseIterator asTwoPhaseIterator() {
-          float sumMatchCost = 0; // See also DisjunctionScorer.asTwoPhaseIterator()
-          long sumApproxCost = 0;
-
-          for (DisiWrapper w : byDocQueue) {
-            if (w.twoPhaseView != null) {
-              long costWeight = (w.cost <= 1) ? 1 : w.cost;
-              sumMatchCost += w.twoPhaseView.matchCost() * costWeight;
-              sumApproxCost += costWeight;
-            }
-          }
-
-          if (sumApproxCost == 0) { // no sub spans supports approximations
-            computePositionsCost();
-            return null;
-          }
-
-          final float matchCost = sumMatchCost / sumApproxCost;
-
-          return new TwoPhaseIterator(new DisjunctionDISIApproximation(byDocQueue)) {
-            @Override
-            public boolean matches() throws IOException {
-              return twoPhaseCurrentDocMatches();
-            }
-
-            @Override
-            public float matchCost() {
-              return matchCost;
-            }
-          };
-        }
-
-        float positionsCost = -1;
-
-        void computePositionsCost() {
-          float sumPositionsCost = 0;
-          long sumCost = 0;
-          for (DisiWrapper w : byDocQueue) {
-            long costWeight = (w.cost <= 1) ? 1 : w.cost;
-            sumPositionsCost += w.spans.positionsCost() * costWeight;
-            sumCost += costWeight;
-          }
-          positionsCost = sumPositionsCost / sumCost;
-        }
-
-        @Override
-        public float positionsCost() {
-          // This may be called when asTwoPhaseIterator returned null,
-          // which happens when none of the sub spans supports approximations.
-          assert positionsCost > 0;
-          return positionsCost;
-        }
-
-        int lastDocTwoPhaseMatched = -1;
-
-        boolean twoPhaseCurrentDocMatches() throws IOException {
-          DisiWrapper listAtCurrentDoc = byDocQueue.topList();
-          // remove the head of the list as long as it does not match
-          final int currentDoc = listAtCurrentDoc.doc;
-          while (listAtCurrentDoc.twoPhaseView != null) {
-            if (listAtCurrentDoc.twoPhaseView.matches()) {
-              // use this spans for positions at current doc:
-              listAtCurrentDoc.lastApproxMatchDoc = currentDoc;
-              break;
-            }
-            // do not use this spans for positions at current doc:
-            listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;
-            listAtCurrentDoc = listAtCurrentDoc.next;
-            if (listAtCurrentDoc == null) {
-              return false;
-            }
-          }
-          lastDocTwoPhaseMatched = currentDoc;
-          topPositionSpans = null;
-          return true;
-        }
-
-        void fillPositionQueue() throws IOException { // called at first nextStartPosition
-          assert byPositionQueue.size() == 0;
-          // add all matching Spans at current doc to byPositionQueue
-          DisiWrapper listAtCurrentDoc = byDocQueue.topList();
-          while (listAtCurrentDoc != null) {
-            Spans spansAtDoc = listAtCurrentDoc.spans;
-            if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation
-              if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation
-                if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false
-                  spansAtDoc = null;
-                } else {
-                  if (listAtCurrentDoc.lastApproxMatchDoc != listAtCurrentDoc.doc) {
-                    if (!listAtCurrentDoc.twoPhaseView.matches()) {
-                      spansAtDoc = null;
-                    }
-                  }
-                }
-              }
-            }
-
-            if (spansAtDoc != null) {
-              assert spansAtDoc.docID() == listAtCurrentDoc.doc;
-              assert spansAtDoc.startPosition() == -1;
-              spansAtDoc.nextStartPosition();
-              assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;
-              byPositionQueue.add(spansAtDoc);
+      return new DisjunctionSpans(SpanOrQuery.this, subSpans);
     }
-            listAtCurrentDoc = listAtCurrentDoc.next;
   }
-          assert byPositionQueue.size() > 0;
-        }
-
-        @Override
-        public int nextStartPosition() throws IOException {
-          if (topPositionSpans == null) {
-            byPositionQueue.clear();
-            fillPositionQueue(); // fills byPositionQueue at first position
-            topPositionSpans = byPositionQueue.top();
-          } else {
-            topPositionSpans.nextStartPosition();
-            topPositionSpans = byPositionQueue.updateTop();
-          }
-          return topPositionSpans.startPosition();
-        }
-
-        @Override
-        public int startPosition() {
-          return topPositionSpans == null ? -1 : topPositionSpans.startPosition();
-        }
-
-        @Override
-        public int endPosition() {
-          return topPositionSpans == null ? -1 : topPositionSpans.endPosition();
-        }
-
-        @Override
-        public int width() {
-          return topPositionSpans.width();
-        }
-
-        @Override
-        public void collect(SpanCollector collector) throws IOException {
-          if (topPositionSpans != null)
-            topPositionSpans.collect(collector);
-        }
-
-        @Override
-        public String toString() {
-          return "spanOr(" + SpanOrQuery.this + ")@" + docID() + ": " + startPosition() + " - " + endPosition();
-        }
-
-        long cost = -1;
-
-        @Override
-        public long cost() {
-          if (cost == -1) {
-            cost = 0;
-            for (Spans spans : subSpans) {
-              cost += spans.cost();
-            }
-          }
-          return cost;
-        }
-      };
-    }
-  }
-
 }
 
