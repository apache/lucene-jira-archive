Index: lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper.java	(revision 1349599)
+++ lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper.java	(working copy)
@@ -33,6 +33,7 @@
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import org.apache.lucene.index.CheckIndex;
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.IndexWriter;
 import org.apache.lucene.index.IndexWriterConfig;
@@ -583,8 +584,17 @@
         crash(); // corrumpt any unsynced-files
         if (LuceneTestCase.VERBOSE) {
           System.out.println("\nNOTE: MockDirectoryWrapper: now run CheckIndex");
-        } 
-        _TestUtil.checkIndex(this, crossCheckTermVectorsOnClose);
+        }
+        final CheckIndex.CrossCheckMode crossCheck;
+        if (!crossCheckTermVectorsOnClose) {
+          crossCheck = CheckIndex.CrossCheckMode.NO;
+        } else if (delegate instanceof RAMDirectory && ((RAMDirectory)delegate).sizeInBytes() < 1048576) {
+          // otherwise its too slow!
+          crossCheck = CheckIndex.CrossCheckMode.FULL;
+        } else {
+          crossCheck = CheckIndex.CrossCheckMode.YES;
+        }
+        _TestUtil.checkIndex(this, crossCheck);
 
         if (assertNoUnreferencedFilesOnClose) {
           // now look for unreferenced files:
Index: lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil.java
===================================================================
--- lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil.java	(revision 1349599)
+++ lucene/test-framework/src/java/org/apache/lucene/util/_TestUtil.java	(working copy)
@@ -178,10 +178,10 @@
    *  issues are hit, a RuntimeException is thrown; else,
    *  true is returned. */
   public static CheckIndex.Status checkIndex(Directory dir) throws IOException {
-    return checkIndex(dir, true);
+    return checkIndex(dir, CheckIndex.CrossCheckMode.YES);
   }
 
-  public static CheckIndex.Status checkIndex(Directory dir, boolean crossCheckTermVectors) throws IOException {
+  public static CheckIndex.Status checkIndex(Directory dir, CheckIndex.CrossCheckMode crossCheckTermVectors) throws IOException {
     ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);
     CheckIndex checker = new CheckIndex(dir);
     checker.setCrossCheckTermVectors(crossCheckTermVectors);
Index: lucene/core/src/java/org/apache/lucene/index/CheckIndex.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/index/CheckIndex.java	(revision 1349599)
+++ lucene/core/src/java/org/apache/lucene/index/CheckIndex.java	(working copy)
@@ -280,17 +280,35 @@
     infoStream = null;
   }
 
-  private boolean crossCheckTermVectors;
+  public static enum CrossCheckMode { 
+    /** don't cross check term vectors back to the postings */
+    NO,
+    /** 
+     * term vectors are compared against postings to
+     * make sure they are the same.  This will likely
+     * drastically increase time it takes to run CheckIndex!
+     */ 
+    YES,
+    /** 
+     * term vectors are compared against postings and postings 
+     * are compared against term vectors. While this guarantees
+     * full equality, this will definitely drastically increase 
+     * time it takes to run CheckIndex!
+     */ 
+    FULL 
+  };
+  
+  private CrossCheckMode crossCheckTermVectors = CrossCheckMode.NO;
 
   /** If true, term vectors are compared against postings to
    *  make sure they are the same.  This will likely
    *  drastically increase time it takes to run CheckIndex! */
-  public void setCrossCheckTermVectors(boolean v) {
+  public void setCrossCheckTermVectors(CrossCheckMode v) {
     crossCheckTermVectors = v;
   }
 
   /** See {@link #setCrossCheckTermVectors}. */
-  public boolean getCrossCheckTermVectors() {
+  public CrossCheckMode getCrossCheckTermVectors() {
     return crossCheckTermVectors;
   }
 
@@ -667,7 +685,7 @@
    * checks Fields api is consistent with itself.
    * searcher is optional, to verify with queries. Can be null.
    */
-  private Status.TermIndexStatus checkFields(Fields fields, Bits liveDocs, int maxDoc, FieldInfos fieldInfos, boolean doPrint) throws IOException {
+  private Status.TermIndexStatus checkFields(Fields fields, Bits liveDocs, int maxDoc, FieldInfos fieldInfos, boolean doPrint, AtomicReader crossCheck) throws IOException {
     // TODO: we should probably return our own stats thing...?!
     
     final Status.TermIndexStatus status = new Status.TermIndexStatus();
@@ -682,6 +700,8 @@
     DocsEnum docsAndFreqs = null;
     DocsAndPositionsEnum postings = null;
     DocsAndPositionsEnum offsets = null;
+    TermsEnum termsEnum = null;
+    TermsEnum vectorsEnum = null; // for cross-check
     
     String lastField = null;
     final FieldsEnum fieldsEnum = fields.iterator();
@@ -717,7 +737,7 @@
         continue;
       }
       
-      final TermsEnum termsEnum = terms.iterator(null);
+      termsEnum = terms.iterator(termsEnum);
       
       boolean hasOrd = true;
       final long termCountStart = status.termCount;
@@ -835,6 +855,19 @@
             throw new RuntimeException("term " + term + ": doc " + doc + " >= maxDoc " + maxDoc);
           }
           
+          // NOTE: because testTermVectors compares terms/freqs/offsets/positions back 
+          // to the postings, its only necessary to verify all postings terms also exist 
+          // in the doc's vector here to test for equality.
+          if (crossCheck != null && fi.hasVectors()) {
+            Terms vectorTerms = crossCheck.getTermVector(doc, field);
+            if (vectorTerms != null) {
+              vectorsEnum = vectorTerms.iterator(vectorsEnum);
+              if (!vectorsEnum.seekExact(term, true)) {
+                throw new RuntimeException("term " + term + ": doc " + doc + " does not exists in term vector");
+              }
+            }
+          }
+          
           lastDoc = doc;
           
           int lastPos = -1;
@@ -1178,10 +1211,6 @@
    * Test the term index.
    */
   private Status.TermIndexStatus testPostings(FieldInfos fieldInfos, SegmentReader reader) {
-
-    // TODO: we should go and verify term vectors match, if
-    // crossCheckTermVectors is on...
-
     Status.TermIndexStatus status;
     final int maxDoc = reader.maxDoc();
     final Bits liveDocs = reader.getLiveDocs();
@@ -1192,12 +1221,14 @@
       }
 
       final Fields fields = reader.fields();
-      status = checkFields(fields, liveDocs, maxDoc, fieldInfos, true);
+      status = checkFields(fields, liveDocs, maxDoc, fieldInfos, true, 
+          /* don't cross-check twice, its very slow! */ 
+          liveDocs == null && crossCheckTermVectors == CrossCheckMode.FULL ? reader : null);
       if (liveDocs != null) {
         if (infoStream != null) {
           infoStream.print("    test (ignoring deletes): terms, freq, prox...");
         }
-        checkFields(fields, null, maxDoc, fieldInfos, true);
+        checkFields(fields, null, maxDoc, fieldInfos, true, crossCheckTermVectors == CrossCheckMode.FULL ? reader : null);
       }
     } catch (Throwable e) {
       msg("ERROR: " + e);
@@ -1394,7 +1425,7 @@
 
       final Fields postingsFields;
       // TODO: testTermsIndex
-      if (crossCheckTermVectors) {
+      if (crossCheckTermVectors.compareTo(CrossCheckMode.YES) >= 0) {
         postingsFields = reader.fields();
       } else {
         postingsFields = null;
@@ -1414,10 +1445,10 @@
 
         if (tfv != null) {
           // First run with no deletions:
-          checkFields(tfv, null, 1, fieldInfos, false);
+          checkFields(tfv, null, 1, fieldInfos, false, null);
 
           // Again, with the one doc deleted:
-          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false);
+          checkFields(tfv, onlyDocIsDeleted, 1, fieldInfos, false, null);
 
           // Only agg stats if the doc is live:
           final boolean doStats = liveDocs == null || liveDocs.get(j);
@@ -1438,7 +1469,7 @@
               throw new RuntimeException("docID=" + j + " has term vectors for field=" + field + " but FieldInfo has storeTermVector=false");
             }
 
-            if (crossCheckTermVectors) {
+            if (crossCheckTermVectors.compareTo(CrossCheckMode.YES) >= 0) {
               Terms terms = tfv.terms(field);
               termsEnum = terms.iterator(termsEnum);
 
@@ -1672,7 +1703,7 @@
   public static void main(String[] args) throws IOException, InterruptedException {
 
     boolean doFix = false;
-    boolean doCrossCheckTermVectors = false;
+    CrossCheckMode doCrossCheckTermVectors = CrossCheckMode.NO;
     Codec codec = Codec.getDefault(); // only used when fixing
     boolean verbose = false;
     List<String> onlySegments = new ArrayList<String>();
@@ -1684,7 +1715,12 @@
       if ("-fix".equals(arg)) {
         doFix = true;
       } else if ("-crossCheckTermVectors".equals(arg)) {
-        doCrossCheckTermVectors = true;
+        if (i == args.length-1) {
+          System.out.println("ERROR: missing name for -crossCheckTermVectors option");
+          System.exit(1);
+        }
+        i++;
+        doCrossCheckTermVectors = CrossCheckMode.valueOf(args[i]);
       } else if ("-codec".equals(arg)) {
         if (i == args.length-1) {
           System.out.println("ERROR: missing name for -codec option");
@@ -1723,7 +1759,7 @@
       System.out.println("\nUsage: java org.apache.lucene.index.CheckIndex pathToIndex [-fix] [-crossCheckTermVectors] [-segment X] [-segment Y] [-dir-impl X]\n" +
                          "\n" +
                          "  -fix: actually write a new segments_N file, removing any problematic segments\n" +
-                         "  -crossCheckTermVectors: verifies that term vectors match postings; THIS IS VERY SLOW!\n" +
+                         "  -crossCheckTermVectors [NO|YES|FULL]: verifies that term vectors match postings; THIS IS VERY SLOW!\n" +
                          "  -codec X: when fixing, codec to write the new segments_N file with\n" +
                          "  -verbose: print additional details\n" +
                          "  -segment X: only check the specified segments.  This can be specified multiple\n" + 
