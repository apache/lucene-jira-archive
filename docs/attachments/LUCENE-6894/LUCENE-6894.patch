diff --git a/lucene/core/src/java/org/apache/lucene/search/BooleanTopLevelScorers.java b/lucene/core/src/java/org/apache/lucene/search/BooleanTopLevelScorers.java
index 443531f..0144686 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BooleanTopLevelScorers.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BooleanTopLevelScorers.java
@@ -94,8 +94,8 @@ class BooleanTopLevelScorers {
     private final Scorer req;
     private final Scorer opt;
     
-    CoordinatingConjunctionScorer(Weight weight, float coords[], Scorer req, int reqCount, Scorer opt) {
-      super(weight, Arrays.asList(req, opt), Arrays.asList(req, opt));
+    CoordinatingConjunctionScorer(Weight weight, float coords[], Scorer req, int reqCount, Scorer opt, long numDocs) {
+      super(weight, Arrays.asList(req, opt), Arrays.asList(req, opt), numDocs);
       this.coords = coords;
       this.req = req;
       this.reqCount = reqCount;
diff --git a/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java b/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java
index a54e713..c15b817 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BooleanWeight.java
@@ -322,13 +322,14 @@ final class BooleanWeight extends Weight {
     // three cases: conjunction, disjunction, or mix
     
     // pure conjunction
+    long numDocs = context.reader().maxDoc();
     if (optional.isEmpty()) {
-      return excl(req(required, requiredScoring, disableCoord), prohibited);
+      return excl(req(required, requiredScoring, disableCoord, numDocs), prohibited, numDocs);
     }
     
     // pure disjunction
     if (required.isEmpty()) {
-      return excl(opt(optional, minShouldMatch, disableCoord), prohibited);
+      return excl(opt(optional, minShouldMatch, disableCoord, numDocs), prohibited, numDocs);
     }
     
     // conjunction-disjunction mix:
@@ -337,19 +338,19 @@ final class BooleanWeight extends Weight {
     // optional side must match. otherwise it's required + optional, factoring the
     // number of optional terms into the coord calculation
     
-    Scorer req = excl(req(required, requiredScoring, true), prohibited);
-    Scorer opt = opt(optional, minShouldMatch, true);
+    Scorer req = excl(req(required, requiredScoring, true, numDocs), prohibited, numDocs);
+    Scorer opt = opt(optional, minShouldMatch, true, numDocs);
 
     // TODO: clean this up: it's horrible
     if (disableCoord) {
       if (minShouldMatch > 0) {
-        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), 1F);
+        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), 1F, numDocs);
       } else {
         return new ReqOptSumScorer(req, opt);          
       }
     } else if (optional.size() == 1) {
       if (minShouldMatch > 0) {
-        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), coord(requiredScoring.size()+1, maxCoord));
+        return new ConjunctionScorer(this, Arrays.asList(req, opt), Arrays.asList(req, opt), coord(requiredScoring.size()+1, maxCoord), numDocs);
       } else {
         float coordReq = coord(requiredScoring.size(), maxCoord);
         float coordBoth = coord(requiredScoring.size() + 1, maxCoord);
@@ -357,7 +358,7 @@ final class BooleanWeight extends Weight {
       }
     } else {
       if (minShouldMatch > 0) {
-        return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords, req, requiredScoring.size(), opt);
+        return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords, req, requiredScoring.size(), opt, numDocs);
       } else {
         return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, requiredScoring.size(), coords); 
       }
@@ -367,7 +368,7 @@ final class BooleanWeight extends Weight {
   /** Create a new scorer for the given required clauses. Note that
    *  {@code requiredScoring} is a subset of {@code required} containing
    *  required clauses that should participate in scoring. */
-  private Scorer req(List<Scorer> required, List<Scorer> requiredScoring, boolean disableCoord) {
+  private Scorer req(List<Scorer> required, List<Scorer> requiredScoring, boolean disableCoord, long numDocs) {
     if (required.size() == 1) {
       Scorer req = required.get(0);
 
@@ -401,11 +402,12 @@ final class BooleanWeight extends Weight {
       return new BooleanTopLevelScorers.BoostedScorer(req, boost);
     } else {
       return new ConjunctionScorer(this, required, requiredScoring,
-                                   disableCoord ? 1.0F : coord(requiredScoring.size(), maxCoord));
+                                   disableCoord ? 1.0F : coord(requiredScoring.size(), maxCoord),
+                                   numDocs);
     }
   }
   
-  private Scorer excl(Scorer main, List<Scorer> prohibited) throws IOException {
+  private Scorer excl(Scorer main, List<Scorer> prohibited, long numDocs) throws IOException {
     if (prohibited.isEmpty()) {
       return main;
     } else if (prohibited.size() == 1) {
@@ -413,11 +415,11 @@ final class BooleanWeight extends Weight {
     } else {
       float coords[] = new float[prohibited.size()+1];
       Arrays.fill(coords, 1F);
-      return new ReqExclScorer(main, new DisjunctionSumScorer(this, prohibited, coords, false));
+      return new ReqExclScorer(main, new DisjunctionSumScorer(this, prohibited, coords, false, numDocs));
     }
   }
   
-  private Scorer opt(List<Scorer> optional, int minShouldMatch, boolean disableCoord) throws IOException {
+  private Scorer opt(List<Scorer> optional, int minShouldMatch, boolean disableCoord, long numDocs) throws IOException {
     if (optional.size() == 1) {
       Scorer opt = optional.get(0);
       if (!disableCoord && maxCoord > 1) {
@@ -435,9 +437,9 @@ final class BooleanWeight extends Weight {
         coords = this.coords;
       }
       if (minShouldMatch > 1) {
-        return new MinShouldMatchSumScorer(this, optional, minShouldMatch, coords);
+        return new MinShouldMatchSumScorer(this, optional, minShouldMatch, coords, numDocs);
       } else {
-        return new DisjunctionSumScorer(this, optional, coords, needsScores);
+        return new DisjunctionSumScorer(this, optional, coords, needsScores, numDocs);
       }
     }
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java b/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
index 07227d2..9399f1d 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
@@ -33,8 +33,13 @@ import org.apache.lucene.util.CollectionUtil;
 public class ConjunctionDISI extends DocIdSetIterator {
 
   /** Create a conjunction over the provided iterators, taking advantage of
-   *  {@link TwoPhaseIterator}. */
-  public static ConjunctionDISI intersect(List<? extends DocIdSetIterator> iterators) {
+   *  {@link TwoPhaseIterator}.
+   *  @param iterators The provided iterators.
+   *  @param numDocs   The number of documents that these iterators have access to.
+   *                   This should not be smaller than any of the provided
+   *                   {@link DocIdSetIterator#cost()}s.
+   */
+  public static ConjunctionDISI intersect(List<? extends DocIdSetIterator> iterators, long numDocs) {
     if (iterators.size() < 2) {
       throw new IllegalArgumentException("Cannot make a ConjunctionDISI of less than 2 iterators");
     }
@@ -45,9 +50,9 @@ public class ConjunctionDISI extends DocIdSetIterator {
     }
 
     if (twoPhaseIterators.isEmpty()) {
-      return new ConjunctionDISI(allIterators);
+      return new ConjunctionDISI(allIterators, numDocs);
     } else {
-      return new TwoPhase(allIterators, twoPhaseIterators);
+      return new TwoPhase(allIterators, twoPhaseIterators, numDocs);
     }
   }
 
@@ -79,9 +84,11 @@ public class ConjunctionDISI extends DocIdSetIterator {
 
   final DocIdSetIterator lead;
   final DocIdSetIterator[] others;
+  final long cost;
 
-  ConjunctionDISI(List<? extends DocIdSetIterator> iterators) {
+  ConjunctionDISI(List<? extends DocIdSetIterator> iterators, long numDocs) {
     assert iterators.size() >= 2;
+    assert numDocs >= 1;
     // Sort the array the first time to allow the least frequent DocsEnum to
     // lead the matching.
     CollectionUtil.timSort(iterators, new Comparator<DocIdSetIterator>() {
@@ -92,6 +99,15 @@ public class ConjunctionDISI extends DocIdSetIterator {
     });
     lead = iterators.get(0);
     others = iterators.subList(1, iterators.size()).toArray(new DocIdSetIterator[0]);
+
+    // Compute expected number of matching docs into cost.
+    double expectMatch = 1;
+    for (DocIdSetIterator iter : iterators) {
+      long iterCost = Math.min(iter.cost(), numDocs);
+      assert iterCost >= 0;
+      expectMatch *= (iterCost / (double) numDocs); // independence: product of probabilities.
+    }
+    cost = (long) (numDocs * expectMatch);
   }
 
   protected boolean matches() throws IOException {
@@ -166,8 +182,11 @@ public class ConjunctionDISI extends DocIdSetIterator {
     private final TwoPhaseIterator[] twoPhaseIterators;
     private final float matchCost;
 
-    private TwoPhaseConjunctionDISI(List<? extends DocIdSetIterator> iterators, List<TwoPhaseIterator> twoPhaseIterators) {
-      super(new ConjunctionDISI(iterators));
+    private TwoPhaseConjunctionDISI(
+        List<? extends DocIdSetIterator> iterators,
+        List<TwoPhaseIterator> twoPhaseIterators,
+        long numDocs) {
+      super(new ConjunctionDISI(iterators, numDocs));
       assert twoPhaseIterators.size() > 0;
 
       CollectionUtil.timSort(twoPhaseIterators, new Comparator<TwoPhaseIterator>() {
@@ -222,9 +241,12 @@ public class ConjunctionDISI extends DocIdSetIterator {
 
     final TwoPhaseConjunctionDISI twoPhaseView;
 
-    private TwoPhase(List<? extends DocIdSetIterator> iterators, List<TwoPhaseIterator> twoPhaseIterators) {
-      super(iterators);
-      twoPhaseView = new TwoPhaseConjunctionDISI(iterators, twoPhaseIterators);
+    private TwoPhase(
+        List<? extends DocIdSetIterator> iterators,
+        List<TwoPhaseIterator> twoPhaseIterators,
+        long numDocs) {
+      super(iterators, numDocs);
+      twoPhaseView = new TwoPhaseConjunctionDISI(iterators, twoPhaseIterators, numDocs);
     }
 
     @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java b/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
index 9afe3af..8c2d13d 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ConjunctionScorer.java
@@ -29,16 +29,21 @@ class ConjunctionScorer extends Scorer {
   final Scorer[] scorers;
   final float coord;
 
-  ConjunctionScorer(Weight weight, List<? extends DocIdSetIterator> required, List<Scorer> scorers) {
-    this(weight, required, scorers, 1f);
+  ConjunctionScorer(Weight weight, List<? extends DocIdSetIterator> required, List<Scorer> scorers, long numDocs) {
+    this(weight, required, scorers, 1f, numDocs);
   }
 
   /** Create a new {@link ConjunctionScorer}, note that {@code scorers} must be a subset of {@code required}. */
-  ConjunctionScorer(Weight weight, List<? extends DocIdSetIterator> required, List<Scorer> scorers, float coord) {
+  ConjunctionScorer(
+      Weight weight,
+      List<? extends DocIdSetIterator> required,
+      List<Scorer> scorers,
+      float coord,
+      long numDocs) {
     super(weight);
     assert required.containsAll(scorers);
     this.coord = coord;
-    this.disi = ConjunctionDISI.intersect(required);
+    this.disi = ConjunctionDISI.intersect(required, numDocs);
     this.scorers = scorers.toArray(new Scorer[scorers.size()]);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisiWrapper.java b/lucene/core/src/java/org/apache/lucene/search/DisiWrapper.java
index d3f5294..9852932 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisiWrapper.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisiWrapper.java
@@ -40,6 +40,7 @@ public class DisiWrapper<Iter extends DocIdSetIterator> {
   public DisiWrapper(Iter iterator) {
     this.iterator = iterator;
     this.cost = iterator.cost();
+    assert this.cost >= 0;
     this.doc = -1;
     this.twoPhaseView = TwoPhaseIterator.asTwoPhaseIterator(iterator);
       
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisjunctionDISIApproximation.java b/lucene/core/src/java/org/apache/lucene/search/DisjunctionDISIApproximation.java
index 1672d79..3a150b2 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisjunctionDISIApproximation.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisjunctionDISIApproximation.java
@@ -29,13 +29,16 @@ extends DocIdSetIterator {
   final DisiPriorityQueue<Iter> subIterators;
   final long cost;
 
-  public DisjunctionDISIApproximation(DisiPriorityQueue<Iter> subIterators) {
+  public DisjunctionDISIApproximation(DisiPriorityQueue<Iter> subIterators, long numDocs) {
     this.subIterators = subIterators;
-    long cost = 0;
+    assert numDocs >= 1;
+    double expectNonMatch = 1;
     for (DisiWrapper<Iter> w : subIterators) {
-      cost += w.cost;
+      assert w.cost <= numDocs;
+      assert w.cost >= 0;
+      expectNonMatch *= (numDocs - w.cost) / (double) numDocs; // independence assumption
     }
-    this.cost = cost;
+    this.cost = (long) (numDocs * (1 - expectNonMatch));
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
index 1b1d0b0..fd1a698 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxQuery.java
@@ -154,7 +154,7 @@ public final class DisjunctionMaxQuery extends Query implements Iterable<Query>
         // only one sub-scorer in this segment
         return scorers.get(0);
       } else {
-        return new DisjunctionMaxScorer(this, tieBreakerMultiplier, scorers, needsScores);
+        return new DisjunctionMaxScorer(this, tieBreakerMultiplier, scorers, needsScores, context.reader().maxDoc());
       }
     }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
index 8f3048e..e253534 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisjunctionMaxScorer.java
@@ -40,8 +40,8 @@ final class DisjunctionMaxScorer extends DisjunctionScorer {
    * @param subScorers
    *          The sub scorers this Scorer should iterate on
    */
-  DisjunctionMaxScorer(Weight weight, float tieBreakerMultiplier, List<Scorer> subScorers, boolean needsScores) {
-    super(weight, subScorers, needsScores);
+  DisjunctionMaxScorer(Weight weight, float tieBreakerMultiplier, List<Scorer> subScorers, boolean needsScores, long numDocs) {
+    super(weight, subScorers, needsScores, numDocs);
     this.tieBreakerMultiplier = tieBreakerMultiplier;
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java b/lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java
index e02efba..9cdd370 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisjunctionScorer.java
@@ -30,23 +30,30 @@ abstract class DisjunctionScorer extends Scorer {
   private final boolean needsScores;
   final DisiPriorityQueue<Scorer> subScorers;
   private final long cost;
+  private final long numDocs;
 
   /** Linked list of scorers which are on the current doc */
   private DisiWrapper<Scorer> topScorers;
 
-  protected DisjunctionScorer(Weight weight, List<Scorer> subScorers, boolean needsScores) {
+  protected DisjunctionScorer(Weight weight, List<Scorer> subScorers, boolean needsScores, long numDocs) {
     super(weight);
     if (subScorers.size() <= 1) {
       throw new IllegalArgumentException("There must be at least 2 subScorers");
     }
     this.subScorers = new DisiPriorityQueue<Scorer>(subScorers.size());
-    long cost = 0;
+
+    assert numDocs >= 1;
+    double expectNonMatch = 1;
     for (Scorer scorer : subScorers) {
       final DisiWrapper<Scorer> w = new DisiWrapper<>(scorer);
-      cost += w.cost;
       this.subScorers.add(w);
+      assert w.cost >= 0;
+      long cost = Math.min(w.cost, numDocs);
+      expectNonMatch *= (numDocs - cost) / (double) numDocs; // independence assumption
     }
-    this.cost = cost;
+    this.cost = (long) (numDocs * (1 - expectNonMatch));
+    this.numDocs = numDocs;
+
     this.needsScores = needsScores;
   }
 
@@ -74,7 +81,7 @@ abstract class DisjunctionScorer extends Scorer {
     // note it is important to share the same pq as this scorer so that
     // rebalancing the pq through the approximation will also rebalance
     // the pq in this scorer.
-    return new TwoPhaseIterator(new DisjunctionDISIApproximation<Scorer>(subScorers)) {
+    return new TwoPhaseIterator(new DisjunctionDISIApproximation<Scorer>(subScorers, numDocs)) {
 
       @Override
       public boolean matches() throws IOException {
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisjunctionSumScorer.java b/lucene/core/src/java/org/apache/lucene/search/DisjunctionSumScorer.java
index 6cf167b..4561473 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DisjunctionSumScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DisjunctionSumScorer.java
@@ -31,8 +31,8 @@ final class DisjunctionSumScorer extends DisjunctionScorer {
    * @param subScorers Array of at least two subscorers.
    * @param coord Table of coordination factors
    */
-  DisjunctionSumScorer(Weight weight, List<Scorer> subScorers, float[] coord, boolean needsScores) {
-    super(weight, subScorers, needsScores);
+  DisjunctionSumScorer(Weight weight, List<Scorer> subScorers, float[] coord, boolean needsScores, long numDocs) {
+    super(weight, subScorers, needsScores, numDocs);
     this.coord = coord;
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java b/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java
index 697860a..ac98475 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java
@@ -170,9 +170,8 @@ public abstract class DocIdSetIterator {
   /**
    * Returns the estimated cost of this {@link DocIdSetIterator}.
    * <p>
-   * This is generally an upper bound of the number of documents this iterator
-   * might match, but may be a rough heuristic, hardcoded value, or otherwise
-   * completely inaccurate.
+   * This is a non negative estimation of the number of documents this iterator
+   * will match.
    */
   public abstract long cost();
   
diff --git a/lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer.java b/lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer.java
index 248a948..fad6e2b 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ExactPhraseScorer.java
@@ -48,7 +48,7 @@ final class ExactPhraseScorer extends Scorer {
 
   ExactPhraseScorer(Weight weight, PhraseQuery.PostingsAndFreq[] postings,
                     Similarity.SimScorer docScorer, boolean needsScores,
-                    float matchCost) throws IOException {
+                    float matchCost, long numDocs) throws IOException {
     super(weight);
     this.docScorer = docScorer;
     this.needsScores = needsScores;
@@ -59,7 +59,7 @@ final class ExactPhraseScorer extends Scorer {
       iterators.add(posting.postings);
       postingsAndPositions.add(new PostingsAndPosition(posting.postings, posting.position));
     }
-    conjunction = ConjunctionDISI.intersect(iterators);
+    conjunction = ConjunctionDISI.intersect(iterators, numDocs);
     this.postings = postingsAndPositions.toArray(new PostingsAndPosition[postingsAndPositions.size()]);
     this.matchCost = matchCost;
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java b/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java
index a93bed2..f147975 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MinShouldMatchSumScorer.java
@@ -47,7 +47,8 @@ import static org.apache.lucene.search.DisiPriorityQueue.rightNode;
  */
 final class MinShouldMatchSumScorer extends Scorer {
 
-  private static long cost(Collection<Scorer> scorers, int minShouldMatch) {
+  private static long cost(Collection<Scorer> scorers, int minShouldMatch, long numDocs) {
+    assert numDocs >= 1;
     // the idea here is the following: a boolean query c1,c2,...cn with minShouldMatch=m
     // could be rewritten to:
     // (c1 AND (c2..cn|msm=m-1)) OR (!c1 AND (c2..cn|msm=m))
@@ -61,6 +62,7 @@ final class MinShouldMatchSumScorer extends Scorer {
 
     // If we recurse infinitely, we find out that the cost of a msm query is the sum of the
     // costs of the num_scorers - minShouldMatch + 1 least costly scorers
+
     final PriorityQueue<Scorer> pq = new PriorityQueue<Scorer>(scorers.size() - minShouldMatch + 1) {
       @Override
       protected boolean lessThan(Scorer a, Scorer b) {
@@ -70,11 +72,15 @@ final class MinShouldMatchSumScorer extends Scorer {
     for (Scorer scorer : scorers) {
       pq.insertWithOverflow(scorer);
     }
-    long cost = 0;
+
+    // Use independence assumption instead of sum cost:
+    double expectNonMatch = 1;
     for (Scorer scorer = pq.pop(); scorer != null; scorer = pq.pop()) {
-      cost += scorer.cost();
+      long scorerCost = Math.min(scorer.cost(), numDocs);
+      assert scorerCost >= 0;
+      expectNonMatch *= (numDocs - scorerCost) / (double) numDocs; // independence assumption
     }
-    return cost;
+    return (long) (numDocs * (1 - expectNonMatch));
   }
 
   final int minShouldMatch;
@@ -99,7 +105,7 @@ final class MinShouldMatchSumScorer extends Scorer {
   final long cost;
 
   @SuppressWarnings({"unchecked","rawtypes"})
-  MinShouldMatchSumScorer(Weight weight, Collection<Scorer> scorers, int minShouldMatch, float[] coord) {
+  MinShouldMatchSumScorer(Weight weight, Collection<Scorer> scorers, int minShouldMatch, float[] coord, long numDocs) {
     super(weight);
 
     if (minShouldMatch > scorers.size()) {
@@ -127,7 +133,7 @@ final class MinShouldMatchSumScorer extends Scorer {
       children.add(new ChildScorer(scorer, "SHOULD"));
     }
     this.childScorers = Collections.unmodifiableCollection(children);
-    this.cost = cost(scorers, minShouldMatch);
+    this.cost = cost(scorers, minShouldMatch, numDocs);
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java b/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
index f36c176..829c757 100644
--- a/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/MultiPhraseQuery.java
@@ -223,14 +223,16 @@ public class MultiPhraseQuery extends Query {
         ArrayUtil.timSort(postingsFreqs);
       }
 
+      long numDocs = context.reader().maxDoc();
+
       if (slop == 0) {
         return new ExactPhraseScorer(this, postingsFreqs,
                                       similarity.simScorer(stats, context),
-                                      needsScores, totalMatchCost);
+                                      needsScores, totalMatchCost, numDocs);
       } else {
         return new SloppyPhraseScorer(this, postingsFreqs, slop,
                                         similarity.simScorer(stats, context),
-                                        needsScores, totalMatchCost);
+                                        needsScores, totalMatchCost, numDocs);
       }
     }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
index da82efb..b8dc9bf 100644
--- a/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/PhraseQuery.java
@@ -427,14 +427,16 @@ public class PhraseQuery extends Query {
         ArrayUtil.timSort(postingsFreqs);
       }
 
+      long numDocs = reader.maxDoc();
+
       if (slop == 0) {  // optimize exact case
         return new ExactPhraseScorer(this, postingsFreqs,
                                       similarity.simScorer(stats, context),
-                                      needsScores, totalMatchCost);
+                                      needsScores, totalMatchCost, numDocs);
       } else {
         return new SloppyPhraseScorer(this, postingsFreqs, slop,
                                         similarity.simScorer(stats, context),
-                                        needsScores, totalMatchCost);
+                                        needsScores, totalMatchCost, numDocs);
       }
     }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer.java b/lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer.java
index 5c565ce..e680073 100644
--- a/lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/SloppyPhraseScorer.java
@@ -56,7 +56,7 @@ final class SloppyPhraseScorer extends Scorer {
   
   SloppyPhraseScorer(Weight weight, PhraseQuery.PostingsAndFreq[] postings,
       int slop, Similarity.SimScorer docScorer, boolean needsScores,
-      float matchCost) {
+      float matchCost, long numDocs) {
     super(weight);
     this.docScorer = docScorer;
     this.needsScores = needsScores;
@@ -69,7 +69,7 @@ final class SloppyPhraseScorer extends Scorer {
       iterators[i] = postings[i].postings;
       phrasePositions[i] = new PhrasePositions(postings[i].postings, postings[i].position, i, postings[i].terms);
     }
-    conjunction = ConjunctionDISI.intersect(Arrays.asList(iterators));
+    conjunction = ConjunctionDISI.intersect(Arrays.asList(iterators), numDocs);
     this.matchCost = matchCost;
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java b/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
index 9e2187c..b7daae8 100644
--- a/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/SynonymQuery.java
@@ -215,7 +215,7 @@ public final class SynonymQuery extends Query {
         // we must optimize this case (term not in segment), disjunctionscorer requires >= 2 subs
         return subScorers.get(0);
       } else {
-        return new SynonymScorer(simScorer, this, subScorers);
+        return new SynonymScorer(simScorer, this, subScorers, context.reader().maxDoc());
       }
     }
   }
@@ -223,8 +223,8 @@ public final class SynonymQuery extends Query {
   static class SynonymScorer extends DisjunctionScorer {
     private final Similarity.SimScorer similarity;
     
-    SynonymScorer(Similarity.SimScorer similarity, Weight weight, List<Scorer> subScorers) {
-      super(weight, subScorers, true);
+    SynonymScorer(Similarity.SimScorer similarity, Weight weight, List<Scorer> subScorers, long numDocs) {
+      super(weight, subScorers, true, numDocs);
       this.similarity = similarity;
     }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java
index 533714d..aa12326 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/ConjunctionSpans.java
@@ -34,13 +34,13 @@ abstract class ConjunctionSpans extends Spans {
   boolean atFirstInCurrentDoc; // a first start position is available in current doc for nextStartPosition
   boolean oneExhaustedInCurrentDoc; // one subspans exhausted in current doc
 
-  ConjunctionSpans(List<Spans> subSpans, SpanWeight weight, Similarity.SimScorer docScorer) {
+  ConjunctionSpans(List<Spans> subSpans, SpanWeight weight, Similarity.SimScorer docScorer, long numDocs) {
     super(weight, docScorer);
     if (subSpans.size() < 2) {
       throw new IllegalArgumentException("Less than 2 subSpans.size():" + subSpans.size());
     }
     this.subSpans = subSpans.toArray(new Spans[subSpans.size()]);
-    this.conjunction = ConjunctionDISI.intersect(subSpans);
+    this.conjunction = ConjunctionDISI.intersect(subSpans, numDocs);
     this.atFirstInCurrentDoc = true; // ensure for doc -1 that start/end positions are -1
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java b/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
index 3c3b771..4eeeae6 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/ContainSpans.java
@@ -28,8 +28,14 @@ abstract class ContainSpans extends ConjunctionSpans {
   Spans bigSpans;
   Spans littleSpans;
 
-  ContainSpans(SpanWeight weight, Similarity.SimScorer simScorer, Spans bigSpans, Spans littleSpans, Spans sourceSpans) {
-    super(Arrays.asList(bigSpans, littleSpans), weight, simScorer);
+  ContainSpans(
+      SpanWeight weight,
+      Similarity.SimScorer simScorer,
+      Spans bigSpans,
+      Spans littleSpans,
+      Spans sourceSpans,
+      long numDocs) {
+    super(Arrays.asList(bigSpans, littleSpans), weight, simScorer, numDocs);
     this.bigSpans = Objects.requireNonNull(bigSpans);
     this.littleSpans = Objects.requireNonNull(littleSpans);
     this.sourceSpans = Objects.requireNonNull(sourceSpans);
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
index c483385..88fbd98 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansOrdered.java
@@ -52,8 +52,13 @@ public class NearSpansOrdered extends ConjunctionSpans {
 
   private final int allowedSlop;
 
-  public NearSpansOrdered(SpanWeight weight, int allowedSlop, List<Spans> subSpans, Similarity.SimScorer simScorer) throws IOException {
-    super(subSpans, weight, simScorer);
+  public NearSpansOrdered(
+      SpanWeight weight,
+      int allowedSlop,
+      List<Spans> subSpans,
+      Similarity.SimScorer simScorer,
+      long numDocs) throws IOException {
+    super(subSpans, weight, simScorer, numDocs);
     this.atFirstInCurrentDoc = true; // -1 startPosition/endPosition also at doc -1
     this.allowedSlop = allowedSlop;
   }
@@ -153,6 +158,12 @@ public class NearSpansOrdered extends ConjunctionSpans {
   }
 
   @Override
+  public long cost() {
+    int costSlop = Math.max(0, allowedSlop);
+    return (long) (super.cost() * (1 + costSlop) / (8 + (double) costSlop));
+  }
+
+  @Override
   public String toString() {
     return "NearSpansOrdered("+weight.getQuery().toString()+")@"+docID()+": "+startPosition()+" - "+endPosition();
   }
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
index cf92e6f..1c45414 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/NearSpansUnordered.java
@@ -38,9 +38,9 @@ public class NearSpansUnordered extends ConjunctionSpans {
 
   private SpanPositionQueue spanPositionQueue;
 
-  public NearSpansUnordered(SpanWeight weight, int allowedSlop, List<Spans> subSpans, Similarity.SimScorer simScorer)
+  public NearSpansUnordered(SpanWeight weight, int allowedSlop, List<Spans> subSpans, Similarity.SimScorer simScorer, long numDocs)
   throws IOException {
-    super(subSpans, weight, simScorer);
+    super(subSpans, weight, simScorer, numDocs);
 
     this.subSpanCells = new ArrayList<>(subSpans.size());
     for (Spans subSpan : subSpans) { // sub spans in query order
@@ -268,6 +268,12 @@ public class NearSpansUnordered extends ConjunctionSpans {
   }
 
   @Override
+  public long cost() {
+    int costSlop = Math.max(0, allowedSlop);
+    return (long) (super.cost() * (1 + costSlop) / (4 + (double) costSlop));
+  }
+
+  @Override
   public String toString() {
     if (minPositionCell() != null) {
       return getClass().getName() + "("+weight.getQuery().toString()+")@"+
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java
index ed5ae9a..dc8966d 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanContainingQuery.java
@@ -71,7 +71,7 @@ public final class SpanContainingQuery extends SpanContainQuery {
       Spans big = containerContained.get(0);
       Spans little = containerContained.get(1);
 
-      return new ContainSpans(this, getSimScorer(context), big, little, big) {
+      return new ContainSpans(this, getSimScorer(context), big, little, big, context.reader().maxDoc()) {
 
         @Override
         boolean twoPhaseCurrentDocMatches() throws IOException {
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
index 33c7d92..182fedd 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanNearQuery.java
@@ -219,8 +219,9 @@ public class SpanNearQuery extends SpanQuery implements Cloneable {
       }
 
       // all NearSpans require at least two subSpans
-      return (!inOrder) ? new NearSpansUnordered(this, slop, subSpans, getSimScorer(context))
-          : new NearSpansOrdered(this, slop, subSpans, getSimScorer(context));
+      long numDocs = context.reader().maxDoc();
+      return (!inOrder) ? new NearSpansUnordered(this, slop, subSpans, getSimScorer(context), numDocs)
+          : new NearSpansOrdered(this, slop, subSpans, getSimScorer(context), numDocs);
     }
 
     @Override
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
index 6fadd60..896947d 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
@@ -176,6 +176,17 @@ public final class SpanOrQuery extends SpanQuery {
 
       SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1
 
+      // Compute cost of disjunction
+      long numDocs = context.reader().maxDoc();
+      double expectNonMatch = 1;
+      for (Spans spans : subSpans) {
+        long subSpansCost = Math.min(spans.cost(), numDocs);
+        assert subSpansCost >= 0;
+        expectNonMatch *= (numDocs - subSpansCost) / (double) numDocs; // independence assumption
+      }
+      final long cost = (long) (numDocs * (1 - expectNonMatch));
+
+
       return new Spans(this, getSimScorer(context)) {
         Spans topPositionSpans = null;
 
@@ -228,7 +239,7 @@ public final class SpanOrQuery extends SpanQuery {
 
           final float matchCost = sumMatchCost / sumApproxCost;
 
-          return new TwoPhaseIterator(new DisjunctionDISIApproximation<Spans>(byDocQueue)) {
+          return new TwoPhaseIterator(new DisjunctionDISIApproximation<Spans>(byDocQueue, numDocs)) {
             @Override
             public boolean matches() throws IOException {
               return twoPhaseCurrentDocMatches();
@@ -357,16 +368,8 @@ public final class SpanOrQuery extends SpanQuery {
           return "spanOr(" + SpanOrQuery.this + ")@" + docID() + ": " + startPosition() + " - " + endPosition();
         }
 
-        long cost = -1;
-
         @Override
         public long cost() {
-          if (cost == -1) {
-            cost = 0;
-            for (Spans spans : subSpans) {
-              cost += spans.cost();
-            }
-          }
           return cost;
         }
       };
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java
index d5cf96f..c48a69b 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanWithinQuery.java
@@ -72,7 +72,7 @@ public final class SpanWithinQuery extends SpanContainQuery {
       Spans big = containerContained.get(0);
       Spans little = containerContained.get(1);
 
-      return new ContainSpans(this, getSimScorer(context), big, little, little) {
+      return new ContainSpans(this, getSimScorer(context), big, little, little, context.reader().maxDoc()) {
 
         @Override
         boolean twoPhaseCurrentDocMatches() throws IOException {
diff --git a/lucene/core/src/test/org/apache/lucene/search/TestConjunctionDISI.java b/lucene/core/src/test/org/apache/lucene/search/TestConjunctionDISI.java
index c907e6e..b27b429 100644
--- a/lucene/core/src/test/org/apache/lucene/search/TestConjunctionDISI.java
+++ b/lucene/core/src/test/org/apache/lucene/search/TestConjunctionDISI.java
@@ -170,7 +170,7 @@ public class TestConjunctionDISI extends LuceneTestCase {
         }
       }
 
-      final ConjunctionDISI conjunction = ConjunctionDISI.intersect(Arrays.asList(iterators));
+      final ConjunctionDISI conjunction = ConjunctionDISI.intersect(Arrays.asList(iterators), maxDoc);
       assertEquals(intersect(sets), toBitSet(maxDoc, conjunction));
     }
   }
@@ -200,7 +200,7 @@ public class TestConjunctionDISI extends LuceneTestCase {
         }
       }
 
-      final ConjunctionDISI conjunction = ConjunctionDISI.intersect(Arrays.asList(iterators));
+      final ConjunctionDISI conjunction = ConjunctionDISI.intersect(Arrays.asList(iterators), maxDoc);
       TwoPhaseIterator twoPhaseIterator = conjunction.asTwoPhaseIterator();
       assertEquals(hasApproximation, twoPhaseIterator != null);
       if (hasApproximation) {
@@ -237,7 +237,7 @@ public class TestConjunctionDISI extends LuceneTestCase {
         if (conjunction == null) {
           conjunction = newIterator;
         } else {
-          final ConjunctionDISI conj = ConjunctionDISI.intersect(Arrays.asList(conjunction, newIterator));
+          final ConjunctionDISI conj = ConjunctionDISI.intersect(Arrays.asList(conjunction, newIterator), maxDoc);
           conjunction = scorer(conj, conj.asTwoPhaseIterator());
         }
       }
@@ -282,9 +282,9 @@ public class TestConjunctionDISI extends LuceneTestCase {
         List<DocIdSetIterator> subIterators = iterators.subList(subSeqStart, subSeqEnd);
         DocIdSetIterator subConjunction;
         if (wrapWithScorer) {
-          subConjunction = new ConjunctionScorer(null, subIterators, Collections.emptyList());
+          subConjunction = new ConjunctionScorer(null, subIterators, Collections.emptyList(), maxDoc);
         } else {
-          subConjunction = ConjunctionDISI.intersect(subIterators);
+          subConjunction = ConjunctionDISI.intersect(subIterators, maxDoc);
         }
         iterators.set(subSeqStart, subConjunction);
         int toRemove = subSeqEnd - subSeqStart - 1;
@@ -298,7 +298,7 @@ public class TestConjunctionDISI extends LuceneTestCase {
       }
 
 
-      final ConjunctionDISI conjunction = ConjunctionDISI.intersect(iterators);
+      final ConjunctionDISI conjunction = ConjunctionDISI.intersect(iterators, maxDoc);
       assertEquals(intersect(sets), toBitSet(maxDoc, conjunction));
     }
   }
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/AssertingBulkScorer.java b/lucene/test-framework/src/java/org/apache/lucene/search/AssertingBulkScorer.java
index 07cdd9d..715cdf4 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/AssertingBulkScorer.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/AssertingBulkScorer.java
@@ -52,7 +52,9 @@ final class AssertingBulkScorer extends BulkScorer {
 
   @Override
   public long cost() {
-    return in.cost();
+    long cost = in.cost();
+    assert cost >= 0 : "cost should be non negative";
+    return cost;
   }
 
   @Override
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java b/lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java
index 78f6f6c..46f5b80 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/AssertingScorer.java
@@ -125,7 +125,9 @@ public class AssertingScorer extends Scorer {
 
   @Override
   public long cost() {
-    return in.cost();
+    long cost = in.cost();
+    assert cost >= 0 : "cost should be non negative";
+    return cost;
   }
 
   @Override
diff --git a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java
index 221c42b..235645e 100644
--- a/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java
+++ b/lucene/test-framework/src/java/org/apache/lucene/search/spans/AssertingSpans.java
@@ -187,7 +187,9 @@ class AssertingSpans extends Spans {
 
   @Override
   public long cost() {
-    return in.cost();
+    long cost = in.cost();
+    assert cost >= 0 : "cost should be non negative";
+    return cost;
   }
 
   @Override
