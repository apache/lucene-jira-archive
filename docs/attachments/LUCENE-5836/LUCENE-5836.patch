Index: lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java	(revision 1612250)
+++ lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.java	(working copy)
@@ -38,6 +38,7 @@
 import org.apache.lucene.store.RAMOutputStream;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.BytesRefBuilder;
 import org.apache.lucene.util.FixedBitSet;
 import org.apache.lucene.util.IOUtils;
 import org.apache.lucene.util.IntsRef;
@@ -373,7 +374,7 @@
 
       TermsWriter termsWriter = new TermsWriter(fieldInfos.fieldInfo(field));
       BytesRef minTerm = null;
-      BytesRef maxTerm = new BytesRef();
+      BytesRefBuilder maxTerm = new BytesRefBuilder();
       while (true) {
         BytesRef term = termsEnum.next();
         if (term == null) {
@@ -382,11 +383,11 @@
         if (minTerm == null) {
           minTerm = BytesRef.deepCopyOf(term);
         }
-        maxTerm.copyBytes(term);
+        maxTerm.copy(term);
         termsWriter.write(term, termsEnum);
       }
 
-      termsWriter.finish(minTerm, minTerm == null ? null : maxTerm);
+      termsWriter.finish(minTerm, minTerm == null ? null : maxTerm.get());
     }
   }
   
Index: lucene/core/src/java/org/apache/lucene/search/FieldComparator.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/search/FieldComparator.java	(revision 1612250)
+++ lucene/core/src/java/org/apache/lucene/search/FieldComparator.java	(working copy)
@@ -27,6 +27,7 @@
 import org.apache.lucene.index.SortedDocValues;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.BytesRef;
+import org.apache.lucene.util.BytesRefBuilder;
 
 /**
  * Expert: a FieldComparator compares hits so as to determine their
@@ -687,7 +688,7 @@
     /* Values for each slot.
        @lucene.internal */
     final BytesRef[] values;
-    private final BytesRef[] tempBRs;
+    private final BytesRefBuilder[] tempBRs;
 
     /* Which reader last copied a value into the slot. When
        we compare two slots, we just compare-by-ord if the
@@ -748,7 +749,7 @@
     public TermOrdValComparator(int numHits, String field, boolean sortMissingLast) {
       ords = new int[numHits];
       values = new BytesRef[numHits];
-      tempBRs = new BytesRef[numHits];
+      tempBRs = new BytesRefBuilder[numHits];
       readerGen = new int[numHits];
       this.field = field;
       if (sortMissingLast) {
@@ -808,10 +809,10 @@
       } else {
         assert ord >= 0;
         if (tempBRs[slot] == null) {
-          tempBRs[slot] = new BytesRef();
+          tempBRs[slot] = new BytesRefBuilder();
         }
-        values[slot] = tempBRs[slot];
-        values[slot].copyBytes(termsIndex.lookupOrd(ord));
+        tempBRs[slot].copy(termsIndex.lookupOrd(ord));
+        values[slot] = tempBRs[slot].get();
       }
       ords[slot] = ord;
       readerGen[slot] = currentReaderGen;
@@ -938,7 +939,7 @@
   public static final class TermValComparator extends FieldComparator<BytesRef> {
     
     private final BytesRef[] values;
-    private final BytesRef[] tempBRs;
+    private final BytesRefBuilder[] tempBRs;
     private BinaryDocValues docTerms;
     private Bits docsWithField;
     private final String field;
@@ -951,7 +952,7 @@
     /** Sole constructor. */
     public TermValComparator(int numHits, String field, boolean sortMissingLast) {
       values = new BytesRef[numHits];
-      tempBRs = new BytesRef[numHits];
+      tempBRs = new BytesRefBuilder[numHits];
       this.field = field;
       missingSortCmp = sortMissingLast ? 1 : -1;
     }
@@ -976,10 +977,10 @@
         values[slot] = null;
       } else {
         if (tempBRs[slot] == null) {
-          tempBRs[slot] = new BytesRef();
+          tempBRs[slot] = new BytesRefBuilder();
         }
-        values[slot] = tempBRs[slot];
-        values[slot].copyBytes(comparableBytes);
+        tempBRs[slot].copy(comparableBytes);
+        values[slot] = tempBRs[slot].get();
       }
     }
 
Index: lucene/core/src/java/org/apache/lucene/util/BytesRef.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/BytesRef.java	(revision 1612250)
+++ lucene/core/src/java/org/apache/lucene/util/BytesRef.java	(working copy)
@@ -17,6 +17,7 @@
  * limitations under the License.
  */
 
+import java.util.Arrays;
 import java.util.Comparator;
 
 /** Represents byte[], as a slice (offset + length) into an
@@ -83,17 +84,6 @@
     this();
     copyChars(text);
   }
-
-  /**
-   * Copies the UTF8 bytes for this string.
-   * 
-   * @param text Must be well-formed unicode text, with no
-   * unpaired surrogates or invalid UTF16 code units.
-   */
-  public void copyChars(CharSequence text) {
-    assert offset == 0;   // TODO broken if offset != 0
-    UnicodeUtil.UTF16toUTF8(text, 0, text.length(), this);
-  }
   
   /**
    * Expert: compares the bytes against another BytesRef,
@@ -176,49 +166,6 @@
     return sb.toString();
   }
 
-  /**
-   * Copies the bytes from the given {@link BytesRef}
-   * <p>
-   * NOTE: if this would exceed the array size, this method creates a 
-   * new reference array.
-   */
-  public void copyBytes(BytesRef other) {
-    if (bytes.length - offset < other.length) {
-      bytes = new byte[other.length];
-      offset = 0;
-    }
-    System.arraycopy(other.bytes, other.offset, bytes, offset, other.length);
-    length = other.length;
-  }
-
-  /**
-   * Appends the bytes from the given {@link BytesRef}
-   * <p>
-   * NOTE: if this would exceed the array size, this method creates a 
-   * new reference array.
-   */
-  public void append(BytesRef other) {
-    int newLen = length + other.length;
-    if (bytes.length - offset < newLen) {
-      byte[] newBytes = new byte[newLen];
-      System.arraycopy(bytes, offset, newBytes, 0, length);
-      offset = 0;
-      bytes = newBytes;
-    }
-    System.arraycopy(other.bytes, other.offset, bytes, length+offset, other.length);
-    length = newLen;
-  }
-
-  /** 
-   * Used to grow the reference array. 
-   * 
-   * In general this should not be used as it does not take the offset into account.
-   * @lucene.internal */
-  public void grow(int newLength) {
-    assert offset == 0; // NOTE: senseless if offset != 0
-    bytes = ArrayUtil.grow(bytes, newLength);
-  }
-
   /** Unsigned byte order comparison */
   @Override
   public int compareTo(BytesRef other) {
@@ -331,7 +278,9 @@
    */
   public static BytesRef deepCopyOf(BytesRef other) {
     BytesRef copy = new BytesRef();
-    copy.copyBytes(other);
+    copy.bytes = Arrays.copyOfRange(other.bytes, other.offset, other.offset + other.length);
+    copy.offset = 0;
+    copy.length = other.length;
     return copy;
   }
   
Index: lucene/core/src/java/org/apache/lucene/util/BytesRefBuilder.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/BytesRefBuilder.java	(revision 0)
+++ lucene/core/src/java/org/apache/lucene/util/BytesRefBuilder.java	(working copy)
@@ -0,0 +1,91 @@
+package org.apache.lucene.util;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * A builder for {@link BytesRef} instances.
+ * @lucene.internal
+ */
+public class BytesRefBuilder {
+
+  private byte[] bytes;
+  private int length;
+
+  private final BytesRef ref;
+
+  /** Sole constructor. */
+  public BytesRefBuilder() {
+    bytes = BytesRef.EMPTY_BYTES;
+    length = 0;
+    ref = new BytesRef();
+  }
+
+  /**
+   * Append the provided bytes to this builder.
+   */
+  public void append(byte[] b, int off, int len) {
+    bytes = ArrayUtil.grow(bytes, length + len);
+    System.arraycopy(b, off, bytes, length, len);
+    length += len;
+  }
+
+  /**
+   * Append the provided bytes to this builder.
+   */
+  public void append(BytesRef ref) {
+    append(ref.bytes, ref.offset, ref.length);
+  }
+
+  /**
+   * Reset this builder to the empty state.
+   */
+  public void clear() {
+    length = 0;
+  }
+
+  /**
+   * Replace the content of this builder with the provided bytes. Equivalent to
+   * calling {@link #clear()} and then {@link #append(byte[], int, int)}.
+   */
+  public void copy(byte[] b, int off, int len) {
+    clear();
+    append(b, off, len);
+  }
+
+  /**
+   * Replace the content of this builder with the provided bytes. Equivalent to
+   * calling {@link #clear()} and then {@link #append(BytesRef)}.
+   */
+  public void copy(BytesRef ref) {
+    clear();
+    append(ref);
+  }
+
+  /**
+   * Return a {@link BytesRef} that points to the internal content of this
+   * builder. Any update to the content of this builder might be reflected to
+   * the provided <code>ref</code> and vice-versa.
+   */
+  public BytesRef get() {
+    ref.offset = 0;
+    ref.bytes = bytes;
+    ref.length = length;
+    return ref;
+  }
+
+}

Property changes on: lucene/core/src/java/org/apache/lucene/util/BytesRefBuilder.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
