Index: lucene/core/src/java/org/apache/lucene/util/Constants.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/Constants.java	(revision 1367570)
+++ lucene/core/src/java/org/apache/lucene/util/Constants.java	(working copy)
@@ -17,7 +17,9 @@
  * limitations under the License.
  */
 
+import java.lang.management.ManagementFactory;
 import java.lang.reflect.Field;
+import java.lang.reflect.Method;
 import java.util.Collections;
 import org.apache.lucene.LucenePackage;
 
@@ -108,6 +110,30 @@
     } else {
       JRE_IS_MINIMUM_JAVA8 = false;
     }
+
+    boolean checkJVM = Boolean.parseBoolean(System.getProperties().getProperty("lucene.checkJVMVersion", "true"));
+
+    if (checkJVM && "21.0-b17".equals(JVM_VERSION) && "Oracle Corporation".equals(JVM_VENDOR)) {
+      boolean useLoopPredicate = true;
+      try {
+        final Class<?> beanClazz = Class.forName("com.sun.management.HotSpotDiagnosticMXBean");
+        final Object hotSpotBean = ManagementFactory.newPlatformMXBeanProxy(
+          ManagementFactory.getPlatformMBeanServer(),
+          "com.sun.management:type=HotSpotDiagnostic",
+          beanClazz
+        );
+        final Method getVMOptionMethod = beanClazz.getMethod("getVMOption", String.class);
+        final Object vmOption = getVMOptionMethod.invoke(hotSpotBean, "UseLoopPredicate");
+        useLoopPredicate = Boolean.parseBoolean(
+            vmOption.getClass().getMethod("getValue").invoke(vmOption).toString()
+        );
+      } catch (Exception e) {
+        // Ignore.
+      }
+      if (useLoopPredicate) {
+        throw new RuntimeException("This JVM is incompatible with Lucene, please run with -XX:-UseLoopPredicate");
+      }
+    }
   }
 
   // this method prevents inlining the final version constant in compiled classes,
