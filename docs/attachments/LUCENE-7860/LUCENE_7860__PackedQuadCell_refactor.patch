Index: lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree.java	(revision 38741ece587f2bfb4a2f6393ea84684f44a52dd5)
+++ lucene/spatial-extras/src/java/org/apache/lucene/spatial/prefix/tree/PackedQuadPrefixTree.java	(revision )
@@ -29,6 +29,8 @@
 import org.locationtech.spatial4j.shape.SpatialRelation;
 import org.locationtech.spatial4j.shape.impl.RectangleImpl;
 
+import static org.apache.lucene.spatial.prefix.tree.LegacyCell.compare;
+
 /**
  * Uses a compact binary representation of 8 bytes to encode a spatial quad trie.
  *
@@ -154,16 +156,13 @@
   }
 
   /** See binary representation in the javadocs of {@link PackedQuadPrefixTree}. */
-  protected class PackedQuadCell extends QuadCell {
+  protected class PackedQuadCell implements Cell {
     private long term;
+    private SpatialRelation shapeRel;
+    private Shape shape;//cached
 
     PackedQuadCell(long term) {
-      super(null, 0, 0);
       this.term = term;
-      this.b_off = 0;
-      this.bytes = longToByteArray(this.term, new byte[8]);
-      this.b_len = 8;
-      readLeafAdjust();
     }
 
     PackedQuadCell(long term, SpatialRelation shapeRel) {
@@ -171,15 +170,20 @@
       this.shapeRel = shapeRel;
     }
 
-    @Override
     protected void readCell(BytesRef bytes) {
+      this.term = longFromByteArray(bytes.bytes, bytes.offset);
       shapeRel = null;
       shape = null;
-      this.bytes = bytes.bytes;
-      this.b_off = bytes.offset;
-      this.b_len = (short) bytes.length;
-      this.term = longFromByteArray(this.bytes, bytes.offset);
-      readLeafAdjust();
+    }
+
+    @Override
+    public SpatialRelation getShapeRel() {
+      return shapeRel;
+    }
+
+    @Override
+    public void setShapeRel(SpatialRelation rel) {
+      this.shapeRel = rel;
     }
 
     private final int getShiftForLevel(final int level) {
@@ -220,11 +224,13 @@
     }
 
     @Override
-    protected void readLeafAdjust() {
-      isLeaf = ((0x1L)&term) == 0x1L;
-      if (getLevel() == getMaxLevels()) {
-        isLeaf = true;
-      }
+    public boolean isLeaf() {
+      return ((0x1L)&term) == 0x1L || getLevel() == getMaxLevels();
+    }
+
+    @Override
+    public void setLeaf() {
+      term |= 0x1L; // set the right most bit (the leaf bit)
     }
 
     @Override
@@ -270,6 +276,17 @@
     }
 
     @Override
+    public CellIterator getNextLevelCells(Shape shapeFilter) {
+      assert getLevel() < getMaxLevels();
+      if (shapeFilter instanceof Point) {
+        PackedQuadCell cell = getSubCell((Point) shapeFilter);
+        cell.shapeRel = SpatialRelation.CONTAINS;
+        return new SingletonCellIterator(cell);
+      } else {
+        return new FilterCellIterator(getSubCells().iterator(), shapeFilter);
+      }
+    }
+
     protected Collection<Cell> getSubCells() {
       List<Cell> cells = new ArrayList<>(4);
       PackedQuadCell pqc = (new PackedQuadCell(((term&0x1)==0x1) ? this.term-1 : this.term))
@@ -281,8 +298,7 @@
       return cells;
     }
 
-    @Override
-    protected QuadCell getSubCell(Point p) {
+    protected PackedQuadCell getSubCell(Point p) {
       return (PackedQuadCell) PackedQuadPrefixTree.this.getCell(p, getLevel() + 1);//not performant!
     }
 
@@ -302,10 +318,16 @@
       return this.term | (((long)(postfix))<<((getMaxLevels()-getLevel()<<1)+6));
     }
 
-    /**
-     * Constructs a bounding box shape out of the encoded cell
-     */
     @Override
+    public Shape getShape() {
+      if (shape == null)
+        shape = makeShape();
+      return shape;
+    }
+
+    /**
+     * Constructs a bounding box shape out of the encoded cell
+     */
     protected Rectangle makeShape() {
       double xmin = PackedQuadPrefixTree.this.xmin;
       double ymin = PackedQuadPrefixTree.this.ymin;
@@ -378,6 +400,23 @@
         s.append(Long.toBinaryString(term));
       return s.toString();
     }
+
+    @Override
+    public boolean equals(Object obj) {
+      //this method isn't "normally" called; just in asserts/tests
+      if (obj instanceof Cell) {
+        Cell cell = (Cell) obj;
+        return getTokenBytesWithLeaf(null).equals(cell.getTokenBytesWithLeaf(null));
+      } else {
+        return false;
+      }
+    }
+
+    @Override
+    public int hashCode() {
+      return getTokenBytesWithLeaf(null).hashCode();
+    }
+
   } // PackedQuadCell
 
   /** This is a streamlined version of TreeCellIterator, with built-in support to prune at detailLevel
