Index: lucene/src/test/org/apache/lucene/search/TestFCValueListener.java
===================================================================
--- lucene/src/test/org/apache/lucene/search/TestFCValueListener.java	(revision 0)
+++ lucene/src/test/org/apache/lucene/search/TestFCValueListener.java	(revision 0)
@@ -0,0 +1,81 @@
+package org.apache.lucene.search;
+
+/**
+ * Copyright 2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.lucene.analysis.core.WhitespaceAnalyzer;
+import org.apache.lucene.document.Document;
+import org.apache.lucene.document.Field;
+import org.apache.lucene.index.IndexReader;
+import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.index.IndexWriterConfig;
+import org.apache.lucene.search.FieldCacheImpl.Entry;
+import org.apache.lucene.search.FieldCacheImpl.ValueCreationListener;
+import org.apache.lucene.search.SortField.Type;
+import org.apache.lucene.store.RAMDirectory;
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.Version;
+
+public class TestFCValueListener extends LuceneTestCase {
+  AtomicInteger seq = new AtomicInteger(0);
+  
+  public void test() throws Exception {
+    IndexWriterConfig iwc = new IndexWriterConfig(Version.LUCENE_40,
+        new WhitespaceAnalyzer(Version.LUCENE_40));
+    RAMDirectory dir = new RAMDirectory();
+    IndexWriter writer = new IndexWriter(dir, iwc);
+    for (int x=0; x < 10; x++) {
+      writer.addDocument(createDoc1(seq.getAndIncrement()));
+    }
+    FieldCacheImpl fc = (FieldCacheImpl)FieldCache.DEFAULT;
+    
+    VCHandler vcHandler = new VCHandler();
+    
+    // add a value creation listener
+    fc.addValueCreationListener(vcHandler);
+    
+    IndexReader reader = IndexReader.open(writer, true);
+    IndexSearcher searcher = new IndexSearcher(reader);
+    
+    // generate field caches
+    searcher.search(new MatchAllDocsQuery(), 10, new Sort(new SortField("id", Type.INT)));
+    
+    assertTrue(vcHandler.fieldValueCreated);
+    
+    reader.close();
+    writer.close();
+    dir.close();
+  }
+  
+  public class VCHandler extends ValueCreationListener {
+    boolean fieldValueCreated = false;
+    
+    public void fieldValueCreated(IndexReader reader, Entry entry, Object values) {
+      System.out.println("fieldValueCreated reader:"+reader+" entry:"+entry+" values:"+values);
+      fieldValueCreated = true;
+    }
+  }
+  
+  public static Document createDoc1(int id) {
+    Document doc = new Document();
+    doc.add(new Field("id", id+"", Field.Store.YES, Field.Index.NOT_ANALYZED_NO_NORMS));
+    doc.add(new Field("text", "motorola hp", Field.Store.YES,
+        Field.Index.ANALYZED));
+    return doc;
+  }
+}
Index: lucene/src/java/org/apache/lucene/search/cache/CachedArray.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/cache/CachedArray.java	(revision 1160882)
+++ lucene/src/java/org/apache/lucene/search/cache/CachedArray.java	(working copy)
@@ -22,8 +22,8 @@
 public abstract class CachedArray 
 {
   public Integer parserHashCode; // a flag to make sure you don't change what you are asking for in subsequent requests
-  public int numDocs;
-  public int numTerms;
+  public volatile int numDocs;
+  public volatile int numTerms;
 
   /**
    * NOTE: these Bits may have false positives for deleted documents.  That is,
@@ -47,32 +47,32 @@
   //-------------------------------------------------------------
 
   public static class ByteValues extends CachedArray {
-    public byte[] values = null;
+    public volatile byte[] values = null;
     @Override public byte[] getRawArray() { return values; }
   };
 
   public static class ShortValues extends CachedArray {
-    public short[] values = null;
+    public volatile short[] values = null;
     @Override public short[] getRawArray() { return values; }
   };
 
   public static class IntValues extends CachedArray {
-    public int[] values = null;
+    public volatile int[] values = null;
     @Override public int[] getRawArray() { return values; }
   };
 
   public static class FloatValues extends CachedArray {
-    public float[] values = null;
+    public volatile float[] values = null;
     @Override public float[] getRawArray() { return values; }
   };
 
   public static class LongValues extends CachedArray {
-    public long[] values = null;
+    public volatile long[] values = null;
     @Override public long[] getRawArray() { return values; }
   };
 
   public static class DoubleValues extends CachedArray {
-    public double[] values = null;
+    public volatile double[] values = null;
     @Override public double[] getRawArray() { return values; }
   };
 }
Index: lucene/src/java/org/apache/lucene/search/FieldCacheImpl.java
===================================================================
--- lucene/src/java/org/apache/lucene/search/FieldCacheImpl.java	(revision 1160882)
+++ lucene/src/java/org/apache/lucene/search/FieldCacheImpl.java	(working copy)
@@ -39,7 +39,8 @@
  * @since   lucene 1.4
  */
 public class FieldCacheImpl implements FieldCache {  // Made Public so that 
-	
+  private List<ValueCreationListener> valueCreationListeners; 
+  
   private Map<Class<?>,Cache> caches;
   FieldCacheImpl() {
     init();
@@ -57,6 +58,13 @@
     caches.put(DocTermOrds.class, new Cache<DocTermOrds>(this));
   }
   
+  public synchronized void addValueCreationListener(ValueCreationListener listener) {
+    if (valueCreationListeners == null) {
+      valueCreationListeners = new ArrayList<ValueCreationListener>();
+    }
+    valueCreationListeners.add(listener);
+  }
+  
   public synchronized void purgeAllCaches() {
     init();
   }
@@ -127,7 +135,23 @@
       FieldCache.DEFAULT.purge(reader);
     }
   };
+  
+  /**
+   * When a field value / entry is created, notify the given
+   * listener(s). 
+   */
+  public static abstract class ValueCreationListener {
+    public abstract void fieldValueCreated(IndexReader reader, Entry entry, Object obj);
+  }
 
+  private void notifyValueCreationListeners(IndexReader reader, Entry entry, Object value) {
+    if (valueCreationListeners != null) {
+      for (ValueCreationListener listener : valueCreationListeners) {
+        listener.fieldValueCreated(reader, entry, value);
+      }
+    }
+  }
+  
   /** Expert: Internal cache. */
   final static class Cache<T> {
     Cache() {
@@ -182,6 +206,9 @@
             progress.value = createValue(reader, key);
             synchronized (readerCache) {
               innerCache.put(key, progress.value);
+              if (wrapper instanceof FieldCacheImpl) {
+                ((FieldCacheImpl)wrapper).notifyValueCreationListeners(reader, key, progress.value);
+              }
             }
 
             // Only check if key.custom (the parser) is
