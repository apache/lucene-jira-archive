Index: lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java	(revision 1614370)
+++ lucene/core/src/java/org/apache/lucene/util/FixedBitSet.java	(working copy)
@@ -63,8 +63,7 @@
         return doc = NO_MORE_DOCS;
       }
       int i = doc >> 6;
-      final int subIndex = doc & 0x3f;      // index within the word
-      long word = bits[i] >> subIndex;  // skip all the bits to the right of index
+      long word = bits[i] >> doc;  // skip all the bits to the right of index
       
       if (word != 0) {
         return doc = doc + Long.numberOfTrailingZeros(word);
@@ -96,8 +95,7 @@
         return doc = NO_MORE_DOCS;
       }
       int i = target >> 6;
-      final int subIndex = target & 0x3f; // index within the word
-      long word = bits[i] >> subIndex; // skip all the bits to the right of index
+      long word = bits[i] >> target; // skip all the bits to the right of index
       
       if (word != 0) {
         return doc = target + Long.numberOfTrailingZeros(word);
@@ -243,8 +241,7 @@
     int i = index >> 6;               // div 64
     // signed shift will keep a negative index and force an
     // array-index-out-of-bounds-exception, removing the need for an explicit check.
-    int bit = index & 0x3f;           // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     return (bits[i] & bitmask) != 0;
   }
 
@@ -251,8 +248,7 @@
   public void set(int index) {
     assert index >= 0 && index < numBits: "index=" + index + ", numBits=" + numBits;
     int wordNum = index >> 6;      // div 64
-    int bit = index & 0x3f;     // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] |= bitmask;
   }
 
@@ -259,8 +255,7 @@
   public boolean getAndSet(int index) {
     assert index >= 0 && index < numBits;
     int wordNum = index >> 6;      // div 64
-    int bit = index & 0x3f;     // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     boolean val = (bits[wordNum] & bitmask) != 0;
     bits[wordNum] |= bitmask;
     return val;
@@ -269,8 +264,7 @@
   public void clear(int index) {
     assert index >= 0 && index < numBits;
     int wordNum = index >> 6;
-    int bit = index & 0x03f;
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] &= ~bitmask;
   }
 
@@ -277,8 +271,7 @@
   public boolean getAndClear(int index) {
     assert index >= 0 && index < numBits;
     int wordNum = index >> 6;      // div 64
-    int bit = index & 0x3f;     // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     boolean val = (bits[wordNum] & bitmask) != 0;
     bits[wordNum] &= ~bitmask;
     return val;
@@ -290,8 +283,7 @@
   public int nextSetBit(int index) {
     assert index >= 0 && index < numBits : "index=" + index + ", numBits=" + numBits;
     int i = index >> 6;
-    final int subIndex = index & 0x3f;      // index within the word
-    long word = bits[i] >> subIndex;  // skip all the bits to the right of index
+    long word = bits[i] >> index;  // skip all the bits to the right of index
 
     if (word!=0) {
       return index + Long.numberOfTrailingZeros(word);
Index: lucene/core/src/java/org/apache/lucene/util/LongBitSet.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/LongBitSet.java	(revision 1614370)
+++ lucene/core/src/java/org/apache/lucene/util/LongBitSet.java	(working copy)
@@ -101,8 +101,7 @@
     int i = (int) (index >> 6);               // div 64
     // signed shift will keep a negative index and force an
     // array-index-out-of-bounds-exception, removing the need for an explicit check.
-    int bit = (int) (index & 0x3f);           // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     return (bits[i] & bitmask) != 0;
   }
 
@@ -109,8 +108,7 @@
   public void set(long index) {
     assert index >= 0 && index < numBits: "index=" + index + " numBits=" + numBits;
     int wordNum = (int) (index >> 6);      // div 64
-    int bit = (int) (index & 0x3f);     // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] |= bitmask;
   }
 
@@ -117,8 +115,7 @@
   public boolean getAndSet(long index) {
     assert index >= 0 && index < numBits;
     int wordNum = (int) (index >> 6);      // div 64
-    int bit = (int) (index & 0x3f);     // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     boolean val = (bits[wordNum] & bitmask) != 0;
     bits[wordNum] |= bitmask;
     return val;
@@ -127,8 +124,7 @@
   public void clear(long index) {
     assert index >= 0 && index < numBits;
     int wordNum = (int) (index >> 6);
-    int bit = (int) (index & 0x03f);
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] &= ~bitmask;
   }
 
@@ -135,8 +131,7 @@
   public boolean getAndClear(long index) {
     assert index >= 0 && index < numBits;
     int wordNum = (int) (index >> 6);      // div 64
-    int bit = (int) (index & 0x3f);     // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     boolean val = (bits[wordNum] & bitmask) != 0;
     bits[wordNum] &= ~bitmask;
     return val;
@@ -148,8 +143,7 @@
   public long nextSetBit(long index) {
     assert index >= 0 && index < numBits;
     int i = (int) (index >> 6);
-    final int subIndex = (int) (index & 0x3f);      // index within the word
-    long word = bits[i] >> subIndex;  // skip all the bits to the right of index
+    long word = bits[i] >> index;  // skip all the bits to the right of index
 
     if (word!=0) {
       return index + Long.numberOfTrailingZeros(word);
Index: lucene/core/src/java/org/apache/lucene/util/OpenBitSet.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/OpenBitSet.java	(revision 1614370)
+++ lucene/core/src/java/org/apache/lucene/util/OpenBitSet.java	(working copy)
@@ -172,8 +172,7 @@
     // array-index-out-of-bounds-exception, removing the need for an explicit check.
     if (i>=bits.length) return false;
 
-    int bit = index & 0x3f;           // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     return (bits[i] & bitmask) != 0;
   }
 
@@ -186,8 +185,7 @@
     int i = index >> 6;               // div 64
     // signed shift will keep a negative index and force an
     // array-index-out-of-bounds-exception, removing the need for an explicit check.
-    int bit = index & 0x3f;           // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     return (bits[i] & bitmask) != 0;
   }
 
@@ -198,8 +196,7 @@
   public boolean get(long index) {
     int i = (int)(index >> 6);             // div 64
     if (i>=bits.length) return false;
-    int bit = (int)index & 0x3f;           // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     return (bits[i] & bitmask) != 0;
   }
 
@@ -209,8 +206,7 @@
   public boolean fastGet(long index) {
     assert index >= 0 && index < numBits;
     int i = (int)(index >> 6);               // div 64
-    int bit = (int)index & 0x3f;           // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     return (bits[i] & bitmask) != 0;
   }
 
@@ -233,8 +229,7 @@
   public int getBit(int index) {
     assert index >= 0 && index < numBits;
     int i = index >> 6;                // div 64
-    int bit = index & 0x3f;            // mod 64
-    return ((int)(bits[i]>>>bit)) & 0x01;
+    return ((int)(bits[i]>>>index)) & 0x01;
   }
 
 
@@ -250,8 +245,7 @@
   /** sets a bit, expanding the set size if necessary */
   public void set(long index) {
     int wordNum = expandingWordNum(index);
-    int bit = (int)index & 0x3f;
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] |= bitmask;
   }
 
@@ -262,8 +256,7 @@
   public void fastSet(int index) {
     assert index >= 0 && index < numBits;
     int wordNum = index >> 6;      // div 64
-    int bit = index & 0x3f;     // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] |= bitmask;
   }
 
@@ -273,8 +266,7 @@
   public void fastSet(long index) {
     assert index >= 0 && index < numBits;
     int wordNum = (int)(index >> 6);
-    int bit = (int)index & 0x3f;
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] |= bitmask;
   }
 
@@ -319,8 +311,7 @@
   public void fastClear(int index) {
     assert index >= 0 && index < numBits;
     int wordNum = index >> 6;
-    int bit = index & 0x03f;
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] &= ~bitmask;
     // hmmm, it takes one more instruction to clear than it does to set... any
     // way to work around this?  If there were only 63 bits per word, we could
@@ -337,8 +328,7 @@
   public void fastClear(long index) {
     assert index >= 0 && index < numBits;
     int wordNum = (int)(index >> 6); // div 64
-    int bit = (int)index & 0x3f;     // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] &= ~bitmask;
   }
 
@@ -346,8 +336,7 @@
   public void clear(long index) {
     int wordNum = (int)(index >> 6); // div 64
     if (wordNum>=wlen) return;
-    int bit = (int)index & 0x3f;     // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] &= ~bitmask;
   }
 
@@ -432,8 +421,7 @@
   public boolean getAndSet(int index) {
     assert index >= 0 && index < numBits;
     int wordNum = index >> 6;      // div 64
-    int bit = index & 0x3f;     // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     boolean val = (bits[wordNum] & bitmask) != 0;
     bits[wordNum] |= bitmask;
     return val;
@@ -445,8 +433,7 @@
   public boolean getAndSet(long index) {
     assert index >= 0 && index < numBits;
     int wordNum = (int)(index >> 6);      // div 64
-    int bit = (int)index & 0x3f;     // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     boolean val = (bits[wordNum] & bitmask) != 0;
     bits[wordNum] |= bitmask;
     return val;
@@ -458,8 +445,7 @@
   public void fastFlip(int index) {
     assert index >= 0 && index < numBits;
     int wordNum = index >> 6;      // div 64
-    int bit = index & 0x3f;     // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] ^= bitmask;
   }
 
@@ -469,8 +455,7 @@
   public void fastFlip(long index) {
     assert index >= 0 && index < numBits;
     int wordNum = (int)(index >> 6);   // div 64
-    int bit = (int)index & 0x3f;       // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] ^= bitmask;
   }
 
@@ -477,8 +462,7 @@
   /** flips a bit, expanding the set size if necessary */
   public void flip(long index) {
     int wordNum = expandingWordNum(index);
-    int bit = (int)index & 0x3f;       // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] ^= bitmask;
   }
 
@@ -488,8 +472,7 @@
   public boolean flipAndGet(int index) {
     assert index >= 0 && index < numBits;
     int wordNum = index >> 6;      // div 64
-    int bit = index & 0x3f;     // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] ^= bitmask;
     return (bits[wordNum] & bitmask) != 0;
   }
@@ -500,8 +483,7 @@
   public boolean flipAndGet(long index) {
     assert index >= 0 && index < numBits;
     int wordNum = (int)(index >> 6);   // div 64
-    int bit = (int)index & 0x3f;       // mod 64
-    long bitmask = 1L << bit;
+    long bitmask = 1L << index;
     bits[wordNum] ^= bitmask;
     return (bits[wordNum] & bitmask) != 0;
   }
