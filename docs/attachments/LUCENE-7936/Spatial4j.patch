Index: lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dSpatialContext.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dSpatialContext.java	(revision )
+++ lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dSpatialContext.java	(revision )
@@ -0,0 +1,102 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.spatial4j;
+
+import org.apache.lucene.spatial3d.geom.GeoBBox;
+import org.apache.lucene.spatial3d.geom.GeoBBoxFactory;
+import org.apache.lucene.spatial3d.geom.PlanetModel;
+import org.locationtech.spatial4j.context.SpatialContext;
+import org.locationtech.spatial4j.context.SpatialContextFactory;
+import org.locationtech.spatial4j.distance.DistanceCalculator;
+import org.locationtech.spatial4j.io.BinaryCodec;
+import org.locationtech.spatial4j.io.SupportedFormats;
+import org.locationtech.spatial4j.shape.Point;
+import org.locationtech.spatial4j.shape.Rectangle;
+import org.locationtech.spatial4j.shape.ShapeFactory;
+
+/**
+ * Spatial context for Geo3dAreaShapes
+ */
+public class Geo3dSpatialContext extends SpatialContext {
+
+  protected PlanetModel planetModel;
+  SpatialContextFactory factory;
+  ShapeFactory shapeFactory;
+
+  public Geo3dSpatialContext(PlanetModel planetModel, SpatialContextFactory factory) {
+    super(factory);
+    this.planetModel = planetModel;
+    this.factory = factory;
+    shapeFactory = new Geo3dAreaShapeFactory(this, planetModel);
+  }
+
+  @Override
+  public ShapeFactory getShapeFactory() {
+    return shapeFactory;
+  }
+
+  @Override
+  public SupportedFormats getFormats() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public DistanceCalculator getDistCalc() {
+    return super.getDistCalc();
+  }
+
+  @Override
+  public double calcDistance(Point p, double x2, double y2) {
+    return super.calcDistance(p, x2, y2);
+  }
+
+  @Override
+  public double calcDistance(Point p, Point p2) {
+    return super.calcDistance(p, p2);
+  }
+
+  @Override
+  public Rectangle getWorldBounds() {
+    GeoBBox bBox = GeoBBoxFactory.makeGeoBBox(planetModel,
+                                              planetModel.NORTH_POLE.getLatitude(),
+                                              planetModel.SOUTH_POLE.getLatitude(),
+                                              planetModel.MIN_Y_POLE.getLongitude(),
+                                              planetModel.MAX_Y_POLE.getLongitude());
+    return new Geo3dAreaRectangle(this, bBox);
+  }
+
+  @Override
+  public boolean isGeo() {
+    return true;
+  }
+
+  @Override
+  public Rectangle makeRectangle(Point lowerLeft, Point upperRight) {
+    return shapeFactory.rect(lowerLeft, upperRight);
+  }
+
+  @Override
+  public Rectangle makeRectangle(double minX, double maxX, double minY, double maxY) {
+    return shapeFactory.rect(minX, maxX, minY, maxY);
+  }
+
+  @Override
+  public BinaryCodec getBinaryCodec() {
+    return new Geo3dBinaryCodec(this, factory);
+  }
+}
Index: lucene/spatial-extras/src/test/org/apache/lucene/spatial/spatial4j/Geo3dAreaRptTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial-extras/src/test/org/apache/lucene/spatial/spatial4j/Geo3dAreaRptTest.java	(revision )
+++ lucene/spatial-extras/src/test/org/apache/lucene/spatial/spatial4j/Geo3dAreaRptTest.java	(revision )
@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.spatial.spatial4j;
+
+import java.io.IOException;
+
+import com.carrotsearch.randomizedtesting.annotations.Repeat;
+import org.apache.lucene.spatial.composite.CompositeSpatialStrategy;
+import org.apache.lucene.spatial.prefix.RandomSpatialOpStrategyTestCase;
+import org.apache.lucene.spatial.prefix.RecursivePrefixTreeStrategy;
+import org.apache.lucene.spatial.prefix.tree.GeohashPrefixTree;
+import org.apache.lucene.spatial.prefix.tree.SpatialPrefixTree;
+import org.apache.lucene.spatial.query.SpatialOperation;
+import org.apache.lucene.spatial.serialized.SerializedDVStrategy;
+import org.apache.lucene.spatial3d.geom.GeoAreaShape;
+import org.apache.lucene.spatial3d.geom.GeoPoint;
+import org.apache.lucene.spatial3d.geom.PlanetModel;
+import org.apache.lucene.spatial3d.geom.RandomGeoShapeGenerator;
+import org.junit.Test;
+import org.locationtech.spatial4j.context.SpatialContext;
+import org.locationtech.spatial4j.context.SpatialContextFactory;
+import org.locationtech.spatial4j.shape.Shape;
+
+public class Geo3dAreaRptTest extends RandomSpatialOpStrategyTestCase {
+
+  private SpatialPrefixTree grid;
+  private RecursivePrefixTreeStrategy rptStrategy;
+
+  SpatialContext ctx;
+  RandomGeoShapeGenerator shapeGenerator = new RandomGeoShapeGenerator();
+  PlanetModel planetModel;
+
+  private void setupGeohashGrid() {
+    planetModel = shapeGenerator.randomPlanetModel();
+    ctx = new Geo3dSpatialContext(planetModel, new SpatialContextFactory());
+    this.grid = new GeohashPrefixTree(ctx, 5);//A fairly shallow grid
+    this.rptStrategy = newRPT();
+  }
+
+  protected RecursivePrefixTreeStrategy newRPT() {
+    final RecursivePrefixTreeStrategy rpt = new RecursivePrefixTreeStrategy(this.grid,
+        getClass().getSimpleName() + "_rpt");
+    rpt.setDistErrPct(0.10);//not too many cells
+    return rpt;
+  }
+
+  private void setupStrategy() {
+    //setup
+    setupGeohashGrid();
+
+    SerializedDVStrategy serializedDVStrategy = new SerializedDVStrategy(ctx, getClass().getSimpleName() + "_sdv");
+    this.strategy = new CompositeSpatialStrategy("composite_" + getClass().getSimpleName(),
+        rptStrategy, serializedDVStrategy);
+  }
+
+
+  @Test
+  @Repeat(iterations = 100)
+  public void testOperations() throws IOException {
+    setupStrategy();
+
+    testOperationRandomShapes(SpatialOperation.Intersects);
+  }
+
+
+  @Override
+  protected Shape randomIndexedShape() {
+    boolean point = random().nextBoolean();
+    if (point){
+      GeoPoint geoPoint = shapeGenerator.randomGeoPoint(planetModel, shapeGenerator.getEmptyConstraint());
+      return new Geo3dAreaPoint(geoPoint.x, geoPoint.y, geoPoint.z);
+    }
+    int type = shapeGenerator.randomShapeType();
+    while (type == 4) {//COMPLEX
+      type = shapeGenerator.randomShapeType();
+    }
+    GeoAreaShape areaShape = (GeoAreaShape)shapeGenerator.randomGeoShape(type, planetModel);
+    return new Geo3dAreaShape<>(ctx, areaShape);
+  }
+
+  @Override
+  protected Shape randomQueryShape() {
+    int type = shapeGenerator.randomShapeType();
+    while (type == 4) {//COMPLEX
+      type = shapeGenerator.randomShapeType();
+    }
+    GeoAreaShape areaShape = (GeoAreaShape)shapeGenerator.randomGeoShape(type, planetModel);
+    return new Geo3dAreaShape<>(ctx, areaShape);
+  }
+}
Index: lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dAreaShape.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dAreaShape.java	(revision )
+++ lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dAreaShape.java	(revision )
@@ -0,0 +1,136 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.spatial4j;
+
+import org.apache.lucene.spatial3d.geom.GeoArea;
+import org.apache.lucene.spatial3d.geom.GeoAreaShape;
+import org.apache.lucene.spatial3d.geom.GeoBBox;
+import org.apache.lucene.spatial3d.geom.GeoBBoxFactory;
+import org.apache.lucene.spatial3d.geom.GeoPoint;
+import org.apache.lucene.spatial3d.geom.LatLonBounds;
+import org.locationtech.spatial4j.context.SpatialContext;
+import org.locationtech.spatial4j.shape.Point;
+import org.locationtech.spatial4j.shape.Rectangle;
+import org.locationtech.spatial4j.shape.Shape;
+import org.locationtech.spatial4j.shape.SpatialRelation;
+
+/**
+ * Wrapper class for GeoShapes so they look like Spatial4j Shapes.
+ */
+public class Geo3dAreaShape<T extends GeoAreaShape> implements Shape {
+
+  SpatialContext spatialcontext;
+  T shape;
+
+  private volatile Rectangle boundingBox = null; // lazy initialized
+
+  public Geo3dAreaShape(SpatialContext spatialcontext, T shape){
+    this.spatialcontext = spatialcontext;
+    this.shape = shape;
+  }
+
+  public T getShape(){
+    return shape;
+  }
+
+  @Override
+  public SpatialRelation relate(Shape other) {
+    if (other instanceof Geo3dAreaShape){
+      int relationship = shape.getRelationship(((Geo3dAreaShape)other).getShape());
+      switch(relationship){
+        case GeoArea.DISJOINT: return SpatialRelation.DISJOINT;
+        case GeoArea.OVERLAPS: return SpatialRelation.INTERSECTS;
+        case GeoArea.CONTAINS: return SpatialRelation.WITHIN;
+        case GeoArea.WITHIN: return SpatialRelation.CONTAINS;
+
+      }
+    }
+    else if(other instanceof GeoPoint) {
+      GeoPoint point = (GeoPoint) other;
+      if(shape.isWithin(point)){
+        return SpatialRelation.CONTAINS;
+      }
+      return SpatialRelation.DISJOINT;
+    }
+    throw new RuntimeException("Unimplemented shape relationship determination: " + other.getClass());
+  }
+
+  @Override
+  public Rectangle getBoundingBox() {
+    Rectangle bbox = this.boundingBox;//volatile read once
+    if (bbox == null) {
+      LatLonBounds bounds = new LatLonBounds();
+      shape.getBounds(bounds);
+      double leftLon;
+      double rightLon;
+      if (bounds.checkNoLongitudeBound()) {
+        leftLon = -Math.PI;
+        rightLon = Math.PI;
+      } else {
+        leftLon = bounds.getLeftLongitude().doubleValue();
+        rightLon = bounds.getRightLongitude().doubleValue();
+      }
+      double minLat;
+      if (bounds.checkNoBottomLatitudeBound()) {
+        minLat = -Math.PI * 0.5;
+      } else {
+        minLat = bounds.getMinLatitude().doubleValue();
+      }
+      double maxLat;
+      if (bounds.checkNoTopLatitudeBound()) {
+        maxLat = Math.PI * 0.5;
+      } else {
+        maxLat = bounds.getMaxLatitude().doubleValue();
+      }
+      GeoBBox geoBBox = GeoBBoxFactory.makeGeoBBox(shape.getPlanetModel(),maxLat, minLat, leftLon, rightLon);
+      bbox = new Geo3dAreaRectangle(spatialcontext, geoBBox);
+      this.boundingBox = bbox;
+    }
+    return bbox;
+  }
+
+  @Override
+  public boolean hasArea() {
+    return false;
+  }
+
+  @Override
+  public double getArea(SpatialContext spatialContext) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public Point getCenter() {
+    return getBoundingBox().getCenter();
+  }
+
+  @Override
+  public Shape getBuffered(double v, SpatialContext spatialContext) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public boolean isEmpty() {
+    return false;
+  }
+
+  @Override
+  public SpatialContext getContext() {
+    return spatialcontext;
+  }
+}
Index: lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dAreaPoint.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dAreaPoint.java	(revision )
+++ lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dAreaPoint.java	(revision )
@@ -0,0 +1,108 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.spatial4j;
+
+
+import org.apache.lucene.spatial3d.geom.GeoPoint;
+import org.apache.lucene.spatial3d.geom.PlanetModel;
+import org.locationtech.spatial4j.context.SpatialContext;
+import org.locationtech.spatial4j.distance.DistanceUtils;
+import org.locationtech.spatial4j.shape.Point;
+import org.locationtech.spatial4j.shape.Rectangle;
+import org.locationtech.spatial4j.shape.Shape;
+import org.locationtech.spatial4j.shape.SpatialRelation;
+
+/**
+ * CWrapper class for GeoPoints so they look like Spatial4j Points.
+ */
+public class Geo3dAreaPoint extends GeoPoint implements Point {
+
+
+  public Geo3dAreaPoint(PlanetModel planetModel, double lat, double lon) {
+    super(planetModel, lat, lon);
+  }
+
+  public Geo3dAreaPoint(double x, double y, double z) {
+    super(x, y, z);
+  }
+
+  @Override
+  public void reset(double v, double v1) {
+
+  }
+
+  @Override
+  public double getX() {
+    return getLongitude() * DistanceUtils.RADIANS_TO_DEGREES;
+  }
+
+  @Override
+  public double getY() {
+    return getLatitude() * DistanceUtils.RADIANS_TO_DEGREES;
+  }
+
+  @Override
+  public SpatialRelation relate(Shape other) {
+    if (other instanceof Geo3dAreaShape){
+      Geo3dAreaShape geo3dAreaShape = (Geo3dAreaShape) other;
+      if (geo3dAreaShape.getShape().isWithin(this)){
+        return SpatialRelation.WITHIN;
+      }
+      return SpatialRelation.DISJOINT;
+    }
+    else if (other instanceof Geo3dAreaPoint){
+      return SpatialRelation.DISJOINT;
+    }
+    throw new RuntimeException("Unimplemented shape relationship determination: " + other.getClass());
+  }
+
+  @Override
+  public Rectangle getBoundingBox() {
+    return null;
+  }
+
+  @Override
+  public boolean hasArea() {
+    return false;
+  }
+
+  @Override
+  public double getArea(SpatialContext spatialContext) {
+    return 0;
+  }
+
+  @Override
+  public Point getCenter() {
+    return null;
+  }
+
+  @Override
+  public Shape getBuffered(double v, SpatialContext spatialContext) {
+    return null;
+  }
+
+  @Override
+  public boolean isEmpty() {
+    return false;
+  }
+
+  @Override
+  public SpatialContext getContext() {
+    return null;
+  }
+}
Index: lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dAreaRectangle.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dAreaRectangle.java	(revision )
+++ lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dAreaRectangle.java	(revision )
@@ -0,0 +1,112 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.spatial4j;
+
+import org.apache.lucene.spatial3d.geom.GeoBBox;
+import org.apache.lucene.spatial3d.geom.GeoPoint;
+import org.apache.lucene.spatial3d.geom.LatLonBounds;
+import org.locationtech.spatial4j.context.SpatialContext;
+import org.locationtech.spatial4j.distance.DistanceUtils;
+import org.locationtech.spatial4j.shape.Point;
+import org.locationtech.spatial4j.shape.Rectangle;
+import org.locationtech.spatial4j.shape.SpatialRelation;
+
+/**
+ * Specialisation of a Geo3dAreShape for geohashing
+ */
+public class Geo3dAreaRectangle extends Geo3dAreaShape<GeoBBox> implements Rectangle {
+
+  LatLonBounds bounds = new LatLonBounds();
+  public Geo3dAreaRectangle(SpatialContext spatialcontext, GeoBBox shape) {
+    super(spatialcontext, shape);
+    shape.getBounds(bounds);
+  }
+
+  @Override
+  public Point getCenter() {
+    GeoPoint point = shape.getCenter();
+    return new Geo3dAreaPoint(point.x, point.y, point.z);
+  }
+
+  @Override
+  public void reset(double v, double v1, double v2, double v3) {
+
+  }
+
+  @Override
+  public Rectangle getBoundingBox() {
+    return this;
+  }
+
+  @Override
+  public double getWidth() {
+    return 0;
+  }
+
+  @Override
+  public double getHeight() {
+    return 0;
+  }
+
+  @Override
+  public double getMinX() {
+    if (bounds.checkNoLongitudeBound()){
+      return -180;
+    }
+    return bounds.getLeftLongitude() * DistanceUtils.RADIANS_TO_DEGREES;
+  }
+
+  @Override
+  public double getMinY() {
+    if (bounds.checkNoBottomLatitudeBound()){
+      return -90;
+    }
+    return bounds.getMinLatitude() * DistanceUtils.RADIANS_TO_DEGREES;
+  }
+
+  @Override
+  public double getMaxX() {
+    if (bounds.checkNoLongitudeBound()){
+      return 180;
+    }
+    return bounds.getRightLongitude() * DistanceUtils.RADIANS_TO_DEGREES;
+  }
+
+  @Override
+  public double getMaxY() {
+    if (bounds.checkNoTopLatitudeBound()){
+      return 90;
+    }
+    return bounds.getMaxLatitude() * DistanceUtils.RADIANS_TO_DEGREES;
+  }
+
+  @Override
+  public boolean getCrossesDateLine() {
+    return false;
+  }
+
+  @Override
+  public SpatialRelation relateYRange(double v, double v1) {
+    return null;
+  }
+
+  @Override
+  public SpatialRelation relateXRange(double v, double v1) {
+    return null;
+  }
+}
Index: lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dAreaShapeFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dAreaShapeFactory.java	(revision )
+++ lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dAreaShapeFactory.java	(revision )
@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.spatial4j;
+
+import java.util.List;
+
+import org.apache.lucene.spatial3d.geom.GeoBBox;
+import org.apache.lucene.spatial3d.geom.GeoBBoxFactory;
+import org.apache.lucene.spatial3d.geom.PlanetModel;
+import org.locationtech.spatial4j.context.SpatialContext;
+import org.locationtech.spatial4j.distance.DistanceUtils;
+import org.locationtech.spatial4j.shape.Circle;
+import org.locationtech.spatial4j.shape.Point;
+import org.locationtech.spatial4j.shape.Rectangle;
+import org.locationtech.spatial4j.shape.Shape;
+import org.locationtech.spatial4j.shape.ShapeCollection;
+import org.locationtech.spatial4j.shape.ShapeFactory;
+
+/**
+ * Shape factory for Geo3dArea shapes.
+ */
+public class Geo3dAreaShapeFactory implements ShapeFactory {
+
+  SpatialContext context;
+  PlanetModel planetModel;
+
+  public Geo3dAreaShapeFactory(SpatialContext context, PlanetModel planetModel){
+    this.context = context;
+    this.planetModel = planetModel;
+  }
+
+  @Override
+  public SpatialContext getSpatialContext() {
+    return context;
+  }
+
+  @Override
+  public boolean isNormWrapLongitude() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public double normX(double v) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public double normY(double v) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public double normZ(double v) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public double normDist(double v) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void verifyX(double v) {
+
+  }
+
+  @Override
+  public void verifyY(double v) {
+
+  }
+
+  @Override
+  public void verifyZ(double v) {
+
+  }
+
+  @Override
+  public Point pointXY(double v, double v1) {
+    Geo3dAreaPoint geo3dAreaPoint = new Geo3dAreaPoint(planetModel,
+                            v1 * DistanceUtils.DEGREES_TO_RADIANS,
+                            v * DistanceUtils.DEGREES_TO_RADIANS);
+    return geo3dAreaPoint;
+  }
+
+  @Override
+  public Point pointXYZ(double v, double v1, double v2) {
+    Geo3dAreaPoint geo3dAreaPoint = new Geo3dAreaPoint(v, v1, v2);
+    return geo3dAreaPoint;
+  }
+
+  @Override
+  public Rectangle rect(Point point, Point point1) {
+    return rect(point.getX(), point1.getX(), point.getY(), point1.getY());
+  }
+
+  @Override
+  public Rectangle rect(double minX, double maxX, double minY, double maxY) {
+    GeoBBox bBox = GeoBBoxFactory.makeGeoBBox(planetModel,
+        maxY * DistanceUtils.DEGREES_TO_RADIANS,
+        minY * DistanceUtils.DEGREES_TO_RADIANS,
+        minX * DistanceUtils.DEGREES_TO_RADIANS,
+        maxX * DistanceUtils.DEGREES_TO_RADIANS);
+    return new Geo3dAreaRectangle(context, bBox);
+  }
+
+  @Override
+  public Circle circle(double v, double v1, double v2) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public Circle circle(Point point, double v) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public Shape lineString(List<Point> list, double v) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public <S extends Shape> ShapeCollection<S> multiShape(List<S> list) {
+    return null;
+  }
+
+  @Override
+  public LineStringBuilder lineString() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public PolygonBuilder polygon() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public <T extends Shape> MultiShapeBuilder<T> multiShape(Class<T> aClass) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public MultiPointBuilder multiPoint() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public MultiLineStringBuilder multiLineString() {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public MultiPolygonBuilder multiPolygon() {
+    throw new UnsupportedOperationException();
+  }
+}
Index: lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dBinaryCodec.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dBinaryCodec.java	(revision )
+++ lucene/spatial-extras/src/java/org/apache/lucene/spatial/spatial4j/Geo3dBinaryCodec.java	(revision )
@@ -0,0 +1,132 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial.spatial4j;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+import org.apache.lucene.spatial3d.geom.GeoAreaShape;
+import org.apache.lucene.spatial3d.geom.GeoBBox;
+import org.apache.lucene.spatial3d.geom.GeoBinaryCodec;
+import org.apache.lucene.spatial3d.geom.GeoPoint;
+import org.apache.lucene.spatial3d.geom.GeoShape;
+import org.locationtech.spatial4j.context.SpatialContext;
+import org.locationtech.spatial4j.context.SpatialContextFactory;
+import org.locationtech.spatial4j.io.BinaryCodec;
+import org.locationtech.spatial4j.shape.Circle;
+import org.locationtech.spatial4j.shape.Point;
+import org.locationtech.spatial4j.shape.Rectangle;
+import org.locationtech.spatial4j.shape.Shape;
+import org.locationtech.spatial4j.shape.ShapeCollection;
+
+/**
+ * Wrapper for GeoBinaryCodec to produce Geo3dAreaShapes
+ */
+public class Geo3dBinaryCodec extends BinaryCodec{
+
+
+  public Geo3dBinaryCodec(SpatialContext ctx, SpatialContextFactory factory) {
+    super(ctx, factory);
+  }
+
+  @Override
+  public Shape readShape(DataInput dataInput) throws IOException {
+    boolean isPoint = dataInput.readBoolean();
+    if (isPoint){
+      GeoPoint point = GeoBinaryCodec.INSTANCE.readPoint(dataInput);
+      return new Geo3dAreaPoint(point.x, point.y, point.z);
+    }
+    GeoAreaShape shape = (GeoAreaShape)GeoBinaryCodec.INSTANCE.readShape(dataInput);
+    return new Geo3dAreaShape<>(ctx, shape);
+  }
+
+  @Override
+  public void writeShape(DataOutput dataOutput, Shape s) throws IOException {
+    if (s instanceof Geo3dAreaShape) {
+      dataOutput.writeBoolean(false);
+      Geo3dAreaShape geoAreaShape =(Geo3dAreaShape)s;
+      GeoBinaryCodec.INSTANCE.writeShape(dataOutput, geoAreaShape.getShape());
+    }
+    else if (s instanceof Geo3dAreaPoint) {
+      dataOutput.writeBoolean(true);
+      Geo3dAreaPoint geoAreaPoint =(Geo3dAreaPoint)s;
+      GeoBinaryCodec.INSTANCE.writePoint(dataOutput, geoAreaPoint);
+    }
+    else {
+      throw new IllegalArgumentException("Unsupported shape");
+    }
+  }
+
+  @Override
+  public Point readPoint(DataInput dataInput) throws IOException {
+    GeoPoint geoPoint= GeoBinaryCodec.INSTANCE.readPoint(dataInput);
+    return new Geo3dAreaPoint(geoPoint.x, geoPoint.y, geoPoint.z);
+  }
+
+  @Override
+  public void writePoint(DataOutput dataOutput, Point pt) throws IOException {
+    if (pt instanceof Geo3dAreaPoint){
+      Geo3dAreaPoint geoPoint = (Geo3dAreaPoint)pt;
+      GeoBinaryCodec.INSTANCE.writePoint(dataOutput, geoPoint);
+    }
+    else{
+      throw new IllegalArgumentException("Unsupported shape");
+    }
+  }
+
+  @Override
+  public Rectangle readRect(DataInput dataInput) throws IOException {
+    GeoShape geoShape = GeoBinaryCodec.INSTANCE.readShape(dataInput);
+    if (geoShape instanceof GeoBBox){
+      return new Geo3dAreaRectangle(ctx, (GeoBBox)geoShape);
+    }
+    throw new IllegalArgumentException("Unsupported shape");
+  }
+
+  @Override
+  public void writeRect(DataOutput dataOutput, Rectangle r) throws IOException {
+    if (r instanceof  Geo3dAreaRectangle){
+      Geo3dAreaRectangle geo3dAreaRectangle = (Geo3dAreaRectangle)r;
+      GeoBinaryCodec.INSTANCE.writeShape(dataOutput, geo3dAreaRectangle.getShape());
+    }
+    else{
+      throw new IllegalArgumentException("Unsupported shape");
+    }
+  }
+
+  @Override
+  public Circle readCircle(DataInput dataInput) throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void writeCircle(DataOutput dataOutput, Circle c) throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public ShapeCollection readCollection(DataInput dataInput) throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public void writeCollection(DataOutput dataOutput, ShapeCollection col) throws IOException {
+    throw new UnsupportedOperationException();
+  }
+}
