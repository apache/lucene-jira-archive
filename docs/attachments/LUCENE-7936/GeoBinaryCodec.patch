Index: lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoBinaryCodec.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoBinaryCodec.java	(revision )
+++ lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoBinaryCodec.java	(revision )
@@ -0,0 +1,425 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial3d.geom;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.List;
+
+/**
+ * A Geo3d binary shape format inspired in Spatial4j BinaryCodec. This example
+ * does not all existing Geoshapes.
+ */
+public class GeoBinaryCodec {
+
+  /**
+   * singleton instance
+   */
+  public static GeoBinaryCodec INSTANCE = new GeoBinaryCodec();
+
+  /**
+   * type of supported planet models
+   */
+  protected static final byte PLANET_SPHERE = 1, PLANET_WGS84 = 2;
+  /**
+   * type of supported shapes
+   */
+  protected static final byte RECTANGLE = 1, BBOX = 2,
+      CIRCLE = 3, CONVEX_POLYGON = 4, CONCAVE_POLYGON = 5,
+      COMPOSITE_POLYGON = 6,PATH = 7,  COMPOSITE_AREASHAPE=8;
+
+  /**
+   * Private constructor.
+   */
+  private  GeoBinaryCodec() {
+
+  }
+
+  /**
+   * Read a point from its byte codec
+   * @param dataInput the data stream
+   * @return the GeoPoint
+   * @throws IOException if there is an error reading the bytes
+   */
+  public GeoPoint readPoint(DataInput dataInput) throws IOException {
+    return new GeoPoint(readDim(dataInput), readDim(dataInput), readDim(dataInput));
+  }
+
+  /**
+   * Writes a GeoPoint to its byte representation in the DataOutput object
+   * @param dataOutput the Object where to write
+   * @param pt The GeoPoint to write
+   * @throws IOException
+   */
+  public void writePoint(DataOutput dataOutput, GeoPoint pt) throws IOException {
+    writeDim(dataOutput, pt.x);
+    writeDim(dataOutput, pt.y);
+    writeDim(dataOutput, pt.z);
+  }
+
+  /**
+   * Read a shape from its byte codec
+   * @param dataInput the data stream
+   * @return The actual GeoShape
+   * @throws IOException
+   */
+  public GeoShape readShape(DataInput dataInput) throws IOException {
+    byte type = dataInput.readByte();
+    GeoShape s = readShapeByTypeIfSupported(dataInput, type);
+    if (s == null)
+      throw new IllegalArgumentException("Unsupported shape byte " + type);
+    return s;
+  }
+
+  /**
+   * Writes a shape to its byte representation in the DataOutput object
+   * @param dataOutput the Object where to write
+   * @param s The GeoShape to write
+   * @throws IOException
+   */
+  public void writeShape(DataOutput dataOutput, GeoShape s) throws IOException {
+    boolean written = writeShapeByTypeIfSupported(dataOutput, s);
+    if (!written)
+      throw new IllegalArgumentException("Unsupported shape " + s.getClass());
+  }
+
+  private GeoShape readShapeByTypeIfSupported(DataInput dataInput, byte type) throws IOException {
+    switch (type) {
+      case RECTANGLE:
+        return readRect(dataInput);
+      case BBOX:
+        return readBbox(dataInput);
+      case CIRCLE:
+        return readCircle(dataInput);
+      case CONVEX_POLYGON:
+        return readConvexPolygon(dataInput);
+      case CONCAVE_POLYGON:
+        return readConcavePolygon(dataInput);
+      case PATH:
+        return readPath(dataInput);
+      case COMPOSITE_POLYGON:
+        return readCompositePolygon(dataInput);
+      case COMPOSITE_AREASHAPE:
+        return readCompositeAreaShape(dataInput);
+      default:
+        return null;
+    }
+  }
+
+  private boolean writeShapeByTypeIfSupported(DataOutput dataOutput, GeoShape s) throws IOException {
+    byte type = typeForShape(s);
+    dataOutput.writeByte(type);
+    return writeShapeByTypeIfSupported(dataOutput, s, type);
+  }
+
+  private boolean writeShapeByTypeIfSupported(DataOutput dataOutput, GeoShape s, byte type) throws IOException {
+    switch (type) {
+      case RECTANGLE:
+        writeRect(dataOutput, (GeoRectangle) s);
+        break;
+      case BBOX:
+        writeBbox(dataOutput, (GeoBBox) s);
+        break;
+      case CIRCLE:
+        writeCircle(dataOutput, (GeoCircle) s);
+        break;
+      case CONVEX_POLYGON:
+        writeConvexPolygon(dataOutput, (GeoConvexPolygon)s);
+        break;
+      case CONCAVE_POLYGON:
+        writeConcavePolygon(dataOutput, (GeoConcavePolygon)s);
+        break;
+      case PATH:
+        writePath(dataOutput, (GeoStandardPath) s);
+        break;
+      case COMPOSITE_POLYGON:
+        writeCompositePolygon(dataOutput, (GeoCompositePolygon) s);
+        break;
+      case COMPOSITE_AREASHAPE:
+        writeCompositeAreaShape(dataOutput, (GeoCompositeAreaShape) s);
+        break;
+      default:
+        return false;
+    }
+    return true;
+  }
+
+  private byte typeForShape(GeoShape s) {
+    if (s instanceof GeoRectangle) {
+      return RECTANGLE;
+    } else if (s instanceof GeoBBox) {
+      return BBOX;
+    } else if (s instanceof GeoCircle) {
+      return CIRCLE;
+    } else if (s instanceof GeoConvexPolygon) {
+      return CONVEX_POLYGON;
+    } else if (s instanceof GeoConcavePolygon) {
+      return CONCAVE_POLYGON;
+    } else if (s instanceof GeoStandardPath) {
+      return PATH;
+    } else if (s instanceof GeoCompositePolygon) {
+      return COMPOSITE_POLYGON;
+    } else if (s instanceof GeoAreaShape) {
+      return COMPOSITE_AREASHAPE;
+    } else {
+      return 0;
+    }
+  }
+
+  private double readDim(DataInput dataInput) throws IOException {
+    return dataInput.readDouble();
+  }
+
+  private void writeDim(DataOutput dataOutput, double v) throws IOException {
+    dataOutput.writeDouble(v);
+  }
+
+  private GeoBBox readRect(DataInput dataInput) throws IOException {
+    return new GeoRectangle(readPlanetModel(dataInput),readDim(dataInput), readDim(dataInput), readDim(dataInput), readDim(dataInput));
+  }
+
+  private void writeRect(DataOutput dataOutput, GeoRectangle r) throws IOException {
+    writePlanetModel(dataOutput, r.getPlanetModel());
+    writeDim(dataOutput, r.topLat);
+    writeDim(dataOutput, r.bottomLat);
+    writeDim(dataOutput, r.leftLon);
+    writeDim(dataOutput, r.rightLon);
+  }
+
+  private GeoBBox readBbox(DataInput dataInput) throws IOException {
+    return GeoBBoxFactory.makeGeoBBox(readPlanetModel(dataInput),readDim(dataInput), readDim(dataInput), readDim(dataInput), readDim(dataInput));
+  }
+
+  private void writeBbox(DataOutput dataOutput, GeoBBox r) throws IOException {
+    writePlanetModel(dataOutput, r.getPlanetModel());
+    LatLonBounds bounds = new LatLonBounds();
+    r.getBounds(bounds);
+    if (bounds.checkNoTopLatitudeBound()){
+      writeDim(dataOutput, Math.PI * 0.5);
+    }
+    else{
+      writeDim(dataOutput, bounds.getMaxLatitude());
+    }
+    if (bounds.checkNoBottomLatitudeBound()){
+      writeDim(dataOutput, -Math.PI * 0.5);
+    }
+    else{
+      writeDim(dataOutput, bounds.getMinLatitude());
+    }
+
+    if (bounds.checkNoLongitudeBound()){
+      writeDim(dataOutput, -Math.PI);
+      writeDim(dataOutput, Math.PI);
+    }
+    else {
+      writeDim(dataOutput, bounds.getLeftLongitude());
+      writeDim(dataOutput, bounds.getRightLongitude());
+    }
+
+  }
+
+  private GeoCircle readCircle(DataInput dataInput) throws IOException {
+    return GeoCircleFactory.makeGeoCircle(readPlanetModel(dataInput),
+                                          readDim(dataInput),
+                                          readDim(dataInput),
+                                          readDim(dataInput));
+  }
+
+  private void writeCircle(DataOutput dataOutput, GeoCircle c) throws IOException {
+    writePlanetModel(dataOutput, c.getPlanetModel());
+    writeDim(dataOutput, c.getCenter().getLatitude());
+    writeDim(dataOutput, c.getCenter().getLongitude());
+    writeDim(dataOutput, c.getRadius());
+  }
+
+  private GeoPath readPath(DataInput dataInput) throws IOException {
+    PlanetModel planetModel = readPlanetModel(dataInput);
+    List<GeoPoint> points = readPoints(dataInput);
+    return new GeoStandardPath(planetModel, readDim(dataInput), points.toArray(new GeoPoint[points.size()]));
+  }
+
+  private void writePath(DataOutput dataOutput, GeoStandardPath path) throws IOException {
+    writePlanetModel(dataOutput, path.getPlanetModel());
+    writePoints(dataOutput, path.points);
+    writeDim(dataOutput, path.cutoffAngle);
+  }
+
+  private void writeConvexPolygon(DataOutput dataOutput, GeoConvexPolygon s) throws IOException {
+    writePlanetModel(dataOutput, s.getPlanetModel());
+    writePoints(dataOutput, s.points);
+    writeBitSet(dataOutput, s.isInternalEdges);
+    if (s.holes == null)
+    {
+      dataOutput.writeInt(0);
+      return;
+    }
+    dataOutput.writeInt(s.holes.size());
+    for(GeoPolygon hole : s.holes){
+      writeShapeByTypeIfSupported(dataOutput, hole);
+    }
+  }
+
+  private GeoShape readConvexPolygon(DataInput dataInput) throws IOException {
+    PlanetModel planetModel = readPlanetModel(dataInput);
+    List<GeoPoint> points = readPoints(dataInput);
+    BitSet internalEdges = readBitSet(dataInput);
+    int size = dataInput.readInt();
+    List<GeoPolygon> holes = null;
+    if (size >0) {
+      holes = new ArrayList(size);
+      for (int i = 0; i < size; i++) {
+        byte type = dataInput.readByte();
+        holes.add((GeoPolygon) readShapeByTypeIfSupported(dataInput, type));
+      }
+    }
+    return new GeoConvexPolygon(planetModel, points, holes, internalEdges, false);
+  }
+
+  private void writeConcavePolygon(DataOutput dataOutput, GeoConcavePolygon s) throws IOException {
+    writePlanetModel(dataOutput, s.getPlanetModel());
+    writePoints(dataOutput, s.points);
+    writeBitSet(dataOutput, s.isInternalEdges);
+    if (s.holes == null)
+    {
+      dataOutput.writeInt(0);
+      return;
+    }
+    dataOutput.writeInt(s.holes.size());
+    for(GeoPolygon hole : s.holes){
+      writeShapeByTypeIfSupported(dataOutput, hole);
+    }
+  }
+
+  private GeoShape readConcavePolygon(DataInput dataInput) throws IOException {
+    PlanetModel planetModel = readPlanetModel(dataInput);
+    List<GeoPoint> points = readPoints(dataInput);
+    BitSet internalEdges = readBitSet(dataInput);
+    int size = dataInput.readInt();
+    List<GeoPolygon> holes = null;
+    if (size >0) {
+      holes = new ArrayList(size);
+      for (int i = 0; i < size; i++) {
+        byte type = dataInput.readByte();
+        holes.add((GeoPolygon) readShapeByTypeIfSupported(dataInput, type));
+      }
+    }
+    return new GeoConcavePolygon(planetModel, points, holes, internalEdges, false);
+  }
+
+  private void writePoints(DataOutput dataOutput, List<GeoPoint> points ) throws IOException {
+    dataOutput.writeInt(points.size());
+    for (GeoPoint point : points) {
+      writePoint(dataOutput, point);
+    }
+  }
+
+  private List<GeoPoint> readPoints(DataInput dataInput) throws IOException {
+    int size = dataInput.readInt();
+    List<GeoPoint> points = new ArrayList<>(size);
+    for (int i = 0; i < size; i++) {
+      points.add(readPoint(dataInput));
+    }
+    return points;
+  }
+
+  private void writeBitSet(DataOutput dataOutput, BitSet bitSet) throws IOException {
+    byte[] bytes = bitSet.toByteArray();
+    dataOutput.writeInt(bytes.length);
+    dataOutput.write(bytes);
+  }
+
+
+  private BitSet readBitSet(DataInput dataInput) throws IOException {
+    int size = dataInput.readInt();
+    byte[] bytes = new byte[size];
+    dataInput.readFully(bytes);
+    return BitSet.valueOf(bytes);
+  }
+
+  private GeoShape readCompositePolygon(DataInput dataInput) throws IOException {
+    PlanetModel planetModel = readPlanetModel(dataInput);
+    int size = dataInput.readInt();
+    GeoCompositePolygon compositePolygon = new GeoCompositePolygon(planetModel);
+    for (int i = 0; i < size; i++) {
+      byte type = dataInput.readByte();
+      compositePolygon.addShape((GeoPolygon)readShapeByTypeIfSupported(dataInput, type));
+    }
+    return compositePolygon;
+  }
+
+  private void writeCompositePolygon(DataOutput dataOutput, GeoCompositePolygon col) throws IOException {
+    writePlanetModel(dataOutput, col.getPlanetModel());
+    dataOutput.writeInt(col.size());
+    for (int i = 0; i < col.size(); i++) {
+      GeoPolygon s = col.getShape(i);
+      boolean written = writeShapeByTypeIfSupported(dataOutput, s);
+      if (!written){
+        throw new IllegalArgumentException("Unsupported shape type " + s.getClass());
+      }
+    }
+  }
+
+  private GeoShape readCompositeAreaShape(DataInput dataInput) throws IOException {
+    PlanetModel planetModel = readPlanetModel(dataInput);
+    int size = dataInput.readInt();
+    GeoCompositeAreaShape compositeAreaShape = new GeoCompositeAreaShape(planetModel);
+    for (int i = 0; i < size; i++) {
+      byte type = dataInput.readByte();
+      compositeAreaShape.addShape((GeoAreaShape) readShapeByTypeIfSupported(dataInput, type));
+    }
+    return compositeAreaShape;
+  }
+
+  private void writeCompositeAreaShape(DataOutput dataOutput, GeoCompositeAreaShape col) throws IOException {
+    writePlanetModel(dataOutput, col.getPlanetModel());
+    dataOutput.writeInt(col.size());
+    for (int i = 0; i < col.size(); i++) {
+      GeoAreaShape s = col.getShape(i);
+      boolean written = writeShapeByTypeIfSupported(dataOutput, s);
+      if (!written){
+        throw new IllegalArgumentException("Unsupported shape type " + s.getClass());
+      }
+    }
+  }
+
+  private PlanetModel readPlanetModel(DataInput dataInput) throws IOException {
+    int type = dataInput.readByte();
+    switch (type){
+      case PLANET_SPHERE: return PlanetModel.SPHERE;
+      case PLANET_WGS84: return PlanetModel.WGS84;
+    }
+    throw new IllegalArgumentException("Unsupported planetModel");
+  }
+
+  private void writePlanetModel(DataOutput dataOutput, PlanetModel planetModel) throws IOException {
+    if (planetModel == PlanetModel.SPHERE){
+      dataOutput.writeByte(PLANET_SPHERE);
+    }
+    else if (planetModel == PlanetModel.WGS84){
+      dataOutput.writeByte(PLANET_WGS84);
+    }
+    else {
+      throw new IllegalArgumentException("Unsupported planetModel " + planetModel.toString());
+    }
+  }
+
+
+}
