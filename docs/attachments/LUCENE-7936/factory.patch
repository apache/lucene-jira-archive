Index: src/java/org/apache/lucene/spatial3d/geom/SerializationFactory.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/java/org/apache/lucene/spatial3d/geom/SerializationFactory.java	(revision )
+++ src/java/org/apache/lucene/spatial3d/geom/SerializationFactory.java	(revision )
@@ -0,0 +1,165 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.lucene.spatial3d.geom;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.lang.reflect.Array;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.List;
+
+/**
+ * The Serialization factory codifies class names into bytes. From 0 to 127 is reserve for internal classes.
+ * From -128 and -1 reserve for user define classes. To make it work generically, we should pass this object
+ * into the constructor.
+ */
+public class SerializationFactory {
+
+  List<Class> externalRegistry = new ArrayList<>();
+  static List<Class> internalRegistry = new ArrayList<>();
+  static {
+    internalRegistry.add(GeoPoint.class);
+    internalRegistry.add(GeoRectangle.class);
+    internalRegistry.add(GeoStandardCircle.class);
+    internalRegistry.add(GeoStandardPath.class);
+    internalRegistry.add(GeoConvexPolygon.class);
+    internalRegistry.add(GeoConcavePolygon.class);
+    internalRegistry.add(GeoComplexPolygon.class);
+    internalRegistry.add(GeoCompositePolygon.class);
+    internalRegistry.add(GeoCompositeMembershipShape.class);
+    internalRegistry.add(GeoCompositeAreaShape.class);
+    internalRegistry.add(GeoCompositeAreaShape.class);
+    internalRegistry.add(GeoDegeneratePoint.class);
+    internalRegistry.add(GeoDegenerateHorizontalLine.class);
+    internalRegistry.add(GeoDegenerateLatitudeZone.class);
+    internalRegistry.add(GeoDegenerateLongitudeSlice.class);
+    internalRegistry.add(GeoDegenerateVerticalLine.class);
+    internalRegistry.add(GeoLatitudeZone.class);
+    internalRegistry.add(GeoLongitudeSlice.class);
+    internalRegistry.add(GeoNorthLatitudeZone.class);
+    internalRegistry.add(GeoNorthRectangle.class);
+    internalRegistry.add(GeoSouthLatitudeZone.class);
+    internalRegistry.add(GeoSouthRectangle.class);
+    internalRegistry.add(GeoWideDegenerateHorizontalLine.class);
+    internalRegistry.add(GeoWideLongitudeSlice.class);
+    internalRegistry.add(GeoWideNorthRectangle.class);
+    internalRegistry.add(GeoWideRectangle.class);
+    internalRegistry.add(GeoWideSouthRectangle.class);
+    internalRegistry.add(GeoWorld.class);
+    internalRegistry.add(dXdYdZSolid.class);
+    internalRegistry.add(dXdYZSolid.class);
+    internalRegistry.add(dXYdZSolid.class);
+    internalRegistry.add(dXYZSolid.class);
+    internalRegistry.add(XdYdZSolid.class);
+    internalRegistry.add(XdYZSolid.class);
+    internalRegistry.add(XYdZSolid.class);
+  }
+
+
+  /**
+   * Method to add user defined classes into the factory. It should check that
+   * the given class is instance of Serializable object. It is important when using this mechanism to
+   * add classes always in the same order as they get a serializable code depending on order.
+   *
+   * @param clazz the class to add.
+   */
+  public void addClass(Class<?> clazz) {
+    if (externalRegistry.contains(clazz) || internalRegistry.contains(clazz)){
+      throw new RuntimeException("Trying to add an existing class on registry "+clazz.getName());
+    }
+    externalRegistry.add(clazz);
+  }
+
+  /** Write an object to a stream.
+   * @param outputStream is the output stream.
+   * @param object is the object to write.
+   */
+  public void writeObject(final OutputStream outputStream, final SerializableObject object) throws IOException {
+    writeCode(outputStream, object.getClass());
+    object.write(outputStream);
+  }
+
+  /** Read an object from a stream (for objects that need a PlanetModel).
+   * @param planetModel is the planet model to use to deserialize the object.
+   * @param inputStream is the input stream.
+   * @return the deserialized object.
+   */
+  public  SerializableObject readObject(final PlanetModel planetModel, final InputStream inputStream) throws IOException {
+    // Look for the class
+    final Class<?> clazz = getClassFromCode(inputStream);
+    return SerializableObject.readObject(planetModel, inputStream, clazz);
+  }
+
+  /** Read an object from a stream (for objects that do not need a PlanetModel).
+   * @param inputStream is the input stream.
+   * @return the deserialized object.
+   */
+  public  SerializableObject readObject(final InputStream inputStream) throws IOException {
+    // Look for the class
+    final Class<?> clazz = getClassFromCode(inputStream);
+    return SerializableObject.readObject(inputStream, clazz);
+  }
+
+  /**
+   * Write a code representing the class in the output stream.
+   * @param outputStream The output stream
+   * @param clazz The class to codify
+   */
+  private void writeCode(final OutputStream outputStream, Class<?> clazz) throws IOException {
+    int code = getCodeFromClass(clazz);
+    outputStream.write(code);
+  }
+
+  /**
+   * Method that codifies the class.
+   * @param clazz The class to codify
+   * @return the code
+   */
+  private int getCodeFromClass(Class<?> clazz){
+    int code = internalRegistry.indexOf(clazz);
+    if (code != -1){
+      return code;
+    }
+    code = externalRegistry.indexOf(clazz);
+    if (code != -1){
+      return (-1)*code -1;
+    }
+    throw new RuntimeException("Class "+clazz.getName()+" not found in registry");
+  }
+
+  /**
+   * Reads a class from the input stream.
+   * @param inputStream the input stream
+   * @return the class
+   */
+  private Class<?> getClassFromCode(final InputStream inputStream) throws IOException{
+    int code = inputStream.read();
+    if (code >= 0){
+      return internalRegistry.get(code);
+    }
+    else{
+      code = (-1)*(code + 1);
+      return externalRegistry.get(code);
+    }
+  }
+}
Index: src/test/org/apache/lucene/spatial3d/geom/RandomBinaryCodecTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/test/org/apache/lucene/spatial3d/geom/RandomBinaryCodecTest.java	(date 1503961398000)
+++ src/test/org/apache/lucene/spatial3d/geom/RandomBinaryCodecTest.java	(revision )
@@ -30,7 +30,7 @@
 public class RandomBinaryCodecTest extends RandomGeoShapeGenerator{
 
   @Test
-  @Repeat(iterations = 100)
+  @Repeat(iterations = 1000)
   public void testRandomShapeCodec() throws IOException{
     PlanetModel planetModel = randomPlanetModel();
     int type = randomShapeType();
@@ -43,5 +43,94 @@
     assertEquals(shape, shapeCopy);
   }
 
+  SerializationFactory factory = new SerializationFactory();
+  @Test
+  @Repeat(iterations = 1000)
+  public void testRandomFactoryCodec() throws IOException{
+    PlanetModel planetModel = randomPlanetModel();
+    int type = randomShapeType();
 
+    GeoShape shape = randomGeoShape(type, planetModel);
+    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+    factory.writeObject(outputStream, shape);
+    ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
+    SerializableObject shapeCopy = factory.readObject(planetModel, inputStream);
+    assertEquals(shape, shapeCopy);
+  }
+
+  /**
+   * This is just a fake test to time two different ways of serialization. Objects that
+   * do not create other Serialization objects take 20-30% of the time with
+   * factory
+   *
+   */
+  @Test
+  @Repeat(iterations = 100)
+  public void testRandomShapeCodecTiming() throws IOException{
+    PlanetModel planetModel = randomPlanetModel();
+    int type = randomShapeType();
+    GeoShape shape = randomGeoShape(type, planetModel);
+    //System.out.println("Experiment:" + type);
+    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+    SerializableObject.writeObject(outputStream, shape);
+    long time = System.nanoTime();
+    int i=0;
+    while (i<5000) {
+      i++;
+      ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
+      SerializableObject shapeCopy = SerializableObject.readObject(planetModel, inputStream);
+      assertEquals(shape, shapeCopy);
+    }
+    long time1 = System.nanoTime() - time;
+    //System.out.println(time1);
+    outputStream = new ByteArrayOutputStream();
+    factory.writeObject(outputStream, shape);
+    time = System.nanoTime();
+    i=0;
+    while (i<5000) {
+      i++;
+      ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
+      SerializableObject shapeCopy = factory.readObject(planetModel, inputStream);
+      assertEquals(shape, shapeCopy);
+    }
+    long time2 = System.nanoTime() - time;
+    //System.out.println(time2);
+    System.out.println(((1.0*time2)/time1)*100);
+  }
+
+  /**
+   * Point deserialization is much faster with factory
+   */
+  @Test
+  @Repeat(iterations = 100)
+  public void testRandomPointCodecTiming() throws IOException{
+    PlanetModel planetModel = randomPlanetModel();
+    GeoPoint shape = randomGeoPoint(planetModel, getEmptyConstraint());
+    //System.out.println("Experiment:" + type);
+    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+    SerializableObject.writeObject(outputStream, shape);
+    long time = System.nanoTime();
+    int i=0;
+    while (i<5000) {
+      i++;
+      ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
+      SerializableObject shapeCopy = SerializableObject.readObject(planetModel, inputStream);
+      assertEquals(shape, shapeCopy);
+    }
+    long time1 = System.nanoTime() - time;
+    //System.out.println(time1);
+    outputStream = new ByteArrayOutputStream();
+    factory.writeObject(outputStream, shape);
+    time = System.nanoTime();
+    i=0;
+    while (i<5000) {
+      i++;
+      ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());
+      SerializableObject shapeCopy = factory.readObject(planetModel, inputStream);
+      assertEquals(shape, shapeCopy);
+    }
+    long time2 = System.nanoTime() - time;
+    //System.out.println(time2);
+    System.out.println(((1.0*time2)/time1)*100);
+  }
 }
