diff --git a/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java b/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
index 53342b5..e3547ce 100644
--- a/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
+++ b/lucene/core/src/java/org/apache/lucene/search/ConjunctionDISI.java
@@ -23,7 +23,6 @@ import java.util.Comparator;
 import java.util.List;
 
 import org.apache.lucene.util.CollectionUtil;
-import org.apache.lucene.search.spans.Spans;
 
 /** A conjunction of DocIdSetIterators.
  * This iterates over the doc ids that are present in each given DocIdSetIterator.
@@ -35,15 +34,11 @@ public class ConjunctionDISI extends DocIdSetIterator {
   /** Create a conjunction over the provided iterators, taking advantage of
    *  {@link TwoPhaseIterator}. */
   public static ConjunctionDISI intersect(List<? extends DocIdSetIterator> iterators) {
+    assert iterators.size() >= 2;
     final List<DocIdSetIterator> allIterators = new ArrayList<>();
     final List<TwoPhaseIterator> twoPhaseIterators = new ArrayList<>();
     for (DocIdSetIterator iterator : iterators) {
-      TwoPhaseIterator twoPhaseIterator = null;
-      if (iterator instanceof Scorer) { 
-        twoPhaseIterator = ((Scorer) iterator).asTwoPhaseIterator();
-      } else if (iterator instanceof Spans) {
-        twoPhaseIterator = ((Spans) iterator).asTwoPhaseIterator();
-      }
+      TwoPhaseIterator twoPhaseIterator = iterator.asTwoPhaseIterator();
       if (twoPhaseIterator != null) {
         allIterators.add(twoPhaseIterator.approximation());
         twoPhaseIterators.add(twoPhaseIterator);
@@ -63,6 +58,7 @@ public class ConjunctionDISI extends DocIdSetIterator {
   final DocIdSetIterator[] others;
 
   ConjunctionDISI(List<? extends DocIdSetIterator> iterators) {
+    assert iterators.size() >= 2;
     // Sort the array the first time to allow the least frequent DocsEnum to
     // lead the matching.
     CollectionUtil.timSort(iterators, new Comparator<DocIdSetIterator>() {
@@ -79,7 +75,8 @@ public class ConjunctionDISI extends DocIdSetIterator {
     return true;
   }
 
-  TwoPhaseIterator asTwoPhaseIterator() {
+  @Override
+  public TwoPhaseIterator asTwoPhaseIterator() {
     return null;
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisiPriorityQueue.java b/lucene/core/src/java/org/apache/lucene/search/DisiPriorityQueue.java
new file mode 100644
index 0000000..55f61b5
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/DisiPriorityQueue.java
@@ -0,0 +1,172 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.Arrays;
+import java.util.Iterator;
+
+import org.apache.lucene.util.PriorityQueue;
+
+/**
+ * A priority queue of DocIdSetIterators that orders by current doc ID.
+ * This specialization is needed over {@link PriorityQueue} because the
+ * pluggable comparison function makes the rebalancing quite slow.
+ * @lucene.internal
+ */
+public final class DisiPriorityQueue<Iter extends DocIdSetIterator>
+implements Iterable<DisiWrapper<Iter>> {
+
+  static int leftNode(int node) {
+    return ((node + 1) << 1) - 1;
+  }
+
+  static int rightNode(int leftNode) {
+    return leftNode + 1;
+  }
+
+  static int parentNode(int node) {
+    return ((node + 1) >>> 1) - 1;
+  }
+
+  private final DisiWrapper<Iter>[] heap;
+  private int size;
+
+  public DisiPriorityQueue(int maxSize) {
+    heap = new DisiWrapper[maxSize];
+    size = 0;
+  }
+
+  public int size() {
+    return size;
+  }
+
+  public DisiWrapper<Iter> top() {
+    return heap[0];
+  }
+
+  /** Get the list of scorers which are on the current doc. */
+  public DisiWrapper<Iter> topList() {
+    final DisiWrapper<Iter>[] heap = this.heap;
+    final int size = this.size;
+    DisiWrapper<Iter> list = heap[0];
+    list.next = null;
+    if (size >= 3) {
+      list = topList(list, heap, size, 1);
+      list = topList(list, heap, size, 2);
+    } else if (size == 2 && heap[1].doc == list.doc) {
+      list = prepend(heap[1], list);
+    }
+    return list;
+  }
+
+  // prepend w1 (iterator) to w2 (list)
+  private DisiWrapper<Iter> prepend(DisiWrapper<Iter> w1, DisiWrapper<Iter> w2) {
+    w1.next = w2;
+    return w1;
+  }
+
+  private DisiWrapper<Iter> topList(DisiWrapper<Iter> list, DisiWrapper<Iter>[] heap,
+                                    int size, int i) {
+    final DisiWrapper<Iter> w = heap[i];
+    if (w.doc == list.doc) {
+      list = prepend(w, list);
+      final int left = leftNode(i);
+      final int right = left + 1;
+      if (right < size) {
+        list = topList(list, heap, size, left);
+        list = topList(list, heap, size, right);
+      } else if (left < size && heap[left].doc == list.doc) {
+        list = prepend(heap[left], list);
+      }
+    }
+    return list;
+  }
+
+  public DisiWrapper<Iter> add(DisiWrapper<Iter> entry) {
+    final DisiWrapper<Iter>[] heap = this.heap;
+    final int size = this.size;
+    heap[size] = entry;
+    upHeap(size);
+    this.size = size + 1;
+    return heap[0];
+  }
+
+  public DisiWrapper<Iter> pop() {
+    final DisiWrapper<Iter>[] heap = this.heap;
+    final DisiWrapper<Iter> result = heap[0];
+    final int i = --size;
+    heap[0] = heap[i];
+    heap[i] = null;
+    downHeap(i);
+    return result;
+  }
+
+  public DisiWrapper<Iter> updateTop() {
+    downHeap(size);
+    return heap[0];
+  }
+
+  DisiWrapper<Iter> updateTop(DisiWrapper<Iter> topReplacement) {
+    heap[0] = topReplacement;
+    return updateTop();
+  }
+
+  void upHeap(int i) {
+    final DisiWrapper<Iter> node = heap[i];
+    final int nodeDoc = node.doc;
+    int j = parentNode(i);
+    while (j >= 0 && nodeDoc < heap[j].doc) {
+      heap[i] = heap[j];
+      i = j;
+      j = parentNode(j);
+    }
+    heap[i] = node;
+  }
+
+  void downHeap(int size) {
+    int i = 0;
+    final DisiWrapper<Iter> node = heap[0];
+    int j = leftNode(i);
+    if (j < size) {
+      int k = rightNode(j);
+      if (k < size && heap[k].doc < heap[j].doc) {
+        j = k;
+      }
+      if (heap[j].doc < node.doc) {
+        do {
+          heap[i] = heap[j];
+          i = j;
+          j = leftNode(i);
+          k = rightNode(j);
+          if (k < size && heap[k].doc < heap[j].doc) {
+            j = k;
+          }
+        } while (j < size && heap[j].doc < node.doc);
+        heap[i] = node;
+      }
+    }
+  }
+
+  @Override
+  public Iterator<DisiWrapper<Iter>> iterator() {
+    return Arrays.asList(heap).subList(0, size).iterator();
+  }
+
+}
+
+
diff --git a/lucene/core/src/java/org/apache/lucene/search/DisiWrapper.java b/lucene/core/src/java/org/apache/lucene/search/DisiWrapper.java
new file mode 100644
index 0000000..92fda55
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/search/DisiWrapper.java
@@ -0,0 +1,50 @@
+package org.apache.lucene.search;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * @lucene.internal
+ * Used in {@link DisiPriorityQueue}.
+ */
+public class DisiWrapper<Iter extends DocIdSetIterator> {
+  public final Iter iterator;
+  //final long cost; //FIXME: needed?
+  public int doc; // the current doc, used for comparison
+  public DisiWrapper<Iter> next; // reference to a next element, see #topList
+
+  // An approximation of the iterator, or the iterator itself if it does not
+  // support two-phase iteration
+  final DocIdSetIterator approximation;
+  // A two-phase view of the iterator, or null if the iterator does not support
+  // two-phase iteration
+  final TwoPhaseIterator twoPhaseView;
+
+  public DisiWrapper(Iter iterator) {
+    this.iterator = iterator;
+    //this.cost = iterator.cost(); //FIXME: needed?
+    this.doc = -1;
+    this.twoPhaseView = iterator.asTwoPhaseIterator();
+      
+    if (twoPhaseView != null) {
+      approximation = twoPhaseView.approximation();
+    } else {
+      approximation = iterator;
+    }
+  }
+}
+
diff --git a/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java b/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java
index fe26e52..0f4cfb2 100644
--- a/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java
+++ b/lucene/core/src/java/org/apache/lucene/search/DocIdSetIterator.java
@@ -19,6 +19,8 @@ package org.apache.lucene.search;
 
 import java.io.IOException;
 
+import org.apache.lucene.search.spans.Spans;
+
 /**
  * This abstract class defines methods to iterate over a set of non-decreasing
  * doc ids. Note that this class assumes it iterates on doc Ids, and therefore
@@ -175,4 +177,16 @@ public abstract class DocIdSetIterator {
    * completely inaccurate.
    */
   public abstract long cost();
+  
+  /**
+   * Returns a {@link TwoPhaseIterator} for this {@link DocIdSetIterator} when available,
+   * otherwise returns null.
+   */
+  public TwoPhaseIterator asTwoPhaseIterator() {
+    return (this instanceof Scorer)
+            ? ((Scorer) this).asTwoPhaseIterator()
+            : (this instanceof Spans)
+            ? ((Spans) this).asTwoPhaseIterator()
+            : null;
+  }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
index 71215d0..e24babd 100644
--- a/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
+++ b/lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery.java
@@ -34,6 +34,9 @@ import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.PriorityQueue;
 import org.apache.lucene.util.ToStringUtils;
 import org.apache.lucene.search.Query;
+import org.apache.lucene.search.DisiPriorityQueue;
+import org.apache.lucene.search.DisiWrapper;
+
 
 /** Matches the union of its clauses.
  */
@@ -42,7 +45,7 @@ public class SpanOrQuery extends SpanQuery implements Cloneable {
   private String field;
 
   /** Construct a SpanOrQuery merging the provided clauses.
-   * All clauses must have the same field. 
+   * All clauses must have the same field.
    */
   public SpanOrQuery(SpanQuery... clauses) {
     this.clauses = new ArrayList<>(clauses.length);
@@ -146,35 +149,16 @@ public class SpanOrQuery extends SpanQuery implements Cloneable {
   }
 
 
-  private class SpanQueue extends PriorityQueue<Spans> {
-    public SpanQueue(int size) {
-      super(size);
-    }
-
-    @Override
-    protected final boolean lessThan(Spans spans1, Spans spans2) {
-      if (spans1.docID() == spans2.docID()) {
-        if (spans1.startPosition() == spans2.startPosition()) {
-          return spans1.endPosition() < spans2.endPosition();
-        } else {
-          return spans1.startPosition() < spans2.startPosition();
-        }
-      } else {
-        return spans1.docID() < spans2.docID();
-      }
-    }
-  }
-
   @Override
   public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts)
   throws IOException {
 
     ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());
 
-    for (SpanQuery seq : clauses) {
-      Spans subSpan = seq.getSpans(context, acceptDocs, termContexts);
-      if (subSpan != null) {
-        subSpans.add(subSpan);
+    for (SpanQuery sq : clauses) {
+      Spans spans = sq.getSpans(context, acceptDocs, termContexts);
+      if (spans != null) {
+        subSpans.add(spans);
       }
     }
 
@@ -184,114 +168,107 @@ public class SpanOrQuery extends SpanQuery implements Cloneable {
       return subSpans.get(0);
     }
 
-    SpanQueue queue = new SpanQueue(clauses.size());
+    DisiPriorityQueue<Spans> queue = new DisiPriorityQueue<>(subSpans.size());
     for (Spans spans : subSpans) {
-      queue.add(spans);
+      queue.add(new DisiWrapper<>(spans));
     }
 
+    SpanPositionQueue positionQueue = new SpanPositionQueue(subSpans.size());
+
+
     return new Spans() {
 
+      Spans topPositionSpans = subSpans.get(0);
+      {
+        assert topPositionSpans.startPosition() == -1;
+        assert topPositionSpans.endPosition() == -1;
+        positionQueue.add(topPositionSpans);
+      }
+
       @Override
       public int nextDoc() throws IOException {
-        if (queue.size() == 0) { // all done
-          return NO_MORE_DOCS;
-        }
-
-        int currentDoc = top().docID();
-
-        if (currentDoc == -1) { // initially
-          return advance(0);
-        }
+        DisiWrapper<Spans> top = queue.top();
+        int currentDoc = top.doc;
 
         do {
-          if (top().nextDoc() != NO_MORE_DOCS) { // move top to next doc
-            queue.updateTop();
-          } else {
-            queue.pop(); // exhausted a clause
-            if (queue.size() == 0) {
-              return NO_MORE_DOCS;
-            }
-          }
-          // assert queue.size() > 0;
-          int doc = top().docID();
-          if (doc > currentDoc) {
-            return doc;
-          }
-        } while (true);
-      }
+          top.doc = top.iterator.nextDoc();
+          top = queue.updateTop();
+        } while (top.doc == currentDoc);
+        topPositionSpans = top.iterator;
 
-      private Spans top() {
-        return queue.top();
+        return top.doc;
       }
 
       @Override
       public int advance(int target) throws IOException {
+        DisiWrapper<Spans> top = queue.top();
+        do {
+          top.doc = top.iterator.advance(target);
+          top = queue.updateTop();
+        } while (top.doc < target);
+        topPositionSpans = top.iterator;
 
-        while ((queue.size() > 0) && (top().docID() < target)) {
-          if (top().advance(target) != NO_MORE_DOCS) {
-            queue.updateTop();
-          } else {
-            queue.pop();
-          }
-        }
-
-        return (queue.size() > 0) ? top().docID() : NO_MORE_DOCS;
+        return top.doc;
       }
 
       @Override
       public int docID() {
-        return (queue == null) ? -1
-              : (queue.size() > 0) ? top().docID()
-              : NO_MORE_DOCS;
+        return queue.top().doc;
       }
 
       @Override
       public int nextStartPosition() throws IOException {
-        top().nextStartPosition();
-        queue.updateTop();
-        int startPos = top().startPosition();
-        while (startPos == -1) { // initially at this doc
-          top().nextStartPosition();
-          queue.updateTop();
-          startPos = top().startPosition();
+        assert topPositionSpans.docID() != NO_MORE_DOCS;
+        if (topPositionSpans.startPosition() == -1) {
+          // add all Spans at current doc to positionQueue
+          DisiWrapper<Spans> listAtCurrentDoc = queue.topList();
+          positionQueue.clear();
+          while (listAtCurrentDoc != null) {
+            Spans spansAtDoc = listAtCurrentDoc.iterator;
+            assert spansAtDoc.startPosition() == -1;
+            spansAtDoc.nextStartPosition();
+            assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;
+            positionQueue.add(spansAtDoc);
+            listAtCurrentDoc = listAtCurrentDoc.next;
+          }
+          topPositionSpans = positionQueue.top();
+        } else {
+          topPositionSpans.nextStartPosition();
+          topPositionSpans = positionQueue.updateTop();
         }
-        return startPos;
+        return topPositionSpans.startPosition();
       }
 
       @Override
       public int startPosition() {
-        return top().startPosition();
+        return topPositionSpans.startPosition();
       }
 
       @Override
       public int endPosition() {
-        return top().endPosition();
+        return topPositionSpans.endPosition();
       }
 
       @Override
       public Collection<byte[]> getPayload() throws IOException {
-        ArrayList<byte[]> result = null;
-        Spans theTop = top();
-        if (theTop != null && theTop.isPayloadAvailable()) {
-          result = new ArrayList<>(theTop.getPayload());
-        }
-        return result;
+        Spans top = queue.top().iterator;
+        return top.isPayloadAvailable() ? new ArrayList<>(top.getPayload()) : null;
       }
 
       @Override
       public boolean isPayloadAvailable() throws IOException {
-        Spans top = top();
-        return top != null && top.isPayloadAvailable();
+        return queue.top().iterator.isPayloadAvailable();
       }
 
       @Override
       public String toString() {
           return "spans("+SpanOrQuery.this+")@"+
             ((queue == null)?"START"
-             :(queue.size()>0?(docID()+": "+top().startPosition()+" - "+top().endPosition()):"END"));
+             :(queue.size()>0?(docID()+": "+startPosition()+" - "+endPosition()):"END"));
       }
 
-      private long cost = -1;
+      long cost = -1;
+
 
       @Override
       public long cost() {
@@ -308,3 +285,18 @@ public class SpanOrQuery extends SpanQuery implements Cloneable {
   }
 
 }
+
+class SpanPositionQueue extends PriorityQueue<Spans> {
+  SpanPositionQueue(int maxSize) {
+    super(maxSize, false); // do not prepopulate
+  }
+
+  protected boolean lessThan(Spans s1, Spans s2) {
+    int start1 = s1.startPosition();
+    int start2 = s2.startPosition();
+    return (start1 < start2) ? true
+          : (start1 == start2) ? s1.endPosition() < s2.endPosition()
+          : false;
+  }
+}
+
diff --git a/lucene/core/src/java/org/apache/lucene/util/PriorityQueue.java b/lucene/core/src/java/org/apache/lucene/util/PriorityQueue.java
index a973461..66b71bb 100644
--- a/lucene/core/src/java/org/apache/lucene/util/PriorityQueue.java
+++ b/lucene/core/src/java/org/apache/lucene/util/PriorityQueue.java
@@ -89,7 +89,7 @@ public abstract class PriorityQueue<T> {
    * value (i.e., {@link #lessThan} should always favor the
    * non-sentinel values).<br>
    * 
-   * By default, this method returns false, which means the queue will not be
+   * By default, this method returns null, which means the queue will not be
    * filled with sentinel values. Otherwise, the value returned will be used to
    * pre-populate the queue. Adds sentinel values to the queue.<br>
    * 
