Index: src/test/org/apache/lucene/index/TestReaderUpdate.java
===================================================================
--- src/test/org/apache/lucene/index/TestReaderUpdate.java	(revision 0)
+++ src/test/org/apache/lucene/index/TestReaderUpdate.java	(revision 0)
@@ -0,0 +1,38 @@
+package org.apache.lucene.index;
+
+import java.io.IOException;
+
+import org.apache.lucene.analysis.WhitespaceAnalyzer;
+import org.apache.lucene.index.IndexWriter.Readers;
+import org.apache.lucene.search.Similarity;
+import org.apache.lucene.store.Directory;
+import org.apache.lucene.store.MockRAMDirectory;
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestReaderUpdate extends LuceneTestCase {
+  
+  public void test() throws Exception {
+    Directory dir = new MockRAMDirectory();
+    IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(),
+        IndexWriter.MaxFieldLength.LIMITED);
+    TestIndexWriterReader.createIndexNoClose(false, "index1", writer);
+    final byte b = Similarity.encodeNorm(500.0f);
+    
+    writer.updateReaders(new Readers() {
+      public void call(SegmentReader[] readers) throws IOException {
+        readers[0].deleteDocument(10);
+        
+        readers[0].setNorm(5, "field1", b);
+      }
+    });
+    IndexReader reader = writer.getReader();
+    assertTrue(reader.isDeleted(10));
+    byte[] norms = reader.norms("field1");
+    assertEquals(b, norms[5]);
+    
+    reader.close();
+    
+    writer.close();
+    dir.close();
+  }
+}
Index: src/java/org/apache/lucene/index/IndexWriter.java
===================================================================
--- src/java/org/apache/lucene/index/IndexWriter.java	(revision 880910)
+++ src/java/org/apache/lucene/index/IndexWriter.java	(working copy)
@@ -368,7 +368,39 @@
   public IndexReader getReader() throws IOException {
     return getReader(IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);
   }
-
+  
+  /**
+   * Enables user updating of the current segment readers.
+   * Synchronization and pooling of the readers is handled
+   * transparently.
+   */
+  public void updateReaders(Readers callback) throws IOException {
+    poolReaders = true;
+    flush(true, true, true);
+    synchronized (this) {
+      SegmentReader[] readers = new SegmentReader[segmentInfos.size()];
+      int i = 0;
+      for (SegmentInfo info : segmentInfos) {
+        SegmentReader reader = readerPool.get(info, true);
+        readers[i++] = reader;
+      }
+      try {
+        callback.call(readers);
+      } finally {
+        for (SegmentReader reader : readers) {
+          readerPool.release(reader);
+        }
+      }
+    }
+  }
+  
+  /**
+   * Callback for updating individual SegmentReaders
+   */
+  public abstract static class Readers {
+    public abstract void call(SegmentReader[] readers) throws IOException;
+  }
+  
   /** Expert: like {@link #getReader}, except you can
    *  specify which termInfosIndexDivisor should be used for
    *  any newly opened readers.
