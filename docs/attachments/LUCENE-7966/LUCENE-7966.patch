diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/blockterms/FixedGapTermsIndexWriter.java b/lucene/codecs/src/java/org/apache/lucene/codecs/blockterms/FixedGapTermsIndexWriter.java
index cdfd962..abb4cb0 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/blockterms/FixedGapTermsIndexWriter.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/blockterms/FixedGapTermsIndexWriter.java
@@ -150,7 +150,13 @@ public class FixedGapTermsIndexWriter extends TermsIndexWriterBase {
 
     @Override
     public void add(BytesRef text, TermStats stats, long termsFilePointer) throws IOException {
-      final int indexedTermLength = indexedTermPrefixLength(lastTerm.get(), text);
+      final int indexedTermLength;
+      if (numIndexTerms == 0) {
+        // no previous term: no bytes to write
+        indexedTermLength = 0;
+      } else {
+        indexedTermLength = indexedTermPrefixLength(lastTerm.get(), text);
+      }
       //System.out.println("FGW: add text=" + text.utf8ToString() + " " + text + " fp=" + termsFilePointer);
 
       // write only the min prefix that shows the diff
diff --git a/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextStoredFieldsReader.java b/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextStoredFieldsReader.java
index ead8ecc..2a2490e 100644
--- a/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextStoredFieldsReader.java
+++ b/lucene/codecs/src/java/org/apache/lucene/codecs/simpletext/SimpleTextStoredFieldsReader.java
@@ -20,6 +20,7 @@ package org.apache.lucene.codecs.simpletext;
 import java.io.IOException;
 
 import org.apache.lucene.codecs.StoredFieldsReader;
+import org.apache.lucene.future.FutureArrays;
 import org.apache.lucene.index.FieldInfo;
 import org.apache.lucene.index.FieldInfos;
 import org.apache.lucene.index.IndexFileNames;
@@ -202,8 +203,8 @@ public class SimpleTextStoredFieldsReader extends StoredFieldsReader {
   }
   
   private boolean equalsAt(BytesRef a, BytesRef b, int bOffset) {
-    return a.length == b.length - bOffset && 
-        ArrayUtil.equals(a.bytes, a.offset, b.bytes, b.offset + bOffset, b.length - bOffset);
+    return a.length == b.length - bOffset &&
+        FutureArrays.equals(a.bytes, a.offset, a.offset + a.length, b.bytes, b.offset + bOffset, b.offset + b.length);
   }
 
   @Override
diff --git a/lucene/common-build.xml b/lucene/common-build.xml
index cc0b356..1c0003c 100644
--- a/lucene/common-build.xml
+++ b/lucene/common-build.xml
@@ -2026,6 +2026,9 @@ ${ant.project.name}.test.dependencies=${test.classpath.list}
     <attribute name="destdir"/>
     <attribute name="javac.release" default="${javac.release}"/>
     <attribute name="includeantruntime" default="${javac.includeAntRuntime}" />
+    <attribute name="fork" default="no"/>
+    <attribute name="executable" default="Executable is mandatory because fork was set"/>
+    <attribute name="profile.args" default="${javac.profile.args}"/>
 
     <element name="nested" implicit="yes" optional="yes"/>
 
@@ -2041,12 +2044,14 @@ ${ant.project.name}.test.dependencies=${test.classpath.list}
         srcdir="@{srcdir}"
         destdir="@{destdir}"
         deprecation="${javac.deprecation}"
+        fork="@{fork}"
+        executable="@{executable}"
         debug="${javac.debug}">
         <nested/>
         <!-- <compilerarg line="-Xmaxwarns 10000000"/>
         <compilerarg line="-Xmaxerrs 10000000"/> -->
         <compilerarg line="${javac.args}"/>
-        <compilerarg line="${javac.profile.args}"/>
+        <compilerarg line="@{profile.args}"/>
         <compilerarg line="${javac.release.args}"/>
         <compilerarg line="${javac.doclint.args}"/>
       </javac>
diff --git a/lucene/core/build.xml b/lucene/core/build.xml
index d968798..4d9e8c9 100644
--- a/lucene/core/build.xml
+++ b/lucene/core/build.xml
@@ -44,6 +44,54 @@
     <pathelement path="${java.class.path}"/>
   </path>
 
+  <target name="compile-core" depends="common.compile-core,compile-futurejava"/>
+
+  <!--
+  TODO: should JAVA9_HOME be optional or mandatory to compile lucene?
+  we can make it optional, instead with a warning such as:
+    "better performance if you set JAVA9_HOME"
+  and add various checks in the smoketester.
+  Otherwise, we have to edit BUILD.txt with the requirements.
+  -->
+  <!--
+  TODO: smoketester should validate any class in META-INF/versions/N has a corresponding
+  file also in the main release! Maybe methods and constants, too.
+  This is the missing validation promised in JEP 238 but not implemented anywhere I can find.
+  -->
+  <!--
+  TODO: various checks in the build such as RAT are hardcoded at src/java and not hooked in.
+  -->
+
+  <property environment="env"/>
+  <fail message="You must currently also set JAVA9_HOME to build from source">
+    <condition>
+      <not><isset property="env.JAVA9_HOME"/></not>
+    </condition>
+  </fail>
+  <!-- TODO: on windows does executable need .exe suffix? -->
+  <property name="java9.javac.exe" value="${env.JAVA9_HOME}/bin/javac"/>
+
+  <!-- simple, as there are no resources or dependencies (jdk only) -->
+  <target name="compile-futurejava">
+    <compile srcdir="src/futurejava"
+             destdir="${build.dir}/futureclasses"
+             fork="true"
+             executable="${java9.javac.exe}"
+             javac.release="9"
+             profile.args=""/>
+  </target>
+
+  <target name="jar-core">
+    <jarify>
+      <filesets>
+        <zipfileset prefix="META-INF/versions/9/" dir="${build.dir}/futureclasses"/>
+      </filesets>
+      <jarify-additional-manifest-attributes>
+        <attribute name="Multi-Release" value="true"/>
+      </jarify-additional-manifest-attributes>
+    </jarify>
+  </target>
+
   <target name="test-core" depends="common.test"/>
 
   <target name="javadocs-core" depends="javadocs"/>
diff --git a/lucene/core/src/futurejava/org/apache/lucene/future/FutureArrays.java b/lucene/core/src/futurejava/org/apache/lucene/future/FutureArrays.java
new file mode 100644
index 0000000..ca58a27
--- /dev/null
+++ b/lucene/core/src/futurejava/org/apache/lucene/future/FutureArrays.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.future;
+
+import java.util.Arrays;
+
+// Methods from Java9's java.util.Arrays
+@Deprecated
+public final class FutureArrays {
+
+  // byte[]
+
+  public static int mismatch(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex) {
+    return Arrays.mismatch(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex);
+  }
+  
+  public static int compareUnsigned(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex) {
+    return Arrays.compareUnsigned(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex);
+  }
+  
+  public static boolean equals(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex) {
+    return Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex);
+  }
+  
+  // char[]
+  
+  public static int mismatch(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex) {
+    return Arrays.mismatch(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex);
+  }
+  
+  public static int compare(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex) {
+    return Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex);
+  }
+  
+  public static boolean equals(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex) {
+    return Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex);
+  }
+  
+  // int[]
+  
+  public static int compare(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex) {
+    return Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex);
+  }
+  
+  public static boolean equals(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex) {
+    return Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex);
+  }
+  
+  // long[]
+  
+  public static int compare(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex) {
+    return Arrays.compare(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex);
+  }
+  
+  public static boolean equals(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex) {
+    return Arrays.equals(a, aFromIndex, aToIndex, b, bFromIndex, bToIndex);
+  }
+  
+}
diff --git a/lucene/core/src/futurejava/org/apache/lucene/future/FutureObjects.java b/lucene/core/src/futurejava/org/apache/lucene/future/FutureObjects.java
new file mode 100644
index 0000000..aa6befe
--- /dev/null
+++ b/lucene/core/src/futurejava/org/apache/lucene/future/FutureObjects.java
@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.future;
+
+import java.util.Objects;
+
+// Methods from Java9's java.util.Objects
+@Deprecated
+public final class FutureObjects {
+
+  public static int checkIndex(int index, int length) {
+    return Objects.checkIndex(index, length);
+  }
+  
+  public static int checkFromToIndex(int fromIndex, int toIndex, int length) {
+    return Objects.checkFromToIndex(fromIndex, toIndex, length);
+  }
+  
+  public static int checkFromIndexSize(int fromIndex, int size, int length) {
+    return Objects.checkFromIndexSize(fromIndex, size, length);
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl.java b/lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl.java
index 355f417..016d768 100644
--- a/lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl.java
+++ b/lucene/core/src/java/org/apache/lucene/analysis/tokenattributes/CharTermAttributeImpl.java
@@ -18,6 +18,7 @@ package org.apache.lucene.analysis.tokenattributes;
 
 import java.nio.CharBuffer;
 
+import org.apache.lucene.future.FutureObjects;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.AttributeImpl;
 import org.apache.lucene.util.AttributeReflector;
@@ -71,11 +72,7 @@ public class CharTermAttributeImpl extends AttributeImpl implements CharTermAttr
 
   @Override
   public final CharTermAttribute setLength(int length) {
-    if (length < 0) {
-      throw new IllegalArgumentException("length " + length + " must not be negative");
-    }
-    if (length > termBuffer.length)
-      throw new IllegalArgumentException("length " + length + " exceeds the size of the termBuffer (" + termBuffer.length + ")");
+    FutureObjects.checkFromIndexSize(0, length, termBuffer.length);
     termLength = length;
     return this;
   }
@@ -102,15 +99,13 @@ public class CharTermAttributeImpl extends AttributeImpl implements CharTermAttr
   
   @Override
   public final char charAt(int index) {
-    if (index >= termLength)
-      throw new IndexOutOfBoundsException();
+    FutureObjects.checkIndex(index, termLength);
     return termBuffer[index];
   }
   
   @Override
   public final CharSequence subSequence(final int start, final int end) {
-    if (start > termLength || end > termLength)
-      throw new IndexOutOfBoundsException();
+    FutureObjects.checkFromToIndex(start, end, termLength);
     return new String(termBuffer, start, end - start);
   }
   
@@ -127,9 +122,9 @@ public class CharTermAttributeImpl extends AttributeImpl implements CharTermAttr
   public final CharTermAttribute append(CharSequence csq, int start, int end) {
     if (csq == null) // needed for Appendable compliance
       csq = "null";
-    final int len = end - start, csqlen = csq.length();
-    if (len < 0 || start > csqlen || end > csqlen)
-      throw new IndexOutOfBoundsException();
+    // TODO: the optimized cases (jdk methods) will already do such checks, maybe re-organize this?
+    FutureObjects.checkFromToIndex(start, end, csq.length());
+    final int len = end - start;
     if (len == 0)
       return this;
     resizeBuffer(termLength + len);
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingTermVectorsWriter.java b/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingTermVectorsWriter.java
index 26fe890..ee948c3 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingTermVectorsWriter.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/compressing/CompressingTermVectorsWriter.java
@@ -293,7 +293,13 @@ public final class CompressingTermVectorsWriter extends TermVectorsWriter {
   @Override
   public void startTerm(BytesRef term, int freq) throws IOException {
     assert freq >= 1;
-    final int prefix = StringHelper.bytesDifference(lastTerm, term);
+    final int prefix;
+    if (lastTerm.length == 0) {
+      // no previous term: no bytes to write
+      prefix = 0;
+    } else {
+      prefix = StringHelper.bytesDifference(lastTerm, term);
+    }
     curField.addTerm(freq, prefix, term.length - prefix);
     termSuffixes.writeBytes(term.bytes, term.offset + prefix, term.length - prefix);
     // copy last term
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4.java b/lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4.java
index 44bc82c..afdbc44 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4.java
@@ -20,6 +20,7 @@ package org.apache.lucene.codecs.compressing;
 import java.io.IOException;
 import java.util.Arrays;
 
+import org.apache.lucene.future.FutureArrays;
 import org.apache.lucene.store.DataInput;
 import org.apache.lucene.store.DataOutput;
 import org.apache.lucene.util.packed.PackedInts;
@@ -61,11 +62,8 @@ final class LZ4 {
 
   private static int commonBytes(byte[] b, int o1, int o2, int limit) {
     assert o1 < o2;
-    int count = 0;
-    while (o2 < limit && b[o1++] == b[o2++]) {
-      ++count;
-    }
-    return count;
+    // never -1 because lengths always differ
+    return FutureArrays.mismatch(b, o1, limit, b, o2, limit);
   }
 
   private static int commonBytesBackward(byte[] b, int o1, int o2, int l1, int l2) {
diff --git a/lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70DocValuesConsumer.java b/lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70DocValuesConsumer.java
index 2dd68e9..e25e8e7 100644
--- a/lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70DocValuesConsumer.java
+++ b/lucene/core/src/java/org/apache/lucene/codecs/lucene70/Lucene70DocValuesConsumer.java
@@ -504,7 +504,13 @@ final class Lucene70DocValuesConsumer extends DocValuesConsumer implements Close
     for (BytesRef term = iterator.next(); term != null; term = iterator.next()) {
       if ((ord & Lucene70DocValuesFormat.TERMS_DICT_REVERSE_INDEX_MASK) == 0) {
         writer.add(offset);
-        int sortKeyLength = StringHelper.sortKeyLength(previous.get(), term);
+        final int sortKeyLength;
+        if (ord == 0) {
+          // no previous term: no bytes to write
+          sortKeyLength = 0;
+        } else {
+          sortKeyLength = StringHelper.sortKeyLength(previous.get(), term);
+        }
         offset += sortKeyLength;
         data.writeBytes(term.bytes, term.offset, sortKeyLength);
       } else if ((ord & Lucene70DocValuesFormat.TERMS_DICT_REVERSE_INDEX_MASK) == Lucene70DocValuesFormat.TERMS_DICT_REVERSE_INDEX_MASK) {
diff --git a/lucene/core/src/java/org/apache/lucene/document/BinaryPoint.java b/lucene/core/src/java/org/apache/lucene/document/BinaryPoint.java
index 81ef092..5ff84d3 100644
--- a/lucene/core/src/java/org/apache/lucene/document/BinaryPoint.java
+++ b/lucene/core/src/java/org/apache/lucene/document/BinaryPoint.java
@@ -19,6 +19,7 @@ package org.apache.lucene.document;
 import java.util.Arrays;
 import java.util.Comparator;
 
+import org.apache.lucene.future.FutureArrays;
 import org.apache.lucene.index.IndexableFieldType;
 import org.apache.lucene.index.PointValues;
 import org.apache.lucene.search.MatchNoDocsQuery;
@@ -26,7 +27,6 @@ import org.apache.lucene.search.PointInSetQuery;
 import org.apache.lucene.search.PointRangeQuery;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.util.BytesRef;
-import org.apache.lucene.util.StringHelper;
 
 /** 
  * An indexed binary field for fast range filters.  If you also
@@ -222,7 +222,7 @@ public final class BinaryPoint extends Field {
                 new Comparator<byte[]>() {
                   @Override
                   public int compare(byte[] a, byte[] b) {
-                    return StringHelper.compare(a.length, a, 0, b, 0);
+                    return FutureArrays.compareUnsigned(a, 0, a.length, b, 0, b.length);
                   }
                 });
 
diff --git a/lucene/core/src/java/org/apache/lucene/document/DoubleRange.java b/lucene/core/src/java/org/apache/lucene/document/DoubleRange.java
index 90a8eb9..3a6d082 100644
--- a/lucene/core/src/java/org/apache/lucene/document/DoubleRange.java
+++ b/lucene/core/src/java/org/apache/lucene/document/DoubleRange.java
@@ -17,6 +17,7 @@
 package org.apache.lucene.document;
 
 import org.apache.lucene.document.RangeFieldQuery.QueryType;
+import org.apache.lucene.future.FutureObjects;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.NumericUtils;
@@ -147,10 +148,7 @@ public class DoubleRange extends Field {
    * @return the decoded min value
    */
   public double getMin(int dimension) {
-    if (dimension < 0 || dimension >= type.pointDimensionCount()/2) {
-      throw new IllegalArgumentException("dimension request (" + dimension +
-          ") out of bounds for field (name=" + name + " dimensions=" + type.pointDimensionCount()/2 + "). ");
-    }
+    FutureObjects.checkIndex(dimension, type.pointDimensionCount()/2);
     return decodeMin(((BytesRef)fieldsData).bytes, dimension);
   }
 
@@ -160,10 +158,7 @@ public class DoubleRange extends Field {
    * @return the decoded max value
    */
   public double getMax(int dimension) {
-    if (dimension < 0 || dimension >= type.pointDimensionCount()/2) {
-      throw new IllegalArgumentException("dimension request (" + dimension +
-          ") out of bounds for field (name=" + name + " dimensions=" + type.pointDimensionCount()/2 + "). ");
-    }
+    FutureObjects.checkIndex(dimension, type.pointDimensionCount()/2);
     return decodeMax(((BytesRef)fieldsData).bytes, dimension);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/document/FloatRange.java b/lucene/core/src/java/org/apache/lucene/document/FloatRange.java
index 8b40538..bef4ec7 100644
--- a/lucene/core/src/java/org/apache/lucene/document/FloatRange.java
+++ b/lucene/core/src/java/org/apache/lucene/document/FloatRange.java
@@ -17,6 +17,7 @@
 package org.apache.lucene.document;
 
 import org.apache.lucene.document.RangeFieldQuery.QueryType;
+import org.apache.lucene.future.FutureObjects;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.NumericUtils;
@@ -147,10 +148,7 @@ public class FloatRange extends Field {
    * @return the decoded min value
    */
   public float getMin(int dimension) {
-    if (dimension < 0 || dimension >= type.pointDimensionCount()/2) {
-      throw new IllegalArgumentException("dimension request (" + dimension +
-          ") out of bounds for field (name=" + name + " dimensions=" + type.pointDimensionCount()/2 + "). ");
-    }
+    FutureObjects.checkIndex(dimension, type.pointDimensionCount()/2);
     return decodeMin(((BytesRef)fieldsData).bytes, dimension);
   }
 
@@ -160,10 +158,7 @@ public class FloatRange extends Field {
    * @return the decoded max value
    */
   public float getMax(int dimension) {
-    if (dimension < 0 || dimension >= type.pointDimensionCount()/2) {
-      throw new IllegalArgumentException("dimension request (" + dimension +
-          ") out of bounds for field (name=" + name + " dimensions=" + type.pointDimensionCount()/2 + "). ");
-    }
+    FutureObjects.checkIndex(dimension, type.pointDimensionCount()/2);
     return decodeMax(((BytesRef)fieldsData).bytes, dimension);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/document/IntRange.java b/lucene/core/src/java/org/apache/lucene/document/IntRange.java
index 6d2b71c..c4c0a3b 100644
--- a/lucene/core/src/java/org/apache/lucene/document/IntRange.java
+++ b/lucene/core/src/java/org/apache/lucene/document/IntRange.java
@@ -17,6 +17,7 @@
 package org.apache.lucene.document;
 
 import org.apache.lucene.document.RangeFieldQuery.QueryType;
+import org.apache.lucene.future.FutureObjects;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.NumericUtils;
@@ -147,10 +148,7 @@ public class IntRange extends Field {
    * @return the decoded min value
    */
   public int getMin(int dimension) {
-    if (dimension < 0 || dimension >= type.pointDimensionCount()/2) {
-      throw new IllegalArgumentException("dimension request (" + dimension +
-          ") out of bounds for field (name=" + name + " dimensions=" + type.pointDimensionCount()/2 + "). ");
-    }
+    FutureObjects.checkIndex(dimension, type.pointDimensionCount()/2);
     return decodeMin(((BytesRef)fieldsData).bytes, dimension);
   }
 
@@ -160,10 +158,7 @@ public class IntRange extends Field {
    * @return the decoded max value
    */
   public int getMax(int dimension) {
-    if (dimension < 0 || dimension >= type.pointDimensionCount()/2) {
-      throw new IllegalArgumentException("dimension request (" + dimension +
-          ") out of bounds for field (name=" + name + " dimensions=" + type.pointDimensionCount()/2 + "). ");
-    }
+    FutureObjects.checkIndex(dimension, type.pointDimensionCount()/2);
     return decodeMax(((BytesRef)fieldsData).bytes, dimension);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/document/LongRange.java b/lucene/core/src/java/org/apache/lucene/document/LongRange.java
index 009f4a1..30630fd 100644
--- a/lucene/core/src/java/org/apache/lucene/document/LongRange.java
+++ b/lucene/core/src/java/org/apache/lucene/document/LongRange.java
@@ -17,6 +17,7 @@
 package org.apache.lucene.document;
 
 import org.apache.lucene.document.RangeFieldQuery.QueryType;
+import org.apache.lucene.future.FutureObjects;
 import org.apache.lucene.search.Query;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.NumericUtils;
@@ -145,10 +146,7 @@ public class LongRange extends Field {
    * @return the decoded min value
    */
   public long getMin(int dimension) {
-    if (dimension < 0 || dimension >= type.pointDimensionCount()/2) {
-      throw new IllegalArgumentException("dimension request (" + dimension +
-          ") out of bounds for field (name=" + name + " dimensions=" + type.pointDimensionCount()/2 + "). ");
-    }
+    FutureObjects.checkIndex(dimension, type.pointDimensionCount()/2);
     return decodeMin(((BytesRef)fieldsData).bytes, dimension);
   }
 
@@ -158,10 +156,7 @@ public class LongRange extends Field {
    * @return the decoded max value
    */
   public long getMax(int dimension) {
-    if (dimension < 0 || dimension >= type.pointDimensionCount()/2) {
-      throw new IllegalArgumentException("dimension request (" + dimension +
-          ") out of bounds for field (name=" + name + " dimensions=" + type.pointDimensionCount()/2 + "). ");
-    }
+    FutureObjects.checkIndex(dimension, type.pointDimensionCount()/2);
     return decodeMax(((BytesRef)fieldsData).bytes, dimension);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/future/FutureArrays.java b/lucene/core/src/java/org/apache/lucene/future/FutureArrays.java
new file mode 100644
index 0000000..9b595ae
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/future/FutureArrays.java
@@ -0,0 +1,258 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.future;
+
+/**
+ * Additional methods from Java 9's java.util.Arrays
+ * @lucene.internal
+ * @deprecated Will be removed when Java 9 is required. Use java.util.Arrays directly instead.
+ */
+@Deprecated
+public final class FutureArrays {
+  
+  // methods in Arrays are defined stupid: they cannot use Objects.checkFromToIndex
+  // they throw IAE (vs IOOBE) in the case of fromIndex > toIndex.
+  // so this method works just like checkFromToIndex, but with that stupidity added.
+  private static void checkFromToIndex(int fromIndex, int toIndex, int length) {
+    if (fromIndex > toIndex) {
+      throw new IllegalArgumentException("fromIndex " + fromIndex + " > toIndex " + toIndex);
+    }
+    if (fromIndex < 0 || toIndex > length) {
+      throw new IndexOutOfBoundsException("Range [" + fromIndex + ", " + toIndex + ") out-of-bounds for length " + length);
+    }
+  }
+
+  // byte[]
+
+  /**
+   * Behaves like Java 9's Arrays.mismatch
+   * @see <a href="http://download.java.net/java/jdk9/docs/api/java/util/Arrays.html#mismatch-byte:A-int-int-byte:A-int-int-">Arrays.mismatch</a>
+   */
+  public static int mismatch(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex) {
+    checkFromToIndex(aFromIndex, aToIndex, a.length);
+    checkFromToIndex(bFromIndex, bToIndex, b.length);
+    int aLen = aToIndex - aFromIndex;
+    int bLen = bToIndex - bFromIndex;
+    int len = Math.min(aLen, bLen);
+    for (int i = 0; i < len; i++)
+      if (a[i+aFromIndex] != b[i+bFromIndex])
+        return i;
+    return aLen == bLen ? -1 : len;
+  }
+  
+  /**
+   * Behaves like Java 9's Arrays.compareUnsigned
+   * @see <a href="http://download.java.net/java/jdk9/docs/api/java/util/Arrays.html#compareUnsigned-byte:A-int-int-byte:A-int-int-">Arrays.compareUnsigned</a>
+   */
+  public static int compareUnsigned(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex) {
+    checkFromToIndex(aFromIndex, aToIndex, a.length);
+    checkFromToIndex(bFromIndex, bToIndex, b.length);
+    int aLen = aToIndex - aFromIndex;
+    int bLen = bToIndex - bFromIndex;
+    int len = Math.min(aLen, bLen);
+    for (int i = 0; i < len; i++) {
+      int aByte = a[i+aFromIndex] & 0xFF;
+      int bByte = b[i+bFromIndex] & 0xFF;
+      int diff = aByte - bByte;
+      if (diff != 0) {
+        return diff;
+      }
+    }
+
+    // One is a prefix of the other, or, they are equal:
+    return aLen - bLen;
+  }
+  
+  /**
+   * Behaves like Java 9's Arrays.equals
+   * @see <a href="http://download.java.net/java/jdk9/docs/api/java/util/Arrays.html#equals-byte:A-int-int-byte:A-int-int-">Arrays.equals</a>
+   */
+  public static boolean equals(byte[] a, int aFromIndex, int aToIndex, byte[] b, int bFromIndex, int bToIndex) {
+    checkFromToIndex(aFromIndex, aToIndex, a.length);
+    checkFromToIndex(bFromIndex, bToIndex, b.length);
+    int aLen = aToIndex - aFromIndex;
+    int bLen = bToIndex - bFromIndex;
+    // lengths differ: cannot be equal
+    if (aLen != bLen) {
+      return false;
+    }
+    for (int i = 0; i < aLen; i++) {
+      if (a[i+aFromIndex] != b[i+bFromIndex]) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  // char[]
+
+  /**
+   * Behaves like Java 9's Arrays.mismatch
+   * @see <a href="http://download.java.net/java/jdk9/docs/api/java/util/Arrays.html#mismatch-char:A-int-int-char:A-int-int-">Arrays.mismatch</a>
+   */
+  public static int mismatch(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex) {
+    checkFromToIndex(aFromIndex, aToIndex, a.length);
+    checkFromToIndex(bFromIndex, bToIndex, b.length);
+    int aLen = aToIndex - aFromIndex;
+    int bLen = bToIndex - bFromIndex;
+    int len = Math.min(aLen, bLen);
+    for (int i = 0; i < len; i++)
+      if (a[i+aFromIndex] != b[i+bFromIndex])
+        return i;
+    return aLen == bLen ? -1 : len;
+  }
+  
+  /**
+   * Behaves like Java 9's Arrays.compare
+   * @see <a href="http://download.java.net/java/jdk9/docs/api/java/util/Arrays.html#compare-char:A-int-int-char:A-int-int-">Arrays.compare</a>
+   */
+  public static int compare(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex) {
+    checkFromToIndex(aFromIndex, aToIndex, a.length);
+    checkFromToIndex(bFromIndex, bToIndex, b.length);
+    int aLen = aToIndex - aFromIndex;
+    int bLen = bToIndex - bFromIndex;
+    int len = Math.min(aLen, bLen);
+    for (int i = 0; i < len; i++) {
+      int aInt = a[i+aFromIndex];
+      int bInt = b[i+bFromIndex];
+      if (aInt > bInt) {
+        return 1;
+      } else if (aInt < bInt) {
+        return -1;
+      }
+    }
+
+    // One is a prefix of the other, or, they are equal:
+    return aLen - bLen;
+  }
+  
+  /**
+   * Behaves like Java 9's Arrays.equals
+   * @see <a href="http://download.java.net/java/jdk9/docs/api/java/util/Arrays.html#equals-char:A-int-int-char:A-int-int-">Arrays.equals</a>
+   */
+  public static boolean equals(char[] a, int aFromIndex, int aToIndex, char[] b, int bFromIndex, int bToIndex) {
+    checkFromToIndex(aFromIndex, aToIndex, a.length);
+    checkFromToIndex(bFromIndex, bToIndex, b.length);
+    int aLen = aToIndex - aFromIndex;
+    int bLen = bToIndex - bFromIndex;
+    // lengths differ: cannot be equal
+    if (aLen != bLen) {
+      return false;
+    }
+    for (int i = 0; i < aLen; i++) {
+      if (a[i+aFromIndex] != b[i+bFromIndex]) {
+        return false;
+      }
+    }
+    return true;
+  }
+
+  // int[]
+  
+  /**
+   * Behaves like Java 9's Arrays.compare
+   * @see <a href="http://download.java.net/java/jdk9/docs/api/java/util/Arrays.html#compare-int:A-int-int-int:A-int-int-">Arrays.compare</a>
+   */
+  public static int compare(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex) {
+    checkFromToIndex(aFromIndex, aToIndex, a.length);
+    checkFromToIndex(bFromIndex, bToIndex, b.length);
+    int aLen = aToIndex - aFromIndex;
+    int bLen = bToIndex - bFromIndex;
+    int len = Math.min(aLen, bLen);
+    for (int i = 0; i < len; i++) {
+      int aInt = a[i+aFromIndex];
+      int bInt = b[i+bFromIndex];
+      if (aInt > bInt) {
+        return 1;
+      } else if (aInt < bInt) {
+        return -1;
+      }
+    }
+
+    // One is a prefix of the other, or, they are equal:
+    return aLen - bLen;
+  }
+  
+  /**
+   * Behaves like Java 9's Arrays.equals
+   * @see <a href="http://download.java.net/java/jdk9/docs/api/java/util/Arrays.html#equals-int:A-int-int-int:A-int-int-">Arrays.equals</a>
+   */
+  public static boolean equals(int[] a, int aFromIndex, int aToIndex, int[] b, int bFromIndex, int bToIndex) {
+    checkFromToIndex(aFromIndex, aToIndex, a.length);
+    checkFromToIndex(bFromIndex, bToIndex, b.length);
+    int aLen = aToIndex - aFromIndex;
+    int bLen = bToIndex - bFromIndex;
+    // lengths differ: cannot be equal
+    if (aLen != bLen) {
+      return false;
+    }
+    for (int i = 0; i < aLen; i++) {
+      if (a[i+aFromIndex] != b[i+bFromIndex]) {
+        return false;
+      }
+    }
+    return true;
+  }
+  
+  // long[]
+  
+  /**
+   * Behaves like Java 9's Arrays.compare
+   * @see <a href="http://download.java.net/java/jdk9/docs/api/java/util/Arrays.html#compare-long:A-int-int-long:A-int-int-">Arrays.compare</a>
+   */
+  public static int compare(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex) {
+    checkFromToIndex(aFromIndex, aToIndex, a.length);
+    checkFromToIndex(bFromIndex, bToIndex, b.length);
+    int aLen = aToIndex - aFromIndex;
+    int bLen = bToIndex - bFromIndex;
+    int len = Math.min(aLen, bLen);
+    for (int i = 0; i < len; i++) {
+      long aInt = a[i+aFromIndex];
+      long bInt = b[i+bFromIndex];
+      if (aInt > bInt) {
+        return 1;
+      } else if (aInt < bInt) {
+        return -1;
+      }
+    }
+
+    // One is a prefix of the other, or, they are equal:
+    return aLen - bLen;
+  }
+  
+  /**
+   * Behaves like Java 9's Arrays.equals
+   * @see <a href="http://download.java.net/java/jdk9/docs/api/java/util/Arrays.html#equals-long:A-int-int-long:A-int-int-">Arrays.equals</a>
+   */
+  public static boolean equals(long[] a, int aFromIndex, int aToIndex, long[] b, int bFromIndex, int bToIndex) {
+    checkFromToIndex(aFromIndex, aToIndex, a.length);
+    checkFromToIndex(bFromIndex, bToIndex, b.length);
+    int aLen = aToIndex - aFromIndex;
+    int bLen = bToIndex - bFromIndex;
+    // lengths differ: cannot be equal
+    if (aLen != bLen) {
+      return false;
+    }
+    for (int i = 0; i < aLen; i++) {
+      if (a[i+aFromIndex] != b[i+bFromIndex]) {
+        return false;
+      }
+    }
+    return true;
+  }
+  
+}
diff --git a/lucene/core/src/java/org/apache/lucene/future/FutureObjects.java b/lucene/core/src/java/org/apache/lucene/future/FutureObjects.java
new file mode 100644
index 0000000..0f0d90b
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/future/FutureObjects.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.future;
+
+/**
+ * Additional methods from Java 9's java.util.Objects
+ * @lucene.internal
+ * @deprecated Will be removed when Java 9 is required. Use java.util.Objects directly instead.
+ */
+@Deprecated
+public final class FutureObjects {
+
+  /**
+   * Behaves like Java 9's Objects.checkIndex
+   * @see <a href="http://download.java.net/java/jdk9/docs/api/java/util/Objects.html#checkIndex-int-int-">Objects.checkIndex</a>
+   */
+  public static int checkIndex(int index, int length) {
+    if (index < 0 || index >= length) {
+      throw new IndexOutOfBoundsException("Index " + index + " out-of-bounds for length " + length);
+    }
+    return index;
+  }
+  
+  /**
+   * Behaves like Java 9's Objects.checkFromToIndex
+   * @see <a href="http://download.java.net/java/jdk9/docs/api/java/util/Objects.html#checkFromToIndex-int-int-int-">Objects.checkFromToIndex</a>
+   */
+  public static int checkFromToIndex(int fromIndex, int toIndex, int length) {
+    if (fromIndex < 0 || fromIndex > toIndex || toIndex > length) {
+      throw new IndexOutOfBoundsException("Range [" + fromIndex + ", " + toIndex + ") out-of-bounds for length " + length);
+    }
+    return fromIndex;
+  }
+  
+  /**
+   * Behaves like Java 9's Objects.checkFromIndexSize
+   * @see <a href="http://download.java.net/java/jdk9/docs/api/java/util/Objects.html#checkFromIndexSize-int-int-int-">Objects.checkFromIndexSize</a>
+   */
+  public static int checkFromIndexSize(int fromIndex, int size, int length) {
+    int end = fromIndex + size;
+    if (fromIndex < 0 || fromIndex > end || end > length) {
+      throw new IndexOutOfBoundsException("Range [" + fromIndex + ", " + fromIndex + " + " + size + ") out-of-bounds for length " + length);
+    }
+    return fromIndex;
+  }
+}
diff --git a/lucene/core/src/java/org/apache/lucene/future/package-info.java b/lucene/core/src/java/org/apache/lucene/future/package-info.java
new file mode 100644
index 0000000..752ff8b
--- /dev/null
+++ b/lucene/core/src/java/org/apache/lucene/future/package-info.java
@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/** 
+ * Methods available in future java versions.
+ * <p>
+ * Code in this package supports the minimum java version, but has a more efficient
+ * implementation on newer java versions.
+ * <p>
+ * Don't use any of the classes here in your own code, they will be removed when Lucene
+ * migrates to newer java versions.
+ */
+@Deprecated
+package org.apache.lucene.future;
+// NOTE: please don't add complex classes here, just stick with 1-1 mapping of the newer JDK API.
+// This makes testing simpler (if you want to add tests to openjdk, please do that separate): it means
+// we only need to test our fallback implementations.
\ No newline at end of file
diff --git a/lucene/core/src/java/org/apache/lucene/index/BitsSlice.java b/lucene/core/src/java/org/apache/lucene/index/BitsSlice.java
index 216d8f9..09c7275 100644
--- a/lucene/core/src/java/org/apache/lucene/index/BitsSlice.java
+++ b/lucene/core/src/java/org/apache/lucene/index/BitsSlice.java
@@ -16,6 +16,7 @@
  */
 package org.apache.lucene.index;
 
+import org.apache.lucene.future.FutureObjects;
 import org.apache.lucene.util.Bits;
 
 
@@ -39,10 +40,7 @@ final class BitsSlice implements Bits {
     
   @Override
   public boolean get(int doc) {
-    if (doc >= length) {
-      throw new RuntimeException("doc " + doc + " is out of bounds 0 .. " + (length-1));
-    }
-    assert doc < length: "doc=" + doc + " length=" + length;
+    FutureObjects.checkIndex(doc, length);
     return parent.get(doc+start);
   }
 
diff --git a/lucene/core/src/java/org/apache/lucene/index/CodecReader.java b/lucene/core/src/java/org/apache/lucene/index/CodecReader.java
index 9efcf25..b46c1f0 100644
--- a/lucene/core/src/java/org/apache/lucene/index/CodecReader.java
+++ b/lucene/core/src/java/org/apache/lucene/index/CodecReader.java
@@ -29,6 +29,7 @@ import org.apache.lucene.codecs.NormsProducer;
 import org.apache.lucene.codecs.PointsReader;
 import org.apache.lucene.codecs.StoredFieldsReader;
 import org.apache.lucene.codecs.TermVectorsReader;
+import org.apache.lucene.future.FutureObjects;
 import org.apache.lucene.util.Accountable;
 import org.apache.lucene.util.Accountables;
 
@@ -94,9 +95,7 @@ public abstract class CodecReader extends LeafReader implements Accountable {
   }
   
   private void checkBounds(int docID) {
-    if (docID < 0 || docID >= maxDoc()) {       
-      throw new IndexOutOfBoundsException("docID must be >= 0 and < maxDoc=" + maxDoc() + " (got docID=" + docID + ")");
-    }
+    FutureObjects.checkIndex(docID, maxDoc());
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/index/MergeReaderWrapper.java b/lucene/core/src/java/org/apache/lucene/index/MergeReaderWrapper.java
index 565bdd4..35e0657 100644
--- a/lucene/core/src/java/org/apache/lucene/index/MergeReaderWrapper.java
+++ b/lucene/core/src/java/org/apache/lucene/index/MergeReaderWrapper.java
@@ -24,6 +24,7 @@ import org.apache.lucene.codecs.FieldsProducer;
 import org.apache.lucene.codecs.NormsProducer;
 import org.apache.lucene.codecs.StoredFieldsReader;
 import org.apache.lucene.codecs.TermVectorsReader;
+import org.apache.lucene.future.FutureObjects;
 import org.apache.lucene.util.Bits;
 
 /** This is a hack to make index sorting fast, with a {@link LeafReader} that always returns merge instances when you ask for the codec readers. */
@@ -226,9 +227,7 @@ class MergeReaderWrapper extends LeafReader {
   }
 
   private void checkBounds(int docID) {
-    if (docID < 0 || docID >= maxDoc()) {       
-      throw new IndexOutOfBoundsException("docID must be >= 0 and < maxDoc=" + maxDoc() + " (got docID=" + docID + ")");
-    }
+    FutureObjects.checkIndex(docID, maxDoc());
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/index/PrefixCodedTerms.java b/lucene/core/src/java/org/apache/lucene/index/PrefixCodedTerms.java
index ba56c2a..7a65d71 100644
--- a/lucene/core/src/java/org/apache/lucene/index/PrefixCodedTerms.java
+++ b/lucene/core/src/java/org/apache/lucene/index/PrefixCodedTerms.java
@@ -26,6 +26,7 @@ import org.apache.lucene.store.RAMOutputStream;
 import org.apache.lucene.util.Accountable;
 import org.apache.lucene.util.BytesRef;
 import org.apache.lucene.util.BytesRefBuilder;
+import org.apache.lucene.util.StringHelper;
 
 /**
  * Prefix codes term instances (prefixes are shared). This is expected to be
@@ -74,14 +75,19 @@ public class PrefixCodedTerms implements Accountable {
       assert lastTerm.equals(new Term("")) || new Term(field, bytes).compareTo(lastTerm) > 0;
 
       try {
-        int prefix = sharedPrefix(lastTerm.bytes, bytes);
-        int suffix = bytes.length - prefix;
-        if (field.equals(lastTerm.field)) {
+        final int prefix;
+        if (size > 0 && field.equals(lastTerm.field)) {
+          // same field as the last term
+          prefix = StringHelper.bytesDifference(lastTerm.bytes, bytes);
           output.writeVInt(prefix << 1);
         } else {
-          output.writeVInt(prefix << 1 | 1);
+          // field change
+          prefix = 0;
+          output.writeVInt(1);
           output.writeString(field);
         }
+
+        int suffix = bytes.length - prefix;
         output.writeVInt(suffix);
         output.writeBytes(bytes.bytes, bytes.offset + prefix, suffix);
         lastTermBytes.copyBytes(bytes);
@@ -102,20 +108,6 @@ public class PrefixCodedTerms implements Accountable {
         throw new RuntimeException(e);
       }
     }
-    
-    private int sharedPrefix(BytesRef term1, BytesRef term2) {
-      int pos1 = 0;
-      int pos1End = pos1 + Math.min(term1.length, term2.length);
-      int pos2 = 0;
-      while(pos1 < pos1End) {
-        if (term1.bytes[term1.offset + pos1] != term2.bytes[term2.offset + pos2]) {
-          return pos1;
-        }
-        pos1++;
-        pos2++;
-      }
-      return pos1;
-    }
   }
 
   /** An iterator over the list of terms stored in a {@link PrefixCodedTerms}. */
diff --git a/lucene/core/src/java/org/apache/lucene/search/BooleanScorer.java b/lucene/core/src/java/org/apache/lucene/search/BooleanScorer.java
index a264dca..deaa431 100644
--- a/lucene/core/src/java/org/apache/lucene/search/BooleanScorer.java
+++ b/lucene/core/src/java/org/apache/lucene/search/BooleanScorer.java
@@ -21,6 +21,7 @@ import java.io.IOException;
 import java.util.Arrays;
 import java.util.Collection;
 
+import org.apache.lucene.future.FutureObjects;
 import org.apache.lucene.util.Bits;
 import org.apache.lucene.util.PriorityQueue;
 
@@ -105,9 +106,7 @@ final class BooleanScorer extends BulkScorer {
     }
 
     public BulkScorerAndDoc get(int i) {
-      if (i < 0 || i >= size()) {
-        throw new IndexOutOfBoundsException();
-      }
+      FutureObjects.checkIndex(i, size());
       return (BulkScorerAndDoc) getHeapArray()[1 + i];
     }
 
diff --git a/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java b/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java
index 3bc65ef..3c5897f 100644
--- a/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java
+++ b/lucene/core/src/java/org/apache/lucene/util/ArrayUtil.java
@@ -313,58 +313,6 @@ public final class ArrayUtil {
       code = code * 31 + array[i];
     return code;
   }
-  
-  // Since Arrays.equals doesn't implement offsets for equals
-  /**
-   * See if two array slices are the same.
-   *
-   * @param left        The left array to compare
-   * @param offsetLeft  The offset into the array.  Must be positive
-   * @param right       The right array to compare
-   * @param offsetRight the offset into the right array.  Must be positive
-   * @param length      The length of the section of the array to compare
-   * @return true if the two arrays, starting at their respective offsets, are equal
-   * 
-   * @see java.util.Arrays#equals(byte[], byte[])
-   */
-  public static boolean equals(byte[] left, int offsetLeft, byte[] right, int offsetRight, int length) {
-    if ((offsetLeft + length <= left.length) && (offsetRight + length <= right.length)) {
-      for (int i = 0; i < length; i++) {
-        if (left[offsetLeft + i] != right[offsetRight + i]) {
-          return false;
-        }
-
-      }
-      return true;
-    }
-    return false;
-  }
-
-  // Since Arrays.equals doesn't implement offsets for equals
-  /**
-   * See if two array slices are the same.
-   *
-   * @param left        The left array to compare
-   * @param offsetLeft  The offset into the array.  Must be positive
-   * @param right       The right array to compare
-   * @param offsetRight the offset into the right array.  Must be positive
-   * @param length      The length of the section of the array to compare
-   * @return true if the two arrays, starting at their respective offsets, are equal
-   * 
-   * @see java.util.Arrays#equals(char[], char[])
-   */
-  public static boolean equals(int[] left, int offsetLeft, int[] right, int offsetRight, int length) {
-    if ((offsetLeft + length <= left.length) && (offsetRight + length <= right.length)) {
-      for (int i = 0; i < length; i++) {
-        if (left[offsetLeft + i] != right[offsetRight + i]) {
-          return false;
-        }
-
-      }
-      return true;
-    }
-    return false;
-  }
 
   /** Swap values stored in slots <code>i</code> and <code>j</code> */
   public static <T> void swap(T[] arr, int i, int j) {
diff --git a/lucene/core/src/java/org/apache/lucene/util/BytesRef.java b/lucene/core/src/java/org/apache/lucene/util/BytesRef.java
index 2fcf28a..3cafcc8 100644
--- a/lucene/core/src/java/org/apache/lucene/util/BytesRef.java
+++ b/lucene/core/src/java/org/apache/lucene/util/BytesRef.java
@@ -19,6 +19,8 @@ package org.apache.lucene.util;
 
 import java.util.Arrays;
 
+import org.apache.lucene.future.FutureArrays;
+
 /** Represents byte[], as a slice (offset + length) into an
  *  existing byte[].  The {@link #bytes} member should never be null;
  *  use {@link #EMPTY_BYTES} if necessary.
@@ -96,20 +98,8 @@ public final class BytesRef implements Comparable<BytesRef>,Cloneable {
    * @lucene.internal
    */
   public boolean bytesEquals(BytesRef other) {
-    assert other != null;
-    if (length == other.length) {
-      int otherUpto = other.offset;
-      final byte[] otherBytes = other.bytes;
-      final int end = offset + length;
-      for(int upto=offset;upto<end;upto++,otherUpto++) {
-        if (bytes[upto] != otherBytes[otherUpto]) {
-          return false;
-        }
-      }
-      return true;
-    } else {
-      return false;
-    }
+    return FutureArrays.equals(this.bytes, this.offset, this.offset + this.length, 
+                               other.bytes, other.offset, other.offset + other.length);
   }
 
   /**
@@ -172,27 +162,8 @@ public final class BytesRef implements Comparable<BytesRef>,Cloneable {
   /** Unsigned byte order comparison */
   @Override
   public int compareTo(BytesRef other) {
-    // TODO: Once we are on Java 9 replace this by java.util.Arrays#compareUnsigned()
-    // which is implemented by a Hotspot intrinsic! Also consider building a
-    // Multi-Release-JAR!
-    final byte[] aBytes = this.bytes;
-    int aUpto = this.offset;
-    final byte[] bBytes = other.bytes;
-    int bUpto = other.offset;
-    
-    final int aStop = aUpto + Math.min(this.length, other.length);
-    while(aUpto < aStop) {
-      int aByte = aBytes[aUpto++] & 0xff;
-      int bByte = bBytes[bUpto++] & 0xff;
-
-      int diff = aByte - bByte;
-      if (diff != 0) {
-        return diff;
-      }
-    }
-
-    // One is a prefix of the other, or, they are equal:
-    return this.length - other.length;
+    return FutureArrays.compareUnsigned(this.bytes, this.offset, this.offset + this.length, 
+                                        other.bytes, other.offset, other.offset + other.length);
   }
     
   /**
diff --git a/lucene/core/src/java/org/apache/lucene/util/BytesRefArray.java b/lucene/core/src/java/org/apache/lucene/util/BytesRefArray.java
index bab3d04..3b26d9d 100644
--- a/lucene/core/src/java/org/apache/lucene/util/BytesRefArray.java
+++ b/lucene/core/src/java/org/apache/lucene/util/BytesRefArray.java
@@ -19,6 +19,8 @@ package org.apache.lucene.util;
 import java.util.Arrays;
 import java.util.Comparator;
 
+import org.apache.lucene.future.FutureObjects;
+
 /**
  * A simple append only random-access {@link BytesRef} array that stores full
  * copies of the appended bytes in a {@link ByteBlockPool}.
@@ -93,34 +95,28 @@ public final class BytesRefArray implements SortableBytesRefArray {
    * @return the <i>n'th</i> element of this {@link BytesRefArray}
    */
   public BytesRef get(BytesRefBuilder spare, int index) {
-    if (lastElement > index) {
-      int offset = offsets[index];
-      int length = index == lastElement - 1 ? currentOffset - offset
-          : offsets[index + 1] - offset;
-      spare.grow(length);
-      spare.setLength(length);
-      pool.readBytes(offset, spare.bytes(), 0, spare.length());
-      return spare.get();
-    }
-    throw new IndexOutOfBoundsException("index " + index
-        + " must be less than the size: " + lastElement);
+    FutureObjects.checkIndex(index, lastElement);
+    int offset = offsets[index];
+    int length = index == lastElement - 1 ? currentOffset - offset
+        : offsets[index + 1] - offset;
+    spare.grow(length);
+    spare.setLength(length);
+    pool.readBytes(offset, spare.bytes(), 0, spare.length());
+    return spare.get();
   }
 
   /** Used only by sort below, to set a {@link BytesRef} with the specified slice, avoiding copying bytes in the common case when the slice
    *  is contained in a single block in the byte block pool. */
   private void setBytesRef(BytesRefBuilder spare, BytesRef result, int index) {
-    if (index < lastElement) {
-      int offset = offsets[index];
-      int length;
-      if (index == lastElement - 1) {
-        length = currentOffset - offset;
-      } else {
-        length = offsets[index + 1] - offset;
-      }
-      pool.setBytesRef(spare, result, offset, length);
+    FutureObjects.checkIndex(index, lastElement);
+    int offset = offsets[index];
+    int length;
+    if (index == lastElement - 1) {
+      length = currentOffset - offset;
     } else {
-      throw new IndexOutOfBoundsException("index " + index + " must be less than the size: " + lastElement);
+      length = offsets[index + 1] - offset;
     }
+    pool.setBytesRef(spare, result, offset, length);
   }
   
   private int[] sort(final Comparator<BytesRef> comp) {
diff --git a/lucene/core/src/java/org/apache/lucene/util/CharsRef.java b/lucene/core/src/java/org/apache/lucene/util/CharsRef.java
index aacdfcc..7a1151c 100644
--- a/lucene/core/src/java/org/apache/lucene/util/CharsRef.java
+++ b/lucene/core/src/java/org/apache/lucene/util/CharsRef.java
@@ -20,6 +20,9 @@ package org.apache.lucene.util;
 import java.util.Arrays;
 import java.util.Comparator;
 
+import org.apache.lucene.future.FutureArrays;
+import org.apache.lucene.future.FutureObjects;
+
 /**
  * Represents char[], as a slice (offset + length) into an existing char[].
  * The {@link #chars} member should never be null; use
@@ -107,46 +110,15 @@ public final class CharsRef implements Comparable<CharsRef>, CharSequence, Clone
   }
 
   public boolean charsEquals(CharsRef other) {
-    if (length == other.length) {
-      int otherUpto = other.offset;
-      final char[] otherChars = other.chars;
-      final int end = offset + length;
-      for (int upto = offset; upto < end; upto++, otherUpto++) {
-        if (chars[upto] != otherChars[otherUpto]) {
-          return false;
-        }
-      }
-      return true;
-    } else {
-      return false;
-    }
+    return FutureArrays.equals(this.chars, this.offset, this.offset + this.length, 
+                               other.chars, other.offset, other.offset + other.length);
   }
 
   /** Signed int order comparison */
   @Override
   public int compareTo(CharsRef other) {
-    if (this == other)
-      return 0;
-
-    final char[] aChars = this.chars;
-    int aUpto = this.offset;
-    final char[] bChars = other.chars;
-    int bUpto = other.offset;
-
-    final int aStop = aUpto + Math.min(this.length, other.length);
-
-    while (aUpto < aStop) {
-      int aInt = aChars[aUpto++];
-      int bInt = bChars[bUpto++];
-      if (aInt > bInt) {
-        return 1;
-      } else if (aInt < bInt) {
-        return -1;
-      }
-    }
-
-    // One is a prefix of the other, or, they are equal:
-    return this.length - other.length;
+    return FutureArrays.compare(this.chars, this.offset, this.offset + this.length, 
+                                other.chars, other.offset, other.offset + other.length);
   }
 
   @Override
@@ -162,18 +134,14 @@ public final class CharsRef implements Comparable<CharsRef>, CharSequence, Clone
   @Override
   public char charAt(int index) {
     // NOTE: must do a real check here to meet the specs of CharSequence
-    if (index < 0 || index >= length) {
-      throw new IndexOutOfBoundsException();
-    }
+    FutureObjects.checkIndex(index, length);
     return chars[offset + index];
   }
 
   @Override
   public CharSequence subSequence(int start, int end) {
     // NOTE: must do a real check here to meet the specs of CharSequence
-    if (start < 0 || end > length || start > end) {
-      throw new IndexOutOfBoundsException();
-    }
+    FutureObjects.checkFromToIndex(start, end, length);
     return new CharsRef(chars, offset + start, end - start);
   }
   
@@ -195,40 +163,33 @@ public final class CharsRef implements Comparable<CharsRef>, CharSequence, Clone
 
     @Override
     public int compare(CharsRef a, CharsRef b) {
-      if (a == b)
-        return 0;
-
-      final char[] aChars = a.chars;
-      int aUpto = a.offset;
-      final char[] bChars = b.chars;
-      int bUpto = b.offset;
-
-      final int aStop = aUpto + Math.min(a.length, b.length);
-
-      while (aUpto < aStop) {
-        char aChar = aChars[aUpto++];
-        char bChar = bChars[bUpto++];
-        if (aChar != bChar) {
-          // http://icu-project.org/docs/papers/utf16_code_point_order.html
-          
-          /* aChar != bChar, fix up each one if they're both in or above the surrogate range, then compare them */
-          if (aChar >= 0xd800 && bChar >= 0xd800) {
-            if (aChar >= 0xe000) {
-              aChar -= 0x800;
-            } else {
-              aChar += 0x2000;
-            }
-            
-            if (bChar >= 0xe000) {
-              bChar -= 0x800;
-            } else {
-              bChar += 0x2000;
-            }
+      int aEnd = a.offset + a.length;
+      int bEnd = b.offset + b.length;
+      int i = FutureArrays.mismatch(a.chars, a.offset, aEnd, 
+                                    b.chars, b.offset, bEnd);
+
+      if (i >= 0 && i < Math.min(a.length, b.length)) {
+        // http://icu-project.org/docs/papers/utf16_code_point_order.html
+
+        char aChar = a.chars[a.offset + i];
+        char bChar = b.chars[b.offset + i];        
+        /* aChar != bChar, fix up each one if they're both in or above the surrogate range, then compare them */
+        if (aChar >= 0xd800 && bChar >= 0xd800) {
+          if (aChar >= 0xe000) {
+            aChar -= 0x800;
+          } else {
+            aChar += 0x2000;
           }
           
-          /* now aChar and bChar are in code point order */
-          return (int)aChar - (int)bChar; /* int must be 32 bits wide */
+          if (bChar >= 0xe000) {
+            bChar -= 0x800;
+          } else {
+            bChar += 0x2000;
+          }
         }
+
+        /* now aChar and bChar are in code point order */
+        return (int)aChar - (int)bChar; /* int must be 32 bits wide */
       }
 
       // One is a prefix of the other, or, they are equal:
diff --git a/lucene/core/src/java/org/apache/lucene/util/IntsRef.java b/lucene/core/src/java/org/apache/lucene/util/IntsRef.java
index 981210d..7e9f029 100644
--- a/lucene/core/src/java/org/apache/lucene/util/IntsRef.java
+++ b/lucene/core/src/java/org/apache/lucene/util/IntsRef.java
@@ -18,6 +18,8 @@ package org.apache.lucene.util;
 
 import java.util.Arrays;
 
+import org.apache.lucene.future.FutureArrays;
+
 
 /** Represents int[], as a slice (offset + length) into an
  *  existing int[].  The {@link #ints} member should never be null; use
@@ -93,45 +95,15 @@ public final class IntsRef implements Comparable<IntsRef>, Cloneable {
   }
 
   public boolean intsEquals(IntsRef other) {
-    if (length == other.length) {
-      int otherUpto = other.offset;
-      final int[] otherInts = other.ints;
-      final int end = offset + length;
-      for(int upto=offset;upto<end;upto++,otherUpto++) {
-        if (ints[upto] != otherInts[otherUpto]) {
-          return false;
-        }
-      }
-      return true;
-    } else {
-      return false;
-    }
+    return FutureArrays.equals(this.ints, this.offset, this.offset + this.length, 
+                               other.ints, other.offset, other.offset + other.length);
   }
 
   /** Signed int order comparison */
   @Override
   public int compareTo(IntsRef other) {
-    if (this == other) return 0;
-
-    final int[] aInts = this.ints;
-    int aUpto = this.offset;
-    final int[] bInts = other.ints;
-    int bUpto = other.offset;
-
-    final int aStop = aUpto + Math.min(this.length, other.length);
-
-    while(aUpto < aStop) {
-      int aInt = aInts[aUpto++];
-      int bInt = bInts[bUpto++];
-      if (aInt > bInt) {
-        return 1;
-      } else if (aInt < bInt) {
-        return -1;
-      }
-    }
-
-    // One is a prefix of the other, or, they are equal:
-    return this.length - other.length;
+    return FutureArrays.compare(this.ints, this.offset, this.offset + this.length, 
+                                other.ints, other.offset, other.offset + other.length);
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/util/LongsRef.java b/lucene/core/src/java/org/apache/lucene/util/LongsRef.java
index 61b85cf..c4f0b2a 100644
--- a/lucene/core/src/java/org/apache/lucene/util/LongsRef.java
+++ b/lucene/core/src/java/org/apache/lucene/util/LongsRef.java
@@ -18,6 +18,8 @@ package org.apache.lucene.util;
 
 import java.util.Arrays;
 
+import org.apache.lucene.future.FutureArrays;
+
 
 /** Represents long[], as a slice (offset + length) into an
  *  existing long[].  The {@link #longs} member should never be null; use
@@ -92,45 +94,15 @@ public final class LongsRef implements Comparable<LongsRef>, Cloneable {
   }
 
   public boolean longsEquals(LongsRef other) {
-    if (length == other.length) {
-      int otherUpto = other.offset;
-      final long[] otherInts = other.longs;
-      final long end = offset + length;
-      for(int upto=offset; upto<end; upto++,otherUpto++) {
-        if (longs[upto] != otherInts[otherUpto]) {
-          return false;
-        }
-      }
-      return true;
-    } else {
-      return false;
-    }
+    return FutureArrays.equals(this.longs, this.offset, this.offset + this.length, 
+                               other.longs, other.offset, other.offset + other.length);
   }
 
   /** Signed int order comparison */
   @Override
   public int compareTo(LongsRef other) {
-    if (this == other) return 0;
-
-    final long[] aInts = this.longs;
-    int aUpto = this.offset;
-    final long[] bInts = other.longs;
-    int bUpto = other.offset;
-
-    final long aStop = aUpto + Math.min(this.length, other.length);
-
-    while(aUpto < aStop) {
-      long aInt = aInts[aUpto++];
-      long bInt = bInts[bUpto++];
-      if (aInt > bInt) {
-        return 1;
-      } else if (aInt < bInt) {
-        return -1;
-      }
-    }
-
-    // One is a prefix of the other, or, they are equal:
-    return this.length - other.length;
+    return FutureArrays.compare(this.longs, this.offset, this.offset + this.length, 
+                                other.longs, other.offset, other.offset + other.length);
   }
 
   @Override
diff --git a/lucene/core/src/java/org/apache/lucene/util/StringHelper.java b/lucene/core/src/java/org/apache/lucene/util/StringHelper.java
index 6d958ba..9c523cc 100644
--- a/lucene/core/src/java/org/apache/lucene/util/StringHelper.java
+++ b/lucene/core/src/java/org/apache/lucene/util/StringHelper.java
@@ -24,6 +24,8 @@ import java.nio.file.Paths;
 import java.util.Arrays;
 import java.util.Properties;
 
+import org.apache.lucene.future.FutureArrays;
+
 /**
  * Methods for manipulating strings.
  *
@@ -34,21 +36,19 @@ public abstract class StringHelper {
   /**
    * Compares two {@link BytesRef}, element by element, and returns the
    * number of elements common to both arrays (from the start of each).
+   * This method assumes currentTerm comes after priorTerm.
    *
-   * @param left The first {@link BytesRef} to compare
-   * @param right The second {@link BytesRef} to compare
+   * @param priorTerm The first {@link BytesRef} to compare
+   * @param currentTerm The second {@link BytesRef} to compare
    * @return The number of common elements (from the start of each).
    */
-  public static int bytesDifference(BytesRef left, BytesRef right) {
-    int len = left.length < right.length ? left.length : right.length;
-    final byte[] bytesLeft = left.bytes;
-    final int offLeft = left.offset;
-    byte[] bytesRight = right.bytes;
-    final int offRight = right.offset;
-    for (int i = 0; i < len; i++)
-      if (bytesLeft[i+offLeft] != bytesRight[i+offRight])
-        return i;
-    return len;
+  public static int bytesDifference(BytesRef priorTerm, BytesRef currentTerm) {
+    int mismatch = FutureArrays.mismatch(priorTerm.bytes, priorTerm.offset, priorTerm.offset + priorTerm.length, 
+                                         currentTerm.bytes, currentTerm.offset, currentTerm.offset + currentTerm.length);
+    if (mismatch < 0) {
+      throw new IllegalArgumentException("terms out of order: priorTerm=" + priorTerm + ",currentTerm=" + currentTerm);
+    }
+    return mismatch;
   }
   
   /** 
@@ -57,15 +57,7 @@ public abstract class StringHelper {
    * This method assumes currentTerm comes after priorTerm.
    */
   public static int sortKeyLength(final BytesRef priorTerm, final BytesRef currentTerm) {
-    final int currentTermOffset = currentTerm.offset;
-    final int priorTermOffset = priorTerm.offset;
-    final int limit = Math.min(priorTerm.length, currentTerm.length);
-    for (int i = 0; i < limit; i++) {
-      if (priorTerm.bytes[priorTermOffset+i] != currentTerm.bytes[currentTermOffset+i]) {
-        return i+1;
-      }
-    }
-    return Math.min(1+priorTerm.length, currentTerm.length);
+    return bytesDifference(priorTerm, currentTerm) + 1;
   }
 
   private StringHelper() {
@@ -83,17 +75,12 @@ public abstract class StringHelper {
    *         Otherwise <code>false</code>.
    */
   public static boolean startsWith(byte[] ref, BytesRef prefix) {
+    // not long enough to start with the prefix
     if (ref.length < prefix.length) {
       return false;
     }
-
-    for(int i=0;i<prefix.length;i++) {
-      if (ref[i] != prefix.bytes[prefix.offset+i]) {
-        return false;
-      }
-    }
-
-    return true;
+    return FutureArrays.equals(ref, 0, prefix.length,
+                               prefix.bytes, prefix.offset, prefix.offset + prefix.length);
   }
 
   /**
@@ -108,7 +95,12 @@ public abstract class StringHelper {
    *         Otherwise <code>false</code>.
    */
   public static boolean startsWith(BytesRef ref, BytesRef prefix) {
-    return sliceEquals(ref, prefix, 0);
+    // not long enough to start with the prefix
+    if (ref.length < prefix.length) {
+      return false;
+    }
+    return FutureArrays.equals(ref.bytes, ref.offset, ref.offset + prefix.length, 
+                               prefix.bytes, prefix.offset, prefix.offset + prefix.length);
   }
 
   /**
@@ -123,24 +115,13 @@ public abstract class StringHelper {
    *         Otherwise <code>false</code>.
    */
   public static boolean endsWith(BytesRef ref, BytesRef suffix) {
-    return sliceEquals(ref, suffix, ref.length - suffix.length);
-  }
-
-  private static boolean sliceEquals(BytesRef sliceToTest, BytesRef other, int pos) {
-    if (pos < 0 || sliceToTest.length - pos < other.length) {
+    int startAt = ref.length - suffix.length;
+    // not long enough to start with the suffix
+    if (startAt < 0) {
       return false;
     }
-    int i = sliceToTest.offset + pos;
-    int j = other.offset;
-    final int k = other.offset + other.length;
-    
-    while (j < k) {
-      if (sliceToTest.bytes[i++] != other.bytes[j++]) {
-        return false;
-      }
-    }
-    
-    return true;
+    return FutureArrays.equals(ref.bytes, ref.offset + startAt, ref.offset + startAt + suffix.length,
+                               suffix.bytes, suffix.offset, suffix.offset + suffix.length);
   }
 
   /** Pass this as the seed to {@link #murmurhash3_x86_32}. */
@@ -375,16 +356,12 @@ public abstract class StringHelper {
 
   /** Compares a fixed length slice of two byte arrays interpreted as
    *  big-endian unsigned values.  Returns positive int if a &gt; b,
-   *  negative int if a &lt; b and 0 if a == b */
+   *  negative int if a &lt; b and 0 if a == b 
+   *  
+   * @deprecated Use FutureArrays.compareUnsigned instead.
+   */
+  @Deprecated
   public static int compare(int count, byte[] a, int aOffset, byte[] b, int bOffset) {
-    // TODO: dedup this w/ BytesRef.compareTo?
-    for(int i=0;i<count;i++) {
-      int cmp = (a[aOffset+i]&0xff) - (b[bOffset+i]&0xff);
-      if (cmp != 0) {
-        return cmp;
-      }
-    }
-
-    return 0;
+    return FutureArrays.compareUnsigned(a, aOffset, aOffset + count, b, bOffset, bOffset + count);
   }
 }
diff --git a/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java b/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java
index e4a5bd9..48c5727 100644
--- a/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java
+++ b/lucene/core/src/java/org/apache/lucene/util/automaton/Automaton.java
@@ -25,6 +25,7 @@ import java.util.BitSet;
 import java.util.HashSet;
 import java.util.Set;
 
+import org.apache.lucene.future.FutureObjects;
 import org.apache.lucene.util.Accountable;
 import org.apache.lucene.util.ArrayUtil;
 import org.apache.lucene.util.InPlaceMergeSorter;
@@ -114,14 +115,8 @@ public class Automaton implements Accountable {
 
   /** Set or clear this state as an accept state. */
   public void setAccept(int state, boolean accept) {
-    if (state >= getNumStates()) {
-      throw new IllegalArgumentException("state=" + state + " is out of bounds (numStates=" + getNumStates() + ")");
-    }
-    if (accept) {
-      isAccept.set(state);
-    } else {
-      isAccept.clear(state);
-    }
+    FutureObjects.checkIndex(state, getNumStates());
+    isAccept.set(state, accept);
   }
 
   /** Sugar to get all transitions for all states.  This is
@@ -161,12 +156,9 @@ public class Automaton implements Accountable {
   public void addTransition(int source, int dest, int min, int max) {
     assert nextTransition%3 == 0;
 
-    if (source >= nextState/2) {
-      throw new IllegalArgumentException("source=" + source + " is out of bounds (maxState is " + (nextState/2-1) + ")");
-    }
-    if (dest >= nextState/2) {
-      throw new IllegalArgumentException("dest=" + dest + " is out of bounds (max state is " + (nextState/2-1) + ")");
-    }
+    int bounds = nextState/2;
+    FutureObjects.checkIndex(source, bounds);
+    FutureObjects.checkIndex(dest, bounds);
 
     growTransitions();
     if (curState != source) {
@@ -842,10 +834,7 @@ public class Automaton implements Accountable {
 
     /** Set or clear this state as an accept state. */
     public void setAccept(int state, boolean accept) {
-      if (state >= getNumStates()) {
-        throw new IllegalArgumentException("state=" + state + " is out of bounds (numStates=" + getNumStates() + ")");
-      }
-      
+      FutureObjects.checkIndex(state, getNumStates());      
       this.isAccept.set(state, accept);
     }
 
diff --git a/lucene/core/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl.java b/lucene/core/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl.java
index 3082129..9bf3621 100644
--- a/lucene/core/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl.java
+++ b/lucene/core/src/test/org/apache/lucene/analysis/tokenattributes/TestCharTermAttributeImpl.java
@@ -46,10 +46,9 @@ public class TestCharTermAttributeImpl extends LuceneTestCase {
     CharTermAttributeImpl t = new CharTermAttributeImpl();
     char[] content = "hello".toCharArray();
     t.copyBuffer(content, 0, content.length);
-    IllegalArgumentException expected = expectThrows(IllegalArgumentException.class, () -> {
+    expectThrows(IndexOutOfBoundsException.class, () -> {
       t.setLength(-1);
     });
-    assertTrue(expected.getMessage().contains("must not be negative"));
   }
 
   public void testGrow() {
diff --git a/lucene/core/src/test/org/apache/lucene/future/TestFutureArrays.java b/lucene/core/src/test/org/apache/lucene/future/TestFutureArrays.java
new file mode 100644
index 0000000..90390f9
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/future/TestFutureArrays.java
@@ -0,0 +1,306 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.future;
+
+import java.nio.charset.StandardCharsets;
+
+import org.apache.lucene.util.LuceneTestCase;
+
+public class TestFutureArrays extends LuceneTestCase {
+  
+  public void testByteMismatch() {
+    assertEquals(1, FutureArrays.mismatch(bytes("ab"), 0, 2, bytes("ac"), 0, 2));
+    assertEquals(0, FutureArrays.mismatch(bytes("ab"), 0, 2, bytes("b"), 0, 1));
+    assertEquals(-1, FutureArrays.mismatch(bytes("ab"), 0, 2, bytes("ab"), 0, 2));
+    assertEquals(1, FutureArrays.mismatch(bytes("ab"), 0, 2, bytes("a"), 0, 1));
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.mismatch(bytes("ab"), 2, 1, bytes("a"), 0, 1);
+    });
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.mismatch(bytes("ab"), 2, 1, bytes("a"), 1, 0);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.mismatch(null, 0, 2, bytes("a"), 0, 1);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.mismatch(bytes("ab"), 0, 2, null, 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.mismatch(bytes("ab"), 0, 3, bytes("a"), 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.mismatch(bytes("ab"), 0, 2, bytes("a"), 0, 2);
+    });
+  }
+  
+  public void testCharMismatch() {
+    assertEquals(1, FutureArrays.mismatch(chars("ab"), 0, 2, chars("ac"), 0, 2));
+    assertEquals(0, FutureArrays.mismatch(chars("ab"), 0, 2, chars("b"), 0, 1));
+    assertEquals(-1, FutureArrays.mismatch(chars("ab"), 0, 2, chars("ab"), 0, 2));
+    assertEquals(1, FutureArrays.mismatch(chars("ab"), 0, 2, chars("a"), 0, 1));
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.mismatch(chars("ab"), 2, 1, chars("a"), 0, 1);
+    });
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.mismatch(chars("ab"), 2, 1, chars("a"), 1, 0);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.mismatch(null, 0, 2, chars("a"), 0, 1);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.mismatch(chars("ab"), 0, 2, null, 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.mismatch(chars("ab"), 0, 3, chars("a"), 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.mismatch(chars("ab"), 0, 2, chars("a"), 0, 2);
+    });
+  }
+  
+  public void testByteCompareUnsigned() {
+    assertEquals(1, Integer.signum(FutureArrays.compareUnsigned(bytes("ab"), 0, 2, bytes("a"), 0, 1)));
+    assertEquals(1, Integer.signum(FutureArrays.compareUnsigned(bytes("ab"), 0, 2, bytes("aa"), 0, 2)));
+    assertEquals(0, Integer.signum(FutureArrays.compareUnsigned(bytes("ab"), 0, 2, bytes("ab"), 0, 2)));
+    assertEquals(-1, Integer.signum(FutureArrays.compareUnsigned(bytes("a"), 0, 1, bytes("ab"), 0, 2)));
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.compareUnsigned(bytes("ab"), 2, 1, bytes("a"), 0, 1);
+    });
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.compareUnsigned(bytes("ab"), 2, 1, bytes("a"), 1, 0);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.compareUnsigned(null, 0, 2, bytes("a"), 0, 1);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.compareUnsigned(bytes("ab"), 0, 2, null, 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.compareUnsigned(bytes("ab"), 0, 3, bytes("a"), 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.compareUnsigned(bytes("ab"), 0, 2, bytes("a"), 0, 2);
+    });
+  }
+  
+  public void testCharCompare() {
+    assertEquals(1, Integer.signum(FutureArrays.compare(chars("ab"), 0, 2, chars("a"), 0, 1)));
+    assertEquals(1, Integer.signum(FutureArrays.compare(chars("ab"), 0, 2, chars("aa"), 0, 2)));
+    assertEquals(0, Integer.signum(FutureArrays.compare(chars("ab"), 0, 2, chars("ab"), 0, 2)));
+    assertEquals(-1, Integer.signum(FutureArrays.compare(chars("a"), 0, 1, chars("ab"), 0, 2)));
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.compare(chars("ab"), 2, 1, chars("a"), 0, 1);
+    });
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.compare(chars("ab"), 2, 1, chars("a"), 1, 0);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.compare(null, 0, 2, chars("a"), 0, 1);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.compare(chars("ab"), 0, 2, null, 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.compare(chars("ab"), 0, 3, chars("a"), 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.compare(chars("ab"), 0, 2, chars("a"), 0, 2);
+    });
+  }
+  
+  public void testIntCompare() {
+    assertEquals(1, Integer.signum(FutureArrays.compare(ints("ab"), 0, 2, ints("a"), 0, 1)));
+    assertEquals(1, Integer.signum(FutureArrays.compare(ints("ab"), 0, 2, ints("aa"), 0, 2)));
+    assertEquals(0, Integer.signum(FutureArrays.compare(ints("ab"), 0, 2, ints("ab"), 0, 2)));
+    assertEquals(-1, Integer.signum(FutureArrays.compare(ints("a"), 0, 1, ints("ab"), 0, 2)));
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.compare(ints("ab"), 2, 1, ints("a"), 0, 1);
+    });
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.compare(ints("ab"), 2, 1, ints("a"), 1, 0);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.compare(null, 0, 2, ints("a"), 0, 1);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.compare(ints("ab"), 0, 2, null, 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.compare(ints("ab"), 0, 3, ints("a"), 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.compare(ints("ab"), 0, 2, ints("a"), 0, 2);
+    });
+  }
+  
+  public void testLongCompare() {
+    assertEquals(1, Integer.signum(FutureArrays.compare(longs("ab"), 0, 2, longs("a"), 0, 1)));
+    assertEquals(1, Integer.signum(FutureArrays.compare(longs("ab"), 0, 2, longs("aa"), 0, 2)));
+    assertEquals(0, Integer.signum(FutureArrays.compare(longs("ab"), 0, 2, longs("ab"), 0, 2)));
+    assertEquals(-1, Integer.signum(FutureArrays.compare(longs("a"), 0, 1, longs("ab"), 0, 2)));
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.compare(longs("ab"), 2, 1, longs("a"), 0, 1);
+    });
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.compare(longs("ab"), 2, 1, longs("a"), 1, 0);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.compare(null, 0, 2, longs("a"), 0, 1);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.compare(longs("ab"), 0, 2, null, 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.compare(longs("ab"), 0, 3, longs("a"), 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.compare(longs("ab"), 0, 2, longs("a"), 0, 2);
+    });
+  }
+  
+  public void testByteEquals() {
+    assertFalse(FutureArrays.equals(bytes("ab"), 0, 2, bytes("a"), 0, 1));
+    assertFalse(FutureArrays.equals(bytes("ab"), 0, 2, bytes("aa"), 0, 2));
+    assertTrue(FutureArrays.equals(bytes("ab"), 0, 2, bytes("ab"), 0, 2));
+    assertFalse(FutureArrays.equals(bytes("a"), 0, 1, bytes("ab"), 0, 2));
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.equals(bytes("ab"), 2, 1, bytes("a"), 0, 1);
+    });
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.equals(bytes("ab"), 2, 1, bytes("a"), 1, 0);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.equals(null, 0, 2, bytes("a"), 0, 1);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.equals(bytes("ab"), 0, 2, null, 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.equals(bytes("ab"), 0, 3, bytes("a"), 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.equals(bytes("ab"), 0, 2, bytes("a"), 0, 2);
+    });
+  }
+  
+  public void testCharEquals() {
+    assertFalse(FutureArrays.equals(chars("ab"), 0, 2, chars("a"), 0, 1));
+    assertFalse(FutureArrays.equals(chars("ab"), 0, 2, chars("aa"), 0, 2));
+    assertTrue(FutureArrays.equals(chars("ab"), 0, 2, chars("ab"), 0, 2));
+    assertFalse(FutureArrays.equals(chars("a"), 0, 1, chars("ab"), 0, 2));
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.equals(chars("ab"), 2, 1, chars("a"), 0, 1);
+    });
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.equals(chars("ab"), 2, 1, chars("a"), 1, 0);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.equals(null, 0, 2, chars("a"), 0, 1);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.equals(chars("ab"), 0, 2, null, 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.equals(chars("ab"), 0, 3, chars("a"), 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.equals(chars("ab"), 0, 2, chars("a"), 0, 2);
+    });
+  }
+  
+  public void testIntEquals() {
+    assertFalse(FutureArrays.equals(ints("ab"), 0, 2, ints("a"), 0, 1));
+    assertFalse(FutureArrays.equals(ints("ab"), 0, 2, ints("aa"), 0, 2));
+    assertTrue(FutureArrays.equals(ints("ab"), 0, 2, ints("ab"), 0, 2));
+    assertFalse(FutureArrays.equals(ints("a"), 0, 1, ints("ab"), 0, 2));
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.equals(ints("ab"), 2, 1, ints("a"), 0, 1);
+    });
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.equals(ints("ab"), 2, 1, ints("a"), 1, 0);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.equals(null, 0, 2, ints("a"), 0, 1);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.equals(ints("ab"), 0, 2, null, 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.equals(ints("ab"), 0, 3, ints("a"), 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.equals(ints("ab"), 0, 2, ints("a"), 0, 2);
+    });
+  }
+  
+  public void testLongEquals() {
+    assertFalse(FutureArrays.equals(longs("ab"), 0, 2, longs("a"), 0, 1));
+    assertFalse(FutureArrays.equals(longs("ab"), 0, 2, longs("aa"), 0, 2));
+    assertTrue(FutureArrays.equals(longs("ab"), 0, 2, longs("ab"), 0, 2));
+    assertFalse(FutureArrays.equals(longs("a"), 0, 1, longs("ab"), 0, 2));
+
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.equals(longs("ab"), 2, 1, longs("a"), 0, 1);
+    });
+    expectThrows(IllegalArgumentException.class, () -> {
+      FutureArrays.equals(longs("ab"), 2, 1, longs("a"), 1, 0);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.equals(null, 0, 2, longs("a"), 0, 1);
+    });
+    expectThrows(NullPointerException.class, () -> {
+      FutureArrays.equals(longs("ab"), 0, 2, null, 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.equals(longs("ab"), 0, 3, longs("a"), 0, 1);
+    });
+    expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureArrays.equals(longs("ab"), 0, 2, longs("a"), 0, 2);
+    });
+  }
+  
+  private byte[] bytes(String s) {
+    return s.getBytes(StandardCharsets.UTF_8);
+  }
+  
+  private char[] chars(String s) {
+    return s.toCharArray();
+  }
+  
+  private int[] ints(String s) {
+    int ints[] = new int[s.length()];
+    for (int i = 0; i < s.length(); i++) {
+      ints[i] = s.charAt(i);
+    }
+    return ints;
+  }
+  
+  private long[] longs(String s) {
+    long longs[] = new long[s.length()];
+    for (int i = 0; i < s.length(); i++) {
+      longs[i] = s.charAt(i);
+    }
+    return longs;
+  }
+}
diff --git a/lucene/core/src/test/org/apache/lucene/future/TestFutureObjects.java b/lucene/core/src/test/org/apache/lucene/future/TestFutureObjects.java
new file mode 100644
index 0000000..d2a0d9c
--- /dev/null
+++ b/lucene/core/src/test/org/apache/lucene/future/TestFutureObjects.java
@@ -0,0 +1,104 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.lucene.future;
+
+import org.apache.lucene.util.LuceneTestCase;
+
+/** Test java 8-compatible implementations of java.util.Objects methods */
+public class TestFutureObjects extends LuceneTestCase {
+
+  public void testCheckIndex() {
+    assertEquals(0, FutureObjects.checkIndex(0, 1));
+    assertEquals(1, FutureObjects.checkIndex(1, 2));
+
+    Exception e = expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureObjects.checkIndex(-1, 0);
+    });
+    assertEquals("Index -1 out-of-bounds for length 0", e.getMessage());
+    
+    e = expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureObjects.checkIndex(0, 0);
+    });
+    assertEquals("Index 0 out-of-bounds for length 0", e.getMessage());
+    
+    e = expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureObjects.checkIndex(1, 0);
+    });
+    assertEquals("Index 1 out-of-bounds for length 0", e.getMessage());
+    
+    e = expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureObjects.checkIndex(0, -1);
+    });
+    assertEquals("Index 0 out-of-bounds for length -1", e.getMessage());
+  }
+  
+  public void testCheckFromToIndex() {
+    assertEquals(0, FutureObjects.checkFromToIndex(0, 0, 0));
+    assertEquals(1, FutureObjects.checkFromToIndex(1, 2, 2));
+    
+    Exception e = expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureObjects.checkFromToIndex(-1, 0, 0);
+    });
+    assertEquals("Range [-1, 0) out-of-bounds for length 0", e.getMessage());
+
+    e = expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureObjects.checkFromToIndex(1, 0, 2);
+    });
+    assertEquals("Range [1, 0) out-of-bounds for length 2", e.getMessage());
+    
+    e = expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureObjects.checkFromToIndex(1, 3, 2);
+    });
+    assertEquals("Range [1, 3) out-of-bounds for length 2", e.getMessage());
+    
+    e = expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureObjects.checkFromToIndex(0, 0, -1);
+    });
+    assertEquals("Range [0, 0) out-of-bounds for length -1", e.getMessage());
+  }
+  
+  public void testCheckFromIndexSize() {
+    assertEquals(0, FutureObjects.checkFromIndexSize(0, 0, 0));
+    assertEquals(1, FutureObjects.checkFromIndexSize(1, 2, 3));
+    
+    Exception e = expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureObjects.checkFromIndexSize(-1, 0, 1);
+    });
+    assertEquals("Range [-1, -1 + 0) out-of-bounds for length 1", e.getMessage());
+    
+    e = expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureObjects.checkFromIndexSize(0, -1, 1);
+    });
+    assertEquals("Range [0, 0 + -1) out-of-bounds for length 1", e.getMessage());
+    
+    e = expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureObjects.checkFromIndexSize(0, 2, 1);
+    });
+    assertEquals("Range [0, 0 + 2) out-of-bounds for length 1", e.getMessage());
+    
+    e = expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureObjects.checkFromIndexSize(1, Integer.MAX_VALUE, Integer.MAX_VALUE);
+    });
+    assertEquals("Range [1, 1 + 2147483647) out-of-bounds for length 2147483647", e.getMessage());
+    
+    e = expectThrows(IndexOutOfBoundsException.class, () -> {
+      FutureObjects.checkFromIndexSize(0, 0, -1);
+    });
+    assertEquals("Range [0, 0 + 0) out-of-bounds for length -1", e.getMessage());
+  }
+
+}
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestArrayUtil.java b/lucene/core/src/test/org/apache/lucene/util/TestArrayUtil.java
index 79f4cbd..0cda337 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestArrayUtil.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestArrayUtil.java
@@ -16,8 +16,6 @@
  */
 package org.apache.lucene.util;
 
-
-import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
@@ -107,20 +105,6 @@ public class TestArrayUtil extends LuceneTestCase {
     test = ArrayUtil.parseInt("foo 1923 bar".toCharArray(), 4, 4);
     assertTrue(test + " does not equal: " + 1923, test == 1923);
   }
-
-  public void testSliceEquals() {
-    String left = "this is equal";
-    String right = left;
-    byte[] leftChars = left.getBytes(StandardCharsets.UTF_8);
-    byte[] rightChars = right.getBytes(StandardCharsets.UTF_8);
-    assertTrue(left + " does not equal: " + right, ArrayUtil.equals(leftChars, 0, rightChars, 0, left.length()));
-    
-    assertFalse(left + " does not equal: " + right, ArrayUtil.equals(leftChars, 1, rightChars, 0, left.length()));
-    assertFalse(left + " does not equal: " + right, ArrayUtil.equals(leftChars, 1, rightChars, 2, left.length()));
-
-    assertFalse(left + " does not equal: " + right, ArrayUtil.equals(leftChars, 25, rightChars, 0, left.length()));
-    assertFalse(left + " does not equal: " + right, ArrayUtil.equals(leftChars, 12, rightChars, 0, left.length()));
-  }
   
   private Integer[] createRandomArray(int maxSize) {
     final Random rnd = random();
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestStringHelper.java b/lucene/core/src/test/org/apache/lucene/util/TestStringHelper.java
index 58c3030..97e1c2e 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestStringHelper.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestStringHelper.java
@@ -23,6 +23,15 @@ public class TestStringHelper extends LuceneTestCase {
     BytesRef left = new BytesRef("foobar");
     BytesRef right = new BytesRef("foozo");
     assertEquals(3, StringHelper.bytesDifference(left, right));
+    assertEquals(2, StringHelper.bytesDifference(new BytesRef("foo"), new BytesRef("for")));
+    assertEquals(2, StringHelper.bytesDifference(new BytesRef("foo1234"), new BytesRef("for1234")));
+    assertEquals(1, StringHelper.bytesDifference(new BytesRef("foo"), new BytesRef("fz")));
+    assertEquals(0, StringHelper.bytesDifference(new BytesRef("foo"), new BytesRef("g")));
+    assertEquals(3, StringHelper.bytesDifference(new BytesRef("foo"), new BytesRef("food")));
+    // we can detect terms are out of order if we see a duplicate
+    expectThrows(IllegalArgumentException.class, () -> {
+      StringHelper.bytesDifference(new BytesRef("ab"), new BytesRef("ab"));
+    });
   }
   
   public void testStartsWith() {
@@ -63,5 +72,9 @@ public class TestStringHelper extends LuceneTestCase {
     assertEquals(2, StringHelper.sortKeyLength(new BytesRef("foo"), new BytesRef("fz")));
     assertEquals(1, StringHelper.sortKeyLength(new BytesRef("foo"), new BytesRef("g")));
     assertEquals(4, StringHelper.sortKeyLength(new BytesRef("foo"), new BytesRef("food")));
+    // we can detect terms are out of order if we see a duplicate
+    expectThrows(IllegalArgumentException.class, () -> {
+      StringHelper.sortKeyLength(new BytesRef("ab"), new BytesRef("ab"));
+    });
   }
 }
diff --git a/lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil.java b/lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil.java
index 15251ad..5fa9cc1 100644
--- a/lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil.java
+++ b/lucene/core/src/test/org/apache/lucene/util/TestUnicodeUtil.java
@@ -16,6 +16,7 @@
  */
 package org.apache.lucene.util;
 
+import org.apache.lucene.future.FutureArrays;
 
 /*
  * Some of this code came from the excellent Unicode
@@ -143,7 +144,7 @@ public class TestUnicodeUtil extends LuceneTestCase {
       final int utf32Len = UnicodeUtil.UTF8toUTF32(new BytesRef(utf8, 0, utf8Len), utf32);
       
       int[] codePoints = s.codePoints().toArray();
-      if (!ArrayUtil.equals(codePoints, 0, utf32, 0, codePoints.length)) {
+      if (!FutureArrays.equals(codePoints, 0, codePoints.length, utf32, 0, codePoints.length)) {
         System.out.println("FAILED");
         for(int j=0;j<s.length();j++) {
           System.out.println("  char[" + j + "]=" + Integer.toHexString(s.charAt(j)));
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyWriter.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyWriter.java
index 1561e2a..6061754 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyWriter.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/TaxonomyWriter.java
@@ -79,7 +79,7 @@ public interface TaxonomyWriter extends Closeable, TwoPhaseCommit {
    * If the given ordinal is the ROOT_ORDINAL, an INVALID_ORDINAL is returned.
    * If the given ordinal is a top-level category, the ROOT_ORDINAL is returned.
    * If an invalid ordinal is given (negative or beyond the last available
-   * ordinal), an ArrayIndexOutOfBoundsException is thrown. However, it is
+   * ordinal), an IndexOutOfBoundsException is thrown. However, it is
    * expected that getParent will only be called for ordinals which are
    * already known to be in the taxonomy.
    * TODO (Facet): instead of a getParent(ordinal) method, consider having a
diff --git a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java
index 632d74b..748e2a5 100644
--- a/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java
+++ b/lucene/facet/src/java/org/apache/lucene/facet/taxonomy/directory/DirectoryTaxonomyWriter.java
@@ -42,6 +42,7 @@ import org.apache.lucene.facet.taxonomy.TaxonomyWriter;
 import org.apache.lucene.facet.taxonomy.writercache.Cl2oTaxonomyWriterCache;
 import org.apache.lucene.facet.taxonomy.writercache.LruTaxonomyWriterCache;
 import org.apache.lucene.facet.taxonomy.writercache.TaxonomyWriterCache;
+import org.apache.lucene.future.FutureObjects;
 import org.apache.lucene.index.CorruptIndexException; // javadocs
 import org.apache.lucene.index.DirectoryReader;
 import org.apache.lucene.index.PostingsEnum;
@@ -764,9 +765,7 @@ public class DirectoryTaxonomyWriter implements TaxonomyWriter {
     // Note: the following if() just enforces that a user can never ask
     // for the parent of a nonexistant category - even if the parent array
     // was allocated bigger than it really needs to be.
-    if (ordinal >= nextID) {
-      throw new ArrayIndexOutOfBoundsException("requested ordinal is bigger than the largest ordinal in the taxonomy");
-    }
+    FutureObjects.checkIndex(ordinal, nextID);
     
     int[] parents = getTaxoArrays().parents();
     assert ordinal < parents.length : "requested ordinal (" + ordinal + "); parents.length (" + parents.length + ") !";
diff --git a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined.java b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined.java
index ecf1401..b2f33b2 100644
--- a/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined.java
+++ b/lucene/facet/src/test/org/apache/lucene/facet/taxonomy/TestTaxonomyCombined.java
@@ -490,13 +490,13 @@ public class TestTaxonomyCombined extends FacetTestCase {
     }
 
     // check parent of of invalid ordinals:
-    expectThrows(ArrayIndexOutOfBoundsException.class, () -> {
+    expectThrows(IndexOutOfBoundsException.class, () -> {
       tw.getParent(-1);
     });
-    expectThrows(ArrayIndexOutOfBoundsException.class, () -> {
+    expectThrows(IndexOutOfBoundsException.class, () -> {
       tw.getParent(TaxonomyReader.INVALID_ORDINAL);
     });
-    expectThrows(ArrayIndexOutOfBoundsException.class, () -> {
+    expectThrows(IndexOutOfBoundsException.class, () -> {
       tw.getParent(tr.getSize());
     });
   }
diff --git a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester.java b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester.java
index 9c6a624..cc11fe1 100644
--- a/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester.java
+++ b/lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggester.java
@@ -390,9 +390,11 @@ public class AnalyzingSuggester extends Lookup implements Accountable {
       } else {
         scratchA.offset = readerA.getPosition();
         scratchB.offset = readerB.getPosition();
-        scratchA.length = a.length - scratchA.offset;
-        scratchB.length = b.length - scratchB.offset;
+        scratchA.length = readerA.length() - readerA.getPosition();
+        scratchB.length = readerB.length() - readerB.getPosition();
       }
+      assert scratchA.isValid();
+      assert scratchB.isValid();
    
       return scratchA.compareTo(scratchB);
     }
diff --git a/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggesterTest.java b/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggesterTest.java
index 67ff056..7302d9e 100644
--- a/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggesterTest.java
+++ b/lucene/suggest/src/test/org/apache/lucene/search/suggest/analyzing/AnalyzingSuggesterTest.java
@@ -1111,6 +1111,66 @@ public class AnalyzingSuggesterTest extends LuceneTestCase {
     IOUtils.close(a, tempDir);
   }
 
+  /**
+   * Adds 50 random keys, that all analyze to the same thing (dog), with the same cost,
+   * and checks that they come back in surface-form order.
+   */
+  public void testTieBreakOnSurfaceForm() throws Exception {
+    Analyzer a = new Analyzer() {
+      @Override
+      protected TokenStreamComponents createComponents(String fieldName) {
+        Tokenizer tokenizer = new MockTokenizer(MockTokenizer.SIMPLE, true);
+
+        return new TokenStreamComponents(tokenizer) {
+          @Override
+          public TokenStream getTokenStream() {
+            return new CannedTokenStream(new Token[] {
+                token("dog", 1, 1)
+              });
+          }
+          @Override
+          protected void setReader(final Reader reader) {
+          }
+        };
+      }
+    };
+
+    Directory tempDir = getDirectory();
+    AnalyzingSuggester suggester = new AnalyzingSuggester(tempDir, "suggest", a, a, 0, 256, -1, true);
+
+    // make 50 inputs all with the same cost of 1, random strings
+    Input[] inputs = new Input[100];
+    for (int i = 0; i < inputs.length; i++) {
+      inputs[i] = new Input(TestUtil.randomSimpleString(random()), 1);
+    }
+
+    suggester.build(new InputArrayIterator(inputs));
+
+    // Try to save/load:
+    Path tmpDir = createTempDir("AnalyzingSuggesterTest");
+    Path path = tmpDir.resolve("suggester");
+
+    OutputStream os = Files.newOutputStream(path);
+    suggester.store(os);
+    os.close();
+
+    InputStream is = Files.newInputStream(path);
+    suggester.load(is);
+    is.close();
+
+    // now suggest everything, and check that stuff comes back in order
+    List<LookupResult> results = suggester.lookup("", false, 50);
+    assertEquals(50, results.size());
+    for (int i = 1; i < 50; i++) {
+      String previous = results.get(i-1).toString();
+      String current = results.get(i).toString();
+      assertTrue("surface forms out of order: previous=" + previous + ",current=" + current,
+                 current.compareTo(previous) >= 0);
+    }
+
+    IOUtils.close(a, tempDir);
+  }
+
   public void test0ByteKeys() throws Exception {
     final Analyzer a = new Analyzer() {
         @Override
