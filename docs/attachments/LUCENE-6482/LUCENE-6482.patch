Index: lucene/core/src/java/org/apache/lucene/codecs/Codec.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/Codec.java	(revision 1684003)
+++ lucene/core/src/java/org/apache/lucene/codecs/Codec.java	(working copy)
@@ -17,6 +17,7 @@
  * limitations under the License.
  */
 
+import java.util.Objects;
 import java.util.Set;
 import java.util.ServiceLoader; // javadocs
 
@@ -38,8 +39,26 @@
  */
 public abstract class Codec implements NamedSPILoader.NamedSPI {
 
-  private static final NamedSPILoader<Codec> loader =
-    new NamedSPILoader<>(Codec.class);
+  /**
+   * This static holder class prevents classloading deadlock by delaying
+   * init of default codecs and available codecs until needed.
+   */
+  private static final class Holder {
+    private static final NamedSPILoader<Codec> LOADER = new NamedSPILoader<>(Codec.class);
+    
+    private Holder() {}
+    
+    static NamedSPILoader<Codec> getLoader() {
+      if (LOADER == null) {
+        throw new IllegalStateException("You tried to lookup a Codec by name before all Codecs could be initialized. "+
+          "This likely happens if you call Codec#forName from a Codec's ctor.");
+      }
+      return LOADER;
+    }
+    
+    // TODO: should we use this, or maybe a system property is better?
+    static Codec defaultCodec = LOADER.lookup("Lucene50");
+  }
 
   private final String name;
 
@@ -91,20 +110,12 @@
   
   /** looks up a codec by name */
   public static Codec forName(String name) {
-    if (loader == null) {
-      throw new IllegalStateException("You called Codec.forName() before all Codecs could be initialized. "+
-          "This likely happens if you call it from a Codec's ctor.");
-    }
-    return loader.lookup(name);
+    return Holder.getLoader().lookup(name);
   }
   
   /** returns a list of all available codec names */
   public static Set<String> availableCodecs() {
-    if (loader == null) {
-      throw new IllegalStateException("You called Codec.availableCodecs() before all Codecs could be initialized. "+
-          "This likely happens if you call it from a Codec's ctor.");
-    }
-    return loader.availableServices();
+    return Holder.getLoader().availableServices();
   }
   
   /** 
@@ -119,24 +130,25 @@
    * of new codecs on the given classpath/classloader!</em>
    */
   public static void reloadCodecs(ClassLoader classloader) {
-    loader.reload(classloader);
+    Holder.getLoader().reload(classloader);
   }
-  
-  private static Codec defaultCodec = Codec.forName("Lucene50");
-  
+    
   /** expert: returns the default codec used for newly created
    *  {@link IndexWriterConfig}s.
    */
-  // TODO: should we use this, or maybe a system property is better?
   public static Codec getDefault() {
-    return defaultCodec;
+    if (Holder.defaultCodec == null) {
+      throw new IllegalStateException("You tried to lookup the default Codec before all Codecs could be initialized. "+
+        "This likely happens if you try to get it from a Codec's ctor.");
+    }
+    return Holder.defaultCodec;
   }
   
   /** expert: sets the default codec used for newly created
    *  {@link IndexWriterConfig}s.
    */
   public static void setDefault(Codec codec) {
-    defaultCodec = codec;
+    Holder.defaultCodec = Objects.requireNonNull(codec);
   }
 
   /**
Index: lucene/core/src/java/org/apache/lucene/codecs/DocValuesFormat.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/DocValuesFormat.java	(revision 1684003)
+++ lucene/core/src/java/org/apache/lucene/codecs/DocValuesFormat.java	(working copy)
@@ -40,8 +40,23 @@
  * @lucene.experimental */
 public abstract class DocValuesFormat implements NamedSPILoader.NamedSPI {
   
-  private static final NamedSPILoader<DocValuesFormat> loader =
-      new NamedSPILoader<>(DocValuesFormat.class);
+  /**
+   * This static holder class prevents classloading deadlock by delaying
+   * init of doc values formats until needed.
+   */
+  private static final class Holder {
+    private static final NamedSPILoader<DocValuesFormat> LOADER = new NamedSPILoader<>(DocValuesFormat.class);
+    
+    private Holder() {}
+    
+    static NamedSPILoader<DocValuesFormat> getLoader() {
+      if (LOADER == null) {
+        throw new IllegalStateException("You tried to lookup a DocValuesFormat by name before all formats could be initialized. "+
+          "This likely happens if you call DocValuesFormat#forName from a DocValuesFormat's ctor.");
+      }
+      return LOADER;
+    }
+  }
   
   /** Unique name that's used to retrieve this format when
    *  reading the index.
@@ -90,20 +105,12 @@
   
   /** looks up a format by name */
   public static DocValuesFormat forName(String name) {
-    if (loader == null) {
-      throw new IllegalStateException("You called DocValuesFormat.forName() before all formats could be initialized. "+
-          "This likely happens if you call it from a DocValuesFormat's ctor.");
-    }
-    return loader.lookup(name);
+    return Holder.getLoader().lookup(name);
   }
   
   /** returns a list of all available format names */
   public static Set<String> availableDocValuesFormats() {
-    if (loader == null) {
-      throw new IllegalStateException("You called DocValuesFormat.availableDocValuesFormats() before all formats could be initialized. "+
-          "This likely happens if you call it from a DocValuesFormat's ctor.");
-    }
-    return loader.availableServices();
+    return Holder.getLoader().availableServices();
   }
   
   /** 
@@ -118,6 +125,6 @@
    * of new docvalues formats on the given classpath/classloader!</em>
    */
   public static void reloadDocValuesFormats(ClassLoader classloader) {
-    loader.reload(classloader);
+    Holder.getLoader().reload(classloader);
   }
 }
Index: lucene/core/src/java/org/apache/lucene/codecs/PostingsFormat.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/codecs/PostingsFormat.java	(revision 1684003)
+++ lucene/core/src/java/org/apache/lucene/codecs/PostingsFormat.java	(working copy)
@@ -41,8 +41,23 @@
  * @lucene.experimental */
 public abstract class PostingsFormat implements NamedSPILoader.NamedSPI {
 
-  private static final NamedSPILoader<PostingsFormat> loader =
-    new NamedSPILoader<>(PostingsFormat.class);
+  /**
+   * This static holder class prevents classloading deadlock by delaying
+   * init of postings formats until needed.
+   */
+  private static final class Holder {
+    private static final NamedSPILoader<PostingsFormat> LOADER = new NamedSPILoader<>(PostingsFormat.class);
+    
+    private Holder() {}
+    
+    static NamedSPILoader<PostingsFormat> getLoader() {
+      if (LOADER == null) {
+        throw new IllegalStateException("You tried to lookup a PostingsFormat by name before all formats could be initialized. "+
+          "This likely happens if you call PostingsFormat#forName from a PostingsFormat's ctor.");
+      }
+      return LOADER;
+    }
+  }
 
   /** Zero-length {@code PostingsFormat} array. */
   public static final PostingsFormat[] EMPTY = new PostingsFormat[0];
@@ -94,20 +109,12 @@
   
   /** looks up a format by name */
   public static PostingsFormat forName(String name) {
-    if (loader == null) {
-      throw new IllegalStateException("You called PostingsFormat.forName() before all formats could be initialized. "+
-          "This likely happens if you call it from a PostingsFormat's ctor.");
-    }
-    return loader.lookup(name);
+    return Holder.getLoader().lookup(name);
   }
   
   /** returns a list of all available format names */
   public static Set<String> availablePostingsFormats() {
-    if (loader == null) {
-      throw new IllegalStateException("You called PostingsFormat.availablePostingsFormats() before all formats could be initialized. "+
-          "This likely happens if you call it from a PostingsFormat's ctor.");
-    }
-    return loader.availableServices();
+    return Holder.getLoader().availableServices();
   }
   
   /** 
@@ -122,6 +129,6 @@
    * of new postings formats on the given classpath/classloader!</em>
    */
   public static void reloadPostingsFormats(ClassLoader classloader) {
-    loader.reload(classloader);
+    Holder.getLoader().reload(classloader);
   }
 }
Index: lucene/core/src/java/org/apache/lucene/util/NamedSPILoader.java
===================================================================
--- lucene/core/src/java/org/apache/lucene/util/NamedSPILoader.java	(revision 1684003)
+++ lucene/core/src/java/org/apache/lucene/util/NamedSPILoader.java	(working copy)
@@ -58,7 +58,7 @@
    * <p><em>This method is expensive and should only be called for discovery
    * of new service providers on the given classpath/classloader!</em>
    */
-  public synchronized void reload(ClassLoader classloader) {
+  public void reload(ClassLoader classloader) {
     final LinkedHashMap<String,S> services = new LinkedHashMap<>(this.services);
     final SPIClassIterator<S> loader = SPIClassIterator.get(clazz, classloader);
     while (loader.hasNext()) {
Index: lucene/core/src/test/org/apache/lucene/codecs/TestCodecLoadingDeadlock.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/codecs/TestCodecLoadingDeadlock.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/codecs/TestCodecLoadingDeadlock.java	(working copy)
@@ -0,0 +1,127 @@
+package org.apache.lucene.codecs;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.Locale;
+import java.util.Random;
+import java.util.Set;
+import java.util.concurrent.CyclicBarrier;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.IntStream;
+
+import org.apache.lucene.util.LuceneTestCase;
+import org.apache.lucene.util.NamedThreadFactory;
+import org.junit.Assert;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+import com.carrotsearch.randomizedtesting.RandomizedContext;
+import com.carrotsearch.randomizedtesting.RandomizedRunner;
+
+/* WARNING: This test does *not* extend LuceneTestCase to prevent static class
+ * initialization when spawned as subprocess (and please let default codecs alive)! */
+
+@RunWith(RandomizedRunner.class)
+public class TestCodecLoadingDeadlock extends Assert {
+  
+  @Test
+  public void testDeadlock() throws Exception {
+    LuceneTestCase.assumeFalse("This test fails on UNIX with Turkish default locale (https://issues.apache.org/jira/browse/LUCENE-6036)",
+      new Locale("tr").getLanguage().equals(Locale.getDefault().getLanguage()));
+    
+    // pick random codec names for stress test in separate process:
+    final Random rnd = RandomizedContext.current().getRandom();
+    Set<String> avail;
+    final String codecName = new ArrayList<>(avail = Codec.availableCodecs())
+        .get(rnd.nextInt(avail.size()));
+    final String pfName = new ArrayList<>(avail = PostingsFormat.availablePostingsFormats())
+        .get(rnd.nextInt(avail.size()));
+    final String dvfName = new ArrayList<>(avail = DocValuesFormat.availableDocValuesFormats())
+        .get(rnd.nextInt(avail.size()));
+    
+    // spawn separate JVM:
+    final Process p = new ProcessBuilder(
+      Paths.get(System.getProperty("java.home"), "bin", "java").toString(),
+      "-cp",
+      System.getProperty("java.class.path"),
+      getClass().getName(),
+      codecName,
+      pfName,
+      dvfName
+    ).inheritIO().start();
+    if (p.waitFor(30, TimeUnit.SECONDS)) {
+      assertEquals("Process died abnormally", 0, p.waitFor());
+    } else {
+      p.destroyForcibly().waitFor();
+      fail("Process did not exit after 30 secs -> classloader deadlock?");
+    }
+  }
+  
+  // this method is called in a spawned process:
+  public static void main(final String... args) throws Exception {
+    final String codecName = args[0];
+    final String pfName = args[1];
+    final String dvfName = args[2];
+    final int numThreads = 14; // two times the modulo in switch statement below
+    final ExecutorService pool = Executors.newFixedThreadPool(numThreads, new NamedThreadFactory("deadlockchecker"));
+    final CyclicBarrier barrier = new CyclicBarrier(numThreads);
+    IntStream.range(0, numThreads).forEach(taskNo -> pool.execute(() -> {
+      try {
+        barrier.await();
+        switch (taskNo % 7) {
+          case 0:
+            Codec.getDefault();
+            break;
+          case 1:
+            Codec.forName(codecName);
+            break;
+          case 2:
+            PostingsFormat.forName(pfName);
+            break;
+          case 3:
+            DocValuesFormat.forName(dvfName);
+            break;
+          case 4:
+            Codec.availableCodecs();
+            break;
+          case 5:
+            PostingsFormat.availablePostingsFormats();
+            break;
+          case 6:
+            DocValuesFormat.availableDocValuesFormats();
+            break;
+          default:
+            throw new AssertionError();
+        }
+      } catch (Throwable t) {
+        synchronized(args) {
+          System.err.println(Thread.currentThread().getName() + " failed to lookup codec service:");
+          t.printStackTrace(System.err);
+        }
+        Runtime.getRuntime().halt(1); // signal failure to caller
+      }
+    }));
+    pool.shutdown();
+    while (!pool.awaitTermination(1, TimeUnit.MINUTES));
+  }
+
+}
Index: lucene/core/src/test/org/apache/lucene/codecs/TestCodecLoadingDeadlock.java
===================================================================
--- lucene/core/src/test/org/apache/lucene/codecs/TestCodecLoadingDeadlock.java	(revision 0)
+++ lucene/core/src/test/org/apache/lucene/codecs/TestCodecLoadingDeadlock.java	(working copy)

Property changes on: lucene/core/src/test/org/apache/lucene/codecs/TestCodecLoadingDeadlock.java
___________________________________________________________________
Added: svn:eol-style
## -0,0 +1 ##
+native
\ No newline at end of property
