Index: src/java/org/apache/lucene/analysis/ISOLatin1AccentFilter.java
===================================================================
--- src/java/org/apache/lucene/analysis/ISOLatin1AccentFilter.java	(revision 830934)
+++ src/java/org/apache/lucene/analysis/ISOLatin1AccentFilter.java	(working copy)
@@ -31,6 +31,7 @@
  * This class is included for use with existing
  * indexes and will be removed in a future release (possibly Lucene 4.0).
  */
+@Deprecated
 public final class ISOLatin1AccentFilter extends TokenFilter {
   public ISOLatin1AccentFilter(TokenStream input) {
     super(input);
@@ -48,7 +49,7 @@
       final int length = termAtt.termLength();
       // If no characters actually require rewriting then we
       // just return token as-is:
-      for(int i=0;i<length;i++) {
+      for(int i=0;i<length;++i) {
         final char c = buffer[i];
         if (c >= '\u00c0' && c <= '\uFB06') {
           removeAccents(buffer, length);
@@ -80,7 +81,7 @@
 
     int pos = 0;
 
-    for (int i=0; i<length; i++, pos++) {
+    for (int i=0; i<length; ++i, ++pos) {
       final char c = input[pos];
 
       // Quick test: if it's not in range then just keep
@@ -116,10 +117,6 @@
         case '\u00CF' : // �?
           output[outputPos++] = 'I';
           break;
-        case '\u0132' : // Ĳ
-            output[outputPos++] = 'I';
-            output[outputPos++] = 'J';
-            break;
         case '\u00D0' : // �?
           output[outputPos++] = 'D';
           break;
@@ -134,10 +131,6 @@
         case '\u00D8' : // Ø
           output[outputPos++] = 'O';
           break;
-        case '\u0152' : // Œ
-          output[outputPos++] = 'O';
-          output[outputPos++] = 'E';
-          break;
         case '\u00DE' : // Þ
           output[outputPos++] = 'T';
           output[outputPos++] = 'H';
@@ -152,6 +145,10 @@
         case '\u0178' : // Ÿ
           output[outputPos++] = 'Y';
           break;
+        case '\u00DF' : // ß
+          output[outputPos++] = 's';
+          output[outputPos++] = 's';
+          break;
         case '\u00E0' : // à
         case '\u00E1' : // á
         case '\u00E2' : // â
@@ -179,10 +176,6 @@
         case '\u00EF' : // ï
           output[outputPos++] = 'i';
           break;
-        case '\u0133' : // ĳ
-            output[outputPos++] = 'i';
-            output[outputPos++] = 'j';
-            break;
         case '\u00F0' : // ð
           output[outputPos++] = 'd';
           break;
@@ -197,14 +190,6 @@
         case '\u00F8' : // ø
           output[outputPos++] = 'o';
           break;
-        case '\u0153' : // œ
-          output[outputPos++] = 'o';
-          output[outputPos++] = 'e';
-          break;
-        case '\u00DF' : // ß
-          output[outputPos++] = 's';
-          output[outputPos++] = 's';
-          break;
         case '\u00FE' : // þ
           output[outputPos++] = 't';
           output[outputPos++] = 'h';
@@ -219,36 +204,60 @@
         case '\u00FF' : // ÿ
           output[outputPos++] = 'y';
           break;
-        case '\uFB00': // ﬀ
-            output[outputPos++] = 'f';
-            output[outputPos++] = 'f';
+        case '\u0132' : // Ĳ
+            output[outputPos++] = 'I';
+            output[outputPos++] = 'J';
             break;
-        case '\uFB01': // �?
-            output[outputPos++] = 'f';
+        case '\u0133' : // ĳ
             output[outputPos++] = 'i';
+            output[outputPos++] = 'j';
             break;
-        case '\uFB02': // ﬂ
-            output[outputPos++] = 'f';
-            output[outputPos++] = 'l';
+        case '\u0152' : // Œ
+            output[outputPos++] = 'O';
+            output[outputPos++] = 'E';
             break;
+        case '\u0153' : // œ
+          output[outputPos++] = 'o';
+          output[outputPos++] = 'e';
+          break;
+        case '\u2013' : // – en dash
+        case '\u2014' : // — em dash
+            output[outputPos++] = '-';
+            break;
+        case '\u2018' : // ‘ left single quotation mark
+        case '\u2019' : // ’ right single quotation mark
+            output[outputPos++] = '\'';
+            break;
+        case '\uFB00': // ﬀ
+          output[outputPos++] = 'f';
+          output[outputPos++] = 'f';
+          break;
+        case '\uFB01': // �?
+          output[outputPos++] = 'f';
+          output[outputPos++] = 'i';
+          break;
+        case '\uFB02': // ﬂ
+          output[outputPos++] = 'f';
+          output[outputPos++] = 'l';
+          break;
         // following 2 are commented as they can break the maxSizeNeeded (and doing *3 could be expensive)
 //        case '\uFB03': // ﬃ
-//            output[outputPos++] = 'f';
-//            output[outputPos++] = 'f';
-//            output[outputPos++] = 'i';
-//            break;
+//          output[outputPos++] = 'f';
+//          output[outputPos++] = 'f';
+//          output[outputPos++] = 'i';
+//          break;
 //        case '\uFB04': // ﬄ
-//            output[outputPos++] = 'f';
-//            output[outputPos++] = 'f';
-//            output[outputPos++] = 'l';
-//            break;
+//          output[outputPos++] = 'f';
+//          output[outputPos++] = 'f';
+//          output[outputPos++] = 'l';
+//          break;
         case '\uFB05': // ﬅ
-            output[outputPos++] = 'f';
-            output[outputPos++] = 't';
-            break;
+          output[outputPos++] = 'f';
+          output[outputPos++] = 't';
+          break;
         case '\uFB06': // ﬆ
-            output[outputPos++] = 's';
-            output[outputPos++] = 't';
+          output[outputPos++] = 's';
+          output[outputPos++] = 't';
           break;
         default :
           output[outputPos++] = c;
